{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\twhile (next_desc->bDescriptorType != USB_CONF_DESCRIPTOR) {\n\t\tif (next_desc->bDescriptorType == desc_id)\n\t\t\treturn next_desc;\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) next_desc + next_desc->bLength);\n\t\tif (next_desc->bDescriptorType == USB_ENDP_DESCRIPTOR)\n\t\t\treturn NULL;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 42.2780584259025}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bDescriptorType != USB_DESC_TYPE_ENDPOINT) {\n\t\tif (desc->bDescriptorType == desc_id)\n\t\t\treturn desc;\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t\t((uint8_t *) desc + desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 38.168083535716576}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *ptr = (uint8_t *) desc;\n\tuint8_t *end = (uint8_t *) UDC_DESCRIPTOR;\n\twhile (ptr < end) {\n\t\tif (*ptr == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) ptr;\n\t\t}\n\t\tptr += *(ptr);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 30.94784256521533}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (udc_device->curr_config == 0) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_device->curr_config->num_ifaces) {\n\t\treturn false;\n\t}\n\n\tuint8_t *ptr = udc_device->curr_config->desc;\n\tuint8_t *end = ptr + udc_device->curr_config->desc_size;\n\twhile (ptr < end) {\n\t\tif (ptr[1] == USB_DT_INTERFACE && ptr[2] == setting_num) {\n\t\t\treturn true;\n\t\t}\n\t\tptr += ptr[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 27.560486222108604}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *config_desc_ptr = (uint8_t *)udc_descriptor_head;\n\tuint8_t *iface_desc_ptr = (uint8_t *)udc_descriptor_head;\n\tuint8_t iface_desc_len;\n\tuint8_t iface_num_tmp;\n\tuint8_t setting_num_tmp;\n\tuint8_t iface_desc_type;\n\tuint8_t desc_len;\n\tuint8_t desc_type;\n\tbool found_iface_desc = false;\n\tbool found_iface_desc_end = false;\n\n\t/*\n\t * Check that a valid configuration descriptor exists.\n\t */\n\tif (config_desc_ptr == NULL) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Check that the interface number is within bounds.\n\t */\n\tif (iface_num >= udc_num_ifaces) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Check that the interface setting number is within bounds.\n\t */\n\tif (setting_num >= udc_iface_settings[iface_num]) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Check that the interface descriptor exists within the current configuration.\n\t */\n\twhile (!found_iface_desc_end) {\n\t\t/*\n\t\t * Get the length of the current descriptor.\n\t\t */\n\t\tdesc_len = *(iface_desc_ptr);\n\n\t\t/*\n\t\t * Get the type of the current descriptor.\n\t\t */\n\t\tdesc_type = *(iface_desc_ptr + 1);\n\n\t\t/*\n\t\t * Check if the current descriptor is an interface descriptor.\n\t\t */\n\t\tif (desc_type == USB_DT_INTERFACE) {\n\t\t\t/*\n\t\t\t * Get the length of the interface descriptor.\n\t\t\t */\n\t\t\tiface_desc_len = *(iface_desc_ptr);\n\n\t\t\t/*\n\t\t\t * Get the interface number of the interface descriptor.\n", "CodeBleu_score": 30.0621328664698}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *ptr;\n\tuint8_t iface_count = 0;\n\tuint8_t setting_count = 0;\n\tuint8_t ep_count = 0;\n\tbool found = false;\n\n\t// Check if there is a valid configuration\n\tif (!udc_config_desc) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is within bounds\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the descriptors, starting from the beginning of the configuration descriptor\n\tptr = (uint8_t *)udc_config_desc;\n\twhile (ptr[0] != 0) {\n\t\t// Check if the current descriptor is an interface descriptor\n\t\tif (ptr[1] == USB_DT_INTERFACE) {\n\t\t\t// Check if the current interface number matches the specified interface number\n\t\t\tif (ptr[2] == iface_num) {\n\t\t\t\t// Check if the current setting number matches the specified setting number\n\t\t\t\tif (ptr[3] == setting_num) {\n\t\t\t\t\t// Found the specified interface descriptor\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Increment the setting count\n\t\t\t\tsetting_count++;\n\t\t\t}\n\t\t\t// Increment the interface count\n\t\t\tiface_count++;\n\t\t}\n\t\t// Check if the current descriptor is an endpoint descriptor\n\t\telse if (ptr[1] == USB_DT_ENDPOINT) {\n\t\t\t// Increment the endpoint count\n\t\t\tep_count++;\n\t\t}\n\t\t// Increment the pointer to the next descriptor\n\t\tptr += ptr[0];\n\t}\n\n\t// Check if the specified interface descriptor was found\n\tif (found) {\n\t\t// Update the interface descriptor pointer\n\t\tudc_iface_desc = (struct usb_interface_descriptor *)ptr;\n\t\t// Update the endpoint descriptors pointer", "CodeBleu_score": 36.923826856223194}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (USB_EP_GET_STATUS_LEN != req.wLength) {\n\t\treturn false;\n\t}\n\tif (req.wValue) {\n\t\treturn false;\n\t}\n\tuint8_t ep_num = req.wIndex & 0x7F;\n\tif (ep_num == 0 || ep_num >= USB_NUM_ENDPOINTS) {\n\t\treturn false;\n\t}\n\tuint8_t ep_status = 0;\n\tif (usb_ep_is_halted(ep_num)) {\n\t\tep_status = 1;\n\t}\n\tuint8_t *payload = udc_control_payload;\n\tpayload[0] = ep_status;\n\tpayload[1] = 0;\n\tudc_control_send(USB_DIR_IN, payload, 2);\n\treturn true;\n}", "CodeBleu_score": 45.786638448008}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\n\tif (udd_g_ctrlreq.req.wLength != 2) {\n\t\treturn false;\n\t}\n\n\t// Fill status\n\tudd_g_ctrlreq.payload[0] = 0;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex & 0xFF)) {\n\t\tudd_g_ctrlreq.payload[0] = 1;\n\t}\n\tudd_g_ctrlreq.payload[1] = 0;\n\n\t// Send status\n\tudd_g_ctrlreq.payload_size = 2;\n\treturn true;\n}", "CodeBleu_score": 36.722271380900835}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = udc_request.wIndex;\n\tuint8_t ep_status;\n\n\tif (udc_request.wLength != 2) {\n\t\treturn false;\n\t}\n\n\tif (ep_num & 0x80) {\n\t\tep_num &= 0x7F;\n\t\tif (udc_ep_is_halted(ep_num)) {\n\t\t\tep_status = 1;\n\t\t} else {\n\t\t\tep_status = 0;\n\t\t}\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\tudc_response_write((uint8_t *) &ep_status, 2);\n\n\treturn true;\n}", "CodeBleu_score": 25.595723444088875}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\t\n\t// Check if the device is in a configured state\n\tif (udd_get_usb_address() == 0) {\n\t\t// Device is not configured yet\n\t\tudd_ep_control_stall();\n\t\treturn false;\n\t}\n\t\n\t// Check if the interface number is valid\n\tif (udd_g_ctrlreq.req.wIndex >= udc_nb_iface) {\n\t\t// Interface number is not valid\n\t\tudd_ep_control_stall();\n\t\treturn false;\n\t}\n\t\n\t// Update the interface descriptor to the default setting\n\tif (udd_g_ctrlreq.req.bRequest == USB_REQ_SET_INTERFACE) {\n\t\t// Update the interface descriptor to the default setting\n\t\tif (udc_iface_default_setting[udd_g_ctrlreq.req.wIndex] == 0) {\n\t\t\t// The default setting is 0\n\t\t\tudd_ep_control_stall();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// Update the interface descriptor to the default setting\n\t\tudd_g_ctrlreq.payload = (uint8_t *) &udc_descriptor_iface[udd_g_ctrlreq.req.wIndex];\n\t\tudd_g_ctrlreq.payload_size = sizeof(usb_iface_desc_t);\n\t\tudd_g_ctrlreq.callback = NULL;\n\t\tudd_g_ctrlreq.over_under_run = NULL;\n\t\tudd_g_ctrlreq.required_zlp = 0;\n\t\tudd_g_ctrlreq.payload_trans = 0;\n\t\tudd_ep_control_send_zlp_in();\n\t}\n\t\n\t// Update the interface descriptor to the current alternate setting\n\tif (udd_g_ctrlreq.req.bRequest == USB_REQ_SET_INTERFACE) {\n\t\t// Update the interface descriptor to the current alternate setting\n\t\tudd_g_ctrlreq.payload = (uint8_t *) &udc_", "CodeBleu_score": 42.57170733081317}, {"code": "static bool udc_req_iface(void){\n\t\tif (USB->USB_SR & USB_SR_CLKUSABLE) {\n\t\treturn false;\n\t}\n\tif (udd_g_ctrlreq.req.wIndex > udc_device.iface_num) {\n\t\treturn false;\n\t}\n\tuint8_t iface_num = udd_g_ctrlreq.req.wIndex;\n\tudc_device.iface[iface_num].ctrl_state = UDC_IFACE_DEFAULT;\n\tudc_device.iface[iface_num].ctrl_state = UDC_IFACE_CURRENT;\n\treturn udc_device.iface[iface_num].udi->setup();\n}", "CodeBleu_score": 47.75435958100213}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num = (g_req.req.wIndex >> 8);\n\tif (g_ctrl_req.b_state != UDC_CTRL_SETUP) {\n\t\treturn false;\n\t}\n\tif (iface_num >= udc_nb_iface) {\n\t\treturn false;\n\t}\n\tif (g_req.req.bRequest == REQ_SET_INTERFACE) {\n\t\tif (g_req.req.wValue == 0) {\n\t\t\t// Update interface descriptor to default setting\n\t\t\tudc_iface_default_handler(iface_num);\n\t\t}\n\t\t// Update interface descriptor to current alternate setting\n\t\tudc_iface_handler(iface_num);\n\t}\n\treturn udc_iface[iface_num]->setup(&g_req.req);\n}", "CodeBleu_score": 48.60478575333554}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\tuint8_t i;\n\t// Initialize internal values\n\tudi_msc_nb_lun = 0;\n\tudi_msc_b_msc_enable = false;\n\tudi_msc_b_cbw_valid = false;\n\tudi_msc_b_sense_valid = false;\n\tudi_msc_b_read_enable = false;\n\tudi_msc_b_write_enable = false;\n\tudi_msc_b_trans_req = false;\n\tudi_msc_b_error_code = 0;\n\tudi_msc_b_phase_error = false;\n\tudi_msc_b_unit_attention = false;\n\tudi_msc_b_state = UDI_MSC_IDLE;\n\tudi_msc_b_substate = 0;\n\tudi_msc_b_ack_req = false;\n\tudi_msc_b_abort_req = false;\n\tudi_msc_b_abort_trans = false;\n\tudi_msc_b_cbw_invalid_field = false;\n\tudi_msc_b_sense_key = 0;\n\tudi_msc_b_sense_code = 0;\n\tudi_msc_b_sense_qualifier = 0;\n\tudi_msc_b_lun = 0;\n\tudi_msc_b_tag = 0;\n\tudi_msc_b_data_trans_direction = 0;\n\tudi_msc_b_data_trans_remaining = 0;\n\tudi_msc_b_data_residue = 0;\n\tudi_msc_b_data_trans_blocks = 0;\n\tudi_msc_b_data_trans_length = 0;\n\tudi_msc_b_data_trans_lba = 0;\n\tudi_msc_b_data_trans_size = 0;\n\tudi_msc_b_data_trans_nb_block = 0;\n\tudi_msc_b_data_trans_nb", "CodeBleu_score": 18.348730322089928}, {"code": "bool udi_msc_enable(void){\n\t\t// Initialize internal values\n\tudi_msc_b_msc_enable = false;\n\tudi_msc_b_cbw_valid = false;\n\tudi_msc_b_sense_key = SBC_SENSE_KEY_NO_SENSE;\n\tudi_msc_b_sense_code = SBC_SENSE_CODE_NONE;\n\tudi_msc_b_sense_qualifier = SBC_SENSE_CODE_NONE;\n\tudi_msc_b_lun = 0;\n\tudi_msc_b_trans_req = 0;\n\tudi_msc_b_trans_dir = 0;\n\tudi_msc_b_trans_size = 0;\n\tudi_msc_b_state = UDI_MSC_IDLE;\n\n\t// Get number of LUNs\n\tudi_msc_b_lun_nb = udi_msc_lun_get_nb();\n\tif (udi_msc_b_lun_nb == 0) {\n\t\treturn false;\n\t}\n\n\t// Enable interface\n\tif (!udi_msc_lun_enable()) {\n\t\treturn false;\n\t}\n\n\t// Initialize all LUNs\n\tfor (udi_msc_b_lun = 0; udi_msc_b_lun < udi_msc_b_lun_nb; udi_msc_b_lun++) {\n\t\tudi_msc_lun_init();\n\t}\n\n\t// Wait CBW\n\tudi_msc_b_state = UDI_MSC_CBW;\n\treturn true;\n}", "CodeBleu_score": 47.55125966542375}, {"code": "bool udi_msc_enable(void){\n\t\tudi_msc_b_cbw_invalid_field = false;\n\tudi_msc_b_sense_key = UDI_MSC_SENSE_KEY_NO_SENSE;\n\tudi_msc_b_sense_code = UDI_MSC_SENSE_CODE_NONE;\n\tudi_msc_b_sense_lba = 0;\n\tudi_msc_b_sense_add_sense_code = 0;\n\tudi_msc_b_sense_add_sense_qual = 0;\n\tudi_msc_b_sense_add_sense_qual_valid = false;\n\tudi_msc_b_sense_add_sense_code_valid = false;\n\tudi_msc_b_sense_add_sense_valid = false;\n\tudi_msc_b_sense_valid = false;\n\tudi_msc_b_state = UDI_MSC_IDLE;\n\tudi_msc_b_trans_req = false;\n\tudi_msc_b_trans_req_pending = false;\n\tudi_msc_b_trans_req_pending_more = false;\n\tudi_msc_b_trans_req_pending_more_wait = false;\n\tudi_msc_b_trans_req_pending_more_wait_0 = false;\n\tudi_msc_b_trans_req_pending_more_wait_1 = false;\n\tudi_msc_b_trans_req_pending_wait = false;\n\tudi_msc_b_trans_req_pending_wait_0 = false;\n\tudi_msc_b_trans_req_pending_wait_1 = false;\n\tudi_msc_b_unit_test_start = false;\n\tudi_msc_b_unit_test_lun = 0;\n\tudi_msc_b_unit_test_lun_test = 0;\n\tudi_msc_b_unit_test_lba = 0;\n\tudi_msc", "CodeBleu_score": 22.980327459645196}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\n    if (UDD_EP_TRANSFER_OK != status) {\n        /* Wait a reset */\n        udi_msc_reset();\n        return;\n    }\n    /* Update Sense Data */\n    udi_msc_sense_data.sense_key = SBC_SENSE_KEY_NO_SENSE;\n    udi_msc_sense_data.add_sense_code = SBC_ASC_NO_ADDITIONAL_SENSE_INFORMATION;\n    udi_msc_sense_data.add_sense_qualif = SBC_ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;\n    /* Update CSW */\n    udi_msc_csw.data_residue -= nb_sent;\n    udi_msc_process_csw();\n}", "CodeBleu_score": 59.50182277088136}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (UDD_EP_TRANSFER_OK != status) {\n    /* Transfer aborted then wait a reset */\n    udi_msc_reset_all();\n    return;\n  }\n  /* Decrease amount of data to transfer */\n  udi_msc_cbw.data_transfer_length -= nb_sent;\n  udi_msc_csw.data_residue -= nb_sent;\n  /* Process updated CSW */\n  udi_msc_process_csw();\n}", "CodeBleu_score": 62.52253989958224}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    // Check status of transfer\n    if (UDD_EP_TRANSFER_OK != status) {\n        // Transfer aborted then wait a reset\n        udi_msc_reset_all();\n        return;\n    }\n    // Update sense data\n    udi_msc_cbw.sense_data[0] = 0x70;\n    udi_msc_cbw.sense_data[7] = 0x0A;\n    // Update residue in CSW\n    udi_msc_csw.data_residue -= nb_sent;\n    // Process updated CSW\n    udi_msc_csw_process();\n}", "CodeBleu_score": 68.02698405509122}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tif (udi_msc_cbw.dCBWDataTransferLength) {\n\t\tif (udi_msc_cbw.bmCBWFlags.dir) {\n\t\t\tudi_msc_stall_in();\n\t\t} else {\n\t\t\tudi_msc_stall_out();\n\t\t}\n\t}\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.bCSWStatus = udi_msc_sense.key;\n\tudi_msc_csw.bCSWStatus |= udi_msc_sense.asc << 8;\n\tudi_msc_csw.bCSWStatus |= udi_msc_sense.ascq << 16;\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 51.55799878295968}, {"code": "static void udi_msc_csw_process(void){\n\t\t// Check if there is a non-zero data residue\n\tif (udi_msc_cbw.dDataLength != 0) {\n\t\t// Stall the next request on the appropriate endpoint\n\t\tif (udi_msc_cbw.bmFlags.dir == USB_CBW_DIRECTION_IN) {\n\t\t\tudi_msc_stall_in();\n\t\t} else {\n\t\t\tudi_msc_stall_out();\n\t\t}\n\t}\n\t// Prepare the CSW\n\tudi_msc_csw.dCSWSignature = USB_MSC_CSW_SIGNATURE;\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.bCSWStatus = udi_msc_csw.bCSWStatus;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dDataLength;\n\tudi_msc_csw.bCSWStatus = udi_msc_csw.bCSWStatus;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dDataLength;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\t// Send the CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 50.77300049741525}, {"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_cbw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength - udi_msc_cbw.dCBWDataTransferLength_copy;\n\tudi_msc_cbw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCSWDataResidue);\n\tudi_msc_cbw.bCSWStatus = 0;\n\tudi_msc_cbw.bCSWStatus |= udi_msc_cbw.dCSWDataResidue ? CSW_STATUS_ERROR : CSW_STATUS_GOOD;\n\tudi_msc_cbw.bCSWStatus |= udi_msc_cbw.bCBWLUN << CSW_STATUS_LUN_BIT_POSITION;\n\tudi_msc_cbw.bCSWStatus |= udi_msc_cbw.bCBWCBLength < 16 ? CSW_STATUS_CMD_PASSED : CSW_STATUS_CMD_FAILED;\n\tudi_msc_cbw.bCSWStatus = cpu_to_le16(udi_msc_cbw.bCSWStatus);\n\tudi_msc_cbw.dCBWTag = cpu_to_le32(udi_msc_cbw.dCBWTag);\n\tudi_msc_cbw.dCBWSignature = cpu_to_le32(CSW_SIGNATURE);\n\tif (udi_msc_cbw.dCSWDataResidue) {\n\t\tudi_msc_cbw.bCSWStatus |= CSW_STATUS_ERROR;\n\t\tudi_msc_cbw.bCSWStatus |= udi_msc_cbw.bCBWRDataDir ? CSW_STATUS_DATA_UNDERRUN : CSW_STATUS_DATA_OVERRUN;\n\t\tif (udi_msc_cbw.bCBWRDataDir) {\n\t\t\tudi_msc_cbw.bCSWStatus |= CSW_STATUS_", "CodeBleu_score": 43.85172996418103}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (b_enable) {\n        /* If the DTR signal is enabled, cancel any scheduled reset */\n        cancelReset();\n    } else {\n        /* If the DTR signal is disabled, check if the DTR rate is 1200 */\n        if (USB_DTR_RATE_1200 == usb_cdc_get_dtr_rate(port)) {\n            /* If the DTR rate is 1200, schedule a delayed system reset */\n            initiateReset(RESET_DTR_1200);\n        }\n    }\n\n    /* Update the DTR status */\n    usb_cdc_set_dtr(port, b_enable);\n}", "CodeBleu_score": 38.97693249896792}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (port >= USB_CDC_NUM_PORTS) {\n        return;\n    }\n\n    if (b_enable) {\n        usb_cdc_dtr_reset_timer[port] = 0;\n    } else {\n        if (usb_cdc_dtr_reset_timer[port] == 0) {\n            usb_cdc_dtr_reset_timer[port] = 1;\n        }\n    }\n\n    usb_cdc_dtr_value[port] = b_enable;\n}", "CodeBleu_score": 37.12659025541851}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\n}", "CodeBleu_score": 10.474702755761884}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t    if (USB_Request.bmRequestType == 0xC0) {\n        if (USB_Request.bRequest == 0x05) {\n            USB_ControlRequest.Header.Device = (void *) &Device_Descriptor;\n            USB_ControlRequest.Header.DeviceSize = sizeof(USB_Descriptor_Device_t);\n            USB_ControlRequest.Header.Config = (void *) &Configuration_Descriptor;\n            USB_ControlRequest.Header.ConfigSize = sizeof(USB_Descriptor_Configuration_Header_t);\n            USB_ControlRequest.Header.String = (void *) &Language_String;\n            USB_ControlRequest.Header.StringSize = pgm_read_byte(&Language_String.Header.Size);\n\n            USB_ControlRequest.MS_CompatibleID = (void *) &MS_CompatibleID_Descriptor;\n            USB_ControlRequest.MS_CompatibleIDSize = sizeof(USB_Descriptor_MS_CompatibleID_t);\n            USB_ControlRequest.MS_ExtendedProperties = (void *) &MS_ExtendedProperties_Descriptor;\n            USB_ControlRequest.MS_ExtendedPropertiesSize = sizeof(USB_Descriptor_MS_ExtendedProperties_t);\n\n            USB_ControlRequest.Header.Size = USB_Request.wLength;\n\n            return true;\n        }\n        else if (USB_Request.bRequest == 0x04) {\n            USB_ControlRequest.Header.Device = (void *) &Device_Descriptor;\n            USB_ControlRequest.Header.DeviceSize = sizeof(USB_Descriptor_Device_t);\n            USB_ControlRequest.Header.Config = (void *) &Configuration_Descriptor;\n            USB_ControlRequest.Header.ConfigSize = sizeof(USB_Descriptor_Configuration_Header_t);\n            USB_ControlRequest.Header.String = (void *) &Language_String;\n            USB_ControlRequest.Header.StringSize = pgm_read_byte(&Language_String.Header.Size);\n\n            USB_ControlRequest.Header.Size = USB_Request.wLength;\n\n            return true;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 22.432857821594652}, {"code": "bool usb_task_other_requests(void){\n\t    /*\n     * The request index (wIndex) is checked against values used by Microsoft\n     * devices.\n     */\n    if (USB_bmRequestType == 0xC0) {\n        if (USB_wIndex == 0x04) {\n            /*\n             * The host has requested the Microsoft OS 1.0 descriptor.\n             *\n             * The response is the same as the device descriptor, with the\n             * following differences:\n             * - The descriptor type is 0x03 (STRING)\n             * - The length is 0x12 (18)\n             * - The string is \"MSFT100\"\n             */\n            USB_ControlRequest.wLength = sizeof(USB_Descriptor_Device_t);\n            USB_Descriptor_String_t* MSFT100_String = (USB_Descriptor_String_t*)&USB_Descriptor_MSFT100;\n            USB_ControlRequest.wLength = MSFT100_String->Header.Size;\n            USB_ControlRequest.Pointer = MSFT100_String;\n            return true;\n        }\n        else if (USB_wIndex == 0x05) {\n            /*\n             * The host has requested the Microsoft OS 2.0 descriptor.\n             *\n             * The response is the same as the device descriptor, with the\n             * following differences:\n             * - The descriptor type is 0x03 (STRING)\n             * - The length is 0x3C (60)\n             * - The string is \"MSFT200\"\n             */\n            USB_ControlRequest.wLength = sizeof(USB_Descriptor_Device_t);\n            USB_Descriptor_String_t* MSFT200_String = (USB_Descriptor_String_t*)&USB_Descriptor_MSFT200;\n            USB_ControlRequest.wLength = MSFT200_String->Header.Size;\n            USB_ControlRequest.Pointer = MSFT200_String;\n            return true;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 26.664324156095397}, {"code": "bool usb_task_other_requests(void){\n\t    /*\n     * If the request type is vendor-specific, the request is handled here.\n     */\n    if (USB_SetupRequest.bmRequestType == REQUEST_VENDOR) {\n        /*\n         * The following switch-case statement checks the bRequest value, and processes the request accordingly.\n         */\n        switch (USB_SetupRequest.bRequest) {\n            case 0x04:\n                /*\n                 * This case handles the request for the Microsoft-compatible ID descriptor.\n                 */\n                USB_Descriptor_Pointer = (void*)&MicrosoftCompatibleIDDescriptor;\n                USB_Descriptor_Size = sizeof(MicrosoftCompatibleIDDescriptor);\n                return true;\n            case 0x05:\n                /*\n                 * This case handles the request for the Microsoft-compatible extended properties descriptor.\n                 */\n                USB_Descriptor_Pointer = (void*)&MicrosoftExtendedPropertiesDescriptor;\n                USB_Descriptor_Size = sizeof(MicrosoftExtendedPropertiesDescriptor);\n                return true;\n        }\n    }\n    /*\n     * If the request is not processed in the switch-case statement, it is not handled by this function.\n     */\n    return false;\n}", "CodeBleu_score": 25.131571958389266}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\n\tif (nbyte == 0) return;\n\n\tuint8_t dummy = 0xFF;\n\twhile (nbyte--) {\n\t\tspiTransmit(dummy);\n\t\t*buf++ = spiReceive();\n\t}\n\t*buf = spiRec();\n}", "CodeBleu_score": 30.255505999519293}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0)\n        return;\n\n    spiRec(buf, nbyte - 1);\n\n    while (nbyte--)\n        *buf++ = spiRec(0);\n}", "CodeBleu_score": 29.219371370592466}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0)\n    return;\n  for (uint16_t i = 0; i < nbyte - 1; i++) {\n    spiSend(0xFF);\n    buf[i] = spiRec();\n  }\n  buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 54.94398027151468}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n    uint32_t *relocated_vectors = (uint32_t *)SCB->VTOR;\n    oldHandler = (pfnISR_Handler)relocated_vectors[irq + 16];\n    relocated_vectors[irq + 16] = (uint32_t)newHandler;\n    return oldHandler;\n}", "CodeBleu_score": 51.24367208351982}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler = NULL;\n    uint32_t *vectors = (uint32_t *)SCB->VTOR;\n    if (vectors != (uint32_t *)&__isr_vector) {\n        oldHandler = (pfnISR_Handler)vectors[irq + 16];\n        vectors[irq + 16] = (uint32_t)newHandler;\n    }\n    return oldHandler;\n}", "CodeBleu_score": 49.561859955088536}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\n\t// Disable global interrupts\n\t__disable_irq();\n\n\t// Retrieve the address of the relocated vector table\n\tuint32_t *vectors = (uint32_t *)SCB->VTOR;\n\n\t// Compute the index of the interrupt handler to be installed\n\tuint32_t index = (uint32_t)irq + 16;\n\n\t// Retrieve the original handler\n\tpfnISR_Handler oldHandler = (pfnISR_Handler)vectors[index];\n\n\t// Install the new handler\n\tvectors[index] = (uint32_t)newHandler;\n\n\t// Enable global interrupts\n\t__enable_irq();\n\n\t// Return the original handler\n\treturn oldHandler;\n}", "CodeBleu_score": 47.29819478448736}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  int c;\n  if (cdc_rx_buffer_head == cdc_rx_buffer_tail) {\n    c = -1;\n  }\n  else {\n    c = cdc_rx_buffer[cdc_rx_buffer_tail];\n  }\n  return c;\n}", "CodeBleu_score": 26.167469800707305}, {"code": "int MarlinSerialUSB::peek(){\n\t  int c;\n  if (cdc_rx_buffer_head == cdc_rx_buffer_tail) {\n    if (cdc_rx_buffer_overflow)\n      c = -1;\n    else\n      c = -2;\n  }\n  else {\n    c = cdc_rx_buffer[cdc_rx_buffer_tail];\n    if (c == -1)\n      c = 0x100;\n  }\n  return c;\n}", "CodeBleu_score": 35.66828923174381}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (cdc_rx_buffer_head == cdc_rx_buffer_tail) {\n    if (!usb_configuration)\n      return -1;\n    if (!usb_cdc_rx_available())\n      return -1;\n    cdc_rx_buffer_head = cdc_rx_buffer_tail = 0;\n    cdc_rx_length = usb_cdc_rx_byte();\n    if (cdc_rx_length == -1) {\n      cdc_rx_buffer_head = cdc_rx_buffer_tail;\n      return -1;\n    }\n  }\n  return cdc_rx_buffer[cdc_rx_buffer_tail];\n}", "CodeBleu_score": 37.903691084757554}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  int c;\n  if (pending_rx_byte >= 0) {\n    c = pending_rx_byte;\n    pending_rx_byte = -1;\n  }\n  else {\n    if (!usb_configuration) return -1;\n    if (!usb_cdc_rx_buffer_full) return -1;\n    c = usb_cdc_rx_buffer[usb_cdc_rx_buffer_tail];\n    usb_cdc_rx_buffer_tail = (usb_cdc_rx_buffer_tail + 1) % CDC_RX_BUFFER_SIZE;\n    usb_cdc_rx_buffer_full = false;\n  }\n  if (c == 0x0d) c = 0x0a;\n  return c;\n}", "CodeBleu_score": 41.141030448763665}, {"code": "int MarlinSerialUSB::read(){\n\t  int c;\n\n  // If we have a pending character from the USART, then return it without\n  // checking for a character from the USB.\n  if ((c = peek()) >= 0) return c;\n\n  // If the USB is not configured, or we are not yet done with the\n  // configuration, then we don't have a character to read\n  if (!usbConfiguration) return -1;\n\n  // Check if we have a character available\n  if (!(UEINTX & (1<<RXOUTI))) return -1;\n\n  // We have a character.  Get it from the buffer\n  c = UEDATX;\n\n  // Check if we have an emergency command to process\n  if (emergencyParser.update(static_cast<char>(c))) {\n    // We don't want the host to know about the emergency command, so\n    // don't echo the character\n    return -1;\n  }\n\n  // If we got here, then we successfully read a character from the USB\n  return c;\n}", "CodeBleu_score": 29.021680381282632}, {"code": "int MarlinSerialUSB::read(){\n\t  if (pending_rx_count) {\n    --pending_rx_count;\n    return pending_rx_buffer[pending_rx_head++];\n  }\n  if (!usb_configuration) return -1;\n  if (!cdc_rx_buffer_full) return -1;\n  uint8_t c;\n  cdc_rx_buffer_full = false;\n  c = cdc_rx_buffer[cdc_rx_buffer_tail];\n  cdc_rx_buffer_tail = (cdc_rx_buffer_tail + 1) % CDC_RX_BUFFER_SIZE;\n  if (emergency_parser.enabled) emergency_parser.update(c);\n  return c;\n}", "CodeBleu_score": 40.216586454167484}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (pending_rx_length) return pending_rx_length;\n  if (!usb_configuration) return 0;\n  if (!usb_cdc_line_rtsdtr) return 0;\n  return usb_serial_available();\n}", "CodeBleu_score": 38.09126056182416}, {"code": "int MarlinSerialUSB::available(){\n\t  if (pending_rx_length) return pending_rx_length;\n  return usb_serial_available();\n}", "CodeBleu_score": 36.950779310340465}, {"code": "int MarlinSerialUSB::available(){\n\t  if (pending_count) return pending_count;\n  if (cdc_rx_cur_buf == NULL) return 0;\n  return cdc_rx_cur_buf->len - cdc_rx_cur_buf->index;\n}", "CodeBleu_score": 33.81425103218455}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (size == 0) return false;\n\n  uint8_t c;\n\n  while (size--) {\n    eeprom_read_block(&c, (uint8_t *)pos, sizeof(c));\n    if (writing) *value++ = c;\n    crc16(c, crc);\n    pos++;\n  }\n\n  return false;\n}", "CodeBleu_score": 53.05769591203744}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (size == 0) return false;\n  for (size_t i = 0; i < size; i++) {\n    uint8_t b = 0xFF;\n    read_data(pos, &b);\n    if (writing) *value++ = b;\n    if (crc) *crc = _PACKET_util::_crc16_update(*crc, b);\n  }\n  return false;\n}", "CodeBleu_score": 44.45236560765981}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (pos < 0 || size < 0 || size > 0xFFFF) return false;\n  if (writing) {\n    if (!value) return false;\n    if (!crc) return false;\n  }\n  if (pos + size > _size) return false;\n  for (size_t i = 0; i < size; i++) {\n    uint8_t b = read_byte(pos + i);\n    if (writing) {\n      value[i] = b;\n      *crc = _crc16_update(*crc, b);\n    }\n  }\n  return false;\n}", "CodeBleu_score": 45.69178687239139}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin < 0 || pin >= NUM_DIGITAL_PINS) return;\n\tif (value == 0) {\n\t\tdigitalWrite(pin, LOW);\n\t\treturn;\n\t}\n\tif (value == 255) {\n\t\tdigitalWrite(pin, HIGH);\n\t\treturn;\n\t}\n\tif (freq == 0) freq = PWM_FREQUENCY;\n\tif (res == 0) res = 8;\n\tif (res > 16) res = 16;\n\tif (res < 1) res = 1;\n\tif (freq > 1000000) freq = 1000000;\n\tif (freq < 1) freq = 1;\n\tif (res == 16) {\n\t\tdigitalWrite(pin, HIGH);\n\t\treturn;\n\t}\n\tif (res == 8) {\n\t\tif (value > 255) value = 255;\n\t\tledcWrite(pin, value);\n\t\treturn;\n\t}\n\tif (res == 4) {\n\t\tif (value > 15) value = 15;\n\t\tledcWrite(pin, value);\n\t\treturn;\n\t}\n\tif (res == 2) {\n\t\tif (value > 3) value = 3;\n\t\tledcWrite(pin, value);\n\t\treturn;\n\t}\n\tif (res == 1) {\n\t\tif (value > 1) value = 1;\n\t\tledcWrite(pin, value);\n\t\treturn;\n\t}\n\tif (res == 0) {\n\t\tif (value > 0) value = 0;\n\t\tledcWrite(pin, value);\n\t\treturn;\n\t}\n\tuint8_t bits = (uint8_t)(res - 1);\n\tuint8_t mask = (uint8_t)((1 << bits) - 1);\n\tuint8_t pwmValue = (uint8_", "CodeBleu_score": 35.66602605918796}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin < 0 || pin >= NUM_DIGITAL_PINS) return;\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value == PWM_MAX) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (freq == 0) freq = PWM_FREQUENCY;\n  if (res == 0) res = 8;\n  if (res > 16) res = 16;\n  if (res > 8) {\n    uint16_t value16 = value;\n    uint8_t res8 = res;\n    while (res8 > 8) {\n      value16 >>= 1;\n      res8--;\n    }\n    analogWrite(pin, value16, freq, res8);\n    return;\n  }\n  if (res < 8) {\n    uint16_t value16 = value;\n    uint8_t res8 = res;\n    while (res8 < 8) {\n      value16 <<= 1;\n      res8++;\n    }\n    analogWrite(pin, value16, freq, res8);\n    return;\n  }\n  uint8_t slot = 0;\n  uint8_t channel = 0;\n  uint8_t timer = 0;\n  for (uint8_t i = 0; i < PWM_CHANNELS; i++) {\n    if (pwm_state[i].pin == pin) {\n      slot = i;\n      channel = pwm_state[i].channel;\n      timer = pwm_state[i].timer;\n      break;\n    }\n  }\n  if (slot == 0) {\n    for (uint8_t i = 0; i < PWM_CHANNELS; i++) {\n      if (pwm_state[i].pin == 0) {\n        slot = i;\n        channel = i;\n        timer = i;\n        break;\n      }\n   ", "CodeBleu_score": 49.04134252320599}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin == PIN_DAC1 || pin == PIN_DAC2) {\n    dacWrite(pin, value);\n    return;\n  }\n  if (pin == PIN_LED) {\n    ledcWrite(pin, value);\n    return;\n  }\n  if (pin == PIN_SERVO) {\n    servoWrite(pin, value);\n    return;\n  }\n  if (pin == PIN_PWM0 || pin == PIN_PWM1 || pin == PIN_PWM2 || pin == PIN_PWM3 || pin == PIN_PWM4 || pin == PIN_PWM5) {\n    pwmWrite(pin, value);\n    return;\n  }\n  if (pin == PIN_PWM6 || pin == PIN_PWM7) {\n    pwm67Write(pin, value);\n    return;\n  }\n\n  if (pin < 0 || pin >= NUM_DIGITAL_PINS) return;\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value == 255) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (freq == 0) freq = PWM_FREQUENCY;\n  if (res == 0) res = 8;\n  if (res > 16) res = 16;\n\n  uint8_t pwm_slot = 0;\n  for (uint8_t i = 0; i < NUM_PWM_SLOTS; i++) {\n    if (pwm_slots[i].pin == pin) {\n      pwm_slot = i;\n      break;\n    }\n  }\n  if (pwm_slot == 0) {\n    for (uint8_t i = 0; i < NUM_PWM_SLOTS; i++) {\n      if (pwm_slots[i].pin == 0) {\n        pwm_slot = i;\n        break;", "CodeBleu_score": 50.397430816691305}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t\n    static_assert(sizeof(servoDelay) == sizeof(int)*NUM_SERVOS, \"Servo delay array length must match the number of servos\");\n\n    if (attach()) {\n        write(value);\n        delay(servoDelay[servoChannel]);\n    }\n\n    #ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n        detach();\n    #endif\n}", "CodeBleu_score": 48.994889542166916}, {"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(SERVO_DELAY) / sizeof(SERVO_DELAY[0]) == NUM_SERVOS, \"SERVO_DELAY array length does not match NUM_SERVOS\");\n\n  if (attach()) {\n    write(value);\n    delay(SERVO_DELAY[servo_channel]);\n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n    detach();\n#endif\n  }\n}", "CodeBleu_score": 55.343069712543254}, {"code": "void Servo::move(const int value){\n\t    static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == NUMBER_OF_SERVOS, \"Servo delay array length does not match the number of servos\");\n    if (this->attach(SERVO_PINS[this->servo_channel])) {\n        this->write(value);\n        delay(servo_delay[this->servo_channel]);\n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n        this->detach();\n#endif\n    }\n}", "CodeBleu_score": 45.18987451476595}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t  // Loop through all pins\n  for (int i = 0; i < NUM_PINS; i++) {\n    // Check if pin is active\n    if (pwm[i] > 0) {\n      // Check if tick count is zero\n      if (pwm_tick[i] == 0) {\n        // Toggle pin state\n        if (pwm_state[i] == HIGH) {\n          pwm_state[i] = LOW;\n        } else {\n          pwm_state[i] = HIGH;\n        }\n        // Set tick count for next transition\n        pwm_tick[i] = pwm[i];\n      } else {\n        // Decrement tick count\n        pwm_tick[i]--;\n      }\n    }\n  }\n\n  // Write data to DMA buffer\n  for (int i = 0; i < NUM_PINS; i++) {\n    // Set data for pin\n    if (pwm_state[i] == HIGH) {\n      dma_buffer[i] = pwm_mask[i];\n    } else {\n      dma_buffer[i] = 0;\n    }\n  }\n  // Increment buffer position\n  dma_pos++;\n  // Check if buffer position is at the end of the buffer\n  if (dma_pos >= DMA_BUF_LEN) {\n    // Reset buffer position\n    dma_pos = 0;\n  }\n}", "CodeBleu_score": 35.97439094057834}, {"code": "void i2s_push_sample(){\n\t\n    uint32_t pwm_tick_count;\n    uint32_t pwm_pin_mask;\n    uint32_t pwm_port_data;\n    uint32_t pwm_pin_data;\n    uint32_t pwm_pin_data_masked;\n    uint32_t pwm_pin_data_shifted;\n    uint32_t pwm_pin_data_shifted_masked;\n    uint32_t pwm_pin_data_inverted;\n    uint32_t pwm_pin_data_inverted_masked;\n    uint32_t pwm_pin_data_inverted_shifted;\n    uint32_t pwm_pin_data_inverted_shifted_masked;\n    uint32_t pwm_pin_data_inverted_shifted_masked_inverted;\n\n    // For each pin, check if it has active PWM by evaluating its duty cycle.\n    for (uint8_t pin_index = 0; pin_index < I2S_PIN_COUNT; pin_index++) {\n\n        // If the PWM tick count reaches zero, toggle the pin state between high and low based on its current state and set the tick count for the next transition.\n        if (i2s_pins[pin_index].pwm_tick_count == 0) {\n            i2s_pins[pin_index].pwm_tick_count = i2s_pins[pin_index].pwm_tick_count_max;\n            i2s_pins[pin_index].pwm_state = !i2s_pins[pin_index].pwm_state;\n        }\n\n        // Decrement the PWM tick count.\n        i2s_pins[pin_index].pwm_tick_count--;\n\n        // If the pin has active PWM, update the port data.\n        if (i2s_pins[pin_index].pwm_duty_cycle > ", "CodeBleu_score": 30.87625231986486}, {"code": "void i2s_push_sample(){\n\t  uint32_t *buf = (uint32_t *)i2s_get_dma_buffer();\n  uint32_t *buf_end = buf + i2s_get_dma_buffer_size() / 4;\n  while (buf < buf_end) {\n    *buf++ = pin_states;\n  }\n}", "CodeBleu_score": 7.277263092411585}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  hal_timer_t timer_count;\n\n  switch (timer_num) {\n    case 0:\n      timer_count = TIMER_0_BASE->TC;\n      break;\n    case 1:\n      timer_count = TIMER_1_BASE->TC;\n      break;\n    case 2:\n      timer_count = TIMER_2_BASE->TC;\n      break;\n    default:\n      timer_count = 0;\n      break;\n  }\n\n  return timer_count;\n}", "CodeBleu_score": 32.7454796666303}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  hal_timer_t timer_value;\n  switch (timer_num) {\n    case 0:\n      timer_value = TIMER0->TCNT;\n      break;\n    case 1:\n      timer_value = TIMER1->TCNT;\n      break;\n    case 2:\n      timer_value = TIMER2->TCNT;\n      break;\n    case 3:\n      timer_value = TIMER3->TCNT;\n      break;\n    default:\n      timer_value = 0;\n      break;\n  }\n  return timer_value;\n}", "CodeBleu_score": 32.37503307103825}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t timer_count;\n\n    switch (timer_num) {\n        case 0:\n            timer_count = TIMER0->TC;\n            break;\n        case 1:\n            timer_count = TIMER1->TC;\n            break;\n        case 2:\n            timer_count = TIMER2->TC;\n            break;\n        case 3:\n            timer_count = TIMER3->TC;\n            break;\n        case 4:\n            timer_count = TIMER4->TC;\n            break;\n        case 5:\n            timer_count = TIMER5->TC;\n            break;\n        default:\n            timer_count = 0;\n            break;\n    }\n\n    return timer_count;\n}", "CodeBleu_score": 29.764639034835653}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint8_t c;\n  for (uint16_t i = 0; i < size; i++) {\n    c = eeprom_read_byte((uint8_t*)pos);\n    if (writing) *value++ = c;\n    crc16(c, crc);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 60.78332044292848}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    uint8_t c = eeprom_read_byte((unsigned char*)pos++);\n    if (writing) *value++ = c;\n    crc16(c, crc);\n  }\n  return false;\n}", "CodeBleu_score": 60.95663468269852}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\n  if (pos < 0 || size < 0 || pos + size > persistentStore.capacity())\n    return false;\n\n  for (size_t i = 0; i < size; i++) {\n    const uint8_t c = persistentStore.read_data(pos, crc);\n    if (writing) value[i] = c;\n  }\n\n  pos += size;\n  return false;\n}", "CodeBleu_score": 66.58176650382957}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (hsd == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tfor (int i = 0; i < SDIO_WRITE_RETRY_COUNT; i++) {\n\t\tif (HAL_SD_WriteBlocks(&hsd, src, block, 1, 1000) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t\tHAL_Delay(SDIO_WRITE_RETRY_DELAY_MS);\n\t}\n\n\tprintf(\"SDIO_WriteBlock: Failed to write block %lu\n\", block);\n\treturn false;\n}", "CodeBleu_score": 33.2827224611261}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (hsd == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tuint8_t retryCount = 0;\n\tbool success = false;\n\n\twhile (retryCount < SDIO_WRITE_RETRY_COUNT) {\n\t\tif (HAL_SD_WriteBlocks(hsd, (uint8_t*) src, block, 1, 5000) == HAL_OK) {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\t\tretryCount++;\n\t}\n\n\tif (success == false) {\n\t\tprintf(\"SDIO_WriteBlock: Failed to write block %lu\n\", block);\n\t}\n\n\treturn success;\n}", "CodeBleu_score": 38.40666185761387}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    if (!sdioHandle || !src) {\n        return false;\n    }\n\n    // Try to write the block\n    for (uint8_t i = 0; i < SDIO_WRITE_RETRY_COUNT; i++) {\n        if (HAL_SD_WriteBlocks(&sdioHandle, (uint8_t *)src, block, 1, SDIO_DATATIMEOUT) == SD_OK) {\n            return true;\n        }\n    }\n\n    // If we get here, all retries have failed\n    printf(\"ERROR: Failed to write block %lu\n\", block);\n    return false;\n}", "CodeBleu_score": 34.570299145711864}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n    #if HAS_TEMP_TIMER\n      case TEMP_TIMER_NUM:\n        HAL_timer_start_temp(frequency);\n        break;\n    #endif\n    #if HAS_STEP_TIMER\n      case STEP_TIMER_NUM:\n        HAL_timer_start_step(frequency);\n        break;\n    #endif\n    default:\n      TERN_(HAS_TEMP_TIMER, HAL_timer_start_temp(TEMP_TIMER_FREQUENCY));\n      TERN_(HAS_STEP_TIMER, HAL_timer_start_step(STEP_TIMER_FREQUENCY));\n  }\n}", "CodeBleu_score": 30.049927151975673}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n    case TEMP_TIMER_NUM:\n      HAL_timer_temp_start(frequency);\n      break;\n    case STEP_TIMER_NUM:\n      HAL_timer_step_start(frequency);\n      break;\n    default:\n      ASSERT(false);\n      break;\n  }\n}", "CodeBleu_score": 18.13291325112747}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n    case TIMER_TEMP:\n      HAL_timer_start_temp(frequency);\n      break;\n    case TIMER_STEP:\n      HAL_timer_start_step(frequency);\n      break;\n    default:\n      ASSERT(false);\n  }\n}", "CodeBleu_score": 17.13004764367251}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\n  // open the file for reading and writing\n  file = fopen(filename, \"r+b\");\n  if (file == NULL) {\n    //Serial.println(\"Could not open persistent storage file\");\n    return false;\n  }\n\n  // get the file size:\n  fseek(file, 0, SEEK_END);\n  long filesize = ftell(file);\n  fseek(file, 0, SEEK_SET);\n\n  // initialize the buffer with the default erase value\n  memset(buffer, EEPROM_DEFAULT_ERASE_VALUE, EEPROM_SIZE);\n\n  // read the file into the buffer\n  if (filesize > 0) {\n    fread(buffer, filesize, 1, file);\n  }\n\n  // close the file:\n  fclose(file);\n\n  return true;\n}", "CodeBleu_score": 32.22655277578167}, {"code": "bool PersistentStore::access_start(){\n\t\tif (!access_file.open(filename, O_RDWR)) {\n\t\treturn false;\n\t}\n\n\tuint32_t file_size = access_file.size();\n\n\tif (file_size < EEPROM_SIZE) {\n\t\tmemset(&_buffer, EEPROM_ERASED_VALUE, EEPROM_SIZE);\n\n\t} else {\n\t\taccess_file.seek(0);\n\t\taccess_file.read(_buffer, EEPROM_SIZE);\n\t}\n\n\taccess_file.close();\n\treturn true;\n}", "CodeBleu_score": 23.339875711648435}, {"code": "bool PersistentStore::access_start(){\n\t  if (!_file.open(_filename, O_RDWR)) {\n    // file does not exist, or cannot be opened\n    return false;\n  }\n  _file.seek(0, SeekSet);\n  _file.read(_buffer, _buffer_size);\n  _file.close();\n  return true;\n}", "CodeBleu_score": 7.948477237849283}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\tb <<= 1;\n\t\tr <<= 1;\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) {\n\t\t\tr |= 0x01;\n\t\t}\n\t}\n\tHAL_Delay(1);\n\treturn r;\n}", "CodeBleu_score": 38.71942001391873}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\n\t// Declare variables\n\tuint8_t r = 0;\n\tuint8_t i;\n\n\t// Iterate through each bit\n\tfor (i = 0; i < 8; i++) {\n\n\t\t// Set clock pin low\n\t\tHAL_GPIO_STM32_WritePin(SPI_STM32_SCK_PORT, SPI_STM32_SCK_PIN, 0);\n\n\t\t// Write MSB to MOSI pin\n\t\tHAL_GPIO_STM32_WritePin(SPI_STM32_MOSI_PORT, SPI_STM32_MOSI_PIN, b & 0x80);\n\n\t\t// Toggle clock pin high\n\t\tHAL_GPIO_STM32_WritePin(SPI_STM32_SCK_PORT, SPI_STM32_SCK_PIN, 1);\n\n\t\t// Read bit from MISO pin\n\t\tr <<= 1;\n\t\tr |= HAL_GPIO_STM32_ReadPin(SPI_STM32_MISO_PORT, SPI_STM32_MISO_PIN);\n\n\t\t// Shift byte left\n\t\tb <<= 1;\n\t}\n\n\t// Introduce small delay\n\tHAL_Delay(1);\n\n\t// Return received byte\n\treturn r;\n}", "CodeBleu_score": 40.50826177454043}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    for (uint8_t i = 0; i < 8; i++) {\n        HAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n        r <<= 1;\n        r |= (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) ? 1 : 0;\n        b <<= 1;\n    }\n    HAL_Delay(1);\n    return r;\n}", "CodeBleu_score": 42.22973848037122}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 39.23701317529721}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 39.23701317529721}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 46.70610074575103}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c;\n\n  // If RX is not enabled, there's nothing to do\n  if (!(obj->rx_buff.head == obj->rx_buff.tail && obj->rx_buff.state != RX_IDLE)) {\n    // Read byte\n    c = obj->serial->DR;\n\n    // Calculate buffer index\n    unsigned char i = (unsigned char)(obj->rx_buff.head + 1) % SERIAL_RX_BUFFER_SIZE;\n\n    // If we should be storing the received character into the location\n    // just before the tail (meaning that the head would advance to the\n    // current location of the tail), we're about to overflow the buffer\n    // and so we don't write the character or advance the head.\n    if (i != obj->rx_buff.tail) {\n      // Attempt to put the character into the buffer\n      obj->rx_buff.buffer[obj->rx_buff.head] = c;\n      // Advance the head\n      obj->rx_buff.head = i;\n    }\n\n    // If the emergency parser is enabled and the character is not\n    // the emergency stop character, reset the emergency parser\n    if (obj->emergency_parser.enabled && c != obj->emergency_parser.char_stop) {\n      obj->emergency_parser.state = 0;\n    }\n\n    // If the emergency parser is enabled and the character is the\n    // emergency start character, reset the emergency parser\n    if (obj->emergency_parser.enabled && c == obj->emergency_parser.char_start) {\n      obj->emergency_parser.state = 1;\n    }\n\n    // If the emergency parser is enabled and the emergency parser\n    // state is 1 and the character is the emergency stop character,\n    // set the emergency parser state to 2\n    if (obj->emergency_parser.enabled && obj->emergency_parser.state == 1 && c == obj->emergency_parser.char_stop) {\n      obj->emergency_parser.state = 2;\n    }\n\n    // If the emergency parser is enabled and", "CodeBleu_score": 47.302338878109595}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\n  #if ENABLED(EMERGENCY_PARSER)\n    if (emergency_state.enabled) emergency_parser.update(emergency_state, obj->uart->DR);\n  #endif\n\n  // If RX interrupts are enabled, there must be a receive buffer defined.\n  // If no receive buffer is defined or the buffer is full, just ignore the\n  // character and clear the interrupt.\n  if (!rx_buffer.buffer || rx_buffer.head == rx_buffer.tail) {\n    obj->uart->ICR = USART_ICR_ORECF;\n    return;\n  }\n\n  // Read the received byte and store it in the receive buffer.\n  uint8_t c;\n  c = obj->uart->DR;\n\n  // Calculate buffer index.\n  unsigned char i = (unsigned char)(rx_buffer.head + 1) % SERIAL_RX_BUFFER_SIZE;\n\n  // If we should be storing the received character into the location\n  // just before the tail (meaning that the head would advance to the\n  // current location of the tail), we're about to overflow the buffer\n  // and so we don't write the character or advance the head.\n  if (i != rx_buffer.tail) {\n    rx_buffer.buffer[rx_buffer.head] = c;\n    rx_buffer.head = i;\n  }\n\n  // Send notification that a character was received.\n  rx_available();\n\n  // Clear the interrupt.\n  obj->uart->ICR = USART_ICR_ORECF;\n}", "CodeBleu_score": 52.75206971233381}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\n  // Get the received byte and store it in the RX buffer\n  uint8_t data = MarlinSerial::_rx_getc(obj);\n\n  // If the buffer is full, set the overflow flag and return\n  unsigned char tmphead = (rx.head + 1) % RX_BUFFER_SIZE;\n  if (tmphead == rx.tail) {\n    rx.overflow = true;\n    return;\n  }\n\n  // Write the data to the buffer and advance the head\n  rx.buffer[rx.head] = data;\n  rx.head = tmphead;\n\n  // If enabled, update the emergency parser with the received byte\n  if (emergencyParser.enabled) emergencyParser.update(data);\n}", "CodeBleu_score": 37.04675017258857}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        if (timer_step_is_init && !timer_step_has_interrupt) {\n            timer_step_has_interrupt = true;\n            attachInterrupt(digitalPinToInterrupt(STEP_TIMER_PIN), Step_Handler, RISING);\n        }\n    } else if (timer_num == MF_TIMER_TEMP) {\n        if (timer_temp_is_init && !timer_temp_has_interrupt) {\n            timer_temp_has_interrupt = true;\n            attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, RISING);\n        }\n    }\n}", "CodeBleu_score": 32.194696852020144}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif(timer_num == MF_TIMER_STEP) {\n\t\tif(HAL_timer_is_initialized(timer_num) && !HAL_timer_has_interrupt(timer_num)) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t}\n\t} else if(timer_num == MF_TIMER_TEMP) {\n\t\tif(HAL_timer_is_initialized(timer_num) && !HAL_timer_has_interrupt(timer_num)) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.59125077919477}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (!(timer_step_is_init) || (timer_step_has_interrupt)) {\n\t\t\treturn;\n\t\t}\n\t\ttimer_step_has_interrupt = true;\n\t\tattachInterrupt(digitalPinToInterrupt(MF_STEP_INT_PIN), Step_Handler, RISING);\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (!(timer_temp_is_init) || (timer_temp_has_interrupt)) {\n\t\t\treturn;\n\t\t}\n\t\ttimer_temp_has_interrupt = true;\n\t\tattachInterrupt(digitalPinToInterrupt(MF_TEMP_INT_PIN), Temp_Handler, RISING);\n\t}\n}", "CodeBleu_score": 28.96473768922426}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\n\tvar (\n\t\tsepHash = hash(sep)\n\t\tsHash   = hash(s[len(s)-len(sep):])\n\t)\n\n\tif sepHash == sHash && equals(s[len(s)-len(sep):], sep) {\n\t\treturn len(s) - len(sep)\n\t}\n\n\tfor i := len(s) - len(sep) - 1; i >= 0; i-- {\n\t\tsHash = (sHash*primeRK + uint32(s[i+len(sep)])) - (uint32(s[i]) * primeRK)\n\t\tif sHash == sepHash && equals(s[i:i+len(sep)], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}", "CodeBleu_score": 42.242206351238195}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp algorithm\n\t// https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm\n\t// https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/\n\t// https://www.youtube.com/watch?v=B4Vmm3yZPgc\n\t// https://www.youtube.com/watch?v=B4Vmm3yZPgc\n\n\t// Base value for the rolling hash function\n\tconst base = 256\n\n\t// Prime number to help avoid hash collisions\n\tconst prime = 16777619\n\n\t// Length of the substring to search for\n\tsepLen := len(sep)\n\n\t// Length of the main string\n\tsLen := len(s)\n\n\t// If the substring length is greater than the main string length, return -1\n\tif sepLen > sLen {\n\t\treturn -1\n\t}\n\n\t// If the substring length is 0, return 0\n\tif sepLen == 0 {\n\t\treturn 0\n\t}\n\n\t// Initialize the hash value of the substring to search for\n\tsepHash := 0\n\tfor i := 0; i < sepLen; i++ {\n\t\tsepHash = (sepHash*base + int(sep[i])) % prime\n\t}\n\n\t// Initialize the hash value of the main string\n\tsHash := 0\n\tfor i := 0; i < sepLen; i++ {\n\t\tsHash = (sHash*base + int(s[i])) % prime\n\t}\n\n\t// Find the last occurrence of the substring\n\tfor i := sLen - 1; i >= sepLen; i-- {\n\t\t// If the hashes match, check the substring\n\t\tif sHash == sepHash {\n\t\t\t// Check the substring\n\t\t\tmatch := true\n\t\t\tfor j := 0; j < sepLen; j++ {\n\t\t\t\tif s[i-j] != sep[j] {\n\t\t\t\t\tmatch = false\n\t\t\t\t\tbreak\n\t\t\t", "CodeBleu_score": 34.376328240822346}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\n\t// Rabin-Karp search\n\thashsep, pow := hashStr(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*primeRK + uint32(s[len(s)-n+i])\n\t}\n\tif h == hashsep && Equal(s[len(s)-n:], sep) {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; i-- {\n\t\th *= primeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && Equal(s[i:i+n], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 58.38710149864639}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable(irqUSB)\n\tif usbcdc.txc {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tusbcdc.waitTxc = false\n\tinterrupt.Enable(irqUSB)\n}", "CodeBleu_score": 47.58530459479149}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tintr := interrupt.Disable()\n\tif len(usbcdc.txBuffer) > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore(intr)\n}", "CodeBleu_score": 47.21835415103893}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable(irqUSB)\n\tif usbcdc.txc {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable(irqUSB)\n}", "CodeBleu_score": 55.989654812633304}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.clearInterruptFlag()\n\ti2c.setStartCondition()\n\ti2c.enable()\n\tfor !i2c.startConditionSent() {\n\t}\n\ti2c.writeAddress(address, write)\n}", "CodeBleu_score": 25.68631176755606}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.Set(avr.TWINT)\n\ti2c.control.Set(avr.TWSTA)\n\ti2c.control.Set(avr.TWEN)\n\tfor !i2c.control.HasBits(avr.TWINT) {\n\t}\n\ti2c.data.Set(address<<1 | func() uint8 {\n\t\tif write {\n\t\t\treturn 0\n\t\t}\n\t\treturn 1\n\t}())\n\ti2c.control.Set(avr.TWINT)\n\tfor !i2c.control.HasBits(avr.TWINT) {\n\t}\n}", "CodeBleu_score": 33.16232264444649}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.TWCR.Set(avr.TWINT)\n\ti2c.TWCR.Set(avr.TWSTA | avr.TWEN)\n\tfor !i2c.TWCR.HasBits(avr.TWINT) {\n\t}\n\ti2c.TWDR.Set(address << 1)\n\tif !write {\n\t\ti2c.TWDR.Set(i2c.TWDR.Get() | 1)\n\t}\n\ti2c.TWCR.Set(avr.TWINT | avr.TWEN)\n\tfor !i2c.TWCR.HasBits(avr.TWINT) {\n\t}\n}", "CodeBleu_score": 37.842401609621426}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := f.blockSize * start\n\tendAddress := startAddress + (f.blockSize * len)\n\n\t// Wait for any ongoing flash operations to complete\n\tfor nrf.NVMC.READY.Get() == 0 {\n\t}\n\n\t// Configure the flash for erasing\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Een)\n\n\t// Erase one block at a time\n\tfor i := startAddress; i < endAddress; i += f.blockSize {\n\t\t// Erase the block\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(i))\n\n\t\t// Wait for the flash to finish erasing\n\t\tfor nrf.NVMC.READY.Get() == 0 {\n\t\t}\n\t}\n\n\t// Set the flash back to read mode\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 44.38601689879464}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif len < 0 {\n\t\treturn ErrInvalidArgument\n\t}\n\tif start < 0 || start > (f.Size() / f.BlockSize()) {\n\t\treturn ErrInvalidArgument\n\t}\n\tif (start + len) > (f.Size() / f.BlockSize()) {\n\t\treturn ErrInvalidArgument\n\t}\n\n\tstartAddr := uint32(f.Base()) + uint32(start * f.BlockSize())\n\tendAddr := startAddr + uint32(len * f.BlockSize())\n\tnrf.NVMC.Configure(nrf.NVMC_CONFIG_WEN_Een)\n\tfor addr := startAddr; addr < endAddr; addr += nrf.FLASH_PAGE_SIZE {\n\t\tnrf.NVMC.ErasePage(addr)\n\t\tfor nrf.NVMC.Readiness() != 0 {\n\t\t}\n\t}\n\tnrf.NVMC.Configure(nrf.NVMC_CONFIG_WEN_Ren)\n\treturn nil\n}", "CodeBleu_score": 47.61646471889609}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := uint32(start * f.blockSize)\n\tendAddress := uint32((start + len) * f.blockSize)\n\t\n\t// Wait for any ongoing flash operations to complete\n\tnrf.NVMC.Events_READY.Get()\n\t\n\t// Configure the flash for erasing\n\tnrf.NVMC.Config.Set(nrf.NVMC_CONFIG_WEN_Een)\n\t\n\t// Erase the blocks\n\tfor address := startAddress; address < endAddress; address += f.blockSize {\n\t\tnrf.NVMC.Erasepage.Set(address)\n\t\t\n\t\t// Wait for the flash to finish erasing the block\n\t\tfor nrf.NVMC.Events_READY.Get() == 0 {\n\t\t}\n\t}\n\t\n\t// Set the flash back to read mode\n\tnrf.NVMC.Config.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\t\n\treturn nil\n}", "CodeBleu_score": 41.941792905943366}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off < 0 || off+int64(len(p)) > f.Size() {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\taddr := f.addr + uint32(off)\n\tif addr%f.blockSize != 0 {\n\t\taddr -= addr % f.blockSize\n\t}\n\tif len(p) < f.blockSize {\n\t\tp = append(p, bytes.Repeat([]byte{0xff}, f.blockSize-len(p))...)\n\t}\n\tn = len(p)\n\tfor len(p) > 0 {\n\t\tif err := f.write(addr, p[:f.blockSize]); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tp = p[f.blockSize:]\n\t\taddr += f.blockSize\n\t}\n\treturn n, nil\n}", "CodeBleu_score": 29.99563572091674}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off > int64(len(f.memory)) {\n\t\treturn 0, flashBlockDeviceError(\"invalid offset\")\n\t}\n\n\tstart := uintptr(unsafe.Pointer(&f.memory[off]))\n\tend := start + uintptr(len(p))\n\n\tif end > uintptr(unsafe.Pointer(&f.memory[len(f.memory)])) {\n\t\treturn 0, flashBlockDeviceError(\"write exceeds flash memory bounds\")\n\t}\n\n\t// Pad the byte slice to fit the write block size\n\tpaddedLength := len(p) + (f.writeBlockSize - (len(p) % f.writeBlockSize))\n\tpadded := make([]byte, paddedLength)\n\tcopy(padded, p)\n\n\t// Enable write mode on the flash memory controller\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN)\n\n\t// Write the data in blocks\n\tfor i := 0; i < paddedLength; i += f.writeBlockSize {\n\t\t// Wait for the flash memory to be ready\n\t\tfor nrf.NVMC.READY.Get() == 0 {\n\t\t}\n\n\t\t// Write the block\n\t\tflashBlock := (*[1024]byte)(unsafe.Pointer(start + uintptr(i)))\n\t\tcopy(flashBlock[:], padded[i:i+f.writeBlockSize])\n\t}\n\n\t// Wait for the flash memory to be ready\n\tfor nrf.NVMC.READY.Get() == 0 {\n\t}\n\n\t// Disable write mode on the flash memory controller\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Disabled)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 34.39243857658909}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tif off < 0 || off > int64(f.Size()) {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\n\tif off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\n\tstartAddr := f.Address() + uintptr(off)\n\n\t// Pad the data to write to the write block size\n\tpaddedLen := (len(p) + f.WriteBlockSize() - 1) & ^(f.WriteBlockSize() - 1)\n\tpaddedData := make([]byte, paddedLen)\n\tcopy(paddedData, p)\n\n\t// Enable write mode\n\tf.enableWriteMode()\n\n\t// Write the data\n\tfor i := 0; i < paddedLen; i += f.WriteBlockSize() {\n\t\t// Wait for the flash controller to be ready\n\t\tf.waitForFlashReady()\n\n\t\t// Write the data\n\t\tnrf.Flash.Write.DST = uint32(startAddr + uintptr(i))\n\t\tnrf.Flash.Write.SRC = uint32(uintptr(unsafe.Pointer(&paddedData[i])))\n\t\tnrf.Flash.Write.CNT = uint32(f.WriteBlockSize())\n\t\tnrf.Flash.Tasks.WRITE.Set(1)\n\t}\n\n\t// Disable write mode\n\tf.disableWriteMode()\n\n\treturn len(p), nil\n}", "CodeBleu_score": 38.7985665574903}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, _, err := syscall.Syscall(syscall.SYS_FCNTL, uintptr(fd), syscall.F_DUPFD_CLOEXEC, 0)\n\tif err != 0 {\n\t\treturn 0, \"Failed to duplicate file descriptor\", err\n\t}\n\t// Attempt to open the directory file descriptor.\n\tvar dir *syscall.Dir\n\tfor {\n\t\tdir, err = syscall.Fdopendir(int(dupFd))\n\t\tif err == nil || err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\tsyscall.Close(int(dupFd))\n\t\treturn 0, \"Failed to open directory file descriptor\", err\n\t}\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 56.24379143416398}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar err error\n\tvar dir uintptr\n\tvar errno syscall.Errno\n\tvar dirptr *syscall.Dirent\n\n\t// Duplicate the file descriptor.\n\tfd, err = darwinDupFd(fd)\n\tif err != nil {\n\t\treturn 0, \"unable to duplicate file descriptor\", err\n\t}\n\n\t// Attempt to open the directory.\n\tfor {\n\t\tdirptr, errno = syscall.Fdopendir(fd)\n\t\tif errno == 0 {\n\t\t\tdir = uintptr(unsafe.Pointer(dirptr))\n\t\t\tbreak\n\t\t} else if errno != syscall.EINTR {\n\t\t\terr = errno\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the duplicated file descriptor.\n\tif err != nil {\n\t\tdarwinCloseFd(fd)\n\t}\n\n\treturn dir, \"\", err\n}", "CodeBleu_score": 49.57379824342459}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the provided file descriptor.\n\tfdDup, err := syscall.Dup(int(fd))\n\tif nil != err {\n\t\treturn 0, \"syscall.Dup() failed\", err\n\t}\n\n\t// Repeatedly attempt to open the directory using \"syscall.Fdopendir\" until it either succeeds or encounters an error other than \"syscall.EINTR\".\n\tfor {\n\t\t// Attempt to open the directory.\n\t\tdirPtr, err := syscall.Fdopendir(fdDup)\n\t\tif nil == err {\n\t\t\treturn uintptr(unsafe.Pointer(dirPtr)), \"\", nil\n\t\t}\n\n\t\t// If the error is not \"syscall.EINTR\", close the duplicated file descriptor and return the error.\n\t\tif syscall.EINTR != err {\n\t\t\tsyscall.Close(fdDup)\n\t\t\treturn 0, \"syscall.Fdopendir() failed\", err\n\t\t}\n\n\t\t// If the error is \"syscall.EINTR\", wait for a signal to be delivered.\n\t\truntime.Gosched()\n\t}\n}", "CodeBleu_score": 46.14641477276224}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n  const esp_partition_t *partition = esp_ota_get_running_partition();\n\n  esp_image_header_t header;\n\n  esp_image_metadata_t data;\n\n  const esp_err_t result = esp_image_verify(ESP_IMAGE_VERIFY, partition, &data);\n\n  if (result != ESP_OK) {\n\n    return 0;\n\n  }\n\n  memcpy(&header, data.image_header, sizeof(header));\n\n  if (header.magic != ESP_IMAGE_HEADER_MAGIC) {\n\n    return 0;\n\n  }\n\n  if (response == sketchSize) {\n\n    return header.image_len;\n\n  }\n\n  return partition->size - header.image_len;\n\n}", "CodeBleu_score": 50.681801575623496}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n\tconst esp_partition_t* partition = esp_ota_get_running_partition();\n\n\tif(partition == NULL) {\n\n\t\treturn 0;\n\t}\n\n\tesp_image_metadata_t metadata;\n\n\tconst esp_err_t result = esp_image_verify(ESP_IMAGE_VERIFY, &metadata, partition);\n\n\tif(result != ESP_OK) {\n\n\t\treturn 0;\n\t}\n\n\tif(response == FREE_SKETCH_SPACE) {\n\n\t\treturn partition->size - metadata.image_len;\n\t}\n\n\treturn metadata.image_len;\n}", "CodeBleu_score": 48.74604000276126}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n  esp_partition_t *partition = esp_ota_get_running_partition();\n\n  esp_image_header_t header;\n\n  esp_partition_read(partition, 0, &header, sizeof(esp_image_header_t));\n\n  if (response == sketchSize_t::freeSpace) {\n\n    return partition->size - header.image.entry_addr;\n\n  }\n\n  return header.image.entry_addr;\n\n}", "CodeBleu_score": 34.111140935403405}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\t\n\tuint32_t i, j;\n\tuint8_t *disk_ptr;\n\t\n\t// Calculate the required disk sectors\n\tdisk_sectors = (firmware_size + (SECTOR_SIZE - 1)) / SECTOR_SIZE;\n\tif (disk_sectors == 0) {\n\t\tdisk_sectors = 1;\n\t}\n\t\n\t// Allocate memory for the RAM disk\n\tdisk_ptr = (uint8_t *)malloc(disk_sectors * SECTOR_SIZE);\n\tif (disk_ptr == NULL) {\n\t\t// Log error\n\t\treturn false;\n\t}\n\t\n\t// Set up the boot sector\n\t\n\t// Clear the RAM disk\n\tmemset(disk_ptr, 0, disk_sectors * SECTOR_SIZE);\n\t\n\t// Set the boot sector jump instruction\n\tdisk_ptr[0] = 0xEB;\n\tdisk_ptr[1] = 0x3C;\n\tdisk_ptr[2] = 0x90;\n\t\n\t// Set the OEM name\n\tmemcpy(&disk_ptr[3], \"MSDOS5.0\", 8);\n\t\n\t// Set the bytes per sector\n\tdisk_ptr[11] = (uint8_t)(SECTOR_SIZE);\n\tdisk_ptr[12] = (uint8_t)(SECTOR_SIZE >> 8);\n\t\n\t// Set the sectors per cluster\n\tdisk_ptr[13] = (uint8_t)(SECTORS_PER_CLUSTER);\n\t\n\t// Set the number of reserved sectors\n\tdisk_ptr[14] = (uint8_t)(RESERVED_SECTORS);\n\t\n\t// Set the number of FATs\n\tdisk_ptr[16] = (uint8_t)(NUM_FATS);\n\t\n\t// Set the number of directory entries\n\tdisk_ptr[17] = (uint8_t)(MAX_DIR_ENTRIES);\n\t\n\t// Set the total sectors\n\tdisk_ptr[19] = (uint8_t)(", "CodeBleu_score": 17.789933379415636}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint8_t *disk_ptr;\n\tuint32_t i;\n\tuint32_t sector_count;\n\tuint32_t fat_sector_count;\n\tuint32_t data_sector_count;\n\tuint32_t root_dir_sectors;\n\tuint32_t total_sectors;\n\tuint32_t reserved_sectors;\n\tuint32_t root_entries;\n\tuint32_t sectors_per_fat;\n\tuint32_t sectors_per_cluster;\n\tuint32_t fat_size;\n\tuint32_t root_dir_first_sector;\n\tuint32_t first_data_sector;\n\tuint32_t total_clusters;\n\tuint32_t data_sectors;\n\tuint32_t fat_offset;\n\tuint32_t fat_length;\n\tuint32_t root_dir_offset;\n\tuint32_t root_dir_length;\n\tuint32_t data_offset;\n\tuint32_t data_length;\n\tuint8_t *fat_ptr;\n\tuint8_t *root_dir_ptr;\n\tuint8_t *data_ptr;\n\tuint8_t *data_ptr_end;\n\tuint8_t *data_ptr_next;\n\tuint8_t *data_ptr_prev;\n\tuint8_t *data_ptr_next_end;\n\tuint8_t *data_ptr_prev_end;\n\tuint32_t fat_entry;\n\tuint32_t fat_entry_value;\n\tuint32_t fat_entry_value_next;\n\tuint32_t fat_entry_value_prev;\n\tuint32_t fat_entry_value_next_end;\n\tuint32_t fat_entry_value_prev_end;\n\tuint32_t fat_entry_value_end;\n\tuint32_t fat_entry_value_end_next;\n\tuint32_t fat_entry_value_end_", "CodeBleu_score": 8.012676914190708}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\t// Set up the RAM disk\n\tuint32_t disk_sectors = 0;\n\tuint8_t *disk_ptr = NULL;\n\tuint32_t boot_sector_offset = 0;\n\tuint32_t fat_offset = 0;\n\tuint32_t fat_size = 0;\n\tuint32_t root_dir_offset = 0;\n\tuint32_t root_dir_size = 0;\n\tuint32_t data_offset = 0;\n\tuint32_t data_size = 0;\n\tuint32_t file_offset = 0;\n\tuint32_t file_size = 0;\n\n\t// Calculate the required disk sectors\n\tdisk_sectors = msc_update_get_disk_sectors();\n\tif (disk_sectors == 0) {\n\t\treturn false;\n\t}\n\n\t// Allocate memory for the RAM disk\n\tdisk_ptr = (uint8_t *) malloc(disk_sectors * MSC_SECTOR_SIZE);\n\tif (disk_ptr == NULL) {\n\t\treturn false;\n\t}\n\n\t// Set up the boot sector\n\tboot_sector_offset = msc_update_get_boot_sector_offset();\n\tfat_offset = msc_update_get_fat_offset();\n\tfat_size = msc_update_get_fat_size();\n\troot_dir_offset = msc_update_get_root_dir_offset();\n\troot_dir_size = msc_update_get_root_dir_size();\n\tdata_offset = msc_update_get_data_offset();\n\tdata_size = msc_update_get_data_size();\n\tfile_offset = msc_update_get_file_offset();\n\tfile_size = msc_update_get_file_size();\n\tif (!msc_update_setup_boot_sector(disk_ptr, volume_label, serial_number, disk_sectors, fat_offset, fat_size, root_dir_offset, root_dir_size", "CodeBleu_score": 38.547117098426}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    if (offset % partition->sector_size != 0) {\n        ESP_LOGE(TAG, \"offset must be sector aligned\");\n        return ESP_FAIL;\n    }\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"data exceeds partition size\");\n        return ESP_FAIL;\n    }\n    if (offset != 0) {\n        err = esp_partition_erase_range(partition, offset, partition->sector_size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"failed to erase partition\");\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"failed to write partition\");\n        return err;\n    }\n    return err;\n}", "CodeBleu_score": 54.540848162336594}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    size_t sector_size = partition->sector_size;\n    size_t sector_mask = sector_size - 1;\n\n    if ((offset & sector_mask) == 0 && (size & sector_mask) == 0) {\n        err = esp_partition_erase_range(partition, offset, size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase partition\");\n            return err;\n        }\n    }\n\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write partition\");\n        return err;\n    }\n\n    return ESP_OK;\n}", "CodeBleu_score": 60.00453598545094}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tif (offset % FLASH_SECTOR_SIZE == 0) {\n\t\terr = esp_partition_erase_range(partition, offset, FLASH_SECTOR_SIZE);\n\t\tif (err != ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Failed to erase partition %s at offset 0x%x\", partition->label, offset);\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\treturn err;\n}", "CodeBleu_score": 59.62916599458289}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  size_t j = 0;\n  char c;\n  unsigned char k;\n  while (in[i] != '\\0' && j < maxlen) {\n    c = in[i];\n    if (c >= '0' && c <= '9')\n      k = c - '0';\n    else if (c >= 'a' && c <= 'f')\n      k = c - 'a' + 10;\n    else if (c >= 'A' && c <= 'F')\n      k = c - 'A' + 10;\n    else {\n      i++;\n      continue;\n    }\n    if (j % 2 == 0)\n      out[j / 2] = k << 4;\n    else\n      out[j / 2] |= k;\n    i++;\n    j++;\n  }\n  return j / 2;\n}", "CodeBleu_score": 45.77732007165462}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  size_t j = 0;\n  while (in[i] != '\\0' && j < maxlen) {\n    unsigned char c = in[i];\n    if (c >= '0' && c <= '9') {\n      c -= '0';\n    } else if (c >= 'a' && c <= 'f') {\n      c -= 'a' - 10;\n    } else if (c >= 'A' && c <= 'F') {\n      c -= 'A' - 10;\n    } else {\n      i++;\n      continue;\n    }\n    if (i % 2 == 0) {\n      out[j] = c << 4;\n    } else {\n      out[j] += c;\n      j++;\n    }\n    i++;\n  }\n  return j;\n}", "CodeBleu_score": 46.21944868475936}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t outlen = 0;\n\tunsigned char c;\n\tunsigned char ctmp;\n\tunsigned char c1;\n\tunsigned char c2;\n\n\twhile (outlen < maxlen && *in != '\\0') {\n\t\tc = *in++;\n\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tctmp = c - '0';\n\t\t} else if (c >= 'a' && c <= 'f') {\n\t\t\tctmp = c - 'a' + 10;\n\t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\tctmp = c - 'A' + 10;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tc1 = ctmp << 4;\n\t\tc = *in++;\n\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tctmp = c - '0';\n\t\t} else if (c >= 'a' && c <= 'f') {\n\t\t\tctmp = c - 'a' + 10;\n\t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\tctmp = c - 'A' + 10;\n\t\t} else {\n\t\t\tin--;\n\t\t\tc1 = c1 >> 4;\n\t\t\tout[outlen++] = c1;\n\t\t\tbreak;\n\t\t}\n\n\t\tc2 = c1 | ctmp;\n\t\tout[outlen++] = c2;\n\t}\n\n\treturn outlen;\n}", "CodeBleu_score": 37.69769039061919}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t    if (!tx_buffer) {\n        return 0;\n    }\n    if (tx_in_progress) {\n        return 0;\n    }\n    if (osSemaphoreWait(tx_mutex, 10) != osOK) {\n        return 0;\n    }\n    int ret = tx_buffer->free();\n    osSemaphoreRelease(tx_mutex);\n    return ret;\n}", "CodeBleu_score": 50.16738591014819}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif(!txRing) return 0;\n\tif(xSemaphoreTake(txSemaphore, 10) == pdTRUE) {\n\t\tint ret = txRing->getFreeSize();\n\t\txSemaphoreGive(txSemaphore);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 40.086170306952184}, {"code": "int HWCDC::availableForWrite(void){\n\t    if (!tx_buffer || !tx_buffer_mutex) return 0;\n    if (tx_buffer_mutex->take(TX_BUFFER_MUTEX_TIMEOUT)) {\n        int free = tx_buffer->free();\n        tx_buffer_mutex->give();\n        return free;\n    }\n    return 0;\n}", "CodeBleu_score": 43.124132874539}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n    if (function) {\n\n        _onReceiveCB = function;\n\n        _onlyOnRxTimeout = onlyOnTimeout;\n\n        _rxTimeout = 10;\n\n        _rxTimeoutEnabled = true;\n\n        _rxTimeoutThreshold = 1;\n\n        _rxTimeoutThresholdReached = false;\n\n        _rxTimeoutThresholdReachedCallback = NULL;\n\n        _rxTimeoutThresholdReachedCallbackData = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunction = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionData = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArg = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgData = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunction = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionData = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArg = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgData = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunction = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionData = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionArg = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionArgData = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionArgFunction = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionArgFunctionData = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionArgFunctionArg = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionArgFunctionArgData = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionArgFunctionArgFunction = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionArgFunctionArgFunctionData = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionArgFunctionArgFunctionArg = NULL;\n\n        _rxTimeoutThresholdReachedCallbackFunctionArgFunctionArgFunctionArgFunctionArgFunctionArgData = NULL;\n\n        _rxTimeout", "CodeBleu_score": 24.024077357740637}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n    xSemaphoreTake(_serialMutex, portMAX_DELAY);\n\n    _onReceiveCB = function;\n\n    if (_onReceiveCB) {\n\n        _rxTimeout = onlyOnTimeout ? 0 : _rxTimeout;\n\n        uart_set_rx_full_threshold(_uart_num, _rxBufSize - 1);\n\n        if (_rxTaskHandle == NULL) {\n\n            xTaskCreateUniversal(HardwareSerial::rxTask, \"HardwareSerial::rxTask\", 2048, (void *)this, 12, &_rxTaskHandle, _rxPin == 3 ? 1 : 0);\n\n        }\n\n    }\n\n    xSemaphoreGive(_serialMutex);\n\n}", "CodeBleu_score": 48.82181324363882}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n    if (function) {\n\n        _onReceiveCB = function;\n\n        _onlyOnTimeout = onlyOnTimeout;\n\n        _rxTimeout = 10000;\n\n        _rxTimeoutCount = 0;\n\n        _rxTimeoutThresh = 1;\n\n        _rxTimeoutThreshCount = 0;\n\n        _rxTimeoutThreshEnabled = false;\n\n        _rxTimeoutThreshFunction = NULL;\n\n        _rxTimeoutThreshFunctionCalled = false;\n\n        _rxTimeoutThreshFunctionArg = NULL;\n\n        _rxTimeoutThreshFunctionArgSize = 0;\n\n        _rxTimeoutThreshFunctionResult = NULL;\n\n        _rxTimeoutThreshFunctionResultSize = 0;\n\n        _rxTimeoutThreshFunctionResultIndex = 0;\n\n        _rxTimeoutThreshFunctionResultLength = 0;\n\n        _rxTimeoutThreshFunctionResultCopyIndex = 0;\n\n        _rxTimeoutThreshFunctionResultCopyLength = 0;\n\n        _rxTimeoutThreshFunctionResultCopy = NULL;\n\n        _rxTimeoutThreshFunctionResultCopySize = 0;\n\n        _rxTimeoutThreshFunctionResultCopyIndex = 0;\n\n        _rxTimeoutThreshFunctionResultCopyLength = 0;\n\n        _rxTimeoutThreshFunctionResultCopySize = 0;\n\n        _rxTimeoutThreshFunctionResultCopyIndex = 0;\n\n        _rxTimeoutThreshFunctionResultCopyLength = 0;\n\n        _rxTimeoutThreshFunctionResultCopySize = 0;\n\n        _rxTimeoutThreshFunctionResultCopyIndex = 0;\n\n        _rxTimeoutThreshFunctionResultCopyLength = 0;\n\n        _rxTimeoutThreshFunctionResultCopySize = 0;\n\n        _rxTimeoutThreshFunctionResultCopyIndex = 0;\n\n        _rxTimeoutThreshFunctionResultCopyLength = 0;\n\n        _rxTimeoutThreshFunctionResultCopySize = 0;\n\n        _rxTimeoutThreshFunctionResultCopyIndex = 0;\n\n        _rxTimeoutThreshFunctionResultCopyLength = 0;\n\n        _rxTimeoutThreshFunctionResultCopySize = 0;\n\n        _rxTimeoutTh", "CodeBleu_score": 34.69749395424518}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if (length < 1) {\n        return 0;\n    }\n\n    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) {\n            break;\n        }\n        *buffer++ = (char)c;\n        index++;\n    }\n    *buffer = 0;\n    return index;\n}", "CodeBleu_score": 95.11866687504892}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if(length < 1) {\n        return 0;\n    }\n    size_t index = 0;\n    while(index < length) {\n        int c = timedRead();\n        if(c < 0 || c == terminator) {\n            break;\n        }\n        *buffer++ = (char)c;\n        index++;\n    }\n    *buffer = '\\0';\n    return index;\n}", "CodeBleu_score": 87.34835262278104}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if (length < 1) {\n        return 0;\n    }\n\n    size_t index = 0;\n\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) {\n            break;\n        }\n        *buffer++ = (char) c;\n        index++;\n    }\n    *buffer = 0;\n    return index;\n}", "CodeBleu_score": 93.59484395861679}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tSerial.printf(\"Tone: Pin %d, Frequency %d, Duration %d", "CodeBleu_score": 3.7400903519395103}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\n\tSerial.printf(\"tone: pin = %d, frequency = %d, duration = %d", "CodeBleu_score": 3.7801406975961225}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\n  Serial.print(\"tone: pin=\");\n\n  Serial.print(pin);\n\n  Serial.print(\", frequency=\");\n\n  Serial.print(frequency);\n\n  Serial.print(\", duration=\");\n\n  Serial.print(duration);\n\n  Serial.println(\"\");\n\n\n\n  if (pin == 255) {\n\n    Serial.println(\"tone: pin is not available\");\n\n    return;\n\n  }\n\n\n\n  if (ledcRead(pin) != 0) {\n\n    Serial.println(\"tone: pin is in use\");\n\n    return;\n\n  }\n\n\n\n  ledcSetup(pin, 5000, 8);\n\n  ledcAttachPin(pin, pin);\n\n\n\n  xQueueSend(toneQueue, &pin, 0);\n\n  xQueueSend(toneQueue, &frequency, 0);\n\n  xQueueSend(toneQueue, &duration, 0);\n\n}", "CodeBleu_score": 39.796134990238826}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (enabled) {\n    if (!_webUSBEnabled) {\n      if (_usbVersion < 0x0210) _usbVersion = 0x0210;\n      _webUSBEnabled = true;\n      return true;\n    }\n  } else {\n    _webUSBEnabled = false;\n  }\n  return false;\n}", "CodeBleu_score": 47.25623871184455}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (enabled) {\n    if (!_usb_started) {\n      _webusb_enabled = true;\n      if (_usb_version < 0x0210) {\n        _usb_version = 0x0210;\n      }\n    }\n  } else {\n    _webusb_enabled = false;\n  }\n  return !_usb_started;\n}", "CodeBleu_score": 56.141417981313715}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (!_usb_started) {\n        _webUSB_enabled = enabled;\n        if (enabled) {\n            _usb_version = 0x0210;\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 42.821881057427156}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t    uint8_t buffer[64];\n    size_t len = 0;\n    while (true) {\n        uint32_t read = _usb.ep_read(_rx_ep, buffer, sizeof(buffer));\n        if (read == 0) {\n            break;\n        }\n        for (size_t i = 0; i < read; i++) {\n            if (!_rx_queue.push(buffer[i])) {\n                _rx_overflow_event.post(read - i);\n                _logger.error(\"rx overflow\");\n                break;\n            }\n        }\n        _rx_event.post(read);\n    }\n}", "CodeBleu_score": 24.99376179007791}, {"code": "void USBCDC::_onRX(){\n\t    uint8_t buffer[64];\n    uint32_t count = 0;\n    uint32_t dropped = 0;\n    uint32_t length = 0;\n\n    while (1) {\n        length = USBDevice.readEP(CDC_EP_OUT, buffer, sizeof(buffer));\n        if (length == 0) {\n            break;\n        }\n        count = 0;\n        while (length--) {\n            if (_rxQueue.full()) {\n                dropped++;\n            }\n            else {\n                _rxQueue.put(buffer[count++]);\n            }\n        }\n        if (dropped) {\n            _rxDropped += dropped;\n            _rxOverflow.post(dropped);\n            _logger.error(\"CDC dropped %d bytes\", dropped);\n        }\n        _rxReceived.post(count);\n    }\n}", "CodeBleu_score": 28.859512741881833}, {"code": "void USBCDC::_onRX(){\n\t    int len = 0;\n    int read = 0;\n    int count = 0;\n    uint8_t buffer[64];\n    while (true) {\n        len = _serial.readable();\n        if (len > 0) {\n            read = _serial.read(buffer, min(len, sizeof(buffer)));\n            for (int i = 0; i < read; i++) {\n                if (_rx.full()) {\n                    _rx.reset();\n                    _rx.putc(buffer[i]);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);\n                    _rx.putc(0);", "CodeBleu_score": 25.37193855402975}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\n\tif robot == \"\" {\n\t\thttp.Error(res, \"Please specify a robot name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif _, ok := a.Robots[robot]; !ok {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %s not found\", robot), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices := []robeaux.Device{}\n\tfor _, device := range a.Robots[robot].Devices {\n\t\tdevices = append(devices, robeaux.Device{\n\t\t\tName:     device.Name,\n\t\t\tCommands: device.Commands(),\n\t\t})\n\t}\n\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 46.60350055571205}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\":robot\")\n\trobot := a.Robot(name)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"robot %q not found\", name), http.StatusNotFound)\n\t\treturn\n\t}\n\tdevices := []robeaux.Device{}\n\tfor _, device := range robot.Devices() {\n\t\tdevices = append(devices, robeaux.NewDevice(device))\n\t}\n\ta.writeJSON(res, devices)\n}", "CodeBleu_score": 49.01191445824692}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tif robot == \"\" {\n\t\thttp.Error(res, \"Please specify a robot name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif !a.RobotExists(robot) {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot named %s\", robot), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices := a.RobotDevices(robot)\n\n\tjs, err := json.Marshal(devices)\n\tif err != nil {\n\t\thttp.Error(res, \"Error creating JSON response\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tres.Write(js)\n}", "CodeBleu_score": 36.16112541490235}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.Robot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %s not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections := []*robeaux.Connection{}\n\tfor _, device := range robot.Devices() {\n\t\tconnections = append(connections, robeaux.FromDevice(device))\n\t}\n\tfor _, command := range robot.Commands() {\n\t\tconnections = append(connections, robeaux.FromCommand(command))\n\t}\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 50.552871575037926}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tvar robotName string\n\tvar robot *gobot.Robot\n\n\trobotName = strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot = a.Robot(robotName)\n\n\tif robot != nil {\n\t\tjson, err := json.Marshal(robot.Connections())\n\t\tif err != nil {\n\t\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tres.Write(json)\n\t} else {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot named %s was found\", robotName), http.StatusNotFound)\n\t}\n}", "CodeBleu_score": 40.69045938744938}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\":name\")\n\tif robot := a.Robot(name); robot != nil {\n\t\tconnections := make([]map[string]interface{}, len(robot.Connections()))\n\t\tfor i, c := range robot.Connections() {\n\t\t\tconnections[i] = map[string]interface{}{\n\t\t\t\t\"Name\": c.Name(),\n\t\t\t\t\"Port\": c.Port(),\n\t\t\t}\n\t\t}\n\t\tjson.NewEncoder(res).Encode(connections)\n\t} else {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %q not found\", name), http.StatusNotFound)\n\t}\n}", "CodeBleu_score": 52.073331269792945}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommandName := req.URL.Query().Get(\"command\")\n\trobot, ok := a.Robot(robotName)\n\tif !ok {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %s not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Device %s not found\", deviceName), http.StatusNotFound)\n\t\treturn\n\t}\n\tcommand := device.Command(commandName)\n\tif command == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Command %s not found\", commandName), http.StatusNotFound)\n\t\treturn\n\t}\n\tcommand.Execute(req.URL.Query().Get(\"params\"))\n}", "CodeBleu_score": 48.9886606319985}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommandName := req.URL.Query().Get(\"command\")\n\tparams := req.URL.Query().Get(\"params\")\n\n\trobot := a.Robot(robotName)\n\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %v not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice := robot.Device(deviceName)\n\n\tif device == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Device %v not found\", deviceName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tvar paramsMap map[string]interface{}\n\tif params != \"\" {\n\t\tif err := json.Unmarshal([]byte(params), &paramsMap); err != nil {\n\t\t\thttp.Error(res, fmt.Sprintf(\"Error unmarshaling params: %v\", err), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif err := device.Call(commandName, paramsMap); err != nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Error executing command: %v\", err), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n}", "CodeBleu_score": 48.37794734437546}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\tif robotName == \"\" || deviceName == \"\" || command == \"\" {\n\t\thttp.Error(res, \"robot, device and command must be specified\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\trobot := a.Robot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"robot %q not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"device %q not found\", deviceName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch command {\n\tcase \"start\":\n\t\tdevice.Start()\n\tcase \"halt\":\n\t\tdevice.Halt()\n\tdefault:\n\t\thttp.Error(res, fmt.Sprintf(\"command %q not found\", command), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tres.Write([]byte(\"ok\"))\n}", "CodeBleu_score": 44.34093281314549}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.42715975393952}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.491049434473936}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tr.Header.Del(\"Authorization\")\n\t\tr.Header.Del(\"Cookie\")\n\t\tr.Header.Del(\"X-CSRFToken\")\n\t\tr.Header.Del(\"X-Requested-With\")\n\t\tr.Header.Del(\"Connection\")\n\t\tr.Header.Del(\"Upgrade-Insecure-Requests\")\n\t\tr.Header.Del(\"Accept-Encoding\")\n\t\tr.Header.Del(\"Accept-Language\")\n\t\tr.Header.Del(\"Sec-Fetch-Dest\")\n\t\tr.Header.Del(\"Sec-Fetch-Mode\")\n\t\tr.Header.Del(\"Sec-Fetch-Site\")\n\t\tr.Header.Del(\"Sec-Fetch-User\")\n\t\tr.Header.Del(\"Sec-GPC\")\n\t\tr.Header.Del(\"Pragma\")\n\t\tr.Header.Del(\"Cache-Control\")\n\t\tr.Header.Del(\"TE\")\n\t\tr.Header.Del(\"Trailer\")\n\t\tr.Header.Del(\"Transfer-Encoding\")\n\t\tr.Header.Del(\"Via\")\n\t\tr.Header.Del(\"X-Forwarded-For\")\n\t\tr.Header.Del(\"X-Forwarded-Host\")\n\t\tr.Header.Del(\"X-Forwarded-Proto\")\n\t\tr.Header.Del(\"X-Real-IP\")\n\t\tr.Header.Del(\"X-Request-ID\")\n\t\tr.Header.Del(\"X-Scheme\")\n\t\tr.Header.Del(\"X", "CodeBleu_score": 45.372832670671194}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tif !a.connection.analogReadSupported {\n\t\treturn 0, 0, fmt.Errorf(\"analog read is not supported by the %sAdaptor\", a.connection.name)\n\t}\n\n\tval, err := a.connection.analogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scale(val)\n\ta.lastRead = scaled\n\ta.lastReadRaw = val\n\n\treturn val, scaled, nil\n}", "CodeBleu_score": 50.06114834728393}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading\n\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif !a.connection.analogReadSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"The connection for the sensor %v does not support analog reading\", a.Name)\n\t}\n\n\t// Read the raw sensor value\n\trawValue, err := a.connection.analogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaledValue := a.scaleRawValue(rawValue)\n\n\t// Update the last read values\n\ta.lastReadRawValue = rawValue\n\ta.lastReadScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 51.75406461122797}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0.0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\tvalue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tscaledValue := a.scale(value)\n\ta.lastAnalogRead = value\n\ta.lastAnalogReadTime = time.Now()\n\ta.lastAnalogReadScaled = scaledValue\n\treturn value, scaledValue, nil\n}", "CodeBleu_score": 46.373109479227125}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tsensor := NewAnalogSensorDriver(a, pin, opts...)\n\treturn &GroveSoundSensorDriver{sensor}\n}", "CodeBleu_score": 22.043575352253843}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tname := \"GroveSoundSensor\"\n\tif len(opts) > 0 {\n\t\tname = opts[0].(string)\n\t}\n\n\td := NewAnalogSensorDriver(a, pin, name, func(s int) int {\n\t\treturn s\n\t})\n\n\treturn &GroveSoundSensorDriver{d}\n}", "CodeBleu_score": 33.748176325868286}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\treturn &GroveSoundSensorDriver{\n\t\tname:        gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:         pin,\n\t\tanalogRead:  a,\n\t\tsensorState: 0,\n\t}\n}", "CodeBleu_score": 35.40225311041065}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(CommandReg, PCD_SoftReset)\n\ttime.Sleep(100 * time.Microsecond)\n\tif d.readRegister(CommandReg) & 0x10 != 0 {\n\t\treturn fmt.Errorf(\"MFRC522 did not reset\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 26.55033210495134}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Set the reset bit in the command register\n\tif err := d.setBitMask(d.regCommand, d.flagCommandSoftReset); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the device to initialize\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Read the command register\n\tcommand, err := d.readRegister(d.regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the device has not finished initializing, return an error\n\tif command&d.flagCommandSoftReset == d.flagCommandSoftReset {\n\t\treturn fmt.Errorf(\"Device did not initialize within the expected time\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.19744451928016}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write the soft reset command to the command register\n\tif err := d.writeCommand(MFRC522_CommandReg, MFRC522_SoftReset_CMD); err != nil {\n\t\treturn err\n\t}\n\t// Wait the required time for the reset to complete\n\ttime.Sleep(100 * time.Millisecond)\n\t// Check if the power-down bit is still set. If it is, the reset didn't complete.\n\tif d.readCommand(MFRC522_CommandReg) & 0x10 != 0 {\n\t\treturn fmt.Errorf(\"Soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.47326180881665}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tvar err error\n\tvar length uint8\n\n\t// Get the number of bytes stored in the FIFO\n\tlength, err = d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// If the number of bytes is more than the size of the byte slice, return an error\n\tif length > uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"The number of bytes in the FIFO (%d) is larger than the size of the byte slice (%d)\", length, len(backData))\n\t}\n\n\t// Read each byte from the FIFO into the byte slice\n\tfor index := uint8(0); index < length; index++ {\n\t\tbackData[index], err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tlastBits, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits & 0x07, nil\n}", "CodeBleu_score": 52.406233724283446}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Read the number of bytes stored in the FIFO\n\tn, err := d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// Check if the number of bytes read is the same as the size of the byte slice\n\tif int(n) != len(backData) {\n\t\treturn 0, fmt.Errorf(\"The number of bytes read (%d) does not match the size of the byte slice (%d)\", n, len(backData))\n\t}\n\t// Read each byte from the FIFO into the byte slice\n\tfor i := 0; i < int(n); i++ {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the control register to get the last bits received\n\treturn d.readRegister(ControlReg)\n}", "CodeBleu_score": 50.58857680102571}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tvar err error\n\tvar length uint8\n\n\t// Get the number of bytes stored in the FIFO\n\tlength, err = d.ReadRegister(d.FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// If the number of bytes is more than the size of the buffer, return an error\n\tif length > uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"FIFO has more bytes than the provided buffer\")\n\t}\n\n\t// Read each byte from the FIFO into the buffer\n\tfor i := uint8(0); i < length; i++ {\n\t\tbackData[i], err = d.ReadRegister(d.FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Return the last bits received\n\treturn d.ReadRegister(d.ControlReg)\n}", "CodeBleu_score": 39.05186755884616}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.log.Debug(\"Halting PICC\")\n\n\t// Create a halt command\n\thaltCommand := []byte{d.CommandHalt, 0}\n\n\t// Calculate CRC\n\thaltCommand = d.appendCrc(haltCommand)\n\n\t// Send the halt command to the PICC\n\tif err := d.dev.Write(haltCommand); err != nil {\n\t\treturn err\n\t}\n\n\t// The halt command is acknowledged by the PICC with an error\n\t// This error is not the same as the error code returned by the PCD\n\t// The error code is the result of the command execution\n\t// The error is the result of the communication with the PICC\n\t// We ignore the error code, but we do want to check the error\n\t_, err := d.dev.Read(1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.507286038968008}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Log message\n\td.logger.Println(\"Halting PICC\")\n\n\t// Build command buffer\n\tbuffer := []byte{d.CommandHalt1, d.CommandHalt2}\n\n\t// Calculate CRC for the command buffer and append it\n\tbuffer = append(buffer, d.calculateCRC(buffer)...)\n\n\t// Send the command and receive the response\n\tresponse, err := d.sendCommand(buffer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Verify response\n\tif response[0] != d.CommandHalt1 || response[1] != d.CommandHalt2 {\n\t\treturn fmt.Errorf(\"Invalid response to PICC halt command\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 36.718333208441656}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.Debugf(\"Halting PICC\")\n\n\t// Create a halt command\n\thaltCmd := []byte{d.PICC_CMD_HLTA, 0}\n\n\t// Calculate CRC for the halt command\n\tcrc := d.calculateCRC(haltCmd)\n\thaltCmd = append(haltCmd, crc[:]...)\n\n\t// Send the halt command to the PICC\n\tif err := d.writeCommand(haltCmd); err != nil {\n\t\treturn err\n\t}\n\n\t// If the PICC responds with any error, communication is halted successfully\n\tif err := d.piccCheckError(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 37.95248860887931}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar err error\n\tvar data []byte\n\tvar buffer []byte\n\tvar size uint8\n\tvar backData []byte\n\tvar backLength uint8\n\tvar validBits uint8\n\tvar uid []byte\n\n\t// Check if a card is present\n\t_, err = d.piccRequest(d.PICC_READ)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// PICC_CMD_READ\n\tbuffer = []byte{d.PICC_READ, block}\n\t// Calculate CRC_A\n\tbuffer, err = d.calculateCRC(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Transmit the buffer and receive the response\n\tbackData, backLength, validBits, err = d.piccTransceive(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(backData) != 16 {\n\t\treturn nil, fmt.Errorf(\"PICC_Read() returned %d bytes, expected 16\", len(backData))\n\t}\n\n\tif d.debug {\n\t\tfmt.Printf(\"PICC_Read() returned:\n\")\n\t\tprintHex(backData)\n\t}\n\n\t// The PICC's response is 16 bytes. The first 4 bytes are the CRC_A, which we ignore.\n\t// The remaining 12 bytes are the data we want.\n\tdata = backData[0:12]\n\n\treturn data, nil\n}", "CodeBleu_score": 41.4384573926632}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar err error\n\tvar data []byte\n\tvar uid []byte\n\tvar buffer []byte\n\tvar bufferUsed int\n\tvar result []byte\n\n\t// Initiate reading from the block\n\tbuffer = []byte{d.PICC_READ, block}\n\tbuffer, err = d.calculateCRC(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuffer, err = d.piccCommunicateWithPICC(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The read command returns 4 bytes; the last 2 bytes are the CRC\n\tif len(buffer) != 4 {\n\t\treturn nil, fmt.Errorf(\"The read command returned %d bytes, but 4 bytes were expected.\", len(buffer))\n\t}\n\n\t// The read command returns 4 bytes; the last 2 bytes are the CRC\n\tif len(buffer) != 4 {\n\t\treturn nil, fmt.Errorf(\"The read command returned %d bytes, but 4 bytes were expected.\", len(buffer))\n\t}\n\n\t// Check the CRC\n\tif !d.checkCRC(buffer) {\n\t\treturn nil, fmt.Errorf(\"The CRC of the read command did not match.\")\n\t}\n\n\t// The first byte of the response is the status code.\n\tif buffer[0] & 0x0F != 0x00 {\n\t\treturn nil, fmt.Errorf(\"The read command returned a status code of 0x%02x.\", buffer[0])\n\t}\n\n\t// The read command returns 4 bytes; the last 2 bytes are the CRC\n\tdata = buffer[1 : len(buffer)-2]\n\n\treturn data, nil\n}", "CodeBleu_score": 40.32558181135449}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar data []byte\n\tvar buffer []byte\n\tvar bufferUsed int\n\n\t// In MFRC522 terminology, \"block\" is a block of memory on the tag. A sector is a group of 4 blocks.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t// The blocks per sector are numbered 0-3 for a total of 16 bytes per sector.\n\t// One tag memory block is 16 bytes.\n\t", "CodeBleu_score": 4.092924898317732}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Check if the answer buffer has at least 2 bytes of space.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"Answer buffer too small\")\n\t}\n\n\t// Clear the collision register.\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// Set the transmission to use only 7 bits of the last byte.\n\td.writeRegister(BitFramingReg, 0x07)\n\n\t// Transceive the request command.\n\treturn d.transceiveData(reqMode, []byte{0x26}, answer)\n}", "CodeBleu_score": 24.774910706431243}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Check if the answer buffer has at least 2 bytes of space.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Clear the collision register.\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// Set the transmission to use only 7 bits of the last byte.\n\tif (reqMode == PiccReqSelect) || (reqMode == PiccReqIdentify) {\n\t\td.writeRegister(BitFramingReg, 0x07)\n\t} else {\n\t\td.writeRegister(BitFramingReg, 0x00)\n\t}\n\n\t// Transmit the request command.\n\terr := d.transceive(reqMode, []byte{}, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the response is valid.\n\tif answer[0] & 0x01 != 0 {\n\t\treturn fmt.Errorf(\"invalid response\")\n\t}\n\n\t// Check if the PICC responded with a collision.\n\tif answer[0] & 0x02 != 0 {\n\t\treturn fmt.Errorf(\"collision detected\")\n\t}\n\n\t// Check if the PICC responded with a timeout.\n\tif answer[0] & 0x04 != 0 {\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 57.92560622054616}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Check if the answer buffer has at least 2 bytes of space.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too short\")\n\t}\n\t// Clear specific bits in the collision register.\n\td.dev.ClearRegisterBitMask(d.dev.CommandReg, 0x80) // ValuesAfterColl\n\td.dev.ClearRegisterBitMask(d.dev.FIFOLevelReg, 0x80) // LevelIrqEn\n\t// Set transmission to use only 7 bits of the last byte.\n\tif reqMode == d.PICC_RequestA || reqMode == d.PICC_WakeupA {\n\t\td.dev.WriteRegister(d.dev.ControlReg, 0x77)\n\t} else {\n\t\td.dev.WriteRegister(d.dev.ControlReg, 0x73)\n\t}\n\t// Transceive the request.\n\treturn d.dev.CommunicateWithPICC(reqMode, answer)\n}", "CodeBleu_score": 37.09731425000017}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == nil {\n\t\treturn fmt.Errorf(\"EasyDriver: onePinStepping() called with nil stepPin\")\n\t}\n\n\tif d.direction == Clockwise {\n\t\td.stepPin.DigitalWrite(0)\n\t\ttime.Sleep(d.stepDelay)\n\t\td.stepPin.DigitalWrite(1)\n\t\td.step++\n\t} else {\n\t\td.stepPin.DigitalWrite(0)\n\t\ttime.Sleep(d.stepDelay)\n\t\td.stepPin.DigitalWrite(1)\n\t\td.step--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 37.54499603056751}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tvar err error\n\n\tif d.stepPin != nil {\n\t\terr = d.stepPin.DigitalWrite(0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(d.stepDelay)\n\t\terr = d.stepPin.DigitalWrite(1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 56.25505584826341}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin != nil {\n\t\terr := d.stepPin.DigitalWrite(0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(d.stepDelay)\n\t\terr = d.stepPin.DigitalWrite(1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif d.direction == 1 {\n\t\t\td.stepNumber++\n\t\t} else {\n\t\t\td.stepNumber--\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 62.77135617883501}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.lock.Lock()\n\tdefer d.lock.Unlock()\n\n\tif d.monitoring {\n\t\treturn fmt.Errorf(\"Monitoring already started\")\n\t}\n\n\td.stopMonitoring = make(chan struct{})\n\td.monitoring = true\n\td.wg.Add(1)\n\n\tgo d.monitorDistance()\n\treturn nil\n}", "CodeBleu_score": 23.932416032158013}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"Distance monitor already running\")\n\t}\n\n\td.distanceMonitorStop = make(chan struct{})\n\td.distanceMonitorWG = &sync.WaitGroup{}\n\td.distanceMonitorWG.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorWG.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\td.log.Errorf(\"Error during distance measurement: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.log.Debugf(\"Distance measurement: %v\", distance)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(d.measurementInterval)\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\n\treturn nil\n}", "CodeBleu_score": 50.63022396047554}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.lock.Lock()\n\tdefer d.lock.Unlock()\n\n\tif d.monitoring {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.stopMonitor = make(chan struct{})\n\td.monitoring = true\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\td.monitoring = false\n\t\t\td.lock.Lock()\n\t\t\td.lock.Unlock()\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopMonitor:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\td.log.Errorf(\"error reading distance: %v\", err)\n\t\t\t\t}\n\t\t\t\td.log.Debugf(\"distance: %v\", distance)\n\t\t\t\td.publish(d.Event(\"distance\"), distance)\n\t\t\t\ttime.Sleep(d.interval)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 44.239640465471666}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstart := uint32(0)\n\treturn func(pin int, duration time.Duration, edge string, count uint32, pinValue uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = uint32(time.Now().UnixNano())\n\t\t} else {\n\t\t\tif start != 0 {\n\t\t\t\tduration := time.Duration(uint32(time.Now().UnixNano()) - start)\n\t\t\t\td.pulse <- duration\n\t\t\t\tstart = 0\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.53414306314767}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, edge string, tick uint32, gpio uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else {\n\t\t\tduration := time.Since(start)\n\t\t\td.pulse <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 36.851024808705304}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTime time.Time\n\treturn func(pin int, duration time.Duration, edge string, count uint32, ticks uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\td.duration <- time.Now().Sub(startTime)\n\t\t}\n\t}\n}", "CodeBleu_score": 35.66249068500936}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measuringMutex.Lock()\n\tdefer d.measuringMutex.Unlock()\n\n\t// trigger the sensor\n\td.triggerPin.DigitalWrite(1)\n\ttime.Sleep(time.Microsecond)\n\td.triggerPin.DigitalWrite(0)\n\n\t// wait for the measurement to complete or for a timeout to occur\n\ttimeout := make(chan bool, 1)\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 50)\n\t\ttimeout <- true\n\t}()\n\n\tselect {\n\tcase <-d.echoPin.WaitForEdge(gobot.RisingEdge):\n\t\t// measurement completed successfully\n\t\td.measuredTime = time.Now().UnixNano() / int64(time.Microsecond)\n\tcase <-timeout:\n\t\treturn fmt.Errorf(\"timeout waiting for measurement to complete\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.90195531571195}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\td.triggerPin.DigitalWrite(1)\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.DigitalWrite(0)\n\n\tvar timeout = time.After(d.measurementTimeout)\n\tvar done = make(chan bool)\n\tvar err error\n\n\tgo func() {\n\t\tfor {\n\t\t\tif d.echoPin.DigitalRead() == 1 {\n\t\t\t\td.startTime = time.Now()\n\t\t\t}\n\t\t\tif d.echoPin.DigitalRead() == 0 {\n\t\t\t\td.endTime = time.Now()\n\t\t\t\tdone <- true\n\t\t\t}\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-timeout:\n\t\terr = fmt.Errorf(\"timeout while measuring distance\")\n\tcase <-done:\n\t\td.measuredDistance = d.endTime.Sub(d.startTime)\n\t}\n\n\treturn err\n}", "CodeBleu_score": 42.890908898314365}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\td.trigger.High()\n\ttime.Sleep(d.triggerPulse)\n\td.trigger.Low()\n\n\td.echo.On(gobot.Data, func(data interface{}) {\n\t\td.echo.Once(gobot.Data, func(data interface{}) {\n\t\t\td.measurementMutex.Lock()\n\t\t\tdefer d.measurementMutex.Unlock()\n\t\t\td.measuredDistance = data.(time.Duration).Microseconds()\n\t\t})\n\t})\n\n\tselect {\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\tcase <-d.echo.WaitForEdge(gobot.RisingEdge):\n\t\treturn nil\n\t}\n}", "CodeBleu_score": 45.465778433021555}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if os.getenv(\"PLATFORMIO_AUTH_TOKEN\"):\n        return os.getenv(\"PLATFORMIO_AUTH_TOKEN\")\n    try:\n        if not os.path.isfile(self.state_file):\n            raise UserSideException(\n                \"Please run `pio account login` to authorize PlatformIO IDE.\"\n            )\n        state = self.load_state()\n        if (\n            \"access_token\" not in state\n            or \"expires_in\" not in state\n            or \"refresh_token\" not in state\n        ):\n            raise UserSideException(\n                \"Please run `pio account login` to authorize PlatformIO IDE.\"\n            )\n        if state[\"expires_in\"] <= int(time.time()):\n            if \"refresh_token\" not in state:\n                raise UserSideException(\n                    \"Please run `pio account login` to authorize PlatformIO IDE.\"\n                )\n            state = self.refresh_authentication_token(state[\"refresh_token\"])\n            self.save_state(state)\n        return state[\"access_token\"]\n    except Exception as e:\n        raise UserSideException(\n            \"Please run `pio account login` to authorize PlatformIO IDE.\"\n        )\n\n", "CodeBleu_score": 38.043794645418664}, {"code": "def fetch_authentication_token(self)\n\t\n\n    # Check if token is available in environment variables\n    if \"PLATFORMIO_AUTH_TOKEN\" in os.environ:\n        return os.environ[\"PLATFORMIO_AUTH_TOKEN\"]\n\n    # Check if token is available in local state\n    state_path = self.get_state_path()\n    if os.path.isfile(state_path):\n        with open(state_path, \"r\") as fp:\n            state = fp.read()\n        state = state.strip()\n        if not state:\n            return None\n        state = state.split(\"", "CodeBleu_score": 19.912733384298164}, {"code": "def fetch_authentication_token(self)\n\t\n    if not self.is_authenticated():\n        raise AccountNotAuthorized()\n    return self.state[\"access_token\"]\n\n", "CodeBleu_score": 10.56710023248871}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    if not self.is_authenticated():\n        return True\n\n    refresh_token = self.get_refresh_token()\n    self.delete_session()\n    try:\n        self.api_request(\n            method=\"POST\", path=\"/v1/logout\", json={\"refresh_token\": refresh_token}\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 71.81483995312718}, {"code": "def logout(self)\n\t\n\n    def _delete_local_session():\n        try:\n            os.remove(app.get_session_filename())\n        except OSError:\n            pass\n\n    if not self.get_refresh_token():\n        _delete_local_session()\n        return True\n\n    try:\n        self.request_access_token(self.get_refresh_token())\n    except HTTPClientError as e:\n        if e.response.status_code == 401:\n            _delete_local_session()\n            return True\n        raise\n\n    try:\n        self.api_request(method=\"POST\", path=\"/v1/logout\")\n    except HTTPClientError as e:\n        if e.response.status_code == 401:\n            _delete_local_session()\n            return True\n        raise\n\n    return False\n\n", "CodeBleu_score": 44.38990937287183}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_session()\n        self.request_url(\n            \"/v1/logout\",\n            method=\"POST\",\n            params={\"refresh_token\": refresh_token},\n            ignore_errors=True,\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 60.07733715402706}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, requirements in self.get_used_packages().items():\n        if requirements.get(\"optional\", False):\n            continue\n        pkg = PackageSpec(owner=requirements[\"owner\"], name=name)\n        pkg.metadata.load(requirements[\"version\"])\n        result.append(\n            {\n                \"name\": pkg.name,\n                \"version\": pkg.metadata.version,\n                \"url\": pkg.metadata.spec.url if pkg.metadata.spec.external else None,\n            }\n        )\n    return result", "CodeBleu_score": 40.281818978460734}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.packages:\n        if not pkg.metadata.get(\"optional\", False):\n            data = {\n                \"name\": pkg.metadata.get(\"name\"),\n                \"version\": pkg.metadata.get(\"version\"),\n            }\n            if pkg.metadata.get(\"url\"):\n                data[\"url\"] = pkg.metadata.get(\"url\")\n            result.append(data)\n    return result\n\n", "CodeBleu_score": 34.62699818294394}, {"code": "def dump_used_packages(self)\n\t\n\n    packages = []\n    for pkg in self.get_used_packages(skip_optional=True):\n        pkg_metadata = self.get_package(pkg[\"__pkg_dir\"])\n        if not pkg_metadata.get(\"external\", False):\n            packages.append({\"name\": pkg[\"name\"], \"version\": pkg[\"version\"]})\n        else:\n            packages.append(\n                {\n                    \"name\": pkg[\"name\"],\n                    \"version\": pkg[\"version\"],\n                    \"url\": pkg_metadata.get(\"url\"),\n                }\n            )\n    return packages\n\n", "CodeBleu_score": 25.309137979985465}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n\n    config = ProjectConfig.get_instance(env.get_project_dir())\n    p_spec = config.get(\"env:\" + env.name, \"platform\")\n    if not p_spec:\n        raise UndefinedEnvPlatformError(env.name)\n    p_cls = cls.new_instance(p_spec, env, autoinstall)\n    p_cls.configure_project_packages(env, targets)\n    return p_cls\n\n", "CodeBleu_score": 38.34952242844007}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    config = ProjectConfig.get_instance()\n    try:\n        name = config.get(\"env:\" + env, \"platform\")\n    except KeyError:\n        raise UndefinedEnvPlatformError(env)\n    if not name:\n        raise UndefinedEnvPlatformError(env)\n    platform = PlatformFactory.new(name, targets, autoinstall)\n    platform.set_project_environment(env)\n    platform.configure_project_packages()\n    return platform\n\n", "CodeBleu_score": 41.21649953922501}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    config = ProjectConfig.get_instance(env.get_project_dir())\n    try:\n        spec = config.get(\"platformio\", \"env:\" + env.name, \"platform\")\n    except KeyError:\n        raise UndefinedEnvPlatformError(env.name)\n    instance = cls(spec, targets, autoinstall)\n    instance.set_project_environment(env)\n    instance.configure_project_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 40.682177265902006}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 69.34153648522857}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\n\tWire.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 66.51085749887085}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(AXP192_ADDR);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(AXP192_ADDR, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 63.29111195816427}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us > 0) {\n    EnableTimerWakeUp(time_in_us);\n  } else {\n    DisableTimerWakeUp();\n  }\n  StartPowerOff();\n}", "CodeBleu_score": 50.118824399773544}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us == 0) {\n    DisableTimerWakeup();\n  } else {\n    EnableTimerWakeup(time_in_us);\n  }\n  Sleep();\n}", "CodeBleu_score": 47.60151103331919}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us == 0) {\n    DisableTimerWake();\n  } else {\n    EnableTimerWake(time_in_us);\n  }\n  StartPowerOff();\n}", "CodeBleu_score": 47.409242887513074}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = start_y;\n\tint y_new = start_y + LINE_HEIGHT;\n\tint y_max = DISPLAY_HEIGHT - BOTTOM_FIXED_AREA;\n\tint y_min = TOP_FIXED_AREA;\n\n\tif (y_new > y_max) {\n\t\ty_new = y_min;\n\t}\n\n\tif (y_new == y_min && tteBar) {\n\t\ty_new = y_min + LINE_HEIGHT;\n\t}\n\n\tstart_y = y_new;\n\n\tdraw_rect(0, y, DISPLAY_WIDTH, LINE_HEIGHT, color);\n\n\treturn y;\n}", "CodeBleu_score": 22.83054598709306}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = this->start_y;\n\n\t// Fill the rectangle at the current starting y-coordinate with the specified color\n\tthis->fill_rect(0, y, this->width, this->line_height, color);\n\n\t// Increment the starting y-coordinate by the height of a text line\n\tthis->start_y += this->line_height;\n\n\t// Wrap around if the starting y-coordinate exceeds the display boundaries minus the bottom fixed area\n\tif (this->start_y >= this->height - this->bottom_fixed_area) {\n\t\tthis->start_y = this->top_fixed_area;\n\t}\n\n\t// Use alternative top fixed area coordinates if the specific condition is met\n\tif (this->start_y == this->top_fixed_area_alt) {\n\t\tthis->start_y = this->top_fixed_area;\n\t}\n\n\t// Update the scroll address\n\tthis->scroll_address(this->start_y);\n\n\t// Return the previous y-coordinate\n\treturn y;\n}", "CodeBleu_score": 7.965338197774111}, {"code": "int Display::scroll_line(uint32_t color){\n\t\n    int y = scroll_y;\n\n    if (tteBar) {\n        y = 0;\n    }\n\n    fill_rect(0, y, DISPLAY_WIDTH, TEXT_HEIGHT, color);\n\n    scroll_y += TEXT_HEIGHT;\n\n    if (scroll_y >= (DISPLAY_HEIGHT - BOTTOM_FIXED_AREA)) {\n        scroll_y = TOP_FIXED_AREA;\n    }\n\n    // Update the scroll address\n    set_scroll_address(scroll_y);\n\n    return y;\n}", "CodeBleu_score": 21.91158047215457}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!set_ssids(ssids)) {\n\t\treturn false;\n\t}\n\tif (!set_access_points(access_points)) {\n\t\treturn false;\n\t}\n\tif (!set_html_content()) {\n\t\treturn false;\n\t}\n\tstart();\n\treturn true;\n}", "CodeBleu_score": 53.709091059521995}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  if (ssids->size() == 0) {\n    Serial.println(\"No SSIDs to connect to\");\n    return false;\n  }\n  if (access_points->size() == 0) {\n    Serial.println(\"No access points to create\");\n    return false;\n  }\n  if (!setupAccessPoints(access_points)) {\n    Serial.println(\"Could not setup access points\");\n    return false;\n  }\n  if (!setupHTML(ssids)) {\n    Serial.println(\"Could not setup HTML\");\n    return false;\n  }\n  startPortal();\n  return true;\n}", "CodeBleu_score": 53.35710553624481}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (WiFi.softAP(ssids->get(0).ssid, ssids->get(0).password) == false) {\n\t\treturn false;\n\t}\n\tif (setHTML(access_points) == false) {\n\t\treturn false;\n\t}\n\tstart();\n\treturn true;\n}", "CodeBleu_score": 54.10508698190187}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (queue == NULL) {\n\t\t\tqueue = xQueueCreate(queue_size, sizeof(char));\n\t\t}\n\t\tif (text == NULL) {\n\t\t\ttext = (char *) pvPortMalloc(sizeof(char) * (text_size + 1));\n\t\t}\n\t\tif (text_in == NULL) {\n\t\t\ttext_in = (char *) pvPortMalloc(sizeof(char) * (text_size + 1));\n\t\t}\n\t} else {\n\t\tif (queue != NULL) {\n\t\t\txQueueReset(queue);\n\t\t}\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 9.468559983789609}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (queue.empty()) {\n\t\t\tqueue.push(text);\n\t\t}\n\t\ttext = text_in;\n\t\ttext_in = \"\";\n\t} else {\n\t\tqueue_enabled_flag = true;\n\t\tqueue.push(text);\n\t\ttext = text_in;\n\t\ttext_in = \"\";\n\t}\n}", "CodeBleu_score": 11.866788614473979}, {"code": "void GpsInterface::enable_queue(){\n\t  if (queue_enabled_flag) {\n    // If the queue is already enabled, ensure that the queue, text, and text_in are initialized\n    text.reserve(100);\n    text_in.reserve(100);\n    queue.reserve(100);\n  } else {\n    // If the queue is not enabled, flush the existing queue and set the queue_enabled_flag to true\n    queue.flush();\n    queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 12.4021405728723}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\n\tif (this->queue_nmea != NULL) {\n\t\tthis->queue_nmea = new std::queue<std::string>();\n\t\tdelete this->queue_nmea;\n\t}\n\telse {\n\t\tthis->queue_nmea = new std::queue<std::string>();\n\t}\n}", "CodeBleu_score": 18.60143633474569}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (queue_nmea != NULL) {\n        queue_nmea = new std::queue<std::string>();\n        delete queue_nmea;\n    }\n    else {\n        queue_nmea = new std::queue<std::string>();\n    }\n}", "CodeBleu_score": 43.330550335403025}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea != NULL) {\n\t\twhile (!queue_nmea->empty()) {\n\t\t\tqueue_nmea->pop();\n\t\t}\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = new std::queue<std::string>;\n\t} else {\n\t\tqueue_nmea = new std::queue<std::string>;\n\t}\n}", "CodeBleu_score": 37.59489338351084}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    /*Return if the area is out the screen*/\n    if (area->x2 < 0) return;\n    if (area->y2 < 0) return;\n    if (area->x1 > TFT_WIDTH - 1) return;\n    if (area->y1 > TFT_HEIGHT - 1) return;\n\n    /*Truncate the area to the screen*/\n    int32_t act_x1 = area->x1 < 0 ? 0 : area->x1;\n    int32_t act_y1 = area->y1 < 0 ? 0 : area->y1;\n    int32_t act_x2 = area->x2 > TFT_WIDTH - 1 ? TFT_WIDTH - 1 : area->x2;\n    int32_t act_y2 = area->y2 > TFT_HEIGHT - 1 ? TFT_HEIGHT - 1 : area->y2;\n\n    uint32_t x;\n    uint32_t y;\n\n    tft.startWrite();\n    tft.setAddrWindow(act_x1, act_y1, (act_x2 - act_x1 + 1), (act_y2 - act_y1 + 1));\n\n    for (y = act_y1; y <= act_y2; y++) {\n      for (x = act_x1; x <= act_x2; x++) {\n        tft.writePixel(color_p->full);\n        color_p++;\n      }\n    }\n\n    tft.endWrite();\n\n    /* IMPORTANT!!!\n     * Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 47.99109434954233}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n    uint16_t x1 = area->x1;\n    uint16_t y1 = area->y1;\n    uint16_t x2 = area->x2;\n    uint16_t y2 = area->y2;\n\n    uint16_t x;\n    uint16_t y;\n\n    /* Set the address window to the specified area */\n    tft.startWrite();\n    tft.setAddrWindow(x1, y1, (x2 - x1 + 1), (y2 - y1 + 1));\n\n    /* Iterate through each pixel in the area */\n    for (y = y1; y <= y2; y++) {\n      for (x = x1; x <= x2; x++) {\n        /* Write the corresponding color from the color buffer */\n        tft.writePixel(color_p->full);\n        color_p++;\n      }\n    }\n    tft.endWrite();\n\n    /* Notify that the display flush is complete */\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 51.42208189650444}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t  uint16_t x, y;\n  uint16_t w = (area->x2 - area->x1 + 1);\n  uint16_t h = (area->y2 - area->y1 + 1);\n  uint8_t *buf = (uint8_t *)malloc(w * 2);\n  if (buf == NULL) {\n    Serial.println(\"malloc error\");\n    return;\n  }\n  //Serial.printf(\"x1:%d,x2:%d,y1:%d,y2:%d\\r\n\", area->x1, area->x2, area->y1, area->y2);\n  //Serial.printf(\"w:%d,h:%d\\r\n\", w, h);\n  for (y = 0; y < h; y++) {\n    for (x = 0; x < w; x++) {\n      uint16_t c = *color_p++;\n      uint8_t r = (c >> 8) & 0xF8;\n      uint8_t g = (c >> 3) & 0xFC;\n      uint8_t b = (c << 3) & 0xF8;\n      buf[x * 2] = r;\n      buf[x * 2 + 1] = g | b >> 5;\n    }\n    tft.startWrite();\n    tft.setAddrWindow(area->x1, area->y1 + y, w, 1);\n    tft.writePixels(buf, w * 2);\n    tft.endWrite();\n  }\n  free(buf);\n  lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 49.221696092954836}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->getChildCount(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tstd::cout << \"  \";\n\t\t}\n\t\tstd::cout << menu->getChild(i)->getName() << std::endl;\n\t\tif (menu->getChild(i)->getChildCount() > 0) {\n\t\t\tshowMenuList(menu->getChild(i), layer + 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.6267178440838}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tint i;\n\tfor (i = 0; i < menu->getLength(); i++) {\n\t\tMenuNode * node = menu->getNode(i);\n\t\tif (node->getType() == MENU_NODE_TYPE_MENU) {\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tprintf(\"  \");\n\t\t\t}\n\t\t\tprintf(\"%s\n\", node->getName());\n\t\t\tshowMenuList((Menu *)node->getData(), layer + 1);\n\t\t}\n\t\telse if (node->getType() == MENU_NODE_TYPE_ITEM) {\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tprintf(\"  \");\n\t\t\t}\n\t\t\tprintf(\"%s\n\", node->getName());\n\t\t}\n\t}\n\tprintf(\"\n\");\n}", "CodeBleu_score": 46.50004550783157}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    for (int i = 0; i < menu->getNumNodes(); i++) {\n        if (menu->getNode(i)->isMenu()) {\n            for (int j = 0; j < layer; j++) {\n                Serial.print(F(\"   \"));\n            }\n            Serial.println(menu->getNode(i)->getName());\n            showMenuList(menu->getNode(i)->getMenu(), layer + 1);\n        }\n        else {\n            for (int j = 0; j < layer; j++) {\n                Serial.print(F(\"   \"));\n            }\n            Serial.println(menu->getNode(i)->getName());\n        }\n    }\n    Serial.println();\n}", "CodeBleu_score": 51.306294408923094}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  int i = 0;\n  while (i < count) {\n    SSID ssid = SSID();\n    ssid.setSSID(generateSSID());\n    ssid.setChannel(generateChannel());\n    ssid.setMAC(generateMAC());\n    ssids.push_back(ssid);\n    Serial.println(ssid.toString());\n    i++;\n  }\n  return i;\n}", "CodeBleu_score": 23.88763230132853}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    for (int i = 0; i < count; i++) {\n        // create random SSID\n        String SSID = \"\";\n        for (int j = 0; j < 6; j++) {\n            SSID += random(1, 26) + 64;\n        }\n\n        // create random MAC address\n        String MAC = \"\";\n        for (int j = 0; j < 6; j++) {\n            MAC += random(0, 255) + 64;\n            if (j < 5) MAC += \":\";\n        }\n\n        // create random channel\n        int channel = random(1, 11);\n\n        // add SSID to list\n        SSIDs.push_back(SSID);\n\n        // print SSID\n        Serial.println(SSID);\n    }\n    return SSIDs.size();\n}", "CodeBleu_score": 41.65865364831238}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    if (count <= 0) {\n        return 0;\n    }\n    int generatedSSIDs = 0;\n    for (int i = 0; i < count; i++) {\n        SSID ssid = SSID();\n        ssid.ssid = generateSSID();\n        ssid.channel = random(1, 14);\n        ssid.mac = generateMAC();\n        ssids.push_back(ssid);\n        generatedSSIDs++;\n        printSSID(ssid);\n    }\n    return generatedSSIDs;\n}", "CodeBleu_score": 32.93016605554371}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Topic created: {topic}\")\n    return topic\n\n", "CodeBleu_score": 77.34853684841664}, {"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n    # TODO project_id = \"Your Google Cloud Project ID\"\n    # TODO topic_name = \"Your Pub/Sub topic name\"\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 78.74405938741704}, {"code": "def create_topic(project_id, topic_name)\n\t\n    try:\n        # Initialize a PublisherClient.\n        publisher = pubsub_v1.PublisherClient()\n        topic_path = publisher.topic_path(project_id, topic_name)\n\n        # Create the topic.\n        topic = publisher.create_topic(topic_path)\n\n        print(f\"Topic created: {topic}\")\n        return topic\n    except Exception as e:\n        print(f\"Error creating topic: {e}\")\n        return None\n\n", "CodeBleu_score": 66.58446619992323}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    global client\n    global topic\n    global bucket\n    global event_topic\n    global file_name\n    global event_topic\n    global jwt_token\n    global device_id\n    global device_name\n    global device_registry_id\n    global project_id\n    global region\n    global cloud_region\n    global registry_id\n    global service_account_json\n    global event_topic\n    global service_account_json\n    global iot_topic\n    global subscription_name\n    global subscription_path\n    global device_id\n    global device_name\n    global device_registry_id\n    global project_id\n    global region\n    global cloud_region\n    global registry_id\n    global service_account_json\n    global event_topic\n    global service_account_json\n    global iot_topic\n    global subscription_name\n    global subscription_path\n    global device_id\n    global device_name\n    global device_registry_id\n    global project_id\n    global region\n    global cloud_region\n    global registry_id\n    global service_account_json\n    global event_topic\n    global service_account_json\n    global iot_topic\n    global subscription_name\n    global subscription_path\n    global device_id\n    global device_name\n    global device_registry_id\n    global project_id\n    global region\n    global cloud_region\n    global registry_id\n    global service_account_json\n    global event_topic\n    global service_account_json\n    global iot_topic\n    global subscription_name\n    global subscription_path\n    global device_id\n    global device_name\n    global device_registry_id\n    global project_id\n    global region\n    global cloud_region\n    global registry_id\n    global service_account_json\n    global event_topic\n    global service_account_json\n    global iot_topic\n    global subscription_name\n    global subscription_path\n    global device_id\n    global device_name\n    global device_registry_id\n    global project_id\n    global region\n    global cloud_region\n    global registry_id\n    global service_account_json\n    global event", "CodeBleu_score": 14.210063745619408}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Received message: {}, topic: {}, qos: {}\".format(payload, message.topic, str(message.qos)))\n    if payload == \"on\":\n        print(\"Taking a picture\")\n        # Capture a preview image\n        os.system(\"fswebcam -r 640x480 --no-banner /home/pi/Desktop/image.jpg\")\n        # Upload the file to a specified bucket\n        bucket = storage.Client().get_bucket(\"your-bucket-name\")\n        blob = bucket.blob(\"image.jpg\")\n        blob.upload_from_filename(\"/home/pi/Desktop/image.jpg\")\n        # Publish the file's URL to an MQTT event topic\n        publish_message(blob.public_url)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 33.950299164154615}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Received message: {}\".format(payload))\n    if payload == \"on\":\n        # capture the image\n        print(\"capturing image...\")\n        os.system('raspistill -o image.jpg -t 1000')\n        # upload the file\n        print(\"uploading image...\")\n        upload_blob(bucket_name, source_file_name, destination_blob_name)\n        # publish the URL\n        print(\"publishing URL...\")\n        publish_message(client, \"events\", f\"https://storage.googleapis.com/{bucket_name}/{destination_blob_name}\")\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 25.260031159035762}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT device connection example.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--subscription_name\", required=True, help=\"Google Cloud Pub/Sub subscription name\")\n    return parser.parse_args()\n\n", "CodeBleu_score": 43.85104247315187}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT example.')\n    parser.add_argument('--project_id', default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help='GCP cloud project name')\n    parser.add_argument('--subscription', required=True, help='Google Pub/Sub subscription name')\n    parser.add_argument('--device_id', required=True, help='Google Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', required=True, help='Path to private key file.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--registry_id', required=True, help='Cloud IoT Core registry id')\n    parser.add_argument('--message_type', default='events', choices=('events', 'state'), help='Indicates whether the message to be published is a telemetry event or a device state message.')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    return parser.parse_args()\n\n", "CodeBleu_score": 41.65090918418778}, {"code": "def parse_command_line_args()\n\t\n\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT example using the Python client library.\n", "CodeBleu_score": 4.01113674835721}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # Get the API scopes and discovery URL for the Cloud IoT Core service.\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Build the credentials from the service account JSON file.\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n\n    # Build the client for the Cloud IoT Core service.\n    return discovery.build(\n        'cloudiot',\n        'v1',\n        discoveryServiceUrl=discovery_url,\n        credentials=credentials,\n        cache_discovery=False)\n\n", "CodeBleu_score": 20.890471592236793}, {"code": "def get_client(service_account_json)\n\t\n    # Set the scopes\n    scopes = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/cloudiot\",\n    ]\n\n    # Configure the credentials for the Google Cloud IoT Core service\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n\n    # Build the client for the Google Cloud IoT Core service\n    service = discovery.build(\n        \"cloudiot\",\n        \"v1\",\n        credentials=credentials,\n        discoveryServiceUrl=\"https://cloudiot.googleapis.com/$discovery/rest\",\n    )\n\n    return service\n\n", "CodeBleu_score": 22.59784152202829}, {"code": "def get_client(service_account_json)\n\t\n\n    # Define the necessary API scopes, version, and discovery URL\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_api_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n\n    # Build the client\n    client = discovery.build(\n        \"cloudiot\",\n        api_version,\n        discoveryServiceUrl=discovery_api_url,\n        credentials=credentials,\n    )\n\n    return client\n\n", "CodeBleu_score": 24.360069501389216}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    # Get the ASN1 code for the hash method\n    hash_method_asn1 = get_hash_asn1(hash_method)\n\n    # Concatenate the hash value with the ASN1 code\n    hash_value_with_asn1 = hash_method_asn1 + hash_value\n\n    # Pad the hash value for signing\n    padded_hash = transform.bytes2int(hash_value_with_asn1)\n    padded_hash = core.pad_for_signing(padded_hash, priv_key.n)\n\n    # Encrypt the padded hash value\n    encrypted_hash = core.encrypt_int(padded_hash, priv_key.d, priv_key.n)\n\n    # Return the encrypted hash as a byte block\n    return transform.int2bytes(encrypted_hash, priv_key.size_in_bytes())\n\n", "CodeBleu_score": 19.55670173913701}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_oid = core.get_hash_oid(hash_method)\n    hash_oid_bytes = transform.bytes2int(hash_oid.encode('ascii'))\n    hash_value_bytes = transform.bytes2int(hash_value)\n    padded_hash_value = _pad_for_signing(hash_value_bytes, hash_oid_bytes)\n    encrypted_hash_value = core.encrypt_int(padded_hash_value, priv_key.d, priv_key.n)\n    return transform.int2bytes(encrypted_hash_value)\n\n", "CodeBleu_score": 18.75187749255461}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    # Get the ASN1 code for the hash method\n    hash_method_asn1 = hash_method_to_asn1(hash_method)\n\n    # Concatenate the hash method ASN1 code with the hash value\n    hash_value_with_asn1 = hash_method_asn1 + hash_value\n\n    # Pad the hash value for signing\n    padded_hash_value = transform.bytes2int(\n        core.pad_for_signing(hash_value_with_asn1, priv_key.size_in_bytes())\n    )\n\n    # Encrypt the padded hash value using the private key\n    encrypted_hash = core.encrypt_int(padded_hash_value, priv_key.d, priv_key.n)\n\n    # Return the encrypted hash as a byte block\n    return transform.int2bytes(encrypted_hash, priv_key.size_in_bytes())\n\n", "CodeBleu_score": 22.455426374772713}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError(\"The message must be a byte string.\")\n    if not isinstance(signature, bytes):\n        raise TypeError(\"The signature must be a byte string.\")\n    if not isinstance(pub_key, common.PubKey):\n        raise TypeError(\"The public key must be a PubKey object.\")\n\n    # Convert the signature to an integer\n    signature = int(signature.hex(), 16)\n\n    # Decrypt the signature\n    clear_signature = core.decrypt_int(signature, pub_key.e, pub_key.n)\n\n    # Determine the hash method used\n    hash_method = core.get_hash_method(pub_key)\n\n    # Compute the hash of the message\n    h = hash_method.hash(message)\n\n    # Reconstruct the expected padded hash\n    padded_hash = core.pad_for_signing(h, hash_method.hash_len)\n\n    # Check whether the hashes match\n    if padded_hash != clear_signature:\n        raise core.VerificationError(\"The signature is not valid.\")\n\n    return hash_method.name\n\n", "CodeBleu_score": 40.71297749461256}, {"code": "def verify(message, signature, pub_key)\n\t\n\n    # Convert the signature to an integer\n    s = int(common.hex2int(signature), 16)\n\n    # Decrypt the signature to obtain the clear signature\n    m = core.decrypt_int(s, pub_key.e, pub_key.n)\n\n    # Determine the hash method used\n    hash_method = core.get_hash_method(pub_key)\n\n    # Compute the hash of the message\n    h = hash_method(message)\n\n    # Reconstruct the expected padded hash\n    em = transform.bytes2int(common.create_padded_hash(h, hash_method))\n\n    # If the expected padded hash does not match the clear signature,\n    # raise a verification error\n    if em != m:\n        raise core.VerificationError('Signature verification failed')\n\n    # If the verification is successful, return the hash method name\n    return hash_method.__name__\n", "CodeBleu_score": 19.705100698990638}, {"code": "def verify(message, signature, pub_key)\n\t\n\n    # Check the signature\n    if not common.byte_size(signature):\n        raise core.VerificationError('The signature is empty')\n\n    # Convert the signature to an integer\n    try:\n        signature = transform.bytes2int(signature)\n    except OverflowError:\n        raise core.VerificationError('Invalid signature.')\n\n    # Decrypt the signature to obtain the clear signature\n    try:\n        clear_signature = core.decrypt_int(signature, pub_key.e, pub_key.n)\n    except OverflowError:\n        raise core.VerificationError('Invalid signature.')\n\n    # Determine the hash method used\n    hash_method = common.get_hash_method(pub_key)\n\n    # Compute the hash of the message\n    try:\n        hash_value = hash_method(message).digest()\n    except UnicodeEncodeError:\n        raise core.VerificationError('Message must be bytes, not unicode.')\n\n    # Reconstruct the padded hash\n    padded_hash = _pad_hash(hash_method, hash_value)\n\n    # Check if the signature is valid\n    if not _verify_signature(padded_hash, clear_signature, pub_key.n):\n        raise core.VerificationError('Invalid signature.')\n\n    return hash_method\n\n", "CodeBleu_score": 38.9231801839577}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t    uint32_t currentUnixTime = 0;\n    // Get the current time.\n    currentUnixTime = getUnixTime();\n    // If the time is valid, update the JWT.\n    if (currentUnixTime != 0) {\n        // Update the JWT.\n        updateJWT(currentUnixTime);\n    }\n    // Connect to the MQTT client.\n    MQTT_Connect();\n    // Set the flag to send an MQTT SUBSCRIBE packet after the connection is established.\n    subscribeFlag = true;\n    // Print a debug message indicating the MQTT connection attempt.\n    debug_printer(SEVERITY_NONE, LEVEL_NORMAL, \"Attempting to connect to the MQTT broker...\");\n}", "CodeBleu_score": 49.58128377685354}, {"code": "static void connectMQTT(){\n\t\n    uint32_t currentUnixTime = 0;\n\n    if (getCurrentUnixTime(&currentUnixTime) == 0) {\n\n        updateJWT(currentUnixTime);\n\n    }\n\n    connectToMQTTBroker();\n\n    subscribeMQTT = true;\n\n    debug_printer(SEVERITY_LEVEL_INFO, \"Attempting MQTT connection...\");\n\n}", "CodeBleu_score": 23.138319954761094}, {"code": "static void connectMQTT(){\n\t\n    uint32_t currentUnixTime = 0;\n\n    getCurrentUnixTime(&currentUnixTime);\n\n    if (currentUnixTime) {\n\n        updateJWT(currentUnixTime);\n\n    }\n\n    connectToMQTTBroker();\n\n    setMqttConnectionFlag();\n\n    debug_printer(SEVERITY_LEVEL_INFO, \"Attempting MQTT connection...\");\n\n}", "CodeBleu_score": 44.61984230470611}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\n    int i;\n\n    *num = 0;\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        *num = (*num * 10) + (str[i] - '0');\n    }\n    return str + width;\n}", "CodeBleu_score": 25.288155410863844}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\n    int i;\n    uint32_t value;\n    uint8_t c;\n\n    value = 0;\n    for (i = 0; i < width; i++) {\n        c = *str;\n        if (c < '0' || c > '9') {\n            return str;\n        }\n        value = value * 10 + (c - '0');\n        str++;\n    }\n    *num = value;\n\n    return str;\n}", "CodeBleu_score": 29.353739019087165}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t num_tmp = 0;\n    const uint8_t* str_end = str;\n\n    if (str == NULL || width <= 0 || num == NULL) {\n        return str;\n    }\n\n    for (; width > 0; --width, ++str_end) {\n        if (*str_end < '0' || *str_end > '9') {\n            return str;\n        }\n        num_tmp = num_tmp * 10 + (*str_end - '0');\n    }\n    *num = num_tmp;\n\n    return str_end;\n}", "CodeBleu_score": 29.927735310056203}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = ATCACERT_E_SUCCESS;\n    uint8_t tbs_digest[32];\n    uint8_t signature[72];\n    size_t block_size = 0;\n    size_t sig_size = 0;\n    size_t tbs_digest_size = 0;\n    uint8_t* tbs_digest_ptr = NULL;\n    uint8_t* signature_ptr = NULL;\n    uint8_t* block_ptr = NULL;\n    size_t block_offset = 0;\n    uint8_t block_data[128];\n    uint8_t block_data_size = 0;\n    uint8_t block_data_offset = 0;\n    uint8_t block_data_remaining = 0;\n    uint8_t block_data_blocks = 0;\n    uint8_t block_data_block_num = 0;\n    uint8_t block_data_block_remaining = 0;\n    uint8_t block_data_block_offset = 0;\n    uint8_t block_data_block_data_offset = 0;\n    uint8_t block_data_block_data_size = 0;\n    uint8_t block_data_block_data_remaining = 0;\n    uint8_t block_data_block_data_blocks = 0;\n    uint8_t block_data_block_data_block_num = 0;\n    uint8_t block_data_block_data_block_remaining = 0;\n    uint8_t block_data_block_data_block_offset = 0;\n    uint8_t block_data_block_data_block_data_offset = 0;\n    uint8_t block_data_block_data_block_data_size = 0;\n    uint8_t block_data_block_data_block_data_remaining = 0;\n    uint8_t block_data_block_data_block_data_blocks = 0;\n    uint8_t block_data_block_data", "CodeBleu_score": 11.72015538016831}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[72];\n    size_t signature_size = sizeof(signature);\n    uint8_t encoded_signature[72];\n    size_t encoded_signature_size = sizeof(encoded_signature);\n\n    if (build_state == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Calculate TBS digest\n    if (build_state->cert_def->cert_sn_dev_loc.zone == DEVZONE_DATA) {\n        // Cert SN in device, use device SN for TBS digest\n        ret = atcacert_get_device_sn(build_state->device_locs, build_state->cert_def->cert_sn_dev_loc.slot, tbs_digest);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n    } else {\n        // Cert SN in template, calculate TBS digest\n        ret = atcacert_get_tbs_digest(build_state->cert_def, &build_state->cert_sn_digest, tbs_digest);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n    }\n\n    // Sign the TBS digest\n    ret = atcacert_sign_internal(build_state->device_locs,\n                                 build_state->cert_def->signer_id,\n                                 tbs_digest,\n                                 sizeof(tbs_digest),\n                                 signature,\n                                 &signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Encode the signature\n    ret = atcacert_encode_signature(build_state->cert_def->signature_algorithm, signature, signature_size, encoded_signature, &encoded_signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return", "CodeBleu_score": 60.545384371115276}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = ATCACERT_E_SUCCESS;\n    uint8_t tbs_digest[32];\n    uint8_t signature[72];\n    size_t signature_size = sizeof(signature);\n\n    if (build_state == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Calculate the TBS digest and build the signature\n    if (build_state->cert_def->signer_id_size > 0) {\n        ret = atcacert_get_tbs_digest(build_state->cert_def, build_state->cert, tbs_digest);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n\n        ret = atcacert_get_signature(build_state->cert_def, tbs_digest, signature, &signature_size);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n    }\n\n    // Append the signature to the cert\n    ret = atcacert_set_cert_element(build_state->cert_def,\n                                    build_state->cert,\n                                    build_state->cert_size,\n                                    build_state->cert_loc,\n                                    ATCACERT_E_CERT_SIGNATURE,\n                                    signature,\n                                    signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 59.76190372050636}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int                 ret = 0;\n    uint8_t             tbs_digest[32];\n    uint8_t             signature[64];\n    const uint8_t*      tbs_digest_ptr = NULL;\n    const uint8_t*      signature_ptr  = NULL;\n    uint8_t             ca_public_key_raw[72];\n    size_t              ca_public_key_raw_size = 0;\n    uint8_t             ca_public_key_x509[72];\n    size_t              ca_public_key_x509_size = 0;\n    uint8_t             ca_public_key_x509_formatted[72];\n    size_t              ca_public_key_x509_formatted_size = 0;\n    uint8_t             ca_public_key_x509_formatted_no_int[64];\n    size_t              ca_public_key_x509_formatted_no_int_size = 0;\n    atcacert_device_loc_t ca_public_key_dev_loc;\n    uint8_t             ca_public_key_dev_loc_bytes[9];\n    size_t              ca_public_key_dev_loc_bytes_size = 0;\n    uint8_t             ca_public_key_raw_from_device[72];\n    size_t              ca_public_key_raw_from_device_size = 0;\n    uint8_t             ca_public_key_x509_from_device[72];\n    size_t              ca_public_key_x509_from_device_size = 0;\n    uint8_t             ca_public_key_x509_formatted_from_device[72];\n    size_t              ca_public_key_x509_formatted_from_device_size = 0;\n    uint8_t             ca_public_key_x509_formatted_no_int_from_device[64];\n    size_", "CodeBleu_score": 19.65361963052272}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int                 ret = ATCACERT_E_SUCCESS;\n    uint8_t             tbs_digest[32];\n    uint8_t             signature[64];\n    uint8_t             public_key[72];\n    atcacert_device_loc_t ca_public_key_loc;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Find the CA public key in the device\n    ca_public_key_loc.zone = DEVZONE_DATA;\n    ca_public_key_loc.slot = 15;\n    ca_public_key_loc.is_genkey = 0;\n    ca_public_key_loc.offset = 0;\n    ca_public_key_loc.count = 72;\n\n    // Retrieve the TBS digest and signature from the certificate\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Read the public key from the device\n    ret = atcab_read_zone(ca_public_key_loc.zone, ca_public_key_loc.slot, ca_public_key_loc.is_genkey, ca_public_key_loc.offset, public_key, ca_public_key_loc.count);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the signature\n    ret = atcab_verify_extern(tbs_digest, signature, public_key, NULL);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n", "CodeBleu_score": 74.9049048682016}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int                 ret = 0;\n    uint8_t             tbs_digest[32];\n    uint8_t             signature[64];\n    atcacert_device_loc_t ca_public_key_dev_loc;\n    atcacert_device_loc_t cert_dev_loc;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL)\n        return ATCACERT_E_BAD_PARAMS;\n\n    if (cert_def->type != CERTTYPE_X509)\n        return ATCACERT_E_BAD_CERT;\n\n    if (cert_size != cert_def->cert_template_size)\n        return ATCACERT_E_WRONG_CERT_DEF;\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS)\n        return ret;\n\n    ret = atcacert_get_signature(cert_def, cert, signature);\n    if (ret != ATCACERT_E_SUCCESS)\n        return ret;\n\n    ca_public_key_dev_loc.zone = DEVZONE_DATA;\n    ca_public_key_dev_loc.slot = 15;\n    ca_public_key_dev_loc.is_genkey = 0;\n    ca_public_key_dev_loc.offset = 0;\n    ca_public_key_dev_loc.count = 72;\n\n    cert_dev_loc.zone = DEVZONE_DATA;\n    cert_dev_loc.slot = 15;\n    cert_dev_loc.is_genkey = 0;\n    cert_dev_loc.offset = 0;\n    cert_dev_loc.count = cert_size;\n\n    ret = atcacert_verify_cert_hw_device_loc(cert_def, &cert_dev_loc, tbs_digest, signature, &ca_public_key_dev_loc);\n\n    return ret;", "CodeBleu_score": 55.613601476068986}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile *current = list;\n\ttimerStruct_t * volatile *next = NULL;\n\ttimerStruct_t * volatile temp = NULL;\n\n\tif (timer == NULL || list == NULL)\n\t\treturn false;\n\n\twhile (*current != NULL)\n\t{\n\t\tif (*current == timer)\n\t\t{\n\t\t\ttemp = *current;\n\t\t\tnext = &((*current)->next);\n\t\t\t*current = (*current)->next;\n\t\t\tfree(temp);\n\t\t\treturn true;\n\t\t}\n\t\tcurrent = &((*current)->next);\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 28.600958078105577}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\t\ttimerStruct_t * volatile *list_ptr = list;\n\t\ttimerStruct_t * volatile *tmp_ptr = list;\n\t\ttimerStruct_t * volatile tmp_timer;\n\t\ttimerStruct_t * volatile tmp_timer2;\n\t\ttimerStruct_t * volatile tmp_timer3;\n\t\ttimerStruct_t * volatile tmp_timer4;\n\t\ttimerStruct_t * volatile tmp_timer5;\n\t\ttimerStruct_t * volatile tmp_timer6;\n\t\ttimerStruct_t * volatile tmp_timer7;\n\t\ttimerStruct_t * volatile tmp_timer8;\n\t\ttimerStruct_t * volatile tmp_timer9;\n\t\ttimerStruct_t * volatile tmp_timer10;\n\t\ttimerStruct_t * volatile tmp_timer11;\n\t\ttimerStruct_t * volatile tmp_timer12;\n\t\ttimerStruct_t * volatile tmp_timer13;\n\t\ttimerStruct_t * volatile tmp_timer14;\n\t\ttimerStruct_t * volatile tmp_timer15;\n\t\ttimerStruct_t * volatile tmp_timer16;\n\t\ttimerStruct_t * volatile tmp_timer17;\n\t\ttimerStruct_t * volatile tmp_timer18;\n\t\ttimerStruct_t * volatile tmp_timer19;\n\t\ttimerStruct_t * volatile tmp_timer20;\n\t\ttimerStruct_t * volatile tmp_timer21;\n\t\ttimerStruct_t * volatile tmp_timer22;\n\t\ttimerStruct_t * volatile tmp_timer23;\n\t\ttimerStruct_t * volatile tmp_timer24;\n\t\ttimerStruct_t * volatile tmp_timer25;\n\t\ttimerStruct_t * volatile tmp_timer26;\n\t\ttimerStruct_t * volatile tmp_timer27;\n\t\ttimerStruct_t * volatile tmp_timer28;\n\t\ttimerStruct_t * volatile tmp_timer29;\n\t\ttimerStruct_t * volatile tmp_timer30;\n\t\ttimerStruct_t * vol", "CodeBleu_score": 7.221934560033591}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t *tmp = *list;\n\twhile (tmp != NULL) {\n\t\tif (tmp == timer) {\n\t\t\ttmp->next->prev = tmp->prev;\n\t\t\ttmp->prev->next = tmp->next;\n\t\t\tfree(tmp);\n\t\t\treturn true;\n\t\t}\n\t\ttmp = tmp->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 22.607004584619506}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\t\n\tstruct bsd_socket_info *bsd_socket;\n\t\n\tif(socket >= MAX_SOCKETS || socket < 0) {\n\t\t\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tbsd_socket = &bsd_sockets[socket];\n\t\n\tif(bsd_socket->state == NOT_A_SOCKET) {\n\t\t\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tbsd_socket->state = NOT_A_SOCKET;\n\t\n\tif(close(socket) == SOCK_ERR_NO_ERROR) {\n\t\t\n\t\treturn BSD_SUCCESS;\n\t}\n\t\n\treturn BSD_ERROR;\n}", "CodeBleu_score": 35.352421906831964}, {"code": "int BSD_close(int socket){\n\t\n\tstruct bsd_socket_info *bsd_socket = NULL;\n\n\tif ((bsd_socket = _bsd_find_socket(socket)) == NULL) {\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\tbsd_socket->state = NOT_A_SOCKET;\n\n\tif (close(socket) == -1) {\n\n\t\tswitch (errno) {\n\n\t\t\tcase EBADF:\n\n\t\t\t\terrno = ENOTSOCK;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\treturn BSD_SUCCESS;\n\n}", "CodeBleu_score": 43.110568454806554}, {"code": "int BSD_close(int socket){\n\t\n\tstruct bsd_socket_info *sock;\n\n\tsock = bsd_find_socket(socket);\n\n\tif (sock == NULL) {\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\tsock->state = NOT_A_SOCKET;\n\n\tint ret = close(socket);\n\n\tif (ret == SOCK_ERR_NO_ERROR) {\n\n\t\treturn BSD_SUCCESS;\n\n\t} else {\n\n\t\tswitch (ret) {\n\n\t\tcase SOCK_ERR_INVALID_ARG:\n\n\t\t\terrno = EBADF;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\terrno = EIO;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n}", "CodeBleu_score": 50.25029941154862}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t    int ret = listen(socket, backlog);\n\n    if (ret != 0) {\n        if (ret == -1) {\n            debug_printError(\"BSD: listen: socket error\");\n            return BSD_ERROR;\n        }\n        if (ret == -2) {\n            debug_printError(\"BSD: listen: not a socket\");\n            return BSD_ERROR;\n        }\n        if (ret == -3) {\n            debug_printError(\"BSD: listen: socket not bound\");\n            return BSD_ERROR;\n        }\n        if (ret == -4) {\n            debug_printError(\"BSD: listen: operation not supported\");\n            return BSD_ERROR;\n        }\n        if (ret == -5) {\n            debug_printError(\"BSD: listen: memory allocation failed\");\n            return BSD_ERROR;\n        }\n        if (ret == -6) {\n            debug_printError(\"BSD: listen: operation in progress\");\n            return BSD_ERROR;\n        }\n        if (ret == -7) {\n            debug_printError(\"BSD: listen: operation not permitted\");\n            return BSD_ERROR;\n        }\n        if (ret == -8) {\n            debug_printError(\"BSD: listen: queue length exceeded\");\n            return BSD_ERROR;\n        }\n        if (ret == -9) {\n            debug_printError(\"BSD: listen: protocol error\");\n            return BSD_ERROR;\n        }\n        if (ret == -10) {\n            debug_printError(\"BSD: listen: not supported\");\n            return BSD_ERROR;\n        }\n        if (ret == -11) {\n            debug_printError(\"BSD: listen: bad address\");\n            return BSD_ERROR;\n        }\n        if (ret == -12) {\n            debug_printError(\"BSD: listen: operation already in progress\");\n            return BSD_ERROR;\n        }\n        if (ret == -13) {\n            debug_printError(\"BSD: listen: operation now in progress\");\n            return BSD_ERROR;\n        }\n        if (ret ==", "CodeBleu_score": 19.38473895270996}, {"code": "int BSD_listen(int socket, int backlog){\n\t\n\tint ret = listen(socket, backlog);\n\n\tif (ret == SOCK_ERR_NO_ERROR) {\n\n\t\treturn BSD_SUCCESS;\n\n\t} else {\n\n\t\tswitch (ret) {\n\n\t\tcase SOCK_ERR_INVALID_ARG:\n\n\t\t\tdebug_printError(\"BSD: Invalid argument.\");\n\n\t\t\tbreak;\n\n\t\tcase SOCK_ERR_INVALID:\n\n\t\t\tdebug_printError(\"BSD: Socket is not bound or not in listen state.\");\n\n\t\t\tbreak;\n\n\t\tcase SOCK_ERR_ADDR_ALREADY_IN_USE:\n\n\t\t\tdebug_printError(\"BSD: Socket is already listening.\");\n\n\t\t\tbreak;\n\n\t\tcase SOCK_ERR_MAX_TCP_SOCK:\n\n\t\t\tdebug_printError(\"BSD: Exceeded max number of TCP sockets.\");\n\n\t\t\tbreak;\n\n\t\tcase SOCK_ERR_MAX_UDP_SOCK:\n\n\t\t\tdebug_printError(\"BSD: Exceeded max number of UDP sockets.\");\n\n\t\t\tbreak;\n\n\t\tcase SOCK_ERR_INVALID_SOCKET:\n\n\t\t\tdebug_printError(\"BSD: Socket is not a valid socket.\");\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tdebug_printError(\"BSD: Unknown error.\");\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n}", "CodeBleu_score": 42.058811476783234}, {"code": "int BSD_listen(int socket, int backlog){\n\t\n    int ret = listen(socket, backlog);\n\n    if (ret == SOCK_ERR_NO_ERROR) {\n\n        return BSD_SUCCESS;\n\n    } else {\n\n        BSD_SetErrno(ret);\n\n        return BSD_ERROR;\n\n    }\n\n}", "CodeBleu_score": 26.816568597081634}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\n    struct sockaddr_in6 sock_addr;\n\n    socklen_t sock_addrlen = sizeof(sock_addr);\n\n    int ret = -1;\n\n    if (socket < 0) {\n\n        errno = EBADF;\n\n        return ret;\n    }\n\n    if (addr == NULL) {\n\n        errno = EFAULT;\n\n        return ret;\n    }\n\n    if (addrlen == NULL) {\n\n        errno = EFAULT;\n\n        return ret;\n    }\n\n    if (*addrlen < sizeof(struct bsd_sockaddr)) {\n\n        errno = EINVAL;\n\n        return ret;\n    }\n\n    if (addr->sa_family == BSD_AF_INET) {\n\n        if (*addrlen < sizeof(struct bsd_sockaddr_in)) {\n\n            errno = EINVAL;\n\n            return ret;\n        }\n\n        ret = accept(socket, (struct sockaddr *) &sock_addr, &sock_addrlen);\n\n        if (ret < 0) {\n\n            errno = EBADF;\n\n            return ret;\n        }\n\n        struct bsd_sockaddr_in *bsd_sock_addr = (struct bsd_sockaddr_in *) addr;\n\n        bsd_sock_addr->sin_family = BSD_AF_INET;\n\n        bsd_sock_addr->sin_port = sock_addr.sin6_port;\n\n        memcpy(&bsd_sock_addr->sin_addr, &sock_addr.sin6_addr, sizeof(struct in_addr));\n\n        *addrlen = sizeof(struct bsd_sockaddr_in);\n\n    } else if (addr->sa_family == BSD_AF_INET6) {\n\n        if (*addrlen < sizeof(struct bsd_sockaddr_in6)) {\n\n            errno = EINVAL;\n\n            return ret;\n        }\n\n        ret = accept(socket, (struct sockaddr *) &sock_addr, &sock_addrlen);\n\n", "CodeBleu_score": 45.842396557391815}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\n\tstruct sockaddr temp_addr;\n\n\tint ret = 0;\n\n\tif (addr == NULL || addrlen == NULL) {\n\n\t\treturn SOCK_ERR_INVAL;\n\n\t}\n\n\tif ((ret = accept(socket, &temp_addr, (uint8_t *) addrlen)) < 0) {\n\n\t\treturn ret;\n\n\t}\n\n\tif (temp_addr.sa_family == AF_INET) {\n\n\t\tstruct sockaddr_in *in_addr = (struct sockaddr_in *) &temp_addr;\n\n\t\taddr->sa_family = BSD_AF_INET;\n\n\t\taddr->sa_data[0] = (uint8_t) (in_addr->sin_port >> 8);\n\n\t\taddr->sa_data[1] = (uint8_t) (in_addr->sin_port & 0xFF);\n\n\t\tmemcpy(&addr->sa_data[2], (uint8_t *) &in_addr->sin_addr, 4);\n\n\t} else {\n\n\t\treturn SOCK_ERR_INVAL;\n\n\t}\n\n\treturn ret;\n\n}", "CodeBleu_score": 39.273502112143476}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\n    struct sockaddr_in local_addr;\n    socklen_t local_addrlen = sizeof(local_addr);\n    int ret = -1;\n\n    if (addr->sa_family == AF_INET) {\n        ret = accept(socket, (struct sockaddr *) &local_addr, &local_addrlen);\n        if (ret < 0) {\n            BSD_SetErrCode(BSD_E_SOC_ACCEPT);\n        } else {\n            addr->sa_family = local_addr.sin_family;\n            addr->sa_data[0] = (uint8_t) (local_addr.sin_addr.s_addr);\n            addr->sa_data[1] = (uint8_t) (local_addr.sin_addr.s_addr >> 8);\n            addr->sa_data[2] = (uint8_t) (local_addr.sin_addr.s_addr >> 16);\n            addr->sa_data[3] = (uint8_t) (local_addr.sin_addr.s_addr >> 24);\n            addr->sa_data[4] = (uint8_t) (local_addr.sin_port);\n            addr->sa_data[5] = (uint8_t) (local_addr.sin_port >> 8);\n            *addrlen = sizeof(struct bsd_sockaddr);\n        }\n    } else {\n        BSD_SetErrCode(BSD_E_SOC_AF);\n    }\n\n    return ret;\n}", "CodeBleu_score": 37.667179525301655}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\n    /* Retrieve the current time in UNIX format. */\n\n    time_t currentTime = getTimeFromNTPServer();\n\n    /* Check if the time is valid. */\n\n    if (currentTime != 0) {\n\n        /* Update the JWT with the current time offset. */\n\n        updateJWTTimeOffset(currentTime);\n\n        /* Initiate the MQTT connection. */\n\n        MQTT_Connect();\n\n        /* Set a flag to send an MQTT SUBSCRIBE packet once the connection is established. */\n\n        sendSubscribePacket = true;\n\n        /* Print a debug message indicating the connection attempt. */\n\n        debug_printer(SEVERITY_NONE, LEVEL_NORMAL, \"Connecting to the MQTT broker...\");\n\n    } else {\n\n        /* Print a debug message indicating that the current time is invalid. */\n\n        debug_printer(SEVERITY_LOW, LEVEL_NORMAL, \"Current time is invalid.\");\n\n    }\n\n}", "CodeBleu_score": 47.011037520663365}, {"code": "static void connectMQTT(){\n\t    uint32_t unixTime = 0;\n    if (getUnixTime(&unixTime) != 0) {\n        debug_printer(SEVERITY_HIGH, LEVEL_ERROR, \"Failed to retrieve UNIX time\");\n        return;\n    }\n    if (updateJWT(unixTime) != 0) {\n        debug_printer(SEVERITY_HIGH, LEVEL_ERROR, \"Failed to update JWT\");\n        return;\n    }\n    if (mqtt_connect(MQTT_BROKER_HOSTNAME, MQTT_BROKER_PORT, MQTT_BROKER_TLS_ENABLED, 0) != MQTT_CODE_SUCCESS) {\n        debug_printer(SEVERITY_HIGH, LEVEL_ERROR, \"Failed to connect to MQTT broker\");\n        return;\n    }\n    debug_printer(SEVERITY_MEDIUM, LEVEL_INFO, \"Connecting to MQTT broker\");\n    mqtt_set_publish_packet_available(true);\n}", "CodeBleu_score": 34.671671262772605}, {"code": "static void connectMQTT(){\n\t\n    uint32_t currentUnixTime = 0;\n\n    if (getCurrentUnixTime(&currentUnixTime)) {\n\n        updateJWTTime(currentUnixTime);\n\n        mqtt_connect();\n\n        debug_printInfo(\"MQTT: Connecting to %s\", CLOUD_ENDPOINT);\n\n        mqtt_set_publish_flag(true);\n\n    }\n\n}", "CodeBleu_score": 20.486651326449}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\n    debug_printer(LOG_LEVEL_DEBUG, \"Disconnecting from cloud service...\");\n\n    if (MQTT_GetConnectionState() == CONNECTED) {\n\n        MQTT_Disconnect(MQTT_GetClientConnectionInfo());\n\n    }\n\n}", "CodeBleu_score": 79.46806299826177}, {"code": "void CLOUD_disconnect(void){\n\t\n\tDEBUG_PRINT(\"[CLOUD] Disconnecting from cloud service\\r\n\");\n\n\tif (MQTT_GetConnectionState() == CONNECTED) {\n\n\t\tMQTT_Disconnect();\n\t}\n}", "CodeBleu_score": 59.047558695298875}, {"code": "void CLOUD_disconnect(void){\n\t    debug_printer(LOG_LEVEL_DEBUG, \"Disconnecting from cloud service...\");\n    if (MQTT_GetConnectionState() == CONNECTED) {\n        MQTT_Disconnect();\n    }\n}", "CodeBleu_score": 65.17670507191215}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    // if the user provided new credentials, use them to connect to the AP\n    if (passed_wifi_creds == 1) {\n        // if the credentials are valid, connect to the AP\n        if (wifi_connect(wifi_creds.ssid, wifi_creds.auth_type, wifi_creds.password, wifi_creds.ssid_length, wifi_creds.password_length) == M2M_SUCCESS) {\n            return true;\n        }\n        // if the credentials are invalid, log an error message and return false\n        else {\n            debug_printError(\"ERROR: Failed to connect to AP with new credentials.\");\n            return false;\n        }\n    }\n    // if the user did not provide new credentials, connect to the AP using the default credentials\n    else {\n        // if the default credentials are valid, connect to the AP\n        if (wifi_connect(DEFAULT_SSID, DEFAULT_AUTH_TYPE, DEFAULT_PASSWORD, DEFAULT_SSID_LENGTH, DEFAULT_PASSWORD_LENGTH) == M2M_SUCCESS) {\n            return true;\n        }\n        // if the default credentials are invalid, log an error message and return false\n        else {\n            debug_printError(\"ERROR: Failed to connect to AP with default credentials.\");\n            return false;\n        }\n    }\n}", "CodeBleu_score": 37.67144498616699}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n    if (passed_wifi_creds == 1) {\n\n        // Connect to the specified Wi-Fi access point.\n        if (M2M_SUCCESS != m2m_wifi_connect((char *) wifi_ssid, strlen(wifi_ssid), wifi_auth_type, (char *) wifi_pass,\n                                            strlen(wifi_pass), 0)) {\n\n            debug_printError(\"WIFI: Failed to connect to AP\");\n\n            return false;\n\n        }\n\n    } else {\n\n        // Connect to the default Wi-Fi access point.\n        if (M2M_SUCCESS != m2m_wifi_default_connect()) {\n\n            debug_printError(\"WIFI: Failed to connect to AP\");\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}", "CodeBleu_score": 48.91374320722027}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n    bool retval = false;\n\n    tstrWifiInitParam param;\n\n    /* Initialize Wi-Fi parameters structure. */\n    memset(&param, 0, sizeof(tstrWifiInitParam));\n\n    /* Initialize Wi-Fi driver with data and status callbacks. */\n    param.pfAppWifiCb = wifi_cb;\n\n    if (passed_wifi_creds == 1) {\n\n        /* Connect to the specified AP. */\n        param.pfAppWifiCb = wifi_cb;\n\n        param.strEthInitParam.pfAppEthCb = ethernet_cb;\n\n        /* Initialize the BSP. */\n        nm_bsp_init();\n\n        /* Initialize Wi-Fi driver with data and status callbacks. */\n        if (M2M_SUCCESS != m2m_wifi_init(&param)) {\n\n            printf(\"main: m2m_wifi_init call error!\\r", "CodeBleu_score": 38.78422907147705}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t    try {\n        /**\n         * Create a client and send a GraphQL query to retrieve sensor data.\n         */\n        const client = new AWSAppSyncClient({\n            url: awsconfig.aws_appsync_graphqlEndpoint,\n            region: awsconfig.aws_appsync_region,\n            auth: {\n                type: awsconfig.aws_appsync_authenticationType,\n                apiKey: awsconfig.aws_appsync_apiKey,\n            },\n        });\n        const response = await client.query({\n            query: GetSensors,\n        });\n        console.log(\"Retrieved sensor data: \", response);\n        /**\n         * If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker.\n         */\n        if (response.data.getSensors) {\n            console.log(\"Retrieved sensors: \", response.data.getSensors);\n            for (const sensor of response.data.getSensors) {\n                /**\n                 * Create a marker and add it to the map.\n                 */\n                const marker = new maplibregl.Marker()\n                    .setLngLat([sensor.longitude, sensor.latitude])\n                    .addTo(map);\n                /**\n                 * Add a popup to the marker with the sensor's name.\n                 */\n                marker.setPopup(\n                    new maplibregl.Popup({ offset: 25 }).setHTML(sensor.name)\n                );\n            }\n        }\n    } catch (error) {\n        console.error(\"Error retrieving sensor data: \", error);\n    }\n}", "CodeBleu_score": 42.666126682249335}, {"code": "async function DisplaySensors(map){\n\t  /**\n   * The function \"GetSensors\" asynchronously retrieves a list of sensors.", "CodeBleu_score": 3.168713460023978}, {"code": "async function DisplaySensors(map){\n\t    /**\n     * The function \"getSensors\" asynchronously retrieves a list of sensors.", "CodeBleu_score": 3.1842612381221587}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor';\n    marker.style.background = '#3bb2d0';\n    marker.style.width = '20px';\n    marker.style.height = '20px';\n    marker.style.border = '2px solid #E6E6FA';\n    marker.style.borderRadius = '50%';\n    marker.style.cursor = 'pointer';\n    return marker;\n}", "CodeBleu_score": 45.11765611664419}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.backgroundColor = 'white';\n    marker.style.border = '3px solid #505050';\n    return marker;\n}", "CodeBleu_score": 46.32286903891607}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.background = '#fff';\n  marker.style.border = '2px solid #333';\n  return marker;\n}", "CodeBleu_score": 43.71209551884277}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n\n    module_path = f\"homeassistant.components.auth.mfa_modules.{module_name}\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError as err:\n        logging.getLogger(__name__).error(f\"Unable to load MFA module {module_name}: {err}\")\n        raise HomeAssistantError(f\"Unable to load MFA module {module_name}: {err}\")\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await requirements.async_process_requirements(hass, module_name, module.REQUIREMENTS)\n\n    if not hasattr(module, \"setup_flow\"):\n        logging.getLogger(__name__).error(f\"MFA module {module_name} has no setup_flow() method\")\n        raise HomeAssistantError(f\"MFA module {module_name} has no setup_flow() method\")\n\n    if not hasattr(module, \"async_setup_flow\"):\n        logging.getLogger(__name__).error(f\"MFA module {module_name} has no async_setup_flow() method\")\n        raise HomeAssistantError(f\"MFA module {module_name} has no async_setup_flow() method\")\n\n    return module\n\n", "CodeBleu_score": 42.11483114346042}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.mfa_module.{module_name}\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError as err:\n        logging.exception(err)\n        raise HomeAssistantError(\n            f\"Unable to import {module_name} MFA module. Please ensure the module is installed.\"\n        )\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module_name, module.REQUIREMENTS\n        )\n    if not hasattr(module, \"setup_flow\"):\n        raise HomeAssistantError(\n            f\"MFA module {module_name} is missing setup_flow function.\"\n        )\n    if not hasattr(module, \"setup_flow\"):\n        raise HomeAssistantError(\n            f\"MFA module {module_name} is missing setup_flow function.\"\n        )\n    return module\n\n", "CodeBleu_score": 43.46082673466689}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.auth.mfa_module.{module_name}\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError as err:\n        logging.exception(err)\n        raise HomeAssistantError(f\"Unable to import {module_path}\")\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await requirements.async_process_requirements(module_path, module.REQUIREMENTS)\n    if not hasattr(module, \"setup_mfa\"):\n        raise HomeAssistantError(f\"{module_path} does not have a setup_mfa function\")\n    return module\n\n", "CodeBleu_score": 35.433784151311876}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for user in self.data:\n        if user[\"user_id\"] == user_id:\n            user[\"pin\"] = pin\n            self.data.update({\"data\": self.data})\n            return\n    self.data.append({\"user_id\": user_id, \"pin\": pin})\n    self.data.update({\"data\": self.data})\n\n", "CodeBleu_score": 53.09001534898818}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for user in self.data[\"users\"]:\n        if user[\"user_id\"] == user_id:\n            user[\"pin\"] = pin\n            return\n    self.data[\"users\"].append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 57.55881794032523}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    user = await self.async_get_user(user_id)\n    if user is None:\n        self.data.append({\"user_id\": user_id, \"pin\": pin})\n    else:\n        user[\"pin\"] = pin\n    await self.async_save()\n    return {\"success\": True, \"data\": {\"pin\": pin}}\n\n", "CodeBleu_score": 42.39886846207499}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._lock:\n        if self._loaded:\n            return\n        data = await self._store.async_load()\n        self._data = OrderedDict()\n        if data is not None:\n            for key, value in data.items():\n                self._data[key] = self._setting_cls(value)\n        self._loaded = True\n\n", "CodeBleu_score": 30.454343633846374}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._lock:\n        if self._loaded:\n            return\n        data = await self._store.async_load()\n        if data is None:\n            self._settings = OrderedDict()\n        else:\n            self._settings = OrderedDict(\n                (key, NotifySetting(key, **value)) for key, value in data.items()\n            )\n        self._loaded = True\n\n", "CodeBleu_score": 33.22053196045172}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._settings is not None:\n            return\n\n        data = await self._store.async_load()\n\n        if data is None:\n            self._settings = OrderedDict()\n            return\n\n        self._settings = OrderedDict()\n        for user_id, settings in data.items():\n            self._settings[user_id] = NotifySetting(**settings)\n\n", "CodeBleu_score": 40.719089367469515}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_settings()\n    settings = self.get_settings(user_id)\n    if settings is None:\n        return False\n    return await self.hass.async_add_executor_job(\n        self.validate_otp, user_input[\"otp\"], settings\n    )\n\n", "CodeBleu_score": 43.65649194496302}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load(user_id)\n    user_settings = self.get(user_id)\n    if user_settings is None:\n        return False\n    return await self.hass.async_add_executor_job(self.validate_otp, user_settings, user_input)\n\n", "CodeBleu_score": 46.19080692781646}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if not self.user_settings:\n        await self.async_load_user_settings()\n    if not self.user_settings:\n        return False\n    if user_id not in self.user_settings:\n        return False\n    settings = self.user_settings[user_id]\n    if settings.get(CONF_INCLUDE):\n        if not self.hass.services.has_service(\n            \"notify\", settings[CONF_INCLUDE]\n        ) and not self.hass.services.has_service(\n            \"persistent_notification\", settings[CONF_INCLUDE]\n        ):\n            return False\n    if settings.get(CONF_EXCLUDE):\n        if not self.hass.services.has_service(\n            \"notify\", settings[CONF_EXCLUDE]\n        ) and not self.hass.services.has_service(\n            \"persistent_notification\", settings[CONF_EXCLUDE]\n        ):\n            return False\n    try:\n        return await self.hass.async_add_executor_job(\n            self.validate_otp, user_input[\"otp\"], settings\n        )\n    except ServiceNotFound:\n        return False\n\n", "CodeBleu_score": 41.60778975630047}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_entries.get(entity_id)\n    if not entity_entry:\n        return None\n\n    device_entry = perm_lookup.device_entries.get(entity_entry.device_id)\n    if not device_entry:\n        return None\n\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 57.713982626411145}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entities.get(entity_id)\n    if entity is None:\n        return None\n\n    device_id = entity[\"device_id\"]\n    device = perm_lookup.devices.get(device_id)\n    if device is None:\n        return None\n\n    area_id = device[\"area_id\"]\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 58.09641014706307}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_id = entity_entry.device_id\n    if device_id is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 67.62416786281416}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n\n    for policy in policies:\n        for category, contents in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = {}\n\n                for key, value in contents.items():\n                    merged_policy[category][key] = value\n\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 51.27552092010147}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    new_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, permissions in policy.items():\n            if category not in seen_categories:\n                new_policy[category] = permissions\n                seen_categories.add(category)\n    return cast(PolicyType, new_policy)\n", "CodeBleu_score": 49.377014779349835}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, permissions in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = permissions\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 49.06363212553172}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(\n            f\"homeassistant.auth.{provider}\", hass.config.skip_pip\n        )\n    except ImportError as err:\n        logging.getLogger(__name__).exception(err)\n        raise HomeAssistantError(\n            f\"Unable to load auth provider {provider}. Make sure all dependencies for it are installed or disable it\"\n        ) from err\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        module.CONFIG_SCHEMA = vol.Schema({})\n    if not hasattr(module, \"SCHEMA\"):\n        module.SCHEMA = vol.Schema({})\n    if not hasattr(module, \"STEPS\"):\n        module.STEPS = []\n    if not hasattr(module, \"DATA_SCHEMA\"):\n        module.DATA_SCHEMA = vol.Schema({})\n    if not hasattr(module, \"DATA_SCHEMA_BASE\"):\n        module.DATA_SCHEMA_BASE = vol.Schema({})\n    if not hasattr(module, \"DATA_SCHEMA_STATE\"):\n        module.DATA_SCHEMA_STATE = vol.Schema({})\n    if not hasattr(module, \"DATA_SCHEMA_META\"):\n        module.DATA_SCHEMA_META = vol.Schema({})\n    if not hasattr(module, \"DATA_SCHEMA_USER\"):\n        module.DATA_SCHEMA_USER = vol.Schema({})\n    if not hasattr(module, \"DATA_SCHEMA_GROUP\"):\n        module.DATA_SCHEMA_GROUP = vol.Schema({})\n    if not hasattr(module, \"DATA_SCHEMA_CREDENTIALS\"):\n        module.DATA_SCHEMA_CREDENTIALS = vol.Schema({})\n    if not hasattr(module, \"DATA_SCHEMA_MFA_MODULE\"):\n        module.DATA_SCHEMA_MFA_MODULE = vol.Schema({})\n    if not hasattr(module, \"DATA_SCHEMA_MFA_MODULE_OPTIONS", "CodeBleu_score": 35.06877568558055}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    module = await async_import_module(f\"homeassistant.auth.{provider}\")\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider} has requirements but no config schema\"\n        )\n    if not hasattr(module, \"async_setup\"):\n        raise HomeAssistantError(f\"Auth provider {provider} has requirements but no setup\")\n    if not hasattr(module, \"async_setup_entry\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider} has requirements but no setup entry\"\n        )\n    if not hasattr(module, \"async_unload_entry\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider} has requirements but no unload entry\"\n        )\n    if not hasattr(module, \"async_remove_entry\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider} has requirements but no remove entry\"\n        )\n    if not hasattr(module, \"async_create_flow\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider} has requirements but no create flow\"\n        )\n    if not hasattr(module, \"async_get_data\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider} has requirements but no get data\"\n        )\n    if not hasattr(module, \"async_get_options\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider} has requirements but no get options\"\n        )\n    if not hasattr(module, \"async_update_options\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider} has requirements but no update options\"\n        )\n    if not hasattr(module, \"async_get_users\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider} has requirements but no get users\"\n        )\n    if not hasattr(module, \"async_get_user\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider}", "CodeBleu_score": 26.83652176377489}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(\n            \"homeassistant.auth.providers.{}\".format(provider)\n        )\n    except ImportError as err:\n        logging.getLogger(__name__).exception(\n            \"Error importing auth provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Unable to find auth provider {provider}. Check your config.\"\n        ) from err\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        logging.getLogger(__name__).exception(\n            \"Auth provider %s is missing CONFIG_SCHEMA\", provider\n        )\n        raise HomeAssistantError(f\"Integration error loading auth provider {provider}\")\n    if not hasattr(module, \"STORAGE_KEY\"):\n        logging.getLogger(__name__).exception(\n            \"Auth provider %s is missing STORAGE_KEY\", provider\n        )\n        raise HomeAssistantError(f\"Integration error loading auth provider {provider}\")\n    if not hasattr(module, \"STORAGE_VERSION\"):\n        logging.getLogger(__name__).exception(\n            \"Auth provider %s is missing STORAGE_VERSION\", provider\n        )\n        raise HomeAssistantError(f\"Integration error loading auth provider {provider}\")\n    if not hasattr(module, \"async_credential_flow\"):\n        logging.getLogger(__name__).exception(\n            \"Auth provider %s is missing async_credential_flow\", provider\n        )\n        raise HomeAssistantError(f\"Integration error loading auth provider {provider}\")\n    if not hasattr(module, \"async_get_data\"):\n        logging.getLogger(__name__).exception(\n            \"Auth provider %s is missing async_get_data\", provider\n        )\n        raise HomeAssistantError(f\"Integration error loading auth provider {provider}\")\n    if not hasattr(module, \"async_get_or_create_credentials\"):\n        logging.getLogger(__name__).exception(\n            \"Auth provider %s is missing async_get_or_create_credentials\", provider\n        )\n        raise HomeAssistantError(f\"Integr", "CodeBleu_score": 33.17998879682781}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    self.users = await self._store.async_load()\n    if self.users is None:\n        self.users = {}\n    for user in self.users.values():\n        if not user[CONF_ID].islower():\n            user_id = user[CONF_ID].lower()\n            user[CONF_ID] = user_id\n            self.users[user_id] = user\n\n", "CodeBleu_score": 23.919683362504216}, {"code": "async def async_load(self) -> None\n\t\n    self._store = Store(self.hass, 1, f\"{self.suggested_id}_users\")\n    data = await self._store.async_load()\n    if data is None:\n        self.users = []\n        self.async_schedule_save()\n        return\n    self.users = [User(self, **user) for user in data]\n    self.async_schedule_save()\n\n", "CodeBleu_score": 30.097848771467213}, {"code": "async def async_load(self) -> None\n\t\n    self._users = await self._store.async_load()\n    if self._users is None:\n        self._users = {}\n\n", "CodeBleu_score": 17.489338457472673}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.data.values():\n        if user[CONF_ID] == username:\n            hashed = base64.b64decode(user[\"password_hash\"])\n            if bcrypt.checkpw(password.encode(), hashed):\n                return\n            raise InvalidAuth\n    raise InvalidAuth\n\n", "CodeBleu_score": 38.227741067726775}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users.values():\n        if user.username == username:\n            password_hash = base64.b64decode(user.password_hash)\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n            raise InvalidAuth()\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth()\n\n", "CodeBleu_score": 34.95949762302409}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    # Normalize the username\n    username = username.lower()\n\n    # Initialize a dummy hash to prevent timing attacks\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n\n    # Iterate through all users\n    for user in self.users.values():\n        # Check if the username matches\n        if user[CONF_ID] == username:\n            # Decode the stored password hash\n            password_hash = base64.b64decode(user[\"password_hash\"])\n            # Compare the password with the stored hash\n            if bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                # Password is correct\n                return\n\n            # Password is incorrect\n            raise ir.InvalidAuth\n\n    # User not found\n    bcrypt.checkpw(b\"\", dummy_hash)\n    raise ir.InvalidAuth\n\n", "CodeBleu_score": 39.49740021921567}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.async_normalize_username(username)\n    if username in self.users:\n        self.users.pop(username)\n    else:\n        raise InvalidUser(f\"User not found: {username}\")\n\n", "CodeBleu_score": 24.84886890365823}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.async_normalize_username(username)\n    if username not in self.users:\n        raise ir.InvalidUser(ir.ERR_NOT_FOUND, \"User not found\")\n    self.users.pop(username)\n    self.async_schedule_save()\n\n", "CodeBleu_score": 26.68494791000414}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self._async_normalize_username(username)\n    user = self._async_get_user(username)\n    if not user:\n        raise InvalidUser(\n            f\"User not found: {username}\",\n            error_code=HomeAssistantError.ERR_NOT_FOUND,\n        )\n    self._store.async_delay_save(lambda: self._data.pop(user[CONF_ID]), 1)\n\n", "CodeBleu_score": 29.930862777893562}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        await self.async_load()\n    try:\n        del self._data[credentials.id]\n        await self.async_save(self._data)\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 42.356145004866605}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.initialized:\n        await self.async_initialize()\n    try:\n        del self.data[credentials.id]\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 43.52485490006216}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        await self.async_load()\n    try:\n        del self.data[credentials.id]\n        await self.async_save(self.data)\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 42.69127455919983}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n\n    # Calculate the timeout for each thread\n    timeout_per_thread = timeout / len(threads)\n\n    # Join each thread\n    joined = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident is None:\n                joined.add(thread)\n            else:\n                try:\n                    thread.join(timeout_per_thread)\n                except RuntimeError:\n                    # This exception is raised if the thread is already being joined.\n                    # In this case, the thread should be in the joined set.\n                    joined.add(thread)\n                if thread.is_alive():\n                    if log:\n                        logging.warning(\n                            \"Thread %s is still running after %s seconds. Attempting to interrupt it.\",\n                            thread.name,\n                            timeout_per_thread,\n                        )\n                    try:\n                        thread.interrupt()\n                    except RuntimeError:\n                        # This exception is raised if the thread is already being interrupted.\n                        # In this case, the thread should be in the joined set.\n                        joined.add(thread)\n                    if thread.is_alive():\n                        if log:\n                            logging.warning(\n                                \"Thread %s is still running after %s seconds. Attempting to raise SystemExit.\",\n                                thread.name,\n                                timeout_per_thread,\n                            )\n                        try:\n                            thread.raise_exception(SystemExit)\n                        except RuntimeError:\n                            # This exception is raised if the thread is already being interrupted.\n                            # In this case, the thread should be in the joined set.\n                            joined.add(thread)\n                        if thread.is_alive():\n                            if log:\n                                logging.warning(\n                                    \"Thread %s is still running after %s seconds. Giving up.\",\n                                    thread.name,\n                                    timeout_per_thread,\n                                )\n                    else:\n                        joined.add(thread)\n                else:\n                    joined.add(thread)\n        else:\n            joined.add(thread)\n\n    return joined", "CodeBleu_score": 37.91765333037507}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    # Calculate the timeout for each thread\n    now = time.time()\n    deadline = now + timeout\n    # Join each thread\n    joined = set()\n    for thread in threads:\n        # Calculate the timeout for the thread\n        if thread.ident is None:\n            # Thread is no longer alive\n            joined.add(thread)\n        else:\n            # Thread is alive\n            remaining = deadline - now\n            if remaining <= 0:\n                # Timeout has already expired\n                if log:\n                    logging.warning(\n                        f\"Timeout expired while waiting for thread {thread.name} ({thread.ident}) to finish\"\n                    )\n            else:\n                # Timeout has not expired\n                try:\n                    # Join the thread\n                    thread.join(remaining)\n                    if not thread.is_alive():\n                        # Thread has finished\n                        joined.add(thread)\n                    else:\n                        # Thread is still running\n                        if log:\n                            logging.warning(\n                                f\"Timeout expired while waiting for thread {thread.name} ({thread.ident}) to finish\"\n                            )\n                except:\n                    # An exception occurred while joining the thread\n                    if log:\n                        logging.error(\n                            f\"An exception occurred while waiting for thread {thread.name} ({thread.ident}) to finish\",\n                            exc_info=True,\n                        )\n        # Update the current time\n        now = time.time()\n    # Attempt to raise a SystemExit exception in any remaining threads\n    for thread in threads - joined:\n        # Attempt to raise a SystemExit exception in the thread\n        try:\n            # Send a SystemExit exception to the thread\n            thread.join(0)\n            if not thread.is_alive():\n                # Thread has finished\n                joined.add(thread)\n            else:\n                # Thread is still running\n                if log:\n                    logging.warning(\n                        f\"Unable to raise a SystemExit exception in thread {thread.name} ({thread.ident})\"\n                    )\n        except:\n            # An exception occurred while raising a SystemExit exception in", "CodeBleu_score": 36.74856347657837}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n\n    joined: set[Thread] = set()\n    start = time.time()\n    for thread in threads:\n        if not thread.is_alive() or thread.ident is None:\n            joined.add(thread)\n            continue\n        remaining = timeout - (time.time() - start)\n        if remaining <= 0:\n            break\n        thread.join(remaining)\n        if not thread.is_alive():\n            joined.add(thread)\n    if log:\n        for thread in threads - joined:\n            logging.error(f\"Thread {thread.name} is still running\")\n    for thread in threads - joined:\n        try:\n            thread.raise_exception(SystemExit)\n        except:\n            pass\n    return joined\n\n", "CodeBleu_score": 53.560666501843656}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    shutdown_timeout = 10\n    remaining_threads = [t for t in threading.enumerate() if t is not threading.current_thread() and t.daemon is False and t.is_alive()]\n    logging.info(f\"Shutting down {len(remaining_threads)} threads...\")\n    for thread in remaining_threads:\n        timeout = shutdown_timeout / len(remaining_threads)\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            logging.warning(f\"Failed to join thread {thread.name}\")\n\n", "CodeBleu_score": 36.847755486412076}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    shutdown_timeout = 5\n    main_thread = threading.main_thread()\n    remaining_threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not main_thread and not thread.daemon\n    ]\n    for thread in remaining_threads:\n        timeout = shutdown_timeout / len(remaining_threads)\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            logging.warning(\n                f\"Failed to join thread {thread.name} ({thread.ident}) within timeout of {timeout} seconds.\"\n            )\n\n", "CodeBleu_score": 39.91734116225088}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    shutdown_timeout = 10\n    threads = threading.enumerate()\n    non_daemon_threads = [t for t in threads if t.is_alive() and not t.daemon]\n    if len(non_daemon_threads) > 1:\n        timeout = shutdown_timeout / len(non_daemon_threads)\n        for t in non_daemon_threads:\n            try:\n                t.join(timeout)\n            except RuntimeError:\n                logging.warning(\n                    f\"Failed to join thread {t.name} with id {t.ident} during shutdown.\"\n                )\n\n", "CodeBleu_score": 29.3698587149814}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self._remaining_with_setup_started = remaining_with_setup_started\n        self.dispatch('on_setup_finished')\n\n", "CodeBleu_score": 44.94258733758624}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self._remaining_with_setup_started or self._remaining_with_setup_started_empty:\n        self._remaining_with_setup_started_empty = not self._remaining_with_setup_started\n        self.dispatch_async(remaining_with_setup_started=self._remaining_with_setup_started)\n\n", "CodeBleu_score": 45.96404397051521}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self.dispatch('on_setup_started', remaining_with_setup_started)\n        self._has_setup_started = True\n    else:\n        self._has_setup_started = False\n\n", "CodeBleu_score": 41.79283981628031}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Generate the Bluetooth content\n    generated_content = generate_bluetooth_content(integrations, config)\n    # If specific integrations are not being validated, read the current content of bluetooth.py\n    if config.specific_integrations:\n        current_content = read_current_bluetooth_content(config)\n    # If the generated content is not the same as the current content, add an error to the configuration\n    if generated_content != current_content:\n        config.add_error(\n            \"bluetooth.py is not up to date\",\n            \"Run 'python3 -m homeassistant --script check_config' to validate your configuration\",\n            \"https://www.home-assistant.io/integrations/bluetooth/#configuration-yaml-file\"\n        )\n        # If specific integrations are not being validated, add a fixable suggestion\n        if config.specific_integrations:\n            config.add_fixable_suggestion(\n                \"Update the content of bluetooth.py\",\n                \"Run 'python3 -m homeassistant --script check_config --fix' to automatically update the content of bluetooth.py\",\n                \"https://www.home-assistant.io/integrations/bluetooth/#configuration-yaml-file\"\n            )\n\n", "CodeBleu_score": 33.51968768009762}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.cache.bluetooth:\n        config.cache.bluetooth = generate(integrations, config)\n    if not config.validate_integrations:\n        with open(config.cache.path / \"bluetooth.py\") as file:\n            content = file.read()\n        if config.cache.bluetooth != content:\n            config.add_error(\n                \"bluetooth\",\n                \"Bluetooth integration is not up to date\",\n                \"Run script 'develop.py' to update bluetooth.py\",\n            )\n\n", "CodeBleu_score": 41.742774137109016}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.cache_dir.exists():\n        config.cache_dir.mkdir()\n    if not config.cache_dir.is_dir():\n        raise FileExistsError(f\"{config.cache_dir} is not a directory.\")\n\n    bluetooth_path = config.cache_dir / \"bluetooth.py\"\n    if not bluetooth_path.exists():\n        bluetooth_path.touch()\n    if not bluetooth_path.is_file():\n        raise FileExistsError(f\"{bluetooth_path} is not a file.\")\n\n    current_content = bluetooth_path.read_text(encoding=\"utf-8\")\n    generated_content = generate(integrations)\n\n    if current_content != generated_content:\n        config.add_error(\n            \"bluetooth.py is not up to date. Please run 'python3 -m homeassistant --script check_config' to fix.\",\n            fixable=True,\n            fix_it=lambda: bluetooth_path.write_text(generated_content, encoding=\"utf-8\"),\n        )\n", "CodeBleu_score": 43.54320269278582}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create a request body with the refresh token, app key, and app secret.\n\tbody := \"grant_type=refresh_token&refresh_token=\" + d.refreshToken + \"&client_id=\" + d.appKey + \"&client_secret=\" + d.appSecret\n\n\t// Create a new request using http.NewRequest.\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"refreshToken, error with http.NewRequest: %v\", err)\n\t}\n\n\t// Add \"Content-Type\" and \"Content-Length\" headers to the request.\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Add(\"Content-Length\", string(len(body)))\n\n\t// Send the request to the Dropbox OAuth2 token endpoint.\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"refreshToken, error with http.DefaultClient.Do: %v\", err)\n\t}\n\n\t// Defer the closing of the body.\n\tdefer resp.Body.Close()\n\n\t// If the response code is 200, parse the access token from the response body.\n\tif resp.StatusCode == 200 {\n\t\t// Call ParseDropboxToken to parse the access token from the response body.\n\t\ttoken, err := parseDropboxToken(resp.Body)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"refreshToken, error with parseDropboxToken: %v\", err)\n\t\t}\n\n\t\t// Update the access token.\n\t\td.accessToken = token\n\t} else {\n\t\t// If the response code is not 200, log the response.\n\t\tlogger.Error(\"refreshToken, response:\", zap.Any(\"resp\", resp))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.966383914398754}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tclient := resty.New()\n\tresp, err := client.R().\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"client_id\":     d.ClientID,\n\t\t\t\"client_secret\": d.ClientSecret,\n\t\t}).\n\t\tSetResult(&base.TokenResp{}).\n\t\tPost(base.DropboxOauth2TokenURL)\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to refresh token: %s\", err)\n\t}\n\n\tif resp.IsError() {\n\t\treturn fmt.Errorf(\"failed to refresh token: %s\", resp.String())\n\t}\n\n\tresult := resp.Result().(*base.TokenResp)\n\td.AccessToken = result.AccessToken\n\td.RefreshToken = result.RefreshToken\n\n\treturn nil\n}", "CodeBleu_score": 50.56081195510702}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create a Resty Client\n\tclient := resty.New()\n\n\t// Set Headers for the request\n\tclient.SetHeaders(map[string]string{\n\t\t\"Content-Type\": \"application/x-www-form-urlencoded\",\n\t})\n\n\t// Set Form data for the request\n\tresp, err := client.R().\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"client_id\":     d.AppKey,\n\t\t\t\"client_secret\": d.AppSecret,\n\t\t}).\n\t\tPost(\"https://api.dropboxapi.com/oauth2/token\")\n\n\tif err != nil {\n\t\tlogger.Error(\"refreshToken\",zap.Any(\"resp\", resp.String()))\n\t\treturn fmt.Errorf(\"Could not refresh token: %v\", err)\n\t}\n\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"refreshToken\",zap.Any(\"resp\", resp.String()))\n\t\treturn fmt.Errorf(\"Could not refresh token: %v\", resp.Status())\n\t}\n\n\t// Update the access token\n\td.AccessToken = resp.Body()\n\n\treturn nil\n}", "CodeBleu_score": 51.93920458916808}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// \u521b\u5efa\u8bf7\u6c42\n\treq := d.client.R()\n\t// \u8bbe\u7f6e\u8bf7\u6c42\u65b9\u5f0f\n\treq.SetMethod(method)\n\t// \u8bbe\u7f6e\u8bf7\u6c42\u5730\u5740\n\treq.SetContext(context.Background())\n\t// \u8bbe\u7f6e\u8bf7\u6c42\u5934\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\t// \u8bbe\u7f6e\u8bf7\u6c42\u53c2\u6570\n\treq.SetQueryParams(map[string]string{\n\t\t\"supportsAllDrives\": \"true\",\n\t})\n\t// \u8bbe\u7f6e\u56de\u8c03\u51fd\u6570\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\t// \u53d1\u9001\u8bf7\u6c42\n\tvar err error\n\tvar respBody []byte\n\tvar respCode int\n\tfor i := 0; i < 3; i++ {\n\t\tresp, err = req.Execute(method, url)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"request error\", zap.Any(\"err\", err))\n\t\t\treturn nil, err\n\t\t}\n\t\trespBody = resp.Body()\n\t\trespCode = resp.StatusCode()\n\t\tif respCode == 401 {\n\t\t\t// \u5237\u65b0Token\n\t\t\tif err = d.RefreshToken(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tif respCode != 200 {\n\t\treturn nil, fmt.Errorf(\"response code %d\", respCode)\n\t}\n\tif resp != nil {\n\t\tif respBody != nil {\n\t\t\tif respStr := string(respBody); respStr != \"\" {\n\t\t\t\tlogger.Info(\"response\", zap.String(\"body\", respStr))\n\t\t\t}\n\t\t}\n\t}\n\tif resp != nil && respBody != nil && resp != nil {\n\t\tif respStr := string(respBody); respStr != \"\" {\n\t\t\tlogger.Info(\"response\", zap.String(\"body\", respStr))\n\t\t}\n\t}\n\t// \u8bbe\u7f6e\u54cd\u5e94\u7ed3\u679c\n", "CodeBleu_score": 48.90219686183309}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar err error\n\tvar respBody []byte\n\tvar req *resty.Request\n\tvar r *resty.Response\n\tvar ctx context.Context\n\tvar cancel context.CancelFunc\n\tvar errCode int\n\tvar errMsg string\n\tvar errResp []byte\n\n\tfor i := 1; i <= 3; i++ {\n\t\treq = d.client.R()\n\t\tif callback != nil {\n\t\t\tcallback(req)\n\t\t}\n\t\tif resp != nil {\n\t\t\treq.SetResult(resp)\n\t\t}\n\t\tif method == \"\" || method == \"GET\" {\n\t\t\tr, err = req.Get(url)\n\t\t} else if method == \"POST\" {\n\t\t\tr, err = req.Post(url)\n\t\t} else if method == \"DELETE\" {\n\t\t\tr, err = req.Delete(url)\n\t\t} else if method == \"PATCH\" {\n\t\t\tr, err = req.Patch(url)\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"unsupported method: %s\", method)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif r.IsError() {\n\t\t\terrCode = r.StatusCode()\n\t\t\terrMsg = r.Status()\n\t\t\terrResp = r.Body()\n\t\t\tif errCode == 401 {\n\t\t\t\t// token expired, refresh it and retry\n\t\t\t\tif d.token.RefreshToken == \"\" {\n\t\t\t\t\treturn nil, fmt.Errorf(\"token expired and refresh token not available\")\n\t\t\t\t}\n\t\t\t\terr := d.RefreshToken(nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif errCode == 403 {\n\t\t\t\t// check if it's because of rate limit\n\t\t\t\tif d.checkRateLimit(errResp) {\n\t\t\t", "CodeBleu_score": 51.079727307855}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tclient := resty.New()\n\treq := client.R()\n\treq.SetContext(context.Background())\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetHeader(\"Accept\", \"application/json\")\n\treq.SetHeader(\"Content-Type\", \"application/json\")\n\treq.SetHeader(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tvar err error\n\tvar respData []byte\n\tvar respCode int\n\tfor i := 0; i < 3; i++ {\n\t\tswitch method {\n\t\tcase \"GET\":\n\t\t\tresp, err = req.Get(url)\n\t\tcase \"POST\":\n\t\t\tresp, err = req.Post(url)\n\t\tcase \"PUT\":\n\t\t\tresp, err = req.Put(url)\n\t\tcase \"DELETE\":\n\t\t\tresp, err = req.Delete(url)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unsupported method: %s\", method)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trespCode = resp.StatusCode()\n\t\trespData = resp.Body()\n\t\tif respCode == 401 {\n\t\t\tif err := d.refreshToken(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tif respCode != 200 {\n\t\treturn nil, fmt.Errorf(\"response code: %d\", respCode)\n\t}\n\tif resp != nil {\n\t\tif err := utils.Json.Unmarshal(respData, resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn resp", "CodeBleu_score": 48.622000684643965}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size.\n\tchunkSize := int(d.ChunkSize)\n\t// Create a buffer to read from the stream.\n\tbuf := make([]byte, chunkSize)\n\t// Read from the stream to fill the buffer.\n\t_, err := stream.Read(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Create a client to send the request.\n\tclient := resty.New()\n\t// Send the first request.\n\tresp, err := client.R().\n\t\tSetBody(buf).\n\t\tSetContext(ctx).\n\t\tSetContentLength(true).\n\t\tSetHeader(\"Content-Range\", \"bytes 0-\"+strconv.Itoa(chunkSize-1)+\"/\"+strconv.Itoa(stream.Size())).\n\t\tSetHeader(\"Content-Type\", \"application/octet-stream\").\n\t\tPut(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Get the range from the response.\n\trangeHeader := resp.Header().Get(\"Range\")\n\tif rangeHeader == \"\" {\n\t\treturn fmt.Errorf(\"empty range in response\")\n\t}\n\t// Get the starting byte from the range.\n\tstart, err := strconv.Atoi(rangeHeader[len(rangeHeader)-(len(rangeHeader)-6):])\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Read from the stream to fill the buffer.\n\t_, err = stream.Read(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Send the next request.\n\tfor start < stream.Size() {\n\t\t// Check if the context is done.\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\t// Calculate the end of the chunk.\n\t\tend := start + chunkSize\n\t\tif end > stream.Size() {\n\t\t\tend = stream.Size()\n\t\t}\n\t\t// Send the request.\n\t\tresp, err = client.R().\n\t\t\tSetBody(buf).\n\t\t\tSetContext(ctx).\n\t\t\tSet", "CodeBleu_score": 44.474777319049345}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size.\n\tchunkSize := int(d.Config.ChunkSize)\n\t// Create a buffer to store each chunk.\n\tbuf := make([]byte, chunkSize)\n\t// Read the first chunk.\n\tn, err := io.ReadFull(stream, buf)\n\tif err != nil && err != io.EOF && err != io.ErrUnexpectedEOF {\n\t\treturn err\n\t}\n\t// Create a new request.\n\treq := resty.New().R()\n\t// Set the context.\n\treq.SetContext(ctx)\n\t// Set the headers.\n\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", n-1, stream.Size()))\n\treq.SetHeader(\"Content-Type\", \"application/json; charset=UTF-8\")\n\t// Set the body.\n\treq.SetBody(buf[:n])\n\t// Send the request.\n\tresp, err := req.Put(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// If the response is not successful, return the error.\n\tif resp.StatusCode() != http.StatusOK {\n\t\treturn fmt.Errorf(\"chunkUpload: %s\", resp.Status())\n\t}\n\t// Get the range header.\n\trangeHeader := resp.Header().Get(\"Range\")\n\t// Get the start and end of the range.\n\tstart, end, err := parseRange(rangeHeader)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// If the end of the range is less than the size of the file, upload the next chunk.\n\tfor end < stream.Size() {\n\t\t// Read the next chunk.\n\t\tn, err := io.ReadFull(stream, buf)\n\t\tif err != nil && err != io.EOF && err != io.ErrUnexpectedEOF {\n\t\t\treturn err\n\t\t}\n\t\t// Set the headers.\n\t\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", start, start+int64(n)-1, stream.Size()))\n\t\treq.SetHeader", "CodeBleu_score": 36.31045059189964}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size.\n\tchunkSize := int(d.ChunkSize)\n\t// Create a buffer to hold each chunk.\n\tbuf := make([]byte, chunkSize)\n\t// Read the first chunk into the buffer.\n\tn, err := stream.Read(buf)\n\tif err != nil && err != io.EOF {\n\t\treturn err\n\t}\n\t// Create a new HTTP client.\n\tclient := resty.New()\n\t// Create a new HTTP request.\n\treq := client.R().SetContext(ctx).SetBody(buf[:n])\n\t// Set the headers.\n\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", n-1, stream.Size()))\n\t// Send the request.\n\tresp, err := req.Put(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Check the response status code.\n\tif resp.StatusCode() != http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode())\n\t}\n\t// Read the next chunk into the buffer.\n\tfor n, err = stream.Read(buf); err == nil; n, err = stream.Read(buf) {\n\t\t// Set the headers.\n\t\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", n, n+len(buf)-1, stream.Size()))\n\t\t// Send the request.\n\t\tresp, err = req.Put(url)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Check the response status code.\n\t\tif resp.StatusCode() != http.StatusOK {\n\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode())\n\t\t}\n\t}\n\t// Check for EOF.\n\tif err != io.EOF {\n\t\treturn err\n\t}\n\t// Return nil to indicate success.\n\treturn nil\n}", "CodeBleu_score": 41.68935396361854}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tm := &model.Mount{}\n\tif err := ctx.Bind(m); err != nil {\n\t\treturn common_err.NewError(ctx, http.StatusBadRequest, 1000, err.Error())\n\t}\n\n\tif m.MountPoint == \"\" {\n\t\treturn common_err.NewError(ctx, http.StatusBadRequest, 1000, \"mount_point is empty\")\n\t}\n\n\tif err := service.MyService.Disk().Umount(m.MountPoint); err != nil {\n\t\treturn common_err.NewError(ctx, http.StatusBadRequest, 1000, err.Error())\n\t}\n\n\tif err := service.MyService.Disk().DeleteMount(m.MountPoint); err != nil {\n\t\treturn common_err.NewError(ctx, http.StatusBadRequest, 1000, err.Error())\n\t}\n\n\treturn common_err.NewSuccess(ctx, http.StatusOK, nil)\n}", "CodeBleu_score": 37.54809991854243}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\ts := service.New()\n\tid := ctx.Param(\"id\")\n\tif len(id) == 0 {\n\t\treturn common_err.ErrInvalidParam()\n\t}\n\n\tif err := s.DeleteStorage(id); err != nil {\n\t\treturn common_err.ErrDeleteFailed()\n\t}\n\n\treturn common_err.ErrSucceed()\n}", "CodeBleu_score": 16.275840038728596}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Get the mount point from the request context.\n\tmountPoint := ctx.FormValue(\"mount_point\")\n\tif mountPoint == \"\" {\n\t\treturn common_err.New(common_err.ErrBadRequest, \"mount_point\")\n\t}\n\t// Get the storage configuration.\n\tstorage, err := service.MyService.Storage().GetByMountPoint(mountPoint)\n\tif err != nil {\n\t\treturn common_err.New(common_err.ErrBadRequest, \"mount_point\")\n\t}\n\t// Unmount the storage.\n\tif err := service.MyService.Storage().Umount(storage); err != nil {\n\t\treturn common_err.New(common_err.ErrInternalServer, err)\n\t}\n\t// Delete the storage configuration.\n\tif err := service.MyService.Storage().Delete(storage); err != nil {\n\t\treturn common_err.New(common_err.ErrInternalServer, err)\n\t}\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err.SUCCESS})\n}", "CodeBleu_score": 48.09700816976628}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.INVALID_PARAMS)})\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusNotFound, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.FILE_NOT_EXIST)})\n\t}\n\n\t// Open the file\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusInternalServerError, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.OPEN_FILE_FAIL)})\n\t}\n\n\t// Get the file size\n\tfileInfo, err := file.Stat()\n\tif err != nil {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusInternalServerError, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.FILE_INFO_FAIL)})\n\t}\n\n\t// Set the response content type\n\tctx.Response().Header().Set(\"Content-Type\", \"application/octet-stream\")\n\n\t// Set the response content length\n\tctx.Response().Header().Set(\"Content-Length\", strconv.FormatInt(fileInfo.Size(), 10))\n\n\t// Set the response content disposition\n\tctx.Response().Header().Set(\"Content-Disposition\", \"attachment; filename=\\\"\"+filepath.Base(filePath)+\"\\\"\")\n\n\t// Return the file to the client\n\treturn ctx.Stream", "CodeBleu_score": 53.21820951890567}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the path from the query parameters\n\tpath := ctx.QueryParam(\"path\")\n\n\t// Check if the path parameter is provided\n\tif path == \"\" {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.INVALID_PARAMS)})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.FILE_NOT_EXIST)})\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(path)\n}", "CodeBleu_score": 63.69704651509341}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: oasis_err2.FILE_NOT_EXIST, Message: oasis_err2.GetMsg(oasis_err2.FILE_NOT_EXIST)})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: oasis_err2.FILE_NOT_EXIST, Message: oasis_err2.GetMsg(oasis_err2.FILE_NOT_EXIST)})\n\t}\n\treturn ctx.Attachment(filePath, path.Base(filePath))\n}", "CodeBleu_score": 58.41886523851818}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\tservice.MyService.Notify().Send(name, message)\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 48.08783875669593}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\tif err := service.MyService.Notify().SendNotification(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, \"Success\")\n}", "CodeBleu_score": 53.34647467699457}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]string\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.NewBadRequest().AddMessage(err.Error())\n\t}\n\tname := ctx.Param(\"name\")\n\tif err := service.MyService.Notify().Send(name, message); err != nil {\n\t\treturn common_err.NewInternalServerError().AddMessage(err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err.SUCCESS})\n}", "CodeBleu_score": 54.74038973862887}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\twsList = append(wsList, ws)\n\tservice.MyService.Notify().AddWS(ws)\n\n\tfor {\n\t\t_, _, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.565012121147426}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t//upgrade := websocket.Upgrader{} // use default options\n\t//c, err := upgrade.Upgrade(w, r, nil)\n\t//if err != nil {\n\t//\treturn\n\t//}\n\t//defer c.Close()\n\t//for {\n\t//\t// read in a message\n\t//\t_, message, err := c.ReadMessage()\n\t//\tif err != nil {\n\t//\t\tlog.Println(\"read:\", err)\n\t//\t\tbreak\n\t//\t}\n\t//\tlog.Printf(\"recv: %s\", message)\n\t//}\n\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn nil\n\t}\n\tdefer ws.Close()\n\n\tfor {\n\t\t// Read message from browser\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(msg)\n\t\t// Write message back to browser\n\t\tif err := ws.WriteMessage(websocket.TextMessage, msg); err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 44.48409769807863}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade initial GET request to a WebSocket\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn err\n\t}\n\t// Make sure we close the connection when the function returns\n\tdefer ws.Close()\n\n\t// Register our new client\n\tservice.WSClientList[ws] = true\n\n\tfor {\n\t\t// Read in a new message as JSON and map it to a Message object\n\t\t_, p, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn err\n\t\t}\n\n\t\t// Send the newly received message to the broadcast channel\n\t\tservice.WSMessageBroadcast <- p\n\t}\n}", "CodeBleu_score": 42.834161167606055}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar result interface{}\n\tvar err error\n\n\t// Get the system hardware information.\n\tresult, err = service.MyService.System().GetSystemHardwareInfo()\n\tif err != nil {\n\t\treturn common_err.InternalServerError(ctx, err)\n\t}\n\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err.SUCCESS, Message: oasis_err.GetMsg(oasis_err.SUCCESS), Data: result})\n}", "CodeBleu_score": 36.26744127284008}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar resp model.Result\n\tresp.Code = 200\n\tresp.Data = model.SystemHardwareInfo{\n\t\tCPU:    utils.GetCPUInfo(),\n\t\tMemory: utils.GetMemInfo(),\n\t\tDisk:   utils.GetDiskInfo(),\n\t}\n\tresp.Msg = \"success\"\n\treturn ctx.JSON(http.StatusOK, resp)\n}", "CodeBleu_score": 24.989284727271677}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar cpu string\n\tvar err error\n\tvar data []model2.CpuInfo\n\tvar drive string\n\tvar arch string\n\tvar memTotal string\n\tvar memFree string\n\tvar memUsed string\n\tvar memUsedPercent string\n\n\tif cpu, err = service.MyService.ZiMa().GetCPUSerial(); err != nil {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.ERROR), Data: nil})\n\t}\n\tif arch, err = service.MyService.ZiMa().GetCPUArch(); err != nil {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.ERROR), Data: nil})\n\t}\n\tif data, err = service.MyService.ZiMa().GetCPUInfo(); err != nil {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.ERROR), Data: nil})\n\t}\n\tif drive, err = service.MyService.ZiMa().GetDriveModel(); err != nil {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.ERROR), Data: nil})\n\t}\n\tif memTotal, memFree, memUsed, memUsedPercent, err = service.MyService.ZiMa().GetMemInfo(); err != nil {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err2.ERROR, Message: oasis_err2.GetMsg(oasis_err2.ERROR), Data: nil})\n\t}\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err2.SUCCESS, Message: oasis_err2.GetMsg(oasis_err2.SUCCESS), Data: model2.", "CodeBleu_score": 32.99500188589254}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := make([]string, 0)\n\tnotRunningServices := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Active == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 66.48330133797975}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar services map[bool]*[]string\n\tvar err error\n\tservices = make(map[bool]*[]string)\n\n\t// get a list of services\n\tservicesList, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// create a list for each status\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\t// categorize the services\n\tfor _, service := range servicesList {\n\t\tif service.Status == \"running\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\t// add the lists to the map\n\tservices[true] = &running\n\tservices[false] = &notRunning\n\n\treturn services, nil\n}", "CodeBleu_score": 59.391376539104535}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.Active {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 75.03044301988784}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageJson, _ := json2.Marshal(message)\n\tlogger.Info(fmt.Sprintf(\"Sending %s notification\", name), zap.Any(\"message\", messageJson))\n\ti.bus.Publish(name, messageJson)\n}", "CodeBleu_score": 16.899651315719}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Marshal the message values to JSON strings.\n\tmessageJson, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to marshal message values to JSON strings\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\terr = i.publisher.Publish(name, messageJson)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish event to message bus\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 41.890897047399925}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tdata, _ := json.Marshal(message)\n\tmsg := notify.Message{\n\t\tName:   name,\n\t\tData:   data,\n\t\tCreate: time.Now(),\n\t}\n\ti.db.Create(&msg)\n}", "CodeBleu_score": 19.297829427054708}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(message_bus.Server(config.MessageBusUrl))\n\treturn client\n}", "CodeBleu_score": 11.678852630177458}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function is not implemented.\n\t// TODO: This function", "CodeBleu_score": 4.208816779281641}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\"ws://\" + config.MessageBusAddress)\n\n\treturn client\n}", "CodeBleu_score": 12.209546622793185}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tforwarded := request.Header.Get(\"x-forwarded-for\")\n\tif forwarded != \"\" {\n\t\t// As the request may go through multiple proxies, the \"x-forwarded-for\" header may contain multiple IP addresses.\n\t\t// The client IP is the first one in the list.\n\t\tparts := strings.Split(forwarded, \",\")\n\t\tclientIP := strings.TrimSpace(parts[0])\n\t\treturn clientIP\n\t}\n\tip, _, err := net.SplitHostPort(request.RemoteAddr)\n\tif err != nil {\n\t\treturn request.RemoteAddr\n\t}\n\treturn ip\n}", "CodeBleu_score": 35.23156622572346}, {"code": "func GetIP(request *http.Request) string{\n\t\tvar ip string\n\tif request.Header.Get(\"x-forwarded-for\") != \"\" {\n\t\tip = request.Header.Get(\"x-forwarded-for\")\n\t} else {\n\t\tip = strings.Split(request.RemoteAddr, \":\")[0]\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 73.35786026355763}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"X-Forwarded-For\")\n\tif len(ip) > 0 {\n\t\t// X-Forwarded-For: 127.0.0.1, 127.0.0.1\n\t\tips := strings.Split(ip, \",\")\n\t\tif len(ips) > 0 {\n\t\t\tip = strings.TrimSpace(ips[0])\n\t\t}\n\t} else {\n\t\tip = strings.TrimSpace(request.RemoteAddr)\n\t\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\t\tip = \"127.0.0.1\"\n\t\t}\n\t}\n\treturn ip\n}", "CodeBleu_score": 61.83967999787081}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the modules directory path\n\tmodulesPath := config.AppInfo.ModuleDir\n\n\t// Get the entry file path\n\tentryPath := config.AppInfo.ModuleEntryFilePath\n\n\t// Ensure the entry file exists\n\tif !file.Exists(entryPath) {\n\t\t// Create the entry file\n\t\tif err := file.CreateFile(entryPath); err != nil {\n\t\t\tlogger.Error(\"Failed to create entry file\", zap.String(\"entryPath\", entryPath), zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read the modules directory\n\tfiles, err := file.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to read modules directory\", zap.String(\"modulesPath\", modulesPath), zap.Error(err))\n\t\treturn\n\t}\n\n\t// Read each module directory for entry.json files\n\tentries := make([]model.ModuleEntry, 0)\n\tfor _, file := range files {\n\t\t// Skip non-directories\n\t\tif !file.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the module directory path\n\t\tmodulePath := filepath.Join(modulesPath, file.Name())\n\n\t\t// Get the module entry file path\n\t\tmoduleEntryPath := filepath.Join(modulePath, \"entry.json\")\n\n\t\t// Read the module entry file\n\t\tmoduleEntryData, err := file.ReadFile(moduleEntryPath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to read module entry file\", zap.String(\"moduleEntryPath\", moduleEntryPath), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Unmarshal the module entry data\n\t\tvar moduleEntry model.ModuleEntry\n\t\tif err := json.Unmarshal(moduleEntryData, &moduleEntry); err != nil {\n\t\t\tlogger.Error(\"Failed to unmarshal module entry data\", zap.String(\"moduleEntryData\", string(moduleEntryData)), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Append the module entry to the entries array\n\t\tentries = append", "CodeBleu_score": 40.568351465349295}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\n\t// Get the path to the modules directory.\n\tmodulesDir := config.Cfg.Section(\"system\").Key(\"modules_dir\").String()\n\n\t// Get the path to the entry file.\n\tentryFile := config.Cfg.Section(\"system\").Key(\"entry_file\").String()\n\n\t// Ensure the entry file exists.\n\tif !file.CheckNotExist(entryFile) {\n\t\t// If the file exists, delete it.\n\t\tos.Remove(entryFile)\n\t}\n\n\t// Create the entry file.\n\t_, err := os.Create(entryFile)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to create system entry file.\", zap.String(\"path\", entryFile), zap.Error(err))\n\t\treturn\n\t}\n\n\t// Read the modules directory.\n\tdir, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to read system modules directory.\", zap.String(\"path\", modulesDir), zap.Error(err))\n\t\treturn\n\t}\n\n\t// Define the entry file content.\n\tvar entryContent []byte\n\n\t// Loop through the directory contents.\n\tfor _, d := range dir {\n\t\t// If the directory entry is not a directory, skip it.\n\t\tif !d.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the path to the directory entry.\n\t\tdirEntryPath := filepath.Join(modulesDir, d.Name())\n\n\t\t// Get the path to the directory entry entry.json file.\n\t\tdirEntryFile := filepath.Join(dirEntryPath, \"entry.json\")\n\n\t\t// Read the directory entry entry.json file.\n\t\tdata, err := os.ReadFile(dirEntryFile)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to read system module entry file.\", zap.String(\"path\", dirEntryFile), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Append the directory entry entry.json file content to the entry file content.\n\t\tentryContent = append(entryContent, data...)\n\t}\n\n\t// Write the entry", "CodeBleu_score": 46.07037781962986}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the current directory path\n\tpath := common.GetRunPath()\n\t// Set the module directory path\n\tmodulePath := path + \"/module\"\n\t// Set the entry file path\n\tentryPath := path + \"/entry.json\"\n\t// Ensure the entry file exists\n\tif !file.Exists(entryPath) {\n\t\tfile.CreateFile(entryPath)\n\t}\n\t// Get the module directory\n\tmoduleDir, err := os.Open(modulePath)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to open module directory:\", zap.Any(\"err\", err.Error()))\n\t\treturn\n\t}\n\t// Get the module directory list\n\tmoduleDirList, err := moduleDir.Readdir(0)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to read module directory:\", zap.Any(\"err\", err.Error()))\n\t\treturn\n\t}\n\t// Define an array to store the module entry content\n\tvar entryContent []string\n\t// Iterate through the module directory list\n\tfor _, module := range moduleDirList {\n\t\t// Skip non-directory files\n\t\tif !module.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\t// Set the module entry file path\n\t\tmoduleEntryPath := modulePath + \"/\" + module.Name() + \"/entry.json\"\n\t\t// Check if the module entry file exists\n\t\tif !file.Exists(moduleEntryPath) {\n\t\t\tcontinue\n\t\t}\n\t\t// Read the module entry file\n\t\tmoduleEntryFile, err := os.Open(moduleEntryPath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to open module entry file:\", zap.Any(\"err\", err.Error()))\n\t\t\tcontinue\n\t\t}\n\t\t// Read the module entry file content\n\t\tmoduleEntryContent, err := io.ReadAll(moduleEntryFile)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to read module entry file:\", zap.Any(\"err\", err.Error()))\n\t\t\tcontinue\n\t\t}\n\t\t// Append the module entry content to the entry content array\n\t\tentryContent = append(entry", "CodeBleu_score": 39.14700364806738}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range ifaces {\n\t\taddrs, err := i.Addrs()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net2.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net2.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net2.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip.IsGlobalUnicast() && ip.To4() != nil && !ip.IsLoopback() {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no network interface found\")\n}", "CodeBleu_score": 54.64619333264178}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifas, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of system network interface names\n\tifNames, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, ifa := range ifas {\n\t\tfor _, ifName := range ifNames {\n\t\t\tif ifa.Name == ifName.Name {\n\t\t\t\treturn ifa.HardwareAddr, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 61.32971491533602}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get a list of network interfaces.\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names.\n\tnames, err := net.IOCounters(true)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces.\n\tfor _, i := range ifaces {\n\t\t// Iterate over the names.\n\t\tfor _, n := range names {\n\t\t\t// Check if the name of the interface matches the name of the network.\n\t\t\tif i.Name == n.Name {\n\t\t\t\t// Return the MAC address of the interface.\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return an error if no interface is found.\n\treturn \"\", errors.New(\"no network interfaces found\")\n}", "CodeBleu_score": 62.67513940242721}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\n\tint32_t rc = 0;\n\n\t/*\n\t * Add a reference to the request object\n\t */\n\ttref_add(pRequest->pRef);\n\n\t/*\n\t * Increment the request count for the associated TSC object\n\t */\n\ttmutex_lock(pTscObj->pMutex);\n\tpTscObj->ui32RequestCount++;\n\ttmutex_unlock(pTscObj->pMutex);\n\n\t/*\n\t * Update the application's request summary, if necessary\n\t */\n\tif (pTscObj->pApp != NULL) {\n\t\ttmutex_lock(pTscObj->pApp->pMutex);\n\t\tpTscObj->pApp->ui32RequestCount++;\n\t\tpTscObj->pApp->ui32CurrentRequestCount++;\n\t\ttmutex_unlock(pTscObj->pApp->pMutex);\n\t}\n\n\t/*\n\t * Log debug information about the new request\n\t */\n\tlogDebug(\"request: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %s: %", "CodeBleu_score": 25.709284937057053}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t retCode = 0;\n    TSC_REQ_SUMMARY *pReqSum = NULL;\n    TSC_APPL_INFO *pApplInfo = NULL;\n\n    if (pRequest == NULL || pTscObj == NULL) {\n        retCode = ERR_CODE_INVALID_PARAM;\n    }\n    else {\n        pRequest->refCount++;\n        pTscObj->reqCount++;\n        if (pTscObj->pApplInfo != NULL) {\n            pApplInfo = pTscObj->pApplInfo;\n            pReqSum = &pApplInfo->reqSummary;\n            pReqSum->totalReqCount++;\n            pReqSum->currReqCount++;\n            pReqSum->lastReqTime = time(NULL);\n        }\n        logDebug(\"Request registered: %s\", pRequest->requestId);\n    }\n\n    return retCode;\n}", "CodeBleu_score": 36.57638100272994}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  int32_t rc = TT_OK;\n  int32_t i;\n  SAppObj *pAppObj = NULL;\n  SAppSummary *pAppSummary = NULL;\n\n  // Add a reference to the request object\n  tref_add(pRequest);\n\n  // Increment the request count for the associated TSC object\n  tsc_incrRequestCount(pTscObj);\n\n  // Update the application's request summary, if available\n  if (pTscObj->pAppObj != NULL) {\n    pAppObj = pTscObj->pAppObj;\n    pAppSummary = &pAppObj->appSummary;\n    pAppSummary->totalRequestCount++;\n    pAppSummary->currentRequestCount++;\n\n    // Update the request count for each of the application's TSC objects\n    for (i = 0; i < pAppObj->tscObjCount; i++) {\n      pAppObj->tscObjList[i]->appSummary.currentRequestCount++;\n    }\n  }\n\n  // Log debug information about the new request\n  log_debug(\"%s: registered request %p for TSC object %p\", __FUNCTION__, pRequest, pTscObj);\n\n  return rc;\n}", "CodeBleu_score": 34.92173420003729}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  bool bResult = true;\n  char *pDb = NULL;\n\n  // check primary database\n  pDb = getPrimaryDatabase(pRequest->pQuery);\n  if (strcmp(pDb, exceptDb) == 0) {\n    bResult = false;\n  }\n\n  // check other databases\n  if (bResult) {\n    TQuery *pQuery = pRequest->pQuery;\n    TQueryItem *pItem = pQuery->pItem;\n    while (pItem != NULL) {\n      pDb = pItem->pDatabase;\n      if (pDb != NULL) {\n        if (strchr(pDb, '.') != NULL) {\n          pDb = strchr(pDb, '.') + 1;\n        }\n        if (strcmp(pDb, exceptDb) == 0) {\n          bResult = false;\n          break;\n        }\n      }\n      pItem = pItem->pNext;\n    }\n  }\n\n  return bResult;\n}", "CodeBleu_score": 46.832098829167926}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\n    bool bRet = true;\n\n    char* pDb = pRequest->pRequest->pQuery->pPrimaryDb;\n\n    if (pDb != NULL) {\n\n        if (strcmp(pDb, exceptDb) == 0) {\n\n            bRet = false;\n\n        } else {\n\n            TDbInfo* pDbInfo = pRequest->pRequest->pQuery->pDbInfo;\n\n            while (pDbInfo != NULL) {\n\n                pDb = pDbInfo->pDb;\n\n                if (pDb != NULL) {\n\n                    if (strcmp(pDb, exceptDb) == 0) {\n\n                        bRet = false;\n\n                        break;\n\n                    }\n\n                }\n\n                pDbInfo = pDbInfo->pNext;\n\n            }\n\n        }\n\n    }\n\n    return bRet;\n\n}", "CodeBleu_score": 41.93249054052875}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (strcmp(pRequest->pQuery->pDBName, exceptDb) != 0) {\n        int i = 0;\n        for (i = 0; i < pRequest->pQuery->nDBCount; i++) {\n            if (strcmp(pRequest->pQuery->pDBNames[i], exceptDb) == 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 44.98983042285789}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\n\tif (code == E_RPC_REDIRECT) {\n\n\t\tif (msgType == TMSG_QUERY || msgType == TMSG_QUERY_CANCEL || msgType == TMSG_QUERY_CLOSE || msgType == TMSG_QUERY_PREPARE || msgType == TMSG_QUERY_PREPARE_CANCEL || msgType == TMSG_QUERY_PREPARE_CLOSE || msgType == TMSG_QUERY_PREPARE_EXECUTE || msgType == TMSG_QUERY_PREPARE_EXECUTE_CANCEL || msgType == TMSG_QUERY_PREPARE_EXECUTE_CLOSE || msgType == TMSG_QUERY_EXECUTE || msgType == TMSG_QUERY_EXECUTE_CANCEL || msgType == TMSG_QUERY_EXECUTE_CLOSE || msgType == TMSG_QUERY_EXECUTE_ASYNC || msgType == TMSG_QUERY_EXECUTE_ASYNC_CANCEL || msgType == TMSG_QUERY_EXECUTE_ASYNC_CLOSE || msgType == TMSG_QUERY_EXECUTE_ASYNC_FETCH || msgType == TMSG_QUERY_EXECUTE_ASYNC_FETCH_CANCEL || msgType == TMSG_QUERY_EXECUTE_ASYNC_FETCH_CLOSE || msgType == TMSG_QUERY_EXECUTE_ASYNC_FETCH_COLUMN || msgType == TMSG_QUERY_EXECUTE_ASYNC_FETCH_COLUMN_CANCEL || msgType == TMSG_QUERY_EXECUTE_ASYNC_FETCH_COLUMN_CLOSE || msgType == TMSG_QUERY_EXECUTE_ASYNC_FETCH_COLUMNS || msgType == TMSG_QUERY_EXECUTE_ASYNC_FETCH_COLUMNS_CANCEL || msgType == TMSG_QUERY_EXECUTE_AS", "CodeBleu_score": 42.205765785485625}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == 0) {\n        return false;\n    }\n    switch (msgType) {\n        case TMSG_QUERY_RESULT:\n        case TMSG_QUERY_ERROR:\n        case TMSG_QUERY_DONE:\n        case TMSG_QUERY_CANCEL:\n        case TMSG_QUERY_CANCEL_RESULT:\n        case TMSG_QUERY_CANCEL_ERROR:\n        case TMSG_QUERY_CANCEL_DONE:\n        case TMSG_QUERY_CANCEL_NOT_FOUND:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_RESULT:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_ERROR:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_DONE:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_NOT_FOUND:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_NOT_FOUND_RESULT:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_NOT_FOUND_ERROR:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_NOT_FOUND_DONE:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_NOT_FOUND_NOT_FOUND:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_NOT_FOUND_NOT_FOUND_RESULT:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_NOT_FOUND_NOT_FOUND_ERROR:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_NOT_FOUND_NOT_FOUND_DONE:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_NOT_FOUND_NOT_FOUND_NOT_FOUND:\n        case TMSG_QUERY_CANCEL_NOT_FOUND_NOT_FOUND_NOT_FOUND_NOT_FOUND_RESULT:\n       ", "CodeBleu_score": 27.958804876177417}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TPSUCCESS) {\n\t\treturn false;\n\t}\n\tswitch (msgType) {\n\tcase TM_RPC_CALL:\n\tcase TM_RPC_CALL_ASYNC:\n\tcase TM_RPC_CALL_ASYNC_RESPONSE:\n\tcase TM_RPC_CALL_ASYNC_RESPONSE_EX:\n\tcase TM_RPC_CALL_ASYNC_RESPONSE_EX_ONEWAY:\n\tcase TM_RPC_CALL_EX:\n\tcase TM_RPC_CALL_EX_ONEWAY:\n\tcase TM_RPC_CALL_ONEWAY:\n\tcase TM_RPC_CALL_RESPONSE:\n\tcase TM_RPC_CALL_RESPONSE_EX:\n\tcase TM_RPC_CALL_RESPONSE_EX_ONEWAY:\n\tcase TM_RPC_CALL_RESPONSE_ONEWAY:\n\tcase TM_RPC_CALL_RETURN_VALUE:\n\tcase TM_RPC_CALL_RETURN_VALUE_EX:\n\tcase TM_RPC_CALL_RETURN_VALUE_EX_ONEWAY:\n\tcase TM_RPC_CALL_RETURN_VALUE_ONEWAY:\n\tcase TM_RPC_CALL_RETURN_VALUE_RESPONSE:\n\tcase TM_RPC_CALL_RETURN_VALUE_RESPONSE_EX:\n\tcase TM_RPC_CALL_RETURN_VALUE_RESPONSE_EX_ONEWAY:\n\tcase TM_RPC_CALL_RETURN_VALUE_RESPONSE_ONEWAY:\n\tcase TM_RPC_CALL_RETURN_VALUE_RESPONSE_RESPONSE:\n\tcase TM_RPC_CALL_RETURN_VALUE_RESPONSE_RESPONSE_EX:\n\tcase TM_RPC_CALL", "CodeBleu_score": 31.873356972008715}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashObj *pNext;\n\tSHashObj *pCurr;\n\tTQuery *pQuery;\n\tTRequest *pRequest;\n\t\n\tif (pRequests == NULL)\n\t\treturn;\n\t\n\tpCurr = pRequests->pNext;\n\twhile (pCurr != pRequests) {\n\t\tpNext = pCurr->pNext;\n\t\tpRequest = (TRequest*)pCurr->pData;\n\t\tif (pRequest->pQuery != NULL) {\n\t\t\tpQuery = pRequest->pQuery;\n\t\t\tif (pQuery->state == QUERY_RUNNING) {\n\t\t\t\tqueryStop(pQuery);\n\t\t\t}\n\t\t}\n\t\trequestRelease(pRequest);\n\t\tpCurr = pNext;\n\t}\n}", "CodeBleu_score": 40.85938195413813}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t    SHashIterator hiter;\n    SQueryObj *pQuery;\n    SRequestObj *pRequest;\n\n    shash_iterate_init(&hiter, pRequests);\n    while (shash_iterate(&hiter, (void **)&pRequest)) {\n        pQuery = pRequest->pQuery;\n        if (pQuery != NULL) {\n            if (pQuery->pQuery != NULL) {\n                pQuery->pQuery->cancel = true;\n            }\n            if (pQuery->pQueryAsync != NULL) {\n                pQuery->pQueryAsync->cancel = true;\n            }\n        }\n        shash_release(pRequests, pRequest->requestID);\n    }\n}", "CodeBleu_score": 39.090330736582516}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\n\tSHashObj *pHashObj = NULL;\n\n\tTQuery *pQuery = NULL;\n\n\tTRequest *pRequest = NULL;\n\n\tchar *requestId = NULL;\n\n\n\n\t// Iterate through all requests\n\n\tpHashObj = pRequests->first;\n\n\twhile (pHashObj != NULL) {\n\n\t\t// Acquire the request by its request ID\n\n\t\trequestId = (char *) pHashObj->key;\n\n\t\tpRequest = (TRequest *) getRequest(requestId);\n\n\t\tif (pRequest != NULL) {\n\n\t\t\t// Acquire the query associated with the request\n\n\t\t\tpQuery = (TQuery *) pRequest->pQuery;\n\n\t\t\tif (pQuery != NULL) {\n\n\t\t\t\t// Stop the query\n\n\t\t\t\tstopQuery(pQuery);\n\n\t\t\t}\n\n\t\t\t// Release the request\n\n\t\t\treleaseRequest(pRequest);\n\n\t\t}\n\n\t\t// Move to the next request\n\n\t\tpHashObj = pHashObj->next;\n\n\t}\n\n}", "CodeBleu_score": 40.84712577347588}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t    if (g_client_config.crash_report_enable == 0) {\n        return;\n    }\n    if (!atomic_compare_exchange_strong(&g_client_status.client_stop, &(int){0}, 1)) {\n        logMessage(LOG_INFO, \"Crash report thread is already stopped\");\n        return;\n    }\n    while (atomic_load(&g_client_status.client_stop) != 0) {\n        osSleep(100);\n    }\n}", "CodeBleu_score": 55.00946733630608}, {"code": "void tscStopCrashReport(){\n\t  if (!g_crashReport) {\n    return;\n  }\n  if (__sync_bool_compare_and_swap(&g_clientStop, 0, 1)) {\n    while (g_clientStop) {\n      tusleep(100000);\n    }\n  } else {\n    tlog(TLOG_WARNING, \"The crash report thread is already stopped.\n\");\n  }\n}", "CodeBleu_score": 53.12002512162468}, {"code": "void tscStopCrashReport(){\n\t\tif (tscGetCrashReporting() == 0) {\n\t\treturn;\n\t}\n\tif (atomic_compare_exchange_strong(&clientStop, 0, 1) == 0) {\n\t\treturn;\n\t}\n\twhile (clientStop != 0) {\n\t\tosSleep(1000);\n\t}\n}", "CodeBleu_score": 42.15269037993955}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t i = 0;\n\tint32_t rc = 0;\n\tint32_t numViews = 0;\n\tint32_t numCols = 0;\n\tstruct SViewInfo *pViewInfo = NULL;\n\tstruct SViewInfo **viewInfoArray = NULL;\n\tstruct SViewInfo *pViewInfoInCatalog = NULL;\n\n\t/*\n\t * Deserialize the view information.\n\t */\n\tviewInfoArray = (struct SViewInfo **) deserializeViewInfo(value, valueLen, &numViews, &rc);\n\tif (viewInfoArray == NULL) {\n\t\t/*\n\t\t * Deserialization failed.\n\t\t */\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Iterate through the view information.\n\t */\n\tfor (i = 0; i < numViews; i++) {\n\t\tpViewInfo = viewInfoArray[i];\n\n\t\t/*\n\t\t * Get the view metadata from the catalog.\n\t\t */\n\t\tpViewInfoInCatalog = getViewInfo(pCatalog, pViewInfo->viewId);\n\n\t\t/*\n\t\t * Get the number of columns in the view metadata.\n\t\t */\n\t\tnumCols = getNumColsInView(pViewInfoInCatalog);\n\n\t\t/*\n\t\t * If the number of columns is 0, then the view was dropped.\n\t\t */\n\t\tif (numCols == 0) {\n\t\t\t/*\n\t\t\t * Remove the view metadata from the catalog.\n\t\t\t */\n\t\t\tremoveViewInfo(pCatalog, pViewInfo->viewId);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Update the view metadata in the catalog.\n\t\t\t */\n\t\t\tupdateViewInfo(pCatalog, pViewInfo->viewId, pViewInfo);\n\t\t}\n\t}\n\n\t/*\n\t * Destroy the view information array.\n\t */\n\tdestroyViewInfoArray(viewInfoArray, numViews);\n\n\treturn 0;\n}", "CodeBleu_score": 37.00147711831099}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t rc = 0;\n  int32_t i = 0;\n  int32_t numViews = 0;\n  int32_t numCols = 0;\n  int32_t numColsInView = 0;\n  int32_t viewID = 0;\n  int32_t colID = 0;\n  char *viewName = NULL;\n  char *colName = NULL;\n  struct SViewInfo *pViewInfo = NULL;\n  struct SViewInfo *pViewInfoArray = NULL;\n  struct SViewInfo *pViewInfoArrayNew = NULL;\n  struct SViewInfo *pViewInfoArrayOld = NULL;\n  struct SViewInfo *pViewInfoArrayOldTmp = NULL;\n  struct SViewInfo *pViewInfoArrayNewTmp = NULL;\n  struct SViewInfo *pViewInfoArrayTmp = NULL;\n  struct SViewInfo *pViewInfoArrayNewTmp2 = NULL;\n  struct SViewInfo *pViewInfoArrayOldTmp2 = NULL;\n  struct SViewInfo *pViewInfoArrayTmp2 = NULL;\n  struct SViewInfo *pViewInfoArrayNewTmp3 = NULL;\n  struct SViewInfo *pViewInfoArrayOldTmp3 = NULL;\n  struct SViewInfo *pViewInfoArrayTmp3 = NULL;\n\n  /*\n   * Deserialize the response.\n   */\n  pViewInfoArray = (struct SViewInfo *)value;\n  numViews = valueLen / sizeof(struct SViewInfo);\n  pViewInfoArrayNew = (struct SViewInfo *)malloc(numViews * sizeof(struct SViewInfo));\n  pViewInfoArrayOld = (struct SViewInfo *)malloc(numViews * sizeof(struct SViewInfo));\n\n  /*\n   * Iterate through the deserialized view metadata and either update or remove view metadata in the catalog based on the number of columns in each view.\n   */\n  for (i = 0; i < numViews; i++) {\n    pViewInfo = &pViewInfoArray[i];\n    viewID = pViewInfo->viewID;\n    numColsInView =", "CodeBleu_score": 20.23026552272203}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t i, j;\n    int32_t rc = 0;\n    int32_t numViews = 0;\n    int32_t numColumns = 0;\n    int32_t numColumnsInView = 0;\n    int32_t numColumnsInCatalog = 0;\n    int32_t viewId = 0;\n    char *viewName = NULL;\n    char *viewQuery = NULL;\n    char *viewType = NULL;\n    char *viewColumnName = NULL;\n    char *viewColumnType = NULL;\n    int32_t viewColumnLength = 0;\n    int32_t viewColumnPrecision = 0;\n    int32_t viewColumnScale = 0;\n    int32_t viewColumnNullable = 0;\n    int32_t viewColumnPosition = 0;\n    int32_t viewColumnKey = 0;\n    int32_t viewColumnUnique = 0;\n    int32_t viewColumnDefault = 0;\n    int32_t viewColumnAutoIncrement = 0;\n    int32_t viewColumnHidden = 0;\n    int32_t viewColumnTree = 0;\n    int32_t viewColumnIndex = 0;\n    int32_t viewColumnFormat = 0;\n    int32_t viewColumnSubPart = 0;\n    int32_t viewColumnCompression = 0;\n    int32_t viewColumnEncryption = 0;\n    int32_t viewColumnEncryptionKey = 0;\n    int32_t viewColumnEncryptionKeySize = 0;\n    int32_t viewColumnEncryptionAlgorithm = 0;\n    int32_t viewColumnEncryptionMode = 0;\n    int32_t viewColumnEncryptionLocation = 0;\n    int32_t viewColumnEncryptionLocationSize = 0;\n    int32_t viewColumnEncryptionLocationOffset = 0;\n    int32_t viewColumnEncryptionInitialVector = 0;\n    int32_", "CodeBleu_score": 10.312860769790912}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    struct callback_data *cbData = (struct callback_data *) callbackData;\n\n    cbData->contentLength = properties->contentLength;\n\n    return S3StatusOK;\n}", "CodeBleu_score": 52.76563204382575}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    //S3Status *status = (S3Status *) callbackData;\n    //*status = S3StatusOK;\n\n    if (properties->contentLength > 0) {\n        *(uint64_t *) callbackData = properties->contentLength;\n    } else {\n        *(uint64_t *) callbackData = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 69.54351442087676}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    struct callback_data *data = (struct callback_data *) callbackData;\n\n    data->contentLength = properties->contentLength;\n\n    return S3StatusOK;\n}", "CodeBleu_score": 52.31404942099919}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tchar cmd[MAX_COMMAND_LENGTH];\n\tchar config[MAX_COMMAND_LENGTH];\n\tchar config_file[MAX_COMMAND_LENGTH];\n\tchar config_dir[MAX_COMMAND_LENGTH];\n\tchar config_dir_path[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash_slash_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash_slash_slash_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash[MAX_COMMAND_LENGTH];\n\tchar config_dir_path_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash[", "CodeBleu_score": 5.267560221276233}, {"code": "void startRsync(){\n\t\tchar *rsync_command = (char *)malloc(MAX_COMMAND_LEN);\n\tchar *rsync_config = (char *)malloc(MAX_COMMAND_LEN);\n\tchar *rsync_config_file = (char *)malloc(MAX_COMMAND_LEN);\n\tchar *rsync_config_path = (char *)malloc(MAX_COMMAND_LEN);\n\tchar *rsync_port = (char *)malloc(MAX_COMMAND_LEN);\n\tchar *rsync_path = (char *)malloc(MAX_COMMAND_LEN);\n\tchar *rsync_dir = (char *)malloc(MAX_COMMAND_LEN);\n\tchar *rsync_log = (char *)malloc(MAX_COMMAND_LEN);\n\tchar *rsync_log_file = (char *)malloc(MAX_COMMAND_LEN);\n\tchar *rsync_log_path = (char *)malloc(MAX_COMMAND_LEN);\n\n\t/* Initialize variables */\n\tmemset(rsync_command, '\\0', MAX_COMMAND_LEN);\n\tmemset(rsync_config, '\\0', MAX_COMMAND_LEN);\n\tmemset(rsync_config_file, '\\0', MAX_COMMAND_LEN);\n\tmemset(rsync_config_path, '\\0', MAX_COMMAND_LEN);\n\tmemset(rsync_port, '\\0', MAX_COMMAND_LEN);\n\tmemset(rsync_path, '\\0', MAX_COMMAND_LEN);\n\tmemset(rsync_dir, '\\0', MAX_COMMAND_LEN);\n\tmemset(rsync_log, '\\0', MAX_COMMAND_LEN);\n\tmemset(rsync_log_file, '\\0', MAX_COMMAND_LEN);\n\tmemset(rsync_log_path, '\\0', MAX_COMMAND_LEN);\n\n\t/* Set variables */\n\tsprintf(rsync_port, \"%d\", RSYNC_PORT);\n\tsprintf(rsync_path, \"%s/bin", "CodeBleu_score": 21.427608368344607}, {"code": "void startRsync(){\n\t\tchar *cmd;\n\tchar *port;\n\tchar *dir;\n\tchar *config;\n\tchar *config_file;\n\tchar *config_dir;\n\tchar *config_dir_path;\n\tchar *config_file_path;\n\tchar *config_dir_path_check;\n\tchar *config_file_path_check;\n\tchar *config_dir_path_check_slash;\n\tchar *config_file_path_check_slash;\n\tchar *config_dir_path_check_slash_slash;\n\tchar *config_file_path_check_slash_slash;\n\tchar *config_dir_path_check_slash_slash_slash;\n\tchar *config_file_path_check_slash_slash_slash;\n\tchar *config_dir_path_check_slash_slash_slash_slash;\n\tchar *config_file_path_check_slash_slash_slash_slash;\n\tchar *config_dir_path_check_slash_slash_slash_slash_slash;\n\tchar *config_file_path_check_slash_slash_slash_slash_slash;\n\tchar *config_dir_path_check_slash_slash_slash_slash_slash_slash;\n\tchar *config_file_path_check_slash_slash_slash_slash_slash_slash;\n\tchar *config_dir_path_check_slash_slash_slash_slash_slash_slash_slash;\n\tchar *config_file_path_check_slash_slash_slash_slash_slash_slash_slash;\n\tchar *config_dir_path_check_slash_slash_slash_slash_slash_slash_slash_slash;\n\tchar *config_file_path_check_slash_slash_slash_slash_slash_slash_slash_slash;\n\tchar *config_dir_path_check_slash_slash_slash_slash_slash_slash_slash_slash_slash;\n\tchar *config_file_path_check_slash_slash_slash_slash_slash_slash_slash_slash_slash;\n\tchar *config_dir_path_check_slash_slash_slash_slash_slash_slash_slash_slash_slash_slash;\n", "CodeBleu_score": 2.266007424888113}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered!\");\n    }\n    dispatcher.getExecutor().shutdownNow();\n}", "CodeBleu_score": 72.08143737276058}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher not found!\");\n    }\n    dispatcher.executor.shutdownNow();\n}", "CodeBleu_score": 53.731196701499265}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered!\");\n    }\n}", "CodeBleu_score": 86.34395310559607}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    Set<TbActorId> children = registeredChildren.get(parent);\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(child -> {\n            try {\n                tell(child, msg, highPriority);\n            } catch (TbActorNotRegisteredException e) {\n                log.warn(\"[{}] Failed to broadcast message: {}\", child, msg);\n            }\n        });\n    }\n}", "CodeBleu_score": 72.52491505964392}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    Set<TbActorId> children = parent.getChildren().stream().filter(childFilter).collect(Collectors.toSet());\n    for (TbActorId child : children) {\n        try {\n            if (highPriority) {\n                tell(child, msg);\n            } else {\n                tellWithHighPriority(child, msg);\n            }\n        } catch (TbActorNotRegisteredException e) {\n            log.warn(\"[{}] Failed to broadcast message to child actor [{}]\", parent, child);\n        }\n    }\n}", "CodeBleu_score": 50.89530321653761}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    Set<TbActorId> children = parent.getChildren();\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(child -> {\n            try {\n                if (highPriority) {\n                    tellWithHighPriority(child, msg);\n                } else {\n                    tell(child, msg);\n                }\n            } catch (TbActorNotRegisteredException e) {\n                log.warn(\"[{}] Failed to broadcast message {} to child actor [{}]\", parent, msg, child);\n            }\n        });\n    }\n}", "CodeBleu_score": 56.43611863530161}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (destroyInProgress.get()) {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (initState == InitState.INIT_FAILED) {\n                initState = InitState.INIT_PENDING;\n                logger.debug(\"[{}] Initializing actor due to high-priority message\", entityId);\n                init();\n            }\n        } else {\n            msg.getCallback().onFailure(new TbActorStopReason(actorSystem, context.self(), TbActorStopReason.ACTOR_STOPPED));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    }\n}", "CodeBleu_score": 60.25149377741026}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!highPriority) {\n        normalPriorityMsgs.add(msg);\n    } else {\n        highPriorityMsgs.add(msg);\n    }\n    if (destroyInProgress.compareAndSet(false, true)) {\n        if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (initState == InitState.INIT_FAILED) {\n                initState = InitState.NOT_INITIALIZED;\n            }\n        } else {\n            if (initState == InitState.INITIALIZED) {\n                msg.getCallback().onSuccess();\n            } else {\n                msg.getCallback().onFailure(new TbActorStopReason(initState.name()));\n            }\n        }\n        destroyInProgress.set(false);\n    } else {\n        if (initState == InitState.INITIALIZED) {\n            processQueue();\n        }\n    }\n}", "CodeBleu_score": 57.03494666549739}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!highPriority) {\n        this.normalPriorityMsgs.add(msg);\n    } else {\n        this.highPriorityMsgs.add(msg);\n    }\n    this.processQueue();\n}", "CodeBleu_score": 16.966772539482633}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    while (true) {\n        if (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n            if (freezeOnQueue) {\n                freeze();\n            } else {\n                setStatus(ActorStatus.FREE);\n            }\n            scheduleMailboxCheck();\n            return;\n        }\n        if (processedMessages >= throughputThreshold) {\n            scheduleMailboxCheck();\n            return;\n        }\n        TbActorMsg msg = null;\n        if (!highPriorityQueue.isEmpty()) {\n            msg = highPriorityQueue.poll();\n        }\n        if (msg == null && !normalPriorityQueue.isEmpty()) {\n            msg = normalPriorityQueue.poll();\n        }\n        if (msg == null) {\n            continue;\n        }\n        try {\n            process(msg);\n        } catch (TbActorException e) {\n            log.debug(\"Failed to process message: {}\", msg, e);\n            if (e.getReason() == TbActorException.Reason.INITIALIZATION_FAILURE) {\n                stop(e.getReason());\n                return;\n            } else {\n                onProcessingFailure(msg, e);\n            }\n        } catch (Exception e) {\n            log.debug(\"Failed to process message: {}\", msg, e);\n            onProcessingFailure(msg, new TbActorException(e));\n        }\n    }\n}", "CodeBleu_score": 41.10504514400958}, {"code": "private void processMailbox(){\n\t    if (mailbox.isClosed()) {\n        return;\n    }\n    long start = System.nanoTime();\n    int total = 0;\n    int processed = 0;\n    long totalLatency = 0;\n    int retries = 0;\n    int errors = 0;\n    int successes = 0;\n    try {\n        while (processed < maxPendingMsgs) {\n            TbActorMsg msg = mailbox.poll();\n            if (msg != null) {\n                total++;\n                long startNano = System.nanoTime();\n                try {\n                    if (msg.getMsgType() == MsgType.QUEUE_TO_RULE_ENGINE_MSG) {\n                        TbMsgWrapper tbMsgWrapper = (TbMsgWrapper) msg;\n                        if (tbMsgWrapper.getTbMsg().getRuleChainId() != null && !tbMsgWrapper.getTbMsg().getRuleChainId().equals(ruleChainId)) {\n                            log.trace(\"[{}][{}] Forwarding msg to the next rule node: {}\", tbMsgWrapper.getTbMsg().getRuleChainId(), tbMsgWrapper.getTbMsg().getId(), tbMsgWrapper.getTbMsg());\n                            tbMsgProcessor.onMsg(tbMsgWrapper.getTbMsg(), tbMsgWrapper.getRuleNodeId(), tbMsgWrapper.getRelationTypes(), tbMsgWrapper.getFailureMessage());\n                        } else {\n                            log.trace(\"[{}][{}] Processing msg: {}\", ruleChainId, tbMsgWrapper.getTbMsg().getId(), tbMsgWrapper.getTbMsg());\n                            process(tbMsgWrapper);\n                        }\n                    } else if (msg.getMsgType() == MsgType.RULE_CHAIN_TO_RULE_CHAIN_INPUT_MSG) {\n                        TbMsgWrapper tbMsgWrapper = (TbMsgWrapper) msg;\n                        log.trace(\"[{}][{}] Forwarding msg to the next rule chain: {}\", ruleChainId, tbMsgWrapper.getTb", "CodeBleu_score": 30.07263612518221}, {"code": "private void processMailbox(){\n\t    long start = System.nanoTime();\n    long totalMailboxProcessingDuration = 0;\n    int totalMessagesProcessed = 0;\n    int totalMessagesInMailbox = 0;\n    int totalMessagesInHighPriorityMailbox = 0;\n    int totalMessagesSkipped = 0;\n    long totalMailboxPauseDuration = 0;\n    long totalMailboxMessagesDelay = 0;\n    int totalExpiredMessages = 0;\n    int totalFailedMessages = 0;\n    int totalPendingMessages = 0;\n    int totalProcessedMessages = 0;\n    int totalSuccessfulMessages = 0;\n    int totalMailboxProcessingIterations = 0;\n    int totalMailboxProcessingIterationsWithMessages = 0;\n    int totalMailboxProcessingIterationsWithPendingMessages = 0;\n    int totalMailboxProcessingIterationsWithExpiredMessages = 0;\n    int totalMailboxProcessingIterationsWithFailedMessages = 0;\n    int totalMailboxProcessingIterationsWithSuccessfulMessages = 0;\n    int totalMailboxProcessingIterationsWithHighPriorityMessages = 0;\n    int totalMailboxProcessingIterationsWithNormalPriorityMessages = 0;\n    int totalMailboxProcessingIterationsWithLowPriorityMessages = 0;\n    int totalMailboxProcessingIterationsWithEmptyMailbox = 0;\n    int totalMailboxProcessingIterationsWithEmptyHighPriorityMailbox = 0;\n    int totalMailboxProcessingIterationsWithEmptyNormalPriorityMailbox = 0;\n    int totalMailboxProcessingIterationsWithEmptyLowPriorityMailbox = 0;\n    int totalMailboxProcessingIterationsWithMessagesExpiredOnStart = 0;\n    int totalMailboxProcessingIterationsWithMessagesFailedOnStart = 0;\n    int totalMailboxProcessingIterationsWithMessagesPendingOnStart = 0;\n    int totalMailboxProcessingIterationsWithMessagesSkippedOnStart = 0;\n    int totalMailboxProcessingIterationsWithMessagesSuccessfulOnStart = 0;\n    int totalMailboxProcessingIterationsWithMessagesHighPriorityOnStart = ", "CodeBleu_score": 10.930295041470659}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (state.compareAndSet(ActorState.RUNNING, ActorState.STOPPING)) {\n        if (stopReason == null) {\n            stopReason = new TbActorStopReason(cause);\n        }\n        scheduleActorStop();\n    } else {\n        log.debug(\"[{}] Actor is already stopped!\", getName());\n    }\n}", "CodeBleu_score": 21.280307411307493}, {"code": "public void destroy(Throwable cause){\n\t    if (this.stopReason == null) {\n        this.stopReason = new TbActorStopReason(cause);\n    }\n\n    this.destroyInProgress = true;\n    this.schedule(() -> {\n        try {\n            this.context.getActorCtx().getActorRef().tell(new ActorContext.ActorInitMsg(this.context.getActorCtx()), ActorRef.noSender());\n        } catch (Exception var2) {\n            log.warn(\"Failed to initialize actor: {}\", this.context.getActorCtx().getSelf(), var2);\n        }\n\n    }, 1L, TimeUnit.MILLISECONDS);\n}", "CodeBleu_score": 33.57126449517367}, {"code": "public void destroy(Throwable cause){\n\t    if (setStopReasonIfNotSet(TbActorStopReason.ERROR)) {\n        log.debug(\"[{}] Destroying actor due to error.\", getActorId());\n        getActorService().getSystemContext().getScheduler().schedule(() -> {\n            try {\n                setReady(false);\n                destroy();\n                notifySuspendedActors();\n                notifyStoppedActors();\n            } catch (Throwable th) {\n                log.warn(\"[{}] Failed to destroy actor.\", getActorId(), th);\n            }\n        }, 0, TimeUnit.MILLISECONDS);\n    }\n}", "CodeBleu_score": 29.469103843543575}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile;\n    try {\n        tenantProfile = tenantProfileCache.get(tenantId);\n    } catch (TenantProfileNotFoundException e) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw e;\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getProfileData().getRateLimitsTrigger();\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits();\n    if (rateLimits == null) {\n        return true;\n    }\n    TbRateLimits.TenantRateLimit tenantRateLimit = rateLimits.getTenantRateLimit();\n    if (tenantRateLimit == null) {\n        return true;\n    }\n    TbRateLimits.TenantRateLimit.ApiLimit apiLimit = tenantRateLimit.getApiLimit(api);\n    if (apiLimit == null) {\n        return true;\n    }\n    TbRateLimits.TenantRateLimit.ApiLimit.LimitConfiguration configuration = apiLimit.getConfiguration(level);\n    if (configuration == null) {\n        return true;\n    }\n    long limit = configuration.getLimit();\n    long interval = configuration.getInterval();\n    long currentTick = System.currentTimeMillis() / interval;\n    String key = tenantId.getId().toString() + \"_\" + api.name() + \"_\" + level;\n    TbRateLimits.TenantRateLimit.ApiLimit.LimitStatistics statistics = rateLimitStats.get(key);\n    if (statistics == null) {\n        statistics = new TbRateLimits.TenantRateLimit.ApiLimit.LimitStatistics(0, currentTick);\n    }\n    if (statistics.getCount() >= limit) {\n        if (statistics.getLastTick() != currentTick)", "CodeBleu_score": 44.75724466103043}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (TenantId.SYS_TENANT_ID.equals(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile;\n    try {\n        tenantProfile = tenantProfileCache.get(tenantId);\n    } catch (TenantProfileNotFoundException e) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw e;\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimitsTrigger();\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits();\n    if (rateLimits == null) {\n        return true;\n    }\n    TbRateLimits.TbRateLimit rateLimit = rateLimits.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    TbRateLimits.TbRateLimitResult rateLimitResult = rateLimit.check(level);\n    if (rateLimitResult.isThrottlingActive()) {\n        if (rateLimitResult.getThrottlingDuration() > 0) {\n            notificationRuleProcessor.process(tenantId, tenantProfile.getId(), api, rateLimitResult.getThrottlingDuration());\n        }\n        return false;\n    } else {\n        return true;\n    }\n}", "CodeBleu_score": 49.69325737791216}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (TenantId.SYS_TENANT_ID.equals(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile;\n    try {\n        tenantProfile = tenantProfileCache.get(tenantId);\n    } catch (TenantProfileNotFoundException e) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw e;\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimitsTrigger();\n    if (rateLimitsTrigger != null) {\n        TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits();\n        if (rateLimits != null) {\n            TbRateLimits.RateLimit rateLimit = rateLimits.getRateLimit(api);\n            if (rateLimit != null) {\n                boolean rateLimitExceeded = rateLimit.tryConsume();\n                if (rateLimitExceeded) {\n                    notificationRuleProcessor.process(tenantId, tenantProfile.getId(), api, level);\n                }\n                return !rateLimitExceeded;\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 50.77536480739704}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\n    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\n    for (ConcurrentMap.Entry<InetSocketAddress, DtlsSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            log.info(\"Evicting DTLS session for address: {}\", entry.getKey());\n            dtlsSessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 53.00477613449503}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (ConcurrentMap.Entry<InetSocketAddress, DtlsSession> entry : dtlsSessions.entrySet()) {\n        DtlsSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            log.info(\"Removed inactive DTLS session for address {}\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 47.624980181764506}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - sessionInactivityTimeout;\n    for (ConcurrentMap.Entry<InetSocketAddress, DtlsSession> entry : dtlsSessions.entrySet()) {\n        DtlsSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            log.debug(\"Evicted DTLS session for {}\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 49.84981864533983}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!CollectionUtils.isEmpty(timeseries)) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            if (!CollectionUtils.isEmpty(values)) {\n                for (JsonNode value : values) {\n                    if (value.isNumber()) {\n                        Double doubleValue = value.asDouble();\n                        if (doubleValue.isInfinite() || doubleValue.equals(Double.NaN)) {\n                            continue;\n                        }\n                        result.add(new BasicTsKvEntry(System.currentTimeMillis(), new DoubleDataEntry(key, doubleValue)));\n                    } else if (value.isBoolean()) {\n                        result.add(new BasicTsKvEntry(System.currentTimeMillis(), new BooleanDataEntry(key, value.asBoolean())));\n                    } else if (value.isTextual()) {\n                        result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.asText())));\n                    }\n                }\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 48.39228462477156}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!CollectionUtils.isEmpty(timeseries)) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            for (JsonNode value : entry.getValue()) {\n                if (value.isDouble()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new DoubleDataEntry(key, value.asDouble())));\n                } else if (value.isLong()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new LongDataEntry(key, value.asLong())));\n                } else if (value.isBoolean()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new BooleanDataEntry(key, value.asBoolean())));\n                } else if (value.isTextual()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.asText())));\n                } else {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new JsonDataEntry(key, value)));\n                }\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 46.810192557486}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!CollectionUtils.isEmpty(timeseries)) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            for (JsonNode value : entry.getValue()) {\n                if (value.isBoolean()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new BooleanDataEntry(key, value.asBoolean())));\n                } else if (value.isDouble()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new DoubleDataEntry(key, value.asDouble())));\n                } else if (value.isLong()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new LongDataEntry(key, value.asLong())));\n                } else if (value.isTextual()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.asText())));\n                } else if (value.isObject()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new JsonDataEntry(key, value)));\n                }\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 46.65395394752625}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t    String refreshToken = tokenInfo.getRefreshToken();\n    String tokenUrl = tokenInfo.getTokenUrl();\n    Map<String, String> requestBody = new HashMap<>();\n    requestBody.put(\"refresh_token\", refreshToken);\n    requestBody.put(\"client_id\", clientId);\n    requestBody.put(\"grant_type\", \"refresh_token\");\n    HttpEntity<Map<String, String>> request = new HttpEntity<>(requestBody, headers);\n    ResponseEntity<Map<String, Object>> response = restTemplate.postForEntity(tokenUrl, request, Map.class);\n    Map<String, Object> body = response.getBody();\n    tokenInfo.setAccessToken(body.get(\"access_token\").toString());\n    tokenInfo.setRefreshToken(body.get(\"refresh_token\").toString());\n    tokenInfo.setExpiresIn(Long.parseLong(body.get(\"expires_in\").toString()));\n    tokenInfo.setRefreshTokenExpiresIn(Long.parseLong(body.get(\"refresh_token_expires_in\").toString()));\n    tokenInfo.setTokenUpdateTs(System.currentTimeMillis());\n}", "CodeBleu_score": 41.01550112641023}, {"code": "public void refreshToken(){\n\t    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refresh_token\", refreshToken);\n    ResponseEntity<JsonNode> response = restTemplate.postForEntity(baseUrl + \"/api/auth/token\", requestMap, JsonNode.class);\n    if (response.getStatusCode().is2xxSuccessful()) {\n        JsonNode body = response.getBody();\n        accessToken = body.get(\"token\").asText();\n        refreshToken = body.get(\"refreshToken\").asText();\n        tokenTs = System.currentTimeMillis();\n    }\n}", "CodeBleu_score": 56.46839580726104}, {"code": "public void refreshToken(){\n\t    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refreshToken\", getRefreshToken());\n    ResponseEntity<JsonNode> response = restTemplate.postForEntity(getBaseUrl() + \"/api/auth/token\", requestMap, JsonNode.class);\n    setJwtToken(response.getBody().get(\"token\").asText());\n    setRefreshToken(response.getBody().get(\"refreshToken\").asText());\n    setJwtTokenExpirationTime(System.currentTimeMillis() + response.getBody().get(\"expiresIn\").asLong() * 1000);\n}", "CodeBleu_score": 49.98979505694166}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t    String token = null;\n    long ts = System.currentTimeMillis();\n    try {\n        token = restTemplate.postForObject(baseURL + \"/api/auth/login\", new HttpEntity<>(loginRequest), String.class);\n    } catch (Exception e) {\n        System.out.println(\"Exception: \" + e.getMessage());\n    }\n    if (!isEmpty(token)) {\n        JwtToken jwtToken = new JwtToken(token);\n        jwtToken.setCreatedTime(ts);\n        tokenInfo = jwtToken;\n    }\n}", "CodeBleu_score": 42.70227707270764}, {"code": " private void doLogin(){\n\t    try {\n        String username = \"tenant@thingsboard.org\";\n        String password = \"tenant\";\n        String loginUrl = \"http://localhost:8080/api/auth/login\";\n        String tokenUrl = \"http://localhost:8080/api/auth/token\";\n        String refreshTokenUrl = \"http://localhost:8080/api/auth/token\";\n        String revokeTokenUrl = \"http://localhost:8080/api/auth/revoke\";\n\n        long currentTimeMillis = System.currentTimeMillis();\n\n        Map<String, String> loginRequestBody = new HashMap<>();\n        loginRequestBody.put(\"username\", username);\n        loginRequestBody.put(\"password\", password);\n\n        RestTemplate restTemplate = new RestTemplate();\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n\n        HttpEntity<Map<String, String>> entity = new HttpEntity<>(loginRequestBody, headers);\n\n        ResponseEntity<JwtToken> loginResponse = restTemplate.postForEntity(loginUrl, entity, JwtToken.class);\n\n        JwtToken jwtToken = loginResponse.getBody();\n        jwtToken.setCreatedTime(currentTimeMillis);\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the token information\n        tokenInfo = jwtToken;\n\n        // Update the", "CodeBleu_score": 41.15356816270056}, {"code": " private void doLogin(){\n\t    try {\n        // Create a post request to the login URL.\n        HttpPost post = new HttpPost(loginUrl);\n        // Set the post body with the user credentials.\n        List<NameValuePair> urlParameters = new ArrayList<>();\n        urlParameters.add(new BasicNameValuePair(\"username\", username));\n        urlParameters.add(new BasicNameValuePair(\"password\", password));\n        post.setEntity(new UrlEncodedFormEntity(urlParameters));\n        // Execute the request.\n        CloseableHttpResponse response = httpclient.execute(post);\n        try {\n            // Get the response status code.\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != 200) {\n                throw new RuntimeException(\"Login failed: \" + statusCode);\n            }\n            // Get the response body as a string.\n            String responseString = EntityUtils.toString(response.getEntity());\n            // Parse the token information from the response body.\n            JsonNode tokenInfo = mapper.readTree(responseString);\n            // Get the token from the token information.\n            token = tokenInfo.get(\"token\").asText();\n            // Get the refresh token from the token information.\n            refreshToken = tokenInfo.get(\"refreshToken\").asText();\n            // Get the timestamp from the token information.\n            tokenTs = tokenInfo.get(\"timestamp\").asLong();\n            // Get the expiration time from the token information.\n            tokenExpiresTs = tokenInfo.get(\"expiresIn\").asLong();\n            // Get the refresh expiration time from the token information.\n            refreshTokenExpiresTs = tokenInfo.get(\"refreshExpiresIn\").asLong();\n        } finally {\n            response.close();\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 37.70626454976197}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    return getDeviceById(deviceId, null);\n}", "CodeBleu_score": 6.444928507714597}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    return Optional.ofNullable(restTemplate.getForObject(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId()));\n}", "CodeBleu_score": 15.344365884119973}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    Device device = null;\n    try {\n        URI uri = new URI(this.getUrl() + \"/api/device/\" + deviceId.getId().toString());\n        HttpHeaders headers = this.getHttpHeaders();\n        HttpEntity<?> entity = new HttpEntity<>(headers);\n        ResponseEntity<Device> response = restTemplate.exchange(uri, HttpMethod.GET, entity, Device.class);\n        device = response.getBody();\n    } catch (Exception e) {\n        if (e.getMessage().contains(\"404\")) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n    return Optional.ofNullable(device);\n}", "CodeBleu_score": 53.59679189746226}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest(device, credentials);\n    try {\n        return Optional.of(restTemplate.postForObject(baseURL + \"/api/device-with-credentials\", request, Device.class));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 61.23098791226263}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        return Optional.ofNullable(restClient.postDeviceWithCredentials(device, credentials));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 40.65052110741239}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest();\n    request.setDevice(device);\n    request.setCredentials(credentials);\n    try {\n        return Optional.of(restTemplate.postForObject(baseURL + \"/api/device-with-credentials\", request, Device.class));\n    } catch (HttpClientErrorException exception) {\n        if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw exception;\n        }\n    }\n}", "CodeBleu_score": 61.0700984193186}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n        this.devices.forEach(function (device) {\n            device.brightness(addr);\n        });\n    } else {\n        this.devices.forEach(function (device) {\n            device.brightness(addr, val);\n        });\n    }\n    return this;\n}", "CodeBleu_score": 59.109123790031305}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n        this.devices.forEach(function (d) {\n            d.brightness(addr);\n        });\n    } else {\n        this.devices.forEach(function (d) {\n            d.brightness(addr, val);\n        });\n    }\n    return this;\n}", "CodeBleu_score": 59.69138363723891}, {"code": "brightness(addr, val){\n\t    if (typeof addr === 'undefined') {\n        this.devices.forEach(device => {\n            device.brightness = val;\n        });\n    } else {\n        this.devices[addr].brightness = val;\n    }\n    return this;\n}", "CodeBleu_score": 33.29334254181725}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    var proto = Object.getPrototypeOf(this);\n    var bound = {};\n    var keys = Object.getOwnPropertyNames(proto).concat(Object.keys(this));\n    keys.forEach(function (key) {\n        if (typeof this[key] === 'function') {\n            bound[key] = this[key].bind(this, addr);\n        }\n    }, this);\n    return bound;\n}", "CodeBleu_score": 49.3143685956549}, {"code": "device(addr){\n\t    let new_obj = {};\n    for (let key of Object.getOwnPropertyNames(LedControl.prototype)) {\n        new_obj[key] = LedControl.prototype[key].bind(this, addr);\n    }\n    for (let key of Object.getOwnPropertyNames(this)) {\n        new_obj[key] = this[key];\n    }\n    return new_obj;\n}", "CodeBleu_score": 44.791361044233504}, {"code": "device(addr){\n\t    var proto = LedControl.prototype;\n    var obj = {};\n    for (var prop in proto) {\n        obj[prop] = proto[prop].bind(this, addr);\n    }\n    for (var prop in this) {\n        obj[prop] = this[prop];\n    }\n    return obj;\n}", "CodeBleu_score": 28.06402513012064}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[`${method}Callback`] = (duration, callback) => {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tthrow new Error(`${method}Callback requires a callback`);\n\t\t\t}\n\n\t\t\tconst promises = this.map(element => {\n\t\t\t\treturn new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\telement[method]();\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}, duration);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 45.227607663683585}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = (duration, callback) => {\n            if (typeof callback !== 'function') {\n                callback = () => {};\n            }\n            let promises = [];\n            for (let element of target) {\n                promises.push(element[method](duration));\n            }\n            Promise.all(promises).then(callback);\n        };\n    });\n}", "CodeBleu_score": 34.21542374255275}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  for (let method of methods) {\n    target[method] = (duration, callback) => {\n      duration = duration || 1000;\n      callback = callback || (() => {});\n\n      let promises = [];\n      this.forEach(element => {\n        let promise = element[method]();\n        promises.push(promise);\n      });\n\n      Promise.all(promises).then(callback);\n    };\n  }\n}", "CodeBleu_score": 30.00805354769705}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t    let input = '';\n    let serial = new SerialPort(this.port, {\n        baudRate: this.baudRate\n    });\n    serial.on('data', data => {\n        input += data.toString();\n        let sentences = input.split(/\\r\n/);\n        input = sentences.pop();\n        sentences.forEach(sentence => {\n            this.parseNmeaSentence(sentence);\n        });\n    });\n}", "CodeBleu_score": 40.10172906626855}, {"code": "listen(){\n\t\n}", "CodeBleu_score": 1.3739519390252413}, {"code": "listen(){\n\t    String input = \"\";\n    while (true) {\n        input += Serial.readString();\n        List<String> sentences = input.split(\"\\r\n\");\n        for (int i = 0; i < sentences.size() - 1; i++) {\n            parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.size() - 1];\n    }\n}", "CodeBleu_score": 28.888682214126625}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tuint8_t active_channels = 0U;\n\tsize_t needed_buffer_size = 0;\n\tconst struct ad559x_config *config = dev->config;\n\n\t/* Validate the buffer size for each active channel */\n\tfor (uint8_t i = 0; i < config->channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t\tneeded_buffer_size += sizeof(struct adc_sequence_options);\n\t\t}\n\t}\n\n\t/* If the buffer size is insufficient, return an error code */\n\tif (sequence->options) {\n\t\tif (sequence->options->extra_samplings) {\n\t\t\tneeded_buffer_size += (active_channels *\n\t\t\t\t\t       sequence->options->extra_samplings *\n\t\t\t\t\t       sizeof(struct adc_sequence_options));\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\tsequence->buffer_size, needed_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.75071133574722}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tuint8_t channels = 0;\n\tuint32_t buffer_size = sequence->options ? sequence->options->extra_samplings * sequence->oversampling : 0;\n\n\tfor (int i = 0; i < sequence->channels->len; i++) {\n\t\tif (sequence->channels->list[i].channel_id < 0) {\n\t\t\tLOG_ERR(\"Invalid channel id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchannels++;\n\t}\n\n\tbuffer_size += channels * sizeof(struct adc_sequence_options);\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\", sequence->buffer_size, buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.22396914046519}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\n\tuint32_t needed_buffer_size;\n\tuint8_t channels = sequence->channels;\n\tuint8_t ch_id;\n\n\t/*\n\t * The AD559x has 4 channels, but the driver only supports 2 of them.\n\t * If the sequence has more than 2 channels, it returns an error.\n\t */\n\tif (channels > 2) {\n\t\tLOG_ERR(\"Sequence has too many channels\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * The AD559x driver only supports 12-bit resolution.\n\t * If the sequence has a resolution different than 12-bit, it returns an error.\n\t */\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Sequence has an invalid resolution\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * The AD559x driver only supports single-ended mode.\n\t * If the sequence has a differential mode, it returns an error.\n\t */\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Sequence has an invalid oversampling\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * The AD559x driver only supports unsigned data.\n\t * If the sequence has a signed data, it returns an error.\n\t */\n\tif (sequence->options & ADC_REJECT_DATA) {\n\t\tLOG_ERR(\"Sequence has an invalid option\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * The AD559x driver only supports one sample per channel.\n\t * If the sequence has more than one sample per channel, it returns an error.\n\t */\n\tif (sequence->buffer_size < (channels * sizeof(uint16_t))) {\n\t\tLOG_ERR(\"Sequence has an invalid buffer size\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * The AD559x driver only supports one sample per channel.\n\t * If the sequence has more than one sample per channel, it returns an error.\n\t */\n", "CodeBleu_score": 47.360215894987924}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tstruct ad559x_data *ad559x_data = &data->ad559x_data;\n\tint error;\n\tuint8_t buf[2];\n\n\tif (sequence->resolution != config->adc_config.resolution) {\n\t\tLOG_ERR(\"ADC resolution %d is not supported\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Check if the requested channels are valid */\n\tfor (size_t i = 0; i < sequence->channels->len; i++) {\n\t\tif (sequence->channels->list[i] >= config->adc_config.channel_count) {\n\t\t\tLOG_ERR(\"ADC channel %d is not supported\", sequence->channels->list[i]);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t}\n\n\tsize_t buf_size = adc_context_samples_buffer_size(sequence, config->adc_config.channel_count);\n\n\tif (buf_size > config->adc_config.buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstruct adc_context *ctx = &data->ctx;\n\n\tadc_context_lock(ctx, true, NULL);\n\tadc_context_start_read(ctx, sequence);\n\n\t/* Read data from the AD559x */\n\tfor (size_t i = 0; i < sequence->channels->len; i++) {\n\t\tuint8_t channel = sequence->channels->list[i];\n\t\tuint8_t channel_reg = channel + 1;\n\n\t\terror = ad559x_read_reg(ad559x_data, AD559X_REG_ADC_DATA(channel_reg), buf, 2);\n\t\tif (error) {\n\t\t\tLOG_ERR(\"Failed", "CodeBleu_score": 49.5380175074838}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct ad559x_driver_config *ad559x_config = config->ad559x_config;\n\tstruct ad559x_data *ad559x_data = ad559x_config->data;\n\tconst struct adc_ad559x_channel_config *channel_config = config->channel_config;\n\tstruct ad559x_channel_config *ad559x_channel_config = ad559x_config->channel_config;\n\n\tuint8_t channel_id = 0;\n\tint err = 0;\n\n\t/* Check if the resolution of the ADC sequence matches the expected resolution */\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"ADC resolution %d does not match expected resolution %d\", sequence->resolution, config->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the specified channels are valid */\n\tfor (uint8_t i = 0; i < sequence->channels; i++) {\n\t\tchannel_id = sequence->channels[i];\n\t\tif (channel_id >= config->channels) {\n\t\t\tLOG_ERR(\"Channel %d is not valid\", channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Validate the buffer size for the ADC read */\n\tsize_t size = adc_context_samples_count_to_buffer_size(sequence->options, sequence->channels, sequence->oversampling);\n\tif (size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size %d is insufficient for sequence options 0x%x, channels %d, and oversampling %d\", sequence->buffer_size, sequence->options, sequence->channels, sequence->oversampling);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Set the buffer */\n\tadc_context_", "CodeBleu_score": 40.379587423465644}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint err;\n\tuint8_t buf[2];\n\tuint8_t chan;\n\tuint8_t i;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"ADC resolution is not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tchan = find_msb_set(sequence->channels) - 1;\n\t\tif (chan < config->num_channels) {\n\t\t\tLOG_ERR(\"Channel %d is not supported\", chan);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t}\n\n\tsize_t size = sizeof(uint16_t) * sequence->channels;\n\tif (size > sequence->options) {\n\t\tLOG_ERR(\"Provided buffer is too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\terr = ad559x_read_reg(config->bus, config->addr, AD559X_REG_ADC_DATA, buf, 2);\n\tif (err) {\n\t\tLOG_ERR(\"Failed to read ADC data\");\n\t\treturn err;\n\t}\n\n\tuint16_t val = sys_get_be16(buf);\n\n\tadc_context_update_buffer(&data->ctx, &val, sizeof(val));\n\n\tadc_context_complete(&data->ctx, err);\n\n\treturn err;\n}", "CodeBleu_score": 47.15883214390126}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct ad559x_data *data = CONTAINER_OF(ctx, struct ad559x_data, ctx);\n\tconst struct ad559x_config *config = data->config;\n\tuint8_t channels = 0;\n\n\tfor (int i = 0; i < config->channels; i++) {\n\t\tif (ctx->sequence.channels & BIT(i)) {\n\t\t\tchannels |= BIT(i);\n\t\t}\n\t}\n\n\tad559x_set_channels(config, channels);\n\n\tad559x_start_sampling(config);\n}", "CodeBleu_score": 38.67102901342811}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct ad559x_data *data = CONTAINER_OF(ctx, struct ad559x_data, ctx);\n\tconst struct adc_sequence *sequence = ctx->sequence.front;\n\tint err;\n\n\tLOG_DBG(\"Starting sampling on ADC %s\", data->name);\n\n\t/* Set channels */\n\terr = ad559x_set_channels(data, sequence->channels, sequence->num_channels);\n\tif (err) {\n\t\tLOG_ERR(\"Failed to set channels: %d\", err);\n\t\treturn;\n\t}\n\n\t/* Setup repeat buffer */\n\tadc_context_start_read(&data->ctx, sequence);\n\n\t/* Start sampling */\n\terr = ad559x_start_sampling(data);\n\tif (err) {\n\t\tLOG_ERR(\"Failed to start sampling: %d\", err);\n\t\treturn;\n\t}\n}", "CodeBleu_score": 45.306786459549386}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct ad559x_data *data = CONTAINER_OF(ctx, struct ad559x_data, ctx);\n\tconst struct adc_sequence *sequence = ctx->sequence.current;\n\tuint8_t channels = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tchannels |= BIT(sequence->channels[i]);\n\t}\n\n\tdata->channels = channels;\n\n\tad559x_set_channels(data->reg, channels);\n\n\tad559x_set_repeat(data->reg, sequence->oversampling);\n\n\tmemset(data->buffer, 0, sizeof(data->buffer));\n\n\tk_sem_give(&data->acq_sem);\n}", "CodeBleu_score": 41.817483365863524}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_sequence *sequence = ctx->sequence.ri;\n\n\tif (repeat_sampling && sequence->options) {\n\t\tctx->repeat_buffer = sequence->options->extra_sampling;\n\t}\n}", "CodeBleu_score": 31.725460125539584}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->repeat_buffer = ctx->buffer;\n\t}\n}", "CodeBleu_score": 44.32578164190454}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->repeat_buffer = ctx->buffer;\n\t}\n}", "CodeBleu_score": 44.32578164190454}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tLOG_DBG(\"Starting ADC thread\");\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (uint8_t i = 0; i < data->active_channels; i++) {\n\t\t\tuint8_t channel = data->channels[i];\n\t\t\tuint16_t result;\n\n\t\t\tif (ad559x_read_adc(data->ad559x, channel, &result) != 0) {\n\t\t\t\tLOG_ERR(\"Failed to read ADC channel %d\", channel);\n\n\t\t\t\tadc_context_on_sampling_done(&data->ctx, data->dev);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdata->buffer[i] = sys_cpu_to_le16(result);\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, data->dev);\n\t}\n}", "CodeBleu_score": 48.799306650877014}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t\tLOG_DBG(\"Starting acquisition\");\n\t\tfor (uint8_t i = 0; i < data->active_channels; i++) {\n\t\t\tconst uint8_t channel_id = data->channels[i];\n\t\t\tconst struct ad559x_channel_config *channel_config = &data->channel_configs[channel_id];\n\t\t\tconst struct adc_sequence *sequence = &data->sequence;\n\t\t\tconst struct adc_channel_cfg *channel_cfg = &sequence->channels[i];\n\n\t\t\tuint16_t adc_value;\n\t\t\tif (ad559x_read_adc(data->ad559x, channel_config->ad559x_channel, &adc_value) != 0) {\n\t\t\t\tLOG_ERR(\"Failed to read ADC value\");\n\t\t\t\tdata->completed = true;\n\t\t\t\tk_sem_give(&data->sem);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (channel_cfg->differential) {\n\t\t\t\tLOG_ERR(\"Differential channels are not supported\");\n\t\t\t\tdata->completed = true;\n\t\t\t\tk_sem_give(&data->sem);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tuint32_t result = adc_raw_to_millivolts(channel_cfg, adc_value);\n\t\t\tif (channel_cfg->gain == ADC_GAIN_1) {\n\t\t\t\tresult *= 2;\n\t\t\t}\n\n\t\t\tif (channel_cfg->reference == ADC_REF_INTERNAL) {\n\t\t\t\tresult = 2500 - result;\n\t\t\t}\n\n\t\t\tdata->buffer[i] = sys_cpu_to_le32(result);\n\t\t}\n\t\tdata->completed = true;\n\t\tk_sem_give", "CodeBleu_score": 38.02613914894831}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct device *dev = data->dev;\n\tstruct adc_sequence *sequence = data->sequence;\n\tstruct adc_channel_cfg *channel_cfg;\n\tuint8_t channel_id;\n\tuint16_t raw_value;\n\tuint16_t *buffer;\n\tint err;\n\tint i;\n\n\twhile (true) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\t\tif (sequence->calibrate) {\n\t\t\terr = ad559x_calibrate(dev);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"AD559x calibration failed with error %d\", err);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < sequence->channels->len; i++) {\n\t\t\tchannel_cfg = &sequence->channels->channels[i];\n\t\t\tchannel_id = channel_cfg->channel_id;\n\t\t\tbuffer = sequence->buffer + i;\n\n\t\t\terr = ad559x_read(dev, channel_id, &raw_value);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"Failed to read ADC channel %d (err %d)\", channel_id, err);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t*buffer = raw_value;\n\t\t}\n\n\tdone:\n\t\tadc_context_on_sampling_done(data->ctx, dev);\n\t}\n}", "CodeBleu_score": 40.68116444280767}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\n\tconst struct ads1112_config *config = dev->config;\n\n\tconst struct device *i2c_dev = config->i2c_dev;\n\n\tuint8_t reg_val[1];\n\n\tuint8_t reg_addr = ADS1112_REG_POINTER_CONFIG;\n\n\tint ret;\n\n\n\n\t/* Sleep for the specified ready time */\n\n\tk_usleep(config->ready_time);\n\n\n\n\t/* Check the configuration register's status bit */\n\n\tret = i2c_burst_read(i2c_dev, config->i2c_addr, reg_addr, reg_val, 1);\n\n\tif (ret != 0) {\n\n\t\treturn ret;\n\n\t}\n\n\twhile ((reg_val[0] & ADS1112_CONFIG_STATUS_MASK) != ADS1112_CONFIG_STATUS_READY) {\n\n\t\tk_usleep(100);\n\n\t\tret = i2c_burst_read(i2c_dev, config->i2c_addr, reg_addr, reg_val, 1);\n\n\t\tif (ret != 0) {\n\n\t\t\treturn ret;\n\n\t\t}\n\n\t}\n\n\n\n\treturn 0;\n\n}", "CodeBleu_score": 49.548974025660044}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tuint16_t config_reg;\n\tint err;\n\n\tk_msleep(config->ready_time);\n\n\twhile (true) {\n\t\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n\n\t\tif (err != 0) {\n\t\t\treturn err;\n\t\t}\n\n\t\tif ((config_reg & ADS1112_REG_CONFIG_RDY) == 0) {\n\t\t\tk_usleep(100);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.74711562380184}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    const struct ads1112_config *config = dev->config;\n    struct ads1112_data *data = dev->data;\n    uint16_t config_reg;\n    int err;\n\n    k_msleep(config->ready_time);\n\n    while (1) {\n        err = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n        if (err) {\n            return err;\n        }\n\n        if (config_reg & ADS1112_CONFIG_BIT_OS) {\n            break;\n        }\n\n        k_usleep(100);\n    }\n\n    return 0;\n}", "CodeBleu_score": 46.73367741044914}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    uint32_t required_buffer_size = sequence->options ? sequence->options->extra_samplings + 1 : 1;\n    if (sequence->buffer_size < required_buffer_size) {\n        LOG_ERR(\"Provided buffer size too small. (%u/%u)\",\n                sequence->buffer_size,\n                required_buffer_size);\n        return -ENOMEM;\n    }\n    return 0;\n}", "CodeBleu_score": 41.578146878459364}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_buffer_size;\n\trequired_buffer_size = sizeof(struct adc_sequence) + sequence->options;\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\", sequence->buffer_size, required_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 48.010358619634324}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    size_t required_buffer_size;\n    required_buffer_size = (sequence->options &\n                            (ADC_OPT_DISCONTINUOUS | ADC_OPT_SAMPLE_ACCUMULATE)) ?\n                           (sequence->oversampling + 1) : 1;\n    if (sequence->buffer_size < required_buffer_size) {\n        LOG_ERR(\"Provided buffer size too small. \"\n                \"Expected %u, got %u.\",\n                required_buffer_size, sequence->buffer_size);\n        return -ENOMEM;\n    }\n    return 0;\n}", "CodeBleu_score": 47.71871758156703}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tconst struct ads1112_config *config = dev->config;\n\tint err;\n\n\t/* Validate sequence */\n\tadc_context_lock(&data->ctx, true, NULL);\n\terr = adc_validate_read(dev, sequence);\n\tif (err) {\n\t\tadc_context_release(&data->ctx, err);\n\t\treturn err;\n\t}\n\n\t/* Assign sequence buffer */\n\tdata->seq_size = sequence->options;\n\tdata->buffer = sequence->buffer;\n\n\t/* Start conversion */\n\terr = ads1112_start_conversion(dev);\n\tif (err) {\n\t\tadc_context_release(&data->ctx, err);\n\t\treturn err;\n\t}\n\n\t/* Wait for conversion to finish if requested */\n\tif (wait) {\n\t\terr = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\tadc_context_release(&data->ctx, err);\n\treturn err;\n}", "CodeBleu_score": 55.85200707424056}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint err;\n\tuint8_t buf[4];\n\tuint16_t val;\n\tuint8_t config;\n\tuint8_t config_msb;\n\tuint8_t config_lsb;\n\n\t/* Validate the sequence */\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unexpected sequence options\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > 1) {\n\t\tLOG_ERR(\"Unexpected sequence channels\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Assign the sequence buffer */\n\tdata->seq_buffer = sequence->buffer;\n\n\t/* Start the ADC read context */\n\tadc_context_start_read(&data->ctx, sequence);\n\n\t/* Configure the ADS1112 */\n\tconfig_msb = 0x80;\n\tconfig_lsb = 0x00;\n\n\t/* Single-shot mode */\n\tconfig_msb |= 0x01 << 15;\n\n\t/* Comparator mode */\n\tconfig_msb |= 0x00 << 14;\n\n\t/* Comparator polarity */\n\tconfig_msb |= 0x00 << 13;\n\n\t/* Comparator latching */\n\tconfig_msb |= 0x00 << 12;\n\n\t/* Comparator queue */\n\tconfig_msb |= 0x00 << 10;\n\n\t/* Conversion rate */\n\tconfig_msb |= 0x00 << 7;\n\n\t/* Input multiplexer */\n\tconfig_msb |= 0x00 << 4;\n\n\t/* PGA gain */\n\tconfig_msb |= 0x00 << 1;\n\n\t/* Operational status */\n\tconfig_msb |= 0x00 << 0;\n\n\t/* Configure the ADS1112 */\n\tconfig_lsb = 0x00;\n\n\t/* Low threshold */", "CodeBleu_score": 48.620368302837406}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint err;\n\tuint8_t i;\n\n\tif (sequence->channels == 0) {\n\t\tLOG_ERR(\"No channels in sequence\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if there is an ongoing conversion.\n\t */\n\tif (data->seq) {\n\t\tLOG_ERR(\"Another sequence is ongoing\");\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Check if there is an invalid channel in the sequence.\n\t */\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channel_id[i] >= ADS1112_NUM_CHANNELS) {\n\t\t\tLOG_ERR(\"Invalid channel in sequence\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Assign the sequence to the device data.\n\t */\n\tdata->seq = sequence;\n\n\t/*\n\t * Start the ADC read context.\n\t */\n\tadc_context_start_read(&data->ctx, sequence);\n\n\t/*\n\t * If the wait flag is true, wait for the read operation to complete.\n\t */\n\tif (wait) {\n\t\terr = adc_context_wait_for_completion(&data->ctx);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.37187432405212}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\tstruct audio_codec_cfg cfg;\n\tint ret;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tcfg.properties = (struct audio_codec_property *)argv[2];\n\tcfg.properties_count = argc - 3;\n\n\tret = audio_codec_configure(dev, &cfg);\n\tif (ret) {\n\t\tshell_error(sh, \"Error configuring device %d\", ret);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 61.9924878320951}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *codec_dev;\n\tstruct audio_codec_cfg cfg;\n\tint ret;\n\n\tcodec_dev = DEVICE_DT_GET_ANY(audio_codec);\n\tif (!codec_dev) {\n\t\tshell_error(sh, \"Failed to get audio codec device\");\n\t\treturn -ENODEV;\n\t}\n\n\tcfg.options = AUDIO_CODEC_DAI_FORMAT_I2S | AUDIO_CODEC_DAI_FORMAT_LEFT_J;\n\tcfg.i2s.word_size = 16;\n\tcfg.i2s.channels = 2;\n\tcfg.i2s.sample_rate = 44100;\n\n\tret = audio_codec_configure(codec_dev, &cfg);\n\tif (ret != 0) {\n\t\tshell_error(sh, \"Failed to configure audio codec device (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\tshell_print(sh, \"Audio codec configured successfully\");\n\n\treturn 0;\n}", "CodeBleu_score": 54.54936361917758}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct audio_codec_cfg cfg = {\n\t\t.dai_type = AUDIO_DAI_TYPE_I2S,\n\t\t.dai_cfg = {\n\t\t\t.i2s = {\n\t\t\t\t.word_size = 16,\n\t\t\t\t.channels = 2,\n\t\t\t\t.format = AUDIO_I2S_FMT_DATA_FORMAT_I2S,\n\t\t\t\t.options = AUDIO_I2S_OPT_FRAME_CLK_MASTER |\n\t\t\t\t\tAUDIO_I2S_OPT_BIT_CLK_MASTER,\n\t\t\t\t.frame_clk_freq = 48000,\n\t\t\t\t.block_size = 48,\n\t\t\t\t.mem_slab = NULL,\n\t\t\t\t.timeout = 0,\n\t\t\t\t.rx_delay = 0,\n\t\t\t},\n\t\t},\n\t\t.i2s_cfg = {\n\t\t\t.word_size = 16,\n\t\t\t.channels = 2,\n\t\t\t.format = AUDIO_PCM_FMT_S16_LE,\n\t\t\t.options = AUDIO_PCM_RATE_48000 | AUDIO_PCM_WIDTH_16_BITS |\n\t\t\t\tAUDIO_PCM_CHANNELS_STEREO,\n\t\t\t.frame_clk_freq = 48000,\n\t\t\t.mem_slab = NULL,\n\t\t\t.timeout = 0,\n\t\t},\n\t};\n\n\treturn audio_codec_configure(dev, &cfg);\n}", "CodeBleu_score": 52.904962994928795}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    struct mpxxdtyy_data *data = dev->data;\n    int ret = 0;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state == MPXXDTYY_STATE_CONFIGURED) {\n                ret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n                if (ret) {\n                    LOG_ERR(\"Failed to start I2S reception (%d)\", ret);\n                } else {\n                    data->state = MPXXDTYY_STATE_ACTIVE;\n                }\n            } else {\n                ret = -EIO;\n            }\n            break;\n        case DMIC_TRIGGER_STOP:\n            if (data->state == MPXXDTYY_STATE_ACTIVE) {\n                ret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n                if (ret) {\n                    LOG_ERR(\"Failed to stop I2S reception (%d)\", ret);\n                } else {\n                    data->state = MPXXDTYY_STATE_CONFIGURED;\n                }\n            } else {\n                ret = -EIO;\n            }\n            break;\n        default:\n            ret = -ENOTSUP;\n            break;\n    }\n\n    return ret;\n}", "CodeBleu_score": 54.44832647289953}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    struct mpxxdtyy_data *data = dev->data;\n    int ret = 0;\n    enum i2s_dir dir;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            dir = I2S_DIR_RX;\n            break;\n        case DMIC_TRIGGER_STOP:\n            dir = I2S_DIR_RX;\n            break;\n        default:\n            return -EINVAL;\n    }\n\n    ret = i2s_trigger(data->i2s_dev, dir, cmd);\n    if (ret < 0) {\n        LOG_ERR(\"I2S trigger failed (%d)\", ret);\n        return ret;\n    }\n\n    return 0;\n}", "CodeBleu_score": 43.45615817081225}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    struct mpxxdtyy_data *data = dev->data;\n    int ret = 0;\n    enum mpxxdtyy_state state = data->state;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            switch (state) {\n                case MPXXDTYY_STATE_CONFIGURED:\n                    LOG_DBG(\"Starting\");\n                    ret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n                    if (ret) {\n                        LOG_ERR(\"Failed to start I2S\");\n                        break;\n                    }\n                    data->state = MPXXDTYY_STATE_ACTIVE;\n                    break;\n                case MPXXDTYY_STATE_ACTIVE:\n                    LOG_ERR(\"Device is already active\");\n                    ret = -EINVAL;\n                    break;\n                default:\n                    LOG_ERR(\"Device is in invalid state\");\n                    ret = -EINVAL;\n                    break;\n            }\n            break;\n        case DMIC_TRIGGER_STOP:\n            switch (state) {\n                case MPXXDTYY_STATE_ACTIVE:\n                    LOG_DBG(\"Stopping\");\n                    ret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n                    if (ret) {\n                        LOG_ERR(\"Failed to stop I2S\");\n                        break;\n                    }\n                    data->state = MPXXDTYY_STATE_CONFIGURED;\n                    break;\n                case MPXXDTYY_STATE_CONFIGURED:\n                    LOG_ERR(\"Device is already configured\");\n                    ret = -EINVAL;\n                    break;\n                default:\n                    LOG_ERR(\"Device is in invalid state\");\n                    ret = -EINVAL;\n                    break;\n            }\n            break;\n        default:\n            LOG_ERR(\"Invalid DMIC trigger command\");\n            ret = -EINVAL;\n            break;\n   ", "CodeBleu_score": 44.56878257098541}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tstruct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t command = config->display_mode_cmd;\n\n\tif (enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->blink_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_send_command(dev, command);\n}", "CodeBleu_score": 61.6731146670038}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = 0;\n\tuint8_t flags = 0;\n\n\tif (enabled) {\n\t\tflags |= HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tflags |= HD44780_CURSOR_ON;\n\t}\n\n\tif (data->cursor_blink_enabled) {\n\t\tflags |= HD44780_CURSOR_BLINK_ON;\n\t}\n\n\tcmd = HD44780_DISPLAY_MODE_SET | flags;\n\tauxdisplay_hd44780_write_command(dev, cmd);\n}", "CodeBleu_score": 60.66970284584821}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = 0;\n\tuint8_t val = 0;\n\n\tif (enabled) {\n\t\tval = BIT(LCD_DISPLAY_ON);\n\t}\n\n\tif (data->cursor_on) {\n\t\tval |= BIT(LCD_CURSOR_ON);\n\t}\n\n\tif (data->blink_on) {\n\t\tval |= BIT(LCD_BLINK_ON);\n\t}\n\n\tcmd = LCD_FUNCTION_SET | LCD_FUNCTION_SET_N;\n\tauxdisplay_hd44780_send_command(dev, cmd);\n\n\tcmd = LCD_DISPLAY_CONTROL | val;\n\tauxdisplay_hd44780_send_command(dev, cmd);\n}", "CodeBleu_score": 54.65701788321613}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n    if (!config->busy_port) {\n        return -ENOTSUP;\n    }\n    int status = gpio_pin_get(config->busy_port, config->busy_pin);\n    if (status < 0) {\n        LOG_ERR(\"Failed to get busy status (err %d)\", status);\n        return status;\n    }\n    return status;\n}", "CodeBleu_score": 61.369999958805025}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n    const struct device *busy_gpio_dev = device_get_binding(config->busy_gpio_port);\n    if (busy_gpio_dev == NULL) {\n        LOG_ERR(\"Busy GPIO port %s not found\", config->busy_gpio_port);\n        return -ENOTSUP;\n    }\n    int busy = gpio_pin_get(busy_gpio_dev, config->busy_gpio_pin);\n    return busy;\n}", "CodeBleu_score": 60.837378017322486}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\n\tif (!config->busy_gpio_port) {\n\t\tLOG_ERR(\"Busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 36.969914407416475}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\n\tuint8_t buffer[2];\n\n\tbuffer[0] = config->special_command_prefix;\n\n\tbuffer[1] = command;\n\n\tint err = i2c_write(config->i2c, buffer, sizeof(buffer),\n\t\t\t    config->i2c_address);\n\n\tk_msleep(config->special_command_delay);\n\n\treturn err;\n}", "CodeBleu_score": 64.05294459134514}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = (uint8_t) command;\n\n\tret = i2c_write(config->i2c_dev, buffer, sizeof(buffer), config->i2c_address);\n\n\tk_busy_wait(config->special_command_delay);\n\n\treturn ret;\n}", "CodeBleu_score": 64.27239254768824}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2] = {config->special_command_prefix, command};\n\tint err = i2c_write(config->i2c, buf, sizeof(buf), config->i2c_addr);\n\tk_msleep(config->command_delay);\n\treturn err;\n}", "CodeBleu_score": 52.781812201443415}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (offset + size > dev_data->size) {\n\t\tLOG_ERR(\"read exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data) {\n\t\tLOG_ERR(\"no data buffer provided\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, dev_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.25261766580361}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *emul = dev->data;\n\n\tif (offset + size > emul->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(data, &emul->data[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 50.10172395996385}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (offset + size > dev_data->size) {\n\t\tLOG_ERR(\"Attempt to read outside of the device memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\tLOG_ERR(\"Attempt to read to a NULL buffer\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, dev_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.38325302090857}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ctx = dev->data;\n\tuint8_t *bbram_data = data_ctx->bbram_data;\n\tsize_t bbram_size = data_ctx->bbram_size;\n\tuint8_t *bbram_status = data_ctx->bbram_status;\n\n\tif (size == 0) {\n\t\tLOG_ERR(\"Write size must be greater than 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram_size) {\n\t\tLOG_ERR(\"Write size must not exceed the size of the BBRAM\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*bbram_status == BBRAM_STATUS_INVALID) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(bbram_data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 54.76230212104636}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *emul_data = dev->data;\n\n\tif (emul_data->state == BBRAM_EMUL_STATE_INVALID) {\n\t\treturn -EIO;\n\t}\n\n\tif (size == 0 || size > emul_data->size || offset + size > emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(emul_data->data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.62278627122615}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_cfg *cfg = dev->config;\n\tuint8_t *ram = cfg->ram;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->state == BBRAM_EMUL_STATE_INVALID) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(ram + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 62.134127556439}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Insufficient arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"BBRAM device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 81.75761869776798}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\t*bbram_dev = DEVICE_DT_GET_ANY(zephyr_bbram);\n\tif (!device_is_ready(*bbram_dev)) {\n\t\tshell_error(sh, \"BBRAM device not ready\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 44.78093121738059}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\t*bbram_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_bram_battery_backed));\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"BBRAM device not found\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 49.80306047291386}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint err;\n\tuint8_t hdr_len = 4;\n\tuint8_t hdr_bytes = 0;\n\tuint8_t hdr[4];\n\twhile (hdr_len) {\n\t\terr = uart_fifo_read(dev, hdr, hdr_len);\n\t\tif (err < 0) {\n\t\t\tBT_ERR(\"Unable to read from UART (err %d)\", err);\n\t\t\treturn;\n\t\t}\n\t\thdr_bytes += err;\n\t\thdr_len -= err;\n\t}\n\tBT_DBG(\"H: %02x %02x %02x %02x\", hdr[0], hdr[1], hdr[2], hdr[3]);\n\tswitch (hdr[0]) {\n\t\tcase H4_EVT:\n\t\t\tbt_buf_set_type(bt_hci_evt_create(bt_buf_get_rx_data(),\n\t\t\t\t\t\thdr[2], hdr[3]));\n\t\t\tbreak;\n\t\tcase H4_ACL:\n\t\t\tbt_buf_set_type(bt_hci_acl_create(bt_buf_get_rx_data(),\n\t\t\t\t\t\tsys_le16_to_cpu(hdr[2]),\n\t\t\t\t\t\thdr[3]));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBT_ERR(\"Unknown H:4 type 0x%02x\", hdr[0]);\n\t\t\treturn;\n\t}\n}", "CodeBleu_score": 25.77485010594001}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint err;\n\tuint8_t hdr[4];\n\tuint8_t *ptr = hdr;\n\tsize_t to_read = sizeof(hdr);\n\tsize_t read;\n\twhile (to_read) {\n\t\tread = to_read;\n\t\terr = uart_fifo_read(dev, ptr, read);\n\t\tif (err) {\n\t\t\tBT_ERR(\"Unable to read from FIFO (err %d)\", err);\n\t\t\treturn;\n\t\t}\n\t\tto_read -= read;\n\t\tptr += read;\n\t}\n\tBT_DBG(\"type 0x%02x len %u\", hdr[0], bt_get_le16(&hdr[1]));\n\tnet_buf_simple_init(bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, 3), 0)->len = 3;\n}", "CodeBleu_score": 26.07123329104402}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    int err;\n    int8_t hdr_bytes_read = 0;\n    int8_t remaining_bytes = sizeof(struct bt_hci_acl_hdr);\n    uint8_t *hdr_buf = (uint8_t *)&bt_hci_acl_hdr;\n\n    while (remaining_bytes) {\n        err = uart_fifo_read(dev, hdr_buf + hdr_bytes_read, remaining_bytes);\n        if (err < 0) {\n            LOG_ERR(\"Failed to read from UART device (%d)\", err);\n            return;\n        }\n        remaining_bytes -= err;\n        hdr_bytes_read += err;\n    }\n}", "CodeBleu_score": 30.408427599671523}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read;\n\tint err;\n\n\twhile (len) {\n\t\tread = min(len, sizeof(buf));\n\t\terr = uart_fifo_read(uart, buf, read);\n\t\tif (err) {\n\t\t\tBT_ERR(\"Failed to read from FIFO (%d)\", err);\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= read;\n\t}\n\n\treturn read;\n}", "CodeBleu_score": 53.002364924890486}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read;\n\tint err;\n\twhile (len) {\n\t\tread = MIN(len, sizeof(buf));\n\t\terr = uart_fifo_read(uart, buf, read);\n\t\tif (err) {\n\t\t\tLOG_ERR(\"Failed to read %zu bytes (%d)\", read, err);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= read;\n\t}\n\treturn read;\n}", "CodeBleu_score": 49.48169840605738}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read;\n\twhile (len) {\n\t\tread = len > 32 ? 32 : len;\n\t\tif (uart_fifo_read(uart, buf, read) < 0) {\n\t\t\tLOG_ERR(\"Failed to discard %zu bytes\", len);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= read;\n\t}\n\treturn len;\n}", "CodeBleu_score": 44.37094339226258}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t hop = 0;\n\tconst struct zbus_observer *observer;\n\n\tfor (observer = zbus_observer_iter_begin(chan);\n\t\tobserver != zbus_observer_iter_end(chan);\n\t\tobserver = zbus_observer_iter_next(observer)) {\n\t\tif (observer->enabled && observer->priority < hop) {\n\t\t\thop = observer->priority;\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = hop;\n}", "CodeBleu_score": 24.873529217995067}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    const struct zbus_observer *observer;\n    int hop = 0;\n\n    for (observer = __start_zbus_observers_section; observer < __stop_zbus_observers_section; observer++) {\n        if (observer->channel == chan && observer->enabled && observer->priority < hop) {\n            hop = observer->priority;\n        }\n    }\n\n    chan->highest_observer_priority = hop;\n}", "CodeBleu_score": 24.58206176053564}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *observer;\n\tint hop = ZBUS_OBSERVER_PRIORITY_MAX;\n\n\tfor (observer = zbus_observer_iter_get(chan); observer; observer = zbus_observer_iter_get(chan)) {\n\t\tif ((observer->priority < hop) && (observer->enabled)) {\n\t\t\thop = observer->priority;\n\t\t}\n\t}\n\n\tchan->hop = hop;\n}", "CodeBleu_score": 22.597554368304877}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observer *ch_obs;\n\n\tfor (ch_obs = __start_zbus_channel_observers; ch_obs < __stop_zbus_channel_observers; ch_obs++) {\n\t\tif (ch_obs->obs == obs) {\n\t\t\tch_obs->update_hop(ch_obs->channel);\n\t\t}\n\t}\n}", "CodeBleu_score": 20.523273507664975}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tconst struct zbus_channel_observer *ch_obs;\n\tconst struct zbus_channel *ch;\n\tfor (ch_obs = __start_zbus_channel_observers; ch_obs < __stop_zbus_channel_observers; ch_obs++) {\n\t\tch = ch_obs->channel;\n\t\tif (ch_obs->observer == obs) {\n\t\t\tzbus_channel_update_hop(ch);\n\t\t}\n\t}\n}", "CodeBleu_score": 18.08510793437778}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *obs_channel;\n\n\tfor (obs_channel = __start_zbus_channel_observations; obs_channel < __stop_zbus_channel_observations; obs_channel++) {\n\t\tif (obs_channel->observer == obs) {\n\t\t\tzbus_channel_update_hop(obs_channel->channel);\n\t\t}\n\t}\n}", "CodeBleu_score": 22.970884528721434}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t__ASSERT(!k_is_in_isr(), \"Cannot attach an observer from an ISR\");\n\t__ASSERT(obs, \"Observer is NULL\");\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\tobs->prio = K_LOWEST_THREAD_PRIO;\n\tfor (const struct zbus_channel *ch = __start_zbus_channels; ch < __stop_zbus_channels; ch++) {\n\t\tif (ch->obs == obs) {\n\t\t\tch->obs = NULL;\n\t\t}\n\t}\n\tk_spin_unlock(&zbus_lock, key);\n\treturn 0;\n}", "CodeBleu_score": 49.9812040460441}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    z_sched_lock();\n    obs->priority = K_LOWEST_THREAD_PRIO;\n    for (const struct zbus_channel *chan = __start_zbus_channels_section; chan < __stop_zbus_channels_section; chan++) {\n        chan->observer = obs;\n    }\n    z_sched_unlock();\n    return 0;\n}", "CodeBleu_score": 35.74158314926039}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tassert(obs != NULL);\n\tassert(!k_is_in_isr());\n\n\tstruct k_thread *thread = obs->thread;\n\tassert(thread != NULL);\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\n\tobs->priority = K_LOWEST_THREAD_PRIO;\n\tfor (const struct zbus_channel *channel = _zbus_channels_start; channel != _zbus_channels_end; channel++) {\n\t\tif (channel->observer == obs) {\n\t\t\tchannel->priority = obs->priority;\n\t\t}\n\t}\n\n\tk_spin_unlock(&zbus_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 43.63837105210052}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\tunsigned int key;\n\tk_ticks_t end = 0;\n\tstruct k_thread *thread = NULL;\n\tstruct k_thread *caller = k_current_get();\n\tk_spinlock_key_t spin_key = k_spin_lock(&chan->lock);\n\n\t/*\n\t * If the channel is null, return an error.\n\t */\n\tif (chan == NULL) {\n\t\tk_spin_unlock(&chan->lock, spin_key);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If the timeout is infinite, set the end to 0.\n\t */\n\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\tend = 0;\n\t}\n\t/*\n\t * If the timeout is not infinite, calculate the end time.\n\t */\n\telse {\n\t\tend = k_ticks_add(k_uptime_ticks(), k_ticks_t(timeout));\n\t}\n\n\t/*\n\t * If the caller is a thread, set the thread to the caller.\n\t */\n\tif (caller != NULL) {\n\t\tthread = caller;\n\t}\n\n\t/*\n\t * If the channel is not empty, return 0.\n\t */\n\tif (chan->thread_count > 0) {\n\t\tk_spin_unlock(&chan->lock, spin_key);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the channel is empty, set the channel's thread count to 1.\n\t */\n\tchan->thread_count = 1;\n\n\t/*\n\t * If the channel is not empty, return 0.\n\t */\n\tif (chan->thread_count > 0) {\n\t\tk_spin_unlock(&chan->lock, spin_key);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the channel is empty, set the channel's thread count to 1.\n\t */\n\tchan->thread_count = 1;\n\n\t/*\n\t * If the channel is empty, set the channel'", "CodeBleu_score": 39.98729387390652}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\n\t__ASSERT_NO_MSG(chan != NULL);\n\n\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\ttimeout = K_MSEC(10000);\n\t}\n\n\tif (IS_ENABLED(CONFIG_ZBUS_CHAN_DEBUG)) {\n\t\tLOG_DBG(\"notifying channel %p\", chan);\n\t}\n\n\terr = zbus_chan_lock(chan);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (IS_ENABLED(CONFIG_ZBUS_CHAN_DEBUG)) {\n\t\tLOG_DBG(\"locked channel %p\", chan);\n\t}\n\n\terr = zbus_chan_notify_locked(chan, timeout);\n\n\tif (IS_ENABLED(CONFIG_ZBUS_CHAN_DEBUG)) {\n\t\tLOG_DBG(\"unlocking channel %p\", chan);\n\t}\n\n\tzbus_chan_unlock(chan);\n\n\tif (IS_ENABLED(CONFIG_ZBUS_CHAN_DEBUG)) {\n\t\tLOG_DBG(\"unlocked channel %p\", chan);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 50.68170158935574}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tif (!chan) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PREEMPT_ENABLED) && z_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timeout_t end_time = z_timeout_end_calc(timeout);\n\tstruct zbus_context ctx = {\n\t\t.prio = z_is_in_isr() ? _IRQ_PRIO_OFFSET : _current->base.prio,\n\t\t.end_time = end_time,\n\t};\n\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\tint err = zbus_chan_notify_locked(chan, &ctx);\n\tk_spin_unlock(&chan->lock, key);\n\n\treturn err;\n}", "CodeBleu_score": 31.743980278244223}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  assert_param(IS_ETH_INT(Int));\n  \n  if (enable) {\n    if (Int & ETH_INT_NORMAL) {\n      ETH->INT_ENABLE |= (Int & ETH_INT_NORMAL);\n    }\n    \n    if (Int & ETH_INT_ABNORMAL) {\n      ETH->INT_ENABLE |= (Int & ETH_INT_ABNORMAL);\n    }\n  } else {\n    if (Int & ETH_INT_NORMAL) {\n      ETH->INT_ENABLE &= ~(Int & ETH_INT_NORMAL);\n    }\n    \n    if (Int & ETH_INT_ABNORMAL) {\n      ETH->INT_ENABLE &= ~(Int & ETH_INT_ABNORMAL);\n    }\n  }\n}", "CodeBleu_score": 51.937047467572214}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  if (Int & ETH_INT_NORMAL_MASK) {\n    if (enable) {\n      ETH->INT_EN |= Int & ETH_INT_NORMAL_MASK;\n    } else {\n      ETH->INT_EN &= ~(Int & ETH_INT_NORMAL_MASK);\n    }\n  }\n  \n  if (Int & ETH_INT_ABNORMAL_MASK) {\n    if (enable) {\n      ETH->INT_EN |= Int & ETH_INT_ABNORMAL_MASK;\n    } else {\n      ETH->INT_EN &= ~(Int & ETH_INT_ABNORMAL_MASK);\n    }\n  }\n}", "CodeBleu_score": 42.117818587924084}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  assert_param(IS_ETH_INT(Int));\n  \n  if (enable) {\n    if (IS_ETH_INT_NORMAL(Int)) {\n      ETH->IER |= Int;\n    } else {\n      ETH->IER |= ETH_IER_NIE;\n      ETH->IER |= Int;\n    }\n  } else {\n    if (IS_ETH_INT_NORMAL(Int)) {\n      ETH->IER &= ~Int;\n    } else {\n      ETH->IER &= ~Int;\n      if (!IS_ETH_INT_NORMAL(ETH->IER)) {\n        ETH->IER &= ~ETH_IER_NIE;\n      }\n    }\n  }\n}", "CodeBleu_score": 58.02979710006068}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\t\n\tpTxDesc = (ETH_TX_DESC *)ETH->TX_DESC_LIST_ADDR;\n\t\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\tif (pTxDesc->CTRL_STAT & ETH_TX_DESC_CTRL_STAT_OWN) {\n\t\t\tpTxDesc++;\n\t\t} else {\n\t\t\treturn pTxDesc;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "CodeBleu_score": 33.86651708322384}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc = (ETH_TX_DESC *)(ETH->TX_DESC_LIST_ADDR);\n\tETH_TX_DESC *pTxDescStart = pTxDesc;\n\n\twhile (pTxDesc->Status.Word & ETH_TX_DESC_OWN_BIT) {\n\t\tpTxDesc++;\n\n\t\tif (pTxDesc >= (ETH_TX_DESC *)(ETH->TX_DESC_LIST_ADDR + ETH->TX_DESC_LIST_SIZE)) {\n\t\t\tpTxDesc = (ETH_TX_DESC *)(ETH->TX_DESC_LIST_ADDR);\n\t\t}\n\n\t\tif (pTxDesc == pTxDescStart) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn pTxDesc;\n}", "CodeBleu_score": 32.852074391131154}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc = (ETH_TX_DESC *)ETH->TX_DESC_LIST_ADDR;\n\tETH_TX_DESC *start_tx_desc = tx_desc;\n\t\n\tdo {\n\t\tif (tx_desc->TDES0 & ETH_TDES0_OWN) {\n\t\t\ttx_desc++;\n\t\t} else {\n\t\t\treturn tx_desc;\n\t\t}\n\t} while (tx_desc != start_tx_desc);\n\t\n\treturn 0;\n}", "CodeBleu_score": 46.65956127929155}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    struct rt_dac_dev_adc *adc = (struct rt_dac_dev_adc *)device;\n    struct rt_dac_adc_channel *adc_channel = &adc->adc_channel[channel];\n\n    if (adc_channel->init == RT_FALSE) {\n        rt_kprintf(\"ADC channel %d not init\n\", channel);\n        return RT_ERROR;\n    }\n\n    Cy_CSDIDAC_OutputEnable(adc_channel->adc_channel, *value);\n\n    return RT_EOK;\n}", "CodeBleu_score": 53.06371872766942}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    struct rt_dac_dev_data *data = (struct rt_dac_dev_data *)(device->parent.user_data);\n    struct cyp_dac_device *dac_dev = (struct cyp_dac_device *)(data->user_data);\n    RT_ASSERT(dac_dev != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n    RT_ASSERT(channel < dac_dev->channel_num);\n    Cy_CSDIDAC_OutputEnable(dac_dev->dac_base, channel, *value);\n    return RT_EOK;\n}", "CodeBleu_score": 48.53619661369971}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    struct rt_dac_dev *dac_dev = (struct rt_dac_dev *)device;\n    RT_ASSERT(dac_dev != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n    RT_ASSERT(channel < dac_dev->channel_count);\n\n    Cy_CSDIDAC_OutputSet(CY_CSDIDAC_HW, *value);\n    Cy_CSDIDAC_OutputEnable(CY_CSDIDAC_HW);\n\n    return RT_EOK;\n}", "CodeBleu_score": 48.06089142944738}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > IFX_FLASH_32K_END_ADDRESS) {\n        LOG_E(\"read out of flash size! addr is (0x%p)\", (void *)(addr + size));\n        return -RT_EINVAL;\n    }\n\n    for (rt_uint32_t i = 0; i < size; i++, buf++, addr++) {\n        *buf = *(rt_uint8_t *) addr;\n    }\n\n    return size;\n}", "CodeBleu_score": 76.57452683124161}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    int i;\n    rt_uint32_t *p = (rt_uint32_t *)buf;\n\n    if (addr + size > IFX_FLASH_32K_END_ADDR) {\n        rt_kprintf(\"invalid address\n\");\n        return -1;\n    }\n\n    for (i = 0; i < size; i += 4) {\n        *p++ = *(rt_uint32_t *)(addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 45.916843348387715}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n\n    if ((addr + size) > IFX_FLASH_32K_END_ADDRESS) {\n        LOG_E(\"ifx_flash_read_32k: Invalid argument.\");\n        return -RT_EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *) (addr + i);\n    }\n\n    return i;\n}", "CodeBleu_score": 60.252857957130715}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\n    rt_uint32_t count = 0;\n\n    RT_ASSERT(timer != RT_NULL);\n\n    count = cyhal_timer_read(timer->parent.user_data);\n\n    return count;\n}", "CodeBleu_score": 53.71537277624555}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    rt_uint32_t count = 0;\n    if (timer == RT_NULL) {\n        return 0;\n    }\n    count = cyhal_timer_read(timer->parent.user_data);\n    return count;\n}", "CodeBleu_score": 50.81906932398342}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    rt_uint32_t count;\n\n    RT_ASSERT(timer != RT_NULL);\n\n    count = cyhal_timer_read((cyhal_timer_t *)timer->parent.user_data);\n\n    return count;\n}", "CodeBleu_score": 63.96096379719513}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    int result;\n\n    /* Try to take the mutex */\n    result = rt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n\n    /* Check if the mutex was successfully taken */\n    RT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 14.193044979208178}, {"code": "void dfs_lock(void){\n\t\n\tint ret;\n\n\t/* Try to take the mutex lock */\n\tret = rt_mutex_take(&dfs_lock, RT_WAITING_FOREVER);\n\n\t/* If the mutex is not available, trigger an assertion failure */\n\tif (ret != RT_EOK) {\n\t\trt_kprintf(\"dfs_lock: failed to take the mutex lock\n\");\n\t\tRT_ASSERT(0);\n\t}\n}", "CodeBleu_score": 27.0141107093259}, {"code": "void dfs_lock(void){\n\t    if (rt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER) != RT_EOK) {\n        rt_kprintf(\"dfs_lock: mutex take failed\n\");\n        RT_ASSERT(0);\n    }\n}", "CodeBleu_score": 24.21444416670648}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* expand the fd table */\n    if (fdt->maxfd >= DFS_FD_MAX) {\n        return -1;\n    }\n\n    fd = fdt->maxfd;\n    fdt->fds[fd] = NULL;\n    fdt->maxfd++;\n\n    return fd;\n}", "CodeBleu_score": 42.005779533046464}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* expand the file descriptor table */\n    if (fdt->maxfd >= DFS_FD_MAX) {\n        return -1;\n    }\n\n    /* allocate a new file descriptor */\n    fd = fdt->maxfd;\n    fdt->maxfd++;\n\n    return fd;\n}", "CodeBleu_score": 41.286391141473274}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* try to expand fd table */\n    if (fdt->maxfd >= DFS_FD_MAX) {\n        return -1;\n    }\n\n    /* find the first free fd */\n    for (fd = fdt->maxfd; fd < DFS_FD_MAX; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            break;\n        }\n    }\n\n    /* expand fd table to fd */\n    if (fd_expand_table(fdt, fd) != 0) {\n        return -1;\n    }\n\n    return fd;\n}", "CodeBleu_score": 50.53011308726736}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n\n    if (error >= RT_ERROR_MAX) {\n        return \"EUNKNOW\";\n    }\n\n    return rt_error_str[error];\n}", "CodeBleu_score": 30.7469486133236}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error == RT_EOK) {\n        return \"no error\";\n    }\n\n    if (error > 0) {\n        error = -error;\n    }\n\n    switch (error) {\n    case RT_ERROR:\n        return \"error\";\n    case RT_ETIMEOUT:\n        return \"timeout\";\n    case RT_EFULL:\n        return \"full\";\n    case RT_EEMPTY:\n        return \"empty\";\n    case RT_ENOMEM:\n        return \"no memory\";\n    case RT_ENOSYS:\n        return \"no system\";\n    case RT_EBUSY:\n        return \"busy\";\n    case RT_EIO:\n        return \"io error\";\n    case RT_EINTR:\n        return \"interrupted system call\";\n    case RT_EINVAL:\n        return \"invalid argument\";\n    default:\n        break;\n    }\n\n    return \"unknown error\";\n}", "CodeBleu_score": 32.85895867302439}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\n    if (error >= 0) {\n\n        return (const char *)error;\n\n    }\n\n\n\n    switch (error) {\n\n    case RT_ERROR:\n\n        return \"RT_ERROR\";\n\n    case RT_ETIMEOUT:\n\n        return \"RT_ETIMEOUT\";\n\n    case RT_EFULL:\n\n        return \"RT_EFULL\";\n\n    case RT_EEMPTY:\n\n        return \"RT_EEMPTY\";\n\n    case RT_ENOMEM:\n\n        return \"RT_ENOMEM\";\n\n    case RT_ENOSYS:\n\n        return \"RT_ENOSYS\";\n\n    case RT_EBUSY:\n\n        return \"RT_EBUSY\";\n\n    case RT_EIO:\n\n        return \"RT_EIO\";\n\n    case RT_EINTR:\n\n        return \"RT_EINTR\";\n\n    case RT_EINVAL:\n\n        return \"RT_EINVAL\";\n\n    }\n\n\n\n    return \"EUNKNOW\";\n\n}", "CodeBleu_score": 32.059049382595646}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    int i;\n\n    rt_base_t level;\n    rt_slist_t *node;\n\n    level = rt_hw_interrupt_disable();\n\n    node = RT_NULL;\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            node = &(idle_hook_list[i]);\n            break;\n        }\n    }\n\n    if (node != RT_NULL) {\n        rt_slist_insert(node, (rt_slist_t *)hook);\n        rt_hw_interrupt_enable(level);\n        return RT_EOK;\n    }\n\n    rt_hw_interrupt_enable(level);\n    return -RT_EFULL;\n}", "CodeBleu_score": 62.101753244587734}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t ret = RT_EOK;\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* try to find idle hook */\n    if (rt_thread_idle_hook_list_size < RT_IDLE_HOOK_LIST_SIZE) {\n        rt_thread_idle_hook_list[rt_thread_idle_hook_list_size] = hook;\n        rt_thread_idle_hook_list_size++;\n    } else {\n        ret = -RT_EFULL;\n    }\n\n    /* enable interrupt */\n    rt_exit_critical();\n\n    return ret;\n}", "CodeBleu_score": 28.930907091235326}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\n\trt_err_t result;\n\n\trt_enter_critical();\n\n\t/* \u904d\u5386\u7a7a\u95f2\u7ebf\u7a0b\u94a9\u5b50\u5217\u8868\uff0c\u5bfb\u627e\u4e00\u4e2a\u7a7a\u95f2\u7684\u94a9\u5b50 */\n\t{\n\t\tstruct rt_thread *tidle = &rt_thread_idle;\n\t\trt_uint32_t number = 0;\n\t\trt_uint32_t *ptr = (rt_uint32_t *)&tidle->user_data;\n\n\t\twhile (number < RT_IDLE_HOOK_LIST_SIZE) {\n\t\t\tif (*ptr == 0) {\n\t\t\t\t*ptr = (rt_uint32_t)hook;\n\t\t\t\tresult = RT_EOK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr ++;\n\t\t\tnumber ++;\n\t\t}\n\n\t\tif (number >= RT_IDLE_HOOK_LIST_SIZE) {\n\t\t\tresult = -RT_EFULL;\n\t\t}\n\t}\n\n\trt_exit_critical();\n\n\treturn result;\n}", "CodeBleu_score": 38.43312301554763}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t level;\n    struct rt_thread *thread;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n    /* find idle thread */\n    thread = rt_list_entry(&(rt_thread_defunct.list), struct rt_thread, list);\n    RT_ASSERT(thread != RT_NULL);\n\n    /* remove hook */\n    result = rt_thread_idle_delhook_locked(thread, hook);\n\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 23.87403051510261}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* check whether hook is already in list */\n    if (rt_thread_idle_hook_list != RT_NULL) {\n        struct rt_thread_idle_hook *head = rt_thread_idle_hook_list;\n        struct rt_thread_idle_hook *next = head->next;\n\n        do {\n            if (next == RT_NULL) {\n                break;\n            }\n\n            /* find out the specified hook */\n            if (next->hook_func == hook) {\n                head->next = next->next;\n                rt_free(next);\n                result = RT_EOK;\n                break;\n            }\n\n            head = next;\n            next = next->next;\n        } while (1);\n    } else {\n        result = -RT_ERROR;\n    }\n\n    /* enable interrupt */\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 33.76947548969695}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t level;\n    struct rt_object *object;\n    struct rt_list_node *node;\n\n    level = rt_hw_interrupt_disable();\n\n    /* try to find the idle hook entry */\n    result = -RT_ENOSYS;\n    rt_object_foreach(object, RT_Object_Class_Hook) {\n        if (object->id == RT_Object_Class_IdleHook) {\n            struct rt_idle_hook *idle_hook;\n\n            idle_hook = (struct rt_idle_hook *) object;\n            if (idle_hook->hook_func == hook) {\n                /* remove idle hook */\n                rt_list_remove(&idle_hook->list);\n\n                /* release the hook list */\n                rt_object_delete(&idle_hook->parent);\n\n                result = RT_EOK;\n                break;\n            }\n        }\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 34.02096598111215}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\n    rt_thread_t thread;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (\"resume all thread in suspend list\n\"));\n\n    /*\n     * The scheduler is unlocked before resuming all threads in the list.\n     * This is because the threads may be resumed on a different CPU\n     * than the one that suspended them.\n     */\n    rt_exit_critical();\n\n    while (!rt_list_isempty(susp_list)) {\n\n        /*\n         * The thread is dequeued from the list before being woken up.\n         * This is because the wakeup function will try to re-acquire the\n         * scheduler lock.\n         */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n        rt_list_remove(&thread->tlist);\n\n        /*\n         * The thread is woken up with the error code.\n         */\n        rt_thread_resume(thread);\n\n        rt_thread_error_set(thread, thread_error);\n\n        rt_schedule();\n    }\n\n    rt_enter_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 37.463227573234946}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_list_t *node;\n    rt_list_t *next;\n\n    /*\n     * If the list is empty, return immediately.\n     */\n    if (rt_list_isempty(susp_list)) {\n        return RT_EOK;\n    }\n\n    /*\n     * Unlock the scheduler.\n     */\n    rt_exit_critical();\n\n    /*\n     * Dequeue and wake up each thread in the list.\n     */\n    for (node = susp_list->next; node != susp_list; node = next) {\n        next = node->next;\n\n        /*\n         * Get the thread in the list.\n         */\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n\n        /*\n         * Remove the thread from the list.\n         */\n        rt_list_remove(node);\n\n        /*\n         * Resume the thread.\n         */\n        rt_thread_resume(thread);\n\n        /*\n         * Set the thread error.\n         */\n        thread->error = thread_error;\n\n        /*\n         * Unlock the scheduler.\n         */\n        rt_exit_critical();\n\n        /*\n         * Lock the scheduler.\n         */\n        rt_enter_critical();\n    }\n\n    /*\n     * Lock the scheduler.\n     */\n    rt_enter_critical();\n\n    /*\n     * Return successfully.\n     */\n    return RT_EOK;\n}", "CodeBleu_score": 35.60586553092111}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /*\n     * It ensures the scheduler is unlocked.\n     */\n    rt_enter_critical();\n\n    /*\n     * It dequeues and wakes up each suspended thread from the list one by one until the list is empty.\n     */\n    while (!rt_list_isempty(susp_list)) {\n        /*\n         * It dequeues a suspended thread from the list.\n         */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n        /*\n         * It sets the error code of the thread.\n         */\n        thread->error = thread_error;\n\n        /*\n         * It wakes up the thread.\n         */\n        rt_thread_resume(thread);\n    }\n\n    /*\n     * It releases the scheduler lock.\n     */\n    rt_exit_critical();\n\n    /*\n     * It returns RT_EOK to indicate successful completion.\n     */\n    return RT_EOK;\n}", "CodeBleu_score": 35.073701481344756}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t new_dev = RT_NULL;\n    rt_device_t old_dev = RT_NULL;\n\n    if (name == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* save old device */\n    old_dev = rt_console_get_device();\n\n    /* find new device */\n    new_dev = rt_device_find(name);\n    if (new_dev == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* check whether is the same device */\n    if (new_dev == old_dev) {\n        return old_dev;\n    }\n\n    /* close old device */\n    if (old_dev != RT_NULL) {\n        rt_device_close(old_dev);\n    }\n\n    /* open new device */\n    if (rt_device_open(new_dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        LOG_E(\"open new console device(%s) failed!\", name);\n        return RT_NULL;\n    }\n\n    /* set new device */\n    rt_console_set_device(new_dev);\n\n    return old_dev;\n}", "CodeBleu_score": 56.133369969291195}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t new_device, old_device;\n\n    /* find new console device */\n    new_device = rt_device_find(name);\n    if (new_device == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* turn off interrupt */\n    rt_enter_critical();\n\n    /* save old console */\n    old_device = rt_console_get_device();\n\n    /* check whether is same device */\n    if (new_device == old_device) {\n        rt_exit_critical();\n        return old_device;\n    }\n\n    /* close old console */\n    if (old_device != RT_NULL) {\n        rt_device_close(old_device);\n    }\n\n    /* open new console */\n    if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        rt_exit_critical();\n        return RT_NULL;\n    }\n\n    /* set new console */\n    rt_console_set_device(new_device);\n\n    /* turn on interrupt */\n    rt_exit_critical();\n\n    return old_device;\n}", "CodeBleu_score": 65.39672483127309}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t new_dev = RT_NULL;\n    rt_device_t old_dev = RT_NULL;\n\n    if (name == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* save the old console device */\n    old_dev = rt_console_get_device();\n\n    /* find the new console device */\n    new_dev = rt_device_find(name);\n    if (new_dev == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* check whether it is the same as the old console device */\n    if (new_dev != old_dev) {\n        /* close the old console device if it exists */\n        if (old_dev != RT_NULL) {\n            rt_device_close(old_dev);\n        }\n\n        /* open the new console device with read/write and stream flags */\n        if (rt_device_open(new_dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n            return RT_NULL;\n        }\n\n        /* set the new console device as the current console device */\n        rt_console_set_device(new_dev);\n    }\n\n    return old_dev;\n}", "CodeBleu_score": 57.207718456164905}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\n    int length = 0;\n    struct rt_object *object;\n    struct rt_list_node *node;\n\n    /* get type mask */\n    type &= ~RT_Object_Class_Static;\n\n    /* which is the first object */\n    node = (struct rt_list_node *)&(rt_object_container[type].object_list);\n\n    /* try to take static object */\n    rt_enter_critical();\n\n    /* get the first node */\n    node = node->next;\n\n    /* iterate over them */\n    while (node != (struct rt_list_node *)&(rt_object_container[type].object_list)) {\n        /* get the object */\n        object = rt_list_entry(node, struct rt_object, list);\n\n        /* get the next node */\n        node = node->next;\n\n        /* calculate length */\n        length ++;\n    }\n\n    rt_exit_critical();\n\n    return length;\n}", "CodeBleu_score": 43.269867132387745}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int length = 0;\n    struct rt_object *object;\n    struct rt_list_node *node;\n\n    /* get object list */\n    rt_object_get_list(type, &node);\n\n    /* iterate object list */\n    rt_list_for_each_entry(object, node, struct rt_object, list) {\n        length ++;\n    }\n\n    return length;\n}", "CodeBleu_score": 30.619606900598406}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int length = 0;\n    struct rt_object *object;\n\n    rt_enter_critical();\n\n    object = rt_object_container[type].next;\n    while (object != &rt_object_container[type]) {\n        length ++;\n        object = object->next;\n    }\n\n    rt_exit_critical();\n\n    return length;\n}", "CodeBleu_score": 34.56254248416356}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_list_t *list;\n    struct rt_object_information *information;\n    rt_uint8_t type;\n\n    if (object == RT_NULL)\n        return;\n\n    type = object->type & ~RT_Object_Class_Static;\n\n    RT_OBJECT_HOOK_CALL(detach_hook, (object));\n\n    information = rt_object_get_information(type);\n    RT_ASSERT(information != RT_NULL);\n\n    rt_enter_critical();\n    list = &(information->object_list);\n\n    rt_list_remove(list, &(object->list));\n\n    rt_exit_critical();\n\n    object->type = RT_Object_Class_None;\n}", "CodeBleu_score": 54.36600762124508}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_list_t *list;\n    struct rt_object *obj;\n\n    if (object == RT_NULL)\n        return;\n\n    list = (rt_list_t *)((rt_uint8_t *)object + sizeof(struct rt_object));\n    obj = (struct rt_object *)((rt_uint8_t *)list - sizeof(struct rt_object));\n\n    rt_object_delete(obj);\n\n    /* unlock the object */\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 17.53481322294886}, {"code": "void rt_object_detach(rt_object_t object){\n\t\n    rt_list_t *list;\n    struct rt_object *obj;\n    struct rt_object_information *information;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n    RT_ASSERT(rt_object_get_type(object) >= RT_Object_Class_Static);\n\n    /* which list */\n    information = rt_object_get_information(object->type);\n    RT_ASSERT(information != RT_NULL);\n\n    list = &(information->object_list);\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* remove from old list */\n    rt_list_remove(&(object->list));\n\n    /* get the first of new list */\n    obj = rt_list_entry(list->next, struct rt_object, list);\n\n    /* determine new list */\n    if (rt_list_isempty(list))\n    {\n        list = &(information->object_list);\n    }\n    else\n    {\n        if (obj->type == object->type)\n        {\n            list = &(information->object_list);\n        }\n        else\n        {\n            information = rt_object_get_information(obj->type);\n            list = &(information->object_list);\n        }\n    }\n\n    /* insert object into list */\n    rt_list_insert_before(list, &(object->list));\n\n    /* enable interrupt */\n    rt_exit_critical();\n}", "CodeBleu_score": 56.077442010455016}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result;\n    struct rt_object *object;\n    struct rt_custom_object *custom_obj;\n\n    object = (struct rt_object *)obj;\n    custom_obj = (struct rt_custom_object *)obj;\n\n    /* check object */\n    RT_ASSERT(object != RT_NULL);\n    RT_ASSERT((object->type & ~RT_Object_Class_Static) == RT_Object_Class_Custom);\n\n    /* invoke destroy function */\n    if (custom_obj->ops->destroy != RT_NULL) {\n        result = custom_obj->ops->destroy(custom_obj);\n    } else {\n        result = RT_EOK;\n    }\n\n    /* delete object */\n    rt_object_delete(object);\n\n    return result;\n}", "CodeBleu_score": 52.66573105063947}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(rt_object_get_type(obj) == RT_Object_Class_Custom);\n\n    if (obj->destroy != RT_NULL) {\n        result = obj->destroy(obj);\n    }\n    rt_object_delete(obj);\n    return result;\n}", "CodeBleu_score": 47.58528133532836}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_custom_object_t custom_obj;\n    rt_err_t result;\n    rt_custom_object_ops_t *ops;\n\n    /* Check if the object is valid and of the custom object class type. */\n    if (obj == RT_NULL || obj->type != RT_Object_Class_Custom) {\n        return RT_ERROR;\n    }\n\n    /* Cast the object to a custom object. */\n    custom_obj = (rt_custom_object_t)obj;\n\n    /* Get the object operations. */\n    ops = custom_obj->ops;\n\n    /* Check if the object has a destroy method. */\n    if (ops->destroy == RT_NULL) {\n        return RT_ERROR;\n    }\n\n    /* Call the destroy method. */\n    result = ops->destroy(custom_obj);\n\n    /* Delete the object. */\n    rt_object_delete(obj);\n\n    /* Return the result of the destroy operation. */\n    return result;\n}", "CodeBleu_score": 49.31258859021593}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\n    rt_thread_t thread;\n    rt_base_t  level;\n\n    thread = rt_thread_self();\n\n    LOG_D(\"thread:%s exit\", thread->name);\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* change stat */\n    thread->stat = RT_THREAD_CLOSE;\n\n    /* remove from schedule */\n    rt_schedule_remove_thread(thread);\n\n    /* add to defunct thread list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* switch to next task */\n    rt_schedule();\n\n    /* never come back */\n}", "CodeBleu_score": 62.35629203601353}, {"code": "static void _thread_exit(void){\n\t    rt_base_t level;\n    struct rt_thread *thread;\n\n    thread = rt_thread_self();\n    LOG_D(\"thread:%s exit\", thread->name);\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* release thread timer */\n    rt_timer_detach(&thread->thread_timer);\n\n    /* change stat */\n    rt_thread_exit(thread);\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* do schedule */\n    rt_schedule();\n}", "CodeBleu_score": 42.19593339929859}, {"code": "static void _thread_exit(void){\n\t    struct rt_thread *thread;\n\n    /* disable interrupt */\n    rt_base_t level;\n    level = rt_hw_interrupt_disable();\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* leave critical */\n    rt_exit_critical();\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* switch to next thread */\n    rt_schedule();\n\n    /* never come here */\n}", "CodeBleu_score": 50.8536466741452}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t)parameter;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n    rt_enter_critical();\n\n    if (rt_object_is_systemobject(&thread->parent.parent) == RT_TRUE) {\n        rt_exit_critical();\n        return;\n    }\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to ready list */\n    rt_thread_ready(thread);\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    rt_exit_critical();\n}", "CodeBleu_score": 46.829293290199104}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t)parameter;\n\n    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (\"thread:%s timeout\n\", thread->name));\n\n    rt_enter_critical();\n\n    /* thread is not suspended, do nothing */\n    if (!thread->scheduler_lock) {\n        goto __exit;\n    }\n\n    /* set thread error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* do scheduler */\n    rt_schedule();\n\n__exit:\n    rt_exit_critical();\n}", "CodeBleu_score": 31.935981622797065}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n\n    thread = (struct rt_thread *)parameter;\n    LOG_D(\"thread:%s timeout\", thread->name);\n\n    rt_enter_critical();\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_exit_critical();\n        return;\n    }\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to ready list */\n    rt_schedule_insert_thread(thread);\n    rt_exit_critical();\n}", "CodeBleu_score": 50.21998677193529}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_ubase_t lock;\n    rt_object_t object;\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* check if the thread is waiting on a mutex */\n    object = thread->pending_object;\n    if (object != RT_NULL) {\n        /* remove the thread from the mutex's waiting list */\n        rt_list_remove(&thread->tlist);\n        /* clear the pending object */\n        thread->pending_object = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    while (thread->hold_mutex != RT_NULL) {\n        rt_mutex_release(thread->hold_mutex);\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n}", "CodeBleu_score": 30.864210588364816}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_ubase_t level;\n    rt_mutex_t mutex;\n\n    RT_ASSERT(thread != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n\n    mutex = thread->pending_object.ptr;\n    if (mutex != RT_NULL) {\n        /* remove from list */\n        rt_list_remove(&(thread->tlist));\n\n        /* clear pending object */\n        thread->pending_object = RT_NULL;\n    }\n\n    /* release all mutexes */\n    while (thread->hold_mutex != RT_NULL) {\n        rt_mutex_release(thread->hold_mutex);\n    }\n\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 36.681368425441725}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_thread_t pthread;\n    rt_list_t *m_list;\n    rt_list_t *n_list;\n    struct rt_mutex *mutex;\n\n    level = rt_hw_interrupt_disable();\n\n    m_list = &(thread->tlist);\n    n_list = m_list->next;\n\n    while (n_list != m_list) {\n        mutex = rt_list_entry(n_list, struct rt_mutex, m_list);\n        pthread = rt_list_entry(mutex->owner_list.next, struct rt_thread, tlist);\n\n        /* remove thread from mutex waiting list */\n        rt_list_remove(&(thread->tlist));\n        /* wakeup the mutex owner thread */\n        rt_thread_resume(pthread);\n        rt_hw_interrupt_enable(level);\n\n        level = rt_hw_interrupt_disable();\n        n_list = m_list->next;\n    }\n\n    /* release all mutexes the thread has taken */\n    m_list = &(thread->m_list);\n    n_list = m_list->next;\n\n    while (n_list != m_list) {\n        mutex = rt_list_entry(n_list, struct rt_mutex, m_list);\n        /* remove thread from mutex list */\n        rt_list_remove(&(thread->m_list));\n        /* change the mutex owner */\n        mutex->owner = RT_NULL;\n\n        rt_hw_interrupt_enable(level);\n\n        level = rt_hw_interrupt_disable();\n        n_list = m_list->next;\n    }\n\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 47.62817622942633}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent) == RT_Object_Class_Thread);\n    RT_ASSERT(rt_object_is_systemobject(&thread->parent));\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->name,\n                  rt_thread_timeout,\n                  thread,\n                  0,\n                  RT_TIMER_FLAG_ONE_SHOT);\n\n    /* thread state check (RUNNING, READY, SUSPEND, INIT) */\n    RT_ASSERT(rt_thread_is_init(thread));\n\n    /* set thread to suspend state */\n    rt_thread_suspend(thread);\n\n    /* set thread to ready state */\n    rt_thread_resume(thread);\n\n    /* invoke scheduler */\n    rt_schedule();\n\n    return RT_EOK;\n}", "CodeBleu_score": 50.81743824919875}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent) == RT_Object_Class_Thread);\n    RT_ASSERT(rt_object_is_systemobject(&thread->parent));\n\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread startup: %s\n\", thread->name));\n\n    result = rt_object_check(&(thread->parent), RT_VALID_STATE);\n    if (result != RT_EOK) {\n        return result;\n    }\n\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread startup: %s, priority: %d, entry: %p, parameter: %p\n\",\n                                  thread->name,\n                                  thread->current_priority,\n                                  thread->entry,\n                                  thread->parameter));\n\n    /* set thread state to suspend */\n    rt_thread_start(thread);\n\n    /* resume thread, do scheduler */\n    rt_thread_resume(thread);\n\n    return RT_EOK;\n}", "CodeBleu_score": 48.07976770050944}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n    RT_ASSERT(rt_object_is_systemobject(&thread->parent.parent));\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->name,\n                  rt_thread_timeout,\n                  thread,\n                  0,\n                  RT_TIMER_FLAG_ONE_SHOT);\n\n    /* thread state check (RUNNING, READY, INIT) */\n    RT_ASSERT(thread->stat != RT_THREAD_CLOSE);\n    RT_ASSERT(thread->stat != RT_THREAD_RUNNING);\n\n    /* change stat */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* initialize thread stack */\n    RT_ASSERT(thread->stack_addr != RT_NULL);\n\n    /* initialize thread entry */\n    thread->entry = RT_NULL;\n\n    /* initialize error number */\n    thread->error = RT_EOK;\n\n    /* initialize thread flags */\n    thread->flags = 0;\n\n    /* initialize thread priority */\n    RT_ASSERT(thread->current_priority >= RT_THREAD_PRIORITY_MAX);\n    thread->current_priority = thread->init_priority;\n    thread->number_mask = 1 << thread->current_priority;\n\n    /* initialize thread tick */\n    thread->init_tick = 0;\n    thread->remaining_tick = 0;\n\n    /* initialize thread error */\n    thread->error = RT_EOK;\n\n    /* initialize cleanup function and user data */\n    thread->cleanup = RT_NULL;\n    thread->user_data = RT_NULL;\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->name,\n                  rt_thread_", "CodeBleu_score": 37.83121776863057}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_err_t ret = RT_ERROR;\n    rt_tick_t timeout = RT_TICK_MAX;\n    rt_list_t *list = RT_NULL;\n    rt_list_t *head = RT_NULL;\n    rt_timer_t *timer = RT_NULL;\n\n    /* check each skip list level */\n    for (list = timer_list; list != timer_list + RT_TIMER_SKIP_LIST_LEVEL; list++) {\n        head = *list;\n\n        /* check whether the level list is empty */\n        if (head != RT_NULL) {\n            timer = rt_list_entry(head, struct rt_timer, row[list - timer_list]);\n\n            /* get the first timer timeout tick */\n            if (timeout > timer->timeout_tick)\n                timeout = timer->timeout_tick;\n        }\n    }\n\n    /* return the timeout tick */\n    if (timeout != RT_TICK_MAX) {\n        *timeout_tick = timeout;\n        ret = RT_EOK;\n    }\n\n    return ret;\n}", "CodeBleu_score": 31.67065072650751}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\n    rt_list_t *head;\n\n    RT_ASSERT(timer_list);\n    RT_ASSERT(timeout_tick);\n\n    /* get the first timer entry */\n    head = timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next;\n\n    if (head != &(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        *timeout_tick = rt_list_entry(head, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1])->timeout_tick;\n\n        return RT_EOK;\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 62.64072887740683}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    struct rt_timer *timer;\n    rt_uint8_t level;\n    rt_list_t *head;\n\n    /* get the first timer */\n    for (level = 0; level < RT_TIMER_SKIP_LIST_LEVEL; level++) {\n        head = timer_list + level;\n        if (!rt_list_isempty(head)) {\n            timer = rt_list_entry(head->next, struct rt_timer, row[level]);\n            *timeout_tick = timer->timeout_tick;\n            return RT_EOK;\n        }\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 50.05066751597621}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n\n    timer = rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer != RT_NULL) {\n        timer->parent.flag = flag;\n        timer->timeout_func = timeout;\n        timer->parameter    = parameter;\n\n        rt_timer_control(timer,\n                         RT_TIMER_CTRL_SET_TIME,\n                         &time);\n    }\n\n    return timer;\n}", "CodeBleu_score": 52.34448104071895}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL) {\n        rt_memset(timer, 0, sizeof(struct rt_timer));\n\n        rt_strncpy(timer->parent.name, name, RT_NAME_MAX);\n\n        timer->timeout_func = timeout;\n        timer->parameter    = parameter;\n        timer->timeout_tick = time;\n        timer->parent.flag  = flag;\n\n        rt_timer_init(timer);\n    }\n\n    return timer;\n}", "CodeBleu_score": 50.425565762207626}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n\n    timer = rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer != RT_NULL) {\n        timer->timeout_func = timeout;\n        timer->parameter    = parameter;\n        timer->init_tick    = rt_tick_get();\n        timer->timeout_tick = time;\n        timer->parent.flag  = flag;\n    }\n\n    return timer;\n}", "CodeBleu_score": 53.106843798379025}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tfor _, handler := range a.handlers {\n\t\trec := httptest.NewRecorder()\n\t\thandler.ServeHTTP(rec, req)\n\t\tfor key, value := range rec.Header() {\n\t\t\tres.Header()[key] = value\n\t\t}\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 84.84539955605547}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tif a.authorizer != nil && !a.authorizer.Authorize(req) {\n\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\tres.Write([]byte(\"Not Authorized\"))\n\t\treturn\n\t}\n\n\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\n\tres.WriteHeader(rec.Code)\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 50.12957874502841}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\ta.Log(req)\n\n\tif a.authorizer != nil && !a.authorizer(req) {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tfor _, handler := range a.middleware {\n\t\thandler(res, req)\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 47.16673236662247}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif strings.HasPrefix(path, \"/api/\") {\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/robots.txt\") {\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/favicon.ico\") {\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/index.html\") {\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/\") {\n\t\tpath = path[1:]\n\t}\n\tasset, err := robeaux.Asset(path)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\text := path[strings.LastIndex(path, \".\")+1:]\n\tswitch ext {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 53.89288852256975}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path[1:]\n\tif strings.HasPrefix(path, \"api/\") {\n\t\treturn\n\t}\n\n\tasset, err := robeaux.Asset(path)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\text := path[strings.LastIndex(path, \".\")+1:]\n\tswitch ext {\n\tcase \"js\":\n\t\tres.Header().Add(\"Content-Type\", \"application/javascript\")\n\tcase \"css\":\n\t\tres.Header().Add(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Add(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(asset)\n}", "CodeBleu_score": 53.86054962402756}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path[1:]\n\tdata, err := robeaux.Asset(path)\n\tif err != nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\n\text := strings.Split(path, \".\")[1]\n\tswitch ext {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(data)\n}", "CodeBleu_score": 51.243195598075665}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %s not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections := []map[string]interface{}{}\n\tfor _, connection := range robot.Connections() {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\":   connection.Name(),\n\t\t\t\"adaptor\": connection.Adaptor().Name(),\n\t\t\t\"port\":   connection.Port(),\n\t\t\t\"params\": connection.Params(),\n\t\t})\n\t}\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 48.44063328128232}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.FindRobot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot '%s' not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections := make(map[string]interface{})\n\tfor _, connection := range robot.Connections() {\n\t\tconnections[connection.Name()] = connection.Params()\n\t}\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 41.71317906142619}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tif robotName == \"\" {\n\t\thttp.Error(res, \"Please specify a robot name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\trobot := a.master.FindRobot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %s not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tconnections := []robeaux.Connection{}\n\tfor _, device := range robot.Devices() {\n\t\tconnections = append(connections, robeaux.Connection{\n\t\t\tName:    device.Name,\n\t\t\tAdaptor: device.Adaptor().Name(),\n\t\t\tPort:    device.Port(),\n\t\t})\n\t}\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 47.17358000791414}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.73455549590731}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 53.47501537357863}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.73455549590731}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - (slope * fromMin)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.709832910613386}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.77499603577397}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - (slope * fromMin)\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int((slope * input) + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.12912679184295}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Verify that the connection supports analog reading\n\tif a.connection == nil || a.connection.(gobot.AnalogReader) == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analogSensorRead: Connection does not support analog reading\")\n\t}\n\n\t// Read the raw value from the specified pin\n\tval, err := a.connection.(gobot.AnalogReader).AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Update the last raw and scaled values\n\ta.lastRawValue = val\n\ta.lastScaledValue = a.scale(val)\n\n\treturn val, a.lastScaledValue, nil\n}", "CodeBleu_score": 53.83405409220734}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.analogReadable() {\n\t\treturn 0, 0.0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\tvalue, err := a.connection.analogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\ta.lastRawValue = value\n\ta.lastScaledValue = a.scale(value)\n\n\treturn value, a.lastScaledValue, nil\n}", "CodeBleu_score": 48.431939514532665}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif !a.connection.analogReadable() {\n\t\treturn 0, 0, fmt.Errorf(\"%s is a digital sensor\", a.Name)\n\t}\n\n\tval, err := a.connection.analogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastVal = val\n\ta.lastValScaled = a.scale(val)\n\treturn val, a.lastValScaled, nil\n}", "CodeBleu_score": 49.94913964905313}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMax - (m * fromMax)\n\n\treturn func(input int) float64 {\n\t\toutput := m * float64(input) + n\n\t\tif output < toMin {\n\t\t\toutput = toMin\n\t\t} else if output > toMax {\n\t\t\toutput = toMax\n\t\t}\n\t\treturn output\n\t}\n}", "CodeBleu_score": 60.20998621347429}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m * fromMin\n\treturn func(input int) float64 {\n\t\toutput := m * float64(input) + n\n\t\tif output < toMin {\n\t\t\treturn toMin\n\t\t} else if output > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn output\n\t}\n}", "CodeBleu_score": 67.9853008731779}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m * fromMin\n\treturn func(input int) float64 {\n\t\treturn m * float64(input) + n\n\t}\n}", "CodeBleu_score": 46.24314740584698}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewGrovePiezoVibrationSensorDriverAdaptor(a, pin, opts...)\n\treturn &GrovePiezoVibrationSensorDriver{\n\t\tName: d.Name,\n\t\tconnection: d.connection,\n\t\tanalogSensorDriver: d.analogSensorDriver,\n\t}\n}", "CodeBleu_score": 22.20941081656204}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\t// Create a new AnalogSensorDriver using the provided analog reader, pin, and optional parameters.\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\n\t// Set a default name for the driver.\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\n\t// Add a vibration event to the driver.\n\td.AddEvent(Vibration)\n\n\t// Set up an event listener for data events that publishes a vibration event if the data exceeds a threshold value of 1000.\n\td.AddEventHandler(Data, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(Vibration, true)\n\t\t} else {\n\t\t\td.Publish(Vibration, false)\n\t\t}\n\t})\n\n\treturn &GrovePiezoVibrationSensorDriver{d}\n}", "CodeBleu_score": 37.77446978366491}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewGrovePiezoVibrationSensorDriver(a, pin, opts...)\n\td.AddEvent(Vibration)\n\td.AddEventHandler(Vibration, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(Vibration, true)\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 31.798195158217542}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period and the tempo based on the given frequency and the buzzer's bpm.\n\ttonePeriod := 1 / hz\n\ttempo := 60 / d.bpm\n\n\t// Calculate the number of times the buzzer should be toggled based on the tone period and the tempo.\n\tnumToggles := int(duration / tonePeriod / tempo)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0; i < numToggles; i++ {\n\t\t// Toggle the buzzer on.\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period.\n\t\ttime.Sleep(time.Duration(tonePeriod * float64(time.Second)))\n\n\t\t// Toggle the buzzer off.\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tempo.\n\t\ttime.Sleep(time.Duration(tempo * float64(time.Second)))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 57.88175311978401}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif duration < 0 {\n\t\treturn fmt.Errorf(\"duration must be greater than 0\")\n\t}\n\n\ttonePeriod := 1000000 / hz\n\ttoneDuration := time.Duration(duration * float64(time.Second))\n\ttempo := time.Duration(60000000 / (d.bpm * tonePeriod))\n\n\tfor start := time.Now(); time.Since(start) < toneDuration; {\n\t\terr := d.On()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgobot.After(tempo, func() {\n\t\t\terr := d.Off()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Errorf(\"error turning buzzer off: %v\", err)\n\t\t\t}\n\t\t})\n\t\ttime.Sleep(tempo)\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.4980202044924}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\ttonePeriod := 1 / hz\n\ttoneDuration := duration / tonePeriod\n\ttoneTempo := time.Duration(60000/d.bpm) * time.Millisecond\n\tgobot.Every(toneTempo, func() {\n\t\tif toneDuration <= 0 {\n\t\t\td.buzzer.Off()\n\t\t\treturn\n\t\t}\n\t\terr := d.buzzer.On()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(toneTempo)\n\t\terr = d.buzzer.Off()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(toneTempo)\n\t\ttoneDuration -= tonePeriod\n\t})\n\treturn nil\n}", "CodeBleu_score": 38.64295117137718}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.Stop()\n\td.sleepPin.DigitalWrite(0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.889790011570597}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"Sleep pin not set\")\n\t}\n\td.Stop()\n\td.sleepPin.Write(LOW)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 29.96907457101532}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stop()\n\td.sleepPin.Write(gobot.Low)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.663946614660997}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpin, err := newAnalogPin(id, a)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 44.88427428889399}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin.(gobot.AnalogPinner), nil\n\t}\n\tpath, err := a.translatePin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := NewAnalogPin(a, path)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 51.30067092692744}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins not initialized\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\n\tpin = NewAnalogPin(id)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 35.65727902235166}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.DigitalPin(id, gobot.DigitalOutput)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.DigitalWrite(val)\n}", "CodeBleu_score": 67.21017603439792}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.DigitalPin(id, gobot.DigitalWriter)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 66.82611147117842}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.DigitalPin(id, gobot.DigitalWriter)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 66.82611147117842}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.connected {\n\t\treturn nil, ErrNotConnected\n\t}\n\n\tpin, err := a.DigitalPin(id)\n\tif err != nil {\n\t\tchip, line, err := a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = newDigitalPin(chip, line)\n\t\terr = pin.Init()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.addDigitalPin(pin)\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 50.45308936039369}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.digitalPins == nil {\n\t\treturn nil, fmt.Errorf(\"Adaptor not connected to any pins\")\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(&a.digitalPinsOpts)\n\t}\n\n\tpin, err := a.digitalPins.Get(id)\n\tif err != nil {\n\t\tpin = a.newDigitalPin(id)\n\t\tif err := a.initializePin(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.digitalPins.Add(pin)\n\t} else {\n\t\tif err := a.applyPinOpts(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 48.65821001095249}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.connected {\n\t\treturn nil, ErrNotConnected\n\t}\n\n\tif a.digitalPins == nil {\n\t\ta.digitalPins = make(map[string]gobot.DigitalPinner)\n\t}\n\n\tif pin, ok := a.digitalPins[id]; ok {\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\tpin, err := a.NewDigitalPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\ta.digitalPins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 42.15600722362811}]}
