{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *desc_ptr = (uint8_t *) desc;\n\tuint8_t *desc_end = (uint8_t *) desc + desc->bLength;\n\tuint8_t *desc_next;\n\n\twhile (desc_ptr < desc_end) {\n\t\tdesc_next = desc_ptr + desc_ptr[0];\n\t\tif (desc_next > desc_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (desc_next[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_next;\n\t\t}\n\t\tdesc_ptr = desc_next;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 40.45152010737772}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\tuint32_t desc_len;\n\tuint32_t desc_type;\n\n\tdo {\n\t\tdesc_len = desc->bLength;\n\t\tdesc_type = desc->bDescriptorType;\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc + desc_len);\n\t\tif (desc_type == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = next_desc;\n\t} while (desc_len!= 0);\n\treturn NULL;\n}", "CodeBleu_score": 39.08321529637222}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *ptr = (uint8_t *) desc;\n\twhile (ptr < (uint8_t *) desc + desc->bLength) {\n\t\tif (ptr[0] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) ptr;\n\t\t}\n\t\tptr += ptr[0];\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.27626894127937}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *ptr = udc_config_desc;\n\tuint8_t *end = udc_config_desc + udc_config_desc_len;\n\tuint8_t iface_num_found = 0;\n\tuint8_t setting_num_found = 0;\n\n\tif (udc_config_desc_len == 0)\n\t\treturn false;\n\n\twhile (ptr < end) {\n\t\tif (*ptr == USB_DESC_TYPE_INTERFACE) {\n\t\t\tif (iface_num_found == iface_num) {\n\t\t\t\tif (setting_num_found == setting_num) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tiface_num_found++;\n\t\t}\n\t\tif (*ptr == USB_DESC_TYPE_ENDPOINT) {\n\t\t\tif (iface_num_found == iface_num) {\n\t\t\t\tsetting_num_found++;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 31.772981100820207}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (udc_config_desc.bNumInterfaces == 0)\n\t\treturn false;\n\n\tif (iface_num >= udc_config_desc.bNumInterfaces)\n\t\treturn false;\n\n\tif (setting_num >= udc_config_desc.bNumConfigurations)\n\t\treturn false;\n\n\tuint8_t *ptr = udc_config_desc.ptr;\n\tuint8_t *end = ptr + udc_config_desc.wTotalLength;\n\n\twhile (ptr < end) {\n\t\tif (ptr[1] == USB_DESC_INTERFACE) {\n\t\t\tif (ptr[2] == iface_num && ptr[3] == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tptr += ptr[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 31.194074185032918}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tstruct usb_config_descriptor *cfg = (struct usb_config_descriptor *) udc_get_cfg_desc();\n\tstruct usb_interface_descriptor *iface_desc;\n\tuint8_t iface_desc_num;\n\tuint8_t iface_desc_setting_num;\n\n\tif (cfg == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= cfg->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tiface_desc_num = 0;\n\tiface_desc_setting_num = 0;\n\tiface_desc = (struct usb_interface_descriptor *) (cfg + 1);\n\n\twhile (iface_desc_num < cfg->bNumInterfaces) {\n\t\tif (iface_desc_num == iface_num) {\n\t\t\tif (iface_desc_setting_num == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tiface_desc_setting_num++;\n\t\t}\n\t\tiface_desc_num++;\n\t\tiface_desc = (struct usb_interface_descriptor *) ((uint8_t *) iface_desc + iface_desc->bLength);\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 44.444779801218004}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = udc_get_ep_num(req->bmRequestType);\n\tuint8_t ep_status = udc_ep_get_status(ep_num);\n\tudc_set_response_data(ep_status);\n\treturn true;\n}", "CodeBleu_score": 11.915929210533935}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tbool ret = false;\n\tuint8_t ep_num = udc_req_get_index();\n\tuint8_t ep_status = 0;\n\tuint8_t ep_type = udc_req_get_type();\n\n\tif (udc_req_get_length() == 2) {\n\t\tif (ep_type == USB_REQ_TYPE_STANDARD) {\n\t\t\tif (ep_num < USB_MAX_ENDPOINTS) {\n\t\t\t\tif (udc_ep_is_halted(ep_num)) {\n\t\t\t\t\tep_status = USB_EP_STATUS_HALT;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ep_type == USB_REQ_TYPE_CLASS) {\n\t\t\tif (ep_num < USB_MAX_ENDPOINTS) {\n\t\t\t\tif (udc_ep_is_halted(ep_num)) {\n\t\t\t\t\tep_status = USB_EP_STATUS_HALT;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ep_type == USB_REQ_TYPE_VENDOR) {\n\t\t\tif (ep_num < USB_MAX_ENDPOINTS) {\n\t\t\t\tif (udc_ep_is_halted(ep_num)) {\n\t\t\t\t\tep_status = USB_EP_STATUS_HALT;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tret = true;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tudc_req_set_status(UDC_REQ_STATUS_OK);\n\t\tudc_req_set_payload_ptr((uint8_t *) &ep_status, 2);\n\t} else {\n\t\tudc_req_set_status(UDC_REQ_STATUS_STALL);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 39.41068488311924}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tbool ret = false;\n\tuint8_t ep_addr;\n\tuint8_t ep_status;\n\n\tif (req_len == 2) {\n\t\tep_addr = req_buf[1];\n\t\tep_status = udc_ep_get_status(ep_addr);\n\t\tif (ep_status == 0) {\n\t\t\tep_status = 1;\n\t\t}\n\t\tret = udc_req_std_ep_set_status(ep_addr, ep_status);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 26.198684685267803}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t *iface_desc = (uint8_t *) &g_udc.dev.config_desc[g_udc.dev.config_desc_offset + 9];\n\tuint8_t iface_num = (g_udc.req.wIndex & 0x0F);\n\tuint8_t alt_num = (g_udc.req.wValue & 0x0F);\n\n\tif (g_udc.dev.state!= UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\n\tif (iface_num > g_udc.dev.config_desc[7]) {\n\t\treturn false;\n\t}\n\n\tif (alt_num > g_udc.dev.config_desc[8 + iface_num]) {\n\t\treturn false;\n\t}\n\n\tiface_desc[2] = alt_num;\n\n\treturn udi_driver_setup_req(g_udc.req.wValue, g_udc.req.wIndex, g_udc.req.wLength);\n}", "CodeBleu_score": 45.88538754210897}, {"code": "static bool udc_req_iface(void){\n\t\tbool result = false;\n\tuint8_t *p_setup = udc_setup_req;\n\tuint8_t iface_num = p_setup[1];\n\tuint8_t alt_num = p_setup[3];\n\n\tif (udc_configured && iface_num < UDC_NUM_INTERFACES) {\n\t\tudc_iface_desc[iface_num].bInterfaceNumber = iface_num;\n\t\tudc_iface_desc[iface_num].bAlternateSetting = alt_num;\n\n\t\tresult = udi_cdc_setup_req(p_setup);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 35.55281713459117}, {"code": "static bool udc_req_iface(void){\n\t\tbool ret = false;\n\tuint8_t iface_num = 0;\n\tuint8_t alt_num = 0;\n\n\tif (udc_is_configured()) {\n\t\tiface_num = udc_get_setup_iface();\n\t\talt_num = udc_get_setup_alt();\n\n\t\tif (iface_num < UDI_COUNT) {\n\t\t\tudc_update_iface_desc(iface_num, alt_num);\n\t\t\tret = udi_setup_iface(iface_num, alt_num);\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 30.93966267354933}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\tbool result = false;\n\tuint8_t lun_count = 0;\n\tuint8_t i;\n\n\t/* Initialize the MSC process. */\n\tudi_msc_process_init();\n\n\t/* Get the number of LUNs. */\n\tif (udi_msc_get_lun_count(&lun_count)!= STATUS_OK) {\n\t\tgoto end;\n\t}\n\n\t/* Check if there are any LUNs available. */\n\tif (lun_count == 0) {\n\t\tgoto end;\n\t}\n\n\t/* Unload the medium on each LUN. */\n\tfor (i = 0; i < lun_count; i++) {\n\t\tif (udi_msc_unload_medium(i)!= STATUS_OK) {\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t/* Start the MSC process by waiting for a CBW reception. */\n\tif (udi_msc_process()!= STATUS_OK) {\n\t\tgoto end;\n\t}\n\n\tresult = true;\n\nend:\n\treturn result;\n}", "CodeBleu_score": 40.19997555663432}, {"code": "bool udi_msc_enable(void){\n\t\tbool res = false;\n\tudi_msc_state = UDI_MSC_STATE_DISABLED;\n\tudi_msc_nb_lun = 0;\n\tudi_msc_nb_lun_available = 0;\n\tudi_msc_cbw_received = false;\n\tudi_msc_cbw_received_from_lun = 0;\n\tudi_msc_cbw_received_from_lun_valid = false;\n\tudi_msc_cbw_received_from_lun_valid_from_lun = 0;\n\tudi_msc_cbw_received_from_lun_valid_from_lun_valid = false;\n\tudi_msc_cbw_received_from_lun_valid_from_lun_valid_from_lun = 0;\n\tudi_msc_cbw_received_from_lun_valid_from_lun_valid_from_lun_valid = false;\n\tudi_msc_cbw_received_from_lun_valid_from_lun_valid_from_lun_valid_from_lun = 0;\n\tudi_msc_cbw_received_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid = false;\n\tudi_msc_cbw_received_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid_from_lun = 0;\n\tudi_msc_cbw_received_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid = false;\n\tudi_msc_cbw_received_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid_from_lun = 0;\n\tudi_msc_cbw_received_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid = false;\n\tudi_msc_cbw_received_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid_from_lun_valid", "CodeBleu_score": 18.287651749221673}, {"code": "bool udi_msc_enable(void){\n\t\tuint8_t lun_count = 0;\n\tbool msc_enabled = false;\n\n\t/*\n\t * Initialize the MSC interface\n\t */\n\tmsc_init();\n\n\t/*\n\t * Check if the MSC interface is enabled\n\t */\n\tif (msc_enabled) {\n\t\t/*\n\t\t * Check the number of LUNs\n\t\t */\n\t\tif (msc_get_lun_count(&lun_count)) {\n\t\t\t/*\n\t\t\t * Check if there are any LUNs available\n\t\t\t */\n\t\t\tif (lun_count > 0) {\n\t\t\t\t/*\n\t\t\t\t * Unload the medium on each LUN\n\t\t\t\t */\n\t\t\t\tfor (uint8_t i = 0; i < lun_count; i++) {\n\t\t\t\t\tif (msc_unload_medium(i)) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Start the MSC process by waiting for a Command Block Wrapper (CBW) reception\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmsc_process();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn msc_enabled;\n}", "CodeBleu_score": 31.660678537897148}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tstruct msc_setup_data_t *setup_data = (struct msc_setup_data_t *)udd_g_setup_payload;\n\tstruct msc_cbw_t *cbw = (struct msc_cbw_t *)udd_g_ctrl_buf;\n\tstruct msc_csw_t *csw = (struct msc_csw_t *)udd_g_ctrl_buf;\n\tstruct msc_cbw_t *cbw_next = (struct msc_cbw_t *)udd_g_ctrl_buf;\n\tstruct msc_csw_t *csw_next = (struct msc_csw_t *)udd_g_ctrl_buf;\n\tstruct msc_cbw_t *cbw_prev = (struct msc_cbw_t *)udd_g_ctrl_buf;\n\tstruct msc_csw_t *csw_prev = (struct msc_csw_t *)udd_g_ctrl_buf;\n\tstruct msc_cbw_t *cbw_current = (struct msc_cbw_t *)udd_g_ctrl_buf;\n\tstruct msc_csw_t *csw_current = (struct msc_csw_t *)udd_g_ctrl_buf;\n\tstruct msc_cbw_t *cbw_last = (struct msc_cbw_t *)udd_g_ctrl_buf;\n\tstruct msc_csw_t *csw_last = (struct msc_csw_t *)udd_g_ctrl_buf;\n\tstruct msc_cbw_t *cbw_next_last = (struct msc_cbw_t *)udd_g_ctrl_buf;\n\tstruct msc_csw_t *csw_next_last = (struct msc_csw_t *)udd_g_ctrl_buf;\n\tstruct msc_cbw_t *cbw_prev_last = (struct msc_cbw_t *)udd_g_ctrl_buf;\n\tstruct msc_csw_t *csw_prev_last = (struct msc_csw_t *)udd_g_ctrl_", "CodeBleu_score": 16.996885051456612}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tstruct msc_desc_struct *msc_desc = (struct msc_desc_struct *)udd_g_desc[ep];\n\tstruct msc_cbw_struct *cbw = (struct msc_cbw_struct *)msc_desc->cbw;\n\tstruct msc_csw_struct *csw = (struct msc_csw_struct *)msc_desc->csw;\n\n\tif (status!= UDD_EP_STATUS_OK) {\n\t\tmsc_desc->data_state = MSC_DATA_STATE_WAIT_RESET;\n\t\treturn;\n\t}\n\n\tmsc_desc->data_state = MSC_DATA_STATE_WAIT_RESET;\n\n\tif (cbw->dCBWDataTransferLength!= nb_sent) {\n\t\tmsc_desc->sense_data.bSenseKey = UDI_MSC_SENSE_KEY_ILLEGAL_REQUEST;\n\t\tmsc_desc->sense_data.bAdditionalSenseCode = UDI_MSC_SENSE_CODE_ILLEGAL_LENGTH;\n\t\tmsc_desc->sense_data.bAdditionalSenseCodeQualifier = 0;\n\t\tmsc_desc->sense_data.bFieldReplaceableUnitCode = 0;\n\t\tmsc_desc->sense_data.bSenseKeySpecific = 0;\n\t\tmsc_desc->sense_data.bAdditionalSenseLength = 0;\n\t\tmsc_desc->sense_data.bASC = 0x24;\n\t\tmsc_desc->sense_data.bASCQ = 0x00;\n\t} else {\n\t\tmsc_desc->sense_data.bSenseKey = UDI_MSC_SENSE_KEY_NO_SENSE;\n\t\tmsc_desc->sense_data.bAdditionalSenseCode = 0;\n\t\tmsc_desc->sense_data.bAdditionalSenseCodeQualifier = 0;\n\t\tmsc_desc->sense_data.bFieldReplaceableUnitCode = 0;\n\t\tmsc_desc->sense_data.bSenseKeySpecific = 0;\n\t\tmsc_desc->sense_data.bAdditionalSenseLength = 0;\n\t\tmsc_desc->sense_data.bASC = 0;\n\t\tmsc_desc->sense_data.bASCQ = 0;\n", "CodeBleu_score": 38.93773322329935}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status!= UDD_EP_STATUS_OK) {\n\t\tudi_msc_wait_setup_reset();\n\t\treturn;\n\t}\n\n\tif (udi_msc_cbw.data_length > 0) {\n\t\tif (udi_msc_cbw.data_length < nb_sent) {\n\t\t\tudi_msc_cbw.data_length -= nb_sent;\n\t\t\tudi_msc_cbw.data_ptr += nb_sent;\n\t\t} else {\n\t\t\tudi_msc_cbw.data_length = 0;\n\t\t\tudi_msc_cbw.data_ptr = NULL;\n\t\t}\n\t}\n\n\tudi_msc_update_csw(nb_sent);\n}", "CodeBleu_score": 52.10629271179129}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_csw_t *csw = &udi_msc_csw_struct;\n\tuint32_t residue = 0;\n\n\tif (csw->csw_data_residue!= 0) {\n\t\tudi_msc_ep_stall(csw->csw_ep_in);\n\t\tudi_msc_ep_stall(csw->csw_ep_out);\n\t}\n\n\tresidue = udi_msc_csw_data_residue_get();\n\n\tcsw->csw_data_residue = residue;\n\tcsw->csw_tag = udi_msc_csw_tag_get();\n\tcsw->csw_status = 0;\n\n\tudi_msc_csw_data_residue_set(residue);\n\tudi_msc_csw_tag_set(csw->csw_tag);\n\tudi_msc_csw_status_set(csw->csw_status);\n}", "CodeBleu_score": 46.903574241210784}, {"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_csw_t *csw = &udi_msc_csw_struct;\n\tuint32_t data_residue;\n\n\tif (udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cbw_struct.udi_msc_cb", "CodeBleu_score": 9.334877708329891}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint8_t *p_csw;\n\tuint32_t data_residue;\n\n\tp_csw = (uint8_t *) &udi_msc_csw;\n\n\tudi_msc_csw.dCSWSignature = CBW_CSW_SIGNATURE;\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\n\tdata_residue = udi_msc_cbw.dCBWDataTransferLength;\n\tif (udi_msc_cbw.bmCBWFlags & CBW_FLAG_DIRECTION_OUT) {\n\t\tudi_msc_csw.dCSWDataResidue = data_residue;\n\t} else {\n\t\tudi_msc_csw.dCSWDataResidue = -data_residue;\n\t}\n\n\tudi_msc_csw.bCSWStatus = CSW_STATUS_GOOD;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw.d", "CodeBleu_score": 42.11845233148943}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port < USB_CDC_NUM_PORTS) {\n\t\tif (b_enable) {\n\t\t\tif (usb_cdc_ports[port].b_dtr_rate == USB_CDC_DTR_RATE_1200) {\n\t\t\t\tusb_cdc_ports[port].b_dtr_rate = USB_CDC_DTR_RATE_1200_ENABLED;\n\t\t\t\tif (usb_cdc_ports[port].b_dtr_rate_enabled) {\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_enabled = false;\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_disabled = true;\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_disabled_timeout = 0;\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_disabled_timeout_max = USB_CDC_DTR_RATE_DISABLED_TIMEOUT;\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_disabled_timeout_max_max = USB_CDC_DTR_RATE_DISABLED_TIMEOUT_MAX;\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_disabled_timeout_max_min = USB_CDC_DTR_RATE_DISABLED_TIMEOUT_MIN;\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_disabled_timeout_max_step = USB_CDC_DTR_RATE_DISABLED_TIMEOUT_STEP;\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_disabled_timeout_max_step_max = USB_CDC_DTR_RATE_DISABLED_TIMEOUT_STEP_MAX;\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_disabled_timeout_max_step_min = USB_CDC_DTR_RATE_DISABLED_TIMEOUT_STEP_MIN;\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_disabled_timeout_max_step_step = USB_CDC_DTR_RATE_DISABLED_TIMEOUT_STEP_STEP;\n\t\t\t\t\tusb_cdc_ports[port].b_dtr_rate_disabled_timeout_max_step_step_max = USB_CDC_DTR_RATE_DISABLED_TIMEOUT_STEP_STEP_", "CodeBleu_score": 28.815252432996992}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\t// Check if the DTR rate is 1200.\n\tif (usb_cdc_ports[port].dtr_rate == USB_CDC_DTR_RATE_1200) {\n\t\t// Check if the DTR signal is disabled.\n\t\tif (!b_enable) {\n\t\t\t// Schedule a delayed system reset.\n\t\t\tusb_cdc_ports[port].dtr_rate_1200_timer = 0;\n\t\t\tusb_cdc_ports[port].dtr_rate_1200_timer_flag = true;\n\t\t\tinitiateReset();\n\t\t} else {\n\t\t\t// Cancel any scheduled reset.\n\t\t\tcancelReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 44.02982624257692}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\t// check if the port is valid\n\tif (port >= USB_MAX_PORTS) {\n\t\treturn;\n\t}\n\n\t// get the port's USB device\n\tUSB_CDC_Device_t *p_cdc_dev = &usb_cdc_device[port];\n\n\t// check if the port is connected\n\tif (!p_cdc_dev->b_connected) {\n\t\treturn;\n\t}\n\n\t// check if the DTR rate is 1200\n\tif (p_cdc_dev->b_dtr_rate_1200) {\n\t\t// check if the DTR signal is disabled\n\t\tif (!b_enable) {\n\t\t\t// check if the port is already scheduled for reset\n\t\t\tif (p_cdc_dev->b_reset_scheduled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// schedule a reset\n\t\t\tp_cdc_dev->b_reset_scheduled = true;\n\t\t\tinitiateReset(port);\n\t\t} else {\n\t\t\t// check if the port is already scheduled for reset\n\t\t\tif (!p_cdc_dev->b_reset_scheduled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// cancel the reset\n\t\t\tp_cdc_dev->b_reset_scheduled = false;\n\t\t\tcancelReset(port);\n\t\t}\n\t}\n}", "CodeBleu_score": 40.320477654794544}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tbool request_handled = false;\n\n\tswitch (usb_setup_packet.bmRequestType.type) {\n\t\tcase REQUEST_TYPE_VENDOR:\n\t\t\tif (usb_setup_packet.bRequest == REQUEST_INDEX_VENDOR_SET_POINTERS) {\n\t\t\t\tusb_descriptors_pointers.ms_compatible_id = (uint8_t *) &usb_descriptors_ms_compatible_id;\n\t\t\t\tusb_descriptors_pointers.ms_compatible_id_size = sizeof(usb_descriptors_ms_compatible_id);\n\t\t\t\tusb_descriptors_pointers.ms_extended_properties = (uint8_t *) &usb_descriptors_ms_extended_properties;\n\t\t\t\tusb_descriptors_pointers.ms_extended_properties_size = sizeof(usb_descriptors_ms_extended_properties);\n\t\t\t\trequest_handled = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase REQUEST_TYPE_STANDARD:\n\t\t\tif (usb_setup_packet.bRequest == REQUEST_INDEX_STANDARD_GET_DESCRIPTOR) {\n\t\t\t\tif (usb_setup_packet.wValue.bytes.high == 0x03) {\n\t\t\t\t\tif (usb_setup_packet.wValue.bytes.low == 0x00) {\n\t\t\t\t\t\tusb_control_request_payload = (uint8_t *) &usb_descriptors_device;\n\t\t\t\t\t\tusb_control_request_size = sizeof(usb_descriptors_device);\n\t\t\t\t\t\trequest_handled = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn request_handled;\n}", "CodeBleu_score": 34.909772784815544}, {"code": "bool usb_task_other_requests(void){\n\t\tbool request_handled = false;\n\n\tif (usb_device_control_request_in_received) {\n\t\tif (usb_device_control_request.bmRequestType == USB_DEVICE_REQUEST_TYPE_VENDOR) {\n\t\t\tif (usb_device_control_request.bRequest == 0x04) {\n\t\t\t\t// Microsoft-compatible ID descriptor\n\t\t\t\tusb_device_control_request_payload = (uint8_t *) &usb_device_ms_compatible_id;\n\t\t\t\tusb_device_control_request_size = sizeof(usb_device_ms_compatible_id);\n\t\t\t\trequest_handled = true;\n\t\t\t} else if (usb_device_control_request.bRequest == 0x05) {\n\t\t\t\t// Extended properties descriptor\n\t\t\t\tusb_device_control_request_payload = (uint8_t *) &usb_device_ms_extended_properties;\n\t\t\t\tusb_device_control_request_size = sizeof(usb_device_ms_extended_properties);\n\t\t\t\trequest_handled = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn request_handled;\n}", "CodeBleu_score": 21.803790010077805}, {"code": "bool usb_task_other_requests(void){\n\t\tbool handled = false;\n\tif (usb_setup.bmRequestType.Type == REQUEST_VENDOR) {\n\t\tswitch (usb_setup.bRequest) {\n\t\t\tcase 0x04:\n\t\t\t\tif (usb_setup.wValue == 0x0100) {\n\t\t\t\t\tusb_control_request_data_ptr = (uint8_t *) &usb_string_desc_ms_compatible_id;\n\t\t\t\t\tusb_control_request_data_size = sizeof(usb_string_desc_ms_compatible_id);\n\t\t\t\t\thandled = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\tif (usb_setup.wValue == 0x0100) {\n\t\t\t\t\tusb_control_request_data_ptr = (uint8_t *) &usb_string_desc_ms_extended_properties;\n\t\t\t\t\tusb_control_request_data_size = sizeof(usb_string_desc_ms_extended_properties);\n\t\t\t\t\thandled = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn handled;\n}", "CodeBleu_score": 27.16695152207195}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\tuint8_t dummy = 0;\n\twhile (nbyte-- > 0) {\n\t\tspiRec(&dummy);\n\t\t*buf++ = dummy;\n\t}\n\tspiRec(buf);\n}", "CodeBleu_score": 32.642034390405286}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tuint8_t dummy = 0;\n\tuint16_t i;\n\tfor (i = 0; i < nbyte; i++) {\n\t\tspiRec(&dummy);\n\t\tbuf[i] = dummy;\n\t}\n\tspiRec(buf + nbyte);\n}", "CodeBleu_score": 46.656963292612815}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\tuint8_t dummy = 0xFF;\n\tfor (uint16_t i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(dummy);\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 47.96492832788978}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated interrupt vector table\n\tuint32_t *pIntVecTable = (uint32_t *)INT_VECTOR_TABLE_BASE;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Retrieve the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = (pfnISR_Handler)pIntVecTable[irq];\n\n\t// Replace the current handler with the new handler\n\tpIntVecTable[irq] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original handler\n\treturn oldHandler;\n}", "CodeBleu_score": 50.37405869931035}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\t__disable_irq();\n\toldHandler = (pfnISR_Handler) NVIC_GetVector(irq);\n\tNVIC_SetVector(irq, (uint32_t) newHandler);\n\t__enable_irq();\n\treturn oldHandler;\n}", "CodeBleu_score": 43.65195997938068}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated interrupt vector table\n\tuint32_t *relocated_isr_table = (uint32_t *)((uint32_t)__vector_table + 0x10);\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Retrieve the current handler for the specified IRQ\n\tpfnISR_Handler current_handler = (pfnISR_Handler)relocated_isr_table[irq];\n\n\t// Replace the current handler with the new handler\n\trelocated_isr_table[irq] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original handler\n\treturn current_handler;\n}", "CodeBleu_score": 46.76333279238134}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\treturn _serial.peek();\n}", "CodeBleu_score": 14.432213181391173}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (this->emergencyParserEnabled) {\n\t\tif (this->emergencyParser->available()) {\n\t\t\treturn this->emergencyParser->read();\n\t\t}\n\t}\n\treturn Serial.peek();\n}", "CodeBleu_score": 18.410747052901044}, {"code": "int MarlinSerialUSB::peek(){\n\t\treturn SerialUSB.peek();\n}", "CodeBleu_score": 14.432549405549732}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (pendingChar!= 0) {\n\t\treturn pendingChar;\n\t}\n\n\tif (usb_enabled &&!usb_configured) {\n\t\treturn -1;\n\t}\n\n\tif (usb_serial_available()) {\n\t\tpendingChar = usb_serial_getchar();\n\t\treturn pendingChar;\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 24.881924806987595}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char!= 0) {\n\t\treturn pending_char;\n\t} else if (is_enabled) {\n\t\tif (is_configured) {\n\t\t\tif (Serial.available() > 0) {\n\t\t\t\tchar c = Serial.read();\n\t\t\t\tif (emergency_parser.enabled()) {\n\t\t\t\t\temergency_parser.parse(c);\n\t\t\t\t}\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 36.290134446787484}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char!= -1) {\n\t\treturn pending_char;\n\t}\n\n\tif (is_enabled && is_configured) {\n\t\tif (usb_available()) {\n\t\t\treturn usb_read();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 18.93009824234275}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tif (SerialUSB.available() > 0) {\n\t\treturn SerialUSB.available();\n\t} else {\n\t\tif (SerialUSB.isReady()) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.48239943849247}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (Serial.available() > 0) {\n\t\treturn Serial.available();\n\t} else {\n\t\tif (SerialUSB.isConnected()) {\n\t\t\treturn SerialUSB.available();\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.538375525419106}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (Serial.available() > 0) {\n\t\treturn Serial.available();\n\t} else if (SerialUSB.enabled()) {\n\t\treturn SerialUSB.available();\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 38.65762500319831}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint8_t data;\n\twhile (size--) {\n\t\tif (!read_byte(pos, data, crc)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (writing) {\n\t\t\t*value++ = data;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.437483685608804}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\t// Check if the position is valid.\n\tif (pos < 0 || pos >= (int)this->size) {\n\t\treturn false;\n\t}\n\n\t// Read the data.\n\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t b;\n\t\tif (!this->read_byte(pos, b)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Write the data to the buffer.\n\t\tif (writing) {\n\t\t\tvalue[i] = b;\n\t\t}\n\n\t\t// Update the CRC.\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, b);\n\t\t}\n\n\t\t// Increment the position.\n\t\tpos++;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 44.79499052096996}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (size == 0) {\n\t\treturn true;\n\t}\n\tif (pos >= _size) {\n\t\treturn false;\n\t}\n\tif (pos + size > _size) {\n\t\tsize = _size - pos;\n\t}\n\tif (writing) {\n\t\tif (value!= NULL) {\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tvalue[i] = read_byte(pos + i);\n\t\t\t}\n\t\t}\n\t}\n\tif (crc!= NULL) {\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\t*crc = crc16_update(*crc, read_byte(pos + i));\n\t\t}\n\t}\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 42.950845031643226}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin < 0 || pin > PWM_PINS) return;\n\tif (value > 255) return;\n\tif (freq > PWM_FREQUENCY) return;\n\tif (res > PWM_RESOLUTION) return;\n\n\tif (pin < PWM_PINS) {\n\t\tledcWrite(pin, value);\n\t} else {\n\t\tif (pwm_states[pin] == NULL) {\n\t\t\tpwm_states[pin] = new PwmState();\n\t\t}\n\n\t\tPwmState *state = pwm_states[pin];\n\t\tstate->pin = pin;\n\t\tstate->value = value;\n\t\tstate->freq = freq;\n\t\tstate->res = res;\n\t\tstate->used = true;\n\t\tstate->count = 0;\n\t\tstate->timer = NULL;\n\n\t\tif (pwm_count == 0) {\n\t\t\tpwm_count = 1;\n\t\t\tpwm_timer = xTimerCreate(\"pwm_timer\", 1000 / portTICK_PERIOD_MS, pdTRUE, NULL, pwm_timer_callback);\n\t\t\txTimerStart(pwm_timer, 0);\n\t\t} else {\n\t\t\tpwm_count++;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.11679048653307}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin < 0 || pin > 15) {\n\t\treturn;\n\t}\n\n\tif (pin < 12) {\n\t\tif (pin < 8) {\n\t\t\tledcWrite(pin, value);\n\t\t} else {\n\t\t\tledcWrite(pin - 8, value);\n\t\t}\n\t} else {\n\t\tif (pin < 14) {\n\t\t\tledcWrite(pin - 12, value);\n\t\t} else {\n\t\t\tledcWrite(pin - 14, value);\n\t\t}\n\t}\n}", "CodeBleu_score": 20.31594813390799}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin < 0 || pin > 15) return;\n\tif (pin >= 16) {\n\t\tif (pin == 16) {\n\t\t\tledcWrite(LED_CHANNEL_1, value);\n\t\t} else if (pin == 17) {\n\t\t\tledcWrite(LED_CHANNEL_2, value);\n\t\t} else if (pin == 18) {\n\t\t\tledcWrite(LED_CHANNEL_3, value);\n\t\t} else if (pin == 19) {\n\t\t\tledcWrite(LED_CHANNEL_4, value);\n\t\t}\n\t} else {\n\t\tif (pwm_pin_state[pin] == 0) {\n\t\t\tpwm_pin_state[pin] = 1;\n\t\t\tif (pwm_pin_count == 0) {\n\t\t\t\tledcSetup(LED_CHANNEL_1, freq, res);\n\t\t\t\tledcSetup(LED_CHANNEL_2, freq, res);\n\t\t\t\tledcSetup(LED_CHANNEL_3, freq, res);\n\t\t\t\tledcSetup(LED_CHANNEL_4, freq, res);\n\t\t\t\tledcAttachPin(LED_PIN_1, LED_CHANNEL_1);\n\t\t\t\tledcAttachPin(LED_PIN_2, LED_CHANNEL_2);\n\t\t\t\tledcAttachPin(LED_PIN_3, LED_CHANNEL_3);\n\t\t\t\tledcAttachPin(LED_PIN_4, LED_CHANNEL_4);\n\t\t\t}\n\t\t\tpwm_pin_count++;\n\t\t}\n\t\tledcWrite(pwm_channel[pin], value);\n\t}\n}", "CodeBleu_score": 38.00596582707642}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t\tstatic_assert(sizeof(delays) / sizeof(delays[0]) == SERVO_CHANNELS, \"Delay array length does not match number of servos\");\n\tif (attached) {\n\t\twrite(value);\n\t\tdelay(delays[channel]);\n\t} else {\n\t\tSerial.println(\"Servo not attached\");\n\t}\n\tif constexpr (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\tdetach();\n\t}\n}", "CodeBleu_score": 51.25401167686273}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == SERVO_CHANNEL_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must equal SERVO_CHANNEL_COUNT\");\n\tif (this->attach(value)) {\n\t\tthis->servo_delay_array[this->servo_channel_index] = SERVO_MOVE_DELAY;\n\t\tif constexpr (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tthis->detach();\n\t\t}\n\t}\n}", "CodeBleu_score": 30.243361033626233}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(sizeof(servoDelay) / sizeof(servoDelay[0]) == SERVO_COUNT, \"Servo::move() servoDelay array length does not match SERVO_COUNT\");\n\tif (servo.attach(PIN_SERVO)) {\n\t\tservo.write(value);\n\t\tdelay(servoDelay[servoChannel]);\n\t\tif constexpr (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tservo.detach();\n\t\t}\n\t}\n}", "CodeBleu_score": 48.97785842894227}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\t//Check if the current PWM tick count has reached zero\n\tif (pwm_tick_count == 0) {\n\t\t//Toggle the pin state\n\t\tif (pwm_state == HIGH) {\n\t\t\tpwm_state = LOW;\n\t\t} else {\n\t\t\tpwm_state = HIGH;\n\t\t}\n\t\t//Set the next PWM tick count\n\t\tpwm_tick_count = pwm_tick_period;\n\t}\n\t//Decrement the PWM tick count\n\tpwm_tick_count--;\n\t//Update the PWM states for each pin\n\tfor (int i = 0; i < 8; i++) {\n\t\tif (pwm_states[i] == HIGH) {\n\t\t\tdigitalWrite(i, HIGH);\n\t\t} else {\n\t\t\tdigitalWrite(i, LOW);\n\t\t}\n\t}\n\t//Write the updated port data to the DMA buffer\n\tfor (int i = 0; i < 8; i++) {\n\t\tdma_buffer[dma_buffer_position] = (pwm_states[i] << i);\n\t\tdma_buffer_position++;\n\t}\n}", "CodeBleu_score": 25.498685388031117}, {"code": "void i2s_push_sample(){\n\t\t// Iterate over the number of pins\n\tfor (int pin_index = 0; pin_index < NUMBER_OF_PINS; pin_index++) {\n\t\t// Get the current pin\n\t\tPin *pin = &pins[pin_index];\n\t\t// Check if the pin has active PWM\n\t\tif (pin->pwm_enabled) {\n\t\t\t// Check if the PWM tick count reached zero\n\t\t\tif (pin->pwm_tick_count == 0) {\n\t\t\t\t// Toggle the pin state between high and low based on its current state\n\t\t\t\tpin->pwm_state =!pin->pwm_state;\n\t\t\t\t// Set the tick count for the next transition\n\t\t\t\tpin->pwm_tick_count = pin->pwm_period;\n\t\t\t}\n\t\t\t// Decrement the PWM tick count\n\t\t\tpin->pwm_tick_count--;\n\t\t}\n\t}\n\t// Update the PWM states for each pin and write the resulting data to the DMA buffer\n\tfor (int pin_index = 0; pin_index < NUMBER_OF_PINS; pin_index++) {\n\t\tPin *pin = &pins[pin_index];\n\t\t// Check if the pin has active PWM\n\t\tif (pin->pwm_enabled) {\n\t\t\t// Toggle the pin state between high and low based on its current state\n\t\t\tpin->port_data = pin->pwm_state? HIGH : LOW;\n\t\t} else {\n\t\t\t// Set the pin state to low if it is not active\n\t\t\tpin->port_data = LOW;\n\t\t}\n\t\t// Write the updated port data to the DMA buffer\n\t\tdma_buffer[pin_index] = pin->port_data;\n\t}\n\t// Increment the buffer position\n\tbuffer_position++;\n}", "CodeBleu_score": 31.058203511345233}, {"code": "void i2s_push_sample(){\n\t\t// Check if the PWM tick count for each pin has reached zero\n\tfor (int i = 0; i < I2S_NUM_PINS; i++) {\n\t\tif (i2s_pwm_ticks[i] == 0) {\n\t\t\t// Toggle the pin state between high and low based on its current state\n\t\t\tif (i2s_pins[i].state == HIGH) {\n\t\t\t\ti2s_pins[i].state = LOW;\n\t\t\t} else {\n\t\t\t\ti2s_pins[i].state = HIGH;\n\t\t\t}\n\n\t\t\t// Set the tick count for the next transition\n\t\t\ti2s_pwm_ticks[i] = i2s_pins[i].period;\n\t\t}\n\t}\n\n\t// Update the PWM tick count for each pin by subtracting the number of ticks elapsed since the last update\n\tfor (int i = 0; i < I2S_NUM_PINS; i++) {\n\t\ti2s_pwm_ticks[i] -= i2s_pwm_ticks_elapsed;\n\t}\n\n\t// Write the updated port data to the current position of the DMA buffer and increment the buffer position\n\ti2s_dma_buffer[i2s_dma_buffer_pos] = i2s_pins[0].state | (i2s_pins[1].state << 1) | (i2s_pins[2].state << 2) | (i2s_pins[3].state << 3) | (i2s_pins[4].state << 4) | (i2s_pins[5].state << 5) | (i2s_pins[6].state << 6) | (i2s_pins[7].state << 7);\n\ti2s_dma_buffer_pos++;\n\n\t// Check if the buffer position has reached the end of the buffer\n\tif (i2s_dma_buffer_pos == I2S_DMA_BUFFER_SIZE) {\n\t\t// Reset the buffer position to the beginning of the buffer\n\t\ti2s_dma_buffer_pos = 0;\n\t}\n}", "CodeBleu_score": 31.079301932895977}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer_count = 0;\n\tswitch (timer_num) {\n\tcase 1:\n\t\ttimer_count = TIM1->CNT;\n\t\tbreak;\n\tcase 2:\n\t\ttimer_count = TIM2->CNT;\n\t\tbreak;\n\tcase 3:\n\t\ttimer_count = TIM3->CNT;\n\t\tbreak;\n\tcase 4:\n\t\ttimer_count = TIM4->CNT;\n\t\tbreak;\n\tcase 5:\n\t\ttimer_count = TIM5->CNT;\n\t\tbreak;\n\tcase 6:\n\t\ttimer_count = TIM6->CNT;\n\t\tbreak;\n\tcase 7:\n\t\ttimer_count = TIM7->CNT;\n\t\tbreak;\n\tcase 8:\n\t\ttimer_count = TIM8->CNT;\n\t\tbreak;\n\tcase 9:\n\t\ttimer_count = TIM9->CNT;\n\t\tbreak;\n\tcase 10:\n\t\ttimer_count = TIM10->CNT;\n\t\tbreak;\n\tcase 11:\n\t\ttimer_count = TIM11->CNT;\n\t\tbreak;\n\tcase 12:\n\t\ttimer_count = TIM12->CNT;\n\t\tbreak;\n\tcase 13:\n\t\ttimer_count = TIM13->CNT;\n\t\tbreak;\n\tcase 14:\n\t\ttimer_count = TIM14->CNT;\n\t\tbreak;\n\tcase 15:\n\t\ttimer_count = TIM15->CNT;\n\t\tbreak;\n\tcase 16:\n\t\ttimer_count = TIM16->CNT;\n\t\tbreak;\n\tcase 17:\n\t\ttimer_count = TIM17->CNT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn timer_count;\n}", "CodeBleu_score": 28.236508315252156}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\t// check if timer number is valid\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\t// get timer configuration\n\tconst hal_timer_config_t* timer_config = &hal_timer_config[timer_num];\n\t// get timer counter\n\treturn timer_config->counter;\n}", "CodeBleu_score": 35.18918446937359}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer;\n\tif (timer_num == 0) {\n\t\ttimer = (hal_timer_t) TIM1->CNT;\n\t} else if (timer_num == 1) {\n\t\ttimer = (hal_timer_t) TIM2->CNT;\n\t} else if (timer_num == 2) {\n\t\ttimer = (hal_timer_t) TIM3->CNT;\n\t} else if (timer_num == 3) {\n\t\ttimer = (hal_timer_t) TIM4->CNT;\n\t} else if (timer_num == 4) {\n\t\ttimer = (hal_timer_t) TIM5->CNT;\n\t} else if (timer_num == 5) {\n\t\ttimer = (hal_timer_t) TIM6->CNT;\n\t} else if (timer_num == 6) {\n\t\ttimer = (hal_timer_t) TIM7->CNT;\n\t} else if (timer_num == 7) {\n\t\ttimer = (hal_timer_t) TIM8->CNT;\n\t} else {\n\t\ttimer = 0;\n\t}\n\treturn timer;\n}", "CodeBleu_score": 29.158192197980163}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tuint8_t data;\n\tbool ret = false;\n\tif (pos < 0 || pos >= size) {\n\t\treturn ret;\n\t}\n\tif (writing) {\n\t\tif (value!= NULL) {\n\t\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\t\tdata = read_byte(pos);\n\t\t\t\tif (data!= 0xFF) {\n\t\t\t\t\tvalue[i] = data;\n\t\t\t\t} else {\n\t\t\t\t\tvalue[i] = 0x00;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tdata = read_byte(pos);\n\t\t\tif (data!= 0xFF) {\n\t\t\t\tvalue[i] = data;\n\t\t\t} else {\n\t\t\t\tvalue[i] = 0x00;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 52.0201712263669}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tif (pos >= EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tuint8_t *p = value;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t b = EEPROM.read(pos++);\n\t\tif (writing) {\n\t\t\t*p = b;\n\t\t}\n\t\t*crc = crc16_update(*crc, b);\n\t\tp++;\n\t}\n\treturn true;\n}", "CodeBleu_score": 54.342927044878955}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tif (pos + size > _size) {\n\t\treturn false;\n\t}\n\tuint16_t crc_temp = 0;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t temp = 0;\n\t\tif (reading_eeprom(pos, temp)) {\n\t\t\tif (writing) {\n\t\t\t\tvalue[i] = temp;\n\t\t\t}\n\t\t\tcrc_temp = crc16_ccitt(crc_temp, temp);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tpos++;\n\t}\n\tif (crc!= nullptr) {\n\t\t*crc = crc_temp;\n\t}\n\treturn true;\n}", "CodeBleu_score": 56.98972562128215}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\tif (SDIO_WriteBlock_Retry(block, src, SDIO_WRITE_RETRY_COUNT) == false) {\n\t\tprintf(\"Error: SDIO_WriteBlock() failed to write block %d\n\", block);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 23.342067317333875}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\t// Check if the SDIO handle and source pointer are not null\n\tif (SDIO_Handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\t// Try to write the block up to a defined number of times\n\tfor (uint32_t i = 0; i < SDIO_RETRY_COUNT; i++) {\n\t\tif (SDIO_WriteBlock_Retry(block, src)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Print an error message and return false if all retries fail\n\tprintf(\"SDIO: Failed to write block %d\n\", block);\n\treturn false;\n}", "CodeBleu_score": 26.27459392841734}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (SDIO_Handle == NULL || src == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: SDIO_Handle or src is NULL\n\");\n\t\treturn false;\n\t}\n\n\tuint32_t i = 0;\n\tfor (i = 0; i < SDIO_RETRY_COUNT; i++) {\n\t\tif (SDIO_WriteBlock_Retry(block, src)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprintf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n\treturn false;\n}", "CodeBleu_score": 33.62861867014656}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_TEMPERATURE) {\n\t\ttimer_temp_freq = frequency;\n\t\tHAL_NVIC_SetPriority(TIMER_TEMP_IRQn, TIMER_TEMP_IRQ_PRIO, 0);\n\t\tHAL_NVIC_EnableIRQ(TIMER_TEMP_IRQn);\n\t} else if (timer_num == TIMER_STEPPER) {\n\t\ttimer_step_freq = frequency;\n\t\tHAL_NVIC_SetPriority(TIMER_STEP_IRQn, TIMER_STEP_IRQ_PRIO, 0);\n\t\tHAL_NVIC_EnableIRQ(TIMER_STEP_IRQn);\n\t} else {\n\t\tassert_param(0);\n\t}\n}", "CodeBleu_score": 37.21335988732306}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\tHAL_timer_start_stepper(frequency);\n\t} else if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\tHAL_timer_start_temperature(frequency);\n\t} else {\n\t\tassert_param(0);\n\t}\n}", "CodeBleu_score": 25.96940399436588}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_TEMPERATURE) {\n\t\tHAL_timer_start_temperature(frequency);\n\t} else if (timer_num == TIMER_STEPPER) {\n\t\tHAL_timer_start_stepper(frequency);\n\t} else {\n\t\tassert(false);\n\t}\n}", "CodeBleu_score": 25.497019453696325}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\t// Open the EEPROM file\n\tif (efile.open(EEPROM_FILE, O_RDWR | O_CREAT)) {\n\t\t// Get the file size\n\t\tuint32_t file_size = efile.file_size();\n\t\t// If the file is too small, fill the remainder with the default erase value\n\t\tif (file_size < EEPROM_SIZE) {\n\t\t\t// Set the buffer to the default erase value\n\t\t\tmemset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n\t\t\t// Write the buffer to the file\n\t\t\tefile.write(buffer, EEPROM_SIZE);\n\t\t\t// Set the file size to the expected size\n\t\t\tefile.seek(EEPROM_SIZE);\n\t\t}\n\t\t// Read the file into the buffer\n\t\tefile.read(buffer, EEPROM_SIZE);\n\t\t// Close the file\n\t\tefile.close();\n\t\t// Return success\n\t\treturn true;\n\t}\n\t// Return failure\n\treturn false;\n}", "CodeBleu_score": 26.77790916385403}, {"code": "bool PersistentStore::access_start(){\n\t\tif (file.open(EEPROM_FILE_NAME, O_RDWR)) {\n\t\tif (file.seek(0, SEEK_END)!= EEPROM_SIZE) {\n\t\t\tfile.close();\n\t\t\treturn false;\n\t\t}\n\t\tfile.read(buffer, EEPROM_SIZE);\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 12.014072004526598}, {"code": "bool PersistentStore::access_start(){\n\t\tbool result = false;\n\tif (file.open(EEPROM_FILE_NAME, O_RDWR | O_CREAT)) {\n\t\t// Check file size\n\t\tfile.seek(0, SEEK_END);\n\t\tint file_size = file.tell();\n\t\tif (file_size < EEPROM_SIZE) {\n\t\t\t// Fill the remainder of the buffer with the default erase value\n\t\t\tfor (int i = file_size; i < EEPROM_SIZE; i++) {\n\t\t\t\tbuffer[i] = EEPROM_DEFAULT_ERASE_VALUE;\n\t\t\t}\n\t\t} else if (file_size > EEPROM_SIZE) {\n\t\t\t// File is too large; truncate it to the expected size\n\t\t\tfile.truncate(EEPROM_SIZE);\n\t\t}\n\t\t// Read the file's contents into the buffer\n\t\tfile.seek(0, SEEK_SET);\n\t\tfile.read(buffer, EEPROM_SIZE);\n\t\t// Close the file\n\t\tfile.close();\n\t\tresult = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 39.262595642412734}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_STM32_PinWrite(SPI_MOSI_PORT, SPI_MOSI_PIN, 0);\n\t\tHAL_GPIO_STM32_PinWrite(SPI_SCK_PORT, SPI_SCK_PIN, 0);\n\t\tHAL_GPIO_STM32_PinWrite(SPI_SCK_PORT, SPI_SCK_PIN, 1);\n\t\tif (HAL_GPIO_STM32_PinRead(SPI_MISO_PORT, SPI_MISO_PIN)) {\n\t\t\tr |= (1 << i);\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_GPIO_STM32_PinWrite(SPI_SCK_PORT, SPI_SCK_PIN, 0);\n\tHAL_Delay_us(1);\n\treturn r;\n}", "CodeBleu_score": 37.571162525849076}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t ret = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_STM32_SetPin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin);\n\t\t} else {\n\t\t\tHAL_GPIO_STM32_ResetPin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin);\n\t\t}\n\t\tHAL_GPIO_STM32_TogglePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin);\n\t\tret <<= 1;\n\t\tif (HAL_GPIO_STM32_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin)) {\n\t\t\tret |= 0x01;\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(1);\n\treturn ret;\n}", "CodeBleu_score": 39.805966155859366}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i, bit, ret = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tbit = b & 0x80;\n\t\tHAL_SPI_STM32_SpiSetMOSI(bit);\n\t\tHAL_SPI_STM32_SpiSetClock(0);\n\t\tHAL_SPI_STM32_SpiSetClock(1);\n\t\tret = ret << 1;\n\t\tif (HAL_SPI_STM32_SpiGetMISO()) {\n\t\t\tret |= 0x01;\n\t\t}\n\t\tb = b << 1;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 40.933584667327096}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 42.579826607808776}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 42.579826607808776}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 42.579826607808776}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tif (obj->rx_count < RX_BUFFER_SIZE) {\n\t\tobj->rx_buffer[obj->rx_head] = obj->serial->getc();\n\t\tobj->rx_head = (obj->rx_head + 1) % RX_BUFFER_SIZE;\n\t\tobj->rx_count++;\n\t} else {\n\t\tobj->serial->clear();\n\t}\n\tif (obj->emergency_parser) {\n\t\tobj->emergency_parser->rx_complete_irq(obj->rx_buffer[obj->rx_head]);\n\t}\n}", "CodeBleu_score": 34.39619482180196}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// if the buffer is full, don't read any more\n\tif (obj->rx_head == obj->rx_tail) {\n\t\treturn;\n\t}\n\n\t// if the buffer is full, don't read any more\n\tif (obj->rx_head >= RX_BUFFER_SIZE) {\n\t\tobj->rx_head = 0;\n\t}\n\n\t// read the byte\n\tobj->rx_buffer[obj->rx_head] = obj->serial_read(obj);\n\n\t// update the head pointer\n\tobj->rx_head++;\n\n\t// update the emergency parser\n\tif (obj->emergency_parser) {\n\t\tobj->emergency_parser(obj->rx_buffer[obj->rx_head - 1]);\n\t}\n}", "CodeBleu_score": 29.719895086897296}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c = obj->getc();\n\tif (c == 0) return; // Ignore null bytes\n\tif (obj->rx_buffer_head == obj->rx_buffer_tail) {\n\t\t// Buffer is full, drop the character\n\t\treturn;\n\t}\n\tobj->rx_buffer[obj->rx_buffer_head++] = c;\n\tobj->rx_buffer_head %= RX_BUFFER_SIZE;\n\tif (obj->rx_buffer_head == obj->rx_buffer_tail) {\n\t\t// Buffer is full, drop the character\n\t\tobj->rx_buffer_head--;\n\t\tobj->rx_buffer_head %= RX_BUFFER_SIZE;\n\t\treturn;\n\t}\n\tif (obj->emergency_parser) {\n\t\tobj->emergency_parser->rx_byte(c);\n\t}\n}", "CodeBleu_score": 40.94333862468498}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (HAL_timer_is_initialized(timer_num) &&!HAL_timer_is_interrupt_attached(timer_num)) {\n\t\t\tHAL_NVIC_EnableIRQ(MF_TIMER_STEP_IRQn);\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (HAL_timer_is_initialized(timer_num) &&!HAL_timer_is_interrupt_attached(timer_num)) {\n\t\t\tHAL_NVIC_EnableIRQ(MF_TIMER_TEMP_IRQn);\n\t\t}\n\t}\n}", "CodeBleu_score": 40.204116235712775}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (!MF_TIMER_STEP_IS_INIT) {\n\t\t\treturn;\n\t\t}\n\t\tif (MF_TIMER_STEP_INTERRUPT_ATTACHED) {\n\t\t\treturn;\n\t\t}\n\t\tMF_TIMER_STEP_INTERRUPT_ATTACHED = true;\n\t\tHAL_NVIC_EnableIRQ(MF_TIMER_STEP_IRQn);\n\t}\n\telse if (timer_num == MF_TIMER_TEMP) {\n\t\tif (!MF_TIMER_TEMP_IS_INIT) {\n\t\t\treturn;\n\t\t}\n\t\tif (MF_TIMER_TEMP_INTERRUPT_ATTACHED) {\n\t\t\treturn;\n\t\t}\n\t\tMF_TIMER_TEMP_INTERRUPT_ATTACHED = true;\n\t\tHAL_NVIC_EnableIRQ(MF_TIMER_TEMP_IRQn);\n\t}\n}", "CodeBleu_score": 24.689692358921395}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (MF_TIMER_STEP_INIT) {\n\t\t\tif (!MF_TIMER_STEP_INT_ATTACHED) {\n\t\t\t\tMF_TIMER_STEP_INT_ATTACHED = 1;\n\t\t\t\tMF_TIMER_STEP_INT_ENABLED = 1;\n\t\t\t\tHAL_NVIC_EnableIRQ(MF_TIMER_STEP_IRQn);\n\t\t\t}\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (MF_TIMER_TEMP_INIT) {\n\t\t\tif (!MF_TIMER_TEMP_INT_ATTACHED) {\n\t\t\t\tMF_TIMER_TEMP_INT_ATTACHED = 1;\n\t\t\t\tMF_TIMER_TEMP_INT_ENABLED = 1;\n\t\t\t\tHAL_NVIC_EnableIRQ(MF_TIMER_TEMP_IRQn);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 25.21238073743031}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\tif len(sep) == len(s) {\n\t\tif s == sep {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\t}\n\thash := hash(sep)\n\tlast := len(s) - len(sep)\n\tfor i := last; i >= 0; i-- {\n\t\tif hash == hash(s[i:i+len(sep)]) && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 35.40307833034083}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tif len(sep) == 1 {\n\t\treturn LastIndex(s, sep[0])\n\t}\n\t// Calculate the hash of the separator\n\thashSep := hash(sep)\n\t// Calculate the hash of the first substring\n\thashSub := hash(s[:len(sep)])\n\t// Check if the hash matches\n\tif hashSub == hashSep {\n\t\tif string(sep) == string(s[:len(sep)]) {\n\t\t\treturn 0\n\t\t}\n\t}\n\t// Calculate the hash of the last substring\n\thashSub = hash(s[len(s)-len(sep):])\n\t// Check if the hash matches\n\tif hashSub == hashSep {\n\t\tif string(sep) == string(s[len(s)-len(sep):]) {\n\t\t\treturn len(s) - len(sep)\n\t\t}\n\t}\n\t// Calculate the hash of the substrings in between\n\tfor i := 1; i < len(s)-len(sep); i++ {\n\t\thashSub = (hashSub - hash(s[i-1]))*prime + hash(s[i+len(sep)-1])\n\t\tif hashSub == hashSep {\n\t\t\tif string(sep) == string(s[i:i+len(sep)]) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 37.60702189621969}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\treturn lastIndexRabinKarp(s, sep, len(s))\n}", "CodeBleu_score": 5.966532158509411}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.lock.Lock()\n\tdefer usbcdc.lock.Unlock()\n\tusbcdc.waitTxc = false\n\tusbcdc.waitRxc = true\n\tif usbcdc.txc == 0 {\n\t\tusbcdc.waitTxc = true\n\t} else {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txc)\n\t\tusbcdc.txc = 0\n\t}\n}", "CodeBleu_score": 30.18485059700275}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.mu.Lock()\n\tdefer usbcdc.mu.Unlock()\n\tif!usbcdc.waitTxc {\n\t\treturn\n\t}\n\tif usbcdc.txc!= nil && usbcdc.txc.Len() > 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txc)\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n}", "CodeBleu_score": 36.48931116126577}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.txcMutex.Lock()\n\tdefer usbcdc.txcMutex.Unlock()\n\tif usbcdc.waitTxc {\n\t\treturn\n\t}\n\tusbcdc.waitTxc = true\n\tusbcdc.txcMutex.Unlock()\n\tfor usbcdc.txcMutex.TryLock() {\n\t\tif usbcdc.txcMutex.TryLock() {\n\t\t\treturn\n\t\t}\n\t}\n\tusbcdc.txcMutex.Lock()\n\tusbcdc.waitTxc = false\n\tusbcdc.txcMutex.Unlock()\n\tusbcdc.txcMutex.Unlock()\n}", "CodeBleu_score": 24.60085835061141}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag\n\ti2c.i2c.I2CSR.Set(avr.I2CSR_IIF)\n\n\t// Put a start condition on the SDA line\n\ti2c.i2c.I2CMR.Set(avr.I2CMR_MSTA)\n\n\t// Enable the I2C module\n\ti2c.i2c.I2CMR.Set(avr.I2CMR_I2EN)\n\n\t// Wait for the start condition to be transmitted\n\tfor!i2c.i2c.I2CSR.Has(avr.I2CSR_IIF) {\n\t}\n\n\t// Write the 7-bit shifted peripheral address to the bus\n\ti2c.i2c.I2CDR.Set(address<<1 | uint8(write))\n\n\t// Send the address\n\tfor!i2c.i2c.I2CSR.Has(avr.I2CSR_IIF) {\n\t}\n}", "CodeBleu_score": 34.07924245963483}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.i2c.CR1.Set(i2c.i2c.CR1.Clear(i2c.i2c.CR1.MSTA | i2c.i2c.CR1.TX | i2c.i2c.CR1.TXAK))\n\ti2c.i2c.CR2.Set(i2c.i2c.CR2.SADD(address << 1))\n\tif write {\n\t\ti2c.i2c.CR2.Set(i2c.i2c.CR2.RD_WRN)\n\t}\n\ti2c.i2c.CR1.Set(i2c.i2c.CR1.MSTA)\n\tfor i2c.i2c.ISR.Get()&i2c.i2c.ISR.TXIS == 0 {\n\t}\n}", "CodeBleu_score": 28.533909952400737}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti2c.control.Set(i2c.control.Clear, i2c.control.Mask, i2c.control.Mask)\n\ti", "CodeBleu_score": 27.830713416999792}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// The function \"EraseBlocks\" in the \"flashBlockDevice\" struct erases a specified number of blocks in flash memory starting from a given block.\nIt calculates the start address based on the block number and block size, then waits for any ongoing flash operations to complete.\nThe flash is configured for erasing, and after each block is erased, it waits until the flash is no longer busy.\nFinally, the flash is set back to read mode and the function returns \"nil\" indicating successful completion.\n\tflash.SetMode(flash.ERASE)\n\tflash.SetAddress(uint32(start * f.BlockSize()))\n\tfor i := int64(0); i < len; i++ {\n\t\tflash.ErasePage()\n\t\tfor flash.Busy() {\n\t\t}\n\t}\n\tflash.SetMode(flash.READ)\n\treturn nil\n}", "CodeBleu_score": 41.77277606554652}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// This function is not implemented in the nrf52840-dk\n\treturn nil\n}", "CodeBleu_score": 3.315122328274832}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tvar err error\n\tvar flash_block_device_t = (*nrf.FlashBlockDevice)(unsafe.Pointer(uintptr(f.flashBlockDevice)))\n\tflash_block_device_t.EraseBlocks(start, len)\n\tfor flash_block_device_t.IsBusy() {\n\t\t// Wait for flash to finish\n\t}\n\tflash_block_device_t.SetMode(nrf.FLASH_MODE_READ)\n\treturn err\n}", "CodeBleu_score": 28.130493174795323}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, ErrNegativeOffset\n\t}\n\n\tif off > int64(f.size) {\n\t\treturn 0, ErrOffsetOutOfBounds\n\t}\n\n\tif len(p) == 0 {\n\t\treturn 0, ErrZeroLength\n\t}\n\n\tif off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, ErrWriteOutOfBounds\n\t}\n\n\t// Enable write mode on the flash memory controller.\n\tf.flash.EnableWrite()\n\n\t// Calculate the start address for writing and pad the byte slice to fit the write block size.\n\tstartAddr := off & ^(f.writeBlockSize - 1)\n\tpaddedSize := len(p) + int(off-startAddr)\n\tpaddedData := make([]byte, paddedSize)\n\tcopy(paddedData[off-startAddr:], p)\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(paddedData); i += f.writeBlockSize {\n\t\t// Calculate the number of bytes to write in this block.\n\t\tn := f.writeBlockSize\n\t\tif i+n > len(paddedData) {\n\t\t\tn = len(paddedData) - i\n\t\t}\n\n\t\t// Write the data to the flash memory.\n\t\terr := f.flash.Write(paddedData[i:i+n], startAddr+int64(i))\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// Wait for the flash memory to be ready.\n\t\tf.flash.WaitReady()\n\t}\n\n\t// Disable write mode on the flash memory controller.\n\tf.flash.DisableWrite()\n\n\treturn len(p), nil\n}", "CodeBleu_score": 33.33579196285823}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds.\n\tif off < 0 || off >= int64(f.Size()) {\n\t\treturn 0, &FlashError{err: \"write operation exceeds flash memory bounds\"}\n\t}\n\n\t// Calculate the start address for writing.\n\tstartAddress := uintptr(f.StartAddress) + uintptr(off)\n\n\t// Pad the byte slice to fit the write block size.\n\tpadSize := f.BlockSize - (int(off) % f.BlockSize)\n\tif padSize!= f.BlockSize {\n\t\tpaddedBytes := make([]byte, padSize)\n\t\tcopy(paddedBytes, p)\n\t\tp = paddedBytes\n\t}\n\n\t// Enable write mode on the flash memory controller.\n\tf.flash.EnableWrite()\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(p); i += f.BlockSize {\n\t\t// Write the data to the flash memory.\n\t\terr = f.flash.Write(startAddress, p[i:i+f.BlockSize])\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// Wait for the flash memory to be ready.\n\t\tf.flash.WaitReady()\n\n\t\t// Update the start address for the next write operation.\n\t\tstartAddress += uintptr(f.BlockSize)\n\t}\n\n\t// Return the number of bytes written.\n\treturn len(p), nil\n}", "CodeBleu_score": 37.263248710791004}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds\n\tif off < 0 || off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, ErrOutOfRange\n\t}\n\n\t// Calculate the start address for writing\n\tstartAddr := off + int64(f.BaseAddr)\n\n\t// Pad the byte slice to fit the write block size\n\tpadSize := f.BlockSize - (startAddr % int64(f.BlockSize))\n\tif padSize > int64(len(p)) {\n\t\tpadSize = int64(len(p))\n\t}\n\tp = append(p, bytes.Repeat([]byte{0}, int(padSize))...)\n\n\t// Enable write mode on the flash memory controller\n\tnrf.FLASH.CTRL.Set(nrf.FLASH_CTRL_WEN)\n\n\t// Write the data in blocks\n\tfor i := 0; i < len(p); i += int(f.BlockSize) {\n\t\t// Write the data to the flash memory\n\t\tnrf.FLASH.ADDR.Set(uint32(startAddr + int64(i)))\n\t\tnrf.FLASH.DATA.Set(binary.LittleEndian.Uint32(p[i:i+4]))\n\n\t\t// Wait for the flash memory to be ready\n\t\tfor nrf.FLASH.READY.Get() == 0 {\n\t\t}\n\t}\n\n\t// Disable write mode on the flash memory controller\n\tnrf.FLASH.CTRL.Clear(nrf.FLASH_CTRL_WEN)\n\n\t// Return the number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 36.846805188373125}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// duplicate the file descriptor\n\tdupedFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\t// close the duplicated file descriptor\n\tdefer syscall.Close(dupedFd)\n\n\t// attempt to open the directory using \"syscall.Fdopendir\"\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupedFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t} else if err!= syscall.EINTR {\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 53.55300885885411}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err!= nil {\n\t\t// If the error is not \"syscall.EINTR\", close the duplicated file descriptor and return the error.\n\t\tif err!= syscall.EINTR {\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\n\t\t// If the error is \"syscall.EINTR\", attempt to open the directory again.\n\t\tfor {\n\t\t\t// Attempt to open the directory.\n\t\t\tdir, err := syscall.Fdopendir(dupFd)\n\t\t\tif err!= nil {\n\t\t\t\t// If the error is not \"syscall.EINTR\", close the duplicated file descriptor and return the error.\n\t\t\t\tif err!= syscall.EINTR {\n\t\t\t\t\tsyscall.Close(dupFd)\n\t\t\t\t\treturn 0, \"\", err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If the directory was opened successfully, close the duplicated file descriptor and return the directory pointer with no error.\n\t\t\t\tsyscall.Close(dupFd)\n\t\t\t\treturn uintptr(dir), \"\", nil\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// If the directory was opened successfully, close the duplicated file descriptor and return the directory pointer with no error.\n\t\tsyscall.Close(dupFd)\n\t\treturn uintptr(dir), \"\", nil\n\t}\n}", "CodeBleu_score": 47.66910513097964}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the provided file descriptor.\n\tnewFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory using \"syscall.Fdopendir\".\n\tfor {\n\t\tdir, err := syscall.Fdopendir(newFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\n\t\t// If the error is not \"syscall.EINTR\", return the error message.\n\t\tif err!= syscall.EINTR {\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 49.823389375742316}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_chip_info_t chip_info;\n\tesp_chip_info(&chip_info);\n\n\tesp_partition_t *partition = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n\n\tif (partition == NULL) {\n\t\treturn 0;\n\t}\n\n\tesp_partition_read(partition, 0, partition->label, 16);\n\n\tesp_partition_read(partition, 16, &partition->label[16], 4);\n\n\tesp_partition_read(partition, 20, &partition->label[20], 4);\n\n\tesp_partition_read(partition, 24, &partition->label[24], 4);\n\n\tesp_partition_read(partition, 28, &partition->label[28], 4);\n\n\tesp_partition_read(partition, 32, &partition->label[32], 4);\n\n\tesp_partition_read(partition, 36, &partition->label[36], 4);\n\n\tesp_partition_read(partition, 40, &partition->label[40], 4);\n\n\tesp_partition_read(partition, 44, &partition->label[44], 4);\n\n\tesp_partition_read(partition, 48, &partition->label[48], 4);\n\n\tesp_partition_read(partition, 52, &partition->label[52], 4);\n\n\tesp_partition_read(partition, 56, &partition->label[56], 4);\n\n\tesp_partition_read(partition, 60, &partition->label[60], 4);\n\n\tesp_partition_read(partition, 64, &partition->label[64], 4);\n\n\tesp_partition_read(partition, 68, &partition->label[68], 4);\n\n\tesp_partition_read(partition, 72, &partition->label[72], 4);\n\n\tesp_partition_read(partition, 76, &partition->label[76], 4);\n\n\tesp_partition_read(partition, 8", "CodeBleu_score": 30.734303623699837}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t partition = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n\tif (partition == NULL) {\n\t\treturn 0;\n\t}\n\n\tesp_partition_read(partition, 0, &partition, sizeof(esp_partition_t));\n\n\tif (response == sketchSize_t::free) {\n\t\treturn partition.size - partition.address;\n\t} else {\n\t\treturn partition.size;\n\t}\n}", "CodeBleu_score": 33.51832441873353}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_OTA_0, NULL);\n\tif (it == NULL) {\n\t\treturn 0;\n\t}\n\tesp_partition_t* partition = esp_partition_get(it);\n\tif (partition == NULL) {\n\t\treturn 0;\n\t}\n\tesp_partition_type_t type = partition->type;\n\tesp_partition_subtype_t subtype = partition->subtype;\n\tesp_partition_size_t size = partition->size;\n\tesp_partition_address_t address = partition->address;\n\tesp_partition_encrypted_t encrypted = partition->encrypted;\n\tesp_partition_label_t label = partition->label;\n\tesp_partition_flags_t flags = partition->flags;\n\tesp_partition_read(it, 0, NULL, 1);\n\tesp_partition_read(it, 1, NULL, 1);\n\tesp_partition_read(it, 2, NULL, 1);\n\tesp_partition_read(it, 3, NULL, 1);\n\tesp_partition_read(it, 4, NULL, 1);\n\tesp_partition_read(it, 5, NULL, 1);\n\tesp_partition_read(it, 6, NULL, 1);\n\tesp_partition_read(it, 7, NULL, 1);\n\tesp_partition_read(it, 8, NULL, 1);\n\tesp_partition_read(it, 9, NULL, 1);\n\tesp_partition_read(it, 10, NULL, 1);\n\tesp_partition_read(it, 11, NULL, 1);\n\tesp_partition_read(it, 12, NULL, 1);\n\tesp_partition_read(it, 13, NULL, 1);\n\tesp_partition_read(it, 14, NULL, 1);\n\tesp_partition_read(it, 15, NULL, 1);\n\tesp_partition_read(it, 16, NULL, 1);\n", "CodeBleu_score": 30.5240605035129}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t disk_sectors = 0;\n\tuint32_t disk_sectors_aligned = 0;\n\tuint32_t disk_sectors_aligned_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded = 0;\n\tuint32_t disk_sectors_aligned_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded", "CodeBleu_score": 7.495751422984307}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t disk_sectors = 0;\n\tuint32_t disk_size_in_sectors = 0;\n\tuint32_t disk_size_in_bytes = 0;\n\tuint32_t root_directory_entries = 0;\n\tuint32_t sector_size = 0;\n\tuint32_t disk_sectors_for_fat = 0;\n\tuint32_t disk_sectors_for_root_directory = 0;\n\tuint32_t disk_sectors_for_firmware = 0;\n\tuint32_t disk_sectors_for_data = 0;\n\tuint32_t disk_sectors_for_fat_and_root_directory = 0;\n\tuint32_t disk_sectors_for_firmware_and_data = 0;\n\tuint32_t disk_sectors_for_fat_and_firmware = 0;\n\tuint32_t disk_sectors_for_root_directory_and_firmware = 0;\n\tuint32_t disk_sectors_for_fat_and_root_directory = 0;\n\tuint32_t disk_sectors_for_root_directory_and_data = 0;\n\tuint32_t disk_sectors_for_firmware_and_data = 0;\n\tuint32_t disk_sectors_for_fat_and_root_directory_and_data = 0;\n\tuint32_t disk_sectors_for_fat_and_firmware_and_data = 0;\n\tuint32_t disk_sectors_for_root_directory_and_firmware_and_data = 0;\n\tuint32_t disk_sectors_for_fat_and_root_directory_and_firmware = 0;\n\tuint32_t disk_sectors_for_fat_and_root_directory_and_firmware_and_data = 0;\n\tuint32_t disk_sectors_for_root_directory_and_firmware_and_data_and_firmware = 0;\n\tuint3", "CodeBleu_score": 11.632971337877557}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\t// Calculate the required disk sectors\n\tuint32_t required_sectors = (MSC_BOOT_SECTOR_SIZE + MSC_FAT_SIZE + MSC_ROOT_SIZE + MSC_FIRMWARE_SIZE) / MSC_SECTOR_SIZE;\n\t// Allocate memory for the RAM disk\n\tuint8_t *ram_disk = (uint8_t *)malloc(required_sectors * MSC_SECTOR_SIZE);\n\tif (ram_disk == NULL) {\n\t\tlog_error(\"Failed to allocate RAM disk for MSC device\");\n\t\treturn false;\n\t}\n\t// Set up the boot sector\n\tmsc_setup_boot_sector(ram_disk, volume_label, serial_number);\n\t// Set up the FAT\n\tmsc_setup_fat(ram_disk);\n\t// Add a root directory entry for a firmware file if a partition is running\n\tif (partition_is_running()) {\n\t\tmsc_add_firmware_file(ram_disk);\n\t}\n\t// Set up the RAM disk\n\tif (!msc_setup_disk(ram_disk, required_sectors)) {\n\t\tlog_error(\"Failed to set up RAM disk for MSC device\");\n\t\tfree(ram_disk);\n\t\treturn false;\n\t}\n\t// Free the RAM disk\n\tfree(ram_disk);\n\treturn true;\n}", "CodeBleu_score": 32.66498618302038}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tuint32_t sector_size = esp_partition_get_info(partition)->size / esp_partition_get_info(partition)->sector_size;\n\tif (offset % sector_size!= 0) {\n\t\tESP_LOGE(TAG, \"Update offset 0x%x is not aligned with flash sector size 0x%x\", offset, sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\terr = esp_partition_erase_range(partition, offset, sector_size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase partition 0x%x\", partition->address);\n\t\treturn err;\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write to partition 0x%x\", partition->address);\n\t\treturn err;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 51.07389204935713}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tesp_err_t erase_err = ESP_OK;\n\tuint32_t addr = offset;\n\tuint32_t erase_size = 0;\n\tuint32_t write_size = 0;\n\tuint32_t write_offset = 0;\n\n\tif (addr % FLASH_SECTOR_SIZE) {\n\t\tESP_LOGE(TAG, \"The offset is not aligned with the flash sector size\");\n\t\terr = ESP_FAIL;\n\t} else {\n\t\terase_size = FLASH_SECTOR_SIZE;\n\t\twrite_size = size;\n\t\twrite_offset = addr;\n\t}\n\n\tif (err == ESP_OK) {\n\t\terase_err = esp_partition_erase_range(partition, write_offset, erase_size);\n\t\tif (erase_err!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Erase error: 0x%x\", erase_err);\n\t\t\terr = ESP_FAIL;\n\t\t}\n\t}\n\n\tif (err == ESP_OK) {\n\t\terr = esp_partition_write(partition, write_offset, data, write_size);\n\t\tif (err!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Write error: 0x%x\", err);\n\t\t}\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 48.22378521476418}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tsize_t sector_size = esp_partition_get_info(partition)->size / esp_partition_get_info(partition)->sector_size;\n\tif (offset % sector_size) {\n\t\tESP_LOGE(TAG, \"Offset %u is not aligned with sector size %u\", offset, sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (esp_partition_erase_range(partition, offset, sector_size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase partition at offset %u\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\tif (esp_partition_write(partition, offset, data, size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write to partition at offset %u\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 44.71079709524372}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = strlen(in);\n\tsize_t outlen = 0;\n\tunsigned char nibble;\n\n\tfor (size_t i = 0; i < len; i++) {\n\t\tchar c = in[i];\n\t\tif (isxdigit(c)) {\n\t\t\tnibble = (c >= 'A')? (c - 'A' + 10) : (c - '0');\n\t\t\tif (i % 2) {\n\t\t\t\tout[outlen++] = nibble;\n\t\t\t\tif (outlen >= maxlen)\n\t\t\t\t\treturn outlen;\n\t\t\t} else {\n\t\t\t\tnibble <<= 4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn outlen;\n}", "CodeBleu_score": 35.084519759400266}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = strlen(in);\n\tsize_t i;\n\tsize_t j = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\tout[j] = out[j] * 16 + in[i] - '0';\n\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\tout[j] = out[j] * 16 + in[i] - 'A' + 10;\n\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\tout[j] = out[j] * 16 + in[i] - 'a' + 10;\n\t\t} else {\n\t\t\t// skip non-hex characters\n\t\t\tcontinue;\n\t\t}\n\t\tj++;\n\t\tif (j == maxlen) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn j;\n}", "CodeBleu_score": 33.69409481399052}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = strlen(in);\n\tsize_t i = 0;\n\tsize_t j = 0;\n\twhile (i < len) {\n\t\tunsigned char c = in[i];\n\t\tif (isxdigit(c)) {\n\t\t\tunsigned char b = 0;\n\t\t\tif (islower(c)) {\n\t\t\t\tb = c - 'a' + 10;\n\t\t\t} else {\n\t\t\t\tb = c - '0';\n\t\t\t}\n\t\t\tif (i + 1 < len) {\n\t\t\t\tc = in[i + 1];\n\t\t\t\tif (isxdigit(c)) {\n\t\t\t\t\tif (islower(c)) {\n\t\t\t\t\t\tb = (b << 4) + (c - 'a' + 10);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = (b << 4) + (c - '0');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j < maxlen) {\n\t\t\t\tout[j] = b;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n\treturn j;\n}", "CodeBleu_score": 38.976518099110756}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (m_hUsb == NULL) {\n\t\treturn 0;\n\t}\n\tif (m_hUsb->m_hUsbLock == NULL) {\n\t\treturn 0;\n\t}\n\tif (m_hUsb->m_hUsbLock->take(m_hUsb->m_hUsbLock->m_timeout) == 0) {\n\t\treturn 0;\n\t}\n\tint free = m_hUsb->m_hUsbLock->m_free;\n\tm_hUsb->m_hUsbLock->release();\n\treturn free;\n}", "CodeBleu_score": 39.791430677774095}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif(m_txRingBuffer == NULL || m_txRingBufferSize == 0)\n\t\treturn 0;\n\tif(xSemaphoreTake(m_txRingBufferLock, pdMS_TO_TICKS(100)) == pdTRUE) {\n\t\tint freeSize = m_txRingBufferSize - m_txRingBufferWriteIndex;\n\t\tif(freeSize < 0)\n\t\t\tfreeSize += m_txRingBufferSize;\n\t\txSemaphoreGive(m_txRingBufferLock);\n\t\treturn freeSize;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 44.889459087455954}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_buffer_size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (tx_buffer_lock == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (tx_buffer_lock->take(tx_buffer_timeout) == false) {\n\t\treturn 0;\n\t}\n\n\tint free_size = tx_buffer_size - tx_buffer_write_index;\n\n\ttx_buffer_lock->give();\n\n\treturn free_size;\n}", "CodeBleu_score": 55.48882962960624}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t//Serial.printf(\"HardwareSerial::onReceive: %p, %d\n\", function, onlyOnTimeout);\n\tif (function == NULL) {\n\t\t_onReceiveCB = NULL;\n\t\t_rxTimeout = 0;\n\t\t_rxTimeoutOnlyOnTimeout = false;\n\t\treturn;\n\t}\n\n\t//Serial.printf(\"HardwareSerial::onReceive: %p, %d\n\", function, onlyOnTimeout);\n\n\tif (xSemaphoreTake(_mutex, portMAX_DELAY)!= pdTRUE) {\n\t\treturn;\n\t}\n\n\t_onReceiveCB = function;\n\n\t_rxTimeout = 0;\n\t_rxTimeoutOnlyOnTimeout = onlyOnTimeout;\n\n\tif (_onReceiveCB!= NULL) {\n\t\tuart_set_rx_task_handle(_uart, _uart_on_receive_task_handle);\n\t\tuart_set_rx_task_stack_size(_uart, _uart_on_receive_task_stack_size);\n\t\tuart_set_rx_task_priority(_uart, _uart_on_receive_task_priority);\n\t\tuart_set_rx_task_core(_uart, _uart_on_receive_task_core);\n\n\t\tuart_set_rx_fifo_full_threshold(_uart, _uart_on_receive_fifo_full_threshold);\n\n\t\tif (_uart_on_receive_task_handle == NULL) {\n\t\t\t_uart_on_receive_task_handle = xTaskCreatePinnedToCore(\n\t\t\t\t\t_uart_on_receive_task, \"uart_on_receive\", _uart_on_receive_task_stack_size, this,\n\t\t\t\t\t_uart_on_receive_task_priority, &_uart_on_receive_task_handle, _uart_on_receive_task_core);\n\t\t}\n\t} else {\n\t\tuart_set_rx_task_handle(_uart, NULL);\n\t}\n\n\txSemaphoreGive(_mutex);\n}", "CodeBleu_score": 39.089522579421434}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tif (function == nullptr) {\n\t\treturn;\n\t}\n\n\tif (onlyOnTimeout) {\n\t\t_rxTimeout = 1;\n\t} else {\n\t\t_rxTimeout = 0;\n\t}\n\n\t_onReceiveCB = function;\n\n\tif (xSemaphoreTake(uart_mutex, portMAX_DELAY) == pdTRUE) {\n\t\tif (_onReceiveCB) {\n\t\t\tuart_set_rx_task_notification_value(UART_TASK_ON_RECEIVE_NOTIF_VALUE);\n\t\t\tif (xTaskCreatePinnedToCore(uart_rx_task, \"uart_rx_task\", 2048, this, 10, NULL, 0)!= pdPASS) {\n\t\t\t\tSerial.println(\"Failed to start uart_rx_task\");\n\t\t\t}\n\t\t} else {\n\t\t\tuart_set_rx_task_notification_value(UART_TASK_ON_RECEIVE_NOTIF_VALUE);\n\t\t\tif (xTaskCreatePinnedToCore(uart_rx_task, \"uart_rx_task\", 2048, this, 10, NULL, 0)!= pdPASS) {\n\t\t\t\tSerial.println(\"Failed to start uart_rx_task\");\n\t\t\t}\n\t\t}\n\t\txSemaphoreGive(uart_mutex);\n\t}\n}", "CodeBleu_score": 41.728245190436304}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tif (function == nullptr) {\n\t\treturn;\n\t}\n\t_rxTimeout = 1000;\n\t_rxTimeoutMax = 1000;\n\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\t_rxBuffer = (uint8_t *) malloc(_rxBufferSize);\n\t_rxBufferLength = 0;\n\t_rxBufferHead = 0;\n\t_rxBufferTail = 0;\n\t_rxBufferOverflow = 0;\n\t_rxBufferTimeout = 0;\n\t_rxBufferTimeoutTask = NULL;\n\t_rxBufferTimeoutTaskHandle = NULL;\n\t_rxBufferSemaphore = xSemaphoreCreateMutex();\n\t_rxBufferSemaphoreHandle = xSemaphoreGetMutexHolder(\n\t\t\t_rxBufferSemaphore);\n\tif (_rxBufferSemaphoreHandle == NULL) {\n\t\t_rxBufferSemaphoreHandle = xTaskGetCurrentTaskHandle();\n\t}\n\t_rxBufferSemaphoreHandle = xSemaphoreGetMutexHolder(_rxBufferSemaphore);\n\tif (_rxBufferSemaphoreHandle == NULL) {\n\t\t_rxBufferSemaphoreHandle = xTaskGetCurrentTaskHandle();\n\t}\n\tif (_rxBufferSemaphoreHandle == NULL) {\n\t\t_rxBufferSemaphoreHandle = xTaskGetIdleTaskHandleForCPU(0);\n\t}\n\tif (_rxBufferSemaphoreHandle == NULL) {\n\t\t_rxBufferSemaphoreHandle = xTaskGetIdleTaskHandleForCPU(1);\n\t}\n\tif (_rxBufferSemaphoreHandle == NULL) {\n\t\t_rxBufferSemaphoreHandle = xTaskGetIdleTaskHandleForCPU(2);\n\t}\n\tif (_rxBufferSemaphoreHandle == NULL) {\n\t\t_rxBufferSemaphoreHandle = xTaskGetIdleTaskHandleForCPU(3);\n\t}\n\tif (_rxBufferSemaphoreHandle == NULL) {\n\t\t_rxBufferSemaphoreHandle = xTaskGetIdleTaskHandleForCPU(4);\n\t}\n\tif (_rxBufferSemaphoreHandle == NULL) {\n\t\t_rxBufferSemaphoreHandle = xTaskGetIdleTaskHandleForCPU(5);\n\t}\n\tif (_rxBufferSemaphoreHandle == NULL) {\n\t\t_rxBufferSemaphoreHandle = xTaskGetIdleTaskHandleForCPU(6);\n\t}\n\tif (_rxBufferSemaphoreHandle == NULL) {\n\t\t_rxBuffer", "CodeBleu_score": 38.640840114012654}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t i = 0;\n\twhile (i < length) {\n\t\tchar c = timedRead();\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tif (c == terminator)\n\t\t\tbreak;\n\t\tbuffer[i++] = c;\n\t}\n\tbuffer[i] = 0;\n\treturn i;\n}", "CodeBleu_score": 48.81238663812807}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t n = 0;\n\twhile (length > 0) {\n\t\tif (timedRead() == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (n < length) {\n\t\t\t*buffer++ = timedRead();\n\t\t\tn++;\n\t\t}\n\t\tif (timedRead() == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*buffer = 0;\n\treturn n;\n}", "CodeBleu_score": 51.67708958160572}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\treturn readBytesUntil(terminator, (uint8_t*)buffer, length);\n}", "CodeBleu_score": 18.328390407128055}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (ledcGetChannel(pin) == LEDC_CHANNEL_0) {\n\t\tledcSetup(pin, frequency, 10);\n\t\tledcWrite(pin, 1023);\n\t\txQueueSend(queue, &pin, 10);\n\t} else {\n\t\tSerial.println(\"Pin is in use.\");\n\t}\n}", "CodeBleu_score": 17.24851392838176}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\t// TODO: Implement this function\n}", "CodeBleu_score": 3.7308020343026738}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (pin == 255) {\n\t\treturn;\n\t}\n\n\tif (ledc_get_channel_status(LED_CHANNEL_0) == LEDC_CHANNEL_DISABLED) {\n\t\tledc_channel_config_t ledc_channel;\n\t\tledc_channel.channel = LED_CHANNEL_0;\n\t\tledc_channel.duty = 0;\n\t\tledc_channel.gpio_num = pin;\n\t\tledc_channel.speed_mode = LEDC_LOW_SPEED_MODE;\n\t\tledc_channel.timer_sel = LEDC_TIMER_0;\n\t\tledc_channel.intr_type = LEDC_INTR_DISABLE;\n\t\tledc_channel_config(&ledc_channel);\n\n\t\tledc_fade_func_install(0);\n\n\t\tledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LED_CHANNEL_0, 500, 500);\n\n\t\tledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LED_CHANNEL_0, 0, 500);\n\n\t\tledc_stop(LEDC_LOW_SPEED_MODE, LED_CHANNEL_0, 0);\n\t} else {\n\t\tSerial.println(\"Pin already in use\");\n\t}\n}", "CodeBleu_score": 33.00427582411493}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usbStarted) {\n\t\tif (enabled) {\n\t\t\t// Enable WebUSB\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\tusbVersion = 0x0210;\n\t\t\t}\n\t\t\twebUSBEnabled = true;\n\t\t} else {\n\t\t\t// Disable WebUSB\n\t\t\twebUSBEnabled = false;\n\t\t}\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 43.291228011360026}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usb_start() == false) {\n\t\treturn false;\n\t}\n\n\tif (enabled) {\n\t\tif (usb_set_version(0x0210) == false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\twebusb_enabled = enabled;\n\n\treturn true;\n}", "CodeBleu_score": 30.730545238050343}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usb_state == USB_STATE_NONE) {\n\t\twebusb_enabled = enabled;\n\t\treturn false;\n\t}\n\tif (enabled) {\n\t\t// Ensure USB version is at least 0x0210\n\t\tif (usb_version < 0x0210) {\n\t\t\tusb_version = 0x0210;\n\t\t}\n\t} else {\n\t\t// Ensure USB version is at least 0x0200\n\t\tif (usb_version < 0x0200) {\n\t\t\tusb_version = 0x0200;\n\t\t}\n\t}\n\twebusb_enabled = enabled;\n\treturn true;\n}", "CodeBleu_score": 58.04653839628497}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t data[64];\n\tuint8_t length = 0;\n\tuint8_t bytesRead = 0;\n\n\twhile (length < 64) {\n\t\tbytesRead = USBCDC::read(data[length], 1);\n\t\tif (bytesRead == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlength += bytesRead;\n\t}\n\n\tif (length > 0) {\n\t\tif (rxQueue.post(data, length) == false) {\n\t\t\terror(\"CDC RX queue overflow\");\n\t\t}\n\t\trxEvent.post(length);\n\t}\n}", "CodeBleu_score": 15.591401720481157}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t rxBuffer[CDC_RX_BUFFER_SIZE];\n\tuint8_t rxLen;\n\n\t// Read data from the CDC device into the rxBuffer\n\trxLen = USB_read(rxBuffer, CDC_RX_BUFFER_SIZE);\n\n\t// If data was successfully read, post a receive event with the length of the received data\n\tif (rxLen > 0) {\n\t\t// Post the receive event\n\t\tpostEvent(EVENT_CDC_RX, rxLen);\n\t}\n\t// If the buffer is full, post an overflow event\n\telse {\n\t\t// Post the overflow event\n\t\tpostEvent(EVENT_CDC_RX_OVERFLOW, rxLen);\n\t}\n}", "CodeBleu_score": 9.407147558715188}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t data[64];\n\tuint8_t length;\n\n\tlength = _cdc.read(data, sizeof(data));\n\tif (length > 0) {\n\t\tfor (uint8_t i = 0; i < length; i++) {\n\t\t\tif (_rxQueue.post(data[i])!= osOK) {\n\t\t\t\t_rxQueue.post(0);\n\t\t\t\tLOG_ERROR(\"CDC RX queue overflow\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t_rxQueue.post(length);\n\t}\n}", "CodeBleu_score": 23.352594539111077}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tparams := pat.ParamValues(req)\n\trobotName := params[0]\n\trobot, err := a.Robot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(`{\"error\": \"no robot found with name %s\"}`, robotName)))\n\t\treturn\n\t}\n\n\tdevices := robot.Devices()\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 28.526043728710636}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot, err := a.Robot(robotName)\n\tif err!= nil {\n\t\tlog.Println(err)\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(`{\"error\": \"No robot found with name %s\"}`, robotName)))\n\t\treturn\n\t}\n\n\tdevices, err := robot.Devices()\n\tif err!= nil {\n\t\tlog.Println(err)\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(fmt.Sprintf(`{\"error\": \"An error occurred while retrieving devices for robot %s\"}`, robotName)))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(robeaux.DevicesToJSON(devices))\n}", "CodeBleu_score": 37.225838125018974}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tvar err error\n\tvar robot *robeaux.Robot\n\tvar robots []robeaux.Robot\n\tvar robotName string\n\tvar robotDevices []robeaux.Device\n\n\t// Get the robot name from the URL path.\n\trobotName = strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\t// Get the robots from the API.\n\trobots, err = a.Robots()\n\tif err!= nil {\n\t\tlog.Printf(\"error getting robots: %v\", err)\n\t\thttp.Error(res, \"error getting robots\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Find the robot with the given name.\n\trobot, err = a.findRobot(robots, robotName)\n\tif err!= nil {\n\t\tlog.Printf(\"error finding robot: %v\", err)\n\t\thttp.Error(res, \"error finding robot\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the devices associated with the robot.\n\trobotDevices, err = robot.Devices()\n\tif err!= nil {\n\t\tlog.Printf(\"error getting devices: %v\", err)\n\t\thttp.Error(res, \"error getting devices\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the JSON response to the HTTP response writer.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\terr = json.NewEncoder(res).Encode(robotDevices)\n\tif err!= nil {\n\t\tlog.Printf(\"error encoding JSON: %v\", err)\n\t\thttp.Error(res, \"error encoding JSON\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 34.60490856538654}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot, ok := a.Robots[robotName]\n\tif!ok {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot found with name %s\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections := make([]string, 0)\n\tfor _, c := range robot.Connections {\n\t\tconnections = append(connections, c.Name)\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 41.20760585486585}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot, err := a.Robot(robotName)\n\tif err!= nil {\n\t\ta.error(res, err)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\terr = json.NewEncoder(res).Encode(robot.Connections())\n\tif err!= nil {\n\t\ta.error(res, err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 40.16032667077209}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot, err := a.Robot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with the name %s was found.\n\", robotName)\n\t\treturn\n\t}\n\n\tconnections := make([]robeaux.Connection, len(robot.Connections))\n\tfor i, conn := range robot.Connections {\n\t\tconnections[i] = robeaux.Connection{\n\t\t\tName:        conn.Name,\n\t\t\tDescription: conn.Description,\n\t\t\tType:        conn.Type,\n\t\t\tID:          conn.ID,\n\t\t\tPin:         conn.Pin,\n\t\t}\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 44.344508511744266}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tvar err error\n\n\t// Parse the URL query parameters\n\tquery := req.URL.Query()\n\trobotName := query.Get(\"robot\")\n\tdeviceName := query.Get(\"device\")\n\tcommand := query.Get(\"command\")\n\n\t// Check if the robot and device names are valid\n\tif robotName == \"\" || deviceName == \"\" || command == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(res, \"Invalid request. Robot name, device name, and command are required.\")\n\t\treturn\n\t}\n\n\t// Check if the robot exists\n\trobot, err := a.getRobot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(res, \"Robot not found.\")\n\t\treturn\n\t}\n\n\t// Check if the device exists\n\tdevice, err := robot.GetDriver(deviceName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(res, \"Device not found.\")\n\t\treturn\n\t}\n\n\t// Execute the command on the device\n\terr = device.Command(command)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(res, \"Error executing command on device.\")\n\t\treturn\n\t}\n\n\t// Send a successful response\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprint(res, \"Command executed successfully.\")\n}", "CodeBleu_score": 41.02412105658383}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL query parameter \"robot\".\n\trobotName := req.URL.Query().Get(\"robot\")\n\n\t// Get the device name from the URL query parameter \"device\".\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Get the command name from the URL query parameter \"command\".\n\tcommandName := req.URL.Query().Get(\"command\")\n\n\t// Get the command parameters from the URL query parameter \"parameters\".\n\tparameters := req.URL.Query().Get(\"parameters\")\n\n\t// Get the command parameters as a map.\n\tparametersMap := make(map[string]string)\n\tif parameters!= \"\" {\n\t\terr := json.Unmarshal([]byte(parameters), &parametersMap)\n\t\tif err!= nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n\n\t// Check if the robot exists.\n\tif _, ok := a.Robots[robotName];!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Robot '%s' not found.\", robotName)))\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\trobot := a.Robots[robotName]\n\tif _, ok := robot.Devices[deviceName];!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Device '%s' not found.\", deviceName)))\n\t\treturn\n\t}\n\n\t// Get the device.\n\tdevice := robot.Devices[deviceName]\n\n\t// Check if the command exists.\n\tif _, ok := device.Commands[commandName];!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Command '%s' not found.\", commandName)))\n\t\treturn\n\t}\n\n\t// Get the command.\n\tcommand := device.Commands[commandName]\n\n\t// Check if the command is a function.\n\tif command.Function == nil {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(fmt.Sprintf(\"Command '%s' is not a function.\", commandName)))\n\t\treturn\n\t}\n\n\t// Execute the command.\n\terr := command.Function(robot, device, parametersMap)\n\tif", "CodeBleu_score": 41.73682031752647}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tlog.Println(\"Executing robot device command\")\n\tlog.Println(\"Query:\", req.URL.Query())\n\n\t// Get the robot name from the URL query parameter\n\trobotName := req.URL.Query().Get(\"robot\")\n\tif robotName == \"\" {\n\t\ta.writeJSONError(res, \"Missing robot name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Get the device name from the URL query parameter\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tif deviceName == \"\" {\n\t\ta.writeJSONError(res, \"Missing device name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Get the command name from the URL query parameter\n\tcommandName := req.URL.Query().Get(\"command\")\n\tif commandName == \"\" {\n\t\ta.writeJSONError(res, \"Missing command name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Get the command parameters from the URL query parameter\n\tcommandParameters := req.URL.Query().Get(\"parameters\")\n\tif commandParameters == \"\" {\n\t\ta.writeJSONError(res, \"Missing command parameters\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Parse the command parameters as JSON\n\tvar commandParametersMap map[string]interface{}\n\terr := json.Unmarshal([]byte(commandParameters), &commandParametersMap)\n\tif err!= nil {\n\t\ta.writeJSONError(res, \"Error parsing command parameters: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Check if the robot exists\n\tif _, ok := a.robots[robotName];!ok {\n\t\ta.writeJSONError(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Check if the device exists\n\trobot := a.robots[robotName]\n\tif _, ok := robot.Devices[deviceName];!ok {\n\t\ta.writeJSONError(res, \"Device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the device\n\tdevice := robot.Devices[deviceName]\n\n\t// Execute the command on the device\n\terr = device.Command(commandName, commandParametersMap)\n\tif err!= nil {\n\t\ta.writeJSONError(res, \"Error", "CodeBleu_score": 44.20369209279661}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\tif authHeader == \"\" {\n\t\t\thttp.Error(w, \"Missing Authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauth, err := base64.StdEncoding.DecodeString(authHeader[6:])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Invalid Authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif subtle.ConstantTimeCompare(auth, []byte(username+\":\"+password))!= 1 {\n\t\t\thttp.Error(w, \"Invalid credentials\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If we get here, the credentials were valid, so we can proceed to the next handler.\n\t}\n}", "CodeBleu_score": 51.89745616745842}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauthorization := r.Header.Get(\"Authorization\")\n\t\tif authorization == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"example\\\"\")\n\t\t\thttp.Error(w, \"Authorization Required\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tencoded := authorization[len(\"Basic \"):]\n\t\tdecoded, err := base64.StdEncoding.DecodeString(encoded)\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tpair := string(decoded)\n\t\tif subtle.ConstantTimeCompare([]byte(pair), []byte(username+\":\"+password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"example\\\"\")\n\t\t\thttp.Error(w, \"Invalid Credentials\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the credentials are valid, the request proceeds to the next handler.\n\t}\n}", "CodeBleu_score": 54.17340119730816}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the incoming request\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\n\t\t// Check if the \"Authorization\" header is empty\n\t\tif authHeader == \"\" {\n\t\t\t// Set the \"WWW-Authenticate\" header to \"Basic realm=\\\"Restricted Area\\\"\"\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted Area\\\"\")\n\n\t\t\t// Respond with a \"401 Unauthorized\" status and an error message\n\t\t\thttp.Error(w, \"Authorization Required\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the \"Authorization\" header using base64 encoding\n\t\tdecodedAuthHeader, err := base64.StdEncoding.DecodeString(authHeader)\n\t\tif err!= nil {\n\t\t\t// Respond with a \"400 Bad Request\" status and an error message\n\t\t\thttp.Error(w, \"Invalid Authorization Header\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the \"Authorization\" header into a username and password\n\t\tusernamePassword := string(decodedAuthHeader)\n\n\t\t// Check if the username and password match the provided credentials\n\t\tif subtle.ConstantTimeCompare([]byte(usernamePassword), []byte(username+\":\"+password))!= 1 {\n\t\t\t// Set the \"WWW-Authenticate\" header to \"Basic realm=\\\"Restricted Area\\\"\"\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted Area\\\"\")\n\n\t\t\t// Respond with a \"401 Unauthorized\" status and an error message\n\t\t\thttp.Error(w, \"Invalid Username or Password\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Call the next handler\n\t\thttp.Error(w, \"OK\", http.StatusOK)\n\t}\n}", "CodeBleu_score": 52.54601208042779}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"No connection to device\")\n\t}\n\n\tif!a.connection.SupportsAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\"Device does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = a.scale(raw)\n\n\treturn raw, a.lastScaledValue, nil\n}", "CodeBleu_score": 53.439054198505985}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif!a.connection.AnalogReadingSupported() {\n\t\treturn 0, 0.0, fmt.Errorf(\"Analog reading is not supported by the connection\")\n\t}\n\n\t// Retrieve the raw sensor value\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaledValue := a.scaleFunction(rawValue)\n\n\t// Update the last read values\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 49.015889932753645}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.scale\n\ta.lastRead = time.Now()\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 48.69010558315854}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n}", "CodeBleu_score": 35.85271778311411}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tname:        \"GroveSoundSensorDriver\",\n\t\tpin:         pin,\n\t\tanalog:      a,\n\t\tanalogValue: 0,\n\t\tthreshold:   100,\n\t}\n\td.Initialize(opts...)\n\treturn d\n}", "CodeBleu_score": 36.8931781013959}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: AnalogSensorDriver{\n\t\t\tAnalogReader: a,\n\t\t\tPin:          pin,\n\t\t},\n\t}\n}", "CodeBleu_score": 28.003590979490095}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Clears the bit.\n\td.writeRegister(MFRC522_CommandReg, MFRC522_PCD_SoftReset)\n\n\t// Wait for the PowerDown bit in CommandReg to be cleared\n\tif!d.readRegisterBit(MFRC522_CommandReg, MFRC522_PCD_SoftReset) {\n\t\treturn fmt.Errorf(\"MFRC522: softReset failed\")\n\t}\n\n\t// Wait for the PowerDown bit in CommandReg to be set\n\tif d.readRegisterBit(MFRC522_CommandReg, MFRC522_PCD_SoftReset) {\n\t\treturn fmt.Errorf(\"MFRC522: softReset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 38.407019943371466}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Reset the MFRC522\n\td.writeRegister(MFRC522_CommandReg, MFRC522_SoftReset)\n\t// Wait for the PowerDown bit in CommandReg to be cleared\n\tif err := d.waitUntilBitIsCleared(MFRC522_CommandReg, MFRC522_PowerDown); err!= nil {\n\t\treturn err\n\t}\n\t// Clear the bit and wait for the PowerDown bit to be set\n\td.writeRegister(MFRC522_CommandReg, MFRC522_SoftReset)\n\tif err := d.waitUntilBitIsSet(MFRC522_CommandReg, MFRC522_PowerDown); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.77878153930361}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Clears the bit mask\n\td.writeRegister(CommandReg, 0x00)\n\t// Set the reset bit\n\td.writeRegister(CommandReg, PCD_SoftReset)\n\t// Wait for the reset to complete\n\ttime.Sleep(100 * time.Millisecond)\n\t// Check the reset bit\n\tif d.readRegister(CommandReg) & PCD_SoftReset!= 0 {\n\t\treturn fmt.Errorf(\"Soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 38.191414735016075}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Read the first byte, which indicates the size of the data that follows.\n\t// The second byte indicates the status of the receiver and transmitter.\n\t// The third byte indicates the error condition.\n\tstatus, err := d.readRegister(MFRC522_FIFODataReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Verify the size of the data\n\tif uint8(len(backData))!= status {\n\t\treturn 0, fmt.Errorf(\"readFifo: Data length does not match FIFO data length\")\n\t}\n\n\t// Read the bytes\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(MFRC522_FIFODataReg)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Tell the MFRC522 to go back to a known state\n\terr = d.writeRegister(MFRC522_CommandReg, MFRC522_Idle)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Tell the MFRC522 to go back to a known state\n\terr = d.writeRegister(MFRC522_BitFramingReg, 0x00)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn status, nil\n}", "CodeBleu_score": 50.186738452998526}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// The maximum length of a FIFO buffer\n\tmaxLen := 64\n\t// The length of the FIFO\n\tlenFifo, err := d.readRegister(MFRC522_FIFO_LENGTH)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\t// The number of bytes to read\n\tnumBytes := lenFifo & 0x7F\n\t// The number of bytes to read is greater than the maximum length\n\tif numBytes > maxLen {\n\t\treturn 0, fmt.Errorf(\"FIFO length is greater than maximum length\")\n\t}\n\t// Read the data from the FIFO\n\tfor i := uint8(0); i < numBytes; i++ {\n\t\t// Read a byte\n\t\tbackData[i], err = d.readRegister(MFRC522_FIFO)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the control byte\n\tcontrol, err := d.readRegister(MFRC522_CONTROL)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\treturn control, nil\n}", "CodeBleu_score": 44.3682275246854}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check if there is enough room in the provided byte slice to store the FIFO contents.\n\tif len(backData) < 1 {\n\t\treturn 0, fmt.Errorf(\"Error: FIFO buffer is too short to store received data.\")\n\t}\n\n\t// Get the number of bytes currently in the FIFO.\n\t// This is the number of bytes that can be read from the FIFO.\n\t// The number of bytes in the FIFO is also equal to the number of bytes in the buffer.\n\tn, err := d.readRegister(0x35)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the number of bytes in the FIFO is equal to the number of bytes requested.\n\tif n!= len(backData) {\n\t\treturn 0, fmt.Errorf(\"Error: Number of bytes in FIFO (%d) is not equal to number of bytes requested (%d).\", n, len(backData))\n\t}\n\n\t// Read the bytes from the FIFO.\n\t// The FIFO is read byte by byte because the MFRC522 uses a SPI interface.\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i], err = d.readRegister(0x38 + uint8(i))\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received.\n\t// This is used to check if the CRC is valid.\n\tcontrol, err := d.readRegister(0x27)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Return the number of bytes read and the last bits received.\n\treturn control, nil\n}", "CodeBleu_score": 52.42431500440584}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Build command buffer\n\thaltCmd := []byte{PICC_CMD_HALT}\n\n\t// Calculate CRC\n\tcrc, err := d.crc(haltCmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Append CRC to halt command\n\thaltCmd = append(haltCmd, crc[0])\n\thaltCmd = append(haltCmd, crc[1])\n\n\t// Halt PICC\n\terr = d.writeCommand(haltCmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 33.53044231647203}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t//debug.Print(fmt.Sprintf(\"Halt PICC\"))\n\t// Create a PICC command buffer\n\tcmd := []byte{PICC_CMD_HLTA}\n\t// Halt the PICC\n\terr := d.writeCommand(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 14.911325593238779}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// build halt command\n\thaltCmd := []byte{PICC_CMD_HALT}\n\n\t// send halt command\n\terr := d.sendCommand(haltCmd, nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// check result\n\tif d.lastErr!= nil {\n\t\treturn d.lastErr\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 18.256938980039827}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// A block is a collection of 4 bytes.\n\t// The MF is divided into 64 blocks of 4 bytes.\n\t// The block address of block 0 is 0x00, and the block address of block 1 is 0x01.\n\t// The block address of block 63 is 0x3F.\n\t// To read a block, the block address must be specified.\n\t// The block address is a number between 0x00 and 0x3F.\n\t// The block address 0x00 is the first block in the 1st sector of the 1st row of the 1st card.\n\t// The block address 0x01 is the second block in the 1st sector of the 1st row of the 1st card.\n\t// The block address 0x02 is the third block in the 1st sector of the 1st row of the 1st card.\n\t// The block address 0x03 is the fourth block in the 1st sector of the 1st row of the 1st card.\n\t// The block address 0x04 is the first block in the 2nd sector of the 1st row of the 1st card.\n\t// The block address 0x05 is the second block in the 2nd sector of the 1st row of the 1st card.\n\t// The block address 0x06 is the third block in the 2nd sector of the 1st row of the 1st card.\n\t// The block address 0x07 is the fourth block in the 2nd sector of the 1st row of the 1st card.\n\t// The block address 0x08 is the first block in the 3rd sector of the 1st row of the 1st card.\n\t// The block address 0x09 is the second block in the 3rd sector of the 1st row of the 1st card.\n\t// The block address 0x0A is the third block in the 3rd sector of the 1st row of the 1st card.\n\t// The block address 0x0B is the fourth block in the 3rd sector of", "CodeBleu_score": 3.9400793350610552}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Sanity check\n\tif block > 63 {\n\t\treturn nil, fmt.Errorf(\"Block number out of range\")\n\t}\n\n\t// Build command\n\tcmd := []byte{PICC_CMD_MF_READ, block}\n\n\t// Calculate CRC\n\tif err := d.mfrc522Crc(cmd, 2, cmd); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Send command\n\tif err := d.mfrc522Transceive(cmd, 0x00, 16); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn cmd, nil\n}", "CodeBleu_score": 37.43039106781203}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// The command buffer\n\tcmdBuffer := make([]byte, 18)\n\t// The response buffer\n\trespBuffer := make([]byte, 18)\n\t// The response size\n\trespSize := 0\n\t// The number of bytes to send\n\tcmdSize := 0\n\n\t// The CRC\n\tcrc := uint8(0)\n\n\t// The command\n\tcmd := make([]byte, 1)\n\n\t// The response\n\tresp := make([]byte, 1)\n\n\t// The command buffer\n\tcmdBuffer[0] = PICC_CMD_MF_READ\n\tcmdBuffer[1] = block\n\n\t// Calculate CRC_A\n\tcrc = d.crc(cmdBuffer[0:2])\n\n\t// Append CRC_A to the end\n\tcmdBuffer[2] = crc\n\n\t// Send the command\n\tif err := d.communicate(cmdBuffer, &cmdSize, respBuffer, &respSize); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Verify CRC_A\n\tif respSize!= 1 || (respBuffer[respSize-1]!= crc) {\n\t\treturn nil, fmt.Errorf(\"CRC_A is not valid!\")\n\t}\n\n\t// The data is the last 16 bytes\n\treturn respBuffer[0:respSize-1], nil\n}", "CodeBleu_score": 36.86779597688101}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Clear the buffer\n\td.ClearBuffer()\n\t// Apply the requested mode.\n\td.WriteByte(PICC_CMD_REQA)\n\t// Apply the command.\n\td.WriteByte(reqMode)\n\t// Start the transmission\n\treturn d.Transceive(answer)\n}", "CodeBleu_score": 13.291911281218727}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tvar err error\n\t// Clear the buffer\n\tfor i := range answer {\n\t\tanswer[i] = 0x00\n\t}\n\n\t// Prepare the command\n\tcommand := []byte{0x00, reqMode}\n\n\t// Transmit the command\n\terr = d.transceive(command, answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check that the response is valid\n\tif answer[0]!= 0x00 {\n\t\treturn fmt.Errorf(\"invalid response\")\n\t}\n\n\t// Check whether the CRC_A is valid\n\tif answer[1]!= 0x00 {\n\t\treturn fmt.Errorf(\"invalid CRC\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 37.73800561783551}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// MFRC522_PICC_REQA - The first byte of a REQuest command uses the 0x52 header.\n\t// MFRC522_PICC_WUPA - The first byte of a WUPA command uses the 0x52 header.\n\t// MFRC522_PICC_ANTICOLL - The first byte of an Anticollision command uses the 0x93 header.\n\t// MFRC522_PICC_SElECTTAG - The first byte of a SelectTag command uses the 0x93 header.\n\t// MFRC522_PICC_AUTHENT1A - The first byte of an Authentication command uses the 0x60 header.\n\t// MFRC522_PICC_AUTHENT1B - The first byte of an Authentication command uses the 0x61 header.\n\t// MFRC522_PICC_READ - The first byte of a Read command uses the 0x30 header.\n\t// MFRC522_PICC_WRITE - The first byte of a Write command uses the 0xA0 header.\n\t// MFRC522_PICC_DECREMENT - The first byte of a Decrement command uses the 0xC0 header.\n\t// MFRC522_PICC_INCREMENT - The first byte of an Increment command uses the 0xC1 header.\n\t// MFRC522_PICC_RESTORE - The first byte of a Restore command uses the 0xC2 header.\n\t// MFRC522_PICC_TRANSFER - The first byte of a Transfer command uses the 0xB0 header.\n\t// MFRC522_PICC_HALT - The first byte of a Halt command uses the 0x50 header.\n\t// The second byte of the command data is the PICC number.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"Answer buffer is too short: %d bytes\", len(answer))\n\t}\n\n\t// Clear the buffer\n\tfor i := range answer {\n\t\tanswer[i] = 0\n\t}\n\n\t// Start the transmission\n\tif err := d", "CodeBleu_score": 29.007071137374986}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.direction == \"cw\" {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\tif d.stepNumber < 0 {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber > d.stepsPerRevolution - 1 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber == 0 {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber == d.stepsPerRevolution - 1 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber == 0 {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber == d.stepsPerRevolution - 1 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber == 0 {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber == d.stepsPerRevolution - 1 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber == 0 {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber == d.stepsPerRevolution - 1 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber == 0 {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber == d.stepsPerRevolution - 1 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber == 0 {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber == d.stepsPerRevolution - 1 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber == 0 {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber == d.steps", "CodeBleu_score": 29.628670408584235}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == nil {\n\t\treturn fmt.Errorf(\"EasyDriver step pin must be set before calling onePinStepping\")\n\t}\n\n\tif d.direction == \"forward\" {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\tif d.stepNumber >= d.stepsPerRevolution {\n\t\td.stepNumber = 0\n\t} else if d.stepNumber < 0 {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\terr := d.stepPin.Low()\n\tif err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.delay)\n\terr = d.stepPin.High()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.1572840695419}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.direction {\n\t\td.step++\n\t\tif d.step > d.steps {\n\t\t\td.step = 1\n\t\t}\n\t} else {\n\t\td.step--\n\t\tif d.step < 1 {\n\t\t\td.step = d.steps\n\t\t}\n\t}\n\n\tif d.step == 1 {\n\t\td.digitalWrite(d.stepPin, gobot.HIGH)\n\t} else {\n\t\td.digitalWrite(d.stepPin, gobot.LOW)\n\t}\n\ttime.Sleep(d.stepDelay)\n\tif d.step == 1 {\n\t\td.digitalWrite(d.stepPin, gobot.LOW)\n\t} else {\n\t\td.digitalWrite(d.stepPin, gobot.HIGH)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 38.05232894170567}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.running {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.stop = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\td.mutex.Lock()\n\t\t\t\td.measureDistance()\n\t\t\t\td.mutex.Unlock()\n\t\t\t\ttime.Sleep(d.interval)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 40.83653179720569}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\tif d.running {\n\t\treturn fmt.Errorf(\"Distance monitor already running\")\n\t}\n\n\td.running = true\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.stop = make(chan bool)\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\tgo d.measureDistance()\n\n\treturn nil\n}", "CodeBleu_score": 26.85130533933475}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.running {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.stop = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\td.mutex.Lock()\n\t\t\t\td.measureDistance()\n\t\t\t\td.mutex.Unlock()\n\t\t\t\ttime.Sleep(d.interval)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 40.83653179720569}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, name string, id uint32, interrupt uint32) {\n\t\tvar start time.Time\n\t\tvar stop time.Time\n\n\t\td.Events.Add(gobot.Event{\n\t\t\tName:   name,\n\t\t\tPin:    pin,\n\t\t\tID:     id,\n\t\t\tParams: []interface{}{duration},\n\t\t\tInterrupt: interrupt,\n\t\t})\n\n\t\tif name == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if name == \"falling\" {\n\t\t\tstop = time.Now()\n\t\t\td.Events.Publish(gobot.Event{\n\t\t\t\tName:   \"duration\",\n\t\t\t\tPin:    pin,\n\t\t\t\tID:     id,\n\t\t\t\tParams: []interface{}{stop.Sub(start)},\n\t\t\t\tInterrupt: interrupt,\n\t\t\t})\n\t\t}\n\t}\n}", "CodeBleu_score": 41.84104329719471}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstart := time.Now()\n\treturn func(pin int, duration time.Duration, name string, low uint32, high uint32) {\n\t\tif pin == 1 {\n\t\t\tstart = time.Now()\n\t\t} else if pin == 0 {\n\t\t\td.eventChannel <- &gobot.Event{\n\t\t\t\tName:        name,\n\t\t\t\tTime:        time.Now(),\n\t\t\t\tData:        time.Since(start),\n\t\t\t\tDevice:      d,\n\t\t\t\tPin:         pin,\n\t\t\t\tLowDuration: low,\n\t\t\t\tHighDuration: high,\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.9247333138355}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, _ string, _ uint32, _ uint32) {\n\t\tif d.startTimestamp == 0 {\n\t\t\td.startTimestamp = time.Now().UnixNano()\n\t\t} else {\n\t\t\td.duration = duration\n\t\t\td.startTimestamp = 0\n\t\t\td.eventChannel <- d.duration\n\t\t}\n\t}\n}", "CodeBleu_score": 37.16011999110227}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor by setting the trigger pin to high\n\td.pin.DigitalWrite(system.HIGH)\n\ttime.Sleep(time.Microsecond * 10)\n\td.pin.DigitalWrite(system.LOW)\n\n\t// Wait for the sensor to complete the measurement or for a timeout to occur\n\tfor {\n\t\tif d.pin.DigitalRead() == system.HIGH {\n\t\t\tbreak\n\t\t}\n\t\tif d.timeout!= 0 && time.Since(d.start) > d.timeout {\n\t\t\treturn fmt.Errorf(\"timeout waiting for sensor to complete measurement\")\n\t\t}\n\t\ttime.Sleep(time.Millisecond * 1)\n\t}\n\n\t// Calculate the time it took for the sensor to complete the measurement\n\telapsed := time.Since(d.start)\n\td.measurements = append(d.measurements, elapsed)\n\n\treturn nil\n}", "CodeBleu_score": 48.146824473718915}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.Trigger()\n\td.log.Info(\"Waiting for measurement to complete\")\n\tselect {\n\tcase <-d.done:\n\t\td.log.Info(\"Measurement timed out\")\n\t\treturn fmt.Errorf(\"measurement timed out\")\n\tcase <-d.timeout:\n\t\td.log.Info(\"Measurement timed out\")\n\t\treturn fmt.Errorf(\"measurement timed out\")\n\tcase <-d.measurementComplete:\n\t\td.log.Info(\"Measurement complete\")\n\t\td.measurementMutex.Lock()\n\t\td.measurement = d.measurementTime\n\t\td.measurementMutex.Unlock()\n\t\treturn nil\n\t}\n}", "CodeBleu_score": 43.74721117892316}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.timeout == 0 {\n\t\treturn fmt.Errorf(\"timeout not set\")\n\t}\n\n\tif d.triggerPin == 0 {\n\t\treturn fmt.Errorf(\"trigger pin not set\")\n\t}\n\n\tif d.echoPin == 0 {\n\t\treturn fmt.Errorf(\"echo pin not set\")\n\t}\n\n\t// Trigger the sensor by setting the trigger pin high for 10 microseconds\n\td.pin.DigitalWrite(d.triggerPin, gobot.HIGH)\n\ttime.Sleep(10 * time.Microsecond)\n\td.pin.DigitalWrite(d.triggerPin, gobot.LOW)\n\n\t// Wait for the echo pin to go high, indicating that the sensor has received the trigger signal\n\ttimeout := time.After(d.timeout)\n\tfor {\n\t\tif d.pin.DigitalRead(d.echoPin) == gobot.HIGH {\n\t\t\tbreak\n\t\t}\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo pin to go high\")\n\t\tdefault:\n\t\t}\n\t}\n\n\t// Wait for the echo pin to go low, indicating that the sensor has received the echo signal\n\ttimeout = time.After(d.timeout)\n\tfor {\n\t\tif d.pin.DigitalRead(d.echoPin) == gobot.LOW {\n\t\t\tbreak\n\t\t}\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo pin to go low\")\n\t\tdefault:\n\t\t}\n\t}\n\n\t// Measure the time it takes for the echo pin to go high and then go low again\n\tstart := time.Now()\n\tfor {\n\t\tif d.pin.DigitalRead(d.echoPin) == gobot.HIGH {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor {\n\t\tif d.pin.DigitalRead(d.echoPin) == gobot.LOW {\n\t\t\tbreak\n\t\t}\n\t}\n\telapsed := time.Since(start)\n\n\t// Calculate the distance in centimeters\n\tdistance := float64(elapsed) / 58\n\n\t// Store the measured distance in the distance variable\n\td.distance = distance\n\n\t", "CodeBleu_score": 45.89845453243952}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if \"PLATFORMIO_TOKEN\" in os.environ:\n        return os.environ[\"PLATFORMIO_TOKEN\"]\n    if \"access_token\" in self.state:\n        if self.state[\"access_token\"] and self.state[\"expires_at\"] > time.time():\n            return self.state[\"access_token\"]\n        if self.state[\"refresh_token\"]:\n            return self.fetch_new_token(self.state[\"refresh_token\"])\n    raise UserSideException(\"Account not authorized\")\n\n", "CodeBleu_score": 21.876101413704536}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.token:\n        return self.token\n    if self.refresh_token:\n        try:\n            return self.__fetch_new_token()\n        except HTTPClientError as e:\n            if e.code == 401:\n                self.token = self.refresh_token = None\n                raise AccountNotAuthorized(\n                    \"Account is not authorized. Please login again.\")\n            raise\n    raise AccountNotAuthorized(\n        \"Account is not authorized. Please login again.\")\n\n", "CodeBleu_score": 22.0556140310018}, {"code": "def fetch_authentication_token(self)\n\t\n    if \"PIO_TOKEN\" in os.environ:\n        return os.environ[\"PIO_TOKEN\"]\n    else:\n        if self.token_expires_at and self.token_expires_at > time.time():\n            return self.token\n        else:\n            if self.refresh_token and self.token_expires_at and self.token_expires_at < time.time():\n                try:\n                    self.token = self.fetch_access_token()\n                    self.save_token()\n                    return self.token\n                except UserSideException:\n                    pass\n            raise PlatformioException(\n                \"Authentication token is not valid or expired. Please login again.\"\n            )\n\n", "CodeBleu_score": 29.728000017999612}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self._get_refresh_token()\n        self._delete_session()\n        response = HTTPClient().post(\n            \"https://accounts.platformio.org/v1/logout\",\n            json={\"refresh_token\": refresh_token},\n        )\n        response.raise_for_status()\n        return True\n    except HTTPClientError as exc:\n        if exc.response.status_code!= 404:\n            raise UserSideException(\n                \"An error occurred while logging out: %s\" % exc.response.text\n            )\n\n", "CodeBleu_score": 43.28816163338569}, {"code": "def logout(self)\n\t\n    try:\n        self._client.delete(self._get_logout_url())\n        self._client.delete_session()\n    except HTTPClientError:\n        pass\n    return True\n\n", "CodeBleu_score": 28.1736984032522}, {"code": "def logout(self)\n\t\n    try:\n        self.get_refresh_token()\n        self.delete_session()\n        self.request_logout()\n    except PlatformioException:\n        pass\n\n", "CodeBleu_score": 24.056634405983594}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for package in self.packages:\n        if not package.optional:\n            spec = PackageSpec(package.name, package.version)\n            spec.url = package.url\n            spec.source_dir = package.source_dir\n            spec.is_library = package.is_library\n            spec.is_optional = package.optional\n            packages.append(spec)\n    return packages", "CodeBleu_score": 24.53514732453487}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if not package.optional:\n            result.append(PackageSpec(package.metadata.name, package.metadata.version, package.metadata.source_url))\n    return result\n\n", "CodeBleu_score": 20.51340107374169}, {"code": "def dump_used_packages(self)\n\t\n    used_packages = []\n    for package in self.get_packages():\n        if not package.optional:\n            package_spec = PackageSpec(package.metadata)\n            if package_spec.external:\n                package_spec.url = package.metadata.get('url')\n            used_packages.append(package_spec)\n    return used_packages\n\n", "CodeBleu_score": 27.86874443773147}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if env is None:\n        raise UndefinedEnvPlatformError()\n    platform = cls.get_spec(env)\n    if platform is None:\n        raise UnknownPlatform(env)\n    project = ProjectConfig.get_instance()\n    project.set_env(env)\n    project.install_packages(\n        targets=targets,\n        autoinstall=autoinstall,\n        force=True,\n    )\n    return cls(platform, autoinstall=autoinstall)\n\n", "CodeBleu_score": 35.696682943444316}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform = cls.get_platform(env)\n    if platform is None:\n        raise UndefinedEnvPlatformError(\n            \"Undefined platform '{}' for environment '{}'\".format(\n                env, cls.get_name()\n            )\n        )\n    if not isinstance(platform, base.Platform):\n        raise UnknownPlatform(\n            \"Platform '{}' is not a valid PlatformIO platform\".format(platform)\n        )\n    if targets is None:\n        targets = cls.get_targets(env)\n    project_config = ProjectConfig.get_instance()\n    project_config.set_env_name(env)\n    project_config.set_targets(targets)\n    project_config.set_auto_install(autoinstall)\n    project_config.set_env_platform(platform)\n    project_config.set_env_packages(\n        cls.get_packages(env, targets, autoinstall)\n    )\n    return cls(platform)\n\n", "CodeBleu_score": 31.029031914340543}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform = cls.get_package_spec(env)\n    if platform is None:\n        raise UndefinedEnvPlatformError(env)\n    if targets is None:\n        targets = cls.get_targets(env)\n    return cls(\n        platform=platform,\n        autoinstall=autoinstall,\n        targets=targets,\n        env=env,\n    )\n\n", "CodeBleu_score": 25.52885861188472}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(AXP192_ADDRESS);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(AXP192_ADDRESS, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 63.05422231852283}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tuint8_t Buff_Temp[255];\n\tuint8_t i;\n\tuint8_t j;\n\tuint8_t k;\n\n\ti = 0;\n\tj = 0;\n\tk = 0;\n\n\tI2C1_Init();\n\tI2C1_Start();\n\tI2C1_Write(0x34);\n\tI2C1_Write(Addr);\n\tI2C1_Stop();\n\tI2C1_Start();\n\tI2C1_Write(0x35);\n\n\twhile (i < Size) {\n\t\tif (i == Size - 1) {\n\t\t\tI2C1_Read_Nack();\n\t\t} else {\n\t\t\tI2C1_Read_Ack();\n\t\t}\n\t\tBuff_Temp[j] = I2C1_Read();\n\t\tj++;\n\t\ti++;\n\t}\n\tI2C1_Stop();\n\tI2C1_DeInit();\n\n\tfor (i = 0; i < Size; i++) {\n\t\tBuff[k] = Buff_Temp[i];\n\t\tk++;\n\t}\n}", "CodeBleu_score": 43.20322542125859}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(AXP192_I2C_ADDRESS);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\n\tWire.requestFrom(AXP192_I2C_ADDRESS, Size);\n\twhile (Wire.available()) {\n\t\t*Buff++ = Wire.read();\n\t}\n}", "CodeBleu_score": 45.373587273543755}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tif (time_in_us > 0) {\n\t\t// enable timer wakeup source\n\t\tuint8_t reg_val = 0;\n\t\tI2C_Read(0x30, &reg_val, 1);\n\t\treg_val |= 0x01;\n\t\tI2C_Write(0x30, &reg_val, 1);\n\n\t\t// set timer wakeup time\n\t\tuint8_t buf[4];\n\t\tbuf[0] = (time_in_us >> 24) & 0xFF;\n\t\tbuf[1] = (time_in_us >> 16) & 0xFF;\n\t\tbuf[2] = (time_in_us >> 8) & 0xFF;\n\t\tbuf[3] = time_in_us & 0xFF;\n\t\tI2C_Write(0x31, buf, 4);\n\t} else {\n\t\t// disable timer wakeup source\n\t\tuint8_t reg_val = 0;\n\t\tI2C_Read(0x30, &reg_val, 1);\n\t\treg_val &= 0xFE;\n\t\tI2C_Write(0x30, &reg_val, 1);\n\t}\n\n\t// enter deep sleep\n\tuint8_t reg_val = 0;\n\tI2C_Read(0x32, &reg_val, 1);\n\treg_val |= 0x01;\n\tI2C_Write(0x32, &reg_val, 1);\n}", "CodeBleu_score": 42.32675852038863}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tuint8_t buf[2];\n\tbuf[0] = 0x00;\n\tbuf[1] = 0x00;\n\tif (time_in_us == 0) {\n\t\tbuf[0] = 0x01;\n\t} else {\n\t\tbuf[0] = 0x02;\n\t\tbuf[1] = (uint8_t) (time_in_us >> 8);\n\t\tbuf[1] |= (uint8_t) (time_in_us << 8);\n\t}\n\tWriteRegister(0x25, buf, 2);\n}", "CodeBleu_score": 35.91826882148227}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tif (time_in_us == 0) {\n\t\tSetSleep(0);\n\t\t_sleep_mode = 0;\n\t} else {\n\t\tSetSleep(1);\n\t\t_sleep_mode = 1;\n\t\t_sleep_time = time_in_us;\n\t}\n}", "CodeBleu_score": 29.271138919510975}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = this->scroll_address;\n\tif (y >= this->height - this->fixed_bottom_height) {\n\t\ty = 0;\n\t} else {\n\t\ty += this->font_height;\n\t}\n\tif (y >= this->height - this->fixed_bottom_height) {\n\t\ty = this->fixed_bottom_height;\n\t}\n\tthis->draw_rect(0, y, this->width, this->font_height, color);\n\tthis->scroll_address = y;\n\treturn y;\n}", "CodeBleu_score": 7.841677460764796}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tuint16_t x = 0, y = 0;\n\tuint16_t x2 = 0, y2 = 0;\n\tuint16_t x3 = 0, y3 = 0;\n\tuint16_t x4 = 0, y4 = 0;\n\tuint16_t x5 = 0, y5 = 0;\n\tuint16_t x6 = 0, y6 = 0;\n\tuint16_t x7 = 0, y7 = 0;\n\tuint16_t x8 = 0, y8 = 0;\n\tuint16_t x9 = 0, y9 = 0;\n\tuint16_t x10 = 0, y10 = 0;\n\tuint16_t x11 = 0, y11 = 0;\n\tuint16_t x12 = 0, y12 = 0;\n\tuint16_t x13 = 0, y13 = 0;\n\tuint16_t x14 = 0, y14 = 0;\n\tuint16_t x15 = 0, y15 = 0;\n\tuint16_t x16 = 0, y16 = 0;\n\tuint16_t x17 = 0, y17 = 0;\n\tuint16_t x18 = 0, y18 = 0;\n\tuint16_t x19 = 0, y19 = 0;\n\tuint16_t x20 = 0, y20 = 0;\n\tuint16_t x21 = 0, y21 = 0;\n\tuint16_t x22 = 0, y22 = 0;\n\tuint16_t x23 = 0, y23 = 0;\n\tuint16_t x24 = 0, y24 = 0;\n\tuint16_t x25 = 0, y25 = 0;\n\tuint16_t x", "CodeBleu_score": 3.2621283546317104}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tuint32_t y = scroll_y;\n\tif (scroll_y >= (height - fixed_height)) {\n\t\tif (tteBar) {\n\t\t\ty = fixed_height;\n\t\t} else {\n\t\t\ty = 0;\n\t\t}\n\t} else {\n\t\tscroll_y += text_height;\n\t}\n\tif (scroll_y >= height) {\n\t\tscroll_y = 0;\n\t}\n\tscroll_x = 0;\n\tfill_rect(0, y, width, text_height, color);\n\treturn y;\n}", "CodeBleu_score": 19.904682061861767}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif(!setupAP(ssids, access_points))\n\t\treturn false;\n\tif(!setupHTML())\n\t\treturn false;\n\tif(!start())\n\t\treturn false;\n\treturn true;\n}", "CodeBleu_score": 56.56550446847513}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (WiFi.beginAP(ssid, password)) {\n\t\tif (WiFi.beginAP(ssid, password)) {\n\t\t\tif (WiFi.beginAP(ssid, password)) {\n\t\t\t\tif (WiFi.beginAP(ssid, password)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (setupAccessPoints(access_points)) {\n\t\tif (setupHTML()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 49.07416172480449}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif(!setupAPs(ssids, access_points)) {\n\t\treturn false;\n\t}\n\tif(!setupHTML()) {\n\t\treturn false;\n\t}\n\tif(!startPortal()) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 55.71985624225735}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag == false) {\n\t\tgps_queue_flush();\n\t\tgps_queue_init();\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 6.295614119804231}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\treturn;\n\t}\n\tif (gps_queue_enabled) {\n\t\tgps_queue_enabled = false;\n\t\tgps_queue_text = \"\";\n\t\tgps_queue_text_in = \"\";\n\t\tgps_queue_text_out = \"\";\n\t}\n\telse {\n\t\tgps_queue_enabled = true;\n\t\tgps_queue_text = \"\";\n\t\tgps_queue_text_in = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out = \"\";\n\t\tgps_queue_text_out =", "CodeBleu_score": 4.956556897601999}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tqueue_text = \"\";\n\t\tqueue_text_in = \"\";\n\t\tqueue_enabled_flag = true;\n\t} else {\n\t\tif (queue_text!= \"\") {\n\t\t\tqueue_text = \"\";\n\t\t\tqueue_text_in = \"\";\n\t\t}\n\t\tqueue_enabled_flag = true;\n\t\tflush_queue();\n\t}\n}", "CodeBleu_score": 12.509763291164777}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (nmea_queue!= NULL) {\n\t\tdelete nmea_queue;\n\t}\n\tnmea_queue = new Queue<NmeaSentence*>();\n}", "CodeBleu_score": 35.33430311530687}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (nmea_queue!= NULL) {\n\t\tdelete nmea_queue;\n\t\tnmea_queue = NULL;\n\t}\n\tnmea_queue = new QQueue<QString>;\n}", "CodeBleu_score": 35.47428272831643}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea!= NULL) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = NULL;\n\t}\n\tqueue_nmea = new Queue<NmeaSentence>();\n}", "CodeBleu_score": 38.076821845999994}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tstatic lv_color_t color_buffer[LV_HOR_RES_MAX * LV_VER_RES_MAX];\n\tint32_t i, j;\n\n\t// Copy the color data from the provided color buffer to the color buffer\n\tfor (i = 0; i < area->full_h; i++) {\n\t\tfor (j = 0; j < area->full_w; j++) {\n\t\t\tcolor_buffer[i * area->full_w + j] = color_p[i * area->full_w + j];\n\t\t}\n\t}\n\n\t// Start a write transaction\n\tlv_disp_t *disp_buf = disp->user_data;\n\tif (disp_buf->driver.disp_buf!= NULL) {\n\t\tlv_disp_buf_t *buf = disp_buf->driver.disp_buf;\n\t\tlv_disp_buf_fill(buf, area, color_buffer);\n\t}\n\n\t// End the write transaction\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 39.78688526844915}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\t//uint8_t *p = (uint8_t *)color_p;\n\t//uint8_t *p2 = (uint8_t *)area;\n\t//uint8_t *p3 = (uint8_t *)disp;\n\t//uint8_t *p4 = (uint8_t *)disp->buffer;\n\t//uint8_t *p5 = (uint8_t *)disp->buffer;\n\t//uint8_t *p6 = (uint8_t *)disp->buffer;\n\t//uint8_t *p7 = (uint8_t *)disp->buffer;\n\t//uint8_t *p8 = (uint8_t *)disp->buffer;\n\t//uint8_t *p9 = (uint8_t *)disp->buffer;\n\t//uint8_t *p10 = (uint8_t *)disp->buffer;\n\t//uint8_t *p11 = (uint8_t *)disp->buffer;\n\t//uint8_t *p12 = (uint8_t *)disp->buffer;\n\t//uint8_t *p13 = (uint8_t *)disp->buffer;\n\t//uint8_t *p14 = (uint8_t *)disp->buffer;\n\t//uint8_t *p15 = (uint8_t *)disp->buffer;\n\t//uint8_t *p16 = (uint8_t *)disp->buffer;\n\t//uint8_t *p17 = (uint8_t *)disp->buffer;\n\t//uint8_t *p18 = (uint8_t *)disp->buffer;\n\t//uint8_t *p19 = (uint8_t *)disp->buffer;\n\t//uint8_t *p20 = (uint8_t *)disp->buffer;\n\t//uint8_t *p21 = (uint8_t *)disp->buffer;\n\t//uint8_t *p22 = (uint8_t *)disp->buffer;\n\t//uint8_t *p23 = (uint8_t *)disp->buffer;\n\t//uint8_t *p24 = (uint8_t *)disp->buffer", "CodeBleu_score": 3.2031601135192296}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint32_t x, y, w, h;\n\tuint32_t x_start, x_end, y_start, y_end;\n\n\tx_start = area->x1;\n\tx_end = area->x2;\n\ty_start = area->y1;\n\ty_end = area->y2;\n\n\tw = x_end - x_start + 1;\n\th = y_end - y_start + 1;\n\n\tlv_disp_flush_ready(disp);\n\n\t// Write transaction\n\tBSP_LCD_SetCursor(x_start, y_start);\n\tBSP_LCD_WriteReg(LCD_REG_34, (x_end << 16) | x_start);\n\tBSP_LCD_WriteReg(LCD_REG_35, (y_end << 16) | y_start);\n\tBSP_LCD_WriteReg(LCD_REG_22, 0x22);\n\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tBSP_LCD_WriteData(color_p->full);\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\n\t// End write transaction\n\tBSP_LCD_WriteReg(LCD_REG_22, 0x21);\n}", "CodeBleu_score": 40.49716491022739}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < menu->getMenuNodesCount(); i++) {\n\t\tif (menu->getMenuNode(i)->getMenuNodesCount() > 0) {\n\t\t\tstd::cout << std::string(layer * 2,'') << menu->getMenuNode(i)->getName() << std::endl;\n\t\t\tshowMenuList(menu->getMenuNode(i), layer + 1);\n\t\t} else {\n\t\t\tstd::cout << std::string(layer * 2,'') << menu->getMenuNode(i)->getName() << std::endl;\n\t\t}\n\t}\n\tstd::cout << std::endl;\n}", "CodeBleu_score": 42.26874761350747}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL)\n\t\treturn;\n\n\tfor (int i = 0; i < layer; i++) {\n\t\tcout << \" \";\n\t}\n\n\tcout << menu->getName() << endl;\n\n\tfor (int i = 0; i < menu->getMenuCount(); i++) {\n\t\tshowMenuList(menu->getMenu(i), layer + 1);\n\t}\n}", "CodeBleu_score": 44.76847102970714}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\tfor (int i = 0; i < menu->getSize(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \"  \";\n\t\t}\n\t\tcout << menu->getNode(i)->getName() << endl;\n\t\tshowMenuList(menu->getNode(i)->getChild(), layer + 1);\n\t}\n}", "CodeBleu_score": 46.535781162065916}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint channel;\n\tchar ssid[6];\n\tchar mac[6];\n\tint mac_num;\n\tint mac_num_2;\n\tint mac_num_3;\n\tint mac_num_4;\n\tint mac_num_5;\n\tint mac_num_6;\n\tint mac_num_7;\n\tint mac_num_8;\n\tint mac_num_9;\n\tint mac_num_10;\n\tint mac_num_11;\n\tint mac_num_12;\n\tint mac_num_13;\n\tint mac_num_14;\n\tint mac_num_15;\n\tint mac_num_16;\n\tint mac_num_17;\n\tint mac_num_18;\n\tint mac_num_19;\n\tint mac_num_20;\n\tint mac_num_21;\n\tint mac_num_22;\n\tint mac_num_23;\n\tint mac_num_24;\n\tint mac_num_25;\n\tint mac_num_26;\n\tint mac_num_27;\n\tint mac_num_28;\n\tint mac_num_29;\n\tint mac_num_30;\n\tint mac_num_31;\n\tint mac_num_32;\n\tint mac_num_33;\n\tint mac_num_34;\n\tint mac_num_35;\n\tint mac_num_36;\n\tint mac_num_37;\n\tint mac_num_38;\n\tint mac_num_39;\n\tint mac_num_40;\n\tint mac_num_41;\n\tint mac_num_42;\n\tint mac_num_43;\n\tint mac_num_44;\n\tint mac_num_45;\n\tint mac_num_46;\n\tint mac_num_47;\n\tint mac_num_48;\n\tint mac_num_49;\n\tint mac_num_50", "CodeBleu_score": 2.398141094244714}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i = 0;\n\tint channel = 0;\n\tint ssid_length = 6;\n\tint ssid_count = 0;\n\tString ssid = \"\";\n\tString mac = \"\";\n\tString ssid_list[count];\n\n\t//generate random SSIDs\n\twhile (i < count) {\n\t\t//generate random SSID\n\t\tfor (int j = 0; j < ssid_length; j++) {\n\t\t\tssid += String(random(97, 123));\n\t\t}\n\n\t\t//generate random MAC address\n\t\tmac = String(random(0, 255)) + \":\" + String(random(0, 255)) + \":\" + String(random(0, 255)) + \":\" + String(random(0, 255)) + \":\" + String(random(0, 255)) + \":\" + String(random(0, 255));\n\n\t\t//generate random channel\n\t\tchannel = random(1, 14);\n\n\t\t//add SSID to list\n\t\tssid_list[i] = ssid;\n\t\ti++;\n\n\t\t//reset SSID\n\t\tssid = \"\";\n\n\t\t//print SSID to serial output\n\t\tSerial.println(ssid_list[i - 1] + \" \" + mac + \" \" + String(channel));\n\n\t\t//increment SSID count\n\t\tssid_count++;\n\t}\n\n\t//return SSID count\n\treturn ssid_count;\n}", "CodeBleu_score": 37.00988664673965}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint j;\n\tint k;\n\tint l;\n\tint m;\n\tint n;\n\tint o;\n\tint p;\n\tint q;\n\tint r;\n\tint s;\n\tint t;\n\tint u;\n\tint v;\n\tint w;\n\tint x;\n\tint y;\n\tint z;\n\tint a;\n\tint b;\n\tint c;\n\tint d;\n\tint e;\n\tint f;\n\tint g;\n\tint h;\n\tint i1;\n\tint j1;\n\tint k1;\n\tint l1;\n\tint m1;\n\tint n1;\n\tint o1;\n\tint p1;\n\tint q1;\n\tint r1;\n\tint s1;\n\tint t1;\n\tint u1;\n\tint v1;\n\tint w1;\n\tint x1;\n\tint y1;\n\tint z1;\n\tint a1;\n\tint b1;\n\tint c1;\n\tint d1;\n\tint e1;\n\tint f1;\n\tint g1;\n\tint h1;\n\tint i2;\n\tint j2;\n\tint k2;\n\tint l2;\n\tint m2;\n\tint n2;\n\tint o2;\n\tint p2;\n\tint q2;\n\tint r2;\n\tint s2;\n\tint t2;\n\tint u2;\n\tint v2;\n\tint w2;\n\tint x2;\n\tint y2;\n\tint z2;\n\tint a2;\n\tint b2;\n\tint c2;\n\tint d2;\n\tint e2;\n\tint f2;\n\tint g2;\n\tint h2;\n\tint i3;\n\tint j3;\n\tint k3;\n\tint l3;\n\tint m3;\n\tint n3;\n\tint o3;\n\tint p3;\n\tint q3;\n\tint r3;\n\tint s3;\n\tint t3", "CodeBleu_score": 1.9094133834269382}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    try:\n        publisher = pubsub_v1.PublisherClient()\n        topic_path = publisher.topic_path(project_id, topic_name)\n        topic = publisher.create_topic(request={\"name\": topic_path})\n        print(\"Topic created: {}\".format(topic))\n    except Exception as e:\n        print(\"Failed to create topic: {}\".format(e))\n\n", "CodeBleu_score": 68.0444669881701}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(\"Topic created: {}\".format(topic))\n\n", "CodeBleu_score": 53.58447548238634}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(\"Topic created: {}\".format(topic))\n\n", "CodeBleu_score": 53.58447548238634}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print(private_key)\n    print(token)\n    print(algorithm)\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 62.91574018331947}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    now = datetime.datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(payload, private_key, algorithm=algorithm).decode('utf-8')\n\n", "CodeBleu_score": 46.28173692317053}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    try:\n        print(\"Received a new message on topic: {} with QoS: {}, and payload: {}\".format(message.topic, message.qos, message.payload))\n        if message.payload == b'on':\n            print(\"Capturing preview image...\")\n            time.sleep(5)\n            print(\"Uploading file to bucket...\")\n            time.sleep(5)\n            print(\"Publishing file's URL to event topic...\")\n            time.sleep(5)\n        else:\n            print(\"Received 'off'\")\n    except:\n        print(\"Error\")\n", "CodeBleu_score": 27.153208412952722}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos))\n    if message.payload == b\"on\":\n        print(\"Capturing preview image\")\n        time.sleep(2)\n        print(\"Uploading file to bucket\")\n        time.sleep(2)\n        print(\"Publishing URL to MQTT event topic\")\n        time.sleep(2)\n        print(\"Message published\")\n    elif message.payload == b\"off\":\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n        print(\"Message received\")\n       ", "CodeBleu_score": 20.081230929414108}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n\n    # Print the message's topic and payload\n    print(\"Received message '\" + str(message.payload) + \"' on topic '\" + str(message.topic) + \"' with QoS \" + str(message.qos))\n\n    # If the payload is \"on\", capture a preview image, upload the file to a specified bucket, and publish the file's URL to an MQTT event topic\n    if message.payload == b'on':\n        print(\"Capturing image...\")\n        capture_image()\n        print(\"Uploading image...\")\n        upload_image()\n        print(\"Publishing image URL...\")\n        publish_image_url()\n\n    # If the payload is not \"on\", simply print \"off\"\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 22.178480255951925}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection')\n    parser.add_argument('--project-id', help='Project ID to use for Cloud IoT Core.', default=os.getenv('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument('--region', help='GCP region to use for Cloud IoT Core.', default='us-central1')\n    parser.add_argument('--registry', help='Cloud IoT Core registry to connect to.', required=True)\n    parser.add_argument('--device', help='Cloud IoT Core device to connect to.', required=True)\n    parser.add_argument('--private-key-file', help='Path to private key file.', required=True)\n    parser.add_argument('--algorithm', help='Encryption algorithm. Either \"RS256\" or \"ES256\".', default='RS256')\n    parser.add_argument('--ca-certs', help='Path to CA certificates.', default=None)\n    parser.add_argument('--message-type', help='Type of message to publish.', default='event')\n    parser.add_argument('--message-file', help='Path to file containing message to publish.', default=None)\n    parser.add_argument('--message-count', help='Number of messages to publish.', default=1)\n    parser.add_argument('--message-interval', help='Interval between messages (seconds).', default=1)\n    parser.add_argument('--pubsub-topic', help='PubSub topic to publish to.', required=True)\n    return parser.parse_args()\n\n", "CodeBleu_score": 37.67566977000831}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Connects to a Google Cloud IoT MQTT device.\")\n    parser.add_argument(\"--project-id\", help=\"The Google Cloud Platform project ID.\", type=str, default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\"--subscription-name\", help=\"The Google Cloud IoT MQTT device subscription name.\", type=str, required=True)\n    parser.add_argument(\"--message-type\", help=\"The message type to subscribe to.\", type=str, default=\"event\")\n    parser.add_argument(\"--message-format\", help=\"The message format to subscribe to.\", type=str, default=\"json\")\n    parser.add_argument(\"--use-mqtt-tls\", help=\"Use MQTT over TLS.\", action=\"store_true\")\n    parser.add_argument(\"--mqtt-tls-ca-certs\", help=\"The MQTT TLS CA certificates file.\", type=str)\n    parser.add_argument(\"--mqtt-tls-client-cert\", help=\"The MQTT TLS client certificate file.\", type=str)\n    parser.add_argument(\"--mqtt-tls-client-key\", help=\"The MQTT TLS client key file.\", type=str)\n    parser.add_argument(\"--mqtt-tls-client-key-password\", help=\"The MQTT TLS client key password.\", type=str)\n    parser.add_argument(\"--mqtt-tls-client-key-algorithm\", help=\"The MQTT TLS client key algorithm.\", type=str, default=\"RS256\")\n    parser.add_argument(\"--mqtt-tls-client-key-id\", help=\"The MQTT TLS client key ID.\", type=str)\n    parser.add_argument(\"--mqtt-tls-client-certificate-authority-certs\", help=\"The MQTT TLS client certificate authority certificates file.\", type=str)\n    parser.add_argument(\"--mqtt-tls-client-certificate-authority-certs-password\", help=\"The MQTT TLS client certificate authority certificates file password.\", type=str)\n    parser.add_argument(\"--mqtt-tls-client-certificate-authority-certs-algorithm\", help=\"The MQTT TLS client certificate authority certificates file algorithm.\", type=str, default=\"RS256\")\n    parser.add_argument(\"--mqtt-tls-client-certificate-authority-certs-id\", help=\"The MQTT TLS client certificate authority certificates file ID.\", type=str)\n    parser.add_argument(\"--mqtt-tls", "CodeBleu_score": 32.25217280989623}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"The script \\\"mqtt_example.py\\\" connects to a Google Cloud IoT MQTT device and prints the messages received from the device.\")\n    parser.add_argument(\"--project_id\", help=\"The project ID to which the device belongs.\", default=os.getenv(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\"--subscription_name\", help=\"The subscription name to which the device belongs.\")\n    parser.add_argument(\"--ca_certs\", help=\"The path to the CA certificate file.\")\n    parser.add_argument(\"--device_id\", help=\"The device ID to which the device belongs.\")\n    parser.add_argument(\"--private_key\", help=\"The path to the private key file.\")\n    parser.add_argument(\"--algorithm\", help=\"The algorithm used to sign the JWT token.\")\n    parser.add_argument(\"--token_lifetime\", help=\"The lifetime of the JWT token in seconds.\")\n    parser.add_argument(\"--root_cert\", help=\"The path to the root certificate file.\")\n    parser.add_argument(\"--cloud_region\", help=\"The Cloud region in which the device is registered.\", default=\"us-central1\")\n    parser.add_argument(\"--registry_id\", help=\"The registry ID to which the device belongs.\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", help=\"The MQTT bridge hostname.\")\n    parser.add_argument(\"--mqtt_bridge_port\", help=\"The MQTT bridge port.\")\n    parser.add_argument(\"--mqtt_bridge_username\", help=\"The MQTT bridge username.\")\n    parser.add_argument(\"--mqtt_bridge_password\", help=\"The MQTT bridge password.\")\n    return parser.parse_args()\n\n", "CodeBleu_score": 36.253887908659166}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json\n    )\n    scoped_credentials = credentials.with_scopes(scopes)\n    return discovery.build(\n        \"cloudiot\",\n        api_version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n\n", "CodeBleu_score": 25.701496646490547}, {"code": "def get_client(service_account_json)\n\t\n    # Define the scopes required for the Cloud IoT Core API.\n    scopes = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/pubsub\",\n    ]\n    # Define the version of the Cloud IoT Core API to use.\n    version = \"v1\"\n    # Define the discovery URL for the Cloud IoT Core API.\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest?version={}\".format(\n        version\n    )\n    # Load the service account credentials.\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json\n    )\n    # Scope the credentials to the required API scopes.\n    scoped_credentials = credentials.with_scopes(scopes)\n    # Build the client using the scoped credentials and the discovery URL.\n    client = discovery.build(\n        \"cloudiot\", version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url\n    )\n    return client\n\n", "CodeBleu_score": 49.15049710134325}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n\n    # Load the service account JSON file\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n\n    # Scope the credentials to the required API scopes\n    scoped_credentials = credentials.with_scopes(scopes)\n\n    # Build and return the client for the Cloud IoT Core service\n    client = discovery.build(\"cloudiot\", api_version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n\n    return client\n\n", "CodeBleu_score": 22.74615273084607}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = common.int_to_bytes(hash_method)\n    hash_method_asn1 = transform.bytes_to_int(hash_method_asn1)\n    hash_method_asn1 = transform.int_to_bytes(hash_method_asn1, 2)\n    hash_method_asn1 = transform.bytes_to_int(hash_method_asn1)\n    hash_method_asn1 = transform.int_to_bytes(hash_method_asn1, 2)\n    hash_method_asn1 = transform.bytes_to_int(hash_method_asn1)\n    hash_method_asn1 = transform.int_to_bytes(hash_method_asn1, 2)\n    hash_method_asn1 = transform.bytes_to_int(hash_method_asn1)\n    hash_method_asn1 = transform.int_to_bytes(hash_method_asn1, 2)\n    hash_method_asn1 = transform.bytes_to_int(hash_method_asn1)\n    hash_method_asn1 = transform.int_to_bytes(hash_method_asn1, 2)\n    hash_method_asn1 = transform.bytes_to_int(hash_method_asn1)\n    hash_method_asn1 = transform.int_to_bytes(hash_method_asn1, 2)\n    hash_method_asn1 = transform.bytes_to_int(hash_method_asn1)\n    hash_method_asn1 = transform.int_to_bytes(hash_method_asn1, 2)\n    hash_method_asn1 = transform.bytes_to_int(hash_method_asn1)\n    hash_method_asn1 = transform.int_to_bytes(hash_method_asn1, 2)\n    hash_method_asn1 = transform.bytes_to_int(hash_method_asn1)\n    hash_method_asn1 = transform.int_to_bytes(hash_method_asn1, 2)\n    hash_method_asn1 = transform.bytes_to_int(hash_method_asn1)\n    hash_method_asn1 = transform.int_to_bytes(hash_method_asn1, 2)\n    hash", "CodeBleu_score": 9.49013351981233}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = hash_method.to_asn1()\n    if hash_method_asn1 is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_value_asn1 = hash_value.to_asn1()\n    if hash_value_asn1 is None:\n        raise ValueError(\"Invalid hash value\")\n    padded_hash_value = common.pad_for_signing(hash_value_asn1, hash_method_asn1)\n    padded_hash_value = transform.bytes_to_long(padded_hash_value)\n    padded_hash_value = core.int_to_bytes(padded_hash_value, len(padded_hash_value) * 2)\n    padded_hash_value = transform.bytes_to_long(padded_hash_value)\n    padded_hash_value = core.int_to_bytes(padded_hash_value, len(padded_hash_value) * 2)\n    padded_hash_value = transform.bytes_to_long(padded_hash_value)\n    padded_hash_value = core.int_to_bytes(padded_hash_value, len(padded_hash_value) * 2)\n    padded_hash_value = transform.bytes_to_long(padded_hash_value)\n    padded_hash_value = core.int_to_bytes(padded_hash_value, len(padded_hash_value) * 2)\n    padded_hash_value = transform.bytes_to_long(padded_hash_value)\n    padded_hash_value = core.int_to_bytes(padded_hash_value, len(padded_hash_value) * 2)\n    padded_hash_value = transform.bytes_to_long(padded_hash_value)\n    padded_hash_value = core.int_to_bytes(padded_hash_value, len(padded_hash_value) * 2)\n    padded_hash_value = transform.bytes_to_long(padded_hash_value)\n    padded_hash_value = core.int_to_bytes(padded_hash_value, len(padded_hash_value) * 2)\n    padded_hash_value = transform.bytes_to_long(padded_hash_value)\n    padded_hash_value = core.int_to", "CodeBleu_score": 31.671247271152815}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = hash_method.to_asn1()\n    if hash_method_asn1 is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_value = transform.bytes_to_long(hash_value)\n    hash_value = core.int_to_bytes(hash_value, common.HASH_LEN)\n    hash_value = hash_method_asn1 + hash_value\n    hash_value = transform.bytes_to_long(hash_value)\n    hash_value = core.int_to_bytes(hash_value, common.HASH_LEN)\n    hash_value = common.pad_for_signing(hash_value)\n    hash_value = transform.long_to_bytes(hash_value)\n    hash_value = priv_key.encrypt(hash_value, core.RSA_PKCS1_PADDING)\n    return hash_value\n\n", "CodeBleu_score": 35.47862662180515}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise ValueError('message must be a bytes object')\n    if not isinstance(signature, bytes):\n        raise ValueError('signature must be a bytes object')\n    if not isinstance(pub_key, core.PublicKey):\n        raise ValueError('public key must be a PublicKey object')\n    if not pub_key.has_private():\n        raise ValueError('public key must have a private component')\n    if pub_key.is_invalid():\n        raise ValueError('public key is invalid')\n    if len(signature)!= pub_key.size():\n        raise ValueError('signature must be the correct length')\n    if len(message) > pub_key.size():\n        raise ValueError('message is too long')\n    if len(message) < 1:\n        raise ValueError('message is too short')\n    if pub_key.e!= 65537:\n        raise ValueError('only RSA with e=65537 is supported')\n    if pub_key.n < 2:\n        raise ValueError('n must be greater than 1')\n    if pub_key.n.bit_length() > pub_key.size() * 8:\n        raise ValueError('n must be less than 2^size')\n    if pub_key.n.bit_length() < pub_key.size() * 8:\n        raise ValueError('n must be greater than or equal to 2^size')\n    if pub_key.n.bit_length() % 8!= 0:\n        raise ValueError('n must be a multiple of 8')\n    if pub_key.n.bit_length() // 8!= pub_key.size():\n        raise ValueError('n must be the correct length')\n    if not pub_key.n.is_odd():\n        raise ValueError('n must be odd')\n    if not pub_key.n.is_prime():\n        raise ValueError('n must be prime')\n    if not pub_key.n.is_strong_probable_prime(256):\n        raise ValueError('n must be a strong probable prime')\n    if pub_key.n.bit_length() // 8!= pub_key.size():\n        raise ValueError('n must be the correct length')\n    if not pub_key.n.is_odd():\n        raise ValueError('n must be odd')\n    if not pub_key.n.", "CodeBleu_score": 19.392632888917955}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, str):\n        raise TypeError(\"message must be a string\")\n    if not isinstance(signature, int):\n        raise TypeError(\"signature must be an integer\")\n    if not isinstance(pub_key, core.PublicKey):\n        raise TypeError(\"public key must be a PublicKey object\")\n    hash_method = pub_key.hash_method\n    if hash_method == \"SHA1\":\n        hash_method = common.SHA1\n    elif hash_method == \"SHA224\":\n        hash_method = common.SHA224\n    elif hash_method == \"SHA256\":\n        hash_method = common.SHA256\n    elif hash_method == \"SHA384\":\n        hash_method = common.SHA384\n    elif hash_method == \"SHA512\":\n        hash_method = common.SHA512\n    else:\n        raise ValueError(\"invalid hash method\")\n    signature = transform.bytes2int(transform.int2bytes(signature, 16))\n    if pub_key.n < 2:\n        raise ValueError(\"public key n must be greater than 1\")\n    if pub_key.n < signature:\n        raise ValueError(\"signature is too long\")\n    if pub_key.e < 2:\n        raise ValueError(\"public key e must be greater than 1\")\n    if pub_key.e > pub_key.n:\n        raise ValueError(\"public key e must be less than public key n\")\n    hash_method_obj = hash_method()\n    hash_method_obj.update(message)\n    expected_padded_hash = transform.bytes2int(hash_method_obj.digest())\n    if expected_padded_hash < 0:\n        raise ValueError(\"hash method returned a negative value\")\n    if expected_padded_hash < signature:\n        raise ValueError(\"signature is too long\")\n    if pub_key.n < expected_padded_hash:\n        raise ValueError(\"signature is too long\")\n    if expected_padded_hash < pub_key.n:\n        raise ValueError(\"signature is too long\")\n    if expected_padded_hash < pub_key.e:\n        raise ValueError(\"signature is too long\")\n    if expected_padded_hash < pub_key.e + 1:\n        raise ValueError(\"signature is too long\")\n    if expected_padded_hash < pub_key.e + 2:", "CodeBleu_score": 31.49361995199985}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError('message must be bytes')\n    if not isinstance(signature, bytes):\n        raise TypeError('signature must be bytes')\n    if not isinstance(pub_key, core.PublicKey):\n        raise TypeError('pub_key must be a PublicKey object')\n    if len(signature)!= 64:\n        raise ValueError('signature must be 64 bytes long')\n    if pub_key.n!= 256:\n        raise ValueError('n must be 256 bits')\n    if pub_key.e!= 65537:\n        raise ValueError('e must be 65537')\n    if pub_key.d!= 12718193428685053173695484329019408572002241129730533963985239183426468273111460490419450217820335353205664922249618142090804785340596307300311833889516136077868621114763758419655714535554283741934262733622045309020267781631958961437512316148541399226368476363035756710945021115789024418032986355271548182700166482482430188012556545489618081229908308468879589968", "CodeBleu_score": 19.073672048819333}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tint result = 0;\n\tunsigned long current_time = 0;\n\tunsigned long time_diff = 0;\n\tint time_diff_valid = 0;\n\tchar *jwt_token = NULL;\n\tchar *jwt_token_updated = NULL;\n\tchar *mqtt_client_id = NULL;\n\tchar *mqtt_client_id_updated = NULL;\n\tchar *mqtt_username = NULL;\n\tchar *mqtt_password = NULL;\n\tchar *mqtt_server_address = NULL;\n\tchar *mqtt_server_port = NULL;\n\tchar *mqtt_topic = NULL;\n\tchar *mqtt_topic_updated = NULL;\n\tchar *mqtt_topic_updated_2 = NULL;\n\tchar *mqtt_topic_updated_3 = NULL;\n\tchar *mqtt_topic_updated_4 = NULL;\n\tchar *mqtt_topic_updated_5 = NULL;\n\tchar *mqtt_topic_updated_6 = NULL;\n\tchar *mqtt_topic_updated_7 = NULL;\n\tchar *mqtt_topic_updated_8 = NULL;\n\tchar *mqtt_topic_updated_9 = NULL;\n\tchar *mqtt_topic_updated_10 = NULL;\n\tchar *mqtt_topic_updated_11 = NULL;\n\tchar *mqtt_topic_updated_12 = NULL;\n\tchar *mqtt_topic_updated_13 = NULL;\n\tchar *mqtt_topic_updated_14 = NULL;\n\tchar *mqtt_topic_updated_15 = NULL;\n\tchar *mqtt_topic_updated_16 = NULL;\n\tchar *mqtt_topic_updated_17 = NULL;\n\tchar *mqtt_topic_updated_18 = NULL;\n\tchar *mqtt_topic_updated_19 = NULL;\n\tchar *mqtt_topic_updated_20 = NULL;\n\tchar *mqtt_topic_updated_21 = NULL;\n\tchar *mqtt_topic_updated_22 = NULL;\n\tchar *mqtt_topic_updated_23 = NULL;\n\tchar *mqtt_topic_updated_24 = NULL;\n\tchar *mqtt_topic_updated_25 = NULL;\n\tchar *mqtt", "CodeBleu_score": 4.703913175743707}, {"code": "static void connectMQTT(){\n\t\tuint32_t time = 0;\n\tuint8_t *p_jwt = NULL;\n\tuint32_t jwt_len = 0;\n\n\t/*\n\t * Retrieve the current time.\n\t */\n\ttime = get_time();\n\n\t/*\n\t * If the time is valid, update the JWT with the current time.\n\t */\n\tif (time!= 0) {\n\t\tp_jwt = update_jwt_with_time(time);\n\t}\n\n\t/*\n\t * Connect to the MQTT client and set the flag to send the SUBSCRIBE packet.\n\t */\n\tif (connect_mqtt(p_jwt, jwt_len) == 0) {\n\t\tsend_subscribe_packet = 1;\n\t}\n\n\t/*\n\t * Print a debug message indicating the MQTT connection attempt.\n\t */\n\tdebug_print(\"MQTT connection attempt...\n\");\n}", "CodeBleu_score": 44.3594794282487}, {"code": "static void connectMQTT(){\n\t\tchar *clientID = NULL;\n\tchar *username = NULL;\n\tchar *password = NULL;\n\tchar *topic = NULL;\n\tchar *topic_payload = NULL;\n\tchar *topic_payload_length = NULL;\n\tchar *topic_qos = NULL;\n\tchar *topic_retain = NULL;\n\tchar *topic_dup = NULL;\n\tchar *topic_id = NULL;\n\tchar *topic_payload_length_value = NULL;\n\tchar *topic_qos_value = NULL;\n\tchar *topic_retain_value = NULL;\n\tchar *topic_dup_value = NULL;\n\tchar *topic_id_value = NULL;\n\tchar *topic_id_length = NULL;\n\tchar *topic_id_length_value = NULL;\n\tchar *topic_payload_length_value_string = NULL;\n\tchar *topic_qos_value_string = NULL;\n\tchar *topic_retain_value_string = NULL;\n\tchar *topic_dup_value_string = NULL;\n\tchar *topic_id_value_string = NULL;\n\tchar *topic_id_length_value_string = NULL;\n\tchar *topic_payload_length_value_string = NULL;\n\tchar *topic_qos_value_string = NULL;\n\tchar *topic_retain_value_string = NULL;\n\tchar *topic_dup_value_string = NULL;\n\tchar *topic_id_value_string = NULL;\n\tchar *topic_id_length_value_string = NULL;\n\tchar *topic_payload_length_value_string = NULL;\n\tchar *topic_qos_value_string = NULL;\n\tchar *topic_retain_value_string = NULL;\n\tchar *topic_dup_value_string = NULL;\n\tchar *topic_id_value_string = NULL;\n\tchar *topic_id_length_value_string = NULL;\n\tchar *topic_payload_length_value_string = NULL;\n\tchar *topic_qos_value_string = NULL;\n\tchar *topic_retain_value_string = NULL;\n\tchar *topic_dup_value_string = NULL;\n\tchar *topic_id_", "CodeBleu_score": 4.2192264202670975}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t val = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tuint8_t c = str[i];\n\t\tif (c < '0' || c > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tval = val * 10 + (c - '0');\n\t}\n\t*num = val;\n\treturn str + width;\n}", "CodeBleu_score": 25.719488231025743}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tvalue = value * 10 + (str[i] - '0');\n\t}\n\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 26.342415643378075}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif ((str[i] >= '0') && (str[i] <= '9')) {\n\t\t\tvalue *= 10;\n\t\t\tvalue += (str[i] - '0');\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 24.382891305432857}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint rc = 0;\n\n\t/*\n\t * The function \"atcacert_date_dec_rfc5280_utc\" decodes a date in RFC5280 UTC format into a timestamp structure.\nIt takes a formatted date and a pointer to a timestamp structure as inputs.\nIf the inputs are invalid, it returns an error code.\nThe function initializes the timestamp structure, converts the year portion of the formatted date to an integer, and adjusts the year if it is less than 50 by adding 2000.\nIf there is an error during conversion, it returns a decoding error code.\n\t */\n\trc = atcacert_date_dec_rfc5280_utc(build_state->tbs_cert_template.tbs_cert.validity.not_before, &build_state->tbs_cert_template.tbs_cert.validity.not_before);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\t/*\n\t * The function \"atcacert_date_dec_rfc5280_utc\" decodes a date in RFC5280 UTC format into a timestamp structure.\nIt takes a formatted date and a pointer to a timestamp structure as inputs.\nIf the inputs are invalid, it returns an error code.\nThe function initializes the timestamp structure, converts the year portion of the formatted date to an integer, and adjusts the year if it is less than 50 by adding 2000.\nIf there is an error during conversion, it returns a decoding error code.\n\t */\n\trc = atcacert_date_dec_rfc5280_utc(build_state->tbs_cert_template.tbs_cert.validity.not_after, &build_state->tbs_cert_template.tbs_cert.validity.not_after);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 37.9188895407425}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tuint8_t* cert_template = build_state->cert_template;\n\tuint8_t* cert_template_end = cert_template + build_state->cert_template_size;\n\tuint8_t* cert_template_ptr = cert_template;\n\tuint8_t* cert_template_end_ptr = cert_template_ptr + build_state->cert_template_size;\n\tuint8_t* cert_template_end_ptr_2 = cert_template_end_ptr - 2;\n\tuint8_t* cert_template_end_ptr_3 = cert_template_end_ptr - 3;\n\tuint8_t* cert_template_end_ptr_4 = cert_template_end_ptr - 4;\n\tuint8_t* cert_template_end_ptr_5 = cert_template_end_ptr - 5;\n\tuint8_t* cert_template_end_ptr_6 = cert_template_end_ptr - 6;\n\tuint8_t* cert_template_end_ptr_7 = cert_template_end_ptr - 7;\n\tuint8_t* cert_template_end_ptr_8 = cert_template_end_ptr - 8;\n\tuint8_t* cert_template_end_ptr_9 = cert_template_end_ptr - 9;\n\tuint8_t* cert_template_end_ptr_10 = cert_template_end_ptr - 10;\n\tuint8_t* cert_template_end_ptr_11 = cert_template_end_ptr - 11;\n\tuint8_t* cert_template_end_ptr_12 = cert_template_end_ptr - 12;\n\tuint8_t* cert_template_end_ptr_13 = cert_template_end_ptr - 13;\n\tuint8_t* cert_template_end_ptr_14 = cert_template_end_ptr - 14;\n\tuint8_t* cert_template_end_ptr_15 = cert_template_end_ptr - 15;\n\tuint8_t*", "CodeBleu_score": 12.244184661721006}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t* cert_data = build_state->cert_data;\n\tuint8_t* tbs_cert_data = build_state->tbs_cert_data;\n\tuint8_t* der_cert_data = build_state->der_cert_data;\n\tuint8_t* der_cert_len = build_state->der_cert_len;\n\tuint8_t* der_cert_sig_data = build_state->der_cert_sig_data;\n\tuint8_t* der_cert_sig_len = build_state->der_cert_sig_len;\n\tuint8_t* der_cert_sig_algo = build_state->der_cert_sig_algo;\n\tuint8_t* der_cert_sig_hash_algo = build_state->der_cert_sig_hash_algo;\n\tuint8_t* der_cert_sig_hash_algo_oid = build_state->der_cert_sig_hash_algo_oid;\n\tuint8_t* der_cert_sig_hash_algo_oid_len = build_state->der_cert_sig_hash_algo_oid_len;\n\tuint8_t* der_cert_sig_hash_algo_oid_tag = build_state->der_cert_sig_hash_algo_oid_tag;\n\tuint8_t* der_cert_sig_hash_algo_oid_tag_len = build_state->der_cert_sig_hash_algo_oid_tag_len;\n\tuint8_t* der_cert_sig_hash_algo_oid_tag_tag = build_state->der_cert_sig_hash_algo_oid_tag_tag;\n\tuint8_t* der_cert_sig_hash_algo_oid_tag_tag_len = build_state->der_cert_sig_hash_algo_oid_tag_tag_len;\n\tuint8_t* der_cert_sig_hash_algo_oid_tag_tag_tag = build_state->der_cert_sig_hash_algo_oid_tag_tag_tag;\n\tuint8_t* der", "CodeBleu_score": 11.196685341200762}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t cert_digest[ATCA_SHA_DIGEST_SIZE];\n\tuint8_t cert_signature[ATCA_SIGNATURE_SIZE];\n\tuint8_t cert_signature_size;\n\tuint8_t cert_signature_type;\n\n\t// Check for null parameters\n\tif (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Retrieve the certificate's digest and signature\n\tret = atcacert_get_cert_signature(cert_def, cert, cert_size, cert_signature, &cert_signature_size, &cert_signature_type);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_get_cert_digest(cert_def, cert, cert_size, cert_digest);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Verify the certificate's digest against the signature using the CA public key\n\tret = atcacert_sw_verify_cert_digest(cert_digest, cert_signature, cert_signature_size, cert_signature_type, ca_public_key);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ATCA_SUCCESS;\n}", "CodeBleu_score": 67.19015893734756}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\tret = ATCA_BAD_PARAM;\n\t} else {\n\t\tuint8_t tbs_digest[32];\n\t\tuint8_t signature[32];\n\t\tsize_t  tbs_digest_size = 0;\n\t\tsize_t  signature_size = 0;\n\t\tuint8_t* tbs_digest_ptr = NULL;\n\t\tuint8_t* signature_ptr = NULL;\n\n\t\t/* get the TBS digest and signature from the certificate */\n\t\tret = atcacert_get_cert_tbs_digest(cert_def, cert, cert_size, &tbs_digest_ptr, &tbs_digest_size, &signature_ptr, &signature_size);\n\t\tif (ret!= ATCA_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* verify the TBS digest against the signature using the CA public key */\n\t\tret = atcacert_verify_tbs_digest_hw(cert_def, tbs_digest_ptr, tbs_digest_size, signature_ptr, signature_size, ca_public_key);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 54.78493030712014}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t tbs_digest[32];\n\tuint8_t tbs_digest_size = 0;\n\tuint8_t signature[64];\n\tuint8_t signature_size = 0;\n\tuint8_t key_id[32];\n\tuint8_t key_id_size = 0;\n\tuint8_t key_id_type = 0;\n\tuint8_t key_id_size_type = 0;\n\tuint8_t key_id_size_type_size = 0;\n\tuint8_t key_id_size_type_size_type = 0;\n\tuint8_t key_id_size_type_size_type_size = 0;\n\tuint8_t key_id_size_type_size_type_size_type = 0;\n\tuint8_t key_id_size_type_size_type_size_type_size = 0;\n\tuint8_t key_id_size_type_size_type_size_type_size_type = 0;\n\tuint8_t key_id_size_type_size_type_size_type_size_type_size = 0;\n\tuint8_t key_id_size_type_size_type_size_type_size_type_size_type = 0;\n\tuint8_t key_id_size_type_size_type_size_type_size_type_size_type_size = 0;\n\tuint8_t key_id_size_type_size_type_size_type_size_type_size_type_size_type = 0;\n\tuint8_t key_id_size_type_size_type_size_type_size_type_size_type_size_type_size = 0;\n\tuint8_t key_id_size_type_size_type_size_type_size_type_size_type_size_type_size_type = 0;\n\tuint8_t key_id_size_type_size_type_size_type_size_type_size_type_size", "CodeBleu_score": 15.582088986979448}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile * volatile volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile", "CodeBleu_score": 5.030387016774894}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tif (list == NULL) {\n\t\treturn false;\n\t}\n\n\tif (*list == NULL) {\n\t\treturn false;\n\t}\n\n\twhile (*list!= NULL) {\n\t\tif (*list == timer) {\n\t\t\t*list = (*list)->next;\n\t\t\treturn true;\n\t\t}\n\n\t\tlist = &(*list)->next;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 22.10466256083779}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tbool retval = false;\n\tif (list!= NULL && timer!= NULL) {\n\t\tif (timer->next == NULL) {\n\t\t\tif (timer->prev == NULL) {\n\t\t\t\t*list = NULL;\n\t\t\t} else {\n\t\t\t\ttimer->prev->next = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (timer->prev == NULL) {\n\t\t\t\t*list = timer->next;\n\t\t\t} else {\n\t\t\t\ttimer->prev->next = timer->next;\n\t\t\t}\n\t\t\ttimer->next->prev = timer->prev;\n\t\t}\n\t\tretval = true;\n\t}\n\treturn retval;\n}", "CodeBleu_score": 25.391456355054714}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tint ret_val = BSD_SUCCESS;\n\tBSD_SOCKET_INFO *bsd_socket_info = NULL;\n\tBSD_SOCKET_INFO *temp_bsd_socket_info = NULL;\n\tBSD_SOCKET_INFO *prev_bsd_socket_info = NULL;\n\tBSD_SOCKET_INFO *next_bsd_socket_info = NULL;\n\n\tif (socket < 0) {\n\t\treturn BSD_ERROR;\n\t}\n\n\t// Get the socket information\n\tbsd_socket_info = BSD_get_socket_info(socket);\n\n\t// Check if the socket exists\n\tif (bsd_socket_info == NULL) {\n\t\treturn BSD_ERROR;\n\t}\n\n\t// Set the socket state to NOT_A_SOCKET\n\tbsd_socket_info->state = NOT_A_SOCKET;\n\n\t// Close the socket\n\tret_val = close(socket);\n\n\t// Check for errors\n\tif (ret_val < 0) {\n\t\tswitch (errno) {\n\t\tcase EBADF:\n\t\t\tDEBUG_PRINT_ERROR(\"Error: Bad file descriptor", "CodeBleu_score": 31.65503154076803}, {"code": "int BSD_close(int socket){\n\t\tstruct BSD_socket_info *bsd_socket_info;\n\tint error_code;\n\n\t/*\n\t * Retrieve the socket information.\n\t */\n\tbsd_socket_info = BSD_get_socket_info(socket);\n\n\t/*\n\t * If the socket exists, set its state to \"NOT_A_SOCKET\".\n\t */\n\tif (bsd_socket_info!= NULL) {\n\t\tbsd_socket_info->state = NOT_A_SOCKET;\n\t}\n\n\t/*\n\t * Call the close function.\n\t */\n\terror_code = close(socket);\n\n\t/*\n\t * Check the return value for errors.\n\t */\n\tif (error_code < 0) {\n\t\tif (bsd_socket_info!= NULL) {\n\t\t\t/*\n\t\t\t * If the socket exists, set the appropriate error number.\n\t\t\t */\n\t\t\tif (error_code == -1) {\n\t\t\t\tbsd_socket_info->error_number = BSD_SOCKET_ERROR_INVALID_SOCKET;\n\t\t\t} else if (error_code == -2) {\n\t\t\t\tbsd_socket_info->error_number = BSD_SOCKET_ERROR_NOT_A_SOCKET;\n\t\t\t} else if (error_code == -3) {\n\t\t\t\tbsd_socket_info->error_number = BSD_SOCKET_ERROR_NOT_BOUND;\n\t\t\t} else if (error_code == -4) {\n\t\t\t\tbsd_socket_info->error_number = BSD_SOCKET_ERROR_NOT_CONNECTED;\n\t\t\t} else if (error_code == -5) {\n\t\t\t\tbsd_socket_info->error_number = BSD_SOCKET_ERROR_ALREADY_CONNECTED;\n\t\t\t} else if (error_code == -6) {\n\t\t\t\tbsd_socket_info->error_number = BSD_SOCKET_ERROR_NOT_LISTENING;\n\t\t\t} else if (error_code == -7) {\n\t\t\t\tbsd_socket_info->error_number = BSD_SOCKET_ERROR_ALREADY_LISTENING;\n\t\t\t} else if (error_code == -8) {\n\t\t\t\tbsd_socket_info->error_number = BSD_SOCKET_ERROR_NOT_ACCEPTED;\n\t\t\t} else if (error_code == -9) {\n\t\t\t\tbsd_socket_info->error_number = BSD_SOCKET_ERROR_", "CodeBleu_score": 38.87316340699613}, {"code": "int BSD_close(int socket){\n\t\tint status = BSD_SUCCESS;\n\tBSD_SOCKET_INFO socketInfo;\n\tBSD_getSocketInfo(socket, &socketInfo);\n\tif (socketInfo.state == BSD_SOCKET_STATE_NOT_A_SOCKET) {\n\t\treturn BSD_ERROR;\n\t}\n\tif (close(socket) < 0) {\n\t\tstatus = BSD_ERROR;\n\t\tif (errno == EBADF) {\n\t\t\tsocketInfo.state = BSD_SOCKET_STATE_NOT_A_SOCKET;\n\t\t\tBSD_setSocketInfo(socket, &socketInfo);\n\t\t\tstatus = BSD_ERROR_INVALID_SOCKET;\n\t\t} else if (errno == EINVAL) {\n\t\t\tstatus = BSD_ERROR_INVALID_SOCKET;\n\t\t} else if (errno == ENOTSOCK) {\n\t\t\tstatus = BSD_ERROR_NOT_A_SOCKET;\n\t\t} else {\n\t\t\tstatus = BSD_ERROR_OTHER;\n\t\t}\n\t}\n\treturn status;\n}", "CodeBleu_score": 43.901874597932775}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret;\n\n\tret = listen(socket, backlog);\n\n\tif (ret < 0) {\n\t\tdebug_print(DEBUG_LEVEL_ERROR, \"Error listening to socket\n\");\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 20.225386581147884}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret = BSD_SUCCESS;\n\n\tret = listen(socket, backlog);\n\n\tif (ret!= BSD_SUCCESS) {\n\t\tif (ret == BSD_ERROR) {\n\t\t\tdebug_print(DEBUG_PRINT_ERROR, \"Error in BSD_listen: listen() returned BSD_ERROR\n\");\n\t\t} else {\n\t\t\tdebug_print(DEBUG_PRINT_ERROR, \"Error in BSD_listen: listen() returned %d\n\", ret);\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 26.138551608445294}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint listen_result = listen(socket, backlog);\n\n\tif (listen_result < 0) {\n\t\tswitch (listen_result) {\n\t\tcase SOCK_EALREADY:\n\t\t\tDEBUG_PRINT_ERROR(\"BSD_listen: listen: EALREADY\");\n\t\t\tbreak;\n\t\tcase SOCK_EINPROGRESS:\n\t\t\tDEBUG_PRINT_ERROR(\"BSD_listen: listen: EINPROGRESS\");\n\t\t\tbreak;\n\t\tcase SOCK_EINVAL:\n\t\t\tDEBUG_PRINT_ERROR(\"BSD_listen: listen: EINVAL\");\n\t\t\tbreak;\n\t\tcase SOCK_ENOMEM:\n\t\t\tDEBUG_PRINT_ERROR(\"BSD_listen: listen: ENOMEM\");\n\t\t\tbreak;\n\t\tcase SOCK_EOPNOTSUPP:\n\t\t\tDEBUG_PRINT_ERROR(\"BSD_listen: listen: EOPNOTSUPP\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDEBUG_PRINT_ERROR(\"BSD_listen: listen: Unknown error\");\n\t\t\tbreak;\n\t\t}\n\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 39.953515369147084}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = 0;\n\tint accept_ret = 0;\n\tint error = 0;\n\tint socket_family = 0;\n\tint socket_type = 0;\n\tint socket_protocol = 0;\n\tint socket_addr_len = 0;\n\tint socket_addr_size = 0;\n\tint socket_addr_family = 0;\n\tint socket_addr_len_size = 0;\n\tint socket_addr_len_family = 0;\n\tint socket_addr_len_family_size = 0;\n\tint socket_addr_len_family_size_size = 0;\n\tint socket_addr_len_family_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size_size_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size_size_size_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size_size_size_size_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size_size_size_size_size_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size_size_size_size_size_size_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size_size_size_size_size_size_size_size_size_size = 0;\n\tint socket_addr_len_family_size_size_size_size_size_size_size_size_size_", "CodeBleu_score": 9.821194009619026}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = BSD_ERROR;\n\tint sock = socket;\n\tstruct sockaddr_in *addr_in;\n\tstruct sockaddr_in6 *addr_in6;\n\n\tif (addr == NULL) {\n\t\treturn ret;\n\t}\n\n\tif (addrlen == NULL) {\n\t\treturn ret;\n\t}\n\n\tif (addr->sa_family == AF_INET) {\n\t\taddr_in = (struct sockaddr_in *) addr;\n\t\tret = accept(sock, (struct sockaddr *) addr_in, addrlen);\n\t} else if (addr->sa_family == AF_INET6) {\n\t\taddr_in6 = (struct sockaddr_in6 *) addr;\n\t\tret = accept(sock, (struct sockaddr *) addr_in6, addrlen);\n\t} else {\n\t\tret = BSD_ERROR;\n\t}\n\n\tif (ret < 0) {\n\t\tret = BSD_ERROR;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 39.313917159970025}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = BSD_SUCCESS;\n\tint addr_family = addr->sa_family;\n\n\tif (addr_family == AF_INET) {\n\t\tstruct sockaddr_in * addr_in = (struct sockaddr_in *) addr;\n\t\tret = accept(socket, (struct sockaddr *) addr_in, addrlen);\n\t} else if (addr_family == AF_INET6) {\n\t\tstruct sockaddr_in6 * addr_in6 = (struct sockaddr_in6 *) addr;\n\t\tret = accept(socket, (struct sockaddr *) addr_in6, addrlen);\n\t} else {\n\t\tret = BSD_ERR_ADDR_FAMILY;\n\t}\n\n\tif (ret < 0) {\n\t\tif (addr_family == AF_INET) {\n\t\t\tret = BSD_ERR_SOCK_ACCEPT_IPV4;\n\t\t} else if (addr_family == AF_INET6) {\n\t\t\tret = BSD_ERR_SOCK_ACCEPT_IPV6;\n\t\t} else {\n\t\t\tret = BSD_ERR_SOCK_ACCEPT;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 42.36859163472416}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t current_time;\n\tuint32_t time_offset;\n\tchar *device_id;\n\tchar *device_token;\n\tchar *device_name;\n\tchar *device_type;\n\tchar *device_secret;\n\tchar *device_public_key;\n\tchar *device_private_key;\n\tchar *device_private_key_path;\n\tchar *device_public_key_path;\n\tchar *device_secret_path;\n\tchar *device_token_path;\n\tchar *device_id_path;\n\tchar *device_name_path;\n\tchar *device_type_path;\n\tchar *device_secret_path;\n\tchar *device_public_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path;\n\tchar *device_private_key_path", "CodeBleu_score": 3.865891818463746}, {"code": "static void connectMQTT(){\n\t\tif (isTimeValid()) {\n\t\tupdateTimeOffset();\n\t\tif (mqtt_connect()) {\n\t\t\tsendMQTTSubscribePacket();\n\t\t\tDEBUG_PRINT(\"MQTT connection established\n\");\n\t\t} else {\n\t\t\tDEBUG_PRINT(\"MQTT connection failed\n\");\n\t\t}\n\t} else {\n\t\tDEBUG_PRINT(\"Time is not valid\n\");\n\t}\n}", "CodeBleu_score": 15.372639993095808}, {"code": "static void connectMQTT(){\n\t\tunsigned int current_time = time(NULL);\n\n\tif (current_time > 0) {\n\t\tchar time_offset[10];\n\t\tsprintf(time_offset, \"%d\", current_time - (unsigned int) credentials_storage_get_time_offset());\n\t\tmqtt_packetPopulate_update_jwt_time_offset(time_offset);\n\t\tmqtt_packetTransfer_send_subscribe();\n\t}\n\telse {\n\t\tdebug_print_error(\"Time is not valid\n\");\n\t}\n}", "CodeBleu_score": 22.888068121874266}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_connectionState == MQTT_CONNECTED) {\n\t\tMQTT_disconnect();\n\t}\n\n\tDEBUG_print(\"Disconnected from cloud service\n\");\n}", "CodeBleu_score": 49.45964503738783}, {"code": "void CLOUD_disconnect(void){\n\t\tDEBUG_PRINT(DEBUG_PRINT_LEVEL_INFO, \"Disconnecting from the cloud service.\n\");\n\tif (MQTT_get_connection_state() == MQTT_CONNECTION_STATE_CONNECTED) {\n\t\tchar *client_id = NULL;\n\t\tchar *username = NULL;\n\t\tchar *password = NULL;\n\t\tint client_id_length = 0;\n\t\tint username_length = 0;\n\t\tint password_length = 0;\n\t\tint i = 0;\n\t\tif (MQTT_get_client_id(&client_id, &client_id_length) == MQTT_SUCCESS) {\n\t\t\tif (MQTT_get_username(&username, &username_length) == MQTT_SUCCESS) {\n\t\t\t\tif (MQTT_get_password(&password, &password_length) == MQTT_SUCCESS) {\n\t\t\t\t\tDEBUG_PRINT(DEBUG_PRINT_LEVEL_INFO, \"Disconnecting from the cloud service.\n\");\n\t\t\t\t\tfor (i = 0; i < client_id_length; i++) {\n\t\t\t\t\t\tDEBUG_PRINT(DEBUG_PRINT_LEVEL_INFO, \"%c\", client_id[i]);\n\t\t\t\t\t}\n\t\t\t\t\tDEBUG_PRINT(DEBUG_PRINT_LEVEL_INFO, \"\n\");\n\t\t\t\t\tfor (i = 0; i < username_length; i++) {\n\t\t\t\t\t\tDEBUG_PRINT(DEBUG_PRINT_LEVEL_INFO, \"%c\", username[i]);\n\t\t\t\t\t}\n\t\t\t\t\tDEBUG_PRINT(DEBUG_PRINT_LEVEL_INFO, \"\n\");\n\t\t\t\t\tfor (i = 0; i < password_length; i++) {\n\t\t\t\t\t\tDEBUG_PRINT(DEBUG_PRINT_LEVEL_INFO, \"%c\", password[i]);\n\t\t\t\t\t}\n\t\t\t\t\tDEBUG_PRINT(DEBUG_PRINT_LEVEL_INFO, \"\n\");\n\t\t\t\t\tMQTT_disconnect();\n\t\t\t\t\tfree(client_id);\n\t\t\t\t\tfree(username);\n\t\t\t\t\tfree(password);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.0526488523134}, {"code": "void CLOUD_disconnect(void){\n\t\tif (CLOUD_isConnected()) {\n\t\tMQTT_clientDisconnect();\n\t\tCLOUD_setConnected(false);\n\t}\n}", "CodeBleu_score": 15.302429775050722}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tbool result = false;\n\tuint8_t wifi_credentials_index = 0;\n\tuint8_t wifi_credentials_length = 0;\n\tuint8_t *wifi_credentials = NULL;\n\tuint8_t *wifi_ssid = NULL;\n\tuint8_t *wifi_password = NULL;\n\tuint8_t wifi_ssid_length = 0;\n\tuint8_t wifi_password_length = 0;\n\tuint8_t wifi_authentication = 0;\n\tuint8_t wifi_credentials_size = 0;\n\tuint8_t *wifi_credentials_ptr = NULL;\n\tuint8_t *wifi_ssid_ptr = NULL;\n\tuint8_t *wifi_password_ptr = NULL;\n\tuint8_t *wifi_authentication_ptr = NULL;\n\tuint8_t *wifi_credentials_index_ptr = NULL;\n\tuint8_t *wifi_credentials_length_ptr = NULL;\n\tuint8_t *wifi_credentials_size_ptr = NULL;\n\tuint8_t *wifi_ssid_length_ptr = NULL;\n\tuint8_t *wifi_password_length_ptr = NULL;\n\tuint8_t *wifi_authentication_ptr = NULL;\n\tuint8_t *wifi_credentials_ptr = NULL;\n\tuint8_t *wifi_ssid_ptr = NULL;\n\tuint8_t *wifi_password_ptr = NULL;\n\tuint8_t *wifi_authentication_ptr = NULL;\n\tuint8_t *wifi_credentials_index_ptr = NULL;\n\tuint8_t *wifi_credentials_length_ptr = NULL;\n\tuint8_t *wifi_credentials_size_ptr = NULL;\n\tuint8_t *wifi_ssid_length_ptr = NULL;\n\tuint8_t *wifi_password_length_ptr = NULL;\n\tuint8_t *wifi_authentication_ptr = NULL;\n\tuint8_t *wifi_credentials_ptr = NULL;\n\tuint8_t *wifi_ssid_ptr = NULL;\n\tuint8_t *wifi_password_ptr = NULL;\n\tuint8_t *wifi_authentication_ptr = NULL", "CodeBleu_score": 4.60349303441164}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tbool return_val = false;\n\tuint8_t i = 0;\n\tuint8_t wifi_creds_index = 0;\n\tuint8_t wifi_creds_count = 0;\n\n\tif (passed_wifi_creds) {\n\t\twifi_creds_index = passed_wifi_creds - 1;\n\t} else {\n\t\twifi_creds_index = 0;\n\t}\n\n\twifi_creds_count = sizeof(wifi_credentials) / sizeof(wifi_credentials[0]);\n\n\tif (wifi_creds_index < wifi_creds_count) {\n\t\tm2m_wifi_connect((char *) wifi_credentials[wifi_creds_index].ssid, strlen((char *) wifi_credentials[wifi_creds_index].ssid), wifi_credentials[wifi_creds_index].security, (void *) wifi_credentials[wifi_creds_index].password, M2M_WIFI_CH_ALL);\n\t} else {\n\t\tm2m_wifi_connect((char *) wifi_credentials[0].ssid, strlen((char *) wifi_credentials[0].ssid), wifi_credentials[0].security, (void *) wifi_credentials[0].password, M2M_WIFI_CH_ALL);\n\t}\n\n\tfor (i = 0; i < 20; i++) {\n\t\tif (m2m_wifi_get_connection_info() == M2M_WIFI_CONNECTED) {\n\t\t\treturn_val = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tdelay_ms(100);\n\t}\n\n\tif (!return_val) {\n\t\tdebug_print(\"Connection to AP failed\n\");\n\n\t\tnetwork_error_status = 1;\n\t}\n\n\treturn return_val;\n}", "CodeBleu_score": 43.273305817697036}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tbool result = false;\n\tbool network_error = false;\n\tuint8_t wifi_creds_index = passed_wifi_creds;\n\tuint8_t wifi_creds_index_prev = wifi_creds_index;\n\tuint8_t wifi_creds_index_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_prev_prev = wifi_creds_index;\n\tuint8_t wifi_creds_index_prev_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_prev = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_prev = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_next_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_next_next_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_next_next_next_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_next_next_next_next_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_next_next_next_next_next_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_next_next_next_next_next_next_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_next_next_next_next_next_next_next_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_next_next_next_next_next_next_next_next_next = wifi_creds_index;\n\tuint8_t wifi_creds_index_next_next_next_next_next_next_next_next_next_next_next_next = wifi_creds", "CodeBleu_score": 3.357212942914578}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t\tconst client = new AWSAppSyncClient({\n\t\turl: API_URL,\n\t\tregion: REGION,\n\t\tauth: {\n\t\t\ttype: AUTH_TYPE,\n\t\t\tapiKey: API_KEY,\n\t\t},\n\t});\n\n\tconst { data: { sensors } } = await client.query({\n\t\tquery: GET_SENSORS,\n\t});\n\n\tif (sensors) {\n\t\tconsole.log('Retrieved sensors:', sensors);\n\t\tsensors.forEach(sensor => {\n\t\t\tconst { id, name, latitude, longitude } = sensor;\n\t\t\tconst marker = new maplibregl.Marker()\n\t\t\t\t.setLngLat([longitude, latitude])\n\t\t\t\t.setPopup(new maplibregl.Popup({ offset: [0, -10] })\n\t\t\t\t\t.setHTML(`<h3>${name}</h3>`))\n\t\t\t\t.addTo(map);\n\n\t\t\tconsole.log(`Created marker for sensor ${id}`);\n\t\t});\n\t}\n}", "CodeBleu_score": 40.71672403253318}, {"code": "async function DisplaySensors(map){\n\t\t// Create a client that connects to the API endpoint\n\tconst api = API.default('prod');\n\n\t// Send a GraphQL query to fetch sensor data\n\tconst response = await api.graphql({\n\t\tquery: gql`\n\t\t\tquery {\n\t\t\t\tsensors {\n\t\t\t\t\tid\n\t\t\t\t\tname\n\t\t\t\t\tlatitude\n\t\t\t\t\tlongitude\n\t\t\t\t\tstatus\n\t\t\t\t}\n\t\t\t}\n\t\t`,\n\t});\n\n\t// Log the API response\n\tconsole.log('API response:', response);\n\n\t// Check if the response contains data\n\tif (response.data && response.data.sensors) {\n\t\t// Log the retrieval of sensors\n\t\tconsole.log('Retrieved sensors:', response.data.sensors);\n\n\t\t// Iterate through each sensor\n\t\tfor (const sensor of response.data.sensors) {\n\t\t\t// Create a marker for the sensor\n\t\t\tconst marker = new maplibregl.Marker({\n\t\t\t\tcolor: sensor.status === 'active'? '#00FF00' : '#FF0000',\n\t\t\t});\n\n\t\t\t// Place the marker on the map at the sensor's geographical coordinates\n\t\t\tmarker.setLngLat([sensor.longitude, sensor.latitude]).addTo(map);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.17689524588259}, {"code": "async function DisplaySensors(map){\n\t\t// Create a client\n\tconst client = new AWSAppSyncClient({\n\t\turl: GRAPHQL_API_URL,\n\t\tregion: GRAPHQL_API_REGION,\n\t\tauth: {\n\t\t\ttype: GRAPHQL_API_AUTH_TYPE,\n\t\t\tapiKey: GRAPHQL_API_KEY,\n\t\t},\n\t});\n\n\t// Send a GraphQL query to fetch sensor data\n\tconst result = await client.query({\n\t\tquery: SENSORS_QUERY,\n\t});\n\n\t// Log the API response\n\tconsole.log(result);\n\n\t// Check if the response contains data\n\tif (result.data.sensors) {\n\t\t// Log the retrieval of sensors\n\t\tconsole.log('Retrieved sensors:');\n\n\t\t// Iterate through each sensor\n\t\tfor (const sensor of result.data.sensors) {\n\t\t\t// Create a marker for the sensor\n\t\t\tconst marker = new maplibregl.Marker({\n\t\t\t\tcolor:'red',\n\t\t\t\tdraggable: false,\n\t\t\t});\n\n\t\t\t// Add the marker to the map\n\t\t\tmarker.setLngLat([sensor.longitude, sensor.latitude]).addTo(map);\n\n\t\t\t// Add the marker's name to the marker's popup\n\t\t\tmarker.setPopup(new maplibregl.Popup().setHTML(`<b>${sensor.name}</b>`));\n\t\t}\n\t}\n}", "CodeBleu_score": 40.52737240600315}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.border = '2px solid black';\n\treturn marker;\n}", "CodeBleu_score": 46.23478450641196}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"marker\";\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.border = \"solid 1px black\";\n\treturn marker;\n}", "CodeBleu_score": 42.43952657341631}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 44.78307227883664}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    module = await async_import_module(hass, module_name)\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not hass.data.get(HassKey.REQUIREMENTS, {}).get(module_path):\n            await hass.async_add_executor_job(\n                requirements.async_install_or_update_requirements, hass, module.REQUIREMENTS\n            )\n            hass.data[HassKey.REQUIREMENTS][module_path] = True\n    return module\n\n", "CodeBleu_score": 25.858414105038708}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Error importing %s: %s\", module_path, err)\n        raise HomeAssistantError(\n            f\"Error importing {module_path}: {err}\"\n        ) from err\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        requirements = module.REQUIREMENTS\n        if not hass.data.get(HassKey.REQUIREMENTS_PROCESSED, {}).get(\n            module_path, False\n        ):\n            try:\n                await hass.async_add_executor_job(\n                    hass.async_add_job, hass.async_add_job, requirements.install\n                )\n            except HomeAssistantError as err:\n                _LOGGER.error(\"Error installing requirements for %s: %s\", module_path, err)\n                raise HomeAssistantError(\n                    f\"Error installing requirements for {module_path}: {err}\"\n                ) from err\n            hass.data[HassKey.REQUIREMENTS_PROCESSED][module_path] = True\n\n    return module\n\n", "CodeBleu_score": 48.323868880001605}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_name)\n    except HomeAssistantError as err:\n        raise HomeAssistantError(\n            f\"Error loading MFA module {module_name}: {err}\"\n        ) from err\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        requirements = module.REQUIREMENTS\n        if not hass.data.get(HassKey.REQUIREMENTS_SKIPPED):\n            hass.data[HassKey.REQUIREMENTS_SKIPPED] = {}\n        if not hass.data[HassKey.REQUIREMENTS_SKIPPED].get(module_path):\n            await hass.async_add_executor_job(\n                async_process_requirements, hass, requirements\n            )\n            hass.data[HassKey.REQUIREMENTS_SKIPPED][module_path] = True\n\n    return module\n\n", "CodeBleu_score": 46.85245039618703}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    self._data[user_id] = setup_data[\"pin\"]\n    return True", "CodeBleu_score": 17.979330480704988}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self._data:\n        self._data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self._data[user_id] = {\n            \"pin\": setup_data[\"pin\"],\n            \"attempts\": 0,\n            \"last_attempt\": 0,\n            \"last_success\": 0,\n        }\n    return True\n\n", "CodeBleu_score": 34.426481550425756}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n    return True\n\n", "CodeBleu_score": 36.05631592053247}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    if self.init_lock.locked():\n        return\n    async with self.init_lock:\n        if not self.user_settings:\n            self.user_settings = await self._async_load_user_settings()\n\n", "CodeBleu_score": 17.952407809027587}, {"code": "async def _async_load(self) -> None\n\t\n    if self._init_lock.locked():\n        return\n    async with self._init_lock:\n        if self._init_lock.locked():\n            return\n        if self._user_settings:\n            return\n        try:\n            data = await self._user_store.async_load()\n        except FileNotFoundError:\n            data = {}\n        self._user_settings = {\n            user_id: NotifySetting(user_id, user_data) for user_id, user_data in data.items()\n        }\n\n", "CodeBleu_score": 40.210837884005116}, {"code": "async def _async_load(self) -> None\n\t\n    # Acquire a lock to ensure thread safety\n    with self._init_lock:\n        # Check if user settings are already loaded\n        if self._user_settings:\n            return\n        # Load user settings from the user store\n        self._user_settings = await self._async_load_from_store()\n        # If user settings are empty, initialize an empty dictionary\n        if not self._user_settings:\n            self._user_settings = {}\n        # Create \"NotifySetting\" objects for each user based on the loaded data\n        self._user_settings = {\n            user_id: NotifySetting(user_id, data)\n            for user_id, data in self._user_settings.items()\n        }\n\n", "CodeBleu_score": 36.93033554594053}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self.hass.data[DOMAIN][user_id] = await self.async_load_settings()\n    if user_id not in self.hass.data[DOMAIN]:\n        return False\n    return await self.async_validate_otp(user_id, user_input)\n\n", "CodeBleu_score": 41.867966337689225}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if not await self.async_is_loaded():\n        return False\n    return await self.async_get_user(user_id).async_validate(user_input)\n\n", "CodeBleu_score": 28.516458874468032}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_settings()\n    if user_id not in self.settings:\n        return False\n\n    settings = self.settings[user_id]\n    if settings.otp_secret is None:\n        return False\n\n    if not settings.otp_secret.startswith(\"otpauth://totp/\"):\n        return False\n\n    user_input = {\n        key: cast(str, value)\n        for key, value in user_input.items()\n        if key in (CONF_EXCLUDE, CONF_INCLUDE)\n    }\n    user_input[CONF_EXCLUDE] = user_input.get(CONF_EXCLUDE, [])\n    user_input[CONF_INCLUDE] = user_input.get(CONF_INCLUDE, [])\n\n    return await self.async_validate_otp(settings.otp_secret, user_input)\n\n", "CodeBleu_score": 44.24103763176418}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 47.22039460883292}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entity(entity_id)\n    if not entity:\n        return None\n    device = entity.device\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 39.746392669979905}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = entity.device\n    if device is None:\n        return None\n    area = area_dict.get(device.area_id)\n    if area is None:\n        return None\n    return area.permissions\n\n", "CodeBleu_score": 52.15273241479661}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy = {}\n    seen_categories = set()\n    for p in policies:\n        for category, value in p.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                policy[category] = value\n            else:\n                policy[category] = merge_categories(policy[category], value)\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 39.93320711860072}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, value in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = value\n            else:\n                merged_policy[category] = merge_categories(merged_policy[category], value)\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 45.37109479179012}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, value in policy.items():\n            if category not in seen_categories:\n                merged_policy[category] = value\n                seen_categories.add(category)\n\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 38.44887521147452}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        return await async_import_module(hass, provider)\n    except HomeAssistantError as err:\n        raise HomeAssistantError(\n            f\"Unable to load authentication provider module {provider}: {err}\"\n        ) from err\n\n", "CodeBleu_score": 19.870808890351466}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        return await async_import_module(hass, provider)\n    except HomeAssistantError as err:\n        raise HomeAssistantError(\n            f\"Failed to load authentication provider module: {provider}", "CodeBleu_score": 15.147368267701388}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, provider)\n    except HomeAssistantError as err:\n        raise HomeAssistantError(\n            f\"Unable to load authentication provider module {provider}: {err}\"\n        ) from err\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not isinstance(module.REQUIREMENTS, Mapping):\n            raise HomeAssistantError(\n                f\"Authentication provider module {provider} has invalid requirements: {module.REQUIREMENTS}\"\n            )\n        if CONF_ID in module.REQUIREMENTS:\n            raise HomeAssistantError(\n                f\"Authentication provider module {provider} has invalid requirements: {module.REQUIREMENTS}\"\n            )\n        hass.data[DATA_REQUIREMENTS][provider] = module.REQUIREMENTS\n    return module\n\n", "CodeBleu_score": 41.29759052772706}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if not self.data:\n        self.data = {}\n\n    if not self.data.get(CONF_ID):\n        self.data[CONF_ID] = {}\n\n    if not self.data.get(CONF_ID).get(CONF_ID):\n        self.data[CONF_ID][CONF_ID] = {}\n\n    if not self.data[CONF_ID][CONF_ID].get(CONF_ID):\n        self.data[CONF_ID][CONF_ID][CONF_ID] = {}\n\n    if not self.data[CONF_ID][CONF_ID][CONF_ID].get(CONF_ID):\n        self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID] = {}\n\n    if not self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID].get(CONF_ID):\n        self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID] = {}\n\n    if not self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID].get(CONF_ID):\n        self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID] = {}\n\n    if not self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID].get(CONF_ID):\n        self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID] = {}\n\n    if not self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID].get(CONF_ID):\n        self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID] = {}\n\n    if not self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID].get(CONF_ID):\n        self.data[CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID][CONF_ID", "CodeBleu_score": 11.074990089789264}, {"code": "async def async_load(self) -> None\n\t\n    self.users = []\n    try:\n        data = await self.store.async_load()\n        if data is not None:\n            for user in data:\n                if isinstance(user, dict) and CONF_ID in user:\n                    self.users.append(User(user))\n    except (ir.DuplicateEntityError, HomeAssistantError) as err:\n        self.hass.async_create_task(\n            self.hass.config_entries.flow.async_init(\n                \"user\", context={\"source\": SOURCE_IMPORT}, errors={\"base\": err}\n            )\n        )\n\n", "CodeBleu_score": 24.106911733401677}, {"code": "async def async_load(self) -> None\n\t\n    if not self.hass.config.is_allowed_path(self.data_dir):\n        raise HomeAssistantError(\"Path not allowed\")\n\n    self.users = []\n\n    # Load data from the store\n    try:\n        self.store = Store(self.data_dir)\n        self.data = await self.store.async_load()\n    except FileNotFoundError:\n        self.data = {}\n\n    # Check for non-normalized usernames and assign them to the internal variable\n    for user_id, user in self.data.items():\n        if not isinstance(user, Mapping):\n            self.users.append(\n                {\n                    CONF_ID: user_id,\n                    \"password\":,\n                    \"name\": user,\n                    \"is_admin\": False,\n                }\n            )\n        else:\n            self.users.append(\n                {\n                    CONF_ID: user_id,\n                    \"password\":,\n                    \"name\": user.get(\"name\"),\n                    \"is_admin\": user.get(\"is_admin\", False),\n                }\n            )\n\n    # Check for non-normalized usernames and assign them to the internal variable\n    for user in self.users:\n        if not isinstance(user[\"name\"], str):\n            self.users.remove(user)\n            self.users.append(\n                {\n                    CONF_ID: user[\"id\"],\n                    \"password\": [\"\"],\n                    \"name\": user[\"name\"].get(\"name\"),\n                    \"is_admin\": user[\"name\"].get(\"is_admin\", False),\n                }\n            )\n\n    # Check for non-normalized usernames and assign them to the internal variable\n    for user in self.users:\n        if not isinstance(user[\"name\"], str):\n            self.users.remove(user)\n            self.users.append(\n                {\n                    CONF_ID: user[\"id\"],\n                    \"password\": [\"\"],\n                    \"name\": user[\"name\"].get(\"name\"),\n                    \"is_admin\": user[\"name\"].get(\"is_admin\", False),\n                }\n            )\n\n", "CodeBleu_score": 24.223937251939354}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user[CONF_ID] == username:\n            stored_hash = user[CONF_ID]\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash.encode(\"utf-8\")):\n                return\n            else:\n                raise InvalidAuth()\n    raise InvalidAuth()\n\n", "CodeBleu_score": 34.05310946170531}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    if not isinstance(username, str):\n        raise TypeError(\n            \"The username must be a string, not %s\" % type(username).__name__\n        )\n    if not isinstance(password, str):\n        raise TypeError(\n            \"The password must be a string, not %s\" % type(password).__name__\n        )\n    username = username.lower()\n    self.log(\n        \"Validating login for user %s\",\n        {\"user\": username, \"password\": \"\"},\n    )\n    if not self._users.get(username):\n        self.log(\"User %s not found\", {\"user\": username})\n        raise ir.InvalidAuth(\"Invalid user\")\n    user = self._users[username]\n    if not isinstance(user, Mapping):\n        raise TypeError(\n            \"The user data must be a mapping, not %s\"\n            % type(user).__name__\n        )\n    if not isinstance(user[CONF_ID], str):\n        raise TypeError(\n            \"The user ID must be a string, not %s\"\n            % type(user[CONF_ID]).__name__\n        )\n    if not isinstance(user[CONF_ID], str):\n        raise TypeError(\n            \"The user ID must be a string, not %s\"\n            % type(user[CONF_ID]).__name__\n        )\n    if not isinstance(user[CONF_ID], str):\n        raise TypeError(\n            \"The user ID must be a string, not %s\"\n            % type(user[CONF_ID]).__name__\n        )\n    if not isinstance(user[CONF_ID], str):\n        raise TypeError(\n            \"The user ID must be a string, not %s\"\n            % type(user[CONF_ID]).__name__\n        )\n    if not isinstance(user[CONF_ID], str):\n        raise TypeError(\n            \"The user ID must be a string, not %s\"\n            % type(user[CONF_ID]).__name__\n        )\n    if not isinstance(user[CONF_ID], str):\n        raise TypeError(\n            \"The user ID must be a string, not %s\"\n            % type(user[CONF_ID]).__name__\n        )\n    if not isinstance(user[CONF_ID], str):\n        raise TypeError(\n            \"The user ID must be a string, not %s\"\n            % type(user[CONF_ID]).__name__\n        )\n   ", "CodeBleu_score": 26.903679972913665}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.username = username.lower()\n    self.password = \n    self.hash = \"$2a$12$\"\n\n", "CodeBleu_score": 13.669146803081142}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    if normalized_username in self.users:\n        del self.users[normalized_username]\n        self.async_write()\n\n", "CodeBleu_score": 19.154498385226464}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    if username is None:\n        raise ValueError(\"username cannot be None\")\n    normalized_username = self._normalize_username(username)\n    if normalized_username in self._users:\n        del self._users[normalized_username]\n        self._save_users()\n        return\n    raise ir.InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 37.36056323153132}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    for user in self.users:\n        if user.username == normalized_username:\n            self.users.remove(user)\n            return\n    raise ir.InvalidUser(f\"User {username} not found\")\n\n", "CodeBleu_score": 28.510766956397227}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        await self.async_initialize()\n    try:\n        await self.async_remove_credentials(credentials.username)\n    except HomeAssistantError:\n        pass\n\n", "CodeBleu_score": 41.38892796719566}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    try:\n        await self.async_remove_credentials(credentials)\n    except HomeAssistantError:\n        pass\n\n", "CodeBleu_score": 22.302532688894388}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    try:\n        await self.async_remove_credentials(credentials.username)\n    except HomeAssistantError:\n        pass\n\n", "CodeBleu_score": 23.298139308925762}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined_threads.add(thread)\n            continue\n        thread_timeout = timeout\n        if log:\n            thread_timeout = timeout / 2\n        if thread_timeout <= 0:\n            thread_timeout = 0.001\n        if thread.is_alive():\n            try:\n                thread.join(thread_timeout)\n            except Exception as e:\n                if log:\n                    logging.error(\n                        \"Thread %s failed to join: %s\",\n                        thread.name,\n                        traceback.format_exc(),\n                    )\n                if thread.is_alive():\n                    thread.interrupt()\n        if thread.is_alive():\n            joined_threads.add(thread)\n    if log:\n        for thread in threads:\n            if thread not in joined_threads:\n                logging.error(\n                    \"Thread %s failed to join: %s\",\n                    thread.name,\n                    traceback.format_exc(),\n                )\n    if len(threads)!= len(joined_threads):\n        raise SystemExit(1)\n    return joined_threads\n\n", "CodeBleu_score": 40.6962358401842}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n\n    def join_or_interrupt(thread: Thread) -> None:\n        \"\"\"The function \"join_or_interrupt\" attempts to join or interrupt a thread.", "CodeBleu_score": 13.619619074203834}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    if not threads:\n        return set()\n    joined_threads = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined_threads.add(thread)\n        else:\n            timeout_seconds = timeout\n            if thread.is_alive():\n                timeout_seconds = timeout_seconds - (time.time() - thread.start_time)\n            if timeout_seconds > 0:\n                thread.join(timeout_seconds)\n                if thread.is_alive():\n                    joined_threads.add(thread)\n                    if log:\n                        logging.warning(\n                            f\"Thread {thread.name} did not finish within {timeout} seconds. It is being interrupted.\"\n                        )\n            else:\n                joined_threads.add(thread)\n                if log:\n                    logging.warning(\n                        f\"Thread {thread.name} did not finish within {timeout} seconds. It is being interrupted.\"\n                    )\n    for thread in threads:\n        if thread not in joined_threads:\n            try:\n                thread.raise_exc_info(SystemExit)\n            except SystemExit:\n                pass\n    return joined_threads\n\n", "CodeBleu_score": 40.10775363544664}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = threading.enumerate()\n    for thread in threads:\n        if thread is not threading.current_thread() and not thread.daemon:\n            timeout = 0.01\n            try:\n                thread.join(timeout)\n            except RuntimeError:\n                logging.warning(f\"Thread {thread} is still alive after timeout of {timeout} seconds\")\n\n", "CodeBleu_score": 26.545347562417852}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    global _shutdown_timeout\n    global _shutdown_lock\n    global _shutdown_thread_list\n    global _shutdown_thread_timeout_map\n    global _shutdown_thread_timeout_map_lock\n    global _shutdown_thread_timeout_map_lock_count\n    global _shutdown_thread_timeout_map_lock_count_lock\n    global _shutdown_thread_timeout_map_lock_count_lock_count\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock_count\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock_count_lock\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock_count_lock_count\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock_count_lock_count_lock\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count_lock\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count_lock\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count\n    global _shutdown_thread_timeout_map_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count_lock_count_lock\n    global _shutdown_thread", "CodeBleu_score": 3.3013769867484957}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    logging.info(\"Deadlock-safe shutdown initiated\")\n    threads = []\n    for thread in threading.enumerate():\n        if thread is not threading.current_thread() and not thread.daemon:\n            threads.append(thread)\n    for thread in threads:\n        timeout = threading.TIMEOUT\n        if len(threads) > 1:\n            timeout = threading.TIMEOUT / (len(threads) - 1)\n        try:\n            thread.join(timeout)\n        except Exception:\n            logging.warning(f\"Failed to join thread {thread.name}\")\n    logging.info(\"Deadlock-safe shutdown completed\")\n\n", "CodeBleu_score": 38.44072027173649}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self._remaining_with_setup_started or remaining_with_setup_started:\n        self._dispatcher_signal.send(remaining_with_setup_started)\n        self._remaining_with_setup_started = remaining_with_setup_started\n    self._dispatcher_signal.send(remaining_with_setup_started)\n    self._remaining_with_setup_started = remaining_with_setup_started\n", "CodeBleu_score": 49.26097530442628}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self._remaining_setups:\n        self._remaining_setups = {}\n        self._dispatcher.send(self._remaining_setups)\n    elif remaining_with_setup_started:\n        self._dispatcher.send(remaining_with_setup_started)\n\n def _async_dispatch_with_setup_started(self, setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatch_with_setup_started\" dispatches a signal based on the state of setups.", "CodeBleu_score": 48.07496936299178}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if (remaining_with_setup_started):\n        self.send_signal(InternalDispatcherSignal(remaining_with_setup_started))\n    self._remaining_with_setup_started = remaining_with_setup_started\n\n\n def _async_dispatch_setup(self, setup: dict[str, Any]) -> None:\n    \"\"\"The function \"_async_dispatch_setup\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 49.51915326316942}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # The function \"validate\" verifies the correctness of the bluetooth.py file for Home Assistant.\n    # It generates and validates the Bluetooth content based on provided integrations and stores it in the configuration cache.\n    # If specific integrations are not being validated, it reads the current content of bluetooth.py and compares it with the generated content.\n    # If the contents differ, it adds an error to the configuration indicating that bluetooth.py is not up to date and provides a fixable suggestion.\n    # The function takes in the following arguments:\n    # integrations: A dictionary of integrations to be validated.\n    # config: A Config object containing the configuration cache.\n    # It returns no value.\n    # The function first checks if the \"bluetooth\" integration is present in the provided integrations dictionary.\n    # If it is not present, it returns without doing anything.\n    # If it is present, it checks if the \"bluetooth\" integration is present in the configuration cache.\n    # If it is not present, it generates the content of the bluetooth.py file based on the provided integrations.\n    # It then compares the generated content with the current content of the bluetooth.py file.\n    # If the contents differ, it adds an error to the configuration indicating that bluetooth.py is not up to date and provides a fixable suggestion.\n    # If the contents match, it does nothing.\n    if \"bluetooth\" in integrations:\n        if \"bluetooth\" not in config.cache:\n            # The \"bluetooth\" integration is present in the provided integrations dictionary.\n            # If it is not present, it returns without doing anything.\n            # If it is present, it checks if the \"bluetooth\" integration is present in the configuration cache.\n            # If it is not present, it generates the content of the bluetooth.py file based on the provided integrations.\n            # It then compares the generated content with the current content of the bluetooth.py file.\n            # If the contents differ, it adds an error to the configuration indicating that bluetooth.py is not up to date and provides a fixable suggestion.\n            # If the contents match, it does nothing.\n            # The function first checks if the \"bluetooth\" integration is present in the provided integrations dictionary.\n            # If it is not present, it returns without doing anything.\n            # If it is present, it checks if the \"bluetooth\" integration is present in the configuration cache.\n            # If it is not", "CodeBleu_score": 13.320073340782612}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.bluetooth_config_cache is None:\n        config.bluetooth_config_cache = {}\n    if config.bluetooth_config_cache.get(\"integrations\")!= integrations:\n        config.bluetooth_config_cache[\"integrations\"] = integrations\n        config.bluetooth_config_cache[\"content\"] = generate_bluetooth_config(integrations)\n        config.bluetooth_config_cache[\"content_no_comments\"] = generate_bluetooth_config(integrations, remove_comments=True)\n        config.bluetooth_config_cache[\"errors\"] = validate_bluetooth_config(integrations, config.bluetooth_config_cache[\"content_no_comments\"])\n    else:\n        config.bluetooth_config_cache[\"errors\"] = validate_bluetooth_config(integrations, config.bluetooth_config_cache[\"content_no_comments\"])\n\n", "CodeBleu_score": 31.514414379921135}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.integrations_to_validate:\n        integrations_to_validate = config.integrations_to_validate\n    else:\n        integrations_to_validate = integrations.keys()\n\n    for integration in integrations_to_validate:\n        if integration in integrations:\n            integration_config = integrations[integration]\n            if integration_config.get(\"bluetooth\"):\n                bluetooth_config = integration_config[\"bluetooth\"]\n                if bluetooth_config.get(\"devices\"):\n                    devices = bluetooth_config[\"devices\"]\n                    if devices:\n                        for device in devices:\n                            if device.get(\"name\"):\n                                name = device[\"name\"]\n                                if name:\n                                    if not name.isidentifier():\n                                        config.add_error(\n                                            f\"The name '{name}' of the device {device} in the bluetooth integration {integration} is not a valid Python identifier.\"\n                                        )\n                                    if name.startswith(\"_\"):\n                                        config.add_error(\n                                            f\"The name '{name}' of the device {device} in the bluetooth integration {integration} starts with an underscore.\"\n                                        )\n                                    if name.endswith(\"_\"):\n                                        config.add_error(\n                                            f\"The name '{name}' of the device {device} in the bluetooth integration {integration} ends with an underscore.\"\n                                        )\n                                    if name.isalnum():\n                                        config.add_error(\n                                            f\"The name '{name}' of the device {device} in the bluetooth integration {integration} is not a valid Python identifier.\"\n                                        )\n                                    if name.lower() in [\n                                        \"bluetooth\",\n                                        \"bluetooth_le\",\n                                        \"bluetooth_classic\",\n                                        \"bluetooth_gatt\",\n                                        \"bluetooth_gatt_server\",\n                                        \"bluetooth_gatt_client\",\n                                        \"bluetooth_gatt_scanner\",\n                                        \"bluetooth_le_scanner\",\n                                        \"bluetooth_le_advertiser\",\n                                        \"bluetooth_le_advertiser_legacy\",\n                                        \"bluetooth_le_advertisements\",\n                                        \"bluetooth_le_advertisement\",\n                                        \"bluetooth_le_advertising\",\n                                        \"bluetooth_le_advertisements_legacy\",\n                                        \"bluetooth_le_advertisement_legacy\",\n                                        \"bluetooth_le_advertisements_legacy\",\n                                        \"bluetooth_le_advertisement_legacy\",\n                                        \"bluetooth_le_advertisements_legacy\",\n                                        \"bluetooth_le_advertisement_legacy\",\n                                        \"bluetooth_le_advertisements_legacy\",\n                                        \"bluetooth_le", "CodeBleu_score": 25.74284846894771}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := fmt.Sprintf(\"%s/oauth2/token\", d.config.TokenEndpoint)\n\tclient := resty.New()\n\treq, err := client.R().\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.config.RefreshToken,\n\t\t\t\"client_id\":     d.config.ClientID,\n\t\t\t\"client_secret\": d.config.ClientSecret,\n\t\t}).\n\t\tSetResult(&d.config).\n\t\tSetError(&d.config).\n\t\tPost(url)\n\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif req.IsError() {\n\t\treturn req.Error()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.286599641893055}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tlogger.Info(\"refreshing access token\")\n\t// Send a POST request to the Dropbox OAuth2 token endpoint with the refresh token, app key, and app secret\n\tresponse, err := resty.New().R().\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"client_id\":     d.AppKey,\n\t\t\t\"client_secret\": d.AppSecret,\n\t\t}).\n\t\tPost(\"https://api.dropbox.com/oauth2/token\")\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Parse the response body as JSON\n\tvar tokenResponse struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}\n\terr = response.JSON(&tokenResponse)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Update the access token and expiration time\n\td.AccessToken = tokenResponse.AccessToken\n\td.ExpiresIn = tokenResponse.ExpiresIn\n\treturn nil\n}", "CodeBleu_score": 51.58353788864416}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create a new request to the Dropbox OAuth2 token endpoint\n\trefreshTokenRequest, err := resty.New().R().\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\": \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"client_id\": d.AppKey,\n\t\t\t\"client_secret\": d.AppSecret,\n\t\t})\n\tif err!= nil {\n\t\treturn fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\t// Send the request to the Dropbox OAuth2 token endpoint\n\tresponse, err := refreshTokenRequest.\n\t\tSetResult(&base.TokenResponse{}).\n\t\tSetError(&base.TokenResponse{}).\n\t\tExecute()\n\tif err!= nil {\n\t\treturn fmt.Errorf(\"failed to send request: %w\", err)\n\t}\n\n\t// Check the response status code\n\tif response.StatusCode()!= http.StatusOK {\n\t\treturn fmt.Errorf(\"received non-200 status code: %d\", response.StatusCode())\n\t}\n\n\t// Parse the response body as a TokenResponse struct\n\ttokenResponse := response.Result().(*base.TokenResponse)\n\n\t// Update the access token and refresh token\n\td.AccessToken = tokenResponse.AccessToken\n\td.RefreshToken = tokenResponse.RefreshToken\n\n\treturn nil\n}", "CodeBleu_score": 45.21052103312403}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar (\n\t\terr  error\n\t\treq  *resty.Request\n\t\tresp *resty.Response\n\t\tbody []byte\n\t)\n\n\t// Set the request method\n\tswitch method {\n\tcase \"GET\":\n\t\treq = d.client.R().SetResult(resp)\n\tcase \"POST\":\n\t\treq = d.client.R().SetBody(resp)\n\tcase \"PUT\":\n\t\treq = d.client.R().SetBody(resp)\n\tcase \"PATCH\":\n\t\treq = d.client.R().SetBody(resp)\n\tcase \"DELETE\":\n\t\treq = d.client.R().SetBody(resp)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"invalid request method: %s\", method)\n\t}\n\n\t// Set the request URL\n\treq.SetURL(url)\n\n\t// Set the authorization header\n\treq.SetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.token.AccessToken))\n\n\t// Set the request parameters\n\treq.SetQueryParams(d.params)\n\n\t// Set the request callback\n\tif callback!= nil {\n\t\treq.SetResult(resp)\n\t\treq.SetBody(resp)\n\t\treq.SetError(resp)\n\t\treq.SetHeaders(resp)\n\t\treq.SetHeader(\"Content-Type\", \"application/json\")\n\t\treq.SetHeader(\"Accept\", \"application/json\")\n\t\treq.SetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.token.AccessToken))\n\t\treq.SetQueryParam(\"alt\", \"json\")\n\t\treq.SetQueryParam(\"prettyPrint\", \"false\")\n\t\treq.SetQueryParam(\"fields\", \"*\")\n\t\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\t\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\t\treq.SetQueryParam(\"includeTeamDriveItems\", \"true\")\n\t}\n\n\t// Send the request\n\tif resp!= nil {\n\t\tresp, err = req.Execute(method, resp)\n\t} else {\n\t\tresp, err = req.Execute(method, nil)\n\t}\n\n\t// Handle errors\n\tif err!= nil {\n\t\tlog.Errorf(\"Failed to send request: %v\", err)\n\t\treturn nil, err\n", "CodeBleu_score": 34.68017341315051}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tif d.token == nil {\n\t\treturn nil, fmt.Errorf(\"token is nil\")\n\t}\n\treq := resty.New().R().SetHeader(\"Authorization\", \"Bearer \"+d.token.AccessToken).SetHeader(\"Accept\", \"application/json\").SetHeader(\"Content-Type\", \"application/json\")\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\tif resp!= nil {\n\t\treq.SetResult(resp)\n\t}\n\tresp, err := req.SetBody(map[string]interface{}{\"url\": url, \"method\": method}).SetQueryParams(map[string]string{\"fields\": \"files(id, name, mimeType, size, createdTime, modifiedTime, md5Checksum, webContentLink, webViewLink, iconLink, parents)\"}).SetError(&model.Error{}).SetRetryCount(3).SetRetryWaitTime(100).SetRetryMaxWaitTime(1000).SetRetryWaitType(base.RetryWaitTypeLinear).SetRetryWaitTimeFunc(base.RetryWaitTimeFuncDefault).SetRetryMaxWaitType(base.RetryMaxWaitTypeLinear).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitType(base.RetryMaxWaitTypeLinear).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTimeFunc(base.RetryMaxWaitTimeFuncDefault).SetRetryMaxWaitTime", "CodeBleu_score": 31.85733883978089}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar body []byte\n\tvar err error\n\tvar req *resty.Request\n\tvar respBody []byte\n\tvar respCode int\n\tvar respHeader http.Header\n\tvar retry int\n\n\t// Make the request\n\treq, err = d.client.R().SetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.token)).SetHeader(\"Content-Type\", \"application/json\").SetResult(&respBody).SetError(&respBody).SetBody(body).SetQueryParams(map[string]string{\"fields\": \"nextPageToken, files(id, name, mimeType, size, createdTime, modifiedTime, webContentLink, webViewLink, parents)\"}).SetDebug(true)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treq.SetBody(body)\n\treq.SetBody(body)\n\n\t// Set the request method\n\tswitch method {\n\tcase \"GET\":\n\t\treq.SetResult(&respBody).SetError(&respBody).SetBody(body)\n\tcase \"POST\":\n\t\treq.SetResult(&respBody).SetError(&respBody).SetBody(body)\n\tcase \"PUT\":\n\t\treq.SetResult(&respBody).SetError(&respBody).SetBody(body)\n\tcase \"PATCH\":\n\t\treq.SetResult(&respBody).SetError(&respBody).SetBody(body)\n\tcase \"DELETE\":\n\t\treq.SetResult(&respBody).SetError(&respBody).SetBody(body)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported method: %s\", method)\n\t}\n\n\t// Set the request URL\n\treq.SetHostURL(url)\n\n\t// Set the request callback\n\tif callback!= nil {\n\t\treq.SetCallback(callback)\n\t}\n\n\t// Make the request\n\tfor retry = 0; retry < d.retry; retry++ {\n\t\tresp, err = req.Execute(method, url)\n\t\tif err!= nil {\n\t\t\tlog.Errorf(\"request error: %s\", err.Error())\n\t\t\tcontinue\n\t\t}\n\t\trespCode = resp.StatusCode()\n\t\trespHeader = resp.Header()\n\t\trespBody = resp.Body()\n\t\tif respCode == http.StatusUnauthorized {\n\t\t\t// Refresh", "CodeBleu_score": 38.32107374314187}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Get the file size\n\tsize, err := stream.Size()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the chunk size to 1 MB\n\tchunkSize := int64(1024 * 1024)\n\n\t// Calculate the number of chunks\n\tnumChunks := int64(size / chunkSize)\n\tif size%chunkSize!= 0 {\n\t\tnumChunks++\n\t}\n\n\t// Initialize the request\n\treq := resty.R().SetContext(ctx).SetBody(stream).SetFormData(true)\n\treq.SetHeader(\"Content-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"Content-Range\", \"bytes 0-\"+strconv.FormatInt(chunkSize-1, 10)+\"/*\")\n\n\t// Upload the chunks sequentially\n\tfor i := int64(0); i < numChunks; i++ {\n\t\t// Calculate the start and end offsets for the current chunk\n\t\tstart := i * chunkSize\n\t\tend := start + chunkSize - 1\n\t\tif end >= size {\n\t\t\tend = size - 1\n\t\t}\n\n\t\t// Set the Content-Range header for the current chunk\n\t\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", start, end, size-1))\n\n\t\t// Send the request\n\t\tresp, err := req.Post(url)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// Check for context cancellation\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Check for HTTP errors\n\t\tif resp.IsError() {\n\t\t\treturn fmt.Errorf(\"error uploading chunk %d: %s\", i, resp.Status())\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.645448131714716}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size\n\tchunkSize := d.chunkSize\n\n\t// Create a new RESTy client\n\tclient := resty.New()\n\n\t// Set the context\n\tclient.SetContext(ctx)\n\n\t// Set the headers\n\tclient.SetHeader(\"Authorization\", \"Bearer \"+d.token)\n\tclient.SetHeader(\"Content-Type\", \"application/json\")\n\n\t// Set the request timeout\n\tclient.SetTimeout(d.timeout)\n\n\t// Set the retry count\n\tclient.SetRetryCount(d.retryCount)\n\n\t// Set the retry wait duration\n\tclient.SetRetryWaitDuration(d.retryWaitDuration)\n\n\t// Set the retry max duration\n\tclient.SetRetryMaxDuration(d.retryMaxDuration)\n\n\t// Set the retry backoff factor\n\tclient.SetRetryBackoffFactor(d.retryBackoffFactor)\n\n\t// Set the retry status codes\n\tclient.SetRetryStatusCodes(d.retryStatusCodes)\n\n\t// Set the retry on unsuccessful status codes\n\tclient.SetRetryOnUnsuccessfulStatusCodes(d.retryOnUnsuccessfulStatusCodes)\n\n\t// Set the retry on unsuccessful status codes\n\tclient.SetRetryOnUnsuccessfulStatusCodes(d.retryOnUnsuccessfulStatusCodes)\n\n\t// Set the retry on unsuccessful status codes\n\tclient.SetRetryOnUnsuccessfulStatusCodes(d.retryOnUnsuccessfulStatusCodes)\n\n\t// Set the retry on unsuccessful status codes\n\tclient.SetRetryOnUnsuccessfulStatusCodes(d.retryOnUnsuccessfulStatusCodes)\n\n\t// Set the retry on unsuccessful status codes\n\tclient.SetRetryOnUnsuccessfulStatusCodes(d.retryOnUnsuccessfulStatusCodes)\n\n\t// Set the retry on unsuccessful status codes\n\tclient.SetRetryOnUnsuccessfulStatusCodes(d.retryOnUnsuccessfulStatusCodes)\n\n\t// Set the retry on unsuccessful status codes\n\tclient.SetRetryOnUnsuccessfulStatusCodes(d.retryOnUnsuccessfulStatusCodes)\n\n\t// Set the retry on unsuccessful status codes\n\tclient.SetRetryOnUnsuccessfulStatusCodes(d.retryOnUnsuccessfulStatusCodes)\n\n\t// Set the retry on unsuccessful status codes\n\tclient.SetRetryOnUnsuccessfulStatusCodes(d.retryOnUnsuccessfulStatusCodes)\n\n\t// Set the retry on un", "CodeBleu_score": 15.883109633151765}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Create a new Resty client with the context\n\tclient := resty.New().SetContext(ctx)\n\n\t// Calculate the chunk size based on the file size and the maximum chunk size\n\tchunkSize := d.chunkSize\n\tif stream.Size < d.chunkSize {\n\t\tchunkSize = stream.Size\n\t}\n\n\t// Create a new reader with the file streamer\n\treader := utils.NewFileReader(stream)\n\n\t// Calculate the number of chunks required for the file\n\tnumChunks := int(stream.Size / chunkSize)\n\tif stream.Size%chunkSize!= 0 {\n\t\tnumChunks++\n\t}\n\n\t// Upload the file in chunks\n\tfor i := 0; i < numChunks; i++ {\n\t\t// Calculate the start and end position of the chunk\n\t\tstart := i * chunkSize\n\t\tend := start + chunkSize\n\n\t\t// Read the chunk from the file\n\t\tchunk, err := reader.Read(chunkSize)\n\t\tif err!= nil {\n\t\t\tif err == io.EOF {\n\t\t\t\t// If the chunk is the last chunk, break out of the loop\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// Create the request body for the chunk\n\t\trequestBody := bytes.NewBuffer(chunk)\n\n\t\t// Create the request headers for the chunk\n\t\theaders := map[string]string{\n\t\t\t\"Content-Type\": stream.MimeType,\n\t\t\t\"Content-Range\": fmt.Sprintf(\"bytes %d-%d/%d\", start, end-1, stream.Size),\n\t\t}\n\n\t\t// Perform the HTTP request for the chunk\n\t\tresp, err := client.R().\n\t\t\tSetBody(requestBody).\n\t\t\tSetHeaders(headers).\n\t\t\tSetResult(&model.GoogleDriveResponse{}).\n\t\t\tPost(url)\n\n\t\t// Check for context cancellation\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Check for errors in the HTTP response\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check the status code of the response\n\t\tif resp.StatusCode()!= http.StatusCreated {\n\t\t\treturn fmt.Errorf(\"HTTP status code: %d\", resp.StatusCode())\n\t\t}\n\n\t\t// Check the response body for errors\n\t\tif resp.Body()", "CodeBleu_score": 45.737031767482684}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar (\n\t\treq model.UmountStorageReq\n\t\terr error\n\t)\n\n\tif err = ctx.Bind(&req); err!= nil {\n\t\treturn httper.Error(ctx, err, common_err.ErrorInvalidParams)\n\t}\n\n\tif req.MountPoint == \"\" {\n\t\treturn httper.Error(ctx, err, common_err.ErrorInvalidParams)\n\t}\n\n\tif err = service.UmountStorage(req.MountPoint); err!= nil {\n\t\tlogger.Log.Error(\"Umount storage failed\", zap.Error(err))\n\t\treturn httper.Error(ctx, err, common_err.ErrorService)\n\t}\n\n\treturn httper.Success(ctx, \"umount storage success\")\n}", "CodeBleu_score": 24.341777033645723}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Get the request body\n\tvar req model.UmountStorageRequest\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn httper.Error(ctx, common_err.ErrBind, nil)\n\t}\n\n\t// Get the mount point\n\tmount_point := req.MountPoint\n\tif mount_point == \"\" {\n\t\treturn httper.Error(ctx, common_err.ErrMountPointEmpty, nil)\n\t}\n\n\t// Get the storage\n\tstorage, err := service.GetStorage(mount_point)\n\tif err!= nil {\n\t\treturn httper.Error(ctx, common_err.ErrStorageNotFound, nil)\n\t}\n\n\t// Get the storage driver\n\tvar driver model.StorageDriver\n\tswitch storage.Driver {\n\tcase model.StorageDriverDropbox:\n\t\tdriver = new(dropbox.Dropbox)\n\tcase model.StorageDriverGoogleDrive:\n\t\tdriver = new(google_drive.GoogleDrive)\n\tcase model.StorageDriverOneDrive:\n\t\tdriver = new(onedrive.OneDrive)\n\tdefault:\n\t\treturn httper.Error(ctx, common_err.ErrDriverNotFound, nil)\n\t}\n\n\t// Unmount the storage\n\tif err := driver.Umount(storage.MountPoint); err!= nil {\n\t\tlogger.Warn(\"Failed to unmount storage\", zap.Error(err))\n\t\treturn httper.Error(ctx, common_err.ErrUnmountStorage, nil)\n\t}\n\n\t// Delete the storage\n\tif err := service.DeleteStorage(mount_point); err!= nil {\n\t\tlogger.Warn(\"Failed to delete storage\", zap.Error(err))\n\t\treturn httper.Error(ctx, common_err.ErrDeleteStorage, nil)\n\t}\n\n\t// Return success\n\treturn httper.Success(ctx, nil)\n}", "CodeBleu_score": 38.990923814518645}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Get the request body\n\tvar req model.UmountStorageRequest\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn httper.Error(ctx, common_err.ErrInvalidParams, err)\n\t}\n\n\t// Get the storage configuration\n\tstorageConfig, err := service.GetStorageConfig(req.MountPoint)\n\tif err!= nil {\n\t\treturn httper.Error(ctx, common_err.ErrStorageConfigNotFound, err)\n\t}\n\n\t// Unmount the storage\n\tswitch storageConfig.Type {\n\tcase \"dropbox\":\n\t\terr = dropbox.Umount(storageConfig.Config)\n\tcase \"google_drive\":\n\t\terr = google_drive.Umount(storageConfig.Config)\n\tcase \"onedrive\":\n\t\terr = onedrive.Umount(storageConfig.Config)\n\tdefault:\n\t\treturn httper.Error(ctx, common_err.ErrStorageTypeNotSupported, nil)\n\t}\n\n\tif err!= nil {\n\t\tlogger.Error(ctx, \"Failed to unmount storage\", zap.Error(err))\n\t\treturn httper.Error(ctx, common_err.ErrStorageUnmountFailed, err)\n\t}\n\n\t// Delete the storage configuration\n\tif err := service.DeleteStorageConfig(req.MountPoint); err!= nil {\n\t\tlogger.Error(ctx, \"Failed to delete storage configuration\", zap.Error(err))\n\t\treturn httper.Error(ctx, common_err.ErrStorageConfigDeleteFailed, err)\n\t}\n\n\treturn httper.Success(ctx, nil)\n}", "CodeBleu_score": 36.99251434751579}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is empty\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"Missing file path\",\n\t\t})\n\t}\n\n\t// Check if the file exists\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"File not found\",\n\t\t})\n\t}\n\n\t// Read the file\n\tfileBytes, err := ioutil.ReadFile(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": \"Error reading file\",\n\t\t})\n\t}\n\n\t// Return the file as a response\n\treturn ctx.JSONBlob(http.StatusOK, fileBytes)\n}", "CodeBleu_score": 35.65876825632294}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided.\n\tif filePath == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Path is required\")\n\t}\n\n\t// Check if the file exists.\n\t_, err := os.Stat(filePath)\n\tif err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusNotFound, \"File not found\")\n\t}\n\n\t// Open the file.\n\tfile, err := os.Open(filePath)\n\tif err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Error opening file\")\n\t}\n\tdefer file.Close()\n\n\t// Get the file name from the path.\n\tfileName := filepath.Base(filePath)\n\n\t// Set the Content-Type header.\n\tctx.Response().Header().Set(echo.HeaderContentType, filetype.Detect(file).MIME.Value)\n\n\t// Set the Content-Disposition header.\n\tctx.Response().Header().Set(echo.HeaderContentDisposition, \"attachment; filename=\"+fileName)\n\n\t// Write the file to the response.\n\t_, err = io.Copy(ctx.Response().Writer, file)\n\tif err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Error writing file\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 35.343301698605224}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": \"File path is missing\",\n\t\t})\n\t}\n\n\t// Check if the file exists\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]interface{}{\n\t\t\t\"error\": \"File not found\",\n\t\t})\n\t}\n\n\t// Open the file\n\tfile, err := os.Open(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": \"Error opening file\",\n\t\t})\n\t}\n\tdefer file.Close()\n\n\t// Set the Content-Type header\n\tcontentType := http.DetectContentType(file)\n\tctx.Response().Header().Set(echo.HeaderContentType, contentType)\n\n\t// Copy the file to the response\n\t_, err = io.Copy(ctx.Response().Writer, file)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": \"Error copying file to response\",\n\t\t})\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 35.50574170228702}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message model.NotifyMessage\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequestError(err))\n\t}\n\terr := service.NotifyMessage(message)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.NewSuccessResponse(\"Notify message sent successfully.\"))\n}", "CodeBleu_score": 48.57415485180277}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\t// Bind the request body to a message map.\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequestError(err.Error()))\n\t}\n\t// Send the notification using the \"name\" and \"message\" from the message map.\n\tif err := service.SendNotifyMessage(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, model.SuccessResponse{Success: true, Message: \"Notification sent successfully.\"})\n}", "CodeBleu_score": 55.66953800010486}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message model.NotifyMessage\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\tif err := service.NotifyMessage(message); err!= nil {\n\t\treturn common_err.NewError(err)\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]string{\n\t\t\"message\": \"success\",\n\t})\n}", "CodeBleu_score": 36.37227712822422}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP GET request to a WebSocket connection.\n\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to a list of connections.\n\tconnections = append(connections, conn)\n\n\t// Ensure that the message sending service is running.\n\tgo send(conn)\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t// Read a message from the WebSocket connection.\n\t\tmt, message, err := conn.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Print the message type and message.\n\t\tfmt.Printf(\"recv: %s, %s\n\", message, mt)\n\n\t\t// Write a message to the WebSocket connection.\n\t\tif err := conn.WriteMessage(mt, message); err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n}", "CodeBleu_score": 43.245922572666494}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\t// \u8fde\u63a5\u6210\u529f\n\tfmt.Println(\"ws connected\")\n\t// \u76d1\u542c\u6d88\u606f\n\tfor {\n\t\tmsgType, msg, err := conn.ReadMessage()\n\t\tif err!= nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\t// \u53d1\u9001\u6d88\u606f\n\t\tif msgType == websocket.TextMessage {\n\t\t\tfmt.Println(\"Text Message: \", string(msg))\n\t\t} else if msgType == websocket.BinaryMessage {\n\t\t\tfmt.Println(\"Binary Message: \", string(msg))\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 35.867938838403084}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Create a new WebSocket connection\n\tconn, err := websocket.Upgrade(ctx.Response(), ctx.Request(), nil, 1024, 1024)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\t// Send a message to the WebSocket connection\n\terr = conn.WriteMessage(websocket.TextMessage, []byte(\"Hello, WebSocket!\"))\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Read messages from the WebSocket connection\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"Message Type: %s\nMessage: %s\nError: %v\n\", conn.MessageType(), message, err)\n\t}\n}", "CodeBleu_score": 42.93516020267604}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\tsystemHardwareInfo = &model.SystemHardwareInfo{}\n\t)\n\n\tsystemHardwareInfo.DriveModel = common.GetDriveModel()\n\tsystemHardwareInfo.Architecture = runtime.GOARCH\n\n\tif cpuInfo, err := common.GetCPUInfo(); err == nil {\n\t\tsystemHardwareInfo.CPUInfo = cpuInfo\n\t}\n\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 28.75258475622846}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\terr error\n\t\t// cpuInfo *model.CpuInfo\n\t\t// cpuInfo *model.CpuInfo\n\t\tcpuInfo *model2.CpuInfo\n\t\t// cpuInfo *model2.CpuInfo\n\t\thardwareInfo *model2.HardwareInfo\n\t)\n\n\t// cpuInfo, err = service.GetCpuInfo()\n\t// if err!= nil {\n\t// \treturn ctx.JSON(http.StatusOK, common_err.ErrGetCpuInfoFailed)\n\t// }\n\tcpuInfo, err = service.GetCpuInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.ErrGetCpuInfoFailed)\n\t}\n\thardwareInfo = &model2.HardwareInfo{\n\t\tArchitecture: runtime.GOARCH,\n\t\tModel:        cpuInfo.Model,\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.ErrSuccess(hardwareInfo))\n}", "CodeBleu_score": 31.16429730526673}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\thardwareInfo model.HardwareInfo\n\t\terr          error\n\t)\n\n\t// Get system hardware information\n\thardwareInfo, err = service.GetSystemHardwareInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.New(common_err.ERR_SYSTEM_HARDWARE_INFO_GET_FAILED, err.Error()))\n\t}\n\n\t// Return system hardware information\n\treturn ctx.JSON(http.StatusOK, common_err.New(common_err.SUCCESS, hardwareInfo))\n}", "CodeBleu_score": 21.869720824720225}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar services map[bool]*[]string\n\tservices = make(map[bool]*[]string)\n\tservices[true] = &[]string{}\n\tservices[false] = &[]string{}\n\tvar err error\n\tservicesList, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tfor _, service := range servicesList {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tstatus, err := systemctl.GetServiceStatus(service)\n\t\t\tif err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif status == \"active\" {\n\t\t\t\t*services[true] = append(*services[true], service)\n\t\t\t} else {\n\t\t\t\t*services[false] = append(*services[false], service)\n\t\t\t}\n\t\t}\n\t}\n\treturn services, nil\n}", "CodeBleu_score": 40.00456089384079}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tif systemctl.IsServiceRunning(service) {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue: &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 61.63188352558151}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]*[]string, 0)\n\tnotRunning := make([]*[]string, 0)\n\tfor _, service := range services {\n\t\tif service.Active {\n\t\t\trunning = append(running, &[]string{service.Name})\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, &[]string{service.Name})\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 65.61174338733468}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tif i.notify == nil {\n\t\treturn\n\t}\n\tvar data []byte\n\tif err := json.Unmarshal([]byte(fmt.Sprintf(\"%v\", message)), &data); err!= nil {\n\t\tlogger.Error(\"failed to marshal message\", zap.Error(err))\n\t\treturn\n\t}\n\ti.notify.Publish(name, data)\n}", "CodeBleu_score": 20.040533962185624}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tif err := i.bus.Publish(name, message); err!= nil {\n\t\tlogger.Error(\"failed to send notify\", zap.Error(err))\n\t}\n}", "CodeBleu_score": 13.26058662240853}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tif i.notifyChannel == nil {\n\t\treturn\n\t}\n\ti.notifyChannel <- &notify.Notify{\n\t\tName:    name,\n\t\tMessage: message,\n\t}\n}", "CodeBleu_score": 13.744677519761389}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Initialize the client\n\tclient := message_bus.NewClientWithResponses()\n\n\t// Get the address from the runtime path\n\taddress, err := external.GetAddressFromRuntimePath(c.config.RuntimePath)\n\tif err!= nil {\n\t\treturn nil\n\t}\n\n\t// Set the client's server\n\tclient.SetServer(address)\n\n\treturn client\n}", "CodeBleu_score": 31.650969845100953}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Get the message bus address from the config.\n\tmessageBusAddress := config.GetConfig().MessageBus.Address\n\t// If the message bus address is empty, set the message bus address to the default error message.\n\tif messageBusAddress == \"\" {\n\t\tmessageBusAddress = \"error\"\n\t}\n\t// Create a new message bus client with responses.\n\tclient := message_bus.NewClientWithResponses()\n\t// Attempt to retrieve the message bus address from the specified runtime path.\n\tif err := client.GetMessageBusAddress(messageBusAddress); err!= nil {\n\t\t// If an error occurs, set the client's server to the default error message.\n\t\tclient.Server = \"error\"\n\t}\n\t// Return the initialized client.\n\treturn client\n}", "CodeBleu_score": 34.4173169914353}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tif c.messageBus == nil {\n\t\tc.messageBus = message_bus.NewClientWithResponses(c.db, c.logger, c.config, c.cache)\n\t}\n\treturn c.messageBus\n}", "CodeBleu_score": 22.89571490628801}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"X-Forwarded-For\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.TrimSpace(strings.Split(ip, \",\")[0])\n\tif ip!= \"\" {\n\t\tip = strings.TrimPrefix(ip, \"::ffff:\")\n\t\tip = strings.TrimPrefix(ip, \"127.0.0.1\")\n\t}\n\treturn ip\n}", "CodeBleu_score": 56.764072777292185}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \":\")[0]\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 63.595567009199236}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"X-Forwarded-For\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.TrimSpace(strings.Split(ip, \",\")[0])\n\tif ip!= \"\" {\n\t\tip = strings.Split(ip, \":\")[0]\n\t}\n\tif strings.HasPrefix(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = strings.TrimPrefix(ip, \"::ffff:\")\n\t}\n\treturn ip\n}", "CodeBleu_score": 59.05585596675964}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the system entry file path\n\tentryFilePath := filepath.Join(config.Config.Module.ModuleDir, \"entry.json\")\n\n\t// Create a new file if it does not exist\n\tif!file.FileExists(entryFilePath) {\n\t\terr := file.CreateFile(entryFilePath)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read the existing entry file content\n\tcontent, err := file.ReadFile(entryFilePath)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Get the module directory path\n\tmoduleDir := config.Config.Module.ModuleDir\n\n\t// Get the entry file content as a JSON array\n\tvar entryFileArray []interface{}\n\tif len(content) > 0 {\n\t\tentryFileArray = gjson.Get(content, \"modules\").Array()\n\t}\n\n\t// Read each module directory for entry.json files\n\tmoduleDirList, err := file.ReadDir(moduleDir)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to read module directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\tfor _, moduleDir := range moduleDirList {\n\t\t// Skip non-module directories\n\t\tif!file.IsDir(filepath.Join(moduleDir, \"entry.json\")) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Read the entry.json file content\n\t\tmoduleEntryContent, err := file.ReadFile(filepath.Join(moduleDir, \"entry.json\"))\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"Failed to read entry.json file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Append the module entry content to the entry file array\n\t\tentryFileArray = append(entryFileArray, gjson.Get(moduleEntryContent, \"module\").String())\n\t}\n\n\t// Write the entry file content as a JSON array\n\terr = file.WriteFile(entryFilePath, fmt.Sprintf(`{\"modules\": [%s]}`, strings.Join(entryFileArray, \",\")))\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to write entry file\", zap.Error(", "CodeBleu_score": 50.633196689124645}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// 1. \u5b9a\u4e49\u7cfb\u7edf\u6a21\u5757\u8def\u5f84\n\tsysModulePath := filepath.Join(config.GlobalConfig.ModulePath, \"system\")\n\t// 2. \u5b9a\u4e49\u7cfb\u7edf\u6a21\u5757\u5165\u53e3\u6587\u4ef6\u8def\u5f84\n\tsysEntryFilePath := filepath.Join(config.GlobalConfig.ModulePath, \"system\", \"entry.json\")\n\t// 3. \u5b9a\u4e49\u7cfb\u7edf\u6a21\u5757\u5165\u53e3\u6587\u4ef6\n\tsysEntryFile, err := os.OpenFile(sysEntryFilePath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to open system entry file: %s\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer sysEntryFile.Close()\n\t// 4. \u5b9a\u4e49\u7cfb\u7edf\u6a21\u5757\u5165\u53e3\u6587\u4ef6\u5185\u5bb9\n\tsysEntryFileContent := []byte(\"[]\")\n\t// 5. \u904d\u5386\u7cfb\u7edf\u6a21\u5757\u76ee\u5f55\n\tsysModuleDirs, err := file.ListDir(sysModulePath)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to list system module directories: %s\", zap.Error(err))\n\t\treturn\n\t}\n\t// 6. \u904d\u5386\u7cfb\u7edf\u6a21\u5757\u76ee\u5f55\n\tfor _, sysModuleDir := range sysModuleDirs {\n\t\t// 7. \u5b9a\u4e49\u7cfb\u7edf\u6a21\u5757\u5165\u53e3\u6587\u4ef6\u8def\u5f84\n\t\tsysModuleEntryFilePath := filepath.Join(sysModulePath, sysModuleDir, \"entry.json\")\n\t\t// 8. \u5b9a\u4e49\u7cfb\u7edf\u6a21\u5757\u5165\u53e3\u6587\u4ef6\n\t\tsysModuleEntryFile, err := os.Open(sysModuleEntryFilePath)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"Failed to open system module entry file: %s\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdefer sysModuleEntryFile.Close()\n\t\t// 9. \u8bfb\u53d6\u7cfb\u7edf\u6a21\u5757\u5165\u53e3\u6587\u4ef6\u5185\u5bb9\n\t\tsysModuleEntryFileContent, err := io.ReadAll(sysModuleEntryFile)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"Failed to read system module entry file: %s\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\t// 10. \u5199\u5165\u7cfb\u7edf\u6a21\u5757\u5165\u53e3\u6587\u4ef6\u5185\u5bb9\n\t\tsysEntryFileContent = append(sysEntryFileContent, sysModuleEntryFileContent...)\n\t}\n\t// 11. \u5199\u5165", "CodeBleu_score": 39.020581397100095}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tlogger.Log.Info(\"GenreateSystemEntry start\")\n\tdefer logger.Log.Info(\"GenreateSystemEntry end\")\n\t// 1. get system entry file path\n\tentryFilePath := c.config.GetSystemEntryFilePath()\n\tif!file.IsExist(entryFilePath) {\n\t\tlogger.Log.Error(\"system entry file not exist\", zap.String(\"entryFilePath\", entryFilePath))\n\t\treturn\n\t}\n\t// 2. get system entry file content\n\tentryFileContent, err := file.Read(entryFilePath)\n\tif err!= nil {\n\t\tlogger.Log.Error(\"read system entry file error\", zap.Error(err))\n\t\treturn\n\t}\n\t// 3. get system entry file content to array\n\tvar entryFileContentArray []string\n\tif entryFileContent!= \"\" {\n\t\tentryFileContentArray = strings.Split(entryFileContent, \"", "CodeBleu_score": 32.25566798711903}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get a list of network interfaces.\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names from the system service.\n\tnames, err := host.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names.\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range names {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 65.06415469005888}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net2.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tif iface.Flags&net2.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif iface.Flags&net2.FlagLoopback!= 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\taddrs, err := iface.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net2.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net2.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net2.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue // not an ipv4 address\n\t\t\t}\n\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no non-loopback interface found\")\n}", "CodeBleu_score": 52.14216088887781}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tnetInterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, netInterface := range netInterfaces {\n\t\tif netInterface.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif netInterface.Flags&net.FlagLoopback!= 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\taddrs, err := netInterface.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net2.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue // not an ipv4 address\n\t\t\t}\n\t\t\treturn netInterface.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no valid interface found\")\n}", "CodeBleu_score": 53.309851462736646}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\n\tif (pRequest == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (pTscObj == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (pRequest->pRef == NULL) {\n\t\tpRequest->pRef = tRefNew();\n\n\t\tif (pRequest->pRef == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\ttRefIncr(pRequest->pRef);\n\n\tif (pTscObj->pRef == NULL) {\n\t\tpTscObj->pRef = tRefNew();\n\n\t\tif (pTscObj->pRef == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\ttRefIncr(pTscObj->pRef);\n\n\tif (pTscObj->pApp!= NULL) {\n\t\tif (pTscObj->pApp->pRef == NULL) {\n\t\t\tpTscObj->pApp->pRef = tRefNew();\n\n\t\t\tif (pTscObj->pApp->pRef == NULL) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\ttRefIncr(pTscObj->pApp->pRef);\n\n\t\tpTscObj->pApp->reqCount++;\n\n\t\tpTscObj->pApp->reqCountCur++;\n\t}\n\n\tif (pTscObj->pApp->pRef == NULL) {\n\t\tpTscObj->pApp->pRef = tRefNew();\n\n\t\tif (pTscObj->pApp->pRef == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\ttRefIncr(pTscObj->pApp->pRef);\n\n\tpTscObj->pApp->reqCount++;\n\n\tpTscObj->pApp->reqCountCur++;\n\n\ttLogDebug(\"registerRequest: new request, ref=%p, tscObj=%p, tscObj->ref=%p, tscObj->pApp=%p, tscObj->pApp->ref=%p, tscObj->pApp->reqCount=%d, tscObj->pApp->reqCountCur=%d\", pRequest->pRef, pTscObj, pTscObj->pRef, pTscObj->pApp, pTscObj->", "CodeBleu_score": 37.48212671692575}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t iRet = SUCCESS;\n\tint32_t i = 0;\n\tuint32_t uiReqCount = 0;\n\tuint32_t uiTotalReqCount = 0;\n\tuint32_t uiCurrentReqCount = 0;\n\tuint32_t uiTotalReqCountPrev = 0;\n\tuint32_t uiCurrentReqCountPrev = 0;\n\tuint32_t uiReqCountPrev = 0;\n\tuint32_t uiReqCountPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n\tuint32_t uiReqCountPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev", "CodeBleu_score": 5.287596484190764}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t iRet = 0;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (pRequest->pRef == NULL) {\n\t\tpRequest->pRef = tRefCreate(1);\n\t}\n\n\ttRefInc(pRequest->pRef);\n\n\tif (pTscObj->pRef == NULL) {\n\t\tpTscObj->pRef = tRefCreate(1);\n\t}\n\n\ttRefInc(pTscObj->pRef);\n\n\tif (pTscObj->pApp!= NULL) {\n\t\tpTscObj->pApp->totalRequests++;\n\t\tpTscObj->pApp->currentRequests++;\n\t}\n\n\tiRet = logDebug(\n\t\t\t\"Registering request with id %d and tsc object with id %d.\",\n\t\t\tpRequest->id, pTscObj->id);\n\n\treturn iRet;\n}", "CodeBleu_score": 38.95494840377585}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *db = NULL;\n\tchar *schema = NULL;\n\tbool found = false;\n\tint i;\n\n\tif (pRequest->db == NULL) {\n\t\treturn false;\n\t}\n\n\tif (strcmp(pRequest->db, exceptDb) == 0) {\n\t\treturn false;\n\t}\n\n\tdb = pRequest->db;\n\tschema = db;\n\tfor (i = 0; i < strlen(schema); i++) {\n\t\tif (schema[i] == '.') {\n\t\t\tschema[i] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (strcmp(db, exceptDb) == 0) {\n\t\treturn false;\n\t}\n\n\tif (strcmp(schema, exceptDb) == 0) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 52.786771958983294}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb = NULL;\n\tbool found = false;\n\n\tif (pRequest->pPrimaryDb!= NULL && strcmp(pRequest->pPrimaryDb, exceptDb)!= 0) {\n\t\tfound = true;\n\t} else {\n\t\tpDb = pRequest->pDb;\n\t\twhile (pDb!= NULL &&!found) {\n\t\t\tif (strcmp(pDb, exceptDb)!= 0) {\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tpDb = pDb->pDbNext;\n\t\t}\n\t}\n\treturn found;\n}", "CodeBleu_score": 40.06666252634573}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->pPrimaryDb!= NULL && strcmp(pRequest->pPrimaryDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->pDb!= NULL && strcmp(pRequest->pDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->pSchema!= NULL && strcmp(pRequest->pSchema, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->pTable!= NULL && strcmp(pRequest->pTable, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->pView!= NULL && strcmp(pRequest->pView, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->pFunction!= NULL && strcmp(pRequest->pFunction, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 32.26610122035033}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TERR_NO_ERROR) {\n\t\treturn false;\n\t} else if (code == TERR_REDIRECT_TO_MASTER) {\n\t\tif (msgType == TMSG_TYPE_QUERY || msgType == TMSG_TYPE_QUERY_RESULT || msgType == TMSG_TYPE_QUERY_RESULT_END || msgType == TMSG_TYPE_QUERY_RESULT_ERROR) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else if (code == TERR_REDIRECT_TO_SLAVE) {\n\t\tif (msgType == TMSG_TYPE_QUERY || msgType == TMSG_TYPE_QUERY_RESULT || msgType == TMSG_TYPE_QUERY_RESULT_END || msgType == TMSG_TYPE_QUERY_RESULT_ERROR) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 52.52523777577993}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool ret = false;\n\n\tif (code == T_RPC_E_REDIRECT) {\n\t\tswitch (msgType) {\n\t\tcase TMSG_TYPE_RPC_REQUEST:\n\t\tcase TMSG_TYPE_RPC_RESPONSE:\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 29.535603493656364}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool ret = false;\n\n\tif (code == 20000) {\n\t\tswitch (msgType) {\n\t\tcase MSG_TYPE_CREATE_SESSION:\n\t\tcase MSG_TYPE_CREATE_SESSION_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_HEARTBEAT:\n\t\tcase MSG_TYPE_SESSION_HEARTBEAT_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_DISCONNECT:\n\t\tcase MSG_TYPE_SESSION_DISCONNECT_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_DISCONNECT_NOTIFY:\n\t\tcase MSG_TYPE_SESSION_DISCONNECT_NOTIFY_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_RECONNECT:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_ACK:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_ACK_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_ACK_NOTIFY:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_ACK_NOTIFY_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_NOTIFY:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_NOTIFY_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_NOTIFY_ACK:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_NOTIFY_ACK_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_NOTIFY_ACK_NOTIFY:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_NOTIFY_ACK_NOTIFY_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_NOTIFY_ACK_NOTIFY_ACK:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_NOTIFY_ACK_NOTIFY_ACK_RESPONSE:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_NOTIFY_ACK_NOTIFY_ACK_NOTIFY:\n\t\tcase MSG_TYPE_SESSION_RECONNECT_NOTIFY_ACK_NOTIFY_", "CodeBleu_score": 21.777489674430132}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i;\n\tint j;\n\tint k;\n\tint l;\n\tint m;\n\tint n;\n\tint o;\n\tint p;\n\tint q;\n\tint r;\n\tint s;\n\tint t;\n\tint u;\n\tint v;\n\tint w;\n\tint x;\n\tint y;\n\tint z;\n\tint aa;\n\tint ab;\n\tint ac;\n\tint ad;\n\tint ae;\n\tint af;\n\tint ag;\n\tint ah;\n\tint ai;\n\tint aj;\n\tint ak;\n\tint al;\n\tint am;\n\tint an;\n\tint ao;\n\tint ap;\n\tint aq;\n\tint ar;\n\tint as;\n\tint at;\n\tint au;\n\tint av;\n\tint aw;\n\tint ax;\n\tint ay;\n\tint az;\n\tint ba;\n\tint bb;\n\tint bc;\n\tint bd;\n\tint be;\n\tint bf;\n\tint bg;\n\tint bh;\n\tint bi;\n\tint bj;\n\tint bk;\n\tint bl;\n\tint bm;\n\tint bn;\n\tint bo;\n\tint bp;\n\tint bq;\n\tint br;\n\tint bs;\n\tint bt;\n\tint bu;\n\tint bv;\n\tint bw;\n\tint bx;\n\tint by;\n\tint bz;\n\tint ca;\n\tint cb;\n\tint cc;\n\tint cd;\n\tint ce;\n\tint cf;\n\tint cg;\n\tint ch;\n\tint ci;\n\tint cj;\n\tint ck;\n\tint cl;\n\tint cm;\n\tint cn;\n\tint co;\n\tint cp;\n\tint cq;\n\tint cr;\n\tint cs;\n\tint ct;\n\tint cu;\n\tint cv;\n\tint cw;\n\tint cx;\n\tint cy;\n\tint cz;\n\tint da;\n\tint db;\n\tint dc;\n\tint dd;\n\tint de;\n\tint", "CodeBleu_score": 4.572150107394267}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSRequest *pRequest = NULL;\n\tSQuery *pQuery = NULL;\n\tSQuery *pQuery2 = NULL;\n\tSQuery *pQuery3 = NULL;\n\tSQuery *pQuery4 = NULL;\n\tSQuery *pQuery5 = NULL;\n\tSQuery *pQuery6 = NULL;\n\tSQuery *pQuery7 = NULL;\n\tSQuery *pQuery8 = NULL;\n\tSQuery *pQuery9 = NULL;\n\tSQuery *pQuery10 = NULL;\n\tSQuery *pQuery11 = NULL;\n\tSQuery *pQuery12 = NULL;\n\tSQuery *pQuery13 = NULL;\n\tSQuery *pQuery14 = NULL;\n\tSQuery *pQuery15 = NULL;\n\tSQuery *pQuery16 = NULL;\n\tSQuery *pQuery17 = NULL;\n\tSQuery *pQuery18 = NULL;\n\tSQuery *pQuery19 = NULL;\n\tSQuery *pQuery20 = NULL;\n\tSQuery *pQuery21 = NULL;\n\tSQuery *pQuery22 = NULL;\n\tSQuery *pQuery23 = NULL;\n\tSQuery *pQuery24 = NULL;\n\tSQuery *pQuery25 = NULL;\n\tSQuery *pQuery26 = NULL;\n\tSQuery *pQuery27 = NULL;\n\tSQuery *pQuery28 = NULL;\n\tSQuery *pQuery29 = NULL;\n\tSQuery *pQuery30 = NULL;\n\tSQuery *pQuery31 = NULL;\n\tSQuery *pQuery32 = NULL;\n\tSQuery *pQuery33 = NULL;\n\tSQuery *pQuery34 = NULL;\n\tSQuery *pQuery35 = NULL;\n\tSQuery *pQuery36 = NULL;\n\tSQuery *pQuery37 = NULL;\n\tSQuery *pQuery38 = NULL;\n\tSQuery *pQuery39 = NULL;\n\tSQuery *pQuery40 = NULL;\n\tSQuery *pQuery41 = NULL;\n\tSQuery *pQuery42 = NULL;\n\tSQuery *pQuery43", "CodeBleu_score": 7.008734037647721}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i;\n\tint j;\n\tint k;\n\tint l;\n\tint m;\n\tint n;\n\tint o;\n\tint p;\n\tint q;\n\tint r;\n\tint s;\n\tint t;\n\tint u;\n\tint v;\n\tint w;\n\tint x;\n\tint y;\n\tint z;\n\tint aa;\n\tint ab;\n\tint ac;\n\tint ad;\n\tint ae;\n\tint af;\n\tint ag;\n\tint ah;\n\tint ai;\n\tint aj;\n\tint ak;\n\tint al;\n\tint am;\n\tint an;\n\tint ao;\n\tint ap;\n\tint aq;\n\tint ar;\n\tint as;\n\tint at;\n\tint au;\n\tint av;\n\tint aw;\n\tint ax;\n\tint ay;\n\tint az;\n\tint ba;\n\tint bb;\n\tint bc;\n\tint bd;\n\tint be;\n\tint bf;\n\tint bg;\n\tint bh;\n\tint bi;\n\tint bj;\n\tint bk;\n\tint bl;\n\tint bm;\n\tint bn;\n\tint bo;\n\tint bp;\n\tint bq;\n\tint br;\n\tint bs;\n\tint bt;\n\tint bu;\n\tint bv;\n\tint bw;\n\tint bx;\n\tint by;\n\tint bz;\n\tint ca;\n\tint cb;\n\tint cc;\n\tint cd;\n\tint ce;\n\tint cf;\n\tint cg;\n\tint ch;\n\tint ci;\n\tint cj;\n\tint ck;\n\tint cl;\n\tint cm;\n\tint cn;\n\tint co;\n\tint cp;\n\tint cq;\n\tint cr;\n\tint cs;\n\tint ct;\n\tint cu;\n\tint cv;\n\tint cw;\n\tint cx;\n\tint cy;\n\tint cz;\n\tint da;\n\tint db;\n\tint dc;\n\tint dd;\n\tint de;\n\tint", "CodeBleu_score": 4.572150107394267}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tscIsCrashReportingEnabled()) {\n\t\treturn;\n\t}\n\tint32_t clientStop = 1;\n\tif (atomic_compare_exchange_strong(&tscClientStopFlag, &clientStop, 0) == 0) {\n\t\ttscLogMessage(TSC_LOG_ERROR, \"Crash report thread already stopped.\");\n\t\treturn;\n\t}\n\twhile (tscClientStopFlag == 1) {\n\t\ttscSleep(1000);\n\t}\n}", "CodeBleu_score": 41.89887424631606}, {"code": "void tscStopCrashReport(){\n\t\tif (g_crashReportEnabled == 1) {\n\t\tif (atomic_compare_exchange_strong(&g_clientStop, 1, 0) == 1) {\n\t\t\twhile (g_clientStop == 1) {\n\t\t\t\tosSleep(1000);\n\t\t\t}\n\t\t} else {\n\t\t\ttlog(TLOG_ERROR, \"crash report thread is already stopped\");\n\t\t}\n\t}\n}", "CodeBleu_score": 40.15386432928057}, {"code": "void tscStopCrashReport(){\n\t\tif (g_crashReportEnabled) {\n\t\tint result = atomic_compare_exchange_strong(&g_clientStop, 0, 1);\n\t\tif (result == 0) {\n\t\t\tLOG_WARN(\"Crash report thread already stopped\");\n\t\t\treturn;\n\t\t}\n\t\twhile (g_clientStop) {\n\t\t\tosSleep(1000);\n\t\t}\n\t}\n}", "CodeBleu_score": 53.01233614891135}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t ret = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t numViews = 0;\n\tint32_t numCols = 0;\n\tint32_t numColsInView = 0;\n\tint32_t numColsInViewInCatalog = 0;\n\tint32_t numColsInViewNotInCatalog = 0;\n\tint32_t numColsInCatalog = 0;\n\tint32_t numColsNotInCatalog = 0;\n\tint32_t numColsInCatalogNotInView = 0;\n\tint32_t numColsNotInCatalogInView = 0;\n\tint32_t numColsInCatalogInView = 0;\n\tint32_t numColsNotInCatalogNotInView = 0;\n\tint32_t numColsInCatalogNotInView = 0;\n\tint32_t numColsNotInCatalogInView = 0;\n\tint32_t numColsInCatalogInView = 0;\n\tint32_t numColsNotInCatalogNotInView = 0;\n\tint32_t numColsInCatalogNotInView = 0;\n\tint32_t numColsNotInCatalogInView = 0;\n\tint32_t numColsInCatalogInView = 0;\n\tint32_t numColsNotInCatalogNotInView = 0;\n\tint32_t numColsInCatalogNotInView = 0;\n\tint32_t numColsNotInCatalogInView = 0;\n\tint32_t numColsInCatalogInView = 0;\n\tint32_t numColsNotInCatalogNotInView = 0;\n\tint32_t numColsInCatalogNotInView = 0;\n\tint32_t numColsNotInCatalogInView = 0;\n\tint32_t numColsInCatalogInView = 0;\n\tint32_t numColsNotInCatalogNotInView = 0;\n\tint32_t numColsInCatalogNotInView = 0;\n\tint32_t numColsNotInCatalogInView = ", "CodeBleu_score": 8.92457054648046}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = 0;\n\tstruct SViewInfoRsp *pViewInfoRsp = (struct SViewInfoRsp *) value;\n\tstruct SViewInfo *pViewInfo = NULL;\n\tstruct SViewInfo *pViewInfoTemp = NULL;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t numViews = 0;\n\tint32_t numCols = 0;\n\tint32_t numColsTemp = 0;\n\tint32_t numColsNew = 0;\n\tint32_t numColsOld = 0;\n\tint32_t numColsDiff = 0;\n\tint32_t numColsDiffNew = 0;\n\tint32_t numColsDiffOld = 0;\n\tint32_t numColsDiffTemp = 0;\n\tint32_t numColsDiffTempNew = 0;\n\tint32_t numColsDiffTempOld = 0;\n\tint32_t numColsDiffTempNew = 0;\n\tint32_t numColsDiffTempOld = 0;\n\tint32_t numColsDiffTempNew = 0;\n\tint32_t numColsDiffTempOld = 0;\n\tint32_t numColsDiffTempNew = 0;\n\tint32_t numColsDiffTempOld = 0;\n\tint32_t numColsDiffTempNew = 0;\n\tint32_t numColsDiffTempOld = 0;\n\tint32_t numColsDiffTempNew = 0;\n\tint32_t numColsDiffTempOld = 0;\n\tint32_t numColsDiffTempNew = 0;\n\tint32_t numColsDiffTempOld = 0;\n\tint32_t numColsDiffTempNew = 0;\n\tint32_t numColsDiffTempOld = 0;\n\tint32_t numColsDiffTempNew = 0;\n\tint32_t numColsDiffTempOld = 0;\n", "CodeBleu_score": 9.257754870104266}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc;\n\tint32_t i;\n\tint32_t numViews;\n\tstruct SViewInfo *pViewInfo;\n\tstruct SViewInfo *pViewInfoArray;\n\tstruct SViewInfo *pViewInfoArrayEnd;\n\tstruct SViewInfo *pViewInfoArrayStart;\n\tint32_t *pViewInfoArrayLen;\n\tint32_t *pViewInfoArrayLenEnd;\n\tint32_t *pViewInfoArrayLenStart;\n\tint32_t *pViewInfoArrayLenLen;\n\tint32_t *pViewInfoArrayLenLenEnd;\n\tint32_t *pViewInfoArrayLenLenStart;\n\tint32_t *pViewInfoArrayLenLenLen;\n\tint32_t *pViewInfoArrayLenLenLenEnd;\n\tint32_t *pViewInfoArrayLenLenLenStart;\n\tint32_t *pViewInfoArrayLenLenLenLen;\n\tint32_t *pViewInfoArrayLenLenLenLenEnd;\n\tint32_t *pViewInfoArrayLenLenLenLenStart;\n\tint32_t *pViewInfoArrayLenLenLenLenLen;\n\tint32_t *pViewInfoArrayLenLenLenLenLenEnd;\n\tint32_t *pViewInfoArrayLenLenLenLenLenStart;\n\tint32_t *pViewInfoArrayLenLenLenLenLenLen;\n\tint32_t *pViewInfoArrayLenLenLenLenLenLenEnd;\n\tint32_t *pViewInfoArrayLenLenLenLenLenLenStart;\n\tint32_t *pViewInfoArrayLenLenLenLenLenLenLen;\n\tint32_t *pViewInfoArrayLenLenLenLenLenLenLenEnd;\n\tint32_t *pViewInfoArrayLenLenLenLenLenLenLenStart;\n\tint32_t *pViewInfoArrayLenLenLenLenLenLenLenLen;\n\tint32_t *pViewInfoArrayLenLenLenLenLenLenLenLenEnd;\n\tint32_t *pViewInfoArrayLenLenLenLenLenLenLenLenStart;", "CodeBleu_score": 7.025382526268589}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tint64_t *contentLength = (int64_t *) callbackData;\n\tif (properties->contentLength > 0) {\n\t\t*contentLength = properties->contentLength;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 63.4682014015604}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3ResponsePropertiesCallbackData *data = (S3ResponsePropertiesCallbackData *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 61.76551901051568}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tint64_t *contentLength = (int64_t *)callbackData;\n\tif (properties->contentLength > 0) {\n\t\t*contentLength = properties->contentLength;\n\t} else {\n\t\t*contentLength = 0;\n\t}\n\treturn status;\n}", "CodeBleu_score": 65.274507368058}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\t// Create checkpoint backup directory\n\tif (mkdir(CHECKPOINT_BACKUP_DIR, 0777) < 0) {\n\t\t// Error creating checkpoint backup directory\n\t\tfprintf(stderr, \"Error creating checkpoint backup directory: %s\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\t// Remove empty directories\n\tremoveEmptyDirectories(CHECKPOINT_BACKUP_DIR);\n\n\t// Generate Rsync configuration file\n\tif (generateRsyncConfigFile() < 0) {\n\t\t// Error generating Rsync configuration file\n\t\tfprintf(stderr, \"Error generating Rsync configuration file: %s\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\t// Construct and execute Rsync command\n\tchar *rsyncCmd = malloc(sizeof(char) * (strlen(RSYNC_CMD) + strlen(RSYNC_CONF_FILE) + strlen(CHECKPOINT_BACKUP_DIR) + 2));\n\tstrcpy(rsyncCmd, RSYNC_CMD);\n\tstrcat(rsyncCmd, \" \");\n\tstrcat(rsyncCmd, RSYNC_CONF_FILE);\n\tstrcat(rsyncCmd, \" \");\n\tstrcat(rsyncCmd, CHECKPOINT_BACKUP_DIR);\n\tstrcat(rsyncCmd, \" \");\n\tstrcat(rsyncCmd, RSYNC_PORT);\n\n\tint rsyncRet = system(rsyncCmd);\n\n\t// Log whether Rsync server started successfully or if it encountered an error\n\tif (rsyncRet == 0) {\n\t\tfprintf(stderr, \"Rsync server started successfully\n\");\n\t} else {\n\t\tfprintf(stderr, \"Error starting Rsync server: %s\n\", strerror(errno));\n\t}\n\n\tfree(rsyncCmd);\n}", "CodeBleu_score": 34.86011836908274}, {"code": "void startRsync(){\n\t\t// Initialize variables\n\tchar *rsync_dir = NULL;\n\tchar *rsync_conf = NULL;\n\tchar *rsync_cmd = NULL;\n\tchar *rsync_port = NULL;\n\tchar *rsync_pid = NULL;\n\tchar *rsync_log = NULL;\n\tchar *rsync_path = NULL;\n\tchar *rsync_path_log = NULL;\n\tchar *rsync_path_conf = NULL;\n\tchar *rsync_path_pid = NULL;\n\tchar *rsync_path_port = NULL;\n\tchar *rsync_path_dir = NULL;\n\tchar *rsync_path_dir_log = NULL;\n\tchar *rsync_path_dir_conf = NULL;\n\tchar *rsync_path_dir_pid = NULL;\n\tchar *rsync_path_dir_port = NULL;\n\n\t// Get the path to the Rsync server\n\trsync_path = getRsyncPath();\n\tif (rsync_path == NULL) {\n\t\tLOG_ERROR(\"Failed to get the path to the Rsync server.\");\n\t\treturn;\n\t}\n\n\t// Get the path to the Rsync server's directory\n\trsync_path_dir = getRsyncPathDir();\n\tif (rsync_path_dir == NULL) {\n\t\tLOG_ERROR(\"Failed to get the path to the Rsync server's directory.\");\n\t\treturn;\n\t}\n\n\t// Get the path to the Rsync server's directory's log file\n\trsync_path_dir_log = getRsyncPathDirLog();\n\tif (rsync_path_dir_log == NULL) {\n\t\tLOG_ERROR(\"Failed to get the path to the Rsync server's directory's log file.\");\n\t\treturn;\n\t}\n\n\t// Get the path to the Rsync server's directory's configuration file\n\trsync_path_dir_conf = getRsyncPathDirConf();\n\tif (rsync_path_dir_conf == NULL) {\n\t\tLOG_ERROR(\"Failed to get the path to the Rsync server's directory's configuration file.\");\n\t\treturn;\n\t}\n\n\t// Get the path to the Rsync server's directory's PID file\n\trsync_", "CodeBleu_score": 12.170533706661587}, {"code": "void startRsync(){\n\t\tint ret;\n\tchar *rsyncConf;\n\tchar *rsyncConfPath;\n\tchar *rsyncConfDir;\n\tchar *rsyncConfFile;\n\tchar *rsyncConfFilepath;\n\tchar *rsyncConfFilepath2;\n\tchar *rsyncConfFilepath3;\n\tchar *rsyncConfFilepath4;\n\tchar *rsyncConfFilepath5;\n\tchar *rsyncConfFilepath6;\n\tchar *rsyncConfFilepath7;\n\tchar *rsyncConfFilepath8;\n\tchar *rsyncConfFilepath9;\n\tchar *rsyncConfFilepath10;\n\tchar *rsyncConfFilepath11;\n\tchar *rsyncConfFilepath12;\n\tchar *rsyncConfFilepath13;\n\tchar *rsyncConfFilepath14;\n\tchar *rsyncConfFilepath15;\n\tchar *rsyncConfFilepath16;\n\tchar *rsyncConfFilepath17;\n\tchar *rsyncConfFilepath18;\n\tchar *rsyncConfFilepath19;\n\tchar *rsyncConfFilepath20;\n\tchar *rsyncConfFilepath21;\n\tchar *rsyncConfFilepath22;\n\tchar *rsyncConfFilepath23;\n\tchar *rsyncConfFilepath24;\n\tchar *rsyncConfFilepath25;\n\tchar *rsyncConfFilepath26;\n\tchar *rsyncConfFilepath27;\n\tchar *rsyncConfFilepath28;\n\tchar *rsyncConfFilepath29;\n\tchar *rsyncConfFilepath30;\n\tchar *rsyncConfFilepath31;\n\tchar *rsyncConfFilepath32;\n\tchar *rsyncConfFilepath33;\n\tchar *rsyncConfFilepath34;\n\tchar *rsyncConfFilepath35;\n\tchar *rsyncConfFilepath36;\n\tchar *rsyncConfFilepath37;\n\tchar *rsyncConfFilepath38;\n\tchar *rsyncConfFilepath39;\n\tchar *rsyncConfFilepath40;\n\tchar", "CodeBleu_score": 2.4732529129601546}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t}", "CodeBleu_score": 2.950171161196606}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t}", "CodeBleu_score": 2.950171161196606}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t}", "CodeBleu_score": 2.950171161196606}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t final Set<TbActorId> children = getChildren(parent);\n final List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n for (TbActorId child : filteredChildren) {\n if (highPriority) {\n try {\n actorService.sendHighPriorityMessage(child, msg);\n } catch (Exception e) {\n log.error(\"Error sending high priority message to child actor [{}]\", child, e);\n }\n } else {\n try {\n actorService.sendMessage(child, msg);\n } catch (Exception e) {\n log.error(\"Error sending message to child actor [{}]\", child, e);\n }\n }\n }\n }", "CodeBleu_score": 38.85699497281252}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t//        final Set<TbActorId> children = getChildren(parent);\n//        for (TbActorId child : children) {\n//            if (childFilter.test(child)) {\n//                try {\n//                    if (highPriority) {\n//                        getActor(child).send(msg, TbActorMsg.Priority.HIGH);\n//                    } else {\n//                        getActor(child).send(msg, TbActorMsg.Priority.NORMAL);\n//                    }\n//                } catch (Exception e) {\n//                    log.warn(\"Failed to send message to child actor {}\", child, e);\n//                }\n//            }\n//        }\n    }", "CodeBleu_score": 13.466092382761225}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t//    log.info(\"Broadcasting message to children of {}: {}\", parent, msg);\n    final Set<TbActorId> children = getChildren(parent);\n    if (children == null) {\n        log.warn(\"No children found for parent actor: {}\", parent);\n        return;\n    }\n    final List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n    if (filteredChildren.isEmpty()) {\n        log.info(\"No children found for parent actor: {} that match the filter: {}\", parent, childFilter);\n        return;\n    }\n    final ExecutorService executor = highPriority? highPriorityExecutor : lowPriorityExecutor;\n    final Lock lock = highPriority? highPriorityLock : lowPriorityLock;\n    for (TbActorId child : filteredChildren) {\n        executor.execute(() -> {\n            try {\n                lock.lock();\n                sendToChild(child, msg);\n            } finally {\n                lock.unlock();\n            }\n        });\n    }\n}", "CodeBleu_score": 42.30243213431223}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (destroyed.get()) {\n\t\tif (msg.getType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\tif (initFailed.get()) {\n\t\t\t\tlog.warn(\"Actor {} failed to initialize, trying to reinitialize\", getName());\n\t\t\t\tinit();\n\t\t\t} else {\n\t\t\t\tlog.warn(\"Actor {} is destroyed, not processing message\", getName());\n\t\t\t\tmsg.notifyActorStopped(TbActorStopReason.ACTOR_STOPPED_BY_DESTRUCTION);\n\t\t\t}\n\t\t} else {\n\t\t\tlog.warn(\"Actor {} is destroyed, not processing message\", getName());\n\t\t\tmsg.notifyActorStopped(TbActorStopReason.ACTOR_STOPPED_BY_DESTRUCTION);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (highPriority) {\n\t\thighPriorityMsgs.add(msg);\n\t} else {\n\t\tnormalPriorityMsgs.add(msg);\n\t}\n\n\tif (!processing) {\n\t\tprocessing = true;\n\t\tprocessQueue();\n\t}\n}", "CodeBleu_score": 53.43829261532059}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (destroyed.get()) {\n\t\tif (msg.getType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\tif (initFailed.get()) {\n\t\t\t\tinitFailed.set(false);\n\t\t\t\tinit();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmsg.setActorStoppedReason(TbActorStopReason.DESTROYED);\n\t\t\tmsg.setActorStopped(true);\n\t\t\tmsg.setActorError(new TbActorError(\"Actor is destroyed\"));\n\t\t\tnotifyMsg(msg);\n\t\t}\n\t\treturn;\n\t}\n\tif (highPriority) {\n\t\thighPriorityMsgs.add(msg);\n\t}\n\telse {\n\t\tnormalPriorityMsgs.add(msg);\n\t}\n\tif (!processing) {\n\t\tprocessing = true;\n\t\tprocessQueue();\n\t}\n}", "CodeBleu_score": 50.56370620083519}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroyed.get()) {\nif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\nreinitialize();\n} else {\nnotifyActorStopped(msg, TbActorStopReason.DESTRUCTED);\n}\n} else {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\nif (processing) {\nprocessQueue();\n} else {\nprocessing = true;\nprocessQueue();\n}\n}\n}", "CodeBleu_score": 42.195463226435464}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t\tif (this.mailbox.isEmpty()) {\n\t\tthis.status = ActorStatus.FREE;\n\t\tthis.mailboxProcessingScheduled = false;\n\t\tthis.mailboxProcessingScheduledAt = 0L;\n\t\treturn;\n\t}\n\tif (this.mailbox.size() > 0) {\n\t\tthis.status = ActorStatus.BUSY;\n\t}\n\ttry {\n\t\tfor (int i = 0; i < this.mailbox.size(); i++) {\n\t\t\tTbActorMsg msg = this.mailbox.poll();\n\t\t\tif (msg == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (msg.getPriority() == MsgPriority.HIGH) {\n\t\t\t\tprocessHighPriorityMessage(msg);\n\t\t\t} else {\n\t\t\t\tprocessNormalPriorityMessage(msg);\n\t\t\t}\n\t\t\tif (this.mailbox.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} catch (Exception e) {\n\t\tthis.status = ActorStatus.FREE;\n\t\tthis.mailboxProcessingScheduled = false;\n\t\tthis.mailboxProcessingScheduledAt = 0L;\n\t\tif (this.processFailureStrategy == ProcessFailureStrategy.STOP_ACTOR) {\n\t\t\tthis.stopReason = TbActorStopReason.PROCESS_FAILURE;\n\t\t\tdestroy();\n\t\t\treturn;\n\t\t}\n\t\tif (this.processFailureStrategy == ProcessFailureStrategy.LOG_FAILURE) {\n\t\t\tlog.error(\"Actor {} failed to process message {}\", this.actorId, e);\n\t\t\treturn;\n\t\t}\n\t\tif (this.processFailureStrategy == ProcessFailureStrategy.RETRY) {\n\t\t\tthis.mailbox.add(msg);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (this.mailbox.isEmpty()) {\n\t\tthis.status = ActorStatus.FREE;\n\t}\n\tif (!this.mailboxProcessingScheduled) {\n\t\tthis.mailboxProcessingScheduled = true;\n\t\tthis.mailboxProcessingScheduledAt = System.currentTimeMillis() + this.mailboxProcessingDelayMs;\n\t\tthis.mailboxProcessingScheduledAt = Math.min(this.mailboxProcessingScheduledAt, System.currentTimeMillis() + this.mailboxProcessingMaxDelayMs);\n\t\tthis.mailboxProcessingScheduledAt = Math.max(this.mailboxProcessingScheduledAt, System.currentTimeMillis() + this.mailboxProcessingMinDelayMs);\n\t\tthis.mailboxProcessingScheduledAt", "CodeBleu_score": 31.001510655771447}, {"code": "private void processMailbox(){\n\t\twhile (true) {\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\ttry {\n\t\t\t\tpauseCondition.await();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlog.error(\"InterruptedException in processMailbox\", e);\n\t\t\t}\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t", "CodeBleu_score": 10.833147060750221}, {"code": "private void processMailbox(){\n\t\ttry {\n\t\t// Process high priority messages\n\t\tif (processHighPriorityMessages()) {\n\t\t\treturn;\n\t\t}\n\t\t// Process normal priority messages\n\t\tif (processNormalPriorityMessages()) {\n\t\t\treturn;\n\t\t}\n\t\t// If there are no more messages, set the actor's status to free and schedule a queue processing attempt\n\t\tif (highPriorityMailbox.isEmpty() && normalPriorityMailbox.isEmpty()) {\n\t\t\tsetStatus(ActorStatus.FREE);\n\t\t\tscheduleQueueProcessingAttempt();\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing the mailbox\n\t\tprocessMailbox();\n\t} catch (Exception e) {\n\t\t// If an exception occurs, set the actor's stop reason and destroy the actor\n\t\tsetStopReason(new TbActorError(e));\n\t\tdestroy();\n\t}\n}", "CodeBleu_score": 9.093058752511611}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (cause == null) {\n\t\tthrow new IllegalArgumentException(\"Cause is null\");\n\t}\n\tif (stopReason!= null) {\n\t\tthrow new IllegalStateException(\"Actor already destroyed\");\n\t}\n\tstopReason = TbActorStopReason.cause(cause);\n\tif (isDestroyed.compareAndSet(false, true)) {\n\t\tif (destroyFuture == null) {\n\t\t\tdestroyFuture = new CompletableFuture<>();\n\t\t}\n\t\ttry {\n\t\t\tdispatcher.submit(() -> {\n\t\t\t\ttry {\n\t\t\t\t\treadiness.set(false);\n\t\t\t\t\tdestroy(stopReason);\n\t\t\t\t\tnotifyAllQueuedMessages();\n\t\t\t\t} catch (Throwable cause2) {\n\t\t\t\t\tlog.warn(\"Exception during actor destroy\", cause2);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (RejectedExecutionException e) {\n\t\t\tlog.warn(\"Exception during actor destroy\", e);\n\t\t}\n\t}\n}", "CodeBleu_score": 32.32928347822218}, {"code": "public void destroy(Throwable cause){\n\t\tif (cause == null) {\n\t\tthrow new NullPointerException(\"Cause cannot be null\");\n\t}\n\tif (cause.getMessage() == null) {\n\t\tcause.initCause(cause);\n\t}\n\tif (stopReason!= null) {\n\t\treturn;\n\t}\n\tstopReason = TbActorStopReason.DESTROY;\n\tstopCause = cause;\n\tready.set(false);\n\tif (log.isDebugEnabled()) {\n\t\tlog.debug(\"Actor {} is being destroyed\", name);\n\t}\n\tif (dispatcher!= null) {\n\t\tdispatcher.execute(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tdestroy(stopReason, stopCause);\n\t\t\t\t\tnotifyAllMessages();\n\t\t\t\t} catch (Throwable cause) {\n\t\t\t\t\tlog.warn(\"Exception during actor {} destruction: {}\", name, cause.getMessage(), cause);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} else {\n\t\tdestroy(stopReason, stopCause);\n\t\tnotifyAllMessages();\n\t}\n}", "CodeBleu_score": 36.28017280032371}, {"code": "public void destroy(Throwable cause){\n\t\tif (cause == null) {\n\t\tthrow new NullPointerException(\"The cause is null\");\n\t}\n\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.DESTROY;\n\t}\n\tif (destroyInProgress.compareAndSet(false, true)) {\n\t\ttry {\n\t\t\tdispatcher.schedule(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsetReady(false);\n\t\t\t\t\t\tdestroy(cause);\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tlog.warn(\"Error during actor destroying\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, 0, TimeUnit.MILLISECONDS);\n\t\t} catch (Throwable e) {\n\t\t\tlog.warn(\"Error during actor destroying\", e);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.08681346252026}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n\t\treturn true;\n\t}\n\n\tTenantProfile profile = null;\n\ttry {\n\t\tprofile = tenantProfileService.findTenantProfileById(tenantId);\n\t} catch (TenantProfileNotFoundException e) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow e;\n\t}\n\n\tif (profile == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit() == null) {\n\t\treturn true;\n\t}\n\n\tif (profile.getRateLimit().getRateLimit().getRateLimit().getRateLimit().getRateLimit", "CodeBleu_score": 28.629199949974428}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n\t\treturn true;\n\t}\n\ttry {\n\t\tTenantProfile tenantProfile = tenantProfileService.findTenantProfileById(tenantId);\n\t\tif (tenantProfile == null && ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t} else if (tenantProfile == null) {\n\t\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t\t}\n\t\tif (tenantProfile.getRateLimit()!= null) {\n\t\t\tif (tenantProfile.getRateLimit().getApiRateLimit()!= null) {\n\t\t\t\tif (tenantProfile.getRateLimit().getApiRateLimit().get(api)!= null) {\n\t\t\t\t\tlong limit = tenantProfile.getRateLimit().getApiRateLimit().get(api).getLimit();\n\t\t\t\t\tif (limit > 0) {\n\t\t\t\t\t\tlong count = tenantProfile.getRateLimit().getApiRateLimit().get(api).getCount();\n\t\t\t\t\t\tlong timestamp = tenantProfile.getRateLimit().getApiRateLimit().get(api).getTimestamp();\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tlong diff = now - timestamp;\n\t\t\t\t\t\tif (diff > TimeUnit.SECONDS.toMillis(tenantProfile.getRateLimit().getApiRateLimit().get(api).getInterval())) {\n\t\t\t\t\t\t\ttenantProfile.getRateLimit().getApiRateLimit().get(api).setCount(1);\n\t\t\t\t\t\t\ttenantProfile.getRateLimit().getApiRateLimit().get(api).setTimestamp(now);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttenantProfile.getRateLimit().getApiRateLimit().get(api).setCount(count + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tenantProfile.getRateLimit().getApiRateLimit().get(api).getCount() > limit) {\n\t\t\t\t\t\t\tlog.info(\"Rate limit exceeded for tenant [{}] for API [{}] for level [{}]\", tenantId, api, level);\n\t\t\t\t\t\t\tNotificationRuleProcessor.processNotification(tenantProfile, RateLimitsTrigger.class, tenantId, level);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} catch (TenantProfileNotFoundException e) {\n\t\tlog.error(\"Tenant profile not found for tenant [{}]\", tenantId);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 43.81907995648471}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n\t\treturn true;\n\t}\n\tTenantProfile profile = null;\n\ttry {\n\t\tprofile = tenantProfileService.getTenantProfile(tenantId);\n\t} catch (TenantProfileNotFoundException e) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow e;\n\t}\n\tTbRateLimits tbRateLimits = profile.getTbRateLimits();\n\tif (tbRateLimits == null) {\n\t\treturn true;\n\t}\n\tRateLimitsTrigger rateLimitsTrigger = tbRateLimits.getRateLimitsTrigger();\n\tif (rateLimitsTrigger == null) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getEnabled()) {\n\t\tlong limit = rateLimitsTrigger.getLimit();\n\t\tlong period = rateLimitsTrigger.getPeriod();\n\t\tif (limit == 0 || period == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tlong periodInSeconds = TimeUnit.MILLISECONDS.toSeconds(period);\n\t\tString key = String.format(\"%s:%s\", api.name(), level);\n\t\tif (rateLimitsCache.get(key, null) == null) {\n\t\t\trateLimitsCache.put(key, 1, periodInSeconds, TimeUnit.SECONDS);\n\t\t} else {\n\t\t\tlong current = rateLimitsCache.get(key, 0L);\n\t\t\tif (current >= limit) {\n\t\t\t\tNotificationRuleProcessor.processNotificationRule(rateLimitsTrigger.getNotificationRule(), tenantId, null);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\trateLimitsCache.put(key, current + 1, periodInSeconds, TimeUnit.SECONDS);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 41.43193328684781}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\t// The function \"evictTimeoutSessions\" removes DTLS sessions that have been inactive for a duration longer than the specified timeout.\n\t// It calculates the expiration time based on the current time minus the inactivity timeout.\n\t// It then iterates over the entries in the DTLS sessions map and removes those with a last activity time older than the calculated expiration time, logging each removal.\n\tlong timeout = 10000;\n\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tConcurrentMap<InetSocketAddress, DtlsSession> sessions = DtlsSessionManager.getSessions();\n\tfor (ConcurrentMap.Entry<InetSocketAddress, DtlsSession> entry : sessions.entrySet()) {\n\t\tDtlsSession session = entry.getValue();\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\tlog.info(\"Removing DTLS session with remote address: {}.\", entry.getKey());\n\t\t\tsessions.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 37.126992046881355}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - this.inactivityTimeout;\n\tConcurrentMap<InetSocketAddress, DtlsSession> sessions = this.sessions;\n\tif (sessions == null) {\n\t\treturn;\n\t}\n\tfor (InetSocketAddress address : sessions.keySet()) {\n\t\tDtlsSession session = sessions.get(address);\n\t\tif (session == null) {\n\t\t\tcontinue;\n\t\t}\n\t\tlong lastActivityTime = session.getLastActivityTime();\n\t\tif (lastActivityTime < expirationTime) {\n\t\t\tsessions.remove(address);\n\t\t\tlog.info(\"Removing DTLS session for {} due to inactivity timeout\", address);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.216820079663464}, {"code": "public void evictTimeoutSessions(){\n\t\t//TODO: Implement this function\n}", "CodeBleu_score": 1.5735629692275181}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (CollectionUtils.isEmpty(timeseries)) {\nreturn Collections.emptyList();\n}\nreturn timeseries.entrySet().stream()\n.map(entry -> {\nList<JsonNode> values = entry.getValue();\nList<TsKvEntry> tsKvEntries = new ArrayList<>();\nfor (JsonNode value : values) {\ntsKvEntries.add(toTsKvEntry(entry.getKey(), value));\n}\nreturn tsKvEntries;\n})\n.flatMap(List::stream)\n.collect(Collectors.toList());\n}", "CodeBleu_score": 35.44482482819923}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (CollectionUtils.isEmpty(timeseries)) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> result = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tList<JsonNode> values = entry.getValue();\n\t\tfor (JsonNode value : values) {\n\t\t\tresult.add(toTsKvEntry(entry.getKey(), value));\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 41.97402408328125}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (CollectionUtils.isEmpty(timeseries)) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> tsKvEntries = new ArrayList<>();\n\ttimeseries.forEach((key, value) -> {\n\t\tList<TsKvEntry> tsKvEntryList = new ArrayList<>();\n\t\tvalue.forEach(jsonNode -> {\n\t\t\tTsKvEntry tsKvEntry = null;\n\t\t\tswitch (jsonNode.getNodeType()) {\n\t\t\t\tcase BOOLEAN:\n\t\t\t\t\ttsKvEntry = new BooleanDataEntry(key, jsonNode.asBoolean());\n\t\t\t\t\tbreak;\n\t\t\t\tcase NUMBER:\n\t\t\t\t\tif (jsonNode.isDouble()) {\n\t\t\t\t\t\ttsKvEntry = new DoubleDataEntry(key, jsonNode.asDouble());\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttsKvEntry = new LongDataEntry(key, jsonNode.asLong());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase STRING:\n\t\t\t\t\ttsKvEntry = new StringDataEntry(key, jsonNode.asText());\n\t\t\t\t\tbreak;\n\t\t\t\tcase OBJECT:\n\t\t\t\t\ttsKvEntry = new JsonDataEntry(key, jsonNode.toString());\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttsKvEntryList.add(tsKvEntry);\n\t\t});\n\t\ttsKvEntries.add(new BasicTsKvEntry(key, tsKvEntryList));\n\t});\n\treturn tsKvEntries;\n}", "CodeBleu_score": 44.27400887891313}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t// Send a request to refresh the authentication token\nMap<String, String> requestMap = new HashMap<>();\nrequestMap.put(\"refresh_token\", \"\");\nMap<String, String> responseBody = restTemplate.postForObject(URI.create(\"http://localhost:8080/api/auth/token\"), requestMap, Map.class);\n\n// Update the token information with the current timestamp and the response body\ntokenInfo.setToken(responseBody.get(\"access_token\"));\ntokenInfo.setExpiresIn(responseBody.get(\"expires_in\"));\ntokenInfo.setRefreshToken(responseBody.get(\"refresh_token\"));\ntokenInfo.setTokenType(responseBody.get(\"token_type\"));\ntokenInfo.setIssuedAt(System.currentTimeMillis());\n}", "CodeBleu_score": 44.85846756799913}, {"code": "public void refreshToken(){\n\t\t// TODO: Implement this function\n}", "CodeBleu_score": 1.6078250809239212}, {"code": "public void refreshToken(){\n\t// Request map\nMap<String, String> requestMap = new HashMap<>();\n\n// Add the current refresh token\nrequestMap.put(\"refresh_token\", \"\");\n\n// Send POST request to the authentication endpoint\nResponseEntity<String> response = restTemplate.postForEntity(URI.create(\"https://thingsboard.cloud/oauth/token\"), requestMap, String.class);\n\n// Get the response body\nString responseBody = response.getBody();\n\n// Update the token information with the current timestamp and the response body\ntoken = responseBody;\ntimestamp = System.currentTimeMillis();\n}", "CodeBleu_score": 51.16406010120914}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\t// Create a login request map with the credentials\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", );\n\tloginRequest.put(\"client_id\", clientId);\n\tloginRequest.put(\"client_secret\", clientSecret);\n\tloginRequest.put(\"grant_type\", \"password\");\n\tloginRequest.put(\"scope\", \"read write\");\n\n\t// Send the login request to the \"/api/auth/login\" URL\n\tResponseEntity<String> loginResponse = restTemplate.postForEntity(loginUrl, loginRequest, String.class);\n\n\t// Parse the response and update the token information\n\tif (loginResponse.getStatusCode() == HttpStatus.OK) {\n\t\tJsonNode loginResponseJson = JacksonUtil.parseJson(loginResponse.getBody());\n\t\ttoken = loginResponseJson.get(\"access_token\").asText();\n\t\trefreshToken = loginResponseJson.get(\"refresh_token\").asText();\n\t\texpiresIn = loginResponseJson.get(\"expires_in\").asLong();\n\t\ttokenType = loginResponseJson.get(\"token_type\").asText();\n\t\trefreshTokenExpiresIn = loginResponseJson.get(\"refresh_token_expires_in\").asLong();\n\t\trefreshTokenExpiresAt = System.currentTimeMillis() + refreshTokenExpiresIn * 1000;\n\t\trefreshTokenExpiresAt = refreshTokenExpiresAt - (refreshTokenExpiresIn / 2) * 1000;\n\t\trefreshTokenRefreshAt = System.currentTimeMillis() + refreshTokenExpiresIn * 1000;\n\t\trefreshTokenRefreshAt = refreshTokenRefreshAt - (refreshTokenExpiresIn / 2) * 1000;\n\t\trefreshTokenRefreshAt = refreshTokenRefreshAt - (refreshTokenExpiresIn / 2) * 1000;\n\t}\n}", "CodeBleu_score": 46.871402269151886}, {"code": " private void doLogin(){\n\t\t// The function \"doLogin\" performs a login operation by sending a POST request with the username and password to the authentication endpoint.\n\t// It captures the current timestamp, creates a login request map with the credentials, and sends the request to the \"/api/auth/login\" URL.\n\t// Upon receiving the response, it updates the token information with the response data and the timestamp.\n\t// Parameters:\n\t// username - The username to be used for authentication.\n\t// password - The password to be used for authentication.\n\t// Returns:\n\t// A boolean value indicating whether the login operation was successful.\n\t// Example:\n\t// doLogin(\"user\", \"password\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n\t// doLogin(\"user\", \"\");\n", "CodeBleu_score": 1.3125195662175013}, {"code": " private void doLogin(){\n\t// Request body", "CodeBleu_score": 1.312489427706073}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn getDeviceById(deviceId, null);\n}", "CodeBleu_score": 6.442408619513598}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn getDeviceById(deviceId, null);\n}", "CodeBleu_score": 6.442408619513598}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn getDeviceById(deviceId, null);\n}", "CodeBleu_score": 6.442408619513598}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\treturn saveDeviceWithCredentials(device, credentials, null);\n}", "CodeBleu_score": 9.595657006565938}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\treturn saveDeviceWithCredentials(device, credentials, null);\n}", "CodeBleu_score": 9.595657006565938}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\treturn saveDeviceWithCredentials(device, credentials, null);\n}", "CodeBleu_score": 9.595657006565938}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\treturn this.setBrightness(addr, val);\n\t} else {\n\t\treturn this.setBrightness(addr, val * 15);\n\t}\n}", "CodeBleu_score": 33.98860265997331}, {"code": "brightness(addr, val){\n\t\treturn this.send(addr, 0x03, val);\n}", "CodeBleu_score": 22.260690237765143}, {"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\tthis.setBrightness(addr, arguments[0]);\n\t} else {\n\t\tthis.setBrightness(addr, Math.round(val * 15));\n\t}\n\treturn this;\n}", "CodeBleu_score": 30.652951053716805}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tconst obj = Object.create(LedControl.prototype);\n\tfor (const key in LedControl.prototype) {\n\t\tobj[key] = LedControl.prototype[key].bind(this, addr);\n\t}\n\treturn obj;\n}", "CodeBleu_score": 21.88209371471952}, {"code": "device(addr){\n\t\tlet bound = {};\n\tfor (let key in LedControl.prototype) {\n\t\tif (typeof LedControl.prototype[key] === \"function\") {\n\t\t\tbound[key] = LedControl.prototype[key].bind(this, addr);\n\t\t}\n\t}\n\treturn bound;\n}", "CodeBleu_score": 33.37404370275513}, {"code": "device(addr){\n\t\tlet obj = Object.create(LedControl.prototype);\n\tfor (let key in LedControl.prototype) {\n\t\tobj[key] = LedControl.prototype[key].bind(this, addr);\n\t}\n\treturn obj;\n}", "CodeBleu_score": 21.426312303656943}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tif (!target ||!methods) {\n\t\treturn;\n\t}\n\tmethods.forEach(method => {\n\t\ttarget[method] = (duration, callback) => {\n\t\t\tif (!duration) {\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tif (!callback || typeof callback!== 'function') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\ttarget.forEach(element => {\n\t\t\t\tpromises.push(new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tconst result = element[method]();\n\t\t\t\t\t\tif (result instanceof Promise) {\n\t\t\t\t\t\t\tresult.then(resolve).catch(reject);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 36.65087986057354}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tconst methodsToReconcile = methods.map(method => {\n\t\treturn {\n\t\t\tname: method,\n\t\t\tcallback: target[method]\n\t\t}\n\t});\n\n\tmethodsToReconcile.forEach(methodToReconcile => {\n\t\tif (typeof methodToReconcile.callback!== 'function') {\n\t\t\tthrow new Error(`The method ${methodToReconcile.name} is not a function.`);\n\t\t}\n\n\t\ttarget[methodToReconcile.name] = (duration = 1000, callback) => {\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error(`The callback is not a function.`);\n\t\t\t}\n\n\t\t\tconst promises = [];\n\t\t\tconst collection = target.getCollection();\n\n\t\t\tcollection.forEach(element => {\n\t\t\t\tpromises.push(new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tconst result = methodToReconcile.callback.call(element,...arguments);\n\t\t\t\t\t\tif (result instanceof Promise) {\n\t\t\t\t\t\t\tresult.then(resolve).catch(reject);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t});\n\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 28.160293073227376}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = (duration = 1000) => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst promises = [];\n\t\t\t\tconst callback = () => {\n\t\t\t\t\tif (promises.length === 0) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.forEach(element => {\n\t\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\telement[method](callback);\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}, duration);\n\t\t\t\t\t}));\n\t\t\t\t});\n\t\t\t\tPromise.all(promises).then(callback);\n\t\t\t});\n\t\t}\n\t});\n}", "CodeBleu_score": 32.196314973612175}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\tlet input = \"\";\n\tlet serialPort = new SerialPort(this.port, {\n\t\tbaudRate: this.baudRate,\n\t\tdataBits: this.dataBits,\n\t\tstopBits: this.stopBits,\n\t\tparity: this.parity,\n\t\tflowControl: this.flowControl,\n\t\tparser: serialPort.parsers.readline(\"\\r\n\")\n\t});\n\n\tserialPort.on(\"open\", () => {\n\t\tconsole.log(\"Listening on port \" + this.port);\n\t});\n\n\tserialPort.on(\"data\", data => {\n\t\tinput += data;\n\t\tlet sentences = input.split(\"\\r\n\");\n\t\tinput = sentences.pop();\n\n\t\tfor (let sentence of sentences) {\n\t\t\tthis.parseNmeaSentence(sentence);\n\t\t}\n\t});\n}", "CodeBleu_score": 36.50111164798323}, {"code": "listen(){\n\t\tlet input = \"\";\n\tlet incompleteSentence = \"\";\n\tlet serialPort = new SerialPort(this.port, {\n\t\tbaudRate: this.baudRate,\n\t\tdataBits: this.dataBits,\n\t\tstopBits: this.stopBits,\n\t\tparity: this.parity,\n\t\tflowControl: this.flowControl\n\t});\n\tserialPort.on(\"data\", (data) => {\n\t\tinput += data.toString();\n\t\tlet sentences = input.split(\"\\r\n\");\n\t\tinput = sentences.pop();\n\t\tfor (let sentence of sentences) {\n\t\t\tthis.parseNmeaSentence(sentence);\n\t\t}\n\t\tif (incompleteSentence) {\n\t\t\tthis.parseNmeaSentence(incompleteSentence);\n\t\t\tincompleteSentence = \"\";\n\t\t}\n\t});\n\tserialPort.on(\"error\", (error) => {\n\t\tconsole.log(\"Error: \" + error);\n\t});\n}", "CodeBleu_score": 33.22782148399741}, {"code": "listen(){\n\t\t//Initialize the input string\n\tlet input = '';\n\n\t//Start the read loop\n\tconst readLoop = () => {\n\t\t//Read data from the serial port\n\t\tthis.serialPort.read(function(err, data) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log('Error reading from serial port:'+ err.message);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//Append the data to the input string\n\t\t\tinput += data;\n\n\t\t\t//Split the input string into sentences based on the \"\\r\n\" delimiter\n\t\t\tconst sentences = input.split('\\r\n');\n\n\t\t\t//Process all complete sentences\n\t\t\tfor (let i = 0; i < sentences.length - 1; i++) {\n\t\t\t\t//Process the sentence\n\t\t\t\tthis.parseNmeaSentence(sentences[i]);\n\t\t\t}\n\n\t\t\t//Retain the incomplete sentence\n\t\t\tinput = sentences[sentences.length - 1];\n\n\t\t\t//Start the next read loop\n\t\t\treadLoop();\n\t\t});\n\t};\n\n\t//Start the read loop\n\treadLoop();\n}", "CodeBleu_score": 52.20688791076738}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tint n_channels = 0;\n\tint n_samples = 0;\n\tint i;\n\n\t/*\n\t * The buffer size is the number of samples times the size of each data sample.\n\t * The number of samples is the number of channels times the number of samples per channel.\n\t */\n\tfor (i = 0; i < sequence->options->channels->num_channels; i++) {\n\t\tn_channels++;\n\t\tn_samples += sequence->options->channels->channel_list[i].channel_count;\n\t}\n\n\t/*\n\t * The buffer size is the number of samples times the size of each data sample.\n\t */\n\tif (n_samples > config->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.77540314289972}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t buffer_size = 0;\n\tuint32_t channel_count = 0;\n\n\t/* Calculate the number of active channels in the sequence. */\n\tfor (uint32_t i = 0; i < sequence->options; i++) {\n\t\tif (sequence->channels[i]!= ADC_CHANNEL_NONE) {\n\t\t\tchannel_count++;\n\t\t}\n\t}\n\n\t/* Calculate the buffer size needed for the sequence. */\n\tbuffer_size = channel_count * config->data_size;\n\n\t/* Validate the buffer size. */\n\tif (sequence->buffer_size < buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 43.7850220076209}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tsize_t buffer_size = 0;\n\tsize_t sample_size = 0;\n\tsize_t sample_count = 0;\n\tsize_t channel_count = 0;\n\tint i;\n\n\tif (!sequence) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Calculate the number of active channels and the buffer size based on the number of channels and the size of each data sample.\n\t */\n\tfor (i = 0; i < sequence->options->channels; i++) {\n\t\tif (sequence->channels[i].channel_id!= ADC_ALL_CHANNELS) {\n\t\t\tchannel_count++;\n\t\t}\n\t}\n\n\tif (channel_count == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tsample_size = sizeof(uint16_t) * channel_count;\n\tsample_count = sequence->options->buffer_size / sample_size;\n\n\t/*\n\t * Calculate the buffer size based on the number of samples and the size of each data sample.\n\t */\n\tbuffer_size = sample_count * sample_size;\n\n\tif (buffer_size < sequence->options->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.72189596389882}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_sequence_callback *cb = sequence->options;\n\tint ret = 0;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"ADC resolution mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels_list_count > config->channels_count) {\n\t\tLOG_ERR(\"Invalid channel list\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\tif (sequence->options->api->data) {\n\t\t\tcb->data = sequence->options->api->data;\n\t\t}\n\n\t\tif (sequence->options->api->on_done) {\n\t\t\tcb->on_done = sequence->options->api->on_done;\n\t\t}\n\t}\n\n\tif (sequence->options && sequence->options->api->data && sequence->options->api->on_done) {\n\t\tcb->data = sequence->options->api->data;\n\t\tcb->on_done = sequence->options->api->on_done;\n\t}\n\n\tif (sequence->options && sequence->options->api->data &&!sequence->options->api->on_done) {\n\t\tcb->data = sequence->options->api->data;\n\t}\n\n\tif (sequence->options &&!sequence->options->api->data && sequence->options->api->on_done) {\n\t\tcb->on_done = sequence->options->api->on_done;\n\t}\n\n\tif (!sequence->options &&!sequence->options->api->data &&!sequence->options->api->on_done) {\n\t\tcb->data = NULL;\n\t\tcb->on_done = NULL;\n\t}\n\n\tif (sequence->options &&!sequence->options->api->data &&!sequence->options->api->on_done) {\n\t\tcb->data = NULL;\n\t}\n\n\tif (!sequence->options && sequence->options->api->data &&!sequence->options->api->on_done) {\n\t\tcb->on_done = NULL;\n\t}\n\n\tif (!sequence->options &&!sequence->options->api->data", "CodeBleu_score": 38.41190160041626}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_channel_cfg *channel;\n\tint i;\n\tint ret;\n\n\t/*\n\t * Check if the resolution of the ADC sequence matches the expected resolution.\n\t */\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"ADC resolution mismatch: %d!= %d\", sequence->resolution, config->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the specified channels are valid.\n\t */\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tchannel = &sequence->channels[i];\n\t\tif (channel->channel_id >= config->channels) {\n\t\t\tLOG_ERR(\"Invalid channel ID: %d\", channel->channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Validate the buffer size for the ADC read.\n\t */\n\tif (sequence->buffer_size < sequence->channels) {\n\t\tLOG_ERR(\"Buffer size too small: %d < %d\", sequence->buffer_size, sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Set the buffer, start the ADC read context, and wait for the read operation to complete.\n\t */\n\tdata->sequence = sequence;\n\tdata->buffer = sequence->buffer;\n\tret = adc_context_start(dev, &data->ctx, adc_ad559x_read_cb, sequence->channels, sequence->buffer_size);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.82782822607628}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_read_context *ctx = data->read_ctx;\n\tint i;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"ADC resolution does not match device resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel specified\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < sequence->channels) {\n\t\tLOG_ERR(\"Buffer size is insufficient for the number of channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tctx->sequence = sequence;\n\tctx->buffer = sequence->buffer;\n\n\tadc_read_context_start(ctx);\n\n\treturn 0;\n}", "CodeBleu_score": 49.027453781789795}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tadc_context_get_data(ctx);\n\n\tadc_context_set_channels(ctx);\n\n\tadc_context_initialize_repeat_buffer(ctx);\n\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 47.02784414107064}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\t/*\n\t * Retrieve the ADC data structure from the context.\n\t */\n\tconst struct device *dev = ctx->dev;\n\tconst struct adc_driver_api *api = dev->driver_api;\n\n\t/*\n\t * Set the channels to be sampled.\n\t */\n\tconst struct adc_channel_cfg *cfg = ctx->cfg;\n\tconst struct adc_sequence *seq = ctx->seq;\n\n\t/*\n\t * Initialize the repeat buffer with the data buffer.\n\t */\n\tstruct adc_sequence *seq_repeat = ctx->seq_repeat;\n\tconst struct adc_sequence *seq_data = ctx->seq_data;\n\n\tfor (int i = 0; i < seq->options.repeat_count; i++) {\n\t\tseq_repeat[i] = seq_data[i];\n\t}\n\n\t/*\n\t * Release the semaphore to signal the start of sampling.\n\t */\n\tapi->start_sampling(dev, seq_repeat, ctx->seq_repeat_count);\n}", "CodeBleu_score": 25.59874686858164}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *adc_data = ctx->adc_data;\n\n\tadc_data->adc_ctx->channels = ctx->channels;\n\tadc_data->adc_ctx->repeat_buffer = ctx->data;\n\tadc_data->adc_ctx->repeat_buffer_length = ctx->data_length;\n\n\tk_sem_give(&adc_data->adc_ctx->sem);\n}", "CodeBleu_score": 49.6080333752669}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data *adc_data = &ctx->adc_data;\n\n\tif (repeat_sampling) {\n\t\tadc_data->buffer = adc_data->repeat_buffer;\n\t} else {\n\t\tadc_data->buffer = adc_data->single_buffer;\n\t}\n}", "CodeBleu_score": 50.53780013048026}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->adc_data_container->buffer_pointer = ctx->adc_data_container->repeat_buffer;\n\t} else {\n\t\tctx->adc_data_container->buffer_pointer = ctx->adc_data_container->data_buffer;\n\t}\n}", "CodeBleu_score": 43.749629283395855}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->data_container = ctx->repeat_buffer;\n\t} else {\n\t\tctx->data_container = ctx->buffer;\n\t}\n}", "CodeBleu_score": 47.93510225722667}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tadc_context_t *ctx = &data->adc_context;\n\tadc_channel_t *channel;\n\tuint16_t value;\n\n\tLOG_DBG(\"adc_ad559x_acquisition_thread started\");\n\n\twhile (1) {\n\t\t/* Wait for the semaphore to be released. */\n\t\tk_sem_take(&ctx->sem, K_FOREVER);\n\n\t\t/* Iterate through the active channels. */\n\t\tfor (channel = ctx->channels; channel < ctx->channels + ctx->active_channels; channel++) {\n\t\t\t/* Read the ADC value. */\n\t\t\tif (adc_channel_get(channel->channel, &value)) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d\", channel->channel);\n\t\t\t\tctx->complete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Store the value. */\n\t\t\tchannel->value = sys_cpu_to_be16(value);\n\t\t}\n\n\t\t/* Signal that the acquisition is done. */\n\t\tk_sem_give(&ctx->sem);\n\t}\n}", "CodeBleu_score": 36.69553044173547}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_context *ctx = &data->ctx;\n\tstruct adc_channel_cfg *channel_cfg;\n\tuint8_t channel_id;\n\tuint8_t channel_count;\n\tuint8_t channel_index;\n\tuint8_t *buffer_ptr;\n\tuint8_t *buffer_end;\n\tuint8_t *buffer_start;\n\tuint8_t *buffer_end_ptr;\n\tuint8_t *buffer_start_ptr;\n\tuint8_t *buffer_ptr_next;\n\tuint8_t *buffer_ptr_prev;\n\tuint8_t *buffer_ptr_current;\n\tuint8_t *buffer_ptr_next_current;\n\tuint8_t *buffer_ptr_prev_current;\n\tuint8_t *buffer_ptr_current_next;\n\tuint8_t *buffer_ptr_current_prev;\n\tuint8_t *buffer_ptr_current_next_next;\n\tuint8_t *buffer_ptr_current_prev_prev;\n\tuint8_t *buffer_ptr_current_next_prev;\n\tuint8_t *buffer_ptr_current_prev_next;\n\tuint8_t *buffer_ptr_current_next_next_next;\n\tuint8_t *buffer_ptr_current_prev_prev_prev;\n\tuint8_t *buffer_ptr_current_next_prev_prev;\n\tuint8_t *buffer_ptr_current_prev_next_prev;\n\tuint8_t *buffer_ptr_current_next_next_next_next;\n\tuint8_t *buffer_ptr_current_prev_prev_prev_prev;\n\tuint8_t *buffer_ptr_current_next_prev_prev_prev;\n\tuint8_t *buffer_ptr_current_prev_next_prev_prev;\n\tuint8_t *buffer_ptr_current_next_next_next_next_next;\n\tuint8_t *buffer_ptr_current_prev_prev_prev_prev_prev;\n\tuint8_t *buffer_ptr_current_next_prev_prev_prev_prev;\n", "CodeBleu_score": 10.504227940799742}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_ad559x_channel *channel;\n\tstruct adc_ad559x_context *ctx;\n\tstruct adc_ad559x_buffer *buffer;\n\tint channel_index;\n\tint status;\n\tint i;\n\n\tctx = &data->ctx;\n\n\t/*\n\t * Wait for a semaphore to be released.\n\t */\n\tk_sem_take(&ctx->sem_acquisition_done, K_FOREVER);\n\n\t/*\n\t * Iterate through the active channels.\n\t */\n\tfor (i = 0; i < ctx->channel_count; i++) {\n\t\tchannel = &ctx->channels[i];\n\t\tbuffer = &channel->buffer;\n\n\t\t/*\n\t\t * Read the ADC value.\n\t\t */\n\t\tstatus = adc_channel_get(channel->channel_id, buffer->data);\n\n\t\tif (status!= 0) {\n\t\t\tLOG_ERR(\"Failed to read ADC value from channel %d\", channel->channel_id);\n\t\t\tctx->complete = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Store the ADC value in the buffer.\n\t\t */\n\t\tbuffer->data[0] = sys_cpu_to_le32(buffer->data[0]);\n\t\tchannel->buffer.data[0] = buffer->data[0];\n\t}\n\n\t/*\n\t * Signal that the sampling is done.\n\t */\n\tk_sem_give(&ctx->sem_sampling_done);\n}", "CodeBleu_score": 39.15996016181671}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tstruct ads1112_data *data = dev->data;\n\tconst struct ads1112_config *config = dev->config;\n\tuint16_t status;\n\tint ret;\n\n\tk_sleep(config->ready_time);\n\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &status);\n\tif (ret!= 0) {\n\t\tLOG_ERR(\"Error reading configuration register: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tif (status & ADS1112_REG_CONFIG_DRDY) {\n\t\treturn 0;\n\t}\n\n\treturn -EBUSY;\n}", "CodeBleu_score": 42.56087493034421}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tconst struct i2c_dt_spec *i2c = (const struct i2c_dt_spec *)config->i2c;\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t reg_value;\n\tint ret;\n\n\tret = i2c_reg_read_byte_timeout(i2c->bus, i2c->addr, ADS1112_REG_CONFIG, &reg_value, 100);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (reg_value & ADS1112_REG_CONFIG_DRDY) {\n\t\treturn 0;\n\t}\n\n\tk_sleep(config->ready_time);\n\n\treturn ads1112_wait_data_ready(dev);\n}", "CodeBleu_score": 38.276821017305515}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint16_t config_reg = 0;\n\tuint16_t config_reg_mask = 0x8000;\n\tuint16_t config_reg_value = 0;\n\tuint32_t ready_time_us = config->ready_time_us;\n\tint err = 0;\n\n\tif (ready_time_us == 0) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Wait for the device to be ready for data reading.\n\t */\n\tk_busy_wait(ready_time_us);\n\n\t/*\n\t * Read the configuration register to check the status.\n\t */\n\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n\tif (err!= 0) {\n\t\tLOG_ERR(\"Failed to read the configuration register: %d\", err);\n\t\treturn err;\n\t}\n\n\t/*\n\t * Check the status.\n\t */\n\tconfig_reg_value = config_reg & config_reg_mask;\n\tif (config_reg_value!= 0) {\n\t\tLOG_ERR(\"The device is not ready for data reading.\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 33.88527058334476}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t samples_per_channel = sequence->options & ADC_SEQ_OPTIONS_EXTRA_SAMPLING? 2 : 1;\n\tuint32_t samples_per_channel_plus_one = samples_per_channel + 1;\n\tuint32_t samples_per_channel_plus_two = samples_per_channel + 2;\n\tuint32_t samples_per_channel_plus_three = samples_per_channel + 3;\n\tuint32_t samples_per_channel_plus_four = samples_per_channel + 4;\n\tuint32_t samples_per_channel_plus_five = samples_per_channel + 5;\n\tuint32_t samples_per_channel_plus_six = samples_per_channel + 6;\n\tuint32_t samples_per_channel_plus_seven = samples_per_channel + 7;\n\tuint32_t samples_per_channel_plus_eight = samples_per_channel + 8;\n\tuint32_t samples_per_channel_plus_nine = samples_per_channel + 9;\n\tuint32_t samples_per_channel_plus_ten = samples_per_channel + 10;\n\tuint32_t samples_per_channel_plus_eleven = samples_per_channel + 11;\n\tuint32_t samples_per_channel_plus_twelve = samples_per_channel + 12;\n\tuint32_t samples_per_channel_plus_thirteen = samples_per_channel + 13;\n\tuint32_t samples_per_channel_plus_fourteen = samples_per_channel + 14;\n\tuint32_t samples_per_channel_plus_fifteen = samples_per_channel + 15;\n\tuint32_t samples_per_channel_plus_sixteen = samples_per_channel + 16;\n\tuint32_t samples_per_channel_plus_seventeen = samples_per_channel + 17;\n\tuint32_t samples_per_channel_plus_eighteen", "CodeBleu_score": 9.334087331752382}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t num_samplings = 0;\n\n\tif (!sequence) {\n\t\treturn -EINVAL;\n\t}\n\n\tnum_samplings = sequence->options & ADC_SEQ_EXTRA_SAMPLINGS_MASK;\n\tnum_samplings += sequence->resolution + 1;\n\n\tif (num_samplings > sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size is not sufficient\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 49.56312246633169}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size;\n\tint samplings;\n\tint extra_samplings;\n\n\tif (sequence->options & ADC_SEQ_OPTION_OVERRUN) {\n\t\textra_samplings = 1;\n\t} else {\n\t\textra_samplings = 0;\n\t}\n\n\tsamplings = sequence->resolution_settings.resolution_settings.samplings;\n\n\tbuffer_size = samplings + extra_samplings;\n\n\tif (buffer_size < samplings) {\n\t\tLOG_ERR(\"Buffer size is too small for the number of samplings.\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.51107656257949}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (sequence == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_OVERSAMPLING) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution > 12) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels > 4) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > 1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = i2c_write(config->i2c, config->i2c_addr, sequence->buffer,\n\t\t\tsequence->length);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = k_sem_take(&data->sem, K_FOREVER);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.099896169246435}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\tuint8_t cmd[3];\n\tuint8_t data_buf[3];\n\n\tif (!data->is_initialized) {\n\t\tLOG_ERR(\"Device not initialized\");\n\t\treturn -EIO;\n\t}\n\n\tif (!sequence) {\n\t\tLOG_ERR(\"Invalid sequence\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_REPEAT) {\n\t\tLOG_ERR(\"Repeat not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_ACQ_MODE_CONTINUOUS) {\n\t\tLOG_ERR(\"Continuous mode not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_ACQ_MODE_SINGLE) {\n\t\tLOG_ERR(\"Single mode not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_ACQ_MODE_SINGLE_END) {\n\t\tLOG_ERR(\"Single-ended mode not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_ACQ_MODE_DIFF) {\n\t\tLOG_ERR(\"Differential mode not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_ACQ_MODE_COMPLEMENTARY) {\n\t\tLOG_ERR(\"Complementary mode not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_ACQ_MODE_DIFFERENTIAL_COMPLEMENTARY) {\n\t\tLOG_ERR(\"Differential complementary mode not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_ACQ_MODE_DIFFERENTIAL_SINGLE_ENDED) {\n\t\tLOG_ERR(\"Differential single-ended mode not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_ACQ_MODE", "CodeBleu_score": 41.79522644487051}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_adc_data *data = dev->data;\n\tconst struct adc_sequence *seq = sequence;\n\tconst struct adc_channel_cfg *channel;\n\tuint8_t reg_val;\n\tint ret;\n\n\tif (sequence == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels_num > data->channels_num) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * The ADC sequence is valid if it contains a single channel and the\n\t * channel is valid.\n\t */\n\tif (sequence->channels_num == 1U) {\n\t\tchannel = &sequence->channels[0];\n\t\tif (channel->channel_id >= data->channels_num) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * The ADC sequence is valid if it contains a single channel and the\n\t * channel is valid.\n\t */\n\tif (sequence->channels_num == 1U) {\n\t\tchannel = &sequence->channels[0];\n\t\tif (channel->channel_id >= data->channels_num) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * The ADC sequence is valid if it contains a single channel and the\n\t * channel is valid.\n\t */\n\tif (sequence->channels_num == 1U) {\n\t\tchannel = &sequence->channels[0];\n\t\tif (channel->channel_id >= data->channels_num) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * The ADC sequence is valid if it contains a single channel and the\n\t * channel is valid.\n\t */\n\tif (sequence->channels_num == 1U) {\n\t\tchannel = &sequence->channels[0];\n\t\tif (channel->channel_id >= data->channels_num) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * The ADC sequence is valid if it contains a single channel and the\n\t * channel is valid.\n\t */\n\tif (sequence->channels_num == 1U) {\n\t\tchannel = &sequence->channels[0];\n\t\tif (channel->channel_id >= data->channels_num) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * The", "CodeBleu_score": 40.34081562495096}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\n\tif (argc!= 2) {\n\t\tshell_error(sh, \"Usage: %s <codec-name>\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = codec_apply_prop(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply codec properties\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 63.865223398481355}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *codec_dev;\n\tint ret;\n\tstruct audio_codec_config codec_cfg = { 0 };\n\n\tcodec_dev = device_get_binding(argv[1]);\n\tif (codec_dev == NULL) {\n\t\tshell_error(sh, \"Could not find device '%s'\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_config(codec_dev, &codec_cfg);\n\tif (ret!= 0) {\n\t\tshell_error(sh, \"Could not apply properties to device '%s'\", argv[1]);\n\t\treturn ret;\n\t}\n\n\tshell_print(sh, \"Applied properties to device '%s'\", argv[1]);\n\n\treturn 0;\n}", "CodeBleu_score": 47.299132768155864}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tif (argc!= 3) {\n\t\tshell_error(sh, \"Usage: apply_prop <device> <prop>\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct device *dev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tint ret = codec_apply_prop(dev, argv[2]);\n\tif (ret!= 0) {\n\t\tshell_error(sh, \"Error applying properties\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.0105176002496}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *data = dev->data;\n\tint err = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state!= DMIC_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device not configured\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device already active\");\n\t\t\treturn -EALREADY;\n\t\t}\n\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state!= DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device not active\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = i2s_trigger(dev, cmd);\n\tif (err) {\n\t\tLOG_ERR(\"I2S trigger failed\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.34718398891484}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret;\n\tstruct mpxxdtyy_data *data = dev->data;\n\tstruct mpxxdtyy_config *cfg = dev->config;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state!= MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Invalid state: %d\", data->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = i2s_trigger_start(cfg->i2s_dev);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to start I2S: %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state!= MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Invalid state: %d\", data->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = i2s_trigger_stop(cfg->i2s_dev);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to stop I2S: %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command: %d\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 58.213995451623845}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_send_command(dev, MPXXDTYY_I2S_CMD_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_send_command(dev, MPXXDTYY_I2S_CMD_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 52.9524639320045}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0;\n\tuint8_t display_mode = data->display_mode;\n\n\tif (enabled) {\n\t\tdisplay_mode |= HD44780_DISPLAY_MODE_ON;\n\t} else {\n\t\tdisplay_mode &= ~HD44780_DISPLAY_MODE_ON;\n\t}\n\n\tif (data->cursor_blink_enabled) {\n\t\tdisplay_mode |= HD44780_DISPLAY_MODE_CURSOR_BLINK;\n\t} else {\n\t\tdisplay_mode &= ~HD44780_DISPLAY_MODE_CURSOR_BLINK;\n\t}\n\n\tif (data->display_enabled) {\n\t\tdisplay_mode |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t} else {\n\t\tdisplay_mode &= ~HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tcommand = HD44780_DISPLAY_MODE | display_mode;\n\n\tauxdisplay_hd44780_write_command(dev, command);\n}", "CodeBleu_score": 55.91669146301743}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tuint8_t command = 0;\n\n\tif (auxdisplay_hd44780_get_display_mode(dev, &command)) {\n\t\tLOG_ERR(\"Failed to retrieve display mode command from device\");\n\t\treturn;\n\t}\n\n\tif (enabled) {\n\t\tcommand |= HD44780_DISPLAY_ON;\n\t} else {\n\t\tcommand &= ~HD44780_DISPLAY_ON;\n\t}\n\n\tif (auxdisplay_hd44780_set_display_mode(dev, command)) {\n\t\tLOG_ERR(\"Failed to set display mode command to device\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 35.30050310449116}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0x00;\n\n\tif (enabled) {\n\t\tcommand = data->display_mode;\n\n\t\tif (data->cursor_blink) {\n\t\t\tcommand |= HD44780_DISP_CURSOR_BLINK;\n\t\t}\n\n\t\tif (data->display_blink) {\n\t\t\tcommand |= HD44780_DISP_BLINK;\n\t\t}\n\t}\n\n\tauxdisplay_hd44780_write_command(dev, command);\n}", "CodeBleu_score": 48.978864879572264}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *cfg = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\n\tif (!cfg->busy_gpio_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&cfg->busy_gpio_port->port, cfg->busy_gpio_port->pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 59.37549218575876}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\n\tif (!config->busy_port) {\n\t\tLOG_ERR(\"Busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get_dt(config->busy_port, config->busy_pin);\n}", "CodeBleu_score": 37.42740655815693}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *cfg = dev->config;\n\tint ret;\n\n\tif (!cfg->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&cfg->busy_gpio, 0);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 65.26972102308203}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tstruct auxdisplay_serlcd_config *config = dev->config;\n\n\tconst uint8_t special_command_prefix = 0x00;\n\n\tuint8_t command_buffer[2];\n\n\tcommand_buffer[0] = special_command_prefix;\n\tcommand_buffer[1] = command;\n\n\treturn i2c_write(config->i2c, config->address, command_buffer, 2, 0);\n}", "CodeBleu_score": 58.366754777594856}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t command_buffer[2];\n\tint ret;\n\n\tcommand_buffer[0] = config->special_command_prefix;\n\tcommand_buffer[1] = command;\n\n\tret = i2c_write(config->i2c_dev, command_buffer, sizeof(command_buffer),\n\t\t\tI2C_KEEP_BUS);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_sleep(config->special_command_delay);\n\n\treturn 0;\n}", "CodeBleu_score": 61.15155349886822}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\n\tuint8_t buffer[2];\n\n\tbuffer[0] = config->command_prefix;\n\tbuffer[1] = command;\n\n\tint ret = i2c_write(data->i2c, buffer, sizeof(buffer), config->address);\n\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to send special command to device 0x%02x: %d\",\n\t\t\tconfig->address, ret);\n\t\treturn ret;\n\t}\n\n\tk_sleep(config->command_delay);\n\n\treturn 0;\n}", "CodeBleu_score": 59.28489173081902}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\n\tif (offset + size > data_ptr->size) {\n\t\tLOG_ERR(\"Read size exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_ptr->buffer_size) {\n\t\tLOG_ERR(\"Read size exceeds buffer bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset % 4!= 0) {\n\t\tLOG_ERR(\"Read offset is not 4-byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (size % 4!= 0) {\n\t\tLOG_ERR(\"Read size is not 4-byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data_ptr->buffer + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 56.84835339803166}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_emul = dev->data;\n\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_emul->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data_emul->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 69.32452639394924}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tconst struct bbram_emul_data *data_ptr = dev->data;\n\tint ret = 0;\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Invalid read size or offset\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data_ptr->mem + offset, size);\n\n\treturn ret;\n}", "CodeBleu_score": 67.55265166088903}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_ptr = dev->data;\n\n\t/*\n\t * Check if the write size is valid.\n\t */\n\tif (size == 0 || size > config->max_write_size) {\n\t\tLOG_ERR(\"Invalid write size: %d\", size);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the write operation stays within the bounds of the BBRAM.\n\t */\n\tif (offset + size > config->max_size) {\n\t\tLOG_ERR(\"Write operation exceeds BBRAM bounds: %d\", offset + size);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the BBRAM is not in an invalid state.\n\t */\n\tif (data_ptr->state!= BBRAM_STATE_READY) {\n\t\tLOG_ERR(\"BBRAM is in invalid state: %d\", data_ptr->state);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Copy the data to the specified offset within the device's memory.\n\t */\n\tmemcpy(data_ptr->memory + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.73365797528727}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *emul = dev->data;\n\tint ret = 0;\n\n\tif (size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (emul->state == BBRAM_STATE_INVALID) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(emul->data + offset, data, size);\n\n\treturn ret;\n}", "CodeBleu_score": 58.80191978159511}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (config->state!= BBRAM_EMUL_STATE_VALID) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(config->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.75827899512045}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint ret = 0;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing argument\");\n\t\tret = -EINVAL;\n\t} else {\n\t\t*bbram_dev = device_get_binding(argv[1]);\n\n\t\tif (*bbram_dev == NULL) {\n\t\t\tshell_error(sh, \"Device not found\");\n\t\t\tret = -ENODEV;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 62.08437034861838}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst struct device *dev;\n\tint ret;\n\n\tif (argc < 1) {\n\t\tshell_error(sh, \"Missing required argument for device\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[0]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_init(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to initialize device\");\n\t\treturn ret;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 66.23293519077545}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst struct device *dev;\n\tconst char *dev_name;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_name = argv[1];\n\n\tdev = device_get_binding(dev_name);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", dev_name);\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 67.81268982280783}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct bt_uart_ops *ops = dev->driver_api;\n\tstruct bt_uart_buf buf = { 0 };\n\tssize_t read_len;\n\tssize_t hdr_len;\n\tssize_t remaining_len;\n\tssize_t total_len;\n\tssize_t total_read;\n\tssize_t hdr_read;\n\tssize_t hdr_total;\n\tssize_t hdr_remaining;\n\tssize_t hdr_total_read;\n\tssize_t hdr_read_len;\n\tssize_t hdr_total_len;\n\tssize_t hdr_total_remaining;\n\tssize_t hdr_total_read_len;\n\tssize_t hdr_total_read_remaining;\n\tssize_t hdr_total_read_len_remaining;\n\tssize_t hdr_total_read_len_remaining_len;\n\tssize_t hdr_total_read_len_remaining_remaining;\n\tssize_t hdr_total_read_len_remaining_remaining_len;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining_len;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining_remaining;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining_remaining_len;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining_remaining_remaining;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining_remaining_remaining_len;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining_remaining_remaining_remaining;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining_remaining_remaining_remaining_len;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining_remaining_remaining_remaining_remaining;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining_remaining_remaining_remaining_remaining_len;\n\tssize_t hdr_total_read_len_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining;\n\t", "CodeBleu_score": 13.353411937498919}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tssize_t ret;\n\tuint8_t *hdr_buf = (uint8_t *) hdr;\n\tsize_t hdr_len = sizeof(hdr);\n\tsize_t hdr_len_read = 0;\n\tsize_t hdr_len_to_read = hdr_len;\n\n\twhile (hdr_len_read < hdr_len) {\n\t\tret = uart_fifo_read(dev, hdr_buf + hdr_len_read, hdr_len_to_read);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART: %d\", ret);\n\t\t\treturn;\n\t\t}\n\t\thdr_len_read += ret;\n\t\thdr_len_to_read -= ret;\n\t}\n}", "CodeBleu_score": 33.77258575753961}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint i;\n\tint num_read;\n\tint num_bytes_read;\n\n\tnum_bytes_read = 0;\n\n\t/*\n\t * Read header bytes\n\t */\n\tfor (i = 0; i < H4_HDR_LEN; i++) {\n\t\tnum_read = uart_fifo_read(dev, &hci_hdr[i], 1);\n\n\t\tif (num_read < 1) {\n\t\t\tLOG_ERR(\"Error reading header byte %d\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_bytes_read += num_read;\n\t}\n\n\t/*\n\t * Calculate remaining number of bytes to read\n\t */\n\tnum_bytes_read = H4_HDR_LEN - num_bytes_read;\n\n\t/*\n\t * Read remaining header bytes\n\t */\n\tfor (; i < H4_HDR_LEN; i++) {\n\t\tnum_read = uart_fifo_read(dev, &hci_hdr[i], num_bytes_read);\n\n\t\tif (num_read < num_bytes_read) {\n\t\t\tLOG_ERR(\"Error reading header byte %d\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_bytes_read -= num_read;\n\t}\n}", "CodeBleu_score": 31.549610983090226}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read;\n\tint err;\n\n\tbytes_read = 0;\n\twhile (len > 0) {\n\t\tif (len > sizeof(buf)) {\n\t\t\terr = uart_fifo_read(uart, buf, sizeof(buf));\n\t\t} else {\n\t\t\terr = uart_fifo_read(uart, buf, len);\n\t\t}\n\n\t\tif (err < 0) {\n\t\t\tLOG_ERR(\"UART read error: %d\", err);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbytes_read += err;\n\t\tlen -= err;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 52.56463726967089}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t n = 0;\n\tuint8_t tmp[33];\n\n\twhile (len > 0) {\n\t\tif (len > sizeof(tmp)) {\n\t\t\tn = sizeof(tmp);\n\t\t} else {\n\t\t\tn = len;\n\t\t}\n\n\t\tif (uart_fifo_read(uart, tmp, n)!= 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART device\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= n;\n\t}\n\n\treturn n;\n}", "CodeBleu_score": 37.76240077768058}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t n = 0;\n\tsize_t read;\n\tint err;\n\n\twhile (len > 0) {\n\t\tread = sizeof(buf);\n\t\tif (read > len) {\n\t\t\tread = len;\n\t\t}\n\n\t\terr = uart_fifo_read(uart, buf, read);\n\t\tif (err < 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART: %d\", err);\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= read;\n\t\tn += read;\n\t}\n\n\treturn n;\n}", "CodeBleu_score": 50.15943219533062}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *observer;\n\tstruct zbus_observer *highest_observer = NULL;\n\tstruct zbus_observer *observer_next;\n\tint highest_priority = 0;\n\n\tzbus_lock_chan(chan);\n\tobserver = zbus_chan_observers_head(chan);\n\twhile (observer) {\n\t\tobserver_next = zbus_chan_observers_next(observer);\n\t\tif (observer->enabled && observer->priority > highest_priority) {\n\t\t\thighest_priority = observer->priority;\n\t\t\thighest_observer = observer;\n\t\t}\n\t\tobserver = observer_next;\n\t}\n\tzbus_chan_set_highest_observer(chan, highest_observer);\n\tzbus_unlock_chan(chan);\n}", "CodeBleu_score": 30.11047573824326}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *observer;\n\tstruct zbus_observer *highest_observer = NULL;\n\tint highest_observer_priority = INT_MIN;\n\tstruct k_spinlock_key key;\n\n\tkey = k_spin_lock(&chan->lock);\n\n\t/*\n\t * Iterate through the observers of the channel.\n\t * If an observer has a higher priority than the current highest, set it as the new highest.\n\t */\n\tfor (observer = chan->observers; observer!= NULL; observer = observer->next) {\n\t\tif (observer->priority > highest_observer_priority && observer->enabled) {\n\t\t\thighest_observer = observer;\n\t\t\thighest_observer_priority = observer->priority;\n\t\t}\n\t}\n\n\tchan->highest_observer = highest_observer;\n\tk_spin_unlock(&chan->lock, key);\n}", "CodeBleu_score": 32.279001482519234}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tstruct zbus_observer *highest_obs = NULL;\n\tint highest_priority = 0;\n\tint obs_priority;\n\n\tif (!chan) {\n\t\treturn;\n\t}\n\n\t/*\n\t * Lock the channel data\n\t */\n\tzbus_chan_lock(chan);\n\n\t/*\n\t * Iterate through the observers\n\t */\n\tfor (obs = zbus_chan_observers_get(chan); obs; obs = zbus_observer_next(obs)) {\n\t\tobs_priority = zbus_observer_priority_get(obs);\n\n\t\t/*\n\t\t * If the observer is enabled\n\t\t */\n\t\tif (zbus_observer_enabled_get(obs)) {\n\t\t\t/*\n\t\t\t * If the observer has a higher priority than the current highest\n\t\t\t */\n\t\t\tif (obs_priority > highest_priority) {\n\t\t\t\thighest_obs = obs;\n\t\t\t\thighest_priority = obs_priority;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Set the channel's highest observer priority to the determined value\n\t */\n\tzbus_chan_highest_observer_priority_set(chan, highest_priority);\n\n\t/*\n\t * Unlock the channel data\n\t */\n\tzbus_chan_unlock(chan);\n}", "CodeBleu_score": 32.751167969535786}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tfor (int i = 0; i < obs->num_channels; i++) {\n\t\tif (obs->channels[i].observer == obs) {\n\t\t\tupdate_channel_hop(obs, obs->channels[i].channel);\n\t\t}\n\t}\n}", "CodeBleu_score": 21.736620590306895}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *channel_observation;\n\tstruct zbus_channel *channel;\n\tstruct zbus_channel_observation *tmp;\n\tstruct zbus_channel_observation *tmp2;\n\n\tchannel_observation = zbus_channel_observation_first(obs);\n\n\twhile (channel_observation) {\n\t\tchannel = channel_observation->channel;\n\t\tif (channel->observer == obs) {\n\t\t\ttmp = channel_observation;\n\t\t\tchannel_observation = channel_observation->next;\n\t\t\tzbus_channel_observation_remove(tmp);\n\t\t\tzbus_channel_observation_add(channel, obs);\n\t\t} else {\n\t\t\tchannel_observation = channel_observation->next;\n\t\t}\n\t}\n\n\tchannel_observation = zbus_channel_observation_first(obs);\n\n\twhile (channel_observation) {\n\t\tchannel = channel_observation->channel;\n\t\tif (channel->observer == obs) {\n\t\t\ttmp = channel_observation;\n\t\t\tchannel_observation = channel_observation->next;\n\t\t\tzbus_channel_observation_remove(tmp);\n\t\t\tzbus_channel_observation_add(channel, obs);\n\t\t} else {\n\t\t\tchannel_observation = channel_observation->next;\n\t\t}\n\t}\n}", "CodeBleu_score": 15.514697691745654}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *obs_iter;\n\tstruct zbus_channel_observation *obs_iter_next;\n\tfor (obs_iter = obs->channels; obs_iter!= NULL; obs_iter = obs_iter_next) {\n\t\tobs_iter_next = obs_iter->next;\n\t\tif (obs_iter->observer == obs) {\n\t\t\tupdate_channel_hop(obs_iter);\n\t\t}\n\t}\n}", "CodeBleu_score": 18.639798697608654}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_SAFE)) {\n\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_SAFE_IS_ISR)) {\n\t\t\treturn -EIS_ISR;\n\t\t}\n\t\tif (obs == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tzbus_observer_lock();\n\n\tif (zbus_obs_is_attached_to_thread(obs)) {\n\t\tzbus_obs_detach_from_thread(obs);\n\t}\n\n\tzbus_obs_set_priority(obs, ZBUS_THREAD_PRIORITY_MIN);\n\n\tzbus_obs_update_channels(obs);\n\n\tzbus_observer_unlock();\n\n\treturn 0;\n}", "CodeBleu_score": 42.99136214261078}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t/*\n\t\t * The observer's priority must be the minimum thread priority.\n\t\t */\n\t\tif (obs->priority!= ZBUS_OBSERVER_THREAD_PRIORITY_MIN) {\n\t\t\tLOG_ERR(\"Observer priority is not the minimum thread priority\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * The observer must not be null.\n\t */\n\tif (!obs) {\n\t\tLOG_ERR(\"Observer is null\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * The observer must not be attached to a thread.\n\t */\n\tif (obs->thread) {\n\t\tLOG_ERR(\"Observer is already attached to a thread\");\n\t\treturn -EALREADY;\n\t}\n\n\t/*\n\t * The observer must not be attached to an ISR.\n\t */\n\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\t\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\t\t\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\t\t\t\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\t\t\t\t\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_THREAD_PRIORITY_MIN)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_OBSERVER_", "CodeBleu_score": 35.02613130153536}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tARG_UNUSED(obs);\n\treturn 0;\n}", "CodeBleu_score": 8.374882378874055}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\tk_timeout_t end_time;\n\n\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_IN_ISR) {\n\t\ttimeout = k_uptime_delta(&chan->timeout);\n\t}\n\n\tend_time = k_uptime_get() + timeout;\n\n\tzbus_chan_lock(chan);\n\n\tif (chan->context_priority!= 0) {\n\t\t/*\n\t\t * If the context priority is not zero, it means that the context priority has been set\n\t\t * and the notification logic will be executed in the context of the channel's\n\t\t * priority.\n\t\t */\n\t\terr = zbus_chan_notify_isr(chan, end_time);\n\t} else {\n\t\t/*\n\t\t * If the context priority is zero, it means that the notification logic will be\n\t\t * executed in the context of the calling thread.\n\t\t */\n\t\terr = zbus_chan_notify_thread(chan, end_time);\n\t}\n\n\tzbus_chan_unlock(chan);\n\n\treturn err;\n}", "CodeBleu_score": 39.551094644657844}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tif (!chan) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ENABLED(CONFIG_ZBUS_CHAN_NOTIFY_IN_ISR)) {\n\t\ttimeout = k_uptime_delta(&chan->notify_timeout);\n\t}\n\n\tk_timeout_t end_time = k_uptime_get() + timeout;\n\tk_priority_t ctx_prio = k_current_get()->priority;\n\n\tzbus_chan_lock(chan);\n\n\tint err = 0;\n\n\tif (chan->notify_cb) {\n\t\terr = chan->notify_cb(chan, timeout);\n\t}\n\n\tzbus_chan_unlock(chan);\n\n\tif (IS_ENABLED(CONFIG_ZBUS_CHAN_NOTIFY_IN_ISR)) {\n\t\tk_timeout_t delta = k_uptime_delta(&chan->notify_timeout);\n\n\t\tif (delta < 0) {\n\t\t\tdelta = 0;\n\t\t}\n\n\t\tk_timeout_set(&chan->notify_timeout, delta);\n\t}\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (IS_ENABLED(CONFIG_ZBUS_CHAN_NOTIFY_IN_ISR)) {\n\t\treturn 0;\n\t}\n\n\tif (ctx_prio!= k_current_get()->priority) {\n\t\treturn -EPERM;\n\t}\n\n\tk_timeout_t delta = k_uptime_delta(&chan->notify_timeout);\n\n\tif (delta < 0) {\n\t\tdelta = 0;\n\t}\n\n\tk_timeout_set(&chan->notify_timeout, delta);\n\n\treturn 0;\n}", "CodeBleu_score": 43.664887335543476}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (k_is_in_isr()) {\n\t\tif (timeout!= K_NO_WAIT) {\n\t\t\ttimeout = k_uptime_delta(&chan->timeout_end);\n\t\t}\n\n\t\tif (timeout == K_NO_WAIT) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tk_timeout_t end = k_uptime_add(k_uptime_get(), timeout);\n\n\tif (k_mutex_lock(&chan->mutex, timeout)!= 0) {\n\t\treturn -EBUSY;\n\t}\n\n\tchan->timeout_end = end;\n\n\tif (chan->notify(chan)!= 0) {\n\t\tk_mutex_unlock(&chan->mutex);\n\t\treturn -EIO;\n\t}\n\n\tk_mutex_unlock(&chan->mutex);\n\n\treturn 0;\n}", "CodeBleu_score": 38.33087560325422}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t it = 0;\n\tuint32_t enable_bits = 0;\n\tuint32_t disable_bits = 0;\n\n\tif (enable == TRUE) {\n\t\tswitch (Int) {\n\t\tcase ETH_INT_FRAME_RECEIVED:\n\t\t\tenable_bits = ETH_INT_FRAME_RECEIVED_MASK;\n\t\t\tdisable_bits = ETH_INT_FRAME_TRANSMITTED_MASK\n\t\t\t\t\t| ETH_INT_ERROR_MASK | ETH_INT_ABNORMAL_MASK;\n\t\t\tbreak;\n\t\tcase ETH_INT_FRAME_TRANSMITTED:\n\t\t\tenable_bits = ETH_INT_FRAME_TRANSMITTED_MASK;\n\t\t\tdisable_bits = ETH_INT_FRAME_RECEIVED_MASK | ETH_INT_ERROR_MASK\n\t\t\t\t\t| ETH_INT_ABNORMAL_MASK;\n\t\t\tbreak;\n\t\tcase ETH_INT_ERROR:\n\t\t\tenable_bits = ETH_INT_ERROR_MASK;\n\t\t\tdisable_bits = ETH_INT_FRAME_RECEIVED_MASK | ETH_INT_FRAME_TRANSMITTED_MASK\n\t\t\t\t\t| ETH_INT_ABNORMAL_MASK;\n\t\t\tbreak;\n\t\tcase ETH_INT_ABNORMAL:\n\t\t\tenable_bits = ETH_INT_ABNORMAL_MASK;\n\t\t\tdisable_bits = ETH_INT_FRAME_RECEIVED_MASK | ETH_INT_FRAME_TRANSMITTED_MASK\n\t\t\t\t\t| ETH_INT_ERROR_MASK;\n\t\t\tbreak;\n\t\tcase ETH_INT_ALL:\n\t\t\tenable_bits = ETH_INT_ALL_MASK;\n\t\t\tdisable_bits = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (Int) {\n\t\tcase ETH_INT_FRAME_RECEIVED:\n\t\t\tdisable_bits = ETH_INT_FRAME_RECEIVED_MASK;\n\t\t\tbreak;\n\t\tcase ETH_INT_FRAME_TRANSMITTED:\n\t\t\tdisable_bits = ETH_INT_FRAME_TRANSMITTED_MASK;\n\t\t\tbreak;\n\t\tcase ETH_INT_ERROR:\n\t\t\tdisable_bits = ETH_INT_ERROR_MASK;\n\t\t\tbreak;\n\t\tcase ETH_INT_ABNORMAL:\n\t\t\tdisable_bits = ETH_INT_", "CodeBleu_score": 28.201674833063596}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (Int == ETH_IT_FRAME_ERROR) {\n\t\tif (enable) {\n\t\t\tETH->DMASR |= ETH_DMASR_FBE;\n\t\t} else {\n\t\t\tETH->DMASR &= ~ETH_DMASR_FBE;\n\t\t}\n\t} else if (Int == ETH_IT_FIFO_OVERFLOW) {\n\t\tif (enable) {\n\t\t\tETH->DMASR |= ETH_DMASR_FO;\n\t\t} else {\n\t\t\tETH->DMASR &= ~ETH_DMASR_FO;\n\t\t}\n\t} else if (Int == ETH_IT_FIFO_UNDERFLOW) {\n\t\tif (enable) {\n\t\t\tETH->DMASR |= ETH_DMASR_FU;\n\t\t} else {\n\t\t\tETH->DMASR &= ~ETH_DMASR_FU;\n\t\t}\n\t} else if (Int == ETH_IT_ERROR) {\n\t\tif (enable) {\n\t\t\tETH->DMASR |= ETH_DMASR_EC;\n\t\t} else {\n\t\t\tETH->DMASR &= ~ETH_DMASR_EC;\n\t\t}\n\t} else if (Int == ETH_IT_ABNORMAL_INTERRUPT) {\n\t\tif (enable) {\n\t\t\tETH->DMASR |= ETH_DMASR_AIS;\n\t\t} else {\n\t\t\tETH->DMASR &= ~ETH_DMASR_AIS;\n\t\t}\n\t} else if (Int == ETH_IT_NORMAL_INTERRUPT) {\n\t\tif (enable) {\n\t\t\tETH->DMASR |= ETH_DMASR_NIS;\n\t\t} else {\n\t\t\tETH->DMASR &= ~ETH_DMASR_NIS;\n\t\t}\n\t} else if (Int == ETH_IT_RECEIVE_ERROR) {\n\t\tif (enable) {\n\t\t\tETH->DMASR |= ETH_DMASR_RE;\n\t\t} else {\n\t\t\tETH->DMASR &= ~ETH_DMASR_RE;\n\t\t}\n\t} else if (Int == ETH_IT_TRANSMIT_ERROR) {\n\t\tif (enable) {\n\t\t\tETH->DMASR |= ETH_DMASR_TE;\n\t\t} else {\n\t\t\tETH->DMAS", "CodeBleu_score": 32.006181541686296}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t tmpreg = 0;\n\tuint32_t enable_bit = 0;\n\tuint32_t disable_bit = 0;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_IT(Int));\n\n\t/* Get the Interrupt enable register value */\n\ttmpreg = ETH->NITR;\n\n\t/* Get interrupt enable bit */\n\tenable_bit = Int << 16;\n\tdisable_bit = enable_bit << 1;\n\n\tif (enable) {\n\t\t/* Set interrupt enable bit */\n\t\ttmpreg |= enable_bit;\n\n\t\t/* Check if interrupt is normal or abnormal */\n\t\tif (Int < 32) {\n\t\t\t/* Set normal interrupt enable bit */\n\t\t\tETH->NIE |= enable_bit;\n\t\t} else {\n\t\t\t/* Set abnormal interrupt enable bit */\n\t\t\tETH->AIE |= disable_bit;\n\t\t}\n\t} else {\n\t\t/* Clear interrupt enable bit */\n\t\ttmpreg &= ~enable_bit;\n\n\t\t/* Check if interrupt is normal or abnormal */\n\t\tif (Int < 32) {\n\t\t\t/* Clear normal interrupt enable bit */\n\t\t\tETH->NIE &= ~enable_bit;\n\t\t} else {\n\t\t\t/* Clear abnormal interrupt enable bit */\n\t\t\tETH->AIE &= ~disable_bit;\n\t\t}\n\t}\n\n\t/* Write interrupt enable register */\n\tETH->NITR = tmpreg;\n}", "CodeBleu_score": 40.3261269015168}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t u32TxDescAddr;\n\tuint32_t u32DescIndex;\n\n\t/* Get the current transmit descriptor address */\n\tu32TxDescAddr = ETH_GetTxDescAddr();\n\n\t/* Get the current transmit descriptor index */\n\tu32DescIndex = ETH_GetTxDescIndex();\n\n\t/* Check if the descriptor is owned by the device */\n\tif (ETH_IsTxDescOwnedByDevice(u32TxDescAddr)) {\n\t\t/* Get the next descriptor address */\n\t\tu32TxDescAddr = ETH_GetTxDescAddr(u32TxDescAddr, 1);\n\n\t\t/* Check if the next descriptor is owned by the device */\n\t\tif (ETH_IsTxDescOwnedByDevice(u32TxDescAddr)) {\n\t\t\t/* Get the next descriptor address */\n\t\t\tu32TxDescAddr = ETH_GetTxDescAddr(u32TxDescAddr, 1);\n\n\t\t\t/* Check if the next descriptor is owned by the device */\n\t\t\tif (ETH_IsTxDescOwnedByDevice(u32TxDescAddr)) {\n\t\t\t\t/* Get the next descriptor address */\n\t\t\t\tu32TxDescAddr = ETH_GetTxDescAddr(u32TxDescAddr, 1);\n\n\t\t\t\t/* Check if the next descriptor is owned by the device */\n\t\t\t\tif (ETH_IsTxDescOwnedByDevice(u32TxDescAddr)) {\n\t\t\t\t\t/* Get the next descriptor address */\n\t\t\t\t\tu32TxDescAddr = ETH_GetTxDescAddr(u32TxDescAddr, 1);\n\n\t\t\t\t\t/* Check if the next descriptor is owned by the device */\n\t\t\t\t\tif (ETH_IsTxDescOwnedByDevice(u32TxDescAddr)) {\n\t\t\t\t\t\t/* Get the next descriptor address */\n\t\t\t\t\t\tu32TxDescAddr = ETH_GetTxDescAddr(u32TxDescAddr, 1);\n\n\t\t\t\t\t\t/* Check if the next descriptor is owned by the device */\n\t\t\t\t\t\tif (ETH_IsTxDescOwnedByDevice(u32TxDescAddr)) {\n\t\t\t\t\t\t\t/* Get the next descriptor address */\n\t\t\t\t\t\t\tu32TxDescAddr = ETH_GetTxDescAddr(u32TxDescAddr, 1);\n\n\t\t\t\t\t\t\t/* Check", "CodeBleu_score": 31.14797228966274}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc;\n\tuint32_t tmp;\n\n\t/* Get current transmit descriptor address */\n\ttmp = (uint32_t) ETH_GetDMATxDescToProcess();\n\n\t/* Get the current transmit descriptor */\n\ttx_desc = (ETH_TX_DESC *) tmp;\n\n\t/* Check if the descriptor is owned by the device */\n\tif (tx_desc->Status & ETH_DMATxDesc_OWN) {\n\t\t/* Check if the descriptor is owned by the DMA */\n\t\tif (tx_desc->Status & ETH_DMATxDesc_OWN) {\n\t\t\t/* Get the next transmit descriptor */\n\t\t\ttx_desc = (ETH_TX_DESC *) ((uint32_t) tx_desc + ETH_DMATxDesc_Size);\n\n\t\t\t/* Check if the next transmit descriptor is owned by the DMA */\n\t\t\tif (tx_desc->Status & ETH_DMATxDesc_OWN) {\n\t\t\t\t/* Get the next transmit descriptor */\n\t\t\t\ttx_desc = (ETH_TX_DESC *) ((uint32_t) tx_desc + ETH_DMATxDesc_Size);\n\n\t\t\t\t/* Check if the next transmit descriptor is owned by the DMA */\n\t\t\t\tif (tx_desc->Status & ETH_DMATxDesc_OWN) {\n\t\t\t\t\t/* Get the next transmit descriptor */\n\t\t\t\t\ttx_desc = (ETH_TX_DESC *) ((uint32_t) tx_desc + ETH_DMATxDesc_Size);\n\n\t\t\t\t\t/* Check if the next transmit descriptor is owned by the DMA */\n\t\t\t\t\tif (tx_desc->Status & ETH_DMATxDesc_OWN) {\n\t\t\t\t\t\t/* Get the next transmit descriptor */\n\t\t\t\t\t\ttx_desc = (ETH_TX_DESC *) ((uint32_t) tx_desc + ETH_DMATxDesc_Size);\n\n\t\t\t\t\t\t/* Check if the next transmit descriptor is owned by the DMA */\n\t\t\t\t\t\tif (tx_desc->Status & ETH_DMATxDesc_OWN) {\n\t\t\t\t\t\t\t/* Get the next transmit descriptor */\n\t\t\t\t\t\t\ttx_desc = (ETH_TX_DESC *) ((uint32_t) tx_desc + ETH_DMATxDesc_Size);\n\n\t\t\t\t\t\t\t/* Check if the next transmit descriptor is owned by the DMA */\n\t\t\t\t\t\t\tif (tx_desc", "CodeBleu_score": 42.589041607189756}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc;\n\tuint32_t tx_desc_addr;\n\tuint32_t tx_desc_addr_next;\n\n\t/* Get the current transmit descriptor address */\n\ttx_desc_addr = ETH_GetTxDescAddr();\n\n\t/* Check if the descriptor is owned by the device */\n\tif ((ETH_GetTxDescStatus(tx_desc_addr) & ETH_TX_DESC_OWN) == 0) {\n\t\t/* The descriptor is owned by the device */\n\t\treturn (ETH_TX_DESC *)tx_desc_addr;\n\t}\n\n\t/* The descriptor is not owned by the device */\n\ttx_desc = (ETH_TX_DESC *)tx_desc_addr;\n\n\t/* Continue to the next descriptor in the list until it loops back to the starting address */\n\ttx_desc_addr_next = tx_desc_addr;\n\tdo {\n\t\t/* Get the address of the next descriptor */\n\t\ttx_desc_addr_next = tx_desc_addr_next + sizeof(ETH_TX_DESC);\n\n\t\t/* Check if the descriptor is owned by the device */\n\t\tif ((ETH_GetTxDescStatus(tx_desc_addr_next) & ETH_TX_DESC_OWN) == 0) {\n\t\t\t/* The descriptor is owned by the device */\n\t\t\treturn (ETH_TX_DESC *)tx_desc_addr_next;\n\t\t}\n\n\t\t/* The descriptor is not owned by the device */\n\t\ttx_desc = (ETH_TX_DESC *)tx_desc_addr_next;\n\t} while (tx_desc_addr_next!= tx_desc_addr);\n\n\t/* No free descriptor found */\n\treturn NULL;\n}", "CodeBleu_score": 42.78380768049627}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t ret = RT_EOK;\n\tstruct rt_dac_device *dac_device = RT_NULL;\n\tstruct rt_dac_config *dac_config = RT_NULL;\n\tcy_stc_csd_dac_config_t dac_config_info;\n\n\t/* Check if the device is null */\n\tif (device == RT_NULL) {\n\t\trt_kprintf(\"device is null\n\");\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* Get the DAC device and check if it is null */\n\tdac_device = (struct rt_dac_device *)device->parent.user_data;\n\tif (dac_device == RT_NULL) {\n\t\trt_kprintf(\"dac_device is null\n\");\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* Get the DAC configuration and check if it is null */\n\tdac_config = (struct rt_dac_config *)dac_device->config;\n\tif (dac_config == RT_NULL) {\n\t\trt_kprintf(\"dac_config is null\n\");\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* Set the DAC configuration */\n\tdac_config_info.dacChannel = channel;\n\tdac_config_info.dacResolution = dac_config->resolution;\n\tdac_config_info.dacClock = dac_config->clock;\n\tdac_config_info.dacOutput = dac_config->output;\n\tdac_config_info.dacReference = dac_config->reference;\n\tdac_config_info.dacRange = dac_config->range;\n\tdac_config_info.dacGain = dac_config->gain;\n\tdac_config_info.dacOffset = dac_config->offset;\n\n\t/* Enable the DAC output */\n\tret = Cy_CSDIDAC_OutputEnable(&dac_config_info, *value);\n\tif (ret!= CY_RSLT_SUCCESS) {\n\t\trt_kprintf(\"Cy_CSDIDAC_OutputEnable failed\n\");\n\t\treturn -RT_ERROR;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 41.544455920781786}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t ret;\n\tstruct rt_dac_device *dac_device = (struct rt_dac_device *) device;\n\tstruct rt_dac_config *dac_config = (struct rt_dac_config *) dac_device->parent.user_data;\n\tstruct rt_dac_data *dac_data = (struct rt_dac_data *) dac_device->parent.user_data;\n\tuint8_t dac_channel;\n\n\tif (channel > dac_config->channel_num) {\n\t\treturn RT_ERROR;\n\t}\n\n\tif (channel == 0) {\n\t\tdac_channel = 0;\n\t} else {\n\t\tdac_channel = 1;\n\t}\n\n\t/* Enable the DAC channel */\n\tret = Cy_CSDIDAC_OutputEnable(dac_data->base, dac_channel, *value);\n\n\treturn ret;\n}", "CodeBleu_score": 41.81063491809749}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\tcy_en_csd_idac_channel_t idacChannel;\n\tcy_en_csd_idac_channel_config_t idacChannelConfig;\n\tcy_en_csd_idac_channel_config_t *idacChannelConfigPtr = NULL;\n\tcy_en_csd_idac_channel_config_t idacChannelConfigDefault = {\n\t\t.idacValue = 0,\n\t\t.idacGain = CY_CSD_IDAC_GAIN_1X,\n\t\t.idacRange = CY_CSD_IDAC_RANGE_1024,\n\t\t.idacMode = CY_CSD_IDAC_MODE_NORMAL,\n\t\t.idacOutputMode = CY_CSD_IDAC_OUTPUT_MODE_DIRECT,\n\t\t.idacOutputStrobe = CY_CSD_IDAC_OUTPUT_STROBE_DISABLED,\n\t\t.idacOutputBuffer = CY_CSD_IDAC_OUTPUT_BUFFER_DISABLED,\n\t\t.idacOutputBufferGain = CY_CSD_IDAC_OUTPUT_BUFFER_GAIN_1X,\n\t\t.idacOutputBufferRange = CY_CSD_IDAC_OUTPUT_BUFFER_RANGE_1024,\n\t\t.idacOutputBufferMode = CY_CSD_IDAC_OUTPUT_BUFFER_MODE_NORMAL,\n\t\t.idacOutputBufferOutput = CY_CSD_IDAC_OUTPUT_BUFFER_OUTPUT_DISABLED,\n\t\t.idacOutputBufferOutputStrobe = CY_CSD_IDAC_OUTPUT_BUFFER_OUTPUT_STROBE_DISABLED,\n\t\t.idacOutputBufferOutputBuffer = CY_CSD_IDAC_OUTPUT_BUFFER_OUTPUT_BUFFER_DISABLED,\n\t\t.idacOutputBufferOutputBufferGain = CY_CSD_IDAC_OUTPUT_BUFFER_OUTPUT_BUFFER_GAIN_1X,\n\t\t.idacOutputBufferOutputBufferRange = CY_CSD_IDAC_OUTPUT_BUFFER_OUTPUT_BUFFER_RANGE_1024,\n\t\t.idacOutputBufferOutputBufferMode = CY_CSD_IDAC_OUTPUT_BUFFER_OUTPUT_BUFFER_MODE_NORMAL,\n\t\t.idacOutputBufferOutputBufferOutput", "CodeBleu_score": 34.762915158113664}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint8_t *p;\n\n\tif ((addr + size) > (FLASH_BASE_ADDR + FLASH_SIZE)) {\n\t\trt_kprintf(\"Flash read error: address out of range.\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tp = buf;\n\tfor (i = 0; i < size; i++) {\n\t\t*p = *(rt_uint8_t *) (addr + i);\n\t\tp++;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 54.748305843337974}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\n\tif (addr + size > 0x800000) {\n\t\trt_kprintf(\"ifx_flash_read_32k: read operation would exceed the end address of the flash memory.\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 45.45851243663326}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif ((addr + size) > 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "CodeBleu_score": 14.791649415052541}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\trt_uint32_t count = 0;\n\n\tRT_ASSERT(timer!= RT_NULL);\n\n\tcyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n\n\tcount = cyhal_timer_read(obj);\n\n\treturn count;\n}", "CodeBleu_score": 66.55719334684892}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\trt_uint32_t count = 0;\n\tif (timer!= RT_NULL) {\n\t\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\t\tcount = cyhal_timer_read(timer_obj);\n\t}\n\treturn count;\n}", "CodeBleu_score": 63.80643345477287}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tif (timer == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 51.56030628654988}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\tint ret;\n\n\tret = pthread_mutex_lock(&dfs_mutex);\n\tif (ret!= 0) {\n\t\tassert(ret == 0);\n\t}\n}", "CodeBleu_score": 7.11745397062465}, {"code": "void dfs_lock(void){\n\t\tint ret;\n\tret = pthread_mutex_lock(&dfs_lock_mutex);\n\tif (ret!= 0) {\n\t\tassert(0);\n\t}\n}", "CodeBleu_score": 10.658691794741717}, {"code": "void dfs_lock(void){\n\t\twhile (pthread_mutex_lock(&dfs_mutex)!= 0) {\n\t\tassert(0);\n\t}\n}", "CodeBleu_score": 16.246446862852707}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint fd;\n\tint ret;\n\tint n;\n\n\tif (fdt == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\n\tif (startfd >= fdt->max_fds) {\n\t\treturn -1;\n\t}\n\n\tfor (i = startfd; i < fdt->max_fds; i++) {\n\t\tfd = fdt->fd[i];\n\t\tif (fd == -1) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t/*\n\t * Expand the fd table if no empty slot is found.\n\t */\n\tn = fdt->max_fds * 2;\n\tret = fd_table_expand(fdt, n);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (i = startfd; i < fdt->max_fds; i++) {\n\t\tfd = fdt->fd[i];\n\t\tif (fd == -1) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 45.51179492963257}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\n\tfor (i = startfd; i < fdt->max_fds; i++) {\n\t\tif (fdt->fd[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t/*\n\t * If no empty slot is found, expand the fd table.\n\t */\n\tif (fd_table_expand(fdt) < 0) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Search for an empty slot again.\n\t */\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 39.23207196761538}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\n\tif (startfd < 0) {\n\t\tfor (i = 0; i < fdt->max_fds; i++) {\n\t\t\tif (fdt->fd[i].fd == -1) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = startfd; i < fdt->max_fds; i++) {\n\t\t\tif (fdt->fd[i].fd == -1) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 32.724795563731064}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tfor (i = 0; i < RT_ERR_NUM; i++) {\n\t\tif (rt_err_table[i].code == error) {\n\t\t\treturn rt_err_table[i].msg;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 45.56224526049218}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\trt_err_t err = error;\n\tif (err < 0) {\n\t\terr = -err;\n\t}\n\tstatic const char *err_strings[] = { \"EOK\", \"EPERM\", \"ENOENT\", \"EIO\", \"EINTR\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"EIO\", \"E", "CodeBleu_score": 9.287972377464515}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tconst char *err_str;\n\n\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (i = 0; i < RT_ERR_MAX; i++) {\n\t\tif (rt_err_table[i].code == error) {\n\t\t\terr_str = rt_err_table[i].string;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == RT_ERR_MAX) {\n\t\terr_str = \"EUNKNOWN\";\n\t}\n\n\treturn err_str;\n}", "CodeBleu_score": 53.69574899842628}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_spin_lock(&_idle_hook_lock);\n\tif (_idle_hook_list_head == NULL) {\n\t\t_idle_hook_list_head = hook;\n\t\t_idle_hook_list_tail = hook;\n\t} else {\n\t\t_idle_hook_list_tail->next = hook;\n\t\t_idle_hook_list_tail = hook;\n\t}\n\trt_spin_unlock(&_idle_hook_lock);\n\treturn result;\n}", "CodeBleu_score": 22.04749092199557}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t err = RT_EOK;\n\trt_spin_lock(&_idle_hook_list_lock);\n\tif (hook!= RT_NULL) {\n\t\tif (_idle_hook_list.next == RT_NULL) {\n\t\t\t_idle_hook_list.next = &_idle_hook_list;\n\t\t\t_idle_hook_list.prev = &_idle_hook_list;\n\t\t} else {\n\t\t\t_idle_hook_list.next->prev = &_idle_hook_list;\n\t\t\t_idle_hook_list.next = &_idle_hook_list;\n\t\t\t_idle_hook_list.prev->next = &_idle_hook_list;\n\t\t}\n\t\t_idle_hook_list.prev = &_idle_hook_list;\n\t}\n\trt_spin_unlock(&_idle_hook_list_lock);\n\treturn err;\n}", "CodeBleu_score": 24.35417307831819}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\t/* Lock the idle hook list */\n\tlevel = rt_hw_spin_lock_irqsave(&rt_thread_idle_hook_list_lock);\n\n\t/* Find an empty slot */\n\tif (rt_list_isempty(&rt_thread_idle_hook_list)) {\n\t\tresult = -RT_EFULL;\n\t} else {\n\t\trt_list_t *list;\n\t\trt_list_for_each(list, &rt_thread_idle_hook_list) {\n\t\t\tif (list->next == NULL) {\n\t\t\t\trt_list_insert_after(list, &rt_thread_idle_hook_list, &hook);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Unlock the idle hook list */\n\trt_hw_spin_unlock_irqrestore(&rt_thread_idle_hook_list_lock, level);\n\n\treturn result;\n}", "CodeBleu_score": 29.579699123638726}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_uint32_t level;\n\n\t/* Lock the spinlock to ensure thread safety */\n\tlevel = rt_hw_spin_lock_irqsave();\n\n\t/* Iterate through the idle hook list to find the specified hook */\n\tfor (rt_uint32_t i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n\t\tif (rt_thread_idle_hook_list[i] == hook) {\n\t\t\trt_thread_idle_hook_list[i] = RT_NULL;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Unlock the spinlock and return the result */\n\trt_hw_spin_unlock_irqrestore(level);\n\treturn result;\n}", "CodeBleu_score": 51.094570311485064}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = -RT_ENOSYS;\n\trt_uint32_t level;\n\n\t/* Lock the spinlock to ensure thread safety */\n\tlevel = rt_hw_spin_lock_irqsave(&rt_thread_idle_hook_lock);\n\n\t/* Iterate through the idle hook list to find the specified hook */\n\trt_list_t *pos;\n\trt_list_for_each(pos, &rt_thread_idle_hook_list) {\n\t\trt_thread_idle_hook_t *hook_entry = rt_list_entry(pos, rt_thread_idle_hook_t, list);\n\n\t\tif (hook_entry->hook == hook) {\n\t\t\t/* Set the corresponding entry to null */\n\t\t\thook_entry->hook = RT_NULL;\n\n\t\t\t/* Unlock the spinlock and return the result */\n\t\t\trt_hw_spin_unlock_irqrestore(&rt_thread_idle_hook_lock, level);\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* Unlock the spinlock and return the result */\n\trt_hw_spin_unlock_irqrestore(&rt_thread_idle_hook_lock, level);\n\treturn result;\n}", "CodeBleu_score": 35.498452531008496}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = -RT_EOK;\n\trt_list_t *list = rt_list_get(&rt_thread_idle_hook_list);\n\trt_list_t *node = rt_list_get_first(list);\n\trt_list_t *next = RT_NULL;\n\trt_spin_lock(&rt_thread_idle_hook_list_lock);\n\twhile (node!= RT_NULL) {\n\t\tnext = rt_list_get_next(node);\n\t\tif (node->data == hook) {\n\t\t\trt_list_remove(node);\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t\tnode = next;\n\t}\n\trt_spin_unlock(&rt_thread_idle_hook_list_lock);\n\treturn result;\n}", "CodeBleu_score": 44.64583132884397}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_err_t result = RT_EOK;\n\n\trt_base_t level;\n\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* dequeue each thread */\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n\n\t\t/* wake up the thread */\n\t\trt_thread_resume(thread);\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 30.098109515704643}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_list_t *list;\n\n\t/* Ensure the scheduler is unlocked */\n\trt_schedule_lock();\n\n\t/* Dequeue and wakeup each suspended thread from the list one by one until the list is empty */\n\tlist = susp_list;\n\twhile (!rt_list_isempty(list)) {\n\t\t/* Dequeue the thread from the list */\n\t\tthread = rt_list_entry(list->next, rt_thread_t, tlist);\n\t\trt_list_remove(list->next);\n\n\t\t/* Wakeup the thread */\n\t\tthread->error = thread_error;\n\t\tthread->stat = RT_THREAD_READY;\n\t\trt_schedule();\n\t}\n\n\t/* Ensure the scheduler is locked */\n\trt_schedule_unlock();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.02422248268179}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_list_t *list;\n\trt_list_t *next;\n\n\t/* Ensure the scheduler is unlocked. */\n\trt_hw_interrupt_disable();\n\n\t/* Dequeue and wake up each suspended thread from the list one by one. */\n\tlist = susp_list;\n\twhile (!rt_list_isempty(list)) {\n\t\t/* Dequeue the next thread from the list. */\n\t\tnext = list->next;\n\t\tlist->next = NULL;\n\t\tlist->prev = NULL;\n\n\t\t/* Get the thread object. */\n\t\tthread = rt_list_entry(list, rt_thread_t, suspend_list);\n\n\t\t/* Resume the thread. */\n\t\trt_thread_resume(thread, thread_error);\n\n\t\t/* Move to the next thread. */\n\t\tlist = next;\n\t}\n\n\t/* Return RT_EOK to indicate successful completion. */\n\treturn RT_EOK;\n}", "CodeBleu_score": 41.22259499791934}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t console = RT_NULL;\n\trt_device_t old_console = RT_NULL;\n\n\t/* get the old console device */\n\told_console = rt_console_get_device();\n\n\t/* get the new console device */\n\tconsole = rt_device_find(name);\n\n\t/* if the new console device is not the same as the old one */\n\tif (console!= old_console) {\n\t\t/* close the old console device */\n\t\tif (old_console) {\n\t\t\trt_device_close(old_console);\n\t\t}\n\n\t\t/* open the new console device */\n\t\trt_device_open(console, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t}\n\n\t/* set the new console device */\n\trt_console_set_device(console);\n\n\t/* return the old console device */\n\treturn old_console;\n}", "CodeBleu_score": 42.86353158505721}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_dev = rt_console_get_device();\n\trt_device_t new_dev = rt_device_find(name);\n\n\tif (new_dev!= RT_NULL) {\n\t\tif (new_dev!= old_dev) {\n\t\t\tif (old_dev!= RT_NULL) {\n\t\t\t\trt_device_close(old_dev);\n\t\t\t}\n\t\t\tif (rt_device_open(new_dev, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\trt_console_set_device(new_dev);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn old_dev;\n}", "CodeBleu_score": 50.97869813025115}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t console = RT_NULL;\n\trt_device_t old_console = RT_NULL;\n\n\t/* find the console device */\n\told_console = rt_console_get_device();\n\tconsole = rt_device_find(name);\n\tif (console == RT_NULL) {\n\t\trt_kprintf(\"console device %s not found\n\", name);\n\t\treturn old_console;\n\t}\n\n\t/* close the old console device */\n\tif (old_console!= RT_NULL) {\n\t\trt_device_close(old_console);\n\t}\n\n\t/* open the new console device */\n\tif (rt_device_open(console, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM)!= RT_EOK) {\n\t\trt_kprintf(\"console device %s open failed\n\", name);\n\t\treturn old_console;\n\t}\n\n\t/* set the new console device */\n\trt_console_set_device(console);\n\n\treturn old_console;\n}", "CodeBleu_score": 52.24225000798647}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_list_t *list = NULL;\n\trt_list_t *node = NULL;\n\trt_object_t *object = NULL;\n\tint count = 0;\n\trt_base_t level;\n\n\t/* get the object list */\n\tswitch (type) {\n\tcase RT_ObjectClass_Thread:\n\t\tlist = &rt_thread_list;\n\t\tbreak;\n\tcase RT_ObjectClass_Semaphore:\n\t\tlist = &rt_sem_list;\n\t\tbreak;\n\tcase RT_ObjectClass_Mutex:\n\t\tlist = &rt_mutex_list;\n\t\tbreak;\n\tcase RT_ObjectClass_Event:\n\t\tlist = &rt_event_list;\n\t\tbreak;\n\tcase RT_ObjectClass_Mail:\n\t\tlist = &rt_mail_list;\n\t\tbreak;\n\tcase RT_ObjectClass_Timer:\n\t\tlist = &rt_timer_list;\n\t\tbreak;\n\tcase RT_ObjectClass_Work:\n\t\tlist = &rt_work_list;\n\t\tbreak;\n\tcase RT_ObjectClass_Device:\n\t\tlist = &rt_device_list;\n\t\tbreak;\n\tcase RT_ObjectClass_Console:\n\t\tlist = &rt_console_list;\n\t\tbreak;\n\tcase RT_ObjectClass_Socket:\n\t\tlist = &rt_socket_list;\n\t\tbreak;\n\tcase RT_ObjectClass_MTD:\n\t\tlist = &rt_mtd_list;\n\t\tbreak;\n\tcase RT_ObjectClass_MMBlock:\n\t\tlist = &rt_mm_block_list;\n\t\tbreak;\n\tcase RT_ObjectClass_MMHeap:\n\t\tlist = &rt_mm_heap_list;\n\t\tbreak;\n\tcase RT_ObjectClass_MMZone:\n\t\tlist = &rt_mm_zone_list;\n\t\tbreak;\n\tcase RT_ObjectClass_MMPage:\n\t\tlist = &rt_mm_page_list;\n\t\tbreak;\n\tcase RT_ObjectClass_MMRegion:\n\t\tlist = &rt_mm_region_list;\n\t\tbreak;\n\tcase RT_ObjectClass_MMSpace:\n\t\tlist = &rt_mm_space_list;\n\t\tbreak;", "CodeBleu_score": 36.55034097814172}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tstruct rt_spinlock *lock = rt_object_class_get_lock(type);\n\trt_spin_lock(lock);\n\tstruct rt_object *object = rt_object_class_get_object(type);\n\twhile (object!= RT_NULL) {\n\t\tobject = object->parent.next;\n\t\tcount++;\n\t}\n\trt_spin_unlock(lock);\n\treturn count;\n}", "CodeBleu_score": 36.14849696968388}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_class *class;\n\tstruct rt_list_node *node;\n\tint count;\n\n\t/* get the object class */\n\tclass = rt_object_class_get(type);\n\tif (class == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/* get the spinlock */\n\trt_spin_lock(&class->lock);\n\n\t/* get the object count */\n\tcount = 0;\n\tnode = class->list.next;\n\twhile (node!= &class->list) {\n\t\tcount++;\n\t\tnode = node->next;\n\t}\n\n\t/* release the spinlock */\n\trt_spin_unlock(&class->lock);\n\n\treturn count;\n}", "CodeBleu_score": 38.206992874774}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\trt_object_t parent = object->parent;\n\trt_list_t *list = &parent->children;\n\trt_list_remove(list, object);\n\tobject->parent = RT_NULL;\n\tobject->type = RT_Object_Type_None;\n}", "CodeBleu_score": 34.68529817461247}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_object_t object_parent = object->parent;\n\trt_object_t object_sibling = object->sibling;\n\trt_object_t object_child = object->child;\n\trt_object_t object_next = object->next;\n\trt_object_t object_prev = object->prev;\n\n\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\tif (object->flag & RT_OBJECT_FLAG_DEACTIVATED) {\n\t\treturn;\n\t}\n\n\tif (object->flag & RT_OBJECT_FLAG_DEACTIVATING) {\n\t\treturn;\n\t}\n\n\tif (object->flag & RT_OBJECT_FLAG_INHERIT) {\n\t\treturn;\n\t}\n\n\tif (object->flag & RT_OBJECT_FLAG_DETACH) {\n\t\treturn;\n\t}\n\n\tif (object->flag & RT_OBJECT_FLAG_IN_LIST) {\n\t\tobject->flag &= ~RT_OBJECT_FLAG_IN_LIST;\n\t\tobject->parent = RT_NULL;\n\t\tobject->sibling = RT_NULL;\n\t\tobject->child = RT_NULL;\n\t\tobject->next = RT_NULL;\n\t\tobject->prev = RT_NULL;\n\t}\n\n\tif (object->flag & RT_OBJECT_FLAG_IN_HASH) {\n\t\tobject->flag &= ~RT_OBJECT_FLAG_IN_HASH;\n\t\tobject->parent = RT_NULL;\n\t\tobject->sibling = RT_NULL;\n\t\tobject->child = RT_NULL;\n\t\tobject->next = RT_NULL;\n\t\tobject->prev = RT_NULL;\n\t}\n\n\tif (object->flag & RT_OBJECT_FLAG_IN_THREAD) {\n\t\tobject->flag &= ~RT_OBJECT_FLAG_IN_THREAD;\n\t\tobject->parent = RT_NULL;\n\t\tobject->sibling = RT_NULL;\n\t\tobject->child = RT_NULL;\n\t\tobject->next = RT_NULL;\n\t\tobject->prev = RT_NULL;\n\t}\n\n\tif (object->flag & RT_OBJECT_FLAG_IN_TIMER) {\n\t\tobject->flag &= ~RT_OBJECT_FLAG_IN_TIMER;\n\t\tobject->parent = RT_NULL;\n\t\tobject->", "CodeBleu_score": 33.00762527673037}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_list_remove(&(object->parent.list));\n\trt_spin_unlock(&(object->parent.lock));\n\tobject->parent.type = RT_Object_Type_None;\n}", "CodeBleu_score": 15.23659029597444}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result;\n\trt_custom_object_t custom_obj;\n\trt_custom_object_class_t custom_class;\n\n\tif (obj == RT_NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\tcustom_obj = (rt_custom_object_t) obj;\n\tcustom_class = custom_obj->parent.class;\n\n\tif (custom_class->destroy) {\n\t\tresult = custom_class->destroy(custom_obj);\n\t} else {\n\t\tresult = RT_EOK;\n\t}\n\n\trt_free(custom_obj);\n\n\treturn result;\n}", "CodeBleu_score": 43.44367305127517}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->type == RT_Object_Custom);\n\tRT_ASSERT(obj->destroy!= RT_NULL);\n\tif (obj->destroy) {\n\t\tresult = obj->destroy(obj);\n\t}\n\trt_free(obj);\n\treturn result;\n}", "CodeBleu_score": 43.078070171469435}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\tif (obj == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (obj->type!= RT_ObjectClass_Custom) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (obj->destroy!= RT_NULL) {\n\t\treturn obj->destroy(obj);\n\t}\n\n\trt_free(obj);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 41.31790944349022}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\n\tthread = rt_thread_self();\n\n\t/* enter critical */\n\trt_enter_critical();\n\n\t/* close the thread */\n\trt_thread_close(thread);\n\n\t/* add the thread to the defunct thread list */\n\trt_thread_defunct(thread);\n\n\t/* leave critical */\n\trt_exit_critical();\n\n\t/* trigger a context switch */\n\trt_schedule();\n}", "CodeBleu_score": 58.55516388641505}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\n\t/* Get the current thread */\n\tthread = rt_thread_self();\n\n\t/* Enter the critical section */\n\trt_enter_critical();\n\n\t/* Close the thread */\n\trt_thread_close(thread);\n\n\t/* Add the thread to the defunct thread list */\n\trt_thread_delete(thread);\n\n\t/* Exit the critical section */\n\trt_exit_critical();\n\n\t/* Trigger a context switch to the next thread */\n\trt_schedule();\n}", "CodeBleu_score": 58.27913858897023}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\trt_uint32_t level;\n\n\tthread = rt_thread_self();\n\n\t/* enter critical */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* close thread */\n\trt_thread_close(thread);\n\n\t/* add to defunct thread list */\n\trt_list_insert_before(&rt_thread_defunct_list, &thread->tlist);\n\n\t/* leave critical */\n\trt_hw_interrupt_enable(level);\n\n\t/* schedule a new thread */\n\trt_schedule();\n}", "CodeBleu_score": 35.6337764074198}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread = (rt_thread_t) parameter;\n\n\tRT_ASSERT(thread!= RT_NULL);\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* check if the thread is suspended */\n\tif (thread->stat & RT_THREAD_SUSPEND) {\n\t\t/* set the thread's error number to timeout */\n\t\tthread->error = RT_ETIMEOUT;\n\n\t\t/* remove the thread from the suspend list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* insert the thread into the ready list */\n\t\trt_list_insert_after(&(rt_thread_priority_table[RT_THREAD_PRIORITY_MAX]->tlist), &(thread->tlist));\n\n\t\t/* reschedule */\n\t\trt_schedule();\n\t}\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n}", "CodeBleu_score": 37.142854947447844}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread = (rt_thread_t)parameter;\n\n\tRT_ASSERT(thread!= RT_NULL);\n\n\trt_enter_critical();\n\n\tif (thread->stat & RT_THREAD_SUSPEND) {\n\t\tthread->error = -RT_ETIMEOUT;\n\t\trt_list_remove(&(thread->tlist));\n\t\trt_list_insert_before(&(rt_thread_priority_table[0]), &(thread->tlist));\n\t\trt_schedule();\n\t}\n\n\trt_exit_critical();\n}", "CodeBleu_score": 38.78491199346824}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread;\n\trt_err_t result;\n\trt_uint32_t error;\n\n\tthread = (rt_thread_t) parameter;\n\n\tRT_ASSERT(thread!= RT_NULL);\n\n\tresult = rt_thread_lock();\n\tRT_ASSERT(result == RT_EOK);\n\n\terror = RT_ETIMEOUT;\n\n\tif (thread->stat & RT_THREAD_SUSPEND_MASK) {\n\t\tthread->stat &= ~RT_THREAD_SUSPEND_MASK;\n\t\tthread->error = error;\n\n\t\t/* remove thread from suspend list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* insert thread to ready list */\n\t\trt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]), &(thread->tlist));\n\n\t\t/* reschedule */\n\t\trt_schedule();\n\t}\n\n\tresult = rt_thread_unlock();\n\tRT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 41.05393951238069}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spin_lock_irqsave(&thread->lock);\n\tif (thread->mutex!= RT_NULL) {\n\t\trt_list_remove(&thread->mutex->wait_list, &thread->tlist);\n\t\tthread->mutex = RT_NULL;\n\t}\n\trt_spin_unlock_irqrestore(&thread->lock);\n}", "CodeBleu_score": 19.80336265008743}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\t/*\n\t * The function \"_thread_detach_from_mutex\" detaches a thread from any mutex it is waiting on or has taken.", "CodeBleu_score": 4.789156631058016}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spin_lock(&thread->mutex_lock);\n\tif (thread->mutex!= RT_NULL) {\n\t\trt_list_remove(&(thread->mutex_list));\n\t\tthread->mutex = RT_NULL;\n\t}\n\trt_spin_unlock(&thread->mutex_lock);\n}", "CodeBleu_score": 21.701125667785412}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\trt_err_t result;\n\trt_uint8_t *stack_top;\n\trt_uint32_t stack_size;\n\trt_uint32_t priority;\n\trt_uint32_t thread_entry;\n\trt_uint32_t thread_entry_param;\n\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->parent.parent.type == RT_Object_Class_Thread);\n\n\t/* get thread entry and entry param */\n\tthread_entry = (rt_uint32_t)thread->entry;\n\tthread_entry_param = (rt_uint32_t)thread->entry_param;\n\n\t/* get thread priority */\n\tpriority = thread->current_priority;\n\n\t/* get thread stack top and stack size */\n\tstack_top = thread->stack_addr + thread->stack_size;\n\tstack_size = thread->stack_size;\n\n\t/* start thread */\n\tresult = rt_hw_thread_start(thread, stack_top, stack_size, priority, thread_entry, thread_entry_param);\n\n\treturn result;\n}", "CodeBleu_score": 37.89885252839507}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->parent.parent.type == RT_Object_Class_Thread);\n\tRT_ASSERT(thread->parent.parent.status == RT_Object_Status_Initialized);\n\tRT_ASSERT(thread->parent.parent.state == RT_Object_State_Ready);\n\n\trt_kprintf(\"thread %s priority %d\n\", thread->parent.parent.name, thread->parent.priority);\n\tthread->parent.priority = rt_thread_priority_adjust(thread->parent.priority);\n\tthread->parent.parent.state = RT_Object_State_Ready;\n\n\trt_thread_resume(thread);\n\n\tif (rt_thread_scheduler_ready()) {\n\t\trt_thread_scheduler_trigger();\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 45.989933610946764}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(thread->type == RT_THREAD_INIT);\n\n\trt_kprintf(\"thread name: %s, thread priority: %d\n\", thread->name, thread->current_priority);\n\n\tthread->current_priority = rt_thread_priority_2_tick(thread->current_priority);\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\trt_thread_resume(thread);\n\n\trt_thread_scheduler_resume();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 50.95974973404647}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_uint32_t i;\n\trt_list_t *timer;\n\n\t/* Get the first timer entry from the highest level of the timer skip list. */\n\ttimer = rt_list_entry(timer_list[0].next, struct rt_timer, list);\n\n\t/* Check if the list is empty. */\n\tif (timer == RT_NULL) {\n\t\treturn -RT_ENOSYS;\n\t}\n\n\t/* Get the timeout tick from the timer. */\n\t*timeout_tick = timer->timeout;\n\n\t/* Delete the timer from the timer list. */\n\tfor (i = 0; i < RT_TIMER_LEVELS; i++) {\n\t\tif (timer_list[i].next == &timer->list) {\n\t\t\trt_list_remove(&timer->list);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 45.11388283948053}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_uint8_t level;\n\trt_list_t *list;\n\trt_list_t *entry;\n\n\t/* find the highest level of the timer skip list */\n\tfor (level = RT_TIMER_SKIP_LIST_LEVELS - 1; level > 0; level--) {\n\t\tif (timer_list[level].next!= RT_NULL) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* if the highest level of the timer skip list is not empty */\n\tif (level > 0) {\n\t\tlist = &timer_list[level];\n\t\tentry = list->next;\n\n\t\t/* set the timeout tick to the timer's timeout value */\n\t\t*timeout_tick = entry->timeout_tick;\n\n\t\treturn RT_EOK;\n\t}\n\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 41.63096322978533}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_uint32_t level;\n\trt_list_t *node;\n\n\t/* Get the highest level of the timer skip list */\n\tlevel = RT_TIMER_LIST_LEVEL - 1;\n\n\t/* Check if the highest level of the timer skip list is not empty */\n\twhile (level > 0 && rt_list_isempty(&timer_list[level])) {\n\t\tlevel--;\n\t}\n\n\t/* Get the first timer entry from the highest level of the timer skip list */\n\tnode = rt_list_first(&timer_list[level]);\n\n\t/* Set the provided timeout tick to the timer's timeout value */\n\t*timeout_tick = RT_TIMER_LIST_GET_TIMEOUT(node);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.51023788358834}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\trt_err_t err;\n\n\tif (timeout == RT_NULL) {\n\t\trt_kprintf(\"rt_timer_create: timeout function is null", "CodeBleu_score": 18.63678962792632}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* Check the parameters */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time >= RT_TIMER_FLAG_ONE_SHOT);\n\tRT_ASSERT(time <= RT_TIMER_FLAG_PERIODIC);\n\n\t/* Allocate memory for the timer object */\n\ttimer = (rt_timer_t) rt_malloc(sizeof(struct rt_timer));\n\tif (timer!= RT_NULL) {\n\t\t/* Initialize the timer object */\n\t\trt_list_init(&(timer->parent.tlist));\n\t\ttimer->flag = flag;\n\t\ttimer->timeout = timeout;\n\t\ttimer->parameter = parameter;\n\t\ttimer->time = time;\n\t\ttimer->flag = flag;\n\t\ttimer->parent.name = name;\n\t\ttimer->parent.flag = RT_TIMER_FLAG_INIT;\n\n\t\t/* Add the timer object to the timer list */\n\t\trt_timer_list_insert(timer);\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 45.50767304250609}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\tif (timeout == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\ttimer = rt_malloc(sizeof(struct rt_timer));\n\tif (timer!= RT_NULL) {\n\t\ttimer->timeout = timeout;\n\t\ttimer->parameter = parameter;\n\t\ttimer->flag = flag;\n\t\ttimer->time = time;\n\t\ttimer->status = RT_TIMER_INIT;\n\t\ttimer->prev = RT_NULL;\n\t\ttimer->next = RT_NULL;\n\t\trt_list_init(&(timer->tlist));\n\t\trt_list_insert_after(&(timer->tlist), &(timer->tlist));\n\t}\n\treturn timer;\n}", "CodeBleu_score": 51.1082708687679}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\ta.router.ServeHTTP(recorder, req)\n\tfor k, v := range recorder.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tres.WriteHeader(recorder.Code)\n\tres.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 38.07907315489044}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// The function \"NewRecorder\" creates a new response recorder.\nIt returns a new recorder, which implements the \"ResponseWriter\" interface.\n\trecorder := httptest.NewRecorder()\n\t// The function \"ServeHTTP\" serves the request using the given router.\n\ta.router.ServeHTTP(recorder, req)\n\t// The function \"Header\" returns the header map that will be sent by WriteHeader.\n\t// The map also includes header entries set by Write, WriteHeader, or a call to a Flush method.\n\tfor k, v := range recorder.HeaderMap {\n\t\t// The function \"Header\" returns the first value for the named header.\nIf there are no values, it returns \"\".\nTo access or modify all the values, use the map accessed through the \"Header\" method.\n\t\tres.Header().Set(k, v[0])\n\t}\n\t// The function \"WriteHeader\" writes a header to the request.\nThe provided code must be a valid HTTP 1.1 status code.\n\tres.WriteHeader(recorder.Code)\n\t// The function \"Body\" returns the body of the response.\nIt is always safe to read from the returned value.\nThe underlying implementation may copy the data before returning.\n\t// The function \"Write\" writes the data to the connection as part of an HTTP reply.\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data.\n\tres.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 40.15601813953082}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Set the default status code to 200 OK\n\tres.WriteHeader(http.StatusOK)\n\n\t// Capture the request headers\n\theaders := make(map[string][]string)\n\tfor k, v := range req.Header {\n\t\theaders[k] = v\n\t}\n\n\t// Create a recorder to capture the response\n\trec := httptest.NewRecorder()\n\n\t// Call the router to handle the request\n\ta.router.ServeHTTP(rec, req)\n\n\t// Copy the response headers from the recorder to the original response\n\tfor k, v := range rec.HeaderMap {\n\t\tfor _, val := range v {\n\t\t\tres.Header().Add(k, val)\n\t\t}\n\t}\n\n\t// Copy the response body from the recorder to the original response\n\tres.Write(rec.Body.Bytes())\n\n\t// Check for unauthorized status\n\tif rec.Code == http.StatusUnauthorized {\n\t\t// Send the \"Not Authorized\" error response\n\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\tres.Write([]byte(`{\"error\": \"Not Authorized\"}`))\n\t}\n}", "CodeBleu_score": 47.155632053781694}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif strings.HasPrefix(path, \"/api\") {\n\t\tpath = strings.Replace(path, \"/api\", \"\", 1)\n\t}\n\tif strings.HasPrefix(path, \"/\") {\n\t\tpath = strings.Replace(path, \"/\", \"\", 1)\n\t}\n\tif strings.HasSuffix(path, \"/\") {\n\t\tpath = strings.Replace(path, \"/\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".html\") {\n\t\tpath = strings.Replace(path, \".html\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".js\") {\n\t\tpath = strings.Replace(path, \".js\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".css\") {\n\t\tpath = strings.Replace(path, \".css\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".png\") {\n\t\tpath = strings.Replace(path, \".png\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".ico\") {\n\t\tpath = strings.Replace(path, \".ico\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".svg\") {\n\t\tpath = strings.Replace(path, \".svg\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".ttf\") {\n\t\tpath = strings.Replace(path, \".ttf\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".woff\") {\n\t\tpath = strings.Replace(path, \".woff\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".woff2\") {\n\t\tpath = strings.Replace(path, \".woff2\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".json\") {\n\t\tpath = strings.Replace(path, \".json\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".xml\") {\n\t\tpath = strings.Replace(path, \".xml\", \"\", -1)\n\t}\n\tif strings.HasSuffix(path, \".yaml\") {\n\t\tpath = strings.Replace(path, \".yaml\", \"\", -1)\n\t}\n\t", "CodeBleu_score": 26.97530010919263}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tvar err error\n\tvar asset string\n\tvar assetType string\n\tvar assetPath string\n\tvar assetContent []byte\n\tvar assetContentLength int64\n\tvar assetContentType string\n\n\tassetPath = strings.TrimPrefix(req.URL.Path, \"/robeaux\")\n\tasset, err = a.robeaux.Asset(assetPath)\n\tif err!= nil {\n\t\tlog.Println(err)\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\n\tassetType = http.DetectContentType(asset)\n\tassetContentType = assetType\n\tassetContent = asset\n\tassetContentLength = int64(len(asset))\n\n\tswitch assetType {\n\tcase \"text/css\":\n\t\tassetContentType = \"text/css; charset=utf-8\"\n\tcase \"text/html\":\n\t\tassetContentType = \"text/html; charset=utf-8\"\n\tcase \"text/javascript\":\n\t\tassetContentType = \"text/javascript; charset=utf-8\"\n\t}\n\n\tres.Header().Set(\"Content-Type\", assetContentType)\n\tres.Header().Set(\"Content-Length\", fmt.Sprintf(\"%d\", assetContentLength))\n\tres.Write(assetContent)\n}", "CodeBleu_score": 34.03595511149202}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := strings.TrimPrefix(req.URL.Path, \"/robeaux/\")\n\tasset, err := a.robeaux.Asset(path)\n\tif err!= nil {\n\t\tlog.Println(err)\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tcontentType := http.DetectContentType(asset)\n\tres.Header().Set(\"Content-Type\", contentType)\n\tres.Write(asset)\n}", "CodeBleu_score": 36.71814762387498}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, `{\"error\": \"No robot found with the name %s\"}`, robotName)\n\t\treturn\n\t}\n\n\tconnections := make([]robeaux.Connection, 0)\n\tfor _, c := range robot.Connections() {\n\t\tconnections = append(connections, robeaux.Connection{\n\t\t\tName:        c.Name(),\n\t\t\tDescription: c.Description(),\n\t\t\tType:        c.Type(),\n\t\t})\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 47.3067208411759}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\t// Find the robot using the master instance\n\trobot := a.master.Robot(robotName)\n\n\t// If the robot is found, gather its connections and convert them to JSON format\n\tif robot!= nil {\n\t\tconnections := make([]robeaux.Connection, 0)\n\t\tfor _, connection := range robot.Connections() {\n\t\t\tconnections = append(connections, robeaux.Connection{\n\t\t\t\tName: connection.Name(),\n\t\t\t\tType: connection.Type(),\n\t\t\t})\n\t\t}\n\t\tjsonResponse, err := json.Marshal(connections)\n\t\tif err!= nil {\n\t\t\tlog.Printf(\"Error converting connections to JSON: %s\", err.Error())\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Write the JSON response containing the connections\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write(jsonResponse)\n\t} else {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name\n\t\tjsonError := robeaux.Error{\n\t\t\tMessage: fmt.Sprintf(\"No robot found with name %s\", robotName),\n\t\t}\n\t\tjsonResponse, err := json.Marshal(jsonError)\n\t\tif err!= nil {\n\t\t\tlog.Printf(\"Error converting error message to JSON: %s\", err.Error())\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write(jsonResponse)\n\t}\n}", "CodeBleu_score": 41.97616272757957}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tvars := pat.Vars(req)\n\trobotName := vars[\"robot\"]\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\ta.writeError(res, http.StatusNotFound, fmt.Sprintf(\"No robot found with name %s\", robotName))\n\t\treturn\n\t}\n\tconnections, err := robot.Connections()\n\tif err!= nil {\n\t\ta.writeError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\tjsonResponse, err := json.Marshal(connections)\n\tif err!= nil {\n\t\ta.writeError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonResponse)\n}", "CodeBleu_score": 38.075151780147785}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check the \"Authorization\" header for a base64-encoded username and password\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the base64-encoded username and password\n\t\tdecoded, err := base64.StdEncoding.DecodeString(authHeader)\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the username and password\n\t\tusername, password, err := extractUsernameAndPassword(decoded)\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password against the expected values\n\t\tif subtle.ConstantTimeCompare([]byte(username), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 50.48975142537001}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\")!= \"\" {\n\t\t\tauth := r.Header.Get(\"Authorization\")\n\t\t\tif subtle.ConstantTimeCompare([]byte(auth), []byte(\"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password)))) == 1 {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 64.81339297081993}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\tif len(authHeader) == 0 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauth, err := base64.StdEncoding.DecodeString(authHeader[6:])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif subtle.ConstantTimeCompare([]byte(auth), []byte(username+\":\"+password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 53.528416343730576}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept of the scaling transformation\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\t// Calculate the scaled value\n\t\tscaledValue := slope * input + intercept\n\n\t\t// Clamp the scaled value to the target range\n\t\tvalue = int(Clamp(scaledValue, float64(toMin), float64(toMax)))\n\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.420285537172596}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tscaled := slope * input + intercept\n\t\treturn clamp(int(scaled), toMin, toMax)\n\t}\n}", "CodeBleu_score": 48.53906539862353}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.423369332856396}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.connection.Connected() {\n\t\treturn 0, 0, gobot.ErrNotConnected\n\t}\n\n\tif!a.connection.Analog() {\n\t\treturn 0, 0, gobot.ErrNotAnalog\n\t}\n\n\tvalue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = value\n\ta.lastScaled = a.scale(value)\n\n\treturn value, a.lastScaled, nil\n}", "CodeBleu_score": 53.13249607869308}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif!a.Connection.isValid() {\n\t\treturn 0, 0, fmt.Errorf(\"invalid connection\")\n\t}\n\traw, err := a.Connection.AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 45.632960898362015}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection is not valid\")\n\t}\n\n\tif a.connection.AnalogMode() == false {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 52.392142932956}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(input int) float64 {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\t\tintercept := toMin - (slope * fromMin)\n\t\treturn slope * float64(input) + intercept\n\t}\n}", "CodeBleu_score": 44.44789386411549}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(input int) float64 {\n\t\tif input < fromMin {\n\t\t\tinput = fromMin\n\t\t} else if input > fromMax {\n\t\t\tinput = fromMax\n\t\t}\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\t\tn := toMin - m*fromMin\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 61.11408317635987}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMax - m * fromMax\n\treturn func(value int) float64 {\n\t\treturn m * float64(value) + n\n\t}\n}", "CodeBleu_score": 46.03921769661559}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\treturn newGrovePiezoVibrationSensorDriver(a, pin, opts...)\n}", "CodeBleu_score": 7.67656178410034}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewGrovePiezoVibrationSensorDriverWithName(\n\t\t\"grove_piezo_vibration_sensor\",\n\t\ta,\n\t\tpin,\n\t\topts...,\n\t)\n\treturn d\n}", "CodeBleu_score": 13.542979457700044}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tdriver := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tdriver.SetName(\"grove-piezo-vibration-sensor-\" + pin)\n\tdriver.AddEvent(VibrationEvent)\n\tgo func() {\n\t\tfor {\n\t\t\tdata, err := driver.AnalogSensorDriver.Read()\n\t\t\tif err!= nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tif data > 1000 {\n\t\t\t\tdriver.Publish(VibrationEvent, data)\n\t\t\t}\n\t\t}\n\t}()\n\treturn driver\n}", "CodeBleu_score": 45.274985275798855}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.tempo == 0 {\n\t\treturn fmt.Errorf(\"tempo is not set\")\n\t}\n\tif d.pin == 0 {\n\t\treturn fmt.Errorf(\"pin is not set\")\n\t}\n\tif d.pin!= 0 {\n\t\td.pin = 0\n\t}\n\tif d.pin!= 0 {\n\t\td.pin = 0\n\t}\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td.pin = 0\n\td", "CodeBleu_score": 12.459545561986369}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tvar err error\n\tvar period time.Duration\n\tvar tempo float64\n\n\ttempo = float64(d.BPM)\n\tperiod = time.Duration(float64(time.Second) / hz / tempo)\n\n\tfor i := 0; i < int(duration/period); i++ {\n\t\terr = d.On()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(period)\n\t\terr = d.Off()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(period)\n\t}\n\treturn nil\n}", "CodeBleu_score": 33.85105452705229}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.pin == nil {\n\t\treturn fmt.Errorf(\"buzzer pin is not set\")\n\t}\n\n\tif duration < 0 {\n\t\treturn fmt.Errorf(\"duration must be greater than 0\")\n\t}\n\n\tif hz < 0 {\n\t\treturn fmt.Errorf(\"hz must be greater than 0\")\n\t}\n\n\tif d.bpm < 0 {\n\t\treturn fmt.Errorf(\"bpm must be greater than 0\")\n\t}\n\n\td.pin.DigitalWrite(gobot.HIGH)\n\n\tperiod := 1000000 / hz\n\ttoggles := int(float64(period) * duration)\n\n\tfor i := 0; i < toggles; i++ {\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t\td.pin.DigitalWrite(gobot.LOW)\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t\td.pin.DigitalWrite(gobot.HIGH)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 36.73368741837479}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.Stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 30.257989130068808}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"no sleep pin configured\")\n\t}\n\td.Stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 29.527265116875796}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\n\tif d.isSleeping() {\n\t\treturn nil\n\t}\n\n\td.Stop()\n\tgobot.SetPinState(d.sleepPin, gobot.LOW)\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 34.95829224754476}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, err := system.TranslatePin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.newAnalogPin(path)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 49.32901018592209}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins not initialized\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\n\tpin, err := a.newAnalogPin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 45.59436920063804}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin, err := a.newAnalogPin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 45.26422640258526}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.Lock()\n\tdefer a.Unlock()\n\tpin, err := a.getDigitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\terr = pin.DigitalWrite(val)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 55.43869175901814}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif err := pin.DigitalWrite(val); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 66.79745593246096}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.Lock()\n\tdefer a.Unlock()\n\tpin, err := a.getDigitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 50.15843245441089}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.isReady() {\n\t\treturn nil, fmt.Errorf(\"not connected\")\n\t}\n\n\tvar pin gobot.DigitalPin\n\tvar err error\n\n\tif pin, err = a.getPin(id); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, opt := range opts {\n\t\tif!opt(pin) {\n\t\t\treturn nil, fmt.Errorf(\"invalid option\")\n\t\t}\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 30.044764947240584}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tvar (\n\t\tpin gobot.DigitalPin\n\t\terr error\n\t)\n\n\tif a.connected {\n\t\tif len(a.pins) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"no pins connected\")\n\t\t}\n\t\tpin, err = a.pin(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tpin, err = a.newPin(id, opts...)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 37.67378340761241}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.connected == false {\n\t\treturn nil, system.ErrNotConnected\n\t}\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins connected to adaptor\")\n\t}\n\n\tif len(id) == 0 {\n\t\treturn nil, fmt.Errorf(\"no ID provided\")\n\t}\n\n\tpin, err := a.pin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, opt := range opts {\n\t\tif opt(pin) == false {\n\t\t\treturn nil, fmt.Errorf(\"invalid option for pin %s\", pin.ID())\n\t\t}\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 37.63557224285738}]}
