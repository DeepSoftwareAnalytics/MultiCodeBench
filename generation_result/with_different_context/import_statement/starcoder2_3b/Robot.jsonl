{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> result;\n\tstd::string path = folder;\n\tif (path.back()!= '/') {\n\t\tpath += '/';\n\t}\n\tfor (const auto &file : m_required_files) {\n\t\tstd::string file_path = path + file;\n\t\tif (download) {\n\t\t\tif (std::filesystem::exists(file_path)) {\n\t\t\t\tCARLA_LOG_DEBUG(\"File found in cache: {}\", file_path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCARLA_LOG_DEBUG(\"Downloading file: {}\", file_path);\n\t\t\tauto response = m_rpc.DownloadFile(file_path);\n\t\t\tif (response.error) {\n\t\t\t\tCARLA_LOG_ERROR(\"Failed to download file: {}\", file_path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCARLA_LOG_DEBUG(\"File downloaded: {}\", file_path);\n\t\t}\n\t\tresult.push_back(file_path);\n\t}\n\treturn result;\n}", "CodeBleu_score": 47.018752486008815}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> result;\n\tstd::string path = folder + \"/\";\n\tstd::string pattern = path + \"*\";\n\tstd::vector<std::string> files = boost::filesystem::directory_iterator(pattern).map([](const boost::filesystem::directory_entry &entry) { return entry.path().string(); }).to_vector();\n\tfor (const std::string &file : files) {\n\t\tif (download) {\n\t\t\tif (!boost::filesystem::exists(file)) {\n\t\t\t\tstd::cout << \"Downloading file: \" << file << std::endl;\n\t\t\t\tstd::string url = \"file://\" + file;\n\t\t\t\tauto response = rpc::Client::Download(url);\n\t\t\t\tif (response.error) {\n\t\t\t\t\tstd::cout << \"Error downloading file: \" << file << std::endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstd::cout << \"File downloaded: \" << file << std::endl;\n\t\t\t} else {\n\t\t\t\tstd::cout << \"File found in cache: \" << file << std::endl;\n\t\t\t}\n\t\t}\n\t\tresult.push_back(file);\n\t}\n\treturn result;\n}", "CodeBleu_score": 41.221446716983245}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> result;\n\n\ttry {\n\t\tauto reply = rpc_client.call(\"GetRequiredFiles\", folder, download);\n\t\tresult = reply.get<std::vector<std::string>>();\n\t} catch (const carla::rpc::Exception &e) {\n\t\tthrow carla::Exception(e.what());\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 37.56318091779552}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\trpc::ActorId actor_id = rpc::ActorId();\n\trpc::ActorDescription actor_description = rpc::ActorDescription();\n\trpc::ActorId parent_actor = rpc::ActorId();\n\trpc::AttachmentType attachment_type_ = rpc::AttachmentType();\n\tstd::string socket_name_ = std::string();\n\n\tactor_id = description.actor_id;\n\tactor_description = description;\n\tparent_actor = parent;\n\tattachment_type_ = attachment_type;\n\tsocket_name_ = socket_name;\n\n\tif (attachment_type_ == rpc::AttachmentType::SpringArm || attachment_type_ == rpc::AttachmentType::SpringArmGhost) {\n\t\tif (transform.location.z!= 0) {\n\t\t\tstd::cerr << \"WARNING: The transformation to be applied to the actor is ill-formed and will be ignored.\" << std::endl;\n\t\t}\n\t}\n\n\tif (actor_id == rpc::ActorId()) {\n\t\tactor_id = SpawnActor(actor_description, transform);\n\t}\n\n\tif (parent_actor!= rpc::ActorId()) {\n\t\tif (attachment_type_ == rpc::AttachmentType::SpringArm || attachment_type_ == rpc::AttachmentType::SpringArmGhost) {\n\t\t\tif (socket_name_!= std::string()) {\n\t\t\t\trpc::Response response = rpc::Response();\n\t\t\t\trpc::Response::Status status = rpc::Response::Status::Success;\n\n\t\t\t\tresponse = AttachSpringArm(actor_id, parent_actor, transform, socket_name_);\n\n\t\t\t\tstatus = response.status;\n\n\t\t\t\tif (status!= rpc::Response::Status::Success) {\n\t\t\t\t\tthrow carla::Exception(\"Failed to attach SpringArm to the actor.\", status);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trpc::Response response = rpc::Response();\n\t\t\t\trpc::Response::Status status = rpc::Response::Status::Success;\n\n\t\t\t\tresponse = AttachSpringArm(actor_id, parent_actor, transform);\n\n\t\t\t\tstatus = response.status;\n\n\t\t\t\tif (status!= rpc::Response::Status::Success) {\n\t\t\t\t\tthrow carla::Exception(\"Failed to attach SpringArm to the actor.\", status);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trpc::Response response = rpc::Response", "CodeBleu_score": 42.19290307384762}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\t// check if the actor is a vehicle\n\tif (description.HasVehicle()) {\n\t\t// check if the actor is a vehicle\n\t\tif (description.vehicle.HasAckermannControl()) {\n\t\t\t// check if the actor is a vehicle\n\t\t\tif (description.vehicle.ackermann_control.HasSteer()) {\n\t\t\t\t// check if the actor is a vehicle\n\t\t\t\tif (description.vehicle.ackermann_control.steer.HasType()) {\n\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\tif (description.vehicle.ackermann_control.steer.type == rpc::VehicleAckermannControl::Steer::Type::NONE) {\n\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\tif (description.vehicle.ackermann_control.steer.HasRate()) {\n\t\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\t\tif (description.vehicle.ackermann_control.steer.rate < 0.0f) {\n\t\t\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\t\t\tif (description.vehicle.ackermann_control.steer.HasRange()) {\n\t\t\t\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\t\t\t\tif (description.vehicle.ackermann_control.steer.range < 0.0f) {\n\t\t\t\t\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\t\t\t\t\tif (description.vehicle.ackermann_control.steer.HasDeadZone()) {\n\t\t\t\t\t\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\t\t\t\t\t\tif (description.vehicle.ackermann_control.steer.dead_zone < 0.0f) {\n\t\t\t\t\t\t\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\t\t\t\t\t\t\tif (description.vehicle.ackermann_control.steer.HasBrake()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (description.vehicle.ackermann_control.steer.brake < 0.0f) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (description.vehicle.ackermann_control.steer.HasThrottle()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (description.vehicle.ackermann_control.steer.throttle < 0.0f) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check if the actor is a vehicle\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (description.vehicle.ackermann_control", "CodeBleu_score": 15.338471175516617}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\trpc::ActorDescription description_copy = description;\n\tdescription_copy.set_parent_id(parent);\n\tdescription_copy.set_attachment_type(attachment_type);\n\tdescription_copy.set_socket_name(socket_name);\n\treturn SpawnActor(description_copy, transform);\n}", "CodeBleu_score": 25.21408466065026}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\trpc::GBufferId gbuffer_id;\n\tgbuffer_id.set_actor_id(ActorId);\n\tgbuffer_id.set_gbuffer_id(GBufferId);\n\n\trpc::Token token;\n\trpc::Response response;\n\n\tauto error = rpc::Client::SubscribeToGBuffer(\n\t\tm_rpc_client,\n\t\tgbuffer_id,\n\t\ttoken,\n\t\tresponse);\n\n\tif (error!= rpc::Error::Ok) {\n\t\tthrow Exception(error);\n\t}\n\n\tif (response.error_code()!= rpc::ErrorCode::Ok) {\n\t\tthrow Exception(response.error_code());\n\t}\n\n\tauto token_data = token.SerializeAsString();\n\tauto token_size = token_data.size();\n\n\tauto buffer = Buffer(token_data, token_size);\n\tcallback(buffer);\n}", "CodeBleu_score": 41.71971801067825}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\t// TODO: implement this function\n}", "CodeBleu_score": 7.390850490544927}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\t// Retrieve token from server\n\trpc::Response<rpc::GBufferToken> response;\n\tif (rpc::Call(rpc::Client::Instance(), \"SubscribeToGBuffer\", ActorId, GBufferId, &response)) {\n\t\tif (response.HasError()) {\n\t\t\tthrow Exception(response.GetError());\n\t\t}\n\t\trpc::GBufferToken token = response.Get();\n\t\t// Copy token data\n\t\tauto token_data = std::make_shared<rpc::GBufferTokenData>(token.data);\n\t\t// Subscribe to streaming client\n\t\tstreaming::Client::Instance()->Subscribe(token_data, callback);\n\t}\n}", "CodeBleu_score": 41.68276380086156}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (navigation_ == nullptr) {\n\t\tnavigation_ = std::make_shared<WalkerNavigation>(this->client_, this->id_);\n\t}\n\treturn navigation_;\n}", "CodeBleu_score": 26.048877628349327}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (!navigation) {\n\t\tnavigation = std::make_shared<WalkerNavigation>(client);\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 21.107987039026277}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (m_navigation == nullptr) {\n\t\tm_navigation = std::make_shared<WalkerNavigation>(m_client);\n\t}\n\treturn m_navigation;\n}", "CodeBleu_score": 26.310005774935714}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (frame > episode.GetFrame()) {\n\t\tif (std::this_thread::sleep_for(std::chrono::milliseconds(100)) &&!episode.IsRunning()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (std::this_thread::sleep_for(std::chrono::milliseconds(100)) &&!episode.IsRunning()) {\n\t\treturn false;\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 26.917092821980827}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start_time = std::chrono::steady_clock::now();\n\twhile (episode.GetFrame() < frame) {\n\t\tif (std::chrono::steady_clock::now() - start_time > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 35.338042184231675}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = std::chrono::steady_clock::now();\n\twhile (true) {\n\t\tif (episode.CurrentFrame() < frame) {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tif (std::chrono::steady_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 37.5303519953375}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy episode;\n\tbool success = false;\n\tauto timeout = std::chrono::steady_clock::now() + std::chrono::seconds(timeout_seconds);\n\tfor (int i = 0; i < timeout_attempts; i++) {\n\t\ttry {\n\t\t\tauto episode_id = client->LoadEpisode(map_name, reset_settings, map_layers);\n\t\t\tif (episode_id!= episode.id) {\n\t\t\t\tepisode = EpisodeProxy(client, episode_id);\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (TimeoutException&) {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(timeout_milliseconds));\n\t\t}\n\t}\n\tif (!success) {\n\t\tthrow std::runtime_error(\"Unable to connect to episode within timeout.\");\n\t}\n\treturn episode;\n}", "CodeBleu_score": 44.265219693589856}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\t// Check if the map exists\n\tif (!client->GetMapLibrary()->HasMap(map_name)) {\n\t\tCARLA_LOG_E(\"Map does not exist: \" + map_name);\n\t\tthrow std::runtime_error(\"Map does not exist: \" + map_name);\n\t}\n\n\t// Check if the map layers are valid\n\tif (map_layers.HasFlag(rpc::MapLayer::None)) {\n\t\tCARLA_LOG_E(\"Map layers are not valid: \" + std::to_string(map_layers));\n\t\tthrow std::runtime_error(\"Map layers are not valid: \" + std::to_string(map_layers));\n\t}\n\n\t// Check if the episode is already loaded\n\tif (episode) {\n\t\tCARLA_LOG_E(\"Episode is already loaded\");\n\t\tthrow std::runtime_error(\"Episode is already loaded\");\n\t}\n\n\t// Check if the simulator is already running\n\tif (running) {\n\t\tCARLA_LOG_E(\"Simulator is already running\");\n\t\tthrow std::runtime_error(\"Simulator is already running\");\n\t}\n\n\t// Check if the simulator is already running\n\tif (client->IsConnected()) {\n\t\tCARLA_LOG_E(\"Simulator is already connected\");\n\t\tthrow std::runtime_error(\"Simulator is already connected\");\n\t}\n\n\t// Create a new episode\n\tEpisodeProxy episode_proxy(client->GetEpisodeLibrary()->CreateEpisode(map_name, reset_settings, map_layers));\n\n\t// Create a new episode\n\tEpisode episode(client->GetEpisodeLibrary()->CreateEpisode(map_name, reset_settings, map_layers));\n\n\t// Wait for the episode to be ready\n\tepisode.WaitForReady();\n\n\t// Connect to the episode\n\tclient->Connect(episode.GetEpisodeId());\n\n\t// Set the episode\n\tthis->episode = episode;\n\n\t// Set the episode proxy\n\tthis->episode_proxy = episode_proxy;\n\n\t// Return the episode proxy\n\treturn episode_proxy;\n}", "CodeBleu_score": 38.18655672037154}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\t// Check if the map is already loaded.\n\tif (m_map) {\n\t\t// Check if the map name is the same.\n\t\tif (m_map->GetName() == map_name) {\n\t\t\t// Check if the map layers are the same.\n\t\t\tif (m_map->GetMapLayers() == map_layers) {\n\t\t\t\t// Check if the map is already reset.\n\t\t\t\tif (m_map->IsReset()) {\n\t\t\t\t\t// Check if the map is already in use.\n\t\t\t\t\tif (m_map->IsInUse()) {\n\t\t\t\t\t\t// Return the episode.\n\t\t\t\t\t\treturn m_map->GetEpisode();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Check if the episode is already loaded.\n\tif (m_episode) {\n\t\t// Check if the episode is still valid.\n\t\tif (m_episode->IsValid()) {\n\t\t\t// Check if the episode is still in use.\n\t\t\tif (m_episode->IsInUse()) {\n\t\t\t\t// Return the episode.\n\t\t\t\treturn m_episode;\n\t\t\t}\n\t\t}\n\t}\n\t// Check if the episode is already in use.\n\tif (m_episode && m_episode->IsInUse()) {\n\t\t// Return the episode.\n\t\treturn m_episode;\n\t}\n\t// Check if the map is already in use.\n\tif (m_map && m_map->IsInUse()) {\n\t\t// Return the episode.\n\t\treturn m_map->GetEpisode();\n\t}\n\t// Check if the episode is already in use.\n\tif (m_episode && m_episode->IsInUse()) {\n\t\t// Return the episode.\n\t\treturn m_episode;\n\t}\n\t// Check if the map is already in use.\n\tif (m_map && m_map->IsInUse()) {\n\t\t// Return the episode.\n\t\treturn m_map->GetEpisode();\n\t}\n\t// Check if the episode is already in use.\n\tif (m_episode && m_episode->IsInUse()) {\n\t\t// Return the episode.\n\t\treturn m_episode;\n\t}\n\t// Check if the map is already in use.\n\tif (m_map && m_map->IsInUse()) {\n\t\t// Return the episode.\n\t", "CodeBleu_score": 24.549144265740548}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tconst auto &walker = controller.GetWalker();\n\tif (!walker) {\n\t\tthrow std::runtime_error(\"Walker not found.\");\n\t}\n\tauto &navigation = walker->GetNavigation();\n\tif (!navigation) {\n\t\tnavigation = std::make_shared<WalkerNavigation>(walker);\n\t}\n\tnavigation->RegisterAIController(controller.GetID(), controller);\n}", "CodeBleu_score": 45.45150989080787}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (controller.Episode == nullptr) {\n\t\tthrow std::invalid_argument(\"Episode is null\");\n\t}\n\tif (controller.Episode->Navigation == nullptr) {\n\t\tcontroller.Episode->Navigation = std::make_unique<detail::WalkerNavigation>(controller.Episode);\n\t}\n\tcontroller.Episode->Navigation->RegisterWalker(controller.Id, controller.Walker);\n}", "CodeBleu_score": 28.277328153931116}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Get walker associated with controller\n\tauto walker = GetWalker(controller.GetId());\n\tif (!walker) {\n\t\tCARLA_LOG_ERROR(\"Walker with id %d not found.\", controller.GetId());\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\n\t// Create navigation if it is missing\n\tauto navigation = walker->GetNavigation();\n\tif (!navigation) {\n\t\tnavigation = std::make_shared<WalkerNavigation>(walker);\n\t}\n\n\t// Register walker with controller\n\tnavigation->RegisterAIController(controller);\n}", "CodeBleu_score": 49.92997698140146}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tauto actor = detail::ActorFactory::CreateActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n\tif (actor) {\n\t\tauto episode = GetCurrentEpisode();\n\t\tif (episode) {\n\t\t\tepisode->RegisterActor(*actor);\n\t\t}\n\t\treturn actor;\n\t}\n\treturn SharedPtr<Actor>();\n}", "CodeBleu_score": 28.84578020865447}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\t// TODO: implement this function\n  std::shared_ptr<Actor> actor = std::make_shared<Actor>(\n      detail::ActorFactory::CreateActor(\n          blueprint,\n          transform,\n          parent,\n          attachment_type,\n          socket_name,\n          gc));\n  actor->Register();\n  return actor;\n}", "CodeBleu_score": 26.92333313769669}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tif (parent) {\n\t\tCARLA_CHECK_ERROR(parent->GetActorId()!= 0, \"Parent actor must be a valid actor.\");\n\t\tCARLA_CHECK_ERROR(parent->GetEpisodeId() == GetEpisodeId(), \"Parent actor must be from the same episode.\");\n\t\tCARLA_CHECK_ERROR(parent->GetWorldId() == GetWorldId(), \"Parent actor must be from the same world.\");\n\t}\n\n\tif (gc == GarbageCollectionPolicy::None) {\n\t\tCARLA_CHECK_ERROR(parent == nullptr, \"Garbage collection policy None can only be used when parent actor is nullptr.\");\n\t}\n\n\tauto actor_id = SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n\n\tif (parent) {\n\t\tauto actor = GetActor(actor_id);\n\t\tCARLA_CHECK_ERROR(actor, \"Actor not found.\");\n\t\tCARLA_CHECK_ERROR(actor->GetEpisodeId() == GetEpisodeId(), \"Actor must be from the same episode.\");\n\t\tCARLA_CHECK_ERROR(actor->GetWorldId() == GetWorldId(), \"Actor must be from the same world.\");\n\t\tCARLA_CHECK_ERROR(actor->GetParentActorId() == parent->GetActorId(), \"Actor must be a child of the parent.\");\n\t\tCARLA_CHECK_ERROR(actor->GetParentAttachmentType() == attachment_type, \"Actor must be attached to the parent with the specified attachment type.\");\n\t\tCARLA_CHECK_ERROR(actor->GetParentSocketName() == socket_name, \"Actor must be attached to the parent with the specified socket name.\");\n\t\tCARLA_CHECK_ERROR(actor->GetParentActor() == parent, \"Actor must be attached to the parent with the specified socket name.\");\n\t\tCARLA_CHECK_ERROR(actor->GetParentActor()->GetActorId() == parent->GetActorId(), \"Actor must be attached to the parent with the specified socket name.\");\n\t\tCARLA_CHECK_ERROR(actor->GetParentActor()->GetEpisodeId() == GetEpisodeId(), \"Actor must be attached to the parent with the specified socket name.\");\n\t\tCARLA_CHECK_ERROR(actor->GetParentActor()->GetWorldId() == GetWorldId(), \"Actor must be attached to the parent with the specified socket name", "CodeBleu_score": 42.96404418784309}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\t// Check if episode is valid\n\tif (!episode_) {\n\t\tthrow std::runtime_error(\"Episode is not valid\");\n\t}\n\t// Subscribe to sensor data stream\n\tepisode_->client->SubscribeToStream(sensor.id, callback);\n}", "CodeBleu_score": 20.400803961935864}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\tauto episode = GetEpisode();\n\tif (!episode) {\n\t\tthrow std::runtime_error(\"Episode is not valid.\");\n\t}\n\tauto data = episode->SubscribeToStream(sensor.id);\n\tif (data) {\n\t\tcarla::sensor::SensorData sensor_data = carla::sensor::Deserializer::Deserialize(data);\n\t\tcallback(SharedPtr<sensor::SensorData>(new sensor::SensorData(sensor_data)));\n\t}\n}", "CodeBleu_score": 39.895008043570904}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\t// Ensure that the episode is valid.\n\tif (!episode_id_) {\n\t\tthrow std::runtime_error(\"Episode is not valid.\");\n\t}\n\n\t// Subscribe to the sensor's data stream.\n\tauto data_stream_id = client_.SubscribeToStream(\n\t\t\t*episode_id_, sensor.GetId());\n\n\t// Set up the callback to handle the incoming sensor data.\n\tauto callback_wrapper = [this, data_stream_id, callback](\n\t\t\tconst std::string &data) {\n\t\t// Deserialize the sensor data.\n\t\tauto sensor_data = sensor::Deserializer::Deserialize(data);\n\t\t// Associate the sensor data with the current episode.\n\t\tsensor_data->SetEpisodeId(*episode_id_);\n\t\t// Invoke the callback with the sensor data.\n\t\tcallback(sensor_data);\n\t};\n\n\t// Register the callback with the client.\n\tclient_.RegisterCallback(data_stream_id, callback_wrapper);\n}", "CodeBleu_score": 46.67491672155234}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = episode->GetWalker();\n\tif (walkers.size() == 0) {\n\t\treturn;\n\t}\n\tauto state = episode->GetState();\n\tauto simulator = episode->GetSimulator();\n\tauto navigation = episode->GetNavigation();\n\tauto world = episode->GetWorld();\n\tauto client = episode->GetClient();\n\tauto world_id = episode->GetWorldId();\n\tauto world_name = episode->GetWorldName();\n\tauto world_port = episode->GetWorldPort();\n\n\tauto transform = std::vector<carla::rpc::Transform>();\n\tauto speed = std::vector<carla::rpc::Float32>();\n\tauto control = std::vector<carla::rpc::WalkerControl>();\n\tauto remove = std::vector<carla::rpc::ActorId>();\n\n\tfor (auto walker : walkers) {\n\t\tauto actor_id = walker.first;\n\t\tauto walker_transform = walker.second.GetTransform();\n\t\tauto walker_speed = walker.second.GetSpeed();\n\t\tauto walker_control = walker.second.GetControl();\n\t\tauto walker_state = walker.second.GetState();\n\n\t\ttransform.push_back(walker_transform);\n\t\tspeed.push_back(walker_speed);\n\t\tcontrol.push_back(walker_control);\n\n\t\tif (walker_state == carla::WalkerState::Dead) {\n\t\t\tremove.push_back(actor_id);\n\t\t\tauto controller = walker.second.GetController();\n\t\t\tcontroller->Destroy();\n\t\t}\n\t}\n\n\tauto batch = carla::rpc::Batch();\n\tbatch.transform = transform;\n\tbatch.speed = speed;\n\tbatch.control = control;\n\n\tauto batch_result = simulator->ApplyBatch(world_id, batch);\n\n\tfor (auto actor_id : remove) {\n\t\tauto walker = walkers.find(actor_id);\n\t\tif (walker!= walkers.end()) {\n\t\t\twalkers.erase(walker);\n\t\t}\n\t}\n\n\tfor (auto actor_id : batch_result.actor_id) {\n\t\tauto walker = walkers.find(actor_id);\n\t\tif (walker!= walk", "CodeBleu_score": 39.33779690015594}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// Load walkers\n\tauto walkers = episode->GetWalkers();\n\tif (walkers.empty())\n\t\treturn;\n\n\t// Get episode state\n\tauto state = episode->GetState();\n\tif (state == EpisodeState::FINISHED)\n\t\treturn;\n\n\t// Remove dead walkers\n\tfor (auto it = walkers.begin(); it!= walkers.end();) {\n\t\tif (it->second->IsDead()) {\n\t\t\tepisode->RemoveWalker(it->first);\n\t\t\tit = walkers.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t// Update vehicles and crowd\n\tauto navigation = episode->GetNavigation();\n\tauto simulator = episode->GetSimulator();\n\tauto vehicles = simulator->GetVehicles();\n\tauto crowd = simulator->GetCrowd();\n\tauto walker_controllers = episode->GetWalkerControllers();\n\tauto walker_controls = episode->GetWalkerControls();\n\n\tfor (auto it = walkers.begin(); it!= walkers.end(); ++it) {\n\t\tauto walker = it->second;\n\t\tauto walker_controller = walker_controllers[it->first];\n\t\tauto walker_control = walker_controls[it->first];\n\n\t\tauto vehicle = vehicles[walker->GetVehicleId()];\n\t\tauto transform = vehicle->GetTransform();\n\t\tauto speed = vehicle->GetSpeed();\n\n\t\twalker_control->SetTransform(transform);\n\t\twalker_control->SetSpeed(speed);\n\n\t\tif (walker_controller->IsDead()) {\n\t\t\tepisode->RemoveWalker(it->first);\n\t\t\twalker_controllers.erase(it->first);\n\t\t\twalker_controls.erase(it->first);\n\t\t} else {\n\t\t\t// Update vehicle\n\t\t\tauto control = simulator->GetVehicleControl(walker->GetVehicleId());\n\t\t\tcontrol->SetTransform(transform);\n\t\t\tcontrol->SetSpeed(speed);\n\n\t\t\t// Update crowd\n\t\t\tauto vehicle_control = simulator->GetVehicleControl(walker->GetVehicleId());\n\t\t\tauto crowd_control = simulator->GetCrowdControl(walker->GetCrowdId());\n\t\t\tcrowd_control->SetVehicle(vehicle_control);\n\t\t}\n\t}\n\n\t// Apply walkers to simulator\n\tauto command =", "CodeBleu_score": 39.487824296395175}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// Load the current walkers\n\tauto walkers = episode->GetWalkerData();\n\n\t// If there are no walkers, return\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get the current state of the episode\n\tauto state = episode->GetState();\n\n\t// Remove any walkers that no longer exist\n\tfor (auto it = walkers.begin(); it!= walkers.end();) {\n\t\tif (state->GetWalkerData().find(it->first) == state->GetWalkerData().end()) {\n\t\t\tit = walkers.erase(it);\n\t\t}\n\t\telse {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t// Update the vehicles in the crowd\n\tfor (auto& walker : walkers) {\n\t\tauto vehicle = state->GetVehicleData().at(walker.first);\n\t\tauto transform = vehicle.GetTransform();\n\t\tauto speed = vehicle.GetSpeed();\n\n\t\t// Update the vehicle in the simulator\n\t\tauto command = std::make_shared<carla::rpc::Command>();\n\t\tcommand->set_actor_id(walker.first);\n\t\tcommand->set_transform(transform);\n\t\tcommand->set_speed(speed);\n\t\tsimulator->ApplyCommand(command);\n\t}\n\n\t// Check if any walker has been killed\n\tfor (auto& walker : walkers) {\n\t\tauto vehicle = state->GetVehicleData().at(walker.first);\n\t\tif (vehicle.IsDead()) {\n\t\t\t// Remove the walker from the crowd\n\t\t\tepisode->RemoveWalker(walker.first);\n\n\t\t\t// Destroy the walker's controller\n\t\t\tauto controller = walker.second->GetController();\n\t\t\tcontroller->Destroy();\n\t\t}\n\t}\n}", "CodeBleu_score": 45.09191002245154}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_actor_id(id);\n\tdescription.set_actor_uid(uid);\n\tdescription.set_type(type);\n\tdescription.set_parent_id(parent_id);\n\tdescription.set_parent_uid(parent_uid);\n\tdescription.set_parent_type(parent_type);\n\tdescription.set_parent_name(parent_name);\n\tdescription.set_parent_actor_id(parent_actor_id);\n\tdescription.set_parent_actor_uid(parent_actor_uid);\n\tdescription.set_parent_actor_type(parent_actor_type);\n\tdescription.set_parent_actor_name(parent_actor_name);\n\tdescription.set_parent_actor_parent_id(parent_actor_parent_id);\n\tdescription.set_parent_actor_parent_uid(parent_actor_parent_uid);\n\tdescription.set_parent_actor_parent_type(parent_actor_parent_type);\n\tdescription.set_parent_actor_parent_name(parent_actor_parent_name);\n\tdescription.set_parent_actor_parent_actor_id(parent_actor_parent_actor_id);\n\tdescription.set_parent_actor_parent_actor_uid(parent_actor_parent_actor_uid);\n\tdescription.set_parent_actor_parent_actor_type(parent_actor_parent_actor_type);\n\tdescription.set_parent_actor_parent_actor_name(parent_actor_parent_actor_name);\n\tdescription.set_parent_actor_parent_actor_parent_id(parent_actor_parent_actor_parent_id);\n\tdescription.set_parent_actor_parent_actor_parent_uid(parent_actor_parent_actor_parent_uid);\n\tdescription.set_parent_actor_parent_actor_parent_type(parent_actor_parent_actor_parent_type);\n\tdescription.set_parent_actor_parent_actor_parent_name(parent_actor_parent_actor_parent_name);\n\tdescription.set_parent_actor_parent_actor_parent_actor_id(parent_actor_parent_actor_parent_actor", "CodeBleu_score": 31.290663908207527}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_id(id);\n\tdescription.set_uid(uid);\n\n\t// Reserve space for the attributes\n\tdescription.mutable_attributes()->Reserve(attributes.size());\n\n\t// Copy the attributes from the ActorBlueprint to the description\n\tfor (const auto& attribute : attributes) {\n\t\tauto* attribute_description = description.add_attributes();\n\t\tattribute_description->set_key(attribute.first);\n\t\tattribute_description->set_value(attribute.second);\n\t}\n\n\treturn description;\n}", "CodeBleu_score": 55.797646590153114}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription actor_description;\n\tactor_description.set_id(id);\n\tactor_description.set_uid(uid);\n\tactor_description.set_name(name);\n\tactor_description.set_type(type);\n\tactor_description.set_parent_id(parent_id);\n\tactor_description.set_parent_type(parent_type);\n\tactor_description.set_parent_uid(parent_uid);\n\tactor_description.set_transform(transform);\n\tactor_description.set_rotation(rotation);\n\tactor_description.set_location(location);\n\tactor_description.set_scale(scale);\n\tactor_description.set_is_persistent(is_persistent);\n\tactor_description.set_is_movable(is_movable);\n\tactor_description.set_is_deletable(is_deletable);\n\tactor_description.set_is_visible(is_visible);\n\tactor_description.set_is_dynamic(is_dynamic);\n\tactor_description.set_is_collideable(is_collideable);\n\tactor_description.set_is_trigger(is_trigger);\n\tactor_description.set_is_static(is_static);\n\tactor_description.set_is_navigable(is_navigable);\n\tactor_description.set_is_sensor(is_sensor);\n\tactor_description.set_is_attached(is_attached);\n\tactor_description.set_is_movable_by_physics(is_movable_by_physics);\n\tactor_description.set_is_synchronize_transform(is_synchronize_transform);\n\tactor_description.set_is_synchronize_physics(is_synchronize_physics);\n\tactor_description.set_is_synchronize_location(is_synchronize_location);\n\tactor_description.set_is_synchronize_rotation(is_synchronize_rotation);\n\tactor_description.set_is_synchronize_scale(is_synchronize_scale);\n\tactor_description.set_is_synchronize_velocity(is_synchronize_velocity);\n\tactor_description.set_is_synchronize_angular_", "CodeBleu_score": 30.860584394862222}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeSharedPtr<BlueprintLibrary>();\n\tfor (const auto& blueprint : blueprints) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tif (blueprint->GetAttribute(name) == value) {\n\t\t\t\tresult->blueprints.push_back(blueprint);\n\t\t\t} else if (blueprint->GetAttribute(name) == \"Recommended\") {\n\t\t\t\tresult->blueprints.push_back(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 39.198691891295255}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (const auto& blueprint : *this) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tconst auto& attribute = blueprint->GetAttribute(name);\n\t\t\tif (attribute.IsValue(value)) {\n\t\t\t\tresult->Add(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 33.09161915716773}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\t// Create new BlueprintLibrary\n\tSharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\n\t// Iterate through all blueprints\n\tfor (auto it = blueprints.begin(); it!= blueprints.end(); ++it) {\n\t\t// Check if blueprint has attribute\n\t\tif ((*it)->HasAttribute(name)) {\n\t\t\t// Get attribute value\n\t\t\tstd::string attribute_value = (*it)->GetAttribute(name);\n\n\t\t\t// Check if attribute value is valid\n\t\t\tif (attribute_value.empty()) {\n\t\t\t\tthrow Exception(\"BlueprintLibrary::FilterByAttribute: Attribute value is empty.\");\n\t\t\t}\n\n\t\t\t// Check if attribute value is equal to the specified value\n\t\t\tif (attribute_value == value) {\n\t\t\t\t// Add blueprint to result\n\t\t\t\tresult->blueprints.push_back(*it);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 44.06499882971547}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Construct full file path\n\tstd::string fullPath = baseFolder + \"/\" + std::to_string(version) + \"/\" + path;\n\n\t// Validate file path\n\tif (!ValidateFilePath(fullPath)) {\n\t\treturn false;\n\t}\n\n\t// Open file in binary mode\n\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\t// Write content to file\n\tfile.write((char*)content.data(), content.size());\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 45.16245101519092}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = baseFolder + \"/\" + version + \"/\" + path;\n\tif (!ValidatePath(fullPath)) {\n\t\treturn false;\n\t}\n\tstd::ofstream file(fullPath, std::ios::binary | std::ios::out | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tfile.write(reinterpret_cast<char *>(content.data()), content.size());\n\tfile.close();\n\treturn true;\n}", "CodeBleu_score": 44.0080978507335}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Construct full file path\n\tstd::string full_path = base_path + \"/\" + version + \"/\" + path;\n\n\t// Validate file path\n\tif (full_path.find_first_of(\"/\\\\\")!= std::string::npos) {\n\t\tstd::cout << \"FileTransfer::WriteFile: Invalid file path: \" << full_path << std::endl;\n\t\treturn false;\n\t}\n\n\t// Open file in binary mode to truncate its contents\n\tstd::ofstream file(full_path, std::ios::out | std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\t// Write content to file\n\t\tfile.write((char*)content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t} else {\n\t\tstd::cout << \"FileTransfer::WriteFile: Cannot open file: \" << full_path << std::endl;\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 42.706034156264174}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\tconst auto &location = transform.location;\n\tconst auto &extents = transform.extent;\n\tconst auto &rotation = transform.rotation;\n\tconst auto &yaw = rotation.yaw;\n\tconst auto &extent = extents.extent;\n\tconst auto &extent_x = extent.x;\n\tconst auto &extent_y = extent.y;\n\tconst auto &extent_z = extent.z;\n\tconst auto &extent_yaw = extent.yaw;\n\tconst auto &extent_pitch = extent.pitch;\n\tconst auto &extent_roll = extent.roll;\n\tconst auto &extent_x_yaw = extent_x * extent_yaw;\n\tconst auto &extent_y_pitch = extent_y * extent_pitch;\n\tconst auto &extent_z_roll = extent_z * extent_roll;\n\tconst auto &extent_x_yaw_pitch = extent_x_yaw + extent_y_pitch;\n\tconst auto &extent_x_yaw_pitch_roll = extent_x_yaw_pitch + extent_z_roll;\n\tconst auto &extent_x_yaw_pitch_roll_yaw = extent_x_yaw_pitch_roll + extent_yaw;\n\tconst auto &extent_x_yaw_pitch_roll_yaw_pitch = extent_x_yaw_pitch_roll_yaw + extent_pitch;\n\tconst auto &extent_x_yaw_pitch_roll_yaw_pitch_roll = extent_x_yaw_pitch_roll_yaw_pitch + extent_roll;\n\tconst auto &extent_x_yaw_pitch_roll_yaw_pitch_roll_x = extent_x_yaw_pitch_roll_yaw_pitch_roll + extent_x;\n\tconst auto &extent_x_yaw_pitch_roll_yaw_pitch_roll_x_y = extent_x_yaw_pitch_roll_yaw_pitch_roll_x + extent_y;\n\tconst auto &extent_x_yaw_pitch_roll_yaw_pitch_roll_x_y_z = extent_x_yaw_pitch_roll_yaw_pitch_roll_x_y + extent_z;\n\tconst auto &extent_x_yaw_pitch_roll_yaw_pitch_roll_", "CodeBleu_score": 27.710856780868305}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\tconst auto &location = transform.location;\n\tconst auto &rotation = transform.rotation;\n\n\tauto bounds = std::make_shared<Bounds>(frame);\n\n\tbounds->corners.push_back(location + rotation.RotateVector(extent.min));\n\tbounds->corners.push_back(location + rotation.RotateVector(extent.max));\n\n\tbounds->corners.push_back(location + rotation.RotateVector(extent.max));\n\tbounds->corners.push_back(location + rotation.RotateVector(extent.min));\n\n\treturn bounds;\n}", "CodeBleu_score": 44.384954315427805}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\t// Calculate the location of the bounding box.\n\tconst auto location = transform.location + parent->GetBoundingBox().location;\n\n\t// Calculate the corners of the bounding box.\n\tconst auto corners = geom::MakeCorners(transform.rotation, parent->GetBoundingBox().extents);\n\n\t// Return a shared pointer to the calculated bounds.\n\treturn std::make_shared<Bounds>(frame, location, corners);\n}", "CodeBleu_score": 29.008157548195445}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex.\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Retrieve the light states from the server.\n\tauto light_states = _simulator->GetLightsState();\n\n\t// Update the local light states.\n\tfor (auto& light_state : light_states) {\n\t\tauto light_ptr = _lights.find(light_state.first);\n\n\t\tif (light_ptr == _lights.end()) {\n\t\t\t_lights.emplace(light_state.first, std::make_shared<carla::client::Light>(light_state.first));\n\t\t} else {\n\t\t\tlight_ptr->second->SetState(light_state.second);\n\t\t}\n\t}\n}", "CodeBleu_score": 32.13160984074756}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t_lights.clear();\n\tauto response = _client->SendQuery(carla::rpc::Command::Request::GetLightsState());\n\tfor (const auto& light : response.lights()) {\n\t\tauto light_ptr = std::make_shared<carla::client::Light>(light);\n\t\t_lights[light.id()] = light_ptr;\n\t\t_light_ptrs.push_back(light_ptr);\n\t}\n}", "CodeBleu_score": 28.434214997105357}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// TODO: implement this function\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n\t// TODO: add mutex to ensure thread safety\n\t// TODO: add light object creation\n\t// TODO: update light states\n", "CodeBleu_score": 0.8959055857291247}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (dirty) {\n\t\tstd::vector<carla::rpc::LightState> states;\n\t\tfor (auto& light : lights) {\n\t\t\tstates.push_back(light.second->GetState());\n\t\t}\n\t\tauto message = carla::rpc::LightStateList(std::move(states));\n\t\tif (discard_client) {\n\t\t\tclient->Send(message);\n\t\t} else {\n\t\t\tserver->Send(message);\n\t\t}\n\t\tdirty = false;\n\t\tchanges.clear();\n\t}\n}", "CodeBleu_score": 34.09129276276842}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (dirty) {\n\t\tcarla::rpc::LightState state;\n\t\tstate.set_discard_client(discard_client);\n\t\tfor (auto& light : lights) {\n\t\t\tauto* state_light = state.add_lights();\n\t\t\tstate_light->set_id(light.first);\n\t\t\tstate_light->set_intensity(light.second.intensity);\n\t\t\tstate_light->set_color(light.second.color.r, light.second.color.g, light.second.color.b);\n\t\t\tstate_light->set_attenuation(light.second.attenuation.x, light.second.attenuation.y, light.second.attenuation.z);\n\t\t\tstate_light->set_position(light.second.position.x, light.second.position.y, light.second.position.z);\n\t\t\tstate_light->set_range(light.second.range);\n\t\t\tstate_light->set_cast_shadows(light.second.cast_shadows);\n\t\t\tstate_light->set_visible(light.second.visible);\n\t\t}\n\t\tauto message = carla::rpc::Message::Create(carla::rpc::MessageId::LIGHT_STATE, state);\n\t\tauto response = client.SendRequest(message);\n\t\tif (response.get_error().has_error()) {\n\t\t\tthrow std::runtime_error(response.get_error().GetMessage());\n\t\t}\n\t\tdirty = false;\n\t\tchanges.clear();\n\t}\n}", "CodeBleu_score": 47.92644526838566}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tif (m_dirty) {\n\t\tauto msg = std::make_shared<carla::rpc::LightState>();\n\t\tfor (auto &light : m_lights) {\n\t\t\tif (light.second.m_dirty) {\n\t\t\t\tauto &light_state = msg->add_lights();\n\t\t\t\tlight_state.set_id(light.first);\n\t\t\t\tlight_state.set_state(light.second.m_state);\n\t\t\t\tlight_state.set_intensity(light.second.m_intensity);\n\t\t\t}\n\t\t}\n\t\tif (msg->lights_size() > 0) {\n\t\t\tm_client.Send(msg);\n\t\t\tif (discard_client) {\n\t\t\t\tm_client.Discard();\n\t\t\t}\n\t\t}\n\t\tm_dirty = false;\n\t}\n}", "CodeBleu_score": 41.510040479430025}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (id!= \"sensor.other.v2x_custom\") {\n\t\tCARLA_LOG_DEBUG(\n\t\t\t\t\"ServerSideSensor::Send: Called with sensor ID \\\"{}\\\". This sensor is not a V2X sensor, so it cannot send a message.\",\n\t\t\t\tid);\n\t\treturn;\n\t}\n\tCARLA_LOG_DEBUG(\"ServerSideSensor::Send: Called with message \\\"{}\\\".\", message);\n\tauto& simulator = detail::Simulator::GetInstance();\n\tauto& episode = simulator.GetEpisode(episode_id);\n\tif (episode.HasSensor(id)) {\n\t\tepisode.Send(id, context, message);\n\t} else {\n\t\tCARLA_LOG_WARNING(\"ServerSideSensor::Send: Called with message \\\"{}\\\" but the sensor with ID \\\"{}\\\" does not exist in the episode.\", message, id);\n\t}\n}", "CodeBleu_score": 39.58336121931939}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->sensor_id!= \"sensor.other.v2x_custom\") {\n\t\tCARLA_LOG_WARNING(\n\t\t\t\"ServerSideSensor::Send: \"\n\t\t\t\"The sensor's ID is not \\\"sensor.other.v2x_custom\\\". \"\n\t\t\t\"It will not send the message to the episode.\");\n\t}\n\telse {\n\t\ttry {\n\t\t\tthis->episode->Send(this->context, message);\n\t\t}\n\t\tcatch (const std::exception &e) {\n\t\t\tCARLA_LOG_ERROR(\n\t\t\t\t\"ServerSideSensor::Send: \"\n\t\t\t\t\"The episode could not be sent the message: \"\n\t\t\t\t\"\\\"{}\\\".\",\n\t\t\t\te.what());\n\t\t}\n\t}\n}", "CodeBleu_score": 40.922119329308074}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->id!= \"sensor.other.v2x_custom\") {\n\t\tCARLA_LOG_WARNING(\"Sensor with ID %s is not a v2x sensor, cannot send message.\", this->id.c_str());\n\t\treturn;\n\t}\n\tauto simulator = this->simulator.lock();\n\tif (!simulator) {\n\t\tCARLA_LOG_ERROR(\"Sensor's simulator has expired.\");\n\t\treturn;\n\t}\n\tauto episode = simulator->GetEpisode();\n\tif (!episode) {\n\t\tCARLA_LOG_ERROR(\"Sensor's episode has expired.\");\n\t\treturn;\n\t}\n\tepisode->Send(this->context, message);\n}", "CodeBleu_score": 44.540077667314584}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tcarla::client::detail::Actor::SetAutopilot(enabled, tm_port);\n}", "CodeBleu_score": 27.589200851760015}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\t// TODO: Implement this method.\n}", "CodeBleu_score": 4.055752836348062}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tcarla::client::detail::Actor::SetAutopilot(enabled, tm_port);\n}", "CodeBleu_score": 27.589200851760015}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\tauto& simulator = detail::Simulator::GetInstance();\n\tauto& navigation = simulator.GetWalkerNavigation();\n\tauto walker_actor = simulator.GetWalkerActor();\n\n\twalker_actor->SetSimulatePhysics(false);\n\twalker_actor->SetEnableGravity(false);\n\twalker_actor->SetEnableCollision(false);\n\n\tnavigation.AddWalker(walker_actor, walker_actor->GetLocation());\n}", "CodeBleu_score": 33.4944359188684}, {"code": "void WalkerAIController::Start(){\n\t\t// Get the walker actor from the episode.\n\tauto walker_actor = GetActor();\n\n\t// Add the walker actor to the navigation system.\n\tauto navigation_system = detail::Simulator::GetInstance().GetNavigationSystem();\n\tnavigation_system->AddActor(walker_actor);\n\n\t// Disable the physics simulation and collisions for the walker actor.\n\twalker_actor->SetSimulatePhysics(false);\n\twalker_actor->SetEnableCollision(false);\n\n\t// Register the AI controller with the episode.\n\tauto episode = GetEpisode();\n\tepisode->RegisterActor(this);\n}", "CodeBleu_score": 35.70362487970884}, {"code": "void WalkerAIController::Start(){\n\t\t// Retrieve the walker actor\n\tauto walker_actor = GetPawn();\n\tif (!walker_actor) {\n\t\tUE_LOG(LogCarla, Error, TEXT(\"WalkerAIController::Start: No walker actor found!\"));\n\t\treturn;\n\t}\n\n\t// Add the walker actor to the navigation system\n\tauto navigation = GetWorld()->GetNavigationSystem();\n\tif (!navigation) {\n\t\tUE_LOG(LogCarla, Error, TEXT(\"WalkerAIController::Start: No navigation system found!\"));\n\t\treturn;\n\t}\n\n\t// Retrieve the walker actor's location\n\tauto walker_location = walker_actor->GetActorLocation();\n\tif (!walker_location.IsNearlyZero()) {\n\t\tnavigation->AddAgent(walker_actor);\n\t}\n\n\t// Disable the walker actor's physics simulation and collisions\n\twalker_actor->SetActorEnableCollision(false);\n\twalker_actor->SetActorTickEnabled(false);\n}", "CodeBleu_score": 37.4588633394066}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (navigation_) {\n\t\tauto walker = navigation_->GetWalker();\n\t\tif (walker) {\n\t\t\twalker->SetMaxSpeed(max_speed);\n\t\t} else {\n\t\t\tCARLA_LOG_E(GetActor()->GetName(), \"Failed to set walker max speed. Walker not found.\");\n\t\t}\n\t} else {\n\t\tCARLA_LOG_E(GetActor()->GetName(), \"Failed to set walker max speed. Navigation not found.\");\n\t}\n}", "CodeBleu_score": 45.13531179392864}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (auto navigation = episode->GetNavigation()) {\n\t\tif (auto walker = navigation->GetWalker()) {\n\t\t\tif (walker->SetMaxSpeed(max_speed)) {\n\t\t\t\tLOG_DEBUG << \"Walker max speed set to \" << max_speed;\n\t\t\t} else {\n\t\t\t\tLOG_WARNING << \"Failed to set walker max speed to \" << max_speed;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_WARNING << \"Walker not found\";\n\t\t}\n\t} else {\n\t\tLOG_WARNING << \"Navigation not found\";\n\t}\n}", "CodeBleu_score": 43.86559229908913}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (auto navigation = episode->GetNavigation()) {\n\t\tif (auto walker = navigation->GetWalker(id)) {\n\t\t\tif (walker->SetMaxSpeed(max_speed)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tCARLA_LOG_E(\n\t\t\"WalkerAIController::SetMaxSpeed: \"\n\t\t\"Could not set max speed for walker %u of %s.\",\n\t\tid, episode->GetActor()->GetName().c_str());\n}", "CodeBleu_score": 39.32998999277062}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tauto result = std::vector<SharedPtr<Waypoint>>();\n\tauto map = GetMap();\n\tauto previous_waypoints = map->GetPreviousWaypoints(this, distance);\n\tfor (auto previous_waypoint : previous_waypoints) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(previous_waypoint)));\n\t}\n\treturn result;\n}", "CodeBleu_score": 51.73468728484857}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tfor (auto& wp : parent_map_->GetWaypoints(this, distance)) {\n\t\tresult.emplace_back(wp);\n\t}\n\treturn result;\n}", "CodeBleu_score": 34.835229253786714}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tauto previous_waypoints = map->GetPrevious(this, distance);\n\tfor (auto& wp : previous_waypoints) {\n\t\tresult.emplace_back(wp->MakeShared());\n\t}\n\treturn result;\n}", "CodeBleu_score": 50.23605919961912}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tauto signals = GetSignalsInDistance(distance);\n\tfor (auto signal : signals) {\n\t\tif (signal->GetLandmark()!= nullptr) {\n\t\t\tauto landmark = signal->GetLandmark();\n\t\t\tif (stop_at_junction && landmark->GetType() == Landmark::Type::Junction) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (std::find(result.begin(), result.end(), landmark) == result.end()) {\n\t\t\t\tresult.push_back(landmark);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 41.55714790508151}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tauto signals = GetSignalsInDistance(distance);\n\tfor (auto signal : signals) {\n\t\tif (stop_at_junction) {\n\t\t\tif (signal->GetType() == LandmarkType::Junction) {\n\t\t\t\tresult.push_back(signal);\n\t\t\t}\n\t\t} else {\n\t\t\tresult.push_back(signal);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 34.199209171246736}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tauto signals = GetSignalsInDistance(distance);\n\tauto signals_set = std::unordered_set<std::string>();\n\tfor (auto signal : signals) {\n\t\tif (signals_set.find(signal->GetId()) == signals_set.end()) {\n\t\t\tsignals_set.insert(signal->GetId());\n\t\t\tauto new_waypoint = SharedPtr<Waypoint>(new Waypoint(signal->GetLocation()));\n\t\t\tauto new_landmark = SharedPtr<Landmark>(new Landmark(signal->GetLocation(), signal->GetId()));\n\t\t\tif (stop_at_junction && new_waypoint->IsJunction()) {\n\t\t\t\tresult.push_back(new_landmark);\n\t\t\t} else {\n\t\t\t\tresult.push_back(new_landmark);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 50.42258945127796}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\t// TODO: Implement this function.\n\treturn 0;\n}", "CodeBleu_score": 3.2297002042048955}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\t// TODO: check if settings are valid\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are compatible with current episode\n\t// TODO: check if settings are", "CodeBleu_score": 3.171605579663}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tauto simulator = std::make_shared<detail::Simulator>(this);\n\tsimulator->ApplySettings(settings, timeout);\n\treturn simulator->GetSettingsId();\n}", "CodeBleu_score": 16.392848593719645}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\t(float x, float y, float x1, float y1, float x2, float y2) -> std::pair<float, float> {\n\t\tfloat x0 = x2 - x1;\n\t\tfloat y0 = y2 - y1;\n\t\tfloat d2 = x0 * x0 + y0 * y0;\n\t\tfloat t;\n\t\tif (d2!= 0) {\n\t\t\tt = (x * x0 + y * y0) / d2;\n\t\t} else {\n\t\t\tt = 0;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tt = 0;\n\t\t} else if (t > 1) {\n\t\t\tt = 1;\n\t\t}\n\t\tfloat x3 = x1 + t * x0;\n\t\tfloat y3 = y1 + t * y0;\n\t\tfloat dx = x - x3;\n\t\tfloat dy = y - y3;\n\t\treturn std::make_pair(dx * dx + dy * dy, t);\n\t}\n}", "CodeBleu_score": 31.9829677631118}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat distance_squared = 0.0f;\n\tfloat distance = 0.0f;\n\tfloat clamped_distance = 0.0f;\n\tfloat clamped_distance_squared = 0.0f;\n\tfloat clamped_distance_squared_distance = 0.0f;\n\tfloat clamped_distance_squared_distance_squared = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance_squared = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance_squared_distance = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared = 0.0f;\n\tfloat clamped_distance_squared_distance_squared_distance_squared_distance_squared_distance_squared", "CodeBleu_score": 6.25249436705613}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat distance_squared = 0.0f;\n\tfloat distance = 0.0f;\n\tfloat projection = 0.0f;\n\n\tconst float dx = point.x - segment.x;\n\tconst float dy = point.y - segment.y;\n\n\tconst float segment_length_squared = dx * dx + dy * dy;\n\tif (segment_length_squared == 0.0f) {\n\t\tdistance_squared = distance = std::abs(dx);\n\t} else {\n\t\tconst float segment_length = std::sqrt(segment_length_squared);\n\t\tconst float segment_length_reciprocal = 1.0f / segment_length;\n\n\t\tprojection = dx * segment_length_reciprocal * segment.x + dy * segment_length_reciprocal * segment.y;\n\t\tif (projection < 0.0f) {\n\t\t\tdistance_squared = distance = std::abs(dx);\n\t\t} else if (projection > segment_length) {\n\t\t\tdistance_squared = distance = std::abs(dy);\n\t\t} else {\n\t\t\tconst float projection_dx = projection * segment_length_reciprocal * dx;\n\t\t\tconst float projection_dy = projection * segment_length_reciprocal * dy;\n\t\t\tdistance_squared = projection_dx * projection_dx + projection_dy * projection_dy;\n\t\t\tdistance = std::sqrt(distance_squared);\n\t\t}\n\t}\n\n\treturn std::make_pair(distance_squared, distance);\n}", "CodeBleu_score": 41.47906152276836}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tassert(vertices.size() >= 3);\n\tindex_type initial_index = vertex_count;\n\tfor (index_type i = 0; i < vertices.size(); ++i) {\n\t\tAddVertex(vertices[i]);\n\t}\n\tfor (index_type i = 0; i < vertices.size() - 2; ++i) {\n\t\tAddTriangle(initial_index, initial_index + i + 1, initial_index + i + 2);\n\t}\n}", "CodeBleu_score": 34.822204419154055}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tassert(vertices.size() >= 3);\n\tindex_type initial_index = vertices.size();\n\tfor (size_type i = 0; i < vertices.size(); i++) {\n\t\tindices.push_back(initial_index);\n\t\tindices.push_back(i);\n\t\tindices.push_back(i + 1);\n\t}\n}", "CodeBleu_score": 41.53868378461755}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\t// assert that there are at least three vertices\n\tassert(vertices.size() >= 3);\n\n\t// record the initial index\n\tsize_t index = m_indices.size();\n\n\t// add the vertices to the mesh\n\tm_indices.reserve(m_indices.size() + vertices.size());\n\tfor (auto &v : vertices) {\n\t\tm_indices.push_back(index);\n\t\tm_vertices.push_back(v);\n\t\tindex++;\n\t}\n\n\t// add indices to form triangles\n\tfor (size_t i = 2; i < vertices.size(); i++) {\n\t\tm_indices.push_back(index);\n\t\tm_indices.push_back(index - i);\n\t\tm_indices.push_back(index - i + 1);\n\t}\n}", "CodeBleu_score": 42.03055906267492}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (message == nullptr) {\n\t\tCARLA_LOG_E(\"Primary::Write: message is null\");\n\t\treturn;\n\t}\n\n\tif (message->size() == 0) {\n\t\tCARLA_LOG_E(\"Primary::Write: message size is zero\");\n\t\treturn;\n\t}\n\n\tif (!socket_->is_open()) {\n\t\tCARLA_LOG_E(\"Primary::Write: socket is not open\");\n\t\treturn;\n\t}\n\n\tauto strand = socket_->get_executor().context().get_strand();\n\tstrand.post(boost::asio::bind_executor(strand, [this, message] {\n\t\tif (!socket_->is_open()) {\n\t\t\tCARLA_LOG_E(\"Primary::Write: socket is not open\");\n\t\t\treturn;\n\t\t}\n\n\t\tsocket_->expires_after(std::chrono::seconds(30));\n\n\t\tauto self = this->shared_from_this();\n\t\tboost::asio::async_write(*socket_, boost::asio::buffer(message->data(), message->size()),\n\t\t\t[self, message](const boost::system::error_code& error, std::size_t bytes_transferred) {\n\t\t\t\tif (error) {\n\t\t\t\t\tCARLA_LOG_E(\"Primary::Write: error: {}\", error.message());\n\t\t\t\t\tself->socket_->close();\n\t\t\t\t}\n\t\t\t});\n\t}));\n}", "CodeBleu_score": 39.15853268145418}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tCARLA_ASSERT(message);\n\tCARLA_ASSERT(message->IsValid());\n\tCARLA_ASSERT(strand_.running_in_this_thread());\n\n\tif (message->IsValid()) {\n\t\tauto self(shared_from_this());\n\t\tstrand_.post([self, message]() {\n\t\t\tif (self->socket_.is_open()) {\n\t\t\t\tself->socket_.expires_from_now(std::chrono::seconds(10));\n\t\t\t\tself->socket_.async_write_some(boost::asio::buffer(message->data(), message->size()),\n\t\t\t\t\t\t[self, message](boost::system::error_code ec, std::size_t length) {\n\t\t\t\t\tif (ec) {\n\t\t\t\t\t\tCARLA_LOG_WARNING(\n\t\t\t\t\t\t\t\t\"Failed to send message, closing connection: \" << ec.message());\n\t\t\t\t\t\tself->socket_.close();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tCARLA_LOG_DEBUG(\"Sent message of size \" << length);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}", "CodeBleu_score": 36.303227266160405}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\treturn;\n\t}\n\tif (!message->IsValid()) {\n\t\tCARLA_LOG_EVERYTHING(Severity::kError, \"Invalid message received.\");\n\t\treturn;\n\t}\n\tif (!socket) {\n\t\tCARLA_LOG_EVERYTHING(Severity::kError, \"Socket is not open.\");\n\t\treturn;\n\t}\n\tif (socket->is_open()) {\n\t\tsocket->expires_after(std::chrono::seconds(2));\n\t\tboost::asio::async_write(*socket, boost::asio::buffer(message->Data(), message->Size()),\n\t\t\t[this, message](const boost::system::error_code& error, std::size_t) {\n\t\t\t\tif (error) {\n\t\t\t\t\tCARLA_LOG_EVERYTHING(Severity::kError, \"Error writing message to socket: \" << error.message());\n\t\t\t\t\tsocket->close();\n\t\t\t\t}\n\t\t\t});\n\t} else {\n\t\tCARLA_LOG_EVERYTHING(Severity::kError, \"Socket is closed.\");\n\t}\n}", "CodeBleu_score": 35.186468148498946}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec!= boost::asio::error::operation_aborted) {\n\t\tif (socket_.is_open()) {\n\t\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t\t\tsocket_.close();\n\t\t}\n\t\tif (on_closed_) {\n\t\t\ton_closed_();\n\t\t}\n\t\tLOG_INFO << \"Session closed.\";\n\t}\n}", "CodeBleu_score": 52.02687520141496}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec) {\n\t\tif (ec!= boost::asio::error::operation_aborted) {\n\t\t\tCARLA_LOG_E(\"Error closing socket: %s\", ec.message().c_str());\n\t\t}\n\t} else {\n\t\tif (socket_.is_open()) {\n\t\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t\t\tsocket_.close();\n\t\t}\n\t}\n\ton_closed(ec);\n}", "CodeBleu_score": 45.00837814265189}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec!= boost::asio::error::operation_aborted) {\n\t\tif (ec == boost::asio::error::eof) {\n\t\t\tLOG_INFO << \"Primary::CloseNow - Socket closed by peer.\";\n\t\t} else if (ec) {\n\t\t\tLOG_ERROR << \"Primary::CloseNow - Socket error: \" << ec.message();\n\t\t} else {\n\t\t\tLOG_INFO << \"Primary::CloseNow - Socket closed by client.\";\n\t\t}\n\t}\n\n\tif (ec!= boost::asio::error::operation_aborted) {\n\t\tif (m_deadlineTimer) {\n\t\t\tm_deadlineTimer->cancel();\n\t\t}\n\t\tif (m_socket) {\n\t\t\tm_socket->shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t\t\tm_socket->close();\n\t\t}\n\t\tif (m_onClosed) {\n\t\t\tm_onClosed();\n\t\t}\n\t}\n}", "CodeBleu_score": 43.095815824889925}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::vector<char> buffer = carla::streaming::detail::tcp::Message::Create(carla::streaming::detail::tcp::Message::YOU_ALIVE);\n\tstd::cout << \"Sending message: \" << carla::streaming::detail::tcp::Message::YOU_ALIVE << std::endl;\n\trouter->Write(buffer);\n\n\tstd::vector<char> response;\n\trouter->Read(response);\n\n\tstd::cout << \"Received message: \" << response << std::endl;\n}", "CodeBleu_score": 37.651671866614386}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create the message\n\tstd::string message = \"Are you alive?\";\n\n\t// Create a buffer from the message\n\tstd::vector<char> buffer(message.begin(), message.end());\n\n\t// Log the sending action\n\tstd::cout << \"Sending: \" << message << std::endl;\n\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\trouter->Send(buffer, YOU_ALIVE);\n\n\t// Wait for and log the response from the system\n\tstd::cout << \"Received: \" << router->Receive() << std::endl;\n}", "CodeBleu_score": 43.255876304542845}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message \"Are you alive?\"\n\tstd::string buffer = \"Are you alive?\";\n\t// Log the sending action\n\tstd::cout << \"Sending message: \" << buffer << std::endl;\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\trouter->Write(buffer, YOU_ALIVE);\n\t// Wait for and log the response from the system\n\tstd::cout << \"Received message: \" << router->Read() << std::endl;\n}", "CodeBleu_score": 37.11429198037241}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tif (router.GetSecondaryCount() > 0) {\n\t\tstd::vector<stream_id> ids;\n\t\tids.push_back(sensor_id);\n\t\tauto message = std::make_shared<carla::streaming::detail::tcp::Message>(\n\t\t\tcarla::streaming::detail::tcp::Message::ENABLE_ROS,\n\t\t\tids);\n\t\trouter.Send(message);\n\t\tauto response = router.WaitForResponse(message);\n\t\tif (response->type!= carla::streaming::detail::tcp::Message::ENABLE_ROS_RESPONSE) {\n\t\t\tstd::cerr << \"Error: Invalid response from server.\" << std::endl;\n\t\t}\n\t} else {\n\t\tstd::cerr << \"Error: No secondary servers found.\" << std::endl;\n\t}\n}", "CodeBleu_score": 41.10774716933369}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tstd::string server_name;\n\tif (router->GetServerNameForSensor(sensor_id, server_name)) {\n\t\tstd::string command = \"ENABLE_ROS \" + std::to_string(sensor_id);\n\t\trouter->SendCommand(server_name, command);\n\t\tstd::string response = router->ReceiveResponse(server_name);\n\t\tif (response == \"OK\") {\n\t\t\tROS_INFO(\"Sensor %d enabled on %s\", sensor_id, server_name.c_str());\n\t\t} else {\n\t\t\tROS_ERROR(\"Sensor %d could not be enabled on %s\", sensor_id, server_name.c_str());\n\t\t}\n\t} else {\n\t\tROS_ERROR(\"Sensor %d could not be found on any server\", sensor_id);\n\t}\n}", "CodeBleu_score": 44.08095063342754}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tstd::vector<std::string> secondary_servers;\n\tstd::string server_name;\n\tstd::string sensor_name;\n\tstd::string topic_name;\n\tstd::string frame_name;\n\tstd::string frame_id;\n\tstd::string sensor_type;\n\tstd::string sensor_subtype;\n\tstd::string sensor_parent;\n\tstd::string sensor_parent_frame;\n\tstd::string sensor_parent_frame_id;\n\tstd::string sensor_parent_type;\n\tstd::string sensor_parent_subtype;\n\tstd::string sensor_parent_parent;\n\tstd::string sensor_parent_parent_frame;\n\tstd::string sensor_parent_parent_frame_id;\n\tstd::string sensor_parent_parent_type;\n\tstd::string sensor_parent_parent_subtype;\n\tstd::string sensor_parent_parent_parent;\n\tstd::string sensor_parent_parent_parent_frame;\n\tstd::string sensor_parent_parent_parent_frame_id;\n\tstd::string sensor_parent_parent_parent_type;\n\tstd::string sensor_parent_parent_parent_subtype;\n\tstd::string sensor_parent_parent_parent_parent;\n\tstd::string sensor_parent_parent_parent_parent_frame;\n\tstd::string sensor_parent_parent_parent_parent_frame_id;\n\tstd::string sensor_parent_parent_parent_parent_type;\n\tstd::string sensor_parent_parent_parent_parent_subtype;\n\tstd::string sensor_parent_parent_parent_parent_parent;\n\tstd::string sensor_parent_parent_parent_parent_parent_frame;\n\tstd::string sensor_parent_parent_parent_parent_parent_frame_id;\n\tstd::string sensor_parent_parent_parent_parent_parent_type;\n\tstd::string sensor_parent_parent_parent_parent_parent_subtype;\n\tstd::string sensor_parent_parent_parent_parent_parent_parent;\n\tstd::string sensor_parent_parent_parent_parent_parent_parent_frame;\n\tstd::string sensor_parent_parent_parent_parent_parent_parent_frame_", "CodeBleu_score": 4.23777050218607}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tif (sensor_id >= sensors.size()) {\n\t\tstd::cerr << \"Error: sensor_id \" << sensor_id << \" is out of range (0, \" << sensors.size() << \")\" << std::endl;\n\t\treturn 0;\n\t}\n\tauto& sensor = sensors[sensor_id];\n\tif (sensor.enabled) {\n\t\tstd::cout << \"Info: sensor \" << sensor_id << \" is already enabled\" << std::endl;\n\t\treturn sensor.token;\n\t}\n\tstd::cout << \"Info: sensor \" << sensor_id << \" is not enabled, enabling it\" << std::endl;\n\tauto token = router.EnableSensor(sensor_id);\n\tif (token == 0) {\n\t\tstd::cerr << \"Error: sensor \" << sensor_id << \" could not be enabled\" << std::endl;\n\t\treturn 0;\n\t}\n\tsensor.enabled = true;\n\tsensor.token = token;\n\treturn token;\n}", "CodeBleu_score": 42.06947495566133}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tif (tokens.find(sensor_id)!= tokens.end()) {\n\t\tLOG(INFO) << \"Token for sensor \" << sensor_id << \" already exists.\";\n\t\treturn tokens[sensor_id];\n\t}\n\n\tLOG(INFO) << \"Token for sensor \" << sensor_id << \" does not exist.\";\n\n\t// Get the sensor's address\n\tauto sensor_address = router->GetSensorAddress(sensor_id);\n\n\t// Check if the sensor is already enabled on the secondary server\n\tif (sensor_address.has_value()) {\n\t\t// If the sensor is already enabled, retrieve the token from the secondary server\n\t\tLOG(INFO) << \"Sensor \" << sensor_id << \" is already enabled on secondary server.\";\n\t\ttoken_type token = router->GetSensorToken(sensor_id);\n\t\ttokens[sensor_id] = token;\n\t\treturn token;\n\t}\n\n\t// If the sensor is not enabled, enable it on the secondary server\n\tLOG(INFO) << \"Sensor \" << sensor_id << \" is not enabled on secondary server.\";\n\ttoken_type token = router->EnableSensor(sensor_id);\n\ttokens[sensor_id] = token;\n\treturn token;\n}", "CodeBleu_score": 49.01840760825028}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// Check if sensor is already activated\n\tif (m_sensor_tokens.find(sensor_id)!= m_sensor_tokens.end()) {\n\t\t// Sensor is already activated, return existing token\n\t\tLOG_DEBUG << \"Sensor \" << sensor_id << \" already activated, returning existing token\";\n\t\treturn m_sensor_tokens[sensor_id];\n\t}\n\n\t// Sensor is not activated, enable sensor on secondary server and retrieve a new token\n\tLOG_DEBUG << \"Sensor \" << sensor_id << \" not yet activated, enabling on secondary server and retrieving new token\";\n\n\t// Enable sensor on secondary server\n\tm_secondary->EnableSensor(sensor_id);\n\n\t// Retrieve new token\n\ttoken_type new_token = m_secondary->GetToken(sensor_id);\n\n\t// Update maps\n\tm_sensor_tokens[sensor_id] = new_token;\n\tm_token_sensor_ids[new_token] = sensor_id;\n\n\treturn new_token;\n}", "CodeBleu_score": 47.06483812033512}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n\tfile.close();\n\treturn Load(buffer);\n}", "CodeBleu_score": 55.28789170207278}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> buffer(std::istreambuf_iterator<char>(file), {});\n\tfile.close();\n\treturn Load(buffer);\n}", "CodeBleu_score": 49.33398961209943}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\tCARLA_ERROR_S(\"Failed to open file '%s'.\", filename.c_str());\n\t\treturn false;\n\t}\n\n\tstd::vector<char> file_data;\n\tfile_data.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());\n\tfile.close();\n\n\treturn Load(file_data);\n}", "CodeBleu_score": 54.17012896980644}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\tCARLA_ERROR_EVERY(1000, \"Navigation system not ready\");\n\t\treturn false;\n\t}\n\tif (crowd == nullptr) {\n\t\tCARLA_ERROR_EVERY(1000, \"Crowd is null\");\n\t\treturn false;\n\t}\n\tstd::lock_guard<std::mutex> lock(mutex_);\n\tauto it = walker_agents_.find(id);\n\tif (it!= walker_agents_.end()) {\n\t\twalker_agents_.erase(it);\n\t}\n\telse {\n\t\tit = vehicle_agents_.find(id);\n\t\tif (it!= vehicle_agents_.end()) {\n\t\t\tvehicle_agents_.erase(it);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.598299413022595}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (!is_ready_) {\n\t\tCARLA_ERROR_SLOW(\n\t\t\t\t\"Navigation::RemoveAgent: Navigation system is not ready. Cannot remove agent.\");\n\t\treturn false;\n\t}\n\tif (crowd_ == nullptr) {\n\t\tCARLA_ERROR_SLOW(\n\t\t\t\t\"Navigation::RemoveAgent: Navigation system is not initialized. Cannot remove agent.\");\n\t\treturn false;\n\t}\n\tif (walker_manager_ == nullptr) {\n\t\tCARLA_ERROR_SLOW(\n\t\t\t\t\"Navigation::RemoveAgent: Walker manager is not initialized. Cannot remove agent.\");\n\t\treturn false;\n\t}\n\tif (vehicle_manager_ == nullptr) {\n\t\tCARLA_ERROR_SLOW(\n\t\t\t\t\"Navigation::RemoveAgent: Vehicle manager is not initialized. Cannot remove agent.\");\n\t\treturn false;\n\t}\n\tauto it = walker_mapping_.find(id);\n\tif (it!= walker_mapping_.end()) {\n\t\twalker_manager_->RemoveWalker(it->second);\n\t\twalker_mapping_.erase(it);\n\t}\n\tit = vehicle_mapping_.find(id);\n\tif (it!= vehicle_mapping_.end()) {\n\t\tvehicle_manager_->RemoveVehicle(it->second);\n\t\tvehicle_mapping_.erase(it);\n\t}\n\treturn true;\n}", "CodeBleu_score": 48.13789456013156}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// If the system is not ready, return false.\n\tif (!is_ready_) {\n\t\treturn false;\n\t}\n\n\t// If the crowd object is null, return false.\n\tif (crowd_ == nullptr) {\n\t\treturn false;\n\t}\n\n\t// If the agent id is invalid, return false.\n\tif (id == 0) {\n\t\treturn false;\n\t}\n\n\t// Enter a critical section to safely remove the agent from the crowd.\n\tstd::lock_guard<std::mutex> lock(crowd_mutex_);\n\n\t// Search for the agent id in the walker and vehicle mappings.\n\tauto walker_it = walker_mapping_.find(id);\n\tauto vehicle_it = vehicle_mapping_.find(id);\n\n\t// If the agent id is not found in the walker or vehicle mappings, return false.\n\tif (walker_it == walker_mapping_.end() && vehicle_it == vehicle_mapping_.end()) {\n\t\treturn false;\n\t}\n\n\t// If the agent id is found in the walker mapping, remove it from the walker mapping.\n\tif (walker_it!= walker_mapping_.end()) {\n\t\twalker_mapping_.erase(walker_it);\n\t}\n\n\t// If the agent id is found in the vehicle mapping, remove it from the vehicle mapping.\n\tif (vehicle_it!= vehicle_mapping_.end()) {\n\t\tvehicle_mapping_.erase(vehicle_it);\n\t}\n\n\t// Remove the agent id from the crowd.\n\tcrowd_->RemoveAgent(id);\n\n\t// Return true to indicate the agent is successfully removed.\n\treturn true;\n}", "CodeBleu_score": 47.86864903492899}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\t// If we have no vehicles, we are done\n\tif (vehicles.empty()) {\n\t\treturn true;\n\t}\n\n\t// Collect the IDs of all vehicles in the current frame\n\tstd::set<uint64_t> current_vehicles;\n\tfor (auto vehicle : vehicles) {\n\t\tcurrent_vehicles.insert(vehicle.id);\n\t}\n\n\t// Add or update vehicles from the provided list\n\tfor (auto vehicle : vehicles) {\n\t\t// If we have a vehicle with the same ID, update it\n\t\tif (vehicles_map.find(vehicle.id)!= vehicles_map.end()) {\n\t\t\tvehicles_map[vehicle.id]->Update(vehicle);\n\t\t}\n\t\t// Otherwise, create a new vehicle\n\t\telse {\n\t\t\tvehicles_map[vehicle.id] = std::make_shared<Vehicle>(vehicle);\n\t\t}\n\t}\n\n\t// Remove vehicles that are not in the current frame\n\tfor (auto vehicle : vehicles_map) {\n\t\tif (current_vehicles.find(vehicle.first) == current_vehicles.end()) {\n\t\t\tvehicles_map.erase(vehicle.first);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.56363959171768}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::lock_guard<std::mutex> lock(vehicles_mutex);\n\tstd::set<std::string> ids;\n\tfor (auto& vehicle : vehicles) {\n\t\tids.insert(vehicle.id);\n\t}\n\tfor (auto& vehicle : vehicles) {\n\t\tif (vehicle.is_updated) {\n\t\t\tauto it = vehicles_map.find(vehicle.id);\n\t\t\tif (it == vehicles_map.end()) {\n\t\t\t\tvehicles_map[vehicle.id] = vehicle;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tit->second = vehicle;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvehicles_map.erase(vehicle.id);\n\t\t}\n\t}\n\tfor (auto& vehicle : vehicles_map) {\n\t\tif (ids.find(vehicle.first) == ids.end()) {\n\t\t\tvehicles_map.erase(vehicle.first);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 49.710960115198134}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::lock_guard<std::mutex> lock(vehicles_mutex_);\n\n\t// collect the IDs of currently mapped vehicles\n\tstd::set<uint64_t> current_vehicles;\n\tfor (const auto& vehicle : vehicles_) {\n\t\tcurrent_vehicles.insert(vehicle.id);\n\t}\n\n\t// add or update vehicles from the provided list, marking them as updated\n\tfor (const auto& vehicle : vehicles) {\n\t\tauto it = vehicles_.find(vehicle.id);\n\t\tif (it == vehicles_.end()) {\n\t\t\t// vehicle does not exist in the current frame\n\t\t\tvehicles_.insert(std::make_pair(vehicle.id, vehicle));\n\t\t} else {\n\t\t\t// vehicle exists in the current frame\n\t\t\tit->second = vehicle;\n\t\t}\n\t\tcurrent_vehicles.erase(vehicle.id);\n\t}\n\n\t// remove vehicles not marked as updated\n\tfor (const auto& vehicle : vehicles_) {\n\t\tif (current_vehicles.find(vehicle.first) == current_vehicles.end()) {\n\t\t\tvehicles_.erase(vehicle.first);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 48.54505424523975}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tauto it = walkers_.find(id);\n\tif (it!= walkers_.end()) {\n\t\tauto walker = it->second;\n\t\tif (walker->HasVehicleNear(distance, direction)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tauto it2 = vehicles_.find(id);\n\tif (it2!= vehicles_.end()) {\n\t\tauto vehicle = it2->second;\n\t\tif (vehicle->HasVehicleNear(distance, direction)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 52.78350805797869}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// Get actor\n\tauto actor = GetActor(id);\n\tif (!actor) {\n\t\treturn false;\n\t}\n\n\t// Get actor location\n\tauto actor_location = actor->GetLocation();\n\n\t// Get actor type\n\tauto actor_type = actor->GetActorType();\n\n\t// Get actor bounding box\n\tauto actor_bounding_box = actor->GetBoundingBox();\n\n\t// Get actor bounding box center\n\tauto actor_bounding_box_center = actor_bounding_box.GetCenter();\n\n\t// Get actor bounding box size\n\tauto actor_bounding_box_size = actor_bounding_box.GetSize();\n\n\t// Get actor bounding box half size\n\tauto actor_bounding_box_half_size = actor_bounding_box_size * 0.5f;\n\n\t// Get actor bounding box half size in x\n\tauto actor_bounding_box_half_size_x = actor_bounding_box_half_size.x;\n\n\t// Get actor bounding box half size in y\n\tauto actor_bounding_box_half_size_y = actor_bounding_box_half_size.y;\n\n\t// Get actor bounding box half size in z\n\tauto actor_bounding_box_half_size_z = actor_bounding_box_half_size.z;\n\n\t// Get actor bounding box center in x\n\tauto actor_bounding_box_center_x = actor_bounding_box_center.x;\n\n\t// Get actor bounding box center in y\n\tauto actor_bounding_box_center_y = actor_bounding_box_center.y;\n\n\t// Get actor bounding box center in z\n\tauto actor_bounding_box_center_z = actor_bounding_box_center.z;\n\n\t// Get actor bounding box half size in x\n\tauto actor_bounding_box_half_size_x = actor_bounding_box_half_size.x;\n\n\t// Get actor bounding box half size in y\n\tauto actor_bounding_box_half_size_y = actor_bounding_box_half_size.y;\n\n\t// Get actor bounding box half size in z\n\tauto actor_bounding_box_half_size_z = actor_bounding_box_half_size.z;\n\n\t// Get actor bounding box", "CodeBleu_score": 35.61049381730423}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tauto it = walkers_.find(id);\n\tif (it!= walkers_.end()) {\n\t\treturn it->second.HasVehicleNear(distance, direction);\n\t}\n\tit = vehicles_.find(id);\n\tif (it!= vehicles_.end()) {\n\t\treturn it->second.HasVehicleNear(distance, direction);\n\t}\n\treturn false;\n}", "CodeBleu_score": 48.89473765770606}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Get the current route point\n\tconst auto &route_point = info.route_points[info.route_point_index];\n\t// Create a visitor to execute the event\n\tWalkerEventVisitor visitor(id, info, delta);\n\t// Process the event\n\treturn boost::variant2::visit(visitor, route_point.event);\n}", "CodeBleu_score": 50.722300630802806}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto &walker = info.walker;\n\n\tauto &route = info.route;\n\tauto &route_point = route[info.route_point];\n\n\tauto &route_point_actor = route_point.actor;\n\tauto &route_point_actor_snapshot = route_point_actor.snapshot;\n\n\tauto &route_point_actor_location = route_point_actor_snapshot.location;\n\tauto &route_point_actor_rotation = route_point_actor_snapshot.rotation;\n\n\tauto &route_point_actor_transform = route_point_actor_snapshot.transform;\n\tauto &route_point_actor_transform_location = route_point_actor_transform.location;\n\tauto &route_point_actor_transform_rotation = route_point_actor_transform.rotation;\n\n\tauto &route_point_location = route_point.location;\n\tauto &route_point_rotation = route_point.rotation;\n\n\tauto &route_point_transform = route_point.transform;\n\tauto &route_point_transform_location = route_point_transform.location;\n\tauto &route_point_transform_rotation = route_point_transform.rotation;\n\n\tauto &route_point_transform_location_x = route_point_transform_location.x;\n\tauto &route_point_transform_location_y = route_point_transform_location.y;\n\tauto &route_point_transform_location_z = route_point_transform_location.z;\n\n\tauto &route_point_transform_rotation_pitch = route_point_transform_rotation.pitch;\n\tauto &route_point_transform_rotation_yaw = route_point_transform_rotation.yaw;\n\tauto &route_point_transform_rotation_roll = route_point_transform_rotation.roll;\n\n\tauto &route_point_transform_rotation_pitch_radians = route_point_transform_rotation_pitch * M_PI / 180.0;\n\tauto &route_point_transform_rotation_yaw_radians = route_point_transform_rotation_yaw * M_PI / 180.0;\n\tauto &route_point_transform_rotation_roll_radians = route_point_transform", "CodeBleu_score": 36.44063963284432}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tWalkerEventVisitor visitor(info, delta);\n\treturn boost::variant2::visit(visitor, info.event);\n}", "CodeBleu_score": 38.3898643964152}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\t// Iterate through each road node in the XML document.\n\tfor (auto road_node : xml.select_nodes(\"OpenDRIVE/road\")) {\n\t\t// Get the road ID from the road node.\n\t\tauto road_id = road_node.node().attribute(\"id\").as_string();\n\t\t// Create a new road with the road ID.\n\t\tauto road = map_builder.CreateRoad(road_id);\n\n\t\t// Iterate through each lane section node in the road node.\n\t\tfor (auto lane_section_node : road_node.node().select_nodes(\"lanes/laneSection\")) {\n\t\t\t// Get the lane section ID from the lane section node.\n\t\t\tauto lane_section_id = lane_section_node.node().attribute(\"id\").as_string();\n\t\t\t// Create a new lane section with the lane section ID.\n\t\t\tauto lane_section = road->CreateLaneSection(lane_section_id);\n\n\t\t\t// Parse the left, center, and right lane nodes.\n\t\t\tParseLanes(lane_section_node.node(), lane_section);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.33251311359116}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\tfor (pugi::xml_node road : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\t\tconst std::string road_id = road.attribute(\"id\").value();\n\t\tfor (pugi::xml_node lane : road.child(\"lanes\").children(\"lane\")) {\n\t\t\tParseLanes(lane, map_builder, road_id);\n\t\t}\n\t}\n}", "CodeBleu_score": 24.98541701849773}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\t// Iterate through each road node\n\tfor (auto road_node : xml.child(\"OpenDRIVE\").child(\"road\").children(\"road\")) {\n\t\t// Get the road ID\n\t\tconst std::string road_id = road_node.attribute(\"id\").value();\n\n\t\t// Iterate through each lane section\n\t\tfor (auto lane_node : road_node.child(\"lanes\").children(\"lane\")) {\n\t\t\t// Parse the left, center, and right lanes\n\t\t\tParseLanes(lane_node, map_builder, road_id);\n\t\t}\n\t}\n}", "CodeBleu_score": 24.55261230023865}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tstd::cout << \"on_publication_matched\" << std::endl;\n\tif (info.current_count_change() > 0) {\n\t\tif (info.current_count() == 1) {\n\t\t\tstd::cout << \"on_publication_matched: First match\" << std::endl;\n\t\t\tm_matched_count = 1;\n\t\t\tm_first_connection = true;\n\t\t} else {\n\t\t\tstd::cout << \"on_publication_matched: Matched count change \" << info.current_count_change() << std::endl;\n\t\t\tm_matched_count += info.current_count_change();\n\t\t}\n\t} else if (info.current_count_change() < 0) {\n\t\tif (info.current_count() == 0) {\n\t\t\tstd::cout << \"on_publication_matched: Last match\" << std::endl;\n\t\t\tm_matched_count = 0;\n\t\t\tm_first_connection = false;\n\t\t} else {\n\t\t\tstd::cout << \"on_publication_matched: Matched count change \" << info.current_count_change() << std::endl;\n\t\t\tm_matched_count += info.current_count_change();\n\t\t}\n\t} else {\n\t\tstd::cout << \"on_publication_matched: Invalid count change \" << info.current_count_change() << std::endl;\n\t}\n}", "CodeBleu_score": 35.92378542816704}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change() == 0) {\n\t\treturn;\n\t}\n\n\tif (info.current_count() == 0) {\n\t\tif (info.total_count() == 0) {\n\t\t\tstd::cout << \"No connections\" << std::endl;\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"Lost connection\" << std::endl;\n\t\t}\n\t}\n\telse if (info.total_count() == 0) {\n\t\tstd::cout << \"New connection\" << std::endl;\n\t}\n\telse {\n\t\tstd::cout << \"Matched \" << info.total_count() << \" times\" << std::endl;\n\t}\n}", "CodeBleu_score": 49.51018538451114}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change() == 0) {\n\t\treturn;\n\t}\n\n\tif (info.current_count() == 0) {\n\t\tif (info.previous_count() == 0) {\n\t\t\treturn;\n\t\t}\n\t\tstd::cout << \"No more matches with the writer\" << std::endl;\n\t} else if (info.current_count() == 1) {\n\t\tif (info.previous_count() == 1) {\n\t\t\treturn;\n\t\t}\n\t\tstd::cout << \"New match with the writer\" << std::endl;\n\t} else {\n\t\tstd::cout << \"Matched count changed from \" << info.previous_count() << \" to \" << info.current_count() << std::endl;\n\t}\n}", "CodeBleu_score": 49.55923495168019}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == efd::SubscriptionMatchedStatus::MATCHED_CURRENT_COUNT_ZERO) {\n\t\tif (info.total_count == 0) {\n\t\t\tif (first_connected) {\n\t\t\t\tfirst_connected = false;\n\t\t\t\tif (matched_count > 0) {\n\t\t\t\t\tmatched_count--;\n\t\t\t\t\tif (matched_count == 0) {\n\t\t\t\t\t\t// TODO: Destroy the subscriber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!first_connected) {\n\t\t\t\tfirst_connected = true;\n\t\t\t\tmatched_count++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstd::cout << \"Error: Invalid change count in subscription matched status.\" << std::endl;\n\t}\n}", "CodeBleu_score": 46.56426528923417}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == efd::STATUS_COUNT_CHANGE_UPDATED) {\n\t\tif (info.current_count == 0) {\n\t\t\t//std::cout << \"No more subscriptions matched for topic: \" << reader->get_topic_name() << std::endl;\n\t\t\t//std::cout << \"Matched count: \" << info.current_count << std::endl;\n\t\t\t//std::cout << \"Total count: \" << info.total_count << std::endl;\n\t\t\t//std::cout << \"Last change: \" << info.last_subscription_change << std::endl;\n\t\t\t//std::cout << \"Total unmatched: \" << info.total_unmatched << std::endl;\n\t\t\t//std::cout << \"Total matched: \" << info.total_matched << std::endl;\n\t\t\t//std::cout << \"Total active: \" << info.total_active << std::endl;\n\t\t\t//std::cout << \"Total inactive: \" << info.total_inactive << std::endl;\n\t\t\t//std::cout << \"Total nowriters: \" << info.total_nowriters << std::endl;\n\t\t\t//std::cout << \"Total unregistered: \" << info.total_unregistered << std::endl;\n\t\t\t//std::cout << \"Total unregistered_unmatched: \" << info.total_unregistered_unmatched << std::endl;\n\t\t\t//std::cout << \"Total disposed: \" << info.total_disposed << std::endl;\n\t\t\t//std::cout << \"Total disposed_unregistered: \" << info.total_disposed_unregistered << std::endl;\n\t\t\t//std::cout << \"Total disposed_unregistered_unmatched: \" << info.total_disposed_unregistered_unmatched << std::endl;\n\t\t\t//std::cout << \"Total disposed_nowriters: \" << info.total_disposed_nowriters << std::endl;\n\t\t\t//std::cout << \"Total disposed_unregistered_nowriters: \" << info.total_disposed_unregistered_nowriters << std::endl;\n\t\t\t//std::cout << \"Total disposed_unregistered_unmatched_nowriters: \" << info.total_disposed_unregistered_unmatched_no", "CodeBleu_score": 21.862991485345933}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == efd::SubscriptionMatchedStatus::MATCHED_CURRENT_COUNT_ZERO) {\n\t\tif (info.total_count > 0) {\n\t\t\tif (info.total_count == 1) {\n\t\t\t\tstd::cout << \"Matched with 1 subscriber.\" << std::endl;\n\t\t\t} else {\n\t\t\t\tstd::cout << \"Matched with \" << info.total_count << \" subscribers.\" << std::endl;\n\t\t\t}\n\t\t} else {\n\t\t\tstd::cout << \"No subscribers.\" << std::endl;\n\t\t}\n\t} else if (info.current_count_change == efd::SubscriptionMatchedStatus::MATCHED_CURRENT_COUNT_ONE) {\n\t\tif (info.total_count > 0) {\n\t\t\tstd::cout << \"Matched with 1 subscriber.\" << std::endl;\n\t\t} else {\n\t\t\tstd::cout << \"No subscribers.\" << std::endl;\n\t\t}\n\t} else if (info.current_count_change == efd::SubscriptionMatchedStatus::MATCHED_CURRENT_COUNT_ZERO) {\n\t\tif (info.total_count > 0) {\n\t\t\tstd::cout << \"Matched with \" << info.total_count << \" subscribers.\" << std::endl;\n\t\t} else {\n\t\t\tstd::cout << \"No subscribers.\" << std::endl;\n\t\t}\n\t} else {\n\t\tstd::cout << \"Invalid change in subscription count.\" << std::endl;\n\t}\n}", "CodeBleu_score": 46.84820061189668}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tCarlaCollisionEvent* p_type = reinterpret_cast<CarlaCollisionEvent*>(data);\n\tif (p_type->key_defined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEventPubSubType new_type;\n\tchar* serialized_data = new char[new_type.getSerializedSizeProvider(p_type)];\n\tnew_type.serialize(&serialized_data, p_type);\n\tif (!force_md5 && serialized_data) {\n\t\thandle->value = serialized_data;\n\t\tdelete[] serialized_data;\n\t\treturn true;\n\t}\n\tchar* md5sum = new char[MD5SUM_LEN];\n\tcomputeMD5(serialized_data, new_type.getSerializedSizeProvider(p_type), md5sum);\n\thandle->value = md5sum;\n\tdelete[] md5sum;\n\tdelete[] serialized_data;\n\treturn true;\n}", "CodeBleu_score": 32.159012678102584}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (m_key_hash!= nullptr) {\n\t\t// If the hash function is defined, we use it to generate the key.\n\t\tchar* key = nullptr;\n\t\tsize_t key_length = 0;\n\t\tif (force_md5 || m_force_md5_key_lookup) {\n\t\t\t// Function is defined, use it to generate the key.\n\t\t\tm_key_hash(data, &key, &key_length);\n\t\t} else {\n\t\t\t// Function is defined, use it to generate the key.\n\t\t\tm_key_hash(data, &key, &key_length);\n\t\t}\n\t\tif (key) {\n\t\t\t// Copy the key into the handle.\n\t\t\tif (handle->key_buffer) {\n\t\t\t\tdelete[] handle->key_buffer;\n\t\t\t}\n\t\t\thandle->key_buffer = new uint8_t[key_length];\n\t\t\thandle->key_length = key_length;\n\t\t\tmemcpy(handle->key_buffer, key, key_length);\n\t\t\tdelete[] key;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// If the hash function is not defined, we copy the serialized key into the handle.\n\tCarlaCollisionEvent* ptr = reinterpret_cast<CarlaCollisionEvent*>(data);\n\tsize_t size = ptr->getKeyMaxCdrSerializedSize(ptr->get_type_id());\n\tif (handle->key_buffer) {\n\t\tdelete[] handle->key_buffer;\n\t}\n\thandle->key_buffer = new uint8_t[size];\n\thandle->key_length = size;\n\tcdr ser(handle->key_buffer, size);\n\tptr->serializeKey(&ser);\n\treturn true;\n}", "CodeBleu_score": 37.598205284003924}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tbool result = false;\n\n\tCarlaCollisionEvent* p_type_data = (CarlaCollisionEvent*)data;\n\n\tif (p_type_data!= nullptr) {\n\t\tconst uint8_t* key = p_type_data->key;\n\n\t\tif (key!= nullptr) {\n\t\t\tif (force_md5 || (key[0] == 0)) {\n\t\t\t\t// If the key is empty, it is automatically defined to be 0\n\t\t\t\t// This is a workaround for the fact that the MD5 hash is\n\t\t\t\t// not initialized to 0 when it is empty\n\t\t\t\t// TODO: remove this workaround when the MD5 hash is fixed\n\t\t\t\t// to be initialized to 0 when it is empty\n\t\t\t\tmemset(handle, 0, 16);\n\t\t\t\tmemcpy(handle, key, 16);\n\t\t\t\tresult = true;\n\t\t\t} else {\n\t\t\t\t// The key is already defined\n\t\t\t\tmemcpy(handle, key, 16);\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 22.06480968388282}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\ttry {\n    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\n    // Serialize encapsulation\n    payload->encapsulation = IENCAPSULATION_CDR_BE;\n\n    // Serialize the object data\n    fastcdr::FastBuffer fastbuffer(FASTBUFFER_MAX_SIZE);\n    fastcdr::Cdr ser(fastbuffer, fastcdr::Cdr::DEFAULT_ENDIAN, fastcdr::Cdr::DDS_CDR);\n    ser.serialize_encapsulation();\n    payload->encapsulation = ser.endianness() == fastcdr::Cdr::BIG_ENDIANNESS? IENCAPSULATION_CDR_BE : IENCAPSULATION_CDR_LE;\n    p_type->serialize(ser);\n    payload->length = (uint32_t)ser.getSerializedDataLength();\n    payload->data = (uint8_t*) malloc(payload->length);\n    memcpy(payload->data, ser.getSerializedData(), payload->length);\n    return true;\n} catch (fastcdr::exception::NotEnoughMemoryException& e) {\n    return false;\n}\n}", "CodeBleu_score": 61.77400945314162}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n\n    // serialize the object to the buffer\n    cdrBuffer.reset();\n    eprosima::fastcdr::Cdr ser(cdrBuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    ser << *p_type;\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n    payload->length = (uint32_t)cdrBuffer.getSerializedDataLength();\n    payload->data = cdrBuffer.getBuffer();\n\n    return true;\n}", "CodeBleu_score": 46.369882334478085}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Serialize the object\n\ttry\n\t{\n\t\tfastcdr::FastBuffer fastbuffer(payload->data, payload->max_size);\n\t\tfastcdr::Cdr ser(fastbuffer, fastcdr::Cdr::DEFAULT_ENDIAN, fastcdr::Cdr::DDS_CDR);\n\n\t\tser.serialize_array(p_type->steering, 1);\n\t\tser.serialize_array(p_type->throttle, 1);\n\t\tser.serialize_array(p_type->brake, 1);\n\t\tser.serialize_array(p_type->clutch, 1);\n\t\tser.serialize_array(p_type->gear, 1);\n\t\tser.serialize_array(p_type->hand_brake, 1);\n\t\tser.serialize_array(p_type->manual_gear_shift, 1);\n\t\tser.serialize_array(p_type->manual_steering_control, 1);\n\t\tser.serialize_array(p_type->manual_throttle_control, 1);\n\t\tser.serialize_array(p_type->manual_brake_control, 1);\n\t\tser.serialize_array(p_type->manual_clutch_control, 1);\n\t\tser.serialize_array(p_type->manual_hand_brake_control, 1);\n\t\tser.serialize_array(p_type->manual_gear_shift_control, 1);\n\t\tser.serialize_array(p_type->manual_gear_shift_control, 1);\n\t\tser.serialize_array(p_type->manual_steering_wheel_control, 1);\n\t\tser.serialize_array(p_type->manual_steering_wheel_angle, 1);\n\t\tser.serialize_array(p_type->manual_throttle_wheel_control, 1);\n\t\tser.serialize_array(p_type->manual_throttle_wheel_angle, 1);\n\t\tser.serialize_array(p_type->manual_brake_wheel_control, 1);\n\t\tser.serialize_array(p_type->manual_brake_wheel_angle", "CodeBleu_score": 33.38455812172315}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED:\n\t\ttarget_sysid = msg.sysid;\n\t\ttarget_set = true;\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_REQUEST_DATA_STREAM:\n\t\tif (msg.sysid == target_sysid) {\n\t\t\tmavlink_msg_request_data_stream_pack(1, 1, &mavlink_msg, msg.sysid, 1, 1, 1, 1);\n\t\t\tmavlink_send_message(&mavlink_msg, &mavlink_chan);\n\t\t\tmavlink_msg_request_data_stream_pack(1, 1, &mavlink_msg, msg.sysid, 1, 2, 1, 1);\n\t\t\tmavlink_send_message(&mavlink_msg, &mavlink_chan);\n\t\t\tmavlink_msg_request_data_stream_pack(1, 1, &mavlink_msg, msg.sysid, 1, 3, 1, 1);\n\t\t\tmavlink_send_message(&mavlink_msg, &mavlink_chan);\n\t\t\tmavlink_msg_request_data_stream_pack(1, 1, &mavlink_msg, msg.sysid, 1, 4, 1, 1);\n\t\t\tmavlink_send_message(&mavlink_msg, &mavlink_chan);\n\t\t\tmavlink_msg_request_data_stream_pack(1, 1, &mavlink_msg, msg.sysid, 1, 5, 1, 1);\n\t\t\tmavlink_send_message(&mavlink_msg, &mavlink_chan);\n\t\t\tmavlink_msg_request_data_stream_pack(1, 1, &mavlink_msg, msg.sysid, 1, 6, 1, 1);\n\t\t\tmavlink_send_message(&mavlink_msg, &mavlink_chan);\n\t\t\tmavlink_msg_request_data_stream_pack(1, 1, &mavlink_msg, msg.sysid, ", "CodeBleu_score": 32.533728763684955}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_ATTITUDE:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\treturn;\n\t\t}\n\n\t\ttarget_set = true;\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\treturn;\n\t\t}\n\n\t\ttarget_set = true;\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_SCALED_PRESSURE:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\treturn;\n\t\t}\n\n\t\ttarget_set = true;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_COMP_ID_ALL, 1, 2, 1);\n\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_COMP_ID_ALL, 3, 1, 1);\n}", "CodeBleu_score": 38.68675608204279}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (mavlink_target_sysid!= 0) {\n\t\treturn;\n\t}\n\n\tif (msg.msgid!= MAVLINK_MSG_ID_GLOBAL_POSITION_INT) {\n\t\treturn;\n\t}\n\n\tmavlink_global_position_int_t pos;\n\tmavlink_msg_global_position_int_decode(&msg, &pos);\n\n\tmavlink_target_sysid = msg.sysid;\n\tmavlink_target_compid = msg.compid;\n\n\tmavlink_request_data_stream(mavlink_target_sysid, mavlink_target_compid, MAV_DATA_STREAM_GLOBAL_POSITION, 1, 1);\n\tmavlink_request_data_stream(mavlink_target_sysid, mavlink_target_compid, MAV_DATA_STREAM_GPS_RAW_INT, 1, 1);\n\tmavlink_request_data_stream(mavlink_target_sysid, mavlink_target_compid, MAV_DATA_STREAM_SCALED_PRESSURE, 1, 1);\n\n\tmavlink_target_set = true;\n}", "CodeBleu_score": 39.84993338378043}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = MAV_RESULT_ACCEPTED;\n\tif (this->get_status() == GCS_MAVLINK_Tracker::GCS_MAVLINK_STATUS_PREFLIGHT) {\n\t\tresult = GCS_MAVLINK_Tracker::handle_command_preflight_calibration_baro(msg);\n\t\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t\tthis->set_barometer_calibration_needed(true);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 48.548894420872834}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\treturn _tracker->handle_command_preflight_calibration_baro(msg);\n}", "CodeBleu_score": 20.35203462574206}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = _mavlink_tracker->handle_command_preflight_calibration_baro(msg);\n\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_cal_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 48.64875996067985}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\t// Arm the servos\n\t\tif (tracker->arm_servos()) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_FAILED;\n\t\t}\n\t} else if (packet.param1 == 0.0) {\n\t\t// Disarm the servos\n\t\tif (tracker->disarm_servos()) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_FAILED;\n\t\t}\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 54.52404505617445}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\t// arm\n\t\tif (packet.target_system == 0) {\n\t\t\t// arm all servos\n\t\t\tfor (uint8_t i = 0; i < 10; i++) {\n\t\t\t\tservo[i].arm();\n\t\t\t}\n\t\t} else {\n\t\t\t// arm servo\n\t\t\tservo[packet.target_system - 1].arm();\n\t\t}\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\t// disarm\n\t\tif (packet.target_system == 0) {\n\t\t\t// disarm all servos\n\t\t\tfor (uint8_t i = 0; i < 10; i++) {\n\t\t\t\tservo[i].disarm();\n\t\t\t}\n\t\t} else {\n\t\t\t// disarm servo\n\t\t\tservo[packet.target_system - 1].disarm();\n\t\t}\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 48.62812771226569}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t//arming/disarming servos\n\tif (packet.param1 == 1.0) {\n\t\t//arm\n\t\tif (packet.command == MAV_CMD_COMPONENT_ARM_DISARM) {\n\t\t\t//arming servos\n\t\t\tmavlink_command_long_t command;\n\t\t\tcommand.command = MAV_CMD_COMPONENT_ARM_DISARM;\n\t\t\tcommand.target_system = packet.target_system;\n\t\t\tcommand.target_component = packet.target_component;\n\t\t\tcommand.param1 = 1.0;\n\t\t\tcommand.param2 = 0.0;\n\t\t\tcommand.param3 = 0.0;\n\t\t\tcommand.param4 = 0.0;\n\t\t\tcommand.param5 = 0.0;\n\t\t\tcommand.param6 = 0.0;\n\t\t\tcommand.param7 = 0.0;\n\t\t\tmavlink_msg_command_long_send(this->mavlink_fd, &command);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t} else if (packet.param1 == 0.0) {\n\t\t//disarm\n\t\tif (packet.command == MAV_CMD_COMPONENT_ARM_DISARM) {\n\t\t\t//disarming servos\n\t\t\tmavlink_command_long_t command;\n\t\t\tcommand.command = MAV_CMD_COMPONENT_ARM_DISARM;\n\t\t\tcommand.target_system = packet.target_system;\n\t\t\tcommand.target_component = packet.target_component;\n\t\t\tcommand.param1 = 0.0;\n\t\t\tcommand.param2 = 0.0;\n\t\t\tcommand.param3 = 0.0;\n\t\t\tcommand.param4 = 0.0;\n\t\t\tcommand.param5 = 0.0;\n\t\t\tcommand.param6 = 0.0;\n\t\t\tcommand.param7 = 0.0;\n\t\t\tmavlink_msg_command_long_send(this->mavlink_fd, &command);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t}\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 45.68823785201022}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over all channels and find the one that has space\n\tfor (int i = 0; i < MAX_NUM_GCS_CHANNELS; i++) {\n\t\tif (gcs_channels[i].get_available_payload_space() >= sizeof(mavlink_position_target_global_int_t)) {\n\t\t\t// Send the request\n\t\t\tmavlink_msg_request_data_stream_send(gcs_channels[i].get_mavlink_channel(), sysid, compid, MAVLINK_DATA_STREAM_POSITION, 1, 1);\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.894342009849474}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over the available GCS channels\n\tfor (int i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\t// Check for available payload space\n\t\tif (gcs_channels[i].payload_space_available()) {\n\t\t\t// Send the request to start the data stream on the corresponding channel\n\t\t\tgcs_channels[i].request_datastream_position(sysid, compid);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 30.261726626534614}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over the available GCS channels and check for available payload space.\n\tfor (int i = 0; i < MAX_GCS_CHANNELS; i++) {\n\t\t// If space is available, send the request to start the data stream on the corresponding channel.\n\t\tif (gcs_channels[i].available_payload_space() >= sizeof(mavlink_position_target_t)) {\n\t\t\t// Send the request to start the data stream on the corresponding channel.\n\t\t\tmavlink_msg_request_data_stream_send(gcs_channels[i].get_channel(), sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.59044490910567}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = AHRS::getInstance();\n\tfloat cos_pitch = ahrs->get_pitch_cos();\n\n\tif (cos_pitch!= 0) {\n\t\tef_pitch = atan2f(ahrs->get_pitch_sin(), cos_pitch);\n\t\tef_yaw = ahrs->get_yaw();\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 38.427110441611866}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = AHRS::GetInstance();\n\tfloat cos_pitch = ahrs->GetPitch() / 180.0f;\n\tif (cos_pitch!= 0) {\n\t\tef_pitch = atan(cos_pitch * sin(pitch)) / M_PI * 180.0f;\n\t\tef_yaw = atan(cos_pitch * cos(yaw)) / M_PI * 180.0f;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 40.13153272202926}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = Tracker::get_ahrs();\n\tif (ahrs->get_pitch_cosine() == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = pitch - ahrs->get_pitch();\n\tef_yaw = yaw - ahrs->get_yaw();\n\treturn true;\n}", "CodeBleu_score": 43.91878587659249}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\tif (tracker.get_target_distance()!= 0 && tracker.get_target_distance() < MIN_TARGET_DISTANCE) {\n\t\ttracker.set_target_distance(MIN_TARGET_DISTANCE);\n\t}\n\n\tif (tracker.get_target_distance() == 0) {\n\t\ttracker.set_target_yaw(0);\n\t\ttracker.set_target_pitch(0);\n\t}\n\n\tif (tracker.get_target_distance() > 0) {\n\t\ttracker.set_target_yaw(tracker.get_target_yaw() + yaw_correction);\n\t\ttracker.set_target_pitch(tracker.get_target_pitch() + pitch_correction);\n\t}\n\n\ttracker.set_target_yaw(tracker.get_target_yaw() * 100);\n\ttracker.set_target_pitch(tracker.get_target_pitch() * 100);\n}", "CodeBleu_score": 20.134848472166816}, {"code": "void Mode::update_auto(void){\n\t\t// Calculate the yaw and pitch in centidegrees\n\tdouble yaw_deg = 0;\n\tdouble pitch_deg = 0;\n\tif (navigation.status == NAV_STATUS_TRACKING) {\n\t\tyaw_deg = navigation.yaw * 100;\n\t\tpitch_deg = navigation.pitch * 100;\n\t} else if (navigation.status == NAV_STATUS_WAYPOINT) {\n\t\tyaw_deg = navigation.yaw_to_waypoint * 100;\n\t\tpitch_deg = navigation.pitch_to_waypoint * 100;\n\t}\n\n\t// Check if the direction is reversed\n\tif (navigation.direction == NAV_DIRECTION_REVERSE) {\n\t\tyaw_deg = -yaw_deg;\n\t\tpitch_deg = -pitch_deg;\n\t}\n\n\t// Compute the angle error\n\tdouble yaw_error = yaw_deg - yaw_servo;\n\tdouble pitch_error = pitch_deg - pitch_servo;\n\n\t// Convert from earth frame to body frame\n\tyaw_error = -yaw_error;\n\tpitch_error = -pitch_error;\n\n\t// If the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n\tif (navigation.distance_to_waypoint >= navigation.min_distance || navigation.min_distance == 0) {\n\t\tyaw_servo += yaw_error;\n\t\tpitch_servo += pitch_error;\n\t}\n}", "CodeBleu_score": 36.10236760213884}, {"code": "void Mode::update_auto(void){\n\t\t// If the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly.\n\tif (target_distance_valid || min_distance == 0) {\n\t\t// Calculate the yaw and pitch in centidegrees.\n\t\tint16_t yaw_error = (int16_t) (target_yaw - yaw);\n\t\tint16_t pitch_error = (int16_t) (target_pitch - pitch);\n\n\t\t// Check if the direction is reversed.\n\t\tif (yaw_error > 1800) {\n\t\t\tyaw_error -= 3600;\n\t\t} else if (yaw_error < -1800) {\n\t\t\tyaw_error += 3600;\n\t\t}\n\n\t\t// Compute the angle error.\n\t\tint16_t angle_error = (int16_t) sqrt(yaw_error * yaw_error + pitch_error * pitch_error);\n\n\t\t// If the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly.\n\t\tif (angle_error < 1800) {\n\t\t\t// Convert the errors from earth frame to body frame.\n\t\t\tyaw_error = (int16_t) (yaw_error * cos(pitch * PI / 1800.0) - pitch_error * sin(pitch * PI / 1800.0));\n\t\t\tpitch_error = (int16_t) (pitch_error * cos(yaw * PI / 1800.0) + yaw_error * sin(yaw * PI / 1800.0));\n\n\t\t\t// If the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly.\n\t\t\tif (target_distance_valid || min_distance == 0) {\n\t\t\t\t// Update the pitch and yaw servos.\n\t\t\t\tpitch_servo.update_servo(pitch_error);\n\t\t\t\tyaw_servo.update_servo(yaw_error);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.390757313885224}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\t// Update GPS data\n\tGPS_update();\n\n\t// If the last message time has changed, check if the GPS status is at least 3D fix\n\tif (GPS.lastMsgTime!= lastMsgTime) {\n\t\tif (GPS.status == GPS_3D_FIX) {\n\t\t\t// If the GPS status is at least 3D fix, start the countdown\n\t\t\tcountdown = GPS_GROUND_START_COUNTDOWN;\n\t\t} else {\n\t\t\t// If the GPS status is not at least 3D fix, reset the countdown\n\t\t\tcountdown = 0;\n\t\t}\n\t}\n\n\t// If the countdown has reached one, set the home location if the current location is valid\n\tif (countdown == 1) {\n\t\t// If the current location is valid, set the home location\n\t\tif (GPS.status == GPS_3D_FIX) {\n\t\t\thome_location.lat = GPS.latitude;\n\t\t\thome_location.lon = GPS.longitude;\n\t\t\thome_location.alt = GPS.altitude;\n\t\t\thome_location.valid = true;\n\t\t\thome_location.time = GPS.lastMsgTime;\n\t\t}\n\n\t\t// Reset the countdown\n\t\tcountdown = 0;\n\t}\n}", "CodeBleu_score": 35.20163299029631}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update the GPS data\n\tgps_data = gps.read();\n\n\t// Check if the last message time has changed\n\tif (last_message_time!= gps_data.last_message_time) {\n\t\tlast_message_time = gps_data.last_message_time;\n\n\t\t// Check if the GPS status is at least 3D fix\n\t\tif (gps_data.fix_type >= 3) {\n\t\t\t// Check if the countdown has reached 1\n\t\t\tif (ground_start_countdown == 1) {\n\t\t\t\t// Check if the current location is valid\n\t\t\t\tif (gps_data.location.valid()) {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\thome_location = gps_data.location;\n\n\t\t\t\t\t// Reset the countdown\n\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Decrement the countdown\n\t\t\t\tground_start_countdown--;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.68791357964968}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update GPS data\n\tgps.read();\n\n\t// Check if the last message time has changed\n\tif (gps.lastNMEAMessageTime!= lastMessageTime) {\n\t\tlastMessageTime = gps.lastNMEAMessageTime;\n\n\t\t// Check if the GPS status is at least 3D fix\n\t\tif (gps.status == GPS_STATUS_FIX) {\n\t\t\t// If the GPS status is 3D fix, set the home location\n\t\t\tif (gps.homeLocationSet == false) {\n\t\t\t\t// Check if the location is valid\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\thomeLocation = gps.location;\n\t\t\t\t\tgps.homeLocationSet = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 22.563822767472242}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0) {\n\t\tif (pitch > 180) {\n\t\t\tpitch = 180;\n\t\t}\n\t\tif (pitch < 10) {\n\t\t\tpitch = 10;\n\t\t}\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = map(pitch, 10, 180, 1000, 2000);\n\t\tpitch = pitch - 1000;\n\t\tpitch = pitch / 1000;\n\t\tpitch = pitch * 100;\n\t\tpitch = pitch + 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch * 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch / 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch * 100;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch + 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch * 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch / 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch * 100;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch + 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch * 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch / 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch * 100;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch + 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch * 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch / 1000;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch * 100;\n\t\t//\t\tSerial.println(pitch);\n\t\tpitch = pitch + 1000;\n\t\t//\t\tSerial", "CodeBleu_score": 14.173759088029541}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0) {\n\t\tpitch_onoff_servo.set_position(pitch);\n\t}\n}", "CodeBleu_score": 11.871258373531905}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0f) {\n\t\tpitch_onoff_servo.set_position(180);\n\t}\n\telse {\n\t\tpitch_onoff_servo.set_position(0);\n\t}\n}", "CodeBleu_score": 13.294418470828806}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool result = true;\n\n\t// check barometer altitude\n\tif (AP_Arming::barometer_checks(display_failure)) {\n\t\t// check barometer altitude\n\t\tif (AP_Arming::check_barometer_alt()) {\n\t\t\tresult = false;\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 19.476461102252458}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\tif (g.arming_check_baro) {\n\t\t// check barometer altitude against inertial navigation altitude\n\t\t// if the difference is too big, then the barometer is probably not reliable\n\t\t// and we should not trust it\n\t\tif (fabsf(get_baro_altitude() - nav_alt) > 100) {\n\t\t\tif (display_failure) {\n\t\t\t\tlog_failed(PSTR(\"Barometer check failed, baro alt %f, nav alt %f\"), get_baro_altitude(), nav_alt);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 32.47606493094798}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (AP_Arming::get_arming_check_flags() & ARMING_CHECK_BARO) {\n\t\t// check barometer altitude against inertial navigation altitude\n\t\tfloat baro_altitude = AP_Baro::get_altitude_m();\n\t\tfloat inertial_altitude = AP_InertialNav::get_altitude_m();\n\t\tfloat alt_disparity = fabsf(baro_altitude - inertial_altitude);\n\t\tif (alt_disparity > AP_Arming::get_arming_check_baro_limit()) {\n\t\t\tif (display_failure) {\n\t\t\t\tAP_Notify::log_error(AP_Notify::BARO_ALTITUDE_DISPARITY_EXCEEDED);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 39.83270814964851}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\t// check if the terrain source is from a rangefinder\n\tif (_terrain_source == TerrainSource::RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\t// check if the terrain source is from the terrain database and the RTL altitude type is terrain\n\tif (_terrain_source == TerrainSource::TERRAIN_DATABASE && _rtl_altitude_type == RTLAltitudeType::TERRAIN) {\n\t\treturn true;\n\t}\n\n\t// defer to the base class implementation of terrain_database_required\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 53.3678586714843}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\treturn false;\n}", "CodeBleu_score": 8.614048038226855}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\treturn _terrain_source == TerrainSource::TerrainDatabase && _rtl_alt_type == RTLAltitudeType::Terrain;\n}", "CodeBleu_score": 6.641552831462885}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// Set the loop time for the attitude controller\n\tattitude_controller.set_loop_time(scheduler.get_last_loop_time());\n\t// Set the loop time for the position controller\n\tposition_controller.set_loop_time(scheduler.get_last_loop_time());\n\t// Set the loop time for the motor controller\n\tmotor_controller.set_loop_time(scheduler.get_last_loop_time());\n\t// Run the low-level rate controllers that require only IMU data\n\tattitude_controller.run();\n\tposition_controller.run();\n\tmotor_controller.run();\n}", "CodeBleu_score": 40.367841183908524}, {"code": "void Copter::run_rate_controller(){\n\t\t// set loop time\n\tloop_time = scheduler.get_loop_time();\n\n\t// run the low-level rate controllers\n\tattitude_control.run_rate_controller(loop_time);\n\n\t// run the position controller\n\tposition_control.run_rate_controller(loop_time);\n\n\t// run the motor controller\n\tmotor_control.run_rate_controller(loop_time);\n}", "CodeBleu_score": 53.36974129209329}, {"code": "void Copter::run_rate_controller(){\n\t\t// Update loop time\n\tloop_time = scheduler.get_loop_time();\n\n\t// Run rate controller\n\tattitude_controller.run_rate_controller();\n\tposition_controller.run_rate_controller();\n\tmotor_controller.run_rate_controller();\n}", "CodeBleu_score": 36.335957105315345}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t//Check if the target is the same as the new location\n\tif (old_loc.is_equal(new_loc)) {\n\t\t//Check if the altitudes are the same\n\t\tif (old_loc.get_altitude_frame() == new_loc.get_altitude_frame()) {\n\t\t\t//Set the new location as the target\n\t\t\ttarget_location = new_loc;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 46.07010047717562}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// Check if the new location is a waypoint\n\tif (new_loc.type!= Location::Waypoint)\n\t\treturn false;\n\n\t// Check if the old location is a waypoint\n\tif (old_loc.type!= Location::Waypoint)\n\t\treturn false;\n\n\t// Check if the old and new locations are the same\n\tif (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng)\n\t\treturn false;\n\n\t// Check if the old and new altitudes are the same\n\tif (old_loc.altitude!= new_loc.altitude)\n\t\treturn false;\n\n\t// Set the new location as the target\n\ttarget_location = new_loc;\n\n\treturn true;\n}", "CodeBleu_score": 41.58044040388093}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.get_latitude() == new_loc.get_latitude() && old_loc.get_longitude() == new_loc.get_longitude() && old_loc.get_altitude() == new_loc.get_altitude()) {\n\t\treturn false;\n\t}\n\telse {\n\t\ttarget_location = new_loc;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 46.67163346801192}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tset_mode(mode);\n\t} else if (ch_flag == AuxSwitchPos::LOW) {\n\t\tif (mode == _mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 43.175403976486635}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode!= current_mode) {\n\t\t\tif (set_mode(mode)) {\n\t\t\t\tcurrent_mode = mode;\n\t\t\t\trc().reset_mode_switch();\n\t\t\t}\n\t\t}\n\t} else if (mode == current_mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 52.470718741893805}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tset_mode(mode);\n\t} else if (ch_flag == AuxSwitchPos::LOW) {\n\t\tif (get_mode() == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 46.44969882988763}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// Save trim\n\tfloat trim_roll = (float)RC_Channel::get_channel_value(RC_CHANNEL_ROLL) / 1000.0f;\n\tfloat trim_pitch = (float)RC_Channel::get_channel_value(RC_CHANNEL_PITCH) / 1000.0f;\n\n\ttrim_roll = trim_roll * M_PI / 180.0f;\n\ttrim_pitch = trim_pitch * M_PI / 180.0f;\n\n\ttrim_roll = trim_roll + AHRS::get_roll_trim();\n\ttrim_pitch = trim_pitch + AHRS::get_pitch_trim();\n\n\tAHRS::set_roll_trim(trim_roll);\n\tAHRS::set_pitch_trim(trim_pitch);\n\n\t// Log event\n\tLog_Write_Event(LOG_EVENT_INFO, \"Trim saved\");\n\tLog_Write_Event(LOG_EVENT_INFO, \"Roll trim: %f\", trim_roll);\n\tLog_Write_Event(LOG_EVENT_INFO, \"Pitch trim: %f\", trim_pitch);\n\n\t// Send confirmation\n\tmavlink_log_message_t msg;\n\tmsg.severity = MAV_SEVERITY_INFO;\n\tmsg.id = 0;\n\tmsg.text = \"Trim saved\";\n\tmavlink_msg_log_message_send(MAVLINK_COMM_0, &msg);\n}", "CodeBleu_score": 40.38204917380889}, {"code": "void Copter::save_trim(){\n\t\tfloat roll_trim = 0, pitch_trim = 0;\n\n\t// calculate the trim values from the control inputs of the roll and pitch channels\n\troll_trim = (float)rc_channels_get_raw_value(ROLL) / 1000.0f;\n\tpitch_trim = (float)rc_channels_get_raw_value(PITCH) / 1000.0f;\n\n\t// convert the trim values to radians\n\troll_trim = roll_trim * M_PI / 180.0f;\n\tpitch_trim = pitch_trim * M_PI / 180.0f;\n\n\t// add the trim values to the AHRS trim\n\tahrs.set_roll_trim(ahrs.get_roll_trim() + roll_trim);\n\tahrs.set_pitch_trim(ahrs.get_pitch_trim() + pitch_trim);\n\n\t// log the event\n\trc_log_write_event(RC_EVENT_TRIM_SAVED);\n\n\t// send a confirmation message\n\trc_mav_log_info(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 50.3680449106763}, {"code": "void Copter::save_trim(){\n\t\t// Calculate trim values from roll and pitch channels\n\tfloat roll_trim_rad = (float)RC_Channels.ch[RC_CHANNEL_ROLL].value / 1000.0f * M_PI;\n\tfloat pitch_trim_rad = (float)RC_Channels.ch[RC_CHANNEL_PITCH].value / 1000.0f * M_PI;\n\n\t// Add trim values to AHRS trim\n\tAHRS.roll_trim += roll_trim_rad;\n\tAHRS.pitch_trim += pitch_trim_rad;\n\n\t// Log event\n\tLog_Event(LOG_EVENT_INFO, \"Trim saved\");\n\n\t// Send confirmation message\n\tmavlink_log_info(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 45.19395852997532}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tif (copter.is_position_valid()) {\n\t\tfloat speed = copter.velocity().norm();\n\t\tif (speed > 0.01) {\n\t\t\tfloat yaw_rate = copter.velocity().yaw() / speed;\n\t\t\tfloat yaw_rate_squared = yaw_rate * yaw_rate;\n\t\t\tfloat look_ahead_yaw = copter.yaw() + yaw_rate_squared;\n\t\t\treturn look_ahead_yaw;\n\t\t}\n\t}\n\treturn copter.yaw();\n}", "CodeBleu_score": 44.84326772553976}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat look_ahead_yaw = 0.0;\n\tfloat speed_squared = 0.0;\n\n\tif (copter.position_valid()) {\n\t\tspeed_squared = copter.velocity.x() * copter.velocity.x() + copter.velocity.y() * copter.velocity.y();\n\t\tif (speed_squared > 0.0001) {\n\t\t\tlook_ahead_yaw = atan2f(copter.velocity.y(), copter.velocity.x());\n\t\t}\n\t}\n\n\treturn look_ahead_yaw;\n}", "CodeBleu_score": 38.07640926900876}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Get the copter's velocity\n\tfloat vx = _copter.vx();\n\tfloat vy = _copter.vy();\n\tfloat vz = _copter.vz();\n\tfloat speed = sqrt(vx*vx + vy*vy + vz*vz);\n\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (_copter.valid_position() && speed > MIN_SPEED) {\n\t\t// Calculate the look-ahead yaw angle using the arctangent of the velocity components\n\t\tfloat look_ahead_yaw = atan2(vy, vx);\n\n\t\t// If the look-ahead yaw angle is not within the allowed yaw range, adjust it to be within the range\n\t\tif (look_ahead_yaw < _yaw_min) {\n\t\t\tlook_ahead_yaw = _yaw_min;\n\t\t}\n\t\telse if (look_ahead_yaw > _yaw_max) {\n\t\t\tlook_ahead_yaw = _yaw_max;\n\t\t}\n\n\t\t// Update the look-ahead yaw angle\n\t\t_look_ahead_yaw = look_ahead_yaw;\n\t}\n\n\t// Return the computed look-ahead yaw angle\n\treturn _look_ahead_yaw;\n}", "CodeBleu_score": 45.395068938324854}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// If we are using the RUDDER method, check that rudder arming is not disabled, and that the throttle is not zero\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (rc_channel_throttle_disabled) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// If arming checks are disabled or the watchdog was armed, return true\n\tif (AP_Arming::armed_by_watchdog ||!AP_Arming::armed_checks_enabled) {\n\t\treturn true;\n\t}\n\n\t// Otherwise, call the parent class's arm_checks method\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 34.424346449596364}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (rudder_arming_disabled || throttle_zero) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 28.62701748640105}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tswitch (method) {\n\tcase AP_Arming::RUDDER:\n\t\tif (rc_channel_throttle->is_armed() || rc_channel_rudder->is_armed()) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase AP_Arming::THROTTLE:\n\t\tif (rc_channel_throttle->is_armed()) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase AP_Arming::THROTTLE_RUDDER:\n\t\tif (rc_channel_throttle->is_armed() || rc_channel_rudder->is_armed()) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase AP_Arming::THROTTLE_RUDDER_ALT:\n\t\tif (rc_channel_throttle->is_armed() || rc_channel_rudder->is_armed() || rc_channel_alt->is_armed()) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase AP_Arming::THROTTLE_RUDDER_ALT_YAW:\n\t\tif (rc_channel_throttle->is_armed() || rc_channel_rudder->is_armed() || rc_channel_alt->is_armed() || rc_channel_yaw->is_armed()) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 44.90570849262218}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// we're armed, so set the home location\n\tif (home_set) {\n\t\thome_set = false;\n\t\thome_location.set_to_current_location();\n\t}\n\n\t// if we're already armed, don't arm again\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// if we're not armed, arm\n\tif (do_arming_checks) {\n\t\tif (!check_arming()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// arm the plane\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\t// stabilize\n\t\tif (!arm_stabilize()) {\n\t\t\treturn false;\n\t\t}\n\t} else if (method == AP_Arming::METHOD_AUTO) {\n\t\t// auto\n\t\tif (!arm_auto()) {\n\t\t\treturn false;\n\t\t}\n\t} else if (method == AP_Arming::METHOD_ALT_HOLD) {\n\t\t// alt hold\n\t\tif (!arm_alt_hold()) {\n\t\t\treturn false;\n\t\t}\n\t} else if (method == AP_Arming::METHOD_MANUAL) {\n\t\t// manual\n\t\tif (!arm_manual()) {\n\t\t\treturn false;\n\t\t}\n\t} else if (method == AP_Arming::METHOD_GPS_HOME) {\n\t\t// gps home\n\t\tif (!arm_gps_home()) {\n\t\t\treturn false;\n\t\t}\n\t} else if (method == AP_Arming::METHOD_GPS_HOLD) {\n\t\t// gps hold\n\t\tif (!arm_gps_hold()) {\n\t\t\treturn false;\n\t\t}\n\t} else if (method == AP_Arming::METHOD_GPS_LOITER) {\n\t\t// gps loiter\n\t\tif (!arm_gps_loiter()) {\n\t\t\treturn false;\n\t\t}\n\t} else if (method == AP_Arming::METHOD_GPS_TAKEOFF) {\n\t\t// gps takeoff\n\t\tif (!arm_gps_takeoff()) {\n\t\t\treturn false;\n\t\t}\n\t} else if (method == AP_Arming::METHOD_GPS_LAND) {\n\t\t// gps land\n\t\tif (!arm_gps_", "CodeBleu_score": 36.01477332041524}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// check if we are already armed\n\tif (state == ARMED) {\n\t\treturn true;\n\t}\n\n\t// check if we are arming or disarming\n\tif (method == AP_Arming::DISARM) {\n\t\t// disarm\n\t\tstate = DISARMED;\n\t\treturn true;\n\t}\n\n\t// check if we are arming\n\tif (method == AP_Arming::ARM) {\n\t\t// arm\n\t\tstate = ARMED;\n\t\treturn true;\n\t}\n\n\t// check if we are arming with a custom check\n\tif (method == AP_Arming::ARM_CUSTOM) {\n\t\t// arm\n\t\tif (do_arming_checks) {\n\t\t\tstate = ARMED;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 41.71554050572186}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// check if we are already armed\n\tif (isArmed()) {\n\t\treturn true;\n\t}\n\n\t// check if we are in manual mode\n\tif (getArmingState() == AP_Arming::MANUAL) {\n\t\treturn false;\n\t}\n\n\t// check if we are in disarmed mode\n\tif (getArmingState() == AP_Arming::DISARMED) {\n\t\treturn false;\n\t}\n\n\t// check if we are in prearm mode\n\tif (getArmingState() == AP_Arming::PREARM) {\n\t\treturn false;\n\t}\n\n\t// check if we are in transition mode\n\tif (getArmingState() == AP_Arming::TRANSITION) {\n\t\treturn false;\n\t}\n\n\t// check if we are in transition mode\n\tif (getArmingState() == AP_Arming::TRANSITION_TO_STABILIZED) {\n\t\treturn false;\n\t}\n\n\t// check if we are in transition mode\n\tif (getArmingState() == AP_Arming::TRANSITION_TO_ARMED) {\n\t\treturn false;\n\t}\n\n\t// check if we are in transition mode\n\tif (getArmingState() == AP_Arming::TRANSITION_TO_PREARMED) {\n\t\treturn false;\n\t}\n\n\t// check if we are in transition mode\n\tif (getArmingState() == AP_Arming::TRANSITION_TO_DISARMED) {\n\t\treturn false;\n\t}\n\n\t// check if we are in transition mode\n\tif (getArmingState() == AP_Arming::TRANSITION_TO_MANUAL) {\n\t\treturn false;\n\t}\n\n\t// check if we are in transition mode\n\tif (getArmingState() == AP_Arming::TRANSITION_TO_ERROR) {\n\t\treturn false;\n\t}\n\n\t// check if we are in transition mode\n\tif (getArmingState() == AP_Arming::TRANSITION_TO_UNINITIALIZED) {\n\t\treturn false;\n\t}\n\n\t// check if we are in transition mode\n\tif (getArmingState() == AP_Arming::TRANSITION_TO_STANDBY) {\n\t", "CodeBleu_score": 21.989961874506097}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (vehicle->armed()) {\n\t\treturn true;\n\t}\n\n\t// check if we have a disarm button configured\n\tif (disarm_button.is_configured()) {\n\t\t// if we have a disarm button configured, we need to check it first\n\t\tif (disarm_button.is_pressed()) {\n\t\t\t// if the disarm button is pressed, we should not arm\n\t\t\tif (display_failure) {\n\t\t\t\tvehicle->send_text_message(MAV_SEVERITY_INFO, \"Disarming not allowed\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// check the standard pre-arm checks\n\tif (!AP_Arming::pre_arm_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 56.08876591048432}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// Check if we are already armed\n\tif (armed) {\n\t\treturn true;\n\t}\n\n\t// Check if we have a disarm button configured\n\tif (disarm_button!= -1) {\n\t\t// Check if we are disarmed\n\t\tif (!disarmed) {\n\t\t\t// Check if the disarm button is pressed\n\t\t\tif (digitalRead(disarm_button) == LOW) {\n\t\t\t\t// Display a failure message\n\t\t\t\tif (display_failure) {\n\t\t\t\t\t// Display a failure message\n\t\t\t\t\tdisplay_failure_message();\n\t\t\t\t}\n\t\t\t\t// Return false\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Call the standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 63.778860352868726}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (Armed) {\n\t\treturn true;\n\t}\n\n\tif (disarm_button) {\n\t\tif (disarm_button->is_pressed()) {\n\t\t\tif (display_failure) {\n\t\t\t\t_failure_message = \"Disarm button is configured\";\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 61.4432347594585}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat yaw = ahrs->get_yaw();\n\tfloat ne_x = x * cos(yaw) + y * sin(yaw);\n\tfloat ne_y = -x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 61.787882825481155}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat yaw_angle = get_yaw_angle();\n\tfloat cos_yaw = cos(yaw_angle);\n\tfloat sin_yaw = sin(yaw_angle);\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 54.96010604872643}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x, ne_y;\n\tne_x = x * cos(yaw) - y * sin(yaw);\n\tne_y = x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 51.55970236520763}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT result = MAV_RESULT_ACCEPTED;\n\n\t// Check the yaw angle is within the range of -180 to 180\n\tif ((packet.param1 < -180.0f) || (packet.param1 > 180.0f)) {\n\t\tresult = MAV_RESULT_DENIED;\n\t}\n\n\t// Check the yaw speed is within the range of 0 to 1000\n\tif ((packet.param4 < 0.0f) || (packet.param4 > 1000.0f)) {\n\t\tresult = MAV_RESULT_DENIED;\n\t}\n\n\t// Check the yaw direction is within the range of 0 to 1\n\tif ((packet.param5 < 0.0f) || (packet.param5 > 1.0f)) {\n\t\tresult = MAV_RESULT_DENIED;\n\t}\n\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t// Set the yaw heading\n\t\t_yaw_heading = packet.param1;\n\t\t_yaw_speed = packet.param4;\n\t\t_yaw_direction = packet.param5;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 49.345155855787816}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if the yaw angle and param4 values are within acceptable ranges\n\tif (packet.param1 >= -180.0f && packet.param1 <= 180.0f && packet.param4 >= -180.0f && packet.param4 <= 180.0f) {\n\t\t// Set the yaw heading using the provided parameters\n\t\t_yaw_heading = packet.param1;\n\t\t_yaw_direction = packet.param4;\n\n\t\t// Return MAV_RESULT_ACCEPTED\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\n\t// Return MAV_RESULT_DENIED\n\treturn MAV_RESULT_DENIED;\n}", "CodeBleu_score": 46.95406141811902}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 < 0.0f || packet.param1 > 180.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param4 < -180.0f || packet.param4 > 180.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// set the yaw heading\n\t_yaw_heading = packet.param1;\n\n\t// set the yaw threshold\n\t_yaw_threshold = packet.param4;\n\n\t// set the yaw direction\n\t_yaw_direction = packet.param5;\n\n\t// set the yaw mode\n\t_yaw_mode = packet.param6;\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 51.046642511759956}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn (uint8_t) (this->high_latency_tgt_heading_ / 2);\n}", "CodeBleu_score": 6.725499169289711}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn (uint8_t) (0);\n}", "CodeBleu_score": 6.058245077177002}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.150400996515202}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (LoggingEnabled) {\n\t\tLogPacket packet = {\n\t\t\t.time = GetTime(),\n\t\t\t.dataID = id,\n\t\t\t.value = value\n\t\t};\n\t\tLog_Write_Packet(packet);\n\t}\n}", "CodeBleu_score": 30.03663078706812}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (logging) {\n\t\tLogger_Packet packet;\n\t\tpacket.time = time(NULL);\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tLogger_Write_Critical_Block(packet);\n\t}\n}", "CodeBleu_score": 36.599986610570575}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (this->Log_Enabled) {\n\t\tLog_Write_Data_Critical(id, value);\n\t}\n}", "CodeBleu_score": 17.920322783568903}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\t// Check if the home is already set\n\tif (home_set) {\n\t\treturn;\n\t}\n\n\t// Check if the motors are armed\n\tif (armed) {\n\t\t// Set home to the current location in-flight\n\t\thome_set = true;\n\t\thome_location.set(current_location);\n\t} else {\n\t\t// Attempt to set home to the current EKF location\n\t\thome_set = EKF.set_home();\n\t}\n}", "CodeBleu_score": 24.284779681820616}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_set) {\n\t\treturn;\n\t}\n\tif (armed) {\n\t\thome_set = true;\n\t\thome_x = x;\n\t\thome_y = y;\n\t\thome_z = z;\n\t\treturn;\n\t}\n\tif (ekf_update_home()) {\n\t\thome_set = true;\n\t\thome_x = x;\n\t\thome_y = y;\n\t\thome_z = z;\n\t}\n}", "CodeBleu_score": 18.5114809591805}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_set) {\n\t\treturn;\n\t}\n\n\tif (armed) {\n\t\thome_location.lat = EKF_location.lat;\n\t\thome_location.lng = EKF_location.lng;\n\t\thome_set = true;\n\t\treturn;\n\t}\n\n\tif (EKF_location.lat == 0.0 && EKF_location.lng == 0.0) {\n\t\treturn;\n\t}\n\n\thome_location.lat = EKF_location.lat;\n\thome_location.lng = EKF_location.lng;\n\thome_set = true;\n}", "CodeBleu_score": 15.473261778855019}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\t// TODO: Implement this function\n\tif (!motorsArmed) {\n\t\tsetThrottle(0);\n\t\tspoolState = SPOOL_UNLIMITED_THROTTLE;\n\t\trelaxAttitude();\n\t\texit();\n\t} else {\n\t\tspoolState = SPOOL_UNLIMITED_THROTTLE;\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO: Implement this function\n\t\t// TODO:", "CodeBleu_score": 9.801546199622834}, {"code": "void ModeAcro::run(){\n\t\tif (!armed) {\n\t\tthrottle = 0;\n\t\tspoolState = SpoolState::UNLIMITED_THROTTLE;\n\t\trelaxAttitudeControllers();\n\t\treturn;\n\t}\n\n\tspoolState = SpoolState::UNLIMITED_THROTTLE;\n\tconvertPilotToBodyRates();\n\tattitudeController.run(bodyRates);\n\tthrottle = pilotThrottle;\n\tif (pilotThrottle == 0) {\n\t\tspoolState = SpoolState::UNLIMITED_THROTTLE;\n\t\trelaxAttitudeControllers();\n\t\treturn;\n\t}\n\tspoolState = SpoolState::THROTTLE_LIMITED;\n\tbodyRates.throttle = pilotThrottle;\n\tbodyRates.roll = pilotRoll;\n\tbodyRates.pitch = pilotPitch;\n\tbodyRates.yaw = pilotYaw;\n\tattitudeController.run(bodyRates);\n\tthrottle = pilotThrottle;\n\tmotor1 = bodyRates.throttle + bodyRates.pitch + bodyRates.yaw;\n\tmotor2 = bodyRates.throttle - bodyRates.pitch - bodyRates.yaw;\n\tmotor3 = bodyRates.throttle + bodyRates.pitch - bodyRates.yaw;\n\tmotor4 = bodyRates.throttle - bodyRates.pitch + bodyRates.yaw;\n}", "CodeBleu_score": 38.815180821254145}, {"code": "void ModeAcro::run(){\n\t\tif (!armed) {\n\t\tthrottle = 0;\n\t\tspoolState = SpoolState::unlimitedThrottle;\n\t\trelaxAttitudeControllers();\n\t\treturn;\n\t}\n\tspoolState = SpoolState::unlimitedThrottle;\n\tconst double pilotRollRate = pilotRoll * pilotRollRateScale;\n\tconst double pilotPitchRate = pilotPitch * pilotPitchRateScale;\n\tconst double pilotYawRate = pilotYaw * pilotYawRateScale;\n\tattitudeController->run(pilotRollRate, pilotPitchRate, pilotYawRate);\n\tthrottle = pilotThrottle;\n\tmotor1 = throttle + pilotThrottleBoost;\n\tmotor2 = throttle - pilotThrottleBoost;\n}", "CodeBleu_score": 33.12248688989527}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set the mode to position control\n\tmavlink_msg_set_mode_send(\n\t\t_mavlink_channel,\n\t\t_system_id,\n\t\tMAV_MODE_FLAG_CUSTOM_MODE_ENABLED | MAV_MODE_FLAG_SAFETY_ARMED,\n\t\tMAV_AUTO_MODE_RTL\n\t);\n\t// Set the waypoint destination\n\t_wp_ctrl.set_destination(_wp_stop);\n\t// Set the yaw to auto\n\t_wp_ctrl.set_yaw_mode(WP_YAW_MODE_AUTO);\n}", "CodeBleu_score": 19.725042101846565}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set to position control mode\n\tmavros_msgs::SetMode mode_msg;\n\tmode_msg.request.custom_mode = \"AUTO.POSCTL\";\n\tif (set_mode_client.call(mode_msg) && mode_msg.response.mode_sent) {\n\t\tROS_INFO(\"Set Mode: POSCTL\");\n\t} else {\n\t\tROS_ERROR(\"Failed Set Mode: POSCTL\");\n\t}\n\n\t// initialize waypoint controller\n\tROS_INFO(\"Initializing Waypoint Controller\");\n\twaypoint_controller.initialize();\n\tROS_INFO(\"Waypoint Controller Initialized\");\n\n\t// set the stopping point\n\twaypoint_controller.set_stopping_point(stopping_point);\n\n\t// set the yaw mode\n\tif (auto_yaw) {\n\t\tROS_INFO(\"Using Auto Yaw\");\n\t\twaypoint_controller.set_yaw_mode(WaypointController::YAW_MODE_AUTO);\n\t} else {\n\t\tROS_INFO(\"Using Fixed Yaw\");\n\t\twaypoint_controller.set_yaw_mode(WaypointController::YAW_MODE_FIXED);\n\t}\n}", "CodeBleu_score": 39.89149830661365}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set mode to position control mode\n\tmavros_msgs::SetMode set_mode;\n\tset_mode.request.custom_mode = \"GUIDED\";\n\tmavros_msgs::State current_state;\n\tros::Rate rate(20.0);\n\twhile (ros::ok() && current_state.mode!= \"GUIDED\") {\n\t\tmavros_msgs::State current_state;\n\t\tcurrent_state = state_sub.get_state();\n\t\tros::spinOnce();\n\t\trate.sleep();\n\t}\n\tif (set_mode_client.call(set_mode)) {\n\t\tROS_INFO(\"set mode: %s\", set_mode.response.mode.c_str());\n\t} else {\n\t\tROS_ERROR(\"Failed to set mode\");\n\t}\n\t// Set waypoint destination\n\tmavros_msgs::CommandBool arm_cmd;\n\tarm_cmd.request.value = true;\n\tros::Rate rate2(20.0);\n\twhile (ros::ok() &&!current_state.armed) {\n\t\tcurrent_state = state_sub.get_state();\n\t\tros::spinOnce();\n\t\trate2.sleep();\n\t}\n\tif (arm_client.call(arm_cmd)) {\n\t\tROS_INFO(\"vehicle armed: %s\", arm_cmd.response.success? \"YES\" : \"NO\");\n\t} else {\n\t\tROS_ERROR(\"Failed to arm\");\n\t}\n\t// Initialize waypoint controller\n\twaypoint_controller.initialize();\n\t// Set default yaw mode\n\tyaw_mode_pub.publish(mavros_msgs::YawMode(0, 0, 0, 0));\n}", "CodeBleu_score": 37.84491619737516}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialize vertical maximum speeds and acceleration\n\tvertical_max_speed = pilot_vertical_max_speed;\n\tvertical_max_accel = pilot_vertical_max_accel;\n\n\t// initialize vertical and horizontal velocity controllers\n\tvertical_vel_controller.initialize(pilot_vertical_vel_p, pilot_vertical_vel_i, pilot_vertical_vel_d, pilot_vertical_vel_i_max, pilot_vertical_vel_i_min, pilot_vertical_vel_i_decay);\n\thorizontal_vel_controller.initialize(pilot_horizontal_vel_p, pilot_horizontal_vel_i, pilot_horizontal_vel_d, pilot_horizontal_vel_i_max, pilot_horizontal_vel_i_min, pilot_horizontal_vel_i_decay);\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\tyaw_control_mode = AUTO_YAW_HOLD;\n}", "CodeBleu_score": 16.087123098581408}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Initialize maximum vertical speeds and acceleration\n\t// This is the maximum speed the plane can reach in the vertical direction.\n\t// It is defined by the pilot and is set in the pilot-defined parameters.\n\t// This is the maximum acceleration the plane can reach in the vertical direction.\n\t// It is defined by the pilot and is set in the pilot-defined parameters.\n\t// The vertical velocity controller will limit the vertical velocity to this maximum value.\n\t// The vertical acceleration controller will limit the vertical acceleration to this maximum value.\n\t// The vertical velocity controller will also limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will also limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.\n\t// The vertical acceleration controller will limit the vertical velocity to this maximum value.\n\t// The vertical velocity controller will limit the vertical acceleration to this maximum value.", "CodeBleu_score": 2.1987473564178663}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set guided mode to velocity controller\n\tset_guided_mode(GUIDED_MODE_VELOCITY_CONTROL);\n\n\t// Initialize vertical maximum speeds and acceleration\n\tset_vertical_max_speed(VERTICAL_MAX_SPEED_HIGH);\n\tset_vertical_acceleration(VERTICAL_ACCELERATION_HIGH);\n\n\t// Initialize vertical and horizontal velocity controllers\n\tvertical_vel_controller_init();\n\thorizontal_vel_controller_init();\n\n\t// Set yaw control mode to AUTO_YAW_HOLD\n\tset_yaw_control_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 13.130735170942387}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// TODO: Implement this function.\n\t// TODO: Return true if the guided mode should be terminated.\n\t// TODO: Return false if the guided mode should continue.\n\tif (time_since_last_guided_command_ > 2000) {\n\t\treturn true;\n\t}\n\tif (current_altitude_ < 10) {\n\t\treturn true;\n\t}\n\tif (current_altitude_ > 1000) {\n\t\treturn true;\n\t}\n\tif (horizontal_distance_moved_ > 100) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 15.226381684990242}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t//check if timeout has been exceeded\n\tif (timer.check_timeout() == true) {\n\t\treturn true;\n\t}\n\n\t//check if altitude is above maximum\n\tif (current_altitude > altitude_max) {\n\t\treturn true;\n\t}\n\n\t//check if altitude is below minimum\n\tif (current_altitude < altitude_min) {\n\t\treturn true;\n\t}\n\n\t//check if horizontal distance moved exceeds limit\n\tif (distance_moved > distance_limit) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 21.643887147406954}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if the time has exceeded the maximum time limit\n\tif (time_since_start() > _time_limit) {\n\t\treturn true;\n\t}\n\n\t// Check if the altitude is below the minimum altitude limit\n\tif (get_altitude() < _alt_min) {\n\t\treturn true;\n\t}\n\n\t// Check if the altitude is above the maximum altitude limit\n\tif (get_altitude() > _alt_max) {\n\t\treturn true;\n\t}\n\n\t// Check if the horizontal distance moved exceeds the maximum horizontal distance limit\n\tif (get_horizontal_distance() > _horiz_dist_max) {\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false\n\treturn false;\n}", "CodeBleu_score": 16.92059842363527}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tbool pass = true;\n\tif (motor_test_timeout_flag) {\n\t\tif (motor_test_timeout_counter < 100) {\n\t\t\tmotor_test_timeout_counter++;\n\t\t}\n\t\telse {\n\t\t\t//timeout\n\t\t\tROS_WARN(\"Motor test timeout\");\n\t\t\tmotor_test_timeout_flag = false;\n\t\t\tpass = false;\n\t\t\tmotor_test_timeout_counter = 0;\n\t\t\tdisable_motor_test();\n\t\t\tdisarm();\n\t\t\trecord_failure_time(motor_test_failure_time);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\tmotor_test_timeout_counter = 0;\n\t}\n\treturn pass;\n}", "CodeBleu_score": 49.69044153134406}, {"code": "bool Sub::verify_motor_test(){\n\t\tif (motor_test_time_out_flag) {\n\t\tif (motor_test_time_out_counter == 0) {\n\t\t\t// send timeout message\n\t\t\tmotor_test_time_out_flag = false;\n\t\t\tmotor_test_time_out_counter = 10;\n\t\t\treturn false;\n\t\t} else {\n\t\t\tmotor_test_time_out_counter--;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tif (motor_test_time_out_counter == 0) {\n\t\t\t// send timeout message\n\t\t\tmotor_test_time_out_flag = true;\n\t\t\tmotor_test_time_out_counter = 10;\n\t\t\treturn false;\n\t\t} else {\n\t\t\tmotor_test_time_out_counter--;\n\t\t\treturn true;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.45933199213143}, {"code": "bool Sub::verify_motor_test(){\n\t\tif(motor_test_requests == 0) {\n\t\tif(motor_test_timeout_counter == 0) {\n\t\t\tmotor_test_timeout_counter = 20;\n\t\t\tsend_message(SUB_MOTOR_TEST_TIMEOUT, 0, 0);\n\t\t}\n\t\tmotor_test_timeout_counter--;\n\t\treturn false;\n\t}\n\telse {\n\t\tmotor_test_timeout_counter = 20;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 27.453836332330905}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Get roll and pitch targets from wp_nav\n\tfloat roll_target = wp_nav.get_roll_target();\n\tfloat pitch_target = wp_nav.get_pitch_target();\n\n\t// Constrain roll and pitch targets\n\tfloat roll_target_norm = constrain(roll_target, -max_roll_target, max_roll_target);\n\tfloat pitch_target_norm = constrain(pitch_target, -max_pitch_target, max_pitch_target);\n\n\t// Normalize roll and pitch targets\n\tfloat roll_target_norm_norm = roll_target_norm / max_roll_target;\n\tfloat pitch_target_norm_norm = pitch_target_norm / max_pitch_target;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target_norm_norm;\n\tforward_out = pitch_target_norm_norm;\n}", "CodeBleu_score": 34.004139549047395}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Constrain the roll and pitch targets to a maximum angle range\n\tfloat roll_target = wp_nav.roll_target;\n\tfloat pitch_target = wp_nav.pitch_target;\n\tif (roll_target > max_roll) {\n\t\troll_target = max_roll;\n\t} else if (roll_target < -max_roll) {\n\t\troll_target = -max_roll;\n\t}\n\tif (pitch_target > max_pitch) {\n\t\tpitch_target = max_pitch;\n\t} else if (pitch_target < -max_pitch) {\n\t\tpitch_target = -max_pitch;\n\t}\n\n\t// Normalize the roll and pitch targets to the range [-1, 1]\n\tfloat roll_norm = roll_target / max_roll;\n\tfloat pitch_norm = pitch_target / max_pitch;\n\n\t// Assign the normalized values to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 37.274189298263884}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.roll_target;\n\tfloat pitch_target = wp_nav.pitch_target;\n\tfloat roll_norm = 0.0;\n\tfloat pitch_norm = 0.0;\n\n\t// Constrain roll and pitch targets\n\tif (roll_target < -roll_max) {\n\t\troll_target = -roll_max;\n\t} else if (roll_target > roll_max) {\n\t\troll_target = roll_max;\n\t}\n\tif (pitch_target < -pitch_max) {\n\t\tpitch_target = -pitch_max;\n\t} else if (pitch_target > pitch_max) {\n\t\tpitch_target = pitch_max;\n\t}\n\n\t// Normalize roll and pitch targets\n\tif (roll_target > 0) {\n\t\troll_norm = roll_target / roll_max;\n\t} else {\n\t\troll_norm = -roll_target / roll_max;\n\t}\n\tif (pitch_target > 0) {\n\t\tpitch_norm = pitch_target / pitch_max;\n\t} else {\n\t\tpitch_norm = -pitch_target / pitch_max;\n\t}\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 35.114806970382126}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// read barometer\n\tbarometer.read();\n\t// update barometer calibration\n\tif (barometer.altitude() > 0) {\n\t\tbarometer_calibrated = true;\n\t}\n\t// update sensor health\n\tif (depth_sensor.healthy()) {\n\t\tsensor_health = true;\n\t} else {\n\t\tsensor_health = false;\n\t}\n}", "CodeBleu_score": 42.29566739864347}, {"code": "void Sub::read_barometer(){\n\t\t// Update the barometer's data\n\tbarometer.update();\n\t// If the altitude is above zero, update the barometer calibration\n\tif (barometer.altitude > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\t// If a depth sensor is present, update the sensor health status\n\tif (depth_sensor.is_present()) {\n\t\tdepth_sensor.update_health();\n\t}\n}", "CodeBleu_score": 55.63149212913912}, {"code": "void Sub::read_barometer(){\n\t\t// If the barometer is not present, do nothing\n\tif (!barometer_present) {\n\t\treturn;\n\t}\n\n\t// Read the barometer\n\tbarometer.read();\n\n\t// If the altitude is above zero, update the calibration\n\tif (barometer.altitude > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\n\t// If a depth sensor is present, update the sensor health status\n\tif (depth_present) {\n\t\tif (barometer.altitude > 0) {\n\t\t\tdepth_health = 1;\n\t\t} else {\n\t\t\tdepth_health = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 61.65351192761138}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\treturn false;\n}", "CodeBleu_score": 5.492678133447096}, {"code": "bool Sub::ekf_position_ok(){\n\t\treturn (AP_InertialNav::instance()!= NULL && AP_InertialNav::instance()->is_absolute_position_valid() && AP_InertialNav::instance()->is_ekf_position_valid());\n}", "CodeBleu_score": 21.524420967537843}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// TODO Auto-generated destructor stub\n\treturn false;\n}", "CodeBleu_score": 5.492677746086194}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// check for EKF failsafe\n\tif (ekf_failsafe_active()) {\n\t\tif (display_failure) {\n\t\t\tDEBUG_PRINTLN(F(\"EKF failsafe active\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check for AHRS system\n\tif (!ahrs_ready()) {\n\t\tif (display_failure) {\n\t\t\tDEBUG_PRINTLN(F(\"AHRS not ready\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check for position validity\n\tif (!position_valid()) {\n\t\tif (display_failure) {\n\t\t\tDEBUG_PRINTLN(F(\"Position not valid\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 25.96482876505888}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// check if the AHRS system is ready\n\tif (!AP_Arming_Base::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if the EKF failsafe is active\n\tif (AP_Arming_Base::ekf_failsafe_active()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::panic(\"EKF Failsafe active\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if the position estimate is valid\n\tif (AP_Arming_Base::position_valid()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::panic(\"Position estimate invalid\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 29.073682217403977}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (AP_Arming::gps_checks(display_failure)) {\n\t\t// if we are not in position control, we are good to go\n\t\tif (control_mode!= AP_Arming::POSCTL) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check that the EKF is not in failsafe\n\t\tif (ekf_status == EKF_FAILSAFE) {\n\t\t\tif (display_failure) {\n\t\t\t\tAP_HAL::console->println_P(PSTR(\"EKF is in failsafe\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// check that the AHRS system is ready\n\t\tif (ahrs_status!= AHRS_OK) {\n\t\t\tif (display_failure) {\n\t\t\t\tAP_HAL::console->println_P(PSTR(\"AHRS not ready\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// check that the EKF is ready\n\t\tif (ekf_status!= EKF_OK) {\n\t\t\tif (display_failure) {\n\t\t\t\tAP_HAL::console->println_P(PSTR(\"EKF not ready\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// check that the EKF position estimate is valid\n\t\tif (ekf_status!= EKF_VALID) {\n\t\t\tif (display_failure) {\n\t\t\t\tAP_HAL::console->println_P(PSTR(\"EKF position estimate is invalid\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 43.00034977832195}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// if we are already armed, return true\n\tif (_armed) {\n\t\treturn true;\n\t}\n\n\t// if we are not armed and we are not in the process of arming, return false\n\tif (!_armed &&!_arming) {\n\t\treturn false;\n\t}\n\n\t// if we are in the process of arming, set the method\n\tif (_arming) {\n\t\t_arming_method = method;\n\t}\n\n\t// if we are not armed and we are not in the process of arming, start the arming process\n\tif (!_armed &&!_arming) {\n\t\t_arming = true;\n\t\t_arming_method = method;\n\t\t_arming_start_time = AP_HAL::millis();\n\t}\n\n\t// if we are not armed and we are in the process of arming, check if we have armed\n\tif (!_armed && _arming) {\n\t\tswitch (_arming_method) {\n\t\tcase AP_Arming::METHOD_NONE:\n\t\t\t// no arming method, so we are armed\n\t\t\t_armed = true;\n\t\t\t_arming = false;\n\t\t\t_arming_start_time = 0;\n\t\t\treturn true;\n\t\t\tbreak;\n\n\t\tcase AP_Arming::METHOD_PWM:\n\t\t\t// check if we have armed\n\t\t\tif (pwm_check_armed()) {\n\t\t\t\t_armed = true;\n\t\t\t\t_arming = false;\n\t\t\t\t_arming_start_time = 0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AP_Arming::METHOD_PWM_AND_GPS:\n\t\t\t// check if we have armed\n\t\t\tif (pwm_check_armed()) {\n\t\t\t\t_armed = true;\n\t\t\t\t_arming = false;\n\t\t\t\t_arming_start_time = 0;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// check if we have a GPS lock\n\t\t\tif (gps_check_armed()) {\n\t\t\t\t_armed = true;\n\t\t\t\t_arming = false;\n\t\t\t\t_arming_start_time = 0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AP_Arming::METHOD_GPS", "CodeBleu_score": 39.49351316915344}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (do_arming_checks) {\n\t\tif (!check_arming_conditions()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// set the home location to the current location\n\thome_location.set_from_location(current_location);\n\n\t// initialize the simple mode heading\n\tif (vehicle_type == AP_ROVER_VEHICLE) {\n\t\tsimple_mode_heading = current_heading;\n\t}\n\n\t// update the soft armed status\n\tsoft_armed = true;\n\n\t// send arm/disarm status text\n\tsend_arm_disarm_status_text();\n\n\treturn true;\n}", "CodeBleu_score": 28.860796727235705}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool success = false;\n\t// If we're already armed, don't arm again\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// If we're not armed, and we're not in the process of arming, arm\n\tif (!is_armed() &&!is_arming()) {\n\t\t// Arm the rover\n\t\tif (arm_rover(method)) {\n\t\t\tsuccess = true;\n\t\t}\n\t}\n\n\t// If we're not armed, and we're in the process of arming, wait for the arming to finish\n\tif (!is_armed() && is_arming()) {\n\t\tsuccess = false;\n\t}\n\n\t// If we're armed, and we're not in the process of arming, disarm\n\tif (is_armed() &&!is_arming()) {\n\t\tif (arm_rover(AP_Arming::DISARM)) {\n\t\t\tsuccess = true;\n\t\t}\n\t}\n\n\t// If we're armed, and we're in the process of arming, wait for the arming to finish\n\tif (is_armed() && is_arming()) {\n\t\tsuccess = false;\n\t}\n\n\t// If we've failed to arm, set an arming_failed event\n\tif (!success) {\n\t\tevents->set_event(ARMED_FAILED);\n\t}\n\n\t// Return success\n\treturn success;\n}", "CodeBleu_score": 43.43037311900259}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tif (charging_disabled_time == 0) {\n\t\t\t\tcharging_disabled_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (charging_disabled_time!= 0) {\n\t\t\t\tcharging_disabled_time = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tif (charging_disabled_time == 0) {\n\t\t\t\tcharging_disabled_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (charging_disabled_time!= 0) {\n\t\t\t\tif (millis() - charging_disabled_time > CHARGING_RETRY_DELAY) {\n\t\t\t\t\tcharging_disabled_time = 0;\n\t\t\t\t\tcharging_enabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.36961658694791}, {"code": "void updateChargingEnabled(){\n\t\tstatic bool charging_enabled = false;\n\tstatic unsigned long charging_enabled_time = 0;\n\n\tif (charging_enabled) {\n\t\tif (charging_allowed) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_enabled_time = millis();\n\t\t} else {\n\t\t\tif (millis() - charging_enabled_time > 10000) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_allowed) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_enabled_time = millis();\n\t\t} else {\n\t\t\tif (millis() - charging_enabled_time > 10000) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.149613310398465}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed &&!charging_enabled) {\n\t\tcharging_enabled = true;\n\t\tcharging_enabled_time = millis();\n\t} else if (!charging_allowed && charging_enabled) {\n\t\tif (millis() - charging_enabled_time > charging_retry_delay) {\n\t\t\tcharging_enabled = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 29.661906026962193}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (!ros::master::check()) {\n\t\treturn;\n\t}\n\n\tif (size < 4) {\n\t\treturn;\n\t}\n\n\tuint8_t *msg = (uint8_t *) message;\n\tuint8_t crc = FastCRC16().calculate(msg, size - 2);\n\tmsg[size - 2] = crc >> 8;\n\tmsg[size - 1] = crc & 0xFF;\n\n\tpacketSerial.write(msg, size);\n}", "CodeBleu_score": 59.895163076114464}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::isStarted()) {\n\t\tif (size >= 4) {\n\t\t\tuint8_t crc = crc8_fast((uint8_t*) message, size - 1);\n\t\t\t*((uint8_t*) message + size - 1) = crc;\n\t\t\tpacketSerial.send(message, size);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.74270409629794}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::master::check()) {\n\t\tif (size >= 4) {\n\t\t\tuint8_t crc = FastCRC32::calculate(message, size - 4);\n\t\t\tmemcpy(((uint8_t*) message) + size - 4, &crc, 4);\n\t\t\tpacketSerial.write(message, size);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.07273885476738}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\tSerial.begin(9600);\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tSerial.println(F(\"begin\"));\n\tdelay(500);\n\tSerial.println(F(\"begin\"));\n\tSerial.", "CodeBleu_score": 34.473361371994194}, {"code": "bool MP3Sound::begin(){\n\t\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");\n\t//Serial.println(\"begin\");", "CodeBleu_score": 2.127520418101323}, {"code": "bool MP3Sound::begin(){\n\t\tif (Serial1.begin(9600)) {\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.write(\"S\");\n\t\tdelay(100);\n\t\tSerial1.", "CodeBleu_score": 31.375939280846964}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (this->activeSounds.size() == 0) {\n\t\treturn 0;\n\t} else if (this->playingMP3) {\n\t\treturn this->activeSounds.size();\n\t}\n\tthis->playingMP3 = true;\n\tthis->activeSounds.front()->play();\n\tthis->activeSounds.pop_front();\n\treturn this->activeSounds.size();\n}", "CodeBleu_score": 16.36813275860378}, {"code": "int MP3Sound::processSounds(){\n\t\tif (sounds.empty()) {\n\t\treturn 0;\n\t}\n\tif (!isPlaying()) {\n\t\tplaySound(sounds.front());\n\t\tsounds.pop_front();\n\t\treturn sounds.size();\n\t}\n\treturn sounds.size();\n}", "CodeBleu_score": 31.055244156186383}, {"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (playingMP3) {\n\t\treturn activeSounds.size();\n\t}\n\tSound* sound = activeSounds.front();\n\tactiveSounds.pop_front();\n\tif (sound->getType() == Sound::SOUND_TYPE_MP3) {\n\t\tMP3Sound* mp3Sound = (MP3Sound*) sound;\n\t\tmp3Sound->playMP3();\n\t}\n\telse {\n\t\tsound->play();\n\t}\n\treturn activeSounds.size();\n}", "CodeBleu_score": 43.58065273200186}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    WbMemoryMappedFile *file = wb_memory_mapped_file_new(r->data, r->data_size);\n    if (file) {\n      wb_abstract_camera_set_memory_mapped_file(d, file);\n      return true;\n    }\n    return false;\n  }\n#endif /* _WIN32 */\n  return false;\n}", "CodeBleu_score": 27.552412857824326}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  // TODO: implement me!\n  return false;\n#else\n  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      if (wb_request_has_field(r, \"filename\")) {\n        if (camera->memory_mapped_file!= NULL) {\n          munmap(camera->memory_mapped_file, camera->memory_mapped_file_size);\n          free(camera->memory_mapped_file);\n        }\n        camera->memory_mapped_file = NULL;\n        camera->memory_mapped_file_size = 0;\n        const char *filename = wb_request_get_string(r, \"filename\");\n        if (filename!= NULL) {\n          camera->memory_mapped_file_size = wb_abstract_camera_get_memory_mapped_file_size(camera);\n          camera->memory_mapped_file = (char *)mmap(NULL, camera->memory_mapped_file_size, PROT_READ, MAP_SHARED, wb_robot_get_device_by_name(filename)->mf_fd, 0);\n          if (camera->memory_mapped_file == MAP_FAILED) {\n            fprintf(stderr, \"Error: could not map memory-mapped file %s\n\", filename);\n            return false;\n          }\n        }\n      } else {\n        fprintf(stderr, \"Error: %s command requires a filename field\n\", wb_request_command_name(r));\n        return false;\n      }\n      break;\n    default:\n      fprintf(stderr, \"Error: unknown command %d\n\", command);\n      return false;\n  }\n\n  return true;\n#endif\n}", "CodeBleu_score": 47.10582962925681}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  // Windows does not support memory mapping\n  return false;\n#else\n  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    // Clean up any existing memory-mapped file\n    if (camera->memory_mapped_file) {\n      munmap(camera->memory_mapped_file, camera->memory_mapped_file_size);\n      camera->memory_mapped_file = NULL;\n    }\n    // Set up new memory-mapped file\n    int fd = open(r->data, O_RDWR);\n    if (fd == -1) {\n      fprintf(stderr, \"Error: unable to open file %s\n\", r->data);\n      return false;\n    }\n    struct stat st;\n    if (fstat(fd, &st) == -1) {\n      fprintf(stderr, \"Error: unable to get file size of file %s\n\", r->data);\n      return false;\n    }\n    camera->memory_mapped_file_size = st.st_size;\n    camera->memory_mapped_file = (unsigned char *)mmap(NULL, camera->memory_mapped_file_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if (camera->memory_mapped_file == MAP_FAILED) {\n      fprintf(stderr, \"Error: unable to map file %s\n\", r->data);\n      return false;\n    }\n    close(fd);\n    return true;\n  }\n  return false;\n#endif\n}", "CodeBleu_score": 37.214038565982}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tif (d == NULL)\n\t\treturn -1;\n\n\tif (d->type!= WB_CAMERA)\n\t\treturn -1;\n\n\tWbAbstractCamera *c = (WbAbstractCamera *)d;\n\n\tif (c->height == -1) {\n\t\tif (c->mutex == NULL) {\n\t\t\tc->mutex = wb_mutex_new();\n\t\t\twb_mutex_lock(c->mutex);\n\t\t}\n\n\t\tif (c->height == -1) {\n\t\t\tif (c->data!= NULL) {\n\t\t\t\tc->height = c->data->height;\n\t\t\t\tc->width = c->data->width;\n\t\t\t} else\n\t\t\t\tc->height = -1;\n\t\t}\n\n\t\twb_mutex_unlock(c->mutex);\n\t}\n\n\treturn c->height;\n}", "CodeBleu_score": 38.28085693153744}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef _WIN32\n  return d->height;\n#else\n  int height;\n  if (d->height == -1) {\n    pthread_mutex_lock(&d->mutex);\n    height = d->height;\n    pthread_mutex_unlock(&d->mutex);\n  } else\n    height = d->height;\n  return height;\n#endif\n}", "CodeBleu_score": 41.27205714834922}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *)d;\n\tint height = -1;\n\n\tif (ac->height_available) {\n\t\tWbMutexLocker ml(&ac->height_mutex);\n\t\theight = ac->height;\n\t}\n\n\treturn height;\n}", "CodeBleu_score": 44.844297938187964}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t#ifdef DEBUG\n  if (wb_robot_step_count() == 0)\n    fprintf(stderr, \"Warning: wb_accelerometer_get_sampling_period called before wb_robot_init.\n\");\n#endif\n\n  WbDevice *const device = get_device(tag);\n  if (!device) {\n    fprintf(stderr, \"Error: wb_accelerometer_get_sampling_period called with an invalid device tag.\n\");\n    return 0;\n  }\n\n  if (device->type!= WB_ACCELEROMETER) {\n    fprintf(stderr, \"Error: wb_accelerometer_get_sampling_period called with a device tag that does not refer to an accelerometer.\n\");\n    return 0;\n  }\n\n  const WbAccelerometer *const accelerometer = (WbAccelerometer *)device->data;\n\n  if (accelerometer->sampling_period == 0) {\n    fprintf(stderr, \"Error: wb_accelerometer_get_sampling_period called with an accelerometer that has not been initialized.\n\");\n    return 0;\n  }\n\n  return accelerometer->sampling_period;\n}", "CodeBleu_score": 41.14855400835453}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t#ifdef DEBUG\n  printf(\"Entering wb_accelerometer_get_sampling_period\n\");\n#endif\n\n  WbDevice *const device = get_device_with_node_and_type(tag, WB_NODE_ACCELEROMETER, \"accelerometer\");\n  if (!device) {\n    fprintf(stderr, \"Invalid accelerometer device tag\n\");\n    return 0;\n  }\n\n  int sampling_period = device->sampling_period;\n\n#ifdef DEBUG\n  printf(\"Leaving wb_accelerometer_get_sampling_period\n\");\n#endif\n\n  return sampling_period;\n}", "CodeBleu_score": 43.02274713115294}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t#ifdef DEBUG\n  int error_code = 0;\n#endif\n  WbDevice *device = robot_get_device_with_tag(tag);\n  WbAccelerometer *accelerometer = (WbAccelerometer *)device;\n\n#ifdef DEBUG\n  if (accelerometer == NULL) {\n    error_code = 1;\n    fprintf(stderr, \"Error: accelerometer with tag %d does not exist\n\", tag);\n  }\n#endif\n\n  if (accelerometer!= NULL) {\n    int period = accelerometer->period;\n\n#ifdef DEBUG\n    if (period < 0) {\n      error_code = 2;\n      fprintf(stderr, \"Error: accelerometer with tag %d has invalid period %d\n\", tag, period);\n    }\n#endif\n\n    if (period > 0)\n      return period;\n  }\n\n  return 0;\n}", "CodeBleu_score": 42.18031782087079}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar * dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString_std(dmsString);\n\tfree(dmsString);\n\treturn dmsString_std;\n}", "CodeBleu_score": 41.75586434241554}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result(dms);\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 38.166184039894674}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar * dms;\n\tdms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 42.52098996896058}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdVector3 center;\n\tdReal dx, dy, dz;\n\tint i, j;\n\tdVector3 p;\n\tdVector3 normal;\n\tdReal d;\n\tdReal dmin;\n\tdReal dmin_abs;\n\tdReal dmax;\n\tdReal dmax_abs;\n\tdReal dmin_norm;\n\tdReal dmax_norm;\n\tdReal dmin_norm_abs;\n\tdReal dmax_norm_abs;\n\tdReal dmin_norm_rel;\n\tdReal dmax_norm_rel;\n\tdReal dmin_norm_rel_abs;\n\tdReal dmax_norm_rel_abs;\n\tdReal dmin_norm_rel_rel;\n\tdReal dmax_norm_rel_rel;\n\tdReal dmin_norm_rel_rel_abs;\n\tdReal dmax_norm_rel_rel_abs;\n\tdReal dmin_norm_rel_rel_rel;\n\tdReal dmax_norm_rel_rel_rel;\n\tdReal dmin_norm_rel_rel_rel_abs;\n\tdReal dmax_norm_rel_rel_rel_abs;\n\tdReal dmin_norm_rel_rel_rel_rel;\n\tdReal dmax_norm_rel_rel_rel_rel;\n\tdReal dmin_norm_rel_rel_rel_rel_abs;\n\tdReal dmax_norm_rel_rel_rel_rel_abs;\n\tdReal dmin_norm_rel_rel_rel_rel_rel;\n\tdReal dmax_norm_rel_rel_rel_rel_rel;\n\tdReal dmin_norm_rel_rel_rel_rel_rel_abs;\n\tdReal dmax_norm_rel_rel_rel_rel_rel_abs;\n\tdReal dmin_norm_rel_rel_rel_rel_rel_rel;\n\tdReal dmax_norm_rel_rel_rel_rel_rel_rel;\n\tdReal dmin_norm_rel_rel_rel_rel_rel_rel_abs;\n\tdReal dmax_norm_rel_rel", "CodeBleu_score": 4.301641458330171}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdReal dx, dy, dz;\n\tdReal min, max;\n\tdReal dist;\n\tdReal min_dist;\n\tdReal max_dist;\n\tdReal min_x, max_x;\n\tdReal min_y, max_y;\n\tdReal min_z, max_z;\n\tdReal min_dist_x, max_dist_x;\n\tdReal min_dist_y, max_dist_y;\n\tdReal min_dist_z, max_dist_z;\n\tdReal min_dist_xy, max_dist_xy;\n\tdReal min_dist_xz, max_dist_xz;\n\tdReal min_dist_yz, max_dist_yz;\n\tdReal min_dist_xyz, max_dist_xyz;\n\tdReal min_dist_x_yz, max_dist_x_yz;\n\tdReal min_dist_x_yz_xz, max_dist_x_yz_xz;\n\tdReal min_dist_x_yz_xy, max_dist_x_yz_xy;\n\tdReal min_dist_x_yz_xyz, max_dist_x_yz_xyz;\n\tdReal min_dist_x_yz_xy_xz, max_dist_x_yz_xy_xz;\n\tdReal min_dist_x_yz_xy_yz, max_dist_x_yz_xy_yz;\n\tdReal min_dist_x_yz_xy_xyz, max_dist_x_yz_xy_xyz;\n\tdReal min_dist_x_yz_xy_xz_yz, max_dist_x_yz_xy_xz_yz;\n\tdReal min_dist_x_yz_xy_xz_yz_xz, max_dist_x_yz_xy_xz_yz_xz;\n\tdReal min_dist_x_yz_xy_xz_yz_xy, max_dist_x_yz_xy_xz_yz_xy;\n\tdReal min_dist_x_yz_xy_xz_yz_xy_yz, max_dist_x_yz_xy_xz_yz_xy_yz;\n\tdReal min", "CodeBleu_score": 3.616947845093902}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdVector3 p;\n\tdReal dist;\n\tdReal d;\n\tdVector3 n;\n\tdReal nx, ny, nz;\n\tdReal px, py, pz;\n\tdReal px2, py2, pz2;\n\tdReal px3, py3, pz3;\n\tdReal px4, py4, pz4;\n\tdReal px5, py5, pz5;\n\tdReal px6, py6, pz6;\n\tdReal px7, py7, pz7;\n\tdReal px8, py8, pz8;\n\tdReal px9, py9, pz9;\n\tdReal px10, py10, pz10;\n\tdReal px11, py11, pz11;\n\tdReal px12, py12, pz12;\n\tdReal px13, py13, pz13;\n\tdReal px14, py14, pz14;\n\tdReal px15, py15, pz15;\n\tdReal px16, py16, pz16;\n\tdReal px17, py17, pz17;\n\tdReal px18, py18, pz18;\n\tdReal px19, py19, pz19;\n\tdReal px20, py20, pz20;\n\tdReal px21, py21, pz21;\n\tdReal px22, py22, pz22;\n\tdReal px23, py23, pz23;\n\tdReal px24, py24, pz24;\n\tdReal px25, py25, pz25;\n\tdReal px26, py26, pz26;\n\tdReal px27, py27, pz27;\n\tdReal px28, py28, pz28;\n\tdReal px29, py29, pz29;\n\tdReal px30, py30, pz30;\n\tdReal px31, py31, pz31;\n\tdReal px32, py32", "CodeBleu_score": 3.620651916931751}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdAssert (box && fluidPlane);\n\tdAssert (immersion);\n\tdAssert (box->body);\n\tdAssert (flags == dImmersionGeom_Immersion || flags == dImmersionGeom_ImmersionAndContact);\n\tdAssert (immersion->box);\n\tdAssert (immersion->fluidPlane);\n\tdAssert (immersion->immersion);\n\tdAssert (immersion->flags == dImmersionGeom_Immersion || immersion->flags == dImmersionGeom_ImmersionAndContact);\n\tdAssert (immersion->box == box);\n\tdAssert (immersion->fluidPlane == fluidPlane);\n\tdAssert (immersion->immersion == immersion);\n\tdAssert (immersion->flags == flags);\n\n\tdReal boxPos[3];\n\tdReal boxRot[3][3];\n\tdReal boxSize[3];\n\tdReal boxCorners[8][3];\n\tdReal fluidPlaneNormal[3];\n\tdReal fluidPlanePoint[3];\n\tdReal fluidPlaneDistance;\n\tdReal fluidPlaneNormalDotCorner[8];\n\tdReal fluidPlaneNormalDotCornerMin;\n\tdReal fluidPlaneNormalDotCornerMax;\n\tdReal fluidPlaneNormalDotCornerMinIndex;\n\tdReal fluidPlaneNormalDotCornerMaxIndex;\n\tdReal fluidPlaneNormalDotCornerMinIndex2;\n\tdReal fluidPlaneNormalDotCornerMaxIndex2;\n\tdReal fluidPlaneNormalDotCornerMin2;\n\tdReal fluidPlaneNormalDotCornerMax2;\n\tdReal fluidPlaneNormalDotCornerMinIndex3;\n\tdReal fluidPlaneNormalDotCornerMaxIndex3;\n\tdReal fluidPlaneNormalDotCornerMin3;\n\tdReal fluidPlaneNormalDotCornerMax3;\n\tdReal fluidPlaneNormalDotCornerMin4;\n\tdReal fluidPlaneNormalDotCornerMax4;\n\tdReal fluidPlaneNormalDotCornerMinIndex4;\n\tdReal fluidPlaneNormalDotCornerMaxIndex4;\n\tdReal fluidPlaneNormalDotCornerMin5;\n\tdReal fluidPlaneNormalDotCornerMax5;\n\tdReal fluidPlaneNormalDotCornerMinIndex5;\n\tdReal fluidPlaneNormalDotCornerMaxIndex5;\n\tdReal fluidPlaneNormalDotCornerMin6;\n\td", "CodeBleu_score": 36.10792958840365}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tassert (box);\n\tassert (fluidPlane);\n\tassert (immersion);\n\n\tsBoxImmersionData data;\n\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\n\treturn dImmerseBox (data);\n}", "CodeBleu_score": 43.80937636013284}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\t//assert(box->body!= NULL);\n\t//assert(fluidPlane!= NULL);\n\t//assert(immersion!= NULL);\n\t//assert(flags & dImmersionGeom_FLUID_PLANE);\n\t//assert(flags & dImmersionGeom_IMMERSION_BOX);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX_PLANE);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX_PLANE_BOX);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX_PLANE_BOX_PLANE);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX_PLANE_BOX_PLANE_BOX);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE_BOX);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE_BOX);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE);\n\t//assert(flags & dImmersionGeom_IMMERSION_OUTLINE_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE_BOX_PLANE_BOX);\n", "CodeBleu_score": 7.3764088787873066}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tif (!dGeomIsBox (o1) ||!dGeomIsCapsule (o2)) {\n\t\treturn 0;\n\t}\n\tdxGeom *box = o1;\n\tdxGeom *capsule = o2;\n\tdReal *box_pos = dGeomGetPosition (box);\n\tdReal *capsule_pos = dGeomGetPosition (capsule);\n\tdReal *capsule_R = dGeomGetRotation (capsule);\n\tdReal *box_R = dGeomGetRotation (box);\n\tdReal *capsule_dir = dGeomCapsuleGetAxis (capsule);\n\tdReal capsule_len = dGeomCapsuleGetLength (capsule);\n\tdReal capsule_rad = dGeomCapsuleGetRadius (capsule);\n\tdReal box_size[3];\n\tdGeomBoxGetLengths (box, box_size);\n\tdReal box_rad = dGeomBoxGetRadius (box);\n\tdReal box_vol = box_size[0] * box_size[1] * box_size[2];\n\tdReal box_area = 2.0 * (box_size[0] * box_size[1] + box_size[1] * box_size[2] + box_size[2] * box_size[0]);\n\tdReal box_mass = box_vol * box_rad;\n\tdReal capsule_mass = capsule_len * capsule_rad;\n\tdReal box_density = box_mass / box_area;\n\tdReal capsule_density = capsule_mass / capsule_len;\n\tdReal box_capsule_density = (box_density + capsule_density) / 2.0;\n\tdReal box_capsule_mass = box_capsule_density * box_area;\n\tdReal box_capsule_rad = box_capsule_mass / (M_PI * box_capsule_density);\n\tdReal box_capsule_vol = box_capsule_rad * box_capsule_rad * box_capsule_rad * M_PI;\n\tdReal box_capsule_area = 4.0 * box_capsule_rad * box_", "CodeBleu_score": 32.17457238398686}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdxGeomCapsule *capsule;\n\tdxGeomBox *box;\n\n\tif (immersion == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (o1->type!= dBoxClass) {\n\t\treturn 0;\n\t}\n\n\tif (o2->type!= dCapsuleClass) {\n\t\treturn 0;\n\t}\n\n\tbox = (dxGeomBox *) o1;\n\tcapsule = (dxGeomCapsule *) o2;\n\n\tif (dGeomGetBody(o1) == NULL || dGeomGetBody(o2) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (dGeomGetBody(o1) == dGeomGetBody(o2)) {\n\t\treturn 0;\n\t}\n\n\tif (immersion->immersion_plane == NULL) {\n\t\timmersion->immersion_plane = dImmersionPlaneCreate();\n\t}\n\n\tif (dImmerseBoxCapsuleValidate(o1, o2, immersion) == 0) {\n\t\treturn 0;\n\t}\n\n\tif (dImmerseBoxCapsuleComputeImmersionPlane(o1, o2, immersion) == 0) {\n\t\treturn 0;\n\t}\n\n\tif (dImmerseBoxCapsuleComputeImmersion(o1, o2, immersion) == 0) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}", "CodeBleu_score": 33.98772205120168}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmersionGeom *immersion_capsule;\n\tdImmersionGeom *immersion_box;\n\n\t/* Validate the input arguments. */\n\tif (o1 == NULL || o2 == NULL) {\n\t\treturn 0;\n\t}\n\n\t/* If the immersion parameters are not set, set them to default values. */\n\tif (immersion == NULL) {\n\t\timmersion = new dImmersionGeom;\n\t}\n\n\t/* Set the immersion parameters. */\n\timmersion_box = immersion;\n\timmersion_capsule = immersion;\n\n\t/* Compute the immersion plane for the capsule. */\n\timmersion_capsule->plane = dCreateImmersionPlane (o2);\n\n\t/* Check for collisions between the box and the capsule. */\n\tif (dCollideBoxCapsule (o1, o2, immersion_box->plane, immersion_capsule->plane)) {\n\t\t/* If a collision is detected, compute the immersion plane for the box. */\n\t\timmersion_box->plane = dCreateImmersionPlane (o1);\n\n\t\t/* Check for collisions between the box and the capsule. */\n\t\tif (dCollideBoxCapsule (o1, o2, immersion_box->plane, immersion_capsule->plane)) {\n\t\t\t/* If a collision is detected, compute the immersion plane for the box. */\n\t\t\timmersion_box->plane = dCreateImmersionPlane (o1);\n\n\t\t\t/* Check for collisions between the box and the capsule. */\n\t\t\tif (dCollideBoxCapsule (o1, o2, immersion_box->plane, immersion_capsule->plane)) {\n\t\t\t\t/* If a collision is detected, compute the immersion plane for the box. */\n\t\t\t\timmersion_box->plane = dCreateImmersionPlane (o1);\n\n\t\t\t\t/* Check for collisions between the box and the capsule. */\n\t\t\t\tif (dCollideBoxCapsule (o1, o2, immersion_box->plane, immersion_capsule->plane)) {\n\t\t\t\t\t/* If a collision is detected, compute the immersion plane for the box. */\n\t\t\t\t\timmersion_box->plane = dCreateImmersionPlane (o1);\n\n\t\t\t\t\t/* Check for collisions between the", "CodeBleu_score": 33.04130934985077}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal sinTheta0 = dSqrt(1.0 - zIOverR * zIOverR);\n\n\tdReal z0 = 0.0;\n\tdReal z1 = 1.0;\n\n\tdReal z02 = z0 * z0;\n\tdReal z12 = z1 * z1;\n\n\tdReal z03 = z02 * z0;\n\tdReal z13 = z12 * z1;\n\n\tdReal z04 = z03 * z0;\n\tdReal z14 = z13 * z1;\n\n\tdReal z05 = z04 * z0;\n\tdReal z15 = z14 * z1;\n\n\tdReal z06 = z05 * z0;\n\tdReal z16 = z15 * z1;\n\n\tdReal z07 = z06 * z0;\n\tdReal z17 = z16 * z1;\n\n\tdReal z08 = z07 * z0;\n\tdReal z18 = z17 * z1;\n\n\tdReal z09 = z08 * z0;\n\tdReal z19 = z18 * z1;\n\n\tdReal z010 = z09 * z0;\n\tdReal z110 = z19 * z1;\n\n\tdReal z011 = z010 * z0;\n\tdReal z111 = z110 * z1;\n\n\tdReal z012 = z011 * z0;\n\tdReal z112 = z111 * z1;\n\n\tdReal z013 = z012 * z0;\n\tdReal z113 = z112 * z1;\n\n\tdReal z014 = z013 * z0;\n\tdReal z114 = z113 * z1;\n\n\tdReal z015 = z014 * z0;\n\tdReal z115 = z114 * z1;\n\n\tdReal z016 = z015 * z0;\n\tdReal z11", "CodeBleu_score": 32.304478503022374}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal volume = 0;\n\tdReal z = 1;\n\n\tdReal z1 = zIOverR * z;\n\tdReal z2 = zIOverR * (1 - z);\n\tdReal z3 = zIOverR * z * z;\n\tdReal z4 = zIOverR * (1 - z) * (1 - z);\n\n\tdReal sinTheta0 = dSqrt(1 - z1 * z1);\n\tdReal sinTheta1 = dSqrt(1 - z2 * z2);\n\n\tdReal cosTheta0 = z1;\n\tdReal cosTheta1 = z2;\n\n\tdReal sinTheta0CosTheta0 = sinTheta0 * cosTheta0;\n\tdReal sinTheta1CosTheta1 = sinTheta1 * cosTheta1;\n\n\tdReal sinTheta0SinTheta0 = sinTheta0 * sinTheta0;\n\tdReal sinTheta1SinTheta1 = sinTheta1 * sinTheta1;\n\n\tdReal sinTheta0SinTheta0CosTheta0 = sinTheta0SinTheta0 * cosTheta0;\n\tdReal sinTheta1SinTheta1CosTheta1 = sinTheta1SinTheta1 * cosTheta1;\n\n\tdReal sinTheta0SinTheta0SinTheta0 = sinTheta0SinTheta0 * sinTheta0;\n\tdReal sinTheta1SinTheta1SinTheta1 = sinTheta1SinTheta1 * sinTheta1;\n\n\tdReal sinTheta0SinTheta0SinTheta0CosTheta0 = sinTheta0SinTheta0SinTheta0 * cosTheta0;\n\tdReal sinTheta1SinTheta1SinTheta1CosTheta1 = sinTheta1SinTheta1SinTheta1 * cosTheta1;\n\n\tdReal sinTheta0SinTheta0SinTheta0SinTheta0 = sinTheta0SinTheta0SinTheta0 * sinTheta0;\n\tdReal sinTheta1SinTheta1SinTheta1SinTheta1 = sinTheta1SinTheta1SinTheta1 * sinTheta1;\n\n\tdReal sinTheta0SinTheta0SinTheta0SinTheta0CosTheta0 = sinTheta0SinTheta0SinTheta0SinTheta0 * cosTheta0;\n\tdReal sinTheta1SinTheta1SinTheta1SinTheta1CosTheta1 = sinTheta1SinTheta1SinTheta", "CodeBleu_score": 36.867443687045736}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal z = zIOverR;\n\tdReal sinTheta0 = std::sin(theta0);\n\tdReal sinTheta1 = std::sin(theta1);\n\tdReal cosTheta0 = std::cos(theta0);\n\tdReal cosTheta1 = std::cos(theta1);\n\tdReal cosTheta0SinTheta1 = cosTheta0 * sinTheta1;\n\tdReal cosTheta1SinTheta0 = cosTheta1 * sinTheta0;\n\tdReal cosTheta0CosTheta1 = cosTheta0 * cosTheta1;\n\tdReal cosTheta1CosTheta0 = cosTheta1 * cosTheta0;\n\tdReal cosTheta0SinTheta1SinTheta0 = cosTheta0SinTheta1 * sinTheta0;\n\tdReal cosTheta0SinTheta1SinTheta1 = cosTheta0SinTheta1 * sinTheta1;\n\tdReal cosTheta1SinTheta0SinTheta0 = cosTheta1SinTheta0 * sinTheta0;\n\tdReal cosTheta1SinTheta0SinTheta1 = cosTheta1SinTheta0 * sinTheta1;\n\n\tdReal volume = 0.0;\n\n\tdReal z0 = 0.0;\n\tdReal z1 = 0.0;\n\tdReal z2 = 0.0;\n\tdReal z3 = 0.0;\n\tdReal z4 = 0.0;\n\tdReal z5 = 0.0;\n\tdReal z6 = 0.0;\n\tdReal z7 = 0.0;\n\n\tdReal z0SinTheta0 = 0.0;\n\tdReal z1SinTheta0 = 0.0;\n\tdReal z2SinTheta0 = 0.0;\n\tdReal z3SinTheta0 = 0.0;\n\tdReal z4SinTheta0 = 0.0;\n\tdReal z5SinTheta0 = 0.0;\n\tdReal z6SinTheta0 = 0.0;\n\tdReal z7SinTheta0 = 0.0;\n\n\tdReal z0SinTheta1 = 0.0;\n\tdReal z1SinTheta1 = 0.0;\n\tdReal z2SinTheta1", "CodeBleu_score": 34.87182981665692}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal xBuoyancyCenter = 0.0;\n\tdReal xCenter = 0.0;\n\tdReal zCenter = 0.0;\n\tdReal zCenterMin = 0.0;\n\tdReal zCenterMax = 0.0;\n\tdReal zCenterMinMinusZCenterMax = 0.0;\n\tdReal zCenterMinPlusZCenterMax = 0.0;\n\tdReal zCenterMinMinusZCenterMaxSquared = 0.0;\n\tdReal zCenterMinPlusZCenterMaxSquared = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMin = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinSquared = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinPlusZCenterMax = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinPlusZCenterMaxSquared = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinPlusZCenterMaxPlusZCenterMin = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinPlusZCenterMaxPlusZCenterMinSquared = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinPlusZCenterMaxPlusZCenterMinPlusZCenterMax = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinPlusZCenterMaxPlusZCenterMinPlusZCenterMaxSquared = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinPlusZCenterMaxPlusZCenterMinPlusZCenterMaxPlusZCenterMin = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinPlusZCenterMaxPlusZCenterMinPlusZCenterMaxPlusZCenterMinSquared = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinPlusZCenterMaxPlusZCenterMinPlusZCenterMaxPlusZCenterMinPlusZCenterMax = 0.0;\n\tdReal zCenterMinPlusZCenterMaxMinusZCenterMinPlusZCenterMaxPlusZCenterMinPlusZCenterMaxPlusZCenterMinPlusZCenterMaxSquared = 0.0;", "CodeBleu_score": 9.85661451463224}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal xBuoyancyCenter;\n\tdReal zBuoyancyCenter;\n\tdReal xBuoyancyCenter0;\n\tdReal zBuoyancyCenter0;\n\tdReal xBuoyancyCenter1;\n\tdReal zBuoyancyCenter1;\n\tdReal xBuoyancyCenter2;\n\tdReal zBuoyancyCenter2;\n\tdReal xBuoyancyCenter3;\n\tdReal zBuoyancyCenter3;\n\tdReal xBuoyancyCenter4;\n\tdReal zBuoyancyCenter4;\n\tdReal xBuoyancyCenter5;\n\tdReal zBuoyancyCenter5;\n\tdReal xBuoyancyCenter6;\n\tdReal zBuoyancyCenter6;\n\tdReal xBuoyancyCenter7;\n\tdReal zBuoyancyCenter7;\n\tdReal xBuoyancyCenter8;\n\tdReal zBuoyancyCenter8;\n\tdReal xBuoyancyCenter9;\n\tdReal zBuoyancyCenter9;\n\tdReal xBuoyancyCenter10;\n\tdReal zBuoyancyCenter10;\n\tdReal xBuoyancyCenter11;\n\tdReal zBuoyancyCenter11;\n\tdReal xBuoyancyCenter12;\n\tdReal zBuoyancyCenter12;\n\tdReal xBuoyancyCenter13;\n\tdReal zBuoyancyCenter13;\n\tdReal xBuoyancyCenter14;\n\tdReal zBuoyancyCenter14;\n\tdReal xBuoyancyCenter15;\n\tdReal zBuoyancyCenter15;\n\tdReal xBuoyancyCenter16;\n\tdReal zBuoyancyCenter16;\n\tdReal xBuoyancyCenter17;\n\tdReal zBuoyancyCenter17;\n\tdReal xBuoyancyCenter18;\n\tdReal zBuoyancyCenter18;\n\tdReal xBuoyancyCenter19;\n\tdReal zBuoyancyCenter19;\n\tdReal xBuoyancyCenter20;\n\tdReal zBuoyancyCenter20;\n\tdReal xBuoyancyCenter", "CodeBleu_score": 12.661352099780162}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal x = 0.0;\n\tdReal z = 0.0;\n\tdReal r = 0.0;\n\tdReal y = 0.0;\n\tdReal z0 = 0.0;\n\tdReal z1 = 0.0;\n\tdReal z2 = 0.0;\n\tdReal z3 = 0.0;\n\tdReal z4 = 0.0;\n\tdReal z5 = 0.0;\n\tdReal z6 = 0.0;\n\tdReal z7 = 0.0;\n\tdReal z8 = 0.0;\n\tdReal z9 = 0.0;\n\tdReal z10 = 0.0;\n\tdReal z11 = 0.0;\n\tdReal z12 = 0.0;\n\tdReal z13 = 0.0;\n\tdReal z14 = 0.0;\n\tdReal z15 = 0.0;\n\tdReal z16 = 0.0;\n\tdReal z17 = 0.0;\n\tdReal z18 = 0.0;\n\tdReal z19 = 0.0;\n\tdReal z20 = 0.0;\n\tdReal z21 = 0.0;\n\tdReal z22 = 0.0;\n\tdReal z23 = 0.0;\n\tdReal z24 = 0.0;\n\tdReal z25 = 0.0;\n\tdReal z26 = 0.0;\n\tdReal z27 = 0.0;\n\tdReal z28 = 0.0;\n\tdReal z29 = 0.0;\n\tdReal z30 = 0.0;\n\tdReal z31 = 0.0;\n\tdReal z32 = 0.0;\n\tdReal z33 = 0.0;\n\tdReal z34 = 0.0;\n\tdReal z35 = 0.0;\n\tdReal z36 = 0.", "CodeBleu_score": 9.832757845471003}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmerseCapsuleTrimeshData *capsuleImmersionData = (dImmerseCapsuleTrimeshData *) immersion->data;\n\n\tdVector3 normal;\n\tdVector3 position;\n\tdVector3 normal_capsule;\n\tdVector3 position_capsule;\n\tdVector3 normal_trimesh;\n\tdVector3 position_trimesh;\n\tdVector3 normal_capsule_trimesh;\n\tdVector3 position_capsule_trimesh;\n\tdVector3 normal_capsule_trimesh_scaled;\n\tdVector3 position_capsule_trimesh_scaled;\n\tdVector3 normal_capsule_trimesh_scaled_scaled;\n\tdVector3 position_capsule_trimesh_scaled_scaled;\n\n\tdVector3 normal_capsule_trimesh_scaled_scaled_scaled;\n\tdVector3 position_capsule_trimesh_scaled_scaled_scaled;\n\n\tdVector3 normal_capsule_trimesh_scaled_scaled_scaled_scaled;\n\tdVector3 position_capsule_trimesh_scaled_scaled_scaled_scaled;\n\n\tdVector3 normal_capsule_trimesh_scaled_scaled_scaled_scaled_scaled;\n\tdVector3 position_capsule_trimesh_scaled_scaled_scaled_scaled_scaled;\n\n\tdVector3 normal_capsule_trimesh_scaled_scaled_scaled_scaled_scaled_scaled;\n\tdVector3 position_capsule_trimesh_scaled_scaled_scaled_scaled_scaled_scaled;\n\n\tdVector3 normal_capsule_trimesh_scaled_scaled_scaled_scaled_scaled_scaled_scaled;\n\tdVector3 position_capsule_trimesh_scaled_scaled_scaled_scaled_scaled_scaled_scaled;\n\n\tdVector3 normal_capsule_trimesh_scaled_scaled_scaled_scaled_scaled_scaled_scaled_scaled;\n\tdVector3 position_capsule_trimesh_scaled_scaled_scaled_scaled_scaled_scaled_scaled_scaled;\n\n\tdVector3 normal_capsule_trimesh_scaled_scaled_scaled_scaled_scaled_scaled_scaled_scaled_scaled;\n\tdVector3 position_capsule_trimesh_scaled_scaled", "CodeBleu_score": 13.47001543568237}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdTriMeshData *trimeshData = (dTriMeshData *)o2->data;\n\tdCapsuleImmersionData *capsuleImmersionData = (dCapsuleImmersionData *)o1->data;\n\tdCapsuleData *capsuleData = (dCapsuleData *)o1->data;\n\tdTriMeshData *trimeshData2 = (dTriMeshData *)o2->data;\n\tdCapsuleImmersionData *capsuleImmersionData2 = (dCapsuleImmersionData *)o1->data;\n\tdCapsuleData *capsuleData2 = (dCapsuleData *)o1->data;\n\tdImmersionGeom *immersion2 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion3 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion4 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion5 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion6 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion7 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion8 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion9 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion10 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion11 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion12 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion13 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion14 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion15 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion16 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom *immersion17 = (dImmersionGeom *)o1->data;\n\tdImmersionGeom", "CodeBleu_score": 17.823227410816738}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmersionGeomData *data = immersion->data;\n\tdImmersionGeomDataCapsuleTrimesh *capsule_trimesh = (dImmersionGeomDataCapsuleTrimesh*)data;\n\tdImmersionGeomDataCapsuleTrimeshData *capsule_trimesh_data = capsule_trimesh->data;\n\tdImmersionGeomDataCapsuleTrimeshDataCapsule *capsule = capsule_trimesh_data->capsule;\n\tdImmersionGeomDataCapsuleTrimeshDataTrimesh *trimesh = capsule_trimesh_data->trimesh;\n\n\tdVector3 point;\n\tdVector3 normal;\n\tdVector3 center;\n\tdVector3 center_normal;\n\tdVector3 center_normal_normal;\n\tdVector3 center_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal_normal;\n\tdVector3 center_normal_normal_normal_normal", "CodeBleu_score": 27.708321825290266}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\tint sleep_duration = 0;\n\tif (!getParam(\"duration\", sleep_duration)) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tif (sleep_duration <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\ttimer_waiting_ = false;\n\ttimer_ = std::make_unique<std::thread>([this]() {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(sleep_duration));\n\t\twakeUp();\n\t});\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 40.864089360440644}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (duration_ms_ < 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\ttimer_waiting_ = false;\n\ttimer_.start(duration_ms_);\n\ttimer_.setCallback(std::bind(&SleepNode::onTimer, this));\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 23.234119773896403}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tint32_t duration_ms = 0;\n\tif (!getInput(\"duration_ms\", duration_ms)) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tif (duration_ms <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\ttimer_waiting_ = true;\n\ttimer_ = std::make_unique<Timer>(duration_ms, [this]() {\n\t\ttimer_waiting_ = false;\n\t\temitWakeUpSignal();\n\t});\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 46.264368851645024}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tstd::string entryName = m_config.entryName;\n\tstd::string entryType = m_config.entryType;\n\tstd::string entryValue = m_config.entryValue;\n\n\tstd::string sequenceID = m_blackboard->getSequenceID(entryName);\n\tstd::string sequenceID_prev = m_blackboard->getSequenceID_prev(entryName);\n\tstd::string sequenceID_prev_prev = m_blackboard->getSequenceID_prev_prev(entryName);\n\n\tif (sequenceID!= sequenceID_prev) {\n\t\tm_blackboard->setSequenceID_prev(sequenceID, entryName);\n\t\tm_blackboard->setSequenceID_prev_prev(sequenceID_prev, entryName);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\telse if (sequenceID == sequenceID_prev && sequenceID!= sequenceID_prev_prev) {\n\t\tm_blackboard->setSequenceID_prev(sequenceID, entryName);\n\t\tm_blackboard->setSequenceID_prev_prev(sequenceID_prev, entryName);\n\t\treturn NodeStatus::FAILURE;\n\t}\n\telse {\n\t\treturn NodeStatus::FAILURE;\n\t}\n}", "CodeBleu_score": 45.42794685639537}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (m_blackboard.hasKey(m_entryName)) {\n\t\t//std::cout << \"EntryUpdatedAction::tick: entry found\" << std::endl;\n\t\tauto& entry = m_blackboard.get(m_entryName);\n\t\t//std::cout << \"EntryUpdatedAction::tick: entry locked\" << std::endl;\n\t\tstd::lock_guard<std::mutex> lock(entry.mutex);\n\t\t//std::cout << \"EntryUpdatedAction::tick: entry locked\" << std::endl;\n\t\tif (entry.sequenceId!= m_sequenceId) {\n\t\t\t//std::cout << \"EntryUpdatedAction::tick: sequenceId updated\" << std::endl;\n\t\t\tm_sequenceId = entry.sequenceId;\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 35.67649392403754}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tauto& blackboard = getInputBlackboard();\n\tstd::string entryName = getInput<std::string>(\"entry_name\");\n\tint sequenceID = getInput<int>(\"sequence_id\");\n\tint currentSequenceID = 0;\n\tint64_t currentTimestamp = 0;\n\n\ttry {\n\t\tcurrentSequenceID = blackboard.get<int>(entryName + \"_sequence_id\");\n\t\tcurrentTimestamp = blackboard.get<int64_t>(entryName + \"_timestamp\");\n\t} catch (std::out_of_range& e) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tif (currentSequenceID!= sequenceID) {\n\t\tblackboard.set<int>(entryName + \"_sequence_id\", sequenceID);\n\t\tblackboard.set<int64_t>(entryName + \"_timestamp\", currentTimestamp);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 43.26897752386185}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (m_successThreshold < 0) {\n\t\treturn m_children.size() + m_successThreshold;\n\t}\n\treturn m_successThreshold;\n}", "CodeBleu_score": 46.233990918715456}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (m_successThreshold < 0) {\n\t\treturn m_children.size() + m_successThreshold;\n\t}\n\treturn m_successThreshold;\n}", "CodeBleu_score": 46.233990918715456}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn static_cast<size_t>(-success_threshold_ * static_cast<double>(children_.size()));\n\t} else {\n\t\treturn static_cast<size_t>(success_threshold_);\n\t}\n}", "CodeBleu_score": 57.84357767754863}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\tif (m_lastHeartbeatTime == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m_lastHeartbeatTime + m_heartbeatTimeout < std::chrono::steady_clock::now()) {\n\t\t\tif (m_heartbeatStatus == Groot2HeartbeatStatus::HEARTBEAT_ACTIVE) {\n\t\t\t\tm_heartbeatStatus = Groot2HeartbeatStatus::HEARTBEAT_INACTIVE;\n\t\t\t\tm_logger->error(\"Heartbeat inactive\");\n\t\t\t\tm_logger->error(\"Server has not sent a heartbeat within the last {} milliseconds\", m_heartbeatTimeout);\n\t\t\t\tm_logger->error(\"All breakpoints will be disabled\");\n\n\t\t\t\tfor (auto& bp : m_breakpoints) {\n\t\t\t\t\tbp.second.enabled = false;\n\t\t\t\t}\n\n\t\t\t\tm_logger->info(\"All breakpoints disabled\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (m_heartbeatStatus == Groot2HeartbeatStatus::HEARTBEAT_INACTIVE) {\n\t\t\t\tm_heartbeatStatus = Groot2HeartbeatStatus::HEARTBEAT_ACTIVE;\n\t\t\t\tm_logger->info(\"Heartbeat active\");\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.07590024648805}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (last_heartbeat_time_ == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst auto now = std::chrono::system_clock::now();\n\t\tconst auto diff = now - last_heartbeat_time_;\n\t\tif (std::chrono::duration_cast<std::chrono::seconds>(diff).count() > 10) {\n\t\t\tlast_heartbeat_time_ = 0;\n\t\t\tfor (auto& bp : breakpoints_) {\n\t\t\t\tbp->setEnabled(false);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 47.00928892539513}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (lastHeartbeatTime == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (std::chrono::duration_cast<std::chrono::seconds>(\n\t\t\t\tstd::chrono::steady_clock::now() - lastHeartbeatTime).count() > 2) {\n\t\t\tif (enableBreakpoints) {\n\t\t\t\tenableBreakpoints = false;\n\t\t\t\tenableBreakpoints_ = false;\n\t\t\t\tstd::cout << \"Server heartbeat lost, disabling breakpoints.\"\n\t\t\t\t\t\t<< std::endl;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!enableBreakpoints) {\n\t\t\t\tenableBreakpoints = true;\n\t\t\t\tenableBreakpoints_ = true;\n\t\t\t\tstd::cout << \"Server heartbeat received, enabling breakpoints.\"\n\t\t\t\t\t\t<< std::endl;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.088246048587976}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> bb_dump;\n\tstd::vector<std::string> bb_names = split(bb_list, \",\");\n\tfor (auto bb_name : bb_names) {\n\t\tauto bb_tree = _blackboards.find(bb_name);\n\t\tif (bb_tree!= _blackboards.end()) {\n\t\t\tif (bb_tree->second->isLocked()) {\n\t\t\t\tbb_tree->second->unlock();\n\t\t\t}\n\t\t\tauto bb_json = bb_tree->second->to_json();\n\t\t\tbb_dump.insert(bb_dump.end(), bb_json.begin(), bb_json.end());\n\t\t}\n\t}\n\treturn bb_dump;\n}", "CodeBleu_score": 46.91982026836015}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\n\tstd::vector<std::string> blackboards_list;\n\tsplitString(bb_list, blackboards_list, ',');\n\n\tfor (auto& bb_name : blackboards_list) {\n\t\tauto bb = m_blackboard_tree.find(bb_name);\n\t\tif (bb!= m_blackboard_tree.end()) {\n\t\t\tif (bb->second->isLocked()) {\n\t\t\t\tbb->second->unlock();\n\t\t\t}\n\t\t\tstd::stringstream ss;\n\t\t\tbb->second->to_json(ss);\n\t\t\tresult.insert(result.end(), ss.str().begin(), ss.str().end());\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 44.981175958659094}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\tstd::vector<std::string> bb_names;\n\tstd::string bb_name;\n\tstd::string::size_type pos = 0;\n\tstd::string::size_type prev_pos = 0;\n\n\t// Split the input string of blackboard names and iterate through them\n\twhile ((pos = bb_list.find(delimiter, prev_pos))!= std::string::npos) {\n\t\tbb_name = bb_list.substr(prev_pos, pos - prev_pos);\n\t\tbb_names.push_back(bb_name);\n\t\tprev_pos = pos + 1;\n\t}\n\tbb_name = bb_list.substr(prev_pos);\n\tbb_names.push_back(bb_name);\n\n\t// For each blackboard name, find the corresponding subtree and lock it\n\tfor (const auto& bb_name : bb_names) {\n\t\tauto subtree = blackboard_.subtree(bb_name);\n\t\tif (subtree) {\n\t\t\tsubtree->lock();\n\t\t}\n\n\t\t// Export the blackboard to JSON and add it to the JSON object\n\t\tstd::string json_string = subtree->to_json();\n\t\trapidjson::Document document;\n\t\tdocument.Parse(json_string.c_str());\n\t\tresult.insert(result.end(), document.GetAllocator().GetFreeMemory());\n\t\tresult.insert(result.end(), document.GetBuffer(), document.GetBuffer() + document.GetSize());\n\t}\n\n\t// Convert the JSON object to MessagePack format and return it\n\treturn MessagePack::pack(result);\n}", "CodeBleu_score": 42.93223536340588}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tauto it = tree_hooks_.find(pos);\n\tif (it == tree_hooks_.end()) {\n\t\treturn false;\n\t}\n\n\tauto hook = it->second;\n\tif (hook->getNodeUID()!= node_uid) {\n\t\treturn false;\n\t}\n\tif (!hook->isBreakpoint()) {\n\t\treturn false;\n\t}\n\n\thook->setNodeStatus(result);\n\thook->setRemoveFlag(remove);\n\thook->setReadyFlag(true);\n\thook->notifyAll();\n\treturn true;\n}", "CodeBleu_score": 42.089843650210696}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\n\t// Search for the node by its UID\n\tauto it = std::find_if(m_nodes.begin(), m_nodes.end(),\n\t\t[node_uid](const NodeInfo &node) {\n\t\t\treturn node.uid == node_uid;\n\t\t});\n\n\t// If the node was not found, return false\n\tif (it == m_nodes.end()) {\n\t\treturn false;\n\t}\n\n\t// If the node is not valid, return false\n\tif (!it->valid) {\n\t\treturn false;\n\t}\n\n\t// Get the associated hook\n\tauto &hook = it->hook;\n\n\t// Lock the hook's mutex\n\tstd::unique_lock<std::mutex> lock2(hook.mutex);\n\n\t// If the hook is not in BREAKPOINT mode, return false\n\tif (hook.mode!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\t// Set the desired status and removal flag\n\thook.status = result;\n\thook.remove = remove;\n\n\t// Mark the hook as ready\n\thook.ready = true;\n\n\t// Notify all waiting threads\n\thook.condition.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 49.39783054548505}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tauto it = m_hooks.find(pos);\n\tif (it == m_hooks.end()) {\n\t\treturn false;\n\t}\n\n\tauto& hook = it->second;\n\tif (!hook->is_valid()) {\n\t\treturn false;\n\t}\n\n\tstd::lock_guard<std::mutex> lock_hook(hook->m_mutex);\n\n\tif (hook->m_status!= NodeStatus::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\thook->m_status = result;\n\thook->m_remove = remove;\n\thook->m_ready = true;\n\thook->m_cv.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 44.295150990529365}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::thread thread(&BT::ThreadedAction::executeTickThread, this);\n\t\tthread.detach();\n\t}\n\tif (!halt_requested_) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\ttry {\n\t\t\texecuteTickThread();\n\t\t} catch (const std::exception& e) {\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t\tthrow e;\n\t\t}\n\t\tstatus_ = NodeStatus::IDLE;\n\t}\n\tif (stored_exception_) {\n\t\tstored_exception_->rethrow();\n\t}\n\treturn status_;\n}", "CodeBleu_score": 35.805902297528654}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::thread t(&ThreadedAction::tick, this);\n\t\tt.detach();\n\t\treturn status_;\n\t}\n\telse if (status_ == NodeStatus::RUNNING) {\n\t\treturn status_;\n\t}\n\telse {\n\t\treturn status_;\n\t}\n}", "CodeBleu_score": 18.941421918522707}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\t// if the node is idle, set the status to running, reset the halt request flag, and start a new asynchronous thread to run the tick function.\n\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tthread_ = std::thread(&ThreadedAction::tick, this);\n\t}\n\t// if the tick function completes without a halt request, update the node status.\n\telse if (!halt_requested_) {\n\t\tstatus_ = NodeStatus::SUCCESS;\n\t}\n\t// if an exception occurs, catch the exception, log an error, and set the node status to IDLE.\n\telse {\n\t\ttry {\n\t\t\tthrow;\n\t\t} catch (const std::exception& e) {\n\t\t\tstd::cerr << \"Exception in \" << name_ << \": \" << e.what() << std::endl;\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t}\n\t// if there are stored exceptions, rethrow them.\n\tif (stored_exception_) {\n\t\tstored_exception_->rethrow();\n\t}\n\treturn status_;\n}", "CodeBleu_score": 30.221595236203637}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstd::function<void(const TreeNode*, int)> print_tree_recursively = [&print_tree_recursively](const TreeNode* node, int depth) {\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"  \";\n\t\t}\n\t\tstream << node->name() << std::endl;\n\t\tfor (const auto& child : node->children()) {\n\t\t\tprint_tree_recursively(child, depth + 1);\n\t\t}\n\t};\n\tprint_tree_recursively(root_node, 0);\n}", "CodeBleu_score": 32.85083228908655}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstd::string indent = \"\";\n\tauto print_node = [&](const TreeNode* node, const std::string& separator) {\n\t\tstream << indent << separator << node->name() << std::endl;\n\t\tindent += \"  \";\n\t\tif (node->is_control_node()) {\n\t\t\tfor (const auto& child : node->children()) {\n\t\t\t\tprint_node(child, \"|-\");\n\t\t\t}\n\t\t} else {\n\t\t\tprint_node(node->child(), \"|-\");\n\t\t}\n\t\tindent.pop_back();\n\t\tindent.pop_back();\n\t};\n\tprint_node(root_node, \"\");\n}", "CodeBleu_score": 29.379840190764366}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// print separator lines\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;\n\tstream << \"================================================================\" << std::endl;", "CodeBleu_score": 14.745398157689916}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow std::logic_error(\"The given node is null!\");\n\t}\n\n\tvisitor(node);\n\n\tif (node->is_control_node()) {\n\t\tconst auto* control_node = static_cast<const ControlNode*>(node);\n\t\tfor (const auto& child : control_node->children_) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->is_decorator_node()) {\n\t\tconst auto* decorator_node = static_cast<const DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(decorator_node->child_, visitor);\n\t}\n}", "CodeBleu_score": 57.25670247292385}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"applyRecursiveVisitor: node is null\");\n\t}\n\n\tvisitor(node);\n\n\tif (node->isControlNode()) {\n\t\tfor (const auto& child : node->children) {\n\t\t\tapplyRecursiveVisitor(child.get(), visitor);\n\t\t}\n\t} else if (node->isDecoratorNode()) {\n\t\tapplyRecursiveVisitor(node->child.get(), visitor);\n\t}\n}", "CodeBleu_score": 43.94560370094784}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"Node is null\");\n\t}\n\tvisitor(node);\n\tif (node->is_control_node()) {\n\t\tfor (const auto& child : node->children_) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->is_decorator_node()) {\n\t\tapplyRecursiveVisitor(node->child_, visitor);\n\t}\n}", "CodeBleu_score": 41.73512420119566}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.find(manifest.registration_id)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with ID '\" + manifest.registration_id + \"' already registered\");\n\t}\n\n\tbuilders_.insert(std::make_pair(manifest.registration_id, builder));\n\tbuilder_manifests_.insert(std::make_pair(manifest.registration_id, manifest));\n}", "CodeBleu_score": 50.14048633911885}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.registration_id)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"The builder with registration ID \" + manifest.registration_id +\n\t\t\t\" is already registered!\");\n\t}\n\tbuilders.insert(std::make_pair(manifest.registration_id, builder));\n\tmanifests.insert(std::make_pair(manifest.registration_id, manifest));\n}", "CodeBleu_score": 49.09671949282131}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.find(manifest.registrationId)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with registration ID '\" + manifest.registrationId + \"' already registered\");\n\t}\n\tbuilders_[manifest.registrationId] = builder;\n\tbuildersManifest_[manifest.registrationId] = manifest;\n}", "CodeBleu_score": 45.63518047839349}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\tauto builder = [tick_functor, ports](const std::string& name, const std::string& description) {\n\t\treturn SimpleActionNode::create(name, description, tick_functor, ports);\n\t};\n\tregisterBuilder(ID, builder);\n}", "CodeBleu_score": 44.59692403711688}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t#if defined(BT_USE_WILDCARDS)\n  auto builder = [tick_functor, ports](const std::string& name) {\n    return std::make_shared<SimpleActionNode>(name, tick_functor, ports);\n  };\n  registerBuilder(ID, builder, \"SimpleActionNode\");\n#else\n  auto builder = [tick_functor, ports](const std::string& name) {\n    return std::make_shared<SimpleActionNode>(name, tick_functor, ports);\n  };\n  registerBuilder(ID, builder);\n#endif\n}", "CodeBleu_score": 55.609309739754096}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t#ifdef BEHAVIOR_TREE_CPP_SHARED_LIBRARY\n  std::string library_path = getLibraryPath();\n  if (!library_path.empty()) {\n    SharedLibrary::instance().load(library_path);\n  }\n#endif\n\n  NodeBuilder builder = [tick_functor, ports](const std::string& name,\n                                                const std::string& xml_str) {\n    auto node_ptr = std::make_shared<SimpleActionNode>(name, tick_functor, ports);\n    return std::make_unique<TreeNodeManifest>(node_ptr, xml_str);\n  };\n\n  registerBuilder(ID, std::move(builder));\n}", "CodeBleu_score": 55.8813096598177}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.size());\n\n\tfor (const auto& subtree : tree) {\n\t\tauto backup = std::make_shared<Blackboard>();\n\t\t*backup = *subtree->blackboard_;\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}", "CodeBleu_score": 52.29017888238282}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.subtrees().size());\n\tfor (auto& subtree : tree.subtrees()) {\n\t\tauto backup = std::make_shared<Blackboard>();\n\t\tbackup->clone(subtree->blackboard());\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}", "CodeBleu_score": 51.99499351640786}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> blackboards;\n\tblackboards.reserve(tree.getSubTrees().size());\n\n\tfor (const auto& subtree : tree.getSubTrees()) {\n\t\tauto bb = std::make_shared<Blackboard>();\n\t\tbb->clone(*subtree->getBlackboard());\n\t\tblackboards.push_back(bb);\n\t}\n\n\treturn blackboards;\n}", "CodeBleu_score": 52.25299220218235}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tBT::Expected<BT::Node> tree = ParseScript(env, script);\n\tif (!tree) {\n\t\treturn tree.asUnexpected();\n\t}\n\tBT::Node& root = *tree;\n\treturn root.execute(env);\n}", "CodeBleu_score": 47.73725406123941}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tBT::ScriptParser parser;\n\tBT::ScriptExecutor executor;\n\n\tauto result = parser.ParseScript(script);\n\n\tif (!result) {\n\t\treturn BT::nonstd::make_unexpected(result.error());\n\t}\n\n\tauto ast = std::move(result.value());\n\n\tauto result2 = executor.Execute(ast, env);\n\n\tif (!result2) {\n\t\treturn BT::nonstd::make_unexpected(result2.error());\n\t}\n\n\treturn result2.value();\n}", "CodeBleu_score": 44.0805006431023}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tBT::ScriptParser parser;\n\tauto res = parser.ParseScript(script);\n\tif (!res) {\n\t\treturn BT::make_unexpected(res.error());\n\t}\n\n\tBT::Executor executor = res.value();\n\tauto result = executor.execute(env);\n\tif (!result) {\n\t\treturn BT::make_unexpected(result.error());\n\t}\n\n\treturn result.value();\n}", "CodeBleu_score": 47.08349836166651}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tif (m_library) {\n\t\tthrow RuntimeError(\"Library is already loaded\");\n\t}\n\n\tm_library = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!m_library) {\n\t\tconst char* error = dlerror();\n\t\tthrow RuntimeError(error);\n\t}\n\tm_path = path;\n}", "CodeBleu_score": 55.252036932770196}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tif (m_lib_handle) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tm_lib_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!m_lib_handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tm_path = path;\n}", "CodeBleu_score": 48.49779662999059}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(m_mutex);\n\tif (m_path!= \"\") {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\n\tm_path = path;\n\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tstd::string error = dlerror();\n\t\tthrow RuntimeError(\"Unable to load library: \" + error);\n\t}\n\n\tm_handle = handle;\n}", "CodeBleu_score": 58.99377016175112}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\t// Strip leading and trailing spaces\n\tStringView stripped = str.strip_leading_and_trailing_spaces();\n\n\t// Ensure string starts with '{' and ends with '}'\n\tif (stripped.size() < 3 || stripped[0]!= '{' || stripped[stripped.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\t// Assign inner content to stripped_pointer if provided\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 25.935241085863503}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.substr(1, str.size() - 2);\n\tif (stripped.size() == 0) {\n\t\treturn false;\n\t}\n\n\tif (stripped[0]!= '{' || stripped[stripped.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 27.262848613977187}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3)\n\t\treturn false;\n\n\t// Strip leading and trailing spaces\n\tsize_t start = 0;\n\twhile (start < str.size() && str[start] =='')\n\t\t++start;\n\n\tsize_t end = str.size() - 1;\n\twhile (end >= start && str[end] =='')\n\t\t--end;\n\n\t// Check if string starts with '{' and ends with '}'\n\tif (start == end || str[start]!= '{' || str[end]!= '}')\n\t\treturn false;\n\n\tif (stripped_pointer)\n\t\t*stripped_pointer = str.substr(start + 1, end - start - 1);\n\n\treturn true;\n}", "CodeBleu_score": 43.49236976917202}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0.0;\n\tLineIterator it(x0, y0, x1, y1, costmap_->getCostmap());\n\tfor (unsigned int i = 0; i < it.size(); ++i, ++it) {\n\t\tdouble pcost = pointCost(it.getX(), it.getY());\n\t\tif (pcost < 0) {\n\t\t\treturn pcost;\n\t\t}\n\t\tcost += pcost;\n\t}\n\treturn cost;\n}", "CodeBleu_score": 36.11856454053923}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0.0;\n\tdouble pcost;\n\tLineIterator iterator(costmap_, x0, y0, x1, y1);\n\tfor (LineIterator::iterator it = iterator.begin(); it!= iterator.end(); ++it) {\n\t\tpcost = pointCost(it->x, it->y);\n\t\tif (pcost < 0.0) {\n\t\t\treturn pcost;\n\t\t} else {\n\t\t\tcost += pcost;\n\t\t}\n\t}\n\treturn cost;\n}", "CodeBleu_score": 47.694324712093476}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tLineIterator line_iterator(x0, y0, x1, y1, costmap_);\n\n\tfor (LineIterator::iterator it = line_iterator.begin(); it!= line_iterator.end(); ++it) {\n\t\tif (costmap_->getCost(*it) < 0) {\n\t\t\treturn costmap_->getCost(*it);\n\t\t} else {\n\t\t\tline_cost = std::max(line_cost, costmap_->getCost(*it));\n\t\t}\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 50.41760957136405}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN_THROTTLE(1.0, \"Received plan with zero length\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path msg;\n\tmsg.header.frame_id = path[0].header.frame_id;\n\tmsg.header.stamp = path[0].header.stamp;\n\n\tfor (const auto& pose : path) {\n\t\tmsg.poses.push_back(pose.pose);\n\t}\n\n\tpub.publish(msg);\n}", "CodeBleu_score": 50.153371016752715}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif(path.empty()) {\n\t\tROS_WARN(\"The received path is empty\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\n\tfor(const auto& pose : path) {\n\t\tpath_msg.poses.push_back(pose.pose);\n\t}\n\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 51.5316639117049}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif(path.empty())\n\t\treturn;\n\n\tnav_msgs::Path path_msg;\n\tpath_msg.poses.resize(path.size());\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\n\tfor(unsigned int i = 0; i < path.size(); ++i)\n\t\tpath_msg.poses[i] = path[i];\n\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 73.6091155125328}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tdouble rot_vel = base_odom.twist.twist.angular.z;\n\tdouble trans_vel = base_odom.twist.twist.linear.x;\n\n\tif(fabs(rot_vel) <= rot_stopped_velocity && fabs(trans_vel) <= trans_stopped_velocity)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "CodeBleu_score": 52.18634889086551}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tbool stopped = true;\n\tif (base_odom.twist.twist.angular.z > rot_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.angular.z < -rot_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.linear.x > trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.linear.x < -trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\treturn stopped;\n}", "CodeBleu_score": 52.04138224379912}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tbool stopped = true;\n\tif (base_odom.twist.twist.angular.z > rot_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.angular.z < -rot_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.linear.x > trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.linear.x < -trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.linear.y > trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.linear.y < -trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.linear.z > trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.linear.z < -trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\treturn stopped;\n}", "CodeBleu_score": 46.86456178150817}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig.setToDefault();\n\t}\n\n\t// If the configuration is not yet setup, initialize the default limits with the provided configuration and set up the flag.\n\tif (!setup) {\n\t\tdefault_limits = config;\n\t\tsetup = true;\n\t}\n\n\t// Lock the configuration mutex and update the current limits with the new configuration.\n\tstd::lock_guard<std::mutex> lock(config_mutex);\n\tlimits = config;\n}", "CodeBleu_score": 45.69228458747941}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// if the setup flag is true and restore_defaults is requested, it resets the configuration to default limits\n\tif (setup_ && restore_defaults) {\n\t\tconfig_mutex_.lock();\n\t\tconfig_ = config;\n\t\tconfig_mutex_.unlock();\n\t\tsetup_ = false;\n\t}\n\t// if setup is not yet done, it initializes the default limits with the provided configuration and sets up the flag\n\telse if (!setup_) {\n\t\tconfig_mutex_.lock();\n\t\tconfig_ = config;\n\t\tconfig_mutex_.unlock();\n\t\tsetup_ = true;\n\t}\n\t// finally, it locks the configuration mutex and updates the current limits with the new configuration\n\telse {\n\t\tconfig_mutex_.lock();\n\t\tconfig_ = config;\n\t\tconfig_mutex_.unlock();\n\t}\n}", "CodeBleu_score": 50.3893426248269}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// TODO: Add code here.\n}", "CodeBleu_score": 4.780716794403336}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t//check if the cell is an obstacle or has no information\n\tif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::NO_INFORMATION) {\n\t\t//if it is an obstacle, set the target distance to the maximum obstacle cost and return false\n\t\tcheck_cell->target_distance = costmap_2d::LETHAL_OBSTACLE;\n\t\treturn false;\n\t}\n\n\t//calculate the new target distance\n\tdouble new_distance = current_cell->target_distance + costmap.getCost(check_cell->x, check_cell->y);\n\n\t//if the new distance is shorter than the old distance, update the cell's target distance\n\tif (new_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_distance;\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 49.64530437624458}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\tif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\tcurrent_cell->target_distance = costmap.getCost(current_cell->x, current_cell->y);\n\t\treturn false;\n\t}\n\n\t// Calculate the new target distance\n\tdouble new_target_distance = costmap.getCost(check_cell->x, check_cell->y) + 1;\n\tif (new_target_distance < current_cell->target_distance) {\n\t\tcurrent_cell->target_distance = new_target_distance;\n\t}\n\treturn true;\n}", "CodeBleu_score": 47.674549798981374}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// Check if the cell is an obstacle or has no information\n\tif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::NO_INFORMATION) {\n\t\t// The cell is an obstacle or has no information\n\t\tcheck_cell->target_distance = costmap.getCost(costmap_2d::LETHAL_OBSTACLE);\n\t\treturn false;\n\t}\n\n\t// Calculate the new target distance\n\tdouble new_target_distance = current_cell->target_distance + costmap.getCost(check_cell->x, check_cell->y);\n\n\t// Update the target distance if the new distance is shorter\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 52.522141480240634}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\t// Initialize the cost and scaling factor.\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\n\t// If the footprint specification is empty, log an error and return -9.\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty!\");\n\t\treturn -9.0;\n\t}\n\n\t// For each point in the trajectory, calculate the footprint cost.\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); i++) {\n\t\t// Get the footprint cost.\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i));\n\n\t\t// If the footprint cost is negative, return the cost immediately.\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn cost;\n\t\t}\n\n\t\t// If the footprint cost is positive, either sum the scores or take the maximum score based on the sum_scores_ flag.\n\t\tif (footprint_cost > 0.0) {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost;\n\t\t\t} else {\n\t\t\t\tcost = std::max(cost, footprint_cost);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the total cost.\n\treturn cost;\n}", "CodeBleu_score": 44.33041283268161}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\n\t// Check if the footprint is empty\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty. This is not allowed.\");\n\t\treturn -9.0;\n\t}\n\n\t// Initialize the cost and scaling factor\n\tcost = 0.0;\n\tscaling_factor = 1.0;\n\n\t// Calculate the footprint cost\n\tfor (int i = 0; i < traj.getPoints().size(); i++) {\n\t\t// Get the footprint cost\n\t\tdouble footprint_cost = footprintCost(traj.getPoints()[i]);\n\n\t\t// Check if the footprint cost is negative\n\t\tif (footprint_cost < 0.0) {\n\t\t\t// Return the cost immediately\n\t\t\treturn cost;\n\t\t}\n\n\t\t// Sum the scores\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t}\n\t\t// Take the maximum score\n\t\telse {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\t// Return the total cost\n\treturn cost * scaling_factor;\n}", "CodeBleu_score": 43.47935516957922}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\t// Initialize cost and scaling factor\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\n\t// Check if footprint is empty\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty!\");\n\t\treturn -9.0;\n\t}\n\n\t// Check if footprint is valid\n\tif (!footprint_spec_.isCostmapSizeValid()) {\n\t\tROS_ERROR(\"Footprint specification is not valid!\");\n\t\treturn -9.0;\n\t}\n\n\t// Check if footprint is valid\n\tif (!footprint_spec_.isFootprintValid(traj.getFootprint())) {\n\t\tROS_ERROR(\"Footprint specification is not valid!\");\n\t\treturn -9.0;\n\t}\n\n\t// Check if footprint is valid\n\tif (!footprint_spec_.isFootprintClear(traj.getFootprint())) {\n\t\tROS_ERROR(\"Footprint specification is not valid!\");\n\t\treturn -9.0;\n\t}\n\n\t// For each point in the trajectory, calculate the footprint cost\n\tfor (unsigned int i = 0; i < traj.getPoints().size(); ++i) {\n\t\t// Calculate footprint cost\n\t\tdouble footprint_cost = footprint_spec_.getCost(traj.getFootprint()[i].x, traj.getFootprint()[i].y);\n\n\t\t// Check if footprint cost is negative\n\t\tif (footprint_cost < 0.0) {\n\t\t\t// Return immediately\n\t\t\treturn -9.0;\n\t\t}\n\n\t\t// Add footprint cost to total cost\n\t\tcost += footprint_cost;\n\n\t\t// Check if sum_scores_ is true\n\t\tif (sum_scores_) {\n\t\t\t// Add footprint cost to total scaling factor\n\t\t\tscaling_factor += footprint_cost;\n\t\t} else {\n\t\t\t// Take maximum of footprint cost and total scaling factor\n\t\t\tscaling_factor = std::max(scaling_factor, footprint_cost);\n\t\t}\n\t}\n\n\t// Return total cost\n\treturn cost / scaling_factor;\n}", "CodeBleu_score": 44.46499989509513}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\tROS_DEBUG_NAMED(\"footprint_cost\", \"footprintCost: x: %f, y: %f, th: %f, scale: %f\", x, y, th, scale);\n\n\t// Scale the footprint points by the given scale factor\n\tstd::vector<geometry_msgs::Point> scaled_footprint;\n\tfor (unsigned int i = 0; i < footprint_spec.size(); i++) {\n\t\tgeometry_msgs::Point scaled_point;\n\t\tscaled_point.x = footprint_spec[i].x * scale;\n\t\tscaled_point.y = footprint_spec[i].y * scale;\n\t\tscaled_footprint.push_back(scaled_point);\n\t}\n\n\t// Find the footprint's position and orientation in the world\n\tdouble footprint_x, footprint_y, footprint_th;\n\tif (world_model->getRobotPose(x, y, th, footprint_x, footprint_y, footprint_th)) {\n\t\t// Get the footprint's cost\n\t\tdouble footprint_cost = costmap->getCost(footprint_x, footprint_y);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn -6.0;\n\t\t}\n\n\t\t// Get the cell cost\n\t\tdouble cell_cost = costmap->getCost(x, y);\n\t\tif (cell_cost < 0) {\n\t\t\treturn -7.0;\n\t\t}\n\n\t\t// Return the maximum of the footprint and cell costs\n\t\treturn std::max(footprint_cost, cell_cost);\n\t} else {\n\t\treturn -7.0;\n\t}\n}", "CodeBleu_score": 59.75539911490009}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\tdouble cost = -6.0;\n\tdouble footprint_cost = 0.0;\n\tdouble cell_cost = 0.0;\n\tdouble max_cost = 0.0;\n\tdouble footprint_cost_scale = 1.0;\n\tdouble cell_cost_scale = 1.0;\n\tdouble max_cost_scale = 1.0;\n\n\tif (scale <= 0.0) {\n\t\tROS_ERROR(\"Footprint scale must be positive\");\n\t\treturn cost;\n\t}\n\n\tfootprint_cost_scale = 1.0 / scale;\n\tcell_cost_scale = 1.0 / scale;\n\tmax_cost_scale = 1.0 / scale;\n\n\tstd::vector<geometry_msgs::Point> scaled_footprint;\n\tscaled_footprint.resize(footprint_spec.size());\n\n\tfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n\t\tscaled_footprint[i].x = footprint_spec[i].x * scale;\n\t\tscaled_footprint[i].y = footprint_spec[i].y * scale;\n\t}\n\n\tfootprint_cost = world_model->footprintCost(scaled_footprint, x, y, th);\n\tcell_cost = costmap->getCost(x, y);\n\n\tif (footprint_cost < 0.0) {\n\t\treturn footprint_cost;\n\t}\n\n\tif (cell_cost < 0.0) {\n\t\treturn cell_cost;\n\t}\n\n\tmax_cost = std::max(footprint_cost, cell_cost);\n\n\treturn max_cost;\n}", "CodeBleu_score": 56.25545186226866}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t//ROS_INFO(\"footprintCost\");\n    // scale the footprint\n    std::vector<geometry_msgs::Point> scaled_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        scaled_footprint.push_back(footprint_spec[i]);\n        scaled_footprint[i].x *= scale;\n        scaled_footprint[i].y *= scale;\n    }\n\n    // find the maximum footprint cost\n    double max_footprint_cost = 0.0;\n    for (unsigned int i = 0; i < scaled_footprint.size(); i++) {\n        double footprint_cost = costmap->getCost(scaled_footprint[i].x, scaled_footprint[i].y);\n        if (footprint_cost < 0)\n            footprint_cost = -6.0;\n        if (footprint_cost > max_footprint_cost)\n            max_footprint_cost = footprint_cost;\n    }\n\n    // find the maximum cell cost\n    double max_cell_cost = 0.0;\n    double cell_cost = costmap->getCost(x, y);\n    if (cell_cost < 0)\n        cell_cost = -6.0;\n    if (cell_cost > max_cell_cost)\n        max_cell_cost = cell_cost;\n\n    // return the maximum cost\n    if (max_footprint_cost > max_cell_cost)\n        return max_footprint_cost;\n    else\n        return max_cell_cost;\n}", "CodeBleu_score": 49.88001014656578}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\tif (!odom_topic.empty()) {\n\t\t\tros::NodeHandle n;\n\t\t\todom_sub_ = n.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t\todom_topic_ = odom_topic;\n\t}\n}", "CodeBleu_score": 44.395477104283046}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\tif (!odom_topic_.empty()) {\n\t\t\tros::NodeHandle nodeHandle;\n\t\t\tros::Subscriber sub = nodeHandle.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t\todom_sub_ = sub;\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t\todom_topic_ = odom_topic;\n\t}\n}", "CodeBleu_score": 52.83361188222997}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\tif (!odom_topic_.empty()) {\n\t\t\tros::NodeHandle n;\n\t\t\tn.shutdown();\n\t\t}\n\t\todom_topic_ = odom_topic;\n\t\tif (!odom_topic_.empty()) {\n\t\t\tros::NodeHandle n;\n\t\t\tros::Subscriber sub = n.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.7841477111645}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tdouble dist = (pos - prev).squaredNorm();\n\tdouble angle = fabs(pos.angle(prev));\n\tif (dist > oscillation_distance_threshold_ * oscillation_distance_threshold_ || angle > oscillation_angle_threshold_) {\n\t\toscillation_flags_ = 0;\n\t}\n}", "CodeBleu_score": 34.36289421076146}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tif (pos.squaredNorm() > oscillation_distance_threshold_ * oscillation_distance_threshold_ || std::abs(pos.z() - prev.z()) > oscillation_angle_threshold_) {\n\t\toscillation_flags_ = false;\n\t}\n}", "CodeBleu_score": 23.09726437258218}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tconst float sq_dist = (pos - prev).squaredNorm();\n\tconst float angle_diff = fabs(pos.angle(prev));\n\tif (sq_dist > oscillation_distance_threshold_ * oscillation_distance_threshold_ || angle_diff > oscillation_angle_threshold_) {\n\t\toscillation_flag_ = false;\n\t}\n}", "CodeBleu_score": 34.483057212174}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// ROS_DEBUG_STREAM(\"PointGrid::insert(\" << pt.x << \", \" << pt.y << \", \" << pt.z << \")\");\n\tint index = getIndex(pt.x, pt.y, pt.z);\n\tif (index < 0)\n\t\treturn;\n\tgrid[index].push_back(pt);\n}", "CodeBleu_score": 30.828864662548128}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//ROS_INFO(\"PointGrid::insert\");\n\t//ROS_INFO(\"pt.x=%f, pt.y=%f, pt.z=%f\", pt.x, pt.y, pt.z);\n\t//ROS_INFO(\"min_x=%f, max_x=%f, min_y=%f, max_y=%f, min_z=%f, max_z=%f\", min_x, max_x, min_y, max_y, min_z, max_z);\n\n\t//ROS_INFO(\"cell_size_x=%f, cell_size_y=%f, cell_size_z=%f\", cell_size_x, cell_size_y, cell_size_z);\n\t//ROS_INFO(\"grid_x=%d, grid_y=%d, grid_z=%d\", grid_x, grid_y, grid_z);\n\n\t//ROS_INFO(\"pt.x=%f, pt.y=%f, pt.z=%f\", pt.x, pt.y, pt.z);\n\t//ROS_INFO(\"min_x=%f, max_x=%f, min_y=%f, max_y=%f, min_z=%f, max_z=%f\", min_x, max_x, min_y, max_y, min_z, max_z);\n\n\t//ROS_INFO(\"cell_size_x=%f, cell_size_y=%f, cell_size_z=%f\", cell_size_x, cell_size_y, cell_size_z);\n\t//ROS_INFO(\"grid_x=%d, grid_y=%d, grid_z=%d\", grid_x, grid_y, grid_z);\n\n\t//ROS_INFO(\"pt.x=%f, pt.y=%f, pt.z=%f\", pt.x, pt.y, pt.z);\n\t//ROS_INFO(\"min_x=%f, max_x=%f, min_y=%f, max_y=%f, min_z=%f, max_z=%f\", min_x, max_x, min_y, max_y, min_z, max_z);\n\n\t//ROS_INFO(\"cell_size_x=%f, cell_", "CodeBleu_score": 5.111364122647389}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// calculate grid coordinates\n\tint x = (int) (pt.x / resolution_ + 0.5);\n\tint y = (int) (pt.y / resolution_ + 0.5);\n\n\t// check if the point is within the grid\n\tif (x < 0 || x >= grid_size_[0] || y < 0 || y >= grid_size_[1])\n\t\treturn;\n\n\t// calculate grid index\n\tint idx = x + y * grid_size_[0];\n\n\t// check if the point is too close to its nearest neighbor\n\tif (grid_[idx].size() > 0 && (pt.x - grid_[idx].back().x) * (pt.x - grid_[idx].back().x)\n\t\t\t+ (pt.y - grid_[idx].back().y) * (pt.y - grid_[idx].back().y) < min_dist_to_obstacle_sq_)\n\t\treturn;\n\n\t// insert point\n\tgrid_[idx].push_back(pt);\n}", "CodeBleu_score": 39.58962528030266}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tdouble current_vel = vel(i);\n\t\tdouble target_vel = sample_target_vel(i);\n\t\tdouble acc_limit = acclimits(i);\n\t\tdouble vel_diff = target_vel - current_vel;\n\t\tdouble vel_change = std::min(acc_limit * dt, std::min(vel_diff, 0.0));\n\t\tnew_vel(i) = current_vel + vel_change;\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 42.21628381995913}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\tnew_vel[0] = computeNewVelocity(sample_target_vel[0], vel[0], acclimits[0], dt);\n\tnew_vel[1] = computeNewVelocity(sample_target_vel[1], vel[1], acclimits[1], dt);\n\tnew_vel[2] = computeNewVelocity(sample_target_vel[2], vel[2], acclimits[2], dt);\n\treturn new_vel;\n}", "CodeBleu_score": 36.53851160257282}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tnew_vel[i] = vel[i] + (sample_target_vel[i] - vel[i]) * std::min(std::max(acclimits[i] / dt, 0.0), 1.0);\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 53.75796932602795}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = 0;\n\tdouble min_diff = DBL_MAX;\n\tdouble goal_x, goal_y;\n\n\t// Iterate through the global plan in reverse\n\tfor (int i = global_plan.size() - 1; i >= 0; i--) {\n\t\t// Check if the point is in the current cell\n\t\tif (global_plan[i].pose.position.x == cell_x && global_plan[i].pose.position.y == cell_y) {\n\t\t\t// Convert the cell coordinates to world coordinates\n\t\t\tgoal_x = global_plan[i].pose.position.x * resolution + origin_x;\n\t\t\tgoal_y = global_plan[i].pose.position.y * resolution + origin_y;\n\n\t\t\t// Calculate the difference in heading between the current heading and the direction to the goal point\n\t\t\tdiff = angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x));\n\n\t\t\t// If the difference is less than the minimum difference, update the minimum difference\n\t\t\tif (diff < min_diff) {\n\t\t\t\tmin_diff = diff;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min_diff;\n}", "CodeBleu_score": 54.76093721569064}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t// find the farthest point in the global plan that is reachable from the current position\n\tint farthest_idx = -1;\n\tdouble farthest_dist = 0.0;\n\tdouble dist = 0.0;\n\tdouble diff = 0.0;\n\n\tfor (int i = 0; i < global_plan_.size(); ++i) {\n\t\tdist = hypot(global_plan_[i].pose.pose.position.x - x, global_plan_[i].pose.pose.position.y - y);\n\t\tif (dist > farthest_dist) {\n\t\t\tfarthest_dist = dist;\n\t\t\tfarthest_idx = i;\n\t\t}\n\t}\n\n\tif (farthest_idx == -1) {\n\t\treturn DBL_MAX;\n\t}\n\n\t// check that the farthest point is valid\n\tif (!isPointValid(global_plan_[farthest_idx].pose.pose.position.x, global_plan_[farthest_idx].pose.pose.position.y, cell_x, cell_y)) {\n\t\treturn DBL_MAX;\n\t}\n\n\t// convert the goal point to the global frame\n\tgeometry_msgs::PoseStamped goal;\n\tgoal.header.frame_id = global_frame_;\n\tgoal.pose.position.x = x;\n\tgoal.pose.position.y = y;\n\tgoal.pose.position.z = 0.0;\n\tgoal.pose.orientation = tf2::createQuaternionMsgFromYaw(heading);\n\n\tgeometry_msgs::PoseStamped global_goal;\n\ttf2::doTransform(goal, global_goal, global_plan_[farthest_idx].pose);\n\n\t// find the difference between the current heading and the heading to the goal point\n\ttf2::Quaternion q1, q2;\n\ttf2::convert(goal.pose.orientation, q1);\n\ttf2::convert(global_goal.pose.orientation, q2);\n\n\ttf2::Matrix3x3 m(q1);\n\tdouble roll, pitch, yaw;\n\tm.getEulerYPR(yaw, pitch, roll);\n\n\tdouble angle1 = angles::normalize_angle", "CodeBleu_score": 43.307668281934475}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble best_dist = DBL_MAX;\n\tdouble best_angle = 0.0;\n\tdouble dx, dy;\n\tdouble dist, angle;\n\tfor (int i = 0; i < global_plan_.size(); i++) {\n\t\tdx = global_plan_[i].pose.pose.position.x - x;\n\t\tdy = global_plan_[i].pose.pose.position.y - y;\n\t\tdist = hypot(dx, dy);\n\t\tangle = angles::normalize_angle(atan2(dy, dx) - heading);\n\t\tif (dist < best_dist && angle > 0.0 && angle < M_PI) {\n\t\t\tbest_dist = dist;\n\t\t\tbest_angle = angle;\n\t\t}\n\t}\n\treturn best_angle;\n}", "CodeBleu_score": 45.84115903698655}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t// TODO: implement this function!\n\t// TODO: make sure to set the cost to a large negative number if you want to disallow the trajectory!\n\t// TODO: also make sure to set the trajectory to a null trajectory if you want to disallow the trajectory!\n\t// TODO: also make sure to set the velocity to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the time to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the distance to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the acceleration to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk_rate to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk_rate_rate to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk_rate_rate_rate to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk_rate_rate_rate_rate to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk_rate_rate_rate_rate_rate to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk_rate_rate_rate_rate_rate_rate to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk_rate_rate_rate_rate_rate_rate_rate to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk_rate_rate_rate_rate_rate_rate_rate_rate to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk_rate_rate_rate_rate_rate_rate_rate_rate_rate to zero if you want to disallow the trajectory!\n\t// TODO: also make sure to set the jerk_rate_rate_rate_rate_rate_rate_rate_rate_rate_", "CodeBleu_score": 10.2773716209011}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\tdouble cost;\n\tdouble temp_x, temp_y, temp_theta;\n\n\t// check if the trajectory is legal\n\tif (!isTrajectoryValid(x, y, theta, vx, vy, vtheta)) {\n\t\tROS_WARN(\"Trajectory Planner: The input trajectory is not valid.\");\n\t\treturn false;\n\t}\n\n\t// evaluate the trajectory using scoreTrajectory\n\tcost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, temp_x, temp_y, temp_theta);\n\n\t// check if the trajectory is legal\n\tif (!isTrajectoryValid(temp_x, temp_y, temp_theta, vx_samp, vy_samp, vtheta_samp)) {\n\t\tROS_WARN(\"Trajectory Planner: The sampled trajectory is not valid.\");\n\t\treturn false;\n\t}\n\n\t// check if the cost is negative\n\tif (cost < 0.0) {\n\t\tROS_WARN(\"Trajectory Planner: The sampled trajectory is not valid. Cost: %f, vx: %f, vy: %f, vtheta: %f\", cost, vx_samp, vy_samp, vtheta_samp);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 59.99203390496276}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t//ROS_ERROR_STREAM(\"checkTrajectory\");\n\t//ROS_ERROR_STREAM(\"x:\" << x << \" y:\" << y << \" theta:\" << theta << \" vx:\" << vx << \" vy:\" << vy << \" vtheta:\" << vtheta << \" vx_samp:\" << vx_samp << \" vy_samp:\" << vy_samp << \" vtheta_samp:\" << vtheta_samp);\n  //ROS_ERROR_STREAM(\"checkTrajectory\");\n  //ROS_ERROR_STREAM(\"x:\" << x << \" y:\" << y << \" theta:\" << theta << \" vx:\" << vx << \" vy:\" << vy << \" vtheta:\" << vtheta << \" vx_samp:\" << vx_samp << \" vy_samp:\" << vy_samp << \" vtheta_samp:\" << vtheta_samp);\n  //ROS_ERROR_STREAM(\"checkTrajectory\");\n  //ROS_ERROR_STREAM(\"x:\" << x << \" y:\" << y << \" theta:\" << theta << \" vx:\" << vx << \" vy:\" << vy << \" vtheta:\" << vtheta << \" vx_samp:\" << vx_samp << \" vy_samp:\" << vy_samp << \" vtheta_samp:\" << vtheta_samp);\n  //ROS_ERROR_STREAM(\"checkTrajectory\");\n  //ROS_ERROR_STREAM(\"x:\" << x << \" y:\" << y << \" theta:\" << theta << \" vx:\" << vx << \" vy:\" << vy << \" vtheta:\" << vtheta << \" vx_samp:\" << vx_samp << \" vy_samp:\" << vy_samp << \" vtheta_samp:\" << vtheta_samp);\n  //ROS_ERROR_STREAM(\"checkTrajectory\");\n  //ROS_ERROR_STREAM(\"x:\" << x << \" y:\" << y << \" theta:\" << theta << \" vx:\" << vx << \" vy:\" << vy << \" vtheta:\" << vtheta << \" vx_samp:\" << vx_samp << \" vy_samp:\" << vy_samp << \" vtheta_samp:\" << vtheta_samp);\n  //ROS_ERROR_STREAM(\"checkTrajectory\");\n  //ROS_ERROR_STREAM(\"x:\" << x << \" y:\" << y << \" theta:\" << theta << \" vx:\" << vx << \" vy:\" << vy << \" vtheta:\" << vtheta << \" vx_samp:\" << vx_samp << \" vy_samp:\"", "CodeBleu_score": 10.814023965817519}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before it can run.\");\n\t\treturn;\n\t}\n\n\tif (costmap_clearer_ == NULL) {\n\t\tROS_ERROR(\"The costmap_clearer_ is NULL.  Please make sure the costmaps are initialized before calling this object.\");\n\t\treturn;\n\t}\n\n\tif (costmap_clearer_->getCostmap() == NULL) {\n\t\tROS_ERROR(\"The costmap_clearer_ has no costmap.  Please make sure the costmaps are initialized before calling this object.\");\n\t\treturn;\n\t}\n\n\tif (costmap_clearer_->getCostmap()->getSizeInCellsX() == 0 || costmap_clearer_->getCostmap()->getSizeInCellsY() == 0) {\n\t\tROS_ERROR(\"The costmap_clearer_ has no size.  Please make sure the costmaps are initialized before calling this object.\");\n\t\treturn;\n\t}\n\n\tif (costmap_clearer_->getCostmap()->isSizeLocked()) {\n\t\tROS_ERROR(\"The costmap_clearer_ has locked size.  Please make sure the costmaps are initialized before calling this object.\");\n\t\treturn;\n\t}\n\n\tif (costmap_clearer_->getCostmap()->isOriginLocked()) {\n\t\tROS_ERROR(\"The costmap_clearer_ has locked origin.  Please make sure the costmaps are initialized before calling this object.\");\n\t\treturn;\n\t}\n\n\tif (costmap_clearer_->getCostmap()->isSizeLocked()) {\n\t\tROS_ERROR(\"The costmap_clearer_ has locked size.  Please make sure the costmaps are initialized before calling this object.\");\n\t\treturn;\n\t}\n\n\tif (costmap_clearer_->getCostmap()->isSizeLocked()) {\n\t\tROS_ERROR(\"The costmap_clearer_ has locked size.  Please make sure the costmaps are initialized before calling this object.\");\n\t\treturn;\n\t}\n\n\tif (costmap_clearer_->getCostmap()->isSizeLocked()) {\n\t\tROS_ERROR(\"The costmap_clearer_ has locked size.  Please make sure the costmaps are initialized before calling this object.\");\n\t\treturn;\n\t}\n\n\tif (costmap_clearer", "CodeBleu_score": 23.405950190260487}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tros::NodeHandle n;\n\tros::NodeHandle private_nh(\"~\");\n\n\t// Check if the object is initialized\n\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This object must be initialized before it can run. Please call initialize() before runBehavior().\");\n\t\treturn;\n\t}\n\n\t// Check if the costmaps are not NULL\n\tif (!global_costmap_ ||!local_costmap_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This object must be initialized with valid costmaps before it can run. Please call initialize() with valid costmaps before runBehavior().\");\n\t\treturn;\n\t}\n\n\t// Log a warning about clearing inside or outside a specified area\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\n\t\t\t\t\"Clearing inside the specified area. This can be dangerous, as it can result in clearing the entire map.\");\n\t}\n\n\t// Clear the global costmap\n\tif (affected_maps_.find(\"global\")!= affected_maps_.end()) {\n\t\tros::Time start_time = ros::Time::now();\n\t\tglobal_costmap_->clearCostmap();\n\t\tros::Time end_time = ros::Time::now();\n\t\tdouble elapsed_time = (end_time - start_time).toSec();\n\t\tROS_INFO(\n\t\t\t\t\"Global costmap cleared in %f seconds.\", elapsed_time);\n\t}\n\n\t// Clear the local costmap\n\tif (affected_maps_.find(\"local\")!= affected_maps_.end()) {\n\t\tros::Time start_time = ros::Time::now();\n\t\tlocal_costmap_->clearCostmap();\n\t\tros::Time end_time = ros::Time::now();\n\t\tdouble elapsed_time = (end_time - start_time).toSec();\n\t\tROS_INFO(\n\t\t\t\t\"Local costmap cleared in %f seconds.\", elapsed_time);\n\t}\n}", "CodeBleu_score": 45.198200805653464}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This object must be initialized before it may be used.\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\n\t\t\t\t\"This object must have a valid costmap before it may be used.\");\n\t\treturn;\n\t}\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\n\t\t\t\t\"Clearing inside the specified area. This may not be what you want.\");\n\t}\n\n\tdouble time_start = ros::Time::now().toSec();\n\tif (affected_maps_ == CLEAR_ALL_MAPS) {\n\t\tROS_INFO(\"Clearing global and local costmaps.\");\n\t\tglobal_costmap_->clearCostmap();\n\t\tlocal_costmap_->clearCostmap();\n\t} else if (affected_maps_ == CLEAR_LOCAL_ONLY) {\n\t\tROS_INFO(\"Clearing local costmap.\");\n\t\tlocal_costmap_->clearCostmap();\n\t} else if (affected_maps_ == CLEAR_GLOBAL_ONLY) {\n\t\tROS_INFO(\"Clearing global costmap.\");\n\t\tglobal_costmap_->clearCostmap();\n\t}\n\tROS_INFO(\"Clearing took %f seconds.\", ros::Time::now().toSec() - time_start);\n}", "CodeBleu_score": 40.29461718375735}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t//printf(\"polygonOutlineCells", "CodeBleu_score": 5.03436411213963}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells outline_cells;\n\tMapLocation start_point, end_point;\n\tint num_points = polygon.size();\n\n\tfor (int i = 0; i < num_points; i++) {\n\t\tstart_point = polygon[i];\n\t\tif (i == num_points - 1) {\n\t\t\tend_point = polygon[0];\n\t\t} else {\n\t\t\tend_point = polygon[i + 1];\n\t\t}\n\n\t\toutline_cells.addCells(start_point, end_point);\n\t}\n\n\toutline_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 41.48329659847533}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t//printf(\"polygonOutlineCells\n\");\n\t//printf(\"polygon.size() = %d\n\", polygon.size());\n\t//printf(\"polygon.size() = %d\n\", polygon.size());\n\tPolygonOutlineCells polygon_outline_cells;\n\tfor (int i = 0; i < polygon.size(); i++) {\n\t\tMapLocation p1 = polygon[i];\n\t\tMapLocation p2 = polygon[(i + 1) % polygon.size()];\n\t\t//printf(\"p1 = (%d, %d)\n\", p1.x, p1.y);\n\t\t//printf(\"p2 = (%d, %d)\n\", p2.x, p2.y);\n\t\tpolygon_outline_cells.addLine(p1, p2);\n\t}\n\tpolygon_outline_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 42.728906240155986}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t// TODO: This function is not used in the current implementation.\n\t// It is left here to serve as an example of how to use the Costmap2DPublisher class.\n\t// You will need to modify this function to publish the prepared grid to the new subscriber.\n\t// You will also need to modify the Costmap2DPublisher::prepareGrid function to set up the grid data.\n\n\t// This function is called when a new subscriber is connected to the costmap_2d/costmap topic.\n\t// It prepares the grid data and publishes it to the new subscriber.\n\n\t// Get the publisher for the new subscriber.\n\t// The publisher will be used to publish the prepared grid.\n\tros::Publisher publisher = pub.getPublisher();\n\n\t// Get the new subscriber's topic name.\n\t// The topic name is used to set the name of the prepared grid.\n\tstd::string topic_name = pub.getTopic();\n\n\t// Prepare the grid data.\n\t// This function sets up the grid data and returns the prepared grid.\n\t// The prepared grid is used to publish the prepared grid to the new subscriber.\n\tcostmap_2d::Costmap2D* prepared_grid = prepareGrid(topic_name);\n\n\t// Publish the prepared grid to the new subscriber.\n\t// The publisher and the prepared grid are used to publish the prepared grid to the new subscriber.\n\tpublisher.publish(*prepared_grid);\n\n\t// Delete the prepared grid.\n\tdelete prepared_grid;\n}", "CodeBleu_score": 45.44810927645462}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//std::cout << \"onNewSubscription\" << std::endl;\n\t//", "CodeBleu_score": 10.99494785012753}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tif (!is_enabled_) {\n\t\treturn;\n\t}\n\n\t// Prepare the grid data\n\tprepareGrid();\n\n\t// Publish the grid\n\tpub.publish(grid_);\n}", "CodeBleu_score": 67.34504610477113}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the mutex\n\tmutex_.lock();\n\n\t// Get the resolution\n\tresolution_ = costmap_.getResolution();\n\n\t// Set the header\n\theader_.frame_id = costmap_.getGlobalFrameID();\n\theader_.stamp = ros::Time::now();\n\n\t// Set the resolution\n\tresolution_ = costmap_.getResolution();\n\n\t// Set the width and height\n\twidth_ = costmap_.getSizeInCellsX();\n\theight_ = costmap_.getSizeInCellsY();\n\n\t// Set the origin\n\torigin_x_ = costmap_.getOriginX();\n\torigin_y_ = costmap_.getOriginY();\n\n\t// Set the origin\n\torigin_.position.x = origin_x_;\n\torigin_.position.y = origin_y_;\n\torigin_.position.z = 0.0;\n\n\t// Set the orientation\n\torigin_.orientation.x = 0.0;\n\torigin_.orientation.y = 0.0;\n\torigin_.orientation.z = 0.0;\n\torigin_.orientation.w = 1.0;\n\n\t// Resize the data vector\n\tdata_.resize(width_ * height_);\n\n\t// Unlock the mutex\n\tmutex_.unlock();\n}", "CodeBleu_score": 34.02681405406017}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// TODO: Implement this function\n\t//std::cout << \"Costmap2DPublisher::prepareGrid\" << std::endl;\n\n\t// Lock the mutex\n\tmutex_.lock();\n\n\t// Retrieve the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header\n\theader_.frame_id = costmap_->getGlobalFrameID();\n\theader_.stamp = ros::Time::now();\n\n\t// Set the grid's resolution, width, and height\n\tresolution_ = resolution;\n\twidth_ = costmap_->getSizeInCellsX();\n\theight_ = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\torigin_x_ = costmap_->getOriginX();\n\torigin_y_ = costmap_->getOriginY();\n\torigin_z_ = 0.0;\n\n\t// Set the origin's position and orientation\n\tgeometry_msgs::Pose origin_pose;\n\torigin_pose.position.x = origin_x_;\n\torigin_pose.position.y = origin_y_;\n\torigin_pose.position.z = origin_z_;\n\torigin_pose.orientation.x = 0.0;\n\torigin_pose.orientation.y = 0.0;\n\torigin_pose.orientation.z = 0.0;\n\torigin_pose.orientation.w = 1.0;\n\n\t// Save the origin coordinates\n\torigin_ = origin_pose;\n\n\t// Resize the grid data vector\n\tdata_.resize(width_ * height_);\n\n\t// Unlock the mutex\n\tmutex_.unlock();\n}", "CodeBleu_score": 37.099251841409384}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tROS_DEBUG_NAMED(\"costmap_2d_publisher\", \"Preparing grid\");\n\tros::Time now = ros::Time::now();\n\tif (!costmap_) {\n\t\tROS_ERROR_NAMED(\"costmap_2d_publisher\", \"Costmap2DPublisher::prepareGrid() called with no costmap_\");\n\t\treturn;\n\t}\n\t// Get the resolution\n\tdouble resolution = costmap_->getResolution();\n\t// Set the grid's header\n\tgrid_.header.stamp = now;\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\t// Set the grid's resolution\n\tgrid_.info.resolution = resolution;\n\t// Set the grid's width and height\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\t// Set the grid's origin\n\tdouble x, y, yaw;\n\tcostmap_->getRobotPose(x, y, yaw);\n\tgrid_.info.origin.position.x = x;\n\tgrid_.info.origin.position.y = y;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation = tf::createQuaternionMsgFromYaw(yaw);\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (int i = 0; i < grid_.info.width * grid_.info.height; ++i) {\n\t\tint mx = i % grid_.info.width;\n\t\tint my = i / grid_.info.width;\n\t\tunsigned char value = costmap_->getCost(mx, my);\n\t\tgrid_.data[i] = static_cast<unsigned char>(value);\n\t}\n}", "CodeBleu_score": 53.381470847745895}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.robot_radius!= old_config.robot_radius) {\n\t\tif (new_config.robot_radius > 0.0) {\n\t\t\tif (new_config.footprint.empty()) {\n\t\t\t\tROS_INFO(\"Setting footprint to default circular robot shape with radius %f\", new_config.robot_radius);\n\t\t\t\tsetRobotFootprint(std::vector<geometry_msgs::Point>({ {0.0, 0.0}, {new_config.robot_radius, 0.0}, {new_config.robot_radius, new_config.robot_radius}, {0.0, new_config.robot_radius}, {-new_config.robot_radius, new_config.robot_radius}, {-new_config.robot_radius, 0.0}, {-new_config.robot_radius, -new_config.robot_radius}, {0.0, -new_config.robot_radius} }));\n\t\t\t} else {\n\t\t\t\tROS_INFO(\"Setting footprint to default circular robot shape with radius %f\", new_config.robot_radius);\n\t\t\t\tsetRobotFootprint(std::vector<geometry_msgs::Point>({ {0.0, 0.0}, {new_config.robot_radius, 0.0}, {new_config.robot_radius, new_config.robot_radius}, {0.0, new_config.robot_radius}, {-new_config.robot_radius, new_config.robot_radius}, {-new_config.robot_radius, 0.0}, {-new_config.robot_radius, -new_config.robot_radius}, {0.0, -new_config.robot_radius} }));\n\t\t\t}\n\t\t} else {\n\t\t\tROS_ERROR(\"Robot radius must be greater than 0.0\");\n\t\t}\n\t}\n\tif (new_config.footprint!= old_config.footprint) {\n\t\tif (!new_config.footprint.empty()) {\n\t\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\t\tif (parseFootprint(new_config.footprint, footprint)) {\n\t\t\t\tsetRobotFootprint(footprint);\n\t\t\t} else {\n\t\t\t\tROS_ERROR(\"Invalid footprint string: %s\", new_config.footprint.c", "CodeBleu_score": 51.09409824258042}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint == old_config.footprint) {\n\t\treturn;\n\t}\n\n\tif (new_config.footprint.empty()) {\n\t\t// if footprint is empty, set the footprint based on the robot radius\n\t\tif (new_config.robot_radius > 0.0) {\n\t\t\t// set the footprint to the robot radius\n\t\t\tsetRobotFootprint(new_config.robot_radius);\n\t\t} else {\n\t\t\tROS_ERROR(\"Costmap2DROS: Invalid robot radius in costmap configuration\");\n\t\t}\n\t} else {\n\t\t// if footprint is not empty, parse the footprint string\n\t\ttry {\n\t\t\t// set the footprint based on the footprint string\n\t\t\tsetRobotFootprint(new_config.footprint);\n\t\t} catch (const std::runtime_error &ex) {\n\t\t\tROS_ERROR(\"Costmap2DROS: Invalid footprint string in costmap configuration\");\n\t\t}\n\t}\n}", "CodeBleu_score": 50.28305539353881}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\tif (new_config.footprint.empty()) {\n\t\tfootprint_ = getRobotFootprint(new_config.robot_radius);\n\t} else {\n\t\tstd::vector<geometry_msgs::Point> points;\n\t\ttry {\n\t\t\tgeometry_msgs::Polygon p;\n\t\t\tif (!geometry_msgs::fromMsg(new_config.footprint, p)) {\n\t\t\t\tROS_ERROR(\"Invalid footprint string\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpoints.insert(points.end(), p.points.begin(), p.points.end());\n\t\t} catch (tf2::TransformException &ex) {\n\t\t\tROS_ERROR(\"Transform exception: %s\", ex.what());\n\t\t\treturn;\n\t\t}\n\t\tfootprint_ = points;\n\t}\n\tfootprint_spec_ = new_config.footprint;\n\tROS_INFO(\"Footprint set to: %s\", footprint_spec_.c_str());\n}", "CodeBleu_score": 51.655823493367215}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (initialized_) {\n\t\tif (!getRobotPose(new_pose_)) {\n\t\t\tROS_WARN(\"Failed to get robot pose\");\n\t\t\tcancelReconfigure();\n\t\t}\n\t}\n}", "CodeBleu_score": 25.948010507739895}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tros::Time start_time = ros::Time::now();\n\n\tif (!current_pose_sub_.hasCallback()) {\n\t\tROS_WARN(\"No pose callback registered, unable to update costmap.\");\n\t\treturn;\n\t}\n\n\tif (!current_pose_sub_.tryReceive(current_pose_)) {\n\t\tROS_WARN(\"Failed to receive current pose, unable to update costmap.\");\n\t\treturn;\n\t}\n\n\tif (!new_pose_.setFromMsg(current_pose_)) {\n\t\tROS_WARN(\"Failed to set new pose from current pose, unable to update costmap.\");\n\t\treturn;\n\t}\n\n\tif (!current_vel_sub_.hasCallback()) {\n\t\tROS_WARN(\"No velocity callback registered, unable to update costmap.\");\n\t\treturn;\n\t}\n\n\tif (!current_vel_sub_.tryReceive(current_vel_)) {\n\t\tROS_WARN(\"Failed to receive current velocity, unable to update costmap.\");\n\t\treturn;\n\t}\n\n\tif (!new_vel_.setFromMsg(current_vel_)) {\n\t\tROS_WARN(\"Failed to set new velocity from current velocity, unable to update costmap.\");\n\t\treturn;\n\t}\n\n\tif (!current_costmap_ros_->getRobotPose(new_pose_)) {\n\t\tROS_WARN(\"Failed to get robot pose, unable to update costmap.\");\n\t\treturn;\n\t}\n\n\tif (!current_costmap_ros_->getRobotVel(new_vel_)) {\n\t\tROS_WARN(\"Failed to get robot velocity, unable to update costmap.\");\n\t\treturn;\n\t}\n\n\tif (!current_costmap_ros_->isCurrent()) {\n\t\tROS_WARN(\"Costmap is not current, unable to update costmap.\");\n\t\treturn;\n\t}\n\n\tif (!current_costmap_ros_->updateMap(new_pose_, new_vel_)) {\n\t\tROS_WARN(\"Failed to update costmap, unable to update costmap.\");\n\t\treturn;\n\t}\n\n\tROS_DEBUG(\"Updated costmap in %f seconds.\", (ros::Time::now() - start_time).toSec());\n}", "CodeBleu_score": 39.949938568137725}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN(\"Failed to get robot pose\");\n\t\treturn;\n\t}\n\tif (!getRobotVel(new_vel)) {\n\t\tROS_WARN(\"Failed to get robot velocity\");\n\t\treturn;\n\t}\n\tif (new_vel.linear.x == 0.0 && new_vel.angular.z == 0.0) {\n\t\treturn;\n\t}\n\tif (new_vel.linear.x < 0.0) {\n\t\tnew_vel.linear.x = 0.0;\n\t}\n\tif (new_vel.angular.z < 0.0) {\n\t\tnew_vel.angular.z = 0.0;\n\t}\n\tif (new_vel.linear.x > max_vel_x_) {\n\t\tnew_vel.linear.x = max_vel_x_;\n\t}\n\tif (new_vel.angular.z > max_vel_th_) {\n\t\tnew_vel.angular.z = max_vel_th_;\n\t}\n\tif (new_vel.linear.x < min_vel_x_) {\n\t\tnew_vel.linear.x = min_vel_x_;\n\t}\n\tif (new_vel.angular.z < min_vel_th_) {\n\t\tnew_vel.angular.z = min_vel_th_;\n\t}\n\tif (new_vel.linear.x == 0.0 && new_vel.angular.z == 0.0) {\n\t\treturn;\n\t}\n\tif (new_vel.linear.x == 0.0) {\n\t\tnew_vel.angular.z = 0.0;\n\t}\n\tif (new_vel.angular.z == 0.0) {\n\t\tnew_vel.linear.x = 0.0;\n\t}\n\tif (new_vel.linear.x!= 0.0 && new_vel.angular.z!= 0.0) {\n\t\tnew_vel.linear.x = new_vel.linear.x * cos(new_vel.angular.z) + new_vel.angular.z * sin(new_vel.angular.z", "CodeBleu_score": 43.7327809980219}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\tROS_INFO(\"Starting costmap with plugin: %s\", get_global_frame().c_str());\n\n\tif (stop_updates_) {\n\t\tROS_WARN(\"Costmap is being restarted by the server, however this is not supported and could result in unpredictable behavior\");\n\t}\n\n\tif (stopped_) {\n\t\tROS_INFO(\"Re-activating costmap plugins\");\n\t\tfor (auto plugin : plugins_) {\n\t\t\tplugin->activate();\n\t\t}\n\t}\n\n\tstop_updates_ = false;\n\n\tif (initialized_) {\n\t\treturn;\n\t}\n\n\tros::Rate r(10);\n\n\twhile (!ros::isStarted()) {\n\t\tr.sleep();\n\t}\n\n\tinitialized_ = true;\n\n\twhile (!map_received_) {\n\t\tr.sleep();\n\t}\n\n\twhile (!update_thread_) {\n\t\tr.sleep();\n\t}\n}", "CodeBleu_score": 40.54082249720388}, {"code": "void Costmap2DROS::start(){\n\t\t// TODO Auto-generated constructor stub\n\t//ROS_INFO(\"Costmap2DROS::start\");\n\t//ROS_INFO(\"Costmap2DROS::start: start\");\n\n\t//ROS_INFO(\"Costmap2DROS::start: start: plugins\");\n\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %d\", plugins_.size());\n\tfor (unsigned int i = 0; i < plugins_.size(); ++i) {\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %d\", i);\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %d\", plugins_[i].name);\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t//ROS_INFO(\"Costmap2DROS::start: start: plugins: %s\", plugins_[i].name.c_str());\n\t\t", "CodeBleu_score": 14.403003844192083}, {"code": "void Costmap2DROS::start(){\n\t\tROS_DEBUG(\"Starting costmap\");\n\n\t// Get the list of plugins\n\tstd::vector<std::string> plugins = layered_costmap_->getPlugins();\n\n\t// Check if the costmap was stopped\n\tif (stopped_) {\n\t\t// Reactivate the plugins\n\t\tfor (unsigned int i = 0; i < plugins.size(); ++i) {\n\t\t\tlayered_costmap_->activatePlugin(plugins[i]);\n\t\t}\n\n\t\t// Set the stopped flag to false\n\t\tstopped_ = false;\n\n\t\t// Set stop_updates_ to false\n\t\tstop_updates_ = false;\n\t}\n\n\t// Wait until ROS is running, the costmap is initialized, and the map update thread is active\n\twhile (!ros::isInitialized() ||!layered_costmap_->isCurrent() ||!map_update_thread_->isActive()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// Publish the map\n\tpublishCostmap();\n\n\t// Start the map update thread\n\tmap_update_thread_->start();\n}", "CodeBleu_score": 50.01606464160654}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// TODO Auto-generated destructor stub\n}", "CodeBleu_score": 1.543726824886217}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == 0) {\n\t\tobservations_.clear();\n\t\treturn;\n\t}\n\n\t// Find the most recent observation\n\tObservation* last_observation = NULL;\n\tfor (Observation* observation : observations_) {\n\t\tif (last_observation == NULL || observation->time > last_observation->time) {\n\t\t\tlast_observation = observation;\n\t\t}\n\t}\n\n\t// Remove observations that are older than the keep time\n\tif (last_observation!= NULL) {\n\t\twhile (last_observation->time < ros::Time::now() - observation_keep_time_) {\n\t\t\tobservations_.remove(last_observation);\n\t\t\tlast_observation = NULL;\n\t\t\tfor (Observation* observation : observations_) {\n\t\t\t\tif (last_observation == NULL || observation->time > last_observation->time) {\n\t\t\t\t\tlast_observation = observation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.61435592612586}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If the observation_keep_time_ is zero, it keeps only the most recent observation.\n\tif (observation_keep_time_ == 0) {\n\t\tobservations_.clear();\n\t} else {\n\t\t// Otherwise, it iterates through the list and removes observations that are older than the specified keep time, stopping once it finds a valid observation.\n\t\twhile (!observations_.empty()) {\n\t\t\tObservationPtr observation = observations_.front();\n\t\t\tif (observation->getObservationTime() + observation_keep_time_ > ros::Time::now())\n\t\t\t\tbreak;\n\t\t\tobservations_.pop_front();\n\t\t}\n\t}\n}", "CodeBleu_score": 27.90925965128662}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Get the start and end orientations\n\tdouble start_orientation = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_orientation = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Compute the shortest angular distance between the start and end orientations\n\tdouble angular_distance = angles::shortest_angular_distance(start_orientation, end_orientation);\n\n\t// Compute the incremental change in angle for each pose in the range\n\tdouble delta_angle = angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the range\n\tfor (int i = start_index; i < end_index; i++) {\n\t\tdouble current_orientation = tf2::getYaw(path[i].pose.orientation);\n\t\tdouble new_orientation = current_orientation + delta_angle;\n\t\tpath[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), new_orientation));\n\t}\n}", "CodeBleu_score": 55.4045236049012}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Get the start and end indices of the path\n\tint start = start_index;\n\tint end = end_index;\n\n\t// Get the start and end orientations of the path\n\ttf2::Quaternion start_orientation(path[start].pose.orientation.x, path[start].pose.orientation.y, path[start].pose.orientation.z, path[start].pose.orientation.w);\n\ttf2::Quaternion end_orientation(path[end].pose.orientation.x, path[end].pose.orientation.y, path[end].pose.orientation.z, path[end].pose.orientation.w);\n\n\t// Get the yaw angles at the start and end indices\n\tdouble start_yaw = tf2::getYaw(start_orientation);\n\tdouble end_yaw = tf2::getYaw(end_orientation);\n\n\t// Get the shortest angular distance between the start and end yaw angles\n\tdouble delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Calculate the incremental change in angle for each pose in the specified range\n\tfor (int i = start + 1; i < end; i++) {\n\t\ttf2::Quaternion orientation(path[i].pose.orientation.x, path[i].pose.orientation.y, path[i].pose.orientation.z, path[i].pose.orientation.w);\n\t\tdouble yaw = tf2::getYaw(orientation);\n\t\tdouble delta_yaw_i = angles::shortest_angular_distance(yaw, start_yaw);\n\t\tdouble delta_yaw_i_normalized = delta_yaw_i / delta_yaw;\n\t\tdouble yaw_i = start_yaw + delta_yaw_i_normalized * delta_yaw;\n\t\ttf2::Quaternion yaw_i_orientation = tf2::Quaternion(0, 0, yaw_i, 1);\n\t\tpath[i].pose.orientation = tf2::toMsg(yaw_i_orientation);\n\t}\n}", "CodeBleu_score": 44.610415035752396}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// check if there are enough poses in the path\n\tif (end_index - start_index < 1) {\n\t\tROS_ERROR(\"Error in OrientationFilter::interpolate: start_index and end_index must be different and at least 1.\");\n\t\treturn;\n\t}\n\n\t// get start and end yaw angles\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// calculate shortest angular distance between start and end yaw angles\n\tdouble angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// calculate incremental change in angle for each pose in the specified range\n\tdouble increment = angular_distance / (end_index - start_index);\n\n\t// update orientation of each pose in the specified range\n\tfor (int i = start_index; i <= end_index; i++) {\n\t\tdouble new_yaw = start_yaw + increment * (i - start_index);\n\t\ttf2::Quaternion new_quat;\n\t\ttf2::convert(tf2::Quaternion(0, 0, new_yaw), new_quat);\n\t\tpath[i].pose.orientation = tf2::toMsg(new_quat);\n\t}\n}", "CodeBleu_score": 63.415512163966326}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t//set start and goal to map frame\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t//make plan\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tbool found_path = makePlan(req.start, req.goal, plan);\n\n\t//update response\n\tresp.plan.poses.resize(plan.size());\n\tfor (unsigned int i = 0; i < plan.size(); i++) {\n\t\tresp.plan.poses[i] = plan[i];\n\t}\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.found_path = found_path;\n\n\treturn true;\n}", "CodeBleu_score": 61.994154940298344}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tmakePlan(req.start, req.goal, resp.plan);\n\n\t// Update the response with the success status and the generated path if a plan is found\n\tif (resp.plan.poses.size() > 0) {\n\t\tresp.success = true;\n\t} else {\n\t\tresp.success = false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.908842734573845}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a plan request for the following start and goal poses:\");\n\tROS_INFO(\"Start: (%.2f, %.2f)\", req.start.pose.position.x, req.start.pose.position.y);\n\tROS_INFO(\"Goal:  (%.2f, %.2f)\", req.goal.pose.position.x, req.goal.pose.position.y);\n\n\tgeometry_msgs::PoseStamped start = req.start;\n\tgeometry_msgs::PoseStamped goal = req.goal;\n\n\t// Clear the plan, just in case\n\tplan_.clear();\n\n\t// Set the frame_id of the start and goal to \"map\"\n\tstart.header.frame_id = \"map\";\n\tgoal.header.frame_id = \"map\";\n\n\t// Call the planner to find a path\n\tmakePlan(start, goal, plan_);\n\n\t// Check if a valid plan was found\n\tif (plan_.empty()) {\n\t\tROS_WARN(\"Failed to find a plan to point (%.2f, %.2f)\", goal.pose.position.x, goal.pose.position.y);\n\t\tresp.plan.poses.clear();\n\t\tresp.success = false;\n\t\treturn true;\n\t}\n\n\t// Copy the plan into the response\n\tresp.plan.poses.resize(plan_.size());\n\tfor (unsigned int i = 0; i < plan_.size(); i++) {\n\t\tresp.plan.poses[i].pose.position.x = plan_[i].pose.position.x;\n\t\tresp.plan.poses[i].pose.position.y = plan_[i].pose.position.y;\n\t\tresp.plan.poses[i].pose.position.z = plan_[i].pose.position.z;\n\t\tresp.plan.poses[i].pose.orientation.x = plan_[i].pose.orientation.x;\n\t\tresp.plan.poses[i].pose.orientation.y = plan_[i].pose.orientation.y;\n\t\tresp.plan.poses[i].pose.orientation.z = plan_[i].pose.orientation.z;\n\t\tresp.plan.poses[i].pose.orientation.w = plan_[i].pose.orientation.w;", "CodeBleu_score": 41.41737244466693}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\"~/\" + name);\n\tprivate_nh.param(\"planner_frequency\", planner_frequency, 0.0);\n\tprivate_nh.param(\"sim_time\", sim_time, 1.0);\n\tprivate_nh.param(\"sim_granularity\", sim_granularity, 0.01);\n\tprivate_nh.param(\"angular_sim_granularity\", angular_sim_granularity, 0.02);\n\tprivate_nh.param(\"planning_time\", planning_time, 1.0);\n\tprivate_nh.param(\"publish_cost_grid_pc\", publish_cost_grid_pc, false);\n\tprivate_nh.param(\"publish_voxel_grid_pc\", publish_voxel_grid_pc, false);\n\tprivate_nh.param(\"publish_plan_pc\", publish_plan_pc, false);\n\tprivate_nh.param(\"publish_cost_pc\", publish_cost_pc, false);\n\tprivate_nh.param(\"publish_voxel_pc\", publish_voxel_pc, false);\n\tprivate_nh.param(\"publish_potential_pc\", publish_potential_pc, false);\n\tprivate_nh.param(\"publish_plan_pc_in_global_frame\", publish_plan_pc_in_global_frame, false);\n\tprivate_nh.param(\"publish_cost_pc_in_global_frame\", publish_cost_pc_in_global_frame, false);\n\tprivate_nh.param(\"publish_voxel_pc_in_global_frame\", publish_voxel_pc_in_global_frame, false);\n\tprivate_nh.param(\"publish_potential_pc_in_global_frame\", publish_potential_pc_in_global_frame, false);\n\tprivate_nh.param(\"publish_cost_pc_in_map_frame\", publish_cost_pc_in_map_frame, false);\n\tprivate_nh.param(\"publish_voxel_pc_in_map_frame\", publish_voxel_pc_in_map_frame, false);\n\tprivate_nh.param(\"publish_potential_pc_in_map_frame\", publish_potential_pc_in_map_frame, false);\n\tprivate_", "CodeBleu_score": 33.98813226073192}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\t// TODO Auto-generated constructor stub\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n\t//ROS_INFO(\"PlannerWithCostmap", "CodeBleu_score": 18.4378864640995}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n    // Initialize private node handle\n    private_nh.reset(new ros::NodeHandle(\"~/\" + name));\n\n    // Initialize planner's private node handle\n    planner_nh.reset(new ros::NodeHandle(\"~/\" + name));\n\n    // Set up a service to get a plan from a start and goal\n    planner_service = planner_nh->advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n    // Set up a subscriber to get a goal\n    goal_sub = planner_nh->subscribe(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n\n    // Set up a subscriber to get a start\n    start_sub = planner_nh->subscribe(\"start\", 1, &PlannerWithCostmap::startCB, this);\n\n    // Initialize the costmap2d global planner\n    costmap_2d_planner_ = boost::shared_ptr<navfn::Costmap2DPlanner>(new navfn::Costmap2DPlanner(cmap->getCostmap()));\n}", "CodeBleu_score": 53.409321550383424}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 41.085239240253316}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\t// Check if the world coordinates are within the bounds of the costmap's origin.\n\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n\t\tROS_WARN(\"The world coordinates (%f, %f) are outside the costmap's bounds.\", wx, wy);\n\t\treturn false;\n\t}\n\n\t// Calculate the map coordinates using the costmap's resolution and an offset.\n\tdouble resolution = costmap_->getResolution();\n\tdouble origin_x = costmap_->getOriginX();\n\tdouble origin_y = costmap_->getOriginY();\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\n\t// Check if the map coordinates are within the costmap's size limits.\n\tif (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n\t\tROS_WARN(\"The map coordinates (%f, %f) are outside the costmap's size limits.\", mx, my);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 63.5018047470859}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < world_model_->getOriginX() || wx > world_model_->getOriginX() + world_model_->getSizeInMetersX() || wy < world_model_->getOriginY() || wy > world_model_->getOriginY() + world_model_->getSizeInMetersY()) {\n\t\treturn false;\n\t}\n\tmx = (wx - world_model_->getOriginX()) * resolution_;\n\tmy = (wy - world_model_->getOriginY()) * resolution_;\n\treturn true;\n}", "CodeBleu_score": 39.908661164078026}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 80.90828973768289}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 82.53666226729315}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 82.53666226729315}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In goal callback\");\n\tmove_base_msgs::MoveBaseActionGoal goal_msg;\n\tgoal_msg.header.stamp = ros::Time::now();\n\tgoal_msg.goal.target_pose = *goal;\n\taction_goal_pub_.publish(goal_msg);\n}", "CodeBleu_score": 63.605298940367184}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG(\"Received a new goal\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.header.frame_id = goal->header.frame_id;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal.goal.target_pose.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose.header.frame_id = goal->header.frame_id;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 63.43395567049467}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In move_base goal callback\");\n\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\tROS_DEBUG_NAMED(\"move_base\", \"Publishing goal\");\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 65.2720825187583}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (distance_squared > limited_distance_squared) {\n\t\tROS_INFO(\"Robot has moved far enough to remove speed limit.\");\n\t\tif (remove_limit_thread) {\n\t\t\tremove_limit_thread->join();\n\t\t}\n\t\tremove_limit_thread = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\tdistance_check_timer.stop();\n\t}\n}", "CodeBleu_score": 42.72919230694173}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble squared_limited_distance = limited_distance_ * limited_distance_;\n\tdouble squared_current_distance = current_distance_ * current_distance_;\n\tif (squared_current_distance > squared_limited_distance) {\n\t\tROS_INFO(\"Robot has moved far enough, stopping distance check\");\n\t\tdistance_check_timer_.stop();\n\t\tremove_limit_thread_ = NULL;\n\t\treturn;\n\t}\n\tif (remove_limit_thread_!= NULL) {\n\t\tROS_INFO(\"Distance check timer running, waiting for thread to finish\");\n\t\tremove_limit_thread_->join();\n\t\tremove_limit_thread_ = NULL;\n\t}\n\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n}", "CodeBleu_score": 49.072557051239585}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (std::sqrt(limitedDistance_) > std::sqrt(currentDistance_)) {\n\t\tROS_INFO(\"Robot has moved a distance of %f m. Distance limit has been removed.\", std::sqrt(currentDistance_));\n\t\tlimitedDistance_ = 0;\n\t\tlimitedDistanceTimer_.stop();\n\t\tremoveLimitThread_.join();\n\t}\n}", "CodeBleu_score": 36.238937826312444}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current pose of the robot\n\trm::PoseStamped current_pose;\n\tgetRobotPose(current_pose);\n\n\t// Generate a path from the current pose to the goal pose\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tmakePlan(current_pose, *goal, plan);\n\n\t// Publish the path to be visualized\n\tpublishPlan(plan);\n}", "CodeBleu_score": 54.915884818560734}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current pose of the robot\n\trm::PoseStamped current_pose;\n\tgetRobotPose(current_pose);\n\n\t// Generate a path from the current pose to the goal pose\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\tmakePlan(current_pose, *goal, path);\n\n\t// Publish the path\n\tnavfn_msgs::Path2D path_msg;\n\tpath_msg.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tpath_msg.header.stamp = ros::Time::now();\n\tpath_msg.poses = path;\n\tpath_pub_.publish(path_msg);\n}", "CodeBleu_score": 52.81194614649508}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current robot pose\n\trm::PoseStamped current_pose = getRobotPose();\n\n\t// Generate a path from the current pose to the goal pose\n\tstd::vector<rm::PoseStamped> path;\n\tmakePlan(current_pose, *goal, path);\n\n\t// If the path is valid\n\tif (path.size() > 1) {\n\t\t// Set the plan to the path generated by makePlan\n\t\tplan = path;\n\n\t\t// Set the current goal to the goal pose\n\t\tcurrent_goal = *goal;\n\n\t\t// Set the current path to the path generated by makePlan\n\t\tcurrent_path = path;\n\n\t\t// Set the current path index to 0\n\t\tcurrent_path_index = 0;\n\n\t\t// Set the current pose to the current pose\n\t\tcurrent_pose = getRobotPose();\n\n\t\t// Set the current goal to the goal pose\n\t\tcurrent_goal = *goal;\n\n\t\t// Set the current path to the path generated by makePlan\n\t\tcurrent_path = path;\n\n\t\t// Set the current path index to 0\n\t\tcurrent_path_index = 0;\n\n\t\t// Set the current pose to the current pose\n\t\tcurrent_pose = getRobotPose();\n\n\t\t// Set the current goal to the goal pose\n\t\tcurrent_goal = *goal;\n\n\t\t// Set the current path to the path generated by makePlan\n\t\tcurrent_path = path;\n\n\t\t// Set the current path index to 0\n\t\tcurrent_path_index = 0;\n\n\t\t// Set the current pose to the current pose\n\t\tcurrent_pose = getRobotPose();\n\n\t\t// Set the current goal to the goal pose\n\t\tcurrent_goal = *goal;\n\n\t\t// Set the current path to the path generated by makePlan\n\t\tcurrent_path = path;\n\n\t\t// Set the current path index to 0\n\t\tcurrent_path_index = 0;\n\n\t\t// Set the current pose to the current pose\n\t\tcurrent_pose = getRobotPose();\n\n\t\t// Set the current goal to the goal pose\n\t\tcurrent_goal = *goal;\n\n\t\t// Set the current path to the path generated by makePlan\n\t\tcurrent_path = path;\n\n\t\t// Set the current path index to 0\n\t\tcurrent_path_index = 0;\n\n\t\t// Set", "CodeBleu_score": 43.926083581878025}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// create a ParamSet service request\n\tmavros_msgs::ParamSet param_set_msg;\n\tparam_set_msg.param_id = param_set.param_id;\n\tparam_set_msg.value = param_set.value;\n\tparam_set_msg.param_type = param_set.param_type;\n\tparam_set_msg.target_component = param_set.target_component;\n\tparam_set_msg.target_system = param_set.target_system;\n\n\t// send the request\n\tparam_set_client_.call(param_set_msg);\n}", "CodeBleu_score": 45.825518610459845}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t//Create the service request\n\tmavros_msgs::ParamSet set_param;\n\tset_param.request.param_id = param_set.param_id;\n\tset_param.request.value = param_set.value;\n\t//Send the request\n\tparam_set_client_.call(set_param);\n}", "CodeBleu_score": 59.154051063231705}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.param_value = param_set.param_value;\n\tparam_set_client_.call(srv);\n}", "CodeBleu_score": 62.03161708219129}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\t// Create a TCP socket\n\tboost::asio::ip::tcp::socket socket(m_io_service);\n\n\t// Start an asynchronous accept operation\n\tboost::asio::ip::tcp::acceptor acceptor(m_io_service, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), m_port));\n\tacceptor.async_accept(socket, boost::bind(&CommunicationBridge::handle_accept, this, boost::asio::placeholders::error, &socket));\n\n\t// Start an asynchronous operation to wait for completion\n\tm_io_service.run();\n}", "CodeBleu_score": 9.306727695830336}, {"code": "void CommunicationBridge::serverFun(){\n\t\t// Set up server socket\n\tint serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n\tif (serverSocket < 0) {\n\t\tROS_ERROR(\"Failed to create server socket!\");\n\t\treturn;\n\t}\n\n\t// Set up server address\n\tstruct sockaddr_in serverAddress;\n\tserverAddress.sin_family = AF_INET;\n\tserverAddress.sin_addr.s_addr = INADDR_ANY;\n\tserverAddress.sin_port = htons(serverPort);\n\n\t// Bind server socket to server address\n\tif (bind(serverSocket, (struct sockaddr*) &serverAddress, sizeof(serverAddress)) < 0) {\n\t\tROS_ERROR(\"Failed to bind server socket!\");\n\t\treturn;\n\t}\n\n\t// Listen for incoming connections\n\tif (listen(serverSocket, 5) < 0) {\n\t\tROS_ERROR(\"Failed to listen for incoming connections!\");\n\t\treturn;\n\t}\n\n\t// Accept incoming connections\n\twhile (ros::ok()) {\n\t\t// Wait for a connection\n\t\tint clientSocket = accept(serverSocket, NULL, NULL);\n\t\tif (clientSocket < 0) {\n\t\t\tROS_ERROR(\"Failed to accept incoming connection!\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Receive data\n\t\twhile (ros::ok()) {\n\t\t\t// Receive message\n\t\t\tchar buffer[256];\n\t\t\tint messageLength = recv(clientSocket, buffer, 256, 0);\n\t\t\tif (messageLength <= 0) {\n\t\t\t\tROS_ERROR(\"Failed to receive message!\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Decode message\n\t\t\tstd::string message(buffer, messageLength);\n\t\t\tstd::string topic;\n\t\t\tstd::string data;\n\t\t\tif (!decodeMessage(message, topic, data)) {\n\t\t\t\tROS_ERROR(\"Failed to decode message!\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Publish data\n\t\t\tros::Time time = ros::Time::now();\n\t\t\tros::Publisher publisher = nodeHandle.advertise<std_msgs::String>(topic, 1);\n\t\t\tstd_msgs::String msg;\n\t\t\tmsg.data = data;\n\t\t\tmsg.header.stamp = time;\n\t\t\tpublisher.publish(msg);\n\t\t}\n\n\t\t// Close socket\n\t\tclose", "CodeBleu_score": 41.19934075509507}, {"code": "void CommunicationBridge::serverFun(){\n\t\tboost::asio::io_service io_service;\n\tboost::asio::ip::tcp::acceptor acceptor(io_service, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port));\n\twhile (true) {\n\t\tboost::asio::ip::tcp::socket socket(io_service);\n\t\tacceptor.accept(socket);\n\t\tboost::asio::streambuf buf;\n\t\tboost::system::error_code error;\n\t\tboost::asio::read_until(socket, buf, '", "CodeBleu_score": 13.238015115832768}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (isSimulation) {\n\t\tswarm_control_simulation_.uav_cmd_pub(uav_cmd);\n\t} else {\n\t\tuav_basic_.uav_cmd_pub(uav_cmd);\n\t}\n}", "CodeBleu_score": 18.515595231468247}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (uav_cmd.uav_id == 0) {\n\t\tROS_WARN(\"CommunicationBridge::recvData: Received command with uav_id=0. This is not allowed.\");\n\t\treturn;\n\t}\n\tif (uav_cmd.uav_id == 1) {\n\t\tROS_WARN(\"CommunicationBridge::recvData: Received command with uav_id=1. This is not allowed.\");\n\t\treturn;\n\t}\n\tif (uav_cmd.uav_id == 2) {\n\t\tROS_WARN(\"CommunicationBridge::recvData: Received command with uav_id=2. This is not allowed.\");\n\t\treturn;\n\t}\n\tif (uav_cmd.uav_id == 3) {\n\t\tROS_WARN(\"CommunicationBridge::recvData: Received command with uav_id=3. This is not allowed.\");\n\t\treturn;\n\t}\n\tif (uav_cmd.uav_id == 4) {\n\t\tROS_WARN(\"CommunicationBridge::recvData: Received command with uav_id=4. This is not allowed.\");\n\t\treturn;\n\t}\n\tif (uav_cmd.uav_id == 5) {\n\t\tROS_WARN(\"CommunicationBridge::recvData: Received command with uav_id=5. This is not allowed.\");\n\t\treturn;\n\t}\n\tif (uav_cmd.uav_id == 6) {\n\t\tROS_WARN(\"CommunicationBridge::recvData: Received command with uav_id=6. This is not allowed.\");\n\t\treturn;\n\t}\n\tif (uav_cmd.uav_id == 7) {\n\t\tROS_WARN(\"CommunicationBridge::recvData: Received command with uav_id=7. This is not allowed.\");\n\t\treturn;\n\t}\n\tif (uav_cmd.uav_id == 8) {\n\t\tROS_WARN(\"CommunicationBridge::recvData: Received command with uav_id=8. This is not allowed.\");\n\t\treturn;\n\t}\n\tif (uav_cmd.uav_id == 9) {\n\t\tROS_WARN(\"CommunicationBridge::recvData: Received command with uav_id=9. This is not allowed.\");", "CodeBleu_score": 31.25582681108342}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (simulation_mode_) {\n\t\t// Find the UAV corresponding to the incoming command.\n\t\tboost::shared_lock<boost::shared_mutex> lock(swarm_control_simulation_mutex_);\n\t\tfor (auto uav_iter = swarm_control_simulation_.begin(); uav_iter!= swarm_control_simulation_.end(); ++uav_iter) {\n\t\t\tif (uav_iter->id == uav_cmd.id) {\n\t\t\t\t// Publish the command to the UAV.\n\t\t\t\tuav_iter->uav_basic.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Publish the command to the UAV.\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 38.81335090861283}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == 0) {\n\t\tstd::cout << \"ModeSwitch: Exiting NX mode\" << std::endl;\n\t\tsystem(\"exitnx\");\n\t} else if (mode_selection.use_mode == 1) {\n\t\tstd::cout << \"ModeSwitch: Entering NX mode\" << std::endl;\n\t\tsystem(\"rebootnx\");\n\t} else {\n\t\tstd::cout << \"ModeSwitch: Unknown mode\" << std::endl;\n\t}\n}", "CodeBleu_score": 31.892953818378622}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\t//TODO: implement\n}", "CodeBleu_score": 4.650810043155036}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tstd::string command;\n\tstd::string command_to_execute;\n\tstd::string mode;\n\tstd::string mode_type;\n\n\t// If the mode is REBOOTNX, execute the REBOOTNX system command.\n\tif (mode_selection.mode == \"REBOOTNX\") {\n\t\tcommand = \"sudo rebootnx\";\n\t\tsystem(command.c_str());\n\t\treturn;\n\t}\n\n\t// If the mode is EXITNX, execute the EXITNX system command.\n\tif (mode_selection.mode == \"EXITNX\") {\n\t\tcommand = \"sudo exitnx\";\n\t\tsystem(command.c_str());\n\t\treturn;\n\t}\n\n\t// If the mode is not REBOOTNX or EXITNX, then it is either createMode or deleteMode.\n\tif (mode_selection.mode == \"createMode\" || mode_selection.mode == \"deleteMode\") {\n\t\t// If the mode is createMode, then the mode_type field is set to create.\n\t\tif (mode_selection.mode == \"createMode\") {\n\t\t\tmode_type = \"create\";\n\t\t}\n\n\t\t// If the mode is deleteMode, then the mode_type field is set to delete.\n\t\tif (mode_selection.mode == \"deleteMode\") {\n\t\t\tmode_type = \"delete\";\n\t\t}\n\n\t\t// If the mode_type field is create, then the mode_type field is set to create.\n\t\tif (mode_selection.mode_type == \"create\") {\n\t\t\tmode_type = \"create\";\n\t\t}\n\n\t\t// If the mode_type field is delete, then the mode_type field is set to delete.\n\t\tif (mode_selection.mode_type == \"delete\") {\n\t\t\tmode_type = \"delete\";\n\t\t}\n\n\t\t// If the mode_type field is not create or delete, then the mode_type field is set to create.\n\t\tif (mode_selection.mode_type!= \"create\" && mode_selection.mode_type!= \"delete\") {\n\t\t\tmode_type = \"create\";\n\t\t}\n\n\t\t// If the mode_type field is create, then the command to execute is set to createMode.\n\t\tif (mode_type == \"create\") {\n\t\t\tcommand_to_execute = \"create", "CodeBleu_score": 41.870834091559864}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tboost::shared_lock<boost::shared_mutex> lock(heartbeat_mutex);\n\tint heartbeat_count = heartbeat_count_map[vehicle_type];\n\tif (heartbeat_count == 0) {\n\t\tROS_ERROR(\"Heartbeat lost for %s\", vehicle_type.c_str());\n\t\tif (vehicle_type == \"UAV\") {\n\t\t\tROS_ERROR(\"UAVs will be disabled for 10 seconds\");\n\t\t\tuav_disable_timer.start();\n\t\t} else if (vehicle_type == \"UGV\") {\n\t\t\tROS_ERROR(\"UGVs will be disabled for 10 seconds\");\n\t\t\tugv_disable_timer.start();\n\t\t} else if (vehicle_type == \"swarm\") {\n\t\t\tROS_ERROR(\"Swarm will be disabled for 10 seconds\");\n\t\t\tswarm_disable_timer.start();\n\t\t}\n\t\tdisconnect_flag = true;\n\t} else {\n\t\theartbeat_count_map[vehicle_type] = 0;\n\t}\n}", "CodeBleu_score": 30.57175205922413}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tros::Time current_time = ros::Time::now();\n\tint missed_heartbeats = 0;\n\tint missed_heartbeat_attempts = 10;\n\n\t// Check the heartbeat status for each vehicle\n\tfor (int i = 0; i < vehicles.size(); i++) {\n\t\tif (vehicles[i]->getHeartbeat() == true) {\n\t\t\tmissed_heartbeats = 0;\n\t\t\tvehicles[i]->setHeartbeat(false);\n\t\t} else {\n\t\t\tmissed_heartbeats++;\n\t\t}\n\n\t\t// If a vehicle has not reported a heartbeat in 10 seconds, trigger an action\n\t\tif (missed_heartbeats >= missed_heartbeat_attempts) {\n\t\t\tif (vehicles[i]->getType() == \"swarm\") {\n\t\t\t\tROS_ERROR_STREAM(\"No heartbeat from \" << vehicles[i]->getName() << \" in \" << missed_heartbeat_attempts << \" seconds. Disconnecting.\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t} else if (vehicles[i]->getType() == \"UAV\") {\n\t\t\t\tROS_ERROR_STREAM(\"No heartbeat from \" << vehicles[i]->getName() << \" in \" << missed_heartbeat_attempts << \" seconds. Disconnecting.\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t} else if (vehicles[i]->getType() == \"UGV\") {\n\t\t\t\tROS_ERROR_STREAM(\"No heartbeat from \" << vehicles[i]->getName() << \" in \" << missed_heartbeat_attempts << \" seconds. Disconnecting.\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If the disconnect flag is set, trigger the appropriate action\n\tif (disconnect_flag == true) {\n\t\t// If the disconnect flag is set, trigger the appropriate action\n\t\tif (vehicles[0]->getType() == \"swarm\") {\n\t\t\tROS_ERROR_STREAM(\"Swarm communication lost. Disconnecting.\");\n\t\t\tdisconnect_flag = false;\n\t\t} else if (vehicles[0]->getType() == \"UAV\") {\n\t\t\tROS_ERROR_STREAM(\"UAV communication lost. Disconnecting.\");\n\t\t\tdisconnect_flag = false;\n\t\t} else if (vehicles[0]->getType() == \"UGV\") {\n\t\t\tROS_ERROR_STREAM(\"UGV communication lost. Disconnecting.\");\n\t\t\tdisconnect_flag = false;\n\t\t}\n", "CodeBleu_score": 40.30892460905488}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tboost::unique_lock<boost::shared_mutex> lock(mutex_heartbeat);\n\n\t// If the heartbeat count has not changed for a specified number of attempts, print an error message and trigger appropriate actions based on the type of vehicle (swarm, UAV, or UGV).\n\tif (heartbeat_counter_ > heartbeat_attempts_) {\n\t\tROS_ERROR_STREAM(\"Heartbeat lost. Number of attempts: \" << heartbeat_counter_);\n\t\tif (vehicle_type_ == \"swarm\") {\n\t\t\tROS_ERROR_STREAM(\"Swarm vehicle disconnected\");\n\t\t\tdisconnect_flag_ = true;\n\t\t} else if (vehicle_type_ == \"UAV\") {\n\t\t\tROS_ERROR_STREAM(\"UAV vehicle disconnected\");\n\t\t\tdisconnect_flag_ = true;\n\t\t} else if (vehicle_type_ == \"UGV\") {\n\t\t\tROS_ERROR_STREAM(\"UGV vehicle disconnected\");\n\t\t\tdisconnect_flag_ = true;\n\t\t}\n\t}\n\n\t// Reset the heartbeat counter.\n\theartbeat_counter_ = 0;\n}", "CodeBleu_score": 32.49147093417378}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb\");\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->header.seq: %d\", msg->header.seq);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->header.stamp: %f\", msg->header.stamp.toSec());\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->header.frame_id: %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->drone_id: %d\", msg->drone_id);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->num_traj: %d\", msg->num_traj);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->traj_type: %d\", msg->traj_type);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->traj_id: %d\", msg->traj_id);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->traj_length: %d\", msg->traj_length);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->traj_time_stamp: %f\", msg->traj_time_stamp);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->traj_time_stamp_sec: %f\", msg->traj_time_stamp_sec);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->traj_time_stamp_nsec: %d\", msg->traj_time_stamp_nsec);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->traj_time_stamp_sec: %d\", msg->traj_time_stamp_sec);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb:", "CodeBleu_score": 1.253353264216107}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tint drone_id;\n\tstd::vector<Bspline> bsplines;\n\tstd::vector<double> time;\n\tstd::vector<double> pos;\n\tstd::vector<double> vel;\n\tstd::vector<double> acc;\n\tstd::vector<double> jerk;\n\tstd::vector<double> yaw;\n\tstd::vector<double> yaw_rate;\n\tstd::vector<double> yaw_acc;\n\tstd::vector<double> yaw_jerk;\n\tstd::vector<double> yaw_rate_rate;\n\tstd::vector<double> yaw_rate_acc;\n\tstd::vector<double> yaw_rate_jerk;\n\tstd::vector<double> yaw_acc_acc;\n\tstd::vector<double> yaw_acc_jerk;\n\tstd::vector<double> yaw_jerk_jerk;\n\tstd::vector<double> yaw_rate_rate_rate;\n\tstd::vector<double> yaw_rate_rate_acc;\n\tstd::vector<double> yaw_rate_rate_jerk;\n\tstd::vector<double> yaw_rate_acc_acc;\n\tstd::vector<double> yaw_rate_acc_jerk;\n\tstd::vector<double> yaw_rate_jerk_jerk;\n\tstd::vector<double> yaw_acc_acc_acc;\n\tstd::vector<double> yaw_acc_acc_jerk;\n\tstd::vector<double> yaw_acc_jerk_jerk;\n\tstd::vector<double> yaw_jerk_jerk_jerk;\n\n\tfor (int i = 0; i < msg->drone_ids.size(); i++) {\n\t\tdrone_id = msg->drone_ids[i];\n\t\ttime = msg->time[i];\n\t\tpos = msg->pos[i];\n\t\tvel = msg->vel[i];\n\t\tacc = msg->acc[i];\n\t\tjerk = msg->jerk[i];\n\t\tyaw = msg->yaw[i];\n\t\tyaw_rate = msg->yaw_rate[i];\n\t\tyaw_acc = msg->yaw_acc[i];\n\t\tyaw_jerk = msg->", "CodeBleu_score": 29.961454600171255}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t//ROS_INFO(\"Received MultiBsplines msg from %s\", msg->header.frame_id.c_str());\n\n\tint droneId = msg->header.frame_id[0] - '0';\n\n\t//ROS_INFO(\"Drone ID: %d\", droneId);\n\n\t//ROS_INFO(\"Received %d Bsplines\", msg->bsplines.size());\n\n\tfor (int i = 0; i < msg->bsplines.size(); i++) {\n\t\t//ROS_INFO(\"Received Bspline %d\", i);\n\n\t\t//ROS_INFO(\"Received %d knots\", msg->bsplines[i].knots.size());\n\t\t//ROS_INFO(\"Received %d position points\", msg->bsplines[i].position_points.size());\n\t\t//ROS_INFO(\"Received %d yaw points\", msg->bsplines[i].yaw_points.size());\n\n\t\t//ROS_INFO(\"Received %d knots\", msg->bsplines[i].knots.size());\n\t\t//ROS_INFO(\"Received %d position points\", msg->bsplines[i].position_points.size());\n\t\t//ROS_INFO(\"Received %d yaw points\", msg->bsplines[i].yaw_points.size());\n\n\t\t//ROS_INFO(\"Received %d knots\", msg->bsplines[i].knots.size());\n\t\t//ROS_INFO(\"Received %d position points\", msg->bsplines[i].position_points.size());\n\t\t//ROS_INFO(\"Received %d yaw points\", msg->bsplines[i].yaw_points.size());\n\n\t\t//ROS_INFO(\"Received %d knots\", msg->bsplines[i].knots.size());\n\t\t//ROS_INFO(\"Received %d position points\", msg->bsplines[i].position_points.size());\n\t\t//ROS_INFO(\"Received %d yaw points\", msg->bsplines[i].yaw_points.size());\n\n\t\t//ROS_INFO(\"Received %d knots\", msg->bsplines[i].knots.size());\n\t\t//ROS_INFO(\"Received %d position points\", msg->bsplines[i].position_points.size());\n\t\t//ROS_INFO(\"Received %d yaw points\", msg->bsplines[", "CodeBleu_score": 12.42046327640393}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PCLPointCloud2 pcl_pc2;\n\tpcl_conversions::toPCL(msg, pcl_pc2);\n\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromPCLPointCloud2(pcl_pc2, *cloud);\n\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\n\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\tsor.setInputCloud(cloud);\n\tsor.setLeafSize(0.01, 0.01, 0.01);\n\tsor.filter(*cloud_filtered);\n\n\tpcl::toPCLPointCloud2(*cloud_filtered, pcl_pc2);\n\n\tsensor_msgs::PointCloud2 pc2_msg;\n\tpcl_conversions::fromPCL(pcl_pc2, pc2_msg);\n\treturn pc2_msg;\n}", "CodeBleu_score": 32.2561087189277}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// TODO: Implement this function\n\tpcl::PCLPointCloud2 pcl_pc2;\n\tpcl_conversions::toPCL(msg,pcl_pc2);\n\tpcl::PointCloud<pcl::PointXYZ> pcl_pc;\n\tpcl::fromPCLPointCloud2(pcl_pc2,pcl_pc);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tcloud->points.resize(pcl_pc.size());\n\tfor (int i=0; i<pcl_pc.size(); i++) {\n\t\tcloud->points[i].x = pcl_pc.points[i].x;\n\t\tcloud->points[i].y = pcl_pc.points[i].y;\n\t\tcloud->points[i].z = pcl_pc.points[i].z;\n\t}\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\tsor.setInputCloud(cloud);\n\tsor.setLeafSize(0.05f,0.05f,0.05f);\n\tsor.filter(*cloud_filtered);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered2(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::VoxelGrid<pcl::PointXYZ> sor2;\n\tsor2.setInputCloud(cloud_filtered);\n\tsor2.setLeafSize(0.02f,0.02f,0.02f);\n\tsor2.filter(*cloud_filtered2);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered3(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::VoxelGrid<pcl::PointXYZ> sor3;\n\tsor3.setInputCloud(cloud_filtered2);\n\tsor3.setLeafSize(0.01f,0.01f,0.01f);\n\tsor3.filter(*cloud_filtered3);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered4(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::VoxelGrid<pcl::PointXYZ> sor4", "CodeBleu_score": 40.03143128543722}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Create a new PointCloud2 message to store the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\n\t// Compress the point cloud using an octree compression technique\n\tpcl::io::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\toctree_compression.setInputCloud(cloud);\n\toctree_compression.setResolution(0.01);\n\toctree_compression.addPointsFromInputCloud();\n\toctree_compression.compress();\n\toctree_compression.getPointIndicesFromInputCloud(compressed_msg.indices);\n\toctree_compression.getPointsFromInputCloud(compressed_msg.points);\n\n\t// Return the compressed message\n\treturn compressed_msg;\n}", "CodeBleu_score": 32.786742170509186}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\t// Iterate through the list of UAV states\n\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\t// If the UAV ID matches, replace the UAV state with the new one\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 54.16810391344823}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (uav_state.uav_id == multi_uav_state_[i].uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 53.18669451584205}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_.at(i).uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_.at(i) = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 52.94267608032225}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize UGVState message\n\tUGVState m_ugv_state;\n\t// Initialize MultiUGVState message\n\tMultiUGVState m_multi_ugv_state;\n\t// Initialize UGV count\n\tint m_ugv_count = 0;\n\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state_list.size(); i++) {\n\t\t// Populate UGVState message with ID, battery, position, velocity, and attitude data\n\t\tm_ugv_state.ugv_id = m_multi_ugv_state.ugv_state_list[i].ugv_id;\n\t\tm_ugv_state.battery = m_multi_ugv_state.ugv_state_list[i].battery;\n\t\tm_ugv_state.position.x = m_multi_ugv_state.ugv_state_list[i].position.x;\n\t\tm_ugv_state.position.y = m_multi_ugv_state.ugv_state_list[i].position.y;\n\t\tm_ugv_state.position.z = m_multi_ugv_state.ugv_state_list[i].position.z;\n\t\tm_ugv_state.velocity.x = m_multi_ugv_state.ugv_state_list[i].velocity.x;\n\t\tm_ugv_state.velocity.y = m_multi_ugv_state.ugv_state_list[i].velocity.y;\n\t\tm_ugv_state.velocity.z = m_multi_ugv_state.ugv_state_list[i].velocity.z;\n\t\tm_ugv_state.attitude.roll = m_multi_ugv_state.ugv_state_list[i].attitude.roll;\n\t\tm_ugv_state.attitude.pitch = m_multi_ugv_state.ugv_state_list[i].attitude.pitch;\n\t\tm_ugv_state.attitude.yaw = m_multi_ugv_state.ugv_", "CodeBleu_score": 37.545179893299846}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize the MultiUGVState message\n\tMultiUGVState msg;\n\n\t// Iterate through each UGV state\n\tfor (int i = 0; i < m_multi_ugv_state.m_ugv_count; i++) {\n\t\t// Initialize the UGVState message\n\t\tUGVState ugv_state;\n\n\t\t// Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tugv_state.id = m_multi_ugv_state.m_ugv_state[i].m_ugv_id;\n\t\tugv_state.battery = m_multi_ugv_state.m_ugv_state[i].m_battery;\n\t\tugv_state.position.x = m_multi_ugv_state.m_ugv_state[i].m_position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.m_ugv_state[i].m_position.y;\n\t\tugv_state.velocity.x = m_multi_ugv_state.m_ugv_state[i].m_velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.m_ugv_state[i].m_velocity.y;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.m_ugv_state[i].m_attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.m_ugv_state[i].m_attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.m_ugv_state[i].m_attitude.yaw;\n\n\t\t// Add the UGVState to the MultiUGVState message\n\t\tmsg.ugv_state.push_back(ugv_state);\n\t}\n\n\t// Publish the MultiUGVState message\n\tm_all_ugv_state_pub.publish(msg);\n}", "CodeBleu_score": 42.749736867667764}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize the MultiUGVState message\n\tmulti_ugv_state_msg.header.stamp = ros::Time::now();\n\tmulti_ugv_state_msg.ugv_count = m_multi_ugv_state.ugv_count;\n\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\t// Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tugv_state_msg.id = m_multi_ugv_state.ugv_states[i].id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_states[i].battery;\n\t\tugv_state_msg.position.x = m_multi_ugv_state.ugv_states[i].position.x;\n\t\tugv_state_msg.position.y = m_multi_ugv_state.ugv_states[i].position.y;\n\t\tugv_state_msg.position.z = m_multi_ugv_state.ugv_states[i].position.z;\n\t\tugv_state_msg.velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n\t\tugv_state_msg.velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n\t\tugv_state_msg.velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n\t\tugv_state_msg.attitude.x = m_multi_ugv_state.ugv_states[i].attitude.x;\n\t\tugv_state_msg.attitude.y = m_multi_ugv_state.ugv_states[i].attitude.y;\n\t\tugv_state_msg.attitude.z = m_multi_ugv_state.ugv_states[i].attitude.z;\n\t\tugv_state_msg.attitude.w = m_multi_ugv_state.", "CodeBleu_score": 40.615304393805815}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tEigen::MatrixXd q_pred = q;\n\tEigen::MatrixXd q_pred_deriv = q;\n\tEigen::MatrixXd q_pred_deriv_deriv = q;\n\tEigen::MatrixXd q_pred_deriv_deriv_deriv = q;\n\n\t// Evaluate the predicted positions of moving objects\n\tfor (int i = 0; i < movingObjList.size(); i++) {\n\t\tMovingObject *obj = movingObjList[i];\n\t\tobj->predict(q_pred, q_pred_deriv, q_pred_deriv_deriv, q_pred_deriv_deriv_deriv);\n\t}\n\n\t// Evaluate the distance between control points and moving objects\n\tdouble dist = 0;\n\tdouble dist_deriv = 0;\n\tdouble dist_deriv_deriv = 0;\n\tfor (int i = 0; i < controlPointList.size(); i++) {\n\t\tEigen::Vector3d cp = controlPointList[i];\n\t\tEigen::Vector3d cp_deriv = controlPointList_deriv[i];\n\t\tEigen::Vector3d cp_deriv_deriv = controlPointList_deriv_deriv[i];\n\n\t\tEigen::Vector3d obj_pos = Eigen::Vector3d::Zero();\n\t\tEigen::Vector3d obj_pos_deriv = Eigen::Vector3d::Zero();\n\t\tEigen::Vector3d obj_pos_deriv_deriv = Eigen::Vector3d::Zero();\n\t\tfor (int j = 0; j < movingObjList.size(); j++) {\n\t\t\tMovingObject *obj = movingObjList[j];\n\t\t\tobj->predict(obj_pos, obj_pos_deriv, obj_pos_deriv_deriv);\n\t\t}\n\n\t\tdouble d = (cp - obj_pos).norm();\n\t\tdist += d;\n\n\t\tEigen::Vector3d d_deriv = (cp_deriv - obj_pos_deriv).normalized();\n\t\tdist_deriv += d_deriv.dot(cp - obj_pos);\n\n\t\tEigen::Vector3d d_deriv_deriv = (cp_deriv_deriv - obj_pos_deriv_deriv).normalized();\n\t\tdist_deriv_deriv += d_deriv_deriv.dot(cp_deriv - obj_pos_deriv);\n\t}\n\n\t// Update the cost and", "CodeBleu_score": 36.27224283539655}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// calculate the predicted positions of moving objects\n\tEigen::MatrixXd predictedPositions = computePredictedPositions(q);\n\t// evaluate the distance between control points and moving objects\n\tEigen::MatrixXd distance = computeDistance(q, predictedPositions);\n\t// update the cost and gradient based on the distance error\n\tupdateCostAndGradient(distance, cost, gradient);\n}", "CodeBleu_score": 10.224959644833598}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tgradient.setZero();\n\n\tEigen::MatrixXd obj_pos(moving_obj_num_, 3);\n\tEigen::MatrixXd obj_vel(moving_obj_num_, 3);\n\tEigen::MatrixXd obj_acc(moving_obj_num_, 3);\n\n\tfor (int i = 0; i < moving_obj_num_; i++) {\n\t\tobj_pos.row(i) = moving_obj_pos_.row(i) + moving_obj_vel_.row(i) * dt_;\n\t\tobj_vel.row(i) = moving_obj_vel_.row(i) + moving_obj_acc_.row(i) * dt_;\n\t\tobj_acc.row(i) = moving_obj_acc_.row(i);\n\t}\n\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\tEigen::VectorXd qi = q.row(i);\n\t\tEigen::VectorXd qi_dot = q.row(i + 1) - q.row(i);\n\t\tEigen::VectorXd qi_ddot = q.row(i + 2) - q.row(i + 1);\n\n\t\tEigen::MatrixXd qi_pos(3, 1);\n\t\tEigen::MatrixXd qi_vel(3, 1);\n\t\tEigen::MatrixXd qi_acc(3, 1);\n\n\t\tEigen::MatrixXd qi_pos_dot(3, 1);\n\t\tEigen::MatrixXd qi_vel_dot(3, 1);\n\t\tEigen::MatrixXd qi_acc_dot(3, 1);\n\n\t\tEigen::MatrixXd qi_pos_ddot(3, 1);\n\t\tEigen::MatrixXd qi_vel_ddot(3, 1);\n\t\tEigen::MatrixXd qi_acc_ddot(3, 1);\n\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tqi_pos(j, 0) = qi(j);\n\t\t\tqi_vel(j, 0) = qi_dot(j);\n\t\t\tqi_acc(j, 0) = qi_ddot(j);", "CodeBleu_score": 40.32184469434097}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0;\n\tgradient.setZero();\n\n\t// Iterate through the control points of the trajectory\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Compute the positional error relative to reference points\n\t\tEigen::Vector3d error = q.row(i).transpose() - ref_points_.row(i).transpose();\n\n\t\t// Compute the velocity vector\n\t\tEigen::Vector3d vel = (q.row(i + 1).transpose() - q.row(i).transpose()) / dt_;\n\n\t\t// Compute the cost function\n\t\tcost += a2_ * error.dot(error) + b2_ * vel.dot(vel);\n\n\t\t// Compute the gradient\n\t\tgradient.row(i) = 2 * a2_ * error + 2 * b2_ * vel;\n\t}\n}", "CodeBleu_score": 23.628089018592057}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize cost and gradient to zero\n\tcost = 0.0;\n\tgradient.setZero();\n\n\t// Iterate through all control points\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Compute the positional error\n\t\tEigen::Vector3d pos_error = q.row(i) - ref_points_.row(i);\n\n\t\t// Compute the velocity vector\n\t\tEigen::Vector3d vel_vec = (q.row(i) - q.row((i + 1) % q.rows())) / dt_;\n\n\t\t// Compute the cost and gradient for this control point\n\t\tdouble a2 = 0.5 * a2_;\n\t\tdouble b2 = 0.5 * b2_;\n\t\tdouble cost_i = a2 * pos_error.dot(pos_error) + b2 * vel_vec.dot(vel_vec);\n\t\tcost += cost_i;\n\t\tgradient.row(i) += 2 * a2 * pos_error + 2 * b2 * vel_vec;\n\t}\n}", "CodeBleu_score": 26.959244745975496}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tgradient.setZero(q.rows(), q.cols());\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\tEigen::VectorXd pos_error = q.row(i) - ref_points_.row(i);\n\t\tEigen::VectorXd vel_error = q.row(i + 1) - q.row(i);\n\t\tdouble a2 = 0.001;\n\t\tdouble b2 = 0.001;\n\t\tdouble pos_cost = pos_error.dot(pos_error) / a2;\n\t\tdouble vel_cost = vel_error.dot(vel_error) / b2;\n\t\tcost += pos_cost + vel_cost;\n\t\tgradient.row(i) = 2 * pos_error / a2 + 2 * vel_error / b2;\n\t}\n}", "CodeBleu_score": 29.61617923010495}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0;\n\tdouble knot_diff = 0;\n\tdouble knot_diff_squared = 0;\n\n\tfor (int i = 1; i < this->control_points.size(); i++) {\n\t\tfor (int j = 0; j < this->control_points[i].size(); j++) {\n\t\t\tknot_diff = this->knots[i] - this->knots[i - 1];\n\t\t\tknot_diff_squared = knot_diff * knot_diff;\n\t\t\tjerk += knot_diff_squared * this->control_points[i][j];\n\t\t}\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 35.1099179159374}, {"code": "double UniformBspline::getJerk(){\n\t\t// get the number of control points\n\tint num_points = control_points_.size();\n\t// get the number of dimensions\n\tint num_dimensions = control_points_[0].size();\n\t// get the number of knots\n\tint num_knots = knots_.size();\n\t// get the knot times\n\tvector<double> knot_times = knots_;\n\t// get the knot values\n\tvector<vector<double> > knot_values = control_points_;\n\t// get the jerk trajectory\n\tvector<vector<double> > jerk_trajectory;\n\t// get the jerk values\n\tvector<double> jerk_values;\n\t// calculate the jerk trajectory\n\tfor (int i = 0; i < num_dimensions; i++) {\n\t\tvector<double> jerk_trajectory_dimension;\n\t\tfor (int j = 0; j < num_points - 3; j++) {\n\t\t\tvector<double> jerk_point;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tjerk_point.push_back(\n\t\t\t\t\t\t(knot_values[j + 1][i] - 2 * knot_values[j + 2][i]\n\t\t\t\t\t\t\t\t+ knot_values[j + 3][i])\n\t\t\t\t\t\t\t\t* (knot_times[j + 1] - knot_times[j + 3])\n\t\t\t\t\t\t\t\t- (knot_values[j][i] - 2 * knot_values[j + 1][i]\n\t\t\t\t\t\t\t\t\t\t+ knot_values[j + 2][i])\n\t\t\t\t\t\t\t\t\t\t* (knot_times[j] - knot_times[j + 2]));\n\t\t\t}\n\t\t\tjerk_trajectory_dimension.push_back(jerk_point[0]);\n\t\t}\n\t\tjerk_trajectory.push_back(jerk_trajectory_dimension);\n\t}\n\t// calculate the jerk values\n\tfor (int i = 0; i < num_points - 3; i++) {\n\t\tdouble jerk_value = 0;\n\t\tfor (int j = 0; j < num_dimensions; j++) {\n\t\t\tjerk_value +=", "CodeBleu_score": 41.747420717891345}, {"code": "double UniformBspline::getJerk(){\n\t\t// Get the third derivative of the spline.\n\tEigen::MatrixXd thirdDerivative = getThirdDerivative();\n\n\t// Get the knot times and control points of the jerk trajectory.\n\tEigen::VectorXd knotTimes = thirdDerivative.col(0);\n\tEigen::MatrixXd controlPoints = thirdDerivative.block(0, 1, knotTimes.size(), 3);\n\n\t// Sum the squared control point values multiplied by the differences in knot times.\n\tdouble jerk = 0.0;\n\tfor (int i = 0; i < knotTimes.size() - 1; i++) {\n\t\tdouble diff = knotTimes(i + 1) - knotTimes(i);\n\t\tjerk += (controlPoints.row(i).array().square() * diff).sum();\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 44.23279867171278}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1;\n\treturn pos;\n}", "CodeBleu_score": 37.896344210819656}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 74.49740701774701}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1.0;\n\treturn pos;\n}", "CodeBleu_score": 38.401332806414366}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\tstd::string child_frame_id = odom.child_frame_id;\n\tstd::string drone_id = child_frame_id.substr(0, child_frame_id.find(\"_\"));\n\ttry {\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (std::exception& e) {\n\t\tROS_ERROR(\"Error processing odometry message: %s\", e.what());\n\t}\n}", "CodeBleu_score": 52.60714010581437}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = extractDroneID(odom.child_frame_id);\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (const std::exception& e) {\n\t\tstd::cerr << \"DroneDetector::rcvDroneXOdomCallback: \" << e.what() << std::endl;\n\t}\n}", "CodeBleu_score": 49.169024237285875}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, getDroneIdFromFrameId(odom.child_frame_id));\n\t} catch (std::runtime_error& e) {\n\t\tROS_ERROR_STREAM(\"Error in DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n\t}\n}", "CodeBleu_score": 35.93954005256888}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Calculate the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose = camera_->pixelToWorld(true_pixel);\n\n\t// Check if the drone is present in the image\n\tif (drones_.find(drone_id)!= drones_.end()) {\n\t\t// Compute the pose error between the camera and world coordinates\n\t\tEigen::Vector3d error = true_pose - drones_[drone_id].pose;\n\n\t\t// Update the debug result\n\t\tdebug_result_.drone_id = drone_id;\n\t\tdebug_result_.true_pose = true_pose;\n\t\tdebug_result_.error = error;\n\n\t\t// Publish the pose error\n\t\tpose_error_pub_.publish(debug_result_);\n\t} else {\n\t\t// Update the debug result to indicate failure\n\t\tdebug_result_.drone_id = drone_id;\n\t\tdebug_result_.true_pose = true_pose;\n\t\tdebug_result_.error = Eigen::Vector3d(0.0, 0.0, 0.0);\n\n\t\t// Publish the pose error\n\t\tpose_error_pub_.publish(debug_result_);\n\t}\n}", "CodeBleu_score": 37.792739715367574}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// TODO: Implement this function\n\t//std::cout << \"detect\" << std::endl;\n\t//std::cout << \"drone_id: \" << drone_id << std::endl;\n\t//std::cout << \"true_pixel: \" << true_pixel.transpose() << std::endl;\n\n\t// Check if the drone is already detected\n\tif (drones_.find(drone_id)!= drones_.end()) {\n\t\t// If so, check if the drone is in the camera frame\n\t\tif (drones_[drone_id].in_camera_frame) {\n\t\t\t// If so, compute the pose error between the camera and world coordinates\n\t\t\tEigen::Vector3d camera_pose = drones_[drone_id].camera_pose;\n\t\t\tEigen::Vector3d world_pose = drones_[drone_id].world_pose;\n\t\t\tEigen::Vector3d pose_error = world_pose - camera_pose;\n\t\t\t//std::cout << \"pose_error: \" << pose_error.transpose() << std::endl;\n\t\t\t// Update the debug result\n\t\t\tdrones_[drone_id].debug_result.pose_error = pose_error;\n\t\t\t// Publish the pose error\n\t\t\tpose_error_pub_.publish(drones_[drone_id].debug_result);\n\t\t}\n\t\telse {\n\t\t\t// If not, update the debug result to indicate failure\n\t\t\tdrones_[drone_id].debug_result.pose_error = Eigen::Vector3d(0, 0, 0);\n\t\t\tpose_error_pub_.publish(drones_[drone_id].debug_result);\n\t\t}\n\t}\n\telse {\n\t\t// If not, update the debug result to indicate failure\n\t\tdrones_[drone_id].debug_result.pose_error = Eigen::Vector3d(0, 0, 0);\n\t\tpose_error_pub_.publish(drones_[drone_id].debug_result);\n\t}\n}", "CodeBleu_score": 38.15891571994381}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the drone\n\tauto drone = drones_.find(drone_id);\n\n\t// If the drone is not found, add it\n\tif (drone == drones_.end()) {\n\t\tdrones_.emplace(drone_id, Drone(drone_id));\n\t\tdrone = drones_.find(drone_id);\n\t}\n\n\t// Get the camera pose\n\tEigen::Affine3d camera_pose = camera_frame_.getPose();\n\n\t// Compute the true pose of the drone\n\tEigen::Vector3d true_pose = drone->second.computeTruePose(camera_pose, true_pixel);\n\n\t// Check if the drone is found\n\tbool found = drone->second.checkFound(true_pose);\n\n\t// If the drone is found, compute the error\n\tif (found) {\n\t\tEigen::Vector3d error = drone->second.computeError(true_pose);\n\t\tdrone->second.setDebugResult(true, error);\n\t}\n\telse {\n\t\tdrone->second.setDebugResult(false, Eigen::Vector3d(0, 0, 0));\n\t}\n\n\t// Publish the result\n\tdrone->second.publish();\n}", "CodeBleu_score": 36.375500460732994}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tGridNodePtr node = current;\n\tpath.push_back(node);\n\twhile (node->cameFrom!= nullptr) {\n\t\tnode = node->cameFrom;\n\t\tpath.push_back(node);\n\t}\n\treturn path;\n}", "CodeBleu_score": 56.94794133225094}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start point to grid index\n\tstart_idx = grid_map.World2Grid(start_pt);\n\n\t// Convert end point to grid index\n\tend_idx = grid_map.World2Grid(end_pt);\n\n\t// Check if start point is inside an obstacle\n\tif (grid_map.IsObstacle(start_idx)) {\n\t\t// Adjust start point by moving it away from the other point until it is no longer in an obstacle\n\t\twhile (grid_map.IsObstacle(start_idx)) {\n\t\t\t// Move start point away from the other point\n\t\t\tstart_idx = start_idx + Vector3i(1, 0, 0);\n\t\t}\n\t}\n\n\t// Check if end point is inside an obstacle\n\tif (grid_map.IsObstacle(end_idx)) {\n\t\t// Adjust end point by moving it away from the other point until it is no longer in an obstacle\n\t\twhile (grid_map.IsObstacle(end_idx)) {\n\t\t\t// Move end point away from the other point\n\t\t\tend_idx = end_idx + Vector3i(1, 0, 0);\n\t\t}\n\t}\n\n\t// Check if start point is inside an obstacle\n\tif (grid_map.IsObstacle(start_idx)) {\n\t\t// Start point is inside an obstacle\n\t\treturn false;\n\t}\n\n\t// Check if end point is inside an obstacle\n\tif (grid_map.IsObstacle(end_idx)) {\n\t\t// End point is inside an obstacle\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 27.500617196384646}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tstart_idx = ConvertToIndex(start_pt);\n\tend_idx = ConvertToIndex(end_pt);\n\tif (start_idx.x < 0 || start_idx.x >= num_x || start_idx.y < 0 || start_idx.y >= num_y || start_idx.z < 0 || start_idx.z >= num_z) {\n\t\treturn false;\n\t}\n\tif (end_idx.x < 0 || end_idx.x >= num_x || end_idx.y < 0 || end_idx.y >= num_y || end_idx.z < 0 || end_idx.z >= num_z) {\n\t\treturn false;\n\t}\n\tif (IsInsideObstacle(start_idx)) {\n\t\twhile (IsInsideObstacle(start_idx)) {\n\t\t\tstart_idx = AdjustIndex(start_idx, end_idx);\n\t\t}\n\t}\n\tif (IsInsideObstacle(end_idx)) {\n\t\twhile (IsInsideObstacle(end_idx)) {\n\t\t\tend_idx = AdjustIndex(end_idx, start_idx);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 34.980176983504016}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tstart_idx = m_grid_map.WorldToGridIndex(start_pt);\n\tend_idx = m_grid_map.WorldToGridIndex(end_pt);\n\tif (m_grid_map.IsObstacle(start_idx)) {\n\t\tVector3d start_pt_adjusted;\n\t\tbool success = AdjustPoint(start_pt, end_pt, start_idx, start_pt_adjusted);\n\t\tif (!success) {\n\t\t\tROS_ERROR(\"Failed to adjust start point.\");\n\t\t\treturn false;\n\t\t}\n\t\tstart_idx = m_grid_map.WorldToGridIndex(start_pt_adjusted);\n\t}\n\tif (m_grid_map.IsObstacle(end_idx)) {\n\t\tVector3d end_pt_adjusted;\n\t\tbool success = AdjustPoint(start_pt, end_pt, end_idx, end_pt_adjusted);\n\t\tif (!success) {\n\t\t\tROS_ERROR(\"Failed to adjust end point.\");\n\t\t\treturn false;\n\t\t}\n\t\tend_idx = m_grid_map.WorldToGridIndex(end_pt_adjusted);\n\t}\n\treturn true;\n}", "CodeBleu_score": 37.57513512240902}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3d min_id = pos2id(min_pos);\n\tEigen::Vector3d max_id = pos2id(max_pos);\n\tfor(int i=min_id[0]; i<=max_id[0]; i++) {\n\t\tfor(int j=min_id[1]; j<=max_id[1]; j++) {\n\t\t\tfor(int k=min_id[2]; k<=max_id[2]; k++) {\n\t\t\t\toccupancy_buffer_inflate_[i][j][k] = 0;\n\t\t\t\tdistance_buffer_inflate_[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 33.996578523827566}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = grid_map::gridMapPosToIndex(min_pos, resolution_);\n\tEigen::Vector3i max_id = grid_map::gridMapPosToIndex(max_pos, resolution_);\n\n\tfor (int i = min_id[0]; i <= max_id[0]; ++i) {\n\t\tfor (int j = min_id[1]; j <= max_id[1]; ++j) {\n\t\t\tfor (int k = min_id[2]; k <= max_id[2]; ++k) {\n\t\t\t\toccupancy_buffer_inflate_[i][j][k] = 0;\n\t\t\t\tdistance_buffer_inflate_[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.937031209467946}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = pos2id(min_pos);\n\tEigen::Vector3i max_id = pos2id(max_pos);\n\tresetBuffer(min_id, max_id);\n}", "CodeBleu_score": 20.83254897309391}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_pt = pt;\n\tEigen::Vector3d max_pt = pt;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff(i) < 0) {\n\t\t\tmin_pt(i) = 0;\n\t\t}\n\t\telse {\n\t\t\tmin_pt(i) = diff(i);\n\t\t}\n\t\tif (diff(i) > 0) {\n\t\t\tmax_pt(i) = (grid_size_ - 1) * resolution_;\n\t\t}\n\t\telse {\n\t\t\tmax_pt(i) = 0;\n\t\t}\n\t}\n\n\treturn min_pt;\n}", "CodeBleu_score": 32.25787017261683}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble min_x = std::min(diff(0), 0.0);\n\tdouble max_x = std::max(diff(0), 0.0);\n\tdouble min_y = std::min(diff(1), 0.0);\n\tdouble max_y = std::max(diff(1), 0.0);\n\tdouble min_z = std::min(diff(2), 0.0);\n\tdouble max_z = std::max(diff(2), 0.0);\n\n\tdouble x_scale = 1.0;\n\tdouble y_scale = 1.0;\n\tdouble z_scale = 1.0;\n\n\tif (max_x < 0.0) {\n\t\tx_scale = (min_x - map_origin(0)) / diff(0);\n\t} else if (min_x > 0.0) {\n\t\tx_scale = (max_x - map_origin(0)) / diff(0);\n\t}\n\n\tif (max_y < 0.0) {\n\t\ty_scale = (min_y - map_origin(1)) / diff(1);\n\t} else if (min_y > 0.0) {\n\t\ty_scale = (max_y - map_origin(1)) / diff(1);\n\t}\n\n\tif (max_z < 0.0) {\n\t\tz_scale = (min_z - map_origin(2)) / diff(2);\n\t} else if (min_z > 0.0) {\n\t\tz_scale = (max_z - map_origin(2)) / diff(2);\n\t}\n\n\tdouble scale = std::max(x_scale, y_scale);\n\tscale = std::max(scale, z_scale);\n\n\tif (scale > 1.0) {\n\t\tscale = 1.0;\n\t}\n\n\treturn pt * scale + camera_pt * (1.0 - scale);\n}", "CodeBleu_score": 36.19393995582591}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_pt, max_pt;\n\tmin_pt.x() = std::max(0.0, -map_size_x_ / 2.0);\n\tmin_pt.y() = std::max(0.0, -map_size_y_ / 2.0);\n\tmin_pt.z() = std::max(0.0, -map_size_z_ / 2.0);\n\tmax_pt.x() = std::min(map_size_x_ / 2.0, map_size_x_ / 2.0);\n\tmax_pt.y() = std::min(map_size_y_ / 2.0, map_size_y_ / 2.0);\n\tmax_pt.z() = std::min(map_size_z_ / 2.0, map_size_z_ / 2.0);\n\tdouble min_scale_x = std::min(max_pt.x() / diff.x(), min_pt.x() / diff.x());\n\tdouble min_scale_y = std::min(max_pt.y() / diff.y(), min_pt.y() / diff.y());\n\tdouble min_scale_z = std::min(max_pt.z() / diff.z(), min_pt.z() / diff.z());\n\tdouble min_scale = std::min(min_scale_x, min_scale_y);\n\tmin_scale = std::min(min_scale, min_scale_z);\n\tEigen::Vector3d new_pt = pt * min_scale + camera_pt * (1.0 - min_scale);\n\treturn new_pt;\n}", "CodeBleu_score": 35.63981759215271}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last occupancy update time\n\tlastOccupancyUpdateTime = ros::Time::now();\n\n\t// If we have not received any odometry or depth data for a while, set the relevant flags\n\tif (lastOdometryUpdateTime < ros::Time(0) || lastDepthUpdateTime < ros::Time(0)) {\n\t\tif (lastOdometryUpdateTime < ros::Time(0)) {\n\t\t\tROS_WARN_STREAM_THROTTLE(1.0, \"No odometry data received for more than \" << occupancyTimeout << \" seconds. Setting occupancy map update flag.\");\n\t\t\tupdateOccupancyFlag = true;\n\t\t}\n\t\tif (lastDepthUpdateTime < ros::Time(0)) {\n\t\t\tROS_WARN_STREAM_THROTTLE(1.0, \"No depth data received for more than \" << occupancyTimeout << \" seconds. Setting occupancy map update flag.\");\n\t\t\tupdateOccupancyFlag = true;\n\t\t}\n\t}\n\n\t// If an update is needed, update the occupancy grid\n\tif (updateOccupancyFlag) {\n\t\t// Project the depth image into points\n\t\tif (depthImage.rows > 0 && depthImage.cols > 0) {\n\t\t\t// Get the current pose\n\t\t\ttf::StampedTransform transform;\n\t\t\ttry {\n\t\t\t\tlistener.lookupTransform(depthFrame, mapFrame, ros::Time(0), transform);\n\t\t\t} catch (tf::TransformException &ex) {\n\t\t\t\tROS_ERROR(\"%s\", ex.what());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttf::Vector3 translation = transform.getOrigin();\n\t\t\ttf::Quaternion rotation = transform.getRotation();\n\t\t\tEigen::Affine3d transform_eigen;\n\t\t\ttf::transformTFToEigen(transform, transform_eigen);\n\n\t\t\t// Project the depth image into points\n\t\t\tdepthToPoints(depthImage, depthToPointsMap, transform_eigen);\n\t\t}\n\n\t\t// Clear the local map\n\t\tlocalMap.clear();\n\n\t\t// Inflate the local map\n\t\tfor (int i = 0; i < depthToPointsMap.size(); i++) {\n\t\t\tif (depthToPointsMap[i].x!= -1 && depthToPointsMap[i].y!= -1) {\n\t\t\t\tlocalMap.insert(depthToPointsMap[i]);\n\t\t\t}\n\t\t", "CodeBleu_score": 32.01405663412002}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// update last occupancy update time\n\tlast_occupancy_update_time = ros::Time::now();\n\n\t// check if odometry or depth data is available\n\tif (!odom_received ||!depth_received) {\n\t\t// set timeout flag\n\t\ttimeout = true;\n\n\t\t// reset local map\n\t\tresetLocalMap();\n\n\t\t// return\n\t\treturn;\n\t}\n\n\t// get current odometry and depth data\n\tconst nav_msgs::Odometry::ConstPtr &odom_msg = odom_msg_ptr;\n\tconst sensor_msgs::Image::ConstPtr &depth_msg = depth_msg_ptr;\n\n\t// get current odometry and depth data\n\tconst geometry_msgs::Pose &odom = odom_msg->pose.pose;\n\tconst sensor_msgs::CameraInfo &depth_info = depth_info_msg_ptr->camera_info;\n\n\t// get current depth data\n\tconst cv::Mat &depth_image = cv_bridge::toCvShare(depth_msg, \"16UC1\")->image;\n\n\t// get current depth data\n\tconst cv::Mat &depth_image_float = cv_bridge::toCvShare(depth_msg, \"32FC1\")->image;\n\n\t// get current odometry data\n\tconst double &x = odom.position.x;\n\tconst double &y = odom.position.y;\n\tconst double &yaw = tf::getYaw(odom.orientation);\n\n\t// get current depth data\n\tconst double &depth_min = depth_info.min_depth;\n\tconst double &depth_max = depth_info.max_depth;\n\tconst double &depth_scale = depth_info.depth_scale;\n\tconst double &depth_offset = depth_info.depth_offset;\n\n\t// get current depth data\n\tconst double &depth_res_x = depth_info.resolution.x;\n\tconst double &depth_res_y = depth_info.resolution.y;\n\n\t// get current depth data\n\tconst double &depth_width = depth_info.width;\n\tconst double &depth_height = depth_info.height;\n\n\t// get current depth data\n\tconst double &depth_cx = depth_info.K[2", "CodeBleu_score": 31.243402305545352}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last update time\n\tlast_update_time = ros::Time::now();\n\n\t// If the local map has been updated, clear and inflate the local map\n\tif (local_map_updated) {\n\t\tlocal_map_updated = false;\n\t\tclearLocalMap();\n\t\tinflateLocalMap();\n\t}\n\n\t// If the odometry has been updated, update the global map\n\tif (odometry_updated) {\n\t\todometry_updated = false;\n\t\tupdateGlobalMap();\n\t}\n\n\t// If the depth has been updated, update the global map\n\tif (depth_updated) {\n\t\tdepth_updated = false;\n\t\tupdateGlobalMap();\n\t}\n\n\t// If the depth has been updated, update the global map\n\tif (scan_updated) {\n\t\tscan_updated = false;\n\t\tupdateGlobalMap();\n\t}\n}", "CodeBleu_score": 25.012846376254394}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tint n_images = image_fns.size();\n\tint n_ellipses = 0;\n\tint n_detected_ellipses = 0;\n\tint n_correct_ellipses = 0;\n\tfloat avg_f = 0.0f;\n\tfloat avg_precision = 0.0f;\n\tfloat avg_recall = 0.0f;\n\tfloat avg_iou = 0.0f;\n\n\tfor (int i = 0; i < n_images; i++) {\n\t\t// Load the image and ground truth ellipses.\n\t\tMat image = imread(image_fns[i], IMREAD_COLOR);\n\t\tMat gt = imread(gt_fns[i], IMREAD_COLOR);\n\t\tvector<Ellipse> gt_ellipses = ellipse_detector::load_ellipses(gt_fns[i], gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses = ellipse_detector::load_ellipses(dt_fns[i], gt_angle_radians);\n\n\t\t// Calculate the number of ground truth ellipses and detected ellipses.\n\t\tn_ellipses += gt_ellipses.size();\n\t\tn_detected_ellipses += dt_ellipses.size();\n\n\t\t// Evaluate the detection performance.\n\t\tfloat precision = 0.0f;\n\t\tfloat recall = 0.0f;\n\t\tfloat iou = 0.0f;\n\t\tfloat f = 0.0f;\n\n\t\tfor (int j = 0; j < dt_ellipses.size(); j++) {\n\t\t\t// Find the best matching ground truth ellipse.\n\t\t\tfloat best_iou = 0.0f;\n\t\t\tint best_index = -1;\n\n\t\t\tfor (int k = 0; k < gt_ellipses.size(); k++) {\n\t\t\t\tfloat iou = ellipse_detector::iou(dt_ellipses[j], gt_ellipses[k]);\n\n\t\t\t\tif (iou > best_iou) {\n\t\t\t\t\tbest_iou = iou;\n\t\t\t\t\tbest_index = k;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update the precision, recall, and F-measure.\n\t\t\tif (best", "CodeBleu_score": 44.87671979660095}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat avg_f = 0.0;\n\tfloat num_images = image_fns.size();\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load image\n\t\tcv::Mat image = cv::imread(image_fns[i]);\n\t\tif (image.empty()) {\n\t\t\tcout << \"ERROR: Failed to load image \" << image_fns[i] << endl;\n\t\t\treturn -1;\n\t\t}\n\t\t// Load ground truth ellipses\n\t\tvector<Ellipse> gt_ellipses;\n\t\tif (!gt_fns.empty()) {\n\t\t\tif (gt_fns[i]!= \"\") {\n\t\t\t\tif (!load_ellipses(gt_fns[i], gt_ellipses, gt_angle_radians)) {\n\t\t\t\t\tcout << \"ERROR: Failed to load ground truth ellipses for image \" << image_fns[i] << endl;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Load detected ellipses\n\t\tvector<Ellipse> dt_ellipses;\n\t\tif (!dt_fns.empty()) {\n\t\t\tif (dt_fns[i]!= \"\") {\n\t\t\t\tif (!load_ellipses(dt_fns[i], dt_ellipses, gt_angle_radians)) {\n\t\t\t\t\tcout << \"ERROR: Failed to load detected ellipses for image \" << image_fns[i] << endl;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Evaluate detection performance\n\t\tfloat f = _ellipse_evaluate(image, gt_ellipses, dt_ellipses);\n\t\tavg_f += f;\n\t}\n\treturn avg_f / num_images;\n}", "CodeBleu_score": 47.462619203679246}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat avg_f = 0.0f;\n\tfloat f = 0.0f;\n\tint n = 0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tMat img = imread(image_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n\t\tMat gt = imread(gt_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n\t\tMat dt = imread(dt_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\t\tif (gt_angle_radians) {\n\t\t\t_ellipse_load_gt_rad(gt_fns[i], gt_ellipses);\n\t\t\t_ellipse_load_dt_rad(dt_fns[i], dt_ellipses);\n\t\t}\n\t\telse {\n\t\t\t_ellipse_load_gt_deg(gt_fns[i], gt_ellipses);\n\t\t\t_ellipse_load_dt_deg(dt_fns[i], dt_ellipses);\n\t\t}\n\n\t\tf = _ellipse_evaluate(img, gt_ellipses, dt_ellipses);\n\t\tavg_f += f;\n\t\tn++;\n\t}\n\treturn avg_f / n;\n}", "CodeBleu_score": 51.38012891936299}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tif (foci == NULL) {\n\t\treturn 0;\n\t}\n\tfloat angle_1 = atan2(y - foci[1], x - foci[0]);\n\tfloat angle_2 = atan2(y - foci[3], x - foci[2]);\n\tfloat angle_difference = angle_1 - angle_2;\n\tif (angle_difference < 0) {\n\t\tangle_difference += 2 * M_PI;\n\t}\n\treturn angle_difference;\n}", "CodeBleu_score": 42.38873421775246}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tif (foci == NULL) {\n\t\treturn 0;\n\t}\n\tfloat angle1 = atan2(y - foci[1], x - foci[0]);\n\tfloat angle2 = atan2(y - foci[3], x - foci[2]);\n\tfloat angle = angle1 - angle2;\n\twhile (angle < -M_PI) {\n\t\tangle += 2 * M_PI;\n\t}\n\twhile (angle > M_PI) {\n\t\tangle -= 2 * M_PI;\n\t}\n\treturn angle;\n}", "CodeBleu_score": 48.27414813365976}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tif (foci == NULL) {\n\t\treturn 0;\n\t}\n\tfloat a = foci[0];\n\tfloat b = foci[1];\n\tfloat c = sqrt(pow(x - a, 2) + pow(y - b, 2));\n\tfloat d = sqrt(pow(x + a, 2) + pow(y + b, 2));\n\tfloat angle = atan((y - b) / (x - a));\n\tfloat angle2 = atan((y + b) / (x + a));\n\tfloat normal_angle = angle - angle2;\n\tif (normal_angle < 0) {\n\t\tnormal_angle += 2 * M_PI;\n\t}\n\treturn normal_angle;\n}", "CodeBleu_score": 38.665181683289376}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint min_x = vp1[start].x;\n\tint max_x = vp1[start].x;\n\tint min_y = vp1[start].y;\n\tint max_y = vp1[start].y;\n\n\tfor (int i = start; i < end; i++) {\n\t\tmin_x = std::min(min_x, vp1[i].x);\n\t\tmax_x = std::max(max_x, vp1[i].x);\n\t\tmin_y = std::min(min_y, vp1[i].y);\n\t\tmax_y = std::max(max_y, vp1[i].y);\n\t}\n\n\tint integral_above = 0;\n\tint integral_below = 0;\n\n\tfor (int i = start; i < end; i++) {\n\t\tintegral_above += std::max(0, std::min(vp1[i].y, max_y) - std::max(0, std::max(vp1[i].y, min_y)));\n\t\tintegral_below += std::max(0, std::min(vp1[i].y, min_y) - std::max(0, std::max(vp1[i].y, max_y)));\n\t}\n\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 41.91572128642955}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\t//Calculate the minimum and maximum x and y coordinates of the points in the section\n\tdouble min_x = *std::min_element(vp1.begin() + start, vp1.begin() + end, [](const VP& a, const VP& b) { return a.x < b.x; });\n\tdouble max_x = *std::max_element(vp1.begin() + start, vp1.begin() + end, [](const VP& a, const VP& b) { return a.x < b.x; });\n\tdouble min_y = *std::min_element(vp1.begin() + start, vp1.begin() + end, [](const VP& a, const VP& b) { return a.y < b.y; });\n\tdouble max_y = *std::max_element(vp1.begin() + start, vp1.begin() + end, [](const VP& a, const VP& b) { return a.y < b.y; });\n\n\t//Calculate the integral above and below the polygon section\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i + 1].y - min_y);\n\t\tintegral_below += (vp1[i].x - min_x) * (vp1[i + 1].y - max_y);\n\t}\n\n\t//Return true if the integral above is less than the integral below, indicating the section is concave; otherwise, return false, indicating the section is convex\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 35.49397907192336}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\tfor (int i = start; i < end; i++) {\n\t\tintegral_above += vp1[i].y * (max_x - vp1[i].x);\n\t\tintegral_below += vp1[i].y * (vp1[i].x - min_x);\n\t}\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 38.47984185376575}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tstatic prometheus_msgs::EllipseDet ellipse_det;\n\tstatic int num_regain = 0;\n\tstatic int num_lost = 0;\n\tstatic bool is_detected = false;\n\n\t//ROS_INFO(\"ellipse_det_cb called\");\n\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost = 0;\n\t\t\tis_detected = true;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\n\t\tif (is_detected) {\n\t\t\tellipse_det.name = msg->detection_info[i].name;\n\t\t\tellipse_det.sight_angle = msg->detection_info[i].sight_angle;\n\t\t\tellipse_det.x = msg->detection_info[i].x;\n\t\t\tellipse_det.y = msg->detection_info[i].y;\n\t\t\tellipse_det.width = msg->detection_info[i].width;\n\t\t\tellipse_det.height = msg->detection_info[i].height;\n\t\t\tellipse_det.confidence = msg->detection_info[i].confidence;\n\t\t}\n\t}\n}", "CodeBleu_score": 55.42601355645851}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tstatic prometheus_msgs::EllipseDet ellipse_det;\n\tstatic int num_lost = 0;\n\tstatic int num_regain = 0;\n\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\tif (msg->detections[i].name == \"T\") {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost = 0;\n\t\t\tellipse_det.name = \"T\";\n\t\t\tellipse_det.sight_angle = msg->detections[i].sight_angle;\n\t\t\tellipse_det.sight_angle_dot = msg->detections[i].sight_angle_dot;\n\t\t\tellipse_det.x = msg->detections[i].x;\n\t\t\tellipse_det.y = msg->detections[i].y;\n\t\t\tellipse_det.z = msg->detections[i].z;\n\t\t\tellipse_det.x_dot = msg->detections[i].x_dot;\n\t\t\tellipse_det.y_dot = msg->detections[i].y_dot;\n\t\t\tellipse_det.z_dot = msg->detections[i].z_dot;\n\t\t\tellipse_det.x_dot_dot = msg->detections[i].x_dot_dot;\n\t\t\tellipse_det.y_dot_dot = msg->detections[i].y_dot_dot;\n\t\t\tellipse_det.z_dot_dot = msg->detections[i].z_dot_dot;\n\t\t\tellipse_det.x_dot_dot_dot = msg->detections[i].x_dot_dot_dot;\n\t\t\tellipse_det.y_dot_dot_dot = msg->detections[i].y_dot_dot_dot;\n\t\t\tellipse_det.z_dot_dot_dot = msg->detections[i].z_dot_dot_dot;\n\t\t\tellipse_det.x_dot_dot_dot_dot = msg->detections[i].x_dot_dot_dot_dot;\n\t\t\tellipse_det.y_dot_dot_dot_dot = msg->detections[i].y_dot_dot_dot_dot;\n\t\t\tellipse_det.z_dot_dot_dot_dot = msg->detection", "CodeBleu_score": 30.417824566653362}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tstatic prometheus_msgs::EllipseDetection ellipse_det;\n\tstatic bool is_detected = false;\n\tstatic int num_lost = 0;\n\tstatic int num_regain = 0;\n\tstatic float sight_angle_prev = 0;\n\tstatic float sight_angle_curr = 0;\n\tstatic float sight_angle_diff = 0;\n\tstatic float sight_angle_diff_prev = 0;\n\n\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost = 0;\n\t\t\tellipse_det = msg->detection_info[i].ellipse_detection;\n\t\t\tis_detected = true;\n\t\t\tsight_angle_prev = msg->detection_info[i].sight_angle;\n\t\t\tsight_angle_curr = sight_angle_prev;\n\t\t\tsight_angle_diff = 0;\n\t\t\tsight_angle_diff_prev = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (is_detected == false) {\n\t\tnum_lost++;\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t} else {\n\t\tnum_regain++;\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\tif (is_detected == true) {\n\t\tsight_angle_curr = msg->detection_info[0].sight_angle;\n\t\tsight_angle_diff = sight_angle_curr - sight_angle_prev;\n\t\tsight_angle_diff_prev = sight_angle_diff;\n\t\tsight_angle_prev = sight_angle_curr;\n\t\tellipse_det.sight_angle = sight_angle_diff;\n\t}\n\n\tif (is_detected == true) {\n\t\tprintf_ellipse_det(ellipse_det);\n\t} else {\n\t\tprintf_ellipse_det(ellipse_det);\n\t\tprintf(\"No object detected\n\");\n\t}\n}", "CodeBleu_score": 56.57770125231663}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tif (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 46.49687078788895}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tEigen::Vector3d pos_in_map;\n\tEigen::Vector3d pos_in_map_2;\n\tpos_in_map = Occupy_map_ptr->transform_to_map(cur_pos);\n\tpos_in_map_2 = Occupy_map_ptr->transform_to_map(cur_pos + safe_distance * Eigen::Vector3d(0, 0, 1));\n\treturn Occupy_map_ptr->is_occupied(pos_in_map) || Occupy_map_ptr->is_occupied(pos_in_map_2);\n}", "CodeBleu_score": 41.906635575669746}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr curr_node = end_node;\n\twhile (curr_node->parent!= nullptr) {\n\t\tpath_nodes_.push_back(curr_node);\n\t\tcurr_node = curr_node->parent;\n\t}\n\tpath_nodes_.push_back(curr_node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.94227947145687}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_front(current_node);\n\t\tcurrent_node = current_node->parent_;\n\t}\n}", "CodeBleu_score": 37.083009794644404}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\tpath_nodes_.push_back(current_node);\n\twhile (current_node->parent!= nullptr) {\n\t\tcurrent_node = current_node->parent;\n\t\tpath_nodes_.push_back(current_node);\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 63.176737883522826}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"odom: %f, %f, %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\t//ROS_INFO(\"id: %d\", id);\n\t//ROS_INFO(\"nei_odom_cb: %f, %f, %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f, %f, %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f, %f, %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f, %f, %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f, %f, %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f, %f, %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f, %f, %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f, %f, %f\", odom->pose.pose.position.", "CodeBleu_score": 3.214082768526657}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"odom: x: %f, y: %f, z: %f, roll: %f, pitch: %f, yaw: %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z, odom->pose.pose.orientation.x, odom->pose.pose.orientation.y, odom->pose.pose.orientation.z);\n\t//ROS_INFO(\"odom: x: %f, y: %f, z: %f, roll: %f, pitch: %f, yaw: %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z, odom->pose.pose.orientation.x, odom->pose.pose.orientation.y, odom->pose.pose.orientation.z);\n\t//ROS_INFO(\"odom: x: %f, y: %f, z: %f, roll: %f, pitch: %f, yaw: %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z, odom->pose.pose.orientation.x, odom->pose.pose.orientation.y, odom->pose.pose.orientation.z);\n\t//ROS_INFO(\"odom: x: %f, y: %f, z: %f, roll: %f, pitch: %f, yaw: %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z, odom->pose.pose.orientation.x, odom->pose.pose.orientation.y, odom->pose.pose.orientation.z);\n\t//ROS_INFO(\"odom: x: %f, y: %f, z: %f, roll: %f, pitch: %f, yaw: %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z, o", "CodeBleu_score": 6.104451140342529}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"id: %d\", id);\n\t//ROS_INFO(\"odom: %f\", odom->pose.pose.position.x);\n\t//ROS_INFO(\"odom: %f\", odom->pose.pose.position.y);\n\t//ROS_INFO(\"odom: %f\", odom->pose.pose.position.z);\n\t//ROS_INFO(\"odom: %f\", odom->pose.pose.orientation.x);\n\t//ROS_INFO(\"odom: %f\", odom->pose.pose.orientation.y);\n\t//ROS_INFO(\"odom: %f\", odom->pose.pose.orientation.z);\n\t//ROS_INFO(\"odom: %f\", odom->pose.pose.orientation.w);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[0]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[1]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[2]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[3]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[4]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[5]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[6]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[7]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[8]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[9]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[10]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[11]);\n\t//ROS_INFO(\"odom: %f\", odom->pose.covariance[12]);\n\t//ROS_INFO(\"odom: %f\", o", "CodeBleu_score": 3.1699259997789317}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odometry_ready) {\n\t\treturn;\n\t}\n\tsensor_msgs::PointCloud2 pointcloud;\n\tpointcloud = *msg;\n\tsensor_msgs::PointCloud2 pointcloud_filtered;\n\tpcl_ros::transformPointCloud(\"base_link\", ros::Time(0), pointcloud, pointcloud_filtered);\n\tpcl::fromROSMsg(pointcloud_filtered, pointcloud_filtered_pcl);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\tsor.setInputCloud(cloud_filtered_pcl.makeShared());\n\tsor.setLeafSize(0.1f, 0.1f, 0.1f);\n\tsor.filter(*cloud_filtered_downsampled);\n\tpcl::toROSMsg(*cloud_filtered_downsampled, pointcloud_filtered);\n\tpointcloud_filtered.header.frame_id = \"base_link\";\n\tpointcloud_filtered.header.stamp = ros::Time::now();\n\tpointcloud_filtered.header.seq = pointcloud_filtered.header.seq + 1;\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(pointcloud_filtered, *cloud_filtered_downsampled_pcl);\n\tif (update_counter % 5 == 0) {\n\t\tmap_mutex.lock();\n\t\tmap_mutex.unlock();\n\t\tupdate_counter = 0;\n\t}\n\tupdate_counter++;\n}", "CodeBleu_score": 39.14046231139064}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t// Check if odometry is ready\n\tif (!odom_ready) {\n\t\tROS_WARN_STREAM(\"GlobalPlannerUGV::Gpointcloud_cb: Odometry not ready yet\");\n\t\treturn;\n\t}\n\n\t// Check if sensor_ready is true\n\tif (sensor_ready) {\n\t\t// Increment update counter\n\t\tupdate_counter++;\n\t\t// Check if update counter is 5\n\t\tif (update_counter == 5) {\n\t\t\t// Update Astar map with new point cloud data\n\t\t\tupdate_Astar_map(msg);\n\t\t\t// Reset update counter\n\t\t\tupdate_counter = 0;\n\t\t}\n\t}\n\telse {\n\t\t// Set sensor_ready to true\n\t\tsensor_ready = true;\n\t\t// Increment update counter\n\t\tupdate_counter++;\n\t\t// Check if update counter is 5\n\t\tif (update_counter == 5) {\n\t\t\t// Update Astar map with new point cloud data\n\t\t\tupdate_Astar_map(msg);\n\t\t\t// Reset update counter\n\t\t\tupdate_counter = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 46.102476999044676}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready)\n\t\treturn;\n\tsensor_msgs::PointCloud2::ConstPtr cloud_msg = msg;\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*cloud_msg, *cloud);\n\tif (cloud->points.size() > 0) {\n\t\tsensor_ready = true;\n\t\tif (update_counter % 5 == 0) {\n\t\t\tupdate_counter = 0;\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\t*cloud_ptr = *cloud;\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_transformed_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_transformed_filtered_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_transformed_filtered_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_transformed_filtered_transformed_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_transformed_filtered_transformed_transformed_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_transformed_filtered_transformed_transformed_transformed_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_transformed_filtered_transformed_transformed_transformed_transformed_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_transformed_filtered_transformed_transformed_transformed_transformed_transformed_transformed_transformed(new pcl::PointCloud<pcl::", "CodeBleu_score": 32.90257888924265}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\t//convert sensor message to point cloud\n\t\tpcl::PointCloud<pcl::PointXYZ> global_point_cloud;\n\t\tpcl::fromROSMsg(*global_point, global_point_cloud);\n\n\t\t//store point cloud\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr point_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t*point_cloud = global_point_cloud;\n\t\tpoint_cloud_vector.push_back(point_cloud);\n\n\t\t//inflate point cloud\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr inflated_point_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud_2(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud_3(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud_4(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud_5(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud_6(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud_7(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud_8(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud_9(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud_10(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr filtered_point_cloud_11(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::Point", "CodeBleu_score": 41.14110030026846}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl == false) {\n\t\tgpcl = global_point;\n\t\tget_gpcl = true;\n\t\tROS_INFO(\"Global point cloud received.\");\n\t\tROS_INFO(\"Global point cloud inflation started.\");\n\t\tmap_update_gpcl_inflation();\n\t\tROS_INFO(\"Global point cloud inflation ended.\");\n\t\tROS_INFO(\"Global point cloud updated.\");\n\t}\n}", "CodeBleu_score": 49.873936671898555}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl) {\n\t\treturn;\n\t}\n\tget_gpcl = true;\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*global_point, *cloud);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_outlier(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_outlier_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_outlier_filtered_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_outlier_filtered_filtered_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_outlier_filtered_filtered_filtered_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_outlier_filtered_filtered_filtered_filtered_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_outlier_filtered_filtered_filtered_filtered_filtered_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_outlier_filtered_filtered_filtered_filtered_filtered_filtered_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_outlier_filtered_filtered_filtered_filtered_filtered_filtered_filtered_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_outlier_filtered_filtered_filtered_filtered_filtered_filtered_filtered_filtered_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n", "CodeBleu_score": 52.068144258215064}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// if in simulation mode, do not update the map\n\tif (sim_mode)\n\t\treturn;\n\n\t// convert the laser scan data into a PointCloud2 format\n\tsensor_msgs::PointCloud2 laser_cloud;\n\tpcl::toROSMsg(*laser_cloud_ptr, laser_cloud);\n\tlaser_cloud.header.frame_id = \"base_laser_link\";\n\tlaser_cloud.header.stamp = ros::Time::now();\n\n\t// convert the PointCloud2 to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> laser_cloud_pcl;\n\tpcl::fromROSMsg(laser_cloud, laser_cloud_pcl);\n\n\t// transform the laser cloud to the map frame\n\tpcl_ros::transformPointCloud(map_frame, laser_cloud_pcl, laser_cloud_pcl, map_transform);\n\n\t// merge the local map with the laser scan data\n\tmap_merge(laser_cloud_pcl, odom);\n}", "CodeBleu_score": 43.615162672316515}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// if not in simulation mode, merge the local map with the odometry data\n\tif (!sim_mode) {\n\t\tif (map_merge_odom) {\n\t\t\t// merge the local map with the odometry data\n\t\t\tmerge_odom(odom);\n\t\t}\n\t}\n\t// project the laser scan into a PointCloud2 format\n\tpcl::PointCloud<pcl::PointXYZ> laser_cloud;\n\tlaser_cloud.header.frame_id = \"map\";\n\tlaser_cloud.header.stamp = ros::Time::now();\n\tpcl::fromROSMsg(*local_point, laser_cloud);\n\t// convert the PointCloud2 to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(laser_cloud));\n\t// convert the pcl::PointCloud to a sensor_msgs::PointCloud2\n\tpcl::toROSMsg(*cloud_ptr, cloud_msg);\n\t// update the occupancy map\n\tupdate_map(cloud_msg);\n}", "CodeBleu_score": 48.75688439913221}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t//ROS_INFO(\"Map update laser\");\n\t//ROS_INFO(\"Map update laser %f\", odom.pose.pose.position.x);\n\t//ROS_INFO(\"Map update laser %f\", odom.pose.pose.position.y);\n\t//ROS_INFO(\"Map update laser %f\", odom.pose.pose.position.z);\n\t//ROS_INFO(\"Map update laser %f\", odom.pose.pose.orientation.x);\n\t//ROS_INFO(\"Map update laser %f\", odom.pose.pose.orientation.y);\n\t//ROS_INFO(\"Map update laser %f\", odom.pose.pose.orientation.z);\n\t//ROS_INFO(\"Map update laser %f\", odom.pose.pose.orientation.w);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.twist.linear.x);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.twist.linear.y);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.twist.linear.z);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.twist.angular.x);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.twist.angular.y);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.twist.angular.z);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.covariance[0]);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.covariance[7]);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.covariance[14]);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.covariance[21]);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.covariance[28]);\n\t//ROS_INFO(\"Map update laser %f\", odom.twist.covariance[35]);\n\t//ROS_INFO(\"Map update laser %f\", odom.pose.covariance[0]);\n\t//ROS_INFO(\"", "CodeBleu_score": 9.54836612082838}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t//ROS_INFO(\"Publishing point cloud\");\n\t// Convert the global point cloud map to a ROS message\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl;\n\tglobal_pcl.header.frame_id = \"world\";\n\tglobal_pcl.header.stamp = ros::Time::now();\n\tglobal_pcl.width = global_map.cols;\n\tglobal_pcl.height = global_map.rows;\n\tglobal_pcl.is_dense = false;\n\tglobal_pcl.points.resize(global_pcl.width * global_pcl.height);\n\n\tfor (int i = 0; i < global_pcl.height; i++) {\n\t\tfor (int j = 0; j < global_pcl.width; j++) {\n\t\t\tglobal_pcl.points[i * global_pcl.width + j].x = j * resolution;\n\t\t\tglobal_pcl.points[i * global_pcl.width + j].y = i * resolution;\n\t\t\tglobal_pcl.points[i * global_pcl.width + j].z = global_map.at<float>(i, j);\n\t\t}\n\t}\n\n\t// Publish the global point cloud\n\tglobal_pcl_pub.publish(global_pcl);\n\n\t// Convert the inflated point cloud map to a ROS message\n\tpcl::PointCloud<pcl::PointXYZ> inflate_pcl;\n\tinflate_pcl.header.frame_id = \"world\";\n\tinflate_pcl.header.stamp = ros::Time::now();\n\tinflate_pcl.width = inflate_map.cols;\n\tinflate_pcl.height = inflate_map.rows;\n\tinflate_pcl.is_dense = false;\n\tinflate_pcl.points.resize(inflate_pcl.width * inflate_pcl.height);\n\n\tfor (int i = 0; i < inflate_pcl.height; i++) {\n\t\tfor (int j = 0; j < inflate_pcl.width; j++) {\n\t\t\tinflate_pcl.points[i * inflate_pcl.width + j].x = j * resolution;\n\t\t\tinflate_pcl.points[i * inflate_pcl.width + j].y = i * resolution;\n\t\t\tinflate_pcl.points[i * inf", "CodeBleu_score": 45.515680999456656}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Create a ROS message of type sensor_msgs::PointCloud2\n\tsensor_msgs::PointCloud2 ros_pc;\n\t// Convert the global point cloud map to a ROS message\n\tpcl::toROSMsg(*pc_map_, ros_pc);\n\t// Publish the point cloud message\n\tglobal_pcl_pub_.publish(ros_pc);\n\t// Convert the inflated point cloud to a ROS message\n\tpcl::toROSMsg(*inflate_pc_map_, ros_pc);\n\t// Publish the inflated point cloud message\n\tinflate_pcl_pub_.publish(ros_pc);\n}", "CodeBleu_score": 37.31090087643718}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert the point cloud map to a ROS message and publish it\n\tsensor_msgs::PointCloud2 pcl_msg;\n\tpcl::toROSMsg(*map_, pcl_msg);\n\tpcl_msg.header.frame_id = \"world\";\n\tpcl_msg.header.stamp = ros::Time::now();\n\tglobal_pcl_pub_.publish(pcl_msg);\n\n\t// Convert the inflated point cloud to a ROS message and publish it\n\tpcl::toROSMsg(*inflate_map_, inflate_pcl_msg_);\n\tinflate_pcl_msg_.header.frame_id = \"world\";\n\tinflate_pcl_msg_.header.stamp = ros::Time::now();\n\tinflate_pcl_pub_.publish(inflate_pcl_msg_);\n}", "CodeBleu_score": 55.183342366509926}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odometry_ready) {\n\t\tsensor_ready = true;\n\t\tpcl::fromROSMsg(*msg, pointcloud);\n\t\tpcl::toROSMsg(pointcloud, pointcloud_ros);\n\t\tpointcloud_ros.header.frame_id = \"map\";\n\t\tpointcloud_ros.header.stamp = ros::Time::now();\n\t\tpointcloud_pub.publish(pointcloud_ros);\n\t}\n}", "CodeBleu_score": 46.32667575039363}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: %d\", msg->data.size());\n\n\t// Get the sensor_ready flag\n\tbool sensor_ready = false;\n\tsensor_ready = this->sensor_ready.load();\n\n\t// If the sensor_ready flag is true, then update the A* map\n\tif (sensor_ready) {\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\n\t\t// Create a new point cloud\n\t\tsensor_msgs::PointCloud2::Ptr new_cloud(new sensor_msgs::PointCloud2);\n\t\t*new_cloud = *msg;\n\n\t\t// Update the A* map\n\t\tthis->planner.updateMap(new_cloud);\n\n\t\t// Update the A* map\n\t\tthis->planner.updateMap(new_cloud);\n\t}\n}", "CodeBleu_score": 38.391635008878126}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odometry_ready) {\n\t\tsensor_ready = true;\n\t}\n\tpcl::fromROSMsg(*msg, *pointcloud);\n\t//ROS_INFO(\"pointcloud received\");\n}", "CodeBleu_score": 41.9050345319976}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\tros::Time now = ros::Time::now();\n\tros::Duration dt = now - last_control_loop_time_;\n\tlast_control_loop_time_ = now;\n\n\t// Get the desired pose from the body controller\n\tgeometry_msgs::PoseStamped desired_pose;\n\tbody_controller_->getDesiredPose(desired_pose);\n\n\t// Calculate the target foot positions based on the desired pose\n\tgeometry_msgs::PoseStamped target_foot_positions;\n\tbody_controller_->calculateTargetFootPositions(desired_pose, target_foot_positions);\n\n\t// Compute velocity commands for the legs and perform inverse kinematics to determine target joint positions\n\tgeometry_msgs::PoseStamped target_joint_positions;\n\tbody_controller_->computeLegVelocityCommands(target_foot_positions, target_joint_positions);\n\n\t// Publish foot contact information and joint positions\n\tpublishFootContactInformation(target_foot_positions);\n\tpublishJointPositions(target_joint_positions);\n}", "CodeBleu_score": 48.921824656974756}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\tros::Time t0 = ros::Time::now();\n\tros::Duration dt = t0 - last_control_loop_time_;\n\tlast_control_loop_time_ = t0;\n\n\t// Get current pose\n\tgeometry_msgs::PoseStamped current_pose;\n\tif (!getPose_(current_pose)) {\n\t\tROS_ERROR(\"Failed to get current pose\");\n\t\treturn;\n\t}\n\n\t// Get desired pose\n\tgeometry_msgs::PoseStamped desired_pose;\n\tif (!getDesiredPose_(desired_pose)) {\n\t\tROS_ERROR(\"Failed to get desired pose\");\n\t\treturn;\n\t}\n\n\t// Get current foot contact\n\tstd::vector<bool> current_foot_contact;\n\tif (!getFootContact_(current_foot_contact)) {\n\t\tROS_ERROR(\"Failed to get current foot contact\");\n\t\treturn;\n\t}\n\n\t// Get current joint positions\n\tstd::vector<double> current_joint_positions;\n\tif (!getJointPositions_(current_joint_positions)) {\n\t\tROS_ERROR(\"Failed to get current joint positions\");\n\t\treturn;\n\t}\n\n\t// Get current joint velocities\n\tstd::vector<double> current_joint_velocities;\n\tif (!getJointVelocities_(current_joint_velocities)) {\n\t\tROS_ERROR(\"Failed to get current joint velocities\");\n\t\treturn;\n\t}\n\n\t// Compute target foot positions\n\tstd::vector<geometry_msgs::Pose> target_foot_positions;\n\tif (!computeTargetFootPositions_(current_pose, desired_pose, current_foot_contact, target_foot_positions)) {\n\t\tROS_ERROR(\"Failed to compute target foot positions\");\n\t\treturn;\n\t}\n\n\t// Compute target joint positions\n\tstd::vector<double> target_joint_positions;\n\tif (!computeTargetJointPositions_(current_pose, desired_pose, current_foot_contact, current_joint_positions, current_joint_velocities, target_foot_positions, target_joint_positions)) {\n\t\tROS_ERROR(\"Failed to compute target joint positions\");\n\t\treturn;\n\t}\n\n\t// Publish foot contact information\n\tif (!publishFootContact_(current_foot_contact)) {\n\t\tROS_ERROR(\"", "CodeBleu_score": 34.54412747947557}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get the current time\n\tros::Time current_time = ros::Time::now();\n\n\t// Get the desired pose\n\tQuadrupedPose desired_pose;\n\tif (!this->getDesiredPose(desired_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get desired pose.\");\n\t\treturn;\n\t}\n\n\t// Get the current pose\n\tQuadrupedPose current_pose;\n\tif (!this->getCurrentPose(current_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get current pose.\");\n\t\treturn;\n\t}\n\n\t// Get the current joint positions\n\tQuadrupedJointPositions current_joint_positions;\n\tif (!this->getCurrentJointPositions(current_joint_positions)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get current joint positions.\");\n\t\treturn;\n\t}\n\n\t// Get the current foot contact information\n\tQuadrupedFootContact current_foot_contact;\n\tif (!this->getCurrentFootContact(current_foot_contact)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get current foot contact.\");\n\t\treturn;\n\t}\n\n\t// Get the current body controller\n\tQuadrupedBodyController current_body_controller;\n\tif (!this->getCurrentBodyController(current_body_controller)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get current body controller.\");\n\t\treturn;\n\t}\n\n\t// Get the current leg controller\n\tQuadrupedLegController current_leg_controller;\n\tif (!this->getCurrentLegController(current_leg_controller)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get current leg controller.\");\n\t\treturn;\n\t}\n\n\t// Get the current leg controller\n\tQuadrupedLegController current_leg_controller;\n\tif (!this->getCurrentLegController(current_leg_controller)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get current leg controller.\");\n\t\treturn;\n\t}\n\n\t// Get the current leg controller\n\tQuadrupedLegController current_leg_controller;\n\tif (!this->getCurrentLeg", "CodeBleu_score": 35.14920814515528}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\t// Create message\n\t\tquadruped_msgs::ContactsStamped msg;\n\t\tmsg.header.stamp = ros::Time::now();\n\t\tmsg.header.frame_id = \"world\";\n\t\tmsg.contacts.resize(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tmsg.contacts[i].phase = foot_contacts[i];\n\t\t}\n\t\tfoot_contacts_publisher_.publish(msg);\n\t}\n}", "CodeBleu_score": 49.055398781619516}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\tif (foot_contacts_publisher_.getTopic().compare(\"/foot_contacts\") == 0) {\n\t\t\tif (gazebo_robot_model_) {\n\t\t\t\tROS_WARN(\"Foot contact publishing is enabled but the robot is not in Gazebo. Foot contact messages will not be published.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Create the message\n\t\t\tquadruped_msgs::ContactsStamped msg;\n\t\t\tmsg.header.stamp = ros::Time::now();\n\t\t\tmsg.header.frame_id = \"base_footprint\";\n\t\t\tmsg.contacts.resize(4);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tmsg.contacts[i].contact_type = foot_contacts[i]? quadruped_msgs::ContactState::CONTACT : quadruped_msgs::ContactState::NO_CONTACT;\n\t\t\t}\n\t\t\tfoot_contacts_publisher_.publish(msg);\n\t\t} else {\n\t\t\tROS_WARN(\"Foot contact publishing is enabled but the foot_contacts_publisher_ topic is not set to /foot_contacts. Foot contact messages will not be published.\");\n\t\t}\n\t}\n}", "CodeBleu_score": 46.21180219352898}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\t// create the message\n\t\tquadruped_msgs::ContactsStamped msg;\n\t\tmsg.header.stamp = ros::Time::now();\n\t\tmsg.header.frame_id = \"world\";\n\t\tmsg.contacts.resize(4);\n\t\tmsg.contacts[0].phase = foot_contacts[0]? quadruped_msgs::ContactState::CONTACT : quadruped_msgs::ContactState::NO_CONTACT;\n\t\tmsg.contacts[1].phase = foot_contacts[1]? quadruped_msgs::ContactState::CONTACT : quadruped_msgs::ContactState::NO_CONTACT;\n\t\tmsg.contacts[2].phase = foot_contacts[2]? quadruped_msgs::ContactState::CONTACT : quadruped_msgs::ContactState::NO_CONTACT;\n\t\tmsg.contacts[3].phase = foot_contacts[3]? quadruped_msgs::ContactState::CONTACT : quadruped_msgs::ContactState::NO_CONTACT;\n\t\tfoot_contacts_publisher_.publish(msg);\n\t}\n}", "CodeBleu_score": 39.131206733587625}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\tself.joints_pub.publish(joints)\n\tself.joint_trajectory_pub.publish(self.trajectory_msg)\n}", "CodeBleu_score": 12.781722934365517}, {"code": "def joints_cmd_callback(self, joints){\n\t\t# Create a minimal joints message with the first 12 joint positions\n\tmsg = Joints()\n\tmsg.position = joints.position[0:12]\n\t# Publish the minimal joints message\n\tself.joints_pub.publish(msg)\n\t# Construct a joint trajectory message with the same positions and a specified duration\n\tmsg = JointTrajectory()\n\tmsg.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6', 'joint7', 'joint8', 'joint9', 'joint10', 'joint11', 'joint12']\n\tmsg.points.append(JointTrajectoryPoint())\n\tmsg.points[0].positions = msg.joint_names\n\tmsg.points[0].positions = joints.position[0:12]\n\tmsg.points[0].time_from_start = rospy.Duration(self.duration)\n\t# Publish the joint trajectory message\n\tself.joint_traj_pub.publish(msg)\n}", "CodeBleu_score": 35.85698429333999}, {"code": "def joints_cmd_callback(self, joints){\n\t\tself.joints_msg = Joints()\n\tself.joints_msg.joint_names = self.joint_names\n\tself.joints_msg.positions = joints.positions\n\tself.joints_msg.velocities = joints.velocities\n\tself.joints_msg.accelerations = joints.accelerations\n\tself.joints_msg.effort = joints.effort\n\tself.joints_msg.header.stamp = rospy.Time.now()\n\tself.joints_msg.header.frame_id = \"base_link\"\n\tself.joints_pub.publish(self.joints_msg)\n\tself.joints_traj_msg = JointTrajectory()\n\tself.joints_traj_msg.joint_names = self.joint_names\n\tself.joints_traj_msg.header.stamp = rospy.Time.now()\n\tself.joints_traj_msg.header.frame_id = \"base_link\"\n\tself.joints_traj_msg.points.append(JointTrajectoryPoint())\n\tself.joints_traj_msg.points[0].positions = self.joints_msg.positions\n\tself.joints_traj_msg.points[0].velocities = self.joints_msg.velocities\n\tself.joints_traj_msg.points[0].accelerations = self.joints_msg.accelerations\n\tself.joints_traj_msg.points[0].effort = self.joints_msg.effort\n\tself.joints_traj_msg.points[0].time_from_start = rospy.Duration(self.traj_duration)\n\tself.joints_traj_pub.publish(self.joints_traj_msg)\n\treturn\n}", "CodeBleu_score": 30.85673825517749}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize foot contact states to false\n\tbool leftFootContact = false;\n\tbool rightFootContact = false;\n\n\t// Iterate over the contacts\n\tfor (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::string collision = _msg->contact(i).collision1();\n\t\tstd::vector<std::string> split;\n\t\tboost::split(split, collision, boost::is_any_of(\"/\"));\n\t\tstd::string link = split[split.size() - 1];\n\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tif (link == \"left_foot\") {\n\t\t\tleftFootContact = true;\n\t\t} else if (link == \"right_foot\") {\n\t\t\trightFootContact = true;\n\t\t}\n\t}\n\n\t// Set the foot contact states in the foot contact state message\n\tfootContactStateMsg.leftFootContact = leftFootContact;\n\tfootContactStateMsg.rightFootContact = rightFootContact;\n}", "CodeBleu_score": 44.36628255195543}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"Gazebo callback\");\n\t//ROS_INFO(\"", "CodeBleu_score": 1.3983365371406244}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tstd::vector<std::string> contact_names;\n\tstd::vector<std::string> contact_links;\n\tstd::vector<std::string> contact_frames;\n\tstd::vector<std::string> contact_bodies;\n\tstd::vector<std::string> contact_names_split;\n\tstd::vector<std::string> contact_links_split;\n\tstd::vector<std::string> contact_frames_split;\n\tstd::vector<std::string> contact_bodies_split;\n\tstd::vector<std::string> contact_names_split_2;\n\tstd::vector<std::string> contact_links_split_2;\n\tstd::vector<std::string> contact_frames_split_2;\n\tstd::vector<std::string> contact_bodies_split_2;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::endl;\n\n\t//std::cout << \"gazeboCallback_\" << std::", "CodeBleu_score": 8.582685408392127}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tif (!this->active_) {\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t(*rotor_velocities)[i] = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tEigen::Vector3d desired_acceleration = this->desired_acceleration_;\n\tEigen::Vector3d angular_acceleration = this->angular_acceleration_;\n\n\t// Project thrust onto the body z-axis.\n\tEigen::Vector3d thrust_body_z = this->thrust_ * this->body_z_;\n\t// Combine angular acceleration and thrust into a single vector.\n\tEigen::Vector3d angular_acceleration_thrust = angular_acceleration + thrust_body_z;\n\n\t// Compute the rotor velocities.\n\tEigen::Matrix3d rotor_velocities_matrix = this->rotor_velocities_matrix_;\n\tfor (int i = 0; i < 3; i++) {\n\t\t(*rotor_velocities)[i] = std::sqrt(rotor_velocities_matrix(i, 0) * angular_acceleration_thrust[0] + rotor_velocities_matrix(i, 1) * angular_acceleration_thrust[1] + rotor_velocities_matrix(i, 2) * angular_acceleration_thrust[2]);\n\t}\n\n\t// Ensure non-negative values.\n\tfor (int i = 0; i < 3; i++) {\n\t\tif ((*rotor_velocities)[i] < 0) {\n\t\t\t(*rotor_velocities)[i] = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 33.91087230523748}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tif (!active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\tEigen::Vector3d acceleration;\n\tacceleration << 0, 0, 0;\n\n\tEigen::Vector3d angular_acceleration;\n\tangular_acceleration << 0, 0, 0;\n\n\tif (desired_acceleration_valid_) {\n\t\tacceleration = desired_acceleration_;\n\t}\n\n\tif (desired_angular_acceleration_valid_) {\n\t\tangular_acceleration = desired_angular_acceleration_;\n\t}\n\n\tEigen::Vector3d thrust_body;\n\tthrust_body << 0, 0, 0;\n\n\tif (acceleration.norm() > 0) {\n\t\tthrust_body = acceleration.normalized() * (acceleration.norm() - vehicle_parameters_.gravity);\n\t}\n\n\tEigen::Vector3d angular_acceleration_body;\n\tangular_acceleration_body << 0, 0, 0;\n\n\tif (angular_acceleration.norm() > 0) {\n\t\tangular_acceleration_body = angular_acceleration.normalized();\n\t}\n\n\tEigen::Vector3d thrust_body_rotated;\n\tthrust_body_rotated << 0, 0, 0;\n\n\tif (vehicle_parameters_.rotor_direction.norm() > 0) {\n\t\tthrust_body_rotated = vehicle_parameters_.rotor_direction.normalized() * thrust_body.dot(vehicle_parameters_.rotor_direction.normalized());\n\t}\n\n\tEigen::Vector3d angular_acceleration_body_rotated;\n\tangular_acceleration_body_rotated << 0, 0, 0;\n\n\tif (vehicle_parameters_.rotor_direction.norm() > 0) {\n\t\tangular_acceleration_body_rotated = vehicle_parameters_.rotor_direction.normalized() * angular_acceleration_body.dot(vehicle_parameters_.rotor_direction.normalized());\n\t}\n\n\tEigen::Vector3d rotor_velocities_body;\n\trotor_velocities_body << 0, 0, 0;\n\n\tif (thrust_body_rotated.norm() > 0) {\n\t\trotor_velocities_body = thrust_", "CodeBleu_score": 38.0651141130352}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Check if the controller is active\n\tif (!is_active_) {\n\t\t// If not, set all rotor velocities to zero\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\t// Compute desired acceleration and angular acceleration\n\tEigen::Vector3d desired_acceleration = desired_position_ - current_position_;\n\tEigen::Vector3d desired_angular_acceleration = (desired_velocity_ - current_velocity_) / dt_;\n\n\t// Project thrust onto the body z-axis\n\tEigen::Vector3d thrust_body = thrust_ * Eigen::Vector3d(0, 0, 1);\n\n\t// Combine angular acceleration and thrust into a single vector\n\tEigen::Vector3d acceleration_body = desired_angular_acceleration + thrust_body;\n\n\t// Compute rotor velocities by multiplying with a predefined matrix, ensuring non-negative values, and taking the square root of each component\n\tEigen::Matrix3d rotor_velocities_matrix;\n\trotor_velocities_matrix << 1, 1, 1, 1, 1, 1, 1, 1, 1;\n\trotor_velocities_matrix *= acceleration_body.cwiseAbs();\n\trotor_velocities_matrix = rotor_velocities_matrix.cwiseSqrt();\n\n\t// Assign the computed rotor velocities to the output vector\n\trotor_velocities->setZero();\n\trotor_velocities->segment<3>(0) = rotor_velocities_matrix.row(0);\n\trotor_velocities->segment<3>(3) = rotor_velocities_matrix.row(1);\n\trotor_velocities->segment<3>(6) = rotor_velocities_matrix.row(2);\n}", "CodeBleu_score": 36.918360421302765}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d commanded_acceleration;\n\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d acceleration_error;\n\tEigen::Vector3d acceleration_desired;\n\n\t// Calculate the position error\n\tposition_error = command_trajectory_.GetPosition() - odometry_.GetPosition();\n\n\t// Calculate the velocity error\n\tvelocity_error = command_trajectory_.GetVelocity() - odometry_.GetVelocity();\n\n\t// Calculate the acceleration error\n\tacceleration_error = command_trajectory_.GetAcceleration() - odometry_.GetAcceleration();\n\n\t// Calculate the commanded acceleration\n\tcommanded_acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error + acceleration_gain_ * acceleration_error;\n\n\t// Calculate the acceleration desired\n\tacceleration_desired = commanded_acceleration - mass_ * gravity_ * odometry_.GetOrientation();\n\n\t// Assign the acceleration desired to the acceleration variable\n\t*acceleration = acceleration_desired;\n}", "CodeBleu_score": 46.82714277061987}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d world_velocity;\n\tEigen::Vector3d world_position;\n\tEigen::Vector3d world_acceleration;\n\tEigen::Vector3d commanded_acceleration;\n\tEigen::Vector3d commanded_velocity;\n\tEigen::Vector3d commanded_position;\n\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d acceleration_error;\n\tEigen::Vector3d desired_acceleration;\n\tEigen::Vector3d desired_velocity;\n\tEigen::Vector3d desired_position;\n\tEigen::Vector3d desired_velocity_error;\n\tEigen::Vector3d desired_position_error;\n\tEigen::Vector3d desired_acceleration_error;\n\tEigen::Vector3d desired_acceleration_error_integrated;\n\tEigen::Vector3d desired_velocity_error_integrated;\n\tEigen::Vector3d desired_position_error_integrated;\n\tEigen::Vector3d desired_acceleration_integrated;\n\tEigen::Vector3d desired_velocity_integrated;\n\tEigen::Vector3d desired_position_integrated;\n\tEigen::Vector3d desired_acceleration_integrated_error;\n\tEigen::Vector3d desired_velocity_integrated_error;\n\tEigen::Vector3d desired_position_integrated_error;\n\tEigen::Vector3d desired_acceleration_integrated_error_integrated;\n\tEigen::Vector3d desired_velocity_integrated_error_integrated;\n\tEigen::Vector3d desired_position_integrated_error_integrated;\n\tEigen::Vector3d desired_acceleration_integrated_error_integrated;\n\tEigen::Vector3d desired_velocity_integrated_error_integrated;\n\tEigen::Vector3d desired_position_integrated_error_integrated;\n\tEigen::Vector3d desired_acceleration_integrated_error_integrated;\n\tEigen::Vector3d desired_velocity_integrated_error_integrated;\n\tEigen::Vector3d desired_position_integrated_error_integrated;\n\tEigen::Vector3d desired_acceleration_integrated_error_integrated;\n\tEigen::Vector3d desired", "CodeBleu_score": 20.062639588285187}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d desired_acceleration;\n\tEigen::Vector3d commanded_acceleration;\n\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d acceleration_error;\n\tEigen::Vector3d acceleration_error_dot;\n\tEigen::Vector3d world_velocity;\n\tEigen::Vector3d world_position;\n\tEigen::Vector3d world_position_dot;\n\tEigen::Vector3d world_acceleration;\n\tEigen::Vector3d world_acceleration_dot;\n\tEigen::Vector3d world_angular_velocity;\n\tEigen::Vector3d world_angular_acceleration;\n\tEigen::Vector3d world_angular_acceleration_dot;\n\tEigen::Vector3d world_angular_velocity_dot;\n\tEigen::Vector3d world_angular_velocity_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot_dot_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot_dot_dot_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot_dot_dot_dot_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot_dot_dot_dot_dot_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot_dot_dot_dot_dot_dot_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot;\n\tEigen::Vector3d world_angular_acceleration_dot", "CodeBleu_score": 13.05358515566158}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Check the input is valid\n\tif (rotor_velocities == NULL) {\n\t\tstd::cout << \"ERROR: AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is NULL\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Resize the rotor velocities vector to match the number of rotors\n\trotor_velocities->resize(rotors_count_);\n\n\t// Calculate the desired angular acceleration\n\tEigen::Vector3d desired_angular_acceleration = CalculateDesiredAngularAcceleration();\n\n\t// Combine the desired angular acceleration and thrust reference into a single vector\n\tEigen::Vector3d thrust_reference_angular_acceleration = thrust_reference_ * desired_angular_acceleration;\n\n\t// Calculate the rotor velocities\n\tfor (int i = 0; i < rotors_count_; i++) {\n\t\trotor_velocities->operator[](i) = thrust_reference_angular_acceleration.operator[](i) * rotor_velocities_matrix_.operator()(i, 0);\n\t}\n\n\t// Ensure the rotor velocities are at least one\n\tfor (int i = 0; i < rotors_count_; i++) {\n\t\tif (rotor_velocities->operator[](i) < 1) {\n\t\t\trotor_velocities->operator[](i) = 1;\n\t\t}\n\t}\n\n\t// Take the square root of each rotor velocity\n\tfor (int i = 0; i < rotors_count_; i++) {\n\t\trotor_velocities->operator[](i) = std::sqrt(rotor_velocities->operator[](i));\n\t}\n}", "CodeBleu_score": 40.498642529209086}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Ensure the input is valid\n\tif (!rotor_velocities) {\n\t\tstd::cout << \"Error in AttitudeControllerSamy::CalculateRotorVelocities: The input pointer is null.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the input has the correct size\n\tif (rotor_velocities->size()!= 3) {\n\t\tstd::cout << \"Error in AttitudeControllerSamy::CalculateRotorVelocities: The input vector is not the correct size.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the thrust reference is valid\n\tif (!thrust_ref_) {\n\t\tstd::cout << \"Error in AttitudeControllerSamy::CalculateRotorVelocities: The thrust reference is null.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the desired angular acceleration is valid\n\tif (!desired_angular_acceleration_) {\n\t\tstd::cout << \"Error in AttitudeControllerSamy::CalculateRotorVelocities: The desired angular acceleration is null.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the rotor velocities matrix is valid\n\tif (!rotor_velocities_matrix_) {\n\t\tstd::cout << \"Error in AttitudeControllerSamy::CalculateRotorVelocities: The rotor velocities matrix is null.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the rotor velocities matrix is square\n\tif (rotor_velocities_matrix_->rows()!= rotor_velocities_matrix_->cols()) {\n\t\tstd::cout << \"Error in AttitudeControllerSamy::CalculateRotorVelocities: The rotor velocities matrix is not square.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the rotor velocities matrix has the correct size\n\tif (rotor_velocities_matrix_->rows()!= 3) {\n\t\tstd::cout << \"Error in AttitudeControllerSamy::CalculateRotorVelocities: The rotor velocities matrix is not the correct size.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the rotor velocities matrix is not singular\n\tif (rotor_velocities_matrix_->determinant() == 0) {\n\t\tstd::cout << \"Error", "CodeBleu_score": 29.89369255379107}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tif (rotor_velocities == nullptr) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is null\" << std::endl;\n\t\treturn;\n\t}\n\tif (rotor_velocities->size()!= 3) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is not 3 elements long\" << std::endl;\n\t\treturn;\n\t}\n\tif (attitude_reference_ == nullptr) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: attitude_reference_ is null\" << std::endl;\n\t\treturn;\n\t}\n\tif (thrust_reference_ == nullptr) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: thrust_reference_ is null\" << std::endl;\n\t\treturn;\n\t}\n\tif (rotor_velocities->norm() == 0) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is zero\" << std::endl;\n\t\treturn;\n\t}\n\tif (rotor_velocities->norm() > 1) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is greater than 1\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Calculate the desired angular acceleration\n\tEigen::Vector3d angular_acceleration = *attitude_reference_ - (attitude_ * attitude_rate_);\n\n\t// Combine the desired angular acceleration with the thrust reference to get a single vector\n\tEigen::Vector3d thrust_and_acceleration = *thrust_reference_ + angular_acceleration;\n\n\t// Calculate the rotor velocities by multiplying with a predefined matrix, ensuring they are at least one, and taking the square root of each component\n\trotor_velocities->setZero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (thrust_and_acceleration(i) < 0) {\n\t\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: thrust_and_acceleration(\" << i", "CodeBleu_score": 36.486527609349395}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # find the indices of the start and end times\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n    # create a copy of the object\n    copy = copy.deepcopy(self)\n    # slice each attribute of the copied object\n    for i in range(len(self.data)):\n        copy.data[i] = copy.data[i][start_index:end_index]\n    return copy\n\n", "CodeBleu_score": 35.76061843191183}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.index(start_time)\n    end_index = self.index(end_time)\n    # Create a deep copy of the object\n    new_bag = copy.deepcopy(self)\n    # Update the start and end times of the bag\n    new_bag.start_time = start_time\n    new_bag.end_time = end_time\n    # Update the start and end indices of the bag\n    new_bag.start_index = start_index\n    new_bag.end_index = end_index\n    # Update the bag's data\n    new_bag.data = self.data[start_index:end_index]\n    # Update the bag's times\n    new_bag.times = self.times[start_index:end_index]\n    # Update the bag's topics\n    new_bag.topics = self.topics[start_index:end_index]\n    # Return the sliced bag\n    return new_bag\n", "CodeBleu_score": 20.888778337206325}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    if start_index is None:\n        raise ValueError(\"Start time does not exist in the data set.\")\n    if end_index is None:\n        raise ValueError(\"End time does not exist in the data set.\")\n    if start_index > end_index:\n        raise ValueError(\"Start time is after end time.\")\n    new_object = copy.deepcopy(self)\n    new_object.start_time = self.time[start_index]\n    new_object.end_time = self.time[end_index]\n    new_object.time = self.time[start_index:end_index+1]\n    new_object.pose = self.pose[start_index:end_index+1]\n    new_object.twist = self.twist[start_index:end_index+1]\n    new_object.linear_acceleration = self.linear_acceleration[start_index:end_index+1]\n    new_object.angular_velocity = self.angular_velocity[start_index:end_index+1]\n    new_object.linear_velocity = self.linear_velocity[start_index:end_index+1]\n    return new_object\n\n", "CodeBleu_score": 37.539396558580975}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n\n    # Extract position and rotation\n    pos = waypoint_msg.pose.position\n    rot = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    yaw = tf.transformations.euler_from_quaternion([rot.x, rot.y, rot.z, rot.w])[2]\n    # Create a Point object\n    point = Point(pos.x, pos.y, pos.z)\n    # Check if the current waypoint is different from the last one\n    if (self.last_point!= point) or (self.last_yaw!= yaw):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.points.append(point)\n        self.yaws.append(yaw)\n        self.times.append(msg_time)\n        self.bag_times.append(bag_time)\n        # Update the last point and yaw\n        self.last_point = point\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 21.369620409627494}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    position_x = position.x\n    position_y = position.y\n    position_z = position.z\n    rotation_x = rotation.x\n    rotation_y = rotation.y\n    rotation_z = rotation.z\n    rotation_w = rotation.w\n    yaw = tf.transformations.euler_from_quaternion([rotation_x, rotation_y, rotation_z, rotation_w])[2]\n    if self.last_position_x!= position_x or self.last_position_y!= position_y or self.last_position_z!= position_z or self.last_yaw!= yaw:\n        self.position_x.append(position_x)\n        self.position_y.append(position_y)\n        self.position_z.append(position_z)\n        self.yaw.append(yaw)\n        self.times.append(msg_time)\n        self.bag_times.append(bag_time)\n        self.last_position_x = position_x\n        self.last_position_y = position_y\n        self.last_position_z = position_z\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 17.625094389585826}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n\n    # Extract the position and rotation\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert the rotation to Euler angles\n    roll, pitch, yaw = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if not self.last_waypoint or not self.last_waypoint.point == point or not self.last_waypoint.yaw == yaw:\n        self.waypoints.append(point)\n        self.yaw.append(yaw)\n        self.times.append(msg_time)\n        self.bag_times.append(bag_time)\n        self.last_waypoint = copy.copy(waypoint_msg)\n\n", "CodeBleu_score": 27.399757200437946}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_data.append(msg)\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n\n", "CodeBleu_score": 18.66401669866999}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_data.append(msg)\n        self.imu_data_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 10 ** -9)\n        self.imu_data_bag_time.append(bag_time)\n        self.imu_data_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_data_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_data_linear_acceleration_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 30.736792933711925}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.imu_bag_time.append(bag_time)\n\n", "CodeBleu_score": 31.89963147866875}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    ax.plot(self.accel_data['x'], label=\"x\")\n    ax.plot(self.accel_data['y'], label=\"y\")\n    ax.plot(self.accel_data['z'], label=\"z\")\n    ax.legend()\n    if plot_suffix is None:\n        plot_suffix = \"\"\n    plot_filename = self.plot_prefix + \"_accelerations\" + plot_suffix + \".png\"\n    if self.save_plots:\n        pyplot.savefig(plot_filename)\n    pyplot.show()\n\n", "CodeBleu_score": 35.253454850725916}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Generate a figure\n    fig = pyplot.figure()\n    # Create a subplot\n    ax = fig.add_subplot(111)\n    # Plot the acceleration data\n    ax.plot(self.accel_x_data, label=\"x\", color=\"red\")\n    ax.plot(self.accel_y_data, label=\"y\", color=\"green\")\n    ax.plot(self.accel_z_data, label=\"z\", color=\"blue\")\n    # Add labels for the x and y axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    # Include a legend\n    ax.legend()\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = self.plot_prefix + \"_accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n        fig.savefig(filename)\n    # Close the figure\n    pyplot.close(fig)\n\n", "CodeBleu_score": 33.93383488423707}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # create figure and subplot\n    fig, ax = pyplot.subplots()\n    fig.set_size_inches(10, 10)\n    ax.set_title(\"Acceleration Data\")\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    # plot acceleration data\n    for accel_dataset in self.accel_datasets:\n        # extract data from accel_dataset\n        accel_data = accel_dataset.data\n        time = accel_dataset.time\n        # plot acceleration data\n        ax.plot(time, accel_data[:, 0], color=\"red\", label=\"X Acceleration\")\n        ax.plot(time, accel_data[:, 1], color=\"green\", label=\"Y Acceleration\")\n        ax.plot(time, accel_data[:, 2], color=\"blue\", label=\"Z Acceleration\")\n    # add legend\n    ax.legend()\n    # save figure\n    if self.save_plots:\n        if plot_suffix:\n            filename = self.plot_prefix + plot_suffix + \".png\"\n        else:\n            filename = self.plot_prefix + \".png\"\n        fig.savefig(filename)\n\n", "CodeBleu_score": 31.961090441814132}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 27.833386770158015}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces)-1):\n        compare_two_xyz(self, pose_indeces[i], pose_indeces[i+1])\n\n", "CodeBleu_score": 9.246635048667539}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 27.833386770158015}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    if start_time is None:\n        start_time = 0\n    if end_time is None:\n        end_time = self.end_time\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 39.81710376849218}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time is not None and end_time is not None:\n            if time > start_time and time < end_time:\n                collision_times.append(time)\n        elif start_time is not None:\n            if time > start_time:\n                collision_times.append(time)\n        elif end_time is not None:\n            if time < end_time:\n                collision_times.append(time)\n        else:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 38.02526583045015}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 32.146680046322444}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time_in_seconds = settling_time / 1000.0\n    start_time_in_seconds = start_time / 1000.0\n    end_time_in_seconds = end_time / 1000.0\n    settling_time_in_seconds = start_time_in_seconds + settling_time_in_seconds\n    analyze_bag.plot_angular_velocities(start_time_in_seconds, end_time_in_seconds,\n                                        settling_time_in_seconds, x_range,\n                                        plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 37.14318912652429}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 31.476525987439373}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = rospy.Duration(settling_time)\n    start_time = rospy.Time(start_time)\n    end_time = rospy.Time(end_time)\n    plot_suffix = str(plot_suffix)\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                       x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 43.345872975669195}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\t// Check if data pointer is null\n\tif (data == NULL) {\n\t\treturn;\n\t}\n\n\t// Calculate multiplier\n\tconst double multiplier = 1.0 / (std::sqrt(width * height) * 1000);\n\n\t// Calculate RMS noise\n\tconst double rmsNoise = std::sqrt(depth_noise_ * multiplier);\n\n\t// Calculate noise values\n\tconst double noise1 = rmsNoise * noise_1_;\n\tconst double noise2 = rmsNoise * noise_2_;\n\n\t// Map data to Eigen vector\n\tEigen::Map<Eigen::VectorXf> data_map(data, width * height);\n\n\t// Compute noise\n\tdata_map += Eigen::VectorXf::Random(width * height) * noise1;\n\tdata_map += Eigen::VectorXf::Random(width * height) * noise2;\n\n\t// Add noise if pixel value is in range\n\tdata_map = data_map.cwiseMax(min_depth_).cwiseMin(max_depth_);\n\n\t// Set bad point value if pixel value is out of range\n\tdata_map = data_map.cwiseEqual(min_depth_).select(bad_point_, data_map);\n\tdata_map = data_map.cwiseEqual(max_depth_).select(bad_point_, data_map);\n}", "CodeBleu_score": 44.17933978327717}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\tif (data == nullptr) {\n\t\treturn;\n\t}\n\n\t// Calculate multiplier\n\tdouble multiplier = 1.0;\n\tif (this->depth_noise_params_.min_noise_ > 0.0) {\n\t\tmultiplier = std::max(0.0, std::min(1.0, (this->depth_noise_params_.max_noise_ - this->depth_noise_params_.min_noise_) / (this->depth_noise_params_.max_depth_ - this->depth_noise_params_.min_depth_)));\n\t}\n\n\t// Calculate noise\n\tEigen::VectorXd noise(width * height);\n\tnoise.setZero();\n\tif (this->depth_noise_params_.min_noise_ > 0.0) {\n\t\tfor (uint32_t i = 0; i < width * height; ++i) {\n\t\t\tnoise[i] = multiplier * (this->depth_noise_params_.max_noise_ - this->depth_noise_params_.min_noise_) * (this->depth_noise_params_.max_depth_ - this->depth_noise_params_.min_depth_) * (this->depth_noise_params_.max_depth_ - data[i]) / (this->depth_noise_params_.max_depth_ - this->depth_noise_params_.min_depth_);\n\t\t}\n\t}\n\n\t// Apply noise\n\tfor (uint32_t i = 0; i < width * height; ++i) {\n\t\tif (data[i] >= this->depth_noise_params_.min_depth_ && data[i] <= this->depth_noise_params_.max_depth_) {\n\t\t\tdata[i] += noise[i] * (2.0 * (this->depth_noise_params_.max_depth_ - data[i]) / (this->depth_noise_params_.max_depth_ - this->depth_noise_params_.min_depth_) - 1.0);\n\t\t} else {\n\t\t\tdata[i] = this->depth_noise_params_.bad_point_;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.596882599668724}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\tif (data == NULL) {\n\t\treturn;\n\t}\n\n\t// Calculate the noise multiplier\n\tdouble multiplier = 1.0;\n\tif (depth_noise_multiplier_!= 0.0) {\n\t\tmultiplier = depth_noise_multiplier_;\n\t} else {\n\t\tmultiplier = std::max(std::min(depth_noise_multiplier_min_, depth_noise_multiplier_max_), depth_noise_multiplier_);\n\t}\n\n\t// Create Eigen vector\n\tEigen::Map<Eigen::VectorXf> data_vector(data, width * height);\n\n\t// Calculate the RMS noise\n\tdouble rms_noise = 0.0;\n\tif (depth_noise_stddev_!= 0.0) {\n\t\trms_noise = depth_noise_stddev_;\n\t} else {\n\t\trms_noise = std::max(std::min(depth_noise_stddev_min_, depth_noise_stddev_max_), depth_noise_stddev_);\n\t}\n\n\t// Calculate the noise values\n\tEigen::VectorXf noise_values = multiplier * (Eigen::VectorXf::Random(width * height) * rms_noise);\n\n\t// Add noise\n\tdata_vector += noise_values;\n}", "CodeBleu_score": 40.0531443137211}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time.\n\tros::Time sim_time = ros::Time::now();\n\n\t// Convert the simulation time to ROS time.\n\tros::Time ros_time = this->ConvertSimTimeToRosTime(sim_time);\n\n\t// Write the trajectory message to the bag file.\n\tthis->bag_writer_->write(this->waypoint_topic_, ros_time, trajectory_msg);\n}", "CodeBleu_score": 43.73644507994283}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\tROS_INFO(\"WaypointCallback\");\n  // Get the current simulation time.\n  ros::Time current_time = ros::Time::now();\n\n  // Convert the current simulation time to ROS time.\n  ros::Time ros_time = ros::Time(current_time.sec, current_time.nsec);\n\n  // Write the trajectory message to the bag file.\n  trajectory_bag_.write(waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 49.502652661291414}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get current simulation time\n\tros::Time ros_time = ros::Time::now();\n\t// Convert to ROS time\n\tros_time = ros_time.fromNSec(trajectory_msg->header.stamp.sec * 1e9 + trajectory_msg->header.stamp.nsec);\n\t// Write to bag\n\tbag_.write(trajectory_msg->header.frame_id, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 38.842500751723804}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Get the current simulation time\n\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n\t// Prepare the message\n\tmav_msgs::Actuators actuators;\n\tactuators.time_ros = ros_now;\n\n\t// Iterate through the motor joints\n\tfor (int i = 0; i < this->motor_joints.size(); i++) {\n\t\t// Get the joint name\n\t\tstd::string joint_name = this->motor_joints[i]->GetName();\n\n\t\t// Get the joint velocity\n\t\tdouble joint_velocity = this->motor_joints[i]->GetVelocity(0);\n\n\t\t// Get the slowed-down rotational velocity\n\t\tdouble slowed_down_rotational_velocity = this->slowed_down_rotational_velocities[i];\n\n\t\t// Assign the slowed-down rotational velocity to the message\n\t\tactuators.angular_velocities[i] = slowed_down_rotational_velocity;\n\t}\n\n\t// Write the message to a bag file\n\tthis->bag_file_writer.write(this->motor_topic, ros_now, actuators);\n}", "CodeBleu_score": 41.98946168339921}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time ros_time = ros::Time(now.sec, now.nsec);\n\tmav_msgs::Actuators actuators;\n\tactuators.time_stamp = ros_time;\n\n\tfor (int i = 0; i < motor_joints_.size(); i++) {\n\t\tdouble slowed_down_velocity = slowed_down_motor_velocities_[i] * 0.001;\n\t\tactuators.angular_velocities.push_back(slowed_down_velocity);\n\t}\n\n\tbag_.write(namespace_ + \"/motor_velocities\", ros_time, actuators);\n}", "CodeBleu_score": 40.246179305206056}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert the simulation time to ROS time\n\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n\t// Prepare the message for actuator velocities\n\tmav_msgs::Actuators actuators;\n\tactuators.header.stamp = ros_now;\n\tactuators.header.frame_id = \"base_link\";\n\n\t// Iterate through the motor joints\n\tfor (int i = 0; i < motor_joints_.size(); i++) {\n\t\t// Calculate the slowed-down rotational velocity\n\t\tdouble rotational_velocity = motor_joints_[i]->GetVelocity(0);\n\t\trotational_velocity = rotational_velocity * motor_slowdown_factor_;\n\n\t\t// Assign the slowed-down rotational velocity to the message\n\t\tactuators.angular_velocities.push_back(rotational_velocity);\n\t}\n\n\t// Write the data to the bag file\n\tbag_.write(motor_topic_, ros_now, actuators);\n}", "CodeBleu_score": 48.51158507241937}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\t// If debug printing is enabled, log that the callback was called.\n\tif (this->debug) {\n\t\tROS_INFO(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called.\");\n\t}\n\n\t// Convert the normalized roll, pitch, and yaw rate values to control surface angles for ailerons, elevator, and rudder respectively.\n\tdouble roll_control_surface_angle = roll_pitch_yawrate_thrust_msg->roll_normalized * this->aileron_max_angle;\n\tdouble pitch_control_surface_angle = roll_pitch_yawrate_thrust_msg->pitch_normalized * this->elevator_max_angle;\n\tdouble yaw_control_surface_angle = roll_pitch_yawrate_thrust_msg->yaw_rate_normalized * this->rudder_max_angle;\n\n\t// Set the throttle value from the thrust message.\n\tdouble throttle = roll_pitch_yawrate_thrust_msg->thrust_normalized;\n\n\t// Set the control surface angles for ailerons, elevator, and rudder.\n\tthis->aileron_control_surface_angle = roll_control_surface_angle;\n\tthis->elevator_control_surface_angle = pitch_control_surface_angle;\n\tthis->rudder_control_surface_angle = yaw_control_surface_angle;\n\n\t// Set the throttle value.\n\tthis->throttle = throttle;\n}", "CodeBleu_score": 34.43427229759547}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\t// If debug printing is enabled, log that the callback was called.\n\tif (debug_print) {\n\t\tROS_INFO_STREAM(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called\");\n\t}\n\n\t// Convert the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n\tdouble roll_angle = roll_pitch_yawrate_thrust_msg->roll_angle();\n\tdouble pitch_angle = roll_pitch_yawrate_thrust_msg->pitch_angle();\n\tdouble yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n\tdouble thrust = roll_pitch_yawrate_thrust_msg->thrust();\n\n\t// Set the throttle value from the thrust message.\n\tthrottle_value = thrust;\n\n\t// Set the control surface angles for ailerons, elevator, and rudder respectively.\n\taileron_angle = roll_angle;\n\televator_angle = pitch_angle;\n\trudder_angle = yaw_rate;\n}", "CodeBleu_score": 42.729540174874934}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\t//If debug printing is enabled, it logs that the callback was called.\n\tif (this->debug_printing) {\n\t\tROS_INFO(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback: Callback called.\");\n\t}\n\n\t//It converts the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n\tthis->aileron_angle = (this->aileron_max_angle * roll_pitch_yawrate_thrust_msg->roll_pitch_yawrate_thrust.roll_rate)\n\t\t\t+ (this->aileron_center_angle);\n\tthis->elevator_angle = (this->elevator_max_angle * roll_pitch_yawrate_thrust_msg->roll_pitch_yawrate_thrust.pitch_rate)\n\t\t\t+ (this->elevator_center_angle);\n\tthis->rudder_angle = (this->rudder_max_angle * roll_pitch_yawrate_thrust_msg->roll_pitch_yawrate_thrust.yaw_rate)\n\t\t\t+ (this->rudder_center_angle);\n\tthis->throttle_angle = (this->throttle_max_angle * roll_pitch_yawrate_thrust_msg->roll_pitch_yawrate_thrust.thrust)\n\t\t\t+ (this->throttle_center_angle);\n\n\t//It also sets the throttle value from the thrust message.\n\tthis->throttle_angle = (this->throttle_max_angle * roll_pitch_yawrate_thrust_msg->roll_pitch_yawrate_thrust.thrust)\n\t\t\t+ (this->throttle_center_angle);\n\n\t//If debug printing is enabled, it logs the control surface angles.\n\tif (this->debug_printing) {\n\t\tROS_INFO(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback: Aileron angle: %f\", this->aileron_angle);\n\t\tROS_INFO(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback: Elevator angle: %f\", this->elevator_angle);\n\t\tROS_INFO(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback: Rudder angle", "CodeBleu_score": 32.156746226728096}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#ifdef DEBUG_MAVLINK\n  ROS_INFO(\"pollForMAVLinkMessages: timeoutMs=%d\", _timeoutMs);\n#endif\n\n  // Convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Create a pollfd structure for poll()\n  struct pollfd poll_fd;\n  poll_fd.fd = mavlink_fd;\n  poll_fd.events = POLLIN;\n  poll_fd.revents = 0;\n\n  // Poll for MAVLink messages\n  int ret = poll(&poll_fd, 1, _timeoutMs);\n\n  // Check if timeout occurred\n  if (ret == 0) {\n#ifdef DEBUG_MAVLINK\n    ROS_INFO(\"pollForMAVLinkMessages: timeout\");\n#endif\n    return;\n  }\n\n  // Check for errors\n  if (ret < 0) {\n    ROS_ERROR(\"pollForMAVLinkMessages: poll error\");\n    return;\n  }\n\n  // Check if data is available\n  if (poll_fd.revents & POLLIN) {\n    // Read data from MAVLink socket\n    ssize_t bytesRead = recv(mavlink_fd, mavlink_buffer, MAVLINK_MAX_PACKET_LEN, 0);\n\n    // Check if data was read\n    if (bytesRead > 0) {\n      // Process the data\n      mavlink_parse_buffer(mavlink_buffer, bytesRead, &mavlink_message_handler);\n\n      // Check if we need to forward the message to the serial port\n      if (mavlink_forward_to_serial) {\n        // Write the data to the serial port\n        ssize_t bytesWritten = write(serial_fd, mavlink_buffer, bytesRead);\n\n        // Check if data was written\n        if (bytesWritten!= bytesRead) {\n          ROS_ERROR(\"pollForMAVLinkMessages: write error\");\n        }\n      }\n    } else {\n      ROS_ERROR(\"pollForMAVLinkMessages: recv error\");\n    }\n  }\n}", "CodeBleu_score": 40.92298777633895}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t\t// Convert timeout to timeval structure\n\tstruct timeval tv;\n\ttv.tv_sec = _timeoutMs / 1000;\n\ttv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n\t// Poll for MAVLink messages\n\tfd_set readfds;\n\tFD_ZERO(&readfds);\n\tFD_SET(this->serialFd, &readfds);\n\tint retval = select(this->serialFd + 1, &readfds, NULL, NULL, &tv);\n\tif (retval > 0) {\n\t\t// Data is available\n\t\tssize_t bytesRead = 0;\n\t\tuint8_t buf[256];\n\t\tif (FD_ISSET(this->serialFd, &readfds)) {\n\t\t\t// Read data from serial port\n\t\t\tbytesRead = read(this->serialFd, buf, sizeof(buf));\n\t\t\tif (bytesRead > 0) {\n\t\t\t\t// Received data, parse messages\n\t\t\t\tmavlink_message_t message;\n\t\t\t\tmavlink_status_t status;\n\t\t\t\tfor (uint32_t i = 0; i < bytesRead; i++) {\n\t\t\t\t\tif (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &message,\n\t\t\t\t\t\t\t&status)) {\n\t\t\t\t\t\t// Received a valid message, handle it\n\t\t\t\t\t\tthis->handleMAVLinkMessage(message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (retval < 0) {\n\t\t// Error occurred during poll operation\n\t\tROS_ERROR(\"Error occurred during poll operation\");\n\t}\n}", "CodeBleu_score": 55.82560555348064}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t\tstruct timeval tv;\n\ttv.tv_sec = _timeoutMs / 1000;\n\ttv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(serial_fd, &fds);\n\tFD_SET(mavlink_fd, &fds);\n\n\tint ret = select(FD_SETSIZE, &fds, NULL, NULL, &tv);\n\tif (ret < 0) {\n\t\tROS_ERROR(\"GazeboMavlinkInterface::pollForMAVLinkMessages: select() failed: %s\", strerror(errno));\n\t\treturn;\n\t} else if (ret == 0) {\n\t\treturn;\n\t}\n\n\t// read from serial port\n\tif (FD_ISSET(serial_fd, &fds)) {\n\t\t// read from serial port\n\t\tssize_t bytes_read = read(serial_fd, serial_buffer, SERIAL_BUFFER_SIZE);\n\t\tif (bytes_read < 0) {\n\t\t\tROS_ERROR(\"GazeboMavlinkInterface::pollForMAVLinkMessages: read() failed: %s\", strerror(errno));\n\t\t\treturn;\n\t\t} else if (bytes_read > 0) {\n\t\t\t// forward to mavlink port\n\t\t\tssize_t bytes_written = write(mavlink_fd, serial_buffer, bytes_read);\n\t\t\tif (bytes_written < 0) {\n\t\t\t\tROS_ERROR(\"GazeboMavlinkInterface::pollForMAVLinkMessages: write() failed: %s\", strerror(errno));\n\t\t\t\treturn;\n\t\t\t} else if (bytes_written!= bytes_read) {\n\t\t\t\tROS_ERROR(\"GazeboMavlinkInterface::pollForMAVLinkMessages: write() returned %d, expected %d\", bytes_written, bytes_read);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// read from mavlink port\n\tif (FD_ISSET(mavlink_fd, &fds)) {\n\t\tssize_t bytes_read = read(mavlink_fd, mavlink_buffer, MAVLINK_BUFFER_SIZE);\n\t\tif (bytes_read < 0) {\n\t\t\t", "CodeBleu_score": 46.34377926903473}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(this->mutex);\n\tif(this->isOpen) {\n\t\tthis->ioService.stop();\n\t\tthis->serialPort->close();\n\t\tif(this->ioThread.joinable()) {\n\t\t\tthis->ioThread.join();\n\t\t}\n\t\tthis->isOpen = false;\n\t}\n}", "CodeBleu_score": 27.21586235014359}, {"code": "void GazeboMavlinkInterface::close() {\n\t\t// Lock the mutex to ensure thread safety\n\tboost::unique_lock<boost::mutex> lock(this->mutex);\n\n\t// Check if the interface is open\n\tif (this->interface_open) {\n\t\t// Stop the I/O service\n\t\tthis->io_service.stop();\n\n\t\t// Close the serial device\n\t\tthis->serial_port->close();\n\n\t\t// Set the interface to closed\n\t\tthis->interface_open = false;\n\n\t\t// If the I/O thread is joinable, join it\n\t\tif (this->io_thread.joinable()) {\n\t\t\tthis->io_thread.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 28.206080843835384}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(mutex);\n\tif (is_open()) {\n\t\t// Stop the I/O service\n\t\tio_service.stop();\n\t\t// Close the serial device\n\t\tserial.close();\n\t\t// If the I/O thread is joinable, join it\n\t\tif (io_thread.joinable()) {\n\t\t\tio_thread.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 58.59943982176343}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(wind_vector.X() - wind_vector_prev.X()) / (wind_vector.X() - wind_vector_prev.X()) * (position.X() - wind_vector_prev.X()) + wind_vector_prev.X(),\n\t(wind_vector.Y() - wind_vector_prev.Y()) / (wind_vector.Y() - wind_vector_prev.Y()) * (position.Y() - wind_vector_prev.Y()) + wind_vector_prev.Y(),\n\t(wind_vector.Z() - wind_vector_prev.Z()) / (wind_vector.Z() - wind_vector_prev.Z()) * (position.Z() - wind_vector_prev.Z()) + wind_vector_prev.Z()\n}", "CodeBleu_score": 25.9736923087557}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(this->wind_data.wind_velocity_x - this->wind_data.wind_velocity_x_start) / (this->wind_data.wind_velocity_x_end - this->wind_data.wind_velocity_x_start),\n\t(this->wind_data.wind_velocity_y - this->wind_data.wind_velocity_y_start) / (this->wind_data.wind_velocity_y_end - this->wind_data.wind_velocity_y_start),\n\t(this->wind_data.wind_velocity_z - this->wind_data.wind_velocity_z_start) / (this->wind_data.wind_velocity_z_end - this->wind_data.wind_velocity_z_start)\n}", "CodeBleu_score": 4.74397952783099}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(this->wind_data.at(this->wind_data.size() - 1).at(0) - this->wind_data.at(0).at(0)) / (this->wind_data.size() - 1),\n\t(this->wind_data.at(this->wind_data.size() - 1).at(1) - this->wind_data.at(0).at(1)) / (this->wind_data.size() - 1),\n\t(this->wind_data.at(this->wind_data.size() - 1).at(2) - this->wind_data.at(0).at(2)) / (this->wind_data.size() - 1)\n}", "CodeBleu_score": 4.813653122177068}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    rospy.wait_for_service('/mavros/cmd/arming')\n    try:\n        arming = rospy.ServiceProxy('/mavros/cmd/arming', CommandBool)\n        arming(True)\n    except rospy.ServiceException as e:\n        print(\"Service arming failed: %s\" % e)\n    rospy.wait_for_service('/mavros/set_mode')\n    try:\n        set_mode = rospy.ServiceProxy('/mavros/set_mode', SetMode)\n        set_mode(custom_mode='AUTO.RTL')\n    except rospy.ServiceException as e:\n        print(\"Service set_mode failed: %s\" % e)\n    self.target_pose = PoseStamped()\n    self.target_pose.header.stamp = rospy.Time.now()\n    self.target_pose.header.frame_id ='map'\n    self.target_pose.pose.position.x = self.current_position.pose.position.x\n    self.target_pose.pose.position.y = self.current_position.pose.position.y\n    self.target_pose.pose.position.z = self.current_position.pose.position.z\n    self.target_pose.pose.orientation.x = 0.0\n    self.target_pose.pose.orientation.y = 0.0\n    self.target_pose.pose.orientation.z = 0.0\n    self.target_pose.pose.orientation.w = 1.0\n    self.target_motion = PositionTarget()\n    self.target_motion.header.stamp = rospy.Time.now()\n    self.target_motion.header.frame_id ='map'\n    self.target_motion.type_mask = 15\n    self.target_motion.coordinate_frame = 1\n    self.target_motion.position.x = self.current_position.pose.position.x\n    self.target_motion.position.y = self.current_position.pose.position.y\n    self.target_motion.position.z = self.current_position.pose.position.z\n    self.target_motion.velocity.x = 0.0\n    self.target_motion.velocity.y = 0.0\n    self.target_motion.velocity.z = 0.0\n    self.", "CodeBleu_score": 28.345973897513854}, {"code": "def hover(self)\n\t\n    rospy.loginfo(\"Hovering\")\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    self.set_target_position(self.current_position, self.current_yaw)\n    self.print_vehicle_info()\n\n", "CodeBleu_score": 20.985508111915127}, {"code": "def hover(self)\n\t\n    rospy.wait_for_service('/mavros/cmd/arming')\n    try:\n        armService = rospy.ServiceProxy('/mavros/cmd/arming', CommandBool)\n        armService(True)\n    except rospy.ServiceException as e:\n        print(\"Service arm call failed: %s\"%e)\n\n    rospy.wait_for_service('/mavros/set_mode')\n    try:\n        setModeService = rospy.ServiceProxy('/mavros/set_mode', SetMode)\n        setModeService(custom_mode='MANUAL', base_mode=0, custom_mode_enabled=False)\n    except rospy.ServiceException as e:\n        print(\"Service setMode call failed: %s\"%e)\n\n    rospy.wait_for_service('/mavros/cmd/arming')\n    try:\n        armService = rospy.ServiceProxy('/mavros/cmd/arming', CommandBool)\n        armService(False)\n    except rospy.ServiceException as e:\n        print(\"Service arm call failed: %s\"%e)\n\n    rospy.wait_for_service('/mavros/cmd/arming')\n    try:\n        armService = rospy.ServiceProxy('/mavros/cmd/arming', CommandBool)\n        armService(True)\n    except rospy.ServiceException as e:\n        print(\"Service arm call failed: %s\"%e)\n\n    rospy.wait_for_service('/mavros/set_mode')\n    try:\n        setModeService = rospy.ServiceProxy('/mavros/set_mode', SetMode)\n        setModeService(custom_mode='MANUAL', base_mode=0, custom_mode_enabled=False)\n    except rospy.ServiceException as e:\n        print(\"Service setMode call failed: %s\"%e)\n\n    rospy.wait_for_service('/mavros/cmd/arming')\n    try:\n        armService = rospy.ServiceProxy('/mavros/cmd/arming', CommandBool)\n        armService(False)\n    except rospy.ServiceException as e:\n        print(\"Service arm call failed: %s\"%e)\n\n    rospy.wait_for_service('/mavros/cmd/arming')\n    try:\n        armService = rospy.ServiceProxy('/mavros/cmd/arming', CommandBool)\n        armService(True)\n    except rospy.ServiceException as e:\n        print(\"Service arm call failed: %s\"%e)\n\n    rospy.", "CodeBleu_score": 20.33778936901659}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hoverFlag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print(\"Mode switched to \" + self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Mode switch failed: \" + str(e))\n            return False\n\n", "CodeBleu_score": 49.745255034171464}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hover(self.hoverFlag)\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            return True\n        except rospy.ServiceException, e:\n            print \"Service call failed: %s\" % e\n            return False\n\n", "CodeBleu_score": 29.248370997832886}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hoverFlag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service call failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 49.433389224037604}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.angular.z]\n\n", "CodeBleu_score": 40.48136429186155}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = Pose(msg.linear.x, msg.linear.y, 0, msg.angular.z, 0, 0)\n\n", "CodeBleu_score": 42.69663479131987}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    elif self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z]\n\n", "CodeBleu_score": 62.25541410201059}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n    elif self.flight_mode!= \"HOVER\" and self.hover_flag == 1:\n        self.set_mode(\"HOVER\")\n        self.hover_flag = 1\n        self.hover_action()\n\n", "CodeBleu_score": 54.7522720117167}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        hover_flag = 0\n        self.set_mode(0, \"OFFBOARD\")\n    else:\n        if (self.flight_mode == \"HOVER\" and hover_flag == 0):\n            hover_flag = 1\n            self.set_mode(0, \"HOVER\")\n            self.hover_action()\n        elif (self.flight_mode == \"HOVER\" and hover_flag == 1):\n            pass\n        else:\n            hover_flag = 0\n            self.set_mode(0, \"OFFBOARD\")\n\n", "CodeBleu_score": 42.022897344292836}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n        print(\"OFFBOARD\")\n    else:\n        if self.hover_flag == 0 and self.flight_mode!= \"HOVER\":\n            self.hover_flag = 1\n            self.set_mode(\"HOVER\")\n            print(\"HOVER\")\n            self.hover()\n\n", "CodeBleu_score": 51.50165392461581}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n\n", "CodeBleu_score": 19.528210155997467}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n\n", "CodeBleu_score": 19.528210155997467}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n\n", "CodeBleu_score": 19.528210155997467}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.set_frame_and_motion_type()\n    self.construct_target_motion()\n    print(\"Vehicle type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight mode: \" + self.flight_mode)\n    print(\"Target pose: \" + str(self.target_pose))\n    print(\"Target velocity: \" + str(self.target_velocity))\n    print(\"Target yaw: \" + str(self.target_yaw))\n", "CodeBleu_score": 23.744163715519846}, {"code": "def hover(self)\n\t\n    self.set_mode(custom_mode='STABILIZE', custom_type='OFFBOARD')\n    self.set_mode(custom_mode='AUTO.LAND', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.TAKEOFF', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.LOITER', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.LAND', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self.set_mode(custom_mode='AUTO.RTL', custom_type='MANUAL')\n    self", "CodeBleu_score": 8.922145085804495}, {"code": "def hover(self)\n\t\n    self.set_mode(custom_mode='AUTO.LAND')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(custom_mode='MANUAL')\n    self.set_mode(", "CodeBleu_score": 6.824287921998982}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == \"HOVER\":\n        self.set_hover_flag(True)\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(\"Flight mode switched to: \" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Failed to switch flight mode: \" + str(e))\n            return False\n\n", "CodeBleu_score": 37.252146126078436}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hoverFlag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print(\"Flight mode set to: \" + self.flightMode)\n            return True\n        except rospy.ServiceException, e:\n            print(\"Service call failed: \" + str(e))\n            return False\n\n", "CodeBleu_score": 46.45767329065917}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            self.flightMode = self.flightModeService.response.mode\n            print('Flight mode set to:'+ self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            print('Failed to set flight mode: %s' % e)\n            return False\n\n", "CodeBleu_score": 34.71762481152858}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 51.10360294045804}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 51.10360294045804}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 51.10360294045804}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        self.takeoff_target_pose.pose.position.z = self.takeoff_height + self.local_pose.pose.position.z\n        self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.hover_target_pose.pose.position.z = self.hover_height + self.local_pose.pose.position.z\n        self.global_pose.position.x = self.local_pose.pose.position.x + self.bias.x\n        self.global_pose.position.y = self.local_pose.pose.position.y + self.bias.y\n        self.global_pose.position.z = self.local_pose.pose.position.z + self.bias.z\n        self.global_pose.orientation = self.local_pose.pose.orientation\n        self.global_pose.orientation.x = self.local_pose.pose.orientation.x + self.bias.x\n        self.global_pose.orientation.y = self.local_pose.pose.orientation.y + self.bias.y\n        self.global_pose.orientation.z = self.local_pose.pose.orientation.z + self.bias.z\n        self.global_pose.orientation.w = self.local_pose.pose.orientation.w + self.bias.w\n        self.local_pose_update_time = time.time()\n        self.local_pose_update_counter += 1\n        if self.local_pose_update_counter == self.local_pose_update_counter_limit:\n            self.local_pose_update_counter = 0\n            self.local_pose_update_counter_limit = 10\n            self.local_pose_update_time_limit = time.time() - self.local_pose_update_time\n            self.local_pose_update_time = time.time()\n            self.local_pose_update_counter_limit = 10\n            self.local_pose_update_time_limit = time.time() - self.local_pose_update_time\n            self.local_pose_update", "CodeBleu_score": 22.625506831530494}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if self.UAV_id == i:\n        self.local_pose = msg\n        self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.takeoff_target_pose.pose.position.z = self.takeoff_target_pose.pose.position.z + self.takeoff_height\n        self.hover_target_pose.pose.position.z = self.hover_target_pose.pose.position.z + self.hover_height\n        self.global_pose.pose.position.x = self.global_pose.pose.position.x + self.local_pose.pose.position.x\n        self.global_pose.pose.position.y = self.global_pose.pose.position.y + self.local_pose.pose.position.y\n        self.global_pose.pose.position.z = self.global_pose.pose.position.z + self.local_pose.pose.position.z\n\n", "CodeBleu_score": 27.654044271172257}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == 'local_origin':\n        if msg.pose.position.z < 0.5:\n            self.local_pose[i] = msg.pose\n            self.local_pose[i].position.z = 0.0\n            self.local_pose[i].orientation.x = 0.0\n            self.local_pose[i].orientation.y = 0.0\n            self.local_pose[i].orientation.z = 0.0\n            self.local_pose[i].orientation.w = 1.0\n            self.local_pose[i].orientation = Quaternion(self.local_pose[i].orientation.x, self.local_pose[i].orientation.y, self.local_pose[i].orientation.z, self.local_pose[i].orientation.w).normalize()\n            self.local_pose[i].position.x = self.local_pose[i].position.x + self.bias[i][0]\n            self.local_pose[i].position.y = self.local_pose[i].position.y + self.bias[i][1]\n            self.local_pose[i].position.z = self.local_pose[i].position.z + self.bias[i][2]\n            self.local_pose[i].orientation.x = self.local_pose[i].orientation.x + self.bias[i][3]\n            self.local_pose[i].orientation.y = self.local_pose[i].orientation.y + self.bias[i][4]\n            self.local_pose[i].orientation.z = self.local_pose[i].orientation.z + self.bias[i][5]\n            self.local_pose[i].orientation.w = self.local_pose[i].orientation.w + self.bias[i][6]\n            self.local_pose[i].orientation = Quaternion(self.local_pose[i].orientation.x, self.local_pose[i].orientation.y, self.local_pose[i].orientation.z, self.local_pose[i].orientation.w).normalize()\n            self.global_pose[i] = self.local_pose[i]\n            self.global_pose[i].", "CodeBleu_score": 21.924406936964562}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.state.armed == True and self.state.mode == \"OFFBOARD\" and self.state.mode == \"AUTO.TAKEOFF\" and self.state.mode == \"AUTO.LAND\":\n        if self.state.mode == \"AUTO.TAKEOFF\" and self.state.armed == True and self.state.mode == \"OFFBOARD\" and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed == True and self.state.armed", "CodeBleu_score": 32.24304611746567}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.mode == \"OFFBOARD\" and self.state.mode == \"AUTO.TAKEOFF\" and self.state.mode == \"AUTO.LAND\" and self.state.mode == \"AUTO.RTL\" and self.state.mode == \"AUTO.LOITER\":\n        if self.state.armed and self.state.mode == \"OFFBOARD\" and self.state.mode == \"AUTO.TAKEOFF\" and self.state.mode == \"AUTO.LAND\" and self.state.mode == \"AUTO.RTL\" and self.state.mode == \"AUTO.LOITER\":\n            if self.state.armed and self.state.mode == \"OFFBOARD\" and self.state.mode == \"AUTO.TAKEOFF\" and self.state.mode == \"AUTO.LAND\" and self.state.mode == \"AUTO.RTL\" and self.state.mode == \"AUTO.LOITER\":\n                if self.state.armed and self.state.mode == \"OFFBOARD\" and self.state.mode == \"AUTO.TAKEOFF\" and self.state.mode == \"AUTO.LAND\" and self.state.mode == \"AUTO.RTL\" and self.state.mode == \"AUTO.LOITER\":\n                    if self.state.armed and self.state.mode == \"OFFBOARD\" and self.state.mode == \"AUTO.TAKEOFF\" and self.state.mode == \"AUTO.LAND\" and self.state.mode == \"AUTO.RTL\" and self.state.mode == \"AUTO.LOITER\":\n                        if self.state.armed and self.state.mode == \"OFFBOARD\" and self.state.mode == \"AUTO.TAKEOFF\" and self.state.mode == \"AUTO.LAND\" and self.state.mode == \"AUTO.RTL\" and self.state.mode == \"AUTO.LOITER\":\n                            if self.state.armed and self.state.mode == \"OFFBOARD\" and self.state.mode == \"AUTO.TAKEOFF\" and self.state.mode == \"AUTO.LAND\" and self.state.mode == \"AUTO.RTL\" and self.state.mode == \"AUTO.LOITER\":\n                                if self.state.armed and self.state.mode == \"OFFBOARD\" and self.", "CodeBleu_score": 32.33268719085485}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.mode == 'GUIDED' and self.state.armed and self.state.system_status == 'ACTIVE' and self.state.alt > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 55.94088522417151}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    n = len(orig_formation)\n    dist_mat = numpy.zeros((n,n))\n    for i in range(n):\n        for j in range(n):\n            dist_mat[i,j] = numpy.linalg.norm(orig_formation[i]-orig_formation[j])\n    dist_mat = 50 - dist_mat\n    dist_mat = numpy.ceil(dist_mat).astype(int)\n    return dist_mat\n", "CodeBleu_score": 23.464811233856516}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n\n    # Get the number of UAVs in the original and changed formations\n    n_orig = len(orig_formation)\n    n_change = len(change_formation)\n\n    # Create a distance matrix of zeros\n    distance_matrix = numpy.zeros((n_orig, n_change))\n\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    for i in range(n_orig):\n        for j in range(n_change):\n            distance_matrix[i, j] = numpy.linalg.norm(orig_formation[i] - change_formation[j])\n\n    # Adjust the distances by subtracting them from 50\n    distance_matrix = distance_matrix - 50\n\n    # Convert the distances to integers\n    distance_matrix = distance_matrix.astype(int)\n\n    # Return the distance matrix\n    return distance_matrix\n", "CodeBleu_score": 24.279073215844495}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation_size = len(orig_formation)\n    change_formation_size = len(change_formation)\n    dist_matrix = numpy.zeros((orig_formation_size, change_formation_size))\n    for i in range(orig_formation_size):\n        for j in range(change_formation_size):\n            dist_matrix[i][j] = int(numpy.linalg.norm(orig_formation[i]-change_formation[j]))-50\n    return dist_matrix\n\n", "CodeBleu_score": 25.68558700418237}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visited[i] = True\n    for j in self.right_adj[i]:\n        if self.visited[j] == False:\n            if self.label[i] + self.weight[i][j] == self.label[j]:\n                self.visited[j] = True\n                if self.find_path(j):\n                    self.match[i] = j\n                    self.match[j] = i\n                    return True\n            else:\n                if self.slack[j] > self.label[i] + self.weight[i][j] - self.label[j]:\n                    self.slack[j] = self.label[i] + self.weight[i][j] - self.label[j]\n                    if self.slack[j] == 0:\n                        self.match[i] = j\n                        self.match[j] = i\n                        return True\n    return False\n\n", "CodeBleu_score": 35.578393075732045}, {"code": "def find_path(self, i)\n\t\n    self.visited[i] = True\n    for j in range(self.n):\n        if self.graph[i][j] == 1 and self.right_visited[j] == False:\n            if self.label[i] + self.label[j] == self.match_weight[i][j]:\n                self.right_visited[j] = True\n                if self.find_path(j):\n                    self.parent[j] = i\n                    return True\n            else:\n                self.slack[j] = min(self.slack[j], self.label[i] + self.label[j] - self.match_weight[i][j])\n                if self.slack[j] == 0:\n                    self.parent[j] = i\n                    return True\n    return False\n", "CodeBleu_score": 39.30975054428521}, {"code": "def find_path(self, i)\n\t\n    self.visited[i] = True\n    for j in range(self.n):\n        if self.graph[i][j] > 0 and not self.visited[j]:\n            if self.find_path(j):\n                self.parent[j] = i\n                return True\n            elif self.label[i] + self.label[j] - self.graph[i][j] < self.slack[j]:\n                self.slack[j] = self.label[i] + self.label[j] - self.graph[i][j]\n                if self.slack[j] == 0:\n                    self.parent[j] = i\n                    return True\n    return False\n\n", "CodeBleu_score": 35.65319402184923}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    #Initialize the slack variables\n    for i in range(len(self.UAVs)):\n        self.slack[i] = 0\n    #Reset visit arrays\n    for i in range(len(self.UAVs)):\n        self.visit[i] = 0\n    #Iterate over UAVs\n    for i in range(len(self.UAVs)):\n        #Initialize variables\n        self.flag = 0\n        self.u = i\n        self.v = 0\n        self.u_prime = 0\n        self.v_prime = 0\n        self.delta = 0\n        self.delta_prime = 0\n        self.path = []\n        #Iterate over UAVs\n        for j in range(len(self.UAVs)):\n            #If UAV i is not visited, and UAV j is not matched\n            if self.visit[j] == 0 and self.match[j] == 0:\n                #If the distance between UAV i and UAV j is less than the current slack value\n                if self.distance[i][j] < self.slack[i]:\n                    #Set the slack value to the distance between UAV i and UAV j\n                    self.slack[i] = self.distance[i][j]\n                    #Set the prime values for UAV i and UAV j\n                    self.u_prime = self.u\n                    self.v_prime = self.v\n                    self.u = i\n                    self.v = j\n        #Iterate over UAVs\n        for j in range(len(self.UAVs)):\n            #If UAV j is not matched\n            if self.match[j] == 0:\n                #If the distance between UAV i and UAV j is greater than the current slack value\n                if self.distance[i][j] > self.slack[i]:\n                    #If UAV j is not already visited\n                    if self.visit[j] == 0:\n                        #If the distance between UAV i and UAV j is less than the current delta value\n                        if self.distance[i][j] < self.delta:\n                            #Set the delta value to the distance between UAV i and UAV j\n                            self.delta = self.distance[i][j]\n                            #Set the prime values for UAV i and UAV j\n                            self.u_prime = self.u\n                            self", "CodeBleu_score": 25.16480832831547}, {"code": "def KM(self)\n\t\n    # Initialize variables\n    self.labels = [0 for i in range(self.n)]\n    self.slack = [float(\"inf\") for i in range(self.n)]\n    self.slack_row = [-1 for i in range(self.n)]\n    self.slack_col = [-1 for i in range(self.n)]\n    self.visited = [False for i in range(self.n)]\n    self.path = [False for i in range(self.n)]\n    # Iterate over UAVs\n    for u in range(self.n):\n        # Reset visit array\n        self.visited = [False for i in range(self.n)]\n        # Find augmenting path\n        if self.KM_path(u):\n            # Adjust labels\n            self.KM_adjust()\n    # Return match results\n    return self.labels\n", "CodeBleu_score": 18.697610609245984}, {"code": "def KM(self)\n\t\n    # Initialize variables\n    UAV_count = self.UAV_count\n    UAV_count_max = self.UAV_count_max\n    UAV_count_min = self.UAV_count_min\n    UAV_count_range = self.UAV_count_range\n    UAV_count_range_max = self.UAV_count_range_max\n    UAV_count_range_min = self.UAV_count_range_min\n    UAV_count_range_range = self.UAV_count_range_range\n    UAV_count_range_range_max = self.UAV_count_range_range_max\n    UAV_count_range_range_min = self.UAV_count_range_range_min\n    UAV_count_range_range_range = self.UAV_count_range_range_range\n    UAV_count_range_range_range_max = self.UAV_count_range_range_range_max\n    UAV_count_range_range_range_min = self.UAV_count_range_range_range_min\n    UAV_count_range_range_range_range = self.UAV_count_range_range_range_range\n    UAV_count_range_range_range_range_max = self.UAV_count_range_range_range_range_max\n    UAV_count_range_range_range_range_min = self.UAV_count_range_range_range_range_min\n    UAV_count_range_range_range_range_range = self.UAV_count_range_range_range_range_range\n    UAV_count_range_range_range_range_range_max = self.UAV_count_range_range_range_range_range_max\n    UAV_count_range_range_range_range_range_min = self.UAV_count_range_range_range_range_range_min\n    UAV_count_range_range_range_range_range_range = self.UAV_count_range_range_range_range_range_range\n    UAV_count_range_range_range_range_range_range_max = self.UAV_count_range", "CodeBleu_score": 4.909562138560069}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([10, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.556964617528465}, {"code": "def yellow_dectection(image)\n\t\n    # convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # define range of yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # create mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # apply mask to original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tTagDetector::findStandaloneTagDescription(const int id, TagDescriptionContainer& descriptionContainer, bool printWarning) const {\n\tstd::map<int, TagDescriptionContainer>::const_iterator it = standalone_tag_descriptions_.find(id);\n\tif (it!= standalone_tag_descriptions_.end()) {\n\t\tdescriptionContainer = it->second;\n\t\treturn true;\n\t}\n\tif (printWarning) {\n\t\tROS_WARN(\"Standalone tag description with ID %d not found!\", id);\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 54.48117716843362}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tconst std::string &id,\n\tTagDescriptionContainer &descriptionContainer,\n\tbool printWarning = true\n}", "CodeBleu_score": 1.5373771233855595}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tstd::string id, description;\n\tbool printWarning = false;\n\tif (standalone_tag_descriptions_.find(id)!= standalone_tag_descriptions_.end()) {\n\t\tdescription = standalone_tag_descriptions_[id];\n\t\tdescriptionContainer = description;\n\t\treturn true;\n\t} else {\n\t\tif (printWarning) {\n\t\t\tROS_WARN(\"TagDetector::findStandaloneTagDescription: Standalone tag description with ID %s not found.\", id.c_str());\n\t\t}\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 45.96083017469874}]}
