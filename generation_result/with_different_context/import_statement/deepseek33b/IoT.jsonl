{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bLength != 0) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc + desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.00003953282957}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc;\n\tdo {\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t\t((uint8_t UDC_DESC_STORAGE *) desc + desc->bLength);\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tdesc = next_desc;\n\t} while (next_desc->bDescriptorType != USB_DESC_INTERFACE);\n\treturn NULL;\n}", "CodeBleu_score": 37.00536354139111}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t((uint8_t UDC_DESC_STORAGE *) desc + desc->bLength);\n\n\twhile (next_desc->bLength != 0) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) (\n\t\t\t\t(uint8_t UDC_DESC_STORAGE *) next_desc + next_desc->bLength);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 40.38974403610027}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tusb_cdc_line_coding_t line_coding;\n\tusb_desc_iface_t *iface_desc;\n\tusb_desc_iface_assoc_t *iface_assoc_desc;\n\tusb_desc_header_t *desc;\n\tuint8_t desc_type;\n\tuint8_t desc_index;\n\tuint8_t desc_len;\n\tuint8_t desc_num;\n\tuint8_t desc_sub_index;\n\tuint8_t desc_sub_num;\n\tuint8_t desc_sub_type;\n\tuint8_t desc_sub_len;\n\tuint8_t desc_sub_iface_num;\n\tuint8_t desc_sub_alt_setting;\n\tuint8_t desc_sub_endpoint_num;\n\tuint8_t desc_sub_endpoint_addr;\n\tuint8_t desc_sub_endpoint_attr;\n\tuint8_t desc_sub_endpoint_max_packet_size;\n\tuint8_t desc_sub_endpoint_interval;\n\tuint8_t desc_sub_endpoint_refresh;\n\tuint8_t desc_sub_endpoint_synch_addr;\n\tuint8_t desc_sub_endpoint_usage;\n\tuint8_t desc_sub_endpoint_usage_page;\n\tuint8_t desc_sub_endpoint_usage_id;\n\tuint8_t desc_sub_endpoint_usage_page_id;\n\tuint8_t desc_sub_endpoint_usage_page_id_id;\n\tuint8_t desc_sub_endpoint_usage_page_id_id_id;\n\tuint8_t desc_sub_endpoint_usage_page_id_id_id_id;\n\tuint8_t desc_sub_endpoint_usage_page_id_id_id_id_id;\n\tuint8_t desc_sub_endpoint_usage_page_id_id_id_id_id_id;\n\tuint8_t desc_sub_endpoint_usage_page_id_id_", "CodeBleu_score": 7.2781213854937645}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t  if (!udc_config_valid) {\n    return false;\n  }\n  if (iface_num >= udc_config_desc->bNumInterfaces) {\n    return false;\n  }\n  struct usb_descriptor_header *desc = (struct usb_descriptor_header *)udc_config_desc;\n  while (desc->bLength != 0) {\n    if (desc->bDescriptorType == USB_DT_INTERFACE) {\n      struct usb_interface_descriptor *iface_desc = (struct usb_interface_descriptor *)desc;\n      if (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n        return true;\n      }\n    }\n    desc = (struct usb_descriptor_header *)((uint8_t *)desc + desc->bLength);\n  }\n  return false;\n}", "CodeBleu_score": 40.77739468650484}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    // Check if there is a valid configuration\n    if (cur_config_desc == NULL) {\n        return false;\n    }\n\n    // Check if the interface number is within bounds\n    if (iface_num >= cur_config_desc->bNumInterfaces) {\n        return false;\n    }\n\n    // Iterate through the descriptors, starting from the beginning of the configuration descriptor\n    uint8_t *desc_ptr = cur_config_desc->descriptors;\n    while (desc_ptr < cur_config_desc->descriptors + cur_config_desc->wTotalLength) {\n        // Check if the descriptor is an interface descriptor\n        if (*desc_ptr == USB_DESCRIPTOR_INTERFACE) {\n            // Check if the interface number and setting number match\n            if (((struct usb_interface_descriptor *)desc_ptr)->bInterfaceNumber == iface_num && ((struct usb_interface_descriptor *)desc_ptr)->bAlternateSetting == setting_num) {\n                return true;\n            }\n        }\n\n        // Move to the next descriptor\n        desc_ptr += *(desc_ptr + 1);\n    }\n\n    return false;\n}", "CodeBleu_score": 41.71768680619342}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udc_req_len != sizeof(uint16_t)) {\n        return false;\n    }\n\n    uint8_t ep_addr = (udc_req_payload[0] & 0xF);\n    uint8_t ep_status = 0;\n\n    if (udc_ep_is_halted(ep_addr)) {\n        ep_status = UDC_EP_STATUS_HALTED;\n    }\n\n    udc_resp_payload[0] = ep_status;\n    udc_resp_len = 1;\n\n    return true;\n}", "CodeBleu_score": 36.44698427382174}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udc_req_len != sizeof(udc_ep_status)) {\n        return false;\n    }\n\n    udc_ep_status = udc_ep_is_halted(udc_req_windex) ? UDC_EP_STATUS_HALTED : 0;\n\n    udc_resp_payload = &udc_ep_status;\n    udc_resp_len = sizeof(udc_ep_status);\n\n    return true;\n}", "CodeBleu_score": 38.50171853463252}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udc_req_len != sizeof(uint16_t)) {\n        return false;\n    }\n    uint8_t ep_num = udc_req_payload[0] & 0x0F;\n    uint16_t ep_status = 0;\n    if (udc_ep_is_halted(ep_num)) {\n        ep_status = 1;\n    }\n    udc_resp_payload[0] = ep_status;\n    udc_resp_len = 2;\n    return true;\n}", "CodeBleu_score": 28.768613478034492}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t    if (udc_state != UDC_STATE_CONFIGURED) {\n        return false;\n    }\n\n    if (udc_setup.wIndex != 0) {\n        return false;\n    }\n\n    udc_iface_desc_update(udc_setup.wValue, 0);\n    udc_iface_desc_update(udc_setup.wValue, udc_setup.wValue);\n\n    if (udc_udi_handler[udc_setup.wValue] != NULL) {\n        return udc_udi_handler[udc_setup.wValue]->setup(udc_setup.bRequestType, udc_setup.bRequest, udc_setup.wValue, udc_setup.wIndex, udc_setup.wLength);\n    }\n\n    return false;\n}", "CodeBleu_score": 49.08013016487983}, {"code": "static bool udc_req_iface(void){\n\t    if (udc_state != UDC_STATE_CONFIGURED) {\n        return false;\n    }\n    if (req_iface > UDC_MAX_IFACES) {\n        return false;\n    }\n    if (req_iface < UDC_MAX_IFACES) {\n        udc_iface_desc[req_iface] = udc_iface_desc_default[req_iface];\n    }\n    if (req_iface < udc_iface_count) {\n        udc_iface_desc[req_iface] = udc_iface_desc_alt[req_iface];\n    }\n    return udc_iface_handler[req_iface].setup(req_type, req_request, req_value, req_index, req_length, req_data);\n}", "CodeBleu_score": 46.6068909276235}, {"code": "static bool udc_req_iface(void){\n\t    bool ret;\n    if (udc_state != UDC_STATE_CONFIGURED) {\n        return false;\n    }\n    if (udc_setup.wIndex > UDC_MAX_IFACE) {\n        return false;\n    }\n    udc_iface_desc_set_alt(udc_setup.wIndex, 0);\n    udc_iface_desc_set_alt(udc_setup.wIndex, udc_iface_desc_get_alt(udc_setup.wIndex));\n    ret = udc_udi_handler[udc_setup.wIndex]->setup(udc_setup);\n    return ret;\n}", "CodeBleu_score": 46.59882634109149}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t    // Set initial states for several flags\n    udi_msc_enable_flag = true;\n    udi_msc_cbw_received_flag = false;\n    udi_msc_cbw_received_abort_flag = false;\n    udi_msc_cbw_received_reset_flag = false;\n    udi_msc_cbw_received_data_flag = false;\n    udi_msc_cbw_received_status_flag = false;\n    udi_msc_cbw_received_error_flag = false;\n    udi_msc_cbw_received_data_in_flag = false;\n    udi_msc_cbw_received_data_out_flag = false;\n    udi_msc_cbw_received_data_setup_flag = false;\n    udi_msc_cbw_received_data_setup_in_flag = false;\n    udi_msc_cbw_received_data_setup_out_flag = false;\n    udi_msc_cbw_received_data_setup_in_flag = false;\n    udi_msc_cbw_received_data_setup_out_flag = false;\n    udi_msc_cbw_received_data_setup_in_flag = false;\n    udi_msc_cbw_received_data_setup_out_flag = false;\n    udi_msc_cbw_received_data_setup_in_flag = false;\n    udi_msc_cbw_received_data_setup_out_flag = false;\n    udi_msc_cbw_received_data_setup_in_flag = false;\n    udi_msc_cbw_received_data_setup_out_flag = false;\n    udi_msc_cbw_received_data_setup_in_flag = false;\n    udi_msc_cbw_received_data_setup_out_flag = false;\n    udi_msc_cbw_received_data_setup_in_flag = false;\n    udi_msc_cbw_received_data_", "CodeBleu_score": 21.254018506010596}, {"code": "bool udi_msc_enable(void){\n\t    /* Initializes the state of the MSC interface. */\n    udi_msc_init();\n\n    /* If there are no LUNs available, return false. */\n    if (udi_msc_get_nb_lun() == 0) {\n        return false;\n    }\n\n    /* If the external enable function fails, return false. */\n    if (!udi_msc_ext_enable()) {\n        return false;\n    }\n\n    /* Unload the medium on each LUN. */\n    for (uint8_t i = 0; i < udi_msc_get_nb_lun(); i++) {\n        udi_msc_unload_lun(i);\n    }\n\n    /* Start the MSC process by waiting for a CBW reception. */\n    udi_msc_wait_cbw();\n\n    return true;\n}", "CodeBleu_score": 36.73369804022043}, {"code": "bool udi_msc_enable(void){\n\t    if (udi_msc_initialize() == false) {\n        return false;\n    }\n\n    udi_msc_luns = udi_msc_get_nb_luns();\n    if (udi_msc_luns == 0) {\n        return false;\n    }\n\n    if (udi_msc_external_enable() == false) {\n        return false;\n    }\n\n    for (uint8_t i = 0; i < udi_msc_luns; i++) {\n        udi_msc_unload_lun(i);\n    }\n\n    udi_msc_wait_for_cbw();\n    return true;\n}", "CodeBleu_score": 41.41449023602276}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\n  // Check the status of the transfer\n  if (status != UDD_EP_TRANSFER_OK) {\n    // If the transfer is not successful, wait for a MSC setup reset to restart CBW reception\n    udi_msc_wait_for_setup_reset();\n    return;\n  }\n\n  // Update the sense data\n  udi_msc_update_sense_data();\n\n  // Decrease the data residue in the CSW by the amount of data sent\n  udi_msc_csw.dDataResidue -= nb_sent;\n\n  // Process the updated CSW\n  udi_msc_process_csw();\n}", "CodeBleu_score": 56.096844681660585}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    // Check if the data transfer was successful\n    if (status != UDD_EP_TRANSFER_OK) {\n        // If the transfer was not successful, wait for a MSC setup reset to restart CBW reception\n        udi_msc_wait_for_setup_reset();\n        return;\n    }\n\n    // Update the sense data\n    udi_msc_sense_data.data_residue -= nb_sent;\n\n    // Process the updated CSW\n    udi_msc_process_csw();\n}", "CodeBleu_score": 55.252681337899844}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    if (status != UDD_EP_TRANSFER_OK) {\n        // Wait for MSC setup reset to restart CBW reception\n        udi_msc_wait_for_reset();\n        return;\n    }\n\n    // Update sense data\n    udi_msc_sense_data.data_residue -= nb_sent;\n\n    // Process updated CSW\n    udi_msc_process_csw();\n}", "CodeBleu_score": 55.520384429686075}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t    uint32_t csw_tag;\n    uint32_t csw_data_residue;\n    uint8_t csw_status;\n\n    // Check if there is a non-zero data residue\n    if (udi_msc_cbw.dDataLength != 0) {\n        // Stall the next request on the appropriate endpoint based on the direction of the CBW\n        if (udi_msc_cbw.bmFlags & UDI_MSC_CBW_FLAG_OUT) {\n            udi_cdc_msc_ep_stall(EP_OUT);\n        } else {\n            udi_cdc_msc_ep_stall(EP_IN);\n        }\n    }\n\n    // Prepare the CSW\n    csw_tag = udi_msc_cbw.dTag;\n    csw_data_residue = udi_msc_cbw.dDataLength;\n    csw_status = UDI_MSC_CSW_STATUS_SUCCESS;\n\n    // Convert the data residue to little-endian format\n    csw_data_residue = htole32(csw_data_residue);\n\n    // Send the CSW\n    udi_cdc_msc_ep_write(EP_CSW, &csw_tag, sizeof(csw_tag));\n    udi_cdc_msc_ep_write(EP_CSW, &csw_data_residue, sizeof(csw_data_residue));\n    udi_cdc_msc_ep_write(EP_CSW, &csw_status, sizeof(csw_status));\n}", "CodeBleu_score": 41.5903696971068}, {"code": "static void udi_msc_csw_process(void){\n\t    uint8_t csw_data_residue;\n    uint8_t csw_status;\n    uint8_t csw_tag;\n    uint8_t *csw_ptr;\n    uint8_t *csw_data_residue_ptr;\n    uint8_t *csw_status_ptr;\n    uint8_t *csw_tag_ptr;\n    uint8_t *csw_signature_ptr;\n    uint8_t *csw_data_residue_end_ptr;\n    uint8_t *csw_status_end_ptr;\n    uint8_t *csw_tag_end_ptr;\n    uint8_t *csw_signature_end_ptr;\n    uint8_t *csw_end_ptr;\n    uint8_t *csw_data_residue_end_ptr;\n    uint8_t *csw_status_end_ptr;\n    uint8_t *csw_tag_end_ptr;\n    uint8_t *csw_signature_end_ptr;\n    uint8_t *csw_end_ptr;\n    uint8_t *csw_data_residue_end_ptr;\n    uint8_t *csw_status_end_ptr;\n    uint8_t *csw_tag_end_ptr;\n    uint8_t *csw_signature_end_ptr;\n    uint8_t *csw_end_ptr;\n    uint8_t *csw_data_residue_end_ptr;\n    uint8_t *csw_status_end_ptr;\n    uint8_t *csw_tag_end_ptr;\n    uint8_t *csw_signature_end_ptr;\n    uint8_t *csw_end_ptr;\n    uint8_t *csw_data_residue_end_ptr;\n    uint8_t *csw_status_end_ptr;\n    uint8_t *csw_tag_end_ptr;\n    uint8_t *csw_signature_end_ptr;\n    uint8_t *c", "CodeBleu_score": 4.819040650840438}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint8_t csw_data_residue = 0;\n\tuint8_t csw_status = 0;\n\tuint8_t csw_status_phase = 0;\n\tuint8_t csw_status_response = 0;\n\tuint8_t csw_status_command = 0;\n\tuint8_t csw_status_command_phase = 0;\n\tuint8_t csw_status_command_response = 0;\n\tuint8_t csw_status_command_response_phase = 0;\n\tuint8_t csw_status_command_response_phase_response = 0;\n\tuint8_t csw_status_command_response_phase_response_response = 0;\n\tuint8_t csw_status_command_response_phase_response_response_phase = 0;\n\tuint8_t csw_status_command_response_phase_response_response_phase_response = 0;\n\tuint8_t csw_status_command_response_phase_response_response_phase_response_phase = 0;\n\tuint8_t csw_status_command_response_phase_response_response_phase_response_phase_response = 0;\n\tuint8_t csw_status_command_response_phase_response_response_phase_response_phase_response_phase = 0;\n\tuint8_t csw_status_command_response_phase_response_response_phase_response_phase_response_phase_response = 0;\n\tuint8_t csw_status_command_response_phase_response_response_phase_response_phase_response_phase_response_phase = 0;\n\tuint8_t csw_status_command_response_phase_response_response_phase_response_phase_response_phase_response_phase_response = 0;\n\tuint8_t csw_status_command_response_phase_response_response_phase_response_phase_response_phase_response_phase_response_phase = 0;\n\tuint8_t csw_status_command_response_phase_response_response_phase_response_phase_response_phase_response_phase_response_phase_response = 0;\n", "CodeBleu_score": 3.6462705880137496}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    // Update the DTR status\n    usb_cdc_dtr[port] = b_enable;\n\n    // Check if the DTR rate is 1200\n    if (usb_cdc_dtr_rate[port] == 1200) {\n        // If the DTR signal is disabled\n        if (!b_enable) {\n            // Schedule a delayed system reset\n            reset_scheduled = true;\n            reset_scheduled_time = millis();\n            reset_scheduled_port = port;\n        } else {\n            // Cancel any scheduled reset\n            reset_scheduled = false;\n            reset_scheduled_time = 0;\n            reset_scheduled_port = 0;\n        }\n    }\n}", "CodeBleu_score": 44.397578083010956}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  if (b_enable) {\n    usb_task_cdc_dtr_status[port] = true;\n  } else {\n    usb_task_cdc_dtr_status[port] = false;\n    if (usb_task_cdc_dtr_rate[port] == 1200) {\n      usb_task_cdc_dtr_reset_scheduled[port] = true;\n      usb_task_cdc_dtr_reset_scheduled_time[port] = get_absolute_time();\n      reset_controller_write(RESET_CONTROLLER_RESET_PIN_USB_TASK_CDC_DTR_RESET, true);\n      initiateReset();\n    }\n  }\n  if (usb_task_cdc_dtr_status[port] == true) {\n    usb_task_cdc_dtr_reset_scheduled[port] = false;\n    reset_controller_write(RESET_CONTROLLER_RESET_PIN_USB_TASK_CDC_DTR_RESET, false);\n    cancelReset();\n  }\n}", "CodeBleu_score": 36.41991780876827}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (port >= USB_NUM_PORTS) {\n        return;\n    }\n\n    usb_cdc_line_coding_t line_coding;\n    usb_cdc_get_line_coding(port, &line_coding);\n\n    usb_cdc_dtr_t dtr;\n    usb_cdc_get_dtr(port, &dtr);\n    dtr.b_enable = b_enable;\n    usb_cdc_set_dtr(port, &dtr);\n\n    if (line_coding.dwDTERate == 1200) {\n        if (!dtr.b_enable) {\n            // Delayed system reset\n            reset_controller_write_reset_pin(0);\n            delay_ms(1000);\n            initiateReset();\n        } else {\n            cancelReset();\n        }\n    }\n}", "CodeBleu_score": 41.581511749795176}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t    switch (usb_task_setup_request.bRequest) {\n        case 0x04:\n            usb_task_setup_request.wValue = 0x0300;\n            usb_task_setup_request.wIndex = 0x0409;\n            usb_task_setup_request.wLength = 18;\n            usb_task_setup_request.pData = (uint8_t *)&desc_ms_vendor_code;\n            return true;\n\n        case 0x05:\n            usb_task_setup_request.wValue = 0x0300;\n            usb_task_setup_request.wIndex = 0x0409;\n            usb_task_setup_request.wLength = 50;\n            usb_task_setup_request.pData = (uint8_t *)&desc_ms_os_string_descriptor;\n            return true;\n\n        default:\n            return false;\n    }\n}", "CodeBleu_score": 19.19833855394138}, {"code": "bool usb_task_other_requests(void){\n\t    switch (usb_setup.bRequest) {\n        case 0x04:\n            usb_control_payload = (uint8_t *)&desc_ms_vendor_code;\n            usb_control_remaining = sizeof(desc_ms_vendor_code);\n            return true;\n\n        case 0x05:\n            usb_control_payload = (uint8_t *)&desc_ms_extended_properties;\n            usb_control_remaining = sizeof(desc_ms_extended_properties);\n            return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 17.741243209675766}, {"code": "bool usb_task_other_requests(void){\n\t    switch (usb_task_setup_request.bRequest) {\n        case 0x04:\n            usb_task_setup_request.wValue = 0x0300;\n            usb_task_setup_request.wIndex = 0x0409;\n            usb_task_setup_request.wLength = 0x0012;\n            usb_task_setup_request.pData = (uint8_t*)&usb_task_setup_request.wLength;\n            return true;\n        case 0x05:\n            usb_task_setup_request.wValue = 0x0300;\n            usb_task_setup_request.wIndex = 0x0409;\n            usb_task_setup_request.wLength = 0x0012;\n            usb_task_setup_request.pData = (uint8_t*)&usb_task_setup_request.wLength;\n            return true;\n    }\n    return false;\n}", "CodeBleu_score": 19.394207088346562}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0)\n    return;\n\n  spiSend(0xFF);\n  while (--nbyte) {\n    spiSend(0xFF);\n    *buf++ = spiRec();\n  }\n\n  *buf = spiRec();\n}", "CodeBleu_score": 35.70551313963482}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0)\n        return;\n\n    for (uint16_t i = 0; i < (nbyte - 1); i++) {\n        spiSend(0xFF);\n        buf[i] = spiRec();\n    }\n\n    spiSend(0xFF);\n    buf[(nbyte - 1)] = spiRec();\n}", "CodeBleu_score": 55.16070440374228}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0)\n        return;\n\n    for (uint16_t i = 0; i < nbyte - 1; i++) {\n        spiSend(0xFF);\n        buf[i] = spiRec();\n    }\n\n    buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 55.234966242787294}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    uint32_t *pNVIC_VectTable;\n    uint32_t offset;\n    uint32_t oldHandler;\n\n    pNVIC_VectTable = (uint32_t *)SCB_VTOR;\n    offset = (uint32_t)irq + NVIC_IRQ_OFFSET;\n    oldHandler = pNVIC_VectTable[offset + 1];\n    pNVIC_VectTable[offset + 1] = (uint32_t)newHandler;\n    return (pfnISR_Handler)oldHandler;\n}", "CodeBleu_score": 41.047295357289016}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler = NULL;\n    uint32_t *pNVIC_VectTable = (uint32_t *)SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_SYSRESETREQ_Msk;\n\n    __disable_irq();\n    oldHandler = (pfnISR_Handler)pNVIC_VectTable[irq + 16];\n    pNVIC_VectTable[irq + 16] = (uint32_t)newHandler;\n    __enable_irq();\n\n    return oldHandler;\n}", "CodeBleu_score": 55.97841930313573}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler = NULL;\n    uint32_t *pNVIC_VectTable;\n    uint32_t offset;\n\n    /* Get the address of the relocated interrupt vector table. */\n    pNVIC_VectTable = (uint32_t *)SCB_VTOR;\n\n    /* Disable global interrupts. */\n    __disable_irq();\n\n    /* Get the offset of the IRQ in the vector table. */\n    offset = (uint32_t)irq + (uint32_t)16;\n\n    /* Get the current handler for the specified IRQ. */\n    oldHandler = (pfnISR_Handler)pNVIC_VectTable[offset];\n\n    /* Replace the current handler with the new handler. */\n    pNVIC_VectTable[offset] = (uint32_t)newHandler;\n\n    /* Re-enable global interrupts. */\n    __enable_irq();\n\n    /* Return the original ISR handler. */\n    return oldHandler;\n}", "CodeBleu_score": 45.3020302359444}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_cdc_enabled) {\n    int c = usb_cdc_peek();\n    if (c < 0) return -1;\n    if (c == DLE) {\n      usb_cdc_getc();\n      c = usb_cdc_getc();\n      if (c < 0) return -1;\n      c ^= 0x20;\n    }\n    return c;\n  }\n  else\n    return -1;\n}", "CodeBleu_score": 45.692142917447796}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!enabled) return -1;\n  if (usb_cdc_line_rtsdtr_available()) {\n    uint8_t b = usb_cdc_getc();\n    if (b == DLE) {\n      if (usb_cdc_line_rtsdtr_available()) {\n        uint8_t c = usb_cdc_getc();\n        if (c == ETX) {\n          in_escape = false;\n          return -1;\n        }\n        else {\n          in_escape = true;\n          return c ^ 0x20;\n        }\n      }\n      else {\n        in_escape = true;\n        return -1;\n      }\n    }\n    else if (b == STX) {\n      in_escape = false;\n      return -1;\n    }\n    else if (in_escape) {\n      in_escape = false;\n      return b ^ 0x20;\n    }\n    else\n      return b;\n  }\n  else\n    return -1;\n}", "CodeBleu_score": 25.472773280445782}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_cdc_enabled) {\n    int c = usb_rx_byte;\n    if (c >= 0) {\n      usb_rx_byte = -1;\n      return c;\n    }\n    return usb_serial_peek();\n  }\n  return -1;\n}", "CodeBleu_score": 30.411673508966462}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t    // Check if there is a pending character\n    if (rx_buffer_head != rx_buffer_tail) {\n        // Return the pending character\n        unsigned char c = rx_buffer[rx_buffer_tail];\n        rx_buffer_tail = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n        return c;\n    }\n\n    // Check if the USB CDC is enabled and configured\n    if (!usb_cdc_enabled || !usb_cdc_configured) {\n        return -1;\n    }\n\n    // Check if there are any bytes available to read from the PC\n    if (!tud_cdc_available()) {\n        return -1;\n    }\n\n    // Read a byte from the PC\n    char c;\n    tud_cdc_read(&c, 1);\n\n    // Update the emergency parser if enabled\n    if (emergency_parser_enabled) {\n        emergency_parser.update(c);\n    }\n\n    // Return the read character\n    return c;\n}", "CodeBleu_score": 37.894440858554766}, {"code": "int MarlinSerialUSB::read(){\n\t    // Check if there is a pending character\n    if (pending_char) {\n        char c = pending_char;\n        pending_char = 0;\n        return c;\n    }\n\n    // Check if the USB CDC is enabled and configured\n    if (!is_usb_cdc_enabled() || !is_usb_cdc_configured()) {\n        return -1;\n    }\n\n    // Check if there are any bytes available to read from the PC\n    if (tud_cdc_available()) {\n        // Read a byte from the PC\n        char c = tud_cdc_read_char();\n\n        // Update the emergency parser if enabled\n        if (emergency_state == EmergencyParserState::STARTED) {\n            update_emergency_parser(c);\n        }\n\n        return c;\n    }\n\n    return -1;\n}", "CodeBleu_score": 44.947769773663595}, {"code": "int MarlinSerialUSB::read(){\n\t  int c = -1;\n\n  if (usb_serial_available()) {\n    c = _usb_serial_getc();\n    if (c < 0) return 0;\n    #if ENABLED(EMERGENCY_PARSER)\n      if (parser.seen('M')) {\n        if (parser.seen('112')) emergency_parser.M112();\n        if (parser.seen('114')) emergency_parser.M114();\n        if (parser.seen('115')) emergency_parser.M115();\n      }\n    #endif\n    return c;\n  }\n  else\n    return -1;\n}", "CodeBleu_score": 46.808194247239385}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (rx_buffer_head != rx_buffer_tail) {\n    return ((unsigned int)BUFFER_SIZE + rx_buffer_head - rx_buffer_tail) % BUFFER_SIZE;\n  }\n  else if (usb_cdc_line_rtsdtr_active()) {\n    return 1;\n  }\n  else {\n    return 0;\n  }\n}", "CodeBleu_score": 32.25073223041812}, {"code": "int MarlinSerialUSB::available(){\n\t  if (rx_buffer.available()) {\n    return rx_buffer.available();\n  }\n  else {\n    return usb_cdc_connected() ? 1 : 0;\n  }\n}", "CodeBleu_score": 43.81374744237932}, {"code": "int MarlinSerialUSB::available(){\n\t  if (usb_serial_available()) {\n    return usb_serial_available();\n  }\n  else {\n    return usb_serial_get_control() ? 1 : 0;\n  }\n}", "CodeBleu_score": 34.85558245303923}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t    while (size--) {\n        uint8_t c = EEPROM.read(pos);\n        crc16(crc, &c, 1);\n        if (writing)\n            *value++ = c;\n        pos++;\n    }\n    return false;\n}", "CodeBleu_score": 61.77005386751302}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t    for (size_t i = 0; i < size; ++i) {\n        uint8_t c = EEPROM.read(pos);\n        if (writing) {\n            *value = c;\n            ++value;\n        }\n        crc16(crc, &c, 1);\n        ++pos;\n    }\n    return false;\n}", "CodeBleu_score": 61.191103588860564}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t    for (size_t i = 0; i < size; i++) {\n        uint8_t c = EEPROM.read(pos);\n        if (writing) {\n            *value = c;\n            value++;\n        }\n        crc16(crc, &c, 1);\n        pos++;\n    }\n    return false;\n}", "CodeBleu_score": 64.22438168228999}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  const uint8_t channel = get_pin_channel(pin);\n  if (channel != LEDC_CHANNEL_NOT_SET) {\n    ledcWrite(channel, value);\n  } else {\n    const uint8_t slot = get_pin_slot(pin);\n    if (slot != LEDC_CHANNEL_NOT_SET) {\n      if (pwm_slots[slot].freq != freq || pwm_slots[slot].res != res) {\n        pwm_slots[slot].freq = freq;\n        pwm_slots[slot].res = res;\n        pwm_slots[slot].value = value;\n        pwm_slots[slot].pin = pin;\n        pwm_slots[slot].used = true;\n        if (pwm_used_count == 0) {\n          pwm_timer = timerBegin(0, 80, true);\n          timerAttachInterrupt(pwm_timer, &onTimer, true);\n          timerAlarmWrite(pwm_timer, 1000000 / freq, true);\n          timerAlarmEnable(pwm_timer);\n        }\n        pwm_used_count++;\n      }\n    }\n  }\n}", "CodeBleu_score": 43.66963295076845}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t    if (pin >= NUM_DIGITAL_PINS) {\n        return;\n    }\n\n    if (ledcWrite(pin, value, res)) {\n        return;\n    }\n\n    if (pin >= NUM_DIGITAL_PINS) {\n        return;\n    }\n\n    if (digitalPinToTimer(pin) == NOT_ON_TIMER) {\n        return;\n    }\n\n    if (ledcRead(pin) == value) {\n        return;\n    }\n\n    if (value == 0) {\n        digitalWrite(pin, LOW);\n        return;\n    }\n\n    if (value >= (1 << res)) {\n        digitalWrite(pin, HIGH);\n        return;\n    }\n\n    if (freq == 0) {\n        freq = PWM_FREQUENCY;\n    }\n\n    if (ledcSetup(pin, freq, res) == 0) {\n        return;\n    }\n\n    ledcWrite(pin, value);\n}", "CodeBleu_score": 37.97924486299695}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin >= NUM_DIGITAL_PINS) {\n    return;\n  }\n  const uint8_t channel = digitalPinToChannel(pin);\n  if (channel != NO_CHANNEL) {\n    const uint8_t bit = digitalPinToBitMask(pin);\n    const uint8_t port = digitalPinToPort(pin);\n    const uint8_t timer = (port == NOT_A_PIN) ? 0 : port;\n    ledcWrite(channel, value);\n    return;\n  }\n  if (pin >= NUM_DIGITAL_PINS) {\n    return;\n  }\n  const uint8_t index = pinToIndex(pin);\n  if (index >= PWM_MAX_CHANNELS) {\n    return;\n  }\n  if (pwm_state[index].pin != pin) {\n    if (pwm_state[index].pin != NOT_A_PIN) {\n      analogWrite(pwm_state[index].pin, 0);\n    }\n    pwm_state[index].pin = pin;\n    pwm_state[index].freq = freq;\n    pwm_state[index].res = res;\n    pwm_state[index].used = true;\n    if (pwm_used == 0) {\n      timerAttachPin(pin, TIMER_LED);\n      timerAlarmWrite(TIMER_LED, 1000000 / freq, true);\n      timerAlarmEnable(TIMER_LED);\n    }\n    pwm_used++;\n  }\n  pwm_state[index].value = value;\n  pwm_state[index].duty = map(value, 0, (1 << res) - 1, 0, 100);\n}", "CodeBleu_score": 40.21176495667921}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t    static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == NUM_SERVOS, \"Servo delay array length does not match the number of servos.\");\n\n    if (servo.attach(servo_pin)) {\n        servo.write(value);\n        delay(servo_delay[servo_channel]);\n\n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n        servo.detach();\n#endif\n    }\n}", "CodeBleu_score": 49.859904804934466}, {"code": "void Servo::move(const int value){\n\t    static_assert(sizeof(servo_delay) / sizeof(int) == SERVO_CHANNELS, \"servo_delay array length does not match SERVO_CHANNELS\");\n    if (attach()) {\n        servo.write(value);\n        delay(servo_delay[channel]);\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n            detach();\n        }\n    }\n}", "CodeBleu_score": 47.19621460094875}, {"code": "void Servo::move(const int value){\n\t    if (servo.attach(pin, min, max)) {\n        servo.write(value);\n        delay(servoDelay[channel]);\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n            servo.detach();\n        }\n    }\n}", "CodeBleu_score": 45.16220281019122}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t    // Update PWM states for each pin\n    for (int i = 0; i < I2S_NUM_PINS; i++) {\n        // Check if the pin has active PWM\n        if (i2s_pwm_duty_cycle[i] > 0) {\n            // Decrement the PWM tick count\n            i2s_pwm_tick_count[i]--;\n\n            // Check if the PWM tick count reaches zero\n            if (i2s_pwm_tick_count[i] == 0) {\n                // Toggle the pin state between high and low\n                if (i2s_pin_state[i]) {\n                    i2s_pin_state[i] = 0;\n                } else {\n                    i2s_pin_state[i] = 1;\n                }\n\n                // Set the tick count for the next transition\n                i2s_pwm_tick_count[i] = i2s_pwm_duty_cycle[i];\n            }\n        }\n    }\n\n    // Write the resulting data to the DMA buffer\n    uint32_t port_data = 0;\n    for (int i = 0; i < I2S_NUM_PINS; i++) {\n        if (i2s_pin_state[i]) {\n            port_data |= (1 << i);\n        }\n    }\n    i2s_dma_buffer[i2s_dma_buffer_pos] = port_data;\n\n    // Increment the buffer position\n    i2s_dma_buffer_pos++;\n}", "CodeBleu_score": 39.28198900234319}, {"code": "void i2s_push_sample(){\n\t    // Update PWM states for each pin\n    for (int i = 0; i < NUM_PINS; i++) {\n        // Check if the pin has active PWM\n        if (pins[i].duty_cycle != 0) {\n            // Decrement the PWM tick count\n            pins[i].tick_count--;\n\n            // Check if the PWM tick count reaches zero\n            if (pins[i].tick_count == 0) {\n                // Toggle the pin state between high and low\n                pins[i].state = !pins[i].state;\n\n                // Set the tick count for the next transition\n                pins[i].tick_count = pins[i].duty_cycle;\n            }\n        }\n    }\n\n    // Write the updated port data to the DMA buffer\n    for (int i = 0; i < NUM_PINS; i++) {\n        dma_buffer[dma_pos] |= pins[i].state << i;\n    }\n\n    // Increment the DMA buffer position\n    dma_pos++;\n}", "CodeBleu_score": 33.30845561293307}, {"code": "void i2s_push_sample(){\n\t    // Update the PWM states for each pin\n    for (int i = 0; i < NUM_PINS; i++) {\n        if (pwm_duty_cycles[i] > 0) {\n            // PWM is active for this pin\n            if (pwm_tick_counts[i] == 0) {\n                // Time to toggle the pin state\n                if (pwm_states[i]) {\n                    // Pin is currently high, set it to low\n                    pwm_states[i] = 0;\n                    port_data &= ~(1 << pins[i]);\n                } else {\n                    // Pin is currently low, set it to high\n                    pwm_states[i] = 1;\n                    port_data |= (1 << pins[i]);\n                }\n                // Reset the tick count for the next transition\n                pwm_tick_counts[i] = pwm_periods[i];\n            } else {\n                // Decrement the tick count for the next transition\n                pwm_tick_counts[i]--;\n            }\n        } else {\n            // PWM is not active for this pin\n            pwm_states[i] = 0;\n            port_data &= ~(1 << pins[i]);\n        }\n    }\n\n    // Write the resulting data to the DMA buffer\n    dma_buffer[dma_buffer_pos] = port_data;\n    dma_buffer_pos++;\n}", "CodeBleu_score": 42.39966718680394}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    return timer_get_count(timer_num);\n}", "CodeBleu_score": 13.961117548126573}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    // Check if the timer number is valid\n    if (timer_num >= NUM_HW_TIMERS) {\n        return 0;\n    }\n\n    // Access the timer configuration\n    timer_config_t *timer_config = &timer_configs[timer_num];\n\n    // Fetch the current counter value from the timer\n    hal_timer_t timer_count = timer_config->timer_count;\n\n    // Return the counter value\n    return timer_count;\n}", "CodeBleu_score": 46.1078460763968}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    // Check if the timer number is valid\n    if (timer_num >= NUM_OF_HW_TIMERS) {\n        return 0;\n    }\n\n    // Retrieve the current counter value from the specified timer\n    return timer_get_count(timer_num);\n}", "CodeBleu_score": 19.092800439655793}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  while (size_t(pos) + size < EEPROM_DATA_END) {\n    for (size_t i = 0; i < size; ++i) {\n      uint8_t c = EEPROM.read(pos);\n      if (writing) value[i] = c;\n      crc16(crc, &c, 1);\n      pos++;\n    }\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 70.19229562183617}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t    for (size_t i = 0; i < size; ++i) {\n        uint8_t c = EEPROM.read(pos);\n        if (writing) {\n            *value = c;\n            ++value;\n        }\n        crc16(crc, &c, 1);\n        ++pos;\n    }\n    return false;\n}", "CodeBleu_score": 60.66852831301467}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t    while (size_t(pos) + size <= EEPROM.length()) {\n        uint8_t c = EEPROM.read(pos);\n        if (writing) {\n            *value = c;\n            ++value;\n        }\n        crc16(crc, &c, 1);\n        ++pos;\n    }\n    return false;\n}", "CodeBleu_score": 46.82231410556717}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    assert_param(sdio_handle != NULL);\n    assert_param(src != NULL);\n\n    uint32_t retries = SDIO_MAX_RETRIES;\n\n    while (HAL_SD_WriteBlocks(sdio_handle, src, block, 1) != HAL_OK) {\n        if (retries-- == 0) {\n            printf(\"SDIO_WriteBlock failed\n\");\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 35.17656715057467}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    assert_param(sdio_handle != NULL);\n    assert_param(src != NULL);\n\n    int retries = SDIO_WRITE_RETRIES;\n    while (retries--) {\n        if (SDIO_OK == SDIO_WriteBlock(sdio_handle, src, block, 5000)) {\n            return true;\n        }\n    }\n\n    printf(\"SDIO_WriteBlock failed\n\");\n    return false;\n}", "CodeBleu_score": 36.91005729546154}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    assert(sdio_handle != NULL);\n    assert(src != NULL);\n\n    for (int i = 0; i < MAX_WRITE_RETRIES; i++) {\n        if (SDIO_WriteBlock_DMA(block, src) == true) {\n            return true;\n        }\n    }\n\n    printf(\"SDIO_WriteBlock failed\n\");\n    return false;\n}", "CodeBleu_score": 32.525356117522776}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n  case TIMER_STEP:\n    timer_init(TIMER_STEP, frequency, STEPPER_TIMER_PRESCALE, STEPPER_TIMER_CALLBACK_PRIORITY);\n    break;\n  case TIMER_TEMP:\n    timer_init(TIMER_TEMP, frequency, TEMPERATURE_TIMER_PRESCALE, TEMPERATURE_TIMER_CALLBACK_PRIORITY);\n    break;\n  default:\n    ASSERT(false);\n    break;\n  }\n}", "CodeBleu_score": 25.232567624738945}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    if (timer_num == TEMP_TIMER) {\n        // Set up the timer\n        timer_init();\n        timer_set_prescaler(TEMP_TIMER_PRESCALE);\n        timer_set_reload(TEMP_TIMER_RELOAD);\n        timer_set_callback_priority(TEMP_TIMER_CALLBACK_PRIORITY);\n        timer_attach_interrupt(TEMP_TIMER_INTERRUPT_PRIORITY, HAL_temp_timer_interrupt_handler);\n        timer_start();\n    } else if (timer_num == STEP_TIMER) {\n        // Set up the timer\n        timer_init();\n        timer_set_prescaler(STEP_TIMER_PRESCALE);\n        timer_set_reload(STEP_TIMER_RELOAD);\n        timer_set_callback_priority(STEP_TIMER_CALLBACK_PRIORITY);\n        timer_attach_interrupt(STEP_TIMER_INTERRUPT_PRIORITY, HAL_step_timer_interrupt_handler);\n        timer_start();\n    } else {\n        // Invalid timer channel\n        assert_param(0);\n    }\n}", "CodeBleu_score": 39.89846082954966}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    if (timer_num == TIMER_CHANNEL_TEMP) {\n        // Start the temperature timer with the given frequency and prescale\n        timer_start(TIMER_GROUP_TEMP, TIMER_TEMP, frequency, TIMER_TEMP_PRESCALE);\n\n        // Set the callback priority for temperature\n        timer_set_callback_arg(TIMER_GROUP_TEMP, TIMER_TEMP, &temperature_callback, (void *)TIMER_CHANNEL_TEMP);\n        timer_set_callback(TIMER_GROUP_TEMP, TIMER_TEMP, temperature_callback);\n    } else if (timer_num == TIMER_CHANNEL_STEP) {\n        // Start the step timer with the given frequency and prescale\n        timer_start(TIMER_GROUP_STEP, TIMER_STEP, frequency, TIMER_STEP_PRESCALE);\n\n        // Set the callback priority for stepper\n        timer_set_callback_arg(TIMER_GROUP_STEP, TIMER_STEP, &stepper_callback, (void *)TIMER_CHANNEL_STEP);\n        timer_set_callback(TIMER_GROUP_STEP, TIMER_STEP, stepper_callback);\n    } else {\n        // Invalid timer channel, trigger an assertion failure\n        assert_param(0);\n    }\n}", "CodeBleu_score": 36.576535444896464}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t    if (!_eeprom_file.open(eeprom_filename, O_RDWR | O_CREAT)) {\n        return false;\n    }\n\n    if (_eeprom_file.fileSize() < EEPROM_SIZE) {\n        for (int i = _eeprom_file.fileSize(); i < EEPROM_SIZE; i++) {\n            _eeprom_file.write(EEPROM_ERASE_VALUE);\n        }\n    }\n\n    _eeprom_file.seekSet(0);\n    _eeprom_file.read(_eeprom_buffer, EEPROM_SIZE);\n    _eeprom_file.close();\n\n    return true;\n}", "CodeBleu_score": 26.4114762570955}, {"code": "bool PersistentStore::access_start(){\n\t  if (!file) {\n    return false;\n  }\n\n  file.seek(0);\n  int bytes_read = file.read(buffer, EEPROM_SIZE);\n\n  file.close();\n\n  if (bytes_read < EEPROM_SIZE) {\n    int bytes_to_write = EEPROM_SIZE - bytes_read;\n    memset(buffer + bytes_read, erase_value, bytes_to_write);\n  }\n\n  return true;\n}", "CodeBleu_score": 30.422661365742325}, {"code": "bool PersistentStore::access_start(){\n\t    if (!_file) {\n        return false;\n    }\n\n    int32_t fileSize = _file.size();\n\n    // Check if file exists and is of sufficient size\n    if (fileSize > 0 && fileSize != EEPROM_SIZE) {\n        _file.close();\n        return false;\n    }\n\n    // If file does not exist or is of insufficient size, create a new one\n    if (fileSize != EEPROM_SIZE) {\n        if (!_file.seek(0)) {\n            _file.close();\n            return false;\n        }\n\n        uint8_t clearByte = 0xFF;\n        for (uint32_t i = 0; i < EEPROM_SIZE; i++) {\n            _file.write(&clearByte, 1);\n        }\n\n        if (!_file.seek(0)) {\n            _file.close();\n            return false;\n        }\n    }\n\n    // Read file into buffer\n    if (_file.available() && _file.read(_buffer, EEPROM_SIZE) != EEPROM_SIZE) {\n        _file.close();\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 30.064614832631243}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t i;\n  uint8_t r = 0;\n\n  for (i = 0; i < 8; i++) {\n    HAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, b & 0x80 ? GPIO_PIN_SET : GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n    b <<= 1;\n    if (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) {\n      b |= 0x01;\n    }\n  }\n  HAL_Delay(1);\n  return r;\n}", "CodeBleu_score": 41.45283913348265}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t i;\n    uint8_t r = 0;\n\n    for (i = 0; i < 8; i++) {\n        HAL_SPI_STM32_Set_Clock_Low();\n        HAL_SPI_STM32_Write_Bit(b & 0x80);\n        HAL_SPI_STM32_Set_Clock_High();\n        r <<= 1;\n        r |= HAL_SPI_STM32_Read_Bit();\n        b <<= 1;\n    }\n\n    HAL_SPI_STM32_Delay();\n    return r;\n}", "CodeBleu_score": 37.45548509091988}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    for (uint8_t i = 0; i < 8; i++) {\n        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_SET);\n        r = (r << 1) | (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET);\n        b <<= 1;\n    }\n    HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);\n    HAL_Delay(1);\n    return r;\n}", "CodeBleu_score": 40.787862636216985}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    uint32_t tmp = 0x00;\n    uint32_t enrpos = 0x00;\n    uint32_t enr = 0x00;\n\n    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    /* Get the AHB peripheral clock enable/disable bit position */\n    enrpos = RCC_AHBPeriph / 0x04000000;\n    enrpos = (uint32_t)0x1 << enrpos;\n\n    /* Get AHB peripheral clock enable/disable bit value */\n    if (NewState != DISABLE) {\n        enr = (uint32_t)0x1 << (RCC_AHBPeriph % 0x04000000);\n    } else {\n        enr = (uint32_t)0x1 << (RCC_AHBPeriph % 0x04000000);\n        enr = ~enr;\n    }\n\n    /* Get AHB peripheral clock enable/disable register value */\n    tmp = RCC->AHBENR;\n\n    /* Set or clear the enable/disable bit in the AHBENR register */\n    if (NewState != DISABLE) {\n        tmp |= enr;\n    } else {\n        tmp &= enr;\n    }\n\n    /* Set the AHBENR register */\n    RCC->AHBENR = tmp;\n}", "CodeBleu_score": 57.75481972028823}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    if (RCC_AHBPeriph == RCC_AHBPeriph_GPIOA) {\n        if (NewState == ENABLE) {\n            RCC->AHBENR |= RCC_AHBPeriph_GPIOA;\n        } else if (NewState == DISABLE) {\n            RCC->AHBENR &= ~RCC_AHBPeriph_GPIOA;\n        }\n    } else if (RCC_AHBPeriph == RCC_AHBPeriph_GPIOB) {\n        if (NewState == ENABLE) {\n            RCC->AHBENR |= RCC_AHBPeriph_GPIOB;\n        } else if (NewState == DISABLE) {\n            RCC->AHBENR &= ~RCC_AHBPeriph_GPIOB;\n        }\n    } else if (RCC_AHBPeriph == RCC_AHBPeriph_GPIOC) {\n        if (NewState == ENABLE) {\n            RCC->AHBENR |= RCC_AHBPeriph_GPIOC;\n        } else if (NewState == DISABLE) {\n            RCC->AHBENR &= ~RCC_AHBPeriph_GPIOC;\n        }\n    } else if (RCC_AHBPeriph == RCC_AHBPeriph_GPIOD) {\n        if (NewState == ENABLE) {\n            RCC->AHBENR |= RCC_AHBPeriph_GPIOD;\n        } else if (NewState == DISABLE) {\n            RCC->AHBENR &= ~RCC_AHBPeriph_GPIOD;\n        }\n    } else if (RCC_AHBPeriph == RCC_AHBPeriph_GPIOE) {\n        if (NewState == ENABLE) {\n            RCC->AHBENR |= RCC_AHBPeriph_GPIOE;\n        } else if (NewState == DISABLE) {\n            RCC->AHBENR &= ~RCC_AHBPeriph_GPIOE;\n        }\n    } else if", "CodeBleu_score": 40.90554547396318}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    uint32_t tmpreg = 0;\n    uint32_t bitpos = 0;\n    uint32_t bitmask = 0;\n\n    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    /* Get the AHB peripheral clock register index */\n    bitpos = RCC_AHBPeriph >> 5;\n    bitpos = (uint32_t) 1 << bitpos;\n\n    /* Get the AHB peripheral clock bit position */\n    bitmask = RCC_AHBPeriph & (uint32_t) 0x1F;\n    bitmask = (uint32_t) 1 << bitmask;\n\n    if (bitmask != RCC_AHBPeriph) {\n        /* Get the AHB peripheral clock register index */\n        bitpos = RCC_AHBPeriph >> 11;\n        bitpos = (uint32_t) 1 << bitpos;\n\n        /* Get the AHB peripheral clock bit position */\n        bitmask = RCC_AHBPeriph & (uint32_t) 0x7FF;\n        bitmask = (uint32_t) 1 << bitmask;\n    }\n\n    /* Get the AHB peripheral clock enable/disable bitmask */\n    tmpreg = RCC->AHBENR;\n\n    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    if (NewState != DISABLE) {\n        /* Enable the selected AHB peripheral clock */\n        tmpreg |= bitmask;\n    } else {\n        /* Disable the selected AHB peripheral clock */\n        tmpreg &= ~bitmask;\n    }\n\n    /* Write to AHBENR */\n    RCC->AHBENR = tmpreg;\n}", "CodeBleu_score": 59.44291313251473}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  #if ENABLED(EMERGENCY_PARSER)\n    if (emergency_state == EMERGENCY_STATE_WAIT_PARSER)\n      emergency_parser.update(obj->uart_getc());\n  #endif\n  if (obj->is_parity_error()) {\n    obj->uart_getc();\n    return;\n  }\n  uint8_t data = obj->uart_getc();\n  if (rx_buffer_head < RX_BUFFER_SIZE) {\n    rx_buffer[rx_buffer_head] = data;\n    uint8_t next_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n    if (next_buffer_head != rx_buffer_tail)\n      rx_buffer_head = next_buffer_head;\n  }\n  else {\n    overrun_error_count++;\n  }\n}", "CodeBleu_score": 37.239962366281134}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\n  // If no parity error occurs, read the byte and store it in the receive buffer if there is space available\n  if (!obj->parity_error) {\n    uint8_t data = obj->periph->RDR;\n    if (obj->rx_buffer_head < obj->rx_buffer_tail) {\n      obj->rx_buffer[obj->rx_buffer_head++] = data;\n    }\n    else {\n      obj->rx_buffer[obj->rx_buffer_head++] = data;\n      obj->rx_buffer_head = obj->rx_buffer_tail;\n    }\n  }\n\n  // Calculate the next buffer index and update the head pointer\n  obj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\n  // If enabled, update the emergency parser with the received byte\n  if (obj->emergency_parser) {\n    obj->emergency_parser(data);\n  }\n}", "CodeBleu_score": 41.75037715081062}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  // If no parity error, read byte and store it in the buffer if there is room\n  uint8_t data = obj->uart->DR;\n  if (obj->parity_error == 0) {\n    if (obj->rx_buffer.head < obj->rx_buffer.get_size()) {\n      obj->rx_buffer.buffer[obj->rx_buffer.head] = data;\n      obj->rx_buffer.head = (obj->rx_buffer.head + 1) % obj->rx_buffer.get_size();\n    }\n  }\n  // Update the emergency parser\n  if (obj->emergency_state != EMERGENCY_STATE_DISABLED) {\n    obj->emergency_parser.update(data);\n  }\n}", "CodeBleu_score": 39.315744654451144}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        if (!(TIMER_STEP_TIMER->CTRL & TC_CTRLA_ENABLE)) {\n            return;\n        }\n\n        if (TIMER_STEP_TIMER->INTENSET & TC_INTENSET_OVF) {\n            return;\n        }\n\n        NVIC_EnableIRQ(TC3_IRQn);\n        TIMER_STEP_TIMER->INTENSET = TC_INTENSET_OVF;\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n        if (!(TIMER_TEMP_TIMER->CTRL & TC_CTRLA_ENABLE)) {\n            return;\n        }\n\n        if (TIMER_TEMP_TIMER->INTENSET & TC_INTENSET_OVF) {\n            return;\n        }\n\n        NVIC_EnableIRQ(TC4_IRQn);\n        TIMER_TEMP_TIMER->INTENSET = TC_INTENSET_OVF;\n    }\n}", "CodeBleu_score": 28.06349401951857}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        if (!step_timer_interrupt_attached) {\n            attachInterrupt(digitalPinToInterrupt(STEP_TIMER_INT), Step_Handler, RISING);\n            step_timer_interrupt_attached = true;\n        }\n    } else if (timer_num == MF_TIMER_TEMP) {\n        if (!temp_timer_interrupt_attached) {\n            attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_INT), Temp_Handler, RISING);\n            temp_timer_interrupt_attached = true;\n        }\n    }\n}", "CodeBleu_score": 32.1991980016154}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        if (is_timer_init(timer_num)) {\n            if (!is_timer_interrupt_attached(timer_num)) {\n                attachInterrupt(digitalPinToInterrupt(PIN_STEP_INT), Step_Handler, RISING);\n            }\n        }\n    } else if (timer_num == MF_TIMER_TEMP) {\n        if (is_timer_init(timer_num)) {\n            if (!is_timer_interrupt_attached(timer_num)) {\n                attachInterrupt(digitalPinToInterrupt(PIN_TEMP_INT), Temp_Handler, RISING);\n            }\n        }\n    }\n}", "CodeBleu_score": 40.48716498649855}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\n\thashSep := Hash[T](sep)\n\thashSub := Hash[T](s[len(s)-len(sep):])\n\n\tif hashSep == hashSub && Equal[T](s[len(s)-len(sep):], sep) {\n\t\treturn len(s) - len(sep)\n\t}\n\n\tpow := Pow[T](len(sep))\n\n\tfor i := len(s) - len(sep) - 1; i >= 0; i-- {\n\t\thashSub = hashSub*Prime + T(s[i]) - pow*T(s[i+len(sep)])\n\t\tif hashSub == hashSep && Equal[T](s[i:i+len(sep)], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}", "CodeBleu_score": 42.18247120049822}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\n\thashSep := hash(sep)\n\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\thashSub := hash(s[i : i+len(sep)])\n\n\t\tif hashSub == hashSep && Equal(s[i:i+len(sep)], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}", "CodeBleu_score": 32.40824748617734}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\n\thashSubStr := Hash(sep)\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\thashSubStr2 := Hash(s[i : i+len(sep)])\n\t\tif hashSubStr == hashSubStr2 {\n\t\t\tif Equal(s[i:i+len(sep)], sep) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1\n}", "CodeBleu_score": 31.02647643888845}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.waitTxc {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore(0)\n}", "CodeBleu_score": 44.80647726985269}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.waitTxc {\n\t\tusbcdc.waitTxc = false\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tinterrupt.Restore(0)\n}", "CodeBleu_score": 35.634478898683874}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.waitTxc {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 43.8820638879313}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.Control.SetBits(1 << avr.TWINT | 1 << avr.TWSTA | 1 << avr.TWEN)\n\n\tfor i2c.Control.HasBits(1 << avr.TWINT) {\n\t}\n\n\ti2c.Data.Set(address << 1)\n\tif !write {\n\t\ti2c.Data.SetBits(1 << avr.TWINT | 1 << avr.TWEN | 1 << avr.TWEA)\n\t} else {\n\t\ti2c.Data.SetBits(1 << avr.TWINT | 1 << avr.TWEN)\n\t}\n\n\tfor i2c.Control.HasBits(1 << avr.TWINT) {\n\t}\n}", "CodeBleu_score": 30.481538492437632}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.Control.SetBits(1<<avr.TWINT | 1<<avr.TWSTA)\n\n\tfor !i2c.Control.HasBits(1 << avr.TWINT) {\n\t}\n\n\ti2c.Data.Set(uint8(address << 1))\n\tif !write {\n\t\ti2c.Data.SetBits(1 << avr.TWINT)\n\t}\n\n\tfor !i2c.Control.HasBits(1 << avr.TWINT) {\n\t}\n}", "CodeBleu_score": 34.650796461717725}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.Control.SetBits(1<<avr.TWINT | 1<<avr.TWSTA)\n\n\ti2c.wait()\n\n\ti2c.writeByte(address<<1 | uint8(write))\n}", "CodeBleu_score": 28.13092537679317}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := uintptr(f.start) + uintptr(start*f.blockSize)\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.Flash.Erase(uint32(startAddr), f.blockSize/4)\n\t\tstartAddr += f.blockSize\n\t\tinterrupt.WaitForEvent()\n\t}\n\tnrf.Flash.ReadWait(1)\n\treturn nil\n}", "CodeBleu_score": 34.26991552202763}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address based on the block number and block size.\n\tstartAddress := f.startAddress + uintptr(start*f.blockSize)\n\n\t// Wait for any ongoing flash operations to complete.\n\tf.wait()\n\n\t// Set flash to erasing mode.\n\tf.config.Erase = nrf.FlashTaskErase\n\n\t// Erase each block in the specified range.\n\tfor i := start; i < start+len; i++ {\n\t\t// Set the flash address register to the current block's address.\n\t\tf.config.Address = uint32(startAddress + uintptr(i*f.blockSize))\n\n\t\t// Wait until the flash is no longer busy.\n\t\tf.wait()\n\t}\n\n\t// Set flash back to read mode.\n\tf.config.Erase = nrf.FlashTaskNone\n\n\treturn nil\n}", "CodeBleu_score": 45.03922143755316}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := f.startAddress + uintptr(start)*f.blockSize\n\tendAddr := startAddr + uintptr(len)*f.blockSize\n\n\t// Wait for any ongoing flash operations to complete.\n\tnrf.NVMC.CONFIG.Wait()\n\n\t// Set flash to erase mode.\n\tnrf.NVMC.CONFIG.MODE = nrf.NVMC_CONFIG_MODE_ERASE\n\n\t// Erase blocks.\n\tfor addr := startAddr; addr < endAddr; addr += f.blockSize {\n\t\t// Set the address to erase.\n\t\tnrf.NVMC.CONFIG.ADDR.Set(uint32(addr))\n\n\t\t// Trigger the erase operation.\n\t\tnrf.NVMC.ERASEPAGE.Set(1)\n\n\t\t// Wait until the flash is no longer busy.\n\t\tnrf.NVMC.CONFIG.Wait()\n\t}\n\n\t// Set flash to read mode.\n\tnrf.NVMC.CONFIG.MODE = nrf.NVMC_CONFIG_MODE_READ\n\n\treturn nil\n}", "CodeBleu_score": 41.31805135037465}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tstart := uint32(off)\n\tend := start + uint32(len(p))\n\tif end > f.size {\n\t\treturn 0, errFlashOutOfBounds\n\t}\n\n\tblockSize := uint32(f.blockSize)\n\tblocks := (uint32(len(p)) + blockSize - 1) / blockSize\n\n\tbuf := make([]byte, blockSize)\n\tcopy(buf, p)\n\tpadLen := blockSize - uint32(len(p))%blockSize\n\tfor i := uint32(0); i < padLen; i++ {\n\t\tbuf[uint32(len(p))+i] = 0xFF\n\t}\n\n\tnrf.NVMC.Config(nrf.NVMC_CONFIG_WEN_Wen)\n\n\tfor i := uint32(0); i < blocks; i++ {\n\t\tnrf.NVMC.Write(start+i*blockSize, binary.LittleEndian.Uint32(buf[i*blockSize:]))\n\t\tnrf.NVMC.Write(start+i*blockSize+4, binary.LittleEndian.Uint32(buf[i*blockSize+4:]))\n\t\tnrf.NVMC.Write(start+i*blockSize+8, binary.LittleEndian.Uint32(buf[i*blockSize+8:]))\n\t\tnrf.NVMC.Write(start+i*blockSize+12, binary.LittleEndian.Uint32(buf[i*blockSize+12:]))\n\n\t\tnrf.NVMC.Task(nrf.NVMC_TASK_WRITE)\n\n\t\tfor !nrf.NVMC.Ready() {\n\t\t}\n\t}\n\n\tnrf.NVMC.Config(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 30.513548696364758}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// check for out-of-bounds write\n\tlast := int(off) + len(p)\n\tif last > len(f) {\n\t\treturn 0, errFlashOutOfBounds\n\t}\n\n\t// convert address to a uint32\n\taddr := uint32(off)\n\n\t// convert p to []uint32 and pad with zeroes if necessary\n\tdata := f.padBuffer(p)\n\n\t// enable writes\n\tf.WriteEnable()\n\n\t// write data\n\ti := 0\n\tfor i < len(data) {\n\t\tend := i + f.writeSize()\n\t\tif end > len(data) {\n\t\t\tend = len(data)\n\t\t}\n\t\terr := f.writeBlock(addr, data[i:end])\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\ti = end\n\t\taddr += uint32(f.writeSize())\n\t}\n\n\treturn i, err\n}", "CodeBleu_score": 33.287493231733045}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Calculate the start address for writing.\n\tstart := uintptr(unsafe.Pointer(&f.reg)) + uintptr(off)\n\n\t// Check if the write operation exceeds the flash memory bounds.\n\tif uintptr(off)+uintptr(len(p)) > f.size {\n\t\treturn 0, errFlashOutOfBounds\n\t}\n\n\t// Pad the byte slice to fit the write block size.\n\tif len(p)%4 != 0 {\n\t\tpadding := make([]byte, 4-len(p)%4)\n\t\tp = append(p, padding...)\n\t}\n\n\t// Enable write mode on the flash memory controller.\n\tf.reg.CONFIG.WEN.Set(nrf.FlashConfigWenRun)\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(p); i += flashBlockSize {\n\t\tword := binary.LittleEndian.Uint32(p[i : i+4])\n\t\t*(*uint32)(unsafe.Pointer(start + uintptr(i))) = word\n\n\t\t// Wait for the flash memory to be ready after each write operation.\n\t\tfor !f.reg.READY.READY().Get() {\n\t\t}\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 33.06729952673886}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdupfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupfd)\n\t\tif err != nil {\n\t\t\tsyscall.Close(dupfd)\n\t\t\tif err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn 0, \"\", err\n\t\t}\n\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t}\n}", "CodeBleu_score": 58.594999771103076}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tfd2, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tfor {\n\t\tdir, err := syscall.Fdopendir(fd2)\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(fd2)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 63.34070252775602}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tfdDup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err := syscall.Fdopendir(fdDup)\n\t\tif err != nil {\n\t\t\tsyscall.Close(fdDup)\n\t\t\treturn 0, \"\", err\n\t\t}\n\n\t\tif err == nil {\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(fdDup)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 59.397377795655416}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n  const esp_partition_t *partition = esp_ota_get_running_partition();\n\n  if (partition == nullptr) {\n\n    return 0;\n\n  }\n\n  if (response == SKETCH_SIZE_AVAILABLE) {\n\n    return partition->size - partition->ota_size;\n\n  }\n\n  return partition->ota_size;\n\n}", "CodeBleu_score": 34.01354002774967}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n  const esp_partition_t *partition = esp_ota_get_running_partition();\n\n  if (response == FREE_SPACE) {\n\n    return (partition->size - partition->used_app_bytes);\n\n  }\n\n  return partition->used_app_bytes;\n\n}", "CodeBleu_score": 26.114399920594234}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n    const esp_partition_t *partition = esp_ota_get_boot_partition();\n\n    const esp_partition_pos_t partition_position = partition->address;\n\n    uint32_t size = partition_position.offset + partition->size;\n\n    if (response == SKETCH_SIZE) {\n\n        return size;\n\n    }\n\n    uint32_t free_space = (partition_position.offset - 0x1000) & 0xFFFFF000;\n\n    return free_space;\n\n}", "CodeBleu_score": 39.64583765619883}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    // Calculate the required disk sectors\n    const uint32_t disk_sectors = RAM_DISK_SIZE / RAM_DISK_SECTOR_SIZE;\n\n    // Allocate memory for the RAM disk\n    ram_disk = (uint8_t *)malloc(disk_sectors * RAM_DISK_SECTOR_SIZE);\n    if (ram_disk == NULL) {\n        LOG_ERR(\"Failed to allocate memory for RAM disk\");\n        return false;\n    }\n\n    // Set up the boot sector\n    struct boot_sector_t *boot_sector = (struct boot_sector_t *)ram_disk;\n    boot_sector->jump_instruction[0] = 0xEB;\n    boot_sector->jump_instruction[1] = 0x58;\n    boot_sector->jump_instruction[2] = 0x90;\n    strncpy(boot_sector->oem_name, \"Firmware\", sizeof(boot_sector->oem_name));\n    boot_sector->bytes_per_sector = RAM_DISK_SECTOR_SIZE;\n    boot_sector->sectors_per_cluster = 1;\n    boot_sector->reserved_sectors = 1;\n    boot_sector->number_of_fats = 2;\n    boot_sector->root_entries = 0;\n    boot_sector->total_sectors = disk_sectors;\n    boot_sector->media_descriptor_type = 0xF8;\n    boot_sector->sectors_per_fat = disk_sectors / 2;\n    boot_sector->sectors_per_track = 63;\n    boot_sector->number_of_heads = 255;\n    boot_sector->hidden_sectors = disk_sectors - 1;\n    boot_sector->total_sectors_32 = disk_sectors;\n    boot_sector->drive_number = 0x80;\n    boot_sector->extended", "CodeBleu_score": 23.80092783578485}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t disk_sectors = RAM_DISK_SIZE / RAM_DISK_SECTOR_SIZE;\n    uint32_t fat_sectors = (disk_sectors + RAM_DISK_SECTOR_PER_CLUSTER - 1) / RAM_DISK_SECTOR_PER_CLUSTER;\n    uint32_t fat_size = fat_sectors * RAM_DISK_SECTOR_SIZE;\n    uint32_t data_sectors = disk_sectors - fat_sectors - 1;\n    uint32_t data_size = data_sectors * RAM_DISK_SECTOR_SIZE;\n\n    // Allocate memory for the RAM disk\n    ram_disk = (uint8_t *)malloc(RAM_DISK_SIZE);\n    if (ram_disk == NULL) {\n        // Log an error if allocation fails\n        printf(\"Error: Failed to allocate memory for RAM disk.", "CodeBleu_score": 25.144519957904176}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    // Calculate the number of disk sectors needed for the RAM disk\n    uint32_t disk_sectors = MSC_DISK_SECTORS;\n\n    // Allocate memory for the RAM disk\n    uint8_t *disk_mem = (uint8_t *)malloc(disk_sectors * MSC_DISK_SECTOR_SIZE);\n    if (!disk_mem) {\n        LOG_ERR(\"Failed to allocate memory for the RAM disk\");\n        return false;\n    }\n\n    // Set up the boot sector and FAT\n    msc_update_set_boot_sector(disk_mem, disk_sectors, volume_label, serial_number);\n    msc_update_set_fat(disk_mem, disk_sectors);\n\n    // Add a root directory entry for the firmware file if a partition is running\n    if (msc_update_partition_running()) {\n        msc_update_add_file(disk_mem, disk_sectors, MSC_UPDATE_FILENAME, MSC_UPDATE_FILESIZE);\n    }\n\n    return true;\n}", "CodeBleu_score": 28.07957533271882}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n    const uint32_t sector_size = partition->size;\n    if (offset % sector_size == 0) {\n        err = spi_flash_erase_sector(partition->address / sector_size + offset / sector_size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"erase failed (%s)\", esp_err_to_name(err));\n            return err;\n        }\n    }\n    err = spi_flash_write(partition->address + offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"write failed (%s)\", esp_err_to_name(err));\n    }\n    return err;\n}", "CodeBleu_score": 54.545665987932736}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n\n    // Check if the offset is aligned with the flash sector size\n    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        err = ESP_ERR_INVALID_ARG;\n        ESP_LOGE(TAG, \"Offset is not aligned with flash sector size\");\n        return err;\n    }\n\n    // Erase the sector corresponding to the offset\n    err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase flash partition\");\n        return err;\n    }\n\n    // Write the data to the specified offset\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data to flash partition\");\n        return err;\n    }\n\n    return err;\n}", "CodeBleu_score": 61.2056328852335}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n    if (offset % partition->size != 0) {\n        err = ESP_FAIL;\n        ESP_LOGE(TAG, \"Offset must be aligned with flash sector size\");\n        return err;\n    }\n    err = esp_partition_erase_range(partition, offset, partition->size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase partition\");\n        return err;\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write partition\");\n        return err;\n    }\n    return err;\n}", "CodeBleu_score": 57.67790477556309}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i, j;\n  for (i = j = 0; i < maxlen && in[j]; j += 2) {\n    if (in[j] >= '0' && in[j] <= '9')\n      out[i] = (in[j] - '0') << 4;\n    else if (in[j] >= 'A' && in[j] <= 'F')\n      out[i] = (in[j] - 'A' + 10) << 4;\n    else if (in[j] >= 'a' && in[j] <= 'f')\n      out[i] = (in[j] - 'a' + 10) << 4;\n    else\n      continue;\n    if (in[j + 1] >= '0' && in[j + 1] <= '9')\n      out[i] |= in[j + 1] - '0';\n    else if (in[j + 1] >= 'A' && in[j + 1] <= 'F')\n      out[i] |= in[j + 1] - 'A' + 10;\n    else if (in[j + 1] >= 'a' && in[j + 1] <= 'f')\n      out[i] |= in[j + 1] - 'a' + 10;\n    else\n      break;\n    i++;\n  }\n  return i;\n}", "CodeBleu_score": 42.31156192743388}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i = 0, j = 0;\n    while (i < maxlen && in[j]) {\n        if (in[j] == ' ') {\n            j++;\n            continue;\n        }\n        if (in[j] >= '0' && in[j] <= '9') {\n            out[i] = (in[j] - '0') << 4;\n        } else if (in[j] >= 'A' && in[j] <= 'F') {\n            out[i] = (in[j] - 'A' + 10) << 4;\n        } else if (in[j] >= 'a' && in[j] <= 'f') {\n            out[i] = (in[j] - 'a' + 10) << 4;\n        } else {\n            break;\n        }\n        j++;\n        if (in[j] >= '0' && in[j] <= '9') {\n            out[i] |= in[j] - '0';\n        } else if (in[j] >= 'A' && in[j] <= 'F') {\n            out[i] |= in[j] - 'A' + 10;\n        } else if (in[j] >= 'a' && in[j] <= 'f') {\n            out[i] |= in[j] - 'a' + 10;\n        } else {\n            break;\n        }\n        i++;\n        j++;\n    }\n    return i;\n}", "CodeBleu_score": 37.63087026065662}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i = 0;\n    size_t j = 0;\n\n    while ((i < maxlen) && (j < strlen(in))) {\n        if (isxdigit(in[j])) {\n            if (isdigit(in[j])) {\n                out[i] = (in[j] - '0') << 4;\n            } else {\n                out[i] = (toupper(in[j]) - 'A' + 10) << 4;\n            }\n            j++;\n            if (j < strlen(in)) {\n                if (isdigit(in[j])) {\n                    out[i] |= in[j] - '0';\n                } else {\n                    out[i] |= toupper(in[j]) - 'A' + 10;\n                }\n                j++;\n            }\n            i++;\n        } else {\n            j++;\n        }\n    }\n    return i;\n}", "CodeBleu_score": 39.28331665875909}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t  if (tx_buffer == NULL || tx_lock == NULL) {\n    return 0;\n  }\n  if (xSemaphoreTake(tx_lock, 10 / portTICK_PERIOD_MS) == pdTRUE) {\n    int free_size = tx_buffer->free();\n    xSemaphoreGive(tx_lock);\n    return free_size;\n  }\n  return 0;\n}", "CodeBleu_score": 71.74241578768313}, {"code": "int HWCDC::availableForWrite(void){\n\t    if (tx_buffer == NULL || tx_lock == NULL)\n        return 0;\n\n    if (xSemaphoreTake(tx_lock, portMAX_DELAY) == pdTRUE) {\n        int free = tx_buffer->availableForWrite();\n        xSemaphoreGive(tx_lock);\n        return free;\n    }\n    return 0;\n}", "CodeBleu_score": 58.06445664234444}, {"code": "int HWCDC::availableForWrite(void){\n\t\tint ret = 0;\n\tif (tx_ring_buffer && tx_lock) {\n\t\tif (xSemaphoreTake(tx_lock, pdMS_TO_TICKS(1000)) == pdTRUE) {\n\t\t\tret = usb_cdc_acm_get_free_tx_buffer_size();\n\t\t\txSemaphoreGive(tx_lock);\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 38.456551147799715}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n    _onReceiveCB = function;\n\n    _onlyOnTimeout = onlyOnTimeout;\n\n    if (_onReceiveCB) {\n\n        uart_set_rx_full_threshold(UART_NUM_1, 1);\n\n        if (!_onReceiveTask) {\n\n            xTaskCreatePinnedToCore(\n\n                [](void *pvParameters) {\n\n                    HardwareSerial *serial = (HardwareSerial *) pvParameters;\n\n                    while (true) {\n\n                        uint8_t data;\n\n                        if (xQueueReceive(serial->_rxQueue, &data, portMAX_DELAY)) {\n\n                            if (serial->_onReceiveCB) {\n\n                                serial->_onReceiveCB(data);\n\n                            }\n\n                        }\n\n                    }\n\n                },\n\n                \"serial_on_receive_task\",\n\n                2048,\n\n                this,\n\n                1,\n\n                &_onReceiveTask,\n\n                tskNO_AFFINITY\n\n            );\n\n        }\n\n    }\n\n}", "CodeBleu_score": 39.064869554239515}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n  _onReceiveCB = function;\n\n  _onlyOnTimeout = onlyOnTimeout;\n\n  if (_onReceiveCB) {\n\n    uart_set_rx_full_threshold(_uart_num, 1);\n\n    if (!_rxTask) {\n\n      xTaskCreate(\n\n        _onReceiveTask,\n\n        \"HardwareSerialRx\",\n\n        2048,\n\n        this,\n\n        1,\n\n        &_rxTask);\n\n    }\n\n  } else {\n\n    uart_set_rx_full_threshold(_uart_num, 0);\n\n  }\n\n}", "CodeBleu_score": 44.11171987647752}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n    xSemaphoreTake(_serialMutex, portMAX_DELAY);\n\n    _onReceiveCB = function;\n\n    _onlyOnTimeout = onlyOnTimeout;\n\n    if (_onReceiveCB != NULL) {\n\n        uart_set_rx_full_threshold(UART_NUM_0, UART_FIFO_LEN - 1);\n\n        if (!_eventTaskHandle) {\n\n            xTaskCreateUniversal(\n\n                eventTask,\n\n                \"serialEventTask\",\n\n                configMINIMAL_STACK_SIZE * 2,\n\n                this,\n\n                1,\n\n                &_eventTaskHandle,\n\n                CONFIG_ARDUINO_RUNNING_CORE\n\n            );\n\n        }\n\n    }\n\n    xSemaphoreGive(_serialMutex);\n\n}", "CodeBleu_score": 46.671928011096}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if (length < 1) return 0;\n    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) break;\n        *buffer++ = (char) c;\n        index++;\n    }\n    return index; // return number of characters, not including null terminator\n}", "CodeBleu_score": 85.53491273696214}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if (length < 1) return 0;\n    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) break;\n        *buffer++ = (char) c;\n        index++;\n    }\n    return index; // return number of characters, not including null terminator\n}", "CodeBleu_score": 85.53491273696214}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if (length < 1) return 0;\n    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) break;\n        *buffer++ = (char) c;\n        index++;\n    }\n    return index; // return number of characters, not including null terminator\n}", "CodeBleu_score": 85.53491273696214}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  Serial.printf(\"Tone on pin %d at %d Hz for %d ms\n\", pin, frequency, duration);\n  if (ledcRead(pin)) {\n    Serial.printf(\"Tone on pin %d is already in use\n\", pin);\n    Serial.println(\"Stop the current tone first with noTone()\");\n    return;\n  }\n  ledcAttachPin(pin, 0);\n  ledcWriteTone(0, frequency);\n  xQueueSend(ledc_queue, &(struct ledc_cmd_s){\n    .pin = pin,\n    .param1 = frequency,\n    .param2 = duration,\n    .op = LEDC_OP_TONE\n  }, 0);\n}", "CodeBleu_score": 45.56382233209775}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    // Log the pin, frequency, and duration\n    Serial.printf(\"Tone on pin %d with frequency %d and duration %d\n\", pin, frequency, duration);\n\n    // Check if the pin is available or already in use\n    if (ledcRead(pin)) {\n        // If the pin is already in use, log an error message\n        Serial.printf(\"Pin %d is already in use, please stop the current tone on this pin first\n\", pin);\n        return;\n    }\n\n    // Initialize the tone\n    ledcSetup(pin, frequency, 8);\n    ledcAttachPin(pin, pin);\n\n    // Send a start command with the pin, frequency, and duration to a queue\n    xQueueSend(tone_queue, &(tone_t){pin, frequency, duration}, portMAX_DELAY);\n}", "CodeBleu_score": 38.87585538478583}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\n  // Log the pin, frequency, and duration\n  Serial.printf(\"Tone on pin %d with frequency %d and duration %d\n\", pin, frequency, duration);\n\n  // Check if the pin is available or already in use\n  if (ledcRead(pin) == 0) {\n\n    // Initialize the tone\n    ledcSetup(pin, 2000, 8);\n\n    // Send a start command with the pin, frequency, and duration to the queue\n    ledcWriteTone(pin, frequency);\n\n  } else {\n\n    // Log an error message instructing to stop the current tone on the pin first\n    Serial.printf(\"Pin %d is already in use, please stop the current tone first\n\", pin);\n\n  }\n\n}", "CodeBleu_score": 30.6845940138823}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!_usbStarted) {\n\t\t_webUSB = enabled;\n\t\tif (_usbVersion < 0x0210) {\n\t\t\t_usbVersion = 0x0210;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (enabled) {\n\t\tusb_enable_webusb();\n\t} else {\n\t\tusb_disable_webusb();\n\t}\n\treturn true;\n}", "CodeBleu_score": 46.67451614912569}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (!_started) {\n        _webUSB = enabled;\n        _usbVersion = 0x0210;\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 37.13350042617941}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (usb_started) {\n        if (enabled) {\n            if (usb_version < 0x0210) {\n                usb_version = 0x0210;\n            }\n            usb_webUSB_enabled = true;\n        } else {\n            usb_webUSB_enabled = false;\n        }\n        return true;\n    } else {\n        usb_webUSB_enabled = enabled;\n        return false;\n    }\n}", "CodeBleu_score": 55.4363566800094}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t    uint8_t buf[64];\n    int len = _usb->read(buf, sizeof(buf));\n    if (len > 0) {\n        for (int i = 0; i < len; i++) {\n            if (!_rx_queue.put(buf[i])) {\n                _rx_overflow.count++;\n                _rx_overflow.timestamp = millis();\n                _rx_overflow.bytes += len;\n                MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER_USB, MBED_ERROR_CODE_USB_CDC_RX_OVERFLOW), \"USB CDC RX overflow\");\n            }\n        }\n        _rx_event.count = len;\n        _rx_event.timestamp = millis();\n        _rx_event.bytes = len;\n        _rx_event.queue = &_rx_queue;\n        _rx_cb.call(&_rx_event);\n    }\n}", "CodeBleu_score": 34.45121729888944}, {"code": "void USBCDC::_onRX(){\n\t    uint8_t buf[64];\n    int len = _usb.readEP(CDC_EP_IN, buf, sizeof(buf));\n    if (len > 0) {\n        for (int i = 0; i < len; i++) {\n            if (!_rxQueue.put(buf[i])) {\n                _overflowCount++;\n            }\n        }\n        _rxEvent.post(len);\n    }\n}", "CodeBleu_score": 19.285661250825743}, {"code": "void USBCDC::_onRX(){\n\t    uint8_t buf[64];\n    int len = read(buf, sizeof(buf));\n    if (len > 0) {\n        for (int i = 0; i < len; i++) {\n            if (!_rxQueue.put(buf[i])) {\n                overflowCnt++;\n                logError(\"USBCDC receive overflow\");\n            }\n        }\n        event(EVENT_RX, len);\n    }\n}", "CodeBleu_score": 21.755013960615386}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := a.getRobotName(req)\n\trobot := a.findRobot(robotName)\n\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(robeaux.JSON{\n\t\t\t\"error\": fmt.Sprintf(\"No robot with name %s\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tdevices := make(robeaux.JSON)\n\tfor _, device := range *robot.Devices() {\n\t\tdevices[device.Name()] = device\n\t}\n\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 32.344384922904645}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\n\trobot := a.findRobot(robotName)\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{\"no robot with that name\"})\n\t\treturn\n\t}\n\n\tdevices := make(map[string]interface{})\n\tfor _, device := range robot.Devices() {\n\t\tdevices[device.Name()] = device\n\t}\n\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 36.63914561058525}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.findRobot(req.URL.Query().Get(\"name\"))\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(robeaux.JSON{\n\t\t\t\"error\": fmt.Sprintf(\"robot with name %s not found\", req.URL.Query().Get(\"name\")),\n\t\t})\n\t\treturn\n\t}\n\tdevices := make(map[string]interface{})\n\tfor _, device := range *robot.Devices() {\n\t\tdevices[device.Name()] = device\n\t}\n\tjson.NewEncoder(res).Encode(robeaux.JSON{\n\t\t\"devices\": devices,\n\t})\n}", "CodeBleu_score": 39.50767441451045}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.findRobot(req.URL.Query().Get(\"name\"))\n\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(gobot.Connection{Name: \"\", Type: \"\"})\n\t} else {\n\t\tvar connections []gobot.Connection\n\t\tfor _, connection := range robot.Connections() {\n\t\t\tconnections = append(connections, *connection)\n\t\t}\n\t\tjson.NewEncoder(res).Encode(connections)\n\t}\n}", "CodeBleu_score": 44.34599417665583}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\n\trobot := a.findRobot(robotName)\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(robeaux.NotFound(\"robot\"))\n\t\treturn\n\t}\n\n\tconnections := make(map[string][]string)\n\tfor name, adaptor := range robot.connections {\n\t\tconnections[name] = adaptor.Connection().ConnectedDevices()\n\t}\n\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 47.1107485452807}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.findRobot(robotName)\n\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(gobot.Connection{})\n\t} else {\n\t\tvar connections []*jsonConnection\n\t\tfor _, connection := range robot.Connections() {\n\t\t\tconnections = append(connections, &jsonConnection{\n\t\t\t\tName: connection.Name(),\n\t\t\t})\n\t\t}\n\t\tjson.NewEncoder(res).Encode(connections)\n\t}\n}", "CodeBleu_score": 49.95909464586143}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robotname\")\n\tdeviceName := req.URL.Query().Get(\"devicename\")\n\tdevice, err := a.findDeviceByName(robotName, deviceName)\n\tif err != nil {\n\t\tjson.NewEncoder(res).Encode(err)\n\t} else {\n\t\tcommand := req.URL.Query().Get(\"command\")\n\t\targs := strings.Split(req.URL.Query().Get(\"args\"), \",\")\n\t\tresult := device.GetDriver().GetCommand(command)(args...)\n\t\tjson.NewEncoder(res).Encode(result)\n\t}\n}", "CodeBleu_score": 43.227179925073635}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robotname\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\tdevice, err := a.GetRobotDevice(robotName, deviceName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\"command\")\n\targs := req.URL.Query().Get(\"args\")\n\n\tres.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\n\t_, err = device.CallFunction(command, args)\n\tif err != nil {\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tjson.NewEncoder(res).Encode(map[string]string{\"status\": \"ok\"})\n}", "CodeBleu_score": 50.91837733049695}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robotname\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\tdevice := a.findRobotDevice(robotName, deviceName)\n\n\tif device == nil {\n\t\tjson.NewEncoder(res).Encode(robeaux.JSONError{\n\t\t\tMessage: fmt.Sprintf(\"Device %q is not available\", deviceName),\n\t\t})\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\"command\")\n\targs := strings.Split(req.URL.Query().Get(\"args\"), \",\")\n\n\t_, err := device.Call(command, args...)\n\tif err != nil {\n\t\tlog.Println(\"Error executing command:\", err)\n\t\tjson.NewEncoder(res).Encode(robeaux.JSONError{\n\t\t\tMessage: fmt.Sprintf(\"Error executing command: %v\", err),\n\t\t})\n\t\treturn\n\t}\n\n\tjson.NewEncoder(res).Encode(robeaux.JSONMessage{\n\t\tMessage: fmt.Sprintf(\"Executed command %q on device %q\", command, deviceName),\n\t})\n}", "CodeBleu_score": 50.73381902162994}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\texpected := []byte(username + \":\" + password)\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif len(auth) > 6 && auth[:6] == \"Basic \" {\n\t\t\tauth = auth[6:]\n\t\t}\n\t\tb, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare(b, expected) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 55.497177236524195}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\texpected := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\t\tactual := r.Header.Get(\"Authorization\")\n\t\tif subtle.ConstantTimeCompare([]byte(expected), []byte(actual)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t}\n\t}\n}", "CodeBleu_score": 61.941071857294446}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\texpected := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\t\tactual := r.Header.Get(\"Authorization\")\n\t\tif subtle.ConstantTimeCompare([]byte(expected), []byte(actual)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", 401)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 33.156799748836825}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tif !a.Connection().AnalogReadSupported() {\n\t\treturn 0, 0.0, fmt.Errorf(\"AnalogRead not supported by this driver\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tscaled := a.scaleReading(raw)\n\ta.lastValue = scaled\n\ta.lastRaw = raw\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 43.151107436753136}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\traw, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tscaled := float64(raw)\n\tif a.SensorType == \"a\" {\n\t\tscaled = float64(raw) * a.aInVolts\n\t} else if a.SensorType == \"d\" {\n\t\tscaled = float64(raw) * a.dInVolts\n\t}\n\n\ta.lastValue = raw\n\ta.lastScaledValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 48.981739587537554}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tval, err := a.Connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\traw := int(val)\n\tscaled := float64(raw)\n\n\ta.lastValue = raw\n\ta.lastScaledValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 35.66908445655329}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, \"GroveSoundSensor\"),\n\t}\n}", "CodeBleu_score": 28.01759788170014}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := &GroveSoundSensorDriver{\n\t\tAnalogSensor: NewAnalogSensorDriver(a, pin, \"500\", opts...),\n\t}\n\ts.AddEvent(SoundDetected)\n\ts.AddEvent(SoundAbsent)\n\ts.SetName(DefaultName(\"GroveSoundSensor\"))\n\treturn s\n}", "CodeBleu_score": 33.792464955564164}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, \"GroveSoundSensor\"),\n\t}\n}", "CodeBleu_score": 28.01759788170014}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(CommandReg, SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tif value, _ := d.readRegister(CommandReg); value != 0x00 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 33.324671997027046}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(CommandReg, SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tval, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&(1<<4) != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.60531432981148}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(CommandReg, SoftReset)\n\ttime.Sleep(50 * time.Millisecond)\n\tval, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&(1<<4) != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.58953099869943}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn := d.readFIFO()\n\tif n != len(backData) {\n\t\treturn 0, fmt.Errorf(\"bad length in readFifo()\")\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i] = d.readFIFO()\n\t}\n\n\treturn d.readFIFO(), nil\n}", "CodeBleu_score": 20.752899060780308}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn := uint8(len(backData))\n\tlastBits, err := d.readReg(FIFO_LEVEL_REG)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tlastBits &= 0x78\n\tif lastBits == 0 {\n\t\tlastBits = 1\n\t}\n\tif n > uint8(64) {\n\t\tn = 64\n\t}\n\ti := uint8(0)\n\tfor ; i < n; i++ {\n\t\tnt, err := d.readReg(FIFO_DATA_REG)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = nt\n\t}\n\treturn lastBits, nil\n}", "CodeBleu_score": 43.31504036142929}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn := d.readFIFO()\n\tif n != len(backData) {\n\t\treturn 0, fmt.Errorf(\"error: received %d bytes instead of %d\", n, len(backData))\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i] = d.readFIFO()\n\t}\n\n\treturn d.readFIFO(), nil\n}", "CodeBleu_score": 27.576439634999073}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"Halting PICC...\")\n\t}\n\tbuff := []byte{mfrc522.PiccHalt, 0}\n\tcrc := d.calculateCRC(buff, 1)\n\tbuff = append(buff, crc[0], crc[1])\n\t_, err := d.PCDRequest(mfrc522.PcdTransceive, buff)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 34.38127453303219}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debugging {\n\t\tfmt.Println(\"Halting PICC...\")\n\t}\n\tbuff := []byte{mfrc522.PiccHalt, 0}\n\tcrcResult := d.calculateCRC(buff)\n\tresult := append(buff, crcResult...)\n\n\t_, err := d.ToCard(mfrc522.PcdTransceive, result)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 29.774746753920223}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debugging {\n\t\tfmt.Println(\"Halting PICC...\")\n\t}\n\tbuff := []byte{mfrc522.PiccHalt}\n\tcrcResult := d.calculateCRC(buff)\n\tresult := append(buff, crcResult...)\n\n\t_, err := d.dev.Write(result)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 27.94465351008965}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tbuffer := []byte{\n\t\tuint8(piccRead),\n\t\tblock,\n\t}\n\tbuffer = append(buffer, d.crc(buffer)...)\n\t_, err := d.dev.Write(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuffer = make([]byte, 18)\n\t_, err = d.dev.Read(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(buffer) != 18 {\n\t\treturn nil, fmt.Errorf(\"read %d bytes, expected 18\", len(buffer))\n\t}\n\tif buffer[0] != 0 || buffer[1] != 0 {\n\t\treturn nil, fmt.Errorf(\"expected 0,0, got %d,%d\", buffer[0], buffer[1])\n\t}\n\tif buffer[2] != 0xAF {\n\t\treturn nil, fmt.Errorf(\"expected 0xAF, got 0x%02x\", buffer[2])\n\t}\n\treturn buffer[0:16], nil\n}", "CodeBleu_score": 41.71017203537165}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := []byte{\n\t\tpiccReadCmd,\n\t\tblock,\n\t}\n\n\td.calculateCRC(cmd)\n\n\t_, err := d.device.Write(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf := make([]byte, 18)\n\t_, err = d.device.Read(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := make([]byte, 16)\n\tcopy(data, buf[0:16])\n\n\treturn data, nil\n}", "CodeBleu_score": 42.83758442634817}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tbuffer := []byte{mfrc522_CmdPcdRead, block}\n\tcrc := d.calculateCrc(buffer)\n\tbuffer = append(buffer, crc[0], crc[1])\n\n\t_, err := d.piccComms(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuffer = []byte{mfrc522_CmdPcdRead}\n\tbuffer = append(buffer, d.lastReceive...)\n\n\treturn buffer, nil\n}", "CodeBleu_score": 36.65191395989618}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer must be at least 2 bytes\")\n\t}\n\n\tswitch reqMode {\n\tcase PiccRequestIdle:\n\t\tbreak\n\tcase PiccRequestAll:\n\t\td.writeRegister(BitFramingReg, 0x07)\n\t\tbreak\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown request mode\")\n\t}\n\n\t_, err := d.transceiveData(reqMode, nil, 0, answer, 0)\n\treturn err\n}", "CodeBleu_score": 45.02742107492441}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"invalid answer buffer size\")\n\t}\n\n\td.clearBitsInRegister(CollReg, 0x80) //ValuesAfterColl=1 => Bits received after collision are cleared.\n\n\tvalidBits := 0\n\tswitch reqMode {\n\tcase PiccRequestAll:\n\t\tvalidBits = 7 // The entire UID has to be read.\n\t\tbreak\n\tcase PiccRequestUid:\n\t\tvalidBits = 4 // Only the UID has to be read.\n\t\tbreak\n\t}\n\n\tif validBits <= 4 {\n\t\td.setRegisterBitMask(CollReg, 0x01) //ValuesBeforeColl=1 => Transmission of bits starts with bit 7.\n\t} else {\n\t\td.clearBitsInRegister(CollReg, 0x01) //ValuesBeforeColl=0 => Transmission of bits starts with bit 0.\n\t}\n\n\tresult, err := d.transceiveData(reqMode, nil, validBits, answer, 0, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif result != StatusOk {\n\t\treturn fmt.Errorf(\"piccRequest failed: %v\", result.String())\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.8657091757962}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\td.clearBitsInRegister(CollReg, 0x80)\n\n\tswitch reqMode {\n\tcase PICC_REQIDL:\n\tcase PICC_REQALL:\n\t\td.setRegisterBit(CollReg, 0x20)\n\t\tbreak\n\tcase PICC_ANTICOLL:\n\t\td.setRegisterBit(CollReg, 0x20)\n\t\td.setRegisterBit(CollReg, 0x80)\n\t\tbreak\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown request mode\")\n\t}\n\n\t_, err := d.transceiveData(reqMode, 0, answer, 1, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 55.101360011213195}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.StepPin.DigitalWrite(0); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.StepDelay)\n\n\tif err := d.StepPin.DigitalWrite(1); err != nil {\n\t\treturn err\n\t}\n\n\tif d.Direction == \"cw\" {\n\t\td.StepNumber++\n\t} else {\n\t\td.StepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 62.781870815880126}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.DigitalWrite(0)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(1000 * time.Microsecond)\n\terr = d.stepPin.DigitalWrite(1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 62.334220764254425}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.stepPin.DigitalWrite(0)\n\ttime.Sleep(d.stepDelay)\n\td.stepPin.DigitalWrite(1)\n\n\tif d.direction == 0 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 34.928135029797545}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"Distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitorRunning = true\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopDistanceMonitor:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tsystem.Errorf(\"Error measuring distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.distance = distance\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttime.Sleep(d.interval)\n\t\t}\n\t}()\n\n\twg.Wait()\n\treturn nil\n}", "CodeBleu_score": 42.847367553581186}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\tstop := make(chan struct{})\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-stop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.GetDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"Error measuring distance: %v\n\", err)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"Distance: %.2f cm\n\", distance)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\td.distanceMonitorStop = stop\n\td.distanceMonitorWaitGroup = &wg\n\n\treturn nil\n}", "CodeBleu_score": 43.35317741485709}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.distanceMutex.Lock()\n\tdefer d.distanceMutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\tstop := make(chan struct{})\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-stop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"Error measuring distance: %v\n\", err)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"Distance: %v cm\n\", distance)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\td.distanceMonitorStop = stop\n\td.distanceMonitorWaitGroup = &wg\n\n\treturn nil\n}", "CodeBleu_score": 42.50763863235796}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTime time.Time\n\n\treturn func(pin int, duration time.Duration, event string, timestamp uint32, seqno uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\td.distanceChannel <- time.Since(startTime)\n\t\t\tstartTime = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.95762698089149}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\n\treturn func(edge int, timestamp time.Duration, pin string, seqno uint32, cfgid uint32) {\n\t\tif edge == system.GPIO_INT_EDGE_RISING {\n\t\t\tstart = time.Now()\n\t\t} else if edge == system.GPIO_INT_EDGE_FALLING {\n\t\t\td.duration <- time.Since(start)\n\t\t\tstart = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.84430972094815}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, event string, timeStamp uint32, seqno uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t}\n\t\tif event == \"falling\" {\n\t\t\tduration := time.Since(start)\n\t\t\td.durationChan <- duration\n\t\t\tstart = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.610351117337785}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.trigger.On()\n\ttime.Sleep(10 * time.Microsecond)\n\td.trigger.Off()\n\n\tselect {\n\tcase <-d.echo.On():\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"HCSR04 timeout\")\n\t}\n\n\tstart := time.Now()\n\n\tselect {\n\tcase <-d.echo.Off():\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"HCSR04 timeout\")\n\t}\n\n\td.measurement = time.Since(start)\n\n\treturn nil\n}", "CodeBleu_score": 51.027516849227595}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.triggerPin.On()\n\td.triggerPin.Off()\n\n\tselect {\n\tcase <-d.echoPin.WaitForEdge(1):\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n\n\tstart := time.Now()\n\tselect {\n\tcase <-d.echoPin.WaitForEdge(0):\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n\n\td.measuredTime = time.Since(start)\n\n\treturn nil\n}", "CodeBleu_score": 51.12225862502127}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\tif err := d.trigger.On(); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(10 * time.Microsecond)\n\tif err := d.trigger.Off(); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the echo to be turned on\n\tstart := time.Now()\n\tfor d.echo.DigitalRead() == 0 {\n\t\ttime.Sleep(time.Microsecond)\n\t\tif time.Since(start) > time.Second {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\t}\n\t}\n\n\t// Wait for the echo to be turned off and measure the time\n\tstart = time.Now()\n\tfor d.echo.DigitalRead() == 1 {\n\t\ttime.Sleep(time.Microsecond)\n\t\tif time.Since(start) > time.Second {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\t}\n\t}\n\td.duration = time.Since(start)\n\n\treturn nil\n}", "CodeBleu_score": 55.60741834997922}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    access_token = os.getenv(\"PLATFORMIO_AUTH_TOKEN\")\n    if access_token:\n        return access_token\n\n    state = self.get_state()\n    access_token = state.get(\"access_token\")\n    if access_token and time.time() < state.get(\"expires_at\", 0):\n        return access_token\n\n    refresh_token = state.get(\"refresh_token\")\n    if refresh_token:\n        try:\n            data = self.refresh_authentication_token(refresh_token)\n            self.set_state(data)\n            return data[\"access_token\"]\n        except HTTPClientError as e:\n            if e.response.status_code == 401:\n                raise PlatformioException(\n                    \"Please log in using `platformio account login` command\"\n                )\n            raise e\n\n    raise UserSideException(\n        \"Please log in using `platformio account login` command\"\n    )\n\n", "CodeBleu_score": 40.0051902867635}, {"code": "def fetch_authentication_token(self)\n\t\n    if os.environ.get(\"PLATFORMIO_AUTH_TOKEN\"):\n        return os.environ[\"PLATFORMIO_AUTH_TOKEN\"]\n    if not self.state:\n        raise AccountNotAuthorized()\n    access_token = self.state.get(\"access_token\")\n    expires_at = self.state.get(\"expires_at\")\n    if access_token and expires_at > time.time():\n        return access_token\n    refresh_token = self.state.get(\"refresh_token\")\n    if not refresh_token:\n        raise AccountNotAuthorized()\n    try:\n        response = HTTPClient(__accounts_api__).post(\n            \"/api/auth/refresh\",\n            data=dict(refresh_token=refresh_token),\n            with_auth_header=False,\n        )\n    except HTTPClientError as e:\n        if e.response.status_code == 401:\n            raise AccountNotAuthorized()\n        raise PlatformioException(e)\n    self.state[\"access_token\"] = response.json()[\"access_token\"]\n    self.state[\"expires_at\"] = response.json()[\"expires_at\"]\n    self.state[\"refresh_token\"] = response.json()[\"refresh_token\"]\n    self.save_state()\n    return self.state[\"access_token\"]\n\n", "CodeBleu_score": 43.33187554257057}, {"code": "def fetch_authentication_token(self)\n\t\n    access_token = os.getenv(\"PLATFORMIO_AUTH_TOKEN\")\n    if access_token:\n        return access_token\n\n    state = self.get_state()\n    access_token = state.get(\"access_token\")\n    if access_token:\n        expires_at = state.get(\"access_token_expires_at\")\n        if expires_at and time.time() < expires_at:\n            return access_token\n\n    refresh_token = state.get(\"refresh_token\")\n    if refresh_token:\n        data = dict(refresh_token=refresh_token)\n        try:\n            response = self.do_request(\"post\", \"/api/v1/auth/token\", data=data)\n        except HTTPClientError as e:\n            raise PlatformioException(e)\n        self.call_api(\n            \"update_state\",\n            access_token=response[\"access_token\"],\n            access_token_expires_at=time.time() + response[\"expires_in\"],\n            refresh_token=response[\"refresh_token\"],\n        )\n        return response[\"access_token\"]\n\n    raise UserSideException(\n        \"Please use `platformio account login` command to authorize \"\n        \"access to the PlatformIO API\"\n    )\n\n", "CodeBleu_score": 41.13257325988357}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_session()\n    try:\n        return (\n            HTTPClient(self.api_endpoint)\n            .post(\n                \"/v1/logout\",\n                dict(refresh_token=refresh_token),\n                headers=dict(Authorization=\"Bearer %s\" % refresh_token),\n            )\n            .json()\n            .get(\"success\", False)\n        )\n    except HTTPClientError as e:\n        if e.response.status_code == 401:\n            return True\n        raise\n\n", "CodeBleu_score": 32.492327724187945}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    if not refresh_token:\n        return True\n    self.delete_session()\n    try:\n        with HTTPClient(__accounts_api__, headers={\"Authorization\": \"Bearer %s\" % refresh_token}) as client:\n            client.fetch_json(\n                method=\"POST\",\n                path=\"/v1/logout\",\n                data={\"refresh_token\": refresh_token},\n            )\n    except HTTPClientError:\n        pass\n    return True\n\n", "CodeBleu_score": 45.48212947295305}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    if not refresh_token:\n        return True\n    self.delete_local_session()\n    try:\n        return (\n            HTTPClient(__accounts_api__, self.verify_ssl)\n            .post(\n                \"/v1/logout\",\n                dict(refresh_token=refresh_token),\n                headers={\"User-Agent\": app.get_user_agent()},\n            )\n            .json()\n        is True\n    except HTTPClientError:\n        pass\n    return True\n\n", "CodeBleu_score": 41.53754643897886}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, pkg in self.packages.items():\n        if pkg.optional:\n            continue\n        metadata = pkg.metadata\n        result.append(\n            {\n                \"name\": name,\n                \"version\": str(pkg.metadata.version),\n                \"path\": pkg.path,\n                \"spec\": PackageSpec.from_package(pkg),\n            }\n        )\n        if metadata.external:\n            result[-1][\"url\"] = metadata.url\n    return result\n\n", "CodeBleu_score": 40.747305479773225}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, pkg in self.packages.items():\n        if pkg.optional:\n            continue\n        data = {\n            \"name\": name,\n            \"version\": str(pkg.metadata.version),\n        }\n        if pkg.metadata.spec.external:\n            data[\"src_url\"] = pkg.metadata.spec.url\n        result.append(data)\n    return result\n\n", "CodeBleu_score": 45.31254794215083}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, pkg in self.packages.items():\n        if pkg.optional:\n            continue\n        data = {\"name\": name, \"version\": pkg.metadata.version}\n        if pkg.metadata.external:\n            data[\"src_url\"] = pkg.metadata.url\n        result.append(data)\n    return result\n\n", "CodeBleu_score": 38.26610095779213}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not isinstance(env, str):\n        raise TypeError(\"Invalid type for 'env'. Expected 'str'\")\n    config = ProjectConfig()\n    if env not in config.envs():\n        raise UndefinedEnvPlatformError(env)\n    spec = config.get(\"env:\" + env, {})\n    if not spec:\n        raise UndefinedEnvPlatformError(env)\n    if not isinstance(spec, dict):\n        raise UndefinedEnvPlatformError(env)\n    if not spec.get(\"platform\"):\n        raise UndefinedEnvPlatformError(env)\n    platform_name = spec.get(\"platform\")\n    platform_cls = None\n    try:\n        platform_cls = base.PlatformFactory.newPlatform(platform_name)\n    except UnknownPlatform:\n        if not autoinstall:\n            raise\n        if not os.path.isdir(config.get(\"platformio\", \"core_dir\")):\n            raise\n        pkg = PackageItem(\n            {\n                \"name\": platform_name,\n                \"version\": \">=0.0.0\",\n                \"optional\": False,\n                \"owner\": \"platformio\",\n                \"sys_platform\": sys.platform,\n            }\n        )\n        if not pkg.check_compatibility():\n            raise\n        pkg.install(\n            dest=os.path.join(\n                config.get(\"platformio\", \"core_dir\"), \"packages\", platform_name\n            )\n        )\n        platform_cls = base.PlatformFactory.newPlatform(platform_name)\n    platform = platform_cls(spec)\n    platform.configure_project_env(env, targets)\n    platform.configure_project_packages(env, targets)\n    return platform\n\n", "CodeBleu_score": 40.63745157210541}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    project_config = ProjectConfig()\n    spec = project_config.get(\"env:\" + env, {})\n    if not spec:\n        raise UndefinedEnvPlatformError(env)\n    platform_name = spec.get(\"platform\")\n    if not platform_name:\n        raise UnknownPlatform(spec.get(\"platform\"))\n    platform_cls = None\n    for name in project_config.get(\"platforms\"):\n        if name == platform_name:\n            platform_cls = load_python_module(\"platformio.platform.%s\" % name)\n            break\n    if not platform_cls:\n        raise UnknownPlatform(platform_name)\n    platform = platform_cls(project_config.get(\"platforms\", {}).get(platform_name))\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.configure_project(project_config, env, targets)\n    return instance\n\n", "CodeBleu_score": 39.924088641759376}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not isinstance(env, str):\n        raise TypeError(\"Invalid type for 'env'\")\n\n    config = ProjectConfig()\n    if not config.has_section(\"env:\" + env):\n        raise UndefinedEnvPlatformError(env)\n\n    config.validate([\"env:\" + env])\n    platform_name = config.get(\"env:\" + env, \"platform\")\n\n    if not platform_name:\n        raise UndefinedEnvPlatformError(env)\n\n    platform_cls = None\n    for name in config.get(\"env:\" + env, \"platform\").split(\",\"):\n        name = name.strip()\n        if not name:\n            continue\n        try:\n            platform_cls = load_python_module(\"platformio.platform.%s\" % name)\n            break\n        except ImportError:\n            pass\n\n    if not platform_cls:\n        raise UnknownPlatform(platform_name)\n\n    platform = platform_cls(config.items(\"env:\" + env, as_dict=True))\n    if not issubclass(platform.__class__, base.BasePlatform):\n        raise TypeError(\"Invalid type for 'platform'\")\n\n    project_env = platform.configure_default_packages(\n        env, targets or []\n    )\n    project_env.platform = platform\n\n    if autoinstall:\n        platform.install_missing_packages()\n\n    return project_env\n\n", "CodeBleu_score": 35.18738721960308}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n\n  Wire.requestFrom(0x34, (int)Size);\n\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire.read();\n  }\n}", "CodeBleu_score": 87.87942830325366}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire.beginTransmission(0x34);\n    Wire.write(Addr);\n    Wire.endTransmission();\n\n    Wire.requestFrom(0x34, (int16_t)Size);\n    for (int i = 0; i < Size; i++) {\n        *(Buff + i) = Wire.read();\n    }\n}", "CodeBleu_score": 88.84976189355156}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 71.81170998094548}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us != 0) {\n        SetTimerWakeup(time_in_us);\n    } else {\n        DisableTimerWakeup();\n    }\n    EnableDCDC3();\n    EnableLDO3();\n    EnableDCDC2();\n    EnableLDO2();\n    EnableBatteryADC();\n    EnableVBUSVoltageADC();\n    Write1Byte(0x31, Read8bit(0x31) | 0b11100000);\n    Write1Byte(0x30, Read8bit(0x30) & 0b11000000);\n    delay(100);\n    LowPowerHandler();\n}", "CodeBleu_score": 46.82228131594838}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep(SLEEP_MODE);\n  if (time_in_us != 0) {\n    SetTimerWakeup(time_in_us);\n  } else {\n    DisableTimerWakeup();\n  }\n  EnableDCDC2();\n  EnableLDO3();\n  EnableLDO4();\n  EnableLDO2();\n  EnableADCs();\n  SetLDO2Voltage(3300);\n  SetLDO3Voltage(3300);\n  SetLDO4Voltage(3300);\n  SetBusPowerMode(0);\n  SetChargeCurrent(0);\n  SetGPIO0Mode(GPIO0_OUTPUT_LOW);\n  SetGPIO1Mode(GPIO1_OUTPUT_LOW);\n  SetGPIO2Mode(GPIO2_OUTPUT_LOW);\n  SetGPIO3Mode(GPIO3_OUTPUT_LOW);\n  SetGPIO4Mode(GPIO4_OUTPUT_LOW);\n  SetESPVoltage(3300);\n  SetLDOVoltage(2, 3300);\n  SetLDOVoltage(3, 3300);\n  SetLDOVoltage(4, 3300);\n  SetESCHostVoltage(3300);\n  SetGeneralPowerMode(0);\n  SetDCDC3(false);\n  SetLDO2(false);\n  SetLDO3(false);\n  SetLDO4(false);\n  SetLDO2Voltage(1200);\n  SetLDO3Voltage(1200);\n  SetLDO4Voltage(1200);\n  SetBusPowerMode(0);\n  SetChargeCurrent(0);\n  SetGPIO0Mode(GPIO0_OUTPUT_LOW);\n  SetGPIO1Mode(GPIO1_OUTPUT_LOW);\n  SetGPIO2Mode(GPIO2_OUTPUT_LOW);\n  SetGPIO3Mode(GPIO3_OUTPUT_LOW);\n  SetGPIO4Mode(GPIO4_OUTPUT_LOW);\n  SetESPVoltage(3", "CodeBleu_score": 38.37783449068324}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep(SLEEP_MODE);\n    if (time_in_us > 0) {\n        SetTimerWakeup(time_in_us);\n    } else {\n        SetDSleepTimer(0);\n    }\n    PowerOff();\n}", "CodeBleu_score": 49.42148285307054}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t    int y = scroll_y;\n    if (tteBar) {\n        tte_set_color(color);\n        tte_fill_rect(0, 0, 320, 240);\n    } else {\n        tte_set_color(color);\n        tte_fill_rect(0, 240, 320, 240);\n    }\n    scroll_y = (scroll_y + line_height) % (240 - 240 + line_height);\n    tte_set_scroll(scroll_x, scroll_y);\n    return y;\n}", "CodeBleu_score": 22.27173479121708}, {"code": "int Display::scroll_line(uint32_t color){\n\t    int y = this->scroll_y;\n    if (this->tteBar) {\n        this->fillRect(0, 0, this->width, this->height - this->bottom_fixed_area, color);\n    } else {\n        this->fillRect(0, 0, this->width, this->height - this->top_fixed_area, color);\n    }\n    this->scroll_y += this->text_height;\n    if (this->scroll_y >= this->height - this->bottom_fixed_area) {\n        this->scroll_y = this->top_fixed_area;\n    }\n    this->scroll_addr = this->scroll_y / this->text_height;\n    return y;\n}", "CodeBleu_score": 12.947812368151979}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = scroll_address;\n  if (tteBar) {\n    if (scroll_address < 12) {\n      scroll_address = display_height - 12;\n    } else {\n      scroll_address -= 12;\n    }\n  } else {\n    if (scroll_address < 16) {\n      scroll_address = display_height - 16;\n    } else {\n      scroll_address -= 16;\n    }\n  }\n  fillRect(0, y, display_width, 12, color);\n  return y;\n}", "CodeBleu_score": 17.057727718922873}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  // Set up access points\n  if (!set_access_points(ssids, access_points)) {\n    return false;\n  }\n\n  // Set up HTML content\n  if (!set_html_content()) {\n    return false;\n  }\n\n  // Start the portal\n  start();\n\n  return true;\n}", "CodeBleu_score": 61.21661775266766}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t    if (!set_ap_ssids(ssids))\n        return false;\n    if (!set_html_content())\n        return false;\n    start_portal();\n    return true;\n}", "CodeBleu_score": 49.2798897505344}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\n    // Set the access points\n    if (!set_access_points(ssids, access_points)) {\n        return false;\n    }\n\n    // Set the HTML content\n    if (!set_html_content()) {\n        return false;\n    }\n\n    // Start the portal\n    start_portal();\n\n    return true;\n}", "CodeBleu_score": 59.80140643544674}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t    if (queue_enabled_flag) {\n        // Queue is already enabled, ensure that queue, text, and text_in are initialized\n        queue.flush();\n        text = \"\";\n        text_in = \"\";\n    } else {\n        // Queue is not enabled, flush the existing queue and set the queue_enabled_flag to true\n        queue.flush();\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 13.470674532118625}, {"code": "void GpsInterface::enable_queue(){\n\t  if (!queue_enabled_flag) {\n    queue_enabled_flag = true;\n    queue.flush();\n    text.flush();\n    text_in.flush();\n  }\n}", "CodeBleu_score": 8.205319371163986}, {"code": "void GpsInterface::enable_queue(){\n\t    if (!queue_enabled_flag) {\n        flush_queue();\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 6.441639193476487}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\n    // Check if the queue exists\n    if (queue_nmea != NULL) {\n\n        // If the queue contains elements, delete it and create a new one\n        if (queue_nmea->size() > 0) {\n            delete queue_nmea;\n            queue_nmea = new std::queue<std::string>;\n        }\n    }\n    // If the queue does not exist, create a new one\n    else {\n        queue_nmea = new std::queue<std::string>;\n    }\n}", "CodeBleu_score": 43.07712931707698}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\n  if (queue_nmea) {\n    while (!queue_nmea->empty()) {\n      delete queue_nmea->front();\n      queue_nmea->pop();\n    }\n    delete queue_nmea;\n  }\n  queue_nmea = new std::queue<std::string*>;\n}", "CodeBleu_score": 42.40819985907488}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->nmea_queue != NULL) {\n        delete this->nmea_queue;\n    }\n    this->nmea_queue = new Queue<char*>();\n}", "CodeBleu_score": 17.71661621178971}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    /*The first parameter \"disp\" is a pointer to the display driver structure. It is used to access the display-specific functions and data structures.*/\n    /*The second parameter \"area\" is a pointer to an area structure that specifies the area of the display to be updated.*/\n    /*The third parameter \"color_p\" is a pointer to the color buffer that contains the new color data for the specified area.*/\n\n    /*Start a write transaction on the display.*/\n    disp_spi_start_write();\n\n    /*Set the address window to the specified area.*/\n    disp_spi_set_addr_window(area->x1, area->y1, area->x2, area->y2);\n\n    /*Iterate through each pixel in the area.*/\n    for (int y = area->y1; y <= area->y2; y++) {\n        for (int x = area->x1; x <= area->x2; x++) {\n            /*Write the corresponding color from the color buffer to the display.*/\n            disp_spi_write_color(*color_p++, 1);\n        }\n    }\n\n    /*End the write transaction on the display.*/\n    disp_spi_end_write();\n\n    /*Notify that the display flush is complete.*/\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 54.49724971947625}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t size = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1);\n    disp_spi_send_colors(color_p, size);\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 26.52885548752578}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    /*The first line of the function sets the address window of the display driver to the specified area.*/\n    disp_set_addr_window(area->x1, area->y1, area->x2, area->y2);\n\n    /*The next lines iterate through each pixel in the area and write the corresponding color from the color buffer to the display.*/\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        disp_write_color(*color_p, 1);\n        color_p++;\n      }\n    }\n\n    /*The last two lines end the write transaction and notify that the display flush is complete.*/\n    disp_write_end();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 55.459345654221956}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    for (int i = 0; i < menu->getMenuNodes().size(); i++) {\n        for (int j = 0; j < layer; j++) {\n            Serial.print(\" \");\n        }\n        Serial.println(menu->getMenuNodes()[i]->getName());\n    }\n    Serial.println();\n}", "CodeBleu_score": 61.38439493844794}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    int i;\n    for (i = 0; i < menu->getMenuNodesCount(); i++) {\n        for (int j = 0; j < layer; j++) {\n            printf(\"    \");\n        }\n        printf(\"%s\n\", menu->getMenuNode(i)->getName().c_str());\n    }\n    printf(\"\n\");\n}", "CodeBleu_score": 53.02298217696409}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  for (int i = 0; i < menu->getMenuNodesCount(); i++) {\n    MenuNode * node = menu->getMenuNode(i);\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\"    \");\n    }\n    Serial.println(node->getName());\n  }\n  Serial.println();\n}", "CodeBleu_score": 59.64892007615563}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\n    int generated = 0;\n\n    for (int i = 0; i < count; i++) {\n        String ssid = \"Test\";\n        for (int j = 0; j < 6; j++) {\n            ssid += (char)random(33, 127);\n        }\n        int channel = random(1, 12);\n        String mac = \"00:11:22:33:44:55\";\n        ssidList.push_back(ssid);\n        channelList.push_back(channel);\n        macList.push_back(mac);\n        generated++;\n    }\n\n    return generated;\n}", "CodeBleu_score": 40.30707755872569}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    int ssidCount = 0;\n    for (int i = 0; i < count; i++) {\n        String ssid = \"\";\n        for (int j = 0; j < 6; j++) {\n            ssid += (char)random(32, 127);\n        }\n        int channel = random(1, 12);\n        String mac = \"\";\n        for (int j = 0; j < 12; j++) {\n            mac += String(random(0, 16), HEX);\n            if (j % 2 == 1 && j < 11) {\n                mac += \":\";\n            }\n        }\n        ssidList[ssidCount] = ssid;\n        channelList[ssidCount] = channel;\n        macList[ssidCount] = mac;\n        ssidCount++;\n        Serial.println(String(ssid) + \",\" + String(channel) + \",\" + String(mac));\n    }\n    return ssidCount;\n}", "CodeBleu_score": 41.05792809080234}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    int numSSIDs = 0;\n    for (int i = 0; i < count; i++) {\n        String ssid = generateRandomSSID();\n        int channel = random(1, 12);\n        String mac = generateRandomMAC();\n        ssidList.push_back(ssid);\n        channelList.push_back(channel);\n        macList.push_back(mac);\n        numSSIDs++;\n        Serial.println(ssid + \" \" + String(channel) + \" \" + mac);\n    }\n    return numSSIDs;\n}", "CodeBleu_score": 38.141624679294885}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n\n    # Initialize a PublisherClient.\n    publisher = pubsub_v1.PublisherClient()\n    # Create a fully qualified identifier in the form of\n    # `projects/{project_id}/topics/{topic_name}`\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic.\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Topic created: {topic.name}\")\n\n", "CodeBleu_score": 69.7121745172126}, {"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 70.0780759150971}, {"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n\n    # Initialize a PublisherClient.\n    client = pubsub_v1.PublisherClient()\n\n    # Construct the fully qualified topic name.\n    topic_path = client.topic_path(project_id, topic_name)\n\n    # Create the topic.\n    topic = client.create_topic(request={\"name\": topic_path})\n\n    # Print the topic details.\n    print(f\"Topic created: {topic.name}\")\n\n", "CodeBleu_score": 59.151966250945556}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        \"iat\": datetime.datetime.utcnow(),\n        # The time the token expires.\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        \"aud\": project_id,\n    }\n\n    # Read the private key file.\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    print(\n        \"Creating JWT using {} from private key file {}\".format(\n            algorithm, private_key_file\n        )\n    )\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 64.96658174821921}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        \"iat\": datetime.datetime.utcnow(),\n        # The time the token expires.\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        \"aud\": project_id,\n    }\n\n    # Read the private key file.\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    print(\n        \"Creating JWT using {} from private key file {}\".format(\n            algorithm, private_key_file\n        )\n    )\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 64.96658174821921}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        'iat': datetime.datetime.utcnow(),\n        # The time the token expires.\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message '{}' on topic '{}' with Qos {}\".format(message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print(\"Taking picture\")\n        capture_and_upload()\n        print(\"Publishing event\")\n        client.publish(_MQTT_EVENT_TOPIC, \"{}/{}\".format(_MQTT_EVENT_BASE_URL, _IMAGE_FILENAME), qos=1)\n    elif message.payload == b'off':\n        print(\"off\")\n\n", "CodeBleu_score": 26.141881562768464}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message '{}' on topic '{}' with Qos {}\".format(message.payload, message.topic, str(message.qos)))\n    if message.payload == b\"on\":\n        print(\"Capturing preview image\")\n        # Capture a preview image\n        os.system(\"fswebcam -r 640x480 --no-banner /tmp/image.jpg\")\n        # Upload the file to a bucket\n        bucket_name = \"my-bucket\"\n        bucket_folder = \"images\"\n        file_name = \"image.jpg\"\n        upload_file(bucket_name, bucket_folder, file_name)\n        # Publish the file's URL to an MQTT event topic\n        file_url = \"https://storage.googleapis.com/{}/{}/{}\".format(bucket_name, bucket_folder, file_name)\n        publish_message(file_url)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 33.404186675939776}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message '{}' on topic '{}' with Qos {}\".format(\n        message.payload, message.topic, str(message.qos)))\n    if message.payload == b\"on\":\n        print(\"Capturing preview image...\")\n        os.system(\"./capture.sh\")\n        print(\"Uploading image to bucket...\")\n        upload_blob(\"preview.jpg\", \"preview.jpg\", \"preview-images-for-demo\")\n        print(\"Publishing to MQTT event topic...\")\n        publish_message(\"preview-image-uploaded\", \"https://storage.googleapis.com/preview-images-for-demo/preview.jpg\", 1)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 26.300751435444354}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=\"Example Google Cloud IoT MQTT device connection code.\"\n    )\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--subscription_name\",\n        required=True,\n        help=\"Cloud Pub/Sub subscription name\",\n    )\n    return parser.parse_args()\n\n", "CodeBleu_score": 50.81883114442526}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=\"Example Google Cloud IoT MQTT device connection code.\"\n    )\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\"--subscription_name\", required=True, help=\"PubSub subscription name\")\n    return parser.parse_args()\n\n", "CodeBleu_score": 51.367306082913046}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=\"Example Google Cloud IoT MQTT device connection code.\"\n    )\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--subscription_name\", required=True, help=\"Cloud IoT subscription name\"\n    )\n    return parser.parse_args()\n\n", "CodeBleu_score": 52.11944418408747}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    api_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_api = \"https://cloudiot.googleapis.com/$discovery/rest?version={}\".format(\n        api_version\n    )\n    service_account_info = json.load(open(service_account_json))\n    credentials = service_account.Credentials.from_service_account_info(\n        service_account_info, scopes=api_scopes\n    )\n    service = discovery.build(\"cloudiot\", api_version, discoveryServiceUrl=discovery_api, credentials=credentials)\n    return service\n\n", "CodeBleu_score": 44.70137117391309}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_account_info = json.load(open(service_account_json))\n    credentials = service_account.Credentials.from_service_account_info(service_account_info, scopes=api_scopes)\n    service_name = 'cloudiotcore'\n    client = discovery.build(service_name, api_version, discoveryServiceUrl=discovery_api, credentials=credentials)\n    return client\n\n", "CodeBleu_score": 39.165968681300974}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_api_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    service_account_credentials = service_account.Credentials.from_service_account_file(\n        service_account_json\n    )\n    scoped_credentials = service_account_credentials.with_scopes(api_scopes)\n    discovery_url = discovery_api_url + \"?version=\" + api_version\n    return discovery.build(\n        \"cloudiot\", api_version, discoveryServiceUrl=discovery_url, credentials=scoped_credentials\n    )\n\n", "CodeBleu_score": 30.60908322625531}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method = hash_method.lower()\n    try:\n        hash_asn1 = transform.OAEP.HASH_ASN1[hash_method]\n    except KeyError:\n        raise ValueError('Unsupported hash type ' + hash_method)\n\n    return transform.bytes2int(\n        core.encrypt_int(\n            transform.bytes2int(hash_asn1 + hash_value),\n            priv_key.d, priv_key.n),\n    )\n\n", "CodeBleu_score": 24.87620589226445}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if not isinstance(hash_method, str):\n        raise TypeError(\"Unsupported hash type\")\n    asn1_hash_algs = {\n        \"MD5\": transform.TRANSFORM_OID_MD5,\n        \"SHA-1\": transform.TRANSFORM_OID_SHA1,\n        \"SHA-224\": transform.TRANSFORM_OID_SHA224,\n        \"SHA-256\": transform.TRANSFORM_OID_SHA256,\n        \"SHA-384\": transform.TRANSFORM_OID_SHA384,\n        \"SHA-512\": transform.TRANSFORM_OID_SHA512,\n    }\n    hash_oid = asn1_hash_algs.get(hash_method)\n    if not hash_oid:\n        raise ValueError(\"Unsupported hash type\")\n    asn1_hash = transform.OID.from_string(hash_oid)\n    return core.encrypt_int(\n        common.bit_size(priv_key.n),\n        common.bytes2int(hash_value),\n        priv_key.d,\n        priv_key.n,\n        asn1_hash,\n    )\n\n", "CodeBleu_score": 34.702535442794904}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    try:\n        asn1_code = transform.asn1.HASH_ASN1[hash_method]\n    except KeyError:\n        raise ValueError('unsupported hash type ' + hash_method)\n\n    hash_info = asn1_code.copy()\n    hash_info['content'] = hash_value\n    padded_hash = transform.asn1.encoder.encode(hash_info)\n    padded_hash_len = len(padded_hash)\n\n    # Generate the signature\n    payload = transform.bytes2int(padded_hash)\n    encrypted = core.encrypt_int(payload, priv_key.d, priv_key.n)\n    block = transform.int2bytes(encrypted, padded_hash_len)\n\n    return block\n\n", "CodeBleu_score": 45.605034414134415}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    hash_method_name = common.inverse_mapping[pub_key.hash_method_id]\n    hash_method = common.inverse_mapping[pub_key.hash_method_id]\n    hash_asn1 = transform.make_mgf(\n        hash_method,\n        pub_key.key_size\n    )\n    decrypted_signature = transform.bytes2int(signature)\n    decrypted_signature = core.decrypt_int(decrypted_signature, pub_key.e, pub_key.n)\n    decrypted_signature = transform.int2bytes(decrypted_signature, pub_key.key_size)\n    message_hash = hash_method(message).digest()\n    padded_hash = transform.EMSA_PSS_ENCODE(\n        message_hash,\n        pub_key.key_size - 1,\n        salt_length=10,\n        hash_method=hash_method_name\n    )\n    if padded_hash != decrypted_signature:\n        raise common.VerificationError(\"Verification failed\")\n    return hash_method_name\n\n", "CodeBleu_score": 24.418901543627612}, {"code": "def verify(message, signature, pub_key)\n\t\n    padded = transform.bytes2int(signature)\n    encrypted = core.decrypt_int(padded, pub_key.e, pub_key.n)\n    clearsig = transform.int2bytes(encrypted, pub_key.size())\n\n    # Convert to bytes\n    try:\n        hash_name = common.byte_to_hash_name(clearsig[0])\n    except IndexError:\n        raise common.VerificationError(\n            \"Verification failed: message too short\",\n            message,\n            signature,\n        )\n\n    try:\n        hasher = common.inverse_hash(hash_name)\n    except ValueError:\n        raise common.VerificationError(\n            \"Verification failed: hash not available\",\n            message,\n            signature,\n        )\n\n    # Compute the hash for this message\n    hashed = hasher(message).digest()\n\n    # Construct the clearsig\n    padding = b\"\\x00\" * (\n        (pub_key.size() - len(hashed) - 3 - pub_key.size() // 8)\n    )\n    block = b\"\\x01\" + padding + b\"\\x00\" + common.hash_algorithms[hash_name] + hashed\n\n    if clearsig != block:\n        raise common.VerificationError(\n            \"Verification failed: signature mismatch\",\n            message,\n            signature,\n        )\n\n    return hash_name\n\n", "CodeBleu_score": 35.53170227849399}, {"code": "def verify(message, signature, pub_key)\n\t\n    hash_method = core.verify(message, signature, pub_key)\n    return hash_method\n\n", "CodeBleu_score": 2.8201305569086874}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\n    time_t currentTime = getCurrentTime();\n\n    if (currentTime != -1) {\n\n        updateJWT(currentTime);\n\n        mqtt_connect();\n\n        sendMqttSubscribe = 1;\n\n    }\n\n    DEBUG_PRINT(\"MQTT CONNECT ATTEMPT\n\");\n\n}", "CodeBleu_score": 26.911675083503216}, {"code": "static void connectMQTT(){\n\t\n    time_t currentTime;\n\n    if (getCurrentTime(&currentTime) == false) {\n\n        return;\n\n    }\n\n    updateJWT(currentTime);\n\n    mqtt_connect(mqtt_connect_callback);\n\n    mqtt_send_subscribe_packet = true;\n\n    DEBUG_PRINT(\"Connecting to MQTT client...\n\");\n\n}", "CodeBleu_score": 22.008922241744067}, {"code": "static void connectMQTT(){\n\t\n    uint32_t currentTime = getCurrentTime();\n\n    if (currentTime != 0) {\n\n        updateJWT(currentTime);\n\n        mqtt_connect();\n\n        mqtt_subscribe_flag = 1;\n\n    }\n\n    debug_print(DBG_INFO, \"Attempting MQTT connection...\n\");\n\n}", "CodeBleu_score": 28.439119399756063}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t val = 0;\n    uint32_t max = 0xFFFFFFFF;\n    int i;\n\n    for (i = 0; i < width; i++) {\n        uint8_t c = *str++;\n        if (c < '0' || c > '9') {\n            return str - 1;\n        }\n        val = val * 10 + (c - '0');\n        if (i < width - 1) {\n            if ((max - 9) / 10 < val) {\n                return str - 1;\n            }\n        }\n    }\n\n    *num = val;\n\n    return str;\n}", "CodeBleu_score": 30.691071583149533}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    uint8_t c;\n    int i;\n\n    for (i = 0; i < width; i++) {\n        c = *str++;\n        if (c < '0' || c > '9') {\n            return str;\n        }\n        value = value * 10 + c - '0';\n    }\n\n    *num = value;\n    return str;\n}", "CodeBleu_score": 27.53264747781077}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    int i;\n\n    for (i = 0; i < width; i++) {\n        if ((str[i] < '0') || (str[i] > '9')) {\n            return str;\n        }\n\n        value = (value * 10) + (str[i] - '0');\n    }\n\n    *num = value;\n\n    return str + i;\n}", "CodeBleu_score": 25.418083769791526}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = 0;\n    atcacert_def_cert_elements_t* cert_def = &build_state->cert_def;\n\n    if (cert_def->cert_signature.value.size == 0) {\n        ret = atcacert_der_encode_cert_signature(build_state->cert_signature, cert_def->cert_signature.value.size, cert_def->cert_signature.value.data);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n    }\n\n    ret = atcacert_der_encode_cert_signature_alg(&cert_def->cert_signature_alg, cert_def->cert_signature_alg.value.size, cert_def->cert_signature_alg.value.data);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_der_encode_cert_tbs(&cert_def->cert_tbs, cert_def->cert_tbs.value.size, cert_def->cert_tbs.value.data);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_der_encode_cert_version(&cert_def->cert_version, cert_def->cert_version.value.size, cert_def->cert_version.value.data);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_der_encode_cert_serial_number(&cert_def->cert_serial_number, cert_def->cert_serial_number.value.size, cert_def->cert_serial_number.value.data);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_der_encode_cert_issuer_name(&cert_def->cert_issuer_name, cert", "CodeBleu_score": 45.97127438934482}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = ATCACERT_E_BAD_PARAMS;\n\n    if (build_state != NULL) {\n        if (build_state->cert_def.cert_type == ATCACERT_ECC_P256_CA) {\n            ret = atcacert_cert_build_finish_ca(build_state);\n        }\n        else if (build_state->cert_def.cert_type == ATCACERT_ECC_P256_CSR) {\n            ret = atcacert_cert_build_finish_csr(build_state);\n        }\n        else if (build_state->cert_def.cert_type == ATCACERT_ECC_P256_CERT) {\n            ret = atcacert_cert_build_finish_cert(build_state);\n        }\n    }\n\n    return ret;\n}", "CodeBleu_score": 43.80633167788612}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = ATCACERT_E_SUCCESS;\n    atcacert_der_encoded_t* encoded_cert = NULL;\n    uint8_t* cert_data = NULL;\n    uint16_t cert_data_size = 0;\n    atcacert_def_cert_elements_t* cert_def = NULL;\n\n    if (build_state == NULL) {\n        ret = ATCACERT_E_BAD_PARAMS;\n        goto cleanup;\n    }\n\n    if (build_state->cert_def == NULL) {\n        ret = ATCACERT_E_BAD_PARAMS;\n        goto cleanup;\n    }\n\n    if (build_state->cert_def->cert_def_type != ATCACERT_DEF_CERT_ELEMENTS) {\n        ret = ATCACERT_E_BAD_PARAMS;\n        goto cleanup;\n    }\n\n    cert_def = build_state->cert_def->cert_def.cert_elements;\n\n    if (cert_def->subject == NULL || cert_def->issuer == NULL || cert_def->serial_number == NULL ||\n        cert_def->subject_public_key_info == NULL || cert_def->extensions == NULL) {\n        ret = ATCACERT_E_BAD_PARAMS;\n        goto cleanup;\n    }\n\n    if (build_state->cert_def->cert_def_type != ATCACERT_DEF_CERT_ELEMENTS) {\n        ret = ATCACERT_E_BAD_PARAMS;\n        goto cleanup;\n    }\n\n    if (cert_def->signature_algorithm == NULL || cert_def->tbs_certificate == NULL) {\n        ret = ATCACERT_E_BAD_PARAMS;\n        goto cleanup;\n    }\n\n    ret = atcacert_der_encoded_new(&encoded_cert);\n    if (ret != ATCACERT_E_SUCCESS) {\n        goto clean", "CodeBleu_score": 51.520603052778924}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    atca_sha256_ctx ctx;\n\n    if (cert_def == NULL || ca_public_key == NULL || cert == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (cert_size < (2 * cert_def->public_key_size + 8)) {\n        return ATCACERT_E_BAD_CERT;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    atcac_sw_sha256_init(&ctx);\n    atcac_sw_sha256_update(&ctx, tbs_digest, sizeof(tbs_digest));\n    atcac_sw_sha256_finish(&ctx, tbs_digest);\n\n    ret = atcac_verify_extern(tbs_digest, sizeof(tbs_digest), signature, sizeof(signature), ca_public_key);\n\n    return ret;\n}", "CodeBleu_score": 76.21929647575088}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = ATCA_BAD_PARAM;\n\n    if (cert_def == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    if (cert == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    if (ca_public_key == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    /* TBS is from beginning of certificate to the signature */\n    size_t tbs_size = cert_size - cert_def->sig_size;\n\n    /* Verify the certificate */\n    ret = atcacert_verify_cert_signature(cert_def, cert, tbs_size, cert + tbs_size, ca_public_key);\n\n    return ret;\n}", "CodeBleu_score": 32.40509258077354}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    ATCA_STATUS status = ATCA_SUCCESS;\n    uint8_t     tbs_digest[32];\n    uint8_t     signature[64];\n\n    if (cert_def == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (cert == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (cert_size < cert_def->cert_size) {\n        return ATCACERT_E_BAD_CERT;\n    }\n\n    // Get the TBS digest\n    status = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (status != ATCA_SUCCESS) {\n        return status;\n    }\n\n    // Get the signature\n    status = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (status != ATCA_SUCCESS) {\n        return status;\n    }\n\n    // Verify the signature\n    status = atcacert_verify_signature(tbs_digest, sizeof(tbs_digest), signature, ca_public_key);\n    if (status != ATCA_SUCCESS) {\n        return status;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 64.12801627437089}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if (timer->next == NULL)\n    {\n        return false;\n    }\n\n    if (timer->next == timer)\n    {\n        return false;\n    }\n\n    timerStruct_t *next = timer->next;\n    timerStruct_t *prev = timer->prev;\n\n    prev->next = next;\n    next->prev = prev;\n\n    if (*list == timer)\n    {\n        *list = next;\n    }\n\n    return true;\n}", "CodeBleu_score": 27.584155509205527}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t  if (list == NULL || timer == NULL)\n    return false;\n\n  timerStruct_t * volatile *prev = list;\n  timerStruct_t * volatile *curr = list;\n  while (*curr != NULL) {\n    if (*curr == timer) {\n      *prev = (*curr)->next;\n      return true;\n    }\n    prev = curr;\n    curr = &(*curr)->next;\n  }\n\n  return false;\n}", "CodeBleu_score": 25.465612906922104}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t  if (list == NULL || timer == NULL) {\n    return false;\n  }\n\n  timerStruct_t *curr = *list;\n  timerStruct_t *prev = NULL;\n\n  while (curr != NULL) {\n    if (curr == timer) {\n      if (prev == NULL) {\n        *list = curr->next;\n      } else {\n        prev->next = curr->next;\n      }\n      return true;\n    }\n    prev = curr;\n    curr = curr->next;\n  }\n\n  return false;\n}", "CodeBleu_score": 35.59991261655738}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\n    struct socketInfo * sockInfo = getSocketInfo(socket);\n\n    if (sockInfo == NULL) {\n\n        return BSD_ERROR;\n\n    }\n\n    sockInfo -> state = NOT_A_SOCKET;\n\n    int ret = close(socket);\n\n    if (ret < 0) {\n\n        switch (errno) {\n\n            case EBADF:\n\n                errno = ENOTSOCK;\n\n                break;\n\n            case ENOTCONN:\n\n                errno = EINVAL;\n\n                break;\n\n            default:\n\n                break;\n\n        }\n\n        return BSD_ERROR;\n\n    }\n\n    return BSD_SUCCESS;\n\n}", "CodeBleu_score": 55.58008615207892}, {"code": "int BSD_close(int socket){\n\t\n    int i = 0;\n\n    int retVal = 0;\n\n    int errno = 0;\n\n    struct socketInfo * sockInfo = NULL;\n\n    // Get socket information\n\n    sockInfo = getSocketInfo(socket);\n\n    if (sockInfo == NULL) {\n\n        // Socket does not exist\n\n        errno = EBADF;\n\n        return BSD_ERROR;\n\n    }\n\n    // Set socket state to \"NOT_A_SOCKET\"\n\n    sockInfo->state = NOT_A_SOCKET;\n\n    // Call close function\n\n    retVal = close(socket);\n\n    if (retVal != 0) {\n\n        // Error occurred\n\n        errno = retVal;\n\n        return BSD_ERROR;\n\n    }\n\n    // No error occurred\n\n    return BSD_SUCCESS;\n\n}", "CodeBleu_score": 41.4342973553338}, {"code": "int BSD_close(int socket){\n\t\n    struct socketInfo * socketInfo = getSocketInfo(socket);\n\n    if (socketInfo == NULL) {\n\n        return BSD_ERROR;\n\n    }\n\n    socketInfo->state = NOT_A_SOCKET;\n\n    int ret = close(socket);\n\n    if (ret < 0) {\n\n        int error = errno;\n\n        if (error == ENOTSOCK) {\n\n            errno = EBADF;\n\n        } else if (error == EINTR) {\n\n            errno = EINPROGRESS;\n\n        } else {\n\n            errno = error;\n\n        }\n\n        return BSD_ERROR;\n\n    }\n\n    return BSD_SUCCESS;\n\n}", "CodeBleu_score": 50.39757849226897}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\n    int response = listen(socket, backlog);\n\n    if (response < 0) {\n\n        errno = response;\n\n        return BSD_ERROR;\n\n    }\n\n    return BSD_SUCCESS;\n\n}", "CodeBleu_score": 19.03807488984469}, {"code": "int BSD_listen(int socket, int backlog){\n\t    int ret = listen(socket, backlog);\n\n    if (ret < 0) {\n        debug_print(DBG_ERROR, \"BSD_listen.listen() failed, errno: %d\n\", errno);\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 17.746052095831654}, {"code": "int BSD_listen(int socket, int backlog){\n\t\n    int response = listen(socket, backlog);\n\n    if (response < 0) {\n\n        BSD_ERROR_NUMBER = response;\n\n        return BSD_ERROR;\n\n    }\n\n    return BSD_SUCCESS;\n\n}", "CodeBleu_score": 19.51222179589733}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\n    int ret = -1;\n\n    int family = 0;\n\n    int sock_type = 0;\n\n    int sock_protocol = 0;\n\n    int sock_addr_len = 0;\n\n    int sock_addr_size = 0;\n\n    struct sockaddr * sock_addr = NULL;\n\n    struct sockaddr_in * sock_addr_in = NULL;\n\n    struct sockaddr_in6 * sock_addr_in6 = NULL;\n\n    struct sockaddr_storage sock_addr_storage;\n\n\n\n    if (socket < 0 || socket >= NUM_SOCKETS) {\n\n        DEBUG_PRINT_ERROR(\"Invalid socket %d", "CodeBleu_score": 15.086541262805136}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    int ret = 0;\n    struct bsd_sockaddr_in * addr_in = (struct bsd_sockaddr_in * ) addr;\n    if (addr_in -> sin_family != AF_INET) {\n        ret = -1;\n        errno = EAFNOSUPPORT;\n        return ret;\n    }\n    ret = accept(socket, (struct sockaddr * ) addr_in, addrlen);\n    if (ret < 0) {\n        if (ret == -1) {\n            errno = EWOULDBLOCK;\n        }\n        return ret;\n    }\n    return ret;\n}", "CodeBleu_score": 39.07549859895323}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\n    int ret;\n\n    struct sockaddr * sock_addr = (struct sockaddr * ) addr;\n\n    if (addr == NULL) {\n\n        return -1;\n\n    }\n\n    if (addrlen == NULL) {\n\n        return -1;\n\n    }\n\n    if (sock_addr -> sa_family == AF_INET) {\n\n        ret = accept(socket, sock_addr, addrlen);\n\n        if (ret < 0) {\n\n            DEBUG_PRINT(DEBUG_ERROR, \"Error accepting connection on socket %d: %d\n\", socket, ret);\n\n            return -1;\n\n        }\n\n        return ret;\n\n    }\n\n    if (sock_addr -> sa_family == AF_INET6) {\n\n        DEBUG_PRINT(DEBUG_ERROR, \"IPv6 not supported\n\");\n\n        errno = EAFNOSUPPORT;\n\n        return -1;\n\n    }\n\n    DEBUG_PRINT(DEBUG_ERROR, \"Unknown address family: %d\n\", sock_addr -> sa_family);\n\n    errno = EAFNOSUPPORT;\n\n    return -1;\n\n}", "CodeBleu_score": 44.38777546358541}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\n    int32_t timeOffset = getCurrentTime();\n\n    if (timeOffset != -1) {\n\n        updateJWT(timeOffset);\n\n        mqttConnect(MQTT_CONNECT_TIMEOUT);\n\n        DEBUG_PRINT(\"Attempting to connect to MQTT broker...\\r\n\");\n\n        mqttSetSubscribeFlag();\n\n    }\n\n}", "CodeBleu_score": 19.38441281892031}, {"code": "static void connectMQTT(){\n\t    uint32_t currentTime = getCurrentTime();\n    if (currentTime != -1) {\n        updateJWT(currentTime);\n        mqtt_connect();\n        DEBUG_PRINT(\"Connecting to MQTT broker...\\r\n\");\n        setSendSubscribePacketFlag(true);\n    }\n}", "CodeBleu_score": 26.444880078804445}, {"code": "static void connectMQTT(){\n\t    uint32_t currentTime = getCurrentTime();\n\n    if (currentTime != 0) {\n        updateJWT(currentTime);\n        initMQTT();\n        DEBUG_PRINT(\"Connecting to MQTT broker...\\r\n\");\n        mqtt_send_connect_packet();\n        mqtt_send_subscribe_packet();\n    }\n}", "CodeBleu_score": 25.029272361509737}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\n    DEBUG_PRINT(\"Disconnecting from cloud service...\n\");\n\n    if (mqtt_getConnectionState() == CONNECTED) {\n\n        MQTT_Client_t * client = mqtt_getClient();\n\n        mqtt_disconnect(client);\n\n    }\n\n}", "CodeBleu_score": 56.98128928990075}, {"code": "void CLOUD_disconnect(void){\n\t\n    debug_print(DEBUG_PRINT_INFO, \"Disconnecting from cloud service\n\");\n\n    if (MQTT_getConnectionState() == CONNECTED) {\n\n        MQTT_Client_t * client = MQTT_getClient();\n\n        MQTT_Client_t * client_info = MQTT_getClientInfo();\n\n        if (client_info != NULL) {\n\n            MQTT_Client_t * client_info_next = client_info->next;\n\n            MQTT_Client_t * client_info_prev = client_info->prev;\n\n            if (client_info_prev != NULL) {\n\n                client_info_prev->next = client_info_next;\n\n            }\n\n            if (client_info_next != NULL) {\n\n                client_info_next->prev = client_info_prev;\n\n            }\n\n            free(client_info);\n\n        }\n\n        MQTT_disconnect(client);\n\n    }\n\n}", "CodeBleu_score": 44.61824687651895}, {"code": "void CLOUD_disconnect(void){\n\t\n    debug_print(\"Disconnecting from cloud service\n\");\n\n    if (MQTT_getConnectionState() == CONNECTED) {\n\n        MQTT_client_connection_info_t * client_connection_info = MQTT_getClientConnectionInfo();\n\n        MQTT_disconnect(client_connection_info);\n\n    }\n\n}", "CodeBleu_score": 56.704964943673545}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n    t_u8 ssid[32];\n\n    t_u8 auth_type;\n\n    t_u8 password[64];\n\n    t_u8 channel;\n\n    t_u8 ssid_len;\n\n    t_u8 password_len;\n\n    t_u8 max_conn;\n\n    t_u8 retry_count;\n\n    t_u8 retry_interval;\n\n    t_u8 power_save_mode;\n\n    t_u8 power_save_level;\n\n    t_u8 listen_interval;\n\n    t_u8 key_index;\n\n    t_u8 key_mgmt;\n\n    t_u8 wep_key_len;\n\n    t_u8 wep_key_format;\n\n    t_u8 wep_key_index;\n\n    t_u8 wep_key[4];\n\n    t_u8 wep_key_count;\n\n    t_u8 wep_key_mgmt;\n\n    t_u8 wpa_key_mgmt;\n\n    t_u8 wpa_key_len;\n\n    t_u8 wpa_key_index;\n\n    t_u8 wpa_key[64];\n\n    t_u8 wpa_key_count;\n\n    t_u8 wpa2_key_mgmt;\n\n    t_u8 wpa2_key_len;\n\n    t_u8 wpa2_key_index;\n\n    t_u8 wpa2_key[64];\n\n    t_u8 wpa2_key_count;\n\n    t_u8 wpa_psk_passphrase[64];\n\n    t_u8 wpa_psk_passphrase_len;\n\n    t_u8 wpa2_psk_passphrase[64];\n\n    t_u8 wpa2_psk_passphrase_len;\n\n    t_u8 wpa_psk_passphrase_id;\n\n    t_u8 wpa2_psk_passphrase_id;\n\n   ", "CodeBleu_score": 3.7671019807404713}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n    t_u8 SSID[33] = {0};\n\n    t_u8 pass[65] = {0};\n\n    t_u8 auth_mode;\n\n    t_u8 channel;\n\n    t_u8 conn_type;\n\n    t_u8 ip_version;\n\n    t_u8 ip_address[4];\n\n    t_u8 mac_address[6];\n\n    t_u8 gateway[4];\n\n    t_u8 netmask[4];\n\n    t_u8 dns_server[4];\n\n    t_u8 dns_server_alt[4];\n\n    t_u8 dns_domain_name[33];\n\n    t_u8 ntp_server[4];\n\n    t_u8 ntp_server_alt[4];\n\n    t_u8 ntp_server_alt_2[4];\n\n    t_u8 ntp_server_alt_3[4];\n\n    t_u8 ntp_server_alt_4[4];\n\n    t_u8 ntp_server_alt_5[4];\n\n    t_u8 ntp_server_alt_6[4];\n\n    t_u8 ntp_server_alt_7[4];\n\n    t_u8 ntp_server_alt_8[4];\n\n    t_u8 ntp_server_alt_9[4];\n\n    t_u8 ntp_server_alt_10[4];\n\n    t_u8 ntp_server_alt_11[4];\n\n    t_u8 ntp_server_alt_12[4];\n\n    t_u8 ntp_server_alt_13[4];\n\n    t_u8 ntp_server_alt_14[4];\n\n    t_u8 ntp_server_alt_15[4];\n\n    t_u8 ntp_server_alt_16[4];\n\n    t_u8 ntp_server_alt_17[4];\n\n    t_u8 ntp_server_alt_18", "CodeBleu_score": 3.43417101855859}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n    // If new credentials are provided, connect using them\n    if (passed_wifi_creds) {\n        // Set the Wi-Fi credentials\n        if (m2m_wifi_set_credentials(wifi_ssid, wifi_auth_type, wifi_pass) != M2M_SUCCESS) {\n            // If the credentials are invalid, log an error message and return false\n            DEBUG_PRINT(\"Invalid Wi-Fi credentials\n\");\n            return false;\n        }\n    }\n\n    // Attempt to connect to the Wi-Fi access point\n    if (m2m_wifi_connect(wifi_conn_type, (uint8_t *)wifi_ip_addr, wifi_port) != M2M_SUCCESS) {\n        // If the connection fails, log an error message, update the networking error status, and return false\n        DEBUG_PRINT(\"Could not connect to Wi-Fi access point\n\");\n        application_manager_update_networking_error_status(true);\n        return false;\n    }\n\n    // If the connection succeeds, return true\n    return true;\n}", "CodeBleu_score": 47.12298723570512}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t  const client = new AWSAppSyncClient({\n    url: \"https://zjjyz74pqvg3vk3472mz6bv6i.appsync-api.us-east-1.amazonaws.com/graphql\",\n    region: \"us-east-1\",\n    auth: {\n      type: \"API_KEY\",\n      apiKey: \"da2-324hx32jvfh47kz5h45x6x4dq\",\n    },\n  });\n\n  const query = `\n    query MyQuery {\n      listSensors {\n        items {\n          sensorId\n          geohash\n          latitude\n          longitude\n          sensorType\n          sensorValue\n        }\n      }\n    }\n  `;\n\n  const response = await client.query({ query });\n\n  console.log(\"API response:\", response);\n\n  if (response.data) {\n    console.log(\"Retrieved sensors:\", response.data.listSensors.items);\n\n    response.data.listSensors.items.forEach((sensor) => {\n      const marker = new maplibregl.Marker({\n        color: \"red\",\n      })\n        .setLngLat([sensor.longitude, sensor.latitude])\n        .addTo(map);\n    });\n  }\n}", "CodeBleu_score": 40.77414733402435}, {"code": "async function DisplaySensors(map){\n\t  const client = new AWSAppSyncClient({\n    url: process.env.REACT_APP_APPSYNC_GRAPHQL_ENDPOINT,\n    region: process.env.REACT_APP_APPSYNC_REGION,\n    auth: {\n      type: AUTH_TYPE.API_KEY,\n      apiKey: process.env.REACT_APP_APPSYNC_API_KEY,\n    },\n  });\n\n  const response = await client.query({\n    query: gql(listSensors),\n  });\n\n  console.log(response);\n\n  if (response.data.listSensors) {\n    console.log(\"Retrieved sensors\");\n    response.data.listSensors.items.forEach((sensor) => {\n      const marker = new maplibregl.Marker({\n        color: \"#FF0000\",\n      })\n        .setLngLat([sensor.longitude, sensor.latitude])\n        .addTo(map);\n    });\n  }\n}", "CodeBleu_score": 44.12489874366974}, {"code": "async function DisplaySensors(map){\n\t  try {\n    const client = new AWSAppSyncClient({\n      url: \"https://55555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555", "CodeBleu_score": 4.327757768467027}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"sensor-marker\";\n  marker.style.backgroundColor = \"#000000\";\n  marker.style.border = \"2px solid #ffffff\";\n  return marker;\n}", "CodeBleu_score": 43.6978071078464}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"marker\";\n  marker.style.backgroundColor = \"#FF0000\";\n  marker.style.border = \"1px solid black\";\n  return marker;\n}", "CodeBleu_score": 42.376050471361175}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'marker';\n  marker.style.backgroundColor = '#3388ff';\n  marker.style.border = '1px solid white';\n  return marker;\n}", "CodeBleu_score": 42.27643925344304}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as err:\n        logging.getLogger(__name__).error(\n            \"Unable to load multi-factor auth module %s: %s\", module_name, err\n        )\n        raise HomeAssistantError(\"Unable to load multi-factor auth module\") from err\n    if not hasattr(module, \"async_setup\") and not hasattr(module, \"async_setup_legacy\"):\n        logging.getLogger(__name__).error(\n            \"Multi-factor auth module %s has no async_setup or async_setup_legacy function\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            \"Multi-factor auth module has no async_setup or async_setup_legacy function\"\n        )\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not hass.config.skip_pip:\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n        if module_name not in hass.data[HassKey.MFA_SETUP_PROCESSED]:\n            await hass.data[HassKey.MFA_SETUP_PROCESSED].add(module_name)\n            await module.async_setup_legacy(hass)\n    return module\n\n", "CodeBleu_score": 53.212670306781774}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = \"homeassistant.components.mfa.{}\".format(module_name)\n    try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Error loading multi-factor authentication module %s: %s\", module_path, err)\n        raise HomeAssistantError(f\"Module not found: {module_path}\") from err\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await requirements.async_process_requirements(hass, module_path, module.REQUIREMENTS)\n    return module\n\n", "CodeBleu_score": 41.02095346537224}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{__package__}.mfa.{module_name}\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Error while importing mfa module %s: %s\", module_name, err)\n        raise HomeAssistantError(f\"Module error: {module_name}\") from err\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module_path, module.REQUIREMENTS\n        )\n    return module\n\n", "CodeBleu_score": 41.31506632862691}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for data in self.data:\n        if data[\"user_id\"] == user_id:\n            data[\"pin\"] = pin\n            return\n    self.data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 72.61260244590233}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for data in self.data[\"users\"]:\n        if data[\"user_id\"] == user_id:\n            data[\"pin\"] = pin\n            return\n    self.data[\"users\"].append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 70.0404272170964}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for data in self._data:\n        if data[\"user_id\"] == user_id:\n            data[\"pin\"] = pin\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 80.42675528111758}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._initialization_lock:\n        if self._user_settings is not None:\n            return\n        self._user_settings = OrderedDict()\n        data = await self._store.async_load()\n        if data is None:\n            data = {}\n        for user_id, settings in data.items():\n            self._user_settings[user_id] = NotifySetting(**settings)\n\n", "CodeBleu_score": 44.415946487972505}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        self._user_settings = OrderedDict()\n        data = await self._store.async_load()\n        if data is None:\n            data = {}\n        for user_id, conf in data.items():\n            self._user_settings[user_id] = NotifySetting(**conf)\n\n", "CodeBleu_score": 46.11169209506734}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        self._user_settings = OrderedDict()\n        data = await self._store.async_load()\n        if data is None:\n            data = {}\n        for user_id, user_data in data.items():\n            self._user_settings[user_id] = NotifySetting(\n                **dict(user_data, user_id=user_id)\n            )\n\n", "CodeBleu_score": 44.96393355887202}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_settings(user_id)\n    settings = self.get_notification_settings(user_id)\n    if settings is None:\n        return False\n    otp = user_input[\"otp\"]\n    return await self.hass.async_add_executor_job(settings.validate, otp)\n\n", "CodeBleu_score": 44.22732853422764}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    try:\n        await self.async_load_settings(user_id)\n    except ValueError:\n        return False\n\n    settings = self.user_settings.get(user_id)\n    if settings is None:\n        return False\n\n    otp = user_input.get(CONF_OTP)\n    if otp is None:\n        return False\n\n    return await self.hass.async_add_executor_job(\n        self.pyotp.verify, settings.secret, otp\n    )\n\n", "CodeBleu_score": 57.2510639069902}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_user_settings(user_id)\n    user_settings = self.user_settings.get(user_id)\n    if user_settings is None:\n        return False\n\n    otp = user_input.get(\"otp\")\n    if otp is None:\n        return False\n\n    result = await self.hass.async_add_executor_job(\n        self.validate_otp, user_settings, otp\n    )\n    return result\n\n", "CodeBleu_score": 51.555482351242745}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n    device_id = entity_entry.device_id\n    if device_id is None:\n        return None\n    device_entry = perm_lookup.device_registry.async_get(device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 67.62416786281416}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_id = entity_entry.device_id\n\n    if device_id is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 67.62416786281416}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n\n    if entity_entry is None:\n        return None\n\n    device_id = entity_entry.device_id\n\n    if device_id is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(device_id)\n\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 67.62416786281416}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n\n    for policy in policies:\n        for category, subcategories in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = subcategories\n            else:\n                merged_policy[category] = {\n                    **merged_policy[category],\n                    **subcategories,\n                }\n\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 48.39940122854226}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n\n    for policy in policies:\n        for category, subcategories in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = subcategories\n            else:\n                merged_policy[category] = {\n                    **merged_policy[category],\n                    **subcategories,\n                }\n\n    return cast(PolicyType, merged_policy)", "CodeBleu_score": 48.39940122854226}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n\n    for policy in policies:\n        for category, subcategories in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = subcategories\n            else:\n                merged_policy[category] |= subcategories\n\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 50.60419974670872}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(\n            f\"homeassistant.auth.providers.{provider}\"\n        )\n    except ImportError as err:\n        _LOGGER.error(\"Error loading module %s: %s\", provider, err)\n        raise HomeAssistantError() from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not hass.config.skip_pip:\n        processed = hass.data.get(HassKey.PROCESSED_REQUIREMENTS, None)\n        await requirements.async_process_requirements(\n            hass, f\"auth_provider {provider}\", module.REQUIREMENTS, processed\n        )\n\n    return module\n\n", "CodeBleu_score": 50.01001882720782}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(\n            \"homeassistant.auth.providers.\" + provider\n        )\n    except ImportError:\n        logging.getLogger(__name__).error(\n            \"Failed to load auth provider %s\", provider\n        )\n        raise HomeAssistantError(\"Module not found\")\n\n    if not hasattr(module, \"async_setup\"):\n        return module\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        module.REQUIREMENTS = []\n\n    processed_requirements = hass.data.get(HassKey.PROCESSED_REQUIREMENTS)\n    if processed_requirements is None:\n        processed_requirements = hass.data[HassKey.PROCESSED_REQUIREMENTS] = set()\n\n    if not module.REQUIREMENTS or processed_requirements.issuperset(\n        module.REQUIREMENTS\n    ):\n        return module\n\n    await requirements.async_process_requirements(\n        hass, \"auth_provider_\" + provider, module.REQUIREMENTS\n    )\n    processed_requirements.update(module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 42.43711725936276}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\"Error loading auth provider %s: %s\", provider, err)\n        raise HomeAssistantError() from err\n\n    if not hasattr(module, \"async_get_auth_provider\"):\n        _LOGGER.error(\"Auth provider %s has no async_get_auth_provider\", provider)\n        raise HomeAssistantError()\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed_requirements = hass.data.get(\n        data_entry_flow.DATA_PROCESSED_REQUIREMENTS\n    ) or set()\n\n    if processed_requirements is None:\n        processed_requirements = hass.data[data_entry_flow.DATA_PROCESSED_REQUIREMENTS] = set()\n\n    if module.REQUIREMENTS in processed_requirements:\n        return module\n\n    processed_requirements.add(module.REQUIREMENTS)\n\n    await requirements.async_process_requirements(\n        hass, f\"auth_provider {provider}\", module.REQUIREMENTS\n    )\n\n    return module\n\n", "CodeBleu_score": 46.94069803256784}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self.store.async_load()\n    except HomeAssistantError as err:\n        self.users = []\n        if not self.hass.config.is_safe_mode():\n            ir.async_create_issue(\n                self.hass,\n                DOMAIN,\n                f\"Found invalid auth data: {err}\",\n                is_fixable=True,\n                learn_more_url=\"https://www.home-assistant.io/integrations/auth/\",\n            )\n    else:\n        if data is None:\n            data = {\"users\": []}\n        self.users = [User(**user) for user in data[\"users\"]]\n        self._normalize_usernames()\n\n", "CodeBleu_score": 35.44049941903561}, {"code": "async def async_load(self) -> None\n\t\n    data = await self._store.async_load()\n    if data is None:\n        data = {\"users\": []}\n    self._users = data[\"users\"]\n    for user in self._users:\n        if CONF_ID not in user:\n            self._async_schedule_save()\n            user[CONF_ID] = base64.b64encode(user[\"username\"].encode()).decode()\n    self._normalize()\n\n", "CodeBleu_score": 35.544936650885}, {"code": "async def async_load(self) -> None\n\t\n    data = await self._store.async_load()\n    if data is None:\n        data = {\"users\": []}\n    self._users = data[\"users\"]\n    for user in self._users:\n        if CONF_ID not in user:\n            user[CONF_ID] = base64.b64encode(user[\"username\"].encode()).decode()\n            self._async_schedule_save()\n\n", "CodeBleu_score": 36.53702276308519}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            try:\n                password_hash = base64.b64decode(user.password_hash)\n                if bcrypt.checkpw(password.encode(), password_hash):\n                    return\n            except ValueError:\n                raise InvalidAuth\n            break\n    else:\n        # Prevent timing attacks by doing a dummy check\n        bcrypt.checkpw(password.encode(), dummy_hash)\n        raise InvalidAuth\n\n", "CodeBleu_score": 39.27292588284437}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n\n    for user in self.data[\"users\"]:\n        if user[\"username\"] == username:\n            password_hash = base64.b64decode(user[\"password\"])\n            try:\n                if bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                    return\n            except ValueError as error:\n                if dummy_hash == password_hash:\n                    raise InvalidAuth from error\n                raise InvalidAuth from error\n\n    # Dummy check to make user enumeration harder\n    bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n\n    raise InvalidAuth\n\n", "CodeBleu_score": 42.17348058034873}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            hash_ = base64.b64decode(user[\"password\"])\n            try:\n                if not bcrypt.checkpw(password.encode(\"utf-8\"), hash_):\n                    raise InvalidAuth\n            except ValueError as ex:\n                raise InvalidAuth() from ex\n            return\n    try:\n        if not bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n            raise InvalidAuth\n    except ValueError as ex:\n        raise InvalidAuth() from ex\n\n", "CodeBleu_score": 46.226316871812436}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    found = None\n    for index, user in enumerate(self.users):\n        if user[\"username\"] == username:\n            found = index\n            break\n\n    if found is None:\n        raise InvalidUser(\"user_not_found\")\n\n    self.users.pop(found)\n\n", "CodeBleu_score": 43.98054250721242}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    for user in self.users:\n        if user[\"username\"] == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 27.049996659621}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    for user in self.users:\n        if user[\"username\"] == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 27.049996659621}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        await self.async_load()\n\n    try:\n        self.data.pop(credentials.id)\n    except KeyError:\n        pass\n    else:\n        await self.async_save()\n\n", "CodeBleu_score": 44.143524525121144}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        await self._async_load()\n\n    try:\n        self._data[\"users\"].pop(credentials.id)\n    except KeyError:\n        pass\n    else:\n        await self._store.async_save(self._data)\n\n", "CodeBleu_score": 46.86257143757351}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        await self.async_load()\n\n    try:\n        self._data.pop(credentials.id)\n    except KeyError:\n        pass\n\n    await self._store.async_save(self._data)\n\n", "CodeBleu_score": 43.61327839496856}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    for thread in threads:\n        if not thread.is_alive():\n            continue\n        if not thread.ident:\n            continue\n        if timeout > 0:\n            thread.join(timeout)\n        else:\n            thread.join()\n        if not thread.is_alive():\n            continue\n        if log:\n            logging.warning(f\"thread {thread.name} is still running\")\n        try:\n            thread.raise_system_exit()\n        except SystemExit:\n            pass\n    return {thread for thread in threads if not thread.is_alive()}\n\n", "CodeBleu_score": 40.426400508052}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    for thread in threads:\n        thread_timeout = timeout - (time.time() - thread.start_time)\n        if thread_timeout > 0:\n            thread.join(thread_timeout)\n        if not thread.is_alive() or thread.ident is None:\n            thread.join()\n            threads.remove(thread)\n        elif log:\n            logging.warning(f\"Thread {thread.name} is still running\")\n    for thread in threads:\n        thread.raise_system_exit()\n    return threads\n\n", "CodeBleu_score": 51.07819849377249}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    for thread in threads:\n        thread_timeout = timeout\n        if thread.ident is not None:\n            thread_timeout = timeout - (time.monotonic() - thread.start_time)\n        thread.join(thread_timeout)\n        if not thread.is_alive() or thread.ident is None:\n            yield thread\n        elif log:\n            logging.warning(f\"Thread {thread.name} is still running\")\n    for thread in threads:\n        if thread.is_alive():\n            thread.raise_system_exit()\n\n", "CodeBleu_score": 49.7304647573932}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    shutdown_timeout = 10\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread != threading.main_thread()\n        and not thread.daemon\n        and thread.is_alive()\n    ]\n    timeout = shutdown_timeout / len(threads)\n    for thread in threads:\n        thread.join(timeout=timeout)\n        if thread.is_alive():\n            logging.warning(f\"Failed to join thread {thread.name}\")\n\n", "CodeBleu_score": 40.36603588253071}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    shutdown_timeout = 5\n    shutdown_thread = threading.current_thread()\n    for thread in threading.enumerate():\n        if thread is not shutdown_thread and thread.is_alive() and not thread.daemon:\n            join_timeout = shutdown_timeout / len(threading.enumerate())\n            thread.join(join_timeout)\n            if thread.is_alive():\n                logging.warning(f\"Thread {thread.name} failed to join within {join_timeout} seconds\")\n\n", "CodeBleu_score": 32.35002977357501}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    shutdown_timeout = 10\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread.ident != threading.main_thread().ident\n        and not thread.daemon\n        and thread.is_alive()\n    ]\n    timeout = shutdown_timeout / len(threads)\n    for thread in threads:\n        thread.join(timeout=timeout)\n        if thread.is_alive():\n            logging.warning(f\"Thread {thread.name} failed to join within {timeout} seconds.\")\n\n", "CodeBleu_score": 37.574394351642475}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining:\n        self._internal_dispatcher.send(remaining_with_setup_started)\n        self._remaining = remaining_with_setup_started\n\n", "CodeBleu_score": 49.349821980409715}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_state:\n        self._internal_dispatcher_signal.send(remaining_with_setup_started)\n    self._previous_state = remaining_with_setup_started\n\n", "CodeBleu_score": 49.73020543253119}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self._internal_dispatcher.send(remaining_with_setup_started)\n        self._remaining_with_setup_started = remaining_with_setup_started\n\n", "CodeBleu_score": 46.84069199321209}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations, config)\n\n    if not github.validate_content(\n        f\"{config.root}/homeassistant/generated/bluetooth.py\", content\n    ):\n        config.add_error(\n            \"bluetooth\",\n            \"File homeassistant/generated/bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n\n    if not (config.specific_integrations or config.specific_packages):\n        return\n\n    old_content = bluetooth_path.read_text() if bluetooth_path.is_file() else \"\"\n\n    if old_content != content:\n        config.add_error(\n            \"bluetooth\",\n            \"File homeassistant/generated/bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n", "CodeBleu_score": 59.44397990456408}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = config.path(\"bluetooth.py\")\n    config.cache[\"bluetooth\"] = content = generate(config, integrations)\n\n    if not bluetooth_path.is_file():\n        config.add_error(\"bluetooth\", \"File bluetooth.py is missing\")\n        return\n\n    current_content = bluetooth_path.read_text()\n\n    if current_content != content:\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n        )\n\n    if not config.specific_integrations:\n        return\n\n    for domain in config.specific_integrations:\n        if domain not in integrations:\n            continue\n\n        for key in (\"notify\", \"scanner\"):\n            if key not in integrations[domain]:\n                continue\n\n            if key not in config.cache[\"bluetooth\"]:\n                config.add_error(\n                    \"bluetooth\",\n                    f\"Integration {domain} does not have bluetooth.py file generation data\",\n                )\n                continue\n\n            if config.cache[\"bluetooth\"][key] != content:\n                config.add_error(\n                    \"bluetooth\",\n                    f\"Integration {domain} bluetooth.py file generation data is incorrect\",\n                )\n", "CodeBleu_score": 47.666971649325355}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations, config)\n\n    if not github.validate(content, bluetooth_path):\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n        )", "CodeBleu_score": 47.940532190206966}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tclient := resty.New()\n\tresp, err := client.R().\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"client_id\":     d.ClientID,\n\t\t\t\"client_secret\": d.ClientSecret,\n\t\t}).\n\t\tPost(\"https://api.dropbox.com/oauth2/token\")\n\tif err != nil {\n\t\tlogger.Error(\"dropbox_driver: failed to refresh token\", zap.Error(err))\n\t\treturn err\n\t}\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"dropbox_driver: failed to refresh token\", zap.String(\"status\", resp.Status()))\n\t\treturn fmt.Errorf(\"dropbox_driver: failed to refresh token: %s\", resp.Status())\n\t}\n\td.AccessToken = resp.String()\n\treturn nil\n}", "CodeBleu_score": 52.55125533217932}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropboxapi.com/oauth2/token\"\n\n\tresp, err := resty.New().R().\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"client_id\":     d.ClientID,\n\t\t\t\"client_secret\": d.ClientSecret,\n\t\t}).\n\t\tPost(url)\n\tif err != nil {\n\t\tlogger.Error(\"refresh token failed\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"refresh token failed\", zap.String(\"status\", resp.Status()))\n\t\treturn fmt.Errorf(\"refresh token failed, status: %s\", resp.Status())\n\t}\n\n\td.AccessToken = resp.String()\n\n\treturn nil\n}", "CodeBleu_score": 52.80351006793107}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropbox.com/oauth2/token\"\n\n\tresp, err := resty.New().R().\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"client_id\":     d.AppKey,\n\t\t\t\"client_secret\": d.AppSecret,\n\t\t}).Post(url)\n\n\tif err != nil {\n\t\tlogger.Error(\"refresh token failed\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"refresh token failed\", zap.String(\"status\", resp.Status()))\n\t\treturn fmt.Errorf(\"refresh token failed: %s\", resp.Status())\n\t}\n\n\td.AccessToken = resp.String()\n\treturn nil\n}", "CodeBleu_score": 54.10421485763616}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tclient := resty.New()\n\treq := client.R()\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\n\treq.SetQueryParams(map[string]string{\n\t\t\"supportsAllDrives\": \"true\",\n\t})\n\n\tres, err := req.Execute(method, url)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode() == http.StatusUnauthorized {\n\t\tif err := d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\tif !res.IsSuccess() {\n\t\treturn nil, fmt.Errorf(\"request failed with status code %d\", res.StatusCode())\n\t}\n\n\treturn res.Body(), nil\n}", "CodeBleu_score": 64.64907619328851}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tclient := resty.New()\n\treq := client.R()\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\n\tres, err := req.Execute(method, url)\n\n\tif err != nil {\n\t\tlogger.Error(\"request error\", zap.Any(\"error\", err))\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode() == http.StatusUnauthorized {\n\t\terr := d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\treturn res.Body(), nil\n}", "CodeBleu_score": 64.59254812425982}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tclient := resty.New()\n\treq := client.R()\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\treq.SetError(&utils.APIError{})\n\n\turl = GoogleDriveAPIRoot + url\n\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\n\tres, err := req.Execute(method, url)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.IsError() {\n\t\terr := res.Error().(*utils.APIError)\n\t\tif err.Code == 401 {\n\t\t\tlogger.Info(\"refreshing token\", zap.String(\"url\", url))\n\t\t\td.RefreshToken(context.Background())\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\n\t\treturn nil, fmt.Errorf(\"request error: %s\", err.Message)\n\t}\n\n\treturn res.Body(), nil\n}", "CodeBleu_score": 64.80746737664515}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := d.config.ChunkSize\n\tchunkSizeString := strconv.Itoa(chunkSize)\n\n\tclient := resty.New()\n\tclient.SetRetryCount(3)\n\tclient.SetRetryMaxWaitTime(30 * 1000)\n\tclient.SetRetryWaitTime(30 * 1000)\n\tclient.SetTimeout(30 * 1000)\n\tclient.SetLogger(logger.NewRestyLogger())\n\tclient.SetDebug(false)\n\n\toffset := 0\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tchunk := make([]byte, chunkSize)\n\t\t\tn, err := stream.Read(chunk)\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tchunk = chunk[:n]\n\n\t\t\tif len(chunk) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treq := client.R()\n\t\t\treq.SetContext(ctx)\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": chunkSizeString,\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+len(chunk)-1, stream.Size()),\n\t\t\t})\n\t\t\treq.SetBody(chunk)\n\n\t\t\tresp, err := req.Put(url)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif resp.StatusCode() != http.StatusCreated && resp.StatusCode() != http.StatusOK {\n\t\t\t\tlog.Error(\"chunk upload failed\", zap.String(\"url\", url), zap.Int(\"status\", resp.StatusCode()), zap.String(\"response\", resp.String()))\n\t\t\t\treturn fmt.Errorf(\"chunk upload failed with status code %d\", resp.StatusCode())\n\t\t\t}\n\n\t\t\toffset += len(chunk)\n\n\t\t\tif offset >= stream.Size() {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n", "CodeBleu_score": 42.133442873819384}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tlogger.Info(\"chunk upload\", zap.String(\"url\", url))\n\n\tchunkSize := d.chunkSize\n\ttotalSize, err := utils.GetReaderLen(stream)\n\tif err != nil {\n\t\tlogger.Error(\"get reader len failed\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tchunkNum := totalSize/chunkSize + 1\n\tlogger.Info(\"chunk num\", zap.Int64(\"chunkNum\", chunkNum))\n\n\tclient := resty.New().SetRetryCount(3).SetRetryMaxWaitTime(30 * 1000).SetLogger(logger.GetLogger()).SetDebug(true)\n\tclient.SetHeader(\"Content-Type\", \"application/octet-stream\")\n\tclient.SetHeader(\"Accept\", \"*/*\")\n\tclient.SetHeader(\"Connection\", \"keep-alive\")\n\tclient.SetHeader(\"Content-Length\", strconv.FormatInt(totalSize, 10))\n\tclient.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", totalSize-1, totalSize))\n\n\tfor i := int64(0); i < chunkNum; i++ {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn fmt.Errorf(\"canceled\")\n\t\tdefault:\n\t\t\tstart := chunkSize * i\n\t\t\tend := chunkSize*(i+1) - 1\n\t\t\tif end > totalSize {\n\t\t\t\tend = totalSize\n\t\t\t}\n\n\t\t\tlog.Info(\"upload chunk\", zap.Int64(\"start\", start), zap.Int64(\"end\", end))\n\n\t\t\tchunk, err := stream.GetSectionReader(start, end)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tresp, err := client.R().SetContext(ctx).SetBody(chunk).Put(url)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif resp.StatusCode() != http.StatusOK && resp.StatusCode() != http.StatusCreated {\n\t\t\t\treturn fmt.Errorf(\"upload", "CodeBleu_score": 44.393069793600944}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tlogger.Info(\"chunkUpload\", zap.String(\"url\", url))\n\n\t// Get the file size\n\tfileSize, err := stream.GetSize()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Calculate the chunk size\n\tchunkSize := int64(1024 * 1024 * 5) // 5 MB\n\tnumChunks := (fileSize + chunkSize - 1) / chunkSize\n\n\t// Create a progress bar\n\tbar := utils.NewProgressBar(int(numChunks))\n\n\t// Initialize the offset\n\toffset := int64(0)\n\n\t// Loop through the chunks and upload each one\n\tfor i := int64(0); i < numChunks; i++ {\n\t\t// Check if the context has been cancelled\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Calculate the chunk start and end offsets\n\t\tchunkStart := offset\n\t\tchunkEnd := chunkStart + chunkSize - 1\n\t\tif chunkEnd > fileSize-1 {\n\t\t\tchunkEnd = fileSize - 1\n\t\t}\n\n\t\t// Create a new HTTP request\n\t\treq, err := http.NewRequestWithContext(ctx, \"PUT\", url, stream)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the request headers\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\treq.Header.Set(\"Content-Length\", strconv.FormatInt(chunkEnd-chunkStart+1, 10))\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", chunkStart, chunkEnd, fileSize))\n\n\t\t// Send the request\n\t\tresp, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// Check the response status code\n\t\tif resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {\n\t\t", "CodeBleu_score": 45.25307956895749}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tmountPoint := ctx.Param(\"mount_point\")\n\tif mountPoint == \"\" {\n\t\treturn httper.NewError(common_err.INVALID_FORM, nil)\n\t}\n\n\tif strings.Contains(mountPoint, \"dropbox\") {\n\t\terr := dropbox.UnmountStorage(mountPoint)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"unmount dropbox error\", zap.Error(err))\n\t\t\treturn httper.NewError(common_err.SERVICE_ERROR, nil)\n\t\t}\n\t}\n\n\tif strings.Contains(mountPoint, \"onedrive\") {\n\t\terr := onedrive.UnmountStorage(mountPoint)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"unmount onedrive error\", zap.Error(err))\n\t\t\treturn httper.NewError(common_err.SERVICE_ERROR, nil)\n\t\t}\n\t}\n\n\tif strings.Contains(mountPoint, \"google\") {\n\t\terr := google_drive.UnmountStorage(mountPoint)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"unmount google drive error\", zap.Error(err))\n\t\t\treturn httper.NewError(common_err.SERVICE_ERROR, nil)\n\t\t}\n\t}\n\n\tservice.MyService.Storage().DeleteStorage(mountPoint)\n\n\treturn httper.NewResponse(nil)\n}", "CodeBleu_score": 43.48409115338263}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req model.UnmountStorageReq\n\n\tif err := ctx.Bind(&req); err != nil {\n\t\tmessage := \"Unable to unmount storage.\"\n\t\tlogger.Error(message, zap.Any(\"error\", err))\n\t\treturn ctx.JSON(common_err.ClientError.Code, common_err.ClientError.Message)\n\t}\n\n\tmountPoint := req.MountPoint\n\n\tif mountPoint == \"\" {\n\t\tmessage := \"Mount point cannot be empty.\"\n\t\tlogger.Error(message)\n\t\treturn ctx.JSON(common_err.ClientError.Code, message)\n\t}\n\n\tif strings.HasPrefix(mountPoint, \"/media\") {\n\t\tumountErr := service.MyService.Storage().UmountStorage(mountPoint)\n\t\tif umountErr != nil {\n\t\t\tmessage := \"Unable to unmount storage.\"\n\t\t\tlogger.Error(message, zap.Any(\"error\", umountErr))\n\t\t\treturn ctx.JSON(common_err.ClientError.Code, common_err.ClientError.Message)\n\t\t}\n\t} else {\n\t\tmessage := \"Invalid mount point.\"\n\t\tlogger.Error(message)\n\t\treturn ctx.JSON(common_err.ClientError.Code, message)\n\t}\n\n\tservice.MyService.Storage().DeleteStorage(mountPoint)\n\n\treturn ctx.JSON(common_err.SUCCESS, common_err.GetMsg(common_err.SUCCESS))\n}", "CodeBleu_score": 44.17954479920695}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req model.Req\n\tif err := ctx.Bind(&req); err != nil {\n\t\tlogger.Error(\"bind req error\", zap.Any(\"err\", err.Error()))\n\t\treturn httper.NewError(common_err.INVALID_FORM)\n\t}\n\n\tmountPoint := req.MountPoint\n\tif mountPoint == \"\" {\n\t\treturn httper.NewError(common_err.INVALID_FORM)\n\t}\n\n\t// check if the mount point is valid\n\tif !strings.HasPrefix(mountPoint, \"/media\") {\n\t\treturn httper.NewError(common_err.INVALID_FORM)\n\t}\n\n\tstorage, err := service.MyService.Storage().Driver(mountPoint)\n\tif err != nil {\n\t\treturn httper.NewError(common_err.STORAGE_NOT_EXIST)\n\t}\n\n\tswitch storage.Driver {\n\tcase \"local\":\n\t\treturn httper.NewError(common_err.OPERATION_NOT_PERMITTED)\n\tcase \"dropbox\":\n\t\tdropbox.MyDropbox.Unmount(mountPoint)\n\tcase \"onedrive\":\n\t\tonedrive.MyOnedrive.Unmount(mountPoint)\n\tcase \"google_drive\":\n\t\tgoogle_drive.MyGoogleDrive.Unmount(mountPoint)\n\tdefault:\n\t\treturn httper.NewError(common_err.STORAGE_NOT_EXIST)\n\t}\n\n\tservice.MyService.Storage().Delete(mountPoint)\n\n\treturn httper.Ok(ctx, nil)\n}", "CodeBleu_score": 42.32888538472975}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: common_err.GetLocalFileError, Data: filePath})\n\t}\n\n\tif !file.IsExist(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: common_err.GetLocalFileError, Data: filePath})\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 46.71990467267372}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(common_err.INVALID_FORM)\n\t}\n\n\tif !file.IsExist(filePath) {\n\t\treturn ctx.JSON(common_err.FILE_NOT_EXIST)\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 30.985767521020136}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"file_path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"file_path is empty\"})\n\t}\n\n\tif !file.IsExist(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"file not exist\"})\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 41.2162684381955}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.INVALID_PARAMS)\n\t}\n\n\tservice.MyService.Notify().SendNotify(name, message)\n\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: message})\n}", "CodeBleu_score": 72.36180333534847}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\n\tif err := ctx.Bind(&message); err != nil {\n\t\tmessage := common_err.GetErrBind(err)\n\t\tc := common_err.ERROR_COMMON_PARSE_BODY\n\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: c.Code, Message: c.Msg, Data: message})\n\t}\n\n\tservice.MyService.Notify().SendNotify(name, message)\n\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: common_err.SUCCESS.Code, Message: common_err.SUCCESS.Msg})\n}", "CodeBleu_score": 73.30608525732997}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\n\tif err := ctx.Bind(&message); err != nil {\n\t\tmessage := common_err.GetErrMessage(err)\n\t\treturn ctx.JSON(http.StatusInternalServerError, model.Result{Success: 0, Message: message})\n\t}\n\n\tservice.MyService.Notify().SendNotify(name, message)\n\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: 1, Message: \"success\"})\n}", "CodeBleu_score": 63.804196695290294}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tupgrader := websocket.Upgrader{}\n\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tservice.MyService.NotifyWSManager.AddConnection(conn)\n\n\t// Ensure that the message sending service is running\n\tgo service.MyService.NotifyWSManager.SendMessage()\n\n\t// Continuously read messages from the WebSocket connection\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Received message:\", string(message))\n\t}\n\n\t// Remove the WebSocket connection from the list of connections\n\tservice.MyService.NotifyWSManager.RemoveConnection(conn)\n\treturn nil\n}", "CodeBleu_score": 40.78735427006334}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer ws.Close()\n\n\tconn := &types.Connection{\n\t\tConn: ws,\n\t}\n\n\tservice.MyService.Notify().AddConn(conn)\n\n\tif !service.MyService.Notify().IsRunning() {\n\t\tgo service.MyService.Notify().SendMsg()\n\t}\n\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Printf(\"recv: %s\", message)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.60911151979057}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupgrader := websocket.Upgrader{}\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tnotify := service.MyService.Notify()\n\tnotify.AddConn(ws)\n\n\tif !service.MyService.Notify().IsMessageSenderRunning() {\n\t\tgo service.MyService.Notify().SendMessages()\n\t}\n\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"%s\n\", message)\n\t}\n\n\treturn ctx.JSON(http.StatusOK, types.ResultOK)\n}", "CodeBleu_score": 43.174728240914405}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar result model.Result\n\tresult.Success = true\n\n\tvar info = model2.HardwareInfo{\n\t\tHardwareDisk: []model2.Disk{},\n\t\tHardwareCPU:  []model2.CPU{},\n\t}\n\n\tdriveInfo := utils.GetCMDOutput(\"smartctl\", []string{\"-i\", \"/dev/sda\"}, \",\")\n\tdriveInfo = strings.ReplaceAll(driveInfo, \" \", \"\")\n\n\tinfo.HardwareDisk = append(info.HardwareDisk, model2.Disk{\n\t\tModel:      gjson.Get(driveInfo, \"model_family\").String(),\n\t\tSerial:     gjson.Get(driveInfo, \"serial_number\").String(),\n\t\tSmart:      gjson.Get(driveInfo, \"ata_version#string\").String(),\n\t\tDriver:     gjson.Get(driveInfo, \"transport_id#string\").String(),\n\t\tFileSystem: gjson.Get(driveInfo, \"user_capacity#string\").String(),\n\t})\n\n\tcpuInfo := utils.GetCMDOutput(\"lscpu\", []string{\"-J\"}, \"\")\n\n\tif cpuInfo != \"\" {\n\t\tinfo.HardwareCPU = append(info.HardwareCPU, model2.CPU{\n\t\t\tModel:      gjson.Get(cpuInfo, \"lscpu.0.0.model_name\").String(),\n\t\t\tVendor:     gjson.Get(cpuInfo, \"lscpu.0.0.vendor_id\").String(),\n\t\t\tCores:      gjson.Get(cpuInfo, \"lscpu.0.0.core_count\").String(),\n\t\t\tClockSpeed: gjson.Get(cpuInfo, \"lscpu.0.0.mhz\").String(),\n\t\t})\n\t}\n\n\tresult.Data = info\n\n\treturn ctx.JSON(http.StatusOK, result)\n}", "CodeBleu_score": 24.109725542129638}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tresult := &model.Result{\n\t\tSuccess: true,\n\t\tMessage: \"success\",\n\t\tData:    nil,\n\t}\n\n\tdriveInfo := service.MyService.Hardware().GetDrive()\n\tcpuInfo := service.MyService.Hardware().GetCPU()\n\n\tresult.Data = map[string]interface{}{\n\t\t\"drive\": driveInfo,\n\t\t\"cpu\":   cpuInfo,\n\t}\n\n\treturn ctx.JSON(http.StatusOK, result)\n}", "CodeBleu_score": 32.23469864702446}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tresult := model.Result{Success: true, Message: \"success\", Data: nil}\n\n\tdriveModel, driveArchitecture := utils.GetDriveModelAndArchitecture()\n\tresult.Data = map[string]interface{}{\n\t\t\"drive_model\":      driveModel,\n\t\t\"drive_architecture\": driveArchitecture,\n\t}\n\n\tif cpuInfo, err := utils.GetCPUInfo(); err == nil {\n\t\tresult.Data = map[string]interface{}{\n\t\t\t\"drive_model\":      driveModel,\n\t\t\t\"drive_architecture\": driveArchitecture,\n\t\t\t\"cpu_info\":         cpuInfo,\n\t\t}\n\t}\n\n\treturn ctx.JSON(http.StatusOK, result)\n}", "CodeBleu_score": 28.01253552064721}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 79.59633022603168}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 79.59633022603168}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 79.59633022603168}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tdata, err := json2.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"send notify failed\", zap.Any(\"error\", err))\n\t\treturn\n\t}\n\n\terr = i.publisher.Publish(name, data)\n\tif err != nil {\n\t\tlogger.Error(\"send notify failed\", zap.Any(\"error\", err))\n\t}\n\n\tresponse, err := http.Get(fmt.Sprintf(\"http://localhost:%d/%s\", types.ServerPort, name))\n\tif err != nil {\n\t\tlogger.Error(\"send notify failed\", zap.Any(\"error\", err))\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"send notify failed\", zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 44.11863764401084}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tdata, _ := json2.Marshal(message)\n\ti.Bus.Publish(name, data)\n}", "CodeBleu_score": 10.971502676630246}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tdata, _ := json2.Marshal(message)\n\ti.Bus.Publish(name, data)\n}", "CodeBleu_score": 10.971502676630246}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient, _ := message_bus.NewClientWithResponses(c.RuntimePath + \"/config\")\n\tif client.Server != \"\" {\n\t\tclient.Server = c.GetConfig().ServerInfo.Server\n\t} else {\n\t\tclient.Server = \"error\"\n\t}\n\treturn client\n}", "CodeBleu_score": 34.20493723333829}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient, err := message_bus.NewClientWithResponses(c.RuntimePath + \"/\" + config.MessageBusAddressFileName)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\taddress, err := external.GetMessageBusAddress(c.RuntimePath)\n\tif err != nil {\n\t\tclient.Server = \"error\"\n\t} else {\n\t\tclient.Server = address\n\t}\n\n\treturn client\n}", "CodeBleu_score": 57.9391551563456}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient, _ := message_bus.NewClientWithResponses(c.RuntimePath)\n\taddress, err := external.GetMessageBusAddress(c.RuntimePath)\n\tif err != nil {\n\t\tclient.Server = \"error\"\n\t} else {\n\t\tclient.Server = address\n\t}\n\n\treturn client\n}", "CodeBleu_score": 56.198472898606745}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\t// \u5c1d\u8bd5\u4ece X-Forwarded-For \u8bf7\u6c42\u5934\u4e2d\u83b7\u53d6 IP \u5730\u5740\n\txForwardedFor := request.Header.Get(\"x-forwarded-for\")\n\tif xForwardedFor != \"\" {\n\t\tips := strings.Split(xForwardedFor, \",\")\n\t\tif len(ips) > 0 {\n\t\t\tip := strings.TrimSpace(ips[0])\n\t\t\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\t\t\treturn \"127.0.0.1\"\n\t\t\t}\n\t\t\treturn ip\n\t\t}\n\t}\n\n\t// \u5982\u679c X-Forwarded-For \u8bf7\u6c42\u5934\u4e0d\u5b58\u5728\uff0c\u5219\u4ece\u8bf7\u6c42\u7684\u8fdc\u7a0b\u5730\u5740\u4e2d\u83b7\u53d6 IP \u5730\u5740\n\tremoteAddr := request.RemoteAddr\n\tip, _, err := net.SplitHostPort(remoteAddr)\n\tif err != nil {\n\t\treturn remoteAddr\n\t}\n\n\t// \u5982\u679c IP \u5730\u5740\u662f\u73af\u56de\u5730\u5740 ::1 \u6216 ::ffff:127.0.0.1\uff0c\u5219\u5c06\u5176\u8f6c\u6362\u4e3a 127.0.0.1\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 43.3310249866891}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip != \"\" && !strings.Contains(ip, \"127.0.0.1\") {\n\t\tip = strings.Split(ip, \",\")[0]\n\t} else {\n\t\tip = request.RemoteAddr\n\t\tif strings.Contains(ip, \"::ffff:\") {\n\t\t\tip = strings.Split(ip, \":\")[0]\n\t\t}\n\t}\n\treturn ip\n}", "CodeBleu_score": 52.19529944350177}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\n\tip = strings.Split(ip, \":\")[0]\n\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = strings.TrimPrefix(ip, \"::ffff:\")\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 60.98417420197514}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesDir := filepath.Join(config.AppInfo.AppPath, \"modules\")\n\tentryFilePath := filepath.Join(config.AppInfo.AppPath, \"entry.json\")\n\n\tif !file.IsExist(entryFilePath) {\n\t\tfile.WriteFile(entryFilePath, []byte(\"[]\"))\n\t}\n\n\tmodules, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlogger.Error(\"read modules dir failed\", zap.Error(err))\n\t\treturn\n\t}\n\n\tvar entries []string\n\n\tfor _, module := range modules {\n\t\tif !module.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tentryFile := filepath.Join(modulesDir, module.Name(), \"entry.json\")\n\t\tif !file.IsExist(entryFile) {\n\t\t\tcontinue\n\t\t}\n\n\t\tcontent, err := file.ReadFile(entryFile)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"read entry file failed\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, string(content))\n\t}\n\n\tentry := \"[\" + strings.Join(entries, \",\") + \"]\"\n\n\terr = file.WriteFile(entryFilePath, []byte(entry))\n\tif err != nil {\n\t\tlogger.Error(\"write entry file failed\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 57.18290174196503}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmoduleDir := filepath.Join(common.Conf.RuntimePath, \"modules\")\n\tentryFile := filepath.Join(moduleDir, \"entry.json\")\n\n\tif !file.IsExist(moduleDir) {\n\t\treturn\n\t}\n\n\tif !file.IsExist(entryFile) {\n\t\tfile.CreateFile(entryFile)\n\t}\n\n\tentryList := make([]string, 0)\n\n\tfilepath.Walk(moduleDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif info.IsDir() && info.Name() != \"modules\" {\n\t\t\tentryFile := filepath.Join(path, \"entry.json\")\n\t\t\tif file.IsExist(entryFile) {\n\t\t\t\tentryList = append(entryList, entryFile)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tentryListJSON := make([]model.Entry, 0)\n\tfor _, entry := range entryList {\n\t\tcontent, err := os.ReadFile(entry)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to read entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tvar entryList []model.Entry\n\t\terr = json.Unmarshal(content, &entryList)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to unmarshal entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tentryListJSON = append(entryListJSON, entryList...)\n\t}\n\n\tentryListJSONBytes, err := json.Marshal(entryListJSON)\n\tif err != nil {\n\t\tlogger.Error(\"failed to marshal entry list\", zap.Error(err))\n\t\treturn\n\t}\n\n\terr = os.WriteFile(entryFile, entryListJSONBytes, 0644)\n\tif err != nil {\n\t\tlogger.Error(\"failed to write entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.31266251197724}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulePath := filepath.Join(common.RuntimePath, \"modules\")\n\tentryPath := filepath.Join(common.RuntimePath, \"entry.json\")\n\n\tif !file.IsExist(entryPath) {\n\t\tos.MkdirAll(modulePath, 0o755)\n\t\tos.Create(entryPath)\n\t}\n\n\tdirs, err := os.ReadDir(modulePath)\n\tif err != nil {\n\t\tlogger.Error(\"read dir error\", zap.Any(\"error\", err))\n\t\treturn\n\t}\n\n\tvar entries []gjson.Result\n\tfor _, dir := range dirs {\n\t\tentryPath := filepath.Join(modulePath, dir.Name(), \"entry.json\")\n\t\tif !file.IsExist(entryPath) {\n\t\t\tcontinue\n\t\t}\n\n\t\tcontent, err := os.ReadFile(entryPath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"read file error\", zap.Any(\"error\", err))\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, gjson.ParseBytes(content).Array()...)\n\t}\n\n\tcontent, err := json.Marshal(entries)\n\tif err != nil {\n\t\tlogger.Error(\"marshal error\", zap.Any(\"error\", err))\n\t\treturn\n\t}\n\n\terr = os.WriteFile(entryPath, content, 0o644)\n\tif err != nil {\n\t\tlogger.Error(\"write file error\", zap.Any(\"error\", err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.467786320090056}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net2.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := net2.InterfaceNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, name := range netNames {\n\t\tfor _, i := range interfaces {\n\t\t\tif i.Name == name {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no mac address found\")\n}", "CodeBleu_score": 60.48674974509679}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net2.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := net2.InterfaceNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, name := range netNames {\n\t\tfor _, i := range interfaces {\n\t\t\tif i.Name == name {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"could not find MAC address\")\n}", "CodeBleu_score": 60.291098303248305}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, i := range interfaces {\n\t\tfor _, n := range netNames {\n\t\t\tif i.Name == n.Name {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 64.45988184453465}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\n  int32_t ret = TSDB_CODE_SUCCESS;\n\n  pRequest->ref = 1;\n\n  pTscObj->numOfRequests++;\n\n  if (pTscObj->pAppInfo != NULL) {\n    pTscObj->pAppInfo->numOfRequests++;\n\n    pTscObj->pAppInfo->numOfActiveRequests++;\n  }\n\n  return ret;\n}", "CodeBleu_score": 19.091658502636967}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  int32_t code = TSDB_CODE_SUCCESS;\n\n  if (pTscObj->pAppInfo != NULL) {\n    pTscObj->pAppInfo->numOfRequests++;\n    pTscObj->pAppInfo->currentRequests++;\n  }\n\n  tscTrace(pTscObj, \"register request:%p\", pRequest);\n\n  return code;\n}", "CodeBleu_score": 18.805502649757216}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  int32_t code = TSDB_CODE_SUCCESS;\n\n  // Increment the reference count for the request object\n  taosRefcntInc(pRequest);\n\n  // Increment the request count for the TSC object\n  pTscObj->requestCount++;\n\n  // If the TSC object has application information, update the application's request summary\n  if (pTscObj->pAppInfo != NULL) {\n    pTscObj->pAppInfo->requestCount++;\n    pTscObj->pAppInfo->currentRequestCount++;\n  }\n\n  // Log debug information about the new request\n  LOG_DEBUG(\"register request:%p, tsc:%p, app:%p\", pRequest, pTscObj, pTscObj->pAppInfo);\n\n  return code;\n}", "CodeBleu_score": 30.98208413825666}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (strcmp(pRequest->db, exceptDb) != 0) {\n    int32_t dbNum = pRequest->dbNum;\n    for (int32_t i = 0; i < dbNum; ++i) {\n      if (strcmp(pRequest->dbList[i], exceptDb) == 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}", "CodeBleu_score": 44.360351695364706}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (strcmp(pRequest->db, exceptDb) != 0) {\n        int32_t numDb = pRequest->numDb;\n        for (int32_t i = 0; i < numDb; ++i) {\n            char *db = pRequest->dbList[i];\n            if (strcmp(db, exceptDb) == 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 48.88722180772743}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->db != exceptDb) {\n    return true;\n  }\n\n  for (int i = 0; i < pRequest->dbList.num; i++) {\n    char* db = pRequest->dbList.data[i];\n    char* ptr = strchr(db, '.');\n    if (ptr != NULL) {\n      db = ptr + 1;\n    }\n    if (strcmp(db, exceptDb) != 0) {\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 60.65709740192864}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  if (code == TSDB_CODE_RPC_REDIRECT_MSG) {\n    if (msgType == TSDB_MSG_TYPE_INSERT_STRINGS || msgType == TSDB_MSG_TYPE_INSERT_BLOCKS ||\n        msgType == TSDB_MSG_TYPE_INSERT_RECORDS || msgType == TSDB_MSG_TYPE_INSERT_ROWS ||\n        msgType == TSDB_MSG_TYPE_INSERT_TABLE_DATA || msgType == TSDB_MSG_TYPE_INSERT_TABLE_DATA_BLOCKS) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 61.688186928302656}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == TSDB_CODE_RPC_REDIRECT_ERROR) {\n        return true;\n    }\n\n    if (msgType == TSDB_MSG_TYPE_INSERT_STRINGS || msgType == TSDB_MSG_TYPE_INSERT_NCHARS || msgType == TSDB_MSG_TYPE_INSERT_BINARY || msgType == TSDB_MSG_TYPE_INSERT_BLOCK || msgType == TSDB_MSG_TYPE_INSERT_TABLE || msgType == TSDB_MSG_TYPE_INSERT_TABLE_DATA || msgType == TSDB_MSG_TYPE_INSERT_TABLE_DATA_BLOCK) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 57.231592123942576}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  if (code == TSDB_CODE_REDIRECT_META) {\n    if (msgType == TSDB_MSG_TYPE_MNODE_CREATE) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_DROP) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_UPDATE) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_GET) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_SNAPSHOT) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_STREAM) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_STREAMS) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_STREAM_METRICS) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_STREAM_TAGS) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_STREAM_TAG_VALUES) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_STREAM_METRIC_TAGS) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_STREAM_METRIC_TAG_VALUES) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_STREAM_METRIC_TAG_VALUES_WITH_AGG) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_STREAM_METRIC_TAG_VALUES_WITH_AGG_AND_RANGE) return true;\n    if (msgType == TSDB_MSG_TYPE_MNODE_SHOW_STREAM_METRIC", "CodeBleu_score": 41.15934601836704}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SRequest *pRequest;\n  SHashObj *pHashObj;\n  SHashObj *pNext;\n\n  pHashObj = pRequests->next;\n  while (pHashObj != NULL) {\n    pNext = pHashObj->next;\n\n    pRequest = (SRequest *)pHashObj->pObj;\n    if (pRequest->pQuery != NULL) {\n      stopQuery(pRequest->pQuery);\n    }\n\n    taosReqRelease(pRequest);\n\n    pHashObj = pNext;\n  }\n}", "CodeBleu_score": 45.96648532821539}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SRequest *pRequest;\n  int32_t    requestId;\n\n  requestId = taosHashIterate(pRequests, (void **)&pRequest);\n  while (requestId >= 0) {\n    if (pRequest->qhandle != NULL) {\n      stopQuery(pRequest->qhandle);\n    }\n    tfree(pRequest);\n    taosHashRemove(pRequests, &requestId, NULL);\n    requestId = taosHashIterate(pRequests, (void **)&pRequest);\n  }\n}", "CodeBleu_score": 45.67038451663098}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SRequest *pRequest;\n\n  if (pRequests == NULL) return;\n\n  pRequest = (SRequest *)taosHashFirst(pRequests);\n  while (pRequest != NULL) {\n    SRequest *pNext = (SRequest *)taosHashNext(pRequests);\n\n    if (pRequest->pQuery != NULL) {\n      taosStopQuery(pRequest->pQuery);\n    }\n\n    taosReqRelease(pRequest);\n    pRequest = pNext;\n  }\n}", "CodeBleu_score": 42.074715709039566}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t    if (client->crashReport == false) {\n        return;\n    }\n\n    if (atomic_compare_exchange_strong(&client->clientStop, &client->clientStop, 1) == false) {\n        taosLog(\"Crash report thread is already stopped\");\n        return;\n    }\n\n    while (client->clientStop != 0) {\n        taosSleep(1);\n    }\n}", "CodeBleu_score": 59.31568444505574}, {"code": "void tscStopCrashReport(){\n\t    if (gClientStop == 0) {\n        return;\n    }\n\n    if (atomic_compare_exchange_strong(&gClientStop, 0, 1) == false) {\n        log_warn(\"crash report thread is already stopped\");\n        return;\n    }\n\n    while (gClientStop != 0) {\n        osSleep(1);\n    }\n}", "CodeBleu_score": 55.63068838354113}, {"code": "void tscStopCrashReport(){\n\t    if (!gClientStop) {\n        gClientStop = 1;\n        while (gClientStop) {\n            osSleep(1);\n        }\n    } else {\n        log_warn(\"crash report thread is already stopped\");\n    }\n}", "CodeBleu_score": 38.966805027528984}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t ret = 0;\n    SViewInfo *pViewInfo = (SViewInfo *)value;\n    if (pViewInfo == NULL) {\n        return TSDB_CODE_CLI_INVALID_PARAMETER;\n    }\n\n    int32_t viewCount = pViewInfo->viewCount;\n    int32_t i;\n    for (i = 0; i < viewCount; ++i) {\n        SViewMeta *pViewMeta = &pViewInfo->viewMeta[i];\n        if (pViewMeta->numOfColumns > 0) {\n            ret = tscUpdateView(pCatalog, pViewMeta);\n        } else {\n            ret = tscDropView(pCatalog, pViewMeta->name);\n        }\n        if (ret != TSDB_CODE_SUCCESS) {\n            return ret;\n        }\n    }\n\n    tfree(pViewInfo);\n    return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 40.054073794734194}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t ret;\n    SViewMeta *pViewMeta = (SViewMeta *)value;\n    int32_t numViews = valueLen / sizeof(SViewMeta);\n    int32_t i;\n\n    for (i = 0; i < numViews; i++) {\n        if (pViewMeta[i].numColumns > 0) {\n            ret = catalogUpdateViewMeta(pCatalog, &pViewMeta[i]);\n            if (ret != 0) {\n                return ret;\n            }\n        } else {\n            ret = catalogRemoveViewMeta(pCatalog, pViewMeta[i].viewName);\n            if (ret != 0) {\n                return ret;\n            }\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 28.60756402665262}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t ret = 0;\n    int32_t i;\n    int32_t count;\n    int32_t columnCount;\n    struct SViewMeta *pViewMeta;\n    struct SViewMeta *pViewMetaNew;\n    struct SViewMeta *pViewMetaOld;\n    struct SViewMeta *pViewMetaTemp;\n    struct SViewMeta *pViewMetaList;\n    struct SViewMeta *pViewMetaListOld;\n    struct SViewMeta *pViewMetaListNew;\n    struct SViewMeta *pViewMetaListTemp;\n    struct SViewMeta *pViewMetaListTemp2;\n    struct SViewMeta *pViewMetaListTemp3;\n    struct SViewMeta *pViewMetaListTemp4;\n    struct SViewMeta *pViewMetaListTemp5;\n    struct SViewMeta *pViewMetaListTemp6;\n    struct SViewMeta *pViewMetaListTemp7;\n    struct SViewMeta *pViewMetaListTemp8;\n    struct SViewMeta *pViewMetaListTemp9;\n    struct SViewMeta *pViewMetaListTemp10;\n    struct SViewMeta *pViewMetaListTemp11;\n    struct SViewMeta *pViewMetaListTemp12;\n    struct SViewMeta *pViewMetaListTemp13;\n    struct SViewMeta *pViewMetaListTemp14;\n    struct SViewMeta *pViewMetaListTemp15;\n    struct SViewMeta *pViewMetaListTemp16;\n    struct SViewMeta *pViewMetaListTemp17;\n    struct SViewMeta *pViewMetaListTemp18;\n    struct SViewMeta *pViewMetaListTemp19;\n    struct SViewMeta *pViewMetaListTemp20;\n    struct SViewMeta *pViewMetaListTemp21;\n    struct SViewMeta *pViewMetaListTemp22;\n    struct SViewMeta *pViewMetaListTemp23;\n    struct SViewMeta *pViewMetaListTemp24;\n    struct SViewMeta *pViewMetaListTemp25;\n    struct SViewMeta *pViewMetaListTemp26;\n    struct SViewMeta *pView", "CodeBleu_score": 9.737355889998268}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    GET_CONTENT_LENGTH_CALLBACK_DATA *callbackDataCast = (GET_CONTENT_LENGTH_CALLBACK_DATA *)callbackData;\n\n    if (properties->contentLength > 0) {\n        callbackDataCast->contentLength = properties->contentLength;\n    } else {\n        callbackDataCast->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 72.55360596286154}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n\n    if (properties->getContentLength() > 0) {\n        ((CosResponseProperties *) callbackData)->contentLength = properties->getContentLength();\n    } else {\n        ((CosResponseProperties *) callbackData)->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 55.795065107006614}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    GET_CONTENT_LENGTH_CALLBACK_DATA *callbackDataCast = (GET_CONTENT_LENGTH_CALLBACK_DATA *)callbackData;\n\n    if (properties->getContentLengthResult.contentLength > 0) {\n        callbackDataCast->contentLength = properties->getContentLengthResult.contentLength;\n    } else {\n        callbackDataCast->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 56.64697978805112}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t    // Create the checkpoint backup directory\n    int createDir = system(\"mkdir -p /home/ubuntu/checkpoint_backup\");\n    if (createDir != 0) {\n        // Log an error if the directory creation fails\n        logError(\"Failed to create the checkpoint backup directory.\");\n    }\n\n    // Remove empty directories\n    system(\"find /home/ubuntu/checkpoint_backup -type d -empty -delete\");\n\n    // Generate the Rsync configuration file\n    FILE* configFile = fopen(\"/home/ubuntu/rsyncd.conf\", \"w\");\n    if (configFile == NULL) {\n        // Log an error if the configuration file generation fails\n        logError(\"Failed to generate the Rsync configuration file.\");\n        return;\n    }\n\n    // Write the configuration file contents\n    fprintf(configFile, \"port = 873", "CodeBleu_score": 17.50852923648809}, {"code": "void startRsync(){\n\t    int rsyncPort = getRsyncPort();\n    char *checkpointDir = getCheckpointDir();\n\n    // Create the checkpoint backup directory\n    int checkpointDirCreated = createDir(checkpointDir);\n    if (checkpointDirCreated != 0) {\n        logError(\"Error creating checkpoint backup directory: %s\", checkpointDir);\n        return;\n    }\n\n    // Remove empty directories\n    removeEmptyDirectories(checkpointDir);\n\n    // Generate Rsync configuration file\n    int configFileGenerated = generateRsyncConfigFile(checkpointDir);\n    if (configFileGenerated != 0) {\n        logError(\"Error generating Rsync configuration file\");\n        return;\n    }\n\n    // Construct Rsync command\n    char rsyncCommand[256];\n    snprintf(rsyncCommand, sizeof(rsyncCommand), \"rsync --daemon --port=%d --config=%s/rsyncd.conf\", rsyncPort, checkpointDir);\n\n    // Start Rsync daemon\n    int rsyncStarted = system(rsyncCommand);\n    if (rsyncStarted == 0) {\n        logInfo(\"Rsync server started successfully\");\n    } else {\n        logError(\"Error starting Rsync server\");\n    }\n}", "CodeBleu_score": 31.261668531400172}, {"code": "void startRsync(){\n\t    int ret;\n\n    ret = system(\"mkdir -p /var/lib/pgsql/checkpoint\");\n    if (ret != 0) {\n        log_error(\"Error creating checkpoint directory: %d\", ret);\n        return;\n    }\n\n    ret = system(\"find /var/lib/pgsql/checkpoint -type d -empty -delete\");\n    if (ret != 0) {\n        log_error(\"Error deleting empty directories in checkpoint directory: %d\", ret);\n        return;\n    }\n\n    ret = generateRsyncConfig();\n    if (ret != 0) {\n        log_error(\"Error generating Rsync configuration file: %d\", ret);\n        return;\n    }\n\n    ret = system(\"rsync --daemon --port=873 --config=/etc/rsyncd.conf\");\n    if (ret != 0) {\n        log_error(\"Error starting Rsync daemon: %d\", ret);\n    } else {\n        log_info(\"Rsync daemon started successfully\");\n    }\n}", "CodeBleu_score": 32.21740788462628}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t        Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n        if (dispatcher != null) {\n            dispatcher.shutdownNow();\n        } else {\n            throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n        }\n    }", "CodeBleu_score": 72.92201762124002}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.shutdown();\n        dispatchers.remove(dispatcherId);\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n    }\n}", "CodeBleu_score": 68.45892913877533}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.executor.shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n    }\n}", "CodeBleu_score": 73.45021531335023}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Set<TbActorId> children = parentChildren.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                if (actorSystemContext.isActorRegistered(child)) {\n                    if (highPriority) {\n                        actorSystemContext.send(child, msg.withHighPriorityFlag());\n                    } else {\n                        actorSystemContext.send(child, msg);\n                    }\n                } else {\n                    log.warn(\"[{}] Failed to send message to child actor [{}] due to it is not registered\", parent, child);\n                }\n            });\n        }\n    }", "CodeBleu_score": 48.8062705952618}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Set<TbActorId> children = childrenMap.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                TbActorRef childRef = actorSystem.get(child);\n                if (childRef != null) {\n                    if (highPriority) {\n                        childRef.tellWithHighPriority(msg);\n                    } else {\n                        childRef.tell(msg);\n                    }\n                } else {\n                    log.warn(\"[{}] Failed to find actor [{}]\", parent, child);\n                }\n            });\n        }\n    }", "CodeBleu_score": 50.69260186553039}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Set<TbActorId> children = getChildren(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                if (child != null) {\n                    if (highPriority) {\n                        send(child, msg.withHighPriorityFlag());\n                    } else {\n                        send(child, msg);\n                    }\n                } else {\n                    log.warn(\"[{}] Failed to send msg: {} to child: {}\", getName(), msg, child);\n                }\n            });\n        }\n    }", "CodeBleu_score": 48.30991162608282}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (msg == null) {\n        return;\n    }\n    if (destructionInProgress.get()) {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (initializationFailed.get()) {\n                log.debug(\"[{}] Reinitializing actor\", getName());\n                reinitialize();\n            }\n        } else {\n            log.debug(\"[{}] Notifying message that actor has stopped: {}\", getName(), msg);\n            msg.onActorStopped(this);\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    }\n}", "CodeBleu_score": 56.371370137298946}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && !highPriority) {\n        log.debug(\"[{}] Skipping low priority RULE_NODE_UPDATED_MSG\", getName());\n        return;\n    }\n    if (!destructionInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processMsgsQueue();\n    } else if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n        if (initializationFailed.get()) {\n            log.debug(\"[{}] Reinitializing actor\", getName());\n            initActor(false);\n        }\n    } else {\n        msg.onTbActorStopped(this);\n    }\n}", "CodeBleu_score": 59.74660289419557}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destructionInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    } else if (msg.getMsgType().equals(MsgType.RULE_NODE_UPDATED_MSG)) {\n        if (highPriority) {\n            if (initializationFailed.get()) {\n                log.info(\"[{}] Actor reinitialization is in progress\", getActorId());\n                reinitialize();\n            } else {\n                log.info(\"[{}] Actor reinitialization is not required\", getActorId());\n            }\n        } else {\n            log.info(\"[{}] Actor is not reinitialized, notifying message\", getActorId());\n            msg.onActorStopped(getActorId(), TbActorStopReason.ACTOR_DESTROYED);\n        }\n    } else {\n        log.info(\"[{}] Actor is not reinitialized, notifying message\", getActorId());\n        msg.onActorStopped(getActorId(), TbActorStopReason.ACTOR_DESTROYED);\n    }\n}", "CodeBleu_score": 52.20444429825428}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    long startTime = System.currentTimeMillis();\n    int processedMessages = 0;\n    while (processedMessages < throughputLimit && !highPriorityQueue.isEmpty() || !normalPriorityQueue.isEmpty()) {\n        TbActorMsg msg = highPriorityQueue.poll();\n        if (msg == null) {\n            msg = normalPriorityQueue.poll();\n        }\n        try {\n            process(msg);\n            processedMessages++;\n        } catch (TbActorError e) {\n            if (e.getReason() == TbActorStopReason.INIT_FAILURE) {\n                setStopReason(e.getReason());\n                destroy();\n            }\n        } catch (Exception e) {\n            log.error(\"[{}] Failed to process message: {}\", getName(), msg, e);\n            if (processFailureStrategy.apply(e)) {\n                setStopReason(TbActorStopReason.FAILURE);\n                destroy();\n            }\n        }\n    }\n    if (processedMessages > 0) {\n        setStatus(TbActorStatus.FREE);\n    }\n    long endTime = System.currentTimeMillis();\n    long elapsedTime = endTime - startTime;\n    long sleepTime = throughputLimit > 0 ? TimeUnit.SECONDS.toMillis(1) / throughputLimit - elapsedTime : 0;\n    if (sleepTime > 0) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(sleepTime);\n        } catch (InterruptedException e) {\n            log.error(\"[{}] Mailbox processing interrupted\", getName(), e);\n        }\n    }\n    scheduleQueueProcessing();\n}", "CodeBleu_score": 41.08492388682453}, {"code": "private void processMailbox(){\n\t    long startTime = System.nanoTime();\n    int processed = 0;\n    int processedHigh = 0;\n    int processedNormal = 0;\n    while (true) {\n        TbActorMsg msg = null;\n        if (highPriorityQueue.size() > 0) {\n            msg = highPriorityQueue.poll();\n            processedHigh++;\n        } else if (normalPriorityQueue.size() > 0) {\n            msg = normalPriorityQueue.poll();\n            processedNormal++;\n        }\n        if (msg != null) {\n            if (msg.getMsgType() == MsgType.INIT_FAILURE) {\n                log.error(\"[{}] Failed to initialize actor: {}\", getName(), msg.getData());\n                stopReason = TbActorStopReason.INIT_FAILURE;\n                destroy();\n                return;\n            } else {\n                try {\n                    process(msg);\n                    processed++;\n                } catch (TbActorError e) {\n                    log.error(\"[{}] Failed to process message: {}\", getName(), e.getMessage());\n                    if (e.getReason() == TbActorStopReason.STOPPED) {\n                        return;\n                    }\n                    if (processFailureStrategy.apply(e)) {\n                        stopReason = e.getReason();\n                        destroy();\n                        return;\n                    }\n                } catch (Exception e) {\n                    log.error(\"[{}] Failed to process message: {}\", getName(), e.getMessage());\n                    if (processFailureStrategy.apply(e)) {\n                        stopReason = TbActorStopReason.PROCESS_FAILURE;\n                        destroy();\n                        return;\n                    }\n                }\n            }\n        } else {\n            break;\n        }\n        if (processed >= throughputLimit) {\n            break;\n        }\n    }\n    long endTime = System.nanoTime();\n    long elapsedTime = endTime - startTime;\n    long timeLeft = TimeUnit.SECONDS.toNanos(1) - elapsedTime;\n    if (timeLeft > 0 && highPriorityQueue.size() > 0) {\n        scheduleQueueProcess", "CodeBleu_score": 37.274568853646336}, {"code": "private void processMailbox(){\n\t    try {\n        long start = System.nanoTime();\n        int processed = 0;\n        boolean hasMoreMessages = true;\n        while (hasMoreMessages) {\n            if (highPriorityQueue.isEmpty()) {\n                if (normalPriorityQueue.isEmpty()) {\n                    hasMoreMessages = false;\n                } else {\n                    TbActorMsg msg = normalPriorityQueue.poll();\n                    processMessage(msg);\n                    processed++;\n                }\n            } else {\n                TbActorMsg msg = highPriorityQueue.poll();\n                processMessage(msg);\n                processed++;\n            }\n            if (processed >= throughputLimit) {\n                break;\n            }\n        }\n        long end = System.nanoTime();\n        long elapsedTime = end - start;\n        long sleepTime = TimeUnit.MILLISECONDS.convert(1000000000L / throughputLimit - elapsedTime, TimeUnit.NANOSECONDS);\n        if (sleepTime > 0) {\n            try {\n                TimeUnit.MILLISECONDS.sleep(sleepTime);\n            } catch (InterruptedException e) {\n                log.warn(\"[{}] Mailbox processing interrupted\", actorId);\n                destroy();\n            }\n        }\n    } finally {\n        if (hasMoreMessages) {\n            scheduleQueueProcessing();\n        } else {\n            status = ActorStatus.FREE;\n        }\n    }\n}", "CodeBleu_score": 35.01623830200683}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (destroyed.compareAndSet(false, true)) {\n        if (stopReason == null) {\n            stopReason = TbActorStopReason.DESTROY;\n        }\n        if (msgQueue != null) {\n            msgQueue.clear();\n        }\n        if (scheduledMsgQueue != null) {\n            scheduledMsgQueue.clear();\n        }\n        if (dispatcher != null) {\n            dispatcher.schedule(new TbActorMsg(getUid(), MsgType.STOP, stopReason, cause));\n        }\n    }\n}", "CodeBleu_score": 33.53416032471918}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason.compareAndSet(null, TbActorStopReason.STOPPED_BY_SYSTEM)) {\n        dispatcher.schedule(this::destroyActor, 0, TimeUnit.MILLISECONDS);\n    }\n}", "CodeBleu_score": 3.759164188359986}, {"code": "public void destroy(Throwable cause){\n\t    if (!isDestroyed.getAndSet(true)) {\n        if (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        dispatcher.getExecutor().schedule(() -> {\n            try {\n                setReady(false);\n                destroy(stopReason, cause);\n                notifyQueuedMessages(TbActorError.newActorStopped(stopReason, cause));\n            } catch (Exception e) {\n                log.warn(\"[{}] Failed to destroy actor: [{}]\", getName(), e);\n            }\n        }, 0, TimeUnit.MILLISECONDS);\n    }\n}", "CodeBleu_score": 47.22520092335305}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId == TenantId.SYS_TENANT_ID) {\n        return true;\n    }\n    TenantProfile profile = getTenantProfile(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    RateLimitsTrigger rateLimitsTrigger = profile.getRateLimitsTrigger();\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits(api);\n    if (rateLimits == null) {\n        return true;\n    }\n    if (rateLimits.checkRateLimit(level)) {\n        return true;\n    }\n    notificationRuleProcessor.process(rateLimitsTrigger, tenantId, api, level);\n    return false;\n}", "CodeBleu_score": 37.75233077543245}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.isSysTenantId()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileService.findTenantProfileById(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimitsTrigger();\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits(api);\n    if (rateLimits == null) {\n        return true;\n    }\n    RateLimitsTrigger.RateLimitConfig rateLimitConfig = rateLimits.getRateLimitConfig(api, level);\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    if (rateLimitConfig.getLimit() == 0) {\n        return true;\n    }\n    RateLimitKey rateLimitKey = new RateLimitKey(tenantId, api, level);\n    RateLimit rateLimit = rateLimitsCache.getIfPresent(rateLimitKey);\n    if (rateLimit == null) {\n        rateLimit = new RateLimit(rateLimitConfig.getLimit(), rateLimitConfig.getDurationMs());\n        rateLimitsCache.put(rateLimitKey, rateLimit);\n    }\n    boolean success = rateLimit.tryAcquire();\n    if (!success) {\n        notificationRuleProcessor.process(tenantId, rateLimitsTrigger.getNotificationRuleId(), api.name() + \" rate limit exceeded\");\n    }\n    return success;\n}", "CodeBleu_score": 58.291424631157106}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId == null || tenantId.isSysTenantId()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileService.findTenantProfileById(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimitsTrigger();\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits(api);\n    if (rateLimits == null) {\n        return true;\n    }\n    boolean result = rateLimits.tryConsume(level);\n    if (!result) {\n        notificationRuleProcessor.process(tenantId, rateLimitsTrigger.getNotificationRuleId(), new RateLimitNotificationMsg(api, tenantId, level));\n    }\n    return result;\n}", "CodeBleu_score": 58.33686016778407}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (ConcurrentMap.Entry<InetSocketAddress, DTLSSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            log.info(\"DTLS session removed due to inactivity timeout: {}\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 52.86437175576173}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (ConcurrentMap.Entry<InetSocketAddress, DtlsSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            log.debug(\"Evicting DTLS session for {}\", entry.getKey());\n            dtlsSessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 53.1817057696122}, {"code": "public void evictTimeoutSessions(){\n\t    long expiration = System.currentTimeMillis() - inactivityTimeout;\n    for (ConcurrentMap.Entry<InetSocketAddress, DTLSSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expiration) {\n            log.debug(\"Evict DTLS session for {}\", entry.getKey());\n            dtlsSessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 52.85753292478622}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!CollectionUtils.isEmpty(timeseries)) {\n        List<TsKvEntry> tsEntries = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                KvEntry kvEntry = parseValue(key, value);\n                tsEntries.add(kvEntry);\n            }\n        }\n        return tsEntries;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 51.93662330583071}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (CollectionUtils.isEmpty(timeseries)) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> tsData = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        List<KvEntry> kvEntries = values.stream().map(value -> {\n            if (value.isBoolean()) {\n                return new BooleanDataEntry(key, value.asBoolean());\n            } else if (value.isNumber()) {\n                return new DoubleDataEntry(key, value.asDouble());\n            } else if (value.isTextual()) {\n                return new StringDataEntry(key, value.asText());\n            } else if (value.isLong()) {\n                return new LongDataEntry(key, value.asLong());\n            } else {\n                return new JsonDataEntry(key, value);\n            }\n        }).collect(Collectors.toList());\n        tsData.addAll(kvEntries);\n    }\n    return tsData;\n}", "CodeBleu_score": 41.427408795082}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (CollectionUtils.isEmpty(timeseries)) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> tsEntries = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        for (JsonNode value : values) {\n            KvEntry kvEntry = null;\n            if (value.isTextual()) {\n                kvEntry = new StringDataEntry(key, value.asText());\n            } else if (value.isNumber()) {\n                kvEntry = new DoubleDataEntry(key, value.asDouble());\n            } else if (value.isBoolean()) {\n                kvEntry = new BooleanDataEntry(key, value.asBoolean());\n            } else if (value.isLong()) {\n                kvEntry = new LongDataEntry(key, value.asLong());\n            } else if (value.isObject()) {\n                kvEntry = new JsonDataEntry(key, value);\n            }\n            if (kvEntry != null) {\n                tsEntries.add(kvEntry);\n            }\n        }\n    }\n    return tsEntries;\n}", "CodeBleu_score": 38.5229416928907}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\"refreshToken\", tokenInfo.getRefreshToken());\n    ResponseEntity<JwtPair> response = restTemplate.postForEntity(\n            baseUrl + \"/api/auth/token\",\n            request,\n            JwtPair.class\n    );\n    tokenInfo.setToken(response.getBody().getToken());\n    tokenInfo.setRefreshToken(response.getBody().getRefreshToken());\n    tokenInfo.setTimestamp(System.currentTimeMillis());\n}", "CodeBleu_score": 55.34598394149799}, {"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\"refreshToken\", tokenInfo.getRefreshToken());\n\n    ResponseEntity<JwtPair> response = restTemplate.postForEntity(\n            URI.create(url + \"/api/auth/token\"),\n            new HttpEntity<>(request, getHeaders(null)),\n            JwtPair.class\n    );\n\n    tokenInfo.setTokenCreationTime(System.currentTimeMillis());\n    tokenInfo.setRefreshToken(response.getBody().getRefreshToken());\n    tokenInfo.setToken(response.getBody().getToken());\n}", "CodeBleu_score": 49.82918327454546}, {"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\"refreshToken\", tokenInfo.getRefreshToken());\n    ResponseEntity<JwtPair> response = restTemplate.postForEntity(getAuthUrl(), request, JwtPair.class);\n    tokenInfo.setToken(response.getBody().getToken());\n    tokenInfo.setRefreshToken(response.getBody().getRefreshToken());\n    tokenInfo.setRefreshTokenTimestamp(System.currentTimeMillis());\n}", "CodeBleu_score": 52.919222007551205}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t     long timestamp = System.currentTimeMillis();\n     Map<String, String> loginRequest = new HashMap<>();\n     loginRequest.put(\"username\", username);\n     loginRequest.put(\"password\", password);\n     ResponseEntity<JwtPair> response = restTemplate.postForEntity(\"/api/auth/login\", loginRequest, JwtPair.class);\n     tokenInfo.update(response.getBody(), timestamp);\n }", "CodeBleu_score": 72.34593128549842}, {"code": " private void doLogin(){\n\t    long currentTimestamp = System.currentTimeMillis();\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n\n    ResponseEntity<JwtPair> response = restTemplate.postForEntity(baseUrl + \"/api/auth/login\", loginRequest, JwtPair.class);\n\n    if (response.getStatusCode() == HttpStatus.OK) {\n        JwtPair jwtPair = response.getBody();\n        tokenInfo.update(jwtPair, currentTimestamp);\n    } else {\n        throw new RuntimeException(\"Login failed: \" + response.getStatusCode());\n    }\n}", "CodeBleu_score": 72.40891464850876}, {"code": " private void doLogin(){\n\t        long timestamp = System.currentTimeMillis();\n        Map<String, Object> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> response = restTemplate.postForEntity(baseUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n        JsonNode responseBody = response.getBody();\n        tokenInfo.update(responseBody, timestamp);\n    }", "CodeBleu_score": 74.55651362813363}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.exchange(\n                baseUrl + \"/api/device/{deviceId}\",\n                HttpMethod.GET,\n                null,\n                Device.class,\n                deviceId\n        );\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 70.5646496919136}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        return Optional.ofNullable(restTemplate.getForObject(getBaseUrl() + \"/api/device/{deviceId}\", Device.class, deviceId));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 49.73073487192979}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 68.6489194614633}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest();\n        request.setDevice(device);\n        request.setCredentials(credentials);\n\n        HttpEntity<SaveDeviceWithCredentialsRequest> requestEntity = new HttpEntity<>(request, getDefaultHeaders());\n        ResponseEntity<Device> response = restTemplate.exchange(baseUrl + \"/api/device-with-credentials\", HttpMethod.POST, requestEntity, Device.class);\n\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 61.234738288233906}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest();\n        request.setDevice(device);\n        request.setCredentials(credentials);\n        return Optional.of(restTemplate.postForObject(baseUrl + \"/api/device-with-credentials\", request, Device.class));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 55.31774194583712}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest(device, credentials);\n        return Optional.of(restTemplate.postForObject(baseUrl + \"/api/device-with-credentials\", request, Device.class));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 62.42610251214591}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t  if (typeof addr === \"number\") {\n    this.brightness(val);\n  } else if (typeof val === \"number\") {\n    this.brightness(addr, val);\n  } else {\n    this.brightness(addr, 0);\n  }\n  return this;\n}", "CodeBleu_score": 39.5572213017913}, {"code": "brightness(addr, val){\n\t  if (val === undefined) {\n    this.brightness = addr;\n    return this;\n  }\n  this.brightness = {\n    [addr]: Math.round(val / 100 * 15)\n  };\n  return this;\n}", "CodeBleu_score": 34.48499029039239}, {"code": "brightness(addr, val){\n\t    if (val === undefined) {\n        this.brightness = addr;\n        return this;\n    }\n    this.brightness[addr] = Math.floor(val * 15 / 100);\n    return this;\n}", "CodeBleu_score": 34.7517145002287}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    let obj = {}\n    for (let key in LedControl.prototype) {\n        obj[key] = LedControl.prototype[key].bind(this, addr)\n    }\n    for (let key in this) {\n        obj[key] = this[key].bind(this, addr)\n    }\n    return obj\n}", "CodeBleu_score": 39.70512279636523}, {"code": "device(addr){\n\t  const obj = {};\n  for (const key of Object.keys(LedControl.prototype)) {\n    const func = LedControl.prototype[key];\n    obj[key] = func.bind(this, addr);\n  }\n  for (const key of Object.keys(this)) {\n    const func = this[key];\n    obj[key] = func.bind(this, addr);\n  }\n  return obj;\n}", "CodeBleu_score": 40.82312848699717}, {"code": "device(addr){\n\t  const bound = {};\n  for (const key of Object.keys(LedControl.prototype)) {\n    if (typeof this[key] === 'function') {\n      bound[key] = this[key].bind(this, addr);\n    }\n  }\n  for (const key of Object.keys(this)) {\n    if (typeof this[key] === 'function') {\n      bound[key] = this[key].bind(this, addr);\n    }\n  }\n  return bound;\n}", "CodeBleu_score": 66.00480758650102}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    for (let method of methods) {\n        target[method] = function(duration = 1000) {\n            const callback = arguments[arguments.length - 1];\n            const promises = [];\n            for (let element of this) {\n                promises.push(new Promise(resolve => {\n                    setTimeout(() => {\n                        element[method]();\n                        resolve();\n                    }, duration);\n                }));\n            }\n            Promise.all(promises).then(callback);\n        }\n    }\n}", "CodeBleu_score": 32.458189882757274}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[method] = function(duration = 1000, callback) {\n      callback = ensureCallback(callback)\n      let promises = this.map(item => {\n        return new Promise(resolve => {\n          setTimeout(() => {\n            item[method]()\n            resolve()\n          }, duration)\n        })\n      })\n      Promise.all(promises).then(callback)\n      return this\n    }\n  })\n}", "CodeBleu_score": 34.04555015856891}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = (duration = 1000, callback) => {\n            callback = callback || (() => {});\n            let promises = [];\n            this.forEach(element => {\n                promises.push(new Promise(resolve => {\n                    setTimeout(() => {\n                        element[method]();\n                        resolve();\n                    }, duration);\n                }));\n            });\n            Promise.all(promises).then(callback);\n        };\n    });\n}", "CodeBleu_score": 31.275126685173245}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t  let input = \"\";\n  this.serialPort.on(\"data\", (data) => {\n    input += data.toString();\n    const sentences = input.split(\"\\r\n\");\n    input = sentences.pop();\n    sentences.forEach((sentence) => {\n      this.parseNmeaSentence(sentence);\n    });\n  });\n}", "CodeBleu_score": 31.521684063503773}, {"code": "listen(){\n\t  let input = \"\";\n  this.serialPort.on(\"data\", (data) => {\n    input += data.toString();\n    const sentences = input.split(\"\\r\n\");\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  });\n}", "CodeBleu_score": 50.80353968290922}, {"code": "listen(){\n\t  let input = '';\n  this.serialPort.on('data', (data) => {\n    input += data.toString();\n    const sentences = input.split('\\r\n');\n    input = sentences.pop();\n    sentences.forEach((sentence) => {\n      this.parseNmeaSentence(sentence);\n    });\n  });\n}", "CodeBleu_score": 30.272717699534706}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tconst struct adc_channel_cfg *channels = sequence->channels;\n\tuint8_t num_channels = 0;\n\tsize_t needed_buffer_size = 0;\n\n\tfor (uint8_t i = 0; i < sequence->num_channels; i++) {\n\t\tif (channels[i].channel_id != config->channel_map[i].channel_id) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channels[i].acquisition_time !=\n\t\t    config->channel_map[i].acquisition_time) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channels[i].differential) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tif (channels[i].gain != config->channel_map[i].gain) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channels[i].reference != config->channel_map[i].reference) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channels[i].channel_id != AD559X_NO_CHANNEL) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = num_channels * sizeof(struct adc_result);\n\n\tif (sequence->options) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.84611612574008}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_data *data = dev->data;\n\tsize_t needed_buf_sz = 0;\n\tsize_t active_channels = 0;\n\n\tfor (uint8_t i = 0; i < sequence->channels; i++) {\n\t\tconst struct adc_channel_cfg *channel_cfg = &sequence->channels[i];\n\n\t\tif (channel_cfg->differential) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channel_cfg->input_positive != data->channels[i]) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channel_cfg->acquisition_time != AD559X_ACQ_TIME_DEFAULT) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channel_cfg->gain != AD559X_GAIN_1) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channel_cfg->reference != AD559X_REF_INTERNAL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channel_cfg->channel_id != i) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tactive_channels++;\n\t}\n\n\tneeded_buf_sz = active_channels * sizeof(struct adc_sequence_entry);\n\n\tif (sequence->options) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < needed_buf_sz) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.883502200854274}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\n\t/*\n\t * The function \"adc_ad559x_validate_buffer_size\" validates the buffer size for an ADC sequence.", "CodeBleu_score": 19.706705848515515}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 4.478133658581989}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\n\tconst struct ad559x_data *data = dev->data;\n\n\tif (sequence->resolution != data->resolution) {\n\n\t\tLOG_ERR(\"Unsupported resolution\");\n\n\t\treturn -EINVAL;\n\n\t}\n\n\tif (sequence->channels > data->resolution) {\n\n\t\tLOG_ERR(\"Too many channels in the sequence\");\n\n\t\treturn -EINVAL;\n\n\t}\n\n\tif (adc_context.buffer_size < DIV_ROUND_UP(sequence->channels, BITS_PER_BYTE)) {\n\n\t\tLOG_ERR(\"Buffer is too small\");\n\n\t\treturn -EINVAL;\n\n\t}\n\n\tadc_context.buffer = sequence->buffer;\n\n\tadc_context.length = sequence->channels;\n\n\tadc_context.resolution = data->resolution;\n\n\tadc_context.done = false;\n\n\tadc_context.config.gain = data->gain;\n\n\tadc_context.config.reference = data->reference;\n\n\tadc_context.config.acquisition_time = data->acquisition_time;\n\n\tadc_context.config.averaging_samples = data->averaging_samples;\n\n\tadc_context.config.channel_mask = BIT(sequence->channels - 1);\n\n\tadc_context.config.differential = sequence->channels > 1;\n\n\tadc_context.config.input_mode = data->input_mode;\n\n\tadc_context.config.power_mode = data->power_mode;\n\n\tadc_context.config.voltage_reference = data->voltage_reference;\n\n\tadc_context.config.enable_repeat = false;\n\n\tadc_context.config.enable_temp_sensor = false;\n\n\tadc_context.config.enable_vref_buffer = false;\n\n\tadc_context.config.filter_mode = data->filter_mode;\n\n\tadc_context.config.oversampling_ratio = data", "CodeBleu_score": 39.66201272829142}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\n\tconst struct ad559x_data *data = dev->data;\n\n\tconst struct ad559x_adc_config *config = &data->adc_config;\n\n\tuint8_t resolution = config->resolution;\n\n\tif (resolution != sequence->resolution) {\n\n\t\tLOG_ERR(\"Unsupported resolution %d\", sequence->resolution);\n\n\t\treturn -EINVAL;\n\n\t}\n\n\tfor (uint8_t i = 0; i < sequence->num_channels; i++) {\n\n\t\tif (sequence->channels[i]->channel_id >= config->num_channels) {\n\n\t\t\tLOG_ERR(\"Invalid channel %d\", sequence->channels[i]->channel_id);\n\n\t\t\treturn -EINVAL;\n\n\t\t}\n\n\t}\n\n\tif (sequence->buffer_size < sequence->num_channels) {\n\n\t\tLOG_ERR(\"Buffer size %zu is smaller than number of channels %d\", sequence->buffer_size, sequence->num_channels);\n\n\t\treturn -EINVAL;\n\n\t}\n\n\tadc_context_start_read(dev, sequence);\n\n\tadc_context_wait_for_completion(dev);\n\n\treturn 0;\n\n}", "CodeBleu_score": 46.76984445440748}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\n    struct adc_sequence *adc_seq = ctx->adc_seq;\n\n    adc_sequence_init_dt(adc_seq, ctx->adc_dev);\n\n    for (size_t i = 0; i < ctx->adc_seq->num_channels; i++) {\n\n        adc_chan_cfg_t adc_chan_cfg = {\n\n            .gain             = ADC_GAIN_1,\n\n            .reference        = ADC_REF_INTERNAL,\n\n            .acquisition_time = ADC_ACQ_TIME_DEFAULT,\n\n            .channel_id       = ctx->adc_seq->channels[i].channel_id,\n\n            .differential     = 0,\n\n            .input_positive   = 0,\n\n        };\n\n        adc_channel_setup_dt(&adc_seq->channels[i], &adc_chan_cfg);\n\n    }\n\n    adc_sequence_repeat_set(adc_seq, 0);\n\n    adc_sequence_repeat_buffer_set(adc_seq, ctx->data_buffer, sizeof(ctx->data_buffer));\n\n    ctx->sample_sem = k_sem_take(&ctx->sample_sem, K_FOREVER);\n\n}", "CodeBleu_score": 41.812855648725346}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_sequence *seq = &ctx->seq;\n\tuint8_t *data = ctx->data;\n\n\tadc_sequence_init(adc, seq, data, sizeof(data), NULL);\n\tadc_sequence_configure(adc, seq, ctx->channels, ARRAY_SIZE(ctx->channels));\n\tadc_sequence_repeat_set(adc, seq, true);\n\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 49.62178549571915}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\n\tstruct ad559x_data *data = ctx->dev_data;\n\n\tdata->channels = ctx->channels;\n\n\tdata->repeat_buf.buffer = ctx->data_buf;\n\n\tdata->repeat_buf.size = sizeof(ctx->data_buf);\n\n\tdata->repeat_buf.period_us = ctx->period_us;\n\n\tk_sem_give(&ctx->sem);\n\n}", "CodeBleu_score": 55.430901325528815}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    if (repeat_sampling) {\n        ctx->adc_data_container = &ctx->repeat_adc_data_container;\n    } else {\n        ctx->adc_data_container = &ctx->adc_data_container_1;\n    }\n}", "CodeBleu_score": 34.589026303368364}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    if (repeat_sampling) {\n        ctx->data_container->buffer = ctx->repeat_buffer;\n    } else {\n        ctx->data_container->buffer = ctx->buffer;\n    }\n}", "CodeBleu_score": 45.86355117677599}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\n    if (repeat_sampling) {\n\n        ctx->data_container->buffer = ctx->repeat_buffer;\n\n    } else {\n\n        ctx->data_container->buffer = ctx->buffer;\n\n    }\n\n}", "CodeBleu_score": 45.93649075841087}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\n    while (true) {\n\n        k_sem_take(&data->sem, K_FOREVER);\n\n        if (data->context->done) {\n            break;\n        }\n\n        for (size_t i = 0; i < data->context->channels_count; i++) {\n\n            if (data->context->channels[i].active) {\n\n                int16_t value;\n\n                if (adc_read(data->context->channels[i].dev, &data->context->channels[i].sequence) != 0) {\n\n                    LOG_ERR(\"ADC read failed\");\n\n                    data->context->done = true;\n\n                    break;\n                }\n\n                value = sys_le16_to_cpu(data->context->channels[i].data.buf[0]);\n\n                data->context->channels[i].buffer[data->context->buffer_index] = value;\n            }\n        }\n\n        data->context->buffer_index++;\n\n        if (data->context->buffer_index == data->context->buffer_size) {\n\n            data->context->buffer_index = 0;\n\n            k_sem_give(&data->context->sem);\n        }\n    }\n}", "CodeBleu_score": 38.21272052816284}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    while (true) {\n        k_sem_take(&data->sem, K_FOREVER);\n\n        for (size_t i = 0; i < ADC_NUM_CHANNELS; i++) {\n            if (!data->active_channels[i]) {\n                continue;\n            }\n\n            int16_t value;\n            int err = adc_read(data->dev, i, &value);\n            if (err) {\n                LOG_ERR(\"ADC read error: %d\", err);\n                data->adc_context.is_complete = true;\n                break;\n            }\n\n            data->adc_context.adc_buffer[i] = sys_le16_to_cpu(value);\n        }\n\n        k_sem_give(&data->adc_context.sem);\n    }\n}", "CodeBleu_score": 38.77735940077724}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\n\twhile (true) {\n\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tif (data->adc_context->done) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (uint8_t i = 0; i < data->adc_context->active_channels; i++) {\n\n\t\t\tint16_t adc_value;\n\t\t\tint ret = adc_read(data->adc_context->adc_channels[i], &adc_value);\n\n\t\t\tif (ret != 0) {\n\t\t\t\tLOG_ERR(\"adc_read() failed: %d\", ret);\n\t\t\t\tdata->adc_context->done = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->adc_context->adc_buffer[i] = adc_value;\n\t\t}\n\n\t\tk_sem_give(&data->adc_context->sem);\n\t}\n}", "CodeBleu_score": 37.71545468302918}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\n    const struct ads1112_config *config = dev->config;\n\n    int ret;\n\n    k_sleep(K_USEC(config->ready_time));\n\n    do {\n\n        uint8_t reg;\n\n        ret = i2c_reg_read_byte(config->i2c_master, config->i2c_addr, ADS1112_CONFIG_REG, &reg);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n        if (reg & ADS1112_CONFIG_DRDY) {\n\n            break;\n\n        }\n\n        k_sleep(K_USEC(100));\n\n    } while (1);\n\n    return 0;\n\n}", "CodeBleu_score": 39.03432075211314}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\n\n\n    const struct ads1112_config *config = dev->config;\n\n    int err;\n\n\n\n    k_sleep(K_USEC(config->ready_time));\n\n    do {\n\n        uint8_t reg;\n\n\n\n        err = i2c_reg_read_byte(config->bus, config->bus_cfg.i2c_slv_addr,\n\n                               ADS1112_REG_CONFIG, &reg);\n\n        if (err) {\n\n            return err;\n\n        }\n\n        if (reg & ADS1112_CONFIG_DRDY) {\n\n            break;\n\n        }\n\n        k_sleep(K_USEC(100));\n\n    } while (1);\n\n\n\n    return 0;\n\n}", "CodeBleu_score": 38.004235311952705}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\n\n\n    const struct ads1112_config *config = dev->config;\n\n    const struct adc_context *ctx = dev->data;\n\n\n\n    k_sleep(K_USEC(config->ready_time_us));\n\n\n\n    uint16_t reg_val;\n\n    int ret = i2c_reg_read_byte_dt(&config->bus_cfg.i2c, config->bus_cfg.i2c_addr,\n\n                                  ADS1112_REG_CONFIG, (uint8_t *)&reg_val);\n\n    if (ret < 0) {\n\n        LOG_ERR(\"Failed to read config register\");\n\n        return ret;\n\n    }\n\n\n\n    reg_val = sys_be16_to_cpu(reg_val);\n\n    while ((reg_val & ADS1112_CONFIG_DRDY) == 0) {\n\n        k_sleep(K_USEC(100));\n\n        ret = i2c_reg_read_byte_dt(&config->bus_cfg.i2c, config->bus_cfg.i2c_addr,\n\n                                  ADS1112_REG_CONFIG, (uint8_t *)&reg_val);\n\n        if (ret < 0) {\n\n            LOG_ERR(\"Failed to read config register\");\n\n            return ret;\n\n        }\n\n        reg_val = sys_be16_to_cpu(reg_val);\n\n    }\n\n\n\n    return 0;\n\n}", "CodeBleu_score": 48.758693663301}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\n    int32_t buffer_size = sequence->options->extra_samplings + 1;\n\n    if (sequence->buffer_size < buffer_size) {\n\n        LOG_ERR(\"Buffer size %d is smaller than required %d\",\n\n                sequence->buffer_size, buffer_size);\n\n        return -EINVAL;\n\n    }\n\n    return 0;\n\n}", "CodeBleu_score": 40.73152057006634}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\n    int err = 0;\n\n    size_t needed_buffer_size = sizeof(uint16_t) * sequence->options->extra_samplings;\n\n    for (size_t i = 0; i < sequence->channels->count; i++) {\n\n        needed_buffer_size += sizeof(uint16_t) * sequence->channels->cfg[i].sampling_window;\n\n    }\n\n    if (sequence->buffer_size < needed_buffer_size) {\n\n        LOG_ERR(\"Buffer size %zu is not sufficient, %zu is required\", sequence->buffer_size, needed_buffer_size);\n\n        err = -EINVAL;\n\n    }\n\n    return err;\n\n}", "CodeBleu_score": 38.66490402114409}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\n    int32_t buffer_size = sequence->options->extra_samplings + 1;\n\n    if (sequence->options->calibrate) {\n\n        buffer_size *= 2;\n\n    }\n\n    if (buffer_size > sequence->buffer->max_samples) {\n\n        LOG_ERR(\"buffer size not sufficient\");\n\n        return -EINVAL;\n\n    }\n\n    return 0;\n\n}", "CodeBleu_score": 29.32549006136097}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\n\tLOG_DBG(\"Starting ADC read\");\n\n\t/* Validate the ADC sequence */\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Invalid ADC options\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Assign the sequence buffer to the device data */\n\tconst struct ads1112_adc_context *adc_context = dev->data;\n\tadc_context->sequence_buffer = sequence;\n\n\t/* Start the ADC read context */\n\tint result = adc_context_start_read(dev, wait);\n\n\t/* If the wait flag is true, wait for the read operation to complete */\n\tif (wait) {\n\t\tk_sem_take(&adc_context->sem, K_FOREVER);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 39.49495496852278}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\n\n\n    struct ads1112_adc_context *ctx = dev->data;\n\n    int ret;\n\n\n\n    /* Validate the ADC sequence */\n\n    ret = ads1112_adc_validate_sequence(dev, sequence);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    /* Assign the sequence buffer to the device data */\n\n    ctx->sequence_buffer = sequence->buffer;\n\n\n\n    /* Start the ADC read context */\n\n    ret = ads1112_adc_start_read_context(dev);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    /* If the wait flag is true, wait for the read operation to complete */\n\n    if (wait) {\n\n        ret = ads1112_adc_wait_for_read_context(dev);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}", "CodeBleu_score": 52.61186489643759}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tint ret;\n\tuint8_t buf[2];\n\n\tif (sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels > 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = i2c_write_read(dev->data, ADS1112_I2C_ADDR,\n\t\t\t     (uint8_t *)&sequence->buffer,\n\t\t\t     sizeof(sequence->buffer), buf, sizeof(buf));\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tk_sleep(K_MSEC(10));\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.171747031421205}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\n    struct audio_codec *codec;\n    int res;\n\n    codec = audio_codec_get_by_name(argv[1]);\n    if (!codec) {\n        shell_error(sh, \"Failed to find audio codec device %s\", argv[1]);\n        return -ENODEV;\n    }\n\n    res = audio_codec_apply_properties(codec);\n    if (res) {\n        shell_error(sh, \"Failed to apply properties to audio codec device %s\", argv[1]);\n        return res;\n    }\n\n    return 0;\n}", "CodeBleu_score": 49.921439485145584}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    struct audio_codec *codec = NULL;\n    int ret;\n\n    if (argc != 2) {\n        shell_error(sh, \"Usage: %s <codec_dev_name>\", argv[0]);\n        return -EINVAL;\n    }\n\n    codec = device_get_binding(argv[1]);\n    if (!codec) {\n        shell_error(sh, \"Could not find codec device %s\", argv[1]);\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_properties(codec);\n    if (ret) {\n        shell_error(sh, \"Failed to apply properties to codec device %s: %d\", argv[1], ret);\n        return ret;\n    }\n\n    shell_print(sh, \"Properties applied to codec device %s\", argv[1]);\n    return 0;\n}", "CodeBleu_score": 47.93028893865921}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    struct audio_codec *codec;\n    int ret;\n\n    codec = audio_codec_get_by_name(argv[1]);\n    if (!codec) {\n        shell_error(sh, \"codec '%s' not found\", argv[1]);\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_properties(codec);\n    if (ret < 0) {\n        shell_error(sh, \"apply properties failed %d\", ret);\n        return ret;\n    }\n\n    return 0;\n}", "CodeBleu_score": 50.44971434660833}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret = 0;\n\tuint32_t state;\n\tuint32_t command;\n\n\tstate = i2s_get_state(dev);\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (state != I2S_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"DMIC device not configured\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tcommand = I2S_TRIGGER_START;\n\t\tret = i2s_trigger(dev, command);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"Failed to trigger DMIC start\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tstate = I2S_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (state != I2S_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"DMIC device not active\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tcommand = I2S_TRIGGER_STOP;\n\t\tret = i2s_trigger(dev, command);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"Failed to trigger DMIC stop\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tstate = I2S_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid DMIC trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\ti2s_set_state(dev, state);\n\n\treturn 0;\n}", "CodeBleu_score": 53.322272177964145}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\n\n\n\tint ret;\n\n\n\n\tswitch (cmd) {\n\n\n\n\t\tcase DMIC_TRIGGER_START:\n\n\n\n\t\t\tif (mpxxdtyy_get_state(dev) != DMIC_STATE_CONFIGURED) {\n\n\n\n\t\t\t\tLOG_ERR(\"DMIC device not configured\");\n\n\n\n\t\t\t\treturn -ENODEV;\n\n\n\n\t\t\t}\n\n\n\n\t\t\tret = i2s_trigger(dev, I2S_TRIGGER_START, I2S_DIR_RX);\n\n\n\n\t\t\tif (ret < 0) {\n\n\n\n\t\t\t\tLOG_ERR(\"Failed to start I2S RX\");\n\n\n\n\t\t\t\treturn ret;\n\n\n\n\t\t\t}\n\n\n\n\t\t\tmpxxdtyy_set_state(dev, DMIC_STATE_ACTIVE);\n\n\n\n\t\t\tbreak;\n\n\n\n\n\t\tcase DMIC_TRIGGER_STOP:\n\n\n\n\t\t\tif (mpxxdtyy_get_state(dev) != DMIC_STATE_ACTIVE) {\n\n\n\n\t\t\t\tLOG_ERR(\"DMIC device not active\");\n\n\n\n\t\t\t\treturn -ENODEV;\n\n\n\n\t\t\t}\n\n\n\n\t\t\tret = i2s_trigger(dev, I2S_TRIGGER_STOP, I2S_DIR_RX);\n\n\n\n\t\t\tif (ret < 0) {\n\n\n\n\t\t\t\tLOG_ERR(\"Failed to stop I2S RX\");\n\n\n\n\t\t\t\treturn ret;\n\n\n\n\t\t\t}\n\n\n\n\t\t\tmpxxdtyy_set_state(dev, DMIC_STATE_CONFIGURED);\n\n\n\n\t\t\tbreak;\n\n\n\n\n\t\tdefault:\n\n\n\n\t\t\tLOG_ERR(\"Unsupported DMIC trigger command\");\n\n\n\n\t\t\treturn -EINVAL;\n\n\n\n\t}\n\n\n\n\treturn 0;\n\n\n\n}", "CodeBleu_score": 49.84634299406133}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\n    struct mpxxdtyy_data *data = dev->data;\n    int ret = 0;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state != STATE_CONFIGURED) {\n                LOG_ERR(\"DMIC device not configured\");\n                return -EINVAL;\n            }\n\n            ret = i2s_trigger(data->i2s, I2S_TRIGGER_START, data->i2s_cfg.mclk);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to start I2S: %d\", ret);\n                return ret;\n            }\n\n            data->state = STATE_ACTIVE;\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (data->state != STATE_ACTIVE) {\n                LOG_ERR(\"DMIC device not active\");\n                return -EINVAL;\n            }\n\n            ret = i2s_trigger(data->i2s, I2S_TRIGGER_STOP, data->i2s_cfg.mclk);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to stop I2S: %d\", ret);\n                return ret;\n            }\n\n            data->state = STATE_CONFIGURED;\n            break;\n\n        default:\n            LOG_ERR(\"Invalid DMIC trigger command: %d\", cmd);\n            return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 57.47663089040936}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\n\n\tuint8_t cmd = HD44780_DISPLAY_MODE_CMD;\n\n\n\tif (enabled) {\n\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\n\t}\n\n\n\tif (auxdisplay_hd44780_get_cursor(dev)) {\n\n\t\tcmd |= HD44780_DISPLAY_MODE_CURSOR_ON;\n\n\t}\n\n\n\tif (auxdisplay_hd44780_get_cursor_blink(dev)) {\n\n\t\tcmd |= HD44780_DISPLAY_MODE_CURSOR_BLINK_ON;\n\n\t}\n\n\n\tauxdisplay_hd44780_send_command(dev, cmd);\n\n}", "CodeBleu_score": 48.445867091561354}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\n    struct auxdisplay_hd44780_data *data = dev->data;\n\n    const struct auxdisplay_hd44780_config *config = dev->config;\n\n    uint8_t cmd = HD44780_CMD_DISPLAY_MODE;\n\n    if (enabled) {\n\n        cmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\n    }\n\n    if (data->cursor_blink) {\n\n        cmd |= HD44780_DISPLAY_MODE_CURSOR_ON;\n\n    }\n\n    if (data->cursor_pos_blink) {\n\n        cmd |= HD44780_DISPLAY_MODE_CURSOR_BLINK_ON;\n\n    }\n\n    auxdisplay_hd44780_send_command(dev, cmd);\n\n}", "CodeBleu_score": 68.15508646417179}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\n\tuint8_t cmd = 0;\n\n\tstruct auxdisplay_hd44780_config *config = dev->config;\n\n\tuint8_t cursor = config->cursor;\n\n\tuint8_t blink = config->blink;\n\n\tuint8_t display = config->display;\n\n\n\n\tif (cursor) {\n\n\t\tcmd |= HD44780_CMD_DISPLAY_ON | HD44780_CMD_CURSOR_ON;\n\n\t}\n\n\tif (blink) {\n\n\t\tcmd |= HD44780_CMD_CURSOR_BLINK;\n\n\t}\n\n\tif (enabled) {\n\n\t\tcmd |= HD44780_CMD_DISPLAY_ON;\n\n\t}\n\n\tcmd |= display;\n\n\tauxdisplay_hd44780_send_command(dev, cmd);\n\n}", "CodeBleu_score": 56.5513588268352}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\n\n\n    const struct auxdisplay_itron_config *config = dev->config;\n\n\n\n    if (!config->busy_gpios.port) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    return gpio_pin_get(config->busy_gpios.port, config->busy_gpios.pin);\n\n}", "CodeBleu_score": 42.67440808597074}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\n\tif (config->busy_port == NULL) {\n\n\t\treturn -ENOTSUP;\n\n\t}\n\n\treturn gpio_pin_get(config->busy_port, config->busy_pin);\n\n}", "CodeBleu_score": 69.89134691668383}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\n    const struct auxdisplay_itron_config *config = dev->config;\n\n    if (!config->busy_port) {\n\n        return -ENOTSUP;\n\n    }\n\n    return gpio_pin_get(config->busy_port, config->busy_pin);\n\n}", "CodeBleu_score": 42.373853582005744}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write(config->i2c, buf, sizeof(buf), config->i2c_addr);\n}", "CodeBleu_score": 60.53115316622058}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\n\tuint8_t buf[2] = {\n\t\tconfig->special_command_prefix,\n\t\tcommand,\n\t};\n\n\treturn i2c_write(config->i2c_dev, buf, sizeof(buf), config->i2c_addr);\n}", "CodeBleu_score": 47.784511586858066}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write(config->i2c, buf, sizeof(buf), config->i2c_address);\n}", "CodeBleu_score": 60.6311596235297}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_cfg *cfg = dev->config;\n\n\tif (size == 0) {\n\t\tLOG_ERR(\"Read size is 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\tLOG_ERR(\"Read exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\tLOG_ERR(\"Data buffer is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &cfg->data[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 47.42819824929886}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_driver_api *api = dev->api;\n\tconst struct bbram_emul_driver_api *emul_api = dev->api_inst;\n\n\t__ASSERT(api != NULL, \"API pointer must not be NULL\");\n\t__ASSERT(emul_api != NULL, \"API pointer must not be NULL\");\n\n\tif (emul_api->read != NULL) {\n\t\treturn emul_api->read(dev, offset, size, data);\n\t}\n\n\tif (size == 0) {\n\t\tLOG_ERR(\"Read size must be greater than 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > emul_api->size) {\n\t\tLOG_ERR(\"Read exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\tLOG_ERR(\"Data pointer must not be NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, emul_api->memory + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 56.41563107827557}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tLOG_DBG(\"Reading from %s at offset %zu size %zu\", dev->name, offset, size);\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > CONFIG_BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, (uint8_t *)dev->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 54.60988341025369}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\n\tARG_UNUSED(dev);\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif ((offset + size) > CONFIG_BBRAM_SIZE) {\n\t\tLOG_ERR(\"Write out of range\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_is_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemcpy(&bbram_emul_get_data(dev)[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 45.085238767808406}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_cfg *cfg = dev->config;\n\n\tif ((size == 0) || (offset + size > cfg->size)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->state != BBRAM_EMUL_VALID) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&cfg->data[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 53.605862518421965}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_driver_api *api = dev->api;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > api->size(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (api->state(dev) != BBRAM_STATE_READY) {\n\t\treturn -ENODEV;\n\t}\n\n\tmemcpy(api->buffer(dev) + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 60.1740583858231}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst char *device_name;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_name = argv[1];\n\n\t*bbram_dev = device_get_binding(device_name);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device \\\"%s\\\" not found\", device_name);\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_init(*bbram_dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Error initializing BBRAM device \\\"%s\\\"\", device_name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 67.77713925218669}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 86.70234567588466}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst struct device *dev;\n\n\tif (argc != 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device \\\"%s\\\" not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 67.87831314951103}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\n  uint8_t hdr_buf[H4_HDR_SIZE];\n\n  size_t hdr_len = 0;\n\n  size_t remaining = H4_HDR_SIZE;\n\n  while (remaining > 0) {\n\n    int ret = uart_fifo_read(dev, &hdr_buf[hdr_len], remaining);\n\n    if (ret < 0) {\n\n      LOG_ERR(\"Error reading header from UART device: %d\", ret);\n\n      return;\n\n    }\n\n    hdr_len += ret;\n\n    remaining -= ret;\n\n  }\n\n}", "CodeBleu_score": 36.10388602288115}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\n    uint8_t hdr[H4_HDR_SIZE];\n\n    size_t hdr_len = sizeof(hdr);\n\n    size_t bytes_read;\n\n    size_t bytes_remaining = hdr_len;\n\n    size_t bytes_already_read = 0;\n\n    while (bytes_remaining > 0) {\n\n        bytes_read = uart_fifo_read(dev, &hdr[bytes_already_read], bytes_remaining);\n\n        if (bytes_read < 0) {\n\n            LOG_ERR(\"Failed to read header data from UART device\");\n\n            return;\n\n        }\n\n        bytes_already_read += bytes_read;\n\n        bytes_remaining -= bytes_read;\n\n    }\n\n    LOG_DBG(\"Header data read from UART device: %s\", log_strdup(hdr));\n\n}", "CodeBleu_score": 29.655539194567226}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\n  uint8_t hdr_buf[H4_HDR_SIZE];\n\n  int remaining = H4_HDR_SIZE;\n\n  int read;\n\n  while (remaining > 0) {\n\n    read = uart_fifo_read(dev, hdr_buf + (H4_HDR_SIZE - remaining), remaining);\n\n    if (read < 0) {\n\n      LOG_ERR(\"Failed to read header: %d\", read);\n\n      return;\n\n    }\n\n    remaining -= read;\n\n  }\n\n}", "CodeBleu_score": 33.356413293221486}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\n    uint8_t buf[33];\n\n    size_t rx_len;\n\n    size_t total_rx_len = 0;\n\n    while (len) {\n\n        rx_len = MIN(len, sizeof(buf));\n\n        if (uart_rx_poll_in(uart, buf, rx_len) != 0) {\n\n            LOG_ERR(\"H4 discard error\");\n\n            return total_rx_len;\n\n        }\n\n        len -= rx_len;\n\n        total_rx_len += rx_len;\n\n    }\n\n    return total_rx_len;\n\n}", "CodeBleu_score": 38.78545574952426}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\n\tuint8_t buf[33];\n\n\tsize_t rx_len = MIN(sizeof(buf), len);\n\n\tssize_t ret = uart_rx_poll_in(uart, buf, rx_len);\n\n\tif (ret < 0) {\n\n\t\tLOG_ERR(\"UART RX error: %d\", ret);\n\n\t\treturn 0;\n\n\t}\n\n\treturn ret;\n\n}", "CodeBleu_score": 39.28445543215977}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t r;\n    size_t total = 0;\n\n    while (len) {\n        r = MIN(len, sizeof(buf));\n        if (uart_fifo_read(uart, buf, r) < 0) {\n            LOG_ERR(\"uart_fifo_read failed\");\n            return total;\n        }\n\n        len -= r;\n        total += r;\n    }\n\n    return total;\n}", "CodeBleu_score": 41.27741397209243}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\n  int hop = INT_MAX;\n\n  struct zbus_observer *obs;\n\n  Z_SYSCALL_MEMORY_WRITE(chan->lock, true);\n\n  SYS_SLIST_FOR_EACH_CONTAINER(&chan->observers, obs, node) {\n\n    if (obs->priority < hop && obs->enabled) {\n\n      hop = obs->priority;\n\n    }\n\n  }\n\n  chan->hop = hop;\n\n  Z_SYSCALL_MEMORY_WRITE(chan->lock, false);\n\n}", "CodeBleu_score": 17.601088798941316}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    int hop = -1;\n    struct zbus_observer *obs;\n    struct zbus_observer_node *node;\n    struct zbus_observer_node *next;\n\n    zbus_chan_lock(chan);\n    SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan->observers, node, next, node) {\n        obs = CONTAINER_OF(node, struct zbus_observer, node);\n        if (obs->priority > hop && obs->enabled) {\n            hop = obs->priority;\n        }\n    }\n    chan->hop = hop;\n    zbus_chan_unlock(chan);\n}", "CodeBleu_score": 22.56045355037318}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    uint8_t hop = 0;\n    struct zbus_observer *obs;\n\n    zbus_chan_lock(chan);\n    Z_ITER_FOREACH(obs, zbus_chan_observers_get(chan)) {\n        if (zbus_observer_is_enabled(obs) &&\n            zbus_observer_priority(obs) < hop) {\n            hop = zbus_observer_priority(obs);\n        }\n    }\n    zbus_chan_unlock(chan);\n\n    zbus_chan_hop_set(chan, hop);\n}", "CodeBleu_score": 14.815075611825371}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t  struct zbus_channel_hop *channel_hop = CONTAINER_OF(obs, struct zbus_channel_hop, observer);\n  struct zbus_channel_hop_observation *obs_it;\n  struct zbus_channel_hop_observation *obs_tmp;\n\n  sys_slist_for_each_entry_safe(&channel_hop->observations, obs_it, obs_tmp, node) {\n    if (obs_it->observer == obs) {\n      channel_hop->update_channel_hop(obs_it);\n    }\n  }\n}", "CodeBleu_score": 18.528189197082803}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel *chan;\n    Z_ITER_FOREACH(chan, zbus_channel_iter_all) {\n        if (chan->observer != obs) {\n            continue;\n        }\n        chan->update(chan);\n    }\n}", "CodeBleu_score": 29.951905988192866}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel_hop *hop;\n\n    Z_ITER_SECTION(zbus_channel_hop, hop, obs) {\n        if (hop->obs == obs) {\n            hop->update(hop);\n        }\n    }\n}", "CodeBleu_score": 22.230524996342005}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\n    // Check if the operation is being performed in an ISR\n    if (k_is_in_isr()) {\n        return -EINVAL;\n    }\n\n    // Check if the observer is not null\n    if (obs == NULL) {\n        return -EINVAL;\n    }\n\n    // Lock the spinlock\n    k_spinlock_key_t key = k_spin_lock(&obs->lock);\n\n    // Set the observer's priority to the minimum thread priority\n    obs->priority = K_MIN_THREAD_PRIO;\n\n    // Update all channels associated with the observer\n    for (struct zbus_channel *ch = obs->channels; ch != NULL; ch = ch->next) {\n        zbus_chan_update(ch);\n    }\n\n    // Unlock the spinlock\n    k_spin_unlock(&obs->lock, key);\n\n    return 0;\n}", "CodeBleu_score": 45.26908487868157}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\n    int ret = 0;\n\n    if (k_is_in_isr()) {\n\n        LOG_ERR(\"Cannot attach observer in ISR\");\n\n        return -EINVAL;\n\n    }\n\n    if (obs == NULL) {\n\n        LOG_ERR(\"Observer cannot be NULL\");\n\n        return -EINVAL;\n\n    }\n\n    k_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\n    obs->priority = K_LOWEST_APPLICATION_THREAD_PRIO;\n\n    for (int i = 0; i < ARRAY_SIZE(zbus_channels); i++) {\n\n        ret = zbus_chan_update(zbus_channels[i], obs);\n\n        if (ret != 0) {\n\n            LOG_ERR(\"Failed to update channel %d\", i);\n\n            break;\n\n        }\n\n    }\n\n    k_spin_unlock(&zbus_lock, key);\n\n    return ret;\n\n}", "CodeBleu_score": 43.773166261525354}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\n    __ASSERT(k_is_in_isr() == false, \"Cannot attach from ISR\");\n\n    __ASSERT(obs != NULL, \"Observer cannot be null\");\n\n    k_spinlock_key_t key = k_spin_lock(&obs->lock);\n\n    obs->prio = K_MIN_THREAD_PRIO;\n\n    struct zbus_channel *chan;\n\n    SYS_FOREACH_CHANNEL(chan) {\n\n        zbus_chan_update(chan, obs);\n\n    }\n\n    k_spin_unlock(&obs->lock, key);\n\n    return 0;\n\n}", "CodeBleu_score": 49.09937786610782}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\n\tint ret;\n\n\tk_spinlock_key_t key;\n\n\tk_tid_t thread = k_current_get();\n\n\tint32_t priority;\n\n\tk_timeout_t end_time;\n\n\n\n\t__ASSERT(chan != NULL, \"chan cannot be NULL\");\n\n\n\n\tkey = k_spin_lock(&chan->lock);\n\n\n\n\tif (k_is_in_isr() && timeout != K_NO_WAIT) {\n\n\t\tend_time = K_TICKS(k_uptime_ticks() + timeout);\n\n\t} else {\n\n\t\tend_time = K_FOREVER;\n\n\t}\n\n\n\n\tpriority = k_sched_priority_get(thread);\n\n\n\n\tret = zbus_chan_notify_internal(chan, end_time, priority);\n\n\n\n\tk_spin_unlock(&chan->lock, key);\n\n\n\n\treturn ret;\n\n}", "CodeBleu_score": 44.6571591094118}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    int ret;\n    k_spinlock_key_t key;\n    k_tid_t thread = k_current_get();\n    k_timeout_t end_time = K_FOREVER;\n\n    if (chan == NULL) {\n        return -EINVAL;\n    }\n\n    if (k_is_in_isr()) {\n        if (timeout == K_NO_WAIT) {\n            return -EAGAIN;\n        }\n\n        if (timeout != K_FOREVER) {\n            end_time = k_uptime_get() + timeout;\n        }\n    }\n\n    key = k_spin_lock(&chan->lock);\n\n    ret = zbus_chan_notify_internal(chan, thread, end_time);\n\n    k_spin_unlock(&chan->lock, key);\n\n    return ret;\n}", "CodeBleu_score": 39.92975708221528}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t  int ret;\n  struct zbus_channel_ctx ctx;\n  k_tid_t thread = k_current_get();\n  k_timeout_t end_time = K_FOREVER;\n  k_timeout_t remaining = K_NO_WAIT;\n  unsigned int prio = k_sched_priority_get(thread);\n\n  __ASSERT(chan != NULL, \"chan cannot be NULL\");\n\n  /* Adjust the timeout if in an ISR. */\n  if (k_is_in_isr()) {\n    if (timeout == K_FOREVER) {\n      return -EBUSY;\n    }\n    end_time = k_uptime_get() + timeout;\n  } else {\n    remaining = timeout;\n  }\n\n  /* Initialize the context priority. */\n  ctx.priority = prio;\n\n  /* Lock the channel. */\n  k_mutex_lock(&chan->lock, remaining);\n\n  /* Execute the notification logic. */\n  ret = zbus_chan_notify_internal(chan, &ctx, end_time);\n\n  /* Unlock the channel. */\n  k_mutex_unlock(&chan->lock);\n\n  return ret;\n}", "CodeBleu_score": 43.81923785787697}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  uint32_t tmp;\n\n  if (Int == ETH_INT_NORMAL) {\n    tmp = ETH->ETH_IMSC;\n    if (enable)\n      ETH->ETH_IMSC |= ETH_INT_NORMAL;\n    else\n      ETH->ETH_IMSC &= ~ETH_INT_NORMAL;\n  } else if (Int == ETH_INT_ABNORMAL) {\n    tmp = ETH->ETH_IMSC;\n    if (enable)\n      ETH->ETH_IMSC |= ETH_INT_ABNORMAL;\n    else\n      ETH->ETH_IMSC &= ~ETH_INT_ABNORMAL;\n  } else {\n    return;\n  }\n}", "CodeBleu_score": 42.238039137097054}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    uint32_t tmp;\n\n    if (Int & 0x10000000) {\n        tmp = ETH_ReadReg(ETH_INTEN);\n        if (enable) {\n            tmp |= Int;\n        } else {\n            tmp &= ~Int;\n        }\n        ETH_WriteReg(ETH_INTEN, tmp);\n    } else {\n        tmp = ETH_ReadReg(ETH_INTEN_ABNORMAL);\n        if (enable) {\n            tmp |= Int;\n        } else {\n            tmp &= ~Int;\n        }\n        ETH_WriteReg(ETH_INTEN_ABNORMAL, tmp);\n    }\n}", "CodeBleu_score": 38.86966738802495}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    uint32_t value;\n\n    if (Int == ETH_INT_NORMAL) {\n        value = ETH_Read(ETH_INT_NORMAL_EN);\n        if (enable) {\n            value |= ETH_INT_NORMAL;\n        } else {\n            value &= ~ETH_INT_NORMAL;\n        }\n        ETH_Write(ETH_INT_NORMAL_EN, value);\n    } else if (Int == ETH_INT_ABNORMAL) {\n        value = ETH_Read(ETH_INT_ABNORMAL_EN);\n        if (enable) {\n            value |= ETH_INT_ABNORMAL;\n        } else {\n            value &= ~ETH_INT_ABNORMAL;\n        }\n        ETH_Write(ETH_INT_ABNORMAL_EN, value);\n    } else if (Int == ETH_INT_RX_DONE) {\n        value = ETH_Read(ETH_INT_RX_DONE_EN);\n        if (enable) {\n            value |= ETH_INT_RX_DONE;\n        } else {\n            value &= ~ETH_INT_RX_DONE;\n        }\n        ETH_Write(ETH_INT_RX_DONE_EN, value);\n    } else if (Int == ETH_INT_TX_DONE) {\n        value = ETH_Read(ETH_INT_TX_DONE_EN);\n        if (enable) {\n            value |= ETH_INT_TX_DONE;\n        } else {\n            value &= ~ETH_INT_TX_DONE;\n        }\n        ETH_Write(ETH_INT_TX_DONE_EN, value);\n    } else if (Int == ETH_INT_RX_ERROR) {\n        value = ETH_Read(ETH_INT_RX_ERROR_EN);\n        if (enable) {\n            value |= ETH_INT_RX_ERROR;\n        } else {\n            value &= ~ETH_INT_RX_ERROR;\n        }\n        ETH_Write(ETH_INT", "CodeBleu_score": 32.52310871336492}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *tx_desc = (ETH_TX_DESC *)ETH_TX_DESC_BASE;\n\n    while (tx_desc->STATUS & ETH_TX_STATUS_OWN) {\n        tx_desc++;\n        if (tx_desc == (ETH_TX_DESC *)ETH_TX_DESC_END) {\n            tx_desc = (ETH_TX_DESC *)ETH_TX_DESC_BASE;\n        }\n    }\n\n    return tx_desc;\n}", "CodeBleu_score": 37.81232406081856}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *tx_desc = ETH->TX_DESC_LIST;\n    ETH_TX_DESC *start_desc = tx_desc;\n    do {\n        if (tx_desc->OWN == 0) {\n            return tx_desc;\n        }\n        tx_desc++;\n    } while (tx_desc != start_desc);\n    return 0;\n}", "CodeBleu_score": 45.426085166836444}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc;\n    uint32_t txDescAddr;\n\n    txDescAddr = ETH->DMATXDESCADDR;\n    txDesc = (ETH_TX_DESC *)txDescAddr;\n\n    if (txDesc->STATUS & ETH_DMATXDESC_OWN) {\n        return 0;\n    }\n\n    while (txDesc->STATUS & ETH_DMATXDESC_OWN) {\n        txDesc = (ETH_TX_DESC *)txDesc->NEXTDESC;\n        if (txDesc == (ETH_TX_DESC *)txDescAddr) {\n            return 0;\n        }\n    }\n\n    return txDesc;\n}", "CodeBleu_score": 52.4029884150446}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n\n    struct cyp_dac_device *cyp_device = (struct cyp_dac_device *)device;\n    Cy_CSDIDAC_OutputEnable(cyp_device->base, channel, *value);\n\n    return RT_EOK;\n}", "CodeBleu_score": 45.22685472254408}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(device->channel == channel);\n\n    if (Cy_CSDIDAC_OutputEnable(device->dac, *value)) {\n        rt_kprintf(\"[%s] Failed to enable DAC output\n\", __FUNCTION__);\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 52.02583772001608}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n\n    struct cyp_dac_device *cyp_device = (struct cyp_dac_device *)device;\n    struct cyp_dac_channel *cyp_channel = &cyp_device->cyp_dac_channel[channel];\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_channel->base, cyp_channel->channel, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"Failed to enable DAC output\");\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 56.4770078276953}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t end_addr;\n\n    if (addr + size > IFX_FLASH_SIZE) {\n        return -RT_EINVAL;\n    }\n\n    end_addr = addr + size;\n    while (addr < end_addr) {\n        *buf++ = *(rt_uint8_t *)addr++;\n    }\n\n    return size;\n}", "CodeBleu_score": 41.37370733657292}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > FLASH_SIZE) {\n        rt_kprintf(\"flash read error: addr=0x%x, size=0x%x\n\", addr, size);\n        return -RT_EINVAL;\n    }\n\n    while (size--) {\n        *buf++ = *(rt_uint8_t *) addr++;\n    }\n\n    return addr - (addr - size);\n}", "CodeBleu_score": 39.88275417201395}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n\n    if (addr + size > FLASH_END_ADDR) {\n        rt_kprintf(\"read addr(0x%x) + size(0x%x) > FLASH_END_ADDR(0x%x)\n\", addr, size, FLASH_END_ADDR);\n        return -RT_EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 58.44903939318606}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    CY_ASSERT(timer);\n\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->priv;\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 19.97295685617703}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    CY_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->priv;\n\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 25.69668780881119}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->priv;\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 26.99729535138733}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\trt_err_t result;\n\n\tresult = rt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n\tRT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 13.320785766858311}, {"code": "void dfs_lock(void){\n\t    dfs_fs_lock();\n}", "CodeBleu_score": 3.116228419233427}, {"code": "void dfs_lock(void){\n\t    rt_err_t result;\n\n    result = rt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n    if (result != RT_EOK) {\n        rt_kprintf(\"dfs lock failed, result: %d\n\", result);\n        RT_ASSERT(result == RT_EOK);\n    }\n}", "CodeBleu_score": 31.607907457669548}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n    struct dfs_fd *dfd;\n\n    for (fd = startfd; fd < DFS_FD_MAX; fd++) {\n        dfd = &fdt->fd[fd];\n        if (dfd->file == NULL) {\n            dfd->type = F_NONE;\n            return fd;\n        }\n    }\n\n    return -1;\n}", "CodeBleu_score": 34.08458870219681}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    /* Search for an empty slot starting from the specified index. */\n    for (i = startfd; i < DFS_FD_MAX; i++) {\n        if (fdt->fd[i] == NULL) {\n            return i;\n        }\n    }\n\n    /* Attempt to expand the fd table. */\n    if (fdt->size < DFS_FD_MAX) {\n        fdt->size++;\n        return fdt->size - 1;\n    }\n\n    /* If expansion fails, return -1. */\n    return -1;\n}", "CodeBleu_score": 35.115435518231685}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    /* Search for an empty slot starting from the specified index. */\n    for (i = startfd; i < DFS_FD_MAX; i++) {\n        if (fdt->fd[i] == NULL) {\n            return i;\n        }\n    }\n\n    /* If no empty slot is found, attempt to expand the fd table. */\n    if (fdt->maxfd < DFS_FD_MAX) {\n        fdt->maxfd++;\n        return fdt->maxfd;\n    }\n\n    /* If expansion fails, return -1. */\n    return -1;\n}", "CodeBleu_score": 35.86262560794581}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\n  if (error < 0) {\n    error = -error;\n  }\n\n  for (int i = 0; i < sizeof(error_strings) / sizeof(error_strings[0]); i++) {\n    if (error_strings[i].error == error) {\n      return error_strings[i].string;\n    }\n  }\n\n  return \"EUNKNOW\";\n}", "CodeBleu_score": 62.14730829313366}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    rt_uint32_t index;\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    for (index = 0; index < sizeof(rt_err_list) / sizeof(rt_err_list[0]); index++) {\n        if ((rt_err_t)rt_err_list[index].err_code == error) {\n            return rt_err_list[index].err_desc;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 58.74661858835349}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n\n    for (int i = 0; i < sizeof(rt_errors) / sizeof(rt_errors[0]); i++) {\n        if (rt_errors[i].code == error) {\n            return rt_errors[i].msg;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 65.16835929610903}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_uint32_t level;\n    struct rt_thread *thread;\n    rt_list_t *node;\n\n    if (hook == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    level = rt_hw_interrupt_disable();\n\n    for (node = rt_thread_idle_hook_list.next; node != &rt_thread_idle_hook_list; node = node->next) {\n        if (node->next == &rt_thread_idle_hook_list) {\n            thread = rt_malloc(sizeof(struct rt_thread));\n            if (thread == RT_NULL) {\n                rt_hw_interrupt_enable(level);\n                return -RT_ENOMEM;\n            }\n\n            rt_list_insert_after(&rt_thread_idle_hook_list, node, &thread->tlist);\n            thread->entry = (void *)hook;\n            thread->stack_addr = RT_NULL;\n            thread->stack_size = 0;\n            thread->priority = RT_THREAD_PRIORITY_MAX - 1;\n            thread->ticks = 0;\n            thread->numberofdone = 0;\n            thread->stat = RT_THREAD_INIT;\n            thread->init_priority = thread->priority;\n            thread->init_tick = thread->ticks;\n            thread->error = RT_EOK;\n            thread->cleanup = RT_NULL;\n            thread->user_data = RT_NULL;\n            thread->entry_parameter = RT_NULL;\n            thread->detach = RT_FALSE;\n            thread->uninterruptible = RT_FALSE;\n            thread->init_entry = RT_NULL;\n            thread->stack_guard = RT_NULL;\n            thread->stack_magic = 0xA5A55A5A;\n            thread->ref_count = 0;\n            thread->id = RT_NULL;\n            thread->name = \"idle\";\n           ", "CodeBleu_score": 30.53786753044937}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_uint32_t level;\n    struct rt_thread *thread;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n    thread = rt_thread_self();\n    if (thread->stat != RT_THREAD_READY) {\n        rt_hw_interrupt_enable(level);\n        return -RT_EPERM;\n    }\n\n    thread->idle_hook = hook;\n    rt_hw_interrupt_enable(level);\n    return RT_EOK;\n}", "CodeBleu_score": 26.69812519385929}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_list_t *l;\n    rt_uint32_t result;\n\n    /* Lock the spinlock */\n    result = rt_hw_spin_lock(&rt_thread_idle_hook_lock);\n    if (result != 0) {\n        return RT_EBUSY;\n    }\n\n    /* Iterate through the idle hook list */\n    for (l = rt_thread_idle_hook_list.next; l != &rt_thread_idle_hook_list; l = l->next) {\n        struct rt_thread_idle_hook *idle_hook;\n\n        idle_hook = rt_list_entry(l, struct rt_thread_idle_hook, list);\n        if (!idle_hook->hook) {\n            idle_hook->hook = hook;\n            rt_hw_spin_unlock(&rt_thread_idle_hook_lock);\n            return RT_EOK;\n        }\n    }\n\n    /* Release the spinlock and return an error */\n    rt_hw_spin_unlock(&rt_thread_idle_hook_lock);\n    return -RT_EFULL;\n}", "CodeBleu_score": 40.36681061887509}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_list_t *node;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    rt_enter_critical();\n\n    node = rt_list_find(&rt_thread_idle_hook_list, (void *)hook);\n    if (node != RT_NULL) {\n        rt_list_remove(&rt_thread_idle_hook_list, node);\n        rt_exit_critical();\n        return RT_EOK;\n    }\n\n    rt_exit_critical();\n    return -RT_ERROR;\n}", "CodeBleu_score": 26.299748046989542}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result = RT_EOK;\n    rt_list_t *node;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    /* lock interrupt */\n    rt_enter_critical();\n\n    /* iterate the idle hook list */\n    node = rt_thread_idle_sethook_list.next;\n    while (node != &rt_thread_idle_sethook_list) {\n        rt_thread_idle_hook_t *idle_hook;\n\n        idle_hook = rt_list_entry(node, rt_thread_idle_hook_t, list);\n        if (idle_hook->hook == hook) {\n            /* find the hook */\n            rt_list_remove(&(idle_hook->list));\n            rt_free(idle_hook);\n            break;\n        }\n        node = node->next;\n    }\n\n    if (node == &rt_thread_idle_sethook_list) {\n        /* not found */\n        result = -RT_ERROR;\n    }\n\n    /* unlock interrupt */\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 40.62027470419037}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result = RT_EOK;\n    rt_base_t level;\n    struct rt_thread *thread;\n    struct rt_thread *thread_tmp;\n\n    /* Disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* Check if the hook is in the idle hook list */\n    thread = rt_thread_self();\n    thread_tmp = thread;\n    while (thread_tmp->idle_hook != hook) {\n        thread_tmp = thread_tmp->next;\n        if (thread_tmp == thread) {\n            result = -RT_ERROR;\n            break;\n        }\n    }\n\n    /* If the hook is found, remove it from the list */\n    if (result == RT_EOK) {\n        thread_tmp->idle_hook = RT_NULL;\n    }\n\n    /* Enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 45.12404063949938}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_base_t level;\n\n    level = rt_hw_interrupt_disable();\n\n    while ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist)) != RT_NULL) {\n        rt_list_remove(&(thread->tlist));\n        thread->error = thread_error;\n        thread->stat = RT_THREAD_READY;\n        rt_thread_ready_priority_group |= thread->number_mask;\n\n        rt_thread_resume(thread);\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 30.094267405300723}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_err_t result = RT_EOK;\n\n    /* Deactivate the scheduler. */\n    rt_enter_critical();\n\n    /* Dequeue and wake up each suspended thread in the list. */\n    while ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist)) !=\n           susp_list) {\n        rt_list_remove(&thread->tlist);\n\n        /* Set the thread's error code and resume it. */\n        thread->error = thread_error;\n        thread->stat = RT_THREAD_READY;\n\n        rt_thread_resume(thread);\n\n        /* Yield to the next thread. */\n        rt_schedule();\n    }\n\n    /* Activate the scheduler. */\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 30.011314847592775}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_err_t result;\n    rt_thread_t thread;\n\n    /* Ensure the scheduler is unlocked */\n    if (rt_scheduler_lock_level() > 0) {\n        return RT_ERROR;\n    }\n\n    /* Dequeue and wake up each suspended thread from the list */\n    while ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist)) !=\n           susp_list) {\n        rt_list_remove(&thread->tlist);\n        result = rt_thread_resume(thread, thread_error);\n        if (result != RT_EOK) {\n            return result;\n        }\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 45.17069280373479}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device = rt_console_get_device();\n\n    if (old_device != RT_NULL && !rt_strcmp(old_device->name, name)) {\n        return old_device;\n    }\n\n    rt_device_t new_device = rt_device_find(name);\n    if (new_device == RT_NULL) {\n        rt_kprintf(\"There is no device on '%s'\n\", name);\n        return RT_NULL;\n    }\n\n    if (!rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM)) {\n        rt_kprintf(\"open %s device failed\n\", name);\n        return RT_NULL;\n    }\n\n    rt_console_set_device(new_device);\n\n    return old_device;\n}", "CodeBleu_score": 56.65186249456795}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device, new_device;\n    old_device = rt_console_get_device();\n    if (old_device != RT_NULL && rt_strcmp(old_device->name, name) == 0) {\n        return old_device;\n    }\n    new_device = rt_device_find(name);\n    if (new_device == RT_NULL) {\n        rt_kprintf(\"can't find device:%s\n\", name);\n        return RT_NULL;\n    }\n    if (new_device->flag & RT_DEVICE_FLAG_RDWR) {\n        if (new_device->open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX) != RT_EOK) {\n            rt_kprintf(\"open %s device failed\n\", name);\n            return RT_NULL;\n        }\n    } else {\n        if (new_device->open(new_device, RT_DEVICE_OFLAG_RDONLY | RT_DEVICE_FLAG_INT_RX) != RT_EOK) {\n            rt_kprintf(\"open %s device failed\n\", name);\n            return RT_NULL;\n        }\n    }\n    if (old_device != RT_NULL) {\n        old_device->close(old_device);\n    }\n    rt_console_set_device(new_device);\n    return new_device;\n}", "CodeBleu_score": 58.091593077241654}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device, new_device;\n\n    old_device = rt_console_get_device();\n\n    if (old_device != RT_NULL) {\n        /* close old device */\n        rt_device_close(old_device);\n    }\n\n    new_device = rt_device_find(name);\n    if (new_device != RT_NULL) {\n        /* open new device */\n        rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    }\n\n    rt_console_set_device_with_pointer(new_device);\n\n    return old_device;\n}", "CodeBleu_score": 51.00734962544434}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object_information *information;\n\n    information = rt_object_get_information(type);\n    if (information != RT_NULL) {\n        rt_spinlock_t *spinlock;\n\n        spinlock = (rt_spinlock_t *)information->object_list_lock;\n\n        /* enter critical */\n        if (spinlock != RT_NULL) {\n            rt_hw_spin_lock(spinlock);\n        }\n\n        /* iterate all object list */\n        count = information->object_list.length;\n\n        /* leave critical */\n        if (spinlock != RT_NULL) {\n            rt_hw_spin_unlock(spinlock);\n        }\n    }\n\n    return count;\n}", "CodeBleu_score": 51.53665132789607}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object *object;\n    struct rt_object_information *information;\n\n    /* Get the object information for the specified type */\n    information = rt_object_class_find(type);\n\n    /* If the information is not found, return 0 */\n    if (information == RT_NULL)\n        return 0;\n\n    /* Lock the spinlock for the object list */\n    rt_spin_lock(&information->object_list_lock);\n\n    /* Iterate through the object list and count the objects */\n    object = information->object_list;\n    while (object != RT_NULL) {\n        count++;\n        object = object->list.next;\n    }\n\n    /* Unlock the spinlock */\n    rt_spin_unlock(&information->object_list_lock);\n\n    return count;\n}", "CodeBleu_score": 54.1966128671898}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object *object;\n    struct rt_object_information *information;\n    rt_list_t *node;\n\n    information = rt_object_get_information(type);\n    if (information == RT_NULL) {\n        return 0;\n    }\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* traverse all object list */\n    rt_list_for_each(node, &(information->object_list)) {\n        object = rt_list_entry(node, struct rt_object, list);\n        count++;\n    }\n\n    /* leave critical */\n    rt_exit_critical();\n\n    return count;\n}", "CodeBleu_score": 59.37027893884378}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_object_t parent;\n    rt_list_t *l;\n\n    /* parameter check */\n    if (object == RT_NULL)\n        return;\n\n    /* detach object from management system */\n    parent = object->parent;\n    if (parent != RT_NULL) {\n        /* remove object from its parent's children list */\n        l = &(parent->children);\n        rt_list_remove(&(object->list));\n        /* unlock parent's spinlock */\n        rt_spin_unlock(&(parent->lock));\n    }\n\n    /* reset object's type */\n    object->type = 0;\n}", "CodeBleu_score": 38.25876018603985}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_object_t object_temp;\n    rt_list_t *node;\n    rt_object_information_t *information;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* get object information */\n    information = object->information;\n\n    /* lock object */\n    rt_spinlock_lock(&information->lock);\n\n    /* check object */\n    if (object->type != RT_Object_Class_Unknown) {\n        /* remove object from object list */\n        node = rt_list_find(&information->object_list, object);\n        if (node != RT_NULL) {\n            rt_list_remove(node);\n        }\n\n        /* call detach hook */\n        object_temp = object;\n        object = RT_NULL;\n        if (information->detach != RT_NULL) {\n            information->detach(object_temp);\n        }\n\n        /* unlock object */\n        rt_spinlock_unlock(&information->lock);\n\n        /* set object type to unknown */\n        object_temp->type = RT_Object_Class_Unknown;\n    } else {\n        /* unlock object */\n        rt_spinlock_unlock(&information->lock);\n    }\n}", "CodeBleu_score": 48.288718394998874}, {"code": "void rt_object_detach(rt_object_t object){\n\t    if (object == RT_NULL) {\n        return;\n    }\n\n    if (object->type & RT_Object_Class_Flag) {\n        rt_class_detach(object);\n        return;\n    }\n\n    rt_object_information_t info = object->information;\n    rt_spinlock_t *l = &(info->lock);\n    rt_base_t level;\n\n    rt_spin_lock_irqsave(l, level);\n    rt_list_remove(&(info->object_list));\n    rt_spin_unlock_irqrestore(l, level);\n\n    object->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 53.56944039055877}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n\n    /* parameter check */\n    RT_ASSERT(obj != RT_NULL);\n\n    if (obj->type != RT_Object_Class_Custom) {\n        return -RT_ERROR;\n    }\n\n    if (obj->ref_count != 0) {\n        return -RT_ERROR;\n    }\n\n    if (obj->destruct != RT_NULL) {\n        result = obj->destruct(obj);\n    }\n\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 49.64191019695979}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n    if (obj != RT_NULL) {\n        if (obj->type == RT_Object_Class_Custom) {\n            if (obj->custom_obj != RT_NULL) {\n                if (obj->custom_obj->destroy != RT_NULL) {\n                    result = obj->custom_obj->destroy(obj);\n                }\n                rt_free(obj->custom_obj);\n            }\n            rt_free(obj);\n        } else {\n            result = -RT_ERROR;\n        }\n    } else {\n        result = -RT_ERROR;\n    }\n    return result;\n}", "CodeBleu_score": 48.54259041928265}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_object_t parent;\n    rt_err_t result = RT_EOK;\n\n    /* check object */\n    RT_ASSERT(obj != RT_NULL);\n\n    /* check object class */\n    RT_ASSERT(rt_object_get_class(obj) == RT_Object_Class_Custom);\n\n    /* get parent object */\n    parent = rt_object_get_parent(obj);\n\n    /* call object destroy method */\n    if (obj->destroy != RT_NULL) {\n        result = obj->destroy(obj);\n    }\n\n    /* delete object */\n    rt_object_delete(obj);\n\n    /* if parent object is a thread */\n    if (rt_object_get_type(parent) == RT_Object_Class_Thread) {\n        /* resume thread */\n        rt_thread_resume(parent);\n    }\n\n    return result;\n}", "CodeBleu_score": 46.505116027915264}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n\n    /* get the current thread */\n    thread = rt_thread_self();\n\n    /* enter critical section */\n    rt_enter_critical();\n\n    /* close the thread */\n    rt_thread_close(thread);\n\n    /* add the thread to the defunct thread list */\n    rt_object_detach(&(thread->object));\n\n    /* exit critical section */\n    rt_exit_critical();\n\n    /* trigger a context switch */\n    rt_schedule();\n}", "CodeBleu_score": 36.84243387202708}, {"code": "static void _thread_exit(void){\n\t    struct rt_thread *thread = rt_thread_self();\n    rt_enter_critical();\n    rt_thread_close(thread);\n    rt_exit_critical();\n    rt_schedule();\n}", "CodeBleu_score": 31.081287525342493}, {"code": "static void _thread_exit(void){\n\t    struct rt_thread *thread;\n    thread = rt_thread_self();\n\n    rt_enter_critical();\n\n    rt_thread_close(thread);\n\n    rt_exit_critical();\n\n    rt_schedule();\n}", "CodeBleu_score": 40.70928306071771}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n\n    RT_ASSERT(parameter != RT_NULL);\n\n    thread = (struct rt_thread *)parameter;\n\n    /* check thread */\n    if ((thread->stat & RT_THREAD_STAT_SUSPEND) == 0) {\n        return;\n    }\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* set error number */\n    thread->error = -RT_ERROR;\n\n    /* insert into ready list */\n    rt_list_insert_after(&(rt_thread_priority_table[thread->current_priority].thread_list), &(thread->tlist));\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 52.800501137572674}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    thread = (rt_thread_t)parameter;\n\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread:%s suspended, time out!!\n\", thread->name));\n\n    RT_ASSERT(thread->stat & RT_THREAD_STAT_SUSPEND);\n\n    thread->error = -RT_ETIMEOUT;\n\n    rt_thread_suspend(thread);\n\n    rt_schedule();\n}", "CodeBleu_score": 38.8419676387455}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n\n    RT_ASSERT(parameter != RT_NULL);\n\n    thread = (struct rt_thread *)parameter;\n\n    /* check thread */\n    if ((thread->stat & RT_THREAD_STAT_SUSPEND) == 0) {\n        return;\n    }\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert into ready list */\n    rt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]),\n                         &(thread->tlist));\n\n    /* ready */\n    thread->stat = RT_THREAD_READY;\n\n    /* switch to next thread */\n    rt_schedule();\n}", "CodeBleu_score": 53.4442439093318}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_mutex_t mutex;\n\n    level = rt_hw_interrupt_disable();\n    mutex = thread->mutex_pending;\n    if (mutex) {\n        thread->mutex_pending = RT_NULL;\n        rt_mutex_release(mutex);\n    }\n\n    rt_hw_spin_lock(&thread->lock);\n    thread->mutex_nest = 0;\n    rt_hw_spin_unlock(&thread->lock);\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 30.273359868354564}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_uint32_t level;\n    rt_thread_t owner;\n    struct rt_mutex *mutex;\n    rt_list_t *node;\n\n    level = rt_hw_interrupt_disable();\n\n    /* Detach the thread from any mutex it is waiting on or has taken */\n    mutex = thread->mutex_pending;\n    if (mutex) {\n        rt_mutex_owner_set(mutex, RT_NULL);\n        thread->mutex_pending = RT_NULL;\n\n        /* Remove the thread from the mutex's waiting list */\n        rt_list_for_each(node, &mutex->wait_list) {\n            if (rt_list_entry(node, struct rt_mutex_waiter, list) == thread) {\n                rt_list_remove(&thread->list);\n                break;\n            }\n        }\n\n        /* Clear the pending object */\n        rt_object_unref(mutex);\n    }\n\n    /* Restore the spinlock state */\n    rt_hw_spin_unlock(&thread->lock);\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 54.42812984904957}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_mutex_t mutex;\n\n    rt_enter_critical();\n\n    level = rt_hw_interrupt_disable();\n\n    mutex = thread->mutex;\n\n    if (mutex) {\n        rt_list_remove(&(thread->tlist));\n        thread->mutex = RT_NULL;\n\n        if (mutex->owner == thread) {\n            mutex->owner = RT_NULL;\n        }\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    rt_exit_critical();\n}", "CodeBleu_score": 29.04754134306732}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->entry != RT_NULL);\n\n    rt_kprintf(\"thread %s(0x%p) startup\n\", thread->name, thread);\n\n    thread->stat = RT_THREAD_SUSPEND;\n    thread->errno = RT_EOK;\n    thread->ticks = thread->init_tick;\n    thread->remaining_tick = thread->init_tick;\n\n    thread->priority = thread->init_priority;\n    thread->number_mask = 1 << thread->init_priority;\n\n    result = rt_thread_resume(thread);\n    if (result == RT_EOK) {\n        if (rt_thread_self() != RT_NULL) {\n            rt_schedule();\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 46.50752192128807}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    RT_ASSERT(thread != RT_NULL);\n\n    if (thread->stat != RT_THREAD_INIT) {\n        return -RT_ERROR;\n    }\n\n    if (thread->entry != RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    rt_kprintf(\"thread %s start\n\", thread->name);\n\n    rt_thread_init(thread);\n\n    thread->stat = RT_THREAD_SUSPEND;\n\n    rt_thread_resume(thread);\n\n    if (rt_thread_self() != RT_NULL) {\n        rt_schedule();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 53.580132080848266}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\n    RT_ASSERT(thread != RT_NULL);\n\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    RT_ASSERT(thread->entry != RT_NULL);\n\n    rt_kprintf(\"thread %s startup\n\", thread->name);\n\n    thread->stat = RT_THREAD_SUSPEND;\n\n    thread->ticks = 0;\n\n    thread->remaining_tick = 0;\n\n    thread->priority = thread->init_priority;\n\n    thread->number_mask = 1 << thread->number;\n\n    thread->error = RT_EOK;\n\n    thread->entry(thread->parameter);\n\n    thread->stat = RT_THREAD_CLOSE;\n\n    rt_schedule();\n\n    return RT_EOK;\n\n}", "CodeBleu_score": 47.426736107981434}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_timer_t timer;\n\n    timer = rt_list_entry(rt_list_first(&timer_list[0]), rt_timer_t, list);\n    if (timer == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    *timeout_tick = timer->timeout;\n\n    return RT_EOK;\n}", "CodeBleu_score": 43.55772220353541}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *node;\n\n    if (rt_list_isempty(&timer_list[0])) {\n        return -RT_ETIMEOUT;\n    }\n\n    node = rt_list_first(&timer_list[0]);\n    if (node) {\n        *timeout_tick = ((rt_timer_t *)node)->timeout_tick;\n        return RT_EOK;\n    }\n\n    return -RT_ETIMEOUT;\n}", "CodeBleu_score": 44.75394885238801}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *node;\n    rt_timer_t *timer;\n\n    node = rt_list_first(&timer_list[0]);\n    if (node != &(timer_list[0])) {\n        timer = rt_list_entry(node, struct rt_timer, list);\n        *timeout_tick = timer->timeout;\n        return RT_EOK;\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 45.180387974777695}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL) {\n        rt_timer_init(timer, name, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}", "CodeBleu_score": 53.293562206995084}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate memory for the timer object */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL) {\n        LOG_E(\"Lack of memory for timer object creation\");\n        return RT_NULL;\n    }\n\n    /* initialize the timer object */\n    rt_timer_init(timer, name, timeout, parameter, time, flag);\n\n    /* return the timer object */\n    return timer;\n}", "CodeBleu_score": 64.86176895139954}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n    RT_ASSERT(timeout != RT_NULL);\n\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL) {\n        timer->timeout_func = (void (*)(void *parameter))timeout;\n        timer->parameter = parameter;\n        timer->init_tick = timer->timeout_tick = rt_tick_get();\n        timer->timeout = time;\n        timer->flag = flag;\n\n        rt_list_init(&(timer->list));\n    }\n\n    return timer;\n}", "CodeBleu_score": 49.82595169287802}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\trobot := gobot.FromContext(req.Context())\n\ta.handlers.ServeHTTP(rec, req)\n\n\tif rec.Code == http.StatusUnauthorized {\n\t\ta.sendError(res, http.StatusUnauthorized, \"Not Authorized\")\n\t\treturn\n\t}\n\n\ta.router.ServeHTTP(res, req.WithContext(gobot.WithRobot(req.Context(), robot)))\n}", "CodeBleu_score": 43.13169808784059}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\n\ta.handlers.ServeHTTP(rec, req)\n\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\n\tif rec.Code == http.StatusUnauthorized {\n\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\tres.Write([]byte(`{\"error\": \"Not Authorized\"}`))\n\t\treturn\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 61.60991997180104}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tw := httptest.NewRecorder()\n\ta.handlers.ServeHTTP(w, req)\n\tfor k, v := range w.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tif w.Code == 401 {\n\t\tres.WriteHeader(401)\n\t\tres.Write([]byte(\"Not Authorized\"))\n\t\treturn\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 50.504682210293176}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tfile := fmt.Sprintf(\"%v%v\", a.staticPath, req.URL.Path)\n\tasset, err := Asset(file)\n\n\tif err != nil {\n\t\tres.WriteHeader(404)\n\t\tres.Write([]byte(fmt.Sprintf(\"404: %v\", req.URL.Path)))\n\t\treturn\n\t}\n\n\tswitch {\n\tcase strings.Contains(req.URL.Path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase strings.Contains(req.URL.Path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.Contains(req.URL.Path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(asset)\n}", "CodeBleu_score": 51.72180983156195}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tfile := strings.Replace(req.URL.Path, \"/robeaux/\", \"\", 1)\n\tasset, err := robeaux.Asset(file)\n\tif err != nil {\n\t\thttp.Error(res, fmt.Sprintf(\"%s\", err), http.StatusNotFound)\n\t\treturn\n\t}\n\tswitch {\n\tcase strings.Contains(file, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase strings.Contains(file, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.Contains(file, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 55.62590666450304}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path[1:]\n\tdata, err := Asset(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tswitch {\n\tcase strings.HasSuffix(path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase strings.HasSuffix(path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(data)\n}", "CodeBleu_score": 59.10308684872335}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := getRequestParam(req, \"robot\")\n\trobot := a.findRobot(robotName)\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(robeaux.JSONRobotError{\n\t\t\tStatus:  \"error\",\n\t\t\tMessage: fmt.Sprintf(\"no robot with the name %s\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := make(map[string][]string)\n\tfor _, device := range robot.Devices() {\n\t\tconnections[device.Name()] = device.Connection().ConnectedAdaptors()\n\t}\n\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 45.82573475875853}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := getRequestParam(req, \"robot\")\n\trobot := a.findRobot(robotName)\n\tif robot == nil {\n\t\tjsonError(res, fmt.Sprintf(\"no robot with name %s\", robotName))\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\tjsonRobotConnections(res, connections)\n}", "CodeBleu_score": 22.448617086126323}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := a.getRobotName(req)\n\trobot := a.findRobot(robotName)\n\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(robeaux.JSON{\n\t\t\t\"error\": fmt.Sprintf(\"robot with name %s not found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := make(map[string][]string)\n\tfor name, adaptor := range robot.Connections() {\n\t\tconnections[name] = adaptor.ConnectedAdaptors()\n\t}\n\n\tjson.NewEncoder(res).Encode(robeaux.JSON{\n\t\t\"robot\":       robotName,\n\t\t\"connections\": connections,\n\t})\n}", "CodeBleu_score": 41.37484044671942}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(u), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(p), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.16000456377083}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Please enter your username and password for this site\"`)\n\t\t\tw.WriteHeader(401)\n\t\t\tw.Write([]byte(\"Not authorized.\n\"))\n\t\t\treturn\n\t\t}\n\t\tuOk := subtle.ConstantTimeCompare([]byte(u), []byte(username)) == 1\n\t\tpOk := subtle.ConstantTimeCompare([]byte(p), []byte(password)) == 1\n\t\tif !(uOk && pOk) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Please enter your username and password for this site\"`)\n\t\t\tw.WriteHeader(401)\n\t\t\tw.Write([]byte(\"Not authorized.\n\"))\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 45.57817072653456}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tauthParts := strings.SplitN(auth, \" \", 2)\n\t\tif len(authParts) != 2 || authParts[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tdecoded, err := base64.StdEncoding.DecodeString(authParts[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tuserPass := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(userPass) != 2 || subtle.ConstantTimeCompare([]byte(userPass[0]), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(userPass[1]), []byte(password)) != 1 {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.08049865405636}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\tslope := float64(toRange) / fromRange\n\tintercept := float64(toMin) - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tscaled := slope*input + intercept\n\t\tvalue = int(scaled + 0.5)\n\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn value\n\t}\n}", "CodeBleu_score": 51.79046213296705}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax-toMin)/(fromMax-fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.10584206726946}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax-toMin) / (fromMax-fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 53.49800080699909}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"analogSensorDriver connection not initialized\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) / float64(a.connection.AnalogMax()) * a.SensorRange\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 50.06110473784907}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"analogSensorDriver connection not initialized\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) * a.scalingFactor\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 47.33890762525361}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"analogSensorDriver connection not initialized\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastValue = float64(raw) * a.scalingFactor\n\n\treturn raw, a.lastValue, nil\n}", "CodeBleu_score": 48.4225215849685}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\treturn func(input int) float64 {\n\t\tscaled := m * float64(input) + n\n\t\tif scaled > toMax {\n\t\t\treturn toMax\n\t\t} else if scaled < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\treturn scaled\n\t}\n}", "CodeBleu_score": 71.8489925860445}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\toldRange := float64(fromMax - fromMin)\n\tnewRange := toMax - toMin\n\tslope := newRange / oldRange\n\tn := toMin - slope*float64(fromMin)\n\treturn func(v int) float64 {\n\t\treturn slope*float64(v) + n\n\t}\n}", "CodeBleu_score": 54.995404744778874}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\n\treturn func(value int) float64 {\n\t\tscaled := m * float64(value) + n\n\n\t\tif scaled < toMin {\n\t\t\treturn toMin\n\t\t} else if scaled > toMax {\n\t\t\treturn toMax\n\t\t}\n\n\t\treturn scaled\n\t}\n}", "CodeBleu_score": 69.84576174351824}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 1*Second, opts...),\n\t\tDefaultName:        \"GrovePiezoVibrationSensor\",\n\t}\n\td.AddEvent(Vibration)\n\n\td.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 61.56134240661668}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, 1*time.Second, opts...)\n\td.SetName(GrovePiezoVibrationSensor)\n\td.AddEvent(Vibration)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: d,\n\t}\n}", "CodeBleu_score": 61.162695629467024}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, opts...)\n\n\td.SetName(GrovePiezoVibrationSensor)\n\td.AddEvent(Vibration)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: d,\n\t}\n}", "CodeBleu_score": 61.59387686387049}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := 1 / hz\n\ttempo := 60 / d.bpm\n\n\tsteps := int(duration/(tempo*period)) + 1\n\tfor i := 0; i < steps; i++ {\n\t\td.On()\n\t\ttime.Sleep(time.Duration(tempo*period/2) * time.Second)\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(tempo*period/2) * time.Second)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 37.17903468158501}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\td.toneMutex.Lock()\n\tdefer d.toneMutex.Unlock()\n\n\tperiod := uint32(1000000 / hz)\n\ttempo := uint32(60 / d.bpm * 1000)\n\n\tsteps := uint32(duration/(float64(period)*4)) - 1\n\n\tgo func() {\n\t\tfor i := uint32(0); i < steps; i++ {\n\t\t\td.On()\n\t\t\t<-time.After(time.Duration(period) * time.Microsecond)\n\n\t\t\td.Off()\n\t\t\t<-time.After(time.Duration(period) * time.Microsecond)\n\t\t}\n\n\t\td.Off()\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 38.89367323896661}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif duration == 0 {\n\t\treturn nil\n\t}\n\n\ttonePeriod := uint64(1000000 / hz)\n\ttempo := uint64(60 / d.bpm * 1000)\n\tsteps := uint64(duration/(tempo/1000)) + 1\n\n\tfor i := uint64(0); i < steps; i++ {\n\t\td.On()\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Microsecond)\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(tempo) * time.Microsecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.42566425435027}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.SleepPin == \"\" {\n\t\treturn fmt.Errorf(\"Sleep pin is not set\")\n\t}\n\n\td.haltEverything()\n\td.CurrentStepper.SetSpeed(0)\n\td.CurrentStepper.Off()\n\n\tif err := d.board.DigitalWrite(d.SleepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 52.96239949988052}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.SleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.haltWhatWeAreDoing()\n\n\terr := d.connection.DigitalWrite(d.SleepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 49.81393579981781}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.Stop()\n\n\td.sleepPin.Low()\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 30.257989130068808}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"must call InitPins() first\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, pin, err := translateAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taPin := system.NewAnalogPin(a.sys, path, pin)\n\tif err := aPin.Export(); err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = aPin\n\n\treturn aPin, nil\n}", "CodeBleu_score": 48.64130938930442}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.pinsLock.Lock()\n\tdefer a.pinsLock.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"must call AnalogPinsAdaptor.Connect() first\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, pin, err := translateAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taPin := system.NewAnalogPin(a.sys, path, pin)\n\tif err := aPin.Export(); err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = aPin\n\treturn aPin, nil\n}", "CodeBleu_score": 48.285280998952715}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"must call InitPins() first\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, pin, err := translateAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = newAnalogPin(a, path, pin)\n\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 51.041300637785135}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.DigitalPin(id, gpio.ModeOutput)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 67.07629029027986}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.DigitalPin(id, gobot.PinModeOutput)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 67.30832741680119}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.DigitalPin(id, gpio.ModeOutput)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 67.07629029027986}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins are registered\")\n\t}\n\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\ti, l, err := translateDigitalPin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = system.NewDigitalPin(a, i, l)\n\t\ta.pins[id] = pin\n\t}\n\n\tfor _, option := range opts {\n\t\toption(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 46.34643847975821}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins are registered yet\")\n\t}\n\n\ti, err := a.translatePin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif p, ok := a.pins[i]; ok {\n\t\tif len(opts) > 0 {\n\t\t\topts[0](p)\n\t\t}\n\t\treturn p, nil\n\t}\n\n\tchip, line, err := a.sys.GpioPinToReg(i)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp, err := system.NewDigitalPin(a.sys, chip, line)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_ = p.ApplyOpts(opts...)\n\n\tif err := p.Export(); err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[i] = p\n\treturn p, nil\n}", "CodeBleu_score": 57.045401401510574}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins are registered\")\n\t}\n\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tvar err error\n\t\tpin, err = system.NewDigitalPin(a.sys, id, append(a.pinOpts, opts...)...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t} else {\n\t\tpin.ApplyOpts(opts...)\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 48.29422784773194}]}
