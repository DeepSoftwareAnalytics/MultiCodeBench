{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> required_files;\n  try {\n    required_files = _client.call(\"get_required_files\", folder).as<std::vector<std::string>>();\n  } catch (const rpc::timeout &) {\n    throw_timeout(\"get_required_files\");\n  }\n\n  if (download) {\n    for (const auto &file : required_files) {\n      const auto local_file = FileTransfer::NFS2Map(file);\n      if (FileTransfer::FileExists(local_file)) {\n        log_info(\"file found in cache:\", local_file);\n      } else {\n        log_info(\"downloading file:\", local_file);\n        FileTransfer::DownloadFile(file, local_file);\n      }\n    }\n  }\n  return required_files;\n}", "CodeBleu_score": 56.879035904399856}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> files;\n  for (const auto &file : GetFileTransfer().GetFilesInDirectory(folder)) {\n    if (download) {\n      if (!GetFileTransfer().FileExists(file)) {\n        GetFileTransfer().DownloadFile(file);\n        log_debug(\"downloaded\", file);\n      } else {\n        log_debug(\"found in cache\", file);\n      }\n    }\n    files.push_back(file);\n  }\n  return files;\n}", "CodeBleu_score": 55.99214351515961}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> files;\n  for (const auto &file : _client.call(\"get_required_files\", folder).as<std::vector<std::string>>()) {\n    if (download) {\n      auto path = FileTransfer::NFSFilePath(folder, file);\n      if (FileTransfer::Exists(path)) {\n        log_info(\"file found in cache:\", path);\n      } else {\n        log_info(\"downloading file:\", file);\n        _client.call(\"download_file\", folder, file);\n      }\n    }\n    files.push_back(file);\n  }\n  return files;\n}", "CodeBleu_score": 59.36960024979365}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the attachment type is SpringArm or SpringArmGhost\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the transformation is ill-formed\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f &&\n        transform.location.z != 0.0f &&\n        transform.rotation.pitch == 0.0f && transform.rotation.yaw == 0.0f &&\n        transform.rotation.roll == 0.0f) {\n      // Issue a warning if the transformation is ill-formed\n      log_warning(\n          \"SpringArm and SpringArmGhost attachments only work with a translation in the 'z' axis. \"\n          \"This is a known issue and will be fixed in a future version.\");\n    }\n  }\n\n  // Call an internal function to complete the actor spawning process\n  return _spawn_actor_with_parent(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 44.90264739579113}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  rpc::Actor actor;\n  try {\n    actor = _client.SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n  } catch (rpc::timeout &) {\n    throw_timeout(\"SpawnActorWithParent\");\n  }\n  return actor;\n}", "CodeBleu_score": 28.902170643031933}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  rpc::Actor actor;\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x != 0.0f || transform.location.y != 0.0f) {\n      log_warning(\n        \"Invalid transformation for attachment type SpringArm or SpringArmGhost. Translation should be only in the 'z' axis.\");\n    }\n  }\n  actor = SpawnActorWithParentImpl(description, transform, parent, attachment_type, socket_name);\n  return actor;\n}", "CodeBleu_score": 44.50737807488334}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n  auto token = _client.call(\"SubscribeToGBuffer\", ActorId, GBufferId).as<std::vector<uint8_t>>();\n\n  Buffer tokenBuffer(token.size());\n  std::memcpy(tokenBuffer.data(), token.data(), token.size());\n\n  _streaming_client.Subscribe(tokenBuffer, callback);\n}", "CodeBleu_score": 48.66905342892293}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n  rpc::GbufferToken token = _client.call(\"GetGbufferToken\", ActorId, GBufferId).as<rpc::GbufferToken>();\n\n  rpc::GbufferToken token_copy;\n  token_copy.set_token(token.token());\n  token_copy.set_width(token.width());\n  token_copy.set_height(token.height());\n  token_copy.set_format(token.format());\n\n  _streaming_client.Subscribe(token_copy, callback);\n}", "CodeBleu_score": 41.62513058081269}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token = Client::GetGBufferToken(ActorId, GBufferId);\n  auto token_data = token.data();\n  auto token_size = token.size();\n\n  streaming_client.Subscribe(\n      std::string(reinterpret_cast<const char*>(token_data), token_size),\n      [callback](carla::Buffer buffer) {\n        callback(buffer);\n      });\n}", "CodeBleu_score": 47.53572131716316}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  auto navigation = _navigation.lock();\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(GetId(), _client);\n    if (!_navigation.compare_exchange_strong(navigation, navigation)) {\n      navigation = _navigation.lock();\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 52.62576419256681}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(GetId());\n    if (!navigation->Set(client)) {\n      navigation = nullptr;\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 38.71984352754181}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    if (_navigation == nullptr) {\n        _navigation = std::make_shared<WalkerNavigation>(this);\n        try {\n            SetNavigation(_navigation);\n        } catch (const std::exception &e) {\n            log_error(\"failed to set navigation:\", e.what());\n        }\n    }\n    return _navigation;\n}", "CodeBleu_score": 44.12206911125821}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto start = std::chrono::system_clock::now();\n  while (episode.GetFrame() < frame) {\n    if (std::chrono::system_clock::now() - start > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.Tick();\n  return true;\n}", "CodeBleu_score": 38.91040596469239}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto start = std::chrono::system_clock::now();\n  while (episode.GetFrame() < frame) {\n    if (std::chrono::system_clock::now() - start > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.Tick(frame);\n  return true;\n}", "CodeBleu_score": 40.45096534633175}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::system_clock::now();\n  while (episode.GetFrame() < frame) {\n    if (timeout != time_duration::zero() && (std::chrono::system_clock::now() - start) > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.Tick();\n  return true;\n}", "CodeBleu_score": 41.05179091936595}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n  auto episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n  auto episode = EpisodeProxy{this, episode_id};\n  episode.WaitForAvailability();\n  return episode;\n}", "CodeBleu_score": 25.895974037831227}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  EpisodeProxy episode;\n  constexpr auto timeout_ms = 10000;\n  constexpr auto sleep_time_ms = 100;\n  constexpr auto max_attempts = timeout_ms / sleep_time_ms;\n\n  for (auto i = 0u; i < max_attempts; ++i) {\n    episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n    if (episode.GetId() != _episode_id) {\n      _episode_id = episode.GetId();\n      break;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(sleep_time_ms));\n  }\n  if (episode.GetId() != _episode_id) {\n    throw_exception(std::runtime_error(\"timeout while loading episode\"));\n  }\n  return episode;\n}", "CodeBleu_score": 59.75672140834397}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  try {\n    const auto episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n    return EpisodeProxy{this, episode_id};\n  } catch (const std::exception &e) {\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(1s);\n    throw_exception(std::runtime_error(std::string(\"failed to load episode: \") + e.what()));\n  }\n}", "CodeBleu_score": 34.66954254875161}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    auto walker = GetWalker(controller.GetId());\n    if (!walker) {\n        throw_exception(std::runtime_error(\"AI controller not found\"));\n    }\n    assert(episode != nullptr);\n    if (navigation == nullptr) {\n        navigation = std::make_unique<detail::WalkerNavigation>(episode->GetId());\n    }\n    navigation->RegisterWalker(walker->GetId());\n}", "CodeBleu_score": 56.55715530693387}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = GetWalker(controller.GetId());\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"failed to find walker with id \" + std::to_string(controller.GetId())));\n  }\n  assert(episode != nullptr);\n  auto navigation = episode->GetNavigation();\n  if (navigation == nullptr) {\n    navigation = episode->MakeNavigation();\n  }\n  navigation->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 65.51937444630931}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = controller.GetWalker();\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"WalkerAIController not associated with a walker.\"));\n  }\n  assert(episode != nullptr);\n  if (navigation == nullptr) {\n    navigation = std::make_unique<detail::WalkerNavigation>(*this);\n  }\n  navigation->RegisterController(*walker, controller.GetId());\n}", "CodeBleu_score": 58.344315583165795}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  auto actor = SpawnActor(blueprint, transform, parent, attachment_type, gc);\n  actor->SetSocketName(socket_name);\n  return actor;\n}", "CodeBleu_score": 24.399555559662122}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  auto result = _episode->RegisterActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n  if (result.has_error()) {\n    throw_exception(std::make_exception_ptr(result.error()));\n  }\n  auto actor = result.value();\n  _garbage_collector.RegisterActor(actor, gc);\n  if (parent != nullptr) {\n    log_debug(\n        \"spawned actor\",\n        actor->GetDisplayId(),\n        \"as child of\",\n        parent->GetDisplayId(),\n        \"with attachment\",\n        static_cast<int>(attachment_type));\n  } else {\n    log_debug(\"spawned actor\", actor->GetDisplayId());\n  }\n  return actor;\n}", "CodeBleu_score": 48.896607735199396}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  auto actor = _impl->SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n  _impl->RegisterActor(actor, gc);\n  log_debug(\"created actor\", actor->GetDisplayId(), \"with blueprint\", blueprint.GetId());\n  return actor;\n}", "CodeBleu_score": 33.137565483898214}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (!_episode.IsValid()) {\n    log_error(\n        \"episode is not valid, can't subscribe to sensor:\",\n        sensor.GetDisplayId());\n    return;\n  }\n  const auto stream = _client->SubscribeToStream(sensor.GetToken());\n  stream->Listen([\n      weak_episode = WeakPtr<Episode>(_episode),\n      callback = std::move(callback)](Buffer buffer) mutable {\n    const auto episode = weak_episode.lock();\n    if (episode != nullptr) {\n      const auto data = episode->DeserializeSensorData(std::move(buffer));\n      if (data != nullptr) {\n        callback(std::move(data));\n      }\n    }\n  });\n}", "CodeBleu_score": 52.56981017307301}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (!_episode.IsValid()) {\n    throw_exception(std::runtime_error(\"This Simulator has no episode\"));\n  }\n\n  auto stream_token = _client->SubscribeToStream(sensor.GetToken());\n\n  auto callback_with_deserialization = [\n    callback,\n    this,\n    sensor_token = sensor.GetToken()\n  ](Buffer buffer) {\n    auto data = sensor::Deserializer::Deserialize(buffer);\n    data->SetEpisodeId(_episode.GetId());\n    data->SetSensorToken(sensor_token);\n    callback(data);\n  };\n\n  _client->SetStreamCallback(stream_token, callback_with_deserialization);\n}", "CodeBleu_score": 51.55315513630996}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  auto episode = _episode.load();\n  if (episode == nullptr) {\n    throw_exception(std::runtime_error(\"Simulator has no episode running\"));\n  }\n  auto stream = episode->GetClient().SubscribeToStream(sensor.GetToken());\n  stream.Listen([\n      episode = episode->GetId(),\n      callback = std::move(callback)\n  ](auto data) {\n    auto sensor_data = sensor::Deserializer::Deserialize(std::move(data));\n    sensor_data->SetEpisodeId(episode);\n    callback(std::move(sensor_data));\n  });\n}", "CodeBleu_score": 53.486636944163166}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    const auto &client = episode->GetClient();\n    const auto &world = episode->GetWorld();\n    const auto &navigation = episode->GetNavigation();\n    const auto &state = episode->GetState();\n\n    auto walkers = state->GetWalkers();\n    if (walkers.empty()) {\n        return;\n    }\n\n    const auto &current_state = episode->GetCurrentState();\n    state->RemoveNonExistentWalkers(current_state);\n\n    navigation->UpdateVehiclesInCrowd(world, walkers);\n    navigation->UpdateCrowdCenters(world, walkers);\n\n    for (auto &&walker : walkers) {\n        const auto &transform = walker->GetTransform();\n        const auto &speed = walker->GetSpeed();\n        client->ApplyBatchSync([&](auto &client) {\n            client.SetTransformSync(walker, transform);\n            client.SetVelocitySync(walker, speed);\n        });\n    }\n\n    state->CheckForKilledWalkers(current_state);\n}", "CodeBleu_score": 39.56697903872066}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    auto walkers = episode->GetCurrentWalkers();\n    if (walkers.empty()) {\n        return;\n    }\n    auto state = episode->GetState();\n    auto walkers_to_remove = state->GetWalkersToRemove();\n    for (auto id : walkers_to_remove) {\n        auto it = std::find_if(walkers.begin(), walkers.end(), [id](auto &walker) {\n            return walker.GetId() == id;\n        });\n        if (it != walkers.end()) {\n            walkers.erase(it);\n        }\n    }\n    episode->GetNavigation()->UpdateVehiclesInCrowd(walkers);\n    episode->GetNavigation()->UpdateCrowd(walkers);\n    for (auto &walker : walkers) {\n        auto transform = walker.GetTransform();\n        auto speed = walker.GetSpeed();\n        auto batch = episode->GetSimulator()->MakeCommand();\n        batch->ApplyWalkerState(walker.GetId(), transform, speed);\n        episode->GetSimulator()->ApplyBatch(*batch);\n        if (walker.IsDead()) {\n            episode->GetNavigation()->RemoveWalker(walker.GetId());\n            walker.DestroyController();\n        }\n    }\n}", "CodeBleu_score": 47.87806452740608}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto walkers = episode->GetCurrentWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n  auto state = episode->GetState();\n  auto current_walkers = state->GetWalkers();\n  for (auto &&walker : walkers) {\n    current_walkers.erase(walker->GetId());\n  }\n  episode->GetNavigation()->UpdateVehicles(walkers);\n  episode->GetNavigation()->UpdateCrowd();\n  for (auto &&walker : walkers) {\n    auto transform = walker->GetTransform();\n    auto speed = walker->GetCurrentSpeed();\n    episode->GetSimulator()->ApplyBatch([&walker, transform, speed](auto &client) {\n      client.SetActorTransform(walker->GetId(), transform);\n      client.SetActorVelocity(walker->GetId(), speed);\n    });\n  }\n  for (auto &&walker : current_walkers) {\n    auto &id = walker.first;\n    auto &controller = walker.second;\n    if (controller->IsDead()) {\n      episode->GetNavigation()->RemoveVehicle(id);\n      controller->Destroy();\n    }\n  }\n}", "CodeBleu_score": 43.6880461405161}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = GetUid();\n  description.id = GetId();\n  description.attributes.reserve(GetAttributes().size());\n  for (auto &&attribute : GetAttributes()) {\n    description.attributes.emplace_back(attribute.second);\n  }\n  return description;\n}", "CodeBleu_score": 65.60712752398688}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = GetUid();\n  description.id = GetId();\n  description.attributes.reserve(GetAttributes().size());\n  for (auto &&attribute : GetAttributes()) {\n    description.attributes.push_back(std::move(attribute));\n  }\n  return description;\n}", "CodeBleu_score": 66.5956261020884}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = GetUid();\n  description.id = GetId();\n  description.attributes.reserve(GetAttributes().size());\n  for (auto &&attribute : GetAttributes()) {\n    description.attributes.emplace_back(attribute);\n  }\n  return description;\n}", "CodeBleu_score": 68.8902199053818}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  std::vector<SharedPtr<BlueprintLibrary>> result;\n  for (auto &blueprint : _blueprints) {\n    if (blueprint->HasAttribute(name)) {\n      if (blueprint->GetAttribute(name).GetRecommendedValues().size() > 0) {\n        for (auto &recommended_value : blueprint->GetAttribute(name).GetRecommendedValues()) {\n          if (recommended_value == value) {\n            result.emplace_back(blueprint);\n            break;\n          }\n        }\n      } else {\n        if (blueprint->GetAttribute(name).GetValue() == value) {\n          result.emplace_back(blueprint);\n        }\n      }\n    }\n  }\n  return SharedPtr<BlueprintLibrary>(new BlueprintLibrary(result));\n}", "CodeBleu_score": 53.96081275844674}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  auto result = std::make_shared<BlueprintLibrary>();\n  for (auto &bp : _blueprints) {\n    if (bp.second.ContainsAttribute(name)) {\n      if (bp.second.GetAttribute(name).GetRecommendedValues().size() > 0) {\n        for (auto &recommended_value : bp.second.GetAttribute(name).GetRecommendedValues()) {\n          if (recommended_value == value) {\n            result->_blueprints[bp.first] = bp.second;\n            break;\n          }\n        }\n      } else {\n        if (bp.second.GetAttribute(name).GetValue() == value) {\n          result->_blueprints[bp.first] = bp.second;\n        }\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 54.73635444659537}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  std::vector<SharedPtr<Blueprint>> result;\n  std::copy_if(\n      begin(),\n      end(),\n      std::back_inserter(result),\n      [&](auto &&bp) {\n        auto attr = bp->GetAttribute(name);\n        return attr != nullptr && (attr->GetValue() == value || attr->GetRecommendedValues().find(value) != attr->GetRecommendedValues().end());\n      });\n  return SharedPtr<BlueprintLibrary>(new BlueprintLibrary(result));\n}", "CodeBleu_score": 37.16096151531361}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string filePath = baseFolder + \"/\" + path + \"_\" + CARLA_VERSION;\n    std::filesystem::path filePathObj(filePath);\n    std::filesystem::path filePathObjParent = filePathObj.parent_path();\n    if (!std::filesystem::exists(filePathObjParent)) {\n        std::filesystem::create_directories(filePathObjParent);\n    }\n    std::ofstream file(filePath, std::ios::binary | std::ios::trunc);\n    if (file.is_open()) {\n        file.write(reinterpret_cast<const char*>(content.data()), content.size());\n        file.close();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 42.10920029411358}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string fullPath = baseFolder + \"/\" + path;\n\n    if (fullPath.find(\"..\") != std::string::npos) {\n        return false;\n    }\n\n    std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n    if (file.is_open()) {\n        file.write(reinterpret_cast<const char*>(content.data()), content.size());\n        file.close();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 45.07133945528528}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string fullPath = GetBaseFolder() + \"/\" + path;\n    if (!ValidateFilePath(fullPath)) {\n        return false;\n    }\n    std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n    file.write(reinterpret_cast<const char*>(content.data()), content.size());\n    file.close();\n    return true;\n}", "CodeBleu_score": 47.32031411000703}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto location = parent_bounds->location + transform.location;\n  const auto extents = parent_bounds->extents;\n  const auto yaw = transform.rotation.yaw;\n  const auto cos_yaw = std::cos(yaw);\n  const auto sin_yaw = std::sin(yaw);\n  const auto corners = std::array<geom::Location, 4u>{\n      geom::Location{cos_yaw * extents.x - sin_yaw * extents.y, sin_yaw * extents.x + cos_yaw * extents.y},\n      geom::Location{cos_yaw * extents.x + sin_yaw * extents.y, sin_yaw * extents.x - cos_yaw * extents.y},\n      geom::Location{cos_yaw * extents.x + sin_yaw * extents.y, sin_yaw * extents.x - cos_yaw * extents.y},\n      geom::Location{cos_yaw * extents.x - sin_yaw * extents.y, sin_yaw * extents.x + cos_yaw * extents.y}};\n  return std::make_shared<const Bounds>(frame, location, corners);\n}", "CodeBleu_score": 46.50850333262533}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n  const auto location = transform.location + parent_bounds->location;\n  const auto yaw = geom::Math::ToDegrees(transform.rotation.yaw);\n  const auto extent = parent_bounds->extent;\n  const auto corners = {\n    geom::Location(extent.x, extent.y, 0.0f),\n    geom::Location(-extent.x, extent.y, 0.0f),\n    geom::Location(-extent.x, -extent.y, 0.0f),\n    geom::Location(extent.x, -extent.y, 0.0f)\n  };\n  const auto rotated_corners = [&]() {\n    std::vector<geom::Location> result;\n    result.reserve(corners.size());\n    for (const auto &corner : corners) {\n      const auto rotated_corner = corner.Rotate(geom::Rotation(0.0f, yaw, 0.0f));\n      result.emplace_back(location + rotated_corner);\n    }\n    return result;\n  }();\n  return std::make_shared<const Bounds>(frame, rotated_corners);\n}", "CodeBleu_score": 45.67190827419043}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  geom::Location location = transform.location + _parent_bb.location;\n  float yaw = transform.rotation.yaw;\n  geom::Vector3D extents = _parent_bb.extent;\n  std::vector<geom::Location> corners;\n  corners.emplace_back(location + geom::Math::RotateVector(geom::Vector3D{extents.x, extents.y, 0.0f}, yaw));\n  corners.emplace_back(location + geom::Math::RotateVector(geom::Vector3D{-extents.x, extents.y, 0.0f}, yaw));\n  corners.emplace_back(location + geom::Math::RotateVector(geom::Vector3D{extents.x, -extents.y, 0.0f}, yaw));\n  corners.emplace_back(location + geom::Math::RotateVector(geom::Vector3D{-extents.x, -extents.y, 0.0f}, yaw));\n  return std::make_shared<const Bounds>(frame, corners);\n}", "CodeBleu_score": 46.376504095507606}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  GetEpisode().Lock()->QueryLightStatesToServer(*this);\n  for (const auto &pair : _lights) {\n    auto &light = pair.second;\n    light->_state = _light_states.at(pair.first);\n  }\n}", "CodeBleu_score": 21.80165805309601}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n\n    _client.GetLightStates(_lights);\n\n    for (auto &&light : _lights) {\n        auto id = light.first;\n        auto state = light.second;\n\n        if (_lights_state.find(id) == _lights_state.end()) {\n            _lights_state[id] = std::make_shared<Light>(id, state, _simulator);\n        } else {\n            _lights_state[id]->SetState(state);\n        }\n    }\n}", "CodeBleu_score": 37.87952153531579}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  // Lock the mutex to ensure thread safety\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Retrieve the light states from the server\n  std::vector<rpc::LightState> light_states = _parent->GetServerLightStates();\n\n  // Update the local light states\n  for (const auto &light_state : light_states) {\n    auto it = _lights.find(light_state.id);\n    if (it != _lights.end()) {\n      it->second.SetLightState(light_state);\n    } else {\n      // Create a new light object if it does not already exist in the _lights map\n      _lights.emplace(light_state.id, Light(light_state, _parent));\n    }\n  }\n}", "CodeBleu_score": 39.447874800944895}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::unique_lock<std::mutex> lock(_mutex);\n  if (!_dirty) {\n    return;\n  }\n\n  carla_simulator::proto::LightStateRequest msg;\n  for (auto &pair : _map) {\n    auto &light = pair.second;\n    if (light._dirty) {\n      light.Serialize(msg.add_lights());\n      light._dirty = false;\n    }\n  }\n  _dirty = false;\n  lock.unlock();\n\n  if (!discard_client) {\n    _simulator->SendMessage(msg);\n  }\n}", "CodeBleu_score": 35.46626203252094}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n\n    if (!_dirty) {\n        return;\n    }\n\n    carla_debug(\"Updating server lights state.\");\n\n    auto lights_state_msg = std::make_unique<carla_msgs::CarlaLightStateList>();\n    for (auto &&light_state : _light_states) {\n        lights_state_msg->lights.emplace_back(light_state);\n    }\n    _simulator->SendMessageToServer(std::move(lights_state_msg), discard_client);\n\n    _changes.clear();\n    _dirty = false;\n}", "CodeBleu_score": 35.27740678752159}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  if (!_dirty) {\n    return;\n  }\n\n  std::lock_guard<std::mutex> lock(_mutex);\n  if (!_dirty) {\n    return;\n  }\n\n  carla_debug(\"Updating server lights state.\");\n  auto msg = MakeLightStateMessage();\n  _client->SendLightState(*msg);\n  if (!discard_client) {\n    _changes.clear();\n  }\n  _dirty = false;\n}", "CodeBleu_score": 25.646161554700285}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"ServerSideSensor::Send() is not implemented for this sensor.\");\n    return;\n  }\n  GetEpisode().Lock()->SendMessageToServer(std::move(message));\n}", "CodeBleu_score": 42.01086736846362}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    if (GetId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"ServerSideSensor::Send: sensor id is not sensor.other.v2x_custom\");\n        return;\n    }\n    GetEpisode().Lock()->SendV2XCustomMessage(std::move(message), GetContext());\n}", "CodeBleu_score": 44.31638796367231}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    if (GetId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"sensor.other.v2x_custom is not the ID of this sensor. This sensor will not send any data.\");\n        return;\n    }\n    GetEpisode().Lock()->SendMessageToServer(std::move(message));\n}", "CodeBleu_score": 44.37616014399229}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  GetEpisode().Lock()->GetTrafficManager(tm_port)->RegisterVehicles({shared_from_this()}, enabled);\n}", "CodeBleu_score": 31.948168925973857}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  GetEpisode().Lock()->SetVehicleAutoPilot(GetId(), enabled, tm_port);\n}", "CodeBleu_score": 25.412588860720074}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  GetEpisode().Lock()->GetTrafficManager(tm_port)->RegisterVehicles({shared_from_this()}, enabled);\n}", "CodeBleu_score": 31.948168925973857}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t    auto self = boost::static_pointer_cast<cc::WalkerAIController>(shared_from_this());\n    _episode->RegisterActor(self);\n    auto walker = GetWalker();\n    _navigation = std::make_unique<detail::WalkerNavigation>(\n        _episode->GetMap()->GetMap(),\n        walker->GetLocation(),\n        walker->GetTransform().rotation.yaw);\n    walker->SetSimulatePhysics(false);\n    walker->SetEnableGravity(false);\n}", "CodeBleu_score": 38.31219584073957}, {"code": "void WalkerAIController::Start(){\n\t    // Register the controller with the episode\n    _episode->RegisterController(this);\n\n    // Get the walker actor\n    auto walker = _episode->GetActorRegistry().Find(_walker_id);\n\n    // Add the walker to the navigation system\n    _episode->GetNavigation()->AddWalker(walker);\n\n    // Disable physics simulation and collisions for the walker\n    walker->SetSimulatePhysics(false);\n    walker->SetEnableGravity(false);\n}", "CodeBleu_score": 31.555111844574597}, {"code": "void WalkerAIController::Start(){\n\t    _navigation = std::make_unique<detail::WalkerNavigation>(_episode->GetId(), _actor->GetId(), _actor->GetLocation());\n    _actor->DisableSimulation();\n    _actor->DisableCollision();\n}", "CodeBleu_score": 19.352310285013637}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto navigation = GetEpisode().Lock()->GetNavigation();\n  if (navigation == nullptr) {\n    return;\n  }\n  auto walker = navigation->GetWalker();\n  if (walker == nullptr) {\n    log_warning(\"walker not found\");\n    return;\n  }\n  if (!navigation->SetMaximumSpeed(*walker, max_speed)) {\n    log_warning(\"failed to set maximum speed\");\n  }\n}", "CodeBleu_score": 62.053762636195145}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto navigation = GetEpisode().Lock()->GetNavigation();\n  if (navigation == nullptr) {\n    log_warning(\"navigation not found\");\n    return;\n  }\n  auto walker = navigation->GetWalkerParent();\n  if (walker == nullptr) {\n    log_warning(\"walker not found\");\n    return;\n  }\n  if (!walker->SetMaxSpeed(max_speed)) {\n    log_warning(\"failed to set maximum speed\");\n  }\n}", "CodeBleu_score": 59.81915082987314}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto navigation = GetEpisode().Lock()->GetNavigation();\n  if (!navigation.has_value()) {\n    return;\n  }\n  auto walker = navigation->GetParent();\n  if (!walker.has_value()) {\n    log_warning(\n        \"Trying to set the maximum speed of a walker that is not found in the navigation\");\n    return;\n  }\n  if (!navigation->SetMaximumSpeed(*walker, max_speed)) {\n    log_warning(\n        \"Trying to set the maximum speed of a walker that is not found in the navigation\");\n  }\n}", "CodeBleu_score": 55.37493703457146}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  for (const auto &waypoint : _parent->GetPrevious(_id, distance)) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, waypoint)));\n  }\n  return result;\n}", "CodeBleu_score": 53.588675533743626}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  for (auto &&waypoint : GetMap()->GetTopology()) {\n    if (waypoint->Distance(shared_from_this()) < distance) {\n      result.emplace_back(waypoint);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 43.66857239154549}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    for (auto &&waypoint : GetMap()->GetTopology()) {\n        if (waypoint->Distance(*this) < distance) {\n            result.emplace_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n        }\n    }\n    return result;\n}", "CodeBleu_score": 47.34220292692963}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::unordered_set<SharedPtr<Landmark>> result;\n  for (auto &&signal : GetSignalsInDistance(distance, stop_at_junction)) {\n    result.insert(SharedPtr<Landmark>(new Landmark(*signal)));\n  }\n  return {result.begin(), result.end()};\n}", "CodeBleu_score": 26.025045587253903}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::unordered_set<SharedPtr<Waypoint>> signals;\n  GetSignalsInDistance(distance, stop_at_junction, signals);\n  std::vector<SharedPtr<Landmark>> result;\n  for (auto &signal : signals) {\n    SharedPtr<Landmark> landmark = MakeShared<Landmark>();\n    landmark->_waypoint = signal;\n    result.push_back(landmark);\n  }\n  return result;\n}", "CodeBleu_score": 37.471733041142826}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\n  std::vector<SharedPtr<Landmark>> result;\n\n  // Get all signals in the specified distance\n  std::unordered_set<SharedPtr<Landmark>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\n  // Check for repeated signals\n  for (auto signal : signals) {\n    // Create a new Waypoint and Landmark for each unique signal\n    SharedPtr<Waypoint> new_waypoint = std::make_shared<Waypoint>(signal->GetLocation());\n    SharedPtr<Landmark> new_landmark = std::make_shared<Landmark>(new_waypoint, signal->GetType());\n    result.push_back(new_landmark);\n  }\n\n  return result;\n}", "CodeBleu_score": 44.26207421766283}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  return _episode->Lock()->GetSimulator()->ApplySettings(settings, timeout);\n}", "CodeBleu_score": 13.982563620635064}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  if (timeout <= 0s) {\n    timeout = _parent->GetSettings().fixed_delta_seconds;\n  }\n  return _parent->ApplySettings(settings, timeout);\n}", "CodeBleu_score": 15.606395649193727}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t    const uint64_t id = _episode->Lock()->ApplySettings(settings, timeout);\n    _on_tick_callbacks.clear();\n    return id;\n}", "CodeBleu_score": 16.402413051092584}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  const float segmentLength2 = (end - start).SquaredLength();\n  const float segmentLength = std::sqrt(segmentLength2);\n  if (segmentLength2 == 0.0f) {\n    return {0.0f, start.Distance(point)};\n  }\n  const Vector2D projection = start + (((point - start) * (end - start)) / segmentLength2) * (end - start);\n  const float projectionDistance = projection.Distance(start);\n  const float distance = projectionDistance <= segmentLength ?\n    (point - projection).Length() :\n    std::min((point - start).Length(), (point - end).Length());\n  return {projectionDistance, distance};\n}", "CodeBleu_score": 40.508948757949106}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  const float segmentLengthSquared = (point2 - point1).SquaredLength();\n  const float segmentLength = std::sqrt(segmentLengthSquared);\n  if (segmentLength < EPSILON) {\n    return {0.0f, point1.Distance(point2)};\n  }\n  const Vector2D projection = point1 + (point2 - point1) * (((point - point1).Dot(point2 - point1)) / segmentLengthSquared);\n  const float distanceAlongSegment = projection.Distance(point1);\n  const float distanceToPoint = distanceAlongSegment < segmentLength ? (point - projection).Length() : std::min((point - point1).Length(), (point - point2).Length());\n  return {distanceAlongSegment, distanceToPoint};\n}", "CodeBleu_score": 37.98532340710755}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    const Vector2D segment_direction = segment_end - segment_begin;\n    const float segment_length_squared = segment_direction.LengthSquared();\n    const float segment_length = std::sqrt(segment_length_squared);\n    if (segment_length < std::numeric_limits<float>::epsilon()) {\n        return std::make_pair(0.0f, Vector2D(point - segment_begin).Length());\n    }\n    const float projection = Vector2D::DotProduct(point - segment_begin, segment_direction) / segment_length_squared;\n    const float distance_on_segment = std::clamp(projection, 0.0f, segment_length);\n    const Vector2D point_on_segment = segment_begin + segment_direction * distance_on_segment;\n    return std::make_pair(distance_on_segment, (point - point_on_segment).Length());\n}", "CodeBleu_score": 42.20843395859583}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  assert(vertices.size() >= 3);\n  const size_t initial_index = _vertices.size();\n  for (const auto &v : vertices) {\n    _vertices.push_back(v);\n  }\n  for (size_t i = initial_index + 1; i < _vertices.size() - 1; ++i) {\n    _indices.push_back(initial_index);\n    _indices.push_back(i);\n    _indices.push_back(i + 1);\n  }\n}", "CodeBleu_score": 52.05972281944552}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  assert(vertices.size() >= 3);\n  size_t initial_index = _vertices.size();\n  _vertices.insert(_vertices.end(), vertices.begin(), vertices.end());\n  for (size_t i = 2; i < vertices.size(); ++i) {\n    _indices.push_back(initial_index);\n    _indices.push_back(initial_index + i - 1);\n    _indices.push_back(initial_index + i);\n  }\n}", "CodeBleu_score": 50.491382124623286}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    assert(vertices.size() >= 3);\n    const auto initial_index = _vertices.size();\n    _vertices.insert(_vertices.end(), vertices.begin(), vertices.end());\n    for (auto i = 1u; i < vertices.size() - 1; ++i) {\n        _indices.emplace_back(initial_index);\n        _indices.emplace_back(initial_index + i);\n        _indices.emplace_back(initial_index + i + 1);\n    }\n}", "CodeBleu_score": 49.553437044274304}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  boost::asio::post(\n      _strand,\n      [=]() {\n        if (!_socket.is_open()) {\n          log_debug(\"socket not open, dropping message\");\n          return;\n        }\n        auto self = shared_from_this();\n        _socket.expires_after(std::chrono::seconds(10));\n        boost::asio::async_write(\n            _socket,\n            boost::asio::buffer(*message),\n            boost::asio::bind_executor(\n                _strand,\n                [=](boost::system::error_code ec, size_t) {\n                  if (ec) {\n                    log_error(\"error sending message:\", ec.message());\n                    self->Close();\n                  }\n                }));\n      });\n}", "CodeBleu_score": 43.0413508316192}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  DEBUG_ASSERT(message->size() < std::numeric_limits<uint32_t>::max());\n  boost::asio::post(\n      _strand,\n      [=]() {\n        if (!_socket.is_open()) {\n          log_error(\"Primary::Write: socket not open\");\n          return;\n        }\n        _socket.expires_after(std::chrono::seconds(10));\n        boost::asio::async_write(\n            _socket,\n            boost::asio::buffer(message->data(), message->size()),\n            boost::asio::bind_executor(\n                _strand,\n                [=](boost::system::error_code ec, size_t) {\n                  if (ec) {\n                    log_error(\"Primary::Write:\", ec.message());\n                    _socket.close();\n                  }\n                }));\n      });\n}", "CodeBleu_score": 41.77421288896973}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  boost::asio::post(\n      _strand,\n      [=]() {\n        if (!_socket.is_open()) {\n          return;\n        }\n        auto self = shared_from_this();\n        auto msg = message;\n        auto timeout = boost::posix_time::milliseconds(_timeout_ms);\n        _socket.async_write_some(\n            boost::asio::buffer(msg->data(), msg->size()),\n            boost::asio::bind_executor(\n                _strand,\n                [=](boost::system::error_code ec, size_t) {\n                  if (ec == boost::asio::error::operation_aborted) {\n                    return;\n                  }\n                  if (ec) {\n                    log_error(\"primary: write error:\", ec.message());\n                    self->Close();\n                  } else {\n                    DEBUG_ASSERT(msg->size() == _bytes_written);\n                    _bytes_written = 0u;\n                  }\n                }));\n        _socket.get_io_service().reset();\n        _socket.get_io_service().run_one_for(timeout);\n      });\n}", "CodeBleu_score": 43.83392388068981}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if (ec) {\n    log_error(\"error in primary close:\", ec.message());\n  }\n  boost::system::error_code ec2;\n  _deadline.cancel(ec2);\n  if (ec2) {\n    log_error(\"error cancelling deadline timer:\", ec2.message());\n  }\n  if (!ec && _socket.is_open()) {\n    _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec2);\n    if (ec2) {\n      log_error(\"error shutting down socket:\", ec2.message());\n    }\n    _socket.close(ec2);\n    if (ec2) {\n      log_error(\"error closing socket:\", ec2.message());\n    }\n  }\n  _on_closed();\n  log_debug(\"session closed\");\n}", "CodeBleu_score": 51.74344403980682}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    if (ec == boost::asio::error::operation_aborted) {\n        return;\n    }\n    if (ec) {\n        log_warning(\"error in primary close:\", ec.message());\n    }\n    if (socket_.is_open()) {\n        boost::system::error_code ec;\n        socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        socket_.close(ec);\n    }\n    on_closed_();\n    log_info(\"session closed\");\n}", "CodeBleu_score": 46.93085665711253}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if (ec == boost::asio::error::operation_aborted) {\n    // The deadline timer has been cancelled, which means that the socket is being closed due to a timeout.\n    return;\n  }\n\n  if (ec) {\n    // An error occurred while attempting to shut down or close the socket.\n    // Log the error and return.\n    log_error(\"error: \", ec.message());\n    return;\n  }\n\n  // The socket has been shut down and closed successfully.\n  // Trigger the on_closed callback and log that the session has been closed.\n  on_closed();\n  log_debug(\"session closed\");\n}", "CodeBleu_score": 30.342081842157253}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t  using namespace carla::streaming::detail::tcp;\n  const auto message = MakeMessage(Command::YOU_ALIVE, 0u);\n  const auto buffer = message.GetBuffer();\n  log_debug(\"sending alive message:\", message);\n  router.Write(buffer, Command::YOU_ALIVE);\n  log_debug(\"waiting for response...\");\n  auto response = router.Read();\n  log_debug(\"response:\", response);\n}", "CodeBleu_score": 50.955224249349364}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  // Create the message\n  const auto message = MakeMessage(Command::ARE_YOU_ALIVE);\n  // Log the sending action\n  log_debug(\"sending %s\", ToString(message));\n  // Write the message to the next router\n  _router.Write(message, Command::YOU_ALIVE);\n  // Wait for the response\n  const auto response = _router.Read();\n  // Log the response\n  log_debug(\"received %s\", ToString(response));\n}", "CodeBleu_score": 46.29137921108724}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t    auto buffer = MakeMessageBuffer(Command::ARE_YOU_ALIVE);\n    log_debug(\"sending 'are you alive?' to the next router\");\n    _router->Write(buffer);\n    log_debug(\"waiting for 'yes, I am alive' from the next router\");\n    _router->Read();\n}", "CodeBleu_score": 35.45533723171878}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  // Check if the sensor is activated on any server\n  auto server = Router::Instance().GetServerForSensor(sensor_id);\n  if (server != nullptr) {\n    // Create a buffer with the sensor ID\n    carla_buffer_t buffer;\n    buffer.size = sizeof(stream_id);\n    buffer.data = reinterpret_cast<uint8_t*>(&sensor_id);\n\n    // Send the ENABLE_ROS command to the server using the router\n    Router::Instance().SendCommand(server, Command::Type::ENABLE_ROS, buffer);\n\n    // Wait for and process the server's response\n    auto response = Router::Instance().WaitForResponse(server);\n    if (response.has_value()) {\n      auto response_buffer = response.value();\n      // Process the response buffer\n    }\n  } else {\n    // Log an error message if the sensor is not found on any server\n    log_error(\"Sensor not found on any server\");\n  }\n}", "CodeBleu_score": 52.283588654793235}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    for (auto &server : _router->GetActiveServers()) {\n        if (server.second.find(sensor_id) != server.second.end()) {\n            auto buffer = std::make_unique<Buffer>();\n            buffer->copy(&sensor_id, sizeof(stream_id));\n            _router->Write(std::move(buffer), server.first, Command::Type::ENABLE_ROS);\n            auto response = _router->Read(server.first);\n            if (response->GetHeader().type == Command::Type::ENABLE_ROS) {\n                return;\n            }\n        }\n    }\n    log_error(\"sensor not found\");\n}", "CodeBleu_score": 48.54166457107342}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    auto server_id = _router.GetServerFor(sensor_id);\n    if (server_id != -1) {\n        auto buffer = _router.MakeBuffer(sensor_id);\n        _router.SendCommand(server_id, Command::ENABLE_ROS, buffer);\n        _router.WaitForResponse(server_id, Command::ENABLE_ROS, buffer);\n    } else {\n        log_error(\"Sensor not found on any server\");\n    }\n}", "CodeBleu_score": 44.1393141562892}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t    if (router.IsActive(sensor_id)) {\n        return router.GetToken(sensor_id);\n    } else {\n        auto token = router.GetToken(sensor_id);\n        auto secondary = router.GetSecondary(sensor_id);\n        auto message = MakeMessage(Command::SpawnSensor, sensor_id, token);\n        secondary->Write(std::move(message));\n        router.SetActive(sensor_id, true);\n        return token;\n    }\n}", "CodeBleu_score": 41.332037215691614}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t    if (Primary::IsSensorActive(sensor_id)) {\n        token_type token = Primary::GetToken(sensor_id);\n        LOG_INFO(\"GetToken: sensor already active, returning existing token\");\n        return token;\n    }\n\n    auto server = Router::GetServerForSensor(sensor_id);\n    token_type token = server->EnableSensor(sensor_id);\n    Primary::SetToken(sensor_id, token);\n    Primary::SetSensorActive(sensor_id, true);\n    LOG_INFO(\"GetToken: sensor not active, enabling on secondary server\");\n    return token;\n}", "CodeBleu_score": 39.16634188150042}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // Check if sensor is already activated\n  if (router.IsSensorActive(sensor_id)) {\n    // Return existing token\n    return router.GetToken(sensor_id);\n  }\n\n  // Enable sensor on a secondary server\n  auto server_id = router.GetServerId(sensor_id);\n  auto message = detail::tcp::Message(\n      detail::tcp::Message::Type::ENABLE_SENSOR, sensor_id);\n  primary.Send(server_id, message);\n\n  // Retrieve new token\n  auto token = primary.GetToken(sensor_id);\n\n  // Update maps\n  router.SetSensorActive(sensor_id, true);\n  router.SetToken(sensor_id, token);\n\n  // Log action\n  log_info(\"enabled sensor\", sensor_id, \"on server\", server_id);\n\n  // Return new token\n  return token;\n}", "CodeBleu_score": 41.497540831410994}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream file(filename, std::ios::binary);\n    if (!file) {\n        return false;\n    }\n    std::vector<char> data(std::istreambuf_iterator<char>(file), {});\n    file.close();\n    return Load(data);\n}", "CodeBleu_score": 49.69127368320587}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  std::vector<char> data;\n  file.seekg(0, std::ios::end);\n  data.reserve(file.tellg());\n  file.seekg(0, std::ios::beg);\n  data.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());\n  file.close();\n  return Load(data);\n}", "CodeBleu_score": 59.509711954307576}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  std::vector<char> data(std::istreambuf_iterator<char>(file), {});\n  file.close();\n  return Load(data);\n}", "CodeBleu_score": 51.9920714716301}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (!_is_ready) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lock(_mutex);\n  if (_crowd == nullptr) {\n    return false;\n  }\n  auto walker_it = _walker_to_agent_id.find(id);\n  if (walker_it != _walker_to_agent_id.end()) {\n    _crowd->removeAgent(walker_it->second);\n    _walker_to_agent_id.erase(walker_it);\n    _agent_id_to_walker.erase(id);\n    return true;\n  }\n  auto vehicle_it = _vehicle_to_agent_id.find(id);\n  if (vehicle_it != _vehicle_to_agent_id.end()) {\n    _crowd->removeAgent(vehicle_it->second);\n    _vehicle_to_agent_id.erase(vehicle_it);\n    _agent_id_to_vehicle.erase(id);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 59.7278941968297}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\n    if (!_is_ready) {\n        return false;\n    }\n\n    assert(_crowd != nullptr);\n\n    // Search for the agent id in the walker and vehicle mappings\n    auto walker_it = _walker_to_agent_id.find(id);\n    auto vehicle_it = _vehicle_to_agent_id.find(id);\n\n    if (walker_it == _walker_to_agent_id.end() && vehicle_it == _vehicle_to_agent_id.end()) {\n        return false;\n    }\n\n    // Enter a critical section to safely remove the agent from the crowd\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    // Update the walker or vehicle manager and remove the id from the mappings\n    if (walker_it != _walker_to_agent_id.end()) {\n        _walker_manager->RemoveWalker(walker_it->second);\n        _walker_to_agent_id.erase(walker_it);\n    } else {\n        _vehicle_manager->RemoveVehicle(vehicle_it->second);\n        _vehicle_to_agent_id.erase(vehicle_it);\n    }\n\n    return true;\n}", "CodeBleu_score": 55.36049544494368}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (!_ready) {\n    return false;\n  }\n\n  assert(_crowd != nullptr);\n\n  std::unique_lock<std::mutex> lock(_mutex);\n\n  auto walker_it = _walker_manager.find(id);\n  auto vehicle_it = _vehicle_manager.find(id);\n\n  if (walker_it != _walker_manager.end()) {\n    _crowd->removeAgent(walker_it->second);\n    _walker_manager.erase(walker_it);\n    return true;\n  }\n\n  if (vehicle_it != _vehicle_manager.end()) {\n    _crowd->removeAgent(vehicle_it->second);\n    _vehicle_manager.erase(vehicle_it);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 59.2621818986539}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n    std::set<int> current_vehicles;\n\n    for (auto &vehicle : vehicles) {\n        current_vehicles.insert(vehicle.vehicle_id);\n    }\n\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    for (auto &vehicle : vehicles) {\n\n        auto it = _vehicles.find(vehicle.vehicle_id);\n\n        if (it == _vehicles.end()) {\n            _vehicles.emplace(vehicle.vehicle_id, VehicleState(vehicle));\n        } else {\n            it->second.Update(vehicle);\n        }\n    }\n\n    for (auto &vehicle : _vehicles) {\n        if (current_vehicles.find(vehicle.first) == current_vehicles.end()) {\n            vehicle.second.MarkForRemoval();\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 53.62437818339155}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n    std::set<int> mapped_vehicles;\n\n    for (auto &vehicle : _vehicles) {\n        mapped_vehicles.insert(vehicle.first);\n    }\n\n    for (auto &vehicle : vehicles) {\n\n        if (_vehicles.find(vehicle.vehicle_id) == _vehicles.end()) {\n            _vehicles.insert(std::make_pair(vehicle.vehicle_id, vehicle));\n        } else {\n            _vehicles[vehicle.vehicle_id] = vehicle;\n        }\n\n        mapped_vehicles.erase(vehicle.vehicle_id);\n\n    }\n\n    for (auto &vehicle_id : mapped_vehicles) {\n        _vehicles.erase(vehicle_id);\n    }\n\n    return true;\n\n}", "CodeBleu_score": 53.36886478132301}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    std::set<uint32_t> current_vehicles;\n    for (auto &v : vehicles_) {\n        current_vehicles.insert(v.first);\n    }\n    for (auto &v : vehicles) {\n        vehicles_[v.id].updated = true;\n        vehicles_[v.id].location = v.location;\n        vehicles_[v.id].velocity = v.velocity;\n        vehicles_[v.id].heading = v.heading;\n        vehicles_[v.id].bounding_box = v.bounding_box;\n        current_vehicles.erase(v.id);\n    }\n    for (auto &v : current_vehicles) {\n        vehicles_.erase(v);\n    }\n    return true;\n}", "CodeBleu_score": 53.85860000230428}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n  // Search for the actor in the mapped walkers and vehicles\n  std::map<ActorId, ActorPtr>::iterator it = _map_id_walkers.find(id);\n  if (it != _map_id_walkers.end()) {\n    // Enter a critical section\n    std::lock_guard<std::mutex> lock(_mutex);\n    // Compute the squared distance\n    float squared_distance = distance * distance;\n    // Use the crowd system to determine if a vehicle is nearby\n    return _crowd_system->HasVehicleNear(it->second->GetLocation(), squared_distance, direction);\n  }\n  it = _map_id_vehicles.find(id);\n  if (it != _map_id_vehicles.end()) {\n    // Enter a critical section\n    std::lock_guard<std::mutex> lock(_mutex);\n    // Compute the squared distance\n    float squared_distance = distance * distance;\n    // Use the crowd system to determine if a vehicle is nearby\n    return _crowd_system->HasVehicleNear(it->second->GetLocation(), squared_distance, direction);\n  }\n  // Return false if the actor is not found\n  return false;\n}", "CodeBleu_score": 55.015733400751486}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  std::unique_lock<std::mutex> lock(_mutex);\n\n  // Search for the actor in the mapped walkers and vehicles\n  auto walker = _walkers.find(id);\n  auto vehicle = _vehicles.find(id);\n\n  // If the actor is not found, return false\n  if (walker == _walkers.end() && vehicle == _vehicles.end()) {\n    return false;\n  }\n\n  // If the actor is a walker, compute the squared distance and use the crowd system to determine if a vehicle is nearby\n  if (walker != _walkers.end()) {\n    float squared_distance = distance * distance;\n    return _crowd_system->HasVehicleNear(walker->second->GetLocation(), squared_distance, direction);\n  }\n\n  // If the actor is a vehicle, compute the squared distance and use the crowd system to determine if a vehicle is nearby\n  if (vehicle != _vehicles.end()) {\n    float squared_distance = distance * distance;\n    return _crowd_system->HasVehicleNear(vehicle->second->GetLocation(), squared_distance, direction);\n  }\n\n  // If the actor is not found, return false\n  return false;\n}", "CodeBleu_score": 54.962146058594726}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  // Search for the actor in the mapped walkers and vehicles.\n  auto walker = walker_manager.GetWalker(id);\n  if (walker != nullptr) {\n    // Enter a critical section.\n    std::lock_guard<std::mutex> lock(mutex);\n    // Compute the squared distance.\n    float squared_distance = distance * distance;\n    // Use the crowd system to determine if a vehicle is nearby.\n    return crowd_system.HasVehicleNear(walker->GetLocation(), squared_distance, direction);\n  }\n\n  auto vehicle = vehicle_manager.GetVehicle(id);\n  if (vehicle != nullptr) {\n    // Enter a critical section.\n    std::lock_guard<std::mutex> lock(mutex);\n    // Compute the squared distance.\n    float squared_distance = distance * distance;\n    // Use the crowd system to determine if a vehicle is nearby.\n    return crowd_system.HasVehicleNear(vehicle->GetLocation(), squared_distance, direction);\n  }\n\n  // Return false if the actor is not found.\n  return false;\n}", "CodeBleu_score": 50.132650066319215}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    const auto current_route_point = info.GetCurrentRoutePoint();\n    WalkerEventVisitor visitor(id, current_route_point, delta);\n    return boost::variant2::visit(visitor, current_route_point.event);\n}", "CodeBleu_score": 46.91711669509971}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    auto &route = info.route;\n    if (route.empty()) {\n        return EventResult::Success;\n    }\n\n    auto &point = route.front();\n    auto context = WalkerEventContext{\n        id,\n        info,\n        delta,\n        point.GetWaypoint(),\n        point.GetEvent(),\n        point.GetId()\n    };\n    auto visitor = WalkerEventVisitor{context};\n    auto result = boost::variant2::visit(visitor, point.GetEvent());\n\n    if (result == EventResult::Success) {\n        route.pop_front();\n    }\n\n    return result;\n}", "CodeBleu_score": 44.151913390442715}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    // Retrieve the current route point for the walker from the WalkerInfo structure\n    const auto &route = info.route;\n    const auto &route_it = info.route_it;\n    const auto &route_point = *route_it;\n\n    // Create a WalkerEventVisitor with the current context\n    WalkerEventVisitor visitor(id, route, route_it, delta);\n\n    // Process the event at the current route point using boost::variant2::visit\n    return boost::variant2::visit(visitor, route_point);\n}", "CodeBleu_score": 50.525732309095716}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  carla::road::element::LaneOffset lane_offset = 0.0f;\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const std::string road_id = road_node.attribute(\"id\").as_string();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      const double s_offset = lane_section_node.attribute(\"s\").as_double();\n      for (pugi::xml_node lane_node : lane_section_node.children(\"left\")) {\n        ParseLanes(lane_node, road_id, s_offset, lane_offset, map_builder);\n      }\n      for (pugi::xml_node lane_node : lane_section_node.children(\"center\")) {\n        ParseLanes(lane_node, road_id, s_offset, lane_offset, map_builder);\n      }\n      for (pugi::xml_node lane_node : lane_section_node.children(\"right\")) {\n        ParseLanes(lane_node, road_id, s_offset, lane_offset, map_builder);\n      }\n      lane_offset += lane_section_node.attribute(\"hOffset\").as_double();\n    }\n  }\n}", "CodeBleu_score": 55.944105031540005}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  carla::road::MapBuilder::LaneDescription lane_description;\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const int road_id = road_node.attribute(\"id\").as_int();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      const double s_offset = lane_section_node.attribute(\"s\").as_double();\n      for (pugi::xml_node left_node : lane_section_node.children(\"left\")) {\n        ParseLanes(left_node, carla::road::MapBuilder::Lane::LaneType::LaneTypeLeft, s_offset, road_id, map_builder);\n      }\n      for (pugi::xml_node center_node : lane_section_node.children(\"center\")) {\n        ParseLanes(center_node, carla::road::MapBuilder::Lane::LaneType::LaneTypeCenter, s_offset, road_id, map_builder);\n      }\n      for (pugi::xml_node right_node : lane_section_node.children(\"right\")) {\n        ParseLanes(right_node, carla::road::MapBuilder::Lane::LaneType::LaneTypeRight, s_offset, road_id, map_builder);\n      }\n    }\n  }\n}", "CodeBleu_score": 54.54025100056634}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  pugi::xml_node open_drive_node = xml.child(\"OpenDRIVE\");\n\n  for (pugi::xml_node road_node = open_drive_node.child(\"road\"); road_node; road_node = road_node.next_sibling(\"road\")) {\n    int road_id = road_node.attribute(\"id\").as_int();\n\n    pugi::xml_node lanes_node = road_node.child(\"lanes\");\n\n    for (pugi::xml_node lane_section_node = lanes_node.child(\"laneSection\"); lane_section_node; lane_section_node = lane_section_node.next_sibling(\"laneSection\")) {\n      double s_offset = lane_section_node.attribute(\"s\").as_double();\n\n      pugi::xml_node left_node = lane_section_node.child(\"left\");\n      pugi::xml_node center_node = lane_section_node.child(\"center\");\n      pugi::xml_node right_node = lane_section_node.child(\"right\");\n\n      ParseLanes(left_node, center_node, right_node, s_offset, road_id, map_builder);\n    }\n  }\n}", "CodeBleu_score": 60.25006054727131}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 71.10309940676105}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_ = info.total_count;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_ = info.total_count;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 80.74878084111555}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_ = info.total_count;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_ = info.total_count;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 80.74878084111555}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for SubscriptionMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 63.340058380638084}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\n    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Subscriber matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for SubscriptionMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 64.2907763582335}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    matched_ = info.total_count;\n    if (!first_connected_) {\n      first_connected_ = true;\n    }\n  } else if (info.current_count_change == -1) {\n    matched_ = info.total_count;\n    if (matched_ == 0) {\n      std::cout << \"Lost subscriber.\" << std::endl;\n      if (subscriber_ != nullptr) {\n        subscriber_->destroy();\n      }\n    }\n  } else {\n    std::cout << \"on_subscription_matched: invalid change: \" << info.current_count_change\n              << std::endl;\n  }\n}", "CodeBleu_score": 69.45613324683406}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16)    {\n        m_md5.init();\n        m_md5.update(m_keyBuffer,\n                static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i)        {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else    {\n        for (uint8_t i = 0; i < 16; ++i)        {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 96.25562439858074}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if(!m_isGetKeyDefined)\n        return false;\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if(force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16)    {\n        m_md5.init();\n        m_md5.update(m_keyBuffer,\n                static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for(uint8_t i = 0;i<16;++i)        {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else    {\n        for(uint8_t i = 0;i<16;++i)        {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 83.79032344723103}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);  // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 97.09562025490489}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.95739996321375}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.95739996321375}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.95739996321375}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (target_set) {\n        return;\n    }\n    mavlink_tracking_target_t packet;\n    mavlink_msg_tracking_target_decode(&msg, &packet);\n    if (packet.tracking_type != TRACKING_TYPE_MISSION) {\n        return;\n    }\n    if (packet.target_sysid == 0) {\n        tracker.set_tracking_sysid(packet.target_sysid);\n        tracker.send_tracking_request();\n    }\n    target_set = true;\n}", "CodeBleu_score": 40.053851638915475}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // exit immediately if the target has already been set\n    if (target_set) {\n        return;\n    }\n\n    // decode the message\n    mavlink_tracker_message_t packet;\n    mavlink_msg_tracker_decode(&msg, &packet);\n\n    // exit immediately if this is not a message that should be tracked\n    if (packet.type != MAV_TRACKER_TYPE_SURFACE_BOAT &&\n        packet.type != MAV_TRACKER_TYPE_AIR_VEHICLE) {\n        return;\n    }\n\n    // if the target sysid has not been set, set it and request data\n    // streams\n    if (target_sysid == -1) {\n        target_sysid = msg.sysid;\n        gcs().request_datastream_position(target_sysid);\n        gcs().request_datastream_airpressure(target_sysid);\n    }\n\n    // flag that the target has been set\n    target_set = true;\n}", "CodeBleu_score": 42.94282697429338}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // exit immediately if the target has already been set\n    if (tracker.target_set) {\n        return;\n    }\n\n    // decode the message\n    mavlink_message_t msg_copy;\n    mavlink_status_t status;\n    mavlink_msg_decode(msg, &msg_copy, &status);\n\n    // exit immediately if the message is not a command\n    if (msg_copy.msgid != MAVLINK_MSG_ID_COMMAND_LONG) {\n        return;\n    }\n\n    // exit immediately if the command is not a tracking command\n    mavlink_command_long_t packet;\n    mavlink_msg_command_long_decode(&msg_copy, &packet);\n    if (packet.command != MAV_CMD_DO_TRACK) {\n        return;\n    }\n\n    // if the target system ID is not set, set it to the target and request position and air pressure data streams\n    if (tracker.target_sysid == -1) {\n        tracker.target_sysid = packet.param1;\n        tracker.send_request(MAVLINK_MSG_ID_LOCAL_POSITION_NED, 1000000);\n        tracker.send_request(MAVLINK_MSG_ID_SCALED_PRESSURE, 1000000);\n    }\n\n    // flag that the target has been set\n    tracker.target_set = true;\n}", "CodeBleu_score": 49.52301162564402}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        AP::baro().pre_calibration_up_count = 0;\n    }\n    return result;\n}", "CodeBleu_score": 63.28002578018067}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        tracker.baro_cal_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 69.36538868534356}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT ret = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (ret == MAV_RESULT_ACCEPTED) {\n        AP::baro().set_next_baro_update(true);\n    }\n    return ret;\n}", "CodeBleu_score": 77.19627060823196}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    // If the command parameter is 1.0, it arms the servos\n    if (packet.param1 == 1.0f) {\n        // Arm the servos\n        tracker.arm_servos();\n        // Return MAV_RESULT_ACCEPTED\n        return MAV_RESULT_ACCEPTED;\n    }\n    // If the command parameter is 0, it disarms the servos\n    else if (packet.param1 == 0.0f) {\n        // Disarm the servos\n        tracker.disarm_servos();\n        // Return MAV_RESULT_ACCEPTED\n        return MAV_RESULT_ACCEPTED;\n    }\n    // For any other parameter value, return MAV_RESULT_UNSUPPORTED\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 79.94627659423749}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0f) {\n        // arm\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0f) {\n        // disarm\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 79.42615140917901}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (packet.param1 == 0) {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 80.8783720114602}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs(); i++) {\n        if (hal.util->get_available_memory() < (1024 * 1024)) {\n            gcs_chan(i).request_datastream_resend();\n        }\n        if (gcs_chan(i).initialised &&\n            (gcs_chan(i).get_protocol() == GCS_PROTOCOL_MAVLINK) &&\n            gcs_chan(i).sysid == sysid &&\n            gcs_chan(i).compid == compid) {\n            gcs_chan(i).request_datastream_position(STREAM_POSITION, 10);\n        }\n    }\n}", "CodeBleu_score": 55.373460098022555}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs(); i++) {\n        if (hal.util->available_space(_chan[i]) > MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN) {\n            mavlink_msg_request_data_stream_send(_chan[i], sysid, compid, MAV_DATA_STREAM_POSITION, _rates[i], 1);\n        }\n    }\n}", "CodeBleu_score": 61.006245043199215}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs(); i++) {\n        if (comm_get_available_buffer_space(chan(i)) >= MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN) {\n            mavlink_msg_request_data_stream_send(chan(i), sysid, compid, MAV_DATA_STREAM_POSITION, 10000000/TRACKER_POSITION_UPDATE_RATE_HZ, 1);\n        }\n    }\n}", "CodeBleu_score": 60.015532591439616}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    // get the ahrs object\n    AP_AHRS_NavEKF &ahrs = AP::ahrs_navekf();\n\n    // check for divide by zero\n    const float cos_pitch = ahrs.cos_pitch();\n    if (cos_pitch < 0.1f) {\n        return false;\n    }\n\n    // convert body-frame angles to earth-frame angles\n    ef_pitch = pitch * cos_pitch - yaw * ahrs.sin_pitch();\n    ef_yaw = yaw * cos_pitch + pitch * ahrs.sin_pitch();\n\n    return true;\n}", "CodeBleu_score": 57.53742120689391}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    // get AHRS instance\n    AP_AHRS &ahrs = AP::ahrs();\n\n    // get the cosine of the current pitch angle\n    float c = ahrs.cos_pitch();\n\n    // check for divide-by-zero condition\n    if (c == 0.0f) {\n        return false;\n    }\n\n    // calculate the earth frame pitch angle\n    ef_pitch = RAD_TO_DEG * atanf(ahrs.sin_pitch() / c);\n\n    // calculate the earth frame yaw angle\n    if (is_zero(c)) {\n        ef_yaw = wrap_180(yaw - ahrs.yaw);\n    } else {\n        ef_yaw = wrap_180(yaw - ahrs.yaw + ahrs.sin_yaw() * (1.0f / c));\n    }\n\n    // return true to indicate success\n    return true;\n}", "CodeBleu_score": 55.764590339782586}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (cos_pitch < 0.7f) {\n        return false;\n    }\n    float sin_yaw = ahrs.sin_yaw();\n    float cos_yaw = ahrs.cos_yaw();\n    float sin_pitch = sqrtf(1 - cos_pitch * cos_pitch);\n    if (pitch > 0) {\n        sin_pitch = -sin_pitch;\n    }\n    ef_pitch = asinf(sin_pitch * cos_yaw + cos_pitch * sin_yaw * yaw);\n    if (isnan(ef_pitch)) {\n        return false;\n    }\n    ef_yaw = atan2f(-sin_yaw * pitch, cos_pitch * cos_yaw - sin_pitch * sin_yaw * yaw);\n    return true;\n}", "CodeBleu_score": 53.17012350433454}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t    // get the target yaw and pitch\n    int32_t target_yaw_cd = g2.wp_yaw_cd;\n    int32_t target_pitch_cd = g2.wp_pitch_cd;\n\n    // if we have reached the waypoint, update the wp distance\n    if (tracker.reached_wp_destination()) {\n        // set wp_distance to distance from current location to destination\n        g2.wp_distance = get_distance(current_loc, tracker.get_destination());\n    }\n\n    // if the wp_distance is zero we have reached the destination so stop\n    if (g2.wp_distance <= 0) {\n        // set wp_distance to distance from current location to destination\n        g2.wp_distance = get_distance(current_loc, tracker.get_destination());\n        if (g2.wp_distance <= 0) {\n            // we have reached the destination so stop\n            motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n            // if no delay is specified, set wp_distance to current altitude + 50cm\n            if (g2.wp_distance_min == 0) {\n                g2.wp_distance_min = current_loc.alt + 50;\n            }\n        }\n    }\n\n    // convert target_yaw_cd and target_pitch_cd to centi-degrees\n    target_yaw_cd = wrap_180_cd(target_yaw_cd);\n    target_pitch_cd = constrain_int32(target_pitch_cd, -9000, 9000);\n\n    // check if direction is reversed\n    bool reverse = false;\n    if (g2.wp_yaw_cd < 0) {\n        reverse = true;\n    }\n\n    // calculate the yaw and pitch error\n    int32_t yaw_error_cd = wrap_180_cd(target_yaw_cd - ahrs.yaw_sensor);\n    int32_t pitch", "CodeBleu_score": 36.656110407088995}, {"code": "void Mode::update_auto(void){\n\t    int32_t yaw_cd = 0;\n    int32_t pitch_cd = 0;\n\n    // set servos to angle\n    if (copter.auto_state.wp_yaw_cd != INT32_MAX) {\n        yaw_cd = copter.auto_state.wp_yaw_cd;\n    } else {\n        yaw_cd = copter.ahrs.yaw_sensor;\n    }\n\n    // calculate final angle error\n    int32_t angle_error = wrap_180_cd(yaw_cd - copter.ahrs.yaw_sensor);\n    if (copter.g2.wp_nav.get_wp_yaw_is_cd() && copter.g2.wp_nav.wp_yaw_loc.reached_destination()) {\n        angle_error = 0;\n    }\n\n    // convert angle error from earth frame to body frame\n    angle_error = wrap_180_cd(angle_error * DEGX100);\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // get pilot desired climb rate\n    float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in());\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // run waypoint controller\n    copter.failsafe_terrain_set_status(wp_nav->update_wpnav());\n\n    // call z-axis position controller (wpnav should have already updated its alt target)\n    pos_control->update_z_controller();\n\n    // call attitude controller\n    if (auto_yaw_mode == AUTO_YAW_HOLD) {\n        // roll & pitch from waypoint controller, yaw rate from pilot\n        attitude_control->input", "CodeBleu_score": 27.09485286646453}, {"code": "void Mode::update_auto(void){\n\t\n    // calculate yaw and pitch in centidegrees\n    int32_t yaw_cd, pitch_cd;\n    if (nav_status == Nav_WP || nav_status == Nav_Land) {\n        // point to next waypoint\n        calc_yaw_pitch_location(next_WP, yaw_cd, pitch_cd);\n    } else if (nav_status == Nav_TakeOff) {\n        // point to home\n        calc_yaw_pitch_location(home, yaw_cd, pitch_cd);\n    } else {\n        // point to vehicle\n        calc_yaw_pitch_location(tracker.current_loc, yaw_cd, pitch_cd);\n    }\n\n    // check if direction is reversed\n    if (g.reverse_yaw) {\n        yaw_cd = -yaw_cd;\n    }\n    if (g.reverse_pitch) {\n        pitch_cd = -pitch_cd;\n    }\n\n    // compute angle error\n    int32_t angle_error_cd = wrap_180_cd(yaw_cd - ahrs.yaw_sensor);\n\n    // convert angle error to earth frame\n    angle_error_cd = wrap_180_cd(angle_error_cd - ahrs.pitch_sensor);\n\n    // update target yaw and pitch\n    if (nav_status == Nav_Land || (nav_status == Nav_WP && target_distance_valid && (target_distance_m > g.wp_radius || target_distance_m == 0))) {\n        tracker.update_pitch_servo(pitch_cd);\n        tracker.update_yaw_servo(yaw_cd);\n    }\n}", "CodeBleu_score": 43.57435043565281}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t  if (gps.encode(gps_serial.read())) {\n    if (millis() - last_message_time > 5000) {\n      last_message_time = millis();\n      if (gps.location.isValid()) {\n        if (ground_start_countdown > 0) {\n          ground_start_countdown--;\n          if (ground_start_countdown == 0) {\n            home_location.latitude = gps.location.lat();\n            home_location.longitude = gps.location.lng();\n            home_location.altitude = gps.altitude.meters();\n          }\n        }\n      } else {\n        ground_start_countdown = 5;\n      }\n    }\n  }\n}", "CodeBleu_score": 45.76492180367387}, {"code": "void Tracker::update_GPS(void){\n\t    // update GPS data\n    gps.update();\n\n    // check if the last message time has changed\n    if (gps.last_message_time() != last_message_time) {\n        last_message_time = gps.last_message_time();\n        // check if the GPS status is at least 3D fix\n        if (gps.status() >= STATUS_3D_FIX) {\n            // decrement the countdown for ground start\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n                // if the countdown reaches one, set the home location if the current location is valid\n                if (ground_start_countdown == 0) {\n                    if (gps.location.isValid()) {\n                        home_location = gps.location;\n                    }\n                    // reset the countdown\n                    ground_start_countdown = GROUND_START_COUNTDOWN;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 46.256092310699145}, {"code": "void Tracker::update_GPS(void){\n\t\n    // Update GPS\n    gps.update();\n\n    // Check if the last message time has changed\n    if (last_message_time != gps.last_message_time()) {\n\n        // Update the last message time\n        last_message_time = gps.last_message_time();\n\n        // Check if the GPS status is at least 3D fix\n        if (gps.satellites() >= 3) {\n\n            // Decrement the countdown\n            countdown--;\n\n            // Check if the countdown has reached zero\n            if (countdown == 0) {\n\n                // Set the home location\n                set_home_location();\n\n                // Reset the countdown\n                countdown = COUNTDOWN;\n            }\n        } else {\n\n            // Reset the countdown\n            countdown = COUNTDOWN;\n        }\n    }\n}", "CodeBleu_score": 39.959957845353436}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t  if (pitch < pitch_on_angle) {\n    pitch_onoff_servo.write(pitch_on_angle);\n  } else if (pitch > pitch_off_angle) {\n    pitch_onoff_servo.write(pitch_off_angle);\n  } else {\n    pitch_onoff_servo.write(pitch);\n  }\n}", "CodeBleu_score": 22.85152312375965}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch > pitch_onoff_servo_threshold) {\n        servo_onoff.write(servo_onoff_max_angle);\n    } else {\n        servo_onoff.write(servo_onoff_min_angle);\n    }\n}", "CodeBleu_score": 13.501130130716705}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // map pitch angle to servo position\n    int servo_position = map(pitch, -10, 10, 0, 180);\n\n    // set servo position\n    servo.write(servo_position);\n}", "CodeBleu_score": 12.014084419745652}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // return true immediately if barometer checks are disabled\n    if (checks_to_perform != ARMING_CHECK_ALL && checks_to_perform != ARMING_CHECK_BARO) {\n        return true;\n    }\n\n    // check baro\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check for baro vs inav altitude failsafe\n    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform == ARMING_CHECK_BARO)) {\n        // Check baro vs inav altitude failsafe\n        if (copter.failsafe.radio) {\n            const char *fail_msg = nullptr;\n\n            // calculate disparity between baro and inav altitude\n            int32_t baro_alt = barometer.get_altitude();\n            if (baro_alt == 0) {\n                fail_msg = \"Baro altitude unavailable\";\n            } else {\n                // get position library altitude without baro correction\n                float pos_alt = copter.inertial_nav.get_position_z_up_cm() * 0.01f;\n                int32_t alt_diff = abs(baro_alt - pos_alt);\n                if (alt_diff > 100) {\n                    fail_msg = \"Altitude discrepancy\";\n                }\n            }\n\n            if (fail_msg != nullptr) {\n                // display warning that baro altitude is too far from EKF altitude\n                if (display_failure) {\n                    gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: %s\", fail_msg);\n                }\n                return false;\n            }\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 50.81921149962143}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // exit immediately if barometer checks are disabled\n    if (checks_to_perform != ARMING_CHECK_ALL &&\n        checks_to_perform != ARMING_CHECK_BARO) {\n        return true;\n    }\n\n    // check Baro\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro vs inav altitude\n    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform == ARMING_CHECK_BARO)) {\n        // Check baro vs inav altitude\n        if (copter.failsafe.baro_alt &&\n            (copter.position_ok() ||\n             copter.flightmode->requires_GPS())) {\n            const float ascent_rate_cm = MAX(inertial_nav.get_velocity_z(), 0.0f);\n            const float inav_alt_cm = inertial_nav.get_position_z() * 100.0f;\n            const float baro_alt_cm = copter.baro_alt * 100.0f;\n            const float acceptable_change_cm = MAX(50.0f - ascent_rate_cm * 3.0f, 50.0f) * 1e-2f * fabsf(copter.g.rangefinder_landing ? copter.g2.rangefinder_landing_min_alt : 100.0f);\n            if (fabsf(inav_alt_cm - baro_alt_cm) > acceptable_change_cm) {\n                if (display_failure) {\n                    gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Altitude disparity\");\n                }\n                return false;\n            }\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 51.9448854630426}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // return true immediately if barometer checks are disabled\n    if (checks_to_perform != ARMING_CHECK_ALL && checks_to_perform != ARMING_CHECK_BARO) {\n        return true;\n    }\n\n    // check baro\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // Check baro vs inav altitude\n    if (copter.failsafe.radio) {\n        return true; // don't check if radio failsafe active\n    }\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // Check baro vs distance sensor\n    if (copter.rangefinder_state.enabled) {\n        // trigger rangefinder update\n        copter.rangefinder.update();\n        // check if rangefinder is available\n        if (copter.rangefinder.has_orientation(ROTATION_PITCH_270)) {\n            // calculate height above home\n            float height_above_home = copter.rangefinder_state.alt_cm*0.01f - copter.ahrs.get_home().alt;\n            bool height_above_home_check = (copter.g.rangefinder_landing_check_height_min <= height_above_home) && (height_above_home <= copter.g.rangefinder_landing_check_height_max);\n            // check distance sensor within range\n            bool rangefinder_distance_check = copter.rangefinder_state.distance_cm <= copter.g.rangefinder_landing_check_rangefinder_distance_max;\n            // check final conclusion\n            if (!height_above_home_check || !rangefinder_distance_check) {\n                // display or log failure\n                const char *reason = height_above_home_check ? \"outside landing check height range\" : \"outside landing check rangefinder distance\";\n                if (display_failure) {\n                    gcs().send_text(MAV_SEVERITY_CRITICAL", "CodeBleu_score": 48.20223032274088}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if terrain is from rangefinder, no terrain database is required\n    if (copter.terrain.get_source() == AP_Terrain::TerrainSourceType::TERRAIN_FROM_RANGEFINDER) {\n        return false;\n    }\n\n    // if terrain is from terrain database and RTL altitude type is terrain, then a terrain database is required\n    if ((copter.terrain.get_source() == AP_Terrain::TerrainSourceType::TERRAIN_FROM_TERRAINDATABASE) &&\n        (copter.g2.rtl_altitude_type == RTL_ALT_TERRAIN)) {\n        return true;\n    }\n\n    // otherwise, defer to the base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 77.22949265992783}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.terrain_source == TerrainSourceType::TERRAIN_FROM_RANGEFINDER) {\n        // no terrain database is required if rangefinder is the source of the terrain\n        return false;\n    }\n\n    if (copter.terrain_source == TerrainSourceType::TERRAIN_FROM_TERRAINDATABASE &&\n        copter.rtl_alt_type == RTL_ALT_TERRAIN) {\n        // terrain database is required for terrain-based RTL\n        return true;\n    }\n\n    // defer to the base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 67.32719164234193}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.terrain.get_source() == AP_Terrain::TerrainSourceType::TERRAIN_FROM_RANGEFINDER) {\n        return false;\n    }\n    if (copter.terrain.get_source() == AP_Terrain::TerrainSourceType::TERRAIN_FROM_TERRAINDATABASE &&\n        copter.rtl_alt_type == RTL_ALT_TYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 77.60303317984751}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    uint32_t tnow = AP_HAL::millis();\n\n    // run low level rate controllers that use imu data\n    attitude_control->rate_controller_run();\n\n    // run low level rate controllers that use motor outputs\n    wp_nav->update_wpnav();\n\n    // now run the high level rate controllers that use both motor outputs and imu data\n    pos_control->update_z_controller();\n    attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), pos_control->get_thrust_heading());\n\n    // update the position controller target using the latest target location from the wp_nav controller\n    pos_control->set_pos_target(wp_nav->get_wp_destination());\n\n    // run the position controller\n    pos_control->update_xy_controller();\n\n    // get pilot desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // get pilot's desired yaw rate\n    target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // update attitude controller targets\n    if (!pos_control->is_active_z()) {\n        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(pos_control->get_roll(), pos_control->get_pitch(), target_yaw_rate);\n    } else {\n        attitude_control->input_euler_angle_roll_pitch_yaw(pos_control->get_roll(), pos_control->get_pitch(), pos_control->get_yaw(), true);\n    }\n\n    // run the attitude controller\n    attitude_control->attitude_controller_run();\n\n    // send output signals to motors\n    motors->output();\n\n    // update RC Channel Data\n    rc().update_aux_servo_function();\n\n    // update output", "CodeBleu_score": 40.97521744027564}, {"code": "void Copter::run_rate_controller(){\n\t    // set loop time for attitude controllers\n    attitude_control->set_dt(scheduler.get_loop_period_s());\n\n    // run low level rate controllers that require only imu data\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 25.69233688077618}, {"code": "void Copter::run_rate_controller(){\n\t    // set the loop time for attitude, position, and motor controllers\n    motors->set_loop_time_us(scheduler.get_loop_time_us());\n\n    // run low level rate controllers that require IMU data\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 17.290698938711294}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n    // if the old and new location are the same, return false\n    if (old_loc == new_loc) {\n        return false;\n    }\n\n    // if the altitude frames of the old and new locations are different, return false\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set the new location as the target\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n    set_next_WP(new_loc);\n\n    // return true\n    return true;\n}", "CodeBleu_score": 58.26480834883356}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // if the old and new locations are the same, return false\n    if (old_loc == new_loc) {\n        return false;\n    }\n\n    // if the altitude frames of the old and new locations are different, return false\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // if the old location matches the next waypoint, set the new location as the target and return true\n    if (wp_nav->reached_wp_destination()) {\n        set_auto_yaw_mode(AUTO_YAW_HOLD);\n        set_next_WP(new_loc);\n        return true;\n    }\n\n    // if the old location does not match the next waypoint, return false\n    return false;\n}", "CodeBleu_score": 55.795863524171686}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // if the old location is the same as the new location, return false\n    if (old_loc == new_loc) {\n        return false;\n    }\n\n    // if the altitude frame of the old and new locations are different, return false\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set the new location as the target location\n    set_target_location(new_loc);\n\n    // return true\n    return true;\n}", "CodeBleu_score": 58.44083167808136}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode->mode_number() == mode) {\n        copter.reset_mode_switch();\n    }\n}", "CodeBleu_score": 61.272564466525516}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode->mode_number() == mode) {\n        // the mode the switch wanted has already been set - reset\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 69.34280080899627}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // engage mode (if not possible we remain in current flight mode)\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else {\n        // return to flight mode switch if we are currently in this mode\n        if (copter.flightmode == &copter.mode_acro      ||\n            copter.flightmode == &copter.mode_stabilize ||\n            copter.flightmode == &copter.mode_flip      ||\n            copter.flightmode == &copter.mode_autotune  ||\n            copter.flightmode == &copter.mode_qstabilize||\n            copter.flightmode == &copter.mode_qhover    ||\n            copter.flightmode == &copter.mode_qloiter   ||\n            copter.flightmode == &copter.mode_qland    ||\n            copter.flightmode == &copter.mode_qrtl     ||\n            copter.flightmode == &copter.mode_qacro    ||\n            copter.flightmode == &copter.mode_thermal_hold) {\n            copter.reset_control_switch();\n        }\n    }\n}", "CodeBleu_score": 40.92638693941739}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // save existing trim values\n    float roll_trim_old = ahrs.get_roll_trim();\n    float pitch_trim_old = ahrs.get_pitch_trim();\n\n    // calculate new trim values\n    float roll_trim = ((float)channel_roll->get_control_in() - (float)channel_roll->get_radio_min()) / ((float)channel_roll->get_radio_max() - (float)channel_roll->get_radio_min()) * radians(4500);\n    float pitch_trim = ((float)channel_pitch->get_control_in() - (float)channel_pitch->get_radio_min()) / ((float)channel_pitch->get_radio_max() - (float)channel_pitch->get_radio_min()) * radians(4500);\n\n    // add trim values to AHRS\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log event\n    Log_Write_Event(DATA_SAVEWP_MSG);\n\n    // display message\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved (%.2f, %.2f)\", (double)roll_trim, (double)pitch_trim);\n}", "CodeBleu_score": 50.68041931269679}, {"code": "void Copter::save_trim(){\n\t    // save existing trim\n    float roll_trim_old = ahrs.get_roll_trim();\n    float pitch_trim_old = ahrs.get_pitch_trim();\n\n    // update roll and pitch trim from current control inputs\n    ahrs.set_roll_trim(channel_roll->get_control_in() * radians(4500.0f)/4500.0f);\n    ahrs.set_pitch_trim(channel_pitch->get_control_in() * radians(4500.0f)/4500.0f);\n\n    // log new values\n    AP::logger().Write_Event(LogEvent::SAVE_TRIM);\n\n    // display message and log new values\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved: Roll %.2f, Pitch %.2f\",\n                    (double)ahrs.roll_trim_rad()*degrees(1),\n                    (double)ahrs.pitch_trim_rad()*degrees(1));\n\n    // re-print the current values of the roll and pitch servo outputs\n    // (so the user can see how much they have changed)\n    gcs().send_named_float(\n        \"Roll\",\n        channel_roll->norm_output()\n    );\n    gcs().send_named_float(\n        \"Pitch\",\n        channel_pitch->norm_output()\n    );\n\n    // send AHRS and EKF trim values to waypoint navigation library\n    copter.wp_nav->set_servo_roll_trim(ahrs.roll_trim_rad());\n    copter.wp_nav->set_servo_pitch_trim(ahrs.pitch_trim_rad());\n\n    // log EKF origin as it will have changed when we saved the ahrs/ekf trim\n    Log_Write_Origin(LogOriginType::AHRS_ORIGIN, ahrs.get_home());\n\n    // send new trim values to the GCS\n    gcs().send_named_float(\"STRIM\", (double)ahrs.roll_trim", "CodeBleu_score": 44.7131848246443}, {"code": "void Copter::save_trim(){\n\t    // save existing trim values\n    float roll_trim_rad, pitch_trim_rad;\n    ahrs.get_trim(roll_trim_rad, pitch_trim_rad);\n\n    // add new trim values to existing trim values\n    roll_trim_rad += (float)channel_roll->get_control_in() / channel_roll->get_range() * radians(45);\n    pitch_trim_rad += (float)channel_pitch->get_control_in() / channel_pitch->get_range() * radians(45);\n\n    // save the new trim values\n    ahrs.set_trim(roll_trim_rad, pitch_trim_rad);\n\n    // log a dataflash event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // display a message that trim has been saved\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 57.727220263356706}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // get velocity vector, convert to NEU\n    const Vector3f vel = inertial_nav.get_velocity_neu();\n\n    // get speed squared\n    const float speed_sq = vel.length_squared();\n\n    // if we are not going fast do not modify the yaw target\n    if (!is_positive(speed_sq)) {\n        return ahrs.yaw;\n    }\n\n    // waypoint speed\n    const float wp_speed = wp_nav.get_speed_xy();\n\n    // if we are doing a loiter and the wp_speed is zero then we are doing a stationary loiter\n    // the loiter controller will try to keep the vehicle's attitude the same as it had when the\n    // loiter was initiated.  This would lead to wing oscillation if the target yaw is pointing\n    // in the opposite direction to the vehicle's heading.\n    //\n    // if we are not doing a loiter, then we can set the target yaw to point in the opposite\n    // direction to the vehicle's heading.\n    if (loiter_active && is_zero(wp_speed)) {\n        return wrap_PI(ahrs.yaw + M_PI);\n    }\n\n    // if we are doing a loiter and the wp_speed is not zero then we are doing a normal loiter\n    // at a particular speed so we use the current vehicle attitude controller's target yaw\n    if (loiter_active) {\n        return wrap_PI(ahrs.yaw);\n    }\n\n    // if we are within the radius of waypoint allow the mission to control heading\n    if (auto_yaw.mode() == AUTO_YAW_LOOK_AT_NEXT_WP && wp_nav.reached_wp_destination()) {\n        return wrap_PI(ahrs.yaw);\n    }\n\n    // calculate angle between vehicle's heading and velocity vector\n    // we only calculate the angle between the vehicle's heading and the velocity vector.\n    // This assumes that the vehicle is always travelling in the direction of the velocity vector\n    // Any deviation from this would require the vehicle to change attitude which we want to avoid if", "CodeBleu_score": 42.43038296815053}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    const Vector3f& vel = inertial_nav.get_velocity();\n    float speed_sq = vel.length_squared();\n    // Commanded Yaw to automatically look ahead\n    if (copter.position_ok() && (speed_sq > MIN_SPEED_SQUARED)) {\n        _look_ahead_yaw = atan2f(-vel.x,vel.y);\n    }\n    return _look_ahead_yaw;\n}", "CodeBleu_score": 56.79601108649484}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // calculate speed squared\n    const float speed_sq = sq(inertial_nav.get_velocity_xy().length());\n\n    // if we have sufficient speed and position information\n    if (position_ok() && (speed_sq > auto_yaw_speed_min_sq)) {\n        // calculate position ahead of vehicle using ground speed\n        const Vector3f pos_ahead = inertial_nav.get_position() + inertial_nav.get_velocity().normalized() * look_ahead_distance_cm;\n\n        // update look ahead yaw angle using vehicle's position and velocity\n        // To-Do: add support for takeoff and landing in Auto mode\n        // To-Do: add support for loiter and RTL\n        look_ahead_yaw = degrees(atan2f(-(pos_ahead.y - inertial_nav.get_position().y),\n                                       -(pos_ahead.x - inertial_nav.get_position().x))) * 100.0f;\n    }\n    return look_ahead_yaw;\n}", "CodeBleu_score": 46.86931705480848}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        if (plane.g.rudder_arming_checks != RUDDER_ARMING_CHECKS_DISABLED) {\n            if (plane.g.rudder_arming_checks == RUDDER_ARMING_CHECKS_PLANE_THROTTLE && plane.get_throttle() < 1) {\n                return false;\n            }\n            if (plane.g.rudder_arming_checks == RUDDER_ARMING_CHECKS_CIRCLE && !plane.quadplane.in_vtol_mode()) {\n                return false;\n            }\n        }\n    }\n\n    if (watchdog_was_armed) {\n        // if we've armed the watchdog then skip the arming checks....\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 62.08826527291775}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        if (rudder_arming_dis_ch != nullptr &&\n            rudder_arming_dis_ch->get_control_in() <= 0) {\n            // rudder arming must be disabled\n            return false;\n        }\n\n        if (throttle_zero_flag) {\n            // throttle is zero\n            return false;\n        }\n\n        // if we got here all must be ok so return true\n        return true;\n    }\n\n    // return arming status as true if disabled or if the method is none\n    if (method == AP_Arming::Method::NONE || arming_disabled) {\n        return true;\n    }\n\n    if (watchdog_was_armed) {\n        // if we got here all must be ok so return true\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 61.321371131142755}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        if ((checks_to_perform & ARMING_CHECK_PARAMETERS) == 0) {\n            // if parameter checks are disabled, only\n            // the rudder arming check needs to succeed\n            return rudder_arming_check();\n        }\n        return true;\n    }\n\n    if (checks_to_perform == 0) {\n        // if parameter checks are disabled, only\n        // the arming flags check needs to succeed\n        return arm_flags_check();\n    }\n\n    if (hal.util->was_watchdog_armed()) {\n        // if we were armed by the watchdog, return true so that\n        // arming will complete\n        return true;\n    }\n\n    return arm_flags_check();\n}", "CodeBleu_score": 52.97788861039242}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (armed) {\n        return true;\n    }\n\n    if (!_parent.ins.get_gyro_health_all() || !_parent.ins.get_accel_health_all()) {\n        // if gyros or accelerometers are not healthy, do not allow arming\n        return false;\n    }\n\n    // run pre_arm_checks checks and display failures\n    if (do_arming_checks && !pre_arm_checks(true)) {\n        AP_Notify::events.arming_failed = true;\n        return false;\n    }\n\n    // if checks are disabled or pass, try to arm\n    if (!do_arming_checks || pre_arm_checks(false)) {\n\n        // remember critical failures that were printed in pre_arm_checks()\n        AP_Notify::flags.pre_arm_failure = pre_arm_failure;\n\n        // arm_and_takeoff calls arm_motors which updates armed state\n        // arm_and_takeoff should return true if arming was successful\n        if (_parent.arm_and_takeoff(method)) {\n            // set system arm flag\n            armed = true;\n\n            // log arming to dataflash\n            _parent.log_arming();\n\n            // update AP_Notify\n            AP_Notify::flags.armed = true;\n            AP_Notify::events.armed = true;\n\n            // update home state\n            _parent.set_home_state(AP_Arming::HOME_SET_NOT_LOCKED);\n\n            // lock airspeed with ekf if enabled\n            _parent.airspeed.set_log_ekf_origins(true);\n\n            // log flight mode in case it was changed while vehicle was disarmed\n            _parent.logger.Write_Mode(control_mode->mode_number(), control_mode_reason);\n\n            gcs().send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n\n            // trigger radio failsafe if enabled\n            _parent.failsafe_radio_on_event(FAILSAFE_EVENT_THROTTLE, false);\n\n            // re", "CodeBleu_score": 52.23996305155683}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // remember home state for next arming check\n    set_home_state(AP_Arming::ArmingMethod::MAVLINK);\n\n    // update location\n    update_home();\n\n    // set system state\n    plane.set_system_status(MAV_STATE::MAV_STATE_STANDBY);\n\n    // set arming flag\n    set_armed(true);\n\n    // set arming delay flag\n    set_delay(true);\n\n    // return success\n    return true;\n}", "CodeBleu_score": 50.07207297444256}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // remember home location\n    AP::ahrs().set_home(AP::gps().location());\n\n    // update current location\n    AP::ahrs().set_location(AP::gps().location());\n\n    // update the current position\n    AP::ahrs().set_home_and_origin(AP::gps().location());\n\n    // change state to armed\n    plane.set_simple_flight_mode(AP_Plane::Flight_Modes::AUTO);\n\n    // set a flag to let the auto code know that we are armed (maybe)\n    plane.set_armed_flag(true);\n\n    // set flag to force update of home location\n    plane.home_is_set = true;\n\n    // set flag to force update of home location\n    plane.home_is_set = true;\n\n    // update the arming status display\n    plane.update_arming_display();\n\n    // log arming to dataflash\n    Log_Write_Event(DATA_ARMED);\n\n    // return success\n    return true;\n}", "CodeBleu_score": 57.15995860951132}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if the vehicle is already armed, return true\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // if disarm button is not configured, return failure\n    if (checks_to_perform == ARMING_CHECK_ALL && !AP_Arming::rc().has_disarm_switch()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm button not configured\");\n        }\n        return false;\n    }\n\n    // return the result of the underlying arming checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 63.67055664059256}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // exit immediately if already armed\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // if disarm button not configured, return failure\n    if (arming.disarm_level() == Disarm_Not_Configured) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm button not configured\");\n        }\n        return false;\n    }\n\n    // call parent class checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.74481680429076}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if the vehicle is already armed, return true\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // if disarm button is not configured, display failure and return false\n    if (!AP_Arming::rc().has_safety_switch()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm button not configured\");\n        }\n        return false;\n    }\n\n    // return the base class checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.76692939805353}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cos(ahrs.get_yaw()) - y * sin(ahrs.get_yaw());\n    float ne_y = x * sin(ahrs.get_yaw()) + y * cos(ahrs.get_yaw());\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 67.0529526909918}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cos(ahrs.yaw) - y * sin(ahrs.yaw);\n    float ne_y = x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 62.41280822119546}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cos(yaw) - y * sin(yaw);\n    float ne_y = x * sin(yaw) + y * cos(yaw);\n\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 57.63208266341391}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // param1 : target angle [0-360]\n    // param2 : speed during change [deg per second]\n    // param3 : direction (-1:ccw, +1:cw)\n    // param4 : relative offset (1) or absolute angle (0)\n\n    // exit immediately if vehicle is not in Guided mode\n    if (sub.control_mode != GUIDED) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // set guided mode yaw to hold with no target\n    sub.set_yaw_state(YAW_HOLD, 0.0f, false, false);\n\n    // check param1\n    if (packet.param1 < 0.0f || packet.param1 > 360.0f) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // check param2\n    if (fabsf(packet.param2) > sub.wp_nav.get_default_speed_xy()) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // check param3\n    if (packet.param3 != -1 && packet.param3 != 1) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // check param4\n    if (packet.param4 != MAV_MOUNT_MODE_MAVLINK_TARGETING && packet.param4 != MAV_MOUNT_MODE_MAVLINK_TARGETING) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // if param4 is zero (absolute) the yaw angle is packet.param1\n    if (packet.param4 == 0) {\n        sub.set_auto_yaw_look_at_heading(packet.param1, 0.0f, 0, 0);\n    } else {\n        // if param4 is one (relative) the yaw angle is relative to the current heading\n        sub.set_auto_yaw_look_ahead(packet.param1, 0.0f, 0, 0);\n    }\n\n", "CodeBleu_score": 49.34762444844474}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // param1 : target angle [0-360]\n    // param2 : speed during change [deg per second]\n    // param3 : direction (-1:ccw, +1:cw)\n    // param4 : relative offset (1) or absolute angle (0)\n\n    // check if yaw angle and param4 values are within acceptable ranges\n    if (fabsf(packet.param1) > 360.0f || fabsf(packet.param4) > 1.0f) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set the yaw heading\n    sub.set_auto_yaw_look_at_heading(packet.param1, packet.param2, (int8_t)packet.param3, (uint8_t)packet.param4);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 55.76960304875862}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // check param1, expect a delay in seconds\n    if (packet.param1 > 0 && packet.param1 < 3600) {\n        condition_value = packet.param1;\n        if (packet.param2 == 0) { // angle\n            // param3 : absolute angle or angle relative to heading (if param4 set)\n            if (fabsf(packet.param3) <= 360.0f) {\n                condition_yaw_deg = packet.param3;\n                if (fabsf(packet.param4) <= 360.0f) {\n                    condition_yaw_deg += copter.ahrs.yaw_sensor;\n                }\n                return MAV_RESULT_ACCEPTED;\n            }\n            return MAV_RESULT_DENIED;\n        }\n        // param3 : speed\n        if (fabsf(packet.param3) <= copter.wp_nav.get_default_speed_down()) {\n            condition_yaw_deg = packet.param3;\n            return MAV_RESULT_ACCEPTED;\n        }\n        return MAV_RESULT_DENIED;\n    }\n\n    return MAV_RESULT_DENIED;\n}", "CodeBleu_score": 54.19023755034722}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode != AUTO && sub.control_mode != GUIDED) {\n        return 0;\n    }\n    int16_t bearing = sub.next_WP_loc.get_bearing_to(sub.current_loc) * 0.01f;\n    if (bearing < 0) {\n        bearing = 360 + bearing;\n    }\n    return wrap_360_cd(bearing * 0.5f) / 2;\n}", "CodeBleu_score": 50.00964924873516}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode == AUTO || sub.control_mode == GUIDED) {\n        return wrap_360_cd(sub.next_WP_loc.bearing) / 200;\n    }\n    return 0;\n}", "CodeBleu_score": 62.742830339063474}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode == &sub.mode_auto || sub.control_mode == &sub.mode_guided) {\n        // get waypoint course from EKF or waypoint controller\n        // if we have no target assume 0 degrees\n        return wrap_360_cd(sub.mode_auto.wp_bearing_cd()) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 66.05387654274283}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (log_enabled) {\n        // Create log packet\n        log_pkt.time_us = AP_HAL::micros64();\n        log_pkt.id = (uint8_t)id;\n        log_pkt.data = value;\n\n        // Write to logger\n        logger.Write_Critical((uint8_t*)&log_pkt, sizeof(log_pkt));\n    }\n}", "CodeBleu_score": 45.75462249506282}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (log_sub_data) {\n        DataFlash.Log_Write_Start(PACKET_TYPE_SUB_DATA);\n        DataFlash.Log_Write_Int32(now());\n        DataFlash.Log_Write_Int16(id);\n        DataFlash.Log_Write_Int32(value);\n        DataFlash.Log_Write_Finish();\n    }\n}", "CodeBleu_score": 37.6334844002032}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (log_control.flags.Enable_Logging) {\n\t\tLogPkt pkt(id, value);\n\t\tlogger.Write_Critical(pkt);\n\t}\n}", "CodeBleu_score": 14.908921995835383}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home is already set\n    if (ap.home_state != HOME_UNSET) {\n        return;\n    }\n\n    // if EKF origin has not been set yet, exit immediately\n    Location temp_loc;\n    if (!ahrs.get_origin(temp_loc)) {\n        return;\n    }\n\n    // if we are disarmed, set home to current location\n    if (!motors.armed()) {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 34.59989942091287}, {"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home is already set\n    if (ap.home_state != HOME_UNSET) {\n        return;\n    }\n\n    // if disarmed, set home to current location\n    if (!motors.armed()) {\n        Location temp_loc;\n        if (ahrs.get_location(temp_loc)) {\n            set_home(temp_loc, false);\n        }\n    } else {\n        // we are armed, but home location is not set.\n        // set home to current location reported by EKF\n        if (ahrs.get_location(current_loc)) {\n            set_home(current_loc, true);\n        }\n    }\n}", "CodeBleu_score": 32.65828156241748}, {"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home is already set\n    if (home_is_set == HOME_SET_NOT_LOCKED || home_is_set == HOME_SET_AND_LOCKED) {\n        return;\n    }\n\n    // if the motors are armed, set home to current location\n    if (motors.armed()) {\n        Location temp_loc;\n        if (ahrs.get_location(temp_loc)) {\n            set_home(temp_loc, false);\n        }\n    } else {\n        // if the motors are not armed, set home to current ekf location\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 38.05249999232031}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t    if (!motors->armed()) {\n        // Motors should be Stopped\n        motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN);\n        // Attempting to Land\n        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    // To-Do: convert get_pilot_desired_lean_angles to return angles as floats\n    float target_roll, target_pitch;\n    get_pilot_desired_lean_angles(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, attitude_control->get_althold_lean_angle_max());\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // get pilot desired climb rate\n    float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in());\n    target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), g.pilot_speed_up);\n\n    // get avoidance adjusted climb rate\n    target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);\n\n    // set rate controller targets\n    if (!is_zero(target_roll) || !is_zero(target_pitch) || is_positive(target_climb_rate)) {\n        // Apply angle limit to pitch target\n        target_p", "CodeBleu_score": 57.16184469790866}, {"code": "void ModeAcro::run(){\n\t    // convert pilot input to lean angles\n    float target_roll, target_pitch;\n    get_pilot_desired_lean_angles(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, aparm.angle_max);\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // get pilot desired climb rate\n    float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in());\n    target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), g.pilot_speed_up);\n\n    // get speed forward\n    float speed_forward;\n    if (g.pilot_velocity_z_max <= 0) {\n        // treat pilot's roll input as a speed forward command\n        speed_forward = (float)target_roll/4500.0f;\n    } else {\n        // pilot is entering a velocity\n        speed_forward = g.pilot_velocity_z_max * (float)channel_throttle->get_control_in() / 1000.0f;\n    }\n\n    // get speed right\n    float speed_right = (float)target_pitch / 4500.0f;\n\n    // Replaced.\n    // // if motors are not armed set throttle to zero and exit immediately\n    // if (!motors.armed()) {\n    //     // Motors should be Stopped\n    //     motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN);\n    //     attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);\n    //     attitude_control.relax_attitude_controllers();\n    //     return", "CodeBleu_score": 48.39191321080493}, {"code": "void ModeAcro::run(){\n\t    // convert pilot input to lean angles\n    float target_roll, target_pitch;\n    get_pilot_desired_lean_angles(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, aparm.angle_max);\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // get pilot desired climb rate\n    float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in());\n    target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), g.pilot_speed_up);\n\n    // get speed forward\n    float target_forward_speed = g.rc_6.get_control_in();\n\n    // convert pilot input to body-frame rates\n    float target_roll_rate = (target_roll/4500.0f) * g.acro_roll_rate;\n    float target_pitch_rate = (target_pitch/4500.0f) * g.acro_pitch_rate;\n\n    // call attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate, get_smoothing_gain());\n\n    // adjust climb rate using rangefinder\n    target_climb_rate = copter.surface_tracking.adjust_climb_rate(target_climb_rate);\n\n    // call position controller\n    pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);\n    pos_control->update_z_controller();\n\n    // call forward controller\n    pos_control->set_forward_speed(target_forward_speed);\n    pos_control->update_x_controller", "CodeBleu_score": 51.16293587877809}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // initialise waypoint controller\n    wp_nav->wp_and_spline_init();\n\n    // set to position control mode\n    guided_pos_control_run();\n}", "CodeBleu_score": 7.986700634057249}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // initialise waypoint and spline controller\n    guided_pos_control_start_internal();\n\n    // initialise guided start time and position as reference for limit checking\n    guided_start_time_ms = AP_HAL::millis();\n    guided_start_pos = inertial_nav.get_position();\n\n    // set guided mode targets\n    guided_pos_target_cm.zero();\n    guided_vel_target_cms.zero();\n    guided_accel_target_cmss.zero();\n    update_time_ms = 0;\n\n    // pilot always controls yaw\n    auto_yaw.set_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 16.17434568503039}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // initialise waypoint controller\n    wp_nav.wp_and_spline_init();\n\n    // initialise guided start time and position as reference for limit checking\n    guided_start_time_ms = AP_HAL::millis();\n    guided_start_pos = inertial_nav.get_position();\n\n    // set guided mode targets\n    guided_pos_target_cm.zero();\n    guided_vel_target_cms.zero();\n    guided_accel_target_cmss.zero();\n    update_time_ms = 0;\n\n    // pilot always controls yaw\n    auto_yaw.set_mode(AutoYaw::Mode::HOLD);\n}", "CodeBleu_score": 17.210413489501555}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration limits\n    pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z);\n\n    // initialize vertical speed and acceleration\n    pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n\n    // initialise the vertical position controller\n    if (!pos_control->is_active_z()) {\n        pos_control->init_z_controller();\n    }\n\n    // set horizontal speed and acceleration limits\n    pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration());\n\n    // initialize the vertical position controller\n    if (!pos_control->is_active_xy()) {\n        pos_control->init_xy_controller();\n    }\n\n    // set yaw speed and acceleration limits\n    pos_control->set_max_speed_accel_yaw(wp_nav->get_default_speed_yaw(), wp_nav->get_default_accel_yaw());\n\n    // initialize the yaw position controller\n    if (!pos_control->is_active_yaw()) {\n        pos_control->init_yaw_controller();\n    }\n\n    // set auto yaw mode to AUTO_YAW_HOLD\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 49.797783755486336}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration\n    pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z);\n\n    // set horizontal speed and acceleration\n    pos_control->set_max_speed_accel_xy(g.pilot_speed_forward, g.pilot_speed_up, g.pilot_accel_xy);\n\n    // initialise the vertical position controller\n    if (!pos_control->is_active_z()) {\n        pos_control->init_z_controller();\n    }\n\n    // initialise the lateral position controller\n    if (!pos_control->is_active_xy()) {\n        pos_control->init_xy_controller();\n    }\n\n    // set guided_mode to velocity controller\n    guided_mode = Guided_Velocity;\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 53.79137605680773}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration\n    pos_control->set_max_speed_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up());\n    pos_control->set_max_accel_z(wp_nav->get_default_acceleration());\n\n    // initialise the vertical position controller\n    if (!pos_control->is_active_z()) {\n        pos_control->init_z_controller();\n    }\n\n    // initialise the lateral position controller\n    if (!pos_control->is_active_xy()) {\n        pos_control->init_xy_controller();\n    }\n\n    // set guided_yaw to yaw to a rate or angle\n    set_guided_yaw();\n}", "CodeBleu_score": 43.89976500391809}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // return true if we have hit an altitude limit\n    if (guided_limit.alt_min != -1 && (int32_t)guided_limit.alt_min > current_loc.alt) {\n        return true;\n    }\n\n    // return true if we have hit an altitude limit\n    if (guided_limit.alt_max != -1 && (int32_t)guided_limit.alt_max < current_loc.alt) {\n        return true;\n    }\n\n    // return true if we have gone beyond horizontal control limit\n    if (guided_limit.horiz_max != -1 &&\n        sq(current_loc.lng-guided_limit.center_loc.lng)+sq(current_loc.lat-guided_limit.center_loc.lat) > sq(guided_limit.horiz_max)) {\n        return true;\n    }\n\n    // return true if the guided mode has been running for longer than the timeout\n    if (guided_limit.timeout_sec != -1 &&\n        millis()-guided_limit.start_time >= guided_limit.timeout_sec*1000) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 56.06456453090956}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // return true if timeout is exceeded\n    if (millis() - _mode_enter_time_ms > _timeout_ms) {\n        return true;\n    }\n\n    // check user set limits\n    if (_limit.alt_min > 0.0f && (int32_t)_guided_pos_target_cm.z < _limit.alt_min * 100.0f) {\n        return true;\n    }\n\n    if (_limit.alt_max > 0.0f && (int32_t)_guided_pos_target_cm.z > _limit.alt_max * 100.0f) {\n        return true;\n    }\n\n    // check if horizontal distance moved is more than limit\n    if (_wp_distance_to_destination > _limit.horiz_max_cm) {\n        return true;\n    }\n\n    // if we got this far we must be in limit\n    return false;\n}", "CodeBleu_score": 37.95335709579796}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // return true if timeout, altitude, or horizontal distance from origin is breached\n    return (millis() - _time_start_ms > _timeout_ms) ||\n           (g.rtl_altitude_cm > 0 && copter.current_loc.alt < g.rtl_altitude_cm) ||\n           (g.rtl_altitude_cm < 0 && copter.current_loc.alt > -g.rtl_altitude_cm) ||\n           (get_horizontal_distance_cm(_origin) > g.rtl_dist_cm);\n}", "CodeBleu_score": 21.451854342524275}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t    // Check if motor test requests are received at least every 2 Hz\n    if (millis() - motor_test_last_request_ms > 500) {\n        // Send timeout message\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout\");\n\n        // Set pass flag to false\n        motor_test_pass = false;\n\n        // Disable motor test\n        disable_motor_test();\n\n        // Disarm system\n        disarm_system();\n\n        // Record failure time\n        motor_test_failed_ms = millis();\n\n        // Return false\n        return false;\n    }\n\n    // Return true\n    return true;\n}", "CodeBleu_score": 40.359845881164446}, {"code": "bool Sub::verify_motor_test(){\n\t    // return immediately if disarmed\n    if (!motor_test_in_progress) {\n        return true;\n    }\n\n    // check if test has run for more than 10 seconds\n    if (millis() - motor_test_start_time > (uint32_t)10000) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Motor test timed out\");\n        set_disarmed();\n        DataFlash.Log_Write_Error(ERROR_SUBSYSTEM_MOTOR_TEST_TIMED_OUT);\n        return false;\n    }\n\n    // check if test requests have timed out\n    if (millis() - motor_test_last_request_ms > (uint32_t)500) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Motor test requests timed out\");\n        set_disarmed();\n        DataFlash.Log_Write_Error(ERROR_SUBSYSTEM_MOTOR_TEST_REQUESTS_TIMED_OUT);\n        return false;\n    }\n\n    // check if test is complete\n    if (motor_test_complete) {\n        gcs().send_text(MAV_SEVERITY_INFO, \"Motor test complete\");\n        return true;\n    }\n\n    // motor test still in progress\n    return false;\n}", "CodeBleu_score": 45.50861526629551}, {"code": "bool Sub::verify_motor_test(){\n\t    if (motor_test_mode == MOTOR_TEST_DISABLED) {\n        return true;\n    }\n\n    // check if test times out\n    if (millis() - motor_test_start_time > MOTOR_TEST_TIMEOUT_MS) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        set_mode(ALT_HOLD, MODE_REASON_MOTOR_TEST_TIMEOUT);\n        set_disarmed_and_landed();\n        last_motor_test_failure_us = AP_HAL::micros();\n        return false;\n    }\n\n    // check if test passes\n    if (millis() - motor_test_start_time > MOTOR_TEST_TIMEOUT_MS * 0.5) {\n        if (motor_test_throttle_max > MOTOR_TEST_THROTTLE_MIN && motor_test_throttle_max < MOTOR_TEST_THROTTLE_MAX) {\n            gcs().send_text(MAV_SEVERITY_INFO, \"Motor test passed\");\n            set_mode(ALT_HOLD, MODE_REASON_MOTOR_TEST_COMPLETE);\n            last_motor_test_pass_us = AP_HAL::micros();\n            return true;\n        } else {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test failed: throttle max (%.2f) outside allowed range (%.2f ~ %.2f)\",\n                (double)motor_test_throttle_max,\n                (double)MOTOR_TEST_THROTTLE_MIN,\n                (double)MOTOR_TEST_THROTTLE_MAX);\n            set_mode(ALT_HOLD, MODE_REASON_MOTOR_TEST_FAILED);\n            set_disarmed_and_landed();\n            last_motor_test_failure_us = AP_HAL::micros();\n            return false;\n", "CodeBleu_score": 43.40216571012911}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets in centidegrees\n    lateral_out = wp_nav->get_roll();\n    forward_out = wp_nav->get_pitch();\n\n    // constrain target forward/lateral values\n    lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize\n    lateral_out  /= aparm.angle_max;\n    forward_out /= aparm.angle_max;\n}", "CodeBleu_score": 46.89479782849357}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get pilot desired lean angles\n    lateral_out = (float)wp_nav->get_roll() / 100.0f;\n    forward_out = -(float)wp_nav->get_pitch() / 100.0f;\n\n    // constrain target forward/lateral values\n    if (g.simple_mode == 0) {\n        // regular operating mode\n        lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n        forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n    }else{\n        // simple mode\n        lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n        forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n    }\n\n    // Normalize\n    lateral_out /= aparm.angle_max;\n    forward_out /= aparm.angle_max;\n}", "CodeBleu_score": 44.115132580298614}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets in centidegrees\n    lateral_out = (float)wp_nav->get_roll();\n    forward_out = (float)wp_nav->get_pitch();\n\n    // Constrain target forward/lateral values\n    lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize\n    lateral_out /= aparm.angle_max;\n    forward_out /= aparm.angle_max;\n}", "CodeBleu_score": 49.726863911365584}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t    // return immediately if not enabled\n    if (!barometer.enabled()) {\n        return;\n    }\n\n    barometer.update();\n\n    if (should_log(MASK_LOG_BARO)) {\n        DataFlash.Log_Write_Baro(barometer);\n    }\n\n    // update barometric calibration\n    barometer.update_calibration();\n\n    // update ROS\n    if (ros_enabled) {\n        const uint32_t now = AP_HAL::micros();\n        if (now - last_baro_ros_ms >= 100000UL) {\n            last_baro_ros_ms = now;\n            send_baro_ros();\n        }\n    }\n\n    // calculate temperature-compensated pressure\n    barometer.calculate_pressure(barometer.get_temperature(), barometer.get_pressure(), &baro_alt);\n\n    // update AP_HAL baro\n    AP_HAL::Atmosphere *hal_atmos = AP::atmosphere();\n    if (hal_atmos != nullptr) {\n        hal_atmos->set_external_pressure(baro_alt);\n    }\n\n    // calculate altitude error\n    if (sonar_enabled && !sonar.has_data_orient(ROTATION_PITCH_270)) {\n        // if we have a sonar but no echo, use the baro altitude\n        // as the sonar altitude\n        sonar_alt = baro_alt;\n    }\n    alt_error = baro_alt - sonar_alt;\n\n    // calculate altitude correction for EKF\n    // baro_alt is in m, sonar_alt is in cm\n    // EKF alt is in cm\n    float ekf_alt_correction = baro_alt * 100.0f - sonar_alt;\n\n    // send altitude and altitude correction to EKF\n    ekf_set_position_z_cm(ekf_alt_correction);\n\n    // update rangefinder state\n    rangefinder_state.alt_cm", "CodeBleu_score": 45.928814609868546}, {"code": "void Sub::read_barometer(){\n\t    // return immediately during low battery\n    if (failsafe.battery) {\n        return;\n    }\n\n    // update barometer readings\n    barometer.update();\n\n    // update barometer health\n    barometer.healthy = barometer.enabled() && !barometer.get_pressure().is_zero();\n\n    // if we are calibrating the barometer, update the calibration\n    if (calibrating_barometer) {\n        barometer.update_calibration();\n    }\n\n    // update baro ground effect\n    barometer.update_ground_effect();\n\n    // calculate the new altitude\n    calc_altitude();\n\n    // update the barometer health status\n    update_barometer_health();\n}", "CodeBleu_score": 55.06212942929826}, {"code": "void Sub::read_barometer(){\n\t    if (barometer.update()) {\n        barometer_healthy = true;\n\n        if (should_log(MASK_LOG_BARO)) {\n            DataFlash.Log_Write_Baro(barometer);\n        }\n\n        barometer.update_calibration();\n\n        if (depth_sensor.enabled() && depth_sensor.healthy()) {\n            // update altitude_cm with baro\n            barometer.update_altitude();\n            if (should_log(MASK_LOG_CURRENT)) {\n                Log_Write_Current();\n            }\n        }\n\n        // if we are configured to use the rangefinder for height\n        // control, then we use the height above ground as the altitude\n        // above home\n        if (rangefinder_alt_ok()) {\n            // we are using rangefinder, correct baro alt above home\n            barometer.correct_alt_for_ef_alt();\n        }\n\n        // only use the baro altitude if we are not using rangefinder\n        // above home for altitude\n        if (!rangefinder_alt_ok()) {\n            // we are not using rangefinder, set altitude above home to\n            // baro altitude\n            barometer.set_home_alt_cm(barometer.get_altitude_cm());\n        }\n\n        // mark baro altitude as valid\n        barometer.set_alt_ok();\n\n        // clear baro altitude offset used for EKF\n        baro_alt_offset_cm = 0;\n    } else {\n        barometer_healthy = false;\n    }\n\n    // update baro ground offset\n    if (barometer.get_ground_temperature() > -100) {\n        baro_ground_temp_celsius = barometer.get_ground_temperature() * 0.01f;\n    }\n\n    if (barometer.get_ground_pressure() > 0) {\n        baro_ground_pressure_pa = barometer.get_ground_pressure() * 100;\n    }\n\n    if (barometer.get_ground_altitude_cm", "CodeBleu_score": 49.91546408469958}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    // if inertial nav never available then do not use EKF for navigation\n    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n\n    // if disarmed we accept a predicted position\n    if (!motors.armed()) {\n        return true;\n    }\n\n    // require acceptable position for navigation\n    if (!ahrs.healthy()\n        || ahrs.get_position().longitude == 0.0f\n        || ahrs.get_position().latitude == 0.0f) {\n        return false;\n    }\n\n    // if ekf origin has not been set yet then EKF home must be within 20km of current position\n    if (!ahrs.get_origin().set) {\n        if (ahrs.get_distance_home() > 20000.0f) {\n            return false;\n        }\n    }\n\n    // if ekf position is invalid\n    if (!ahrs.get_position().xy_valid) {\n        return false;\n    }\n\n    // if we are using range finder for height\n    if (rangefinder_alt_ok()) {\n        // if ekf alt is not ok\n        if (!ahrs.get_position().z_valid) {\n            return false;\n        }\n    }\n\n    // if we are using optical flow for height\n    if (optical_flow_alt_ok()) {\n        // if ekf alt is not ok\n        if (!ahrs.get_position().z_valid) {\n            return false;\n        }\n    }\n\n    // if we are using GPS for height\n    if (gps_alt_ok()) {\n        // if ekf alt is not ok\n        if (!ahrs.get_position().z_valid) {\n            return false;\n        }\n    }\n\n    // if we are using external vision for height\n    if (ext_vision_alt_ok()) {\n        // if ekf alt is not ok\n        if (!ahrs.get_position().z_valid) {\n            return false;\n        }\n    }\n\n    // if we are using GPS for position\n", "CodeBleu_score": 53.54762456608435}, {"code": "bool Sub::ekf_position_ok(){\n\t    // check ekf position estimate\n    if (!ahrs.get_position(current_loc)) {\n        return false;\n    }\n\n    // if disarmed we accept a predicted horizontal position\n    if (!motors.armed()) {\n        return true;\n    }\n\n    // if in constant position mode we accept a predicted horizontal position\n    if (ap.position_relative_to_origin && !ahrs.home_is_set()) {\n        return true;\n    }\n\n    // require an absolute position\n    if (!current_loc.relative_alt) {\n        return true;\n    }\n\n    // if ekf origin has not been set yet\n    Location ekf_origin;\n    if (!ahrs.get_origin(ekf_origin)) {\n        return false;\n    }\n\n    // if ekf origin and ahrs home are not the same and not in relative altitude mode\n    if (!ap.position_relative_to_origin && (ekf_origin != ahrs.get_home())) {\n        return false;\n    }\n\n    // if ekf position is not valid\n    if (!current_loc.ekf_valid) {\n        return false;\n    }\n\n    // if ekf position is not trusted\n    if (!current_loc.pos_horiz_accuracy_ok()) {\n        return false;\n    }\n\n    // if ekf altitude is not trusted\n    if (!current_loc.pos_vert_accuracy_ok()) {\n        return false;\n    }\n\n    // if ekf's horizontal position estimate is not reliably different from the ekf origin\n    if (current_loc.get_distance(ekf_origin) < 1000) {\n        return false;\n    }\n\n    // if we are in guided mode and the pilot's horizontal position is more than 100m from the ekf origin\n    if (control_mode == GUIDED && current_loc.get_distance(ekf_origin) > 100) {\n        return false;\n    }\n\n    // if we are in a takeoff state\n    if (takeoff_state.running && !take", "CodeBleu_score": 45.12372445994391}, {"code": "bool Sub::ekf_position_ok(){\n\t    // return false if ekf not yet initialised\n    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n\n    // return true if motors are disarmed\n    if (!motors.armed()) {\n        return true;\n    }\n\n    // return true if in constant position mode\n    if (control_mode == AUTO && nav_status == AP_NavEKF_NAV_STATUS_FIXED_POS) {\n        return true;\n    }\n\n    // ensure position is recent\n    if (ahrs.get_last_attitude_time_ms() > 1000) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 46.19435255125802}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // always allow if arming disabled\n    if (!_checks_to_perform.gps) {\n        return true;\n    }\n\n    if (!rover.control_mode->requires_position() && !rover.control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure position estimate is ok\n    if ((rover.failsafe.ekf || rover.failsafe.terrain) && !rover.ekf_position_ok()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: EKF failsafe\");\n        }\n        return false;\n    }\n\n    // if we have GPS and are in AUTO mode, return true\n    return rover.control_mode != &rover.mode_auto;\n}", "CodeBleu_score": 49.055947773384226}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // check parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check ahrs is ok\n    if (!AP::ahrs().pre_arm_check()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: AHRS not healthy\");\n        }\n        return false;\n    }\n\n    // check ekf has enough ground stations\n    if (rover.control_mode != &rover.mode_hold && rover.g2.failsafe_gcs) {\n        if (rover.g2.failsafe_gcs == AP_GPS::GCS_FAILSAFE_EKF_GPS && !rover.ahrs.get_NavEKF_const().have_horizontal_velocity()) {\n            if (display_failure) {\n                gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: EKF must confirm GPS\");\n            }\n            return false;\n        }\n    }\n\n    // check position estimate is ok\n    if (!AP::ahrs().get_position(location)) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Need position estimate\");\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 56.09957070562539}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // check EKF has started\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check AHRS has started\n    if (!AP_Arming::ahrs_checks(display_failure)) {\n        return false;\n    }\n\n    // check EKF is ok\n    if (!ekf_checks(display_failure)) {\n        return false;\n    }\n\n    // check position estimate is ok\n    if (!AP_Arming::position_checks(display_failure)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 28.37010056349959}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // check if arming is disabled\n    if (!_rover.arming.is_enabled()) {\n        return false;\n    }\n\n    // check if arming method is allowed\n    if (!_rover.arming.arm_method(method)) {\n        return false;\n    }\n\n    // check if arming checks are required\n    if (do_arming_checks && !_rover.arming.pre_arm_checks(true)) {\n        return false;\n    }\n\n    // check if arming checks are required\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // check if arming checks are required\n    if (do_arming_checks && !_rover.arming.pre_arm_rc_checks()) {\n        return false;\n    }\n\n    // set smart RTL home location\n    if (_rover.g2.smart_rtl) {\n        if (!_rover.mode_auto.set_home_to_current_location(false)) {\n            return false;\n        }\n    }\n\n    // initialise simple mode heading\n    _rover.mode_simple.init_heading();\n\n    // record home heading for sail vehicles\n    if (_rover.g2.sailboat_protection && !_rover.mode_auto.is_autopilot_mode()) {\n        _rover.mode_simple.record_home_heading();\n    }\n\n    // update armed status\n    _rover.set_armed(true, ArmingMethod::RUDDER);\n\n    // log arming enabled\n    _rover.logger.Write_Event(LogEvent::ARMING_ENABLE);\n\n    // send arm/disarm status text\n    _rover.gcs().send_text(MAV_SEVERITY_INFO, \"Armed\");\n\n    return true;\n}", "CodeBleu_score": 54.01165732112151}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (armed) {\n        return true;\n    }\n\n    // don't allow arming until all sensors have been calibrated\n    if (do_arming_checks && !rover.ins.get_accel_calibration_complete()) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Acc Cal required\");\n        return false;\n    }\n\n    if (do_arming_checks && !rover.ins.get_gyro_calibration_complete()) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Gyro Cal required\");\n        return false;\n    }\n\n    // check if arming via the mode switch is allowed\n    if (do_arming_checks && !rover.control_mode->mode_allows_arming(method, true)) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Mode not armable\");\n        return false;\n    }\n\n    // check if arming via RC switch is allowed\n    if (do_arming_checks && !rc_calibration_checks(true)) {\n        return false;\n    }\n\n    // check if arming via the mission controller is allowed\n    if (do_arming_checks && !mission_checks(true)) {\n        return false;\n    }\n\n    // check if arming via the command interface is allowed\n    if (do_arming_checks && !command_checks(true)) {\n        return false;\n    }\n\n    // if we got this far all arming checks have passed and the vehicle can be armed\n    set_armed(true, ArmingMethod::MAVLINK, true);\n\n    // Record time stamp of arming and log an event\n    arm_time_ms = AP_HAL::millis();\n    AP::logger().Write_Event(LogEvent::ARMED);\n\n    // log flight mode in case it was changed while vehicle was disarmed\n    AP::logger().Write_Mode(rover.control_mode->mode_number(), control_mode);\n\n    // re-", "CodeBleu_score": 45.79990734906367}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (armed) {\n        return true;\n    }\n\n    // if method is unknown, try to use the current method\n    if (method == AP_Arming::Method::UNKNOWN) {\n        method = arming_method;\n    }\n\n    // arm according to method\n    switch (method) {\n\n    case AP_Arming::Method::RUDDER:\n        if (!rudder_arm()) {\n            return false;\n        }\n        break;\n\n    default:\n        // do nothing\n        return false;\n    }\n\n    // if we got this far all must be ok\n    // set arming flag\n    armed = true;\n\n    // arm gcs and motors\n    AP::logger().Write_Event(LogEvent::ARMED);\n\n    // log arming to dataflash\n    AP::logger().Write_Data_Armed();\n\n    // update notify object\n    AP_Notify::flags.armed = true;\n    AP::notify().update_notify();\n\n    // return success\n    return true;\n}", "CodeBleu_score": 38.987929791138455}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (charging_enabled) {\n      // Charging is allowed and is already enabled, so do nothing\n      return;\n    } else {\n      // Charging is allowed but is not enabled, so enable it\n      charging_enabled = true;\n      digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n      charging_start_time = millis();\n      return;\n    }\n  } else {\n    if (charging_enabled) {\n      // Charging is not allowed but is already enabled, so disable it\n      charging_enabled = false;\n      digitalWrite(CHARGE_ENABLE_PIN, LOW);\n      charging_stop_time = millis();\n      return;\n    } else {\n      // Charging is not allowed and is already disabled, so do nothing\n      return;\n    }\n  }\n}", "CodeBleu_score": 45.52804040413668}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (!charging_enabled) {\n            charging_enabled = true;\n            charging_enabled_time = millis();\n            digitalWrite(CHARGE_PIN, HIGH);\n        }\n    } else {\n        if (charging_enabled) {\n            charging_enabled = false;\n            charging_enabled_time = millis();\n            digitalWrite(CHARGE_PIN, LOW);\n        }\n    }\n}", "CodeBleu_score": 47.04967812232708}, {"code": "void updateChargingEnabled(){\n\t    static bool charging_enabled = false;\n    static bool charging_allowed = true;\n    static uint32_t charging_disabled_time = 0;\n\n    if (charging_allowed) {\n        if (charging_enabled) {\n            // Charging is enabled, check if it should be disabled\n            if (is_charging_allowed()) {\n                // Charging is allowed, do nothing\n            } else {\n                // Charging is not allowed, disable charging\n                charging_enabled = false;\n                charging_disabled_time = millis();\n            }\n        } else {\n            // Charging is disabled, check if it should be enabled\n            if (is_charging_allowed()) {\n                // Charging is allowed, enable charging\n                charging_enabled = true;\n            } else {\n                // Charging is not allowed, check if it should be enabled again\n                if (millis() - charging_disabled_time > CHARGING_DISABLED_TIME) {\n                    // Charging has been disabled for a while, check if it should be enabled again\n                    if (is_charging_allowed()) {\n                        // Charging is allowed, enable charging\n                        charging_enabled = true;\n                    }\n                }\n            }\n        }\n    } else {\n        // Charging is not allowed, check if it should be enabled again\n        if (is_charging_allowed()) {\n            // Charging is allowed, enable charging\n            charging_allowed = true;\n            charging_enabled = true;\n        }\n    }\n\n    // Set the charging state based on the charging_enabled flag\n    if (charging_enabled) {\n        charging_control_pin.setDigitalValue(1);\n    } else {\n        charging_control_pin.setDigitalValue(0);\n    }\n}", "CodeBleu_score": 57.11926414533524}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t    if (ros_running && size >= 4) {\n        uint16_t crc = FastCRC16.ccitt((uint8_t*)message, size - 2);\n        memcpy((uint8_t*)message + size - 2, &crc, 2);\n        packetSerial.send((uint8_t*)message, size);\n    }\n}", "CodeBleu_score": 44.29225427050374}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ROS_running) {\n    if (size < 4) {\n      return;\n    }\n\n    uint16_t crc = FastCRC16.ccitt((uint8_t *) message, size - 2);\n    memcpy((uint8_t *) message + size - 2, &crc, 2);\n\n    packetSerial.send((uint8_t *) message, size);\n  }\n}", "CodeBleu_score": 56.08446926437662}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (ros_running && size > 3) {\n        uint8_t *message_ = (uint8_t *)message;\n        uint16_t crc = FastCRC16::ccitt(message_, size - 2);\n        message_[size - 2] = crc >> 8;\n        message_[size - 1] = crc & 0xFF;\n        packetSerial.send(message_, size);\n    }\n}", "CodeBleu_score": 56.461487054440205}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t  Serial.begin(9600);\n  delay(100);\n  clearBuffer();\n  Serial.println(\"MP3Sound::begin()\");\n  Serial.println(\"Initializing sound module...\");\n  if (!initializeSoundModule()) {\n    Serial.println(\"Failed to initialize sound module\");\n    return false;\n  }\n\n  Serial.println(\"Sound module initialized\");\n  Serial.println(\"Retrieving number of sound files...\");\n  int numFiles = getNumberOfFiles();\n  Serial.print(\"Number of sound files: \");\n  Serial.println(numFiles);\n  if (numFiles <= 0) {\n    Serial.println(\"No sound files found\");\n    return false;\n  }\n\n  Serial.println(\"Sound files available\");\n  return true;\n}", "CodeBleu_score": 40.214862327767065}, {"code": "bool MP3Sound::begin(){\n\t  Serial1.begin(9600);\n  clearBuffer();\n  if (initSoundSystem()) {\n    numSounds = getNumberOfSounds();\n    return numSounds > 0;\n  }\n  return false;\n}", "CodeBleu_score": 28.527954415878774}, {"code": "bool MP3Sound::begin(){\n\t  Serial.begin(9600);\n  delay(100);\n  Serial.write(0x7E);\n  Serial.write(0xFF);\n  Serial.write(0x06);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0xEF);\n  delay(100);\n  while (Serial.available()) {\n    Serial.read();\n  }\n  Serial.write(0x7E);\n  Serial.write(0xFF);\n  Serial.write(0x06);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0xEF);\n  delay(100);\n  while (Serial.available()) {\n    Serial.read();\n  }\n  Serial.write(0x7E);\n  Serial.write(0xFF);\n  Serial.write(0x06);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0", "CodeBleu_score": 41.27161930480002}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\n  if (activeSounds.size() == 0) {\n    return 0;\n  }\n\n  if (mp3.isPlaying()) {\n    return activeSounds.size();\n  }\n\n  Sound sound = activeSounds.back();\n  activeSounds.pop_back();\n\n  mp3.play(sound.filename);\n\n  return activeSounds.size();\n\n}", "CodeBleu_score": 49.29776830438779}, {"code": "int MP3Sound::processSounds(){\n\t\n  if (activeSounds.size() == 0) {\n    return 0;\n  }\n\n  if (mp3.isPlaying()) {\n    return activeSounds.size();\n  }\n\n  String sound = activeSounds.back();\n  activeSounds.pop_back();\n\n  playMP3(sound);\n\n  return activeSounds.size();\n}", "CodeBleu_score": 45.615464253748925}, {"code": "int MP3Sound::processSounds(){\n\t    if (this->activeSounds.size() == 0) {\n        return 0;\n    }\n\n    if (this->mp3.isPlaying()) {\n        return this->activeSounds.size();\n    }\n\n    String sound = this->activeSounds.back();\n    this->activeSounds.pop_back();\n\n    this->mp3.play(sound);\n\n    return this->activeSounds.size();\n}", "CodeBleu_score": 23.93468330870385}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    const char *filename = wb_request_get_string(r);\n    if (filename == NULL)\n      return false;\n    const char *path = wb_device_get_data_path(d);\n    char *full_path = malloc(strlen(path) + strlen(filename) + 1);\n    sprintf(full_path, \"%s%s\", path, filename);\n    if (wb_robot_set_memory_mapped_file(d, full_path) == false) {\n      free(full_path);\n      return false;\n    }\n    free(full_path);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 37.29962914857846}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    int i;\n    char *file_name;\n    char *file_path;\n    int file_size;\n    int file_descriptor;\n    void *file_pointer;\n    char *file_name_pointer;\n    char *file_path_pointer;\n    int file_size_pointer;\n    int file_descriptor_pointer;\n    void *file_pointer_pointer;\n    int file_name_size;\n    int file_path_size;\n    int file_size_size;\n    int file_descriptor_size;\n    int file_pointer_size;\n    int file_name_pointer_size;\n    int file_path_pointer_size;\n    int file_size_pointer_size;\n    int file_descriptor_pointer_size;\n    int file_pointer_pointer_size;\n    int size;\n    int size_pointer;\n    int size_pointer_size;\n    int size_pointer_pointer_size;\n    int size_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer_pointer_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_size;\n    int size_pointer_pointer_pointer", "CodeBleu_score": 13.949366787896372}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  bool handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      if (d->memory_mapped_file != NULL)\n        wb_robot_free(d->memory_mapped_file);\n      d->memory_mapped_file = wb_robot_malloc(r->length + 1);\n      memcpy(d->memory_mapped_file, r->data, r->length);\n      d->memory_mapped_file[r->length] = '\\0';\n      break;\n    default:\n      handled = false;\n  }\n  return handled;\n}", "CodeBleu_score": 56.64205664051744}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  AbstractCamera *ac = d->pdata;\n  int height = -1;\n  if (ac->height_changed) {\n    pthread_mutex_lock(&ac->mutex);\n    height = ac->height;\n    pthread_mutex_unlock(&ac->mutex);\n  }\n  return height;\n}", "CodeBleu_score": 53.23136652052721}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  AbstractCamera *ac = d->pdata;\n  if (d->type != WB_DEVICE_CAMERA) {\n    fprintf(stderr, \"Error: %s() called for a non-camera device.\n\", __FUNCTION__);\n    return -1;\n  }\n  pthread_mutex_lock(&ac->mutex);\n  int height = ac->height;\n  pthread_mutex_unlock(&ac->mutex);\n  return height;\n}", "CodeBleu_score": 46.504576160731915}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (d->tag != WB_DEVICE_TAG_CAMERA)\n    return -1;\n\n  wb_robot_mutex_lock_step();\n\n  if (d->image_data) {\n    wb_robot_mutex_unlock_step();\n    return d->image_data->height;\n  }\n\n  wb_robot_mutex_unlock_step();\n  return -1;\n}", "CodeBleu_score": 45.33296543964303}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  device_t *device = robot_get_device_from_tag(tag);\n  if (device == NULL) {\n    fprintf(stderr, \"Error: %s() called with an invalid device tag.\n\", __FUNCTION__);\n    return 0;\n  }\n  if (device->type != WB_NODE_ACCELEROMETER) {\n    fprintf(stderr, \"Error: %s() called with a device tag not associated with an accelerometer.\n\", __FUNCTION__);\n    return 0;\n  }\n  pthread_mutex_lock(&device->mutex);\n  sampling_period = device->accelerometer->sampling_period;\n  pthread_mutex_unlock(&device->mutex);\n  return sampling_period;\n}", "CodeBleu_score": 50.71717724572178}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  WbDevice *d = robot_search_device(tag);\n  if (d == NULL) {\n    fprintf(stderr, \"Error: %s() called for an invalid device tag.\n\", __FUNCTION__);\n    return 0;\n  }\n  if (d->type != WB_NODE_ACCELEROMETER) {\n    fprintf(stderr, \"Error: %s() called on a device \\\"%s\\\" which is not an accelerometer.\n\", __FUNCTION__,\n            d->name);\n    return 0;\n  }\n  pthread_mutex_lock(&d->mutex);\n  sampling_period = d->accelerometer.sampling_period;\n  pthread_mutex_unlock(&d->mutex);\n  return sampling_period;\n}", "CodeBleu_score": 51.10052624194332}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  WbDevice *d = robot_search_device(tag);\n  if (d == NULL) {\n    fprintf(stderr, \"Error: %s() called with an invalid device tag.\n\", __FUNCTION__);\n    return 0;\n  }\n  if (d->type != WB_NODE_ACCELEROMETER) {\n    fprintf(stderr, \"Error: %s() called with a device tag from an unsupported device.\n\", __FUNCTION__);\n    return 0;\n  }\n  pthread_mutex_lock(&d->mutex);\n  sampling_period = d->accelerometer.sampling_period;\n  pthread_mutex_unlock(&d->mutex);\n  return sampling_period;\n}", "CodeBleu_score": 51.23610971503889}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *str = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string s(str);\n  free(str);\n  return s;\n}", "CodeBleu_score": 38.94488609569987}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *str = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(str);\n  free(str);\n  return result;\n}", "CodeBleu_score": 39.62874746604304}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dmsString(dms);\n  free(dms);\n  return dmsString;\n}", "CodeBleu_score": 40.526162192779694}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dVector3 p;\n    dReal d, d1, d2;\n    dGeomBoxGetLengths (g, &p[0], &p[1], &p[2]);\n    d = x - dGeomGetPosition (g)[0];\n    d1 = dAbs (d) - p[0];\n    d2 = dAbs (d) - p[1];\n    if (d1 < d2) {\n        plane[0] = dSign (d);\n        plane[1] = 0;\n        plane[2] = 0;\n        plane[3] = dGeomGetPosition (g)[0] + p[0] * dSign (d);\n    } else {\n        plane[0] = 0;\n        plane[1] = dSign (d);\n        plane[2] = 0;\n        plane[3] = dGeomGetPosition (g)[1] + p[1] * dSign (d);\n    }\n}", "CodeBleu_score": 25.85449576216543}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dGeomBoxGetLengths (g, plane, plane + 1, plane + 2);\n    plane[3] = plane[0] * plane[1] * plane[2];\n    dReal p[3] = {x, y, z};\n    dReal c[3];\n    dGeomBoxGetLengths (g, c, c + 1, c + 2);\n    dReal d = plane[3] / 2;\n    dReal dist[3];\n    for (int i = 0; i < 3; i++) {\n        dist[i] = dGeomBoxPointDepth (g, x, y, z, i);\n        if (dist[i] < d) {\n            d = dist[i];\n            plane[3] = -d;\n            plane[i] = 0;\n            plane[(i + 1) % 3] = 1;\n            plane[(i + 2) % 3] = 0;\n        }\n    }\n}", "CodeBleu_score": 30.596296456020255}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dGeomBoxGetParams(g, plane, plane + 1, plane + 2);\n    dReal p[3] = {x, y, z};\n    dReal center[3];\n    dGeomBoxGetLengths(g, center, center + 1, center + 2);\n    for (int i = 0; i < 3; i++) {\n        center[i] -= plane[i];\n    }\n    int closest_axis = 0;\n    dReal closest_distance = std::abs(center[0]);\n    for (int i = 1; i < 3; i++) {\n        dReal distance = std::abs(center[i]);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_axis = i;\n        }\n    }\n    plane[3] = -center[closest_axis];\n    plane[closest_axis] = 0;\n}", "CodeBleu_score": 30.704404414146413}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  int result;\n  dBodyID body;\n  dReal *p;\n  dReal *R;\n  dReal *side;\n  dReal *up;\n  dReal *front;\n  dReal *pos;\n  dReal *rot;\n  dReal *boxSize;\n  dReal *boxPos;\n  dReal *boxRot;\n  dReal *fluidPlanePos;\n  dReal *fluidPlaneRot;\n  dReal *fluidPlaneNormal;\n  dReal *fluidPlaneUp;\n  dReal *fluidPlaneSide;\n  dReal *fluidPlaneFront;\n  dReal *fluidPlaneSize;\n  dReal *fluidPlanePos2;\n  dReal *fluidPlaneRot2;\n  dReal *fluidPlaneNormal2;\n  dReal *fluidPlaneUp2;\n  dReal *fluidPlaneSide2;\n  dReal *fluidPlaneFront2;\n  dReal *fluidPlaneSize2;\n  dReal *fluidPlanePos3;\n  dReal *fluidPlaneRot3;\n  dReal *fluidPlaneNormal3;\n  dReal *fluidPlaneUp3;\n  dReal *fluidPlaneSide3;\n  dReal *fluidPlaneFront3;\n  dReal *fluidPlaneSize3;\n  dReal *fluidPlanePos4;\n  dReal *fluidPlaneRot4;\n  dReal *fluidPlaneNormal4;\n  dReal *fluidPlaneUp4;\n  dReal *fluidPlaneSide4;\n  dReal *fluidPlaneFront4;\n  dReal *fluidPlaneSize4;\n  dReal *fluidPlanePos5;\n  dReal *fluidPlaneRot5;\n  dReal *fluidPlaneNormal5;\n  dReal *fluidPlaneUp5;\n  dReal *fluidPlaneSide5;\n  dReal *fluidPlaneFront5;\n  dReal *fluidPlaneSize5;\n  dReal *fluidPlanePos6;\n  dReal *fluidPlaneRot6;\n  dReal *fluidPlaneNormal6;\n  dReal *fluidPlaneUp6;\n", "CodeBleu_score": 8.364270137958583}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n   if (!box->body) return 0;\n\n   if (!immersion) return 0;\n\n   if (flags < 0) return 0;\n\n   sBoxImmersionData immersionData;\n\n   immersionData.box = box;\n\n   immersionData.fluidPlane = fluidPlane;\n\n   immersionData.immersion = immersion;\n\n   immersionData.flags = flags;\n\n   return dImmerseBox(&immersionData);\n}", "CodeBleu_score": 43.431782775817005}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n  // Check that the box has a body and the flags are valid\n  if (!box->body || !fluidPlane || !immersion) return 0;\n  if (flags & ~(dIMMERSE_FORCE_ONLY | dIMMERSE_IGNORE_BOX_ROTATION)) return 0;\n\n  // Initialize an sBoxImmersionData object with the box, fluid plane, immersion, and flags\n  sBoxImmersionData data;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.immersion = immersion;\n  data.flags = flags;\n\n  // Perform the immersion checking and return the result\n  return dImmerseBoxData(&data);\n}", "CodeBleu_score": 45.92362886396193}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    int err = 0;\n    dGeomID g1 = dGeomGetBody (o1);\n    dGeomID g2 = dGeomGetBody (o2);\n    dBodyID b1 = dGeomGetBody (o1);\n    dBodyID b2 = dGeomGetBody (o2);\n    dReal *p1 = dGeomGetPosition (o1);\n    dReal *p2 = dGeomGetPosition (o2);\n    dReal *R1 = dGeomGetRotation (o1);\n    dReal *R2 = dGeomGetRotation (o2);\n    dReal *v1 = dBodyGetLinearVel (b1);\n    dReal *v2 = dBodyGetLinearVel (b2);\n    dReal *w1 = dBodyGetAngularVel (b1);\n    dReal *w2 = dBodyGetAngularVel (b2);\n    dReal *l1 = dGeomGetLengths (o1);\n    dReal *l2 = dGeomGetLengths (o2);\n    dReal *r1 = dGeomGetRadius (o1);\n    dReal *r2 = dGeomGetRadius (o2);\n    dReal *p = immersion->p;\n    dReal *n = immersion->n;\n    dReal *v = immersion->v;\n    dReal *w = immersion->w;\n    dReal *t = immersion->t;\n    dReal *a = immersion->a;\n    dReal *b = immersion->b;\n    dReal *c = immersion->c;\n    dReal *d = immersion->d;\n    dReal *e = immersion->e;\n    dReal *f = immersion->f;\n    dReal *g = immersion->g;\n    dReal *h = immersion->h;\n    dReal *i = immersion->i;\n    dReal *j = immersion->j;\n    dReal *k = immersion->k;\n    dReal *l = immersion->l", "CodeBleu_score": 33.32948856779993}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dVector3 p, R;\n    dReal a, b, c;\n    dReal r1, r2, r3;\n    dReal h, h2;\n    dReal radius, radius2;\n    dReal h1, h2;\n    dReal h3, h4;\n    dReal h5, h6;\n    dReal h7, h8;\n    dReal h9, h10;\n    dReal h11, h12;\n    dReal h13, h14;\n    dReal h15, h16;\n    dReal h17, h18;\n    dReal h19, h20;\n    dReal h21, h22;\n    dReal h23, h24;\n    dReal h25, h26;\n    dReal h27, h28;\n    dReal h29, h30;\n    dReal h31, h32;\n    dReal h33, h34;\n    dReal h35, h36;\n    dReal h37, h38;\n    dReal h39, h40;\n    dReal h41, h42;\n    dReal h43, h44;\n    dReal h45, h46;\n    dReal h47, h48;\n    dReal h49, h50;\n    dReal h51, h52;\n    dReal h53, h54;\n    dReal h55, h56;\n    dReal h57, h58;\n    dReal h59, h60;\n    dReal h61, h62;\n    dReal h63, h64;\n    dReal h65, h66;\n    dReal h67, h68;\n    dReal h69, h70;\n    dReal h71, h72;\n    dReal h73, h74;\n    dReal h75, h76;\n    dReal h77, h78;\n    dReal", "CodeBleu_score": 7.476816352251831}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  // Validate input arguments\n  if (!o1 || !o2 || !immersion) {\n    return 0;\n  }\n\n  // Get the box and capsule geometries\n  dxBox *box = (dxBox *) o1;\n  dxCapsule *capsule = (dxCapsule *) o2;\n\n  // Check if the box and capsule are in contact\n  if (!dIMMERSE_BOX_CAPSULE_TEST (box, capsule)) {\n    return 0;\n  }\n\n  // Set the immersion parameters\n  immersion->type = dImmersionType::BOX_CAPSULE;\n  immersion->o1 = o1;\n  immersion->o2 = o2;\n  immersion->flags = flags;\n\n  // Compute the immersion plane for the capsule\n  dVector3 plane;\n  dReal plane0, plane1, plane2, plane3;\n  dIMMERSE_BOX_CAPSULE_PLANE (box, capsule, plane, plane0, plane1, plane2, plane3);\n\n  // Process the immersion of the box in the fluid\n  return dImmerseBox (immersion, plane, plane0, plane1, plane2, plane3);\n}", "CodeBleu_score": 51.04438645826044}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    dReal zIOverR2 = zIOverR * zIOverR;\n    dReal zIOverR3 = zIOverR2 * zIOverR;\n    dReal zIOverR4 = zIOverR2 * zIOverR2;\n    dReal zIOverR5 = zIOverR3 * zIOverR2;\n    dReal zIOverR6 = zIOverR3 * zIOverR3;\n    dReal zIOverR7 = zIOverR4 * zIOverR3;\n    dReal zIOverR8 = zIOverR4 * zIOverR4;\n    dReal zIOverR9 = zIOverR5 * zIOverR4;\n    dReal zIOverR10 = zIOverR5 * zIOverR5;\n    dReal zIOverR11 = zIOverR6 * zIOverR5;\n    dReal zIOverR12 = zIOverR6 * zIOverR6;\n    dReal zIOverR13 = zIOverR7 * zIOverR6;\n    dReal zIOverR14 = zIOverR7 * zIOverR7;\n    dReal zIOverR15 = zIOverR8 * zIOverR7;\n    dReal zIOverR16 = zIOverR8 * zIOverR8;\n    dReal zIOverR17 = zIOverR9 * zIOverR8;\n    dReal zIOverR18 = zIOverR9 * zIOverR9;\n    dReal zIOverR19 = zIOverR10 * zIOverR9;\n    dReal zIOverR20 = zIOverR10 * zIOverR10;\n    dReal zIOverR21 = zIOverR11 * zIOverR10;\n    dReal zIOverR22 = zIOverR11 * zIOverR11;\n    dReal zIOverR23 = zIOverR12 * zIOverR11;\n    dReal zIOverR2", "CodeBleu_score": 34.97401609379131}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\n    dReal zIOverR2 = zIOverR * zIOverR;\n\n    dReal zIOverR3 = zIOverR2 * zIOverR;\n\n    dReal zIOverR4 = zIOverR3 * zIOverR;\n\n    dReal zIOverR5 = zIOverR4 * zIOverR;\n\n    dReal zIOverR6 = zIOverR5 * zIOverR;\n\n    dReal zIOverR7 = zIOverR6 * zIOverR;\n\n    dReal zIOverR8 = zIOverR7 * zIOverR;\n\n    dReal zIOverR9 = zIOverR8 * zIOverR;\n\n    dReal zIOverR10 = zIOverR9 * zIOverR;\n\n    dReal zIOverR11 = zIOverR10 * zIOverR;\n\n    dReal zIOverR12 = zIOverR11 * zIOverR;\n\n    dReal zIOverR13 = zIOverR12 * zIOverR;\n\n    dReal zIOverR14 = zIOverR13 * zIOverR;\n\n    dReal zIOverR15 = zIOverR14 * zIOverR;\n\n    dReal zIOverR16 = zIOverR15 * zIOverR;\n\n    dReal zIOverR17 = zIOverR16 * zIOverR;\n\n    dReal zIOverR18 = zIOverR17 * zIOverR;\n\n    dReal zIOverR19 = zIOverR18 * zIOverR;\n\n    dReal zIOverR20 = zIOverR19 * zIOverR;\n\n    dReal zIOverR21 = zIOverR20 * zIOverR;\n\n    dReal zIOverR22 = zIOverR21 * zIOverR;\n\n    dReal zIOverR23 = zIOverR22 * zIOverR;\n\n   ", "CodeBleu_score": 29.961336656293565}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\n\n\n    // Calculate the normalized volume of the hemisphere using Simpson's rule\n\n    dReal volume = 0.0;\n\n    dReal tanTheta1 = zIOverR / sinTheta1;\n\n    dReal tanThetaHalf = (tanTheta0 + tanTheta1) / 2.0;\n\n    dReal sinThetaHalf = tanThetaHalf / sqrt(1.0 + tanThetaHalf * tanThetaHalf);\n\n    dReal tanThetaHalfSquared = tanThetaHalf * tanThetaHalf;\n\n    dReal sinThetaHalfSquared = sinThetaHalf * sinThetaHalf;\n\n    dReal zIOverRHalf = zIOverR / 2.0;\n\n    dReal zIOverRHalfSquared = zIOverRHalf * zIOverRHalf;\n\n    dReal zIOverRHalfCubed = zIOverRHalfSquared * zIOverRHalf;\n\n    dReal zIOverRHalfQuartic = zIOverRHalfCubed * zIOverRHalf;\n\n    dReal zIOverRHalfQuintic = zIOverRHalfQuartic * zIOverRHalf;\n\n    dReal tanTheta0Squared = tanTheta0 * tanTheta0;\n\n    dReal tanTheta0Cubed = tanTheta0Squared * tanTheta0;\n\n    dReal tanTheta0Quartic = tanTheta0Cubed * tanTheta0;\n\n    dReal tanTheta0Quintic = tanTheta0Quartic * tanTheta0;\n\n    dReal tanTheta1Squared = tanTheta1 * tanTheta1;\n\n    dReal tanTheta1Cubed = tanTheta1Squared * tanTheta1;\n\n    dReal tanTheta1Quartic = tanTheta1Cubed * tanTheta1;\n\n    dReal tanTheta1Quintic = tanTheta1Quartic * tanTheta1;\n\n    dReal sinTheta0 = tanTheta0 / sqrt(1.0 + tanTheta0Squared);\n\n    dReal sinTheta", "CodeBleu_score": 36.82567611485514}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\n    dReal xBuoyancyCenter = 0;\n\n    dReal x0 = zIOverR * tanTheta0;\n\n    dReal x1 = zIOverR * sinTheta1;\n\n    dReal xMid = (x0 + x1) / 2;\n\n    dReal xDelta = x1 - x0;\n\n    dReal xDeltaSquared = xDelta * xDelta;\n\n    dReal xDeltaCubed = xDeltaSquared * xDelta;\n\n    dReal xDeltaQuartic = xDeltaCubed * xDelta;\n\n    dReal xDeltaQuintic = xDeltaQuartic * xDelta;\n\n    dReal xDeltaSextic = xDeltaQuintic * xDelta;\n\n    dReal xDeltaSeptic = xDeltaSextic * xDelta;\n\n    dReal xDeltaOctic = xDeltaSeptic * xDelta;\n\n    dReal xDeltaNonic = xDeltaOctic * xDelta;\n\n    dReal xDeltaDecadic = xDeltaNonic * xDelta;\n\n    dReal xDeltaDodecic = xDeltaDecadic * xDelta;\n\n    dReal xDeltaTridecic = xDeltaDodecic * xDelta;\n\n    dReal xDeltaTetradecic = xDeltaTridecic * xDelta;\n\n    dReal xDeltaPentadecic = xDeltaTetradecic * xDelta;\n\n    dReal xDeltaHexadecic = xDeltaPentadecic * xDelta;\n\n    dReal xDeltaHeptadecic = xDeltaHexadecic * xDelta;\n\n    dReal xDeltaOctadecic = xDeltaHeptadecic * xDelta;\n\n    dReal xDeltaEnneadecic = xDeltaOctadecic * xDelta;\n\n    dReal xDeltaDodecadecic = xDeltaEnneadecic * xDelta;\n\n    dReal xDeltaTridecadecic = xDeltaDodecadecic * xDelta;\n\n    dReal xDeltaTetradecadecic = xDeltaTridecadecic * xDelta;\n\n    dReal", "CodeBleu_score": 35.83445500973241}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\n    // Initialize the x-coordinate of the buoyancy center to zero.\n    dReal xBuoyancyCenter = 0;\n\n    // Set the number of divisions for the integration.\n    int nDivisions = 10;\n\n    // Calculate the step size for the integration.\n    dReal step = (dReal) 0.5 * (sinTheta1 - tanTheta0) / nDivisions;\n\n    // Initialize the angle and the previous angle to the initial angle.\n    dReal theta = tanTheta0;\n    dReal thetaPrev = theta;\n\n    // Initialize the previous value of the x-coordinate of the buoyancy center to zero.\n    dReal xBuoyancyCenterPrev = 0;\n\n    // Loop over the divisions.\n    for (int i = 0; i < nDivisions; i++) {\n\n        // Update the angle.\n        theta += step;\n\n        // Calculate the x-coordinate of the buoyancy center for the current angle.\n        dReal xBuoyancyCenterCurr = (dReal) 0.5 * (theta + thetaPrev) * (dReal) 0.5 * (sinTheta1 - tanTheta0) * (zIOverR * (dReal) 0.5 * (theta + thetaPrev) + (dReal) 0.5 * (thetaPrev * thetaPrev - theta * theta)) / (dReal) 0.5 * (theta + thetaPrev);\n\n        // Update the x-coordinate of the buoyancy center.\n        xBuoyancyCenter += (dReal) 0.5 * (xBuoyancyCenterCurr + xBuoyancyCenterPrev);\n\n        // Update the previous angle and the previous value of the x-coordinate of the buoyancy center.\n        thetaPrev = theta;\n        xBuoyancyCenterPrev = xBuoyancyCenterCurr;\n\n    }\n\n    // Return the x-coordinate of the buoyancy center scaled by the radius and adjusted by the volume.\n    return xBuoyancyCenter * radius * volume;\n\n}", "CodeBleu_score": 39.13406651390028}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\n\n\n    dReal x = 0;\n\n    dReal dTheta = acos(tanTheta0 * sinTheta1);\n\n    dReal sinTheta0 = tanTheta0 * cos(dTheta);\n\n    dReal z0 = zIOverR * sinTheta0;\n\n    dReal z1 = zIOverR * sinTheta1;\n\n    dReal z0Sq = z0 * z0;\n\n    dReal z1Sq = z1 * z1;\n\n    dReal z0Cb = z0 * z0Sq;\n\n    dReal z1Cb = z1 * z1Sq;\n\n    dReal z04th = z0Cb * z0;\n\n    dReal z14th = z1Cb * z1;\n\n    dReal z05th = z04th * z0;\n\n    dReal z15th = z14th * z1;\n\n    dReal z06th = z05th * z0;\n\n    dReal z16th = z15th * z1;\n\n    dReal z07th = z06th * z0;\n\n    dReal z17th = z16th * z1;\n\n    dReal z08th = z07th * z0;\n\n    dReal z18th = z17th * z1;\n\n    dReal z09th = z08th * z0;\n\n    dReal z19th = z18th * z1;\n\n    dReal z010th = z09th * z0;\n\n    dReal z110th = z19th * z1;\n\n    dReal z011th = z010th * z0;\n\n    dReal z111th = z110th * z1;\n\n    dReal z012th = z011th * z0;\n\n    dReal z112th = z111th * z1;\n\n    dReal z013th = z012th * z0;\n\n    dReal z113", "CodeBleu_score": 36.19885648780253}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n  dReal volume;\n\n  dReal radius;\n\n  dReal depth;\n\n  dReal *depths;\n\n  dReal *depths_inv;\n\n  dReal *depths_inv_sq;\n\n  dReal *depths_inv_cb;\n\n  dReal *depths_inv_sq_cb;\n\n  dReal *depths_inv_sq_sq;\n\n  dReal *depths_inv_sq_sq_cb;\n\n  dReal *depths_inv_sq_sq_sq;\n\n  dReal *depths_inv_sq_sq_sq_cb;\n\n  dReal *depths_inv_sq_sq_sq_sq;\n\n  dReal *depths_inv_sq_sq_sq_sq_cb;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_cb;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_sq;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_sq_cb;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_sq_sq;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_sq_sq_cb;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_sq_sq_sq;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_sq_sq_sq_cb;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq_cb;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n\n  dReal *depths_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_cb", "CodeBleu_score": 6.580139615867281}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dReal volume;\n    dReal radius;\n    dReal depth;\n    dReal *normal;\n    dReal *center;\n    dReal *position;\n    dReal *rotation;\n    dReal *scale;\n    dReal *rotation_matrix;\n    dReal *rotation_matrix_transpose;\n    dReal *rotation_matrix_transpose_times_normal;\n    dReal *rotation_matrix_transpose_times_normal_times_radius;\n    dReal *rotation_matrix_transpose_times_normal_times_radius_times_depth;\n    dReal *rotation_matrix_transpose_times_normal_times_radius_times_depth_times_position;\n    dReal *rotation_matrix_transpose_times_normal_times_radius_times_depth_times_position_plus_center;\n    dReal *rotation_matrix_transpose_times_normal_times_radius_times_depth_times_position_plus_center_times_rotation_matrix;\n    dReal *rotation_matrix_transpose_times_normal_times_radius_times_depth_times_position_plus_center_times_rotation_matrix_transpose;\n    dReal *rotation_matrix_transpose_times_normal_times_radius_times_depth_times_position_plus_center_times_rotation_matrix_transpose_times_scale;\n    dReal *rotation_matrix_transpose_times_normal_times_radius_times_depth_times_position_plus_center_times_rotation_matrix_transpose_times_scale_times_scale;\n    dReal *rotation_matrix_transpose_times_normal_times_radius_times_depth_times_position_plus_center_times_rotation_matrix_transpose_times_scale_times_scale_times_scale;\n    dReal *rotation_matrix_transpose_times_normal_times_radius_times_depth_times_position_plus_center_times_rotation_matrix_transpose_times_scale_times_scale_times_scale_times_scale;\n    dReal *rotation_matrix_transpose_times_normal", "CodeBleu_score": 8.474425761261289}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n    dxGeom *g1, *g2;\n    dReal *params;\n    dReal *data;\n    int i;\n    dReal radius, length;\n    dReal volume;\n    dReal mass;\n    dReal buoyancyCenterX;\n    dReal buoyancyCenterY;\n    dReal buoyancyCenterZ;\n    dReal buoyancyCenterXScaled;\n    dReal buoyancyCenterYScaled;\n    dReal buoyancyCenterZScaled;\n    dReal buoyancyCenterXAdjusted;\n    dReal buoyancyCenterYAdjusted;\n    dReal buoyancyCenterZAdjusted;\n    dReal buoyancyCenterXAdjustedScaled;\n    dReal buoyancyCenterYAdjustedScaled;\n    dReal buoyancyCenterZAdjustedScaled;\n    dReal buoyancyCenterXAdjustedScaledAdjusted;\n    dReal buoyancyCenterYAdjustedScaledAdjusted;\n    dReal buoyancyCenterZAdjustedScaledAdjusted;\n    dReal buoyancyCenterXAdjustedScaledAdjustedScaled;\n    dReal buoyancyCenterYAdjustedScaledAdjustedScaled;\n    dReal buoyancyCenterZAdjustedScaledAdjustedScaled;\n    dReal buoyancyCenterXAdjustedScaledAdjustedScaledAdjusted;\n    dReal buoyancyCenterYAdjustedScaledAdjustedScaledAdjusted;\n    dReal buoyancyCenterZAdjustedScaledAdjustedScaledAdjusted;\n    dReal buoyancyCenterXAdjustedScaledAdjustedScaledAdjustedScaled;\n    dReal buoyancyCenterYAdjustedScaledAdjustedScaledAdjustedScaled;\n    dReal buoyancyCenterZAdjustedScaledAdjustedScaledAdjustedScaled;\n    dReal buoyancyCenterXAdjustedScaledAdjustedScaledAdjustedScaledAdjusted;\n    dReal buoyancyCenterYAdjustedScaledAdjustedScaledAdjustedScaled", "CodeBleu_score": 8.227270302481365}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t    auto timeout = getInput<int>(\"msec\");\n    if (!timeout || *timeout <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n\n    setStatus(NodeStatus::RUNNING);\n    timer_.start(std::chrono::milliseconds(*timeout));\n    timer_waiting_ = true;\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 35.40567815213972}, {"code": "NodeStatus SleepNode::onStart(){\n\t    sleep_duration_ = getInput<int>(\"ms\").value();\n    if (sleep_duration_ <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n    setStatus(NodeStatus::RUNNING);\n    timer_.start(std::chrono::milliseconds(sleep_duration_));\n    timer_.setCallback([this]() {\n        timer_waiting_ = false;\n        emitWakeUpSignal();\n    });\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 45.43583218734214}, {"code": "NodeStatus SleepNode::onStart(){\n\t  int sleep_ms = 0;\n  if (!getInput(\"sleep_ms\", sleep_ms)) {\n    return NodeStatus::SUCCESS;\n  }\n  if (sleep_ms <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_.start(std::chrono::milliseconds(sleep_ms));\n  timer_.setCallback([this]() {\n    if (timer_waiting_) {\n      timer_waiting_ = false;\n      emitWakeUpSignal();\n    }\n  });\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 58.391558519871055}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // Get the entry from the blackboard\n    auto entry = BT::Blackboard::get<Entry>(config().entry_name);\n\n    // Lock the entry's mutex\n    std::unique_lock<std::mutex> lock(entry.mutex);\n\n    // Check if the sequence ID has changed\n    if (entry.sequence_id != entry.sequence_id) {\n        // Update the stored sequence ID\n        entry.sequence_id = entry.sequence_id;\n        return NodeStatus::SUCCESS;\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 30.662451423241325}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // Get the entry from the blackboard\n    auto entry = blackboard()->getAny(entry_name_);\n    if (!entry) {\n        throw std::logic_error(\"EntryUpdatedAction: Entry \" + entry_name_ + \" not found in blackboard\");\n    }\n\n    // Lock the entry's mutex\n    std::unique_lock<std::mutex> entry_lock(entry->mutex());\n\n    // Check if the entry has been updated\n    if (entry->seqNum() != last_seq_num_) {\n        // Update the stored sequence number\n        last_seq_num_ = entry->seqNum();\n        return NodeStatus::SUCCESS;\n    }\n\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 37.684711514811276}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  auto entry = BT::Blackboard::get<Entry>(config().entry);\n  if (!entry) {\n    return NodeStatus::FAILURE;\n  }\n  std::lock_guard<std::mutex> lock(entry->mutex);\n  if (entry->seq != last_seq_) {\n    last_seq_ = entry->seq;\n    return NodeStatus::SUCCESS;\n  }\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 40.170337682835275}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t    return static_cast<size_t>(std::max(0, success_threshold_));\n}", "CodeBleu_score": 8.425921708137377}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    size_t threshold = static_cast<size_t>(m_threshold);\n    if (threshold < 0) {\n        threshold = std::max(0, static_cast<int>(m_children_nodes.size()) + threshold);\n    }\n    return threshold;\n}", "CodeBleu_score": 49.90043915113264}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  size_t threshold = static_cast<size_t>(m_threshold);\n  if (threshold < 0) {\n    threshold = std::max(0, static_cast<int>(children_nodes_.size()) + threshold);\n  }\n  return threshold;\n}", "CodeBleu_score": 50.908955991833295}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while( true ) {\n    std::this_thread::sleep_for( std::chrono::milliseconds(10) );\n\n    std::lock_guard<std::mutex> lock(mutex_);\n\n    auto elapsed = std::chrono::steady_clock::now() - last_heartbeat_;\n    bool is_alive = elapsed < std::chrono::seconds(1);\n\n    if( is_alive != is_server_alive_ ) {\n      is_server_alive_ = is_alive;\n      if( is_alive ) {\n        enableAllBreakpoints();\n      } else {\n        disableAllBreakpoints();\n      }\n    }\n  }\n}", "CodeBleu_score": 38.084357070891336}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while(true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::lock_guard<std::mutex> lock(mutex_);\n        auto now = std::chrono::high_resolution_clock::now();\n        auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_heartbeat_).count();\n        if(diff > 1000) {\n            setAllStatus(NodeStatus::IDLE);\n            enableAll(false);\n        }\n        else {\n            setAllStatus(NodeStatus::RUNNING);\n            enableAll(true);\n        }\n    }\n}", "CodeBleu_score": 40.92256024975958}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n        std::chrono::duration<double> elapsed_seconds = now - last_heartbeat_time_;\n        if (elapsed_seconds.count() > 1.0) {\n            if (heartbeat_on_) {\n                heartbeat_on_ = false;\n                enableAllBreakpoints();\n            }\n        } else {\n            if (!heartbeat_on_) {\n                heartbeat_on_ = true;\n                disableAllBreakpoints();\n            }\n        }\n    }\n}", "CodeBleu_score": 39.95365029026161}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> buffer;\n\n  std::stringstream ss(bb_list);\n  std::string item;\n  std::vector<std::string> bb_names;\n  while (std::getline(ss, item, ';')) {\n    bb_names.push_back(item);\n  }\n\n  nlohmann::json j;\n  for (const auto& bb_name : bb_names) {\n    auto subtree = _tree.subTree(bb_name);\n    if (subtree) {\n      std::unique_lock lock(subtree->mutex());\n      auto bb = subtree->blackboard()->toMsgPack();\n      j[bb_name] = nlohmann::json::from_msgpack(bb);\n    }\n  }\n  nlohmann::json j_final;\n  j_final[\"type\"] = \"blackboards\";\n  j_final[\"data\"] = j;\n  auto msgpack = nlohmann::json::to_msgpack(j_final);\n  buffer.resize(msgpack.size());\n  memcpy(buffer.data(), msgpack.data(), msgpack.size());\n  return buffer;\n}", "CodeBleu_score": 45.92054875000191}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> buffer;\n    std::stringstream ss(bb_list);\n    std::string token;\n    nlohmann::json j_dump;\n    while (std::getline(ss, token, ';')) {\n        auto subtree = _root->subTree(token);\n        if (subtree) {\n            std::lock_guard<std::mutex> lk(subtree->_mutex);\n            auto j_bb = subtree->blackboard()->toJson();\n            j_dump[token] = j_bb;\n        }\n    }\n    if (!j_dump.empty()) {\n        nlohmann::json j_header = {{\"op\", groot2_protocol::Opcode::BLACKBOARD}, {\"type\", \"State\"}};\n        auto msgpack_j_dump = nlohmann::json::to_msgpack(j_dump);\n        auto msgpack_j_header = nlohmann::json::to_msgpack(j_header);\n        buffer.resize(msgpack_j_header.size() + msgpack_j_dump.size());\n        std::memcpy(buffer.data(), msgpack_j_header.data(), msgpack_j_header.size());\n        std::memcpy(buffer.data() + msgpack_j_header.size(), msgpack_j_dump.data(), msgpack_j_dump.size());\n    }\n    return buffer;\n}", "CodeBleu_score": 42.01350270322076}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<std::string> blackboards;\n    std::stringstream ss(bb_list);\n    std::string item;\n    while (std::getline(ss, item, ';')) {\n        blackboards.push_back(item);\n    }\n\n    nlohmann::json j_dump;\n\n    for (const auto& blackboard : blackboards) {\n        auto subtree = _root.subTree(blackboard);\n        if (subtree) {\n            std::unique_lock<std::mutex> lk(subtree->mutex());\n            j_dump[blackboard] = subtree->blackboard()->toJson();\n        }\n    }\n\n    return nlohmann::json::to_msgpack(j_dump);\n}", "CodeBleu_score": 45.40570366793284}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t    auto it = _hooks.find(node_uid);\n    if (it == _hooks.end()) {\n        return false;\n    }\n\n    auto& hook = it->second;\n\n    std::unique_lock<std::mutex> lk(hook.mutex);\n\n    if (hook.status == NodeStatus::BREAKPOINT) {\n        hook.desired_status = result;\n        hook.remove_flag = remove;\n        hook.ready = true;\n        hook.cv.notify_all();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 45.923847169095176}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  if (node_uid == 0) {\n    return false;\n  }\n\n  std::unique_lock<std::mutex> lk(mutex_);\n\n  auto it = _blackboards.find(node_uid);\n  if (it == _blackboards.end()) {\n    return false;\n  }\n\n  auto& hook = it->second;\n\n  if (!hook.valid) {\n    return false;\n  }\n\n  hook.mutex.lock();\n  if (hook.status == NodeStatus::BREAKPOINT) {\n    hook.desired_status = result;\n    hook.remove_flag = remove;\n    hook.ready = true;\n    hook.cond_var.notify_all();\n  }\n  hook.mutex.unlock();\n  return true;\n}", "CodeBleu_score": 48.834452191733966}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto it = _hooks.find(node_uid);\n  if (it == _hooks.end()) {\n    return false;\n  }\n  auto &hook = it->second;\n\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if (hook->status == NodeStatus::BREAKPOINT) {\n    hook->desired_status = result;\n    hook->remove_flag = remove;\n    hook->ready = true;\n    hook->cv.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 46.344787480929185}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  setStatus(NodeStatus::RUNNING);\n  halt_requested_.store(false);\n  auto future = std::async(std::launch::async, [this]() {\n    try {\n      tick();\n    }\n    catch (const std::exception& exc) {\n      halt_requested_.store(true);\n      setStatus(NodeStatus::FAILURE);\n      throw exc;\n    }\n  });\n  return checkStatus(future);\n}", "CodeBleu_score": 29.001263078812435}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status() == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    thread_ = std::thread(&BT::ThreadedAction::executeThread, this);\n  }\n\n  // wait for the thread to complete\n  thread_.join();\n\n  if (halt_requested_) {\n    setStatus(NodeStatus::IDLE);\n  }\n\n  // check if an exception was stored\n  if (exception_) {\n    std::rethrow_exception(exception_);\n  }\n\n  return status();\n}", "CodeBleu_score": 31.03731814936217}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  setStatus(NodeStatus::RUNNING);\n  halt_requested_.store(false);\n\n  thread_ = std::thread([this]() {\n    try {\n      setStatus(tick() ? NodeStatus::SUCCESS : NodeStatus::FAILURE);\n    }\n    catch (std::exception& exc) {\n      halt_requested_.store(true);\n      setStatus(NodeStatus::IDLE);\n      throw exc;\n    }\n  });\n\n  // wait for the thread to complete\n  thread_.join();\n\n  // check for exceptions\n  if (exception_ptr_) {\n    std::rethrow_exception(exception_ptr_);\n  }\n\n  return status();\n}", "CodeBleu_score": 32.47588691206328}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto printNode = [](const TreeNode* node, std::ostream& stream, int indent, int depth) {\n        for (int i = 0; i < indent; i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n        for (const auto& child : node->children()) {\n            printNode(child, stream, indent + 1, depth + 1);\n        }\n    };\n\n    stream << \"----------------\" << std::endl;\n    printNode(root_node, stream, 0, 0);\n    stream << \"----------------\" << std::endl;\n}", "CodeBleu_score": 46.46776118888569}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    if (!root_node) {\n        stream << \"Empty tree\" << std::endl;\n        return;\n    }\n\n    const auto depth = root_node->depth();\n\n    std::function<void(const TreeNode*)> recursiveStep;\n    recursiveStep = [&](const TreeNode* node) {\n        for (int i = 1; i < depth + node->depth(); i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n\n        if (node->type() == NodeType::CONTROL) {\n            for (const auto& child : dynamic_cast<const ControlNode*>(node)->children()) {\n                recursiveStep(child);\n            }\n        } else if (node->type() == NodeType::DECORATOR) {\n            recursiveStep(dynamic_cast<const DecoratorNode*>(node)->child());\n        }\n    };\n\n    stream << \"----------------\" << std::endl;\n    recursiveStep(root_node);\n    stream << \"----------------\" << std::endl;\n}", "CodeBleu_score": 58.83003148061399}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    const auto printTreeRecursivelyImpl = [](const TreeNode* node, std::ostream& os, int indent) {\n        for (int i = 0; i < indent; i++) {\n            os << \"  \";\n        }\n        os << node->name() << std::endl;\n\n        if (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control_node->children()) {\n                printTreeRecursivelyImpl(child, os, indent + 1);\n            }\n        }\n        else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n            printTreeRecursivelyImpl(decorator_node->child(), os, indent + 1);\n        }\n    };\n\n    stream << std::endl;\n    stream << \"----------------\" << std::endl;\n    printTreeRecursivelyImpl(root_node, stream, 0);\n    stream << \"----------------\" << std::endl;\n}", "CodeBleu_score": 59.25125201038307}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"Passing a nullptr to applyRecursiveVisitor\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 67.65560102824001}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw std::logic_error(\"applyRecursiveVisitor: node is null\");\n  }\n  visitor(node);\n  if (auto control = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 66.26114787093586}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (!node) {\n        throw std::logic_error(\"applyRecursiveVisitor: node pointer is null\");\n    }\n    visitor(node);\n    if (auto control = dynamic_cast<const ControlNode*>(node)) {\n        for (const auto& child : control->children()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n        applyRecursiveVisitor(decorator->child(), visitor);\n    }\n}", "CodeBleu_score": 66.84326981729001}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    auto it = builders_.find(manifest.registration_ID);\n    if (it != builders_.end()) {\n        throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                    \"] already registered\");\n    }\n\n    builders_.insert({manifest.registration_ID, builder});\n    manifests_.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 69.10778220580758}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (builders_.count(manifest.registration_ID) != 0) {\n        throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                    \"] already registered\");\n    }\n    builders_.insert({manifest.registration_ID, builder});\n    manifests_.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 59.62221367805366}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (builders_.count(manifest.registration_ID) != 0) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                \"] already registered\");\n  }\n  builders_.insert({manifest.registration_ID, builder});\n  manifests_.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 59.686341484187786}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\n    NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n    };\n\n    TreeNodeManifest manifest;\n    manifest.type = NodeType::ACTION;\n    manifest.ports = std::move(ports);\n    manifest.simple_action_ID = ID;\n\n    registerBuilder(manifest, std::move(builder));\n}", "CodeBleu_score": 65.5923698942857}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t    NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n    };\n\n    TreeNodeManifest manifest;\n    manifest.type = NodeType::ACTION;\n    manifest.ports = ports;\n    manifest.ID = ID;\n\n    registerBuilder(manifest, std::move(builder));\n}", "CodeBleu_score": 68.17586345590969}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n  };\n\n  TreeNodeManifest manifest = {NodeType::ACTION, ID, ports};\n  registerBuilder(manifest, std::move(builder));\n}", "CodeBleu_score": 69.02845753014508}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        Blackboard::Ptr backup = Blackboard::create();\n        backup->debugMessage();\n        *backup = *subtree->blackboard();\n        backups.push_back(std::move(backup));\n    }\n    return backups;\n}", "CodeBleu_score": 56.81853548226504}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backup;\n    backup.reserve(tree.subtrees.size());\n\n    for (const auto& subtree : tree.subtrees) {\n        auto bb = Blackboard::create();\n        bb->setBlackboard(subtree.blackboard->toMap());\n        backup.push_back(std::move(bb));\n    }\n\n    return backup;\n}", "CodeBleu_score": 57.958791831413414}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        Blackboard::Ptr backup = Blackboard::create();\n        backup->set(\"__shared_blackboard\", tree.blackboard);\n        *backup = *subtree->blackboard;\n        backups.push_back(std::move(backup));\n    }\n    return backups;\n}", "CodeBleu_score": 54.88418121546289}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  // Parse the script and get an executor\n  auto executor = ParseScript(script);\n\n  if (!executor) {\n    return nonstd::make_unexpected(executor.error());\n  }\n\n  // Execute the script using the environment\n  return executor.value()(env);\n}", "CodeBleu_score": 75.36578563692761}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    // Parse the script using the lexy parser\n    auto result = lexy::parse<grammar::statement_list>(lexy::zstring_input<lexy::utf8_encoding>(script), env);\n\n    // Check if the parsing was successful\n    if (result.has_value()) {\n        // Execute the script using the environment and return the result\n        return result.value().Execute(env);\n    } else {\n        // Forward the error using nonstd::make_unexpected\n        return nonstd::make_unexpected(lexy::to_error_string<lexy::utf8_encoding>(result.error()));\n    }\n}", "CodeBleu_score": 57.31497387850825}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    // Parse the script into an AST\n    auto result = ParseScript(script);\n    if (!result) {\n        return nonstd::make_unexpected(result.error());\n    }\n\n    // Execute the script and return the result\n    return result.value()->execute(env);\n}", "CodeBleu_score": 61.7492744021079}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t  std::unique_lock<std::mutex> lock(mutex_);\n\n  if (isLoaded()) {\n    throw RuntimeError(\"Library already loaded\");\n  }\n\n  handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!handle_) {\n    char* error_str = dlerror();\n    if (error_str) {\n      throw RuntimeError(std::string(\"Could not load library: \") + error_str);\n    }\n    else {\n      throw RuntimeError(\"Could not load library: unknown error\");\n    }\n  }\n  path_ = path;\n}", "CodeBleu_score": 60.89936357960502}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(mutex_);\n\n    if (handle_ != nullptr) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle_) {\n        auto error_str = dlerror();\n        throw RuntimeError(error_str);\n    }\n    path_ = path;\n}", "CodeBleu_score": 57.37589286084047}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(mutex_);\n\n    if (is_loaded_) {\n        throw RuntimeError(\"A library is already loaded. load() can be called only once.\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle_) {\n        char* error_str = dlerror();\n        throw RuntimeError(std::string(\"Could not load library: \") + error_str);\n    }\n    library_path_ = path;\n    is_loaded_ = true;\n}", "CodeBleu_score": 54.52130588448092}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    const std::size_t len = str.size();\n    if (len < 3) {\n        return false;\n    }\n\n    const char* c_str = str.data();\n\n    // strip leading and trailing spaces\n    std::size_t first = 0;\n    while (first < len && std::isspace(c_str[first])) {\n        first++;\n    }\n\n    std::size_t last = len - 1;\n    while (last > first && std::isspace(c_str[last])) {\n        last--;\n    }\n\n    // must at least contain \"{}\"\n    if (last - first < 1) {\n        return false;\n    }\n\n    // check if the extremities contain the brackets\n    if (c_str[first] != '{') {\n        return false;\n    }\n    if (c_str[last] != '}') {\n        return false;\n    }\n\n    first++;\n    last--;\n\n    // if stripped_ptr is not null, then copy to it\n    if (stripped_pointer != nullptr) {\n        stripped_pointer->assign(c_str + first, last - first + 1);\n    }\n    return true;\n}", "CodeBleu_score": 42.78868402067006}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    const auto len = str.size();\n    if (len < 3) {\n        return false;\n    }\n    const char* c_str = str.data();\n\n    // strip\n    char front = c_str[0];\n    char end = c_str[len - 1];\n\n    while (front == ' ' || front == '\\t') {\n        c_str++;\n        front = c_str[0];\n    }\n\n    while (end == ' ' || end == '\\t') {\n        end = c_str[len - 2];\n        len--;\n    }\n\n    if (front != '{' || end != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = StringView(c_str + 1, len - 2);\n    }\n    return true;\n}", "CodeBleu_score": 45.71353145790017}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n  const char* start = str.data();\n  const char* end   = start + str.size();\n\n  start = skipWhitespaces(start, end);\n\n  if (*start != '{') {\n    return false;\n  }\n  start++;\n\n  end--;\n  while ((end > start) && isWhitespace(*end)) {\n    end--;\n  }\n  if (*end != '}') {\n    return false;\n  }\n  end--;\n\n  if (stripped_pointer) {\n    while ((end > start) && isWhitespace(*end)) {\n      end--;\n    }\n    *stripped_pointer = StringView{start, static_cast<uint16_t>(end - start + 1)};\n  }\n  return true;\n}", "CodeBleu_score": 43.1731121386267}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  double point_cost = -1.0;\n\n  for(LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance())\n  {\n    point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n\n    if(point_cost < 0)\n      return -1.0;\n\n    if(line_cost < point_cost)\n      line_cost = point_cost;\n  }\n\n  return line_cost;\n}", "CodeBleu_score": 85.06299308701021}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  //Bresenham Ray-Tracing\n  double line_cost = 0.0;\n  double point_cost = -1.0;\n\n  for(LineIterator line( x0, y0, x1, y1 ); line.isValid(); line.advance())\n  {\n    point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n\n    if(point_cost < 0)\n      return -1;\n\n    if(line_cost < point_cost)\n      line_cost = point_cost;\n  }\n\n  return line_cost;\n}", "CodeBleu_score": 88.19708709870935}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  //Bresenham Ray-Tracing\n  double line_cost = 0.0;\n  double point_cost = -1.0;\n\n  for(LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance())\n  {\n    point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n\n    if(point_cost < 0)\n      return -1;\n\n    if(line_cost < point_cost)\n      line_cost = point_cost;\n  }\n\n  return line_cost;\n}", "CodeBleu_score": 85.14686017910375}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses = path;\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 55.164768362233744}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty())\n    return;\n\n  //create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 89.37841922522855}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    //given an empty path we won't do anything\n    if(path.empty())\n        return;\n\n    //create a path message\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for(unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    pub.publish(gui_path);\n}", "CodeBleu_score": 91.98507267311075}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return stopped(base_odom.twist.twist, rot_stopped_velocity, trans_stopped_velocity);\n}", "CodeBleu_score": 34.29616105485677}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return stopped(base_odom.twist.twist, rot_stopped_velocity, trans_stopped_velocity);\n}", "CodeBleu_score": 34.29616105485677}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}", "CodeBleu_score": 98.44124980190988}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = LocalPlannerLimits(config);\n}", "CodeBleu_score": 94.37547694487087}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  // update the configuration\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 84.69149037454177}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = LocalPlannerLimits(config);\n}", "CodeBleu_score": 94.37547694487087}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_dist = obstacleCosts();\n    return false;\n  }\n  double new_target_dist = current_cell->target_dist + 1;\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n  }\n  return true;\n}", "CodeBleu_score": 69.78362136221052}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost == costmap_2d::LETHAL_OBSTACLE || cell_cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = obstacleCosts();\n    return false;\n  }\n\n  double new_target_dist = current_cell->target_dist + 1;\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n  }\n  return true;\n}", "CodeBleu_score": 74.70870476081859}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_dist = obstacleCosts();\n    return false;\n  }\n  else if (cell_cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = unreachableCellCosts();\n    return false;\n  }\n  else {\n    unsigned int new_target_dist = current_cell->target_dist + 1;\n    if (new_target_dist < check_cell->target_dist) {\n      check_cell->target_dist = new_target_dist;\n    }\n    return true;\n  }\n}", "CodeBleu_score": 74.40011489065931}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, scaling_factor_);\n  double px, py, pth;\n  unsigned int i;\n  if (footprint_spec_.size() == 0) {\n    // nothing to score\n    return -9;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    traj.getPoint(i, px, py, pth);\n    double f_cost = footprintCost(px, py, pth);\n\n    if (f_cost < 0) {\n      // return a max cost if footprint hits an obstacle\n      return -9;\n    }\n\n    if (sum_scores_) {\n      cost += f_cost;\n    } else {\n      cost = std::max(cost, f_cost);\n    }\n  }\n  return scale * cost;\n}", "CodeBleu_score": 68.22830700090556}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scale = potential_scale_;\n  double px, py, pth;\n  unsigned int i;\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    traj.getPoint(i, px, py, pth);\n    double f_cost = footprintCost(px, py, pth);\n\n    if (f_cost < 0) {\n      return -9;\n    }\n\n    if (sum_scores_) {\n      cost += f_cost * scale;\n    } else {\n      cost = cost > f_cost ? cost : f_cost;\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 57.425421666876545}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scale = this->pdist_scale_;\n  if (this->sum_scores_) scale = this->pdist_scale_ * traj.getPointsSize();\n\n  if (this->footprint_spec_.size() == 0) {\n    // footprint not set... maybe we'll just assume all the costs are the same.\n    ROS_ERROR(\"Footprint spec is empty...\");\n    return -9;\n  }\n\n  //we shouldn't really be here, but we'll return negative cost.\n  if (traj.getPointsSize() == 0) {\n    return -7;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    TransformedTrajectoryPoint p = traj.getPoint(i);\n    double px = p.x_, py = p.y_, pth = p.theta_;\n\n    double f_cost = footprintCost(px, py, pth,\n                                  scale,\n                                  this->footprint_spec_,\n                                  this->costmap_,\n                                  this->line_cost_,\n                                  this->map_resolution_);\n\n    if (f_cost < 0) {\n      return f_cost;\n    }\n\n    if (this->sum_scores_) cost += f_cost;\n    else cost = f_cost;\n  }\n  return cost;\n}", "CodeBleu_score": 63.21261088616487}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  double cos_th = cos (th);\n  double sin_th = sin (th);\n  std::vector<geometry_msgs::Point> oriented_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point new_pt;\n    new_pt.x = x + (footprint_spec[i].x * cos_th - footprint_spec[i].y * sin_th) * scale;\n    new_pt.y = y + (footprint_spec[i].x * sin_th + footprint_spec[i].y * cos_th) * scale;\n    oriented_footprint.push_back (new_pt);\n  }\n\n  double footprint_cost = world_model->footprintCost (x, y, th, oriented_footprint);\n  //if there is an obstacle that hits the robot... we know that we can't go there\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n  unsigned int cell_x, cell_y;\n\n  //we won't allow trajectories that go off the map... shouldn't happen that often anyways\n  if ( ! costmap->worldToMap (x, y, cell_x, cell_y)) {\n    return -7.0;\n  }\n\n  unsigned char cost = costmap->getCost (cell_x, cell_y);\n  //if the cell is in an obstacle the trajectory is invalid\n  if (cost == LETHAL_OBSTACLE) {\n    return -7.0;\n  }\n\n  //if the trajectory enters onto or through an obstacle the trajectory is invalid\n  footprint_cost = std::max (footprint_cost, double (cost));\n\n  //the point is not in the line of sight... we won't know any thing about it\n  if (footprint_cost == NO_INFORMATION) {\n    return -8.0;\n  }\n\n  //the footprint covers at least one obscale cell and the footprint is not fully legal\n  return footprint_cost;\n}", "CodeBleu_score": 73.32404134357571}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  double cos_th = cos (th);\n  double sin_th = sin (th);\n  std::vector<geometry_msgs::Point> oriented_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point new_pt;\n    new_pt.x = x + (footprint_spec[i].x * cos_th - footprint_spec[i].y * sin_th) * scale;\n    new_pt.y = y + (footprint_spec[i].x * sin_th + footprint_spec[i].y * cos_th) * scale;\n    oriented_footprint.push_back (new_pt);\n  }\n\n  double footprint_cost = world_model->footprintCost (x, y, th, oriented_footprint);\n  //if there is an obstacle that hits the robot... we know that we can't fit through this space\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n  unsigned int cell_x, cell_y;\n\n  //we won't allow trajectories that go off the map... shouldn't happen that often anyways\n  if ( ! costmap->worldToMap (x, y, cell_x, cell_y)) {\n    return -7.0;\n  }\n\n  double occ_cost = std::max (std::max (0.0, footprint_cost), costmap->getCost (cell_x, cell_y));\n\n  return occ_cost;\n}", "CodeBleu_score": 78.54577705088688}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    double cos_th = cos (th);\n    double sin_th = sin (th);\n    std::vector<geometry_msgs::Point> oriented_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        geometry_msgs::Point new_pt;\n        new_pt.x = x + (footprint_spec[i].x * cos_th - footprint_spec[i].y * sin_th) * scale;\n        new_pt.y = y + (footprint_spec[i].x * sin_th + footprint_spec[i].y * cos_th) * scale;\n        oriented_footprint.push_back (new_pt);\n    }\n\n    double footprint_cost = world_model->footprintCost (x, y, th, oriented_footprint);\n    //if there is no costmap, or it is not lethal at this point\n    if (costmap == NULL || footprint_cost < 0) {\n        return -6.0;\n    }\n\n    unsigned int cell_x, cell_y;\n\n    //we won't allow trajectories that go off the map... shouldn't happen that often, but we can't check here\n    if ( ! costmap->worldToMap (x, y, cell_x, cell_y)) {\n        return -7.0;\n    }\n\n    double occ_cost = std::max (std::max (0.0, footprint_cost), double (costmap->getCost (cell_x, cell_y)));\n\n    return occ_cost;\n}", "CodeBleu_score": 77.67641715887301}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n\n    if (odom_topic_.empty()) {\n      odom_sub_.shutdown();\n    } else {\n      odom_sub_ = gnh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1,\n          boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n    }\n  }\n}", "CodeBleu_score": 50.469299250800724}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    if(odom_topic != odom_topic_) {\n        odom_topic_ = odom_topic;\n\n        if(odom_topic_ == \"\") {\n            if(odom_sub_) {\n                odom_sub_->shutdown();\n                odom_sub_.reset();\n            }\n            return;\n        }\n\n        if(!odom_sub_) {\n            ROS_INFO(\"[OdometryHelperRos] Subscribing to odom topic '%s'\", odom_topic_.c_str());\n            odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n        }\n        else {\n            odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n        }\n    }\n}", "CodeBleu_score": 49.53134734480981}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n\n    if (odom_topic_.empty()) {\n      sub_.shutdown();\n      return;\n    }\n\n    sub_ = gnh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1,\n        boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n  }\n}", "CodeBleu_score": 46.553117527506735}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double x_diff = pos[0] - prev[0];\n  double y_diff = pos[1] - prev[1];\n  double sq_dist = x_diff * x_diff + y_diff * y_diff;\n\n  // we only reset the flags if the robot has moved enough to give the\n  // oscillation a chance to start.\n  if (sq_dist > oscillation_reset_dist_sq_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 67.40688998341142}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n\n  if (sq_dist < oscillation_reset_dist_sq_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 23.208710918140657}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n\n  if (sq_dist < oscillation_reset_dist_sq_) {\n    resetOscillationFlags();\n  }\n\n  if (prev.x() == pos.x() && prev.y() == pos.y()) {\n    return;\n  }\n\n  double angle = atan2(pos.y() - prev.y(), pos.x() - prev.x());\n  double diff = angles::shortest_angular_distance(angle, prev_angle_);\n\n  if (fabs(diff) >= oscillation_reset_angle_) {\n    resetOscillationFlags();\n  }\n\n  prev_angle_ = angle;\n}", "CodeBleu_score": 47.60893992850658}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  int x = (int) floor(pt.x / cell_size_x);\n  int y = (int) floor(pt.y / cell_size_y);\n  int z = (int) floor(pt.z / cell_size_z);\n  if (x < 0 || y < 0 || z < 0 || x >= size_x || y >= size_y || z >= size_z) {\n    return;\n  }\n  int index = x + y * size_x + z * size_x * size_y;\n  if (index >= cells.size()) {\n    return;\n  }\n  if (cells[index].size() >= max_points_per_cell) {\n    return;\n  }\n  if (!cells[index].empty()) {\n    double x_diff = cells[index].back().x - pt.x;\n    double y_diff = cells[index].back().y - pt.y;\n    double z_diff = cells[index].back().z - pt.z;\n    if (x_diff * x_diff + y_diff * y_diff + z_diff * z_diff < min_dist_sq) {\n      return;\n    }\n  }\n  cells[index].push_back(pt);\n}", "CodeBleu_score": 40.708287283502145}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    int x = (int) floor(pt.x / resolution);\n    int y = (int) floor(pt.y / resolution);\n    int z = (int) floor(pt.z / resolution);\n\n    if (x < 0 || y < 0 || z < 0 || x >= width || y >= height || z >= depth) {\n        return;\n    }\n\n    int index = x + y * width + z * width * height;\n\n    if (cells[index].empty()) {\n        cells[index].push_back(pt);\n        return;\n    }\n\n    double min_dist_sq = distanceSq(pt, cells[index].front());\n\n    for (size_t i = 1; i < cells[index].size(); ++i) {\n        double dist_sq = distanceSq(pt, cells[index][i]);\n        if (dist_sq < min_dist_sq) {\n            min_dist_sq = dist_sq;\n        }\n    }\n\n    if (min_dist_sq > sq_resolution) {\n        cells[index].push_back(pt);\n    }\n}", "CodeBleu_score": 40.91590143920332}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  if(!worldToGrid(pt.x, pt.y, ix_, iy_)) {\n    return;\n  }\n\n  if(ix_ < 0 || ix_ >= size_x_ || iy_ < 0 || iy_ >= size_y_) {\n    return;\n  }\n\n  int index = iy_ * size_x_ + ix_;\n  if(index < 0 || index >= size_x_ * size_y_) {\n    ROS_ERROR(\"[PointGrid] Index out of bounds: %d %d\", ix_, iy_);\n    return;\n  }\n\n  // If the cell is empty, insert the point\n  if(cells_[index].empty()) {\n    cells_[index].push_back(pt);\n    return;\n  }\n\n  // Otherwise, check if the point is too close to the nearest neighbor\n  float min_dist_sq = std::numeric_limits<float>::max();\n  for(int i = 0; i < cells_[index].size(); ++i) {\n    float dist_sq = (pt.x - cells_[index][i].x) * (pt.x - cells_[index][i].x) + (pt.y - cells_[index][i].y) * (pt.y - cells_[index][i].y);\n    if(dist_sq < min_dist_sq) {\n      min_dist_sq = dist_sq;\n    }\n  }\n\n  if(min_dist_sq < min_dist_sq_) {\n    return;\n  }\n\n  cells_[index].push_back(pt);\n}", "CodeBleu_score": 40.60698284844936}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel;\n  new_vel.setZero();\n  for (int i = 0; i < 3; ++i) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n    } else {\n      new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 90.74621037142889}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel;\n  for (int i = 0; i < 3; ++i) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n    } else {\n      new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 89.77644573142017}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel;\n  for (int i = 0; i < 3; ++i) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n    } else {\n      new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 89.77644573142017}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // Find the farthest point with a clear line of sight from the robot's current cell\n  int farthest_cell_x = cell_x;\n  int farthest_cell_y = cell_y;\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    int x_diff = global_plan_[i].pose.position.x - x;\n    int y_diff = global_plan_[i].pose.position.y - y;\n    double distance = sqrt(x_diff * x_diff + y_diff * y_diff);\n    if (distance > lookahead_dist_) {\n      break;\n    }\n    if (isClear(farthest_cell_x, farthest_cell_y, x_diff, y_diff)) {\n      farthest_cell_x = global_plan_[i].pose.position.x;\n      farthest_cell_y = global_plan_[i].pose.position.y;\n    }\n  }\n\n  // Convert the goal cell coordinates to world coordinates\n  double goal_x = farthest_cell_x * costmap_->getResolution();\n  double goal_y = farthest_cell_y * costmap_->getResolution();\n\n  // Calculate the shortest angular distance between the current heading and the direction to the goal point\n  double goal_heading = atan2(goal_y - y, goal_x - x);\n  double heading_diff = angles::shortest_angular_distance(heading, goal_heading);\n\n  return fabs(heading_diff);\n}", "CodeBleu_score": 55.30681797595811}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\n    // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n    for (int i = global_plan_.size() - 1; i >= 0; --i) {\n\n        // Get the coordinates of the current point on the path\n        double x_i = global_plan_[i].pose.position.x;\n        double y_i = global_plan_[i].pose.position.y;\n\n        // Calculate the distance between the current point and the robot's current cell\n        double distance = hypot(x_i - x, y_i - y);\n\n        // Check if the distance is less than or equal to the maximum distance for a valid point\n        if (distance <= max_dist_) {\n\n            // Convert the goal cell coordinates to world coordinates\n            double goal_x, goal_y;\n            costmap_.mapToWorld(cell_x, cell_y, goal_x, goal_y);\n\n            // Calculate the direction to the goal point\n            double direction = atan2(goal_y - y, goal_x - x);\n\n            // Return the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n            return fabs(angles::shortest_angular_distance(heading, direction));\n        }\n    }\n\n    // If no valid point is found, return DBL_MAX\n    return DBL_MAX;\n}", "CodeBleu_score": 61.24699212706607}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  if (cell_x < 0 || cell_x >= costmap_->getSizeInCellsX() || cell_y < 0 || cell_y >= costmap_->getSizeInCellsY()) {\n    return DBL_MAX;\n  }\n\n  // calculate the difference in heading between the robot's current position and the goal point\n  double goal_heading = atan2(y - cell_y, x - cell_x);\n  double heading_diff = angles::shortest_angular_distance(heading, goal_heading);\n\n  // check if there is a clear line of sight between the robot's current cell and the goal point\n  int x_step = (x > cell_x) ? 1 : -1;\n  int y_step = (y > cell_y) ? 1 : -1;\n  int x_curr = cell_x;\n  int y_curr = cell_y;\n  while (x_curr != x && y_curr != y) {\n    if (costmap_->getCost(x_curr, y_curr) >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n      return DBL_MAX;\n    }\n    x_curr += x_step;\n    y_curr += y_step;\n  }\n\n  return fabs(heading_diff);\n}", "CodeBleu_score": 39.46812283917661}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n        ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp,\n            vtheta_samp, cost);\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 85.18565875892745}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  if (cost < 0) {\n    ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx, vy, vtheta, cost);\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 78.10407377488504}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n        ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp,\n                vtheta_samp, cost);\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 84.87556999271648}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  ROS_WARN(\"Clearing %s costmap%s to unstuck robot\", (affected_maps_ & GLOBAL) ? \"global\" : \"local\",\n           (affected_maps_ & GLOBAL) && (affected_maps_ & LOCAL) ? \"s\" : \"\");\n\n  if (affected_maps_ & GLOBAL) {\n    if (invert_area_to_clear_) {\n      ROS_WARN(\"Clearing %f, %f, %f, %f from global costmap.\", x_min_, y_min_, x_max_, y_max_);\n      global_costmap_->clearAreaNoChecks(x_min_, y_min_, x_max_, y_max_, true);\n    } else {\n      ROS_WARN(\"Clearing %f, %f, %f, %f from global costmap.\", x_min_, y_min_, x_max_, y_max_);\n      global_costmap_->clearAreaNoChecks(x_min_, y_min_, x_max_, y_max_, true);\n    }\n  }\n\n  if (affected_maps_ & LOCAL) {\n    if (invert_area_to_clear_) {\n      ROS_WARN(\"Clearing %f, %f, %f, %f from local costmap.\", x_min_, y_min_, x_max_, y_max_);\n      local_costmap_->clearAreaNoChecks(x_min_, y_min_, x_max_, y_max_, true);\n    } else {\n      ROS_WARN(\"Clearing %f, %f, %f, %f from local costmap.\", x_min_, y_min_, x_max_, y_max_);\n      local_costmap_->clearAreaNo", "CodeBleu_score": 51.26976519948512}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside the area instead of outside\");\n  } else {\n    ROS_WARN(\"Clearing outside the area instead of inside\");\n  }\n\n  if (affected_maps_ & GLOBAL_COSTMAP) {\n    clear(global_costmap_, invert_area_to_clear_, force_updating_);\n  }\n\n  if (affected_maps_ & LOCAL_COSTMAP) {\n    clear(local_costmap_, invert_area_to_clear_, force_updating_);\n  }\n}", "CodeBleu_score": 35.61732661096757}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t    if (!initialized_) {\n        ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n        return;\n    }\n\n    if (global_costmap_ == NULL || local_costmap_ == NULL) {\n        ROS_ERROR(\"The global_costmap_ and local_costmap_ must be set before runBehavior is called\");\n        return;\n    }\n\n    if (invert_area_to_clear_) {\n        ROS_WARN(\"Clearing inside area instead of outside\");\n    } else {\n        ROS_WARN(\"Clearing outside area instead of inside\");\n    }\n\n    ros::WallTime start_time = ros::WallTime::now();\n\n    if (affected_maps_ & GLOBAL_COSTMAP) {\n        clear(global_costmap_);\n        global_costmap_->update();\n    }\n\n    if (affected_maps_ & LOCAL_COSTMAP) {\n        clear(local_costmap_);\n        local_costmap_->update();\n    }\n\n    ros::WallTime end_time = ros::WallTime::now();\n    ROS_DEBUG(\"[ClearCostmapRecovery]: Time taken for clearing map: %f seconds\", (end_time - start_time).toSec());\n}", "CodeBleu_score": 48.48103414585634}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t    PolygonOutlineCells cell_gatherer(*this, polygon_cells);\n\n    for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n        raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n    }\n\n    if (!polygon.empty()) {\n        unsigned int last_index = polygon.size() - 1;\n        // we also need to close the polygon\n        raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n    }\n}", "CodeBleu_score": 95.1122210677831}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells cell_gatherer(*this);\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n  }\n  if (!polygon.empty()) {\n    unsigned int last_index = polygon.size() - 1;\n    //we also need to close the polygon\n    raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n  }\n  polygon_cells = cell_gatherer.getCells();\n}", "CodeBleu_score": 93.34364503767658}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells cell_gatherer(*this);\n\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n  }\n\n  if (!polygon.empty()) {\n    unsigned int last_index = polygon.size() - 1;\n    // we also need to close the polygon by going from the last point to the first\n    raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n  }\n\n  cell_gatherer.getCells(polygon_cells);\n}", "CodeBleu_score": 93.47545943574347}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(*grid_);\n}", "CodeBleu_score": 67.76459846532012}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock < boost::recursive_mutex > lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = frame_id_;\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    grid_.data[i] = cost_translation_table_[ data[ i ]];\n  }\n}", "CodeBleu_score": 89.62520320660789}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock < boost::recursive_mutex > lock(*costmap_->getMutex());\n  double resolution = costmap_->getResolution();\n\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = frame_id_;\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    if (data[i] == 0)\n      grid_.data[i] = -1;\n    else if (data[i] == costmap_2d::NO_INFORMATION)\n      grid_.data[i] = costmap_2d::NO_INFORMATION;\n    else if (data[i] == costmap_2d::LETHAL_OBSTACLE || data[i] == costmap_2d::INSCRIBED_INFLATED_OBSTACLE)\n      grid_.data[i] = 100;\n    else if (data[i] == costmap_2d::FREE_SPACE)\n      grid_.data[i] = 0;\n    else\n      grid_.data[i] = costmap_2d::NO_INFORMATION;\n  }\n}", "CodeBleu_score": 80.98243198399547}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock < boost::recursive_mutex > lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = layered_costmap_->getGlobalFrameID();\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    if (data[i] == 0)\n      grid_.data[i] = -1;\n    else if (data[i] == costmap_2d::LETHAL_OBSTACLE)\n      grid_.data[i] = 100;\n    else if (data[i] == costmap_2d::INSCRIBED_INFLATED_OBSTACLE)\n      grid_.data[i] = 99;\n    else if (data[i] == costmap_2d::NO_INFORMATION)\n      grid_.data[i] = -1;\n    else\n      grid_.data[i] = data[i] - 1;\n  }\n}", "CodeBleu_score": 83.14120125324646}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t    // check if the footprint has changed\n    if (new_config.footprint == old_config.footprint) {\n        return;\n    }\n\n    // min_x, min_y, max_x, max_y\n    std::vector<geometry_msgs::Point> footprint;\n\n    if (new_config.footprint == \"\") {\n        // use the previous footprint\n    } else {\n        try {\n            geometry_msgs::PolygonStamped polygon;\n            geometry_msgs::Point32 point32;\n            std::vector<std::string> v;\n\n            boost::split(v, new_config.footprint, boost::is_any_of(\" \"), boost::token_compress_on);\n\n            for (unsigned int i = 0; i < v.size(); i++) {\n                // the value is a tuple of float coords\n                std::vector<std::string> coords;\n                boost::split(coords, v[i], boost::is_any_of(\",\"), boost::token_compress_on);\n\n                if (coords.size() == 2) {\n                    float x, y;\n                    if (boost::conversion::try_lexical_convert<std::string, float>(coords[0], x) &&\n                        boost::conversion::try_lexical_convert<std::string, float>(coords[1], y)) {\n                        point32.x = x;\n                        point32.y = y;\n                        point32.z = 0;\n                        polygon.polygon.points.push_back(point32);\n                    } else {\n                        ROS_WARN(\"Footprint parameter does not appear to have correct syntax, \"\n                                 \"discarding: %s\", new_config.footprint.c_str());\n                        break;\n                    }\n                } else {\n                    ROS_WARN(\"Footprint parameter does not appear to have correct syntax, \"\n                             \"discarding: %s\", new_config.footprint.c_str());\n                    break;\n                }\n            }\n\n            geometry_msgs::PointStamped point;\n            geometry_msgs::Point32 p", "CodeBleu_score": 45.930199066321855}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // check if the footprint parameter changed\n  if (old_config.footprint == new_config.footprint) {\n    return;\n  }\n\n  // compute the robot footprint\n  if (new_config.footprint == \"\") {\n    // if we're using the default parameter value and the old\n    // config was specified explicitly, we'll keep the old config\n    if (old_config.footprint != \"\") {\n      ROS_DEBUG(\"Received new footprint parameter with empty string. Keeping the previous footprint.\");\n      return;\n    }\n    // otherwise we'll compute it based on the robot radius\n    std::vector<geometry_msgs::Point> footprint;\n    makeFootprintFromRadius(new_config.footprint_radius, footprint);\n    setRobotFootprint(footprint);\n    return;\n  }\n\n  // read the new footprint string from param server\n  std::vector<geometry_msgs::Point> new_footprint;\n  if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n    setRobotFootprint(new_footprint);\n  } else {\n    ROS_ERROR(\"Failed to set robot footprint from string: \\\"%s\\\"\", new_config.footprint.c_str());\n  }\n}", "CodeBleu_score": 63.3757163259665}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // update the robot footprint\n  if (new_config.footprint != old_config.footprint) {\n    std::vector<geometry_msgs::Point> footprint;\n    if (makeFootprintFromString(new_config.footprint, footprint)) {\n      setFootprint(footprint);\n    } else {\n      ROS_ERROR(\"The footprint parameter does not take a valid value.  Footprint will be set to the robot radius.\");\n      setFootprint(std::vector<geometry_msgs::Point>());\n    }\n  }\n}", "CodeBleu_score": 45.65571232527979}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t    tf2::Stamped<tf2::Transform> tmp_tf;\n    geometry_msgs::PoseStamped tmp_pose;\n    geometry_msgs::PoseStamped new_pose;\n    tf2::toMsg(tf2::Transform::getIdentity(), tmp_pose.pose);\n    tmp_pose.header.frame_id = global_frame_;\n    tmp_pose.header.stamp = ros::Time();\n    try {\n        tf_->transform(tmp_pose, new_pose, global_frame_);\n        pose_ = new_pose;\n    }\n    catch (tf2::LookupException &ex) {\n        ROS_WARN_THROTTLE(1.0, \"Transform from %s to %s failed: %s\", global_frame_.c_str(), base_frame_.c_str(), ex.what());\n        return;\n    }\n    catch (tf2::ExtrapolationException &ex) {\n        ROS_WARN_THROTTLE(1.0, \"Transform from %s to %s failed: %s\", global_frame_.c_str(), base_frame_.c_str(), ex.what());\n        return;\n    }\n    // check if the footprint changed\n    if (footprint_changed) {\n        layered_costmap_->updateFootprint(robot_footprint_);\n        footprint_changed = false;\n    }\n    double x = new_pose.pose.position.x, y = new_pose.pose.position.y,\n           theta = tf2::getYaw(new_pose.pose.orientation);\n    // check if the robot is outside the bounds of the costmap\n    if (x < min_x_ || x > max_x_ || y < min_y_ || y > max_y_) {\n        ROS_WARN_THROTTLE(1.0, \"Robot is out of bounds of the costmap.\");\n        return;\n    }\n    // update the global current pose of the robot\n    layered_costmap_->updateRobotPose(x, y, theta);\n    // if we not running the layered costmap from this thread... we'", "CodeBleu_score": 44.50649538375675}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t    tf2::Stamped<tf2::Transform> new_pose;\n    if (!getRobotPose(new_pose)) {\n        ROS_WARN(\"[Costmap2DROS] Could not get robot pose, cancelling reconfiguration\");\n        return;\n    }\n\n    // Check if the robot has moved since the last update\n    if (fabs((old_pose_.getOrigin().x() - new_pose.getOrigin().x()) < resolution_ * 0.05) &&\n        fabs((old_pose_.getOrigin().y() - new_pose.getOrigin().y()) < resolution_ * 0.05) &&\n        fabs(tf2::getYaw(old_pose_.getRotation()) - tf2::getYaw(new_pose.getRotation())) < 0.05) {\n        return;\n    }\n\n    // Update the stored pose\n    old_pose_ = new_pose;\n\n    // Update the costmap's global frame ID\n    costmap_->updateOrigin(new_pose.getOrigin().x(), new_pose.getOrigin().y());\n\n    // Update the stored pose\n    old_pose_ = new_pose;\n\n    // Update the costmap's global frame ID\n    costmap_->updateOrigin(new_pose.getOrigin().x(), new_pose.getOrigin().y());\n\n    // Update the stored pose\n    old_pose_ = new_pose;\n\n    // Update the costmap's global frame ID\n    costmap_->updateOrigin(new_pose.getOrigin().x(), new_pose.getOrigin().y());\n\n    // Update the stored pose\n    old_pose_ = new_pose;\n\n    // Update the costmap's global frame ID\n    costmap_->updateOrigin(new_pose.getOrigin().x(), new_pose.getOrigin().y());\n\n    // Update the stored pose\n    old_pose_ = new_pose;\n\n    // Update the costmap's global frame ID\n    costmap_->updateOrigin(new_pose.getOrigin().x(), new_pose.getOrigin().y());\n\n    // Update the stored pose\n    old_pose_", "CodeBleu_score": 55.3731829386357}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  // get the current pose of the robot\n  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"[Costmap2DROS] Could not get robot pose, cancelling reconfiguration\");\n    return;\n  }\n\n  // check if the robot has moved since the last update\n  if (fabs((old_pose_.pose.position.x - new_pose.pose.position.x) < min_x_velocity_ * sim_granularity_) &&\n      fabs((old_pose_.pose.position.y - new_pose.pose.position.y) < min_y_velocity_ * sim_granularity_) &&\n      fabs((old_pose_.pose.position.z - new_pose.pose.position.z) < min_z_velocity_ * sim_granularity_) &&\n      fabs((tf2::getYaw(old_pose_.pose.orientation) - tf2::getYaw(new_pose.pose.orientation)) < min_yaw_velocity_ * sim_granularity_)) {\n    return;\n  }\n\n  // update the stored pose\n  old_pose_ = new_pose;\n\n  // reset the costmap layers\n  for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n    (*plugin)->reset();\n  }\n}", "CodeBleu_score": 61.62105148442147}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\n    // lock and unlock mtx\n    std::unique_lock<Costmap2D::mutex_t> lock(*(layered_costmap_->getMutex()));\n\n    // get the list of plugins\n    std::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n\n    // check if costmap is stopped\n    if (stopped_) {\n\n        // loop through plugins\n        for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin != plugins->end(); ++plugin) {\n\n            // activate plugin\n            (*plugin)->activate();\n\n        }\n\n        // set stopped flag to false\n        stopped_ = false;\n\n    }\n\n    // set stop_updates_ flag to false\n    stop_updates_ = false;\n\n    // wait until ROS is running\n    ros::Rate r(100);\n\n    while (ros::ok() && !costmap_initialized_) {\n\n        r.sleep();\n\n    }\n\n    // wait until map update thread is active\n    while (ros::ok() && !map_update_thread_active_) {\n\n        r.sleep();\n\n    }\n\n}", "CodeBleu_score": 71.82331820805297}, {"code": "void Costmap2DROS::start(){\n\t\n  if (stopped_) {\n\n    // reactivate all the plugins\n\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n\n      (*plugin)->activate();\n\n    }\n\n    stopped_ = false;\n\n  }\n\n  stop_updates_ = false;\n\n  // block until the costmap is reinitialized.. meaning one update cycle has run\n\n  ros::Rate r(100);\n\n  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n  while (ros::ok() && !initialized_)\n\n    r.sleep();\n\n  while (ros::ok() && !map_update_thread_active_)\n\n    r.sleep();\n\n}", "CodeBleu_score": 68.13589329158782}, {"code": "void Costmap2DROS::start(){\n\t\n  std::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n\n  for (std::vector<boost::shared_ptr<Layer> >::iterator pluginp = plugins->begin(); pluginp != plugins->end(); ++pluginp) {\n\n    boost::shared_ptr<Layer> plugin = *pluginp;\n\n    plugin->activate();\n\n  }\n\n  stopped_ = false;\n\n  stop_updates_ = false;\n\n  initialized_ = true;\n\n  ros::NodeHandle nh;\n\n  while (!ros::ok() && !stopped_) {\n\n    ros::spinOnce();\n\n  }\n\n  map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, map_update_frequency_));\n\n}", "CodeBleu_score": 57.72233885327296}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t    if (observation_keep_time_ == 0) {\n        while (observation_list_.size() > 1) {\n            observation_list_.pop_front();\n        }\n    } else {\n        ros::Time earliest_allowed = ros::Time::now() - observation_keep_time_;\n        std::list<Observation>::iterator iter = observation_list_.begin();\n        while ((iter != observation_list_.end()) && (iter->cloud_->header.stamp <= earliest_allowed)) {\n            iter = observation_list_.erase(iter);\n        }\n    }\n}", "CodeBleu_score": 42.437935412349006}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == 0.0) {\n    // If keep time is zero, only keep the most recent observation\n    if (observations_.size() > 1) {\n      observations_.erase(observations_.begin(), observations_.end() - 1);\n    }\n    return;\n  }\n\n  // Iterate through the observations and remove those that are too old\n  auto iter = observations_.begin();\n  while (iter != observations_.end()) {\n    if (iter->header.stamp + ros::Duration(observation_keep_time_) < ros::Time::now()) {\n      iter = observations_.erase(iter);\n    } else {\n      ++iter;\n    }\n  }\n}", "CodeBleu_score": 40.40185514871288}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ <= 0) {\n    // If the keep time is zero, keep only the most recent observation\n    if (observations_.size() > 1) {\n      observations_.erase(observations_.begin(), observations_.end() - 1);\n    }\n  } else {\n    // Iterate through the list and remove observations that are older than the specified keep time\n    for (std::list<Observation>::iterator it = observations_.begin(); it != observations_.end();) {\n      if (it->header.stamp + ros::Duration(observation_keep_time_) < ros::Time::now()) {\n        it = observations_.erase(it);\n      } else {\n        // Stop once we find a valid observation\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 42.829945520933045}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    // Check if the start and end indices are valid\n    if (start_index < 0 || end_index < 0 || start_index >= path.size() || end_index >= path.size()) {\n        ROS_ERROR(\"Invalid start or end index for interpolation\");\n        return;\n    }\n\n    // Get the start and end yaw angles\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Calculate the shortest angular distance between the start and end yaw angles\n    double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Calculate the incremental change in angle for each pose\n    double incremental_yaw = delta_yaw / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index; i <= end_index; i++) {\n        double yaw = start_yaw + (i - start_index) * incremental_yaw;\n        tf2::Quaternion quat;\n        quat.setRPY(0, 0, yaw);\n        path[i].pose.orientation = tf2::toMsg(quat);\n    }\n}", "CodeBleu_score": 60.72125282160135}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    if (start_index < 0 || start_index >= path.size() || end_index < 0 || end_index >= path.size() || start_index > end_index) {\n        // Invalid input, return without modifying the path\n        return;\n    }\n\n    // Calculate the yaw angle at the start and end indices\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Determine the shortest angular distance between the start and end yaw angles\n    double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Calculate the incremental change in angle for each pose in the specified range\n    double increment = delta_yaw / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index; i <= end_index; i++) {\n        double yaw = start_yaw + (i - start_index) * increment;\n        tf2::Quaternion quat;\n        quat.setRPY(0, 0, yaw);\n        path[i].pose.orientation = tf2::toMsg(quat);\n    }\n}", "CodeBleu_score": 63.88176529456145}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    double start_yaw, end_yaw;\n    int increment = 1;\n\n    if (start_index > end_index) {\n        increment = -1;\n    }\n\n    bool get_start_yaw = getYaw(path[start_index], start_yaw);\n    bool get_end_yaw = getYaw(path[end_index], end_yaw);\n\n    if (!get_start_yaw || !get_end_yaw) {\n        ROS_ERROR(\"Unable to determine start or end yaw of path, cannot interpolate\");\n        return;\n    }\n\n    double diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    double incremental_yaw = diff / (end_index - start_index);\n\n    for (int i = start_index; i != end_index; i += increment) {\n        double angle = start_yaw + incremental_yaw * (i - start_index);\n        angle = angles::normalize_angle(angle);\n        path[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0.0, 0.0, 1.0), angle));\n    }\n}", "CodeBleu_score": 57.17184345741282}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  std::vector<geometry_msgs::PoseStamped> path;\n\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  bool success = makePlan(req.start, req.goal, path);\n  resp.plan_found = success;\n\n  if (success) {\n    resp.path = path;\n  }\n\n  return true;\n}", "CodeBleu_score": 91.8845741286968}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  std::vector<geometry_msgs::PoseStamped> path;\n\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  bool success = makePlan(req.start, req.goal, path);\n  resp.plan_found = success;\n\n  if (success) {\n    resp.path = path;\n  }\n\n  return true;\n}", "CodeBleu_score": 91.8845741286968}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  std::vector<geometry_msgs::PoseStamped> path;\n\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  bool success = makePlan(req.start, req.goal, path);\n  resp.plan_found = success;\n  if (success) {\n    resp.path = path;\n  }\n\n  return true;\n}", "CodeBleu_score": 91.8845741286968}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~\");\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n    plan_pub_ = private_nh.advertise<nav_msgs::Path>(\"plan\", 1);\n    tf_ = new tf2_ros::Buffer(ros::Duration(10));\n    tf_listener_ = new tf2_ros::TransformListener(*tf_);\n}", "CodeBleu_score": 64.7571527255397}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~\");\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n    costmap_ros_ = cmap;\n    initialized_ = false;\n}", "CodeBleu_score": 74.22648519586403}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~\");\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n    plan_pub_ = private_nh.advertise<nav_msgs::Path>(\"plan\", 1);\n    costmap_ros_ = cmap;\n    initialized_ = false;\n}", "CodeBleu_score": 70.90960960742422}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if(wx < origin_x_ || wy < origin_y_)\n        return false;\n\n    mx = (wx - origin_x_) / resolution_;\n    my = (wy - origin_y_) / resolution_;\n\n    if(mx < size_x_ && my < size_y_)\n        return true;\n\n    return false;\n}", "CodeBleu_score": 40.96060094716112}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (wx < origin_x_ || wy < origin_y_)\n        return false;\n\n    mx = (wx - origin_x_) / resolution_;\n    my = (wy - origin_y_) / resolution_;\n\n    if (mx < size_x_ && my < size_y_)\n        return true;\n\n    return false;\n}", "CodeBleu_score": 42.381549214563776}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if(wx < origin_x_ || wy < origin_y_)\n        return false;\n\n    mx = (wx - origin_x_) / resolution_;\n    my = (wy - origin_y_) / resolution_;\n\n    if(mx < size_x_ && my < size_y_)\n        return true;\n\n    return false;\n}", "CodeBleu_score": 40.96060094716112}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\n            \"This planner has not been initialized yet, \"\n            \"but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the \n    // same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.0715500275678}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if(!initialized_){\n        ROS_ERROR(\n            \"This planner has not been initialized yet, \"\n            \"but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the \n    // same frame\n    for(unsigned int i=0; i < path.size(); i++){\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 86.65188958605219}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_) {\n    ROS_ERROR(\n        \"This planner has not been initialized yet, \"\n        \"but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  if (!path.empty()) {\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n  }\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the\n  // same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 92.29713081441263}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message and re-sending to the server.\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 97.91245108335265}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message and re-sending to the server.\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 97.91245108335265}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message and re-sending to the server.\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 97.91245108335265}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  // Get the current distance\n  double current_distance = sqrt(pow(current_pose_.position.x - start_pose_.position.x, 2) + pow(current_pose_.position.y - start_pose_.position.y, 2));\n\n  // Check if the robot has moved far enough\n  if (current_distance >= limited_distance_) {\n    ROS_INFO(\"MoveSlowAndClear: Robot has moved far enough. Removing speed limit.\");\n\n    // Join and delete any existing remove limit thread\n    if (remove_limit_thread_.joinable()) {\n      remove_limit_thread_.join();\n    }\n\n    // Start a new thread to remove the speed limit\n    remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n    // Stop the distance check timer\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 48.92932895370665}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    if (limitedDistance * limitedDistance <= distanceMoved * distanceMoved) {\n        ROS_INFO(\"Distance check passed. Removing speed limit.\");\n        if (removeLimitThread) {\n            removeLimitThread->join();\n            delete removeLimitThread;\n            removeLimitThread = nullptr;\n        }\n        removeLimitThread = new std::thread([this] {\n            std::this_thread::sleep_for(std::chrono::seconds(removeLimitDelay));\n            ROS_INFO(\"Removing speed limit.\");\n            obstacleLayer->setSpeedLimit(0.0);\n        });\n        distanceCheckTimer.stop();\n    }\n}", "CodeBleu_score": 43.897457176477296}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    if (distance_squared_ < limited_distance_squared_) {\n        ROS_INFO_STREAM(\"Moved \" << distance_squared_ << \"m, \" << limited_distance_squared_ - distance_squared_ << \"m to go\");\n        return;\n    }\n    ROS_INFO_STREAM(\"Moved \" << distance_squared_ << \"m, reached limit\");\n\n    if (remove_limit_thread_.joinable()) {\n        remove_limit_thread_.join();\n    }\n    remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n    distance_check_timer_.stop();\n}", "CodeBleu_score": 46.19826418874984}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    ROS_INFO(\"New goal received\");\n\n    geometry_msgs::PoseStamped start;\n    start.header.frame_id = \"map\";\n    start.header.stamp = ros::Time::now();\n    start.pose.position.x = global_pose_.pose.position.x;\n    start.pose.position.y = global_pose_.pose.position.y;\n    start.pose.position.z = global_pose_.pose.position.z;\n    start.pose.orientation.x = global_pose_.pose.orientation.x;\n    start.pose.orientation.y = global_pose_.pose.orientation.y;\n    start.pose.orientation.z = global_pose_.pose.orientation.z;\n    start.pose.orientation.w = global_pose_.pose.orientation.w;\n\n    std::vector<geometry_msgs::PoseStamped> path;\n\n    makePlan(start, *goal, path);\n\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = \"map\";\n    gui_path.header.stamp = ros::Time::now();\n    gui_path.poses = path;\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 48.013183989890145}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Get the current robot pose\n    geometry_msgs::PoseStamped start;\n    start.header.frame_id = \"map\";\n    start.header.stamp = ros::Time::now();\n    start.pose.position.x = global_pose_.getOrigin().x();\n    start.pose.position.y = global_pose_.getOrigin().y();\n    tf2::Quaternion q(global_pose_.getRotation().x(), global_pose_.getRotation().y(), global_pose_.getRotation().z(), global_pose_.getRotation().w());\n    tf2::Matrix3x3 m(q);\n    double roll, pitch, yaw;\n    m.getRPY(roll, pitch, yaw);\n    start.pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), yaw));\n\n    // Set the goal pose\n    geometry_msgs::PoseStamped goal_pose;\n    goal_pose.header.frame_id = \"map\";\n    goal_pose.header.stamp = ros::Time::now();\n    goal_pose.pose.position.x = goal->pose.position.x;\n    goal_pose.pose.position.y = goal->pose.position.y;\n    goal_pose.pose.orientation = goal->pose.orientation;\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<geometry_msgs::PoseStamped> plan;\n    makePlan(start, goal_pose, plan);\n\n    // Publish the path\n    nav_msgs::Path path;\n    path.header.frame_id = \"map\";\n    path.header.stamp = ros::Time::now();\n    path.poses = plan;\n    plan_pub_.publish(path);\n}", "CodeBleu_score": 43.15579258218506}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Get the current pose of the robot\n    geometry_msgs::PoseStamped start;\n    getRobotPose(start);\n\n    // Set the frame_id of the start pose to be the same as the goal pose\n    start.header.frame_id = goal->header.frame_id;\n\n    // Define an empty path vector\n    std::vector<geometry_msgs::PoseStamped> path;\n\n    // Call the makePlan function to generate a path from the current pose to the goal pose\n    bool success = makePlan(start, *goal, path);\n\n    // Publish the path\n    if (success) {\n        nav_msgs::Path gui_path;\n        gui_path.header.frame_id = frame_id_;\n        gui_path.header.stamp = ros::Time::now();\n        gui_path.poses = path;\n        plan_pub_.publish(gui_path);\n    }\n}", "CodeBleu_score": 49.85156073698304}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    mavsdk::Param::ParamSet param_set_req;\n    param_set_req.param_id = param_set.param_id;\n    param_set_req.value.set_float_value(param_set.value);\n    param_set_client_->set_param_async(param_set_req);\n}", "CodeBleu_score": 51.18762010645636}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    // Create a ParamSet service request\n    mavros_msgs::ParamSet param_set_srv;\n\n    // Assign the parameter ID and value from the provided GimbalParamSet structure\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.real = param_set.value;\n\n    // Call the param_set_client_ to send the request\n    param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 63.205798935543946}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    dji_osdk_ros::GimbalParamSet param_set_req;\n    param_set_req.request.param_id = param_set.param_id;\n    param_set_req.request.param_value = param_set.param_value;\n    param_set_client_.call(param_set_req);\n}", "CodeBleu_score": 55.2658905768213}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Forcefully attaching socket to the port 8080\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,\n                   &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *) &address,\n             sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Wait for a connection from the ground station\n    if ((new_socket = accept(server_fd, (struct sockaddr *) &address,\n                             (socklen_t *) &addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Loop to accept incoming connections\n    while (true) {\n        // Receive data from the ground station\n        int valread = recv(new_socket, buffer, 1024, 0);\n        if (valread > 0) {\n            // Decode the received message\n            std::string message = decodeMessage(buffer);\n\n            // Publish the decoded message\n            publishMessage(message);\n        } else if (valread == 0", "CodeBleu_score": 53.157893794800785}, {"code": "void CommunicationBridge::serverFun(){\n\t    while (true) {\n        // Accept a connection from the ground station\n        int client_socket = accept(server_socket_, (struct sockaddr*)&client_address_, &client_address_len_);\n        if (client_socket < 0) {\n            // An error occurred\n            continue;\n        }\n\n        // Receive data from the client\n        char buffer[1024];\n        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);\n        if (bytes_received <= 0) {\n            // An error occurred\n            continue;\n        }\n\n        // Process the received data\n        std::string message(buffer, bytes_received);\n        // Decode the message and publish it\n        decodeAndPublish(message);\n\n        // Close the socket\n        close(client_socket);\n    }\n}", "CodeBleu_score": 29.00377197823139}, {"code": "void CommunicationBridge::serverFun(){\n\t    int server_fd, new_socket, valread;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Forcefully attaching socket to the port 8080\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,\n                   &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(port);\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *) &address,\n             sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    if ((new_socket = accept(server_fd, (struct sockaddr *) &address,\n                             (socklen_t *) &addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *) &address,\n                                 (socklen_t *) &addrlen)) < 0) {\n            perror(\"accept\");\n            exit(EXIT_FAILURE);\n        }\n        valread = read(new_socket, buffer, 1024);\n        if (valread > 0) {\n            std::string msg(buffer);\n            msg = msg.sub", "CodeBleu_score": 54.80644894979426}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (!simulation_) {\n    uav_basic_.publish(uav_cmd);\n  } else {\n    boost::shared_lock<boost::shared_mutex> lock(mutex_);\n    if (swarm_control_simulation_.find(uav_cmd.drone_id) == swarm_control_simulation_.end()) {\n      lock.unlock();\n      boost::unique_lock<boost::shared_mutex> lock2(mutex_);\n      swarm_control_simulation_[uav_cmd.drone_id] = std::make_shared<UAVControlSimulation>(uav_cmd.drone_id);\n      lock2.unlock();\n    }\n    swarm_control_simulation_[uav_cmd.drone_id]->publish(uav_cmd);\n  }\n}", "CodeBleu_score": 36.476853456841404}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    boost::shared_lock<boost::shared_mutex> lock(mutex_uav_control_);\n\n    if (simulation_mode_) {\n        // Find the UAV in the swarm\n        for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n            if (swarm_control_simulation_[i].id == uav_cmd.id) {\n                // Publish the command to the UAV\n                swarm_control_simulation_[i].publish(uav_cmd);\n                break;\n            }\n        }\n    } else {\n        uav_basic_.publish(uav_cmd);\n    }\n}", "CodeBleu_score": 42.70182175449404}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\n  if (!simulation_mode_) {\n    uav_basic_.publishCommand(uav_cmd);\n  } else {\n    boost::shared_mutex::scoped_lock lock(simulation_mutex_);\n    swarm_control_simulation_.at(uav_cmd.drone_id)->publishCommand(uav_cmd);\n  }\n}", "CodeBleu_score": 21.669335147276804}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    switch (mode_selection.use_mode) {\n        case ModeSelection::Mode::REBOOTNX:\n            system(\"reboot\");\n            break;\n        case ModeSelection::Mode::EXITNX:\n            system(\"exit\");\n            break;\n        case ModeSelection::Mode::CREATE:\n            createMode(mode_selection.mode_name);\n            break;\n        case ModeSelection::Mode::DELETE:\n            deleteMode(mode_selection.mode_name);\n            break;\n        default:\n            break;\n    }\n}", "CodeBleu_score": 40.77423595040639}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    boost::mutex::scoped_lock lock(bridge_mutex);\n    if (mode_selection.use_mode == \"REBOOTNX\") {\n        system(\"sudo reboot\");\n    } else if (mode_selection.use_mode == \"EXITNX\") {\n        system(\"sudo shutdown -h now\");\n    } else if (mode_selection.use_mode == \"CREATE\") {\n        createMode(mode_selection.mode_name);\n    } else if (mode_selection.use_mode == \"DELETE\") {\n        deleteMode(mode_selection.mode_name);\n    }\n}", "CodeBleu_score": 53.65877608772244}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode == ModeSelection::REBOOTNX) {\n        system(\"reboot\");\n    } else if (mode_selection.use_mode == ModeSelection::EXITNX) {\n        system(\"exit\");\n    }\n\n    if (mode_selection.use_mode == ModeSelection::CREATE) {\n        createMode(mode_selection.mode);\n    } else if (mode_selection.use_mode == ModeSelection::DELETE) {\n        deleteMode(mode_selection.mode);\n    }\n}", "CodeBleu_score": 58.002428197326864}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\n    boost::shared_lock<boost::shared_mutex> lock(mutex_heartbeat_state);\n\n    if (heartbeat_state == false) {\n        if (heartbeat_count == heartbeat_attempts) {\n            if (vehicle_type == \"Swarm\") {\n                ROS_ERROR(\"Swarm heartbeat lost\");\n            } else if (vehicle_type == \"UAV\") {\n                ROS_ERROR(\"UAV heartbeat lost\");\n            } else if (vehicle_type == \"UGV\") {\n                ROS_ERROR(\"UGV heartbeat lost\");\n            }\n\n            disconnect_flag = true;\n        }\n    } else {\n        heartbeat_count = 0;\n    }\n\n    heartbeat_state = false;\n}", "CodeBleu_score": 33.24763240065347}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    boost::mutex::scoped_lock lock(mutex_heartbeat_state_);\n\n    if (heartbeat_state_ == true) {\n        heartbeat_count_ = 0;\n    }\n    else {\n        heartbeat_count_++;\n    }\n\n    if (heartbeat_count_ >= heartbeat_attempts_) {\n        if (vehicle_type_ == VehicleType::SWARM) {\n            ROS_ERROR(\"Communication bridge with swarm lost. Check connection!\");\n        }\n        else if (vehicle_type_ == VehicleType::UAV) {\n            ROS_ERROR(\"Communication bridge with UAV lost. Check connection!\");\n        }\n        else if (vehicle_type_ == VehicleType::UGV) {\n            ROS_ERROR(\"Communication bridge with UGV lost. Check connection!\");\n        }\n\n        disconnect_flag_ = true;\n    }\n}", "CodeBleu_score": 37.744346850780154}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    boost::mutex::scoped_lock lock(heartbeat_mutex);\n    if (heartbeat_state.count(vehicle_type) > 0) {\n        int missed_heartbeats = heartbeat_state[vehicle_type];\n        if (missed_heartbeats >= max_missed_heartbeats) {\n            ROS_ERROR_STREAM(\"Lost connection with \" << vehicle_type << \"!\");\n            disconnect_flag = true;\n            if (vehicle_type == \"swarm\") {\n                // Do something for swarm\n            } else if (vehicle_type == \"UAV\") {\n                // Do something for UAV\n            } else if (vehicle_type == \"UGV\") {\n                // Do something for UGV\n            }\n        }\n    }\n}", "CodeBleu_score": 27.08532233693922}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    if(msg->traj_id.size() == 0) {\n        return;\n    }\n\n    // Extract drone ID from the message\n    int drone_id = msg->drone_id;\n\n    // Iterate over the trajectory IDs in the message\n    for(int i = 0; i < msg->traj_id.size(); i++) {\n        // Create a Bspline struct to store the trajectory data\n        Bspline bspline;\n\n        // Set the Bspline attributes\n        bspline.drone_id = drone_id;\n        bspline.traj_id = msg->traj_id[i];\n        bspline.start_time = msg->start_time[i];\n        bspline.order = msg->order[i];\n        bspline.duration = msg->duration[i];\n        bspline.knots = msg->knots[i];\n        bspline.control_points = msg->control_points[i];\n        bspline.yaw = msg->yaw[i];\n\n        // Populate the knots, position points, and yaw points\n        bspline.knots.push_back(msg->knots[i].front());\n        bspline.control_points.push_back(msg->control_points[i].front());\n        bspline.yaw.push_back(msg->yaw[i].front());\n\n        // Encode the MultiBsplines data\n        std::vector<uint8_t> data = encode_multitraj(drone_id, bspline);\n\n        // Send the encoded data via TCP using the communication module\n        comm.send_data(data);\n    }\n}", "CodeBleu_score": 44.835497849760955}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract the drone ID from the message\n    int drone_id = msg->drone_id;\n\n    // Iterate over the trajectories in the message\n    for (int i = 0; i < msg->trajectory.size(); i++) {\n        // Create a Bspline struct to store the trajectory data\n        Bspline bspline;\n\n        // Set the Bspline attributes\n        bspline.control_points = msg->trajectory[i].control_points;\n        bspline.knots = msg->trajectory[i].knots;\n        bspline.position_pts = msg->trajectory[i].position_pts;\n        bspline.yaw_pts = msg->trajectory[i].yaw_pts;\n\n        // Populate the Bspline knots, position points, and yaw points\n        bspline.knots.push_back(msg->trajectory[i].time_duration);\n        bspline.position_pts.push_back(msg->trajectory[i].goal_point);\n        bspline.yaw_pts.push_back(msg->trajectory[i].yaw);\n\n        // Encode the MultiBsplines data\n        std::vector<uint8_t> encoded_data;\n        encodeMultiBsplines(encoded_data, drone_id, bspline);\n\n        // Send the encoded data via TCP using the communication module\n        communication.sendTcpData(encoded_data);\n    }\n}", "CodeBleu_score": 41.20280270691421}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    int drone_id = msg->drone_id;\n    std::vector<Bspline> traj_vec;\n    for (int i = 0; i < msg->traj_num; i++) {\n        Bspline bspline;\n        bspline.order = msg->order[i];\n        bspline.control_points = msg->control_points[i];\n        bspline.knots = msg->knots[i];\n        bspline.color = msg->color[i];\n        bspline.start_time = msg->start_time[i];\n        bspline.traj_id = msg->traj_id[i];\n        bspline.duration = msg->duration[i];\n        bspline.init_pos = msg->init_pos[i];\n        bspline.init_vel = msg->init_vel[i];\n        bspline.init_acc = msg->init_acc[i];\n        bspline.init_yaw = msg->init_yaw[i];\n        bspline.init_yaw_rate = msg->init_yaw_rate[i];\n        bspline.init_yaw_acc = msg->init_yaw_acc[i];\n        bspline.final_pos = msg->final_pos[i];\n        bspline.final_vel = msg->final_vel[i];\n        bspline.final_acc = msg->final_acc[i];\n        bspline.final_yaw = msg->final_yaw[i];\n        bspline.final_yaw_rate = msg->final_yaw_rate[i];\n        bspline.final_yaw_acc = msg->final_yaw_acc[i];\n        traj_vec.push_back(bspline);\n    }\n    // Encode the MultiBsplines data\n    prometheus_msgs::MultiBsplines msg_out;\n    msg_out.drone_id = drone_id;\n    msg_out.traj_", "CodeBleu_score": 46.454063076173696}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.01);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZ>);\n    octree.getPointIndicesFromNewVoxels(cloud_compressed->points, cloud_compressed->width, cloud_compressed->height);\n    sensor_msgs::PointCloud2 msg_compressed;\n    pcl::toROSMsg(*cloud_compressed, msg_compressed);\n    return msg_compressed;\n}", "CodeBleu_score": 35.07481365639389}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud using an octree\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(1.0f);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n    std::vector<uint32_t> compressed_data;\n    octree.encodePointCloud(cloud, compressed_data);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.size();\n    compressed_msg.fields.resize(1);\n    compressed_msg.fields[0].name = \"compressed_data\";\n    compressed_msg.fields[0].offset = 0;\n    compressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT32;\n    compressed_msg.fields[0].count = 1;\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = sizeof(uint32_t);\n    compressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n    compressed_msg.is_dense = true;\n    compressed_msg.data.resize(compressed_msg.row_step * compressed_msg.height);\n    std::memcpy(&compressed_msg.data[0], &compressed_data[0], compressed_msg.row_step * compressed_msg.height);\n\n    // Release dynamically allocated memory\n    cloud.reset();\n\n    return compressed_msg;\n}", "CodeBleu_score": 49.63086625565829}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Create an octree compression object\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(128.0f);\n\n    // Compress the point cloud\n    std::stringstream compressedData;\n    octree.encodePointCloud(cloud, compressedData);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressedMsg;\n    compressedMsg.header = msg.header;\n    compressedMsg.height = 1;\n    compressedMsg.width = compressedData.str().size();\n    compressedMsg.is_bigendian = false;\n    compressedMsg.point_step = 0;\n    compressedMsg.row_step = compressedData.str().size();\n    compressedMsg.is_dense = true;\n    compressedMsg.data = std::vector<uint8_t>(compressedData.str().begin(), compressedData.str().end());\n\n    // Release dynamically allocated memory\n    cloud.reset();\n\n    return compressedMsg;\n}", "CodeBleu_score": 43.31416918927151}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto& uav : multi_uav_state_) {\n        if (uav.uav_id == uav_state.uav_id) {\n            uav = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 40.21071628244498}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto& state : multi_uav_state_) {\n        if (state.uav_id == uav_state.uav_id) {\n            state = uav_state;\n            return;\n        }\n    }\n}", "CodeBleu_score": 34.49306250921422}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto it = multi_uav_state_.begin(); it != multi_uav_state_.end(); ++it) {\n        if (it->uav_id == uav_state.uav_id) {\n            *it = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 51.19884106390078}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    swarm_control::MultiUGVState multi_ugv_state;\n    int ugv_count = 0;\n    for (auto &ugv : m_multi_ugv_state.ugv_state) {\n        swarm_control::UGVState ugv_state;\n        ugv_state.id = ugv.id;\n        ugv_state.battery = ugv.battery;\n        ugv_state.position.x = ugv.position.x;\n        ugv_state.position.y = ugv.position.y;\n        ugv_state.position.z = ugv.position.z;\n        ugv_state.velocity.x = ugv.velocity.x;\n        ugv_state.velocity.y = ugv.velocity.y;\n        ugv_state.velocity.z = ugv.velocity.z;\n        ugv_state.attitude.x = ugv.attitude.x;\n        ugv_state.attitude.y = ugv.attitude.y;\n        ugv_state.attitude.z = ugv.attitude.z;\n        ugv_state.attitude.w = ugv.attitude.w;\n        multi_ugv_state.ugv_state.push_back(ugv_state);\n        ugv_count++;\n    }\n    multi_ugv_state.ugv_count = ugv_count;\n    multi_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 45.23089374149449}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  swarm_control::MultiUGVState multi_ugv_state;\n  int ugv_count = 0;\n  for (auto &ugv : m_multi_ugv_state.ugv_states) {\n    swarm_control::UGVState ugv_state;\n    ugv_state.id = ugv.id;\n    ugv_state.battery = ugv.battery;\n    ugv_state.position.x = ugv.position.x;\n    ugv_state.position.y = ugv.position.y;\n    ugv_state.position.z = ugv.position.z;\n    ugv_state.velocity.x = ugv.velocity.x;\n    ugv_state.velocity.y = ugv.velocity.y;\n    ugv_state.velocity.z = ugv.velocity.z;\n    ugv_state.attitude.x = ugv.attitude.x;\n    ugv_state.attitude.y = ugv.attitude.y;\n    ugv_state.attitude.z = ugv.attitude.z;\n    ugv_state.attitude.w = ugv.attitude.w;\n    multi_ugv_state.ugv_states.push_back(ugv_state);\n    ugv_count++;\n  }\n  multi_ugv_state.ugv_count = ugv_count;\n  multi_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 43.17857087555475}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    swarm_control::MultiUGVState m_ugv_states;\n    swarm_control::UGVState m_ugv_state;\n    int count = 0;\n    for (auto &ugv_state : m_multi_ugv_state.ugv_states) {\n        m_ugv_state.ugv_id = ugv_state.ugv_id;\n        m_ugv_state.battery = ugv_state.battery;\n        m_ugv_state.position.x = ugv_state.position.x;\n        m_ugv_state.position.y = ugv_state.position.y;\n        m_ugv_state.position.z = ugv_state.position.z;\n        m_ugv_state.velocity.x = ugv_state.velocity.x;\n        m_ugv_state.velocity.y = ugv_state.velocity.y;\n        m_ugv_state.velocity.z = ugv_state.velocity.z;\n        m_ugv_state.attitude.x = ugv_state.attitude.x;\n        m_ugv_state.attitude.y = ugv_state.attitude.y;\n        m_ugv_state.attitude.z = ugv_state.attitude.z;\n        m_ugv_state.attitude.w = ugv_state.attitude.w;\n        m_ugv_states.ugv_states.push_back(m_ugv_state);\n        count++;\n    }\n    m_ugv_states.ugv_count = count;\n    all_ugv_state_pub.publish(m_ugv_states);\n}", "CodeBleu_score": 44.29294093759446}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Iterate through control points\n  for (int i = 0; i < q.cols(); i++) {\n    // Compute predicted positions of moving objects\n    Eigen::MatrixXd predicted_positions = q.col(i) + moving_obstacles_states_.col(i);\n\n    // Evaluate distance between control points and moving objects\n    for (int j = 0; j < predicted_positions.cols(); j++) {\n      // Compute distance error\n      double distance_error = (predicted_positions.col(j) - moving_obstacles_states_.col(i)).norm();\n\n      // If distance is less than clearance, update cost and gradient\n      if (distance_error < moving_obstacles_clearance_) {\n        cost += moving_obstacles_penalty_ * distance_error;\n        gradient.col(i) += moving_obstacles_penalty_ * (predicted_positions.col(j) - moving_obstacles_states_.col(i)).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 33.13956482864128}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    /*\n     * q: Control points of the B-spline trajectory\n     * cost: The cost of the trajectory\n     * gradient: The gradient of the cost with respect to the control points\n     */\n    // Initialize variables\n    int num_control_points = q.cols();\n    int num_moving_objects = moving_objs_.size();\n    double cost_sum = 0.0;\n    Eigen::MatrixXd gradient_sum = Eigen::MatrixXd::Zero(3, num_control_points);\n\n    // Iterate through control points\n    for (int i = 0; i < num_control_points; ++i) {\n        // Get current control point\n        Eigen::Vector3d q_i = q.col(i);\n\n        // Iterate through moving objects\n        for (int j = 0; j < num_moving_objects; ++j) {\n            // Get predicted position of moving object at current control point\n            Eigen::Vector3d predicted_pos = moving_objs_[j].predictPos(i);\n\n            // Compute distance between control point and predicted position\n            double distance = (q_i - predicted_pos).norm();\n\n            // If distance is less than clearance, update cost and gradient\n            if (distance < moving_objs_[j].getClearance()) {\n                double distance_error = moving_objs_[j].getClearance() - distance;\n                cost_sum += distance_error * distance_error;\n                Eigen::Vector3d gradient_i = -2.0 * distance_error * (q_i - predicted_pos).normalized();\n                gradient_sum.col(i) += gradient_i;\n            }\n        }\n    }\n\n    // Set output variables\n    cost = cost_sum;\n    gradient = gradient_sum;\n}", "CodeBleu_score": 42.44212343328538}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    /*\n     * q: nx3 matrix, each row is a control point\n     * cost: double, the cost of the trajectory\n     * gradient: nx3 matrix, each row is the gradient of the cost w.r.t. the corresponding control point\n     */\n\n    // clear data\n    cost = 0.0;\n    gradient.setZero();\n\n    // iterate through obstacles\n    for (int i = 0; i < q.rows(); i++) {\n        // get the position of the current control point\n        Eigen::Vector3d p = q.row(i);\n\n        // iterate through moving obstacles\n        for (int j = 0; j < moving_obstacles_.size(); j++) {\n            // get the position of the current moving obstacle\n            Eigen::Vector3d p_obs = moving_obstacles_[j].getPosition(t_[i]);\n\n            // calculate the distance between the control point and the moving obstacle\n            double dist = (p - p_obs).norm();\n\n            // if the distance is less than the clearance, update the cost and gradient\n            if (dist < moving_obstacles_[j].getClearance()) {\n                // update the cost\n                cost += moving_obstacles_[j].getWeight() * (moving_obstacles_[j].getClearance() - dist) * (moving_obstacles_[j].getClearance() - dist);\n\n                // update the gradient\n                gradient.row(i) += moving_obstacles_[j].getWeight() * 2.0 * (moving_obstacles_[j].getClearance() - dist) * (p - p_obs).transpose();\n            }\n        }\n    }\n}", "CodeBleu_score": 36.73657686413902}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Initialize cost to zero\n  cost = 0.0;\n\n  // Iterate through the control points of the trajectory\n  for (int i = 0; i < q.cols(); ++i) {\n    // Compute the positional error relative to reference points\n    Eigen::Vector3d p = q.col(i) - ref_pts_[i];\n\n    // Compute the velocity vector\n    Eigen::Vector3d v = q.col(i + 1) - q.col(i);\n\n    // Compute the cost function\n    double a2 = p.dot(p);\n    double b2 = v.dot(v);\n    cost += a2 * a2 + b2 * b2;\n\n    // Compute the gradient\n    gradient.col(i) = 4.0 * p.dot(p) * p + 4.0 * v.dot(v) * v;\n  }\n}", "CodeBleu_score": 26.063108669546743}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n\n    int N = q.rows();\n    int D = q.cols();\n\n    double a2 = 1.0, b2 = 1.0;\n\n    for (int i = 0; i < N; i++) {\n        Eigen::VectorXd qi = q.row(i);\n        Eigen::VectorXd pi = ref_pts_.row(i);\n        Eigen::VectorXd vi = ref_vel_.row(i);\n\n        double sqr_dist = (qi - pi).squaredNorm();\n        double vel_rel = (qi - pi).dot(vi) / sqr_dist;\n\n        cost += sqr_dist * a2 + vel_rel * vel_rel * b2;\n\n        Eigen::VectorXd grad_i = Eigen::VectorXd::Zero(D);\n        for (int j = 0; j < D; j++) {\n            grad_i(j) += 2.0 * a2 * (qi(j) - pi(j)) +\n                         2.0 * b2 * vel_rel * (vi(j) - pi(j)) / sqr_dist;\n        }\n        gradient.row(i) = grad_i;\n    }\n}", "CodeBleu_score": 40.461065327744016}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n    int num_points = q.cols();\n    for (int i = 0; i < num_points; ++i) {\n        Eigen::Vector3d p = q.col(i);\n        Eigen::Vector3d p_diff = p - ref_pts_.col(i);\n        Eigen::Vector3d v = q.col(i) - q.col(std::max(0, i - 1));\n        double a2 = p_diff.squaredNorm();\n        double b2 = v.squaredNorm();\n        cost += a2 + b2;\n        gradient.col(i) += 2.0 * p_diff + 2.0 * v;\n    }\n}", "CodeBleu_score": 30.578057642862987}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  double jerk = 0.0;\n  double time_segment = t_knots[1] - t_knots[0];\n\n  MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n  for (int i = 0; i < ctrl_pts.rows(); ++i) {\n    for (int j = 0; j < ctrl_pts.cols(); ++j) {\n      jerk += (ctrl_pts(i, j) * ctrl_pts(i, j) * time_segment);\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 66.31663519865792}, {"code": "double UniformBspline::getJerk(){\n\t  Eigen::MatrixXd jerk_traj = UniformBspline::getDerivative().getDerivative().getDerivative();\n  double jerk = 0.0;\n  double time_step = UniformBspline::getTimeSum();\n  Eigen::VectorXd kts = UniformBspline::getKnot();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.transpose();\n\n  for (int i = 2; i < ctrl_pts.rows() - 2; i++) {\n    for (int j = 0; j < ctrl_pts.cols(); j++) {\n      jerk += (time_step * ctrl_pts(i + 1, j) - time_step * ctrl_pts(i, j)) *\n              (time_step * ctrl_pts(i + 1, j) - time_step * ctrl_pts(i, j));\n    }\n  }\n  return sqrt(jerk);\n}", "CodeBleu_score": 59.05035104963214}, {"code": "double UniformBspline::getJerk(){\n\t  Eigen::MatrixXd jerk_traj = getDerivative().getDerivative().getDerivative();\n  double jerk = 0.0;\n  double time_step = (time_interval_) / (ctrl_pts_.cols() - 3);\n  for (int i = 0; i < jerk_traj.cols(); ++i) {\n    jerk += (jerk_traj.col(i)).squaredNorm() * time_step;\n  }\n  return jerk;\n}", "CodeBleu_score": 42.27232021856634}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 78.35005343899863}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    // TODO: 1. Convert the pixel coordinates (u, v) to normalized image coordinates (x, y)\n    // TODO: 2. Calculate the 3D position of the point in camera coordinates\n    // TODO: 3. Return the 4D position vector in the camera frame\n\n    // Convert the pixel coordinates (u, v) to normalized image coordinates (x, y)\n    float x = (u - cx_) / fx_;\n    float y = (v - cy_) / fy_;\n\n    // Calculate the 3D position of the point in camera coordinates\n    float z = depth;\n    Eigen::Vector4d pos(x * z, y * z, z, 1.0);\n\n    return pos;\n}", "CodeBleu_score": 40.38035056375831}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1;\n    return pos;\n}", "CodeBleu_score": 77.10646079020273}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    std::string drone_id = odom.child_frame_id;\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  } catch (std::exception& e) {\n    ROS_ERROR(\"Error extracting drone ID from odometry message: %s\", e.what());\n  }\n}", "CodeBleu_score": 50.497138293377006}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        std::string child_frame_id = odom.child_frame_id;\n        int drone_id = std::stoi(child_frame_id.substr(child_frame_id.length() - 1));\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 56.81391274143775}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    std::string drone_id;\n    try {\n        drone_id = odom.child_frame_id.substr(odom.child_frame_id.find(\"_\") + 1);\n    } catch (const std::exception& e) {\n        ROS_ERROR_STREAM(\"Error extracting drone ID from child_frame_id: \" << e.what());\n        return;\n    }\n    rcvDroneOdomCallbackBase(odom, drone_id);\n}", "CodeBleu_score": 48.81027468800906}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Calculate true pose of drone in camera frame\n    Eigen::Vector3d true_pose = calc_pose(true_pixel);\n\n    // Check if drone is present\n    if (true_pose.z() > 0) {\n        // Compute pose error between camera and world coordinates\n        Eigen::Vector3d pose_error = true_pose - drone_pose_;\n\n        // Update debug result\n        debug_result_.drone_id = drone_id;\n        debug_result_.true_pixel = true_pixel;\n        debug_result_.pose_error = pose_error;\n        debug_result_.detected = true;\n\n        // Publish pose error\n        geometry_msgs::PoseStamped pose_msg;\n        pose_msg.header.stamp = ros::Time::now();\n        pose_msg.header.frame_id = \"drone_detector\";\n        pose_msg.pose.position.x = pose_error.x();\n        pose_msg.pose.position.y = pose_error.y();\n        pose_msg.pose.position.z = pose_error.z();\n        pose_error_pub_.publish(pose_msg);\n    } else {\n        // Update debug result to indicate failure\n        debug_result_.detected = false;\n    }\n}", "CodeBleu_score": 41.65560880715869}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Calculate the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = calculate_pose(true_pixel);\n\n    // Check for the presence of the drone in the image\n    if (check_presence(true_pose)) {\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d pose_error = calculate_pose_error(true_pose);\n\n        // Update the debug result\n        debug_result_ = true;\n\n        // Publish the pose error\n        publish_pose_error(pose_error);\n    } else {\n        // Update the debug result to indicate failure\n        debug_result_ = false;\n    }\n}", "CodeBleu_score": 17.448288390062178}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n    // Check if the drone ID is valid\n    if (drone_id < 0 || drone_id >= num_drones_) {\n        ROS_ERROR(\"Invalid drone ID: %d\", drone_id);\n        return;\n    }\n\n    // Calculate the true pose of the drone in the camera frame\n    Eigen::Vector3d true_position;\n    true_position << true_pixel(0), true_pixel(1), 0.0;\n    Eigen::Vector3d true_pose = camera_model_.projectPixelTo3dRay(true_position);\n\n    // Check if the drone is present in the camera frame\n    if (true_pose.norm() > 0.0) {\n        // Calculate the pose error between the camera and world coordinates\n        Eigen::Vector3d error = true_pose - drone_poses_[drone_id];\n\n        // Update the debug result\n        debug_result_.header.stamp = ros::Time::now();\n        debug_result_.pose_error = error.norm();\n        debug_result_.drone_id = drone_id;\n        debug_result_.true_pose = true_pose;\n        debug_result_.detected_pose = drone_poses_[drone_id];\n        debug_result_.drone_detected = true;\n\n        // Publish the pose error\n        pose_error_pub_.publish(debug_result_);\n    } else {\n        // Update the debug result to indicate failure\n        debug_result_.header.stamp = ros::Time::now();\n        debug_result_.pose_error = 0.0;\n        debug_result_.drone_id = drone_id;\n        debug_result_.true_pose = true_pose;\n        debug_result_.detected_pose = drone_poses_[drone_id];\n        debug_result_.drone_detected = false;\n\n        // Publish the debug result\n        pose_error_pub_.publish(debug_result_);\n    }\n}", "CodeBleu_score": 47.83843648516877}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    // start from end point\n    path.push_back(current);\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 98.77621185986197}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t  vector<GridNodePtr> path;\n  // std::cout << \"In retrievePath\" << std::endl;\n  path.push_back(current);\n\n  while (current->cameFrom != NULL) {\n    current = current->cameFrom;\n    path.push_back(current);\n  }\n\n  return path;\n}", "CodeBleu_score": 96.25191622895396}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n\n    return path;\n}", "CodeBleu_score": 98.77621185986197}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  if (!pos_checker_ptr_->odomValid())\n    return false;\n\n  if (!ptr_grid_path_finding_map_->odomValid()) {\n    ROS_WARN(\"[Astar] Map range not valid.\");\n    return false;\n  }\n\n  if (VoxelPositionCheckInRange(start_pt)) {\n    start_idx = pos_checker_ptr_->getGridIndex(start_pt);\n  } else {\n    ROS_WARN(\"[Astar] Start point is out of range.\");\n    return false;\n  }\n\n  if (VoxelPositionCheckInRange(end_pt)) {\n    end_idx = pos_checker_ptr_->getGridIndex(end_pt);\n  } else {\n    ROS_WARN(\"[Astar] End point is out of range.\");\n    return false;\n  }\n\n  // Check if the start or end point is inside an obstacle.\n  // If so, adjust the point by moving it away from the other point until it is no longer inside an obstacle.\n  if (ptr_grid_path_finding_map_->isOccupied(start_idx)) {\n    ROS_WARN(\"[Astar] Start point is inside obstacle, adjusting start point.\");\n    do {\n      start_pt = (start_pt - end_pt).normalized() * resolution + start_pt;\n      start_idx = pos_checker_ptr_->getGridIndex(start_pt);\n    } while (ptr_grid_path_finding_map_->isOccupied(start_idx));\n  }\n\n  if (ptr_grid_path_finding_map_->isOccupied(end_idx)) {\n    ROS_WARN(\"[Astar] End point is inside obstacle, adjusting end point.\");\n    do {\n      end_pt = (end_pt - start_pt).normalized() * resolution + end_pt;\n      end_idx = pos_checker_ptr_->getGridIndex(end_pt);\n    } while (ptr_grid_path_finding_map_->isOccupied(end_idx", "CodeBleu_score": 55.948854888159495}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    if (!pos_checker_->odomValid() || !pos_checker_->idxValid())\n        return false;\n\n    /*\n     * Convert the start and end points to grid indices.\n     */\n    pos_checker_->posToIndex(start_pt, start_idx);\n    pos_checker_->posToIndex(end_pt, end_idx);\n\n    /*\n     * Adjust the start point if it is inside an obstacle.\n     */\n    int iter_num = 0, max_iter_num = 5;\n    while (pos_checker_->isOccupied(start_idx) && iter_num < max_iter_num) {\n        start_pt = (start_pt + end_pt) / 2;\n        pos_checker_->posToIndex(start_pt, start_idx);\n        iter_num++;\n    }\n    /*\n     * Adjust the end point if it is inside an obstacle.\n     */\n    iter_num = 0;\n    while (pos_checker_->isOccupied(end_idx) && iter_num < max_iter_num) {\n        end_pt = (start_pt + end_pt) / 2;\n        pos_checker_->posToIndex(end_pt, end_idx);\n        iter_num++;\n    }\n\n    /*\n     * If the start or end point is still inside an obstacle after adjustment, return false.\n     */\n    if (pos_checker_->isOccupied(start_idx) || pos_checker_->isOccupied(end_idx))\n        return false;\n    else\n        return true;\n}", "CodeBleu_score": 46.874483786499326}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  if (!pos_checker_->inside_map(start_pt) || !pos_checker_->inside_map(end_pt))\n    return false;\n\n  start_idx = pos_checker_->float_to_grid_index(start_pt);\n  end_idx = pos_checker_->float_to_grid_index(end_pt);\n\n  int iter_num = 0;\n  while (iter_num < 10 && (pos_checker_->is_occ(start_idx) || pos_checker_->is_occ(end_idx))) {\n    Eigen::Vector3d mid_pt = (start_pt + end_pt) / 2;\n    if (iter_num % 2 == 0)\n      start_pt = mid_pt;\n    else\n      end_pt = mid_pt;\n    start_idx = pos_checker_->float_to_grid_index(start_pt);\n    end_idx = pos_checker_->float_to_grid_index(end_pt);\n    iter_num += 1;\n  }\n\n  if (iter_num >= 10)\n    return false;\n  else\n    return true;\n}", "CodeBleu_score": 39.74744483977938}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  max_id -= Eigen::Vector3i(1, 1, 1);\n\n  for (int x = min_id(0); x <= max_id(0); ++x)\n    for (int y = min_id(1); y <= max_id(1); ++y)\n      for (int z = min_id(2); z <= max_id(2); ++z) {\n        occupancy_buffer_inflate_[x * grid_size_(1) * grid_size_(2) +\n                                  y * grid_size_(2) + z] = 0;\n      }\n}", "CodeBleu_score": 70.20899687774347}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  min_id = min_id.array().max(Eigen::Array3i::Zero());\n  max_id = max_id.array().min(buffer_size_ - Eigen::Array3i::Ones());\n\n  /* reset occupancy cached in the buffer */\n  std::unique_lock<std::mutex> lock(mutex_);\n\n  for (int x = min_id(0); x <= max_id(0); ++x)\n    for (int y = min_id(1); y <= max_id(1); ++y)\n      for (int z = min_id(2); z <= max_id(2); ++z) {\n        occupancy_buffer_inflate_[x * buffer_size_(1) * buffer_size_(2) + y * buffer_size_(2) + z] = 0;\n      }\n}", "CodeBleu_score": 67.85639570913004}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  boundIndex(min_id);\n  boundIndex(max_id);\n\n  /* reset occupancy_buffer_inflate_ */\n  for (int x = min_id(0); x <= max_id(0); ++x)\n    for (int y = min_id(1); y <= max_id(1); ++y)\n      for (int z = min_id(2); z <= max_id(2); ++z)\n        occupancy_buffer_inflate_[x * grid_size(1) * grid_size(2) + y * grid_size(2) + z] = 0;\n}", "CodeBleu_score": 69.8092981211536}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  Eigen::Vector3d max_t = map_max_boundary_ - camera_pt;\n  Eigen::Vector3d min_t = map_min_boundary_ - camera_pt;\n  max_t = max_t.array() / diff.array();\n  min_t = min_t.array() / diff.array();\n  double min_scalar = std::numeric_limits<double>::infinity();\n  for (int i = 0; i < 3; i++) {\n    if (max_t(i) > 0.0 && max_t(i) < min_scalar) {\n      min_scalar = max_t(i);\n    }\n    if (min_t(i) > 0.0 && min_t(i) < min_scalar) {\n      min_scalar = min_t(i);\n    }\n  }\n  return camera_pt + diff * min_scalar;\n}", "CodeBleu_score": 47.10567425691282}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  Eigen::Vector3d max_t = this->map_max_boundary_ - camera_pt;\n  Eigen::Vector3d min_t = this->map_min_boundary_ - camera_pt;\n  max_t = max_t.cwiseQuotient(diff);\n  min_t = min_t.cwiseQuotient(diff);\n\n  double min_scale = std::numeric_limits<double>::infinity();\n\n  if (max_t(0) > 0.0) {\n    min_scale = std::min(min_scale, max_t(0));\n  }\n  if (max_t(1) > 0.0) {\n    min_scale = std::min(min_scale, max_t(1));\n  }\n  if (max_t(2) > 0.0) {\n    min_scale = std::min(min_scale, max_t(2));\n  }\n  if (min_t(0) > 0.0) {\n    min_scale = std::min(min_scale, min_t(0));\n  }\n  if (min_t(1) > 0.0) {\n    min_scale = std::min(min_scale, min_t(1));\n  }\n  if (min_t(2) > 0.0) {\n    min_scale = std::min(min_scale, min_t(2));\n  }\n  return camera_pt + min_scale * diff;\n}", "CodeBleu_score": 36.60980808064694}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d max_t = this->map_max_boundary_ - camera_pt;\n    Eigen::Vector3d min_t = this->map_min_boundary_ - camera_pt;\n    max_t = max_t.cwiseQuotient(diff);\n    min_t = min_t.cwiseQuotient(diff);\n    std::vector<Eigen::Vector3d> translation_coeffs = {max_t, min_t};\n    double min_positive_t = std::numeric_limits<double>::max();\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 2; j++) {\n            if (translation_coeffs[j](i) > 0 && translation_coeffs[j](i) < min_positive_t) {\n                min_positive_t = translation_coeffs[j](i);\n            }\n        }\n    }\n    return camera_pt + min_positive_t * diff;\n}", "CodeBleu_score": 53.131732515184716}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Check if the last occupancy update time is valid\n  if (!last_occupancy_update_time_.isValid()) {\n    last_occupancy_update_time_ = ros::Time::now();\n    return;\n  }\n\n  // Calculate the time since the last occupancy update\n  double time_since_last_occupancy_update =\n      (ros::Time::now() - last_occupancy_update_time_).toSec();\n\n  // If the time since the last occupancy update is less than the occupancy update\n  // interval, return\n  if (time_since_last_occupancy_update < occupancy_update_interval_) {\n    return;\n  }\n\n  // Update the last occupancy update time\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // Check if the depth image is valid\n  if (!depth_image_valid_) {\n    return;\n  }\n\n  // Check if the odometry is valid\n  if (!odom_valid_) {\n    return;\n  }\n\n  // Check if the odometry is timeout\n  if (odom_timeout_) {\n    return;\n  }\n\n  // Check if the depth image is timeout\n  if (depth_image_timeout_) {\n    return;\n  }\n\n  // Check if the depth image is timeout\n  if (depth_image_timeout_) {\n    return;\n  }\n\n  // Check if the odometry is timeout\n  if (odom_timeout_) {\n    return;\n  }\n\n  // Check if the local map is valid\n  if (!local_map_valid_) {\n    return;\n  }\n\n  // Project the depth image into points\n  std::vector<Eigen::Vector3d> points;\n  projectDepthImage(points);\n\n  // Process the points with raycasting\n  processPoints(points);\n\n  // If the local map has been updated, clear and inflate the local map\n  if (local_map_updated_) {\n    local_map_updated_ = false;\n    clearLocalMap();\n    inflateLocalMap();\n  }\n\n  // Check if the odometry is timeout\n", "CodeBleu_score": 42.74823241256045}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t    // Check if the last occupancy update time is within the timeout\n    if (ros::Time::now() - last_occupancy_update_time > occupancy_update_timeout) {\n        // Handle timeout error for odometry or depth data\n        // Set relevant flags\n    }\n\n    // Update the last occupancy update time\n    last_occupancy_update_time = ros::Time::now();\n\n    // Check if an update is needed\n    if (update_occupancy) {\n        // Project the depth image into points\n        // Process the points with raycasting\n        // Update the occupancy grid\n\n        // Check if the local map has been updated\n        if (update_local_map) {\n            // Clear and inflate the local map\n            // Update the local map\n\n            // Reset the update flags\n            update_occupancy = false;\n            update_local_map = false;\n        }\n    }\n}", "CodeBleu_score": 23.60924820597092}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t    // Update last occupancy update time\n    last_occupancy_update_time_ = ros::Time::now();\n\n    // Check if an update is needed\n    if (!map_updated_ && (ros::Time::now() - last_depth_update_time_).toSec() < depth_timeout_) {\n        return;\n    }\n\n    // Project depth image into points\n    sensor_msgs::PointCloud2 depth_cloud;\n    depth_image_to_point_cloud_converter_.convertDepthImageToPointCloudMsg(depth_image_, depth_cloud);\n\n    // Process points with raycasting\n    processPoints(depth_cloud);\n\n    // Clear and inflate local map if needed\n    if (map_updated_) {\n        clearAndInflateMap();\n        map_updated_ = false;\n    }\n\n    // Handle timeout errors for odometry and depth data\n    if ((ros::Time::now() - last_odom_update_time_).toSec() > odom_timeout_) {\n        ROS_WARN_THROTTLE(1.0, \"GridMap: Odometry timeout!\");\n        odom_timeout_flag_ = true;\n    } else {\n        odom_timeout_flag_ = false;\n    }\n\n    if ((ros::Time::now() - last_depth_update_time_).toSec() > depth_timeout_) {\n        ROS_WARN_THROTTLE(1.0, \"GridMap: Depth timeout!\");\n        depth_timeout_flag_ = true;\n    } else {\n        depth_timeout_flag_ = false;\n    }\n}", "CodeBleu_score": 44.586171082561926}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    int num_images = image_fns.size();\n    float avg_fmeasure = 0.0;\n\n    for (int i = 0; i < num_images; i++) {\n        Mat img = imread(image_fns[i], IMREAD_GRAYSCALE);\n        Mat gt_img = imread(gt_fns[i], IMREAD_GRAYSCALE);\n        Mat dt_img = imread(dt_fns[i], IMREAD_GRAYSCALE);\n\n        vector<vector<Point>> gt_ellipses = _ellipse_detector_get_ellipses(gt_img, gt_angle_radians);\n        vector<vector<Point>> dt_ellipses = _ellipse_detector_get_ellipses(dt_img, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_single(img, gt_ellipses, dt_ellipses);\n        avg_fmeasure += fmeasure;\n    }\n\n    return avg_fmeasure / num_images;\n}", "CodeBleu_score": 53.03896521671645}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n    // Initialize variables for accumulating the F-measure\n    float f_sum = 0.0f;\n\n    // Iterate through the image filenames\n    for (int i = 0; i < image_fns.size(); i++) {\n\n        // Load the image, ground truth, and detected ellipses\n        Mat image = imread(image_fns[i]);\n        vector<Ellipse> gt_ellipses = _load_ellipses(gt_fns[i], gt_angle_radians);\n        vector<Ellipse> dt_ellipses = _load_ellipses(dt_fns[i], gt_angle_radians);\n\n        // Evaluate the detection performance\n        float f = _ellipse_evaluate(image, gt_ellipses, dt_ellipses);\n\n        // Accumulate the F-measure\n        f_sum += f;\n    }\n\n    // Calculate and return the average F-measure\n    return f_sum / image_fns.size();\n}", "CodeBleu_score": 61.418138097734385}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n    // Initialize the accumulated F-measure\n    float f_measure_acc = 0.0f;\n\n    // Iterate through the image filenames\n    for (int i = 0; i < image_fns.size(); i++) {\n\n        // Load the image, ground truth, and detected ellipses\n        Mat image = imread(image_fns[i], IMREAD_COLOR);\n        vector<Ellipse> gt_ellipses = _ellipse_load_gt(gt_fns[i], gt_angle_radians);\n        vector<Ellipse> dt_ellipses = _ellipse_load_dt(dt_fns[i], gt_angle_radians);\n\n        // Evaluate the detection performance\n        float f_measure = _ellipse_evaluate_single(image, gt_ellipses, dt_ellipses);\n\n        // Accumulate the F-measure\n        f_measure_acc += f_measure;\n    }\n\n    // Calculate and return the average F-measure\n    return f_measure_acc / image_fns.size();\n}", "CodeBleu_score": 62.16621664840956}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    if (foci == nullptr) {\n        return 0.0f;\n    }\n\n    float angle1 = atan2(y - foci[1], x - foci[0]);\n    float angle2 = atan2(y - foci[3], x - foci[2]);\n    float angle_diff = angle1 - angle2;\n\n    if (angle_diff > M_PI) {\n        angle_diff -= 2 * M_PI;\n    } else if (angle_diff < -M_PI) {\n        angle_diff += 2 * M_PI;\n    }\n\n    return angle_diff;\n}", "CodeBleu_score": 50.676660793972}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle1 = atan2(y - foci[1], x - foci[0]);\n    float angle2 = atan2(y - foci[3], x - fci[2]);\n    float angle = angle1 - angle2;\n    if (angle < -M_PI) {\n        angle += 2 * M_PI;\n    } else if (angle > M_PI) {\n        angle -= 2 * M_PI;\n    }\n    return angle;\n}", "CodeBleu_score": 44.806505901647455}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    if (foci == NULL) {\n        return 0.0;\n    }\n\n    float angle1 = atan2(y - foci[1], x - foci[0]);\n    float angle2 = atan2(y - foci[3], x - foci[2]);\n    float normal_angle = angle1 - angle2;\n\n    // Adjust normal angle to lie within range [-\u03c0, \u03c0]\n    while (normal_angle > M_PI) {\n        normal_angle -= 2 * M_PI;\n    }\n    while (normal_angle < -M_PI) {\n        normal_angle += 2 * M_PI;\n    }\n\n    return normal_angle;\n}", "CodeBleu_score": 51.58623201115966}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    int min_x = INT_MAX, min_y = INT_MAX, max_x = INT_MIN, max_y = INT_MIN;\n    for (int i = start; i <= end; i++) {\n        min_x = std::min(min_x, vp1[i].x);\n        min_y = std::min(min_y, vp1[i].y);\n        max_x = std::max(max_x, vp1[i].x);\n        max_y = std::max(max_y, vp1[i].y);\n    }\n    int above = 0, below = 0;\n    for (int i = min_x; i <= max_x; i++) {\n        for (int j = min_y; j <= max_y; j++) {\n            if (cv::pointPolygonTest(vp1, cv::Point(i, j), false) > 0) {\n                above++;\n            }\n            else {\n                below++;\n            }\n        }\n    }\n    return above < below;\n}", "CodeBleu_score": 44.197700747247424}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    int min_x = vp1[start].x, max_x = vp1[start].x, min_y = vp1[start].y, max_y = vp1[start].y;\n    for (int i = start; i <= end; i++) {\n        if (vp1[i].x < min_x)\n            min_x = vp1[i].x;\n        if (vp1[i].x > max_x)\n            max_x = vp1[i].x;\n        if (vp1[i].y < min_y)\n            min_y = vp1[i].y;\n        if (vp1[i].y > max_y)\n            max_y = vp1[i].y;\n    }\n    int above = 0, below = 0;\n    for (int i = min_x; i <= max_x; i++) {\n        for (int j = min_y; j <= max_y; j++) {\n            int sum = 0;\n            for (int k = start; k <= end; k++) {\n                sum += (vp1[k].x - i) * (vp1[k].y - j);\n            }\n            if (sum > 0)\n                above++;\n            else if (sum < 0)\n                below++;\n        }\n    }\n    return above < below;\n}", "CodeBleu_score": 42.55645163211751}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = std::numeric_limits<double>::max();\n\tdouble max_x = std::numeric_limits<double>::min();\n\tdouble min_y = std::numeric_limits<double>::max();\n\tdouble max_y = std::numeric_limits<double>::min();\n\n\tfor (int i = start; i <= end; i++) {\n\t\tmin_x = std::min(min_x, vp1[i].x);\n\t\tmax_x = std::max(max_x, vp1[i].x);\n\t\tmin_y = std::min(min_y, vp1[i].y);\n\t\tmax_y = std::max(max_y, vp1[i].y);\n\t}\n\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\n\tfor (int i = start; i <= end; i++) {\n\t\tint next = i == end ? start : i + 1;\n\t\tintegral_above += (vp1[next].x - vp1[i].x) * (vp1[next].y + vp1[i].y);\n\t\tintegral_below += (vp1[i].x - vp1[next].x) * (vp1[i].y + vp1[next].y);\n\t}\n\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 43.62650762437351}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\n    // Iterate through each detection info in the message\n    for (int i = 0; i < msg->num_det; i++) {\n        prometheus_msgs::DetectionInfo det_info = msg->det_info[i];\n\n        // Check if the object name is \"T\"\n        if (det_info.name == \"T\") {\n            // Increment the num_regain counter and reset num_lost\n            ellipse_det.num_regain++;\n            ellipse_det.num_lost = 0;\n        } else {\n            // Reset num_regain and increment num_lost\n            ellipse_det.num_regain = 0;\n            ellipse_det.num_lost++;\n        }\n\n        // Check if num_lost exceeds VISION_THRES\n        if (ellipse_det.num_lost > VISION_THRES) {\n            // Set is_detected to false\n            ellipse_det.is_detected = false;\n        }\n\n        // Check if num_regain exceeds VISION_THRES\n        if (ellipse_det.num_regain > VISION_THRES) {\n            // Set is_detected to true\n            ellipse_det.is_detected = true;\n        }\n\n        // Swap the sight_angle values\n        ellipse_det.sight_angle.x = det_info.sight_angle.y;\n        ellipse_det.sight_angle.y = det_info.sight_angle.x;\n    }\n}", "CodeBleu_score": 46.68187581410802}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    ellipse_det.num_detected = msg->num_detected;\n    ellipse_det.num_regain = 0;\n    ellipse_det.num_lost = 0;\n    ellipse_det.is_detected = false;\n    for (int i = 0; i < msg->num_detected; i++) {\n        ellipse_det.detected_class[i] = msg->detected_class[i];\n        ellipse_det.detected_prob[i] = msg->detected_prob[i];\n        ellipse_det.detected_rect[i] = msg->detected_rect[i];\n        ellipse_det.detected_img_center[i] = msg->detected_img_center[i];\n        ellipse_det.detected_img_size[i] = msg->detected_img_size[i];\n        ellipse_det.detected_world_center[i] = msg->detected_world_center[i];\n        ellipse_det.detected_world_size[i] = msg->detected_world_size[i];\n        ellipse_det.detected_bbox_center[i] = msg->detected_bbox_center[i];\n        ellipse_det.detected_bbox_size[i] = msg->detected_bbox_size[i];\n        ellipse_det.detected_bbox_rotation[i] = msg->detected_bbox_rotation[i];\n        ellipse_det.sight_angle[i] = msg->sight_angle[i];\n        if (ellipse_det.detected_class[i] == \"T\") {\n            ellipse_det.num_regain++;\n            ellipse_det.num_lost = 0;\n        } else {\n            ellipse_det.num_regain = 0;\n            ellipse_det.num_lost++;\n        }\n        if (ellipse_det.num_lost > VISION_TH", "CodeBleu_score": 30.707181527102602}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (int i = 0; i < msg->num_detection; i++) {\n        ellipse_det.detected_class = msg->detection[i].detected_class;\n        ellipse_det.sight_angle = msg->detection[i].sight_angle;\n        ellipse_det.confidence = msg->detection[i].confidence;\n        ellipse_det.position[0] = msg->detection[i].position[0];\n        ellipse_det.position[1] = msg->detection[i].position[1];\n        ellipse_det.position[2] = msg->detection[i].position[2];\n        ellipse_det.velocity[0] = msg->detection[i].velocity[0];\n        ellipse_det.velocity[1] = msg->detection[i].velocity[1];\n        ellipse_det.velocity[2] = msg->detection[i].velocity[2];\n        ellipse_det.ellipse_a = msg->detection[i].ellipse_a;\n        ellipse_det.ellipse_b = msg->detection[i].ellipse_b;\n        ellipse_det.ellipse_angle = msg->detection[i].ellipse_angle;\n        if (ellipse_det.detected_class == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n        if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n        swap_sight_angle(ellipse_det);\n    }\n}", "CodeBleu_score": 64.87658112043933}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    if (Occupy_map_ptr->get_prob(cur_pos) < safe_distance)\n        return true;\n    else\n        return false;\n}", "CodeBleu_score": 35.263538862805845}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    Eigen::Vector3d check_pos;\n    check_pos(0) = cur_pos(0);\n    check_pos(1) = cur_pos(1);\n    check_pos(2) = cur_pos(2);\n    return Occupy_map_ptr->check_safety(check_pos, safe_distance);\n}", "CodeBleu_score": 49.80867814888541}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    Eigen::Vector3d check_pos = cur_pos;\n    check_pos[2] = 0.0;\n    return Occupy_map_ptr->check_safety(check_pos, safe_distance);\n}", "CodeBleu_score": 53.599109463013846}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 67.26908921647082}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t  NodePtr current_node = end_node;\n  path_nodes_.push_back(current_node);\n\n  while (current_node->parent != nullptr) {\n    current_node = current_node->parent;\n    path_nodes_.push_back(current_node);\n  }\n\n  reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 73.06814700495583}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 67.26908921647082}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n    if (sim_mode) {\n        double dist = sqrt(pow(state_nei[id][0] - start_pos[0], 2) + pow(state_nei[id][1] - start_pos[1], 2));\n        if (dist > 5) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    } else {\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 59.4549444224425}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n    state_nei[id][3] = odom->pose.pose.orientation.x;\n    state_nei[id][4] = odom->pose.pose.orientation.y;\n    state_nei[id][5] = odom->pose.pose.orientation.z;\n    state_nei[id][6] = odom->pose.pose.orientation.w;\n    state_nei[id][7] = odom->twist.twist.linear.x;\n    state_nei[id][8] = odom->twist.twist.linear.y;\n    state_nei[id][9] = odom->twist.twist.linear.z;\n    state_nei[id][10] = odom->twist.twist.angular.x;\n    state_nei[id][11] = odom->twist.twist.angular.y;\n    state_nei[id][12] = odom->twist.twist.angular.z;\n    if (simulation) {\n        double dist = sqrt(pow(state_nei[id][0] - start_pos[0], 2) + pow(state_nei[id][1] - start_pos[1], 2));\n        if (dist > 5) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    }\n}", "CodeBleu_score": 55.989301318894235}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n    if (simulation_mode) {\n        double dist = sqrt(pow(state_nei[id][0] - start_pos[0], 2) + pow(state_nei[id][1] - start_pos[1], 2));\n        if (dist > 5) {\n            get_nei_state = false;\n        } else {\n            get_nei_state = true;\n        }\n    }\n}", "CodeBleu_score": 45.2701572644784}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!odom_ready)\n    return;\n\n  sensor_ready = true;\n  update_counter++;\n  if (update_counter == 5) {\n    update_counter = 0;\n    astar_map.update_map(msg);\n  }\n}", "CodeBleu_score": 45.441857346061596}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter >= 5) {\n        update_counter = 0;\n        // ROS_INFO(\"Updating map\");\n        astar_map->updateMap(msg);\n    }\n}", "CodeBleu_score": 57.24695191674185}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    if(!odom_ready) return;\n\n    sensor_ready = true;\n\n    if(update_counter == 5) {\n        update_counter = 0;\n        update_map(msg);\n    }\n    else {\n        update_counter++;\n    }\n}", "CodeBleu_score": 46.56915817820616}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (get_gpcl) {\n        get_gpcl = false;\n        pcl::fromROSMsg(*global_point, *global_cloud);\n        global_cloud->header.frame_id = \"map\";\n        global_cloud->header.stamp = ros::Time::now();\n        global_map->setInputCloud(global_cloud);\n        global_map->inflation_update();\n    }\n}", "CodeBleu_score": 52.81241160605789}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (get_gpcl) {\n        get_gpcl = false;\n        pcl::fromROSMsg(*global_point, *global_cloud);\n        pcl::toROSMsg(*global_cloud, global_map);\n        inflate_cloud(global_cloud, global_map);\n    }\n}", "CodeBleu_score": 51.12344836421817}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (get_gpcl) {\n        get_gpcl = false;\n        pcl::PointCloud<pcl::PointXYZ> cloud;\n        pcl::fromROSMsg(*global_point, cloud);\n        global_map = cloud;\n        inflate_pcl(global_map);\n    }\n}", "CodeBleu_score": 51.51971176038048}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // Project the laser scan into a PointCloud2 format\n    sensor_msgs::PointCloud2 cloud2;\n    projector_.projectLaser(*local_point, cloud2);\n\n    // Convert the PointCloud2 to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(cloud2, *cloud);\n\n    // If not in simulation mode, merge the local map with the provided odometry data\n    if(!simulation_mode_) {\n        pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        Eigen::Matrix4f odom_matrix = Eigen::Matrix4f::Identity();\n        odom_matrix.block<3, 3>(0, 0) = Eigen::Quaternionf(odom.pose.pose.orientation.w, odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z).toRotationMatrix();\n        odom_matrix(0, 3) = odom.pose.pose.position.x;\n        odom_matrix(1, 3) = odom.pose.pose.position.y;\n        odom_matrix(2, 3) = odom.pose.pose.position.z;\n        pcl::transformPointCloud(*cloud, *transformed_cloud, odom_matrix);\n        *cloud = *transformed_cloud;\n    }\n\n    // Update the occupancy map using the laser scan data and odometry information\n    map_update(cloud, odom);\n}", "CodeBleu_score": 47.303379657708945}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    // project the laser scan into a PointCloud2 format\n    sensor_msgs::PointCloud2 cloud2;\n    projector_.projectLaser(*local_point, cloud2);\n\n    // convert the PointCloud2 to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in (new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(cloud2, *cloud_in);\n\n    // if not in simulation mode, merge the local map with the provided odometry data\n    if (!simulation_mode_) {\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_trans (new pcl::PointCloud<pcl::PointXYZ>);\n        cloud_trans = merge_cloud(cloud_in, odom);\n        cloud_in = cloud_trans;\n    }\n\n    // update the occupancy map with the new point cloud\n    update_map(cloud_in);\n}", "CodeBleu_score": 52.76533682064911}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    sensor_msgs::PointCloud2 cloud_msg;\n    cloud_msg.header.stamp = ros::Time::now();\n    cloud_msg.header.frame_id = \"laser_link\";\n    cloud_msg.height = 1;\n    cloud_msg.width = local_point->ranges.size();\n    cloud_msg.is_bigendian = false;\n    cloud_msg.is_dense = true;\n    cloud_msg.point_step = 16;\n    cloud_msg.row_step = cloud_msg.point_step * cloud_msg.width;\n    cloud_msg.fields.resize(3);\n    cloud_msg.fields[0].name = \"x\";\n    cloud_msg.fields[0].offset = 0;\n    cloud_msg.fields[0].datatype = 7;\n    cloud_msg.fields[0].count = 1;\n    cloud_msg.fields[1].name = \"y\";\n    cloud_msg.fields[1].offset = 4;\n    cloud_msg.fields[1].datatype = 7;\n    cloud_msg.fields[1].count = 1;\n    cloud_msg.fields[2].name = \"z\";\n    cloud_msg.fields[2].offset = 8;\n    cloud_msg.fields[2].datatype = 7;\n    cloud_msg.fields[2].count = 1;\n    cloud_msg.data.resize(cloud_msg.row_step * cloud_msg.height);\n    sensor_msgs::PointCloud2Iterator<float> iter_x(cloud_msg, \"x\");\n    sensor_msgs::PointCloud2Iterator<float> iter_y(cloud_msg, \"y\");\n    sensor_msgs::PointCloud2Iterator<float> iter_z(cloud_msg, \"z\");\n    for (size_t i = 0; i < local_point->ranges.size(); i++) {\n        float x = local_point->ranges[i] * cos(local_point->angle_min + local_point->angle_increment * i);\n        float y = local_point->ranges[i] * sin", "CodeBleu_score": 38.609678369496606}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr global_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr inflate_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n    for (int i = 0; i < map_size; i++) {\n        for (int j = 0; j < map_size; j++) {\n            if (map[i][j] == 1) {\n                pcl::PointXYZ pt;\n                pt.x = i * map_resolution + map_origin_x;\n                pt.y = j * map_resolution + map_origin_y;\n                pt.z = 0;\n                global_pcl->push_back(pt);\n            }\n            if (inflate_map[i][j] == 1) {\n                pcl::PointXYZ pt;\n                pt.x = i * map_resolution + map_origin_x;\n                pt.y = j * map_resolution + map_origin_y;\n                pt.z = 0;\n                inflate_pcl->push_back(pt);\n            }\n        }\n    }\n    global_pcl->header.frame_id = \"world\";\n    inflate_pcl->header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl);\n    inflate_pcl_pub.publish(inflate_pcl);\n}", "CodeBleu_score": 53.56125709212884}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(global_pcl, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_msg);\n\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(inflate_pcl, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 59.20223611668707}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Convert the global point cloud map to a ROS message\n    sensor_msgs::PointCloud2 global_map_msg;\n    pcl::toROSMsg(global_map, global_map_msg);\n    global_map_msg.header.frame_id = \"world\";\n    // Publish the global point cloud map\n    global_pcl_pub.publish(global_map_msg);\n\n    // Convert the inflated point cloud to a ROS message\n    sensor_msgs::PointCloud2 inflate_map_msg;\n    pcl::toROSMsg(inflate_map, inflate_map_msg);\n    inflate_map_msg.header.frame_id = \"world\";\n    // Publish the inflated point cloud\n    inflate_pcl_pub.publish(inflate_map_msg);\n}", "CodeBleu_score": 59.621433878807174}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (odom_ready) {\n    sensor_ready = true;\n  }\n  // update the global map\n  global_map.update_map(msg, odom);\n  // update the A* algorithm's map\n  astar_planner.update_map(global_map.get_map());\n}", "CodeBleu_score": 49.6380685304686}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    //ROS_INFO(\"PointCloud callback\");\n\n    if (odom_ready) {\n        sensor_ready = true;\n        //ROS_INFO(\"Odom ready\");\n    }\n\n    //ROS_INFO(\"Updating map\");\n    //ROS_INFO(\"PointCloud callback\");\n    //ROS_INFO(\"Updating map\");\n    a_star_ptr->update_map(msg);\n\n}", "CodeBleu_score": 46.4005928540985}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (odom_ready) {\n        sensor_ready = true;\n        // update A* map\n        astar_path_planner.updateMap(msg, odom);\n    }\n}", "CodeBleu_score": 49.05391133990581}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Calculate target foot positions based on desired pose\n    body_controller_->controlLoop();\n\n    // Compute velocity commands for legs\n    for (int i = 0; i < 4; i++) {\n        leg_controllers_[i]->controlLoop();\n    }\n\n    // Perform inverse kinematics to determine target joint positions\n    for (int i = 0; i < 4; i++) {\n        leg_controllers_[i]->inverseKinematics();\n    }\n\n    // Publish foot contact information\n    for (int i = 0; i < 4; i++) {\n        leg_controllers_[i]->publishFootContact();\n    }\n\n    // Publish joint positions\n    for (int i = 0; i < 4; i++) {\n        leg_controllers_[i]->publishJointPositions();\n    }\n}", "CodeBleu_score": 36.08356260215586}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Update body pose\n    body_controller_.updateBodyPose();\n\n    // Calculate target foot positions\n    Eigen::Matrix<double, 3, 4> target_foot_positions = body_controller_.calculateTargetFootPositions();\n\n    // Calculate velocity commands for the legs\n    Eigen::Matrix<double, 3, 4> leg_velocity_commands = body_controller_.calculateLegVelocityCommands(target_foot_positions);\n\n    // Perform inverse kinematics to determine target joint positions\n    Eigen::Matrix<double, 3, 4> target_joint_positions = kinematics_.inverseKinematics(target_foot_positions, leg_velocity_commands);\n\n    // Publish foot contact information\n    publishFootContactInfo();\n\n    // Publish joint positions\n    publishJointPositions(target_joint_positions);\n}", "CodeBleu_score": 51.704459299584705}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Calculate target foot positions based on desired pose\n    body_controller_.calculateFootPositions(desired_pose_, target_foot_positions_);\n\n    // Compute velocity commands for legs\n    for (int i = 0; i < 4; i++) {\n        leg_controllers_[i].computeVelocityCommand(target_foot_positions_[i], target_joint_velocities_[i]);\n    }\n\n    // Perform inverse kinematics to determine target joint positions\n    for (int i = 0; i < 4; i++) {\n        leg_controllers_[i].computeJointAngles(target_foot_positions_[i], target_joint_positions_[i]);\n    }\n\n    // Publish foot contact information\n    for (int i = 0; i < 4; i++) {\n        std_msgs::Bool msg;\n        msg.data = leg_controllers_[i].isFootContact();\n        foot_contact_publishers_[i].publish(msg);\n    }\n\n    // Publish joint positions\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 3; j++) {\n            std_msgs::Float64 msg;\n            msg.data = target_joint_positions_[i][j];\n            joint_position_publishers_[i][j].publish(msg);\n        }\n    }\n}", "CodeBleu_score": 48.04875346868527}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t    if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n        quadruped_msgs::ContactsStamped msg;\n        msg.header.stamp = ros::Time::now();\n        msg.header.frame_id = \"base_link\";\n        msg.contacts[0] = foot_contacts[0];\n        msg.contacts[1] = foot_contacts[1];\n        msg.contacts[2] = foot_contacts[2];\n        msg.contacts[3] = foot_contacts[3];\n        foot_contacts_publisher_.publish(msg);\n    }\n}", "CodeBleu_score": 46.220460737246924}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contact_publishing_enabled_) {\n    if (not gazebo_simulation_) {\n      // Create a ContactsStamped message\n      std_msgs::Bool foot_contacts_msg;\n      foot_contacts_msg.data = foot_contacts[0] && foot_contacts[1] && foot_contacts[2] && foot_contacts[3];\n\n      // Publish the message\n      foot_contacts_publisher_.publish(foot_contacts_msg);\n    }\n  }\n}", "CodeBleu_score": 40.55424939044659}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  // Create a ContactsStamped message\n  quadruped_msgs::ContactsStamped contacts_msg;\n  contacts_msg.header.stamp = ros::Time::now();\n\n  // Populate the message with the current gait phase of each leg\n  for (int i = 0; i < 4; i++) {\n    quadruped_msgs::Contact contact_msg;\n    contact_msg.contact = foot_contacts[i];\n    contacts_msg.contacts.push_back(contact_msg);\n  }\n\n  // Publish the message\n  foot_contacts_publisher_.publish(contacts_msg);\n}", "CodeBleu_score": 55.69517255118356}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    joints_msg = Joints()\n    joints_msg.position = joints.position[:12]\n    self.joints_pub.publish(joints_msg)\n\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[:12]\n    point.time_from_start = rospy.Duration(0.1)\n    joint_trajectory.points.append(point)\n    self.joint_trajectory_pub.publish(joint_trajectory)\n\n", "CodeBleu_score": 45.980627456420024}, {"code": "def joints_cmd_callback(self, joints){\n\t    joints_msg = Joints()\n    joints_msg.joints = joints.position[:12]\n    self.joints_pub.publish(joints_msg)\n\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.joint_names = joints.name[:12]\n    joint_trajectory.points = [JointTrajectoryPoint()]\n    joint_trajectory.points[0].positions = joints.position[:12]\n    joint_trajectory.points[0].time_from_start = rospy.Duration(1.0)\n    self.joint_trajectory_pub.publish(joint_trajectory)\n\n", "CodeBleu_score": 38.936660631129264}, {"code": "def joints_cmd_callback(self, joints){\n\t    joints_msg = Joints()\n    joints_msg.joints = joints.position[:12]\n    self.joints_pub.publish(joints_msg)\n\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.joint_names = joints.name[:12]\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[:12]\n    point.time_from_start = rospy.Duration(0.5)\n    joint_trajectory.points.append(point)\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 45.67441291448937}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    std::vector<std::string> contacts;\n    for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n        contacts.push_back(_msg->contact(i).collision1());\n        contacts.push_back(_msg->contact(i).collision2());\n    }\n\n    for (unsigned int i = 0; i < contacts.size(); ++i) {\n        std::vector<std::string> strs;\n        boost::split(strs, contacts[i], boost::is_any_of(\"::\"));\n        if (strs[0] == \"hip_l\" || strs[0] == \"hip_r\" || strs[0] == \"thigh_l\" || strs[0] == \"thigh_r\" || strs[0] == \"calf_l\" || strs[0] == \"calf_r\" || strs[0] == \"foot_l\" || strs[0] == \"foot_r\") {\n            champ_msgs::ContactsStamped contacts_msg;\n            contacts_msg.header.stamp = ros::Time::now();\n            contacts_msg.contacts.push_back(strs[0]);\n            contacts_msg.states.push_back(true);\n            contacts_pub_.publish(contacts_msg);\n        }\n    }\n}", "CodeBleu_score": 41.92427437999417}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n        std::string collision1 = _msg->contact(i).collision1();\n        std::string collision2 = _msg->contact(i).collision2();\n        std::vector<std::string> collisions1;\n        std::vector<std::string> collisions2;\n        boost::split(collisions1, collision1, boost::is_any_of(\"::\"));\n        boost::split(collisions2, collision2, boost::is_any_of(\"::\"));\n        std::string link1 = collisions1[0];\n        std::string link2 = collisions2[0];\n\n        if (link1 == \"l_sole\" || link2 == \"l_sole\") {\n            std::cout << \"Left foot contact\" << std::endl;\n        }\n        if (link1 == \"r_sole\" || link2 == \"r_sole\") {\n            std::cout << \"Right foot contact\" << std::endl;\n        }\n    }\n}", "CodeBleu_score": 42.460321978697365}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  for (int i = 0; i < 4; i++) {\n    foot_contact_state_[i] = false;\n  }\n  for (int i = 0; i < _msg->contact_size(); ++i) {\n    std::vector<std::string> strs;\n    boost::split(strs, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n    std::string link_name = strs[0];\n    if (link_name == \"FL_foot\") {\n      foot_contact_state_[0] = true;\n    }\n    if (link_name == \"FR_foot\") {\n      foot_contact_state_[1] = true;\n    }\n    if (link_name == \"RL_foot\") {\n      foot_contact_state_[2] = true;\n    }\n    if (link_name == \"RR_foot\") {\n      foot_contact_state_[3] = true;\n    }\n  }\n}", "CodeBleu_score": 55.47961917311054}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(rotor_count_);\n  if (!active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::VectorXd angular_acceleration_thrust;\n  angular_acceleration_thrust.resize(3);\n  angular_acceleration_thrust << angular_acceleration, thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 81.43689807017363}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 99.77937154959373}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 99.77937154959373}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration != nullptr);\n\n  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  // Transform the velocity to the world frame.\n  const Eigen::Vector3d velocity_W =\n      vehicle_state_.orientation_W_B.conjugate() * vehicle_state_.velocity_B;\n\n  ComputePositionError(&position_error, &velocity_error);\n\n  Eigen::Vector3d gravity_W = Eigen::Vector3d::Zero();\n  // \u8ba1\u7b97\u91cd\u529b\u65b9\u5411\n  ComputeGravityInWorldFrame(&gravity_W);\n\n  Eigen::Vector3d total_desired_acceleration = Eigen::Vector3d::Zero();\n  ComputeDesiredAcceleration(position_error, velocity_error, gravity_W,\n                             &total_desired_acceleration);\n\n  *acceleration = total_desired_acceleration;\n}", "CodeBleu_score": 46.68425988017406}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration != nullptr);\n\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position_W;\n\n  // Transform velocity to world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - command_trajectory_.velocity_W;\n\n  Eigen::Vector3d acc_des;\n  acc_des = position_gain_.cwiseProduct(position_error) +\n            velocity_gain_.cwiseProduct(velocity_error) +\n            Eigen::Vector3d(0, 0, -gravity_) + command_trajectory_.acceleration_W;\n  *acceleration = acc_des;\n}", "CodeBleu_score": 73.16769067557958}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration != nullptr);\n\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position -\n                    trajectory_point_.position;\n\n  // Transform velocity to world frame.\n  const Eigen::Vector3d velocity_W =\n      odometry_.orientation * odometry_.velocity;\n\n  // Compute velocity error.\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - trajectory_point_.velocity;\n\n  Eigen::Vector3d acc_desired;\n  acc_desired = position_gain_.cwiseProduct(position_error) +\n                velocity_gain_.cwiseProduct(velocity_error) +\n                inertia_gain_.cwiseProduct(acceleration_W_);\n\n  *acceleration = acc_desired;\n}", "CodeBleu_score": 56.10173571937616}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_);\n\n  rotor_velocities->resize(rotor_count_);\n  // Return 0 velocities on all rotors, until the first command is received.\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 75.30789432261416}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_);\n\n  rotor_velocities->resize(rotor_count_);\n  // Return 0 velocities on all rotors, until the first command is received.\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  angular_acceleration = acceleration / vehicle_parameters_.mass_;\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 75.06535104968694}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(rotor_count_);\n  // Return 0 velocities on all rotors, until the first command is received.\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 75.87358314476405}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_closest_index(start_time)\n    end_index = self.get_closest_index(end_time)\n    new_obj = copy.deepcopy(self)\n    for key in new_obj.__dict__.keys():\n        if isinstance(new_obj.__dict__[key], TimeSeries):\n            new_obj.__dict__[key].timestamps = new_obj.__dict__[key].timestamps[start_index:end_index]\n            new_obj.__dict__[key].values = new_obj.__dict__[key].values[start_index:end_index]\n    return new_obj\n\n", "CodeBleu_score": 39.98722353657963}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices corresponding to the start and end times\n    start_index = self.get_closest_index(start_time)\n    end_index = self.get_closest_index(end_time)\n\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Slice each attribute of the copied object\n    for attr in vars(sliced_object):\n        if isinstance(getattr(sliced_object, attr), list):\n            setattr(sliced_object, attr, getattr(sliced_object, attr)[start_index:end_index])\n\n    return sliced_object\n\n", "CodeBleu_score": 27.662114410812432}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_closest_index(start_time)\n    end_index = self.get_closest_index(end_time)\n    sliced_obj = copy.deepcopy(self)\n    sliced_obj.update_attributes(start_index, end_index)\n    return sliced_obj\n\n", "CodeBleu_score": 22.7221427138717}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    _, _, yaw = tf.transformations.euler_from_quaternion((rotation.x, rotation.y, rotation.z, rotation.w))\n    point = Point(position.x, position.y, position.z)\n\n    if len(self.waypoints) == 0 or (self.waypoints[-1].x != point.x and self.waypoints[-1].y != point.y and self.yaw[-1] != yaw):\n        self.waypoints.append(point)\n        self.yaw.append(yaw)\n        self.waypoint_times.append(msg_time)\n        self.waypoint_bag_times.append(bag_time)\n\n", "CodeBleu_score": 26.206757061448098}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    (roll, pitch, yaw) = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    point = Point(position.x, position.y, position.z)\n    if len(self.waypoints) == 0 or self.waypoints[-1].x != point.x or self.waypoints[-1].y != point.y or self.yaw[-1] != yaw:\n        self.waypoints.append(point)\n        self.yaw.append(yaw)\n        self.time.append(msg_time)\n        self.bag_time.append(bag_time)\n\n", "CodeBleu_score": 26.015293821076778}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.position\n    quat = waypoint_msg.pose.orientation\n    roll, pitch, yaw = tf.transformations.euler_from_quaternion(\n        [quat.x, quat.y, quat.z, quat.w])\n    point = Point(position.x, position.y, position.z)\n    if (len(self.waypoints) == 0) or (\n            (self.waypoints[-1].x != point.x) or (self.waypoints[-1].y != point.y) or (self.yaw[-1] != yaw)):\n        self.waypoints.append(point)\n        self.yaw.append(yaw)\n        self.waypoint_times.append(msg_time)\n        self.waypoint_bag_times.append(bag_time)\n\n", "CodeBleu_score": 28.16629497327095}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_time_bag.append(bag_time)\n        self.imu_ax.append(msg.linear_acceleration.x)\n        self.imu_ay.append(msg.linear_acceleration.y)\n        self.imu_az.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.05023442836023}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.imu_time_bag.append(bag_time)\n        self.imu_x.append(msg.linear_acceleration.x)\n        self.imu_y.append(msg.linear_acceleration.y)\n        self.imu_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.331719181952415}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_x_accel.append(msg.linear_acceleration.x)\n        self.imu_y_accel.append(msg.linear_acceleration.y)\n        self.imu_z_accel.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.398686883066656}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle('Accelerations')\n    ax = fig.add_subplot(111)\n    for i, accel_data in enumerate(self.accelerations):\n        ax.plot(accel_data.time, accel_data.x, label='X' + str(i))\n        ax.plot(accel_data.time, accel_data.y, label='Y' + str(i))\n        ax.plot(accel_data.time, accel_data.z, label='Z' + str(i))\n    ax.set_xlabel('Time')\n    ax.set_ylabel('Acceleration')\n    ax.legend()\n    if self.save_plots:\n        filename = 'accelerations'\n        if plot_suffix is not None:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 42.17694820319407}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle('Accelerations')\n    ax = fig.add_subplot(111)\n    for i in range(len(self.accelerations)):\n        ax.plot(self.accelerations[i].x, label='x' + str(i))\n        ax.plot(self.accelerations[i].y, label='y' + str(i))\n        ax.plot(self.accelerations[i].z, label='z' + str(i))\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    ax.legend()\n    if self.save_plots:\n        filename = 'accelerations'\n        if plot_suffix is not None:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        fig.savefig(filename)\n\n", "CodeBleu_score": 42.31125536045722}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Set up the plot\n    figure = pyplot.figure()\n    figure.suptitle(\"Accelerations\")\n    axes = figure.add_subplot()\n\n    # Plot the x, y, and z components of the accelerations\n    axes.plot(self.accelerations[:, 0], label=\"x\")\n    axes.plot(self.accelerations[:, 1], label=\"y\")\n    axes.plot(self.accelerations[:, 2], label=\"z\")\n\n    # Add labels and a legend\n    axes.set_xlabel(\"Time (s)\")\n    axes.set_ylabel(\"Acceleration (m/s^2)\")\n    axes.legend()\n\n    # Save the plot\n    if self.save_plots:\n        filename = \"accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        figure.savefig(filename + \".png\")\n\n", "CodeBleu_score": 31.790502024351724}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"You must provide at least two pose indeces to compare.\")\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 39.81577266152966}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Must provide at least two pose indeces to compare positions.\")\n        return\n\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 43.26948350315525}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"At least two pose indeces are required to perform comparisons.\")\n        return\n\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 43.267248808827674}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision_time in self.wrench:\n        if start_time is not None and collision_time < start_time:\n            continue\n        if end_time is not None and collision_time > end_time:\n            continue\n        collision_times.append(collision_time)\n    return collision_times\n\n", "CodeBleu_score": 39.426292227103005}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision_time in self.wrench.keys():\n        if start_time is not None and collision_time < start_time:\n            continue\n        if end_time is not None and collision_time > end_time:\n            continue\n        collision_times.append(collision_time)\n    return collision_times\n", "CodeBleu_score": 43.295540664718246}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    # Calculate the absolute settling time by adding the settling time to the start time\n    absolute_settling_time = start_time + settling_time\n    # Call analyze_bag.plot_angular_velocities with the specified start time, end time, settling time, x-axis range, plot suffix, and a fixed y-axis range of [-1.5, 1.5]\n    analyze_bag.plot_angular_velocities(\n        start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 35.28137792029307}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 30.087936187511037}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    # Calculate the absolute settling time\n    absolute_settling_time = start_time + settling_time\n\n    # Call plot_angular_velocities with the specified parameters\n    analyze_bag.plot_angular_velocities(\n        start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 35.28137792029307}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == NULL) {\n    return;\n  }\n\n  double multiplier =\n      1.0 / (this->depth_camera_baseline_ * this->depth_camera_focal_length_);\n\n  Eigen::Map<Eigen::VectorXf> data_vector(data, width * height, 1);\n\n  // Compute the RMS noise\n  double rms_noise = this->depth_camera_noise_factor_ * multiplier;\n\n  // Compute the noise values\n  std::normal_distribution<double> distribution(0.0, rms_noise);\n  std::vector<double> noise_values(width * height);\n  for (auto &noise_value : noise_values) {\n    noise_value = distribution(this->random_generator_);\n  }\n\n  // Add noise to the data\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_vector(i) > 0.0) {\n      data_vector(i) += noise_values[i];\n    } else {\n      data_vector(i) = this->bad_point_;\n    }\n  }\n}", "CodeBleu_score": 48.787985336914616}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) return;\n\n  const float multiplier =\n      (this->focalLength_ / this->baseline_) * this->depthScale_;\n\n  Eigen::Map<Eigen::VectorXf> data_map(data, width * height, 1);\n\n  const float rms_noise = this->rmsDepthNoise_ * multiplier;\n  const float noise_offset = this->depthNoiseOffset_ * multiplier;\n\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_map[i] > 0.0f) {\n      const float rnd_val = (2.0f * ((float)rand() / (float)RAND_MAX)) - 1.0f;\n      const float noise = rms_noise * rnd_val + noise_offset;\n      data_map[i] += noise;\n      if (data_map[i] < 0.0f) data_map[i] = 0.0f;\n    } else {\n      data_map[i] = this->badPoint_;\n    }\n  }\n}", "CodeBleu_score": 49.38404370199752}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (!data) {\n    return;\n  }\n\n  const float multiplier =\n      (this->params_.k1_ * this->params_.k2_) /\n      ((this->params_.k1_ - this->params_.k2_) *\n       (this->params_.k1_ + this->params_.k2_));\n\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  const float rms_noise =\n      this->params_.strength_ * multiplier * this->params_.k1_ *\n      this->params_.baseline_ *\n      this->params_.focal_length_ * this->params_.focal_length_ /\n      (this->params_.k2_ - this->params_.k1_) /\n      (this->params_.k2_ - this->params_.k1_) /\n      (this->params_.k2_ * this->params_.k2_ - this->params_.k1_ * this->params_.k1_);\n\n  const float noise_offset =\n      this->params_.strength_ * multiplier * this->params_.k1_ *\n      this->params_.baseline_ * this->params_.focal_length_ *\n      this->params_.focal_length_ / (this->params_.k2_ - this->params_.k1_) /\n      (this->params_.k2_ - this->params_.k1_) /\n      (this->params_.k2_ * this->params_.k2_ - this->params_.k1_ * this->params_.k1_);\n\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (data_vec(i) >= this->params_.min_range_ &&\n        data_vec(i) <= this->params_.max_range_) {\n      data_vec(i) +=\n          rms_noise * this->gaussian_distribution_(this->generator_) +\n          noise_offset;\n    } else {\n      data_vec", "CodeBleu_score": 38.23476963007184}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  if (trajectory_msg->points.size() > 0) {\n    // Get the current simulation time\n    ros::Time now = ros::Time::now();\n    // Convert the simulation time to ROS time\n    ros::Time ros_time = ros::Time(now.sec, now.nsec);\n    // Write the trajectory message to the bag file\n    bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n  }\n}", "CodeBleu_score": 63.54575211902736}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  if (trajectory_msg->points.size() > 0) {\n    double sim_time = trajectory_msg->points[0].time_from_start.toSec();\n    ros::Time time_stamp = ros::Time::now() - ros::Duration(sim_time);\n    std::string topic = namespace_ + \"/waypoint\";\n    bag_.write(topic, time_stamp, *trajectory_msg);\n  }\n}", "CodeBleu_score": 43.40032699615423}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  if (trajectory_msg->points.size() == 0) {\n    ROS_WARN_STREAM(\"Received empty waypoint message. Not logging.\");\n    return;\n  }\n\n  const ros::Time current_time = ros::Time::now();\n  const std::string ns = GetNamespace();\n\n  mav_msgs::EigenTrajectoryPoint::Vector flat_states;\n  mav_msgs::msgMultiDofJointTrajectoryToEigenTrajectoryPointVector(*trajectory_msg, &flat_states);\n  const mav_msgs::EigenTrajectoryPoint goal_point = flat_states.back();\n\n  const double sampling_time = trajectory_msg->points.front().time_from_start.toSec();\n  const double distance = (goal_point.position_W - trajectory_msg->points.front().transforms.front().translation()).norm();\n  const double speed = distance / sampling_time;\n\n  mav_planning_msgs::PolynomialTrajectory4D::Ptr polynomial_msg(\n      new mav_planning_msgs::PolynomialTrajectory4D());\n  mav_trajectory_generation::trajectoryToPolynomialTrajectoryMsg(trajectory_msg,\n                                                                  polynomial_msg);\n  bag_ptr_->write(ns + \"/polynomial_trajectory\", current_time, *polynomial_msg);\n\n  bag_ptr_->write(ns + \"/waypoint_topic\", current_time, *trajectory_msg);\n  bag_ptr_->write(ns + \"/speed\", current_time, speed);\n}", "CodeBleu_score": 42.61124928057195}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time time = ros::Time::now();\n\n  // Prepare a message for actuator velocities\n  mav_msgs::Actuators msg;\n  msg.header.stamp = time;\n\n  // Iterate through the motor joints\n  for (unsigned int i = 0; i < joints_.size(); ++i) {\n    // Get the current rotational velocity\n    double velocity = joints_[i]->GetVelocity(0);\n\n    // Calculate the slowed-down velocity\n    double slowed_down_velocity = velocity * 0.9;\n\n    // Assign the slowed-down velocity to the message\n    msg.angular_velocities.push_back(slowed_down_velocity);\n  }\n\n  // Write the message to the bag file\n  bag_.write(namespace_ + \"/\" + motor_topic_, time, msg);\n}", "CodeBleu_score": 41.82386312712056}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  ros::Time time = ros::Time::now();\n\n  mav_msgs::Actuators msg;\n  msg.header.stamp = time;\n  msg.angular_velocities.resize(rotor_joints_.size());\n\n  for (unsigned int i = 0; i < rotor_joints_.size(); ++i) {\n    msg.angular_velocities[i] = rotor_joints_[i]->GetVelocity(0) * kFrequency_;\n  }\n\n  motor_velocity_bag_.write(namespace_ + motor_topic_, time, msg);\n}", "CodeBleu_score": 42.225890392332595}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time time;\n  time.sec = now.sec;\n  time.nsec = now.nsec;\n\n  // Prepare a message for the actuator velocities\n  mav_msgs::ActuatorsPtr actuator_velocities_msg(new mav_msgs::Actuators);\n\n  // Iterate through the motor joints\n  for (int i = 0; i < joints_.size(); i++) {\n    // Calculate the slowed-down rotational velocity\n    double velocity = joints_[i]->GetVelocity(0) * motor_velocity_reference_ / max_rotor_velocity_;\n\n    // Assign the slowed-down velocity to the message\n    actuator_velocities_msg->angular_velocities.push_back(velocity);\n  }\n\n  // Set the message timestamp\n  actuator_velocities_msg->header.stamp = time;\n\n  // Write the message to a bag file\n  bag_.write(namespace_ + motor_topic_, time, *actuator_velocities_msg);\n}", "CodeBleu_score": 44.082531891526756}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // convert normalized input values to control surface angles\n  double aileron_angle = (roll_pitch_yawrate_thrust_msg->roll() - 0.5) * max_aileron_angle_;\n  double elevator_angle = (roll_pitch_yawrate_thrust_msg->pitch() - 0.5) * max_elevator_angle_;\n  double rudder_angle = (roll_pitch_yawrate_thrust_msg->yaw_rate() - 0.5) * max_rudder_angle_;\n\n  // set the throttle value\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // set the control surface angles and throttle values\n  joints_[\"aileron_left\"]->SetParam(\"vel\", 0, aileron_angle);\n  joints_[\"aileron_right\"]->SetParam(\"vel\", 0, -aileron_angle);\n  joints_[\"elevator\"]->SetParam(\"vel\", 0, elevator_angle);\n  joints_[\"rudder\"]->SetParam(\"vel\", 0, rudder_angle);\n  joints_[\"propeller_left\"]->SetParam(\"vel\", 0, throttle);\n  joints_[\"propeller_right\"]->SetParam(\"vel\", 0, throttle);\n}", "CodeBleu_score": 43.33984051858065}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  // If debug printing is enabled, log that the callback was called\n  if (debug_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively\n  double ailerons = (roll_pitch_yawrate_thrust_msg->roll() - 0.5) * max_aileron_deflection_;\n  double elevator = (roll_pitch_yawrate_thrust_msg->pitch() - 0.5) * max_elevator_deflection_;\n  double rudder = (roll_pitch_yawrate_thrust_msg->yaw_rate() - 0.5) * max_rudder_deflection_;\n\n  // Set the throttle value from the thrust message\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // If debug printing is enabled, log the control surface angles and throttle value\n  if (debug_) {\n    gzdbg << \"ailerons: \" << ailerons << std::endl;\n    gzdbg << \"elevator: \" << elevator << std::endl;\n    gzdbg << \"rudder: \" << rudder << std::endl;\n    gzdbg << \"throttle: \" << throttle << std::endl;\n  }\n\n  // Set the control surface angles and throttle value in the model\n  model_->SetJointPosition(joints_[0], ailerons);\n  model_->SetJointPosition(joints_[1], elevator);\n  model_->SetJointPosition(joints_[2], rudder);\n  model_->SetJointPosition(joints_[3], throttle);\n}", "CodeBleu_score": 53.41751123863045}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called.\" << std::endl;\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to\n  // control surface angles for ailerons, elevator, and rudder respectively.\n  ctrl_surf_deflection_[0] =\n      roll_pitch_yawrate_thrust_msg->roll() * max_ctrl_surf_deflection_[0];\n  ctrl_surf_deflection_[1] =\n      roll_pitch_yawrate_thrust_msg->pitch() * max_ctrl_surf_deflection_[1];\n  ctrl_surf_deflection_[2] =\n      roll_pitch_yawrate_thrust_msg->yaw_rate() * max_ctrl_surf_deflection_[2];\n\n  // Set the throttle value from the thrust message.\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 46.34027310902796}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  if (!_dt) {\n    return;\n  }\n\n  timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  fd_set read_fds;\n  FD_ZERO(&read_fds);\n  FD_SET(fd_, &read_fds);\n\n  int ret = select(fd_ + 1, &read_fds, NULL, NULL, &timeout);\n  if (ret < 0) {\n    return;\n  }\n\n  if (ret == 0) {\n    return;\n  }\n\n  if (!FD_ISSET(fd_, &read_fds)) {\n    return;\n  }\n\n  uint8_t buf[MAVLINK_MAX_PACKET_LEN];\n  int nread = read(fd_, buf, MAVLINK_MAX_PACKET_LEN);\n  if (nread <= 0) {\n    return;\n  }\n\n  mavlink_message_t msg;\n  mavlink_status_t status;\n  for (int i = 0; i < nread; i++) {\n    if (mavlink_parse_char(MAVLINK_COMM_1, buf[i], &msg, &status)) {\n      if (mavlink_get_msg_id_info(&msg, &info_)) {\n        if (info_.crc_extra) {\n          if (mavlink_check_payload_crc(&msg, &status)) {\n            handleMessage(&msg);\n          }\n        } else {\n          handleMessage(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 51.85491231762469}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  if (serial_port_quit) {\n    // this happens when the serial port is closed\n    // (for example, when gazebo shuts down)\n    return;\n  }\n\n  if (serial_port_fd < 0) {\n    // this happens when the serial port is not open\n    // (for example, when gazebo starts up)\n    return;\n  }\n\n  // poll for MAVLink messages\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(serial_port_fd, &readfds);\n\n  int ret = select(serial_port_fd + 1, &readfds, NULL, NULL, &timeout);\n\n  if (ret < 0) {\n    // this happens when the serial port is closed\n    // (for example, when gazebo shuts down)\n    return;\n  }\n\n  if (ret == 0) {\n    // this happens when the serial port times out\n    // (for example, when the serial port is not open)\n    return;\n  }\n\n  // data is available\n  if (FD_ISSET(serial_port_fd, &readfds)) {\n    // read data from serial port\n    int bytes_read = read(serial_port_fd, rx_buf, sizeof(rx_buf));\n\n    if (bytes_read < 0) {\n      // this happens when the serial port is closed\n      // (for example, when gazebo shuts down)\n      return;\n    }\n\n    // parse MAVLink messages from buffer\n    for (int i = 0; i < bytes_read; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, rx_buf[i], &rx_msg, &rx_status)) {\n        // forward message to serial connection\n        if (serial_conn != nullptr) {\n          serial_conn->send_message(&rx", "CodeBleu_score": 53.75284478099695}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // poll for MAVLink messages\n  if (use_serial_) {\n    // get current time\n    struct timeval timeout;\n    timeout.tv_sec = 0;\n    timeout.tv_usec = _timeoutMs * 1000;\n\n    // poll for data\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(fd_, &readfds);\n    int ret = select(fd_ + 1, &readfds, NULL, NULL, &timeout);\n\n    // check for received data\n    if (ret > 0 && FD_ISSET(fd_, &readfds)) {\n      // receive data\n      int len = read(fd_, buf_, sizeof(buf_));\n      if (len > 0) {\n        // parse all MAVLink messages in buffer\n        for (unsigned int i = 0; i < len; ++i) {\n          // Try to get a new message\n          mavlink_message_t message;\n          mavlink_status_t status;\n\n          // Handle MAVLink2 and MAVLink1\n          if (protocol_version_ == MAVLINK_VERSION::MAVLINK_V2) {\n            // message received is mavlink2\n            // the status will remain the same\n            mavlink_message_t *msg_ptr = mavlink_comm_receive_ch(&mavlink_comm_,\n                                                                  (uint8_t *)&buf_[i], 1, &message,\n                                                                  &status);\n\n            // check for null pointer\n            if (msg_ptr) {\n              // handle message\n              handle_mavlink_message(&message);\n            }\n          } else {\n            // message received is mavlink1\n            // the status will be modified\n            uint8_t msgReceived = mavlink_parse_char(MAVLINK_COMM_0, buf_[i],\n                                                     &message, &status);\n\n            // check for received message\n            if (msgReceived) {\n              // handle message\n              handle_mavlink_message(&message);\n            }\n          }\n        }\n      }\n   ", "CodeBleu_score": 51.49410575065908}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t  if(io_service_.stopped())\n    return;\n  mutex::scoped_lock lock(mutex_);\n  io_service_.stop();\n  if(port_) {\n    port_->close();\n    port_.reset();\n  }\n  if(io_thread_.joinable())\n    io_thread_.join();\n  io_service_.reset();\n  if (open_) {\n    open_ = false;\n  }\n}", "CodeBleu_score": 56.70390121921295}, {"code": "void GazeboMavlinkInterface::close() {\n\t    boost::mutex::scoped_lock lock(mutex); // Locks thread\n    if (serial_dev->is_open()) {\n        io_service.stop(); // Stops I/O service\n        serial_dev->close(); // Closes serial device\n        if (io_thread.joinable()) io_thread.join(); // Joins thread\n    }\n}", "CodeBleu_score": 54.42036523578923}, {"code": "void GazeboMavlinkInterface::close() {\n\t    // This prevents a race condition when the serial device is closed while the I/O thread is waiting for data to be read.\n    std::lock_guard<std::mutex> lock(mutex);\n\n    // Check if the interface is open.\n    if (is_open()) {\n        // Stop the I/O service.\n        io_service.stop();\n\n        // Close the serial device.\n        serial_dev->close();\n\n        // If the I/O thread is joinable, join it to clean up resources.\n        if (io_thread.joinable()) {\n            io_thread.join();\n        }\n    }\n}", "CodeBleu_score": 59.250468231105714}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    (ignition::math::Vector3d p1, ignition::math::Vector3d p2, double x, double x1, double x2, double y1, double y2, double z1, double z2)\n    {\n        ignition::math::Vector3d p;\n        double lambda;\n        if (x2 - x1 == 0)\n        {\n            lambda = 0;\n        }\n        else\n        {\n            lambda = (x - x1) / (x2 - x1);\n        }\n        p.X() = (1 - lambda) * p1.X() + lambda * p2.X();\n        p.Y() = (1 - lambda) * y1 + lambda * y2;\n        p.Z() = (1 - lambda) * z1 + lambda * z2;\n        return p;\n    }\n}", "CodeBleu_score": 28.19594141839385}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    ignition::math::Vector3d pos1,\n    ignition::math::Vector3d pos2,\n    ignition::math::Vector3d val1,\n    ignition::math::Vector3d val2,\n    ignition::math::Vector3d pos\n}", "CodeBleu_score": 17.41680617718859}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    ignition::math::Vector3d position,\n    ignition::math::Vector3d point1,\n    ignition::math::Vector3d point2,\n    ignition::math::Vector3d value1,\n    ignition::math::Vector3d value2\n}", "CodeBleu_score": 18.87882850553076}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t  if (_time != this->timePos) {\n    this->timePos = _time;\n\n    if (this->timePos < 0.0) {\n      this->timePos = 0.0;\n    } else if (this->timePos > this->length) {\n      this->timePos = this->length;\n    }\n  }\n}", "CodeBleu_score": 57.69179693924201}, {"code": "void Animation::SetTime(double _time){\n\t\n\n\n    // If the new time is different from the current time, update the time position\n\n    if (_time != this->timePos) {\n\n        this->timePos = _time;\n\n\n\n        // If looping is enabled, wrap the time within the animation length\n\n        if (this->length > 0.0 && this->loop) {\n\n            this->timePos = fmod(this->timePos, this->length);\n\n            if (this->timePos < 0) {\n\n                this->timePos += this->length;\n\n            }\n\n        }\n\n        // If looping is disabled, clamp the time between 0 and the animation length\n\n        else {\n\n            this->timePos = std::max(this->timePos, 0.0);\n\n            this->timePos = std::min(this->timePos, this->length);\n\n        }\n\n    }\n\n}", "CodeBleu_score": 69.74634115636617}, {"code": "void Animation::SetTime(double _time){\n\t  if (_time != this->timePos) {\n    this->timePos = _time;\n    if (this->length > 0.0) {\n      while (this->timePos > this->length && this->loop)\n        this->timePos -= this->length;\n      while (this->timePos < 0 && this->loop)\n        this->timePos += this->length;\n    }\n    this->timePos = std::max(this->timePos, 0.0);\n    this->timePos = std::min(this->timePos, this->length);\n  }\n}", "CodeBleu_score": 63.05791591794876}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    target_motion = PositionTarget()\n    target_motion.coordinate_frame = 1\n    target_motion.type_mask = 0\n    target_motion.position.x = self.current_pose.pose.position.x\n    target_motion.position.y = self.current_pose.pose.position.y\n    target_motion.position.z = self.current_pose.pose.position.z\n    target_motion.yaw = self.current_yaw\n    self.target_motion_pub.publish(target_motion)\n    print(\"Vehicle Type:\", self.vehicle_type, \"ID:\", self.vehicle_id, \"Flight Mode:\", self.flight_mode)\n\n", "CodeBleu_score": 24.029730976470475}, {"code": "def hover(self)\n\t\n    self.target_motion.coordinate_frame = 1\n    self.target_motion.type_mask = 0\n    self.target_motion.position.x = self.current_position.x\n    self.target_motion.position.y = self.current_position.y\n    self.target_motion.position.z = self.current_position.z\n    self.target_motion.yaw = self.current_yaw\n    print(f\"Vehicle type: {self.vehicle_type}\")\n    print(f\"Vehicle ID: {self.vehicle_id}\")\n    print(f\"Flight mode: {self.flight_mode}\")\n\n", "CodeBleu_score": 31.542345499931802}, {"code": "def hover(self)\n\t\n    target_motion = PoseStamped()\n    target_motion.pose.position.x = self.current_pose.pose.position.x\n    target_motion.pose.position.y = self.current_pose.pose.position.y\n    target_motion.pose.position.z = self.current_pose.pose.position.z\n    target_motion.pose.orientation.x = self.current_pose.pose.orientation.x\n    target_motion.pose.orientation.y = self.current_pose.pose.orientation.y\n    target_motion.pose.orientation.z = self.current_pose.pose.orientation.z\n    target_motion.pose.orientation.w = self.current_pose.pose.orientation.w\n    self.target_motion_pub.publish(target_motion)\n    self.flight_mode = \"Hover\"\n    print(\"Vehicle Type: \" + str(self.vehicle_type))\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: \" + str(self.flight_mode))\n\n", "CodeBleu_score": 21.522693928921097}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hoverFlag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy(\n                \"/mavros/set_mode\", SetMode\n            )\n            flightModeService(0, self.flightMode)\n            print(\"Flight mode changed to \" + self.flightMode)\n            return True\n        except rospy.ServiceException:\n            print(\"Failed to change flight mode\")\n            return False\n\n", "CodeBleu_score": 44.516282307705744}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hover()\n        self.hover_flag = 1\n        return True\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy(\n                \"/mavros/set_mode\", SetMode\n            )\n            isModeChanged = flightModeService(\n                custom_mode=self.flightMode\n            )\n            if isModeChanged.mode_sent:\n                rospy.loginfo(\n                    f\"{self.vehicle_name}: Flight mode changed to {self.flightMode}\"\n                )\n                return True\n            else:\n                rospy.loginfo(\n                    f\"{self.vehicle_name}: Failed to change flight mode to {self.flightMode}\"\n                )\n                return False\n        except rospy.ServiceException as e:\n            rospy.loginfo(\n                f\"{self.vehicle_name}: Failed to change flight mode to {self.flightMode}: {e}\"\n            )\n            return False\n\n", "CodeBleu_score": 34.05603702547661}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hoverFlag = 1\n        self.hover()\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy(\n                \"/mavros/set_mode\", SetMode\n            )\n            flightModeService(custom_mode=self.flightMode)\n            print(f\"Successfully switched to {self.flightMode} mode\")\n            return True\n        except rospy.ServiceException as e:\n            print(f\"Failed to switch to {self.flightMode} mode: {e}\")\n            return False\n\n", "CodeBleu_score": 45.22066628765094}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z]\n\n", "CodeBleu_score": 48.89892543127967}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == False:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == False and self.hold_flag == False:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z]\n\n", "CodeBleu_score": 53.010924523317094}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z]\n\n", "CodeBleu_score": 48.89892543127967}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n\n    if (\n        abs(x) > 0.02\n        or abs(y) > 0.02\n        or abs(z) > 0.02\n        or abs(w) > 0.005\n    ):\n        self.hover_flag = 0\n        if self.flight_mode != \"OFFBOARD\":\n            self.set_mode(\"OFFBOARD\")\n            self.hover_flag = 1\n            self.hover_action()\n    else:\n        self.hover_flag = 1\n        if self.flight_mode != \"HOVER\":\n            self.set_mode(\"HOVER\")\n            self.hover_flag = 1\n            self.hover_action()\n\n", "CodeBleu_score": 49.61370235093931}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (\n        (abs(x) > 0.02)\n        or (abs(y) > 0.02)\n        or (abs(z) > 0.02)\n        or (abs(w) > 0.005)\n    ):\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n        return\n    if self.flight_mode != \"HOVER\":\n        self.hover_flag = 1\n        self.set_mode(\"HOVER\")\n        self.hover_action()\n\n", "CodeBleu_score": 44.15062894726396}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005) and self.flight_mode != \"HOVER\":\n        self.hover_flag = 0\n        self.set_flight_mode(\"OFFBOARD\")\n    elif self.flight_mode != \"HOVER\" and self.hover_flag == 0:\n        self.hover_flag = 1\n        self.set_flight_mode(\"HOVER\")\n        self.hover_action()\n\n", "CodeBleu_score": 49.788511264972435}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if not isinstance(q, Quaternion):\n        q = Quaternion(q.w, q.x, q.y, q.z)\n    return q.yaw_pitch_roll[0]\n\n", "CodeBleu_score": 41.62202682799502}, {"code": "def q2yaw(self, q)\n\t\n    if not isinstance(q, Quaternion):\n        q = Quaternion(q.w, q.x, q.y, q.z)\n    return q.yaw_pitch_roll[0]\n\n", "CodeBleu_score": 41.62202682799502}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        rotate_z_rad = q.angle\n    else:\n        assert q.shape == (4,)\n        rotate_z_rad = Quaternion(q[0], q[1], q[2], q[3]).angle\n    return rotate_z_rad\n\n", "CodeBleu_score": 48.394258717036955}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.frame = \"LOCAL_NED\"\n    self.motion_type = \"hover\"\n    self.target_motion = PoseStamped()\n    self.target_motion.pose.position.x = self.current_position.pose.position.x\n    self.target_motion.pose.position.y = self.current_position.pose.position.y\n    self.target_motion.pose.position.z = self.current_position.pose.position.z\n    self.target_motion.pose.orientation.x = self.current_position.pose.orientation.x\n    self.target_motion.pose.orientation.y = self.current_position.pose.orientation.y\n    self.target_motion.pose.orientation.z = self.current_position.pose.orientation.z\n    self.target_motion.pose.orientation.w = self.current_position.pose.orientation.w\n    print(self.vehicle_type, self.vehicle_id, \"hovering\")\n\n", "CodeBleu_score": 15.083891709521074}, {"code": "def hover(self)\n\t\n    self.update_frame()\n    self.motion_type = \"hover\"\n    self.target_motion = PoseStamped()\n    self.target_motion.pose.position.x = self.current_position.x\n    self.target_motion.pose.position.y = self.current_position.y\n    self.target_motion.pose.position.z = self.current_position.z\n    self.target_motion.pose.orientation = self.current_orientation\n    print(f\"{self.vehicle_type} {self.vehicle_id} is in {self.flight_mode} mode.\")\n\n", "CodeBleu_score": 18.991014109155014}, {"code": "def hover(self)\n\t\n    self.update_coordinate_frame()\n    self.motion_type = \"hover\"\n    self.target_motion = PoseStamped()\n    self.target_motion.pose.position.x = self.current_position.x\n    self.target_motion.pose.position.y = self.current_position.y\n    self.target_motion.pose.position.z = self.current_position.z\n    self.target_motion.pose.orientation = self.current_orientation\n    print(\"Vehicle Type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight Mode: \", self.flight_mode)\n\n", "CodeBleu_score": 25.684641323764247}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy(\n                \"/mavros/set_mode\", SetMode\n            )\n            isModeChanged = flightModeService(\n                custom_mode=self.flight_mode\n            )\n        except rospy.ServiceException as e:\n            print(\n                \"setmode error: {0}\".format(e)\n            )\n        if isModeChanged.mode_sent:\n            print(\"Flight mode changed to {0}\".format(self.flight_mode))\n            return True\n        else:\n            print(\"Failed to change flight mode\")\n            return False\n\n", "CodeBleu_score": 26.92998516942149}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hoverFlag = True\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy(\n                \"/mavros/set_mode\", SetMode\n            )\n            flightModeService(custom_mode=self.flightMode)\n            print(\"Switched to flight mode:\", self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            print(\n                \"Failed to switch to flight mode:\", self.flightMode, \"Error:\", e\n            )\n            return False\n\n", "CodeBleu_score": 42.67889938181536}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hover_flag = True\n        self.hover()\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy(\n                \"/mavros/set_mode\", SetMode\n            )\n            isModeChanged = flightModeService(\n                custom_mode=self.flightMode\n            )\n        except rospy.ServiceException as e:\n            print(\n                \"Failed to switch flight mode: %s\" % (e)\n            )\n            return False\n\n        if isModeChanged.mode_sent:\n            print(\n                \"Flight mode changed to %s\" % (self.flightMode)\n            )\n            return True\n        else:\n            print(\"Failed to switch flight mode\")\n            return False\n\n", "CodeBleu_score": 25.81449093325111}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == \"base_link\":\n        if msg.header.seq == i:\n            self.local_pose = msg\n            self.global_pose.pose.position.x = msg.pose.position.x + self.bias[0]\n            self.global_pose.pose.position.y = msg.pose.position.y + self.bias[1]\n            self.global_pose.pose.position.z = msg.pose.position.z + self.bias[2]\n\n            if self.takeoff_command:\n                self.takeoff_target_pose.pose.position.x = msg.pose.position.x + self.bias[0]\n                self.takeoff_target_pose.pose.position.y = msg.pose.position.y + self.bias[1]\n                self.takeoff_target_pose.pose.position.z = msg.pose.position.z + self.bias[2]\n\n            if self.hover_command:\n                self.hover_target_pose.pose.position.x = msg.pose.position.x + self.bias[0]\n                self.hover_target_pose.pose.position.y = msg.pose.position.y + self.bias[1]\n                self.hover_target_pose.pose.position.z = msg.pose.position.z + self.bias[2]\n\n", "CodeBleu_score": 21.403441064096658}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == \"world\":\n        if msg.header.seq == self.uav_id:\n            self.local_pose = msg\n            self.global_pose = msg\n            self.global_pose.pose.position.x += self.bias_x\n            self.global_pose.pose.position.y += self.bias_y\n            self.global_pose.pose.position.z += self.bias_z\n            if self.takeoff_command:\n                self.takeoff_target_pose = msg\n            if self.hover_command:\n                self.hover_target_pose = msg\n\n", "CodeBleu_score": 24.65624458833212}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == \"fcu_\" + str(i):\n        self.local_pose[i] = msg\n        self.global_pose[i] = msg\n        self.global_pose[i].pose.position.x += self.bias_x\n        self.global_pose[i].pose.position.y += self.bias_y\n        self.global_pose[i].pose.position.z += self.bias_z\n\n        if self.takeoff_command == \"takeoff\":\n            self.takeoff_target_pose[i] = copy.deepcopy(self.local_pose[i])\n            self.takeoff_target_pose[i].pose.position.z = self.takeoff_altitude\n\n        if self.hover_command == \"hover\":\n            self.hover_target_pose[i] = copy.deepcopy(self.local_pose[i])\n            self.hover_target_pose[i].pose.position.z = self.hover_altitude\n\n", "CodeBleu_score": 30.438495689950884}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.mode == \"OFFBOARD\" and self.local_pose.pose.position.z > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 66.40237708934488}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.mode == \"OFFBOARD\" and self.local_position.pose.position.z > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 65.00987353939092}, {"code": "def takeoff_detection(self)\n\t\n    if self.current_state.armed and self.current_pose.pose.position.z > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 59.30347763450481}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate pairwise distances between UAVs in the original formation\n    distances_orig = numpy.linalg.norm(orig_formation - orig_formation[:, numpy.newaxis], axis=-1)\n    # Calculate pairwise distances between UAVs in the changed formation\n    distances_change = numpy.linalg.norm(change_formation - change_formation[:, numpy.newaxis], axis=-1)\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    distances_orig = numpy.rint(50 - distances_orig).astype(int)\n    distances_change = numpy.rint(50 - distances_change).astype(int)\n    # Build the distance matrix\n    distance_matrix = numpy.maximum(distances_orig, distances_change)\n    return distance_matrix\n\n", "CodeBleu_score": 17.41090983823964}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = numpy.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            distance_matrix[i, j] = int(50 - numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j])))\n    return distance_matrix\n", "CodeBleu_score": 27.423439777564184}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i][j] = int(50 - numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j])))\n    return distance_matrix\n", "CodeBleu_score": 29.56220688200975}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    visited[i] = True\n    for j in range(self.n):\n        if visited[self.n + j]:\n            continue\n        gap = self.labels[i] + self.labels[self.n + j] - self.cost[i][j]\n        if gap == 0:\n            visited[self.n + j] = True\n            if self.match[j] == -1 or self.find_path(self.match[j]):\n                self.match[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n", "CodeBleu_score": 44.084557196317974}, {"code": "def find_path(self, i)\n\t\n    visited_left[i] = True\n    for j in range(self.n_right):\n        if visited_right[j]:\n            continue\n        gap = self.left_labels[i] + self.right_labels[j] - self.cost[i][j]\n        if gap == 0:\n            visited_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_left[i] = j\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n", "CodeBleu_score": 51.13686799544743}, {"code": "def find_path(self, i)\n\t\n    visited_left[i] = True\n    for j in range(self.num_right):\n        if visited_right[j]:\n            continue\n        gap = self.left_labels[i] + self.right_labels[j] - self.weights[i][j]\n        if gap == 0:\n            visited_right[j] = True\n            if self.right_matching[j] == -1 or self.find_path(self, self.right_matching[j]):\n                self.left_matching[i] = j\n                self.right_matching[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n\n", "CodeBleu_score": 44.61433049060418}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    for i in range(self.num_uav):\n        slack = [float('inf')] * self.num_uav\n        slack_x = [0] * self.num_uav\n        slack_y = [0] * self.num_uav\n        vx = [0] * self.num_uav\n        vy = [0] * self.num_uav\n        match = [-1] * self.num_uav\n\n        while True:\n            vx = [False] * self.num_uav\n            vy = [False] * self.num_uav\n            if self.find_path(i, match, vx, vy, slack):\n                break\n            d = float('inf')\n            for j in range(self.num_uav):\n                if not vy[j]:\n                    d = min(d, slack[j])\n            for j in range(self.num_uav):\n                if vx[j]:\n                    slack[j] -= d\n            for j in range(self.num_uav):\n                if vy[j]:\n                    slack[j] += d\n                else:\n                    slack[j] -= d\n                slack_x[j] += d\n                slack_y[j] -= d\n\n        for j in range(self.num_uav):\n            if match[j] != -1:\n                self.match_result[match[j]] = j\n\n    return self.match_result\n", "CodeBleu_score": 28.689342106367622}, {"code": "def KM(self)\n\t\n    n = len(self.uav_pos)\n    m = len(self.task_pos)\n    # Initialize slack variables\n    slack = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            slack[i][j] = self.dist(self.uav_pos[i], self.task_pos[j])\n    # Initialize visit arrays\n    u_visit = [False] * n\n    v_visit = [False] * m\n    # Initialize match arrays\n    u_match = [-1] * n\n    v_match = [-1] * m\n    # Iterate over UAVs\n    for i in range(n):\n        # Reset visit arrays\n        for j in range(n):\n            u_visit[j] = False\n        for j in range(m):\n            v_visit[j] = False\n        # Find augmenting path\n        while True:\n            # Find minimum slack value\n            delta = float('inf')\n            for j in range(m):\n                if not v_visit[j]:\n                    delta = min(delta, slack[i][j])\n            # Adjust labels\n            for j in range(n):\n                if u_visit[j]:\n                    u_match[j] -= delta\n            for j in range(m):\n                if v_visit[j]:\n                    v_match[j] += delta\n                else:\n                    slack[j] -= delta\n            # Find next vertex\n            j = -1\n            for k in range(m):\n                if not v_visit[k] and slack[i][k] == 0:\n                    j = k\n                    break\n            # Augment path found\n            if j != -1:\n                v_visit[j] = True\n                if v_match[j] == -1:\n                    u_match[i] = j\n                    return v_match\n                else:\n                    u_visit[v_match[j]] = True\n                    q = v_match[j]\n                    v_match[j] = i", "CodeBleu_score": 26.394697887787956}, {"code": "def KM(self)\n\t\n    # Initialize variables\n    UAV_num = self.UAV_num\n    UAV_num_max = self.UAV_num_max\n    UAV_num_min = self.UAV_num_min\n    UAV_num_max_copy = UAV_num_max\n    UAV_num_min_copy = UAV_num_min\n    UAV_num_max_copy_1 = UAV_num_max\n    UAV_num_min_copy_1 = UAV_num_min\n    UAV_num_max_copy_2 = UAV_num_max\n    UAV_num_min_copy_2 = UAV_num_min\n    UAV_num_max_copy_3 = UAV_num_max\n    UAV_num_min_copy_3 = UAV_num_min\n    UAV_num_max_copy_4 = UAV_num_max\n    UAV_num_min_copy_4 = UAV_num_min\n    UAV_num_max_copy_5 = UAV_num_max\n    UAV_num_min_copy_5 = UAV_num_min\n    UAV_num_max_copy_6 = UAV_num_max\n    UAV_num_min_copy_6 = UAV_num_min\n    UAV_num_max_copy_7 = UAV_num_max\n    UAV_num_min_copy_7 = UAV_num_min\n    UAV_num_max_copy_8 = UAV_num_max\n    UAV_num_min_copy_8 = UAV_num_min\n    UAV_num_max_copy_9 = UAV_num_max\n    UAV_num_min_copy_9 = UAV_num_min\n    UAV_num_max_copy_10 = UAV_num_max\n    UAV_num_min_copy_10 = UAV_num_min\n    UAV_num_max_copy_11 = UAV_num_max\n    UAV_num_min_copy_11 = UAV_num_min\n    U", "CodeBleu_score": 4.953975270069822}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds of the yellow color in HSV\n    lower_yellow = (20, 100, 100)\n    upper_yellow = (30, 255, 255)\n\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n", "CodeBleu_score": 46.45006548587249}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = (20, 100, 100)\n    upper_yellow = (30, 255, 255)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 46.45006548587249}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = (20, 100, 100)\n    upper_yellow = (30, 255, 255)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 46.45006548587249}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t    const auto& it = standalone_tag_descriptions_.find(tag_id);\n    if (it == standalone_tag_descriptions_.end()) {\n        if (print_warning) {\n            ROS_WARN(\"Tag ID %d not found in standalone tags\", tag_id);\n        }\n        return false;\n    }\n\n    descriptionContainer = it->second;\n    return true;\n}", "CodeBleu_score": 39.072544330364664}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    // Check if the standalone_tag_descriptions_ map contains the given ID\n    if (standalone_tag_descriptions_.find(id) != standalone_tag_descriptions_.end()) {\n        // If found, set the descriptionContainer to the tag's description\n        descriptionContainer = standalone_tag_descriptions_[id];\n        return true;\n    } else {\n        // If not found, log a warning message if printWarning is true\n        if (printWarning) {\n            ROS_WARN_STREAM(\"Tag ID \" << id << \" not found in standalone_tag_descriptions_ map\");\n        }\n        return false;\n    }\n}", "CodeBleu_score": 33.64130319130489}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    if (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n        if (printWarning) {\n            ROS_WARN(\"Tag description ID %d not found\", id);\n        }\n        return false;\n    }\n\n    descriptionContainer = standalone_tag_descriptions_[id];\n    return true;\n}", "CodeBleu_score": 33.885228347653225}]}
