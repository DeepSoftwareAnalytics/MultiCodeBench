{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tauto &client = GetClient();\n\tauto response = client.GetRequiredFiles(folder, download);\n\tif (response.error.empty()) {\n\t\treturn response.files;\n\t} else {\n\t\tthrow_exception(std::runtime_error, response.error);\n\t}\n}", "CodeBleu_score": 31.505114953564007}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> required_files;\n\tstd::string folder_path = folder;\n\tif (folder_path.back()!= '/') {\n\t\tfolder_path += '/';\n\t}\n\tconst std::string folder_path_with_version = folder_path + GetVersion() + '/';\n\tconst std::string folder_path_without_version = folder_path + \"latest/\";\n\ttry {\n\t\tconst std::vector<std::string> files_with_version = Call(\"get_required_files\", folder_path_with_version);\n\t\tfor (const auto &file : files_with_version) {\n\t\t\tif (download) {\n\t\t\t\tconst std::string full_path = folder_path_with_version + file;\n\t\t\t\tif (FileTransfer::Exists(full_path)) {\n\t\t\t\t\tLOG_INFO_S << \"File found in cache: \" << full_path;\n\t\t\t\t} else {\n\t\t\t\t\tLOG_INFO_S << \"Downloading file: \" << full_path;\n\t\t\t\t\tFileTransfer::Download(full_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\trequired_files.emplace_back(folder_path_with_version + file);\n\t\t}\n\t} catch (const std::exception &) {\n\t\t// ignore\n\t}\n\ttry {\n\t\tconst std::vector<std::string> files_without_version = Call(\"get_required_files\", folder_path_without_version);\n\t\tfor (const auto &file : files_without_version) {\n\t\t\tif (download) {\n\t\t\t\tconst std::string full_path = folder_path_without_version + file;\n\t\t\t\tif (FileTransfer::Exists(full_path)) {\n\t\t\t\t\tLOG_INFO_S << \"File found in cache: \" << full_path;\n\t\t\t\t} else {\n\t\t\t\t\tLOG_INFO_S << \"Downloading file: \" << full_path;\n\t\t\t\t\tFileTransfer::Download(full_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\trequired_files.emplace_back(folder_path_without_version + file);\n\t\t}\n\t} catch (const std::exception &) {\n\t\t// ignore\n\t}\n\treturn required_files;\n}", "CodeBleu_score": 45.92904549455934}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\treturn Call(\"GetRequiredFiles\", folder, download);\n}", "CodeBleu_score": 20.866076007956107}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  CARLA_CHECK_WITH_MESSAGE(\n      false,\n      \"Client::SpawnActorWithParent is not available in UE4 builds\");\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f && transform.location.z!= 0.0f) {\n      log_warning(\"Client::SpawnActorWithParent: SpringArm and SpringArmGhost attachment types require a translation in the 'x' and 'y' axes, but the provided transform only has a translation in the 'z' axis. The actor will be spawned with an ill-formed transform.\");\n    }\n  }\n  return _SpawnActor(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 45.02588356421505}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  check_rpc(false);\n#else // LIBCARLA_INCLUDED_FROM_UE4\n  check_rpc(true);\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0 && transform.location.y == 0) {\n      log_warning(\"Client::SpawnActorWithParent\", \"SpringArm/SpringArmGhost attachment type requires a non-zero translation in the 'x' and 'y' axes.\");\n    }\n  }\n  return SpawnActorInternal(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 45.1287299446419}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  check_client_is_ready();\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f && transform.location.z!= 0.0f) {\n      log_warning(\"Warning: the translation of the transform is only in the 'z' axis. This is not a valid transformation for a SpringArm or SpringArmGhost attachment type.\");\n    }\n  }\n  return SpawnActorWithParent_internal(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 45.325543134556064}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  if (ActorId.IsNull()) {\n    UE_LOG(LogCarla, Error, TEXT(\"Client::SubscribeToGBuffer: ActorId is null.\"));\n    return;\n  }\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n  rpc::GBufferToken token;\n  try {\n    token = Call(\"get_gbuffer_token\", ActorId, GBufferId);\n  } catch (const std::exception &e) {\n    throw_exception(rpc::Error::GBufferTokenError, e.what());\n  }\n  // Copy the token data to a local buffer.\n  Buffer buffer(token.Data.size());\n  std::memcpy(buffer.data(), token.Data.data(), buffer.size());\n  // Subscribe to the streaming client using the provided callback.\n  streaming_client->SubscribeToGBuffer(buffer, callback);\n}", "CodeBleu_score": 44.29396459697848}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n//\n//\n//\n  // If the client is not connected, throw an exception.\n  if (!IsConnected()) {\n    throw_exception(rpc::RPCError::kClientError, \"Client not connected\");\n  }\n//\n//\n//\n  // Get the G-buffer token for the given actor id and g-buffer id.\n  auto token = Call(\"get_g_buffer_token\", ActorId, GBufferId);\n  // Copy the token data.\n  auto token_data = token.Get(0).Get(0).Get<std::vector<uint8_t>>();\n  // Subscribe to the streaming client using the provided callback function.\n  streaming_client->SubscribeToGBuffer(token_data, callback);\n}", "CodeBleu_score": 45.641373029502475}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  CARLA_LOG_ERROR(\"This function is not supported in UE4.\");\n#else // LIBCARLA_INCLUDED_FROM_UE4\n  if (!IsConnected()) {\n    throw_exception(rpc::error::ClientError, \"Not connected to server.\");\n  }\n\n  // Retrieve the token for the G-buffer.\n  rpc::GBufferToken token = Call(\"get_gbuffer_token\", ActorId, GBufferId);\n  // Copy the token data.\n  std::vector<uint8_t> token_data(token.data.begin(), token.data.end());\n  // Subscribe to the streaming client using the provided callback function.\n  streaming_client->SubscribeToGBuffer(token_data, callback);\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n}", "CodeBleu_score": 42.16197194614456}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (walker_navigation == nullptr) {\n\t\tdo {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\t} while (walker_navigation == nullptr);\n\t}\n\treturn walker_navigation;\n}", "CodeBleu_score": 28.60316436183511}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (walker_navigation == nullptr) {\n\t\twhile (walker_navigation == nullptr) {\n\t\t\ttry {\n\t\t\t\twalker_navigation = std::make_shared<WalkerNavigation>(shared_from_this());\n\t\t\t} catch (const std::exception &e) {\n\t\t\t\tlog_error(\"Episode::CreateNavigationIfMissing:\", e.what());\n\t\t\t}\n\t\t}\n\t}\n\treturn walker_navigation;\n}", "CodeBleu_score": 42.61578803081542}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (!this->walker_navigation) {\n\t\tthis->walker_navigation = std::make_shared<WalkerNavigation>();\n\t}\n\treturn this->walker_navigation;\n}", "CodeBleu_score": 15.191264970659757}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = std::chrono::steady_clock::now();\n\twhile (episode.GetCurrentFrame() < frame) {\n\t\tif (std::chrono::steady_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 35.0048403220502}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t#ifdef LIBCARLA_NO_EXCEPTIONS\n  try {\n#endif // LIBCARLA_NO_EXCEPTIONS\n    auto timeout_point = std::chrono::steady_clock::now() + timeout;\n    while (episode.GetFrame() < frame) {\n      if (timeout_point <= std::chrono::steady_clock::now()) {\n        return false;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n    episode.Tick();\n    return true;\n#ifdef LIBCARLA_NO_EXCEPTIONS\n  } catch (const std::exception &e) {\n    log_error(\"Error while synchronizing frame:\", e.what());\n    return false;\n  }\n#endif // LIBCARLA_NO_EXCEPTIONS\n}", "CodeBleu_score": 34.54760469868004}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto timeout_time = std::chrono::steady_clock::now() + timeout;\n\twhile (episode.GetFrame() < frame) {\n\t\tif (std::chrono::steady_clock::now() > timeout_time) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.TickTrafficManager();\n\treturn true;\n}", "CodeBleu_score": 33.68690904834835}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tusing namespace carla::rpc;\n\n\t// Check if the simulator is connected\n\tif (!IsConnected()) {\n\t\tthrow_exception(std::runtime_error(\"Simulator is not connected\"));\n\t}\n\n\t// Check if the map name is valid\n\tif (map_name.empty()) {\n\t\tthrow_exception(std::runtime_error(\"Invalid map name\"));\n\t}\n\n\t// Check if the map layers are valid\n\tif (map_layers == MapLayer::None) {\n\t\tthrow_exception(std::runtime_error(\"Invalid map layers\"));\n\t}\n\n\t// Check if the reset settings are valid\n\tif (reset_settings) {\n\t\tif (GetEpisodeSettings().map_name!= map_name) {\n\t\t\tthrow_exception(std::runtime_error(\"Invalid reset settings\"));\n\t\t}\n\t}\n\n\t// Send the request\n\tauto request_id = _client->SendLoadEpisode(map_name, reset_settings, map_layers);\n\n\t// Wait for the response\n\tauto response = _client->PollResponse<ResponseLoadEpisode>(request_id, _timeout);\n\n\t// Check the response\n\tif (response.error) {\n\t\tthrow_exception(std::runtime_error(response.error_message));\n\t}\n\n\t// Check if the episode ID has changed\n\tif (_episode_id!= response.episode_id) {\n\t\t// Update the episode ID\n\t\t_episode_id = response.episode_id;\n\n\t\t// Update the episode settings\n\t\t_episode_settings = response.settings;\n\n\t\t// Update the episode state\n\t\t_episode_state = response.state;\n\n\t\t// Update the episode start time\n\t\t_episode_start_time = std::chrono::steady_clock::now();\n\n\t\t// Update the episode duration\n\t\t_episode_duration = std::chrono::milliseconds(response.settings.synchronous_mode.fixed_delta_seconds * 1000);\n\n\t\t// Update the episode timeout\n\t\t_episode_timeout = std::chrono::milliseconds(response.settings.synchronous_mode.timeout * 1000);\n\n\t\t// Update the episode timeout handler\n\t\t_episode_timeout_handler = response.settings.synchronous_mode.timeout_handler;\n\n\t\t// Update the episode weather parameters\n\t\t_episode", "CodeBleu_score": 41.39849748189754}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tDEBUG_ASSERT(map_name.size() > 0);\n\n\t// If the episode is already loaded, we have to unload it first.\n\tif (IsEpisodeLoaded()) {\n\t\tUnloadEpisode();\n\t}\n\n\t// Set the map name.\n\tSetMap(map_name);\n\n\t// Set the reset settings.\n\tSetResetSettings(reset_settings);\n\n\t// Set the map layers.\n\tSetMapLayers(map_layers);\n\n\t// Load the episode.\n\tLoad();\n\n\t// Wait for the episode to be loaded.\n\tauto attempts = 100u;\n\twhile (attempts > 0 && GetEpisodeId() == 0u) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\tattempts--;\n\t}\n\n\t// Check if the episode was loaded.\n\tif (GetEpisodeId() == 0u) {\n\t\tthrow_exception(TimeoutException(\"Failed to load episode.\"));\n\t}\n\n\t// Return the episode.\n\treturn EpisodeProxy(this, GetEpisodeId());\n}", "CodeBleu_score": 33.068443058972754}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\t// Check if the episode is already loaded.\n\tif (IsEpisodeLoaded()) {\n\t\tthrow_exception(std::runtime_error(\"Episode is already loaded.\"));\n\t}\n\n\t// Load episode.\n\trpc::EpisodeSettings settings;\n\tsettings.set_map_name(map_name);\n\tsettings.set_reset_settings(reset_settings);\n\tsettings.set_map_layers(map_layers);\n\tauto episode_id = LoadEpisode(settings);\n\n\t// Wait for the episode to be loaded.\n\tauto episode_proxy = GetEpisode(episode_id);\n\tauto timeout = std::chrono::system_clock::now() + std::chrono::seconds(10);\n\twhile (episode_proxy.GetId()!= episode_id) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\tepisode_proxy = GetEpisode(episode_id);\n\t\tif (std::chrono::system_clock::now() > timeout) {\n\t\t\tthrow_exception(TimeoutException(\"Failed to connect to the new episode.\"));\n\t\t}\n\t}\n\n\t// Return the episode object.\n\treturn episode_proxy;\n}", "CodeBleu_score": 48.3106526291155}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Retrieve the walker associated with the controller.\n\tauto walker = GetWalkerById(controller.GetWalkerId());\n\tif (!walker) {\n\t\tthrow_exception(std::runtime_error(\"Walker not found.\"));\n\t}\n\n\t// Assert that the episode is not null.\n\tassert(_episode!= nullptr);\n\n\t// Create navigation if it is missing.\n\tif (_episode->GetWalkerNavigation() == nullptr) {\n\t\t_episode->SetWalkerNavigation(std::make_shared<detail::WalkerNavigation>(GetEpisode()));\n\t}\n\n\t// Register the walker with the controller's ID.\n\t_episode->GetWalkerNavigation()->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 50.29539988119778}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  checkf(Episode.IsValid(), TEXT(\"Episode is null\"));\n#else // LIBCARLA_INCLUDED_FROM_UE4\n  assert(Episode!= nullptr);\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n  auto walker = Episode->GetWalker(controller.GetActorId());\n  if (!walker) {\n    throw_exception(std::runtime_error(\"Walker not found\"));\n  }\n  auto &navigation = Episode->GetNavigation();\n  navigation.Register(walker, controller.GetActorId());\n}", "CodeBleu_score": 52.2118714593385}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tauto walker = GetActor(controller.GetActorId());\n\tif (!walker.IsValid()) {\n\t\tthrow_exception(std::runtime_error(\"Walker not found.\"));\n\t}\n\tassert(episode_!= nullptr);\n\tif (!episode_->GetNavigation()) {\n\t\tepisode_->SetNavigation(std::make_shared<detail::WalkerNavigation>(episode_));\n\t}\n\tepisode_->GetNavigation()->RegisterWalker(walker, controller.GetId());\n}", "CodeBleu_score": 49.728531028805186}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  check(IsInGameThread());", "CodeBleu_score": 9.041840241603314}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  CARLA_CHECK_WITH_MESSAGE(\n      parent!= nullptr,\n      \"Cannot spawn actor as a child of a null actor.\");\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n\n  auto actor_id = Call(\"world.spawn_actor\",\n      blueprint.id,\n      transform,\n      parent == nullptr? 0u : parent->GetId(),\n      static_cast<uint8_t>(attachment_type),\n      static_cast<uint8_t>(gc),\n      socket_name);\n\n  auto actor = MakeActor(actor_id, blueprint, transform);\n  if (parent!= nullptr) {\n    actor->SetParent(parent, attachment_type, socket_name);\n  }\n\n  RegisterActor(actor);\n\n  Log::Debug(\"Spawned actor '%s' with id %d.\", actor->GetDisplayId(), actor->GetId());\n\n  return actor;\n}", "CodeBleu_score": 45.71609147171878}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  checkf(parent == nullptr, TEXT(\"Spawning actors as children of other actors is not supported in Unreal Engine.\"));\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n\n  if (blueprint.IsChildActor()) {\n    log_error(\"Cannot spawn child actor \", blueprint.id, \" directly.\");\n    return nullptr;\n  }\n\n  if (parent!= nullptr &&!parent->IsChildActor()) {\n    log_error(\"Cannot spawn child actor \", blueprint.id, \" as child of actor \", parent->id, \".\");\n    return nullptr;\n  }\n\n  auto actor_id = _client->Call(\"world.spawn_actor\", blueprint.id, transform, parent == nullptr? -1 : parent->id, attachment_type, socket_name);\n\n  auto actor = _actor_factory->CreateActor(actor_id, blueprint.id);\n  _episode->RegisterActor(actor, gc);\n  log_info(\"Spawned actor \", actor->id, \" of type \", blueprint.id, \".\");\n  return actor;\n}", "CodeBleu_score": 39.57320736294696}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifdef LIBCARLA_WITH_OPENDRIVE\n  if (!episode) {\n    throw_exception(std::runtime_error(\"Simulator::SubscribeToSensor: episode not set\"));\n  }\n#endif // LIBCARLA_WITH_OPENDRIVE\n  auto client = episode->client;\n  auto stream = sensor.GetStream();\n  auto id = client->SubscribeToStream(stream);\n  client->SetTimeout(id, 1000000000000000000);\n  client->OnStreamDataReceived(\n      id,\n      [this, callback, id, client, sensor](const std::vector<uint8_t> &data) {\n        try {\n          auto episode = this->episode;\n          if (episode) {\n            auto stream = sensor.GetStream();\n            auto frame = episode->GetFrameNumber();\n            auto sensor_data = sensor::deserialize(stream, data, frame);\n            callback(sensor_data);\n          } else {\n            client->UnsubscribeFromStream(id);\n          }\n        } catch (const std::exception &e) {\n          client->UnsubscribeFromStream(id);\n          Log::Error(\"Sensor data stream error: \", e.what());\n        }\n      });\n}", "CodeBleu_score": 42.81463020808676}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  if (!episode) {\n    throw_exception(std::runtime_error(\"Simulator::SubscribeToSensor: Invalid episode.\"));\n  }\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n  auto stream_id = client->SubscribeToStream(sensor.GetStream(), sensor.GetStream().GetIdentifier());\n  auto callback_wrapper = [callback](const std::string &data) {\n    try {\n      auto sensor_data = sensor::Deserializer::Deserialize(data);\n      callback(sensor_data);\n    } catch (const std::exception &e) {\n      log_error(e.what());\n    }\n  };\n  client->SetStreamCallback(stream_id, callback_wrapper);\n}", "CodeBleu_score": 46.19299112154876}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifdef LIBCARLA_WITH_OPENDRIVE\n  if (IsEpisodeValid()) {\n    client->SubscribeToStream(sensor.GetId(), [this, callback](SharedPtr<Buffer> buffer) {\n      try {\n        auto data = sensor::Deserializer::Deserialize(buffer);\n        data->SetEpisode(episode);\n        callback(data);\n      } catch (const std::exception &e) {\n        log_error(\"Error deserializing sensor data: \", e.what());\n      }\n    });\n  }\n#else\n  throw_exception(std::runtime_error(\"This version of CARLA was compiled without OpenDRIVE support.\"));\n#endif // LIBCARLA_WITH_OPENDRIVE\n}", "CodeBleu_score": 42.86310153280579}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// Load walkers\n\tauto walkers = episode->GetWalkers();\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get episode state\n\tauto state = episode->GetState();\n\tif (state == EpisodeState::EpisodeState_Finished) {\n\t\treturn;\n\t}\n\n\t// Update walkers in crowd\n\tauto crowd = episode->GetCrowd();\n\tcrowd->Update(episode->GetSimulation());\n\n\t// Update crowd in navigation\n\tepisode->GetNavigation()->Update(crowd);\n\n\t// Update walkers\n\tstd::vector<rpc::WalkerControl> walker_controls;\n\twalker_controls.reserve(walkers.size());\n\tfor (auto walker : walkers) {\n\t\t// Get transform and speed\n\t\tauto transform = walker->GetTransform();\n\t\tauto speed = walker->GetSpeed();\n\t\twalker_controls.emplace_back(transform, speed);\n\t}\n\n\t// Apply walker controls\n\tepisode->GetSimulation()->ApplyWalkerControl(walker_controls);\n\n\t// Check if walker is dead\n\tfor (auto walker : walkers) {\n\t\tif (walker->IsDead()) {\n\t\t\t// Remove walker from crowd\n\t\t\tcrowd->RemoveAgent(walker->GetId());\n\t\t\t// Destroy walker controller\n\t\t\twalker->DestroyController();\n\t\t}\n\t}\n}", "CodeBleu_score": 37.836995879314756}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = episode->GetWalkers();\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\tauto state = episode->GetState();\n\tfor (auto &walker : walkers) {\n\t\tif (state.find(walker.first) == state.end()) {\n\t\t\twalkers.erase(walker.first);\n\t\t}\n\t}\n\tauto &crowd = episode->GetCrowd();\n\tcrowd.UpdateVehicles(walkers);\n\tcrowd.UpdateCrowd();\n\tstd::vector<rpc::WalkerControl> walker_controls;\n\tfor (auto &walker : walkers) {\n\t\tauto transform = walker.second.transform;\n\t\tauto speed = walker.second.speed;\n\t\twalker_controls.emplace_back(walker.first, transform, speed);\n\t}\n\tepisode->ApplyWalkerControl(walker_controls);\n\tfor (auto &walker : walkers) {\n\t\tif (walker.second.is_alive == false) {\n\t\t\tcrowd.RemoveVehicle(walker.first);\n\t\t\twalkers.erase(walker.first);\n\t\t\tepisode->DestroyWalkerController(walker.first);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.87507361938904}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = episode->GetWalkers();\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\tauto state = episode->GetState();\n\tfor (auto &walker : walkers) {\n\t\tif (state.find(walker) == state.end()) {\n\t\t\tepisode->RemoveWalker(walker);\n\t\t}\n\t}\n\n\tauto &nav = episode->GetNavigation();\n\tnav.UpdateCrowd(walkers);\n\tnav.UpdateCrowd();\n\n\tauto &sim = episode->GetSimulator();\n\tstd::vector<carla::rpc::Transform> transforms;\n\tstd::vector<float> speeds;\n\tfor (auto &walker : walkers) {\n\t\tauto transform = state[walker].transform;\n\t\tauto speed = state[walker].velocity.norm();\n\t\ttransforms.push_back(transform);\n\t\tspeeds.push_back(speed);\n\t}\n\tsim.ApplyWalkerBatch(transforms, speeds);\n\n\tfor (auto &walker : walkers) {\n\t\tif (state[walker].killed) {\n\t\t\tepisode->RemoveWalker(walker);\n\t\t\tif (walker->GetController()) {\n\t\t\t\twalker->DestroyController();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.42370192310487}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  if (UActorBlueprint::GetBlueprintClass() == nullptr) {\n    UE_LOG(LogCarla, Error, TEXT(\"ActorBlueprint::MakeActorDescription() - UActorBlueprint::GetBlueprintClass() == nullptr\"));\n    return rpc::ActorDescription();\n  }\n  auto *blueprint = UActorBlueprint::GetBlueprintClass();\n  auto *generated_class = blueprint->GetGeneratedClass();\n  if (generated_class == nullptr) {\n    UE_LOG(LogCarla, Error, TEXT(\"ActorBlueprint::MakeActorDescription() - generated_class == nullptr\"));\n    return rpc::ActorDescription();\n  }\n#else // LIBCARLA_INCLUDED_FROM_UE4\n  if (BlueprintClass == nullptr) {\n    log_error(\"ActorBlueprint::MakeActorDescription() - BlueprintClass == nullptr\");\n    return rpc::ActorDescription();\n  }\n  auto *blueprint = BlueprintClass;\n  auto *generated_class = blueprint->GetGeneratedClass();\n  if (generated_class == nullptr) {\n    log_error(\"ActorBlueprint::MakeActorDescription() - generated_class == nullptr\");\n    return rpc::ActorDescription();\n  }\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n\n  rpc::ActorDescription description;\n  description.id = GetId();\n  description.uid = GetUID();\n  description.attributes.reserve(GetAttributes().Num());\n  for (const auto &attribute : GetAttributes()) {\n    description.attributes.emplace_back(attribute.MakeAttributeDescription());\n  }\n  return description;\n}", "CodeBleu_score": 41.61182090419777}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_id(GetId());\n\tdescription.set_uid(GetUID());\n\tdescription.set_type(GetTag());\n\tdescription.set_parent_id(GetParentId());\n\tdescription.set_parent_type(GetParentTag());\n\tdescription.set_rolename(GetRoleName());\n\tdescription.set_rolename_alias(GetRoleNameAlias());\n\tdescription.set_rolename_color(GetRoleNameColor());\n\tdescription.set_rolename_prefix(GetRoleNamePrefix());\n\tdescription.set_rolename_suffix(GetRoleNameSuffix());\n\tdescription.set_rolename_suffix_color(GetRoleNameSuffixColor());\n\tdescription.set_rolename_suffix_alias(GetRoleNameSuffixAlias());\n\tdescription.set_rolename_suffix_alias_color(GetRoleNameSuffixAliasColor());\n\tdescription.set_rolename_suffix_alias_prefix(GetRoleNameSuffixAliasPrefix());\n\tdescription.set_rolename_suffix_alias_prefix_color(GetRoleNameSuffixAliasPrefixColor());\n\tdescription.set_rolename_suffix_alias_prefix_suffix(GetRoleNameSuffixAliasPrefixSuffix());\n\tdescription.set_rolename_suffix_alias_prefix_suffix_color(GetRoleNameSuffixAliasPrefixSuffixColor());\n\tdescription.set_rolename_suffix_alias_prefix_suffix_alias(GetRoleNameSuffixAliasPrefixSuffixAlias());\n\tdescription.set_rolename_suffix_alias_prefix_suffix_alias_color(GetRoleNameSuffixAliasPrefixSuffixAliasColor());\n\tdescription.set_rolename_suffix_alias_prefix_suffix_alias_prefix(GetRoleNameSuffixAliasPrefixSuffixAliasPrefix());\n\tdescription.set_rolename_suffix_alias_prefix_suffix_alias_prefix_color(GetRoleNameSuffixAliasPrefixSuffixAliasPrefixColor());\n\tdescription.set_rolename_suffix_alias_prefix_suffix_alias_prefix_suffix(GetRoleNameSuffixAliasPrefixSuffixAliasPrefixSuffix());\n\tdescription.set_rolename_suffix_alias_prefix_suffix_alias_prefix_suffix_color(GetRoleNameSuffixAliasPrefixSuffixAliasPrefixSuffixColor());\n\tdescription.set_rolename_suffix_alias_", "CodeBleu_score": 31.045113671400195}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  check(ActorId!= 0);\n#else // LIBCARLA_INCLUDED_FROM_UE4\n  CARLA_CHECK(ActorId!= 0);\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n  rpc::ActorDescription description;\n  description.id = ActorId;\n  description.type_id = GetId();\n  description.attributes.reserve(Attributes.size());\n  for (auto &&attribute : Attributes) {\n    description.attributes.push_back(attribute->MakeAttributeDescription());\n  }\n  return description;\n}", "CodeBleu_score": 51.3140987776339}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n//   SharedPtr<BlueprintLibrary> result(new BlueprintLibrary);\n//   for (const auto &bp : *this) {\n//     const auto &attr = bp.GetAttribute(name);\n//     if (attr.HasRecommendedValues()) {\n//       for (const auto &value_ : attr.GetRecommendedValues()) {\n//         if (value_ == value) {\n//           result->Append(bp);\n//           break;\n//         }\n//       }\n//     } else {\n//       if (attr.GetValue() == value) {\n//         result->Append(bp);\n//       }\n//     }\n//   }\n//   return result;\n  return nullptr;\n}", "CodeBleu_score": 7.9219290158571845}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  const auto &bp_library = GetMutableDefault<UCarlaBlueprintLibrary>();\n#else\n  const auto &bp_library = GetMutableDefault<carla::client::BlueprintLibrary>();\n#endif\n\n  SharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\n  for (auto &bp : bp_library) {\n    if (bp.HasAttribute(name)) {\n      const auto &attr = bp.GetAttribute(name);\n      if (attr.recommended_values.empty()) {\n        if (attr.value == value) {\n          result->Append(bp);\n        }\n      } else {\n        if (std::find(attr.recommended_values.begin(), attr.recommended_values.end(), value)!= attr.recommended_values.end()) {\n          result->Append(bp);\n        }\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 50.22990350758727}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  if (name.empty()) {\n    UE_LOG(LogCarla, Error, TEXT(\"Attribute name cannot be empty\"));\n    return SharedPtr<BlueprintLibrary>();\n  }\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n\n  SharedPtr<BlueprintLibrary> result(new BlueprintLibrary);\n  for (const auto &bp : *this) {\n    if (bp->HasAttribute(name)) {\n      auto bp_value = bp->GetAttribute(name);\n      if (bp_value == value) {\n        result->Append(bp);\n      } else {\n        auto bp_values = bp->GetAttributeRecommendedValues(name);\n        if (std::find(bp_values.begin(), bp_values.end(), value)!= bp_values.end()) {\n          result->Append(bp);\n        }\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 52.55110614733902}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = path;\n\tif (fullPath[0]!= '/') {\n\t\tfullPath = std::string(CARLA_VERSION_STR) + \"/\" + fullPath;\n\t}\n\tif (fullPath[0]!= '/') {\n\t\tfullPath = \"/tmp/carla/\" + fullPath;\n\t}\n\tif (fullPath[fullPath.size()-1]!= '/') {\n\t\tfullPath += \"/\";\n\t}\n\n\t// validate file path\n\tif (fullPath.find(\"..\")!= std::string::npos) {\n\t\treturn false;\n\t}\n\tif (fullPath.find(\"//\")!= std::string::npos) {\n\t\treturn false;\n\t}\n\n\t// open file\n\tFILE* file = fopen(fullPath.c_str(), \"wb\");\n\tif (file == nullptr) {\n\t\treturn false;\n\t}\n\n\t// write content\n\tfwrite(content.data(), sizeof(uint8_t), content.size(), file);\n\n\t// close file\n\tfclose(file);\n\n\treturn true;\n}", "CodeBleu_score": 46.94085178303643}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Construct the full file path using the base folder and version information\n\tstd::string fullPath = path + \"/carla-\" + CARLA_VERSION_STRING + path;\n\n\t// Validate the file path\n\tif (fullPath.empty()) {\n\t\treturn false;\n\t}\n\n\t// Open the file in binary mode to truncate its contents\n\tFILE *file = fopen(fullPath.c_str(), \"wb\");\n\n\t// Check if the file is successfully opened\n\tif (file == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Write the content to the file\n\tfwrite(content.data(), sizeof(uint8_t), content.size(), file);\n\n\t// Close the file\n\tfclose(file);\n\n\t// Return true if the file is successfully written\n\treturn true;\n}", "CodeBleu_score": 36.298304379648854}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Construct the full file path\n\tstd::string filePath = path;\n\tif (filePath.find(\"~\") == 0) {\n\t\tfilePath.erase(0, 1);\n\t\tfilePath = std::string(getenv(\"HOME\")) + filePath;\n\t}\n\tfilePath = filePath + \"/\" + CARLA_VERSION_STR + \"/\" + CARLA_VERSION_STR + \".carla.cache\";\n\t// Validate the file path\n\tif (filePath.find(\"..\")!= std::string::npos) {\n\t\tstd::cout << \"Invalid path\" << std::endl;\n\t\treturn false;\n\t}\n\t// Open the file in binary mode to truncate its contents\n\tFILE* file = fopen(filePath.c_str(), \"wb\");\n\tif (file == nullptr) {\n\t\tstd::cout << \"Failed to open file\" << std::endl;\n\t\treturn false;\n\t}\n\t// Write the content and close the file\n\tfwrite(content.data(), sizeof(uint8_t), content.size(), file);\n\tfclose(file);\n\treturn true;\n}", "CodeBleu_score": 44.47773253831918}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\t// This is the location of the bounding box.\n\tconst auto location = transform.location + parent->GetBoundingBox().location;\n\t// This is the yaw angle of the bounding box.\n\tconst auto yaw = transform.rotation.yaw;\n\t// This is the extents of the bounding box.\n\tconst auto extents = parent->GetBoundingBox().extents;\n\t// This is the first corner of the bounding box.\n\tconst auto corner1 = location + geom::Math::RotateVector(extents, yaw);\n\t// This is the second corner of the bounding box.\n\tconst auto corner2 = location + geom::Math::RotateVector(geom::Vector3D(-extents.x, extents.y, extents.z), yaw);\n\t// This is the third corner of the bounding box.\n\tconst auto corner3 = location + geom::Math::RotateVector(geom::Vector3D(-extents.x, -extents.y, extents.z), yaw);\n\t// This is the fourth corner of the bounding box.\n\tconst auto corner4 = location + geom::Math::RotateVector(geom::Vector3D(extents.x, -extents.y, extents.z), yaw);\n\t// This creates a shared pointer to a Bounds object.\n\treturn std::make_shared<const Bounds>(frame, corner1, corner2, corner3, corner4);\n}", "CodeBleu_score": 49.33654230771316}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t// This function, LaneInvasionCallback::MakeBounds, creates a bounding box for a given frame and transform. It calculates the location by adding the parent's bounding box location to the transform's location. It then computes the four corners of the bounding box by rotating the extents based on the yaw angle. Finally, it returns a shared pointer to a Bounds object containing the frame number and the calculated corners.\n\n  const auto &parent_bounds = _parent->GetBoundingBox();\n\n  auto location = parent_bounds.location + transform.location;\n\n  auto yaw = transform.rotation.yaw;\n\n  auto corners = parent_bounds.corners;\n\n  for (auto &corner : corners) {\n    corner = geom::Math::rotate(corner, yaw);\n  }\n\n  return std::make_shared<Bounds>(frame, corners);\n}", "CodeBleu_score": 40.513994108610795}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\tauto bounds = std::make_shared<Bounds>();\n\tbounds->frame = frame;\n\tbounds->corners[0] = transform.location + geom::Math::RotateVector(transform.rotation, geom::Vector3D(-bounds->extents.x, -bounds->extents.y, 0.0f));\n\tbounds->corners[1] = transform.location + geom::Math::RotateVector(transform.rotation, geom::Vector3D(bounds->extents.x, -bounds->extents.y, 0.0f));\n\tbounds->corners[2] = transform.location + geom::Math::RotateVector(transform.rotation, geom::Vector3D(bounds->extents.x, bounds->extents.y, 0.0f));\n\tbounds->corners[3] = transform.location + geom::Math::RotateVector(transform.rotation, geom::Vector3D(-bounds->extents.x, bounds->extents.y, 0.0f));\n\treturn bounds;\n}", "CodeBleu_score": 44.42718116546778}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto light_state = _simulator.GetLightState();\n\tfor (auto &light_id : light_state.first) {\n\t\tif (_lights.find(light_id) == _lights.end()) {\n\t\t\t_lights[light_id] = std::make_shared<Light>(light_id, _simulator);\n\t\t}\n\t\t_lights[light_id]->SetState(light_state.second[light_id]);\n\t}\n}", "CodeBleu_score": 29.73093825113715}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto lights = detail::Simulator::Get()->GetLightsState();\n\tfor (auto &&light : lights) {\n\t\tauto it = _lights.find(light.first);\n\t\tif (it == _lights.end()) {\n\t\t\t_lights.emplace(light.first, std::make_shared<Light>(light.first, light.second));\n\t\t} else {\n\t\t\tit->second->Update(light.second);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.605030274263356}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t_lights.clear();\n\n\t// get all lights\n\tauto lights = _parent->GetSimulator().GetLightState();\n\n\t// update light states\n\tfor (auto &light : lights) {\n\t\t_lights[light.id] = light;\n\t}\n}", "CodeBleu_score": 24.49762864285191}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (discard_client) {\n\t\t// Discard changes made by the client.\n\t\t_lights_state_client = _lights_state_server;\n\t}\n\tif (_lights_state_client!= _lights_state_server) {\n\t\t// Send changes to the server.\n\t\tauto message = boost::make_shared<rpc::LightStateUpdate>(\n\t\t\t_lights_state_client.GetHeader(),\n\t\t\t_lights_state_client.GetLights());\n\t\tdetail::Simulator::Get().Send(message);\n\t\t// Update the server state.\n\t\t_lights_state_server = _lights_state_client;\n\t}\n}", "CodeBleu_score": 23.098498966645547}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (discard_client) {\n\t\t_dirty = true;\n\t}\n\tif (_dirty) {\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\tif (_dirty) {\n\t\t\tdetail::Simulator::get_instance()->send_message(detail::BuildLightsStateUpdate(_lights_state));\n\t\t\t_dirty = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 17.005619435695152}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tif (_dirty || discard_client) {\n\t\t_dirty = false;\n\t\tdetail::Simulator::get_instance()->send(detail::Message::LightsState(_lights_state));\n\t}\n}", "CodeBleu_score": 13.401619879135435}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetSensorId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send() called on a sensor that is not'sensor.other.v2x_custom'.\");\n\t\treturn;\n\t}\n\tdetail::Simulator::GetEpisode().SendV2XMessage(GetContext(), message);\n}", "CodeBleu_score": 38.68490106467313}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->GetId()!= \"sensor.other.v2x_custom\") {\n\t\tcarla::Logging::LogWarning(\"ServerSideSensor::Send() called on a sensor that is not a V2X sensor.  This function only works on V2X sensors.\");\n\t\treturn;\n\t}\n\tdetail::EpisodeProxy episode = detail::EpisodeProxy::FromActor(this);\n\tepisode.Send(this->GetContext(), message);\n}", "CodeBleu_score": 45.84046566979169}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->id!= \"sensor.other.v2x_custom\") {\n\t\tcarla::Logging::LogWarning(\"This sensor is not a V2X sensor.\");\n\t\treturn;\n\t}\n\n\tcarla::Logging::LogDebug(\"ServerSideSensor::Send\");\n\tthis->context->Send(message);\n}", "CodeBleu_score": 41.283268854023326}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tif (traffic_manager_port == 0) {\n\t\t\ttraffic_manager_port = tm_port;\n\t\t\ttraffic_manager_client = carla::trafficmanager::TrafficManager::getInstance(tm_port);\n\t\t\ttraffic_manager_client->registerVehicle(GetActorId());\n\t\t}\n\t} else {\n\t\tif (traffic_manager_port!= 0) {\n\t\t\ttraffic_manager_client->unregisterVehicle(GetActorId());\n\t\t\ttraffic_manager_port = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.50363355439769}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tauto &tm = carla::traffic_manager::TrafficManager::GetInstance(tm_port);\n\t\ttm.RegisterVehicle(GetActorId());\n\t} else {\n\t\tauto &tm = carla::traffic_manager::TrafficManager::GetInstance(tm_port);\n\t\ttm.UnregisterVehicle(GetActorId());\n\t}\n}", "CodeBleu_score": 45.422808603384404}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tif (traffic_manager_port_ == 0) {\n\t\t\ttraffic_manager_port_ = tm_port;\n\t\t\tdetail::Simulator::RegisterVehicle(this);\n\t\t}\n\t}\n\telse {\n\t\tif (traffic_manager_port_!= 0) {\n\t\t\tdetail::Simulator::UnregisterVehicle(this);\n\t\t\ttraffic_manager_port_ = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.34685040604854}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\tauto walker = GetActor();\n\tif (walker) {\n\t\tauto simulator = GetSimulator();\n\t\tif (simulator) {\n\t\t\tauto navigation = simulator->GetWalkerNavigation();\n\t\t\tnavigation->AddWalker(walker, walker->GetTransform().location);\n\t\t\twalker->SetSimulatePhysics(false);\n\t\t\twalker->SetCollisionEnabled(carla::CollisionDetectionMode::NoCollision);\n\t\t}\n\t}\n}", "CodeBleu_score": 40.39707358258063}, {"code": "void WalkerAIController::Start(){\n\t\t// Register the AI controller with the episode.\n\tEpisode.RegisterAIController(this);\n\n\t// Retrieve the walker actor and add it to the navigation system with its current location.\n\tconst auto walker = Episode.GetWalker(WalkerId);\n\tEpisode.GetNavigation().AddWalker(walker, walker->GetTransform().location);\n\n\t// Disable the physics simulation and collisions for the walker actor.\n\twalker->SetSimulatePhysics(false);\n\twalker->SetCollision(false);\n}", "CodeBleu_score": 33.138326202277014}, {"code": "void WalkerAIController::Start(){\n\t\tif (auto walker = GetWalker()) {\n\t\tauto &navigation = GetEpisode().GetWalkerNavigation();\n\t\tnavigation.AddWalker(walker, walker->GetTransform().location);\n\t\twalker->SetSimulatePhysics(false);\n\t\twalker->SetCollision(false);\n\t}\n}", "CodeBleu_score": 32.73130477111508}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto navigation = detail::Episode::GetCurrent().GetNavigation();\n\tif (navigation) {\n\t\tauto walker = navigation->GetParentWalker();\n\t\tif (walker) {\n\t\t\twalker->SetMaxSpeed(max_speed);\n\t\t} else {\n\t\t\tLOG_WARNING(\"WalkerAIController::SetMaxSpeed: walker not found.\");\n\t\t}\n\t} else {\n\t\tLOG_WARNING(\"WalkerAIController::SetMaxSpeed: navigation not found.\");\n\t}\n}", "CodeBleu_score": 48.93343728451066}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (auto navigation = detail::Episode::GetCurrent().GetWalkerNavigation()) {\n\t\tif (auto walker = GetParent().lock()) {\n\t\t\tif (!navigation->SetMaxSpeed(walker, max_speed)) {\n\t\t\t\tLOG_WARNING(\"Failed to set the maximum speed for walker \" << walker->GetId());\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_WARNING(\"Walker not found\");\n\t\t}\n\t} else {\n\t\tLOG_WARNING(\"Walker navigation not found\");\n\t}\n}", "CodeBleu_score": 48.74509070230017}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto episode = detail::Simulator::Episode();\n\tif (episode) {\n\t\tauto navigation = episode->GetNavigation();\n\t\tif (navigation) {\n\t\t\tauto walker = navigation->GetWalker(GetActorId());\n\t\t\tif (walker) {\n\t\t\t\twalker->SetMaxSpeed(max_speed);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tLOG_WARNING(\"Unable to set max speed for walker \" << GetActorId());\n}", "CodeBleu_score": 45.92546331786121}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<carla::client::Waypoint> waypoints = parent_map->GetPrevious(*this, distance);\n\tfor (auto &waypoint : waypoints) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint, parent_map)));\n\t}\n\treturn result;\n}", "CodeBleu_score": 62.382810886754}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tauto previous_waypoints = GetParentMap().GetPrevious(*this, distance);\n\tfor (auto &previous_waypoint : previous_waypoints) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(previous_waypoint, GetParentMap())));\n\t}\n\treturn result;\n}", "CodeBleu_score": 57.41988002162148}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tauto parent = GetMap();\n\tif (parent!= nullptr) {\n\t\tauto waypoints = parent->GetPrevious(*this, distance);\n\t\tfor (auto &waypoint : waypoints) {\n\t\t\tresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 67.9900354906269}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tauto signals = GetSignalsInDistance(distance, stop_at_junction);\n\tstd::unordered_set<SharedPtr<Signal>> signals_set;\n\tfor (auto signal : signals) {\n\t\tif (signals_set.count(signal) == 0) {\n\t\t\tsignals_set.insert(signal);\n\t\t\tSharedPtr<Waypoint> waypoint = SharedPtr<Waypoint>(new Waypoint(this->GetMap(), signal->GetLocation()));\n\t\t\tSharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(waypoint, Landmark::Type::Signal));\n\t\t\tresult.push_back(landmark);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 51.64523586759705}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::unordered_set<SharedPtr<Signal>> signals_seen;\n\tauto signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tif (signals_seen.find(signal) == signals_seen.end()) {\n\t\t\tsignals_seen.insert(signal);\n\t\t\tresult.emplace_back(std::make_shared<Landmark>(signal));\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 38.623884870605}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\t// TODO: implement this function\n\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<carla::client::Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tstd::unordered_set<SharedPtr<carla::client::Signal>> unique_signals;\n\tfor (auto signal : signals) {\n\t\tif (unique_signals.find(signal) == unique_signals.end()) {\n\t\t\tunique_signals.insert(signal);\n\t\t\tSharedPtr<Waypoint> wp = SharedPtr<Waypoint>(new Waypoint(signal->GetLocation(), signal->GetTransform()));\n\t\t\tSharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(wp, LandmarkType::Signal));\n\t\t\tresult.push_back(landmark);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 49.70313303373093}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  check(IsInGameThread());", "CodeBleu_score": 5.626742333802562}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tauto simulator = GetSimulator();\n\tauto settings_id = simulator->ApplySettings(settings);\n\tif (settings.HasFixedDeltaSeconds()) {\n\t\tconst auto fixed_delta_seconds = settings.fixed_delta_seconds();\n\t\tconst auto networking_timeout = GetSettings().networking_timeout;\n\t\ttimeout = std::min(timeout, networking_timeout);\n\t\tconst auto start_time = std::chrono::steady_clock::now();\n\t\tfor (uint32_t i = 0; i < 10; ++i) {\n\t\t\tsimulator->Tick();\n\t\t\tif (simulator->GetDeltaSeconds() == fixed_delta_seconds) {\n\t\t\t\treturn settings_id;\n\t\t\t}\n\t\t\tif (std::chrono::steady_clock::now() - start_time > timeout) {\n\t\t\t\tlog_warning(\n\t\t\t\t\t\"ApplySettings: The fixed delta time of \", fixed_delta_seconds,\n\t\t\t\t\t\" seconds was not correctly applied after \", i + 1, \" attempts.\");\n\t\t\t\treturn settings_id;\n\t\t\t}\n\t\t}\n\t}\n\treturn settings_id;\n}", "CodeBleu_score": 43.97122936704101}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  UE_LOG(LogCarla, Log, TEXT(\"Applying settings to the world.\"));", "CodeBleu_score": 3.700642311185895}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\t(const Vector2D &segment_start, const Vector2D &segment_end, const Vector2D &point) {\n\t\tconst float segment_length_squared = (segment_end - segment_start).SquaredLength();\n\t\tif (segment_length_squared == 0.0f) {\n\t\t\treturn std::make_pair(0.0f, (point - segment_start).Length());\n\t\t}\n\t\tconst float t = (point - segment_start).Dot(segment_end - segment_start) / segment_length_squared;\n\t\tconst float clamped_t = std::clamp(t, 0.0f, 1.0f);\n\t\tconst Vector2D projection = segment_start + (segment_end - segment_start) * clamped_t;\n\t\treturn std::make_pair(clamped_t, (point - projection).Length());\n\t}\n}", "CodeBleu_score": 43.24712140074462}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\t(const Vector2D &segment_start, const Vector2D &segment_end, const Vector2D &point) {\n\t\tconst Vector2D segment_vector {segment_end - segment_start};\n\t\tconst float segment_length_squared {segment_vector.SquaredLength()};\n\t\tif (segment_length_squared == 0.0f) {\n\t\t\treturn {0.0f, (point - segment_start).Length()};\n\t\t}\n\t\tconst float projection {DotProduct(point - segment_start, segment_vector) / segment_length_squared};\n\t\tconst float clamped_projection {std::clamp(projection, 0.0f, 1.0f)};\n\t\tconst Vector2D projection_vector {segment_vector * clamped_projection};\n\t\tconst Vector2D projection_point {segment_start + projection_vector};\n\t\treturn {clamped_projection, (projection_point - point).Length()};\n\t}\n}", "CodeBleu_score": 37.702800979722454}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\t(const geom::Vector2D &A, const geom::Vector2D &B, const geom::Vector2D &P)", "CodeBleu_score": 9.64930977341709}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\t// assert(vertices.size() >= 3);\n\t// auto initial_index = static_cast<index_type>(vertices_.size());\n\t// vertices_.insert(vertices_.end(), vertices.begin(), vertices.end());\n\t// for (size_t i = 0; i < vertices.size() - 2; ++i) {\n\t// \tindices_.push_back(initial_index);\n\t// \tindices_.push_back(initial_index + i + 1);\n\t// \tindices_.push_back(initial_index + i + 2);\n\t// }\n\t// return initial_index;\n}", "CodeBleu_score": 5.829718325262547}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t#ifdef _WIN32\n#pragma warning(push)\n#pragma warning(disable : 4127)\n#endif // _WIN32\n#if defined(__clang__) || defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wtype-limits\"\n#endif // defined(__clang__) || defined(__GNUC__)\n  assert(vertices.size() >= 3);\n#if defined(__clang__) || defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif // defined(__clang__) || defined(__GNUC__)\n#ifdef _WIN32\n#pragma warning(pop)\n#endif // _WIN32\n\n  const auto initial_index = static_cast<uint32_t>(GetVertices().size());\n\n  AddVertices(vertices);\n\n  for (size_t i = 2; i < vertices.size(); ++i) {\n    AddIndices({initial_index, static_cast<uint32_t>(i - 1), static_cast<uint32_t>(i)});\n  }\n}", "CodeBleu_score": 41.4366522461045}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\t// TODO:\n\t// 1. Assert that there are at least three vertices.\n\t// 2. Record the initial index and add the vertices to the mesh.\n\t// 3. Iteratively add indices to form triangles, connecting the initial vertex with each subsequent pair of vertices in the list.\n\t// 4. Add a new triangle to the mesh.\n\t// 5. Add a new vertex to the mesh.\n\t// 6. Add a new index to the mesh.\n\t// 7. Add a new triangle to the mesh.\n\t// 8. Add a new vertex to the mesh.\n\t// 9. Add a new index to the mesh.\n\t// 10. Add a new triangle to the mesh.\n\t// 11. Add a new vertex to the mesh.\n\t// 12. Add a new index to the mesh.\n\t// 13. Add a new triangle to the mesh.\n\t// 14. Add a new vertex to the mesh.\n\t// 15. Add a new index to the mesh.\n\t// 16. Add a new triangle to the mesh.\n\t// 17. Add a new vertex to the mesh.\n\t// 18. Add a new index to the mesh.\n\t// 19. Add a new triangle to the mesh.\n\t// 20. Add a new vertex to the mesh.\n\t// 21. Add a new index to the mesh.\n\t// 22. Add a new triangle to the mesh.\n\t// 23. Add a new vertex to the mesh.\n\t// 24. Add a new index to the mesh.\n\t// 25. Add a new triangle to the mesh.\n\t// 26. Add a new vertex to the mesh.\n\t// 27. Add a new index to the mesh.\n\t// 28. Add a new triangle to the mesh.\n\t// 29. Add a new vertex to the mesh.\n\t// 30. Add a new index to the mesh.\n\t// 31. Add a new triangle to the mesh.\n\t// 32. Add a new vertex to the mesh.\n\t// 33. Add a new index to the mesh.\n\t//", "CodeBleu_score": 5.712762733113359}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (message) {\n\t\tboost::asio::post(strand, [this, message] {\n\t\t\tif (socket.is_open()) {\n\t\t\t\tboost::asio::async_write(socket, message->GetBuffer(),\n\t\t\t\t\tboost::asio::bind_executor(strand, [this, message](boost::system::error_code ec, std::size_t) {\n\t\t\t\t\t\tif (!ec) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ec == boost::asio::error::operation_aborted) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLOG_ERROR(\"Failed to send message of type \" << message->GetType() << \": \" << ec.message());\n\t\t\t\t\t\tClose();\n\t\t\t\t\t}));\n\t\t\t}\n\t\t});\n\t}\n}", "CodeBleu_score": 29.331654652629524}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\tlog_error(\"Primary::Write - message is null\");\n\t\treturn;\n\t}\n\n\tif (message->size() > MaxMessageSize) {\n\t\tlog_error(\"Primary::Write - message size is too big\");\n\t\treturn;\n\t}\n\n\tboost::asio::post(strand, [this, message]() {\n\t\tif (!socket.is_open()) {\n\t\t\tlog_error(\"Primary::Write - socket is not open\");\n\t\t\treturn;\n\t\t}\n\n\t\tauto self(shared_from_this());\n\n\t\tboost::asio::async_write(socket, boost::asio::buffer(message->data(), message->size()), [this, self](const boost::system::error_code &error, std::size_t) {\n\t\t\tif (error) {\n\t\t\t\tlog_error(\"Primary::Write - error: \" << error.message());\n\t\t\t\tClose();\n\t\t\t}\n\t\t});\n\t});\n}", "CodeBleu_score": 35.20476718570659}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\tlog_error(\"Attempting to write a null message\");\n\t\treturn;\n\t}\n\tboost::asio::post(strand_, [this, message]() {\n\t\tif (!socket_.is_open()) {\n\t\t\tlog_error(\"Attempting to write to a closed socket\");\n\t\t\treturn;\n\t\t}\n\t\tboost::asio::async_write(socket_, message->ToBuffers(), boost::asio::bind_executor(strand_, [this](const boost::system::error_code& error, std::size_t) {\n\t\t\tif (error) {\n\t\t\t\tlog_error(\"Error writing to socket: \", error.message());\n\t\t\t\tClose();\n\t\t\t}\n\t\t}));\n\t});\n}", "CodeBleu_score": 31.392529398886847}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer so that the blocking close() will complete immediately.\n\tthis->deadline.cancel();\n\n\t// If we're not connected, there's nothing to do.\n\tif (this->socket.is_open()) {\n\t\t// Shut down the socket to prevent sending or receiving any more data.\n\t\tthis->socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n\t\t// Close the socket so that all further operations on the socket will fail.\n\t\tthis->socket.close(ec);\n\t}\n\n\t// If the connection is closed successfully, trigger the on_closed callback.\n\tif (this->on_closed) {\n\t\tthis->on_closed(this);\n\t}\n\n\t// Log that the session has been closed.\n\tLog(\"Primary session closed.\");\n}", "CodeBleu_score": 29.16642872274301}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec) {\n\t\tif (ec!= boost::asio::error::operation_aborted) {\n\t\t\tCARLA_WARN(\"Primary::CloseNow: Error code: \" << ec.message());\n\t\t}\n\t} else {\n\t\tCARLA_ASSERT(m_socket.is_open());\n\t\tm_socket.cancel();\n\t\tm_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\tm_socket.close(ec);\n\t}\n\n\tif (m_on_closed) {\n\t\tm_on_closed();\n\t}\n\n\tCARLA_ASSERT(!m_socket.is_open());\n\tCARLA_ASSERT(m_session_id == 0);\n\tCARLA_ASSERT(m_deadline.expires_at() == boost::asio::deadline_timer::traits_type::time_type::max());\n\tCARLA_ASSERT(m_deadline.get_executor().context() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT(m_deadline.get_executor().target<void>() == nullptr);\n\tCARLA_ASSERT", "CodeBleu_score": 43.39965594926174}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer so that the blocked accept() function\n\t// will be free to return.\n\tthis->deadline_.cancel();\n\n\t// If we're not connected, there's nothing to do. The connect\n\t// timed out or the user tried to break it up.\n\tif (!this->socket_.is_open()) {\n\t\treturn;\n\t}\n\n\t// Shut down the accept socket.\n\tif (ec == boost::asio::error::operation_aborted) {\n\t\t// The operation was aborted, so the connection was\n\t\t// closed gracefully.\n\t\tthis->socket_.close();\n\t\treturn;\n\t}\n\n\t// The connection was closed unexpectedly.\n\tthis->socket_.close();\n}", "CodeBleu_score": 23.15271673144329}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tcarla::streaming::detail::Buffer buffer;\n\tbuffer.Resize(sizeof(carla::multigpu::primaryCommands::IsAlive));\n\tcarla::multigpu::primaryCommands::IsAlive *msg = reinterpret_cast<carla::multigpu::primaryCommands::IsAlive *>(buffer.GetData());\n\tmsg->header.type = carla::streaming::detail::MessageType::YOU_ALIVE;\n\tmsg->header.size = sizeof(carla::multigpu::primaryCommands::IsAlive);\n\n\t// Log the sending action\n\tLOG_INFO(\"PrimaryCommands::SendIsAlive: Sending a message to check if the system is responsive\");\n\n\t// Write the buffer to the next router\n\tPrimary::GetRouter()->Write(buffer);\n\n\t// Wait for the response from the system\n\tcarla::streaming::detail::Buffer bufferResponse;\n\tPrimary::GetRouter()->Read(bufferResponse);\n\n\t// Log the response\n\tLOG_INFO(\"PrimaryCommands::SendIsAlive: Received a response from the system\");\n}", "CodeBleu_score": 44.44739149751368}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create buffer\n\tstd::vector<char> buffer;\n\tbuffer.resize(sizeof(int32_t) + sizeof(int32_t));\n\tint32_t *buffer_int = reinterpret_cast<int32_t *>(buffer.data());\n\tbuffer_int[0] = carla::streaming::detail::Command::YOU_ALIVE;\n\tbuffer_int[1] = 0;\n\n\t// Log sending action\n\tLOG_INFO(\"Sending message to check if system is alive\");\n\n\t// Write buffer to next router\n\tRouter::Write(buffer, carla::streaming::detail::Command::YOU_ALIVE);\n\n\t// Wait for response\n\tRouter::Read(buffer);\n\tbuffer_int = reinterpret_cast<int32_t *>(buffer.data());\n\tLOG_INFO(\"System is alive\");\n}", "CodeBleu_score": 45.47451044739577}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tstd::vector<char> buffer = PrimaryCommands::CreateBuffer(carla::streaming::detail::Message::IsAlive());\n\t// Log the sending action\n\tPrimaryCommands::Log(\"Sending message: \\\"Are you alive?\\\"\");\n\t// Write the buffer to the next router\n\tPrimary::WriteBuffer(buffer, carla::streaming::detail::Command::YOU_ALIVE);\n\t// Wait for the response\n\tPrimary::WaitForResponse();\n}", "CodeBleu_score": 18.091618978564846}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// If the sensor is not found on any secondary server, log an error message.\n\tif (Router::GetSecondaryServerForSensor(sensor_id) == -1) {\n\t\tstd::cout << \"ERROR: Sensor ID \" << sensor_id << \" not found on any secondary server.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Create a buffer with the sensor ID.\n\tuint8_t buffer[sizeof(stream_id)];\n\tmemcpy(buffer, &sensor_id, sizeof(stream_id));\n\n\t// Send an ENABLE_ROS command to the server using the router.\n\tRouter::SendCommand(Primary::GetPrimaryServer(), Commands::ENABLE_ROS, buffer, sizeof(stream_id));\n\n\t// Wait for and process the server's response.\n\tstreaming::detail::tcp::Message response = Router::ReceiveResponse(Primary::GetPrimaryServer());\n\tif (response.type == streaming::detail::tcp::Message::Type::ERROR) {\n\t\tstd::cout << \"ERROR: \" << response.data << std::endl;\n\t}\n}", "CodeBleu_score": 44.2838284049753}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if the sensor is active on any secondary server\n\tbool sensor_found = false;\n\tfor (auto& secondary : secondary_servers) {\n\t\tif (secondary.second.IsSensorActive(sensor_id)) {\n\t\t\tsensor_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If the sensor is active on any secondary server, send an ENABLE_ROS command to the server using the router\n\tif (sensor_found) {\n\t\t// Create a buffer with the sensor ID\n\t\tstd::vector<uint8_t> buffer;\n\t\tbuffer.reserve(sizeof(stream_id));\n\t\tstreaming::detail::WriteLittleEndian(sensor_id, buffer);\n\n\t\t// Send an ENABLE_ROS command to the server using the router\n\t\trouter.SendCommand(secondary_server_id, CommandType::ENABLE_ROS, buffer);\n\n\t\t// Wait for and process the server's response\n\t\tauto response = router.ReceiveResponse(secondary_server_id);\n\t\tif (response.first == ResponseType::SUCCESS) {\n\t\t\t// Sensor successfully enabled for ROS\n\t\t\tLOG_INFO(\"Sensor \" << sensor_id << \" successfully enabled for ROS\");\n\t\t} else {\n\t\t\t// Error enabling sensor for ROS\n\t\t\tLOG_ERROR(\"Error enabling sensor \" << sensor_id << \" for ROS\");\n\t\t}\n\t} else {\n\t\t// Sensor not found on any secondary server\n\t\tLOG_ERROR(\"Sensor \" << sensor_id << \" not found on any secondary server\");\n\t}\n}", "CodeBleu_score": 46.756864999617534}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tstd::vector<stream_id> ids;\n\tids.push_back(sensor_id);\n\tSendEnableForROS(ids);\n}", "CodeBleu_score": 15.417684387935427}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// Check if the sensor is already activated.\n\tif (this->active_sensors.find(sensor_id)!= this->active_sensors.end()) {\n\t\t// If it is, retrieve the token and log the action.\n\t\ttoken_type token = this->active_sensors.at(sensor_id);\n\t\tthis->log->debug(\"PrimaryCommands::GetToken: Sensor %d is already activated, token %d retrieved.\", sensor_id, token);\n\t\treturn token;\n\t}\n\telse {\n\t\t// If it is not, enable the sensor on a secondary server, retrieve a new token, update the maps, log the action, and return the new token.\n\t\ttoken_type token = this->router->EnableSensor(sensor_id);\n\t\tthis->active_sensors.insert(std::pair<stream_id, token_type>(sensor_id, token));\n\t\tthis->sensor_token.insert(std::pair<token_type, stream_id>(token, sensor_id));\n\t\tthis->log->debug(\"PrimaryCommands::GetToken: Sensor %d is not activated, token %d retrieved.\", sensor_id, token);\n\t\treturn token;\n\t}\n}", "CodeBleu_score": 32.29693863402402}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// If sensor is already activated, return existing token\n\tif (sensor_to_token.count(sensor_id) == 1) {\n\t\t// Log the action\n\t\tLOG_INFO(\"PrimaryCommands::GetToken: Sensor \" << sensor_id << \" already activated. Returning existing token.\");\n\t\treturn sensor_to_token[sensor_id];\n\t}\n\n\t// If sensor is not activated, enable sensor on secondary, get new token, update maps, log action, and return new token\n\telse {\n\t\t// Enable sensor on secondary\n\t\tLOG_INFO(\"PrimaryCommands::GetToken: Sensor \" << sensor_id << \" not activated. Enabling sensor on secondary.\");\n\t\tPrimary::get()->EnableSensor(sensor_id);\n\n\t\t// Get new token\n\t\tLOG_INFO(\"PrimaryCommands::GetToken: Retrieving new token for sensor \" << sensor_id << \".\");\n\t\ttoken_type token = Primary::get()->GetToken(sensor_id);\n\n\t\t// Update maps\n\t\tLOG_INFO(\"PrimaryCommands::GetToken: Updating maps.\");\n\t\tsensor_to_token[sensor_id] = token;\n\t\ttoken_to_sensor[token] = sensor_id;\n\n\t\t// Log action\n\t\tLOG_INFO(\"PrimaryCommands::GetToken: Returning new token \" << token << \" for sensor \" << sensor_id << \".\");\n\t\treturn token;\n\t}\n}", "CodeBleu_score": 44.328553812641125}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\ttoken_type token;\n\tif (active_sensors.find(sensor_id)!= active_sensors.end()) {\n\t\ttoken = active_sensors.at(sensor_id);\n\t\tstd::cout << \"Token already exists for sensor \" << sensor_id << std::endl;\n\t} else {\n\t\tstd::cout << \"Activating sensor \" << sensor_id << \" on secondary server\" << std::endl;\n\t\tPrimary::EnableSensor(sensor_id);\n\t\ttoken = Primary::GetToken(sensor_id);\n\t\tactive_sensors.insert(std::pair<stream_id, token_type>(sensor_id, token));\n\t\tsensor_tokens.insert(std::pair<token_type, stream_id>(token, sensor_id));\n\t\tstd::cout << \"Token retrieved for sensor \" << sensor_id << std::endl;\n\t}\n\treturn token;\n}", "CodeBleu_score": 41.08862278801152}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> file_data((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n\tfile.close();\n\treturn Load(file_data);\n}", "CodeBleu_score": 58.02363409922828}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tfile.seekg(0, std::ios::end);\n\tstd::vector<uint8_t> data(file.tellg());\n\tfile.seekg(0, std::ios::beg);\n\tfile.read(reinterpret_cast<char *>(&data[0]), data.size());\n\tfile.close();\n\treturn Load(data);\n}", "CodeBleu_score": 53.76967517517242}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content;\n\tfile.seekg(0, std::ios::end);\n\tcontent.resize(file.tellg());\n\tfile.seekg(0, std::ios::beg);\n\tfile.read(reinterpret_cast<char *>(content.data()), content.size());\n\tfile.close();\n\treturn Load(content);\n}", "CodeBleu_score": 53.667221165578624}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\tstd::lock_guard<std::mutex> lock(mutex);\n\tauto walker_it = walker_mapping.find(id);\n\tif (walker_it!= walker_mapping.end()) {\n\t\tconst auto &walker = walker_it->second;\n\t\twalker->SetEnabled(false);\n\t\twalker->SetMaxSpeed(0.0f);\n\t\twalker->SetVelocity(carla::geom::Vector3D(0.0f, 0.0f, 0.0f));\n\t\tcrowd->removeAgent(walker->GetAgentId());\n\t\twalker_manager->RemoveWalker(walker);\n\t\twalker_mapping.erase(walker_it);\n\t\treturn true;\n\t}\n\tauto vehicle_it = vehicle_mapping.find(id);\n\tif (vehicle_it!= vehicle_mapping.end()) {\n\t\tconst auto &vehicle = vehicle_it->second;\n\t\tvehicle->SetEnabled(false);\n\t\tvehicle->SetMaxSpeed(0.0f);\n\t\tvehicle->SetVelocity(carla::geom::Vector3D(0.0f, 0.0f, 0.0f));\n\t\tcrowd->removeAgent(vehicle->GetAgentId());\n\t\tvehicle_manager->RemoveVehicle(vehicle);\n\t\tvehicle_mapping.erase(vehicle_it);\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 49.442864713976945}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!ready) {\n\t\treturn false;\n\t}\n\tassert(crowd!= nullptr);\n\n\tauto walker_it = walker_mapping.find(id);\n\tif (walker_it!= walker_mapping.end()) {\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\t\tcrowd->removeAgent(walker_it->second);\n\t\twalker_manager->RemoveWalker(id);\n\t\twalker_mapping.erase(walker_it);\n\t\treturn true;\n\t}\n\n\tauto vehicle_it = vehicle_mapping.find(id);\n\tif (vehicle_it!= vehicle_mapping.end()) {\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\t\tcrowd->removeAgent(vehicle_it->second);\n\t\tvehicle_manager->RemoveVehicle(id);\n\t\tvehicle_mapping.erase(vehicle_it);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 61.046349750432825}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\tassert(crowd!= nullptr);\n\n\tauto walker_it = walker_mapping.find(id);\n\tauto vehicle_it = vehicle_mapping.find(id);\n\n\tif (walker_it!= walker_mapping.end()) {\n\t\tstd::lock_guard<std::mutex> lock(walker_manager->GetMutex());\n\t\tcrowd->removeAgent(walker_it->second);\n\t\twalker_manager->RemoveWalker(id);\n\t\twalker_mapping.erase(walker_it);\n\t\treturn true;\n\t}\n\n\tif (vehicle_it!= vehicle_mapping.end()) {\n\t\tstd::lock_guard<std::mutex> lock(vehicle_manager->GetMutex());\n\t\tcrowd->removeAgent(vehicle_it->second);\n\t\tvehicle_manager->RemoveVehicle(id);\n\t\tvehicle_mapping.erase(vehicle_it);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 57.1641109284428}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\t// Collect IDs of currently mapped vehicles\n\tstd::set<uint64_t> current_vehicles;\n\tfor (auto &v : _vehicles) {\n\t\tcurrent_vehicles.insert(v.first);\n\t}\n\n\t// Add or update vehicles from the provided list\n\tfor (auto &v : vehicles) {\n\t\tcurrent_vehicles.erase(v.id);\n\t\t_vehicles[v.id] = v;\n\t}\n\n\t// Remove vehicles not marked as updated\n\tfor (auto &v : current_vehicles) {\n\t\t_vehicles.erase(v);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 55.20963348429746}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\t//std::cout << \"Updating vehicles.\" << std::endl;\n\t//std::cout << \"Current vehicles: \" << this->vehicle_map.size() << std::endl;\n\t//std::cout << \"New vehicles: \" << vehicles.size() << std::endl;\n\tstd::set<int> current_ids;\n\tfor (auto &vehicle : this->vehicle_map) {\n\t\tcurrent_ids.insert(vehicle.first);\n\t}\n\tfor (auto &vehicle : vehicles) {\n\t\t//std::cout << \"Vehicle ID: \" << vehicle.id << std::endl;\n\t\t//std::cout << \"Vehicle distance: \" << vehicle.distance << std::endl;\n\t\tcurrent_ids.erase(vehicle.id);\n\t\tif (this->vehicle_map.find(vehicle.id) == this->vehicle_map.end()) {\n\t\t\t//std::cout << \"Adding vehicle.\" << std::endl;\n\t\t\tthis->vehicle_map[vehicle.id] = vehicle;\n\t\t} else {\n\t\t\t//std::cout << \"Updating vehicle.\" << std::endl;\n\t\t\tthis->vehicle_map[vehicle.id] = vehicle;\n\t\t}\n\t}\n\tfor (auto &id : current_ids) {\n\t\t//std::cout << \"Removing vehicle.\" << std::endl;\n\t\tthis->vehicle_map.erase(id);\n\t}\n\t//std::cout << \"Vehicles updated.\" << std::endl;\n\treturn true;\n}", "CodeBleu_score": 52.32901187250815}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t//std::cout << \"Updating vehicles\" << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles size: \" << vehicles.size() << std::", "CodeBleu_score": 5.700180495096394}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tauto walker = GetWalker(id);\n\tif (walker!= nullptr) {\n\t\treturn HasVehicleNear(walker, distance, direction);\n\t}\n\tauto vehicle = GetVehicle(id);\n\tif (vehicle!= nullptr) {\n\t\treturn HasVehicleNear(vehicle, distance, direction);\n\t}\n\treturn false;\n}", "CodeBleu_score": 29.28262328126886}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tauto actor = GetActor(id);\n\tif (actor) {\n\t\tauto location = actor->GetLocation();\n\t\tauto rotation = actor->GetTransform().GetRotation();\n\t\tdirection = direction.Transform(rotation);\n\t\tdirection.Normalize();\n\n\t\tauto walker = walker_manager->GetWalker(id);\n\t\tif (walker) {\n\t\t\tauto walker_location = walker->GetLocation();\n\t\t\tauto walker_direction = walker->GetDirection();\n\t\t\tauto walker_distance = (walker_location - location).SquaredSize();\n\t\t\tauto walker_angle = std::abs(walker_direction.Angle(direction));\n\t\t\tif (walker_distance < distance * distance && walker_angle < 0.5f) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tstd::lock_guard<std::mutex> lock(vehicles_mutex);\n\t\tauto it = vehicles.find(id);\n\t\tif (it!= vehicles.end()) {\n\t\t\tauto vehicle_location = it->second.location;\n\t\t\tauto vehicle_direction = it->second.direction;\n\t\t\tauto vehicle_distance = (vehicle_location - location).SquaredSize();\n\t\t\tauto vehicle_angle = std::abs(vehicle_direction.Angle(direction));\n\t\t\tif (vehicle_distance < distance * distance && vehicle_angle < 0.5f) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tauto crowd = crowd_system->Query(location, distance);\n\t\tfor (auto agent : crowd) {\n\t\t\tif (agent->id!= id) {\n\t\t\t\tauto agent_location = agent->position;\n\t\t\t\tauto agent_direction = agent->velocity;\n\t\t\t\tauto agent_distance = (agent_location - location).SquaredSize();\n\t\t\t\tauto agent_angle = std::abs(agent_direction.Angle(direction));\n\t\t\t\tif (agent_distance < distance * distance && agent_angle < 0.5f) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 46.130206788404784}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tif (this->walkers.find(id)!= this->walkers.end()) {\n\t\treturn this->HasVehicleNear(this->walkers[id], distance, direction);\n\t} else if (this->vehicles.find(id)!= this->vehicles.end()) {\n\t\treturn this->HasVehicleNear(this->vehicles[id], distance, direction);\n\t}\n\treturn false;\n}", "CodeBleu_score": 26.948234018980056}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tstd::vector<RoutePoint>::iterator current_point = info.current_route_point;\n\tstd::vector<RoutePoint>::iterator next_point = current_point + 1;\n\tWalkerEventVisitor visitor(info.current_route_point, info.next_route_point, delta);\n\tEventResult result = boost::variant2::visit(visitor, info.current_route_point->event);\n\treturn result;\n}", "CodeBleu_score": 44.5729309004187}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto &route = info.route;\n\tauto &current = route.GetCurrent();\n\tauto &next = route.GetNext();\n\tauto &current_event = current.event;\n\tauto &next_event = next.event;\n\tauto &current_event_type = current.event_type;\n\tauto &next_event_type = next.event_type;\n\tauto &current_event_param = current.event_param;\n\tauto &next_event_param = next.event_param;\n\tauto &current_event_time = current.event_time;\n\tauto &next_event_time = next.event_time;\n\tauto &current_event_time_left = current.event_time_left;\n\tauto &next_event_time_left = next.event_time_left;\n\tauto &current_event_time_passed = current.event_time_passed;\n\tauto &next_event_time_passed = next.event_time_passed;\n\tauto &current_event_time_passed_total = current.event_time_passed_total;\n\tauto &next_event_time_passed_total = next.event_time_passed_total;\n\tauto &current_event_time_total = current.event_time_total;\n\tauto &next_event_time_total = next.event_time_total;\n\tauto &current_event_time_passed_total_at_last_event = current.event_time_passed_total_at_last_event;\n\tauto &next_event_time_passed_total_at_last_event = next.event_time_passed_total_at_last_event;\n\tauto &current_event_time_total_at_last_event = current.event_time_total_at_last_event;\n\tauto &next_event_time_total_at_last_event = next.event_time_total_at_last_event;\n\tauto &current_event_time_passed_total_at_last_event_update = current.event_time_passed_total_at_last_event_update;\n\tauto &next_event_time_passed_total_at_last_event", "CodeBleu_score": 37.746191921048386}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Retrieve the current route point for the walker.\n\tauto &route = info.route;\n\tauto &current_route_point = route.GetCurrent();\n\t// Create a WalkerEventVisitor with the current context.\n\tWalkerEventVisitor visitor(id, delta, current_route_point);\n\t// Process the event at the current route point using boost::variant2::visit.\n\treturn boost::variant2::visit(visitor, current_route_point.event);\n}", "CodeBleu_score": 50.3179043784826}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n//  std::cout << \"LaneParser::Parse\" << std::endl;\n\n  for (pugi::xml_node road_node : xml.select_nodes(\"/OpenDRIVE/road\")) {\n    const auto id = std::stoi(road_node.attribute(\"id\").value());\n\n//    std::cout << \"Road id: \" << id << std::endl;\n\n    for (pugi::xml_node lanes_node : road_node.select_nodes(\"lanes\")) {\n      for (pugi::xml_node lane_node : lanes_node.select_nodes(\"laneSection\")) {\n        const auto s = std::stod(lane_node.attribute(\"s\").value());\n\n        for (pugi::xml_node left_lane_node : lane_node.select_nodes(\"left\")) {\n          ParseLanes(left_lane_node, s, id, map_builder);\n        }\n\n        for (pugi::xml_node center_lane_node : lane_node.select_nodes(\"center\")) {\n          ParseLanes(center_lane_node, s, id, map_builder);\n        }\n\n        for (pugi::xml_node right_lane_node : lane_node.select_nodes(\"right\")) {\n          ParseLanes(right_lane_node, s, id, map_builder);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 59.13645753917278}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n//  std::cout << \"LaneParser::Parse\" << std::endl;\n  for (const auto &road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const auto road_id = std::stoul(road_node.attribute(\"id\").value());\n    const auto road_junction = std::stoul(road_node.attribute(\"junction\").value());\n    const auto road_length = std::stof(road_node.attribute(\"length\").value());\n    const auto road_name = std::string(road_node.attribute(\"name\").value());\n    const auto road_type = std::string(road_node.attribute(\"type\").value());\n    map_builder.AddRoad(road_id, road_junction, road_length, road_name, road_type);\n    for (const auto &lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      const auto lane_section_id = std::stoul(lane_section_node.attribute(\"id\").value());\n      const auto lane_section_s = std::stof(lane_section_node.attribute(\"s\").value());\n      map_builder.AddLaneSection(road_id, lane_section_id, lane_section_s);\n      const auto &left_lane_node = lane_section_node.child(\"left\");\n      const auto &center_lane_node = lane_section_node.child(\"center\");\n      const auto &right_lane_node = lane_section_node.child(\"right\");\n      ParseLanes(left_lane_node, carla::road::LaneType::Left, map_builder);\n      ParseLanes(center_lane_node, carla::road::LaneType::Center, map_builder);\n      ParseLanes(right_lane_node, carla::road::LaneType::Right, map_builder);\n    }\n  }\n}", "CodeBleu_score": 47.66826511974999}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n/*\n * This line of code, xml.child(\"OpenDRIVE\"), retrieves the first child element of the XML document with the name \"OpenDRIVE\".", "CodeBleu_score": 17.678961237183508}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tstd::cout << \"Publisher matched.\" << std::endl;\n\t}\n\telse if (info.current_count_change == -1) {\n\t\tstd::cout << \"Publisher unmatched.\" << std::endl;\n\t}\n\telse {\n\t\tstd::cerr << \"Listener: on_publication_matched: \" << info.current_count_change << \" is an invalid current count change.\" << std::endl;\n\t}\n}", "CodeBleu_score": 58.09101724971817}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tmatched_count_++;\n\t\tstd::cout << \"Publisher matched.\" << std::endl;\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_count_--;\n\t\tstd::cout << \"Publisher unmatched.\" << std::endl;\n\t} else {\n\t\tstd::cerr << \"Listener: on_publication_matched: invalid current_count_change: \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 56.55662247267102}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tmatched_count_++;\n\t\tstd::cout << \"Listener matched.\" << std::endl;\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_count_--;\n\t\tstd::cout << \"Listener unmatched.\" << std::endl;\n\t} else {\n\t\tstd::cout << \"Listener: \" << info.current_count_change << \" is an invalid count change.\" << std::endl;\n\t}\n}", "CodeBleu_score": 56.13679424462347}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tmatched_count++;\n\t\tfirst_connected = true;\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_count--;\n\t\tif (matched_count == 0) {\n\t\t\treader->get_subscriber()->delete_contained_entities();\n\t\t}\n\t} else {\n\t\tstd::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: \" << info.current_count_change << \" is an invalid change count.\n\";\n\t}\n}", "CodeBleu_score": 53.97077483658257}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tmatched_count_++;\n\t\tfirst_connected_ = true;\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_count_--;\n\t\tif (matched_count_ == 0) {\n\t\t\treader->get_subscriber()->delete_contained_entities();\n\t\t}\n\t} else {\n\t\tstd::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: \" << info.current_count_change << \" is an invalid change count.\" << std::endl;\n\t}\n}", "CodeBleu_score": 55.120384426189496}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tstd::cout << \"Subscriber matched.\" << std::endl;\n\t\tmatched_count_++;\n\t\tfirst_connected_ = true;\n\t} else if (info.current_count_change == -1) {\n\t\tstd::cout << \"Subscriber unmatched.\" << std::endl;\n\t\tmatched_count_--;\n\t\tif (matched_count_ == 0) {\n\t\t\tstd::cout << \"Subscriber destroyed.\" << std::endl;\n\t\t\treader->get_subscriber()->delete_datareader(reader);\n\t\t\tdelete this;\n\t\t}\n\t} else {\n\t\tstd::cerr << \"SubscriberListener: on_subscription_matched: unknown current_count_change: \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 53.52454965688689}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n\t\t\tCarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n\t\tm_md5.init();\n\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\t(*handle).value[i] = m_md5.digest[i];\n\t\t}\n\t} else {\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\t(*handle).value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 88.00703549698676}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\tp_type->serializeKey(ser);\n\tunsigned char* keyBuffer = ser.getBuffer();\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize()>16) {\n\t\tm_md5.init();\n\t\tm_md5.update(keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor(uint8_t i = 0;i<16;++i) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t}\n\telse {\n\t\tfor(uint8_t i = 0;i<16;++i) {\n\t\t\thandle->value[i] = keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 76.57514381447302}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n\t\tm_md5.init();\n\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t}\n\telse {\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 92.03796617295504}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\n\ttry {\n\t\tser.serialize(p_type->throttle);\n\t\tser.serialize(p_type->brake);\n\t\tser.serialize(p_type->steering);\n\t\tser.serialize(p_type->hand_brake);\n\t\tser.serialize(p_type->reverse);\n\t\tser.serialize(p_type->gear);\n\t\tser.serialize(p_type->manual_gear_shift);\n\t\tser.serialize(p_type->clutch);\n\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\n\tpayload->length = (uint32_t)ser.getSerializedDataLength();\n\treturn true;\n}", "CodeBleu_score": 68.9779986668335}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\ttry {\n\t\tser.serialize(p_type->m_steer);\n\t\tser.serialize(p_type->m_throttle);\n\t\tser.serialize(p_type->m_brake);\n\t\tser.serialize(p_type->m_hand_brake);\n\t\tser.serialize(p_type->m_reverse);\n\t\tser.serialize(p_type->m_gear);\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\tpayload->length = (uint32_t)ser.getSerializedDataLength();\n\treturn true;\n}", "CodeBleu_score": 70.36711873176299}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\ttry {\n\t\tser.serialize(p_type->throttle);\n\t\tser.serialize(p_type->steering);\n\t\tser.serialize(p_type->brake);\n\t\tser.serialize(p_type->hand_brake);\n\t\tser.serialize(p_type->reverse);\n\t\tser.serialize(p_type->gear);\n\t\tser.serialize(p_type->manual_gear_shift);\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\treturn true;\n}", "CodeBleu_score": 83.88698524152855}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// Decode message\n\tmavlink_message_t message;\n\tmavlink_status_t status;\n\tmavlink_status_t *status_ptr = &status;\n\tmavlink_status_t *status_ptr_null = NULL;\n\tmavlink_status_t *status_ptr_out = status_ptr;\n\n\tmavlink_message_t *message_ptr = &message;\n\tmavlink_message_t *message_ptr_null = NULL;\n\tmavlink_message_t *message_ptr_out = message_ptr;\n\n\tmavlink_msg_decode(&msg, status_ptr_out, message_ptr_out);\n\n\t// Check if the target has been set\n\tif (target_sysid!= 0) {\n\t\tif (message.sysid!= target_sysid) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t// Set the target system ID\n\t\ttarget_sysid = message.sysid;\n\t}\n\n\t// Request position and air pressure data streams\n\tif (target_sysid!= 0) {\n\t\tif (!position_stream_sent) {\n\t\t\t// Request position data stream\n\t\t\tmavlink_msg_request_data_stream_pack(target_sysid, target_compid, msg.sysid, msg.compid, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\t\tposition_stream_sent = true;\n\t\t}\n\t\tif (!pressure_stream_sent) {\n\t\t\t// Request air pressure data stream\n\t\t\tmavlink_msg_request_data_stream_pack(target_sysid, target_compid, msg.sysid, msg.compid, MAV_DATA_STREAM_EXTRA1, 1, 1);\n\t\t\tpressure_stream_sent = true;\n\t\t}\n\t}\n\n\t// Check if the message type is one that should be tracked\n\tif (message.msgid == MAVLINK_MSG_ID_GPS_RAW_INT || message.msgid == MAVLINK_MSG_ID_GLOBAL_POSITION_INT || message.msgid == MAVLINK_MSG_ID_VFR_HUD || message.msgid == MAVLINK_MSG_ID", "CodeBleu_score": 37.40599848184536}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n\tcase MAVLINK_MSG_ID_VFR_HUD:\n\tcase MAVLINK_MSG_ID_ATTITUDE:\n\tcase MAVLINK_MSG_ID_GPS_RAW_INT:\n\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (target_sysid == 0) {\n\t\ttarget_sysid = msg.sysid;\n\t\trequest_data_stream(target_sysid, 1, 1000000);\n\t\trequest_data_stream(target_sysid, 3, 1000000);\n\t}\n\n\ttarget_set = true;\n}", "CodeBleu_score": 28.924088221110615}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) return;\n\n\tswitch (msg.msgid) {\n\t\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT: {\n\t\t\tmavlink_global_position_int_t packet;\n\t\t\tmavlink_msg_global_position_int_decode(&msg, &packet);\n\t\t\tif (packet.time_boot_ms < 10000) return;\n\t\t\tif (packet.time_boot_ms > 1000000000) return;\n\t\t\tif (packet.lat < -900000000 || packet.lat > 900000000) return;\n\t\t\tif (packet.lon < -1800000000 || packet.lon > 1800000000) return;\n\t\t\tif (packet.alt < -10000 || packet.alt > 10000000) return;\n\t\t\tif (packet.vx < -32768 || packet.vx > 32767) return;\n\t\t\tif (packet.vy < -32768 || packet.vy > 32767) return;\n\t\t\tif (packet.vz < -32768 || packet.vz > 32767) return;\n\t\t\tif (packet.hdg < 0 || packet.hdg > 36000) return;\n\t\t\tif (packet.relative_alt < -10000 || packet.relative_alt > 10000000) return;\n\n\t\t\tif (!target_sysid) {\n\t\t\t\ttarget_sysid = packet.sysid;\n\t\t\t\trequest_data_stream(target_sysid, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\t\t\trequest_data_stream(target_sysid, MAV_DATA_STREAM_EXTRA1, 1, 1);\n\t\t\t}\n\t\t\ttarget_set = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase MAVLINK_MSG_ID_GPS_RAW_INT: {\n\t\t\tmavlink_gps_raw_int_t packet;\n\t\t\tmavlink_msg_gps_raw_int_decode(&msg", "CodeBleu_score": 33.23319628232665}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_calibration_needed |= CAL_BARO;\n\t}\n\treturn result;\n}", "CodeBleu_score": 59.632852446937676}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = Tracker::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 62.328966559045554}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\tbaro_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.464660361221796}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// TODO: implement\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 8.484763582851587}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\tTracker::arm();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\tTracker::disarm();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 52.94690267844406}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\tTracker::arm();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\tTracker::disarm();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 46.79240161257378}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tuint8_t chan;\n\tuint8_t i;\n\tuint8_t j;\n\tuint8_t found = 0;\n\tuint8_t chan_count = 0;\n\tuint8_t chan_list[GCS_MAX_CHANNELS];\n\n\t// check if we are already streaming this data\n\tfor (i = 0; i < _num_datastreams; i++) {\n\t\tif (_datastreams[i].sysid == sysid && _datastreams[i].compid == compid) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// check if we have space for another datastream\n\tif (_num_datastreams >= GCS_MAX_DATASTREAMS) {\n\t\treturn;\n\t}\n\n\t// check if we have space for another channel\n\tfor (i = 0; i < _num_channels; i++) {\n\t\tif (_channels[i].payload_space() > 0) {\n\t\t\tchan_list[chan_count++] = i;\n\t\t}\n\t}\n\n\tif (chan_count == 0) {\n\t\treturn;\n\t}\n\n\t// find a channel that is not already streaming this data\n\tfor (i = 0; i < _num_datastreams; i++) {\n\t\tfor (j = 0; j < chan_count; j++) {\n\t\t\tif (_channels[chan_list[j]].stream_id == _datastreams[i].stream_id) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// if we found a channel, start the data stream on it\n\tif (found) {\n\t\t_channels[chan_list[j]].start_request(MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 10);\n\t\t_datastreams[_num_datastreams].stream_id = _channels[chan_list[j]].stream_id;\n\t\t_datastreams[_num_datastreams].sysid = sysid;\n\t\t_datastreams[_num_datastreams].compid = compid;\n\t\t_num_datastreams++;\n\t}\n}", "CodeBleu_score": 38.4986538173033}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i=0; i<GCS_MAX_CHANNELS; i++) {\n\t\tif (g.channel_used[i]) {\n\t\t\tif (gcs[i].available_payload_space() > 15) {\n\t\t\t\tgcs[i].send_message(MSG_REQUEST_DATA_STREAM, sysid, compid, 0, 1, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 43.4693654625566}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tif (sysid == 0 || compid == 0) {\n\t\treturn;\n\t}\n\n\t// check if we have a channel with space available\n\tfor (int i = 0; i < C_MAX_GCS; i++) {\n\t\tif (gcs[i]!= NULL) {\n\t\t\tif (gcs[i]->space_left() > 10) {\n\t\t\t\tgcs[i]->send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, sysid, compid, MAV_DATA_STREAM_POSITION, 1000000/50, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.40877888801596}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = AHRS::get_instance();\n\tif (ahrs == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Check for zero pitch cosine\n\tif (cosf(pitch) == 0.0f) {\n\t\treturn false;\n\t}\n\n\t// Calculate earth frame pitch and yaw\n\tef_pitch = atanf(sinf(pitch) / cosf(pitch) * cosf(ahrs->get_roll()));\n\tef_yaw = yaw + ahrs->get_yaw();\n\n\treturn true;\n}", "CodeBleu_score": 47.69866790421854}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = ahrs_get_instance();\n\tif (ahrs == NULL) {\n\t\treturn false;\n\t}\n\n\tfloat cos_pitch = cosf(pitch);\n\tif (fabsf(cos_pitch) > 0.001f) {\n\t\tef_pitch = atan2f(sinf(pitch), cosf(pitch) * cosf(ahrs->get_roll()));\n\t\tef_yaw = yaw + ahrs->get_yaw();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 47.08596961257705}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = AHRS::getInstance();\n\tif (ahrs->get_pitch_cosine()!= 0) {\n\t\tef_pitch = atan2(sin(pitch), cos(pitch) * ahrs->get_pitch_cosine()) * 180.0 / PI;\n\t\tef_yaw = yaw - ahrs->get_yaw();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.92446827784509}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// if we are not in auto mode, do nothing\n\tif (!auto_mode) {\n\t\treturn;\n\t}\n\n\t// update target yaw and pitch\n\ttarget_yaw = (int16_t) (navigation.get_target_yaw() * 100);\n\ttarget_pitch = (int16_t) (navigation.get_target_pitch() * 100);\n\n\t// check if the direction is reversed\n\tif (navigation.get_direction() == DIRECTION_REVERSE) {\n\t\ttarget_yaw = -target_yaw;\n\t\ttarget_pitch = -target_pitch;\n\t}\n\n\t// calculate angle errors\n\tangle_error_yaw = target_yaw - tracker.get_yaw();\n\tangle_error_pitch = target_pitch - tracker.get_pitch();\n\n\t// convert errors from earth frame to body frame\n\tangle_error_yaw = (int16_t) (angle_error_yaw * cos(navigation.get_pitch() * M_PI / 18000));\n\tangle_error_pitch = (int16_t) (angle_error_pitch * cos(navigation.get_yaw() * M_PI / 18000));\n\n\t// if the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n\tif (navigation.get_target_distance() == 0 || navigation.get_min_distance() == 0) {\n\t\ttracker.set_yaw(angle_error_yaw);\n\t\ttracker.set_pitch(angle_error_pitch);\n\t}\n}", "CodeBleu_score": 37.18404688878793}, {"code": "void Mode::update_auto(void){\n\t\tfloat target_yaw = 0.0f;\n\tfloat target_pitch = 0.0f;\n\tfloat yaw_error = 0.0f;\n\tfloat pitch_error = 0.0f;\n\tfloat distance = 0.0f;\n\tfloat target_distance = 0.0f;\n\tfloat distance_error = 0.0f;\n\tfloat target_altitude = 0.0f;\n\tfloat altitude_error = 0.0f;\n\tfloat target_speed = 0.0f;\n\tfloat speed_error = 0.0f;\n\tfloat target_speed_error = 0.0f;\n\tfloat target_altitude_error = 0.0f;\n\tfloat target_speed_error_rate = 0.0f;\n\tfloat target_altitude_error_rate = 0.0f;\n\tfloat target_speed_error_rate_error = 0.0f;\n\tfloat target_altitude_error_rate_error = 0.0f;\n\tfloat target_speed_error_rate_error_rate = 0.0f;\n\tfloat target_altitude_error_rate_error_rate = 0.0f;\n\tfloat target_speed_error_rate_error_rate_error = 0.0f;\n\tfloat target_altitude_error_rate_error_rate_error = 0.0f;\n\tfloat target_speed_error_rate_error_rate_error_rate = 0.0f;\n\tfloat target_altitude_error_rate_error_rate_error_rate = 0.0f;\n\tfloat target_speed_error_rate_error_rate_error_rate_error = 0.0f;\n\tfloat target_altitude_error_rate_error_rate_error_rate_error = 0.0f;\n\tfloat target_speed_error_rate_error_rate_error_rate_error_rate = 0.0f;\n\tfloat target_altitude_error_rate_error_rate_error_rate_error_rate = 0.0f;\n\tfloat target_speed_error_rate_error_rate_error_rate_", "CodeBleu_score": 4.513024729156717}, {"code": "void Mode::update_auto(void){\n\t\t// Calculate yaw and pitch in centidegrees\n\tint32_t yaw_cd = (int32_t)(100.0 * (float)yaw_angle);\n\tint32_t pitch_cd = (int32_t)(100.0 * (float)pitch_angle);\n\n\t// Check if the direction is reversed\n\tif (direction_reversed) {\n\t\tyaw_cd = -yaw_cd;\n\t\tpitch_cd = -pitch_cd;\n\t}\n\n\t// Compute the angle error\n\tint32_t yaw_error = yaw_cd - yaw_servo.get_angle();\n\tint32_t pitch_error = pitch_cd - pitch_servo.get_angle();\n\n\t// Convert the errors from earth frame to body frame\n\tint32_t yaw_error_bf = yaw_error * cos_pitch_angle + pitch_error * sin_pitch_angle;\n\tint32_t pitch_error_bf = pitch_error * cos_pitch_angle - yaw_error * sin_pitch_angle;\n\n\t// If the target distance is valid or no minimum distance is set\n\tif (target_distance >= 0 || min_distance == 0) {\n\t\t// Update the pitch and yaw servos\n\t\tyaw_servo.set_angle(yaw_servo.get_angle() + yaw_error_bf);\n\t\tpitch_servo.set_angle(pitch_servo.get_angle() + pitch_error_bf);\n\t}\n}", "CodeBleu_score": 31.578542974991674}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tif (GPS.update()) {\n\t\tif (GPS.lastNMEA()!= last_GPS_time) {\n\t\t\tlast_GPS_time = GPS.lastNMEA();\n\t\t\tif (GPS.fix()) {\n\t\t\t\tif (GPS.fix_age() < 1000) {\n\t\t\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\t\t\tif (GPS.latitudeDegrees() > 0 && GPS.longitudeDegrees() > 0) {\n\t\t\t\t\t\t\thome_lat = GPS.latitudeDegrees();\n\t\t\t\t\t\t\thome_lon = GPS.longitudeDegrees();\n\t\t\t\t\t\t\thome_alt = GPS.altitude();\n\t\t\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tground_start_countdown = 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.6120806609079}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update GPS data\n\tgps.update();\n\n\t// Check if the GPS has new data\n\tif (gps.last_message_time!= last_gps_message_time) {\n\t\tlast_gps_message_time = gps.last_message_time;\n\n\t\t// Check if the GPS has a valid 3D fix\n\t\tif (gps.status >= 3) {\n\t\t\t// Check if the GPS is initializing\n\t\t\tif (gps_init_countdown > 0) {\n\t\t\t\t// Check if the GPS has a valid location\n\t\t\t\tif (gps.latitude!= 0 && gps.longitude!= 0) {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\thome_latitude = gps.latitude;\n\t\t\t\t\thome_longitude = gps.longitude;\n\t\t\t\t\thome_altitude = gps.altitude;\n\n\t\t\t\t\t// Reset the countdown\n\t\t\t\t\tgps_init_countdown = 0;\n\t\t\t\t}\n\t\t\t\t// If the GPS has an invalid location, reset the countdown\n\t\t\t\telse {\n\t\t\t\t\tgps_init_countdown = GPS_INIT_COUNTDOWN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if the GPS is initializing\n\tif (gps_init_countdown > 0) {\n\t\t// Decrement the countdown\n\t\tgps_init_countdown--;\n\t}\n}", "CodeBleu_score": 40.25229571325205}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update the GPS data\n\tgps.update();\n\n\t// Check if the last message time has changed and if the GPS status is at least 3D fix\n\tif (gps.last_message_time!= last_message_time && gps.status >= 3) {\n\t\t// Update the last message time\n\t\tlast_message_time = gps.last_message_time;\n\n\t\t// Check if the ground start countdown is active\n\t\tif (ground_start_countdown) {\n\t\t\t// Check if the current location is valid\n\t\t\tif (gps.location.lat!= 0 && gps.location.lng!= 0) {\n\t\t\t\t// Set the home location\n\t\t\t\thome_location = gps.location;\n\n\t\t\t\t// Disable the ground start countdown\n\t\t\t\tground_start_countdown = false;\n\t\t\t} else {\n\t\t\t\t// Reset the ground start countdown\n\t\t\t\tground_start_countdown = 10;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if the ground start countdown is active\n\tif (ground_start_countdown) {\n\t\t// Decrement the ground start countdown\n\t\tground_start_countdown--;\n\t}\n}", "CodeBleu_score": 39.03068813503114}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif(pitch > 0) {\n\t\t_pitch_onoff_servo->writeMicroseconds(1100);\n\t} else if(pitch < 0) {\n\t\t_pitch_onoff_servo->writeMicroseconds(1900);\n\t} else {\n\t\t_pitch_onoff_servo->writeMicroseconds(1500);\n\t}\n}", "CodeBleu_score": 15.951707839895866}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif(pitch > 0.0f) {\n\t\tif(pitch > 10.0f) {\n\t\t\tpitch = 10.0f;\n\t\t}\n\t\tpitch_onoff_servo.write(pitch);\n\t} else {\n\t\tpitch_onoff_servo.write(0.0f);\n\t}\n}", "CodeBleu_score": 14.838668077548595}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 10) {\n\t\tpitch_servo.write(180);\n\t}\n\telse {\n\t\tpitch_servo.write(0);\n\t}\n}", "CodeBleu_score": 13.135059659984355}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool ret = AP_Arming::barometer_checks(display_failure);\n\tif (!ret) {\n\t\treturn false;\n\t}\n\tif (g.arming_check & ARMING_CHECK_BARO) {\n\t\t// check barometer reference\n\t\tif (!barometer_reference_valid()) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"baro ref not valid\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t// check baro altitude\n\t\tif (fabsf(ahrs.get_altitude() - baro_alt_cms) > g.baro_alt_check_enabled) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"baro alt check failed\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 41.439638318073094}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call base class\n\tbool ret = AP_Arming::barometer_checks(display_failure);\n\n\t// check barometer reference\n\tif (ret && g.arming_check & ARMING_CHECK_BARO) {\n\t\t// check barometer reference\n\t\tif (barometer.get_pressure() == 0) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"baro ref fail\"));\n\t\t\t}\n\t\t\tret = false;\n\t\t}\n\n\t\t// check baro altitude\n\t\tif (ret) {\n\t\t\tfloat baro_alt = barometer.get_altitude();\n\t\t\tfloat inertial_alt = inertial_nav.get_altitude();\n\t\t\tif (fabs(baro_alt - inertial_alt) > g.arming_check_alt_max_diff) {\n\t\t\t\tif (display_failure) {\n\t\t\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"baro alt fail\"));\n\t\t\t\t}\n\t\t\t\tret = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 47.281566276350496}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call base class barometer checks\n\tbool ret = AP_Arming::barometer_checks(display_failure);\n\tif (!ret) {\n\t\treturn false;\n\t}\n#if ARMING_CHECK_BARO == ENABLED\n\t// check barometer reference\n\tif (!barometer.healthy()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"Barometer not healthy\"));\n\t\t}\n\t\treturn false;\n\t}\n\t// check baro altitude\n\tif (!barometer.update()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"Barometer update failed\"));\n\t\t}\n\t\treturn false;\n\t}\n\tfloat baro_alt = barometer.get_altitude();\n\tfloat diff = baro_alt - ahrs.get_home().alt;\n\tif (fabsf(diff) > g.arming_check_alt_max) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"Baro alt: %.1f home alt: %.1f diff: %.1f\"), baro_alt, ahrs.get_home().alt, diff);\n\t\t}\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}", "CodeBleu_score": 44.02757492785469}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (g.rtl_altitude_source == RTL_ALTITUDE_SOURCE_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 31.01744409547732}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (g.rtl_altitude_source == RTL_ALTITUDE_SOURCE_TERRAIN && g.rtl_altitude_type == RTL_ALTITUDE_TYPE_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 43.76058683101371}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (g.terrain_source == TERRAIN_SOURCE_RANGEFINDER) {\n\t\treturn false;\n\t}\n\tif (g.terrain_source == TERRAIN_SOURCE_TERRAIN_DATABASE && g.rtl_altitude_type == RTL_ALTITUDE_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 59.158976187724875}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for attitude, position, and motor controllers\n\t// using the last loop time from the scheduler\n\t_loop_rate = _scheduler->get_loop_time_usec();\n\n\t// run the low-level rate controllers that require only IMU data\n\t// by invoking the rate_controller_run method of the attitude control\n\t_attitude_control.rate_controller_run();\n}", "CodeBleu_score": 14.329921918766095}, {"code": "void Copter::run_rate_controller(){\n\t\t// run the rate controller at the rate defined by the scheduler\n\trate_controller_run(dt_att_ctrl);\n}", "CodeBleu_score": 6.191745513986653}, {"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for the attitude controller\n\t_attitude_control.set_loop_time(_dt);\n\n\t// set the loop time for the position controller\n\t_position_control.set_loop_time(_dt);\n\n\t// run the low-level rate controllers\n\t_attitude_control.rate_controller_run();\n}", "CodeBleu_score": 41.2835016117613}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// check if we have a new waypoint to set\n\tif (new_loc == old_loc) {\n\t\treturn false;\n\t}\n\n\t// check if we have a new waypoint to set\n\tif (new_loc.alt_frame()!= old_loc.alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// we have a new waypoint to set\n\t_target_loc = new_loc;\n\treturn true;\n}", "CodeBleu_score": 44.035193217301725}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.alt_frame()!= new_loc.alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set the new target\n\t_target_location = new_loc;\n\t_target_location.set_alt_frame(old_loc.alt_frame());\n\n\treturn true;\n}", "CodeBleu_score": 53.27656976148617}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// if the old location matches the new location, don't update\n\tif (old_loc == new_loc) {\n\t\treturn false;\n\t}\n\n\t// if the altitude frames don't match, don't update\n\tif (old_loc.alt_frame()!= new_loc.alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// update the target location\n\ttarget_location = new_loc;\n\n\t// we have a new target\n\treturn true;\n}", "CodeBleu_score": 44.468558766949975}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode == Mode::Number::MANUAL) {\n\t\t\tset_mode(Mode::Number::MANUAL);\n\t\t} else if (mode == Mode::Number::STABILIZE) {\n\t\t\tset_mode(Mode::Number::STABILIZE);\n\t\t} else if (mode == Mode::Number::ACRO) {\n\t\t\tset_mode(Mode::Number::ACRO);\n\t\t} else if (mode == Mode::Number::ALT_HOLD) {\n\t\t\tset_mode(Mode::Number::ALT_HOLD);\n\t\t} else if (mode == Mode::Number::AUTO) {\n\t\t\tset_mode(Mode::Number::AUTO);\n\t\t} else if (mode == Mode::Number::GUIDED) {\n\t\t\tset_mode(Mode::Number::GUIDED);\n\t\t} else if (mode == Mode::Number::CIRCLE) {\n\t\t\tset_mode(Mode::Number::CIRCLE);\n\t\t} else if (mode == Mode::Number::POSITION) {\n\t\t\tset_mode(Mode::Number::POSITION);\n\t\t} else if (mode == Mode::Number::LAND) {\n\t\t\tset_mode(Mode::Number::LAND);\n\t\t} else if (mode == Mode::Number::OF_LOITER) {\n\t\t\tset_mode(Mode::Number::OF_LOITER);\n\t\t} else if (mode == Mode::Number::DRIFT) {\n\t\t\tset_mode(Mode::Number::DRIFT);\n\t\t} else if (mode == Mode::Number::SPORT) {\n\t\t\tset_mode(Mode::Number::SPORT);\n\t\t} else if (mode == Mode::Number::FLIP) {\n\t\t\tset_mode(Mode::Number::FLIP);\n\t\t} else if (mode == Mode::Number::AUTOTUNE) {\n\t\t\tset_mode(Mode::Number::AUTOTUNE);\n\t\t} else if (mode == Mode::Number::POSHOLD) {\n\t\t\tset_mode(Mode::Number::POSHOLD);\n\t\t} else if (mode == Mode::Number::BRAKE) {\n\t\t\tset_mode(Mode::Number::BRAKE);\n\t\t} else if (mode == Mode::Number::THROW) {\n\t\t\tset_mode(Mode::", "CodeBleu_score": 33.73031675755757}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (rc().aux_channel_mode(ch_flag) == AUX_SWITCH_HIGH) {\n\t\tif (!set_mode(mode)) {\n\t\t\t// failed to set mode, so reset the mode switch\n\t\t\trc().reset_mode_switch(ch_flag);\n\t\t}\n\t} else if (mode_id == mode) {\n\t\t// reset the mode switch\n\t\trc().reset_mode_switch(ch_flag);\n\t}\n}", "CodeBleu_score": 45.533916880926114}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (rc().aux_channel(AUX_FUNCTION_CH_INDEX).get_position() == ch_flag) {\n\t\tif (mode == mode_id) {\n\t\t\trc().reset_mode_switch();\n\t\t} else {\n\t\t\tset_mode(mode);\n\t\t}\n\t}\n}", "CodeBleu_score": 46.907484690765244}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// save the current roll and pitch trim values\n\t// this is done by calculating the trim values from the control inputs of the roll and pitch channels\n\t// and adding them to the AHRS trim\n\t// the trim values are then saved to the EEPROM\n\n\t// calculate the trim values from the control inputs of the roll and pitch channels\n\t// and add them to the AHRS trim\n\t// the trim values are then saved to the EEPROM\n\t// if the current channel mode is manual\n\tif (control_mode == MANUAL) {\n\t\t// calculate the trim values from the control inputs of the roll and pitch channels\n\t\t// and add them to the AHRS trim\n\t\t// the trim values are then saved to the EEPROM\n\t\t// if the current channel mode is manual\n\t\t// if the roll channel is active\n\t\tif (g.rc_1.control_in > 0) {\n\t\t\t// calculate the trim value from the roll channel control input\n\t\t\t// and add it to the AHRS trim\n\t\t\t// the trim value is then saved to the EEPROM\n\t\t\tahrs.set_trim(ahrs.roll_trim + ((g.rc_1.control_in - 1500) / 500.0f) * radians(20), ahrs.pitch_trim, ahrs.yaw_trim);\n\t\t}\n\n\t\t// if the pitch channel is active\n\t\tif (g.rc_2.control_in > 0) {\n\t\t\t// calculate the trim value from the pitch channel control input\n\t\t\t// and add it to the AHRS trim\n\t\t\t// the trim value is then saved to the EEPROM\n\t\t\tahrs.set_trim(ahrs.roll_trim, ahrs.pitch_trim + ((g.rc_2.control_in - 1500) / 500.0f) * radians(20), ahrs.yaw_trim);\n\t\t}\n\t}\n\n\t// log the event\n\tLog_Write_Event(DATA_TRIM_SAVE);\n\n\t// send a confirmation message with MAV_SEVERITY_INFO\n\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"Saved Trim\"));\n}", "CodeBleu_score": 38.07662372770487}, {"code": "void Copter::save_trim(){\n\t\t// save roll trim\n\tg.channel_roll->trim_save();\n\n\t// save pitch trim\n\tg.channel_pitch->trim_save();\n\n\t// log event\n\tLog_Write_Event(DATA_TRIM_SAVE);\n\n\t// send message\n\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Trim saved\"));\n}", "CodeBleu_score": 20.57960549209371}, {"code": "void Copter::save_trim(){\n\t\t// save roll trim\n\tfloat trim_roll_rad = (g.rc_1.control_in - 1500) / 1000.0f * radians(g.rc_1.get_trim());\n\tahrs.set_trim(trim_roll_rad, 0, 0);\n\n\t// save pitch trim\n\tfloat trim_pitch_rad = (g.rc_2.control_in - 1500) / 1000.0f * radians(g.rc_2.get_trim());\n\tahrs.set_trim(0, trim_pitch_rad, 0);\n\n\t// log the event\n\tLog_Write_Event(DATA_TRIM_SAVE);\n\n\t// send confirmation message\n\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Saved trim\"));\n}", "CodeBleu_score": 42.19773555586549}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tVector3f vel = _copter->get_velocity();\n\tfloat vel_sq = vel.length_squared();\n\tif (_copter->get_position().is_zero() || vel_sq < 1.0f) {\n\t\treturn 0.0f;\n\t}\n\n\treturn atan2f(vel.y, vel.x);\n}", "CodeBleu_score": 35.61024330210376}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// get velocity\n\tVector3f vel = _vfr_land_speed.vel_xy;\n\n\t// calculate speed squared\n\tfloat vel_sq = vel.length_squared();\n\n\t// if position is valid and speed exceeds a minimum threshold, update look-ahead yaw angle\n\tif (_ahrs.get_position_ok() && vel_sq > 1.0f) {\n\t\t// update look-ahead yaw angle\n\t\t_look_ahead_yaw = atan2f(vel.y, vel.x);\n\t}\n\n\t// return computed look-ahead yaw angle\n\treturn _look_ahead_yaw;\n}", "CodeBleu_score": 40.56904033365901}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tVector2f vel = _parent->get_velocity();\n\tfloat speed_sq = vel.length_squared();\n\tif (_parent->get_position().is_zero() || speed_sq < sq(MIN_SPEED_FOR_LOOK_AHEAD)) {\n\t\treturn 0.0f;\n\t}\n\treturn atan2f(vel.y, vel.x);\n}", "CodeBleu_score": 38.57154828341115}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (g.arming_check == ARMING_CHECK_RUDDER_DISABLED) {\n\t\t\treturn false;\n\t\t}\n\t\tif (g.arming_check == ARMING_CHECK_RUDDER_THROTTLE_ZERO) {\n\t\t\tif (aparm.throttle_zero_for_arming) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (method == AP_Arming::WATCHDOG) {\n\t\tif (g.arming_check == ARMING_CHECK_WATCHDOG_DISABLED) {\n\t\t\treturn true;\n\t\t}\n\t\tif (g.arming_check == ARMING_CHECK_WATCHDOG_ARMED) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 50.05854255936495}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\t// rudder arming is disabled\n\t\tif (g.arming_check == ARMING_CHECK_RUDDER) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// throttle not zero\n\t\tif (g.rc_3.control_in > 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// watchdog armed\n\tif (g.arming_check == ARMING_CHECK_WATCHDOG && watchdog_armed) {\n\t\treturn true;\n\t}\n\n\t// parent class checks\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 45.994028082060275}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// RUDDER method\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (g.arming_check == ARMING_CHECK_RUDDER) {\n\t\t\t// rudder arming is disabled\n\t\t\treturn false;\n\t\t}\n\t\tif (g.arming_check == ARMING_CHECK_THROTTLE) {\n\t\t\t// throttle is not zero\n\t\t\tif (g.rc_3.control_in > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// watchdog armed\n\tif (g.arming_check == ARMING_CHECK_WATCHDOG) {\n\t\tif (ap.watchdog_armed) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// call parent class\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 46.86595835979264}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool ret = false;\n\tif (method == AP_Arming::Method::Manual) {\n\t\tif (do_arming_checks) {\n\t\t\tif (arming_checks()) {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t} else {\n\t\t\tret = true;\n\t\t}\n\t} else if (method == AP_Arming::Method::Auto) {\n\t\tif (do_arming_checks) {\n\t\t\tif (arming_checks()) {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t} else {\n\t\t\tret = true;\n\t\t}\n\t}\n\tif (ret) {\n\t\t// set home location\n\t\tif (ahrs.get_home_position()!= nullptr) {\n\t\t\tahrs.get_home_position()->set_position(ahrs.get_latitude(), ahrs.get_longitude(), ahrs.get_altitude());\n\t\t}\n\t\t// set home location in AHRS\n\t\tahrs.set_home_position(ahrs.get_latitude(), ahrs.get_longitude(), ahrs.get_altitude());\n\t\t// set current location\n\t\tahrs.set_current_position(ahrs.get_latitude(), ahrs.get_longitude(), ahrs.get_altitude());\n\t\t// set the armed state\n\t\tset_armed(true);\n\t\t// set the delay arming flag\n\t\tset_delay_arming(true);\n\t\t// send status text\n\t\tgcs().send_text_P(SEVERITY_LOW, PSTR(\"Armed by %s\"), method == AP_Arming::Method::Manual? \"manual\" : \"auto\");\n\t}\n\treturn ret;\n}", "CodeBleu_score": 38.62489166866526}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// sanity check\n\tif (!ahrs) {\n\t\treturn false;\n\t}\n\n\t// check if already armed\n\tif (armed()) {\n\t\treturn false;\n\t}\n\n\t// check if the plane is landed\n\tif (method == AP_Arming::Method::Auto &&!is_landed()) {\n\t\treturn false;\n\t}\n\n\t// check if the plane is landed\n\tif (method == AP_Arming::Method::Auto &&!is_landed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a valid arming state\n\tif (do_arming_checks &&!valid_arming_state()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a valid arming state\n\tif (do_arming_checks &&!valid_arming_state()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a valid arming state\n\tif (do_arming_checks &&!valid_arming_state()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a valid arming state\n\tif (do_arming_checks &&!valid_arming_state()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a valid arming state\n\tif (do_arming_checks &&!valid_arming_state()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a valid arming state\n\tif (do_arming_checks &&!valid_arming_state()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a valid arming state\n\tif (do_arming_checks &&!valid_arming_state()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a valid arming state\n\tif (do_arming_checks &&!valid_arming_state()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a valid arming state\n\tif (do_arming_checks &&!valid_arming_state()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a valid arming state\n\tif (do_", "CodeBleu_score": 36.907826883824086}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// do the arming checks if requested\n\tif (do_arming_checks &&!arming_checks()) {\n\t\treturn false;\n\t}\n\n\t// check if we are already armed\n\tif (motors->armed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in the right mode\n\tif (mode!= Plane::STABILIZE && mode!= Plane::ALT_HOLD && mode!= Plane::AUTO) {\n\t\treturn false;\n\t}\n\n\t// check if we are in the right state\n\tif (state!= Plane::MANUAL) {\n\t\treturn false;\n\t}\n\n\t// check if we have enough throttle\n\tif (throttle_zero_timer.running()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in the right throttle range\n\tif (throttle_filt < g.throttle_cruise) {\n\t\treturn false;\n\t}\n\n\t// check if we are in the right altitude range\n\tif (alt_filt < g.alt_hold_alt) {\n\t\treturn false;\n\t}\n\n\t// check if we have enough airspeed\n\tif (airspeed_cruise < g.airspeed_cruise) {\n\t\treturn false;\n\t}\n\n\t// check if we have enough battery voltage\n\tif (battery_voltage < g.battery_voltage) {\n\t\treturn false;\n\t}\n\n\t// check if we are in the right roll/pitch range\n\tif (roll_pitch_cd_filt > g.roll_limit * 100 || roll_pitch_cd_filt < -g.roll_limit * 100) {\n\t\treturn false;\n\t}\n\n\t// check if we are in the right yaw range\n\tif (yaw_cd_filt > g.yaw_limit * 100 || yaw_cd_filt < -g.yaw_limit * 100) {\n\t\treturn false;\n\t}\n\n\t// check if we have enough ground speed\n\tif (groundspeed < g.groundspeed_cruise) {\n\t\treturn false;\n\t}\n\n\t// check if we have enough climb rate\n\tif (climb_rate < g.climb_rate_cruise)", "CodeBleu_score": 40.28720323618622}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (_armed.get()) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\tif (!_disarm_button_enabled) {\n\t\tif (display_failure) {\n\t\t\t// no disarm button configured\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"No disarm button\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 62.07342694071885}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// check if we are already armed\n    if (armed.armed) {\n        return true;\n    }\n\n    // check if disarm button is configured\n    if (disarm_button_enabled == false) {\n        if (display_failure) {\n            // display a message\n            AP_Notify::flags.arming_failure = true;\n        }\n        return false;\n    }\n\n    // call the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 63.77894620544248}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tbool ret;\n\n\t/*\n\t * If the vehicle is already armed, return true.\n\t */\n\tif(armed.armed) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * If a disarm button is configured, proceed with the standard pre-arm checks.\n\t */\n\tif(disarm_button_enabled()) {\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t}\n\n\t/*\n\t * If the vehicle is not armed and no disarm button is configured, display a failure message if requested and return false.\n\t */\n\tif(display_failure) {\n\t\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"No disarm button configured\"));\n\t}\n\treturn false;\n}", "CodeBleu_score": 58.20093226310061}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * cos(ahrs_yaw) - y * sin(ahrs_yaw);\n\tfloat ne_y = x * sin(ahrs_yaw) + y * cos(ahrs_yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 56.77417287080549}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * cos(yaw) + y * sin(yaw);\n\tfloat ne_y = y * cos(yaw) - x * sin(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 53.54404660886538}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * cos(ahrs.yaw) + y * sin(ahrs.yaw);\n\tfloat ne_y = -x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 58.593113893386885}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tfloat heading = packet.param1;\n\tfloat condition_yaw_relative = packet.param2;\n\tfloat condition_yaw_speed = packet.param3;\n\tfloat condition_yaw_radius = packet.param4;\n\n\tif (heading < 0.0f || heading > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (condition_yaw_radius < 0.0f || condition_yaw_radius > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (condition_yaw_relative!= 0.0f && condition_yaw_relative!= 1.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (condition_yaw_speed < 0.0f || condition_yaw_speed > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (condition_yaw_speed == 0.0f) {\n\t\t// set yaw angle\n\t\t_yaw_controller.set_yaw_heading(heading, condition_yaw_relative!= 0);\n\t} else {\n\t\t// set yaw speed\n\t\t_yaw_controller.set_yaw_speed(condition_yaw_speed, condition_yaw_relative!= 0);\n\t}\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 31.537543661737544}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t//MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\tMAV_RESULT result = MAV_RESULT_ACCEPTED;\n\t// TODO: Implement MAV_CMD_CONDITION_YAW\n\t//mavlink_command_ack_t ack = {};\n\t//ack.command = MAV_CMD_CONDITION_YAW;\n\t//ack.result = result;\n\t//mavlink_msg_command_ack_send_struct(chan, &ack);\n\treturn result;\n}", "CodeBleu_score": 10.607329839532783}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 0.0f) {\n\t\t// set yaw angle\n\t\tif (packet.param4 >= -180.0f && packet.param4 <= 180.0f) {\n\t\t\t// set yaw heading\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t} else {\n\t\t// set yaw speed\n\t\tif (packet.param4 >= -1.0f && packet.param4 <= 1.0f) {\n\t\t\t// set yaw speed\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.03626113420532}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.150400996515202}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n\t\treturn (uint8_t)(wp_bearing / 2);\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 34.34401791716743}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n\t\treturn (uint8_t)((wp_bearing / 2) + 180);\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 34.64600127722155}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (log_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.data_id = id;\n\t\tpacket.value = value;\n\t\tpacket.time = Time_Get_Time();\n\t\tLog_Write_Critical_Block(packet);\n\t}\n}", "CodeBleu_score": 34.38131435319671}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (logging_enabled) {\n\t\tlog_packet_t packet;\n\t\tpacket.data_id = id;\n\t\tpacket.value = value;\n\t\tpacket.time = get_time_ms();\n\t\tlog_write_critical_block(&packet);\n\t}\n}", "CodeBleu_score": 32.383363429028975}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (Log_Enabled) {\n\t\t// Create a log packet with the current time, log data ID, and value\n\t\tLog_Packet packet;\n\t\tpacket.time = Get_Time();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\n\t\t// Write the packet to the logger as a critical block\n\t\tLog_Write_Critical_Block(&packet, sizeof(Log_Packet));\n\t}\n}", "CodeBleu_score": 38.26158952362972}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_set) {\n\t\treturn;\n\t}\n\tif (motors_armed) {\n\t\tset_home_to_current_location();\n\t\treturn;\n\t}\n\tif (ekf_data.status_bits & (1 << 3)) {\n\t\tset_home_to_current_location();\n\t}\n}", "CodeBleu_score": 27.51358068871157}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_set) {\n\t\treturn;\n\t}\n\n\tif (motors_armed) {\n\t\thome_set = true;\n\t\thome_latitude = current_latitude;\n\t\thome_longitude = current_longitude;\n\t\thome_altitude = current_altitude;\n\t} else {\n\t\tif (current_latitude!= 0 && current_longitude!= 0) {\n\t\t\thome_set = true;\n\t\t\thome_latitude = current_latitude;\n\t\t\thome_longitude = current_longitude;\n\t\t\thome_altitude = current_altitude;\n\t\t}\n\t}\n}", "CodeBleu_score": 18.469516287770922}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_set) {\n\t\treturn;\n\t}\n\n\tif (motors_armed) {\n\t\tset_home(get_EKF_latitude(), get_EKF_longitude(), get_EKF_altitude());\n\t} else {\n\t\tset_home(get_EKF_latitude(), get_EKF_longitude(), get_EKF_altitude());\n\t}\n}", "CodeBleu_score": 21.335815395464614}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\tif(!motorsArmed) {\n\t\tthrottle = 0;\n\t\tspoolState = SPOOL_UNLIMITED;\n\t\tattitudeController.relax();\n\t\treturn;\n\t}\n\tspoolState = SPOOL_UNLIMITED;\n\tattitudeController.setDesiredRates(pilot.getDesiredRates());\n\tattitudeController.run();\n\tthrottle = pilot.getThrottle();\n\tthrottle = throttle * (1 - angleBoost) + angleBoost * attitudeController.getAngleBoost();\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.getThrottleBoost());\n\tthrottle = throttle * (1 - pilot.get", "CodeBleu_score": 38.34449595911659}, {"code": "void ModeAcro::run(){\n\t\t// If motors are not armed, set throttle to zero, adjust spool state, relax attitude controllers, and exit\n\tif (!motorsArmed) {\n\t\tthrottle = 0;\n\t\tspoolState = SPOOL_UNLIMITED;\n\t\tattitudeController.relax();\n\t\treturn;\n\t}\n\n\t// Set spool state to unlimited throttle\n\tspoolState = SPOOL_UNLIMITED;\n\n\t// Convert pilot inputs to desired body frame rates\n\t// TODO: Use the new pilot inputs\n\tdesiredRollRate = pilotRollInput;\n\tdesiredPitchRate = pilotPitchInput;\n\tdesiredYawRate = pilotYawInput;\n\n\t// Run the attitude controller with these rates\n\tattitudeController.run(desiredRollRate, desiredPitchRate, desiredYawRate, roll, pitch, yaw, rollRate, pitchRate, yawRate, &rollInput, &pitchInput, &yawInput);\n\n\t// Output pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls\n\tthrottle = pilotThrottleInput;\n\tforwardMotorInput = pilotForwardInput;\n\tlateralMotorInput = pilotLateralInput;\n}", "CodeBleu_score": 34.84931606763817}, {"code": "void ModeAcro::run(){\n\t\tif (!motorsArmed) {\n\t\t// motors not armed, relax attitude controllers and exit\n\t\tdesiredRates.setZero();\n\t\tdesiredBodyRates.setZero();\n\t\tdesiredAttitude.setIdentity();\n\t\tdesiredBodyAttitude.setIdentity();\n\t\tdesiredThrottle = 0.0f;\n\t\tdesiredForward = 0.0f;\n\t\tdesiredLateral = 0.0f;\n\t\tdesiredYaw = 0.0f;\n\t\tdesiredYawRate = 0.0f;\n\t\tdesiredAltitude = 0.0f;\n\t\tdesiredAltitudeRate = 0.0f;\n\t\tdesiredSpool = SPOOL_IDLE;\n\t\tdesiredSpoolRate = 0.0f;\n\t\treturn;\n\t}\n\n\t// motors armed, set spool state to unlimited throttle\n\tdesiredSpool = SPOOL_UNLIMITED;\n\n\t// convert pilot inputs to desired body frame rates\n\tdesiredBodyRates.x() = pilotInputs.roll * cfg.acroRollRate;\n\tdesiredBodyRates.y() = pilotInputs.pitch * cfg.acroPitchRate;\n\tdesiredBodyRates.z() = pilotInputs.yaw * cfg.acroYawRate;\n\n\t// run attitude controller with these rates\n\tdesiredAttitude = attitudeController.run(desiredBodyRates, desiredBodyAttitude, desiredBodyRates, desiredBodyRates, desiredBodyRates);\n\n\t// output pilot's throttle input without angle boost and set forward and lateral motor inputs based on pilot controls\n\tdesiredThrottle = pilotInputs.throttle;\n\tdesiredForward = pilotInputs.forward;\n\tdesiredLateral = pilotInputs.lateral;\n\tdesiredYaw = 0.0f;\n\tdesiredYawRate = 0.0f;\n\tdesiredAltitude = 0.0f;\n\tdesiredAltitudeRate = 0.0f;\n\tdesiredSpool = SPOOL_UNLIMITED;\n\tdesiredSpoolRate = 0.0f;\n}", "CodeBleu_score": 36.451183008337026}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set to position control mode\n\tset_mode(MODE_POSCTL);\n\n\t// Initialize waypoint controller\n\t_wp_controller.init();\n\n\t// Set stopping point as waypoint destination\n\t_wp_controller.set_destination(_stopping_point);\n\n\t// Initialize yaw\n\t_yaw_mode = YawMode::YAW_MODE_AUTO;\n\t_yaw_sp = _stopping_point.yaw();\n}", "CodeBleu_score": 29.667411655579567}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\tmode_set(MODE_POSCTL);\n\twp_nav.init_waypoint();\n\twp_nav.set_destination(stopping_point);\n\twp_nav.set_default_auto_yaw_mode();\n}", "CodeBleu_score": 24.8785198102218}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set to position control mode\n\tset_mode(Mode::PositionControl);\n\t// Set the waypoint destination to the stopping point\n\twp_controller.set_destination(stopping_point);\n\t// Initialize the yaw\n\tyaw_controller.set_auto_yaw_mode(YawController::AutoYawMode::Default);\n}", "CodeBleu_score": 13.176930430776174}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set the mode to velocity controller\n\tset_mode(MODE_GUIDED);\n\t// set the vertical speed limits\n\tset_vertical_velocity_limit(get_param_float(PARAM_GUIDED_VEL_Z_MAX));\n\tset_vertical_acceleration_limit(get_param_float(PARAM_GUIDED_VEL_Z_ACC));\n\t// initialize the vertical velocity controller\n\t_vel_controller_z.set_max_speed(get_param_float(PARAM_GUIDED_VEL_Z_MAX));\n\t_vel_controller_z.set_max_acceleration(get_param_float(PARAM_GUIDED_VEL_Z_ACC));\n\t_vel_controller_z.set_min_speed(-get_param_float(PARAM_GUIDED_VEL_Z_MAX));\n\t_vel_controller_z.set_min_acceleration(-get_param_float(PARAM_GUIDED_VEL_Z_ACC));\n\t// initialize the horizontal velocity controller\n\t_vel_controller_xy.set_max_speed(get_param_float(PARAM_GUIDED_VEL_XY_MAX));\n\t_vel_controller_xy.set_max_acceleration(get_param_float(PARAM_GUIDED_VEL_XY_ACC));\n\t_vel_controller_xy.set_min_speed(-get_param_float(PARAM_GUIDED_VEL_XY_MAX));\n\t_vel_controller_xy.set_min_acceleration(-get_param_float(PARAM_GUIDED_VEL_XY_ACC));\n\t// set the yaw control mode to AUTO_YAW_HOLD\n\tset_yaw_mode(YAW_HOLD);\n}", "CodeBleu_score": 36.717465553243024}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set vertical max speed and acceleration\n\tset_vertical_max_speed(g.guided_vel_z_max);\n\tset_vertical_cruise_speed(g.guided_vel_z_cruise);\n\tset_vertical_accel(g.guided_vel_z_accel);\n\t// set horizontal max speed and acceleration\n\tset_horizontal_max_speed(g.guided_vel_xy_max);\n\tset_horizontal_cruise_speed(g.guided_vel_xy_cruise);\n\tset_horizontal_accel(g.guided_vel_xy_accel);\n\t// initialize vertical and horizontal velocity controllers\n\tinit_vel_controller_xy();\n\tinit_vel_controller_z();\n\t// set yaw control mode to AUTO_YAW_HOLD\n\tset_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 30.435334609212155}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set vertical max speeds and accelerations\n\t_vel_ctrl.set_vel_xy_max(AP_PARAM_LOAD(GUIDED_VEL_XY_MAX));\n\t_vel_ctrl.set_accel_xy_max(AP_PARAM_LOAD(GUIDED_ACCEL_XY_MAX));\n\t_vel_ctrl.set_vel_z_max(AP_PARAM_LOAD(GUIDED_VEL_Z_MAX));\n\t_vel_ctrl.set_accel_z_max(AP_PARAM_LOAD(GUIDED_ACCEL_Z_MAX));\n\n\t// initialize velocity controllers\n\t_vel_ctrl.set_velocity_frame(velocity_frame_id_t(AP_PARAM_LOAD(GUIDED_FRAME)));\n\t_vel_ctrl.set_xy_frame(velocity_frame_id_t(AP_PARAM_LOAD(GUIDED_FRAME)));\n\t_vel_ctrl.set_z_frame(velocity_frame_id_t(AP_PARAM_LOAD(GUIDED_FRAME)));\n\t_vel_ctrl.set_xy_vel_limit(AP_PARAM_LOAD(GUIDED_VEL_XY_MAX));\n\t_vel_ctrl.set_z_vel_limit(AP_PARAM_LOAD(GUIDED_VEL_Z_MAX));\n\t_vel_ctrl.set_accel_xy(AP_PARAM_LOAD(GUIDED_ACCEL_XY_MAX));\n\t_vel_ctrl.set_accel_z(AP_PARAM_LOAD(GUIDED_ACCEL_Z_MAX));\n\t_vel_ctrl.set_xy_cruise_speed(AP_PARAM_LOAD(GUIDED_CRUISE_SPEED));\n\t_vel_ctrl.set_z_cruise_speed(AP_PARAM_LOAD(GUIDED_CRUISE_SPEED));\n\t_vel_ctrl.set_xy_cruise_throttle(AP_PARAM_LOAD(GUIDED_CRUISE_THROTTLE));\n\t_vel_ctrl.set_z_cruise_throttle(AP_PARAM_LOAD(GUIDED_CRUISE_THROTTLE));\n\t_vel_ctrl.set_xy_cruise_throttle_slew_rate(AP_PARAM", "CodeBleu_score": 33.11276524344211}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check if a timeout has been exceeded\n\tif (millis() - _last_update > _guided_timeout) {\n\t\t// timeout exceeded\n\t\treturn true;\n\t}\n\t// check if the current altitude is below a minimum or above a maximum threshold\n\tif (_current_alt < _guided_min_altitude || _current_alt > _guided_max_altitude) {\n\t\t// altitude out of bounds\n\t\treturn true;\n\t}\n\t// check if the horizontal distance moved exceeds a specified limit\n\tif (_guided_distance_moved > _guided_max_distance) {\n\t\t// distance moved exceeds limit\n\t\treturn true;\n\t}\n\t// no limits exceeded\n\treturn false;\n}", "CodeBleu_score": 16.038381429404886}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tbool ret = false;\n\t// Check if we have exceeded the timeout\n\tif (millis() > (timeout_start + timeout_ms)) {\n\t\t// We have exceeded the timeout\n\t\tret = true;\n\t\t// Set the timeout flag\n\t\ttimeout_reached = true;\n\t}\n\t// Check if we have exceeded the minimum altitude\n\tif (current_altitude < min_altitude) {\n\t\t// We have exceeded the minimum altitude\n\t\tret = true;\n\t\t// Set the minimum altitude flag\n\t\tmin_altitude_reached = true;\n\t}\n\t// Check if we have exceeded the maximum altitude\n\tif (current_altitude > max_altitude) {\n\t\t// We have exceeded the maximum altitude\n\t\tret = true;\n\t\t// Set the maximum altitude flag\n\t\tmax_altitude_reached = true;\n\t}\n\t// Check if we have exceeded the horizontal distance moved\n\tif (distance_moved > max_distance_moved) {\n\t\t// We have exceeded the horizontal distance moved\n\t\tret = true;\n\t\t// Set the horizontal distance moved flag\n\t\tmax_distance_moved_reached = true;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 19.663247130177027}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tif (timeout > 0 && (millis() - last_heartbeat) > timeout) {\n\t\t// timeout\n\t\treturn true;\n\t}\n\n\tif (max_altitude > 0 && current_altitude > max_altitude) {\n\t\t// max altitude\n\t\treturn true;\n\t}\n\n\tif (min_altitude > 0 && current_altitude < min_altitude) {\n\t\t// min altitude\n\t\treturn true;\n\t}\n\n\tif (max_distance > 0 && (abs(current_latitude - last_latitude) > max_distance || abs(current_longitude - last_longitude) > max_distance)) {\n\t\t// max distance\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 28.65827362503297}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tif (motor_test_request_timer.elapsed() > 1.0/2.0) {\n\t\tmotor_test_request_timer.start();\n\t\tif (motor_test_request_received) {\n\t\t\tmotor_test_request_received = false;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\ttimeout_message(\"Motor Test\");\n\t\t\tpass_flag = false;\n\t\t\tdisable_motor_test();\n\t\t\tdisarm_system();\n\t\t\trecord_failure_time();\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 41.50991144537497}, {"code": "bool Sub::verify_motor_test(){\n\t\t// Check if the motor test requests have been received at least every 2 Hz.\n\tif (motor_test_request_timer.getElapsedTime() > 2.0) {\n\t\t// If the motor test requests have timed out, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, and record the failure time.\n\t\tsend_timeout_message(motor_test_request_timer.getElapsedTime(), \"motor_test_request\");\n\t\tmotor_test_pass = false;\n\t\tdisable_motor_test();\n\t\tdisarm();\n\t\tmotor_test_failure_time = ros::Time::now();\n\t\treturn false;\n\t}\n\t// If the motor test requests have not timed out, return true.\n\treturn true;\n}", "CodeBleu_score": 31.799930608071147}, {"code": "bool Sub::verify_motor_test(){\n\t\t// If the motor test has not been enabled, return false\n\tif (!motor_test_enabled) {\n\t\treturn false;\n\t}\n\n\t// If the motor test has timed out, return false\n\tif (motor_test_timeout) {\n\t\treturn false;\n\t}\n\n\t// If the motor test has been passed, return true\n\tif (motor_test_passed) {\n\t\treturn true;\n\t}\n\n\t// If the motor test has not been passed, and the motor test has not timed out, return true\n\treturn true;\n}", "CodeBleu_score": 12.287159713651025}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.roll_target;\n\tfloat pitch_target = wp_nav.pitch_target;\n\tfloat roll_target_max = wp_nav.roll_target_max;\n\tfloat pitch_target_max = wp_nav.pitch_target_max;\n\n\t// constrain the target angles to the maximums\n\troll_target = constrain_float(roll_target, -roll_target_max, roll_target_max);\n\tpitch_target = constrain_float(pitch_target, -pitch_target_max, pitch_target_max);\n\n\t// normalize the targets\n\troll_target = roll_target / roll_target_max;\n\tpitch_target = pitch_target / pitch_target_max;\n\n\t// assign the normalized targets to the output variables\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 39.05188076935468}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Get the desired roll and pitch from wp_nav.\n\tfloat roll_target = wp_nav.get_roll_target();\n\tfloat pitch_target = wp_nav.get_pitch_target();\n\n\t// Constrain the roll and pitch targets to the specified maximum angle range.\n\troll_target = constrain_float(roll_target, -roll_max_angle, roll_max_angle);\n\tpitch_target = constrain_float(pitch_target, -pitch_max_angle, pitch_max_angle);\n\n\t// Normalize the roll and pitch targets.\n\troll_target = roll_target / roll_max_angle;\n\tpitch_target = pitch_target / pitch_max_angle;\n\n\t// Assign the normalized roll and pitch targets to lateral_out and forward_out.\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 42.19297727684162}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// wpnav_rp_t is a struct containing the roll and pitch targets from wp_nav\n\twpnav_rp_t wpnav_rp;\n\t// This is the maximum angle that the controller can output.\n\tfloat max_angle = 30.0f;\n\t// This is the maximum angle that the controller can output, in radians.\n\tfloat max_angle_rad = max_angle * M_PI / 180.0f;\n\t// This is the maximum angle that the controller can output, in centidegrees.\n\tfloat max_angle_cd = max_angle * 100.0f;\n\t// This is the maximum angle that the controller can output, in centidegrees, as a 16-bit integer.\n\tint16_t max_angle_cd_int = (int16_t)max_angle_cd;\n\t// This is the maximum angle that the controller can output, in centidegrees, as a 16-bit integer, with the sign bit flipped.\n\tint16_t max_angle_cd_int_neg = (int16_t)(-max_angle_cd);\n\t// This is the maximum angle that the controller can output, in centidegrees, as a 16-bit integer, with the sign bit flipped, and with the sign bit set to 0.\n\tint16_t max_angle_cd_int_neg_0 = (int16_t)(-max_angle_cd + 32768);\n\t// This is the maximum angle that the controller can output, in centidegrees, as a 16-bit integer, with the sign bit set to 0.\n\tint16_t max_angle_cd_int_0 = (int16_t)(max_angle_cd + 32768);\n\t// This is the maximum angle that the controller can output, in centidegrees, as a 16-bit integer, with the sign bit flipped, and with the sign bit set to 1.\n\tint16_t max_angle_cd_int_neg_1 = (int16_t)(-max_angle_cd + 65536);\n\t", "CodeBleu_score": 16.485899562900574}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// Read barometer\n\tbarometer.read();\n\n\t// Update barometer calibration\n\tif (barometer.altitude() > 0) {\n\t\tbarometer.calibrate();\n\t}\n\n\t// Update barometer health\n\tif (depth_sensor.is_present()) {\n\t\tbarometer.health = depth_sensor.health;\n\t}\n}", "CodeBleu_score": 57.01548575378411}, {"code": "void Sub::read_barometer(){\n\t\tif (baro.read_barometer()!= 0) {\n\t\treturn;\n\t}\n\n\t// If the altitude is above zero, update the barometer calibration.\n\tif (baro.altitude > 0) {\n\t\tbaro.update_calibration();\n\t}\n\n\t// If a depth sensor is present, update the sensor health status based on the barometer's health.\n\tif (depth_sensor!= NULL) {\n\t\tdepth_sensor->update_health(baro.health);\n\t}\n}", "CodeBleu_score": 42.51692298267478}, {"code": "void Sub::read_barometer(){\n\t\tfloat pressure, temperature;\n\tif (barometer->read(&pressure, &temperature)) {\n\t\tif (depth_sensor) {\n\t\t\tdepth_sensor->update_health(pressure);\n\t\t}\n\t\tif (pressure > 0) {\n\t\t\tbarometer_calibration = pressure;\n\t\t}\n\t\tbarometer_pressure = pressure;\n\t\tbarometer_temperature = temperature;\n\t}\n}", "CodeBleu_score": 45.54242088063497}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.ekfHealth()) {\n\t\treturn false;\n\t}\n\tif (motors.armed()) {\n\t\tif (!ahrs.ekf_pos_horiz_abs()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ahrs.ekf_const_pos_mode()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 38.807720039253994}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// If we don't have a position estimate, we can't navigate\n\tif (!ahrs.have_position()) {\n\t\treturn false;\n\t}\n\n\t// If we are disarmed, we can use the EKF position for navigation\n\tif (!motors.armed()) {\n\t\treturn true;\n\t}\n\n\t// If we are armed, we need a good absolute position and EKF not in constant position mode\n\treturn (ahrs.get_ekf_pos_horiz_accuracy() < 100 &&!ahrs.ekf_const_pos_mode());\n}", "CodeBleu_score": 40.78777902865549}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// check if we have inertial navigation\n\tif (!ahrs.have_position()) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_ok) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_3dfix) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_glitch) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_no_fix) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_bad_fix) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_fix) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_pwr) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_no_pwr) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_antenna_short) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_antenna_ok) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_antenna_open) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (!ahrs.get_gps().status_flags.gps_antenna_short_", "CodeBleu_score": 46.92935379505195}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// if we are not in a position or velocity controlled mode, we don't need to check GPS\n\tif (control_mode!= AP_MOTORS_STABILIZE && control_mode!= AP_MOTORS_LOITER && control_mode!= AP_MOTORS_AUTO) {\n\t\treturn true;\n\t}\n\n\t// call the parent class's GPS checks\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check the EKF failsafe\n\tif (!ahrs.ekfHealthy()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH, PSTR(\"EKF failsafe triggered\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check that the EKF has a valid position estimate\n\tif (!ahrs.ekfPositionValid()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH, PSTR(\"EKF position invalid\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// all checks passed\n\treturn true;\n}", "CodeBleu_score": 45.8824402323738}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// if we are in a mode that doesn't require position or velocity,\n\t// return true\n\tif (control_mode == AP_HAL::ControlMode::MANUAL ||\n\t    control_mode == AP_HAL::ControlMode::STABILIZE ||\n\t    control_mode == AP_HAL::ControlMode::ACRO ||\n\t    control_mode == AP_HAL::ControlMode::TRAINING ||\n\t    control_mode == AP_HAL::ControlMode::FBWA ||\n\t    control_mode == AP_HAL::ControlMode::FBWB ||\n\t    control_mode == AP_HAL::ControlMode::CRUISE) {\n\t\treturn true;\n\t}\n\n\t// call the parent class's GPS checks\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if the AHRS system is ready and if the EKF failsafe is active\n\tif (!ahrs.healthy() || failsafe.ekf_check()) {\n\t\treturn false;\n\t}\n\n\t// check if the position estimate is valid\n\tif (!ahrs.get_position_ok()) {\n\t\treturn false;\n\t}\n\n\t// all checks passed\n\treturn true;\n}", "CodeBleu_score": 38.48867886570434}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif(control_mode!= AP_HAL::ControlMode::GUIDED && control_mode!= AP_HAL::ControlMode::AUTO) {\n\t\treturn true;\n\t}\n\n\tif(!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif(!ahrs->healthy()) {\n\t\tif(display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"EKF not healthy\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif(ahrs->ekf_failsafe()) {\n\t\tif(display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"EKF failsafe\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif(!ahrs->get_position_ok()) {\n\t\tif(display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"EKF position not OK\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 47.97651800289966}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// check if already armed\n\tif (armed.get()) {\n\t\treturn true;\n\t}\n\n\t// check if we can arm\n\tif (do_arming_checks &&!can_arm(method)) {\n\t\treturn false;\n\t}\n\n\t// set home location\n\tif (g.log_bitmask & MASK_LOG_SMART_RTL) {\n\t\thome.set_and_save();\n\t}\n\n\t// initialize simple mode heading\n\tsimple_mode.set_heading_all();\n\n\t// record home heading for sail vehicles\n\tif (g.sail_enabled == 1) {\n\t\tsail.set_home_heading();\n\t}\n\n\t// update soft armed status\n\tarmed.set_and_save(true);\n\n\t// send arm/disarm status text\n\tsend_arm_disarm_status();\n\n\treturn true;\n}", "CodeBleu_score": 47.15219635832285}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// sanity check\n\tif (!AP_Rover::arming_check()) {\n\t\treturn false;\n\t}\n\n\t// check if already armed\n\tif (armed.armed) {\n\t\treturn true;\n\t}\n\n\t// perform arming checks if required\n\tif (do_arming_checks) {\n\t\t// check if we have a valid home location\n\t\tif (!AP_Rover::have_home()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we have a valid position\n\t\tif (!AP_Rover::have_position()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we have a valid compass\n\t\tif (!AP_Rover::have_compass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we have a valid battery\n\t\tif (!AP_Rover::have_battery()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we have a valid GPS\n\t\tif (!AP_Rover::have_gps()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we have a valid altitude\n\t\tif (!AP_Rover::have_altitude()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we have a valid airspeed\n\t\tif (!AP_Rover::have_airspeed()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we have a valid ground speed\n\t\tif (!AP_Rover::have_ground_speed()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we have a valid heading\n\t\tif (!AP_Rover::have_heading()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we have a valid attitude\n\t\tif (!AP_Rover::have_attitude()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// set the home location\n\tAP_Rover::set_home();\n\n\t// initialize the simple mode heading\n\tAP_Rover::init_simple_mode_heading();\n\n\t// record the home heading for sail vehicles\n\tAP_Rover::record_home_heading();\n\n\t// update the soft armed status\n\tarmed.soft_armed = true;\n\n\t// send an arm/disarm status text\n\tAP_Rover::", "CodeBleu_score": 28.269157188192835}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool rc = false;\n\n\tif (method == AP_Arming::Method::ARM_IMMEDIATELY) {\n\t\t// if we're already armed, do nothing\n\t\tif (is_armed()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// set the armable flag\n\t\tset_armable(true);\n\n\t\t// do arming checks if required\n\t\tif (do_arming_checks) {\n\t\t\tif (!arming_checks()) {\n\t\t\t\t// arming checks failed, so return false\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// set the armed flag\n\t\tset_armed(true);\n\n\t\t// set the soft armed flag\n\t\tset_soft_armed(true);\n\n\t\t// send arm status text\n\t\tsend_arm_status_text();\n\n\t\t// set the arming failed flag to false\n\t\tset_arming_failed(false);\n\n\t\t// return true\n\t\trc = true;\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 39.35097022729482}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed &&!charging_enabled) {\n\t\tcharging_enabled = true;\n\t\tdigitalWrite(CHARGE_ENABLE_PIN, HIGH);\n\t\tcharging_start = millis();\n\t} else if (!charging_allowed && charging_enabled) {\n\t\tcharging_enabled = false;\n\t\tdigitalWrite(CHARGE_ENABLE_PIN, LOW);\n\t\tcharging_start = millis();\n\t} else if (!charging_allowed &&!charging_enabled && millis() - charging_start > CHARGING_RETRY_DELAY) {\n\t\tcharging_start = millis();\n\t\tdigitalWrite(CHARGE_ENABLE_PIN, HIGH);\n\t\tcharging_enabled = true;\n\t}\n}", "CodeBleu_score": 54.5344178602994}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed &&!charging_enabled) {\n\t\tcharging_enabled = true;\n\t\tcharging_start_time = millis();\n\t\tdigitalWrite(CHARGING_PIN, HIGH);\n\t} else if (!charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tdigitalWrite(CHARGING_PIN, LOW);\n\t\t} else if (millis() - charging_start_time > CHARGING_RETRY_DELAY) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_start_time = millis();\n\t\t\tdigitalWrite(CHARGING_PIN, HIGH);\n\t\t}\n\t}\n}", "CodeBleu_score": 49.59828850349347}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\tcharging_enabled = true;\n\t\t\tenableCharging();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tdisableCharging();\n\t\t} else {\n\t\t\tif (millis() - charging_disabled_time > CHARGING_RETRY_DELAY) {\n\t\t\t\tcharging_disabled_time = millis();\n\t\t\t\tenableCharging();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.97425013496332}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (size < 4) {\n\t\treturn;\n\t}\n\tuint32_t crc = FastCRC::crc32(message, size);\n\tmemcpy(message + size, &crc, 4);\n\tsize += 4;\n\tpacketSerial.send(message, size);\n}", "CodeBleu_score": 36.841806333160385}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros_running && size >= 4) {\n\t\tuint32_t crc = crc32(message, size);\n\t\tmemcpy(message + size, &crc, 4);\n\t\tpacketSerial.send(message, size + 4);\n\t}\n}", "CodeBleu_score": 28.814375789679737}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::isInitialized() && size >= 4) {\n\t\tuint32_t crc = FastCRC::crc32(message, size);\n\t\tmemcpy(message + size, &crc, 4);\n\t\tpacketSerial.send(message, size + 4);\n\t}\n}", "CodeBleu_score": 29.208843375072348}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\t// Initialize serial communication\n\tSerial.begin(9600);\n\n\t// Clear buffer\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\n\t// Initialize sound module\n\tsendCommand(CMD_SEL_DEV, DEV_TF);\n\tdelay(500);\n\tsendCommand(CMD_SET_VOLUME, 0x1E);\n\tdelay(500);\n\n\t// Get number of sound files on SD card\n\tnumSounds = getNumSounds();\n\n\t// Return true if there are one or more sound files available\n\treturn numSounds > 0;\n}", "CodeBleu_score": 43.57528613419202}, {"code": "bool MP3Sound::begin(){\n\t\tSerial.begin(9600);\n\twhile (!Serial) {\n\t\t; // wait for serial port to connect. Needed for native USB port only\n\t}\n\n\t// clear buffer\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\n\t// initialize sound module\n\tSerial.write(0x7E);\n\tSerial.write(0x03);\n\tSerial.write(0x0C);\n\tSerial.write(0xEF);\n\n\t// get number of sound files\n\tSerial.write(0x7E);\n\tSerial.write(0x04);\n\tSerial.write(0xA0);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\n\t// wait for response\n\twhile (!Serial.available()) {\n\t}\n\tif (Serial.read()!= 0x7E) {\n\t\treturn false;\n\t}\n\tif (Serial.read()!= 0x06) {\n\t\treturn false;\n\t}\n\tif (Serial.read()!= 0xA0) {\n\t\treturn false;\n\t}\n\tnumFiles = Serial.read() * 256;\n\tnumFiles += Serial.read();\n\tif (Serial.read()!= 0xEF) {\n\t\treturn false;\n\t}\n\treturn (numFiles > 0);\n}", "CodeBleu_score": 43.88297113761499}, {"code": "bool MP3Sound::begin(){\n\t\tSerial.begin(9600);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x09);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x01);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(1000);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x09);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x01);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(1000);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x12);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(1000);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x12);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(1000);\n\twhile (Serial.available()) {\n\t\tSerial.read", "CodeBleu_score": 40.601076738114294}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\n\tif (isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\n\tint soundID = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplay(soundID);\n\n\treturn activeSounds.size();\n}", "CodeBleu_score": 43.007867683404754}, {"code": "int MP3Sound::processSounds(){\n\t\tint numActive = activeSounds.size();\n\tif (numActive == 0)\n\t\treturn numActive;\n\tif (MP3.isPlaying())\n\t\treturn numActive;\n\tMP3.play(activeSounds.back());\n\tactiveSounds.pop_back();\n\treturn activeSounds.size();\n}", "CodeBleu_score": 53.09606629683565}, {"code": "int MP3Sound::processSounds(){\n\t\tint numSounds = activeSounds.size();\n\tif (numSounds == 0 || playing) {\n\t\treturn numSounds;\n\t}\n\tSound* sound = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplaying = true;\n\tsound->play();\n\tdelete sound;\n\treturn activeSounds.size();\n}", "CodeBleu_score": 52.76413745240182}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef DEBUG\n  printf(\"wb_abstract_camera_handle_command: command=%d\n\", command);\n#endif\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      WbAbstractCamera *ac = (WbAbstractCamera *)d;\n      if (ac->memory_mapped_file)\n        wb_abstract_camera_delete_memory_mapped_file(ac);\n      wb_abstract_camera_create_memory_mapped_file(ac, r);\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 39.716044779872675}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef DEBUG\n  printf(\"abstract_camera: received command %d\n\", command);\n#endif\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      if (r->read_int32(r)!= 0) {\n        if (d->memory_mapped_file)\n          wb_abstract_camera_delete_memory_mapped_file(d);\n        wb_abstract_camera_create_memory_mapped_file(d, r);\n      }\n      d->command_handled = true;\n      return true;\n    default:\n      d->command_handled = false;\n      return false;\n  }\n}", "CodeBleu_score": 45.47156738952561}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_handle_command: command = %d\n\", command);\n#endif\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      WbAbstractCamera *ac = d->pdata;\n      if (ac->memory_mapped_file_size > 0) {\n        wb_abstract_camera_memory_mapped_file_cleanup(ac);\n      }\n      ac->memory_mapped_file_size = wb_request_read_uint32(r);\n      if (ac->memory_mapped_file_size > 0) {\n        wb_abstract_camera_memory_mapped_file_setup(ac);\n      }\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 50.96195852610512}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef DEBUG_ABSTRACT_CAMERA\n  printf(\"wb_abstract_camera_get_height\n\");\n#endif\n  WbAbstractCamera *ac = (WbAbstractCamera *)d;\n  pthread_mutex_lock(&ac->mutex);\n  int height = ac->height;\n  pthread_mutex_unlock(&ac->mutex);\n  return height;\n}", "CodeBleu_score": 40.209217770334845}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef DEBUG\n  printf(\"wb_abstract_camera_get_height(%d)\n\", d->tag);\n#endif\n\n  WbAbstractCamera *ac = d->pdata;\n\n  pthread_mutex_lock(&ac->mutex);\n  int height = ac->height;\n  pthread_mutex_unlock(&ac->mutex);\n\n  return height;\n}", "CodeBleu_score": 43.55405893628335}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tWbAbstractCamera *c = (WbAbstractCamera *)d;\n\tint height;\n\tmutex_lock(&c->mutex);\n\tif (c->data!= NULL)\n\t\theight = c->data->height;\n\telse\n\t\theight = -1;\n\tmutex_unlock(&c->mutex);\n\treturn height;\n}", "CodeBleu_score": 40.59035071348273}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\n#ifdef DEBUG\n  printf(\"wb_accelerometer_get_sampling_period(%d)\n\", tag);\n#endif\n\n  WbDevice *d = robot_get_device_with_node(tag, WB_NODE_ACCELEROMETER, true);\n\n  if (d)\n    return d->sampling_period;\n\n  return 0;\n}", "CodeBleu_score": 26.821316353430557}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\n#ifdef DEBUG\n  printf(\"wb_accelerometer_get_sampling_period(%d)\n\", tag);\n#endif\n\n  WbDevice *d = robot_get_device_with_node(tag, WB_NODE_ACCELEROMETER, \"wb_accelerometer_get_sampling_period\");\n  if (d)\n    return d->sampling_period;\n  return 0;\n}", "CodeBleu_score": 29.20151033648033}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t#ifdef DEBUG\n  printf(\"wb_accelerometer_get_sampling_period(%d)\n\", tag);\n#endif\n  WbDevice *d = robot_get_device_with_node(tag, WB_NODE_ACCELEROMETER, ACCELEROMETER);\n  if (d)\n    return d->sampling_period;\n  else\n    return 0;\n}", "CodeBleu_score": 27.749753624126782}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tconst char *result = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms = result;\n\tfree((void *)result);\n\treturn dms;\n}", "CodeBleu_score": 49.51879370578096}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 39.245249918562564}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t#ifdef __cplusplus\n  return std::string(wb_gps_convert_to_degrees_minutes_seconds(decimalDegree));\n#else\n  return wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n#endif\n}", "CodeBleu_score": 31.11621608827932}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdAASSERT (g && g->type == dBoxClass);\n\tdxBox *o = (dxBox*) g;\n\n\t// Compute the relative position of the point to the box center.\n\tdVector3 r;\n\tr[0] = x - o->posr.pos[0];\n\tr[1] = y - o->posr.pos[1];\n\tr[2] = z - o->posr.pos[2];\n\n\t// Compute the distance of the point to each axis of the box.\n\tdReal dx = dFabs (dDOT14 (r, o->posr.R + 0));\n\tdReal dy = dFabs (dDOT14 (r, o->posr.R + 1));\n\tdReal dz = dFabs (dDOT14 (r, o->posr.R + 2));\n\n\t// Check each axis for proximity to the box's surface.\n\tif (dx < o->side[0]) {\n\t\t// The point is close to the x axis.\n\t\tif (dy < o->side[1]) {\n\t\t\t// The point is close to the y axis.\n\t\t\tif (dz < o->side[2]) {\n\t\t\t\t// The point is inside the box.\n\t\t\t\tplane[0] = 0;\n\t\t\t\tplane[1] = 0;\n\t\t\t\tplane[2] = 0;\n\t\t\t\tplane[3] = 0;\n\t\t\t} else {\n\t\t\t\t// The point is close to the z axis.\n\t\t\t\tplane[0] = 0;\n\t\t\t\tplane[1] = 0;\n\t\t\t\tplane[2] = (dz < o->side[2]? 1 : -1);\n\t\t\t\tplane[3] = o->side[2] - dz;\n\t\t\t}\n\t\t} else if (dz < o->side[2]) {\n\t\t\t// The point is close to the z axis.\n\t\t\tplane[0] = 0;\n\t\t\tplane[1] = (dy < o->side[1]? 1 : -1);\n\t\t\tplane[2] = 0;\n\t\t\tplane[3] = o->side[1] - dy;\n\t\t} else {\n\t\t\t// The point is close to the y and z axes", "CodeBleu_score": 32.86825710930172}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\tdVector3 p;\n\tp[0] = x - g->posr.pos[0];\n\tp[1] = y - g->posr.pos[1];\n\tp[2] = z - g->posr.pos[2];\n\tdMultiply0_331 (plane, g->posr.R, p);\n\tdReal depth[3];\n\tdepth[0] = dFabs (plane[0]) - g->box.side[0];\n\tdepth[1] = dFabs (plane[1]) - g->box.side[1];\n\tdepth[2] = dFabs (plane[2]) - g->box.side[2];\n\tif (depth[0] < depth[1]) {\n\t\tif (depth[0] < depth[2]) {\n\t\t\t// x\n\t\t\tif (plane[0] < 0) {\n\t\t\t\tplane[0] = -1;\n\t\t\t\tplane[3] = g->box.side[0];\n\t\t\t} else {\n\t\t\t\tplane[0] = 1;\n\t\t\t\tplane[3] = -g->box.side[0];\n\t\t\t}\n\t\t} else {\n\t\t\t// z\n\t\t\tif (plane[2] < 0) {\n\t\t\t\tplane[2] = -1;\n\t\t\t\tplane[3] = g->box.side[2];\n\t\t\t} else {\n\t\t\t\tplane[2] = 1;\n\t\t\t\tplane[3] = -g->box.side[2];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (depth[1] < depth[2]) {\n\t\t\t// y\n\t\t\tif (plane[1] < 0) {\n\t\t\t\tplane[1] = -1;\n\t\t\t\tplane[3] = g->box.side[1];\n\t\t\t} else {\n\t\t\t\tplane[1] = 1;\n\t\t\t\tplane[3] = -g->box.side[1];\n\t\t\t}\n\t\t} else {\n\t\t\t// z\n\t\t\tif (plane[2] < 0) {\n\t\t\t\tplane[2] = -1;\n\t\t\t\tplane[3] = g->box.side[2", "CodeBleu_score": 26.7290302539548}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdAASSERT (g);\n\tdAASSERT (dGeomGetClass (g) == dBoxClass);\n\n\tconst dReal *sides = dGeomBoxGetLengths (g);\n\tdVector3 pos;\n\tdGeomBoxGetRelPointPos (g, x, y, z, pos);\n\n\t// Check if the point is inside the box.\n\tif (dFabs (pos[0]) <= sides[0] && dFabs (pos[1]) <= sides[1] && dFabs (pos[2]) <= sides[2]) {\n\t\t// The point is inside the box.\n\t\tdSetZero (plane);\n\t\treturn;\n\t}\n\n\t// Check each axis for proximity to the box's surface.\n\tdReal dist = dInfinity;\n\tint axis = -1;\n\tif (dFabs (pos[0]) >= sides[0] - dEpsilon) {\n\t\tdReal d = dFabs (pos[0]) - sides[0];\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\taxis = 0;\n\t\t}\n\t}\n\tif (dFabs (pos[1]) >= sides[1] - dEpsilon) {\n\t\tdReal d = dFabs (pos[1]) - sides[1];\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\taxis = 1;\n\t\t}\n\t}\n\tif (dFabs (pos[2]) >= sides[2] - dEpsilon) {\n\t\tdReal d = dFabs (pos[2]) - sides[2];\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\taxis = 2;\n\t\t}\n\t}\n\n\t// The point is on the box's surface.\n\tdSetZero (plane);\n\tplane[axis] = dSign (pos[axis]);\n\tplane[3] = -dCalcVectorDot3 (pos, plane);\n}", "CodeBleu_score": 35.06500782507327}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdAASSERT (box && box->body);\n\tdAASSERT (fluidPlane);\n\tdAASSERT (flags >= 0 && flags <= 3);\n\n\tsBoxImmersionData boxImmersionData;\n\tboxImmersionData.box = box;\n\tboxImmersionData.fluidPlane = fluidPlane;\n\tboxImmersionData.flags = flags;\n\tboxImmersionData.immersion = immersion;\n\n\treturn dImmerse (boxImmersionData, &dImmerseBoxCallback);\n}", "CodeBleu_score": 42.99958710312926}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdAASSERT (box);\n\tdAASSERT (fluidPlane);\n\tdAASSERT (flags >= 0);\n\tdAASSERT (flags < 2);\n\tdAASSERT (immersion);\n\tsBoxImmersionData data (box, fluidPlane, flags, immersion);\n\treturn dImmerse (&data);\n}", "CodeBleu_score": 48.22038336048272}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdAASSERT (box);\n\tdAASSERT (box->body);\n\tdAASSERT (fluidPlane);\n\tdAASSERT (immersion);\n\tdAASSERT (flags >= 0);\n\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.immersion = immersion;\n\tdata.flags = flags;\n\n\treturn dImmerse (dGeomGetClass (box->geom), &data);\n}", "CodeBleu_score": 44.50798785348216}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (o1->type == dBoxClass, \"dImmerseBoxCapsule: first geometry must be a box\");\n\tdUASSERT (o2->type == dCapsuleClass, \"dImmerseBoxCapsule: second geometry must be a capsule\");\n\tdUASSERT (immersion, \"dImmerseBoxCapsule: immersion structure must be valid\");\n\n\t// Validate the input arguments\n\tif (o1->body && o2->body) {\n\t\tdUASSERT (o1->space && o2->space, \"dImmerseBoxCapsule: geometries must be in the same space\");\n\t\tdUASSERT (o1->space == o2->space, \"dImmerseBoxCapsule: geometries must be in the same space\");\n\t\tdUASSERT (o1->body!= o2->body, \"dImmerseBoxCapsule: geometries must not be attached to the same body\");\n\t}\n\n\t// Check for collisions\n\tif (dxCheckAABB (o1, o2)) {\n\t\t// Set the immersion parameters\n\t\timmersion->o1 = o1;\n\t\timmersion->o2 = o2;\n\t\timmersion->flags = flags;\n\n\t\t// Compute the immersion plane for the capsule\n\t\tdVector3 normal;\n\t\tdReal depth;\n\t\tdImmerseCapsulePlane (o2, o1, normal, depth);\n\t\timmersion->plane[0] = normal[0];\n\t\timmersion->plane[1] = normal[1];\n\t\timmersion->plane[2] = normal[2];\n\t\timmersion->plane[3] = depth;\n\n\t\t// Process the immersion of the box in the fluid\n\t\tdImmerseBox (o1, o2, flags, immersion);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.68826658420017}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdAASSERT (o1->type == dBoxClass);\n\tdAASSERT (o2->type == dCapsuleClass);\n\tdAASSERT ((flags & NUMC_MASK) == 1);\n\tdAASSERT (immersion);\n\n\tdxBox *box = (dxBox*) o1;\n\tdxCapsule *capsule = (dxCapsule*) o2;\n\n\t// validate input arguments\n\tif (box->final_posr.pos[0] == dInfinity) {\n\t\treturn 0;\n\t}\n\tif (capsule->final_posr.pos[0] == dInfinity) {\n\t\treturn 0;\n\t}\n\n\t// initialize immersion parameters\n\tdVector3 normal;\n\tdVector3 point;\n\tdVector3 axis;\n\tdReal depth;\n\tdReal radius;\n\tdReal length;\n\tdReal depth_min = dInfinity;\n\tdReal radius_min = dInfinity;\n\tdReal length_min = dInfinity;\n\tdReal depth_max = -dInfinity;\n\tdReal radius_max = -dInfinity;\n\tdReal length_max = -dInfinity;\n\tdReal depth_total = 0;\n\tdReal radius_total = 0;\n\tdReal length_total = 0;\n\tdReal depth_average = 0;\n\tdReal radius_average = 0;\n\tdReal length_average = 0;\n\tdReal depth_stddev = 0;\n\tdReal radius_stddev = 0;\n\tdReal length_stddev = 0;\n\tdReal depth_min_average = dInfinity;\n\tdReal radius_min_average = dInfinity;\n\tdReal length_min_average = dInfinity;\n\tdReal depth_max_average = -dInfinity;\n\tdReal radius_max_average = -dInfinity;\n\tdReal length_max_average = -dInfinity;\n\tdReal depth_min_stddev = dInfinity;\n\tdReal radius_min_stddev = dInfinity;\n\tdReal length_min_stddev = dInfinity;\n\tdReal depth_max_stddev = -dInfinity;\n\tdReal radius", "CodeBleu_score": 32.993515564490764}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (o1->type == dBoxClass, \"dImmerseBoxCapsule: o1 is not a box\");\n\tdUASSERT (o2->type == dCapsuleClass, \"dImmerseBoxCapsule: o2 is not a capsule\");\n\n\t// Check if the box is inside the capsule.\n\tdVector3 center;\n\tdReal radius, length;\n\tdGeomCapsuleGetParams (o2, &radius, &length);\n\tdGeomBoxGetParams (o1, center);\n\tdReal distance = dVector3Length (center);\n\tif (distance < radius) {\n\t\t// The box is inside the capsule.\n\t\treturn 0;\n\t}\n\n\t// Check if the box is outside the capsule.\n\tdReal radius2 = radius + length * 0.5f;\n\tif (distance > radius2) {\n\t\t// The box is outside the capsule.\n\t\treturn 0;\n\t}\n\n\t// Check if the box is partially inside the capsule.\n\tdReal radius3 = radius - length * 0.5f;\n\tif (distance < radius3) {\n\t\t// The box is partially inside the capsule.\n\t\timmersion->fluid = o2->fluid;\n\t\timmersion->fluid_density = o2->fluid_density;\n\t\timmersion->fluid_viscosity = o2->fluid_viscosity;\n\t\timmersion->fluid_viscosity2 = o2->fluid_viscosity2;\n\t\timmersion->fluid_velocity = o2->fluid_velocity;\n\t\timmersion->fluid_velocity2 = o2->fluid_velocity2;\n\t\timmersion->fluid_angular_velocity = o2->fluid_angular_velocity;\n\t\timmersion->fluid_angular_velocity2 = o2->fluid_angular_velocity2;\n\t\timmersion->fluid_vorticity = o2->fluid_vorticity;\n\t\timmersion->fluid_vorticity2 = o2->fluid_vorticity2;\n\t\timmersion->fluid_density_change_rate = o2->fluid_density_change_rate;\n\t\timmersion->fluid_density_change_rate2 = o2->fluid_density_change_", "CodeBleu_score": 34.46342375223199}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal tanTheta1 = dSqrt(zIOverR * zIOverR + 1.0 - sinTheta1 * sinTheta1);\n\tdReal tanTheta2 = dSqrt(zIOverR * zIOverR + 1.0 - sinTheta1 * sinTheta1 * zIOverR * zIOverR);\n\tdReal tanTheta3 = dSqrt(zIOverR * zIOverR + 1.0 - sinTheta1 * sinTheta1 * zIOverR * zIOverR * zIOverR * zIOverR);\n\tdReal tanTheta4 = dSqrt(zIOverR * zIOverR + 1.0 - sinTheta1 * sinTheta1 * zIOverR * zIOverR * zIOverR * zIOverR * zIOverR * zIOverR);\n\tdReal tanTheta5 = dSqrt(zIOverR * zIOverR + 1.0 - sinTheta1 * sinTheta1 * zIOverR * zIOverR * zIOverR * zIOverR * zIOverR * zIOverR * zIOverR * zIOverR);\n\n\tdReal tanTheta02 = tanTheta0 * tanTheta0;\n\tdReal tanTheta04 = tanTheta02 * tanTheta02;\n\tdReal tanTheta06 = tanTheta04 * tanTheta02;\n\tdReal tanTheta08 = tanTheta06 * tanTheta02;\n\tdReal tanTheta010 = tanTheta08 * tanTheta02;\n\tdReal tanTheta012 = tanTheta010 * tanTheta02;\n\n\tdReal tanTheta12 = tanTheta1 * tanTheta1;\n\tdReal tanTheta14 = tanTheta12 * tanTheta12;\n\tdReal tanTheta16 = tanTheta14 * tanTheta12;\n\tdReal tanTheta18 = tanTheta16 * tanTheta12;\n\tdReal tanTheta110 = tanTheta18 * tanTheta12;\n\tdReal tanTheta112 = tanTheta110 * tanTheta12;\n\n\tdReal tanTheta22 = tanTheta2 *", "CodeBleu_score": 33.69491652868669}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal zI = zIOverR * radius;\n\tdReal zI2 = zI * zI;\n\tdReal zI3 = zI2 * zI;\n\tdReal zI4 = zI2 * zI2;\n\tdReal zI5 = zI4 * zI;\n\tdReal zI6 = zI4 * zI2;\n\tdReal zI7 = zI6 * zI;\n\tdReal zI8 = zI6 * zI2;\n\tdReal zI9 = zI8 * zI;\n\tdReal zI10 = zI8 * zI2;\n\tdReal zI11 = zI10 * zI;\n\tdReal zI12 = zI10 * zI2;\n\tdReal zI13 = zI12 * zI;\n\tdReal zI14 = zI12 * zI2;\n\tdReal zI15 = zI14 * zI;\n\tdReal zI16 = zI14 * zI2;\n\tdReal zI17 = zI16 * zI;\n\tdReal zI18 = zI16 * zI2;\n\tdReal zI19 = zI18 * zI;\n\tdReal zI20 = zI18 * zI2;\n\tdReal zI21 = zI20 * zI;\n\tdReal zI22 = zI20 * zI2;\n\tdReal zI23 = zI22 * zI;\n\tdReal zI24 = zI22 * zI2;\n\tdReal zI25 = zI24 * zI;\n\tdReal zI26 = zI24 * zI2;\n\tdReal zI27 = zI26 * zI;\n\tdReal zI28 = zI26 * zI2;\n\tdReal zI29 = zI28 * zI;\n\tdReal zI30 = zI28 * zI2;\n\tdReal zI31 = z", "CodeBleu_score": 34.58212103458958}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal tanTheta02 = tanTheta0 * tanTheta0;\n\tdReal tanTheta03 = tanTheta02 * tanTheta0;\n\tdReal sinTheta12 = sinTheta1 * sinTheta1;\n\tdReal sinTheta13 = sinTheta12 * sinTheta1;\n\tdReal tanTheta1 = sinTheta1 / cosTheta1;\n\tdReal tanTheta12 = tanTheta1 * tanTheta1;\n\tdReal tanTheta13 = tanTheta12 * tanTheta1;\n\tdReal tanTheta14 = tanTheta13 * tanTheta1;\n\tdReal tanTheta15 = tanTheta14 * tanTheta1;\n\tdReal tanTheta16 = tanTheta15 * tanTheta1;\n\tdReal tanTheta17 = tanTheta16 * tanTheta1;\n\tdReal tanTheta18 = tanTheta17 * tanTheta1;\n\tdReal tanTheta19 = tanTheta18 * tanTheta1;\n\tdReal tanTheta110 = tanTheta19 * tanTheta1;\n\tdReal tanTheta111 = tanTheta110 * tanTheta1;\n\tdReal tanTheta112 = tanTheta111 * tanTheta1;\n\tdReal tanTheta113 = tanTheta112 * tanTheta1;\n\tdReal tanTheta114 = tanTheta113 * tanTheta1;\n\tdReal tanTheta115 = tanTheta114 * tanTheta1;\n\tdReal tanTheta116 = tanTheta115 * tanTheta1;\n\tdReal tanTheta117 = tanTheta116 * tanTheta1;\n\tdReal tanTheta118 = tanTheta117 * tanTheta1;\n\tdReal tanTheta119 = tanTheta118 * tanTheta1;\n\tdReal tanTheta120 = tanTheta119 * tanTheta1;\n\tdReal tanTheta121 = tanTheta120 * tanTheta1;\n\tdReal tanTheta122 = tanTheta121 * tanTheta1;\n\tdReal tan", "CodeBleu_score": 32.59266495501018}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal x = 0;\n\tdReal z = 0;\n\tdReal z2 = 0;\n\tdReal z3 = 0;\n\tdReal z4 = 0;\n\tdReal z5 = 0;\n\tdReal z6 = 0;\n\tdReal z7 = 0;\n\tdReal z8 = 0;\n\tdReal z9 = 0;\n\tdReal z10 = 0;\n\tdReal z11 = 0;\n\tdReal z12 = 0;\n\tdReal z13 = 0;\n\tdReal z14 = 0;\n\tdReal z15 = 0;\n\tdReal z16 = 0;\n\tdReal z17 = 0;\n\tdReal z18 = 0;\n\tdReal z19 = 0;\n\tdReal z20 = 0;\n\tdReal z21 = 0;\n\tdReal z22 = 0;\n\tdReal z23 = 0;\n\tdReal z24 = 0;\n\tdReal z25 = 0;\n\tdReal z26 = 0;\n\tdReal z27 = 0;\n\tdReal z28 = 0;\n\tdReal z29 = 0;\n\tdReal z30 = 0;\n\tdReal z31 = 0;\n\tdReal z32 = 0;\n\tdReal z33 = 0;\n\tdReal z34 = 0;\n\tdReal z35 = 0;\n\tdReal z36 = 0;\n\tdReal z37 = 0;\n\tdReal z38 = 0;\n\tdReal z39 = 0;\n\tdReal z40 = 0;\n\tdReal z41 = 0;\n\tdReal z42 = 0;\n\tdReal z43 = 0;\n\tdReal z44 = 0;\n\tdReal z45 = 0;\n\tdReal z46 = 0;\n\tdReal z47 =", "CodeBleu_score": 9.74150982069509}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal z = zIOverR * radius;\n\tdReal tanTheta1 = (radius - z) / sqrt(radius * radius - z * z);\n\tdReal sinTheta0 = tanTheta0 / sqrt(1 + tanTheta0 * tanTheta0);\n\tdReal cosTheta0 = sinTheta0 / tanTheta0;\n\tdReal cosTheta1 = sinTheta1 / tanTheta1;\n\tdReal theta0 = atan2(sinTheta0, cosTheta0);\n\tdReal theta1 = atan2(sinTheta1, cosTheta1);\n\tdReal sinTheta02 = sinTheta0 * sinTheta0;\n\tdReal sinTheta12 = sinTheta1 * sinTheta1;\n\tdReal sinTheta03 = sinTheta02 * sinTheta0;\n\tdReal sinTheta13 = sinTheta12 * sinTheta1;\n\tdReal cosTheta02 = cosTheta0 * cosTheta0;\n\tdReal cosTheta12 = cosTheta1 * cosTheta1;\n\tdReal cosTheta03 = cosTheta02 * cosTheta0;\n\tdReal cosTheta13 = cosTheta12 * cosTheta1;\n\tdReal tanTheta02 = tanTheta0 * tanTheta0;\n\tdReal tanTheta12 = tanTheta1 * tanTheta1;\n\tdReal tanTheta03 = tanTheta02 * tanTheta0;\n\tdReal tanTheta13 = tanTheta12 * tanTheta1;\n\tdReal tanTheta04 = tanTheta03 * tanTheta0;\n\tdReal tanTheta14 = tanTheta13 * tanTheta1;\n\tdReal tanTheta05 = tanTheta04 * tanTheta0;\n\tdReal tanTheta15 = tanTheta14 * tanTheta1;\n\tdReal tanTheta06 = tanTheta05 * tanTheta0;\n\tdReal tanTheta16 = tanTheta15 * tanTheta1;\n\tdReal tanTheta07 = tanTheta06 * tanTheta0;\n\tdReal tanTheta17 = tanTheta16 * tanTheta1;\n\tdReal tanTheta08 = tanTheta07 * tanTheta0;\n\tdReal tanTheta18 = tanTheta1", "CodeBleu_score": 35.14319598077876}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal tanTheta1 = dSqrt(1.0 - sinTheta1 * sinTheta1);\n\tdReal tanTheta02 = tanTheta0 * tanTheta0;\n\tdReal tanTheta12 = tanTheta1 * tanTheta1;\n\tdReal tanTheta03 = tanTheta02 * tanTheta0;\n\tdReal tanTheta13 = tanTheta12 * tanTheta1;\n\tdReal tanTheta04 = tanTheta03 * tanTheta0;\n\tdReal tanTheta14 = tanTheta13 * tanTheta1;\n\tdReal tanTheta05 = tanTheta04 * tanTheta0;\n\tdReal tanTheta15 = tanTheta14 * tanTheta1;\n\tdReal tanTheta06 = tanTheta05 * tanTheta0;\n\tdReal tanTheta16 = tanTheta15 * tanTheta1;\n\tdReal tanTheta07 = tanTheta06 * tanTheta0;\n\tdReal tanTheta17 = tanTheta16 * tanTheta1;\n\tdReal tanTheta08 = tanTheta07 * tanTheta0;\n\tdReal tanTheta18 = tanTheta17 * tanTheta1;\n\tdReal tanTheta09 = tanTheta08 * tanTheta0;\n\tdReal tanTheta19 = tanTheta18 * tanTheta1;\n\tdReal tanTheta010 = tanTheta09 * tanTheta0;\n\tdReal tanTheta110 = tanTheta19 * tanTheta1;\n\tdReal tanTheta011 = tanTheta010 * tanTheta0;\n\tdReal tanTheta111 = tanTheta110 * tanTheta1;\n\tdReal tanTheta012 = tanTheta011 * tanTheta0;\n\tdReal tanTheta112 = tanTheta111 * tanTheta1;\n\tdReal tanTheta013 = tanTheta012 * tanTheta0;\n\tdReal tanTheta113 = tanTheta112 * tanTheta1;\n\tdReal tanTheta014 = tanTheta013 * tanTheta0;\n\tdReal tanTheta114 = tanTheta113 * tanTheta1;\n\tdReal tanTheta", "CodeBleu_score": 34.49588667290023}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (o1->type == dCapsuleClass, \"dImmerseCapsuleTrimesh: o1 is not a capsule.\");\n\tdUASSERT (o2->type == dTriMeshClass, \"dImmerseCapsuleTrimesh: o2 is not a trimesh.\");\n\tdUASSERT (flags & dImmersionMask, \"dImmerseCapsuleTrimesh: flags has no bits set in dImmersionMask.\");\n\tdUASSERT (immersion, \"dImmerseCapsuleTrimesh: immersion is NULL.\");\n\n\tdxCapsule *capsule = (dxCapsule *) o1;\n\tdxTriMesh *trimesh = (dxTriMesh *) o2;\n\n\tdxBody *body1 = capsule->body;\n\tdxBody *body2 = trimesh->body;\n\n\tdMatrix3 R1;\n\tdMatrix3 R2;\n\tdVector3 pos1;\n\tdVector3 pos2;\n\tdVector3 vel1;\n\tdVector3 vel2;\n\tdVector3 vel;\n\tdVector3 omega1;\n\tdVector3 omega2;\n\tdVector3 omega;\n\tdVector3 rel_pos;\n\tdVector3 rel_vel;\n\tdVector3 rel_omega;\n\tdVector3 rel_omega_cross_pos;\n\tdVector3 normal;\n\tdVector3 rel_pos_cross_normal;\n\tdVector3 rel_vel_cross_normal;\n\tdVector3 rel_omega_cross_normal;\n\tdVector3 rel_omega_cross_pos_cross_normal;\n\tdVector3 rel_omega_cross_rel_pos_cross_normal;\n\tdVector3 rel_vel_cross_rel_pos_cross_normal;\n\tdVector3 rel_omega_cross_rel_vel_cross_rel_pos_cross_normal;\n\tdVector3 rel_omega_cross_rel_omega_cross_rel_pos_cross_normal;\n\tdVector3 rel_omega_cross_rel_omega_cross_rel_vel_cross_rel_pos_cross_normal;\n\tdVector3 rel_omega_cross_rel_omega_cross_rel_omega_cross_rel_pos_", "CodeBleu_score": 30.101413790054977}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (o1->type == dCapsuleClass);\n\tdIASSERT (o2->type == dTriMeshClass);\n\n\tdxCapsule *c = (dxCapsule*) o1;\n\tdxTriMesh *t = (dxTriMesh*) o2;\n\n\t// Get the capsule's radius and length\n\tdReal radius = c->radius;\n\tdReal length = c->length;\n\n\t// Get the capsule's position and orientation\n\tconst dReal *pos = c->final_posr.pos;\n\tconst dReal *R = c->final_posr.R;\n\n\t// Get the capsule's axis\n\tdVector3 axis;\n\tdMULTIPLY0_331 (axis, R, c->dir);\n\n\t// Get the capsule's axis-aligned bounding box\n\tdReal aabb[6];\n\tdGeomGetAABB (o1, aabb);\n\n\t// Get the trimesh's position and orientation\n\tconst dReal *pos2 = t->final_posr.pos;\n\tconst dReal *R2 = t->final_posr.R;\n\n\t// Get the trimesh's axis-aligned bounding box\n\tdReal aabb2[6];\n\tdGeomGetAABB (o2, aabb2);\n\n\t// Get the trimesh's vertices and indices\n\tdReal *vertices = t->vertices;\n\tint *indices = t->indices;\n\tint numVertices = t->vertex_count;\n\tint numIndices = t->index_count;\n\n\t// Get the trimesh's collision data\n\tdReal *normals = t->normals;\n\tdReal *depths = t->depths;\n\tdReal *areas = t->areas;\n\n\t// Get the capsule's immersion data\n\tsCapsuleImmersionData *data = (sCapsuleImmersionData*) immersion->data;\n\n\t// Get the capsule's immersion data\n\tsCapsuleImmersionData *data2 = (sCapsuleImmersionData*) immersion->data2;\n\n\t// Get the capsule's immersion data\n\tsCapsuleImmersionData *data3 = (sCapsuleImmersionData*) immersion->data3;\n\n\t// Get the capsule's imm", "CodeBleu_score": 36.18047087945632}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (o1->type == dCapsuleClass, \"dImmerseCapsuleTrimesh() o1 is not a capsule\");\n\tdUASSERT (o2->type == dTriMeshClass, \"dImmerseCapsuleTrimesh() o2 is not a trimesh\");\n\tdUASSERT (immersion->type == dImmersionCapsuleTrimeshClass, \"dImmerseCapsuleTrimesh() immersion is not a capsule-trimesh immersion\");\n\tdxCapsule *c = (dxCapsule *) o1;\n\tdxTriMesh *t = (dxTriMesh *) o2;\n\tdImmersionCapsuleTrimesh *it = (dImmersionCapsuleTrimesh *) immersion;\n\tdVector3 p1, p2, p3, p4, p5, p6, p7, p8;\n\tdVector3 p9, p10, p11, p12, p13, p14, p15, p16;\n\tdVector3 p17, p18, p19, p20, p21, p22, p23, p24;\n\tdVector3 p25, p26, p27, p28, p29, p30, p31, p32;\n\tdVector3 p33, p34, p35, p36, p37, p38, p39, p40;\n\tdVector3 p41, p42, p43, p44, p45, p46, p47, p48;\n\tdVector3 p49, p50, p51, p52, p53, p54, p55, p56;\n\tdVector3 p57, p58, p59, p60, p61, p62, p63, p64;\n\tdVector3 p65, p66, p67, p68, p69, p70, p71, p72;\n\tdVector3 p73, p74, p75, p76, p", "CodeBleu_score": 25.969910103000736}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// Retrieve the sleep duration in milliseconds from the input\n\tint sleep_time_ms = blackboard->get<int>(\"sleep_time_ms\");\n\n\t// If the duration is missing or non-positive, return SUCCESS\n\tif (sleep_time_ms <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start a timer and set a callback to emit a wake-up signal when the timer expires\n\ttimer_waiting_ = true;\n\ttimer_ = std::make_shared<rclcpp::TimerBase>(node_->get_clock(), std::chrono::milliseconds(sleep_time_ms), std::bind(&SleepNode::onTimerExpired, this));\n\tnode_->add_timer(timer_);\n\n\t// Return RUNNING\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 50.21811257679843}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tconst int duration_ms = getInput<int>(\"duration_ms\");\n\tif (duration_ms <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\tsetStatus(NodeStatus::RUNNING);\n\ttimer_waiting_ = true;\n\ttimer_ = std::make_shared<rclcpp::TimerBase>(get_clock());\n\ttimer_->callback_group->add_subscription(\n\t\tget_node_base_interface()->get_subscription_factory()->add_subscription(\n\t\t\t\"wake_up\",\n\t\t\tstd::bind(&SleepNode::wakeUpCallback, this),\n\t\t\trmw_qos_profile_default));\n\ttimer_->callback_group->add_timer(timer_);\n\ttimer_->schedule(std::chrono::milliseconds(duration_ms));\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 45.76437811413609}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (!blackboard_->hasInt(\"duration_ms\") || blackboard_->getInt(\"duration_ms\") <= 0 ) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tstatus_ = NodeStatus::RUNNING;\n\ttimer_waiting_ = true;\n\ttimer_.start(blackboard_->getInt(\"duration_ms\"));\n\ttimer_.timeout().connect(this, &SleepNode::wakeup);\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 32.20772829693013}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry from the blackboard\n\tauto entry = blackboard()->get_entry(m_name);\n\n\t// If the entry is not found, return FAILURE\n\tif (!entry) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the entry's mutex\n\tentry->lock();\n\n\t// If the sequence ID has changed, update the stored sequence ID and return SUCCESS\n\tif (entry->get_sequence_id()!= m_sequence_id) {\n\t\tm_sequence_id = entry->get_sequence_id();\n\t\tentry->unlock();\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// If the sequence ID has not changed, return FAILURE\n\tentry->unlock();\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 37.949130252935085}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (blackboard->hasKey(m_key)) {\n\t\tstd::lock_guard<std::mutex> lock(blackboard->getMutex(m_key));\n\t\tif (blackboard->getSequenceID(m_key)!= m_last_sequence_id) {\n\t\t\tm_last_sequence_id = blackboard->getSequenceID(m_key);\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 32.786236227619675}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (blackboard_->hasKey(key_)) {\n\t\tstd::lock_guard<std::mutex> lock(blackboard_->getMutex(key_));\n\t\tif (blackboard_->getSequenceID(key_) > sequence_id_) {\n\t\t\tsequence_id_ = blackboard_->getSequenceID(key_);\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 32.7033552345574}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn static_cast<size_t>(-success_threshold_) * children_nodes_.size();\n\t}\n\treturn static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 53.55092706993878}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tsize_t num_children = children_nodes_.size();\n\tif (success_threshold_ < 0) {\n\t\treturn num_children + success_threshold_;\n\t} else {\n\t\treturn success_threshold_;\n\t}\n}", "CodeBleu_score": 48.03716677380275}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\t// If the success threshold is negative, adjust it based on the number of child nodes\n\tif (success_threshold_ < 0) {\n\t\treturn static_cast<size_t>(num_children_ + success_threshold_ + 1);\n\t}\n\t// If the success threshold is non-negative, return it directly as a size_t\n\treturn static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 51.39252121204163}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tbool is_alive = std::chrono::system_clock::now() < m_last_heartbeat + std::chrono::seconds(1);\n\t\tif (is_alive!= m_heartbeat_active) {\n\t\t\tm_heartbeat_active = is_alive;\n\t\t\tfor (auto &it : m_breakpoints) {\n\t\t\t\tit.second->setEnabled(is_alive);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.13552037465276}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\tif (m_heartbeat_active) {\n\t\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - m_last_heartbeat_time).count() > 1000) {\n\t\t\t\tm_heartbeat_active = false;\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message_t(1, 0), zmq::send_flags::sndmore);\n\t\t\t\tm_pub_socket->send(zmq::message", "CodeBleu_score": 32.192828817531606}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tif (m_server_heartbeat_time!= 0) {\n\t\t\tif (std::chrono::system_clock::now() - m_server_heartbeat_time > std::chrono::seconds(5)) {\n\t\t\t\tm_server_heartbeat_time = 0;\n\t\t\t\tm_groot2_publisher.disableAllBreakpoints();\n\t\t\t}\n\t\t}\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t}\n}", "CodeBleu_score": 27.619915781128267}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> dump;\n\n\tstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\n\tfor (const auto& bb_name : bb_names) {\n\t\tauto subtree = _root_tree->findTree(bb_name);\n\t\tif (subtree) {\n\t\t\tsubtree->lock();\n\t\t\tstd::string json_str = subtree->dumpBlackboard();\n\t\t\tsubtree->unlock();\n\n\t\t\trapidjson::Document json_doc;\n\t\t\tjson_doc.Parse(json_str.c_str());\n\t\t\trapidjson::StringBuffer buffer;\n\t\t\trapidjson::Writer<rapidjson::StringBuffer> writer(buffer);\n\t\t\tjson_doc.Accept(writer);\n\n\t\t\tmsgpack::sbuffer sbuffer;\n\t\t\tmsgpack::pack(sbuffer, buffer.GetString());\n\t\t\tdump.insert(dump.end(), sbuffer.data(), sbuffer.data() + sbuffer.size());\n\t\t}\n\t}\n\n\treturn dump;\n}", "CodeBleu_score": 43.62019454044251}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\tnlohmann::json json_result;\n\n\tstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\n\tfor (const auto& bb_name : bb_names) {\n\t\tauto subtree = getSubtree(bb_name);\n\t\tif (subtree) {\n\t\t\tauto lock = subtree->lock();\n\t\t\tauto json_bb = subtree->blackboard()->to_json();\n\t\t\tjson_result[bb_name] = json_bb;\n\t\t}\n\t}\n\n\tresult = nlohmann::json::to_msgpack(json_result);\n\n\treturn result;\n}", "CodeBleu_score": 48.61035330523088}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> dump;\n\tif (bb_list.empty()) {\n\t\treturn dump;\n\t}\n\n\tstd::vector<std::string> bb_names;\n\tsplitString(bb_list, ',', bb_names);\n\n\tfor (auto& bb_name : bb_names) {\n\t\tauto tree = getTree(bb_name);\n\t\tif (tree) {\n\t\t\ttree->lock();\n\t\t\tauto bb_dump = tree->getBlackboard()->to_json();\n\t\t\ttree->unlock();\n\n\t\t\tdump.insert(dump.end(), bb_dump.begin(), bb_dump.end());\n\t\t}\n\t}\n\n\treturn dump;\n}", "CodeBleu_score": 42.942126417110835}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::lock_guard<std::mutex> lock(mutex_hook_);\n\tauto it = hooks_.find(node_uid);\n\tif (it == hooks_.end()) {\n\t\treturn false;\n\t}\n\tauto& hook = it->second;\n\tif (hook.status!= HookStatus::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook.desired_status = result;\n\thook.remove = remove;\n\thook.ready = true;\n\thook.cond.notify_all();\n\treturn true;\n}", "CodeBleu_score": 39.85944965217273}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::lock_guard<std::mutex> lck(m_mutex);\n\tauto it = m_nodes.find(node_uid);\n\tif (it == m_nodes.end()) {\n\t\treturn false;\n\t}\n\tauto &node = it->second;\n\tif (node.pos!= pos) {\n\t\treturn false;\n\t}\n\tauto &hook = node.hook;\n\tif (hook.mode!= Groot2Hook::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook.status = result;\n\thook.remove = remove;\n\thook.ready = true;\n\thook.cv.notify_all();\n\treturn true;\n}", "CodeBleu_score": 53.012563566614425}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tif (pos.first >= _hooks.size()) {\n\t\treturn false;\n\t}\n\tauto &hook = _hooks[pos.first];\n\tif (hook.second.uid!= node_uid) {\n\t\treturn false;\n\t}\n\tstd::lock_guard<std::mutex> lock(hook.first);\n\tif (hook.second.status == NodeStatus::IDLE) {\n\t\treturn false;\n\t}\n\thook.second.status = result;\n\thook.second.remove = remove;\n\thook.second.ready = true;\n\thook.second.cv.notify_all();\n\treturn true;\n}", "CodeBleu_score": 38.667234801543785}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status() == NodeStatus::IDLE) {\n\t\thalt_requested_ = false;\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\ttry {\n\t\t\tstd::thread t(&ThreadedAction::tickThread, this);\n\t\t\tt.detach();\n\t\t} catch (std::exception& e) {\n\t\t\tLOG_ERROR << \"ThreadedAction::executeTick: exception: \" << e.what();\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t}\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\thalt_requested_ = false;\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t}\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (stored_exception_) {\n\t\t\tstd::rethrow_exception(stored_exception_);\n\t\t}\n\t}\n\treturn status();\n}", "CodeBleu_score": 41.5171839756532}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status() == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\ttry {\n\t\t\tthread_ = std::thread(&ThreadedAction::tick, this);\n\t\t\tthread_.detach();\n\t\t} catch (std::exception &e) {\n\t\t\tLOG_ERROR(\"ThreadedAction::executeTick: exception caught: %s\", e.what());\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t}\n\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t} else {\n\t\t\tif (thread_.joinable()) {\n\t\t\t\tthread_.join();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t} else {\n\t\t\tif (thread_.joinable()) {\n\t\t\t\tthread_.join();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t} else {\n\t\t\tif (thread_.joinable()) {\n\t\t\t\tthread_.join();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t} else {\n\t\t\tif (thread_.joinable()) {\n\t\t\t\tthread_.join();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t} else {\n\t\t\tif (thread_.joinable()) {\n\t\t\t\tthread_.join();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t} else {\n\t\t\tif (thread_.joinable()) {\n\t\t\t\tthread_.join();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\tstatus_ = NodeStatus::IDLE", "CodeBleu_score": 39.364765631780344}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tswitch (status()) {\n\tcase NodeStatus::IDLE:\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tthread_ = std::thread(&BT::ThreadedAction::tick, this);\n\t\tbreak;\n\n\tcase NodeStatus::RUNNING:\n\t\tif (halt_requested_) {\n\t\t\thalt_requested_ = false;\n\t\t\tthread_.join();\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (thread_.joinable()) {\n\t\ttry {\n\t\t\tthread_.join();\n\t\t} catch (...) {\n\t\t\thalt_requested_ = false;\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tif (exception_) {\n\t\tstd::exception_ptr eptr = exception_;\n\t\texception_ = nullptr;\n\t\tstd::rethrow_exception(eptr);\n\t}\n\n\treturn status();\n}", "CodeBleu_score": 42.01551555776398}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstream << \"-----------------------------------------\" << std::endl;\n\t// This lambda function is used to recursively print the tree structure\n\tauto print_tree = [&stream](const TreeNode* node, int depth) {\n\t\t// Indent the output based on the node's depth\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"  \";\n\t\t}\n\t\t// Print the node's name\n\t\tstream << node->name() << std::endl;\n\t\t// Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control_node->children()) {\n\t\t\t\tprint_tree(child, depth + 1);\n\t\t\t}\n\t\t} else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n\t\t\tprint_tree(decorator_node->child(), depth + 1);\n\t\t}\n\t};\n\t// Begin the printing by calling the lambda function with the root_node and depth 0\n\tprint_tree(root_node, 0);\n\tstream << \"-----------------------------------------\" << std::endl;\n}", "CodeBleu_score": 51.854623699200744}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\tstream << \"Tree is empty!\" << std::endl;\n\t\treturn;\n\t}\n\n\tauto print_node = [&](const TreeNode* node, int depth) {\n\t\tstream << std::string(depth, '\\t') << node->name() << std::endl;\n\t\tif (node->children.empty()) {\n\t\t\treturn;\n\t\t}\n\t\tif (node->type() == NodeType::CONTROL_NODE) {\n\t\t\tfor (const auto& child : node->children) {\n\t\t\t\tprint_node(child.get(), depth + 1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprint_node(node->children.front().get(), depth + 1);\n\t\t}\n\t};\n\n\tstream << \"---------------------------\" << std::endl;\n\tprint_node(root_node, 0);\n\tstream << \"---------------------------\" << std::endl;\n}", "CodeBleu_score": 38.673235365271296}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tint depth = 0;\n\tauto print_node = [&stream, &depth](const TreeNode* node) {\n\t\tfor (int i = 0; i < depth; ++i) {\n\t\t\tstream << \"  \";\n\t\t}\n\t\tstream << node->name() << \"\n\";\n\t\tif (node->children().size() > 0) {\n\t\t\t++depth;\n\t\t\tfor (auto child : node->children()) {\n\t\t\t\tprint_node(child);\n\t\t\t}\n\t\t\t--depth;\n\t\t}\n\t};\n\n\tstream << \"====================\n\";\n\tprint_node(root_node);\n\tstream << \"====================\n\";\n}", "CodeBleu_score": 34.72882513211992}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow BT::LogicError(\"applyRecursiveVisitor: null pointer\");\n\t}\n\tvisitor(node);\n\tif (node->children.size() > 0) {\n\t\tif (node->children.size() > 1) {\n\t\t\tif (node->children.front()->type() == \"ControlNode\") {\n\t\t\t\tfor (auto child : node->children) {\n\t\t\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow BT::LogicError(\n\t\t\t\t\t\"applyRecursiveVisitor: expected a ControlNode\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (node->children.front()->type() == \"DecoratorNode\") {\n\t\t\t\tapplyRecursiveVisitor(node->children.front(), visitor);\n\t\t\t} else {\n\t\t\t\tthrow BT::LogicError(\n\t\t\t\t\t\"applyRecursiveVisitor: expected a DecoratorNode\");\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 43.30963523705706}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"Null pointer in applyRecursiveVisitor\");\n\t}\n\n\tvisitor(node);\n\n\tif (node->isControl()) {\n\t\tfor (const auto& child : node->children()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->isDecorator()) {\n\t\tapplyRecursiveVisitor(node->children().front(), visitor);\n\t}\n}", "CodeBleu_score": 43.45716591793508}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"applyRecursiveVisitor: node is null\");\n\t}\n\n\tvisitor(node);\n\n\tif (node->isControlNode()) {\n\t\tauto* control_node = static_cast<const ControlNode*>(node);\n\t\tfor (auto& child : control_node->children_nodes) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->isDecoratorNode()) {\n\t\tauto* decorator_node = static_cast<const DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(decorator_node->child_node, visitor);\n\t}\n}", "CodeBleu_score": 57.33042508842632}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.find(manifest.registration_ID)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"Builder already registered with ID: \" + manifest.registration_ID);\n\t}\n\tbuilders_[manifest.registration_ID] = builder;\n\tmanifests_[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 45.38281955090763}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tstd::string registration_id = manifest.registration_id;\n\tauto it = builders_.find(registration_id);\n\tif (it!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\"ID \" + registration_id +\n\t\t                            \" already registered\");\n\t}\n\n\tbuilders_.insert(std::make_pair(registration_id, builder));\n\tmanifests_.insert(std::make_pair(registration_id, manifest));\n}", "CodeBleu_score": 43.40005260840676}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.find(manifest.registration_ID)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\"Builder already registered\");\n\t}\n\tbuilders_.insert(std::make_pair(manifest.registration_ID, builder));\n\tmanifests_.insert(std::make_pair(manifest.registration_ID, manifest));\n}", "CodeBleu_score": 47.791014731105776}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t#if defined(BT_USE_ROS)\n  // The tick_functor is a lambda function that takes a SimpleActionNode as an\n  // argument and returns a NodeStatus.\n  // It is used to define the behavior of the SimpleActionNode when it is\n  // executed.\n  // The ports argument is a list of ports that the SimpleActionNode requires to\n  // function properly.\n  // The ports argument is passed to the SimpleActionNode constructor to define\n  // the ports that the node requires.\n  // The tick_functor is used to define the behavior of the SimpleActionNode\n  // when it is executed.\n  // The ports argument is used to define the ports that the SimpleActionNode\n  // requires to function properly.\n  // The tick_functor and ports arguments are used together to create a\n  // SimpleActionNode that can be used in a Behavior Tree.\n  // The tick_functor is a lambda function that takes a SimpleActionNode as an\n  // argument and returns a NodeStatus.\n  // The ports argument is a list of ports that the SimpleActionNode requires to\n  // function properly.\n  // The tick_functor is used to define the behavior of the SimpleActionNode\n  // when it is executed.\n  // The ports argument is used to define the ports that the SimpleActionNode\n  // requires to function properly.\n  // The tick_functor and ports arguments are used together to create a\n  // SimpleActionNode that can be used in a Behavior Tree.\n  // The tick_functor is a lambda function that takes a SimpleActionNode as an\n  // argument and returns a NodeStatus.\n  // The ports argument is a list of ports that the SimpleActionNode requires to\n  // function properly.\n  // The tick_functor is used to define the behavior of the SimpleActionNode\n  // when it is executed.\n  // The ports argument is used to define the ports that the SimpleActionNode\n  // requires to function properly.\n  // The tick_functor and ports arguments are used together to create a\n  // SimpleActionNode that can be used in a Behavior Tree.\n  // The tick_functor is a lambda function that takes a SimpleActionNode as an\n  // argument and returns a NodeStatus.\n  // The ports argument is a list of ports that the SimpleActionNode requires to\n  // function properly.\n  // The tick_functor is used to define the behavior of the SimpleActionNode\n  // when it is executed.\n  // The ports argument is used to define", "CodeBleu_score": 12.248971347935832}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t// Create a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\n  auto builder = [tick_functor, ports](const std::string& name,\n                                       const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n// Create a TreeNodeManifest with the action node type, ID, and ports list.\n  TreeNodeManifest manifest(NodeType::ACTION, ID, ports);\n\n// Call registerBuilder to register the manifest and builder.\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 73.99263523958261}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\tauto builder = [tick_functor](const std::string& name, const NodeConfig& config) {\n\t\treturn std::make_unique<SimpleActionNode>(name, tick_functor, config);\n\t};\n\n\tTreeNodeManifest manifest(NodeType::ACTION, ID, ports);\n\tregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 63.64629019526442}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.subtrees().size());\n\tfor (const auto& subtree : tree.subtrees()) {\n\t\tBlackboard::Ptr backup = subtree->root_node()->blackboard()->clone();\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}", "CodeBleu_score": 53.11053312430324}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> blackboard_backups;\n\tblackboard_backups.reserve(tree.subtrees().size());\n\tfor (const auto& subtree : tree.subtrees()) {\n\t\tBlackboard::Ptr backup = Blackboard::create();\n\t\tsubtree->root_node()->blackboard()->clone(*backup);\n\t\tblackboard_backups.push_back(backup);\n\t}\n\treturn blackboard_backups;\n}", "CodeBleu_score": 50.799773250413146}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.subtrees().size());\n\n\tfor (auto subtree : tree.subtrees()) {\n\t\tbackups.emplace_back(subtree->root_node()->blackboard()->clone());\n\t}\n\n\treturn backups;\n}", "CodeBleu_score": 52.53433001966097}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn executor.error();\n\t}\n\n\treturn executor->execute(env);\n}", "CodeBleu_score": 58.974290521264614}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(env, script);\n\tif(executor.has_value()) {\n\t\treturn executor.value()();\n\t}\n\telse {\n\t\treturn executor.error();\n\t}\n}", "CodeBleu_score": 60.1753446189288}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tBT::Expected<std::unique_ptr<Ast::Executor>> executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn BT::makeUnexpected(executor.error());\n\t}\n\treturn (*executor)->Execute(env);\n}", "CodeBleu_score": 58.96242816499927}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (loaded_) {\n\t\tthrow RuntimeError(\"SharedLibrary::load: library already loaded\");\n\t}\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle_) {\n\t\tthrow RuntimeError(\"SharedLibrary::load: \" + std::string(dlerror()));\n\t}\n\tloaded_ = true;\n\tpath_ = path;\n}", "CodeBleu_score": 52.180850047119364}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (handle_!= nullptr) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle_ == nullptr) {\n\t\tstd::string error = dlerror();\n\t\tthrow RuntimeError(error);\n\t}\n\tpath_ = path;\n}", "CodeBleu_score": 53.17021354552415}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\n\tif (handle_!= nullptr) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\tif (handle_ == nullptr) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\n\tpath_ = path;\n}", "CodeBleu_score": 46.69494545744301}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif(str.size() < 3) {\n\t\treturn false;\n\t}\n\n\t// strip leading and trailing spaces\n\tStringView stripped = str;\n\twhile(stripped.size() > 0 && stripped[0] =='') {\n\t\tstripped = stripped.substr(1);\n\t}\n\twhile(stripped.size() > 0 && stripped[stripped.size()-1] =='') {\n\t\tstripped = stripped.substr(0, stripped.size()-1);\n\t}\n\n\t// check if it starts with '{' and ends with '}'\n\tif(stripped[0] == '{' && stripped[stripped.size()-1] == '}') {\n\t\tif(stripped_pointer) {\n\t\t\t*stripped_pointer = stripped.substr(1, stripped.size()-2);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 30.095068526498736}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tauto stripped = str;\n\tstripped.trim();\n\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped[0]!= '{' || stripped[stripped.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\tstripped_pointer->assign(stripped.begin() + 1, stripped.end() - 1);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 25.869980923751378}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tauto start = str.begin();\n\tauto end = str.end();\n\n\t// strip leading spaces\n\twhile (start!= end && *start =='') {\n\t\t++start;\n\t}\n\n\t// strip trailing spaces\n\twhile (end!= start && *(end - 1) =='') {\n\t\t--end;\n\t}\n\n\tif (*start!= '{' || *(end - 1)!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = StringView(start + 1, end - start - 1);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 38.319040098418185}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0.0;\n\tbase_local_planner::LineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (int i = 0; i < line.n; i++, line.advance()) {\n\t\tdouble point_cost = pointCost(line.x, line.y);\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\tif (point_cost > cost) {\n\t\t\tcost = point_cost;\n\t\t}\n\t}\n\treturn cost;\n}", "CodeBleu_score": 53.87081389907507}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0.0;\n\tbase_local_planner::LineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (int i = 0; i < line.n; ++i, ++line) {\n\t\tdouble point_cost = pointCost(line.x, line.y);\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\tif (point_cost > cost) {\n\t\t\tcost = point_cost;\n\t\t}\n\t}\n\treturn cost;\n}", "CodeBleu_score": 49.0951896958835}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tbase_local_planner::LineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (int i = 0; i < line.n; ++i, ++line) {\n\t\tdouble point_cost = pointCost(line.x, line.y);\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\tif (point_cost > line_cost) {\n\t\t\tline_cost = point_cost;\n\t\t}\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 55.98230738838821}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 83.04198294017864}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 83.04198294017864}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 83.04198294017864}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (base_odom.twist.twist.linear.x <= trans_stopped_velocity && base_odom.twist.twist.linear.y <= trans_stopped_velocity && base_odom.twist.twist.linear.z <= trans_stopped_velocity && base_odom.twist.twist.angular.x <= rot_stopped_velocity && base_odom.twist.twist.angular.y <= rot_stopped_velocity && base_odom.twist.twist.angular.z <= rot_stopped_velocity);\n}", "CodeBleu_score": 49.798239171717356}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (base_odom.twist.twist.angular.x <= rot_stopped_velocity && base_odom.twist.twist.angular.y <= rot_stopped_velocity && base_odom.twist.twist.angular.z <= rot_stopped_velocity && base_odom.twist.twist.linear.x <= trans_stopped_velocity && base_odom.twist.twist.linear.y <= trans_stopped_velocity && base_odom.twist.twist.linear.z <= trans_stopped_velocity);\n}", "CodeBleu_score": 49.798239171717356}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tif(base_odom.twist.twist.angular.x <= rot_stopped_velocity && base_odom.twist.twist.angular.y <= rot_stopped_velocity && base_odom.twist.twist.angular.z <= rot_stopped_velocity && base_odom.twist.twist.linear.x <= trans_stopped_velocity && base_odom.twist.twist.linear.y <= trans_stopped_velocity && base_odom.twist.twist.linear.z <= trans_stopped_velocity) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 48.7722927464365}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (setup_ && restore_defaults) {\n\t\tconfig = default_limits_;\n\t}\n\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\tlimits_ = config;\n\tlimits_.acc_lim_theta = fabs(limits_.acc_lim_theta);\n\tlimits_.acc_lim_x = fabs(limits_.acc_lim_x);\n\tlimits_.acc_lim_y = fabs(limits_.acc_lim_y);\n\tlimits_.max_vel_theta = fabs(limits_.max_vel_theta);\n\tlimits_.min_vel_theta = -1.0 * fabs(limits_.min_vel_theta);\n\tlimits_.min_in_place_vel_theta = -1.0 * fabs(limits_.min_in_place_vel_theta);\n\tlimits_.max_vel_x = fabs(limits_.max_vel_x);\n\tlimits_.min_vel_x = -1.0 * fabs(limits_.min_vel_x);\n\tlimits_.max_vel_y = fabs(limits_.max_vel_y);\n\tlimits_.min_vel_y = -1.0 * fabs(limits_.min_vel_y);\n\tlimits_.xy_goal_tolerance = fabs(limits_.xy_goal_tolerance);\n\tlimits_.yaw_goal_tolerance = fabs(limits_.yaw_goal_tolerance);\n\tlimits_.prune_plan = config.prune_plan;\n\tlimits_.trans_stopped_vel = fabs(limits_.trans_stopped_vel);\n\tlimits_.rot_stopped_vel = fabs(limits_.rot_stopped_vel);\n}", "CodeBleu_score": 58.30795146188468}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t\treturn;\n\t}\n\n\tconfig.acc_lim_x = std::max(config.acc_lim_x, 0.0);\n\tconfig.acc_lim_y = std::max(config.acc_lim_y, 0.0);\n\tconfig.acc_lim_theta = std::max(config.acc_lim_theta, 0.0);\n\tconfig.acc_lim_trans = std::max(config.acc_lim_trans, 0.0);\n\n\tconfig.max_vel_x = std::max(config.max_vel_x, 0.0);\n\tconfig.min_vel_x = std::min(config.min_vel_x, config.max_vel_x);\n\tconfig.max_vel_y = std::max(config.max_vel_y, 0.0);\n\tconfig.min_vel_y = std::min(config.min_vel_y, config.max_vel_y);\n\tconfig.max_vel_trans = std::max(config.max_vel_trans, 0.0);\n\tconfig.min_vel_trans = std::min(config.min_vel_trans, config.max_vel_trans);\n\tconfig.max_vel_theta = std::max(config.max_vel_theta, 0.0);\n\tconfig.min_vel_theta = std::min(config.min_vel_theta, config.max_vel_theta);\n\n\tconfig.min_in_place_vel_theta = std::max(config.min_in_place_vel_theta, 0.0);\n\n\tconfig.xy_goal_tolerance = std::max(config.xy_goal_tolerance, 0.0);\n\tconfig.yaw_goal_tolerance = std::max(config.yaw_goal_tolerance, 0.0);\n\tconfig.latch_xy_goal_tolerance = config.latch_xy_goal_tolerance? true : false;\n\n\tconfig.sim_time = std::max(", "CodeBleu_score": 47.9020131055798}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t\treturn;\n\t}\n\n\tconfig_mutex_.lock();\n\tlimits_ = config;\n\tconfig_mutex_.unlock();\n}", "CodeBleu_score": 59.29778655416417}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false\n\tif (check_cell->cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\tcurrent_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n\t\treturn false;\n\t}\n\n\t// Calculate the new target distance\n\tdouble new_target_dist = current_cell->target_dist + check_cell->target_dist;\n\n\t// If the new distance is shorter, update the cell's target distance and return true\n\tif (new_target_dist < check_cell->target_dist) {\n\t\tcheck_cell->target_dist = new_target_dist;\n\t\treturn true;\n\t}\n\n\t// If the new distance is not shorter, return false\n\treturn false;\n}", "CodeBleu_score": 49.54801138885808}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\tunsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\tif (cost >= costmap_2d::LETHAL_OBSTACLE) {\n\t\tcurrent_cell->target_dist = LETHAL_OBSTACLE;\n\t\treturn false;\n\t}\n\n\tdouble dist = current_cell->target_dist + 1;\n\tif (dist < check_cell->target_dist) {\n\t\tcheck_cell->target_dist = dist;\n\t}\n\treturn true;\n}", "CodeBleu_score": 54.137106004770985}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\tif (check_cell->cost == costmap_2d::NO_INFORMATION || check_cell->cost >= costmap_2d::LETHAL_OBSTACLE) {\n\t\tcheck_cell->target_dist = costmap_2d::LETHAL_OBSTACLE;\n\t\treturn false;\n\t}\n\tdouble dist = current_cell->target_dist + hypot(check_cell->x - current_cell->x, check_cell->y - current_cell->y);\n\tif (dist < check_cell->target_dist) {\n\t\tcheck_cell->target_dist = dist;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 51.21759273084621}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"No footprint points provided for cost calculation.\");\n\t\treturn -9;\n\t}\n\n\tdouble cost = 0.0;\n\tdouble scale = 1.0;\n\tdouble x = 0.0;\n\tdouble y = 0.0;\n\tdouble theta = 0.0;\n\tdouble resolution = costmap_->getResolution();\n\tdouble footprint_cost = 0.0;\n\n\t//for each point in the trajectory...\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble px = traj.xv_[i];\n\t\tdouble py = traj.yv_[i];\n\t\tdouble pth = traj.thetav_[i];\n\t\tdouble pvel = traj.getPoint(i).getVelocity();\n\t\tdouble pacc = traj.getPoint(i).getAcceleration();\n\t\tdouble ptime = traj.getPoint(i).getTime();\n\n\t\t//make sure that we are using the newest costmap\n\t\tcostmap_ = costmap_ros_->getCostmap();\n\n\t\t//if we shouldn't take the velocity into account, pvel = 0\n\t\tif (!use_velocity_) {\n\t\t\tpvel = 0.0;\n\t\t}\n\n\t\t//if we shouldn't take the acceleration into account, pacc = 0\n\t\tif (!use_acceleration_) {\n\t\t\tpacc = 0.0;\n\t\t}\n\n\t\t//if we shouldn't take the time into account, ptime = 0\n\t\tif (!use_time_) {\n\t\t\tptime = 0.0;\n\t\t}\n\n\t\t//if we are using a scaling factor, scale = 1\n\t\tif (scaling_speed_ > 0.0) {\n\t\t\tscale = pvel / scaling_speed_;\n\t\t}\n\n\t\t//if we are using a scaling factor, scale = 1\n\t\tif (scaling_acceleration_ > 0.0) {\n\t\t\tscale = pacc / scaling_acceleration_;\n\t\t}\n\n\t\t//if we are using a scaling factor, scale = 1\n\t\tif (scaling_time_ > 0.0) {\n\t\t\tscale = ptime / scaling_time_;\n\t\t}\n\n\t\t//if", "CodeBleu_score": 47.55807586469726}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tif (footprint_spec_.points.empty()) {\n\t\tROS_ERROR(\"The robot footprint is not set for the obstacle cost function, so it cannot score trajectories\");\n\t\treturn -9;\n\t}\n\n\tdouble cost = 0.0;\n\tdouble scaling = 1.0;\n\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i), scaling);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\treturn cost;\n}", "CodeBleu_score": 48.008492182359234}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\t// The total cost for this trajectory.\n\tdouble cost = 0.0;\n\t// The total scaling factor.\n\tdouble scaling = 0.0;\n\t// The cost of the footprint at each point on the trajectory.\n\tdouble footprint_cost = 0.0;\n\t// The footprint specification.\n\tstd::vector<geometry_msgs::Point> footprint_spec = footprint_spec_;\n\t// The number of points in the trajectory.\n\tunsigned int num_points = traj.getPointsSize();\n\t// The number of points in the footprint specification.\n\tunsigned int num_spec_points = footprint_spec.size();\n\n\t// If the footprint specification is empty, log an error and return -9.\n\tif (footprint_spec.empty()) {\n\t\tROS_ERROR(\"The footprint specification is empty.\");\n\t\treturn -9.0;\n\t}\n\n\t// For each point in the trajectory, calculate the footprint cost.\n\tfor (unsigned int i = 0; i < num_points; ++i) {\n\t\t// Get the pose of the point in the trajectory.\n\t\tPoseStamped pose = traj.getPoint(i);\n\t\t// Calculate the footprint cost.\n\t\tfootprint_cost = footprintCost(pose, footprint_spec, inscribed_radius_, circumscribed_radius_);\n\t\t// If the footprint cost is negative, return the cost immediately.\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\t\t// Otherwise, either sum the scores or take the maximum score based on the sum_scores_ flag.\n\t\telse {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost;\n\t\t\t\tscaling += 1.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcost = std::max(cost, footprint_cost);\n\t\t\t\tscaling = std::max(scaling, 1.0);\n\t\t\t}\n\t\t}\n\t}\n\n\t// If the scaling factor is not zero, scale the cost by the scaling factor.\n\tif (scaling!= 0.0) {\n\t\tcost /= scaling;\n\t}\n\n\t// Return the total cost.\n\treturn cost;\n}", "CodeBleu_score": 52.444299522363515}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//  ROS_INFO(\"ObstacleCostFunction::footprintCost\");\n\n  //check if the footprint is legal\n  if (!costmap->worldToMap(x, y, grid_x, grid_y)) {\n    return -7.0;\n  }\n\n  //check if the footprint is legal\n  if (footprint_spec.size() > 0) {\n    double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec);\n    if (footprint_cost < 0) {\n      return -6.0;\n    }\n  }\n\n  //check the cell validity\n  unsigned int cell_x, cell_y;\n  costmap->worldToMap(x, y, cell_x, cell_y);\n  double point_cost = costmap->getCost(cell_x, cell_y);\n  if (point_cost == costmap_2d::NO_INFORMATION) {\n    return -1.0;\n  }\n\n  return std::max(double(point_cost), footprint_cost);\n}", "CodeBleu_score": 54.68175997130537}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//    ROS_INFO(\"ObstacleCostFunction::footprintCost\");\n\n    //check if the footprint is legal\n    if (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n        ROS_DEBUG(\"The robot is off the map\");\n        return -7.0;\n    }\n\n    //if we cannot draw a circle around the footprint, we'll just assume there's\n    //an obstacle\n    if (!world_model->footprintCost(x, y, th, footprint_spec, costmap, cell_x, cell_y)) {\n        return -6.0;\n    }\n\n    //set up parameters for scaling the footprint\n    double cos_th = cos(th);\n    double sin_th = sin(th);\n    double scaled_x, scaled_y;\n\n    //we need to loop through the 360 degrees\n    for (double i = 0; i < 2 * M_PI; i += M_PI / 180.0) {\n        //check if the footprint point is in our costmap\n        scaled_x = x + scale * cos(i) * cos_th - scale * sin(i) * sin_th;\n        scaled_y = y + scale * cos(i) * sin_th + scale * sin(i) * cos_th;\n\n        if (!costmap->worldToMap(scaled_x, scaled_y, cell_x, cell_y)) {\n            ROS_DEBUG(\"The robot is off the map\");\n            return -7.0;\n        }\n\n        //check cost function\n        double point_cost = pointCost(costmap, cell_x, cell_y);\n\n        if (point_cost < 0) {\n            return -6.0;\n        }\n    }\n\n    return 0.0;\n}", "CodeBleu_score": 53.60136392029033}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t//ROS_INFO(\"ObstacleCostFunction::footprintCost\");\n    if (costmap == NULL) {\n        ROS_ERROR(\"The costmap passed to this function is NULL, please call setCostmap() before using this function\");\n        return -1.0;\n    }\n    if (world_model == NULL) {\n        ROS_ERROR(\"The world model passed to this function is NULL, please call setWorldModel() before using this function\");\n        return -1.0;\n    }\n\n    //check if the footprint is legal\n    double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec);\n    if (footprint_cost < 0) {\n        return -6.0;\n    }\n\n    //check if the position is off the map\n    unsigned int cell_x, cell_y;\n    if (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n        return -7.0;\n    }\n\n    //check the cell validity\n    double point_x = x;\n    double point_y = y;\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        point_x += scale * cos(th + footprint_spec[i].x);\n        point_y += scale * sin(th + footprint_spec[i].x);\n\n        unsigned int cell_x, cell_y;\n        if (!costmap->worldToMap(point_x, point_y, cell_x, cell_y)) {\n            return -7.0;\n        }\n\n        double point_cost = costmap->getCost(cell_x, cell_y);\n        if (point_cost < 0) {\n            return -6.0;\n        }\n    }\n\n    //check the maximum cost of the footprint points\n    double max_cost = 0.0;\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        point_x = x + scale * cos(th + footprint_spec[i].x);\n        point_y = y + scale * sin(th + footprint_spec[i].x);\n\n        unsigned int cell_x, cell_y;\n        if (!costmap->worldToMap(point_x, point_y, cell_x, cell_y)) {\n           ", "CodeBleu_score": 64.22241318799851}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic_!= odom_topic) {\n\t\todom_topic_ = odom_topic;\n\t\tif (!odom_topic_.empty()) {\n\t\t\tROS_INFO(\"Subscribing to %s\", odom_topic_.c_str());\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 10, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\tROS_INFO(\"Unsubscribing from odometry topic\");\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}", "CodeBleu_score": 45.7049446620141}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (!odom_topic_.empty()) {\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}", "CodeBleu_score": 44.906430684719034}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic_!= odom_topic) {\n\t\todom_topic_ = odom_topic;\n\n\t\tif (odom_topic_!= \"\") {\n\t\t\tROS_INFO(\"Subscribing to %s\", odom_topic_.c_str());\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\tROS_INFO(\"Unsubscribing from odometry topic\");\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}", "CodeBleu_score": 47.8779383663242}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// Check if we are oscillating\n\tfloat dx = pos.x() - prev.x();\n\tfloat dy = pos.y() - prev.y();\n\tfloat dist_sq = dx*dx + dy*dy;\n\tfloat angle = atan2(dy, dx) - prev.z();\n\tangle = angles::normalize_angle(angle);\n\tif (dist_sq > oscillation_reset_dist_sq_ || fabs(angle) > oscillation_reset_angle_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 47.315124858501875}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat sq_dist = (pos[0] - prev[0]) * (pos[0] - prev[0]) + (pos[1] - prev[1]) * (pos[1] - prev[1]);\n\tfloat angle = std::abs(angles::shortest_angular_distance(pos[2], prev[2]));\n\tif (sq_dist > sq_dist_threshold_ || angle > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 44.4512710909851}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat dist_sq = (pos - prev).squaredNorm();\n\tif (dist_sq > oscillation_reset_dist_ * oscillation_reset_dist_) {\n\t\tresetOscillationFlags();\n\t\treturn;\n\t}\n\n\tfloat angle = fabs(angles::shortest_angular_distance(tf::getYaw(prev.cast<tf::Quaternion>()), tf::getYaw(pos.cast<tf::Quaternion>())));\n\tif (angle > oscillation_reset_angle_) {\n\t\tresetOscillationFlags();\n\t\treturn;\n\t}\n}", "CodeBleu_score": 40.94939270429662}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tint i, j;\n\tint idx;\n\n\t// calculate grid coordinates\n\ti = (int) ((pt.x - origin_.x) / resolution_);\n\tj = (int) ((pt.y - origin_.y) / resolution_);\n\n\t// check if the point is outside the grid\n\tif (i < 0 || i >= width_ || j < 0 || j >= height_)\n\t\treturn;\n\n\t// check if the point is too close to its nearest neighbor\n\tif (nearest_neighbor_dist_sq(pt) < min_dist_sq_)\n\t\treturn;\n\n\t// calculate the index of the grid cell\n\tidx = i + j * width_;\n\n\t// insert the point into the grid\n\tgrid_[idx].push_back(pt);\n}", "CodeBleu_score": 47.28792491304742}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// determine grid coordinates\n\tunsigned int x = (unsigned int) ((pt.x - origin_x_) / resolution_);\n\tunsigned int y = (unsigned int) ((pt.y - origin_y_) / resolution_);\n\n\t// check if point is inside the grid\n\tif (x >= width_ || y >= height_) {\n\t\treturn;\n\t}\n\n\t// check if point is too close to its nearest neighbor\n\tif (closest_point_distance_sq(pt) < min_point_dist_sq_) {\n\t\treturn;\n\t}\n\n\t// calculate grid index\n\tunsigned int index = y * width_ + x;\n\n\t// insert point into cell\n\tgrid_[index].push_back(pt);\n}", "CodeBleu_score": 48.16292157540928}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// Determine grid coordinates of point\n\tint x = (int) (pt.x / resolution_);\n\tint y = (int) (pt.y / resolution_);\n\n\t// Check if point is within grid bounds\n\tif (x < 0 || x >= width_ || y < 0 || y >= height_) {\n\t\treturn;\n\t}\n\n\t// Check if point is too close to its nearest neighbor\n\tif (min_distance_ > 0.0) {\n\t\tint x_min = x - 1;\n\t\tint x_max = x + 1;\n\t\tint y_min = y - 1;\n\t\tint y_max = y + 1;\n\n\t\tif (x_min < 0) {\n\t\t\tx_min = 0;\n\t\t}\n\t\tif (x_max >= width_) {\n\t\t\tx_max = width_ - 1;\n\t\t}\n\t\tif (y_min < 0) {\n\t\t\ty_min = 0;\n\t\t}\n\t\tif (y_max >= height_) {\n\t\t\ty_max = height_ - 1;\n\t\t}\n\n\t\tdouble min_dist = min_distance_;\n\t\tmin_dist *= min_dist;\n\t\tfor (int i = x_min; i <= x_max; i++) {\n\t\t\tfor (int j = y_min; j <= y_max; j++) {\n\t\t\t\tconst geometry_msgs::Point32& nearest_pt = cells_[i + j * width_];\n\t\t\t\tdouble dx = pt.x - nearest_pt.x;\n\t\t\t\tdouble dy = pt.y - nearest_pt.y;\n\t\t\t\tdouble dist = dx * dx + dy * dy;\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Insert point into grid\n\tcells_[x + y * width_] = pt;\n}", "CodeBleu_score": 31.99649256775298}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (unsigned int i = 0; i < 3; ++i) {\n\t\t// compute the new velocity in the ith dimension\n\t\tnew_vel[i] = computeNewVelocity(sample_target_vel[i], vel[i], acclimits[i], dt);\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 48.20039075461642}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\t// initialize new velocity vector\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n\t// compute new velocities for each component\n\tfor (unsigned int i = 0; i < 3; ++i) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n\t\t}\n\t}\n\n\treturn new_vel;\n}", "CodeBleu_score": 80.30546534526519}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; ++i) {\n\t\tdouble diff = sample_target_vel[i] - vel[i];\n\t\tif (fabs(diff) < 0.0001) {\n\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t} else {\n\t\t\tdouble acc = diff / dt;\n\t\t\tif (acc > acclimits[i]) {\n\t\t\t\tnew_vel[i] = vel[i] + acclimits[i] * dt;\n\t\t\t} else if (acc < -acclimits[i]) {\n\t\t\t\tnew_vel[i] = vel[i] - acclimits[i] * dt;\n\t\t\t} else {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 72.7336196682129}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = DBL_MAX;\n\tdouble dx = 0.0;\n\tdouble dy = 0.0;\n\tdouble gx = 0.0;\n\tdouble gy = 0.0;\n\tdouble goal_heading = 0.0;\n\tdouble goal_diff = 0.0;\n\tdouble goal_dist = 0.0;\n\tdouble goal_angle = 0.0;\n\tdouble angle_diff = 0.0;\n\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\tdx = global_plan_[i].x - x;\n\t\tdy = global_plan_[i].y - y;\n\t\tif (dx * dx + dy * dy <= 1.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!costmap_->worldToMap(global_plan_[i].x, global_plan_[i].y, cell_x, cell_y)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!costmap_->getCost(cell_x, cell_y) == costmap_2d::NO_INFORMATION) {\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (cell_x == 0 && cell_y == 0) {\n\t\treturn diff;\n\t}\n\n\tcostmap_->mapToWorld(cell_x, cell_y, gx, gy);\n\tgoal_heading = atan2(gy - y, gx - x);\n\tgoal_diff = angles::shortest_angular_distance(heading, goal_heading);\n\tgoal_dist = hypot(gx - x, gy - y);\n\tgoal_angle = angles::normalize_angle(atan2(gy - y, gx - x) - heading);\n\tangle_diff = fabs(angles::shortest_angular_distance(goal_angle, 0.0));\n\tdiff = fabs(angles::shortest_angular_distance(heading, atan2(gy - y, gx - x)));\n\n\treturn diff;\n}", "CodeBleu_score": 55.34868755665092}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble goal_x, goal_y;\n\tdouble dx, dy, dth;\n\n\t// Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// Get the cell coordinates of the current point in the global plan\n\t\tint g_cell_x = global_plan_[i].pose.position.x;\n\t\tint g_cell_y = global_plan_[i].pose.position.y;\n\n\t\t// Check if the current point is in the same cell as the robot's current position\n\t\tif (g_cell_x == cell_x && g_cell_y == cell_y) {\n\t\t\t// Check if the current point has a clear line of sight from the robot's current cell\n\t\t\tif (checkLineOfSight(cell_x, cell_y, g_cell_x, g_cell_y)) {\n\t\t\t\t// Convert the cell coordinates of the current point to world coordinates\n\t\t\t\tgoal_x = costmap_->getOriginX() + g_cell_x * costmap_->getResolution();\n\t\t\t\tgoal_y = costmap_->getOriginY() + g_cell_y * costmap_->getResolution();\n\n\t\t\t\t// Calculate the difference in heading between the robot's current position and the current point\n\t\t\t\tdx = goal_x - x;\n\t\t\t\tdy = goal_y - y;\n\t\t\t\tdth = atan2(dy, dx) - heading;\n\n\t\t\t\t// Return the absolute value of the shortest angular distance between the current heading and the direction to the current point\n\t\t\t\treturn angles::normalize_angle(dth);\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no valid point is found, return DBL_MAX\n\treturn DBL_MAX;\n}", "CodeBleu_score": 57.0333654521232}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble goal_x = 0.0;\n\tdouble goal_y = 0.0;\n\tdouble diff = 0.0;\n\tdouble angle = 0.0;\n\tdouble dx = 0.0;\n\tdouble dy = 0.0;\n\tdouble goal_angle = 0.0;\n\tdouble goal_heading = 0.0;\n\tdouble angle_diff = 0.0;\n\tdouble min_dist = 0.0;\n\tdouble dist = 0.0;\n\tint i = 0;\n\tint j = 0;\n\tint count = 0;\n\tint mx = 0;\n\tint my = 0;\n\tint nx = 0;\n\tint ny = 0;\n\tint gx = 0;\n\tint gy = 0;\n\tint min_i = 0;\n\tint min_j = 0;\n\tint max_i = 0;\n\tint max_j = 0;\n\tint num_cells = 0;\n\tint num_steps = 0;\n\tint num_steps_x = 0;\n\tint num_steps_y = 0;\n\tint step_x = 0;\n\tint step_y = 0;\n\tint cell_step_x = 0;\n\tint cell_step_y = 0;\n\tint first_i = 0;\n\tint first_j = 0;\n\tint last_i = 0;\n\tint last_j = 0;\n\tint cell_step = 0;\n\tint num_cells_x = 0;\n\tint num_cells_y = 0;\n\tint num_cells_step = 0;\n\tint cell_step_x_sign = 0;\n\tint cell_step_y_sign = 0;\n\tint num_cells_step_x = 0;\n\tint num_cells_step_y = 0;\n\tint cell_step_x_inc = 0;\n\tint cell_step_y_inc = 0;\n\tint num_cells_x_sign = 0;\n\tint num_cells_", "CodeBleu_score": 7.622818537640866}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t//ROS_INFO(\"checkTrajectory\");\n\t//ROS_INFO(\"checkTrajectory: x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\t//ROS_INFO(\"checkTrajectory: x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f\", x, y, theta, vx, vy, vtheta);\n\t//ROS_INFO(\"checkTrajectory: vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", vx_samp, vy_samp, vtheta_samp);\n\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta);\n\t//ROS_INFO(\"checkTrajectory: cost: %f\", cost);\n\tif (cost < 0) {\n\t\tROS_WARN(\"Invalid Trajectory x: %.2f, y: %.2f, theta: %.2f, vx: %.2f, vy: %.2f, vtheta: %.2f, cost: %.2f\", x, y, theta, vx, vy, vtheta, cost);\n\t\tROS_WARN(\"Invalid Trajectory vx_samp: %.2f, vy_samp: %.2f, vtheta_samp: %.2f\", vx_samp, vy_samp, vtheta_samp);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 60.110061270061784}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t//ROS_INFO(\"TrajectoryPlanner::checkTrajectory\");\n\t//ROS_INFO(\"x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n\t// compute the cost of the trajectory\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta);\n\n\t// if the trajectory is a legal one...\n\tif (cost >= 0) {\n\t\t//ROS_INFO(\"TrajectoryPlanner::checkTrajectory: cost >= 0\");\n\t\treturn true;\n\t} else {\n\t\t//ROS_INFO(\"TrajectoryPlanner::checkTrajectory: cost < 0\");\n\t\t//ROS_INFO(\"TrajectoryPlanner::checkTrajectory: vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", vx_samp, vy_samp, vtheta_samp);\n\t\t//ROS_INFO(\"TrajectoryPlanner::checkTrajectory: cost: %f\", cost);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 45.18442265599115}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t//compute the cost of the trajectory\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n\t//if the cost is negative, log a warning and return false\n\tif (cost < 0) {\n\t\tROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp, vtheta_samp, cost);\n\t\treturn false;\n\t}\n\n\t//otherwise, return true\n\treturn true;\n}", "CodeBleu_score": 84.61219902855532}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"The clear_costmap_recovery behavior has not been initialized, please call initialize() before using this behavior\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not set the costmaps in the constructor. Please use the ClearCostmapRecovery::initialize() function.\");\n\t\treturn;\n\t}\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"The ClearCostmapRecovery behavior will clear outside the specified area\");\n\t} else {\n\t\tROS_WARN(\"The ClearCostmapRecovery behavior will clear inside the specified area\");\n\t}\n\n\tif (affected_maps_ & CLEAR_COSTMAP_RECOVERY_LAYER_GLOBAL_COSTMAP) {\n\t\tROS_INFO(\"Clearing the global costmap\");\n\t\tglobal_costmap_->resetLayers();\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->updateMap();\n\t\t}\n\t}\n\n\tif (affected_maps_ & CLEAR_COSTMAP_RECOVERY_LAYER_LOCAL_COSTMAP) {\n\t\tROS_INFO(\"Clearing the local costmap\");\n\t\tlocal_costmap_->resetLayers();\n\t\tif (force_update_) {\n\t\t\tlocal_costmap_->updateMap();\n\t\t}\n\t}\n}", "CodeBleu_score": 39.44651528038614}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not set the global_costmap and local_costmap parameters of the node.\");\n\t\treturn;\n\t}\n\n\tif (invert_area_to_clear_)\n\t\tROS_WARN(\"Clearing outside the area specified by the clearing rectangle.\");\n\telse\n\t\tROS_WARN(\"Clearing inside the area specified by the clearing rectangle.\");\n\n\tros::Time start = ros::Time::now();\n\n\tif (affected_maps_ & CLEAR_COSTMAP_RECOVERY_LAYER_GLOBAL_COSTMAP) {\n\t\tglobal_costmap_->clearArea(clearing_rect_.left, clearing_rect_.top, clearing_rect_.right, clearing_rect_.bottom, invert_area_to_clear_);\n\t\tif (force_updating_when_clearing_)\n\t\t\tglobal_costmap_->updateMap();\n\t}\n\n\tif (affected_maps_ & CLEAR_COSTMAP_RECOVERY_LAYER_LOCAL_COSTMAP) {\n\t\tlocal_costmap_->clearArea(clearing_rect_.left, clearing_rect_.top, clearing_rect_.right, clearing_rect_.bottom, invert_area_to_clear_);\n\t\tif (force_updating_when_clearing_)\n\t\t\tlocal_costmap_->updateMap();\n\t}\n\n\tROS_INFO(\"Clearing area took %f seconds.\", (ros::Time::now() - start).toSec());\n}", "CodeBleu_score": 52.55548769595422}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The global_costmap_ pointer is null, unable to clear the costmap\");\n\t\treturn;\n\t}\n\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local_costmap_ pointer is null, unable to clear the costmap\");\n\t\treturn;\n\t}\n\n\t// check if a new message has arrived\n\ttf::Stamped<tf::Pose> global_pose;\n\tcostmap_ros_->getRobotPose(global_pose);\n\n\tdouble x = global_pose.getOrigin().x();\n\tdouble y = global_pose.getOrigin().y();\n\tdouble yaw = tf::getYaw(global_pose.getRotation());\n\n\tif (x!= last_position_.x || y!= last_position_.y || yaw!= last_position_.yaw) {\n\t\tlast_position_ = tf::Stamped<tf::Pose>(tf::Pose(tf::createQuaternionFromYaw(yaw), tf::Point(x, y, 0.0)), ros::Time::now(), costmap_ros_->getGlobalFrameID());\n\t\tposition_changed_ = true;\n\t}\n\n\tif (position_changed_) {\n\t\tposition_changed_ = false;\n\n\t\t// if we should invert the area to clear, we need to transform the pose of the robot to the local costmap\n\t\tif (invert_area_to_clear_) {\n\t\t\ttf::Stamped<tf::Pose> local_pose;\n\t\t\tif (!costmap_ros_->getRobotPose(local_pose)) {\n\t\t\t\tROS_ERROR(\"Could not get robot pose, unable to clear the costmap\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgeometry_msgs::PoseStamped pose_stamped;\n\t\t\ttf::poseStampedTFToMsg(local_pose, pose_stamped);\n\n\t\t\tif (clear_global_costmap_) {\n\t\t\t\tglobal_costmap_->clearArea(pose_stamped.pose.position.x, pose_stamped.pose.position.y, pose_stamped.pose.position.z, clear_radius_, 0", "CodeBleu_score": 48.94955471158266}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\n\tif (polygon.size() == 0) {\n\t\treturn;\n\t}\n\n\t// Connect the last point to the first\n\tstd::vector<MapLocation> new_polygon = polygon;\n\tnew_polygon.push_back(polygon.front());\n\n\tfor (unsigned int i = 0; i < new_polygon.size() - 1; ++i) {\n\t\tMapLocation p1 = new_polygon[i];\n\t\tMapLocation p2 = new_polygon[i + 1];\n\n\t\t// If the points are the same, don't bother\n\t\tif (p1 == p2) {\n\t\t\tcontinue;\n\t\t}\n\n\t\traytraceLine(p1, p2, polygon_cells);\n\t}\n}", "CodeBleu_score": 47.82012975888688}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\n\tPolygonOutlineCells cells(polygon, size_x_, size_y_);\n\n\tfor (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n\t\traytraceLine(polygon[i], polygon[i + 1], cells);\n\t}\n\n\traytraceLine(polygon[polygon.size() - 1], polygon[0], cells);\n\n\tcells.getCells(polygon_cells);\n}", "CodeBleu_score": 53.020471860755066}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t// Initialize a PolygonOutlineCells object to collect the cells.\n\tPolygonOutlineCells poc(this, polygon_cells);\n\t// The function iterates through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points.\n\tfor (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n\t\traytraceLine(polygon[i], polygon[i + 1], poc);\n\t}\n\t// If the polygon is not empty, it also closes the polygon by connecting the last point to the first.\n\tif (!polygon.empty()) {\n\t\traytraceLine(polygon.back(), polygon.front(), poc);\n\t}\n}", "CodeBleu_score": 50.53933351077692}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tboost::recursive_mutex::scoped_lock lock(lock_);\n\tif (pub.getNumSubscribers() == 1) {\n\t\tprepareGrid();\n\t}\n\tpub.publish(grid_);\n}", "CodeBleu_score": 57.91130915961234}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t// prepare the grid\n\tprepareGrid();\n\t// publish the grid\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.90268748571795}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tboost::recursive_mutex::scoped_lock lock(lock_);\n\tif (costmap_ == NULL) {\n\t\tROS_ERROR(\"Costmap2DPublisher::onNewSubscription: costmap_ is NULL\");\n\t\treturn;\n\t}\n\n\t// prepare the grid data\n\tprepareGrid();\n\n\t// publish the grid\n\tpub.publish(grid_);\n}", "CodeBleu_score": 60.03547348214839}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tfor (unsigned int i = 0; i < grid_.data.size(); i++) {\n\t\tgrid_.data[i] = costmap_2d::NO_INFORMATION;\n\t}\n\tunsigned char* char_map = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < costmap_->getSizeInCellsX(); i++) {\n\t\tfor (unsigned int j = 0; j < costmap_->getSizeInCellsY(); j++) {\n\t\t\tgrid_.data[j * grid_.info.width + i] = costmap_2d::LETHAL_OBSTACLE;\n\t\t}\n\t}\n\tfor (unsigned int i = 0; i < costmap_->getSizeInCellsX(); i++) {\n\t\tfor (unsigned int j = 0; j < costmap_->getSizeInCellsY(); j++) {\n\t\t\tunsigned int index = j * grid_.info.width + i;\n\t\t\tif (char_map[index] == costmap_2d::NO_INFORMATION) {\n\t\t\t\tgrid_.data[index] = costmap_2d::NO_INFORMATION;\n\t\t\t} else if (char_map[", "CodeBleu_score": 68.32407449385727}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tfor (unsigned int i = 0; i < grid_.data.size(); i++) {\n\t\tunsigned char cost = costmap_->getCharMap()[i];\n\t\tif (cost == costmap_2d::NO_INFORMATION) {\n\t\t\tgrid_.data[i] = -1;\n\t\t} else {\n\t\t\tgrid_.data[i] = cost;\n\t\t}\n\t}\n}", "CodeBleu_score": 65.80521591702981}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tcostmap_2d::Costmap2D costmap = *costmap_;\n\tcostmap_2d::Costmap2D costmap_copy = costmap;\n\tcostmap_2d::Costmap2D costmap_copy2 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy3 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy4 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy5 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy6 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy7 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy8 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy9 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy10 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy11 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy12 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy13 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy14 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy15 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy16 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy17 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy18 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy19 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy20 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy21 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy22 = costmap;\n\tcostmap_2d::Costmap2D costmap_copy23 = cost", "CodeBleu_score": 8.853384569048723}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\n\tstd::vector<geometry_msgs::Point> new_footprint;\n\tif (costmap_2d::convertFootprintFromString(new_config.footprint, new_footprint)) {\n\t\tsetUnpaddedRobotFootprint(new_footprint);\n\t} else {\n\t\tROS_ERROR(\"Failed to parse footprint string \\\"%s\\\"\", new_config.footprint.c_str());\n\t}\n\n\tif (new_config.robot_radius!= old_config.robot_radius) {\n\t\tsetRobotRadius(new_config.robot_radius);\n\t}\n}", "CodeBleu_score": 64.04955318972785}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\t// if the footprint or the robot radius changed, we need to re-configure the footprint\n\tif (new_config.footprint!= old_config.footprint || new_config.robot_radius!= old_config.robot_radius) {\n\t\t// first, we'll get the footprint string from the parameter server\n\t\tstd::string footprint_param = new_config.footprint;\n\t\t// we'll also get the radius of the robot\n\t\tdouble footprint_radius = new_config.robot_radius;\n\n\t\t// now we'll actually set the footprint\n\t\tif (footprint_param.size() > 0) {\n\t\t\t// first we'll make sure that the footprint is valid\n\t\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\t\tif (costmap_2d::makeFootprintFromString(footprint_param, footprint)) {\n\t\t\t\t// if we've made it here, we have a valid footprint, so we can set it in the costmap\n\t\t\t\tsetFootprint(footprint);\n\t\t\t\t// and we'll want to re-initialize the costmap because the footprint has changed\n\t\t\t\tresetLayers();\n\t\t\t} else {\n\t\t\t\t// if we've made it here, the footprint string is invalid, so we'll issue a warning and continue with the\n\t\t\t\t// last-known good footprint\n\t\t\t\tROS_WARN(\"The footprint passed in to the costmap2DROS is invalid, \"\n\t\t\t\t\t\t\"we'll use the last valid footprint received\");\n\t\t\t}\n\t\t} else {\n\t\t\t// if no footprint is passed in, we'll use the radius to create a default footprint\n\t\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\t\tcostmap_2d::makeFootprintFromRadius(footprint_radius, footprint);\n\t\t\tsetFootprint(footprint);\n\t\t\tresetLayers();\n\t\t}\n\t}\n}", "CodeBleu_score": 50.17831421982646}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n}", "CodeBleu_score": 4.80081231526899}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// Get the pose of the robot\n\tgeometry_msgs::PoseStamped new_pose;\n\tgeometry_msgs::PoseStamped old_pose;\n\ttf2::toMsg(tf2::Transform::getIdentity(), old_pose.pose);\n\told_pose.header.frame_id = global_frame_;\n\told_pose.header.stamp = ros::Time();\n\n\ttry {\n\t\ttf_->transform(old_pose, new_pose, robot_base_frame_, ros::Duration(0.1));\n\t} catch (tf2::TransformException &ex) {\n\t\tROS_WARN(\"Failed to compute odom pose, skipping scan (%s)\", ex.what());\n\t\treturn;\n\t}\n\n\t// Compute change in pose\n\tdouble yaw = tf2::getYaw(new_pose.pose.orientation);\n\tdouble x = new_pose.pose.position.x;\n\tdouble y = new_pose.pose.position.y;\n\n\tdouble dyaw = angles::shortest_angular_distance(yaw_, yaw);\n\tdouble dx = x - x_;\n\tdouble dy = y - y_;\n\n\t// Check if the robot moved\n\tif (fabs(dx) < 0.01 && fabs(dy) < 0.01 && fabs(dyaw) < 0.01) {\n\t\treturn;\n\t}\n\n\t// Store the pose\n\tx_ = x;\n\ty_ = y;\n\tyaw_ = yaw;\n\n\t// Update the costmap\n\tupdateMap(x, y, yaw);\n}", "CodeBleu_score": 43.590141972557475}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\ttf2::Stamped<tf2::Transform> new_pose;\n\tif (!transformPose(global_frame_, ros::Time(0), new_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to compute new pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\n\t//we also want to check if the new pose has changed in a significant way\n\tdouble yaw = tf2::getYaw(new_pose.getRotation());\n\tdouble x = new_pose.getOrigin().getX();\n\tdouble y = new_pose.getOrigin().getY();\n\tdouble resolution = costmap_->getResolution();\n\n\t//we need to compute the pose in the costmap's coordinate frame (probably the robot's coordinate frame)\n\tdouble new_x = x - origin_x_;\n\tdouble new_y = y - origin_y_;\n\n\t//if the cell that the center of the robot is in has changed... we need to re-subscribe to messages\n\tbool new_cell = costmap_->getCellIndex(new_x, new_y, mx_, my_);\n\n\tif (new_cell ||!ros::isShuttingDown()) {\n\t\t//we need to re-subscribe to two topics\n\t\tsubscribe();\n\t\tlast_valid_pose_ = new_pose;\n\t\tnew_pose_ = true;\n\t}\n\n\t//if we have changed 25% of the costmap in size, we need to re-subscribe to messages\n\tint new_size_x, new_size_y;\n\tcostmap_->getSize(new_size_x, new_size_y);\n\tif (abs(new_size_x - size_x_) > size_x_ / 4 || abs(new_size_y - size_y_) > size_y_ / 4) {\n\t\tsubscribe();\n\t\tlast_valid_pose_ = new_pose;\n\t\tnew_pose_ = true;\n\t}\n\n\t//we also want to check if the orientation has changed in a significant way\n\tif (!initialized_) {\n\t\tlast_valid_pose_ = new_pose;\n\t\tnew_pose_ = true;\n\t}\n\n\t//we also want to check if the resolution has changed\n\tif (resolution!= resolution_)", "CodeBleu_score": 43.97534278052774}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tgeometry_msgs::PoseStamped new_pose;\n\tgeometry_msgs::PoseStamped old_pose;\n\tnew_pose.header.frame_id = global_frame_;\n\tnew_pose.header.stamp = ros::Time::now();\n\n\t//we can't do anything like check if the pose has changed and skip updating if it hasn't\n\t//because someone could change the pose in a client while we're handling a ros call\n\t//request from map or costmap\n\ttf_->transform(new_pose, old_pose, global_frame_);\n\n\t// if we've moved more than a tolerance, update the costmap\n\tif (old_pose.header.stamp!= last_pose_.header.stamp &&\n\t\t(old_pose.pose.position.x!= last_pose_.pose.position.x ||\n\t\told_pose.pose.position.y!= last_pose_.pose.position.y ||\n\t\told_pose.pose.orientation.z!= last_pose_.pose.orientation.z ||\n\t\told_pose.pose.orientation.w!= last_pose_.pose.orientation.w)) {\n\t\tlast_pose_ = old_pose;\n\t\t// update the old pose time\n\t\tlast_pose_.header.stamp = new_pose.header.stamp;\n\t\t// store the pose sent to the costmap\n\t\tcostmap_->setRobotPose(old_pose);\n\n\t\t// if we're stopped we won't update the costmap because the robot isn't moving\n\t\tif (stopped_) {\n\t\t\treturn;\n\t\t}\n\n\t\t// if we're stopped we won't update the costmap because the robot isn't moving\n\t\tif (stopped_) {\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have a rolling window, we need to do a full update\n\t\tif (rolling_window_) {\n\t\t\t// we need to compute our x and y bounds based on our robot's location\n\t\t\tdouble new_x = old_pose.pose.position.x;\n\t\t\tdouble new_y = old_pose.pose.position.y;\n\t\t\tdouble new_yaw = tf2::getYaw(old_pose.pose.orientation);\n\n\t\t\t// if we haven't initialized our bounds yet, do so now\n\t\t\tif (!initialized_) {\n\t\t\t\tx_ = new_x;\n\t\t\t\t", "CodeBleu_score": 40.691833984770284}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\tfor (unsigned int i = 0; i < plugins_.size(); i++) {\n\t\t\tplugins_[i]->activate();\n\t\t}\n\t\tstopped_ = false;\n\t}\n\n\tstop_updates_ = false;\n\n\twhile (ros::ok() &&!layered_costmap_->isSizeLocked() &&!layered_costmap_->isInitialized()) {\n\t\tROS_INFO(\"Waiting for costmap to be ready...\");\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\twhile (ros::ok() &&!layered_costmap_->isMapUpdated()) {\n\t\tROS_INFO(\"Waiting for costmap to update map...\");\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\tROS_INFO(\"Costmap initialization complete\");\n}", "CodeBleu_score": 44.48525539318725}, {"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\t// re-subscribe to topics\n\t\tfor (unsigned int i = 0; i < plugins_.size(); i++) {\n\t\t\tif (plugins_[i]->isStopped()) {\n\t\t\t\tplugins_[i]->activate();\n\t\t\t}\n\t\t}\n\t\tstopped_ = false;\n\t}\n\n\tstop_updates_ = false;\n\n\t// wait for costmap to be ready\n\tros::Rate r(100.0);\n\twhile (!layered_costmap_->isSizeLocked() && ros::ok()) {\n\t\tROS_DEBUG(\"Waiting for costmap to be ready...\");\n\t\tr.sleep();\n\t}\n\n\t// wait for map updates to occur\n\twhile (layered_costmap_->isInitialized() && ros::ok() &&!layered_costmap_->isRolling()) {\n\t\tROS_DEBUG(\"Waiting for map updates to occur...\");\n\t\tr.sleep();\n\t}\n}", "CodeBleu_score": 51.37777999005391}, {"code": "void Costmap2DROS::start(){\n\t\tif (!stopped_) {\n\t\treturn;\n\t}\n\tstd::vector<boost::shared_ptr<Layer> > *plugins = layered_costmap_->getPlugins();\n\tfor (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin!= plugins->end(); ++plugin) {\n\t\t(*plugin)->activate();\n\t}\n\tstopped_ = false;\n\tstop_updates_ = false;\n\twhile (!ros::ok() ||!layered_costmap_->isInitialized() ||!map_update_thread_) {\n\t\tif (!ros::ok()) {\n\t\t\tROS_ERROR(\"Costmap2DROS is not running. Did you call ros::init?\");\n\t\t}\n\t\tif (!layered_costmap_->isInitialized()) {\n\t\t\tROS_ERROR(\"Costmap2DROS is not running. Did you call loadMap?\");\n\t\t}\n\t\tif (!map_update_thread_) {\n\t\t\tROS_ERROR(\"Costmap2DROS is not running. Did you call startLayeredCostmap?\");\n\t\t}\n\t\tros::Duration(0.1).sleep();\n\t}\n}", "CodeBleu_score": 59.2201949458798}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == 0.0) {\n\t\tobservation_list_.clear();\n\t\treturn;\n\t}\n\n\tros::Time current_time = ros::Time::now();\n\tstd::list<Observation>::iterator it = observation_list_.begin();\n\twhile (it!= observation_list_.end()) {\n\t\tif (current_time - it->observation.header.stamp > ros::Duration(observation_keep_time_)) {\n\t\t\tit = observation_list_.erase(it);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.90699468059318}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == 0.0) {\n\t\tobservation_list_.clear();\n\t\treturn;\n\t}\n\n\t// Iterate through the list and remove observations that are older than the specified keep time, stopping once it finds a valid observation\n\tfor (ObservationList::iterator it = observation_list_.begin(); it!= observation_list_.end();) {\n\t\tif (ros::Time::now() - it->observation->header.stamp > ros::Duration(observation_keep_time_)) {\n\t\t\tit = observation_list_.erase(it);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 32.51771738422518}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == 0.0) {\n\t\t// Keep only the most recent observation\n\t\tobservation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n\t} else {\n\t\t// Remove observations older than the specified keep time\n\t\tauto it = observation_list_.begin();\n\t\twhile (it!= observation_list_.end() && ros::Time::now() - it->observation_time >= ros::Duration(observation_keep_time_)) {\n\t\t\tit = observation_list_.erase(it);\n\t\t}\n\t}\n}", "CodeBleu_score": 33.64550065011389}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Calculate the yaw angles at the start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Determine the shortest angular distance between the start and end yaw angles\n\tdouble diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose\n\tdouble increment = diff / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tdouble angle = start_yaw;\n\tfor (int i = start_index; i < end_index; i++) {\n\t\t// Calculate the new orientation\n\t\tgeometry_msgs::Quaternion new_orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), angle));\n\n\t\t// Update the pose's orientation\n\t\tpath[i].pose.orientation = new_orientation;\n\n\t\t// Increment the angle\n\t\tangle += increment;\n\t}\n}", "CodeBleu_score": 65.88353194818963}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// calculate the yaw angle at the start index\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\t// calculate the yaw angle at the end index\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\t// calculate the shortest angular distance between the start and end yaw angles\n\tdouble angle_diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\t// calculate the incremental change in angle for each pose\n\tdouble angle_inc = angle_diff / (end_index - start_index);\n\t// update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\t// calculate the current yaw angle\n\t\tdouble current_yaw = start_yaw + angle_inc * (i - start_index);\n\t\t// create a quaternion from the current yaw angle\n\t\ttf2::Quaternion q;\n\t\tq.setRPY(0, 0, current_yaw);\n\t\t// update the orientation of the current pose\n\t\tpath[i].pose.orientation.x = q.x();\n\t\tpath[i].pose.orientation.y = q.y();\n\t\tpath[i].pose.orientation.z = q.z();\n\t\tpath[i].pose.orientation.w = q.w();\n\t}\n}", "CodeBleu_score": 60.079669109095654}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Check if the path is empty\n\tif (path.empty()) {\n\t\treturn;\n\t}\n\n\t// Get the orientation of the first pose in the path\n\ttf2::Quaternion start_orientation;\n\ttf2::fromMsg(path[start_index].pose.orientation, start_orientation);\n\tdouble start_yaw = tf2::getYaw(start_orientation);\n\n\t// Get the orientation of the last pose in the path\n\ttf2::Quaternion end_orientation;\n\ttf2::fromMsg(path[end_index].pose.orientation, end_orientation);\n\tdouble end_yaw = tf2::getYaw(end_orientation);\n\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Calculate the incremental change in angle for each pose in the range\n\tdouble delta_angle = delta_yaw / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\t// Calculate the new yaw angle for the current pose\n\t\tdouble new_yaw = start_yaw + delta_angle * (i - start_index);\n\n\t\t// Update the orientation of the current pose\n\t\ttf2::Quaternion new_orientation;\n\t\tnew_orientation.setRPY(0, 0, new_yaw);\n\t\tpath[i].pose.orientation = tf2::toMsg(new_orientation);\n\t}\n}", "CodeBleu_score": 52.390281879090416}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tif (makePlan(req.start, req.goal, req.tolerance, resp.plan)) {\n\t\tresp.code = resp.PATH_FOUND;\n\t\treturn true;\n\t}\n\n\tresp.code = resp.NO_PATH_FOUND;\n\treturn true;\n}", "CodeBleu_score": 29.028143250078784}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tgeometry_msgs::PoseStamped start;\n\tgeometry_msgs::PoseStamped goal;\n\n\tstart.header.stamp = ros::Time::now();\n\tstart.header.frame_id = costmap_->getGlobalFrameID();\n\tstart.pose = req.start;\n\n\tgoal.header.stamp = ros::Time::now();\n\tgoal.header.frame_id = costmap_->getGlobalFrameID();\n\tgoal.pose = req.goal;\n\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tbool result = makePlan(start, goal, plan);\n\tresp.plan.poses.clear();\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.plan.header.frame_id = costmap_->getGlobalFrameID();\n\tfor (unsigned int i = 0; i < plan.size(); ++i) {\n\t\tresp.plan.poses.push_back(plan[i]);\n\t}\n\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.plan.header.frame_id = costmap_->getGlobalFrameID();\n\tresp.success = result;\n\treturn true;\n}", "CodeBleu_score": 42.29263870141657}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tgeometry_msgs::PoseStamped start;\n\tgeometry_msgs::PoseStamped goal;\n\n\tstart = req.start;\n\tgoal = req.goal;\n\n\tstart.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tgoal.header.frame_id = costmap_ros_->getGlobalFrameID();\n\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tbool result = makePlan(start, goal, plan);\n\tresp.plan.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tresp.plan.header.stamp = ros::Time::now();\n\n\t//copy the plan into the response\n\tfor (unsigned int i = 0; i < plan.size(); i++) {\n\t\tresp.plan.poses.push_back(plan[i]);\n\t}\n\n\tif (result) {\n\t\tresp.code = navfn::MakeNavPlan::Response::OK;\n\t} else {\n\t\tresp.code = navfn::MakeNavPlan::Response::NO_PATH;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 43.08098881154551}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tcostmap_ros_ = cmap;\n\tinitialize(name, cmap->getLayeredCostmap()->getCostmap());\n}", "CodeBleu_score": 23.351358386320868}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\t//ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n    ros::NodeHandle private_nh(\"~/\" + name);\n    plan_pub_ = private_nh.advertise<nav_msgs::Path>(\"plan\", 1);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, boost::bind(&PlannerWithCostmap::goalCB, this, _1));\n    tf_ = new tf2_ros::Buffer();\n    tf_listener_ = new tf2_ros::TransformListener(*tf_);\n}", "CodeBleu_score": 59.33512597591134}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, boost::bind(&PlannerWithCostmap::goalCB, this, _1));\n    plan_pub_ = private_nh.advertise<nav_msgs::Path>(\"plan\", 1);\n    initialized_ = true;\n    costmap_ros_ = cmap;\n}", "CodeBleu_score": 63.158887601886484}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tunsigned int x, y;\n\tif (costmap_->worldToMap(wx, wy, x, y)) {\n\t\tmx = x;\n\t\tmy = y;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 23.4097922337139}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\tdouble resolution = costmap_->getResolution();\n\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 83.87997991772444}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\tdouble resolution = costmap_->getResolution();\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 83.87997991772444}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.52659093292189}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.52659093292189}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.52659093292189}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message and re-publishing to the server.\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 93.84205889100247}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID goal_id;\n\tgoal_id.stamp = ros::Time::now();\n\tgoal_id.id = \"\";\n\tMoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = goal_id.stamp;\n\taction_goal.goal_id = goal_id;\n\taction_goal.goal.target_pose = *goal;\n\tROS_DEBUG_NAMED(\"move_base\", \"Wrapping goal in action message\");\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 64.55789924317719}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID goal_id;\n\tgoal_id.stamp = ros::Time::now();\n\tgoal_id.id = boost::lexical_cast<std::string>(goal_id.stamp.toSec()) + boost::lexical_cast<std::string>(goal_id.stamp.nsec());\n\n\tMoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal_id = goal_id;\n\taction_goal.goal.target_pose = *goal;\n\n\tROS_DEBUG_NAMED(\"move_base\",\"Going to pose (%.2f, %.2f) and angle (%.2f) based on plan\", goal->pose.position.x, goal->pose.position.y, tf2::getYaw(goal->pose.orientation));\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 59.73578555487231}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\t// Check if the robot has moved far enough\n\tif (pow(robot_pose.x - robot_pose_old.x, 2) + pow(robot_pose.y - robot_pose_old.y, 2) > pow(limited_distance, 2)) {\n\t\t// Log a message\n\t\tROS_INFO(\"The robot has moved far enough to remove the speed limit.\");\n\n\t\t// Join and delete any existing remove limit thread\n\t\tif (remove_limit_thread!= NULL) {\n\t\t\tremove_limit_thread->join();\n\t\t\tdelete remove_limit_thread;\n\t\t}\n\n\t\t// Start a new thread to remove the speed limit\n\t\tremove_limit_thread = new boost::thread(&MoveSlowAndClear::removeLimit, this);\n\n\t\t// Stop the distance check timer\n\t\tdistance_check_timer.stop();\n\t}\n}", "CodeBleu_score": 48.45107353043947}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (currentDistanceSquared > limitedDistanceSquared) {\n\t\tROS_INFO(\"MoveSlowAndClear: Robot has moved far enough. Removing speed limit.\");\n\t\tif (removeLimitThread!= NULL) {\n\t\t\tremoveLimitThread->join();\n\t\t\tdelete removeLimitThread;\n\t\t}\n\t\tremoveLimitThread = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\tdistanceCheckTimer.stop();\n\t}\n}", "CodeBleu_score": 43.47224698280579}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble distance = sqrt(pow(x_ - x_prev_, 2) + pow(y_ - y_prev_, 2));\n\tif (distance > dist_lim_sq_) {\n\t\tROS_INFO(\"Robot has moved far enough.\");\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 57.23663937873963}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\ttf2_ros::Buffer tfBuffer;\n\ttf2_ros::TransformListener tf(tfBuffer);\n\tgeometry_msgs::TransformStamped transformStamped;\n\ttry {\n\t\ttransformStamped = tfBuffer.lookupTransform(\"map\", \"base_link\", ros::Time(0), ros::Duration(1.0));\n\t} catch (tf2::TransformException &ex) {\n\t\tROS_WARN(\"%s\", ex.what());\n\t\tros::Duration(1.0).sleep();\n\t}\n\trm::PoseStamped goal_transformed;\n\tgoal_transformed.pose.position.x = goal->pose.position.x + transformStamped.transform.translation.x;\n\tgoal_transformed.pose.position.y = goal->pose.position.y + transformStamped.transform.translation.y;\n\tgoal_transformed.pose.orientation.z = goal->pose.orientation.z + transformStamped.transform.rotation.z;\n\tgoal_transformed.pose.orientation.w = goal->pose.orientation.w + transformStamped.transform.rotation.w;\n\n\tROS_INFO(\"Received goal pose: x: %.2f, y: %.2f\", goal_transformed.pose.position.x, goal_transformed.pose.position.y);\n\n\trm::PoseStamped global_pose;\n\tif (!costmap_ros_->getRobotPose(global_pose)) {\n\t\tROS_WARN(\"Unable to get starting pose of robot, unable to create global plan\");\n\t\treturn;\n\t}\n\n\tstd::vector<rm::PoseStamped> plan;\n\tif (planner_->makePlan(global_pose, goal_transformed, plan) == true) {\n\t\tROS_INFO(\"Got plan with %d points!\", (int)plan.size());\n\t\t//publish the plan\n\t\trm::Path gui_path;\n\t\tgui_path.poses.resize(plan.size());\n\t\tgui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n\t\tgui_path.header.stamp = ros::Time::now();\n\n\t\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\t\tfor (unsigned int i = 0; i < plan.size(); i++) {\n\t\t\t", "CodeBleu_score": 37.222591155147086}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\ttf2_ros::Buffer tfBuffer;\n\ttf2_ros::TransformListener tfListener(tfBuffer);\n\tgeometry_msgs::TransformStamped transformStamped;\n\ttry {\n\t\ttransformStamped = tfBuffer.lookupTransform(\"odom\", \"base_link\", ros::Time(0));\n\t} catch (tf2::TransformException &ex) {\n\t\tROS_WARN(\"%s\", ex.what());\n\t\tros::Duration(1.0).sleep();\n\t\treturn;\n\t}\n\t//ROS_INFO(\"Transform: %f %f %f %f %f %f %f\", transformStamped.transform.translation.x, transformStamped.transform.translation.y, transformStamped.transform.translation.z, transformStamped.transform.rotation.x, transformStamped.transform.rotation.y, transformStamped.transform.rotation.z, transformStamped.transform.rotation.w);\n\ttf2::Quaternion q(transformStamped.transform.rotation.x, transformStamped.transform.rotation.y, transformStamped.transform.rotation.z, transformStamped.transform.rotation.w);\n\ttf2::Matrix3x3 m(q);\n\tdouble roll, pitch, yaw;\n\tm.getRPY(roll, pitch, yaw);\n\t//ROS_INFO(\"RPY: %f %f %f\", roll, pitch, yaw);\n\trm::PoseStamped robotPose;\n\trobotPose.header.frame_id = \"odom\";\n\trobotPose.pose.position.x = transformStamped.transform.translation.x;\n\trobotPose.pose.position.y = transformStamped.transform.translation.y;\n\trobotPose.pose.position.z = transformStamped.transform.translation.z;\n\trobotPose.pose.orientation.x = transformStamped.transform.rotation.x;\n\trobotPose.pose.orientation.y = transformStamped.transform.rotation.y;\n\trobotPose.pose.orientation.z = transformStamped.transform.rotation.z;\n\trobotPose.pose.orientation.w = transformStamped.transform.rotation.w;\n\t//ROS_INFO(\"Robot pose: %f %f %f %f %f %f %f\", robotPose", "CodeBleu_score": 38.09866802053909}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Pose Callback\");\n\ttf2_ros::Buffer tfBuffer;\n\ttf2_ros::TransformListener tf(tfBuffer);\n\tgeometry_msgs::TransformStamped transformStamped;\n\ttry {\n\t\ttransformStamped = tfBuffer.lookupTransform(\"map\", \"base_link\", ros::Time(0));\n\t} catch (tf2::TransformException &ex) {\n\t\tROS_WARN(\"%s\", ex.what());\n\t\tros::Duration(1.0).sleep();\n\t}\n\tROS_INFO(\"Pose Callback 2\");\n\ttf2::Transform transform;\n\ttf2::fromMsg(transformStamped.transform, transform);\n\ttf2::Vector3 translation = transform.getOrigin();\n\ttf2::Quaternion quaternion = transform.getRotation();\n\ttf2::Matrix3x3 m(quaternion);\n\tdouble roll, pitch, yaw;\n\tm.getRPY(roll, pitch, yaw);\n\tROS_INFO(\"Pose Callback 3\");\n\trm::PoseStamped pose;\n\tpose.header.frame_id = \"map\";\n\tpose.pose.position.x = translation.getX();\n\tpose.pose.position.y = translation.getY();\n\tpose.pose.position.z = translation.getZ();\n\tpose.pose.orientation.x = quaternion.getX();\n\tpose.pose.orientation.y = quaternion.getY();\n\tpose.pose.orientation.z = quaternion.getZ();\n\tpose.pose.orientation.w = quaternion.getW();\n\tROS_INFO(\"Pose Callback 4\");\n\tstd::vector<rm::PoseStamped> plan;\n\tROS_INFO(\"Pose Callback 5\");\n\tbool success = makePlan(pose, *goal, plan);\n\tROS_INFO(\"Pose Callback 6\");\n\tif (success) {\n\t\tROS_INFO(\"Pose Callback 7\");\n\t\tROS_INFO(\"Got plan\");\n\t\trm::Path path;\n\t\tpath.poses = plan;\n\t\tpath.header.frame_id = \"map\";\n\t\tpath.header.stamp = ros::Time::now();\n\t\tROS_INFO(\"Pose Callback 8\");\n\t\tpathPublisher.publish(path);\n\t\tROS_INFO(\"Pose Callback 9\");\n\t}\n", "CodeBleu_score": 44.41529177219639}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tparam_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 58.7743208729043}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create ParamSet service request\n\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\n\t// Call param_set_client_\n\tparam_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 58.867051428695675}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create the request\n\tmavros_msgs::ParamSet gimbal_param_set_request;\n\tgimbal_param_set_request.request.param_id = param_set.param_id;\n\tgimbal_param_set_request.request.value = param_set.value;\n\n\t// Call the service\n\tparam_set_client_.call(gimbal_param_set_request);\n}", "CodeBleu_score": 54.65371587149653}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\tboost::shared_mutex mutex;\n\tboost::mutex mutex2;\n\tboost::asio::io_service io_service;\n\tboost::asio::ip::tcp::acceptor acceptor(io_service, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 5000));\n\tboost::asio::ip::tcp::socket socket(io_service);\n\tboost::asio::streambuf buf;\n\tboost::asio::streambuf::mutable_buffers_type bufs = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs2 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs3 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs4 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs5 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs6 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs7 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs8 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs9 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs10 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs11 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs12 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs13 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs14 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs15 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs16 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs17 = buf.data();\n\tboost::asio::streambuf::mutable_buffers_type bufs18 = buf.data();\n\tboost::asio::", "CodeBleu_score": 11.07677306804257}, {"code": "void CommunicationBridge::serverFun(){\n\t\t// Create a TCP socket\n\tint sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (sock == -1) {\n\t\tROS_ERROR(\"Failed to create socket\");\n\t\treturn;\n\t}\n\n\t// Bind the socket to port 5000\n\tsockaddr_in addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = INADDR_ANY;\n\taddr.sin_port = htons(5000);\n\n\tif (bind(sock, (const sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tROS_ERROR(\"Failed to bind socket\");\n\t\tclose(sock);\n\t\treturn;\n\t}\n\n\t// Listen for incoming connections\n\tif (listen(sock, 10) == -1) {\n\t\tROS_ERROR(\"Failed to listen on socket\");\n\t\tclose(sock);\n\t\treturn;\n\t}\n\n\t// Accept incoming connections\n\tsockaddr_in clientAddr;\n\tsocklen_t clientAddrLen = sizeof(clientAddr);\n\tint clientSock;\n\twhile (ros::ok()) {\n\t\tclientSock = accept(sock, (sockaddr *)&clientAddr, &clientAddrLen);\n\t\tif (clientSock == -1) {\n\t\t\tROS_ERROR(\"Failed to accept connection\");\n\t\t\tclose(sock);\n\t\t\treturn;\n\t\t}\n\n\t\t// Receive data\n\t\tuint8_t buf[1024];\n\t\tint bytesReceived = recv(clientSock, buf, sizeof(buf), 0);\n\t\tif (bytesReceived <= 0) {\n\t\t\tROS_ERROR(\"Failed to receive data\");\n\t\t\tclose(clientSock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Process the received data\n\t\tmavlink_message_t msg;\n\t\tmavlink_status_t status;\n\t\tfor (int i = 0; i < bytesReceived; i++) {\n\t\t\tif (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status)) {\n\t\t\t\t// Decode the message\n\t\t\t\tmavlink_msg_decode(&msg, &status);\n\n\t\t\t\t// Publish the decoded message\n\t\t\t\tswitch (msg.", "CodeBleu_score": 42.97843028026989}, {"code": "void CommunicationBridge::serverFun(){\n\t\tint sockfd, newsockfd, portno;\n\tsocklen_t clilen;\n\tstruct sockaddr_in serv_addr, cli_addr;\n\tint n;\n\tchar buffer[256];\n\n\tsockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sockfd < 0) {\n\t\tROS_ERROR(\"ERROR opening socket\");\n\t\treturn;\n\t}\n\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tportno = 5000;\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(portno);\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tROS_ERROR(\"ERROR on binding\");\n\t\treturn;\n\t}\n\tlisten(sockfd, 5);\n\tclilen = sizeof(cli_addr);\n\n\twhile (1) {\n\t\tnewsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\t\tif (newsockfd < 0) {\n\t\t\tROS_ERROR(\"ERROR on accept\");\n\t\t\treturn;\n\t\t}\n\t\tbzero(buffer, 256);\n\t\tn = read(newsockfd, buffer, 255);\n\t\tif (n < 0) {\n\t\t\tROS_ERROR(\"ERROR reading from socket\");\n\t\t\treturn;\n\t\t}\n\t\tif (n <= 0) {\n\t\t\tROS_ERROR(\"ERROR reading from socket\");\n\t\t\treturn;\n\t\t}\n\t\tstd::string data = std::string(buffer);\n\t\t//ROS_INFO(\"Here is the message: %s\", buffer);\n\t\t//ROS_INFO(\"Length of the message: %d\", n);\n\t\t//ROS_INFO(\"Here is the message: %s\", data.c_str());\n\t\t//ROS_INFO(\"Length of the message: %d\", data.length());\n\t\tdecodeMessage(data);\n\t\tclose(newsockfd);\n\t}\n\tclose(sockfd);\n}", "CodeBleu_score": 44.538771651171935}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (simulation_mode_) {\n\t\tboost::shared_lock<boost::shared_mutex> lock(swarm_control_simulation_mutex_);\n\t\tauto it = swarm_control_simulation_.find(uav_cmd.id);\n\t\tif (it!= swarm_control_simulation_.end()) {\n\t\t\tit->second->recvData(uav_cmd);\n\t\t}\n\t} else {\n\t\tuav_basic_->recvData(uav_cmd);\n\t}\n}", "CodeBleu_score": 38.25399903551461}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\t// If not in simulation mode, publish to a single UAV.\n\tif (!simulation_mode_) {\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n\t// In simulation mode, publish to the corresponding UAV.\n\telse {\n\t\t// Find the UAV by ID.\n\t\tstd::map<int, UAVBasic>::iterator it;\n\t\tit = swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= swarm_control_simulation_.end()) {\n\t\t\t// Publish the command to the UAV.\n\t\t\tit->second.publish(uav_cmd);\n\t\t}\n\t\telse {\n\t\t\tROS_ERROR(\"UAV ID %d not found in swarm_control_simulation_.\", uav_cmd.uav_id);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.28931839340536}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\t// If we are not in simulation mode, publish the command to a single UAV\n\tif (!simulation_mode_) {\n\t\t// Publish the command to the single UAV\n\t\tuav_basic_.publishCommand(uav_cmd);\n\t} else {\n\t\t// Find the corresponding UAV by ID from swarm_control_simulation_ and publish the command to the matching UAV\n\t\tboost::shared_lock<boost::shared_mutex> lock(swarm_control_simulation_mutex_);\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (uav_cmd.uav_id == swarm_control_simulation_[i].uav_id) {\n\t\t\t\t// Publish the command to the matching UAV\n\t\t\t\tswarm_control_simulation_[i].publishCommand(uav_cmd);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.643263112741785}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == 0) {\n\t\t// Mode is not selected, so no action is taken.\n\t\treturn;\n\t} else if (mode_selection.use_mode == 1) {\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == 2) {\n\t\t// Mode is not selected, so delete it.\n\t\tdeleteMode(mode_selection);\n\t} else if (mode_selection.use_mode == 3) {\n\t\t// Mode is selected, so delete it.\n\t\tdeleteMode(mode_selection);\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == 4) {\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t\t// Mode is not selected, so delete it.\n\t\tdeleteMode(mode_selection);\n\t} else if (mode_selection.use_mode == 5) {\n\t\t// Mode is not selected, so delete it.\n\t\tdeleteMode(mode_selection);\n\t\t// Mode is not selected, so delete it.\n\t\tdeleteMode(mode_selection);\n\t} else if (mode_selection.use_mode == 6) {\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == 7) {\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == 8) {\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t\t// Mode is selected, so create it.\n\t\tcreateMode(mode_selection);\n\t\t// Mode is selected, so create it.", "CodeBleu_score": 54.91254986488637}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\t//if (mode_selection.use_mode == ModeSelection::REBOOTNX) {\n\t//\tsystem(\"reboot\");\n\t//} else if (mode_selection.use_mode == ModeSelection::EXITNX) {\n\t//\tsystem(\"shutdown -h now\");\n\t//} else {\n\t//\tif (mode_selection.use_mode == ModeSelection::CREATE) {\n\t//\t\tcreateMode(mode_selection.mode_name);\n\t//\t} else if (mode_selection.use_mode == ModeSelection::DELETE) {\n\t//\t\tdeleteMode(mode_selection.mode_name);\n\t//\t}\n\t//}\n}", "CodeBleu_score": 4.650810043155036}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\t// Execute system commands for REBOOTNX and EXITNX modes\n\tif (mode_selection.mode == ModeSelection::REBOOTNX) {\n\t\tsystem(\"sudo reboot\");\n\t} else if (mode_selection.mode == ModeSelection::EXITNX) {\n\t\tsystem(\"sudo shutdown -h now\");\n\t}\n\n\t// Create or delete mode\n\tif (mode_selection.use_mode) {\n\t\tcreateMode(mode_selection.mode);\n\t} else {\n\t\tdeleteMode(mode_selection.mode);\n\t}\n}", "CodeBleu_score": 45.700177526560395}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tboost::unique_lock<boost::mutex> heartbeat_lock(heartbeat_mutex);\n\tif (heartbeat_count == last_heartbeat_count) {\n\t\tROS_ERROR(\"Heartbeat not received. Check network connection.\");\n\t\tif (vehicle_type == \"swarm\") {\n\t\t\tROS_ERROR(\"Swarm will now shut down.\");\n\t\t\tdisconnect_flag = true;\n\t\t} else if (vehicle_type == \"uav\") {\n\t\t\tROS_ERROR(\"UAV will now land.\");\n\t\t\tuav_land_flag = true;\n\t\t} else if (vehicle_type == \"ugv\") {\n\t\t\tROS_ERROR(\"UGV will now stop.\");\n\t\t\tugv_stop_flag = true;\n\t\t}\n\t} else {\n\t\tlast_heartbeat_count = heartbeat_count;\n\t}\n}", "CodeBleu_score": 29.91271508915288}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tboost::shared_lock<boost::shared_mutex> read_lock(heartbeat_mutex_);\n\tif (heartbeat_count_ == prev_heartbeat_count_) {\n\t\tif (heartbeat_count_ == 0) {\n\t\t\tROS_ERROR(\"Heartbeat not received from %s\", heartbeat_source_.c_str());\n\t\t}\n\t\telse {\n\t\t\tROS_ERROR(\"Heartbeat not received from %s. Missed %d heartbeats\", heartbeat_source_.c_str(), heartbeat_count_);\n\t\t}\n\n\t\tif (vehicle_type_ == \"swarm\") {\n\t\t\tROS_ERROR(\"Swarm communication is down. Shutting down.\");\n\t\t\tros::shutdown();\n\t\t}\n\t\telse if (vehicle_type_ == \"UAV\") {\n\t\t\tROS_ERROR(\"UAV communication is down. Shutting down.\");\n\t\t\tros::shutdown();\n\t\t}\n\t\telse if (vehicle_type_ == \"UGV\") {\n\t\t\tROS_ERROR(\"UGV communication is down. Shutting down.\");\n\t\t\tros::shutdown();\n\t\t}\n\t}\n\telse {\n\t\tprev_heartbeat_count_ = heartbeat_count_;\n\t}\n}", "CodeBleu_score": 34.7789061894887}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tboost::shared_lock<boost::shared_mutex> lock(heartbeat_mutex_);\n\tif (heartbeat_count_ == last_heartbeat_count_) {\n\t\tif (heartbeat_count_ == 0) {\n\t\t\tROS_ERROR(\"No heartbeat detected from vehicle %d\", vehicle_id_);\n\t\t\tif (vehicle_type_ == VehicleType::UAV) {\n\t\t\t\tROS_ERROR(\"No heartbeat detected from UAV %d\", vehicle_id_);\n\t\t\t\tROS_ERROR(\"Waiting for heartbeat from UAV %d\", vehicle_id_);\n\t\t\t} else if (vehicle_type_ == VehicleType::UGV) {\n\t\t\t\tROS_ERROR(\"No heartbeat detected from UGV %d\", vehicle_id_);\n\t\t\t\tROS_ERROR(\"Waiting for heartbeat from UGV %d\", vehicle_id_);\n\t\t\t} else if (vehicle_type_ == VehicleType::SWARM) {\n\t\t\t\tROS_ERROR(\"No heartbeat detected from swarm %d\", vehicle_id_);\n\t\t\t\tROS_ERROR(\"Waiting for heartbeat from swarm %d\", vehicle_id_);\n\t\t\t}\n\t\t\tROS_ERROR(\"Waiting for heartbeat from vehicle %d\", vehicle_id_);\n\t\t\tROS_ERROR(\"Waiting for heartbeat from vehicle %d\", vehicle_id_);\n\t\t} else {\n\t\t\tROS_ERROR(\"No heartbeat detected from vehicle %d\", vehicle_id_);\n\t\t\tif (vehicle_type_ == VehicleType::UAV) {\n\t\t\t\tROS_ERROR(\"No heartbeat detected from UAV %d\", vehicle_id_);\n\t\t\t\tROS_ERROR(\"Waiting for heartbeat from UAV %d\", vehicle_id_);\n\t\t\t} else if (vehicle_type_ == VehicleType::UGV) {\n\t\t\t\tROS_ERROR(\"No heartbeat detected from UGV %d\", vehicle_id_);\n\t\t\t\tROS_ERROR(\"Waiting for heartbeat from UGV %d\", vehicle_id_);\n\t\t\t} else if (vehicle_type_ == VehicleType::SWARM) {\n\t\t\t\tROS_ERROR(\"No heartbeat detected from swarm %d\", vehicle_id_);\n\t\t\t\tROS_ERROR(\"Waiting for heartbeat from swarm %d\", vehicle_id_);\n\t\t\t}\n\t\t\tROS_ERROR(\"Waiting for heartbeat from vehicle %d\", vehicle_id_);\n\t\t\tROS_ERROR(\"Waiting for heartbeat from vehicle %d\", vehicle_id_);\n\t\t}\n\t\tdisconnect_flag_ = true;\n", "CodeBleu_score": 27.59928237524501}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb\");\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->id = \" << msg->id);\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->num_bspline = \" << msg->num_bspline);\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->header.stamp.sec = \" << msg->header.stamp.sec);\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->header.stamp.nsec = \" << msg->header.stamp.nsec);\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->header.frame_id = \" << msg->header.frame_id);\n\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->bspline_data[0].id = \" << msg->bspline_data[0].id);\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->bspline_data[0].knots = \" << msg->bspline_data[0].knots);\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->bspline_data[0].pos_x = \" << msg->bspline_data[0].pos_x);\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->bspline_data[0].pos_y = \" << msg->bspline_data[0].pos_y);\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->bspline_data[0].pos_z = \" << msg->bspline_data[0].pos_z);\n\t//ROS_INFO_STREAM(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->bspline_data[0].yaw = \" << msg->bspline_data[0].yaw", "CodeBleu_score": 1.255320246319541}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb\");\n\t//ROS_INFO_STREAM(\"msg->header.frame_id: \" << msg->header.frame_id);\n\t//ROS_INFO_STREAM(\"msg->header.stamp: \" << msg->header.stamp);\n\t//ROS_INFO_STREAM(\"msg->header.seq: \" << msg->header.seq);\n\t//ROS_INFO_STREAM(\"msg->id: \" << msg->id);\n\t//ROS_INFO_STREAM(\"msg->bspline.size(): \" << msg->bspline.size());\n\n\t//ROS_INFO_STREAM(\"msg->bspline[0].id: \" << msg->bspline[0].id);\n\t//ROS_INFO_STREAM(\"msg->bspline[0].knots.size(): \" << msg->bspline[0].knots.size());\n\t//ROS_INFO_STREAM(\"msg->bspline[0].pos.size(): \" << msg->bspline[0].pos.size());\n\t//ROS_INFO_STREAM(\"msg->bspline[0].yaw.size(): \" << msg->bspline[0].yaw.size());\n\n\t//ROS_INFO_STREAM(\"msg->bspline[1].id: \" << msg->bspline[1].id);\n\t//ROS_INFO_STREAM(\"msg->bspline[1].knots.size(): \" << msg->bspline[1].knots.size());\n\t//ROS_INFO_STREAM(\"msg->bspline[1].pos.size(): \" << msg->bspline[1].pos.size());\n\t//ROS_INFO_STREAM(\"msg->bspline[1].yaw.size(): \" << msg->bspline[1].yaw.size());\n\n\t//ROS_INFO_STREAM(\"msg->bspline[2].id: \" << msg->bspline[2].id);\n\t//ROS_INFO_STREAM(\"msg->bspline[2].knots.size(): \" << msg->bspline[2].knots.size());\n\t//ROS_INFO_STREAM(\"msg->bspline[2].pos.size(): \" << msg->bspline[2].pos.size());\n\t//ROS_INFO_STREAM(\"msg->bsp", "CodeBleu_score": 1.2533532611694387}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb\");\n\t//ROS_INFO(\"msg->num_bsplines = %d\", msg->num_bsplines);\n\t//ROS_INFO(\"msg->id = %d\", msg->id);\n\n\t// for each bspline\n\tfor (int i = 0; i < msg->num_bsplines; i++) {\n\t\t//ROS_INFO(\"msg->bspline_list[%d].id = %d\", i, msg->bspline_list[i].id);\n\t\t//ROS_INFO(\"msg->bspline_list[%d].num_knots = %d\", i, msg->bspline_list[i].num_knots);\n\t\t//ROS_INFO(\"msg->bspline_list[%d].num_points = %d\", i, msg->bspline_list[i].num_points);\n\n\t\t// initialize bspline struct\n\t\tBspline bspline;\n\t\tbspline.id = msg->bspline_list[i].id;\n\t\tbspline.num_knots = msg->bspline_list[i].num_knots;\n\t\tbspline.num_points = msg->bspline_list[i].num_points;\n\t\tbspline.knots.resize(msg->bspline_list[i].num_knots);\n\t\tbspline.pos_points.resize(msg->bspline_list[i].num_points);\n\t\tbspline.yaw_points.resize(msg->bspline_list[i].num_points);\n\n\t\t// set bspline knots\n\t\tfor (int j = 0; j < msg->bspline_list[i].num_knots; j++) {\n\t\t\tbspline.knots[j] = msg->bspline_list[i].knots[j];\n\t\t}\n\n\t\t// set bspline position points\n\t\tfor (int j = 0; j < msg->bspline_list[i].num_points; j++) {\n\t\t\tbspline.pos_points[j].x = msg->bspline_list[i].pos_points[j].x;\n\t\t\tbspline.pos_points[j].y = msg->bspline_", "CodeBleu_score": 42.81371141460946}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZRGB> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Compress the point cloud\n\tpcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZRGB>(cloud));\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree(compression_level_);\n\toctree.encodePointCloud(cloud_ptr, compressed_data_);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.height = msg.height;\n\tcompressed_msg.width = msg.width;\n\tcompressed_msg.is_bigendian = msg.is_bigendian;\n\tcompressed_msg.is_dense = msg.is_dense;\n\tcompressed_msg.fields = msg.fields;\n\tcompressed_msg.point_step = msg.point_step;\n\tcompressed_msg.row_step = msg.row_step;\n\tcompressed_msg.data = compressed_data_;\n\n\t// Release dynamically allocated memory\n\tcloud.clear();\n\tcloud_ptr->clear();\n\tcompressed_data_.clear();\n\n\t// Return the compressed message\n\treturn compressed_msg;\n}", "CodeBleu_score": 40.17152555809628}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PCLPointCloud2 pcl_pc2;\n\tpcl_conversions::toPCL(msg, pcl_pc2);\n\tpcl::PointCloud<pcl::PointXYZRGB>::Ptr temp_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);\n\tpcl::fromPCLPointCloud2(pcl_pc2, *temp_cloud);\n\n\t// Compress the point cloud\n\tpcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_out(new pcl::PointCloud<pcl::PointXYZRGB>);\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree(compression_level_);\n\toctree.setInputCloud(temp_cloud);\n\toctree.encodePointCloud(cloud_out);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 output;\n\tpcl::toROSMsg(*cloud_out, output);\n\toutput.header = msg.header;\n\n\t// Return the new message\n\treturn output;\n}", "CodeBleu_score": 34.309314003048904}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PCLPointCloud2 pcl_pc2;\n\tpcl_conversions::toPCL(msg, pcl_pc2);\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromPCLPointCloud2(pcl_pc2, cloud);\n\n\t// Compress the point cloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud_out;\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(compression_level);\n\toctree.setInputCloud(cloud.makeShared());\n\toctree.encodePointCloud(cloud_out);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 msg_out;\n\tpcl::toROSMsg(cloud_out, msg_out);\n\tmsg_out.header = msg.header;\n\n\t// Release dynamically allocated memory\n\toctree.deleteTree();\n\n\treturn msg_out;\n}", "CodeBleu_score": 32.29457202986683}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (auto &uav : multi_uav_state_) {\n\t\tif (uav.uav_id == uav_state.uav_id) {\n\t\t\tuav = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 28.976885673682805}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\t//std::cout << \"Updating all UAV state\" << std::endl;\n\tfor (auto it = multi_uav_state_.begin(); it!= multi_uav_state_.end(); ++it) {\n\t\tif (it->uav_id == uav_state.uav_id) {\n\t\t\t*it = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 45.84709195573975}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tstd::list<struct UAVState>::iterator it;\n\tfor (it = multi_uav_state_.begin(); it!= multi_uav_state_.end(); it++) {\n\t\tif (it->uav_id == uav_state.uav_id) {\n\t\t\t*it = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.91701957126779}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize the multi UGV state message\n\tswarm_msgs::msg::MultiUGVState multi_ugv_state_msg;\n\n\t// Iterate through each UGV state\n\tfor (int i = 0; i < m_multi_ugv_state.num_ugvs; i++) {\n\t\t// Populate the UGV state message with ID, battery, position, velocity, and attitude data\n\t\tswarm_msgs::msg::UGVState ugv_state_msg;\n\t\tugv_state_msg.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state_msg.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tugv_state_msg.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tugv_state_msg.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\n\t\t// Increment the UGV count\n\t\tmulti_ugv_state_msg.ugv_count++;\n\n\t\t// Add the UGV state to the multi UGV", "CodeBleu_score": 41.99869684469068}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize a MultiUGVState message\n\tswarm_control_msgs::MultiUGVState multi_ugv_state;\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (auto &ugv_state : m_multi_ugv_state.ugv_state) {\n\t\t// Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tswarm_control_msgs::UGVState ugv_state_msg;\n\t\tugv_state_msg.id = ugv_state.id;\n\t\tugv_state_msg.battery = ugv_state.battery;\n\t\tugv_state_msg.position.x = ugv_state.position.x;\n\t\tugv_state_msg.position.y = ugv_state.position.y;\n\t\tugv_state_msg.position.z = ugv_state.position.z;\n\t\tugv_state_msg.velocity.x = ugv_state.velocity.x;\n\t\tugv_state_msg.velocity.y = ugv_state.velocity.y;\n\t\tugv_state_msg.velocity.z = ugv_state.velocity.z;\n\t\tugv_state_msg.attitude.x = ugv_state.attitude.x;\n\t\tugv_state_msg.attitude.y = ugv_state.attitude.y;\n\t\tugv_state_msg.attitude.z = ugv_state.attitude.z;\n\t\tugv_state_msg.attitude.w = ugv_state.attitude.w;\n\t\t// Increment the UGV count\n\t\tmulti_ugv_state.count++;\n\t\t// Add each UGVState to the MultiUGVState message\n\t\tmulti_ugv_state.ugv_state.push_back(ugv_state_msg);\n\t}\n\t// Publish the assembled MultiUGVState message\n\tmulti_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 39.12394078646514}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState ugv_state_msg;\n\tUGVState ugv_state;\n\tint ugv_count = 0;\n\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\t\tugv_state_msg.ugv_state.push_back(ugv_state);\n\t\tugv_count++;\n\t}\n\n\tugv_state_msg.ugv_count = ugv_count;\n\tugv_state_pub.publish(ugv_state_msg);\n}", "CodeBleu_score": 45.73513118751734}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// TODO: Implement the function\n\t// 1. Compute the predicted positions of moving objects\n\t// 2. Evaluate the distance between control points and these objects\n\t// 3. If the distance is less than a specified clearance, update the cost and gradient based on the distance error\n\t// 4. If the distance is larger than the clearance, do nothing\n\t// 5. The cost function is the sum of the squared distance error of all control points\n\t// 6. The gradient is the sum of the derivative of the squared distance error of all control points\n\t// 7. The derivative of the squared distance error is 2 * (control point - predicted position) * (derivative of control point)\n\t// 8. The derivative of control point is the derivative of B-spline curve\n\t// 9. The derivative of B-spline curve is computed in BsplineOptimizer::calcDerivativeOfBSplineCurve\n\t// 10. The derivative of B-spline curve is a 3x3 matrix. The first row is the derivative of x, the second row is the derivative of y, and the third row is the derivative of z.\n\t// 11. The derivative of control point is the derivative of B-spline curve multiplied by the derivative of control point weights\n\t// 12. The derivative of control point weights is a 3x3 matrix. The first row is the derivative of weight1, the second row is the derivative of weight2, and the third row is the derivative of weight3.\n\t// 13. The derivative of weight is 1 / (sum of weights)\n\t// 14. The derivative of sum of weights is a 3x3 matrix. The first row is the derivative of sum of weights w.r.t. weight1, the second row is the derivative of sum of weights w.r.t. weight2, and the third row is the derivative of sum of weights w.r.t. weight3.\n\t// 15. The derivative of sum of weights w.r.t. weight1 is weight2 + weight3\n\t// 16. The derivative of sum of weights w.r.t. weight2 is weight1 + weight3\n\t// 17. The derivative of sum of weights w.r.t. weight3 is weight1 + weight", "CodeBleu_score": 3.5574547207900293}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// clear the cost and gradient\n\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// iterate through control points\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// get the control point\n\t\tEigen::Vector3d ctrl_pt = q.col(i);\n\n\t\t// get the predicted position of moving objects\n\t\tEigen::Vector3d pred_pos;\n\t\tdouble pred_vel_norm;\n\t\tif (!moving_obj_pred_pos_vel_norm_.empty()) {\n\t\t\tpred_pos = moving_obj_pred_pos_vel_norm_[i].first;\n\t\t\tpred_vel_norm = moving_obj_pred_pos_vel_norm_[i].second;\n\t\t} else {\n\t\t\tpred_pos = Eigen::Vector3d::Zero();\n\t\t\tpred_vel_norm = 0;\n\t\t}\n\n\t\t// compute the distance between control points and predicted positions of moving objects\n\t\tdouble dist = (ctrl_pt - pred_pos).norm();\n\n\t\t// if the distance is less than the clearance, update the cost and gradient\n\t\tif (dist < clearance_) {\n\t\t\t// update the cost\n\t\t\tcost += (clearance_ - dist) * (clearance_ - dist);\n\n\t\t\t// update the gradient\n\t\t\tEigen::Vector3d gradient_i = 2 * (clearance_ - dist) * (ctrl_pt - pred_pos);\n\t\t\tgradient.col(i) = gradient_i;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.773651020454125}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tdouble dist;\n\tEigen::Vector3d pos;\n\tEigen::Vector3d diff;\n\tint num_ctrl_pts = q.cols();\n\tint num_moving_objs = moving_objs_.size();\n\tint num_ctrl_pts_per_moving_obj = num_ctrl_pts / num_moving_objs;\n\tint num_ctrl_pts_per_dim = num_ctrl_pts_per_moving_obj / 3;\n\tint num_ctrl_pts_per_moving_obj_per_dim = num_ctrl_pts_per_moving_obj / 3;\n\tint num_ctrl_pts_per_dim_per_moving_obj = num_ctrl_pts_per_moving_obj / 3;\n\tint num_ctrl_pts_per_dim_per_moving_obj_per_dim = num_ctrl_pts_per_moving_obj / 3;\n\n\t// clear cost and gradient\n\tcost = 0.0;\n\tgradient.setZero();\n\n\t// iterate through control points\n\tfor (int i = 0; i < num_ctrl_pts; i++) {\n\t\t// compute the predicted position of the moving object\n\t\tpos = moving_objs_[i / num_ctrl_pts_per_moving_obj].predictPosition(q.block(0, i, 3, 1));\n\n\t\t// compute the distance between the control point and the predicted position of the moving object\n\t\tdiff = pos - q.block(0, i, 3, 1);\n\t\tdist = diff.norm();\n\n\t\t// update cost and gradient based on the distance error\n\t\tif (dist < clearance_) {\n\t\t\tcost += pow(dist, 2);\n\t\t\tgradient.block(0, i, 3, 1) = diff;\n\t\t}\n\t}\n}", "CodeBleu_score": 34.97619489763113}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tint n_points = q.rows();\n\tint n_dims = q.cols();\n\tint n_knots = n_points + 3;\n\n\t// initialize cost to zero\n\tcost = 0.0;\n\n\t// initialize gradient to zero\n\tgradient.setZero(n_knots, n_dims);\n\n\t// iterate through control points\n\tfor (int i = 0; i < n_points; i++) {\n\t\t// get current control point\n\t\tEigen::VectorXd qi = q.row(i);\n\n\t\t// get reference point\n\t\tEigen::VectorXd pi = getRefPoint(i);\n\n\t\t// get velocity vector\n\t\tEigen::VectorXd vi = getVelocityVector(i);\n\n\t\t// compute positional error\n\t\tEigen::VectorXd e = pi - qi;\n\n\t\t// compute cost\n\t\tcost += a2 * e.squaredNorm();\n\t\tcost += b2 * (vi.dot(e)) * (vi.dot(e));\n\n\t\t// compute gradient\n\t\tgradient.row(i) += 2.0 * a2 * e.transpose();\n\t\tgradient.row(i) += 2.0 * b2 * (vi.dot(e)) * vi.transpose();\n\t}\n\n\t// normalize cost by number of control points\n\tcost /= n_points;\n}", "CodeBleu_score": 31.395348309112425}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0;\n\tgradient.setZero();\n\n\t// Iterate through the control points of the trajectory\n\tfor (int i = 0; i < n_control_points; i++) {\n\t\t// Compute the positional error relative to reference points\n\t\tEigen::Vector3d pos_error = q.col(i) - ref_points.col(i);\n\n\t\t// Compute the velocity vector\n\t\tEigen::Vector3d vel_vector;\n\t\tif (i == 0) {\n\t\t\t// For the first control point, the velocity vector is the difference between the first and second control points\n\t\t\tvel_vector = q.col(i + 1) - q.col(i);\n\t\t} else if (i == n_control_points - 1) {\n\t\t\t// For the last control point, the velocity vector is the difference between the last and second-to-last control points\n\t\t\tvel_vector = q.col(i) - q.col(i - 1);\n\t\t} else {\n\t\t\t// For all other control points, the velocity vector is the average of the difference between the current and previous control points and the difference between the current and next control points\n\t\t\tvel_vector = (q.col(i + 1) - q.col(i - 1)) / 2.0;\n\t\t}\n\n\t\t// Compute the cost function based on the squared dot product and cross product of the positional error and velocity vector, normalized by constants a2 and b2\n\t\tcost += a2 * pos_error.squaredNorm() + b2 * vel_vector.cross(pos_error).squaredNorm();\n\n\t\t// Compute the derivatives of the cost function with respect to the control points\n\t\tEigen::Vector3d dcost_dq = 2 * a2 * pos_error + 2 * b2 * vel_vector.cross(pos_error);\n\n\t\t// Update the gradient for the current control point\n\t\tgradient.col(i) = dcost_dq;\n\t}\n}", "CodeBleu_score": 31.027287983153855}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tconst int n = q.cols();\n\n\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tconst Eigen::VectorXd &qi = q.col(i);\n\t\tconst Eigen::VectorXd &qi1 = q.col(i + 1);\n\n\t\tconst Eigen::VectorXd &ref_qi = ref_points.col(i);\n\t\tconst Eigen::VectorXd &ref_qi1 = ref_points.col(i + 1);\n\n\t\tconst Eigen::VectorXd &ref_qi_vel = ref_vel.col(i);\n\t\tconst Eigen::VectorXd &ref_qi1_vel = ref_vel.col(i + 1);\n\n\t\tconst Eigen::VectorXd &qi_vel = (qi1 - qi) / dt;\n\n\t\tconst Eigen::VectorXd &qi_pos_err = qi - ref_qi;\n\t\tconst Eigen::VectorXd &qi1_pos_err = qi1 - ref_qi1;\n\n\t\tconst Eigen::VectorXd &qi_vel_err = qi_vel - ref_qi_vel;\n\t\tconst Eigen::VectorXd &qi1_vel_err = qi_vel - ref_qi1_vel;\n\n\t\tconst double pos_cost = qi_pos_err.dot(qi_pos_err) + qi1_pos_err.dot(qi1_pos_err);\n\t\tconst double vel_cost = qi_vel_err.dot(qi_vel_err) + qi1_vel_err.dot(qi1_vel_err);\n\n\t\tcost += pos_cost * a2 + vel_cost * b2;\n\n\t\tgradient.col(i) += 2 * a2 * qi_pos_err + 2 * b2 * qi_vel_err;\n\t\tgradient.col(i + 1) += 2 * a2 * qi1_pos_err + 2 * b2 * qi1_vel_err;\n\t}\n}", "CodeBleu_score": 37.08452071582132}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\t// Calculate the third derivative of the spline to obtain the jerk trajectory\n\tUniformBspline jerk_spline = this->derivative(3);\n\n\t// Retrieve the knot times and control points of the jerk trajectory\n\tstd::vector<double> knots = jerk_spline.getKnots();\n\tstd::vector<Eigen::VectorXd> control_points = jerk_spline.getControlPoints();\n\n\t// Initialize the total jerk value\n\tdouble total_jerk = 0;\n\n\t// Iterate through the control points and dimensions\n\tfor (int i = 0; i < control_points.size(); i++) {\n\t\tfor (int j = 0; j < control_points[i].size(); j++) {\n\t\t\t// Sum the squared control point values multiplied by the differences in knot times\n\t\t\ttotal_jerk += control_points[i][j] * control_points[i][j] * (knots[i + 4] - knots[i]);\n\t\t}\n\t}\n\n\t// Return the total jerk value\n\treturn total_jerk;\n}", "CodeBleu_score": 45.293720452053634}, {"code": "double UniformBspline::getJerk(){\n\t\t// Compute the third derivative of the spline to obtain the jerk trajectory\n\tUniformBspline jerk = this->getDerivative(3);\n\n\t// Retrieve the knot times and control points of the jerk trajectory\n\tstd::vector<double> knots = jerk.getKnots();\n\tstd::vector<std::vector<double>> controlPoints = jerk.getControlPoints();\n\n\t// Initialize the total jerk value to zero\n\tdouble totalJerk = 0;\n\n\t// Iterate through the control points and dimensions\n\tfor (int i = 0; i < controlPoints.size(); i++) {\n\t\tfor (int j = 0; j < controlPoints[i].size(); j++) {\n\t\t\t// Sum the squared control point values multiplied by the differences in knot times\n\t\t\ttotalJerk += controlPoints[i][j] * controlPoints[i][j] * (knots[i + 4] - knots[i]);\n\t\t}\n\t}\n\n\t// Return the total jerk value\n\treturn totalJerk;\n}", "CodeBleu_score": 43.63132945015134}, {"code": "double UniformBspline::getJerk(){\n\t\t// Compute the third derivative of the spline\n\tUniformBspline jerk_spline = this->getDerivative(3);\n\n\t// Retrieve the knot times and control points of the jerk trajectory\n\tstd::vector<double> knot_times = jerk_spline.getKnotTimes();\n\tstd::vector<Eigen::VectorXd> control_points = jerk_spline.getControlPoints();\n\n\t// Initialize the total jerk value\n\tdouble jerk = 0;\n\n\t// Iterate through the control points and dimensions\n\tfor (int i = 0; i < control_points.size(); i++) {\n\t\tfor (int j = 0; j < control_points[i].size(); j++) {\n\t\t\t// Sum the squared control point values multiplied by the differences in knot times\n\t\t\tjerk += control_points[i][j] * control_points[i][j] * (knot_times[i + 1] - knot_times[i]);\n\t\t}\n\t}\n\n\t// Return the total jerk value\n\treturn jerk;\n}", "CodeBleu_score": 48.11257514952524}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 74.49740701774701}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 74.49740701774701}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 74.49740701774701}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, getDroneID(odom.child_frame_id));\n\t}\n\tcatch (std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 35.9789114376752}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint drone_id = std::stoi(odom.child_frame_id);\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t}\n\tcatch (std::invalid_argument& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 51.09783800485898}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, extractDroneID(odom.child_frame_id));\n\t} catch (std::exception& e) {\n\t\tROS_ERROR(\"Failed to extract drone ID from child_frame_id: %s\", e.what());\n\t}\n}", "CodeBleu_score": 36.935438277359076}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// TODO: Implement this function\n\tEigen::Vector3d drone_pose = Eigen::Vector3d::Zero();\n\tbool found = false;\n\tif (found) {\n\t\t// TODO: Compute pose error\n\t\tEigen::Vector3d pose_error = Eigen::Vector3d::Zero();\n\t\t// TODO: Update debug result\n\t\tdebug_result_.drone_pose_error = pose_error;\n\t\tdebug_result_.found = true;\n\t\t// TODO: Publish pose error\n\t\tpose_error_pub_.publish(pose_error);\n\t} else {\n\t\t// TODO: Update debug result\n\t\tdebug_result_.found = false;\n\t}\n}", "CodeBleu_score": 21.494281340120775}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Compute the true pose of the drone in the camera frame\n\tEigen::Vector3d true_drone_pose = computeTruePose(drone_id);\n\t// Check if the drone is present\n\tbool drone_present = checkPresence(true_drone_pose);\n\t// If the drone is present, compute the pose error and publish it\n\tif (drone_present) {\n\t\t// Compute the pose error between the camera and world coordinates\n\t\tEigen::Vector3d pose_error = computePoseError(true_drone_pose);\n\t\t// Update the debug result\n\t\tdebug_result.drone_id = drone_id;\n\t\tdebug_result.true_pixel = true_pixel;\n\t\tdebug_result.true_pose = true_drone_pose;\n\t\tdebug_result.estimated_pose = pose_error;\n\t\tdebug_result.success = true;\n\t\t// Publish the pose error\n\t\tpose_error_pub.publish(pose_error);\n\t} else {\n\t\t// Update the debug result\n\t\tdebug_result.drone_id = drone_id;\n\t\tdebug_result.true_pixel = true_pixel;\n\t\tdebug_result.true_pose = true_drone_pose;\n\t\tdebug_result.estimated_pose = Eigen::Vector3d::Zero();\n\t\tdebug_result.success = false;\n\t}\n\t// Publish the debug result\n\tdebug_result_pub.publish(debug_result);\n}", "CodeBleu_score": 32.03470456011296}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Check if the drone is present\n\tif (!is_present(drone_id)) {\n\t\t// Update the debug result\n\t\tdebug_result.set_drone_id(drone_id);\n\t\tdebug_result.set_status(DroneDetectorDebug::NOT_FOUND);\n\t\tdebug_result.set_error_x(0);\n\t\tdebug_result.set_error_y(0);\n\t\tdebug_result.set_error_z(0);\n\t\tdebug_result.set_error_yaw(0);\n\t\tdebug_result.set_error_pitch(0);\n\t\tdebug_result.set_error_roll(0);\n\t\t// Publish the debug result\n\t\tdebug_result_pub.publish(debug_result);\n\t\treturn;\n\t}\n\n\t// Compute the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose_camera_frame;\n\ttrue_pose_camera_frame << true_pixel[0], true_pixel[1], drone_id_to_height[drone_id];\n\n\t// Compute the pose error between the camera and world coordinates\n\tEigen::Vector3d error_pose;\n\terror_pose = true_pose_camera_frame - pose_camera_frame;\n\n\t// Update the debug result\n\tdebug_result.set_drone_id(drone_id);\n\tdebug_result.set_status(DroneDetectorDebug::SUCCESS);\n\tdebug_result.set_error_x(error_pose[0]);\n\tdebug_result.set_error_y(error_pose[1]);\n\tdebug_result.set_error_z(error_pose[2]);\n\tdebug_result.set_error_yaw(0);\n\tdebug_result.set_error_pitch(0);\n\tdebug_result.set_error_roll(0);\n\t// Publish the debug result\n\tdebug_result_pub.publish(debug_result);\n}", "CodeBleu_score": 31.628844341530886}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start and end points to grid indices\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Adjust start and end points if they are inside obstacles\n\tif (start_idx(0) >= 0 && start_idx(0) < grid_size_(0) && start_idx(1) >= 0 && start_idx(1) < grid_size_(1) && start_idx(2) >= 0 && start_idx(2) < grid_size_(2) && grid_[start_idx(0)][start_idx(1)][start_idx(2)] == 1) {\n\t\t// Start point is inside an obstacle, so adjust it\n\t\tVector3i offset;\n\t\tif (start_pt(0) < end_pt(0)) {\n\t\t\toffset(0) = -1;\n\t\t} else {\n\t\t\toffset(0) = 1;\n\t\t}\n\t\tif (start_pt(1) < end_pt(1)) {\n\t\t\toffset(1) = -1;\n\t\t} else {\n\t\t\toffset(1) = 1;\n\t\t}\n\t\tif (start_pt(2) < end_pt(2)) {\n\t\t\toffset(2) = -1;\n\t\t} else {\n\t\t\toffset(2) = 1;\n\t\t}\n\t\twhile (start_idx(0) >= 0 && start_idx(0) < grid_size_(0) && start_idx(1) >= 0 && start_idx(1) < grid_size_(1) && start_idx(2) >= 0 && start_idx(2) < grid_size_(2) && grid_[start_idx(0)][start_idx(1)][start_idx(2)] == 1) {\n\t\t\tstart_idx += offset;\n\t\t}\n\t}\n\tif (end_idx(0) >= 0 && end_idx(0) < grid_size_(0) && end_idx(1) >= 0 && end_idx(1) < grid_size_(1) && end_idx(2) >= 0 && end_idx(", "CodeBleu_score": 35.444581790560946}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tVector3i start_idx_tmp, end_idx_tmp;\n\tif (ConvertToIndex(start_pt, start_idx_tmp) && ConvertToIndex(end_pt, end_idx_tmp)) {\n\t\tif (IsPointInsideObstacle(start_idx_tmp)) {\n\t\t\tVector3i start_idx_tmp_new;\n\t\t\tif (AdjustPointInsideObstacle(start_idx_tmp, end_idx_tmp, start_idx_tmp_new)) {\n\t\t\t\tstart_idx = start_idx_tmp_new;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tstart_idx = start_idx_tmp;\n\t\t}\n\n\t\tif (IsPointInsideObstacle(end_idx_tmp)) {\n\t\t\tVector3i end_idx_tmp_new;\n\t\t\tif (AdjustPointInsideObstacle(end_idx_tmp, start_idx, end_idx_tmp_new)) {\n\t\t\t\tend_idx = end_idx_tmp_new;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tend_idx = end_idx_tmp;\n\t\t}\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 35.26066187213625}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start and end points to indices\n\tstart_idx = PointToIndex(start_pt);\n\tend_idx = PointToIndex(end_pt);\n\n\t// Check if start or end point is inside an obstacle\n\tif (isPointInObstacle(start_idx) || isPointInObstacle(end_idx)) {\n\t\t// If start or end point is inside an obstacle, adjust it iteratively until it is no longer in an obstacle\n\t\tVector3i start_idx_adjusted = start_idx;\n\t\tVector3i end_idx_adjusted = end_idx;\n\t\tVector3d start_pt_adjusted = start_pt;\n\t\tVector3d end_pt_adjusted = end_pt;\n\t\tbool start_adjusted = false;\n\t\tbool end_adjusted = false;\n\t\twhile (isPointInObstacle(start_idx_adjusted) || isPointInObstacle(end_idx_adjusted)) {\n\t\t\t// Move start point away from end point until it is no longer in an obstacle\n\t\t\tif (isPointInObstacle(start_idx_adjusted)) {\n\t\t\t\tstart_pt_adjusted = start_pt_adjusted + (start_pt_adjusted - end_pt_adjusted).normalized() * 0.1;\n\t\t\t\tstart_idx_adjusted = PointToIndex(start_pt_adjusted);\n\t\t\t\tstart_adjusted = true;\n\t\t\t}\n\n\t\t\t// Move end point away from start point until it is no longer in an obstacle\n\t\t\tif (isPointInObstacle(end_idx_adjusted)) {\n\t\t\t\tend_pt_adjusted = end_pt_adjusted + (end_pt_adjusted - start_pt_adjusted).normalized() * 0.1;\n\t\t\t\tend_idx_adjusted = PointToIndex(end_pt_adjusted);\n\t\t\t\tend_adjusted = true;\n\t\t\t}\n\n\t\t\t// If both start and end points are in an obstacle, return false\n\t\t\tif (isPointInObstacle(start_idx_adjusted) && isPointInObstacle(end_idx_adjusted)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// If start or end point was adjusted, update the adjusted indices and points\n\t\tif (start_adjusted) {\n\t\t\tstart_idx = start_idx_adjusted;\n\t\t\tstart_pt = start_pt_", "CodeBleu_score": 36.92829492849684}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tint min_id[3], max_id[3];\n\tposToId(min_pos, min_id);\n\tposToId(max_pos, max_id);\n\tfor (int i = min_id[0]; i <= max_id[0]; i++) {\n\t\tfor (int j = min_id[1]; j <= max_id[1]; j++) {\n\t\t\tfor (int k = min_id[2]; k <= max_id[2]; k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.29605869154226}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = posToId(min_pos);\n\tEigen::Vector3i max_id = posToId(max_pos);\n\tfor (int x = min_id.x(); x <= max_id.x(); ++x) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); ++y) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); ++z) {\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t\tdistance_buffer_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.903465187562574}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = getGridId(min_pos);\n\tEigen::Vector3i max_id = getGridId(max_pos);\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.14472013953615}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_max = diff(0) / (double) (max_x - min_x);\n\tdouble x_min = diff(0) / (double) (min_x - max_x);\n\tdouble y_max = diff(1) / (double) (max_y - min_y);\n\tdouble y_min = diff(1) / (double) (min_y - max_y);\n\tdouble z_max = diff(2) / (double) (max_z - min_z);\n\tdouble z_min = diff(2) / (double) (min_z - max_z);\n\n\tdouble x_scale = 1.0, y_scale = 1.0, z_scale = 1.0;\n\tif (x_max > 0 && x_max < x_scale)\n\t\tx_scale = x_max;\n\tif (x_min > 0 && x_min < x_scale)\n\t\tx_scale = x_min;\n\tif (y_max > 0 && y_max < y_scale)\n\t\ty_scale = y_max;\n\tif (y_min > 0 && y_min < y_scale)\n\t\ty_scale = y_min;\n\tif (z_max > 0 && z_max < z_scale)\n\t\tz_scale = z_max;\n\tif (z_min > 0 && z_min < z_scale)\n\t\tz_scale = z_min;\n\n\tEigen::Vector3d new_pt = camera_pt + x_scale * diff;\n\tnew_pt(1) = camera_pt(1) + y_scale * diff(1);\n\tnew_pt(2) = camera_pt(2) + z_scale * diff(2);\n\treturn new_pt;\n}", "CodeBleu_score": 40.54646690706303}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_max = (x_max_ - camera_pt(0)) / diff(0);\n\tdouble x_min = (x_min_ - camera_pt(0)) / diff(0);\n\tdouble y_max = (y_max_ - camera_pt(1)) / diff(1);\n\tdouble y_min = (y_min_ - camera_pt(1)) / diff(1);\n\tdouble z_max = (z_max_ - camera_pt(2)) / diff(2);\n\tdouble z_min = (z_min_ - camera_pt(2)) / diff(2);\n\tdouble x_scale = 1.0;\n\tdouble y_scale = 1.0;\n\tdouble z_scale = 1.0;\n\tif (x_max < 1.0) {\n\t\tx_scale = x_max;\n\t}\n\tif (x_min > 1.0) {\n\t\tx_scale = x_min;\n\t}\n\tif (y_max < 1.0) {\n\t\ty_scale = y_max;\n\t}\n\tif (y_min > 1.0) {\n\t\ty_scale = y_min;\n\t}\n\tif (z_max < 1.0) {\n\t\tz_scale = z_max;\n\t}\n\tif (z_min > 1.0) {\n\t\tz_scale = z_min;\n\t}\n\tdouble scale = std::min(x_scale, std::min(y_scale, z_scale));\n\treturn camera_pt + scale * diff;\n}", "CodeBleu_score": 39.793941804072496}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_scale_factor = 1;\n\tdouble min_scale_factor = 1;\n\tfor (int i = 0; i < 3; i++) {\n\t\tdouble scale_factor = 1;\n\t\tif (diff[i] > 0) {\n\t\t\tscale_factor = (map_max[i] - camera_pt[i]) / diff[i];\n\t\t} else if (diff[i] < 0) {\n\t\t\tscale_factor = (map_min[i] - camera_pt[i]) / diff[i];\n\t\t}\n\t\tif (scale_factor < min_scale_factor) {\n\t\t\tmin_scale_factor = scale_factor;\n\t\t}\n\t\tif (scale_factor > max_scale_factor) {\n\t\t\tmax_scale_factor = scale_factor;\n\t\t}\n\t}\n\tif (min_scale_factor > 1) {\n\t\tmin_scale_factor = 1;\n\t}\n\tif (max_scale_factor < 1) {\n\t\tmax_scale_factor = 1;\n\t}\n\treturn camera_pt + diff * min_scale_factor;\n}", "CodeBleu_score": 45.42243002427897}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t//update last occupancy update time\n\tlast_occupancy_update_time = ros::Time::now();\n\n\t//if an update is needed\n\tif (update_occupancy_grid) {\n\t\t//clear and inflate local map\n\t\tif (local_map_updated) {\n\t\t\tlocal_map_updated = false;\n\t\t\tclearLocalMap();\n\t\t\tinflateLocalMap();\n\t\t}\n\n\t\t//project depth image into points\n\t\tprojectDepthImageIntoPoints();\n\n\t\t//process points with raycasting\n\t\tprocessPointsWithRaycasting();\n\t}\n\n\t//handle timeout errors for odometry or depth data\n\thandleTimeoutErrors();\n}", "CodeBleu_score": 17.075478533291484}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tlast_occupancy_update_time = ros::Time::now();\n\tif (need_occupancy_update) {\n\t\tneed_occupancy_update = false;\n\t\tif (depth_data_available && odom_data_available) {\n\t\t\t// update local map\n\t\t\tif (local_map_updated) {\n\t\t\t\tlocal_map_updated = false;\n\t\t\t\tclearLocalMap();\n\t\t\t\tinflateLocalMap();\n\t\t\t}\n\n\t\t\t// update occupancy grid\n\t\t\tif (occupancy_grid_updated) {\n\t\t\t\toccupancy_grid_updated = false;\n\t\t\t\tupdateOccupancyGrid();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!depth_data_available) {\n\t\t\t\tROS_WARN_THROTTLE(1, \"No depth data available\");\n\t\t\t}\n\t\t\tif (!odom_data_available) {\n\t\t\t\tROS_WARN_THROTTLE(1, \"No odometry data available\");\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 28.266112824020134}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last occupancy update time\n\tlast_occupancy_update_time_ = ros::Time::now();\n\n\t// Check if an update is needed\n\tif (last_depth_update_time_ < last_occupancy_update_time_) {\n\t\t// Update the depth image\n\t\tdepth_image_ = depth_image_msg_;\n\t\tlast_depth_update_time_ = last_occupancy_update_time_;\n\n\t\t// Check if the depth image is valid\n\t\tif (depth_image_.empty()) {\n\t\t\t// Set the depth image invalid flag\n\t\t\tdepth_image_invalid_ = true;\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if the depth image is valid\n\t\tif (depth_image_.isContinuous()) {\n\t\t\t// Set the depth image invalid flag\n\t\t\tdepth_image_invalid_ = false;\n\n\t\t\t// Clear and inflate the local map\n\t\t\tif (local_map_updated_) {\n\t\t\t\t// Clear the local map\n\t\t\t\tlocal_map_.clear();\n\n\t\t\t\t// Inflate the local map\n\t\t\t\tinflateLocalMap();\n\n\t\t\t\t// Set the local map updated flag\n\t\t\t\tlocal_map_updated_ = false;\n\t\t\t}\n\n\t\t\t// Process the depth image\n\t\t\tprocessDepthImage();\n\t\t} else {\n\t\t\t// Set the depth image invalid flag\n\t\t\tdepth_image_invalid_ = true;\n\t\t}\n\t}\n\n\t// Check if the depth image is invalid\n\tif (depth_image_invalid_) {\n\t\t// Check if the depth image timeout is exceeded\n\t\tif ((ros::Time::now() - last_depth_update_time_).toSec() > depth_image_timeout_) {\n\t\t\t// Set the depth image timeout flag\n\t\t\tdepth_image_timeout_ = true;\n\t\t} else {\n\t\t\t// Set the depth image timeout flag\n\t\t\tdepth_image_timeout_ = false;\n\t\t}\n\t} else {\n\t\t// Set the depth image timeout flag\n\t\tdepth_image_timeout_ = false;\n\t}\n\n\t// Check if the odometry timeout is exceeded\n\tif ((ros::Time::now() - last_odometry_update_time_).toSec() > odometry_timeout_) {\n\t\t// Set the odometry timeout flag\n\t\todometry_timeout_ = true;\n\t} else {\n\t", "CodeBleu_score": 39.31999044001268}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\t// TODO: Implement this function\n\tfloat avg_fmeasure = 0;\n\tint num_images = image_fns.size();\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load image\n\t\tMat image = imread(image_fns[i]);\n\t\tif (image.empty()) {\n\t\t\tcout << \"Cannot read image file: \" << image_fns[i] << endl;\n\t\t\texit(1);\n\t\t}\n\n\t\t// Load ground truth\n\t\tvector<Ellipse> gt_ellipses;\n\t\tifstream gt_file(gt_fns[i]);\n\t\tif (gt_file.is_open()) {\n\t\t\tstring line;\n\t\t\twhile (getline(gt_file, line)) {\n\t\t\t\tistringstream iss(line);\n\t\t\t\tdouble x, y, a, b, angle;\n\t\t\t\tiss >> x >> y >> a >> b >> angle;\n\t\t\t\tif (gt_angle_radians) {\n\t\t\t\t\tangle = angle * 180 / CV_PI;\n\t\t\t\t}\n\t\t\t\tgt_ellipses.push_back(Ellipse(x, y, a, b, angle));\n\t\t\t}\n\t\t\tgt_file.close();\n\t\t}\n\n\t\t// Load detected ellipses\n\t\tvector<Ellipse> dt_ellipses;\n\t\tifstream dt_file(dt_fns[i]);\n\t\tif (dt_file.is_open()) {\n\t\t\tstring line;\n\t\t\twhile (getline(dt_file, line)) {\n\t\t\t\tistringstream iss(line);\n\t\t\t\tdouble x, y, a, b, angle;\n\t\t\t\tiss >> x >> y >> a >> b >> angle;\n\t\t\t\tdt_ellipses.push_back(Ellipse(x, y, a, b, angle));\n\t\t\t}\n\t\t\tdt_file.close();\n\t\t}\n\n\t\t// Evaluate detection performance\n\t\tavg_fmeasure += ellipse_fmeasure(gt_ellipses, dt_ellipses, image.size());\n\t}\n\n\t// Return average F-measure\n\treturn avg_fmeasure / num_images;\n}", "CodeBleu_score": 49.153146248958244}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat f_measure = 0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tMat image = imread(image_fns[i], IMREAD_GRAYSCALE);\n\t\tMat gt = imread(gt_fns[i], IMREAD_GRAYSCALE);\n\t\tMat dt = imread(dt_fns[i], IMREAD_GRAYSCALE);\n\t\tf_measure += ellipse_evaluate(image, gt, dt, gt_angle_radians);\n\t}\n\treturn f_measure / image_fns.size();\n}", "CodeBleu_score": 58.01475800367019}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat f_measure = 0;\n\tint num_images = image_fns.size();\n\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load image\n\t\tcv::Mat image = cv::imread(image_fns[i]);\n\n\t\t// Load ground truth\n\t\tvector<Ellipse> gt_ellipses;\n\t\tellipse_load_gt(gt_fns[i], gt_ellipses);\n\n\t\t// Load detections\n\t\tvector<Ellipse> dt_ellipses;\n\t\tellipse_load_dt(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\t// Evaluate detections\n\t\tf_measure += ellipse_f_measure(gt_ellipses, dt_ellipses);\n\t}\n\n\treturn f_measure / num_images;\n}", "CodeBleu_score": 56.63423497398878}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_a, angle_b;\n\tfloat normal_angle;\n\tif (foci) {\n\t\tangle_a = atan2(y, x - foci[0]);\n\t\tangle_b = atan2(y, x - foci[1]);\n\t\tnormal_angle = angle_b - angle_a;\n\t\tif (normal_angle > M_PI)\n\t\t\tnormal_angle -= 2 * M_PI;\n\t\telse if (normal_angle < -M_PI)\n\t\t\tnormal_angle += 2 * M_PI;\n\t}\n\telse {\n\t\tnormal_angle = atan2(y, x);\n\t}\n\treturn normal_angle;\n}", "CodeBleu_score": 38.315925537762055}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tif (foci == NULL) {\n\t\treturn 0.0;\n\t}\n\n\tfloat angle1 = atan2(y, x);\n\tfloat angle2 = atan2(y, x - 2 * foci[0]);\n\tfloat angle = angle1 - angle2;\n\n\tif (angle > M_PI) {\n\t\tangle -= 2 * M_PI;\n\t} else if (angle < -M_PI) {\n\t\tangle += 2 * M_PI;\n\t}\n\n\treturn angle;\n}", "CodeBleu_score": 35.67321536139663}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = foci[0];\n\tfloat b = foci[1];\n\tfloat c = foci[2];\n\tfloat d = foci[3];\n\n\tfloat angle_a = atan2(y - d, x - a);\n\tfloat angle_b = atan2(y - d, x - c);\n\n\tfloat normal_angle = angle_a - angle_b;\n\n\tif (normal_angle > M_PI) {\n\t\tnormal_angle -= 2 * M_PI;\n\t} else if (normal_angle < -M_PI) {\n\t\tnormal_angle += 2 * M_PI;\n\t}\n\n\treturn normal_angle;\n}", "CodeBleu_score": 37.34261274666972}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint x_min = 1000000000;\n\tint x_max = 0;\n\tint y_min = 1000000000;\n\tint y_max = 0;\n\tint x_min_index = 0;\n\tint x_max_index = 0;\n\tint y_min_index = 0;\n\tint y_max_index = 0;\n\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < x_min) {\n\t\t\tx_min = vp1[i].x;\n\t\t\tx_min_index = i;\n\t\t}\n\t\tif (vp1[i].x > x_max) {\n\t\t\tx_max = vp1[i].x;\n\t\t\tx_max_index = i;\n\t\t}\n\t\tif (vp1[i].y < y_min) {\n\t\t\ty_min = vp1[i].y;\n\t\t\ty_min_index = i;\n\t\t}\n\t\tif (vp1[i].y > y_max) {\n\t\t\ty_max = vp1[i].y;\n\t\t\ty_max_index = i;\n\t\t}\n\t}\n\n\tint x_min_index_next = (x_min_index + 1) % vp1.size();\n\tint x_max_index_next = (x_max_index + 1) % vp1.size();\n\tint y_min_index_next = (y_min_index + 1) % vp1.size();\n\tint y_max_index_next = (y_max_index + 1) % vp1.size();\n\n\tint x_min_index_prev = (x_min_index - 1 + vp1.size()) % vp1.size();\n\tint x_max_index_prev = (x_max_index - 1 + vp1.size()) % vp1.size();\n\tint y_min_index_prev = (y_min_index - 1 + vp1.size()) % vp1.size();\n\tint y_max_index_prev = (y_max_", "CodeBleu_score": 34.101349644144605}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint min_x = vp1[start].x;\n\tint max_x = vp1[start].x;\n\tint min_y = vp1[start].y;\n\tint max_y = vp1[start].y;\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\tint integral_above = 0;\n\tint integral_below = 0;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x || vp1[i].x > max_x || vp1[i].y < min_y || vp1[i].y > max_y) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vp1[i].x == min_x || vp1[i].x == max_x || vp1[i].y == min_y || vp1[i].y == max_y) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = start; j <= end; j++) {\n\t\t\tif (vp1[j].x < min_x || vp1[j].x > max_x || vp1[j].y < min_y || vp1[j].y > max_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vp1[j].x == min_x || vp1[j].x == max_x || vp1[j].y == min_y || vp1[j].y == max_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vp1[j].x == vp1[i].x && vp1[j].y == vp1[i].y", "CodeBleu_score": 32.609361039003545}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\t// Compute the minimum and maximum x and y coordinates of the points in the section\n\tint min_x = INT_MAX, max_x = INT_MIN, min_y = INT_MAX, max_y = INT_MIN;\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\n\t// Compute the integral above the polygon section\n\tint above = 0;\n\tfor (int i = min_x; i < max_x; i++) {\n\t\tint y_above = INT_MIN;\n\t\tfor (int j = start; j < end; j++) {\n\t\t\tif (vp1[j].x == i) {\n\t\t\t\tif (vp1[j].y > y_above)\n\t\t\t\t\ty_above = vp1[j].y;\n\t\t\t}\n\t\t\telse if (vp1[j].x > i) {\n\t\t\t\tif (vp1[j].y > y_above)\n\t\t\t\t\ty_above = vp1[j].y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tabove += y_above;\n\t}\n\n\t// Compute the integral below the polygon section\n\tint below = 0;\n\tfor (int i = min_x; i < max_x; i++) {\n\t\tint y_below = INT_MAX;\n\t\tfor (int j = start; j < end; j++) {\n\t\t\tif (vp1[j].x == i) {\n\t\t\t\tif (vp1[j].y < y_below)\n\t\t\t\t\ty_below = vp1[j].y;\n\t\t\t}\n\t\t\telse if (vp1[j].x > i) {\n\t\t\t\tif (vp1[j].y < y_below)\n\t\t\t\t\ty_below = vp1[j].y;\n\t\t\t\t", "CodeBleu_score": 36.88448866001677}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t// ROS_INFO(\"ellipse_det_cb\");\n\tint num_lost = 0;\n\tint num_regain = 0;\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t}\n\t}\n\tif (num_lost > VISION_THRES) {\n\t\tis_detected = false;\n\t}\n\tif (num_regain > VISION_THRES) {\n\t\tis_detected = true;\n\t}\n\tellipse_det.sight_angle[0] = msg->detection_infos[0].sight_angle[1];\n\tellipse_det.sight_angle[1] = msg->detection_infos[0].sight_angle[0];\n}", "CodeBleu_score": 56.27852331025329}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].target_name == \"T\") {\n\t\t\tellipse_det.num_lost = 0;\n\t\t\tellipse_det.num_regain++;\n\t\t}\n\t\telse {\n\t\t\tellipse_det.num_regain = 0;\n\t\t\tellipse_det.num_lost++;\n\t\t}\n\n\t\tif (ellipse_det.num_lost >= VISION_THRES) {\n\t\t\tellipse_det.is_detected = false;\n\t\t}\n\t\tif (ellipse_det.num_regain >= VISION_THRES) {\n\t\t\tellipse_det.is_detected = true;\n\t\t}\n\n\t\tif (msg->detection_infos[i].target_name == \"T\") {\n\t\t\tellipse_det.target_name = msg->detection_infos[i].target_name;\n\t\t\tellipse_det.target_id = msg->detection_infos[i].target_id;\n\t\t\tellipse_det.target_type = msg->detection_infos[i].target_type;\n\t\t\tellipse_det.target_position[0] = msg->detection_infos[i].target_position[0];\n\t\t\tellipse_det.target_position[1] = msg->detection_infos[i].target_position[1];\n\t\t\tellipse_det.target_position[2] = msg->detection_infos[i].target_position[2];\n\t\t\tellipse_det.target_velocity[0] = msg->detection_infos[i].target_velocity[0];\n\t\t\tellipse_det.target_velocity[1] = msg->detection_infos[i].target_velocity[1];\n\t\t\tellipse_det.target_velocity[2] = msg->detection_infos[i].target_velocity[2];\n\t\t\tellipse_det.target_size[0] = msg->detection_infos[i].target_size[0];\n\t\t\tellipse_det.target_size[1] = msg->detection_infos[i].target_size[1];\n\t\t\tellipse_det.target_size[2] = msg->detection_infos[i].target_size[2];\n\t\t\tellipse_det.target_yaw = msg->detection_", "CodeBleu_score": 32.552153495424385}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tif (msg->detection_infos.size() == 0) {\n\t\tellipse_det.is_detected = false;\n\t\tellipse_det.num_lost++;\n\t\tellipse_det.num_regain = 0;\n\t\tellipse_det.ellipse_pose.position.x = 0;\n\t\tellipse_det.ellipse_pose.position.y = 0;\n\t\tellipse_det.ellipse_pose.position.z = 0;\n\t\tellipse_det.ellipse_pose.orientation.x = 0;\n\t\tellipse_det.ellipse_pose.orientation.y = 0;\n\t\tellipse_det.ellipse_pose.orientation.z = 0;\n\t\tellipse_det.ellipse_pose.orientation.w = 0;\n\t\tellipse_det.ellipse_size.x = 0;\n\t\tellipse_det.ellipse_size.y = 0;\n\t\tellipse_det.ellipse_size.z = 0;\n\t\tellipse_det.sight_angle.x = 0;\n\t\tellipse_det.sight_angle.y = 0;\n\t\tellipse_det.sight_angle.z = 0;\n\t\tellipse_det.num_obj = 0;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].object_name == \"T\") {\n\t\t\tellipse_det.is_detected = true;\n\t\t\tellipse_det.num_regain++;\n\t\t\tellipse_det.num_lost = 0;\n\t\t\tellipse_det.ellipse_pose.position.x = msg->detection_infos[i].object_pose.position.x;\n\t\t\tellipse_det.ellipse_pose.position.y = msg->detection_infos[i].object_pose.position.y;\n\t\t\tellipse_det.ellipse_pose.position.z = msg->detection_infos[i].object_pose.position.z;\n\t\t\tellipse_det.ellipse_pose.orientation.x = msg->detection_infos[i].object_pose.orientation.x;\n\t\t\tellipse_det.ellipse_pose.orientation.y = msg->detection_infos[i].object_pose.orientation.y;\n\t\t\t", "CodeBleu_score": 26.267577507449158}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tbool safe;\n\tif (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n\t\tsafe = true;\n\t} else {\n\t\tsafe = false;\n\t}\n\treturn safe;\n}", "CodeBleu_score": 57.98396031066018}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tbool safe = true;\n\tif (Occupy_map_ptr->check_safety(cur_pos, safe_distance) == false) {\n\t\tsafe = false;\n\t}\n\treturn safe;\n}", "CodeBleu_score": 57.473819225430475}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tbool safe_flag = true;\n\t// check the safety of the current position\n\tif (!Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n\t\tsafe_flag = false;\n\t}\n\treturn safe_flag;\n}", "CodeBleu_score": 56.68810032816213}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr node = end_node;\n\twhile (node!= nullptr) {\n\t\tpath_nodes_.push_back(node);\n\t\tnode = node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 49.75303871233074}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node->parent_!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent_;\n\t}\n\tpath_nodes_.push_back(current_node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.649509291890034}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node->parent!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tpath_nodes_.push_back(current_node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.7481664549514}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif(simulation_mode) {\n\t\tif(sqrt(pow(odom->pose.pose.position.x - start_position.x, 2) + pow(odom->pose.pose.position.y - start_position.y, 2)) > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].theta = tf::getYaw(odom->pose.pose.orientation);\n}", "CodeBleu_score": 47.56828904177673}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"odom->pose.pose.position.x: %f\", odom->pose.pose.position.x);\n\t//ROS_INFO(\"odom->pose.pose.position.y: %f\", odom->pose.pose.position.y);\n\t//ROS_INFO(\"odom->pose.pose.position.z: %f\", odom->pose.pose.position.z);\n\t//ROS_INFO(\"odom->pose.pose.orientation.x: %f\", odom->pose.pose.orientation.x);\n\t//ROS_INFO(\"odom->pose.pose.orientation.y: %f\", odom->pose.pose.orientation.y);\n\t//ROS_INFO(\"odom->pose.pose.orientation.z: %f\", odom->pose.pose.orientation.z);\n\t//ROS_INFO(\"odom->pose.pose.orientation.w: %f\", odom->pose.pose.orientation.w);\n\t//ROS_INFO(\"odom->twist.twist.linear.x: %f\", odom->twist.twist.linear.x);\n\t//ROS_INFO(\"odom->twist.twist.linear.y: %f\", odom->twist.twist.linear.y);\n\t//ROS_INFO(\"odom->twist.twist.linear.z: %f\", odom->twist.twist.linear.z);\n\t//ROS_INFO(\"odom->twist.twist.angular.x: %f\", odom->twist.twist.angular.x);\n\t//ROS_INFO(\"odom->twist.twist.angular.y: %f\", odom->twist.twist.angular.y);\n\t//ROS_INFO(\"odom->twist.twist.angular.z: %f\", odom->twist.twist.angular.z);\n\t//ROS_INFO(\"odom->header.stamp.sec: %d\", odom->header.stamp.sec);\n\t//ROS_INFO(\"odom->header.stamp.nsec: %d\", odom->header.stamp.nsec);\n\t", "CodeBleu_score": 3.237095374924035}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t// update the state of the neighboring UGV based on its odometry data\n\tstate_nei[id][0] = odom->pose.pose.position.x;\n\tstate_nei[id][1] = odom->pose.pose.position.y;\n\tstate_nei[id][2] = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id][3] = odom->pose.pose.position.z;\n\n\t// in simulation mode, check the distance from the start position and set the get_nei_state flag to false if the distance exceeds 5 meters\n\tif (sim_mode) {\n\t\tif (sqrt(pow(state_nei[id][0], 2) + pow(state_nei[id][1], 2)) > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 54.03669809242435}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count == 5) {\n\t\tupdate_count = 0;\n\t\t//ROS_INFO(\"Updating map\");\n\t\tupdateMap(msg);\n\t}\n}", "CodeBleu_score": 51.61970192300497}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) return;\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count == 5) {\n\t\tupdate_count = 0;\n\t\tpcl::PointCloud<pcl::PointXYZ> pcl_pc;\n\t\tpcl::fromROSMsg(*msg, pcl_pc);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr pcl_pc_ptr(new pcl::PointCloud<pcl::PointXYZ>(pcl_pc));\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr pcl_pc_ptr_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::VoxelGrid<pcl::PointXYZ> vg;\n\t\tvg.setInputCloud(pcl_pc_ptr);\n\t\tvg.setLeafSize(0.1, 0.1, 0.1);\n\t\tvg.filter(*pcl_pc_ptr_filtered);\n\t\t//ROS_INFO(\"Filtered cloud size: %d\", pcl_pc_ptr_filtered->size());\n\t\tupdate_astar_map(pcl_pc_ptr_filtered);\n\t}\n}", "CodeBleu_score": 43.36321911021622}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb\");\n\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count == 5) {\n\t\tupdate_count = 0;\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: updating map\");\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\t\tpcl::fromROSMsg(*msg, cloud);\n\t\tpcl::PointCloud<pcl::PointXYZ> transformed_cloud;\n\t\tpcl_ros::transformPointCloud(cloud, transformed_cloud, odom_tf);\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: updating map: %d points\", (int)transformed_cloud.points.size());\n\t\tfor (int i = 0; i < (int)transformed_cloud.points.size(); i++) {\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: updating map: %d of %d\", i, (int)transformed_cloud.points.size());\n\t\t\tint x = (int)transformed_cloud.points[i].x;\n\t\t\tint y = (int)transformed_cloud.points[i].y;\n\t\t\tif (x >= 0 && x < map_size_x && y >= 0 && y < map_size_y) {\n\t\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: updating map: %d of %d\", i, (int)transformed_cloud.points.size());\n\t\t\t\tmap[x][y] = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 54.24712908622349}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, gpcl);\n\t\tgpcl_stored = gpcl;\n\t\tgpcl_inflated = gpcl;\n\t\tpcl::PointXYZ pt;\n\t\tfor(int i = 0; i < gpcl_inflated.points.size(); i++) {\n\t\t\tpt = gpcl_inflated.points[i];\n\t\t\tpt.x = pt.x - inflation_dist;\n\t\t\tpt.y = pt.y - inflation_dist;\n\t\t\tpt.z = pt.z - inflation_dist;\n\t\t\tgpcl_inflated.points[i] = pt;\n\t\t}\n\t}\n}", "CodeBleu_score": 48.34272667098895}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl) {\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_inflated);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_2(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_3(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_4(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_5(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_6(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_7(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_8(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_9(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_10(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_11(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_12(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflated_temp_13(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::Point", "CodeBleu_score": 30.675606475745976}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tgpcl->header.frame_id = \"map\";\n\t\tgpcl->header.stamp = ros::Time::now();\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr temp_gpcl(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl, *temp_gpcl);\n\t\tgpcl_inflated = gpcl;\n\t\tgpcl_inflated->header.frame_id = \"map\";\n\t\tgpcl_inflated->header.stamp = ros::Time::now();\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr temp_gpcl_inflated(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl_inflated, *temp_gpcl_inflated);\n\t\tgpcl_inflated = temp_gpcl_inflated;\n\t\tinflation_gpcl(gpcl_inflated, gpcl_inflated);\n\t\tgpcl_inflated->header.frame_id = \"map\";\n\t\tgpcl_inflated->header.stamp = ros::Time::now();\n\t}\n}", "CodeBleu_score": 47.88753686805577}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert the laser scan to a PointCloud2 format\n\tsensor_msgs::PointCloud2 cloud;\n\tprojector_.projectLaser(*local_point, cloud);\n\n\t// Convert the PointCloud2 format to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> laser_cloud;\n\tpcl::fromROSMsg(cloud, laser_cloud);\n\n\t// If not in simulation mode, merge the local map with the provided odometry data\n\tif (!simulation_) {\n\t\t// Get the transformation matrix from the odometry data\n\t\tEigen::Matrix4f pose = Eigen::Matrix4f::Identity();\n\t\tpose(0, 0) = odom.pose.pose.orientation.w;\n\t\tpose(0, 1) = odom.pose.pose.orientation.x;\n\t\tpose(0, 2) = odom.pose.pose.orientation.y;\n\t\tpose(0, 3) = odom.pose.pose.orientation.z;\n\t\tpose(1, 0) = -odom.pose.pose.orientation.z;\n\t\tpose(1, 1) = odom.pose.pose.orientation.w;\n\t\tpose(1, 2) = odom.pose.pose.orientation.x;\n\t\tpose(1, 3) = odom.pose.pose.orientation.y;\n\t\tpose(2, 0) = odom.pose.pose.orientation.y;\n\t\tpose(2, 1) = -odom.pose.pose.orientation.x;\n\t\tpose(2, 2) = odom.pose.pose.orientation.w;\n\t\tpose(2, 3) = odom.pose.pose.orientation.z;\n\t\tpose(3, 0) = odom.pose.pose.position.x;\n\t\tpose(3, 1) = odom.pose.pose.position.y;\n\t\tpose(3, 2) = odom.pose.pose.position.z;\n\n\t\t// Transform the local map to the global frame\n\t\tpcl::transformPointCloud(laser_cloud, laser_cloud, pose);\n\t}\n\n\t// Update the occupancy map\n\tmap_update(laser_cloud);\n}", "CodeBleu_score": 44.72667525076792}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t//Convert laser scan to point cloud\n\tsensor_msgs::PointCloud2 cloud;\n\tprojector_.transformLaserScanToPointCloud(map_frame_, *local_point, cloud, tfListener_);\n\n\t//Convert point cloud to pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> pcl_cloud;\n\tpcl::fromROSMsg(cloud, pcl_cloud);\n\n\t//Merge local map with odometry data\n\tif (!simulation_mode_) {\n\t\t//Convert odometry to a transform\n\t\ttf::Transform odom_tf;\n\t\ttf::poseMsgToTF(odom.pose.pose, odom_tf);\n\n\t\t//Transform local map into the global map frame\n\t\tpcl::PointCloud<pcl::PointXYZ> transformed_cloud;\n\t\tpcl_ros::transformPointCloud(map_frame_, odom_tf, pcl_cloud, transformed_cloud);\n\n\t\t//Merge local map with global map\n\t\tpcl::PointCloud<pcl::PointXYZ> merged_cloud;\n\t\tpcl::concatenatePointCloud(transformed_cloud, global_map_, merged_cloud);\n\t\tglobal_map_ = merged_cloud;\n\t}\n\telse {\n\t\tglobal_map_ = pcl_cloud;\n\t}\n\n\t//Convert pcl::PointCloud to PointCloud2\n\tsensor_msgs::PointCloud2 cloud2;\n\tpcl::toROSMsg(global_map_, cloud2);\n\tcloud2.header.frame_id = map_frame_;\n\n\t//Publish point cloud\n\tmap_pub_.publish(cloud2);\n}", "CodeBleu_score": 41.38773880510019}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert the laser scan to a PointCloud2 format\n\tsensor_msgs::PointCloud2 cloud;\n\tprojector_.projectLaser(*local_point, cloud);\n\tpcl::PointCloud<pcl::PointXYZ> pcl_cloud;\n\tpcl::fromROSMsg(cloud, pcl_cloud);\n\t// Convert the PointCloud2 to a pcl::PointCloud\n\t// If in simulation mode, use the laser scan data as the local map\n\tif (simulation_mode_) {\n\t\t// Convert the PointCloud2 to a pcl::PointCloud\n\t\tpcl::PointCloud<pcl::PointXYZ> pcl_cloud;\n\t\tpcl::fromROSMsg(cloud, pcl_cloud);\n\t\t// Merge the local map with the provided odometry data\n\t\tpcl::PointCloud<pcl::PointXYZ> odom_cloud;\n\t\tpcl::transformPointCloud(pcl_cloud, odom_cloud, odom_transform(odom));\n\t\t// Merge the local map with the provided odometry data\n\t\tpcl::PointCloud<pcl::PointXYZ> local_map;\n\t\tpcl::transformPointCloud(odom_cloud, local_map, odom_transform(odom));\n\t\t// Update the occupancy map\n\t\tmap_update(local_map);\n\t}\n\t// If not in simulation mode, use the provided odometry data as the local map\n\telse {\n\t\t// Merge the local map with the provided odometry data\n\t\tpcl::PointCloud<pcl::PointXYZ> odom_cloud;\n\t\tpcl::transformPointCloud(pcl_cloud, odom_cloud, odom_transform(odom));\n\t\t// Merge the local map with the provided odometry data\n\t\tpcl::PointCloud<pcl::PointXYZ> local_map;\n\t\tpcl::transformPointCloud(odom_cloud, local_map, odom_transform(odom));\n\t\t// Update the occupancy map\n\t\tmap_update(local_map);\n\t}\n}", "CodeBleu_score": 46.909407795906674}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// convert the global point cloud map to a ROS message\n\tsensor_msgs::PointCloud2 global_pcl_msg;\n\tpcl::toROSMsg(*global_pcl, global_pcl_msg);\n\t// set the frame ID of the point cloud message\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\t// publish the global point cloud message\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// convert the inflated point cloud to a ROS message\n\tsensor_msgs::PointCloud2 inflate_pcl_msg;\n\tpcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n\t// set the frame ID of the inflated point cloud message\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\t// publish the inflated point cloud message\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 63.660760928112914}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t//publish the global point cloud map\n\tpcl::PointCloud<pcl::PointXYZI>::Ptr global_pcl_msg(new pcl::PointCloud<pcl::PointXYZI>);\n\tglobal_pcl_msg->header.frame_id = \"world\";\n\tglobal_pcl_msg->header.stamp = ros::Time::now();\n\tglobal_pcl_msg->width = global_pcl_map.width;\n\tglobal_pcl_msg->height = global_pcl_map.height;\n\tglobal_pcl_msg->points.resize(global_pcl_map.width * global_pcl_map.height);\n\tfor (size_t i = 0; i < global_pcl_map.width * global_pcl_map.height; ++i) {\n\t\tglobal_pcl_msg->points[i].x = global_pcl_map.points[i].x;\n\t\tglobal_pcl_msg->points[i].y = global_pcl_map.points[i].y;\n\t\tglobal_pcl_msg->points[i].z = global_pcl_map.points[i].z;\n\t\tglobal_pcl_msg->points[i].intensity = global_pcl_map.points[i].intensity;\n\t}\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t//publish the inflated point cloud map\n\tpcl::PointCloud<pcl::PointXYZI>::Ptr inflated_pcl_msg(new pcl::PointCloud<pcl::PointXYZI>);\n\tinflated_pcl_msg->header.frame_id = \"world\";\n\tinflated_pcl_msg->header.stamp = ros::Time::now();\n\tinflated_pcl_msg->width = inflated_pcl_map.width;\n\tinflated_pcl_msg->height = inflated_pcl_map.height;\n\tinflated_pcl_msg->points.resize(inflated_pcl_map.width * inflated_pcl_map.height);\n\tfor (size_t i = 0; i < inflated_pcl_map.width * inflated_pcl_map.height; ++i) {\n\t\tinflated_pcl_msg->points[i].x = inflated_pcl_map.points[", "CodeBleu_score": 47.76138353217705}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// publish the global point cloud map\n\tpcl::PointCloud<pcl::PointXYZ> pcl_global_map;\n\tpcl::fromROSMsg(global_map, pcl_global_map);\n\tpcl_global_map.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(pcl_global_map);\n\n\t// publish the inflated point cloud map\n\tpcl::PointCloud<pcl::PointXYZ> pcl_inflated_map;\n\tpcl::fromROSMsg(inflated_map, pcl_inflated_map);\n\tpcl_inflated_map.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(pcl_inflated_map);\n}", "CodeBleu_score": 54.448600047834674}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (sensor_ready) {\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\t\tpcl::fromROSMsg(*msg, cloud);\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered;\n\t\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\t\tsor.setInputCloud(cloud.makeShared());\n\t\tsor.setLeafSize(0.05f, 0.05f, 0.05f);\n\t\tsor.filter(cloud_filtered);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud_filtered));\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_transformed_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::transformPointCloud(*cloud_filtered_ptr, *cloud_transformed_ptr, sensor_transform);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_transformed_ptr_no_ground(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PassThrough<pcl::PointXYZ> pass;\n\t\tpass.setInputCloud(cloud_transformed_ptr);\n\t\tpass.setFilterFieldName(\"z\");\n\t\tpass.setFilterLimits(0.2, 100.0);\n\t\tpass.filter(*cloud_transformed_ptr_no_ground);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_transformed_ptr_no_ground_no_ceiling(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpass.setInputCloud(cloud_transformed_ptr_no_ground);\n\t\tpass.setFilterFieldName(\"z\");\n\t\tpass.setFilterLimits(-100.0, 1.5);\n\t\tpass.filter(*cloud_transformed_ptr_no_ground_no_ceiling);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_transformed_ptr_no_ground_no_ceiling_no_walls(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpass.setInputCloud(cloud_transformed_ptr_no_ground_no_ceiling);\n\t\tpass.setFilterFieldName(\"x\");\n\t\tpass.setFilterLimits(-10.0, 10.0);\n\t\tpass.filter(*cloud_transformed_", "CodeBleu_score": 35.898098458967034}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Lidar callback\");\n\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\t\tpcl::fromROSMsg(*msg, cloud);\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_2;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_3;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_4;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_5;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_6;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_7;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_8;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_9;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_10;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_11;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_12;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_13;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_14;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_15;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_16;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_17;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_18;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_19;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_20;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_21;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_22;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_23;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_24;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_25;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered_26;\n\t", "CodeBleu_score": 39.02166411957574}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\tif (!sensor_ready) {\n\t\tif (odom_ready) {\n\t\t\tsensor_ready = true;\n\t\t}\n\t}\n\tif (sensor_ready) {\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb", "CodeBleu_score": 44.14334547904535}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get the current time\n\tconst ros::Time current_time = ros::Time::now();\n\n\t// Get the current pose of the robot\n\tconst Eigen::VectorXd current_pose = getPose();\n\n\t// Get the desired pose of the robot\n\tconst Eigen::VectorXd desired_pose = getDesiredPose();\n\n\t// Compute the target foot positions based on the desired pose\n\tconst Eigen::VectorXd target_foot_positions = computeTargetFootPositions(current_pose, desired_pose);\n\n\t// Compute the velocity commands for the legs\n\tconst Eigen::VectorXd leg_velocities = computeLegVelocities(target_foot_positions);\n\n\t// Compute the target joint positions\n\tconst Eigen::VectorXd target_joint_positions = computeTargetJointPositions(leg_velocities);\n\n\t// Publish the foot contact information\n\tpublishFootContactInformation();\n\n\t// Publish the target joint positions\n\tpublishTargetJointPositions(target_joint_positions);\n}", "CodeBleu_score": 40.625303736116024}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get current time\n\tconst ros::Time time_now = ros::Time::now();\n\n\t// Get current pose of the robot\n\tconst Eigen::Vector3d& position = robot_state_->get_position();\n\tconst Eigen::Vector3d& velocity = robot_state_->get_velocity();\n\tconst Eigen::Quaterniond& orientation = robot_state_->get_orientation();\n\tconst Eigen::Vector3d& angular_velocity = robot_state_->get_angular_velocity();\n\n\t// Get desired pose of the robot\n\tconst Eigen::Vector3d& desired_position = robot_state_->get_desired_position();\n\tconst Eigen::Quaterniond& desired_orientation = robot_state_->get_desired_orientation();\n\n\t// Get desired velocity of the robot\n\tconst Eigen::Vector3d& desired_velocity = robot_state_->get_desired_velocity();\n\tconst Eigen::Vector3d& desired_angular_velocity = robot_state_->get_desired_angular_velocity();\n\n\t// Get desired pose of the robot\n\tconst Eigen::Vector3d& desired_position_world = robot_state_->get_desired_position_world();\n\tconst Eigen::Quaterniond& desired_orientation_world = robot_state_->get_desired_orientation_world();\n\n\t// Get desired velocity of the robot\n\tconst Eigen::Vector3d& desired_velocity_world = robot_state_->get_desired_velocity_world();\n\tconst Eigen::Vector3d& desired_angular_velocity_world = robot_state_->get_desired_angular_velocity_world();\n\n\t// Get desired pose of the robot\n\tconst Eigen::Vector3d& desired_position_body = robot_state_->get_desired_position_body();\n\tconst Eigen::Quaterniond& desired_orientation_body = robot_state_->get_desired_orientation_body();\n\n\t// Get desired velocity of the robot\n\tconst Eigen::Vector3d& desired_velocity_body = robot_state_->get_desired_velocity_body();\n\tconst Eigen::Vector3d& desired_angular_velocity_body = robot_state_->get_desired_angular_velocity_body();\n\n\t// Get desired pose of the robot\n\tconst Eigen::Vector3d& desired_position_foot = robot_state_->get_desired_", "CodeBleu_score": 20.608195836147747}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get current time\n\tros::Time current_time = ros::Time::now();\n\t// Get current pose of robot\n\tgeometry_msgs::PoseStamped pose_msg;\n\tpose_msg.header.stamp = current_time;\n\tpose_msg.header.frame_id = \"world\";\n\tpose_msg.pose = pose_;\n\t// Get current foot positions\n\tstd::vector<geometry_msgs::PoseStamped> foot_positions;\n\tfoot_positions.resize(4);\n\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_positions[i].header.stamp = current_time;\n\t\tfoot_positions[i].header.frame_id = \"world\";\n\t\tfoot_positions[i].pose = foot_positions_[i];\n\t}\n\t// Get current joint positions\n\tstd::vector<double> joint_positions;\n\tjoint_positions.resize(12);\n\tfor (int i = 0; i < 12; i++) {\n\t\tjoint_positions[i] = joint_positions_[i];\n\t}\n\t// Get current foot contacts\n\tstd::vector<bool> foot_contacts;\n\tfoot_contacts.resize(4);\n\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contacts[i] = foot_contacts_[i];\n\t}\n\t// Compute target foot positions\n\tgeometry_msgs::PoseStamped target_pose_msg;\n\ttarget_pose_msg.header.stamp = current_time;\n\ttarget_pose_msg.header.frame_id = \"world\";\n\ttarget_pose_msg.pose = target_pose_;\n\tstd::vector<geometry_msgs::PoseStamped> target_foot_positions;\n\ttarget_foot_positions.resize(4);\n\tfor (int i = 0; i < 4; i++) {\n\t\ttarget_foot_positions[i].header.stamp = current_time;\n\t\ttarget_foot_positions[i].header.frame_id = \"world\";\n\t\ttarget_foot_positions[i].pose = target_foot_positions_[i];\n\t}\n\t// Compute target joint positions\n\tstd::vector<double> target", "CodeBleu_score": 39.9633983953681}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif(foot_contacts_publisher_ && foot_contacts_publisher_->getNumSubscribers() > 0) {\n\t\t// Create the message\n\t\tquadruped_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.header.frame_id = \"base_link\";\n\n\t\t// Populate the message\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tquadruped_msgs::ContactState contact_state;\n\t\t\tcontact_state.phase = gait_phase_[i];\n\t\t\tcontact_state.contact = foot_contacts[i];\n\t\t\tcontacts_msg.contacts.push_back(contact_state);\n\t\t}\n\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_->publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 49.900034089235085}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_ && foot_contacts_publisher_->getNumSubscribers() > 0) {\n\t\t// Create message\n\t\tquadruped_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.header.frame_id = \"world\";\n\t\tfor (int leg_id = 0; leg_id < 4; leg_id++) {\n\t\t\tcontacts_msg.contact_states.push_back(foot_contacts[leg_id]);\n\t\t}\n\t\t// Publish\n\t\tfoot_contacts_publisher_->publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 45.53426907978708}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_!= NULL) {\n\t\t// Create a new ContactsStamped message\n\t\trobot_msgs::ContactsStamped contacts_msg;\n\t\t// Populate the message\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.contacts.resize(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts[i].phase = gait_phase_[i];\n\t\t\tcontacts_msg.contacts[i].state = foot_contacts[i];\n\t\t}\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_->publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 54.888854736412775}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\t// Create a minimal joints message with the first 12 joint positions\n\tjoints_msg = Joints()\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tfor i in range(12):\n\t\tjoints_msg.position.append(joints.position[i])\n\n\t// Publish the minimal joints message\n\tself.joints_pub.publish(joints_msg)\n\n\t// Construct a joint trajectory message with the same positions and a specified duration\n\ttraj = JointTrajectory()\n\ttraj.header.stamp = rospy.Time.now()\n\ttraj.joint_names = self.joint_names\n\tpoint = JointTrajectoryPoint()\n\tpoint.positions = joints.position\n\tpoint.time_from_start = rospy.Duration(0.1)\n\ttraj.points.append(point)\n\n\t// Publish the joint trajectory message\n\tself.joints_traj_pub.publish(traj)\n}", "CodeBleu_score": 57.669604138110365}, {"code": "def joints_cmd_callback(self, joints){\n\t\t// create a minimal joints message with the first 12 joint positions\n\tjoints_msg = Joints()\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tjoints_msg.header.frame_id = \"base_link\"\n\tjoints_msg.position = joints.position[:12]\n\tself.joints_pub.publish(joints_msg)\n\n\t// construct a joint trajectory message with the same positions and a specified duration\n\ttraj = JointTrajectory()\n\ttraj.header.stamp = rospy.Time.now()\n\ttraj.header.frame_id = \"base_link\"\n\ttraj.joint_names = self.joint_names\n\tpoint = JointTrajectoryPoint()\n\tpoint.positions = joints.position[:12]\n\tpoint.time_from_start = rospy.Duration(0.001)\n\ttraj.points.append(point)\n\tself.traj_pub.publish(traj)\n}", "CodeBleu_score": 51.861628223510905}, {"code": "def joints_cmd_callback(self, joints){\n\t\t// Create a minimal joints message with the first 12 joint positions\n\tjoints_msg = Joints()\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tjoints_msg.position = joints.position[0:12]\n\n\t// Publish the joints message\n\tself.joints_pub.publish(joints_msg)\n\n\t// Create a joint trajectory message with the same positions\n\ttraj = JointTrajectory()\n\ttraj.header.stamp = rospy.Time.now()\n\ttraj.joint_names = self.joint_names\n\tpoint = JointTrajectoryPoint()\n\tpoint.positions = joints.position\n\tpoint.time_from_start = rospy.Duration(0.001)\n\ttraj.points.append(point)\n\n\t// Publish the joint trajectory message\n\tself.joint_traj_pub.publish(traj)\n}", "CodeBleu_score": 51.373780907601265}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tstd::string collision_name;\n\tstd::vector<std::string> collision_names;\n\tstd::vector<std::string> foot_names = {\"left_sole\", \"right_sole\"};\n\tstd::string link_name;\n\tstd::vector<std::string> link_names;\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tcollision_name = _msg->contact(i).collision1();\n\t\tboost::split(collision_names, collision_name, boost::is_any_of(\"::\"));\n\t\tlink_name = collision_names[collision_names.size() - 1];\n\t\tboost::split(link_names, link_name, boost::is_any_of(\"_\"));\n\t\tif (std::find(foot_names.begin(), foot_names.end(), link_names[0])!= foot_names.end()) {\n\t\t\tif (link_names[0] == \"left_sole\") {\n\t\t\t\tleft_foot_contact = true;\n\t\t\t}\n\t\t\telse if (link_names[0] == \"right_sole\") {\n\t\t\t\tright_foot_contact = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 43.33199553396453}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tstd::vector<std::string> contact_links;\n\tstd::vector<std::string> contact_links_split;\n\n\t// Initialize foot contact states to false\n\tfor (int i = 0; i < 4; i++) {\n\t\tcontact_states[i] = false;\n\t}\n\n\t// Split collision string to identify the contact link\n\tcontact_links = boost::split(contact_links, _msg->contact(0).collision1(), boost::is_any_of(\"/\"));\n\tcontact_links_split = boost::split(contact_links_split, contact_links[1], boost::is_any_of(\"_\"));\n\n\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (contact_links_split[0] == foot_links[i]) {\n\t\t\tcontact_states[i] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 49.45085498611559}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t//ROS_INFO(\"Contacts\");\n\n\t//Initialize foot contact states to false\n\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contact_state_[i] = false;\n\t}\n\n\t//For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t//Split the collision string to identify the contact link\n\t\tstd::vector<std::string> collision_vector;\n\t\tboost::split(collision_vector, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n\t\tstd::string collision_link = collision_vector[collision_vector.size() - 1];\n\n\t\t//If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (collision_link == foot_link_names_[j]) {\n\t\t\t\tfoot_contact_state_[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t//Publish the foot contact states\n\tchamp_msgs::ContactsStamped contact_msg;\n\tcontact_msg.header.stamp = ros::Time::now();\n\tcontact_msg.left_front_contact = foot_contact_state_[0];\n\tcontact_msg.right_front_contact = foot_contact_state_[1];\n\tcontact_msg.left_rear_contact = foot_contact_state_[2];\n\tcontact_msg.right_rear_contact = foot_contact_state_[3];\n\tcontact_pub_.publish(contact_msg);\n}", "CodeBleu_score": 61.08984596343123}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Check if controller is active\n\tif (!is_active_flag_) {\n\t\tfor (int i = 0; i < number_of_rotors_; ++i) {\n\t\t\t(*rotor_velocities)(i) = 0.0;\n\t\t}\n\t\treturn;\n\t}\n\n\t// Check if input and parameters are valid\n\tif (command_trajectory_ptr_ == nullptr ||\n\t\tcommand_trajectory_ptr_->get_reference_time() < 0.0) {\n\t\tfor (int i = 0; i < number_of_rotors_; ++i) {\n\t\t\t(*rotor_velocities)(i) = 0.0;\n\t\t}\n\t\treturn;\n\t}\n\n\t// Calculate the desired acceleration and angular acceleration\n\tEigen::Vector3d desired_acceleration = CalculateDesiredAcceleration();\n\tEigen::Vector3d desired_angular_acceleration = CalculateDesiredAngularAcceleration();\n\n\t// Project thrust onto the body z-axis\n\tdouble thrust_z = mass_ * (desired_acceleration(2) + gravity_constant_);\n\n\t// Combine angular acceleration and thrust\n\tEigen::Vector3d desired_acceleration_and_angular_acceleration(0.0, 0.0, thrust_z);\n\tdesired_acceleration_and_angular_acceleration += mass_ * desired_angular_acceleration;\n\n\t// Calculate rotor velocities\n\t*rotor_velocities = rotor_velocity_matrix_ * desired_acceleration_and_angular_acceleration;\n\n\t// Ensure non-negative values\n\tfor (int i = 0; i < number_of_rotors_; ++i) {\n\t\tif ((*rotor_velocities)(i) < 0.0) {\n\t\t\t(*rotor_velocities)(i) = 0.0;\n\t\t}\n\t}\n\n\t// Take the square root of each component\n\t*rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 46.44534753459827}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\tassert(rotor_velocities->size() == kRotorCount);\n\n\tif (!is_active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\tEigen::Vector3d acceleration = Eigen::Vector3d::Zero();\n\tEigen::Vector3d angular_acceleration = Eigen::Vector3d::Zero();\n\n\tCalculateDesiredAcceleration(&acceleration, &angular_acceleration);\n\n\tEigen::Vector3d thrust = mass_ * acceleration;\n\tthrust(2) += mass_ * kGravity;\n\n\tEigen::Vector3d moment = inertia_ * angular_acceleration;\n\n\tEigen::Vector4d thrust_moment;\n\tthrust_moment << thrust, moment;\n\n\tEigen::Matrix4d rotor_velocities_matrix = rotor_velocities_matrix_;\n\trotor_velocities_matrix.col(3) = thrust_moment;\n\n\t*rotor_velocities = rotor_velocities_matrix.inverse() * thrust_moment;\n\n\tfor (int i = 0; i < kRotorCount; ++i) {\n\t\tif (rotor_velocities->coeffRef(i) < 0) {\n\t\t\trotor_velocities->coeffRef(i) = 0;\n\t\t}\n\t\trotor_velocities->coeffRef(i) = sqrt(rotor_velocities->coeffRef(i));\n\t}\n}", "CodeBleu_score": 48.99889523013127}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// TODO: Calculate the desired rotor velocities here\n\tif (!is_active_flag) {\n\t\tfor (int i = 0; i < number_of_rotors_; ++i) {\n\t\t\t(*rotor_velocities)(i) = 0.0;\n\t\t}\n\t} else {\n\t\tEigen::Vector3d acceleration_command;\n\t\tEigen::Vector3d angular_acceleration_command;\n\t\tEigen::Vector3d thrust_command;\n\t\tEigen::Vector3d angular_thrust_command;\n\t\tEigen::Vector3d thrust_vector;\n\t\tEigen::Vector3d angular_thrust_vector;\n\t\tEigen::Vector3d thrust_vector_rotated;\n\t\tEigen::Vector3d angular_thrust_vector_rotated;\n\t\tEigen::Vector3d thrust_vector_final;\n\t\tEigen::Vector3d angular_thrust_vector_final;\n\n\t\t// Get the acceleration command\n\t\tacceleration_command = GetDesiredAcceleration();\n\n\t\t// Get the angular acceleration command\n\t\tangular_acceleration_command = GetDesiredAngularAcceleration();\n\n\t\t// Get the thrust command\n\t\tthrust_command = acceleration_command * mass_;\n\n\t\t// Get the angular thrust command\n\t\tangular_thrust_command = angular_acceleration_command * inertia_(2, 2);\n\n\t\t// Get the thrust vector\n\t\tthrust_vector = thrust_command * Eigen::Vector3d::UnitZ();\n\n\t\t// Get the angular thrust vector\n\t\tangular_thrust_vector = angular_thrust_command * Eigen::Vector3d::UnitZ();\n\n\t\t// Rotate the thrust vector\n\t\tthrust_vector_rotated = R_I_B_.transpose() * thrust_vector;\n\n\t\t// Rotate the angular thrust vector\n\t\tangular_thrust_vector_rotated = R_I_B_.transpose() * angular_thrust_vector;\n\n\t\t// Add the thrust vector and angular thrust vector\n\t\tthrust_vector_final = thrust_vector_rotated + angular_thrust_vector_rotated;\n\n\t\t// Get the thrust vector\n\t\tangular_thrust_vector_final = R_I_B_.transpose() * angular_thrust_vector;\n\n\t\t// Compute the rotor velocities\n\t\tEigen::MatrixXd rotor_velocities_", "CodeBleu_score": 37.89732756166029}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Get the current position and velocity.\n\tEigen::Vector3d current_position = odometry_data_->position_W;\n\tEigen::Vector3d current_velocity = odometry_data_->velocity_W;\n\n\t// Compute the position and velocity errors.\n\tEigen::Vector3d position_error = command_trajectory_->position - current_position;\n\tEigen::Vector3d velocity_error = command_trajectory_->velocity - current_velocity;\n\n\t// Transform the vehicle's velocity to the world frame.\n\tEigen::Vector3d current_velocity_W = odometry_data_->orientation_W_B.toRotationMatrix() * current_velocity;\n\n\t// Compute the velocity error in the world frame.\n\tEigen::Vector3d velocity_error_W = command_trajectory_->velocity_W - current_velocity_W;\n\n\t// Compute the desired acceleration.\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error_W;\n\n\t// Adjust for vehicle mass, gravity, and commanded acceleration.\n\t*acceleration += Eigen::Vector3d(0, 0, -mass_ * gravity_) + command_trajectory_->acceleration;\n}", "CodeBleu_score": 47.603364914736254}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Get the position and velocity errors\n\tEigen::Vector3d position_error = command_trajectory_.position() - odometry_.position_W;\n\tEigen::Vector3d velocity_error = command_trajectory_.velocity() - odometry_.velocity_W;\n\n\t// Transform the velocity error to the world frame\n\tEigen::Vector3d velocity_error_W = odometry_.orientation_W_B.inverse() * velocity_error;\n\n\t// Compute the desired acceleration\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error_W + command_trajectory_.acceleration();\n\t*acceleration = *acceleration / mass_;\n\n\t// Adjust for gravity\n\t*acceleration = *acceleration - Eigen::Vector3d(0, 0, 9.81);\n\n\t// Adjust for commanded acceleration\n\t*acceleration = *acceleration + command_trajectory_.acceleration();\n}", "CodeBleu_score": 40.93175937775083}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute position and velocity errors.\n\tEigen::Vector3d position_error = command_trajectory_.position() - odometry_.position_W;\n\tEigen::Vector3d velocity_error = command_trajectory_.velocity() - odometry_.velocity_W;\n\n\t// Transform velocity error to world frame.\n\tvelocity_error = odometry_.orientation_W_B.toRotationMatrix() * velocity_error;\n\n\t// Calculate desired acceleration.\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error;\n\n\t// Adjust for mass and gravity.\n\t*acceleration += Eigen::Vector3d(0, 0, -mass_ * gravity_);\n\n\t// Add commanded acceleration.\n\t*acceleration += command_trajectory_.acceleration();\n}", "CodeBleu_score": 36.93297130641785}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Check if the input is valid\n\tassert(rotor_velocities!= nullptr);\n\tassert(rotor_velocities->size() == 4);\n\n\t// Ensure the input is valid\n\tif (rotor_velocities == nullptr) {\n\t\treturn;\n\t}\n\n\t// Resizing the rotor velocities vector to match the number of rotors\n\trotor_velocities->resize(4);\n\n\t// Calculating the desired angular acceleration\n\tEigen::Vector3d angular_acceleration = CalculateAngularAcceleration();\n\n\t// Combining the angular acceleration and thrust reference into a single vector\n\tEigen::Vector4d angular_acceleration_thrust;\n\tangular_acceleration_thrust << angular_acceleration, thrust_reference_;\n\n\t// Calculating the rotor velocities by multiplying with a predefined matrix, ensuring they are at least one, and taking the square root of each component\n\t*rotor_velocities = rotor_velocity_gain_.inverse() * angular_acceleration_thrust;\n\tfor (int i = 0; i < 4; i++) {\n\t\t(*rotor_velocities)(i) = std::max((*rotor_velocities)(i), 1.0);\n\t\t(*rotor_velocities)(i) = std::sqrt((*rotor_velocities)(i));\n\t}\n}", "CodeBleu_score": 50.93254983914392}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Check if the input is valid.\n\tif (!rotor_velocities || rotor_velocities->size()!= kRotorVelocityCount) {\n\t\tstd::cout << \"Invalid rotor velocities.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Calculate the desired angular acceleration.\n\tEigen::Vector3d angular_acceleration_command = CalculateAngularAccelerationCommand();\n\n\t// Combine the angular acceleration and thrust reference into a single vector.\n\tEigen::VectorXd desired_angular_acceleration_thrust(kRotorVelocityCount);\n\tdesired_angular_acceleration_thrust << angular_acceleration_command, thrust_reference_;\n\n\t// Resize the rotor velocities vector to match the number of rotors.\n\trotor_velocities->resize(kRotorVelocityCount);\n\n\t// Calculate the rotor velocities.\n\t*rotor_velocities = matrix_rotor_velocities_from_angular_acceleration_thrust_ * desired_angular_acceleration_thrust;\n\n\t// Ensure the rotor velocities are at least one.\n\tfor (int i = 0; i < kRotorVelocityCount; ++i) {\n\t\tif ((*rotor_velocities)(i) < 1.0) {\n\t\t\t(*rotor_velocities)(i) = 1.0;\n\t\t}\n\t}\n\n\t// Take the square root of each component.\n\t*rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 52.69255057368984}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\tassert(rotor_velocities->size() == rotor_velocities_command_.size());\n\n\t// Get the angular acceleration from the attitude controller\n\tEigen::Vector3d angular_acceleration = attitude_controller_.getAngularAcceleration();\n\n\t// Combine the angular acceleration and thrust reference into a single vector\n\tEigen::Vector4d angular_acceleration_thrust_reference;\n\tangular_acceleration_thrust_reference << angular_acceleration, thrust_reference_;\n\n\t// Calculate the rotor velocities\n\trotor_velocities_command_ = rotor_velocity_matrix_ * angular_acceleration_thrust_reference;\n\n\t// Ensure the rotor velocities are at least one\n\trotor_velocities_command_ = rotor_velocities_command_.cwiseMax(Eigen::VectorXd::Ones(rotor_velocities_command_.rows()));\n\n\t// Take the square root of each component\n\trotor_velocities_command_ = rotor_velocities_command_.cwiseSqrt();\n\n\t// Set the output vector\n\t*rotor_velocities = rotor_velocities_command_;\n}", "CodeBleu_score": 47.5740512153716}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n    if start_index == -1 or end_index == -1:\n        return None\n    else:\n        sliced_object = copy.deepcopy(self)\n        sliced_object.time = self.time[start_index:end_index]\n        sliced_object.data = self.data[start_index:end_index]\n        sliced_object.header = self.header[start_index:end_index]\n        sliced_object.child_frame_id = self.child_frame_id[start_index:end_index]\n        return sliced_object\n\n", "CodeBleu_score": 20.27921870437868}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n    sliced_object = copy.deepcopy(self)\n    sliced_object.time = self.time[start_index:end_index]\n    sliced_object.pose = self.pose[start_index:end_index]\n    sliced_object.velocity = self.velocity[start_index:end_index]\n    sliced_object.acceleration = self.acceleration[start_index:end_index]\n    sliced_object.jerk = self.jerk[start_index:end_index]\n    sliced_object.snap = self.snap[start_index:end_index]\n    sliced_object.crackle = self.crackle[start_index:end_index]\n    sliced_object.pop = self.pop[start_index:end_index]\n    sliced_object.yaw = self.yaw[start_index:end_index]\n    sliced_object.pitch = self.pitch[start_index:end_index]\n    sliced_object.roll = self.roll[start_index:end_index]\n    sliced_object.yaw_rate = self.yaw_rate[start_index:end_index]\n    sliced_object.pitch_rate = self.pitch_rate[start_index:end_index]\n    sliced_object.roll_rate = self.roll_rate[start_index:end_index]\n    sliced_object.yaw_acceleration = self.yaw_acceleration[start_index:end_index]\n    sliced_object.pitch_acceleration = self.pitch_acceleration[start_index:end_index]\n    sliced_object.roll_acceleration = self.roll_acceleration[start_index:end_index]\n    sliced_object.yaw_jerk = self.yaw_jerk[start_index:end_index]\n    sliced_object.pitch_jerk = self.pitch_jerk[start_index:end_index]\n    sliced_object.roll_jerk = self.roll_jerk[start_index:end_index]\n    return sliced_object\n\n", "CodeBleu_score": 13.726851621666508}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n    sliced_object = copy.deepcopy(self)\n    sliced_object.times = self.times[start_index:end_index]\n    sliced_object.positions = self.positions[start_index:end_index]\n    sliced_object.velocities = self.velocities[start_index:end_index]\n    sliced_object.accelerations = self.accelerations[start_index:end_index]\n    sliced_object.quaternions = self.quaternions[start_index:end_index]\n    sliced_object.angular_velocities = self.angular_velocities[start_index:end_index]\n    sliced_object.angular_accelerations = self.angular_accelerations[start_index:end_index]\n    sliced_object.linear_accelerations = self.linear_accelerations[start_index:end_index]\n    return sliced_object\n", "CodeBleu_score": 16.79746352718487}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation from the waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert the rotation to Euler angles\n    euler_angles = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    yaw = euler_angles[2]\n\n    # Create a Point object for the position\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if len(self.waypoints) == 0 or (self.waypoints[-1]!= point or self.yaws[-1]!= yaw):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.yaws.append(yaw)\n        self.waypoint_times.append(msg_time)\n        self.bag_times.append(bag_time)\n\n", "CodeBleu_score": 25.305419062183404}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert rotation to Euler angles\n    roll, pitch, yaw = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if len(self.waypoints) > 0 and (point.x!= self.waypoints[-1].x or point.y!= self.waypoints[-1].y or yaw!= self.yaws[-1]):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.yaws.append(yaw)\n        self.waypoint_times.append(msg_time)\n        self.bag_times.append(bag_time)\n\n", "CodeBleu_score": 25.445402231658644}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n\n    # Extract position and rotation\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert rotation to Euler angles\n    euler_angles = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    yaw = euler_angles[2]\n\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint is not None and (point.x!= self.last_waypoint.x or point.y!= self.last_waypoint.y or yaw!= self.last_waypoint.yaw):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.waypoints_yaw.append(yaw)\n        self.waypoints_time.append(msg_time - bag_time)\n        self.waypoints_bag_time.append(msg_time)\n\n    # Update the last waypoint\n    self.last_waypoint = point\n\n", "CodeBleu_score": 27.31989364627589}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_linear_accel_x.append(msg.linear_acceleration.x)\n        self.imu_linear_accel_y.append(msg.linear_acceleration.y)\n        self.imu_linear_accel_z.append(msg.linear_acceleration.z)\n        self.imu_linear_accel_time.append(msg.header.stamp.secs)\n        self.imu_linear_accel_bag_time.append(bag_time)\n\n", "CodeBleu_score": 31.034448826232904}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 10**-9)\n        self.imu_bag_time.append(bag_time)\n        self.imu_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acceleration_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 32.31202616925864}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_linear_accel_x.append(msg.linear_acceleration.x)\n        self.imu_linear_accel_y.append(msg.linear_acceleration.y)\n        self.imu_linear_accel_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n\n", "CodeBleu_score": 32.02310505360378}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure(figsize=(10, 7))\n    fig.suptitle(self.name)\n    ax = fig.add_subplot(111)\n    ax.plot(self.accel_x_time, self.accel_x, 'r-', label='x')\n    ax.plot(self.accel_y_time, self.accel_y, 'g-', label='y')\n    ax.plot(self.accel_z_time, self.accel_z, 'b-', label='z')\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    ax.legend()\n    if self.save_plots:\n        filename = f\"{self.plot_prefix}{plot_suffix}.png\"\n        fig.savefig(filename)\n        print(f\"Saved plot to {filename}\")\n\n", "CodeBleu_score": 31.80266407022326}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.save_plots:\n        filename = self.plot_prefix + \"_accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot(self.time, self.accel_x, \"r\", label=\"x\")\n    ax.plot(self.time, self.accel_y, \"g\", label=\"y\")\n    ax.plot(self.time, self.accel_z, \"b\", label=\"z\")\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    ax.legend()\n\n    if self.save_plots:\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 40.77040113410322}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure and set the title\n    figure = pyplot.figure()\n    figure.suptitle('Accelerations')\n\n    # Create a subplot for accelerations\n    accelerations_subplot = figure.add_subplot(111)\n\n    # Plot the x, y, and z components of each acceleration dataset\n    for acceleration_dataset in self.acceleration_datasets:\n        accelerations_subplot.plot(acceleration_dataset.time_array, acceleration_dataset.x_array, label='x')\n        accelerations_subplot.plot(acceleration_dataset.time_array, acceleration_dataset.y_array, label='y')\n        accelerations_subplot.plot(acceleration_dataset.time_array, acceleration_dataset.z_array, label='z')\n\n    # Add labels for the x and y axes\n    accelerations_subplot.set_xlabel('Time (s)')\n    accelerations_subplot.set_ylabel('Acceleration (m/s^2)')\n\n    # Add a legend\n    accelerations_subplot.legend()\n\n    # If saving plots is enabled, save the plot as a PNG file\n    if self.save_plots:\n        filename = f'accelerations{plot_suffix}.png'\n        figure.savefig(filename)\n\n", "CodeBleu_score": 31.902376798949287}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) > 1:\n        for i in range(0, len(pose_indeces)):\n            for j in range(i+1, len(pose_indeces)):\n                compare_two_xyz(self, pose_indeces[i], pose_indeces[j])\n    else:\n        print \"ERROR: Not enough pose indices to compare.\"\n\n", "CodeBleu_score": 33.67567930571216}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 27.833386770158015}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print('Error: compare_positions requires at least two pose indices')\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 40.26660960183388}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench.keys():\n        if start_time <= collision <= end_time:\n            collision_times.append(collision)\n    return collision_times\n\n", "CodeBleu_score": 40.08422754577043}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.header.stamp.to_sec() <= end_time:\n            collision_times.append(collision.header.stamp.to_sec())\n    return collision_times\n\n", "CodeBleu_score": 41.348198905525855}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 35.848869058795394}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    abs_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 28.605689571937422}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    abs_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 28.605689571937422}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    abs_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 28.605689571937422}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\tif (data == NULL) {\n\t\treturn;\n\t}\n\n\tconst float multiplier = 1.0 / 1000.0;\n\tconst float bad_point = 0.0;\n\n\tconst float rms_noise = 0.0000001;\n\n\tEigen::VectorXf noise(width * height);\n\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tnoise(i) = rms_noise * random_generator_.gaussian(0.0, 1.0);\n\t}\n\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tif (data[i]!= bad_point) {\n\t\t\tdata[i] = data[i] + noise(i) * multiplier;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.907236902785996}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\tif (data == nullptr) {\n\t\treturn;\n\t}\n\n\tfloat multiplier = 0.000001 * (float) width / (float) height;\n\tEigen::VectorXf depth_data(width * height);\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tdepth_data(i) = data[i];\n\t}\n\n\tfloat rms_noise = sqrt(2 * multiplier * multiplier * depth_data.mean() *\n\t\t\tdepth_data.mean());\n\tfloat noise_value = 0.0;\n\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tif (depth_data(i) > 0.0 && depth_data(i) < 10.0) {\n\t\t\tnoise_value = rms_noise * randn(generator);\n\t\t\tdata[i] = depth_data(i) + noise_value;\n\t\t} else {\n\t\t\tdata[i] = bad_point_value;\n\t\t}\n\t}\n}", "CodeBleu_score": 48.18192698988631}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\tif (data == nullptr) {\n\t\treturn;\n\t}\n\n\tconst float multiplier = 1.0f / 1000.0f;\n\tconst float rms_noise = 0.001f;\n\n\tconst uint32_t num_pixels = width * height;\n\tEigen::VectorXf noise(num_pixels);\n\n\t// Compute noise values\n\tfor (uint32_t i = 0; i < num_pixels; ++i) {\n\t\tnoise[i] = rms_noise * Randn();\n\t}\n\n\t// Apply noise\n\tfor (uint32_t y = 0; y < height; ++y) {\n\t\tfor (uint32_t x = 0; x < width; ++x) {\n\t\t\tconst uint32_t index = y * width + x;\n\n\t\t\tconst float value = data[index] * multiplier;\n\n\t\t\tif (value < min_depth_ || value > max_depth_) {\n\t\t\t\tdata[index] = bad_point_value_;\n\t\t\t} else {\n\t\t\t\tdata[index] = (value + noise[index]) * 1000.0f;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.84129752340538}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get current simulation time\n\tros::Time current_time = ros::Time::now();\n\n\t// Write trajectory message to bag file\n\tbag_.write(trajectory_namespace_ + \"/\" + trajectory_topic_, current_time, *trajectory_msg);\n}", "CodeBleu_score": 41.94337446270424}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time and convert it to ROS time\n\tros::Time current_time(ros::Time::now());\n\n\t// Write the trajectory message to a bag file using the specified namespace and waypoint topic\n\twaypoint_bag_.write(waypoint_topic_namespace_, current_time, *trajectory_msg);\n}", "CodeBleu_score": 35.74923565836489}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get current time.\n\tcommon::Time sim_time = world_->GetSimTime();\n\tros::Time ros_time(sim_time.sec, sim_time.nsec);\n\n\t// Write message to bag file.\n\tbag_.write(waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 55.46026981800172}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert simulation time to ROS time.\n\tros::Time time(now.sec, now.nsec);\n\n\t// Prepare a message for actuator velocities.\n\tmav_msgs::ActuatorsPtr msg(new mav_msgs::Actuators);\n\tmsg->angular_velocities.resize(motor_joint_names_.size());\n\n\t// Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message.\n\tfor (int i = 0; i < motor_joint_names_.size(); i++) {\n\t\tphysics::JointPtr motor_joint = model_->GetJoint(motor_joint_names_[i]);\n\t\tdouble motor_velocity = motor_joint->GetVelocity(0);\n\t\tmsg->angular_velocities[i] = motor_velocity / motor_velocity_slowdown_factor_;\n\t}\n\n\t// Set the message timestamp and write the data to a bag file using the specified namespace and motor topic.\n\tmsg->header.stamp = time;\n\tmotor_bag_.write(motor_topic_, msg);\n}", "CodeBleu_score": 47.490176066259174}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Get the current simulation time\n\tros::Time sim_time = ros::Time::now();\n\t// Create a message for actuator velocities\n\tmav_msgs::ActuatorsPtr actuator_velocities_msg(new mav_msgs::Actuators);\n\t// Iterate through the motor joints\n\tfor (int i = 0; i < motor_joints_.size(); i++) {\n\t\t// Get the current joint velocity\n\t\tdouble joint_velocity = motor_joints_[i]->GetVelocity(0);\n\t\t// Convert the joint velocity to the slowed-down rotational velocity\n\t\tdouble rotational_velocity = joint_velocity * motor_velocity_ratio_;\n\t\t// Assign the rotational velocity to the actuator velocities message\n\t\tactuator_velocities_msg->angular_velocities.push_back(rotational_velocity);\n\t}\n\t// Set the message timestamp\n\tactuator_velocities_msg->header.stamp = sim_time;\n\t// Write the message to the bag file using the specified namespace and motor topic\n\tmotor_velocity_bag_writer_.Write(motor_velocity_topic_namespace_, actuator_velocities_msg);\n}", "CodeBleu_score": 41.494836319239724}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert simulation time to ROS time\n\tros::Time ros_time(now.sec, now.nsec);\n\t// Prepare a message for actuator velocities\n\tmav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators());\n\t// Iterate through the motor joints\n\tfor (int i = 0; i < motor_joint_names_.size(); i++) {\n\t\t// Calculate the slowed-down rotational velocities\n\t\tdouble rot_vel = motor_joint_ptrs_[i]->GetVelocity(0);\n\t\tdouble motor_vel = rot_vel * motor_rotor_velocity_slowdown_factors_[i];\n\t\t// Assign the motor velocities to the message\n\t\tactuator_msg->angular_velocities.push_back(motor_vel);\n\t}\n\t// Set the message timestamp\n\tactuator_msg->header.stamp = ros_time;\n\t// Write the data to a bag file using the specified namespace and motor topic\n\tmotor_bag_.write(motor_topic_, actuator_msg);\n}", "CodeBleu_score": 40.97466577889281}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\tif (debug_printing_) {\n\t\tstd::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called.\" << std::endl;\n\t}\n\n\t// Convert normalized roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n\tdouble roll_angle = roll_pitch_yawrate_thrust_msg->roll() * roll_max_;\n\tdouble pitch_angle = roll_pitch_yawrate_thrust_msg->pitch() * pitch_max_;\n\tdouble rudder_angle = roll_pitch_yawrate_thrust_msg->yaw_rate() * rudder_max_;\n\n\t// Set the throttle value from the thrust message.\n\tdouble throttle = roll_pitch_yawrate_thrust_msg->thrust();\n\n\t// Set the control surface angles and throttle.\n\tSetControlSurfaceAngles(roll_angle, pitch_angle, rudder_angle);\n\tSetThrottle(throttle);\n}", "CodeBleu_score": 41.95151537248597}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_MAJOR_VERSION >= 7\n  double roll = roll_pitch_yawrate_thrust_msg->roll();\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch();\n  double yawrate = roll_pitch_yawrate_thrust_msg->yawrate();\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n#else\n  double roll = roll_pitch_yawrate_thrust_msg->roll;\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch;\n  double yawrate = roll_pitch_yawrate_thrust_msg->yawrate;\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust;\n#endif\n  if (debug_mode_) {\n    ROS_DEBUG_STREAM_NAMED(\"gazebo_fw_dynamics_plugin\",\n                           \"RollPitchYawrateThrustCallback: roll = \" << roll);\n    ROS_DEBUG_STREAM_NAMED(\"gazebo_fw_dynamics_plugin\",\n                           \"RollPitchYawrateThrustCallback: pitch = \" << pitch);\n    ROS_DEBUG_STREAM_NAMED(\"gazebo_fw_dynamics_plugin\",\n                           \"RollPitchYawrateThrustCallback: yawrate = \"\n                           << yawrate);\n    ROS_DEBUG_STREAM_NAMED(\"gazebo_fw_dynamics_plugin\",\n                           \"RollPitchYawrateThrustCallback: thrust = \"\n                           << thrust);\n  }\n  // Convert the normalized input values for roll, pitch, and yaw rate to\n  // control surface angles for ailerons, elevator, and rudder respectively.\n  aileron_ = roll * max_aileron_deflection_;\n  elevator_ = pitch * max_elevator_deflection_;\n  rudder_ = yawrate * max_rudder_deflection_;\n  // Set the throttle value from the thrust message.\n  throttle_ = thrust;\n}", "CodeBleu_score": 45.57226500320865}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_MAJOR_VERSION >= 8\n  this->current_time_ = this->world_->SimTime();\n#else\n  this->current_time_ = this->world_->GetSimTime();\n#endif\n\n  this->roll_ = roll_pitch_yawrate_thrust_msg->roll();\n  this->pitch_ = roll_pitch_yawrate_thrust_msg->pitch();\n  this->yaw_rate_ = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  this->thrust_ = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Convert roll, pitch, and yaw rate to control surface angles.\n  this->aileron_ = this->roll_ * this->max_aileron_;\n  this->elevator_ = this->pitch_ * this->max_elevator_;\n  this->rudder_ = this->yaw_rate_ * this->max_rudder_;\n\n  // Set the throttle value.\n  this->throttle_ = this->thrust_;\n\n  if (this->debug_) {\n    ROS_INFO_STREAM_THROTTLE(1, \"Received roll, pitch, yaw rate, and thrust: \"\n        << this->roll_ << \", \" << this->pitch_ << \", \" << this->yaw_rate_\n        << \", \" << this->thrust_);\n  }\n}", "CodeBleu_score": 31.67954094768553}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 9\n  // Gazebo 9 uses a different API for handling communication\n  // with the MAVLink plugin.\n  return;\n#endif\n  // We need to lock the mutex here because this function can be called from a\n  // different thread.\n  boost::mutex::scoped_lock scopedLock(this->mutex);\n\n  // Convert timeout to timeval structure\n  struct timeval tv;\n  tv.tv_sec = 0;\n  tv.tv_usec = _timeoutMs * 1000;\n\n  // Create file descriptor sets\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(this->fd, &readfds);\n\n  // Poll file descriptors\n  int ret = select(this->fd + 1, &readfds, NULL, NULL, &tv);\n  if (ret == -1) {\n    // Error\n    gzerr << \"Error in select() call\" << std::endl;\n    return;\n  } else if (ret == 0) {\n    // Timeout\n    return;\n  }\n\n  // Receive data\n  char buffer[1024];\n  ssize_t nbytes = read(this->fd, buffer, sizeof(buffer));\n  if (nbytes == -1) {\n    // Error\n    gzerr << \"Error in read() call\" << std::endl;\n    return;\n  } else if (nbytes == 0) {\n    // EOF\n    gzerr << \"Connection closed by remote host\" << std::endl;\n    return;\n  }\n\n  // Parse MAVLink messages from buffer\n  mavlink_message_t msg;\n  mavlink_status_t status;\n  for (unsigned int i = 0; i < nbytes; ++i) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n      // Handle message\n      this->handleMessage(msg);\n\n      // Forward message to serial connection\n      if (this->serialEnabled && this->serialConnection) {\n        this->serialConnection->write(buffer + i, 1);\n      }\n    }\n  }\n}", "CodeBleu_score": 51.86946790684741}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t//    if (this->timeout_usec > 0) {\n//        // poll for new data\n//        struct timeval tv;\n//        tv.tv_sec = 0;\n//        tv.tv_usec = this->timeout_usec;\n//        int ret = poll(&this->poll_fds, 1, this->timeout_usec);\n//        if (ret < 0) {\n//            gzerr << \"poll failed: \" << strerror(errno) << \"\n\";\n//        } else if (ret == 0) {\n//            gzdbg << \"poll timed out\n\";\n//        } else {\n//            if (this->poll_fds.revents & POLLIN) {\n//                this->receiveMAVLinkMessages();\n//            }\n//        }\n//    } else {\n//        this->receiveMAVLinkMessages();\n//    }\n}", "CodeBleu_score": 1.4726803394282788}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#ifdef HAVE_LIBUSB\n    if (this->fd_usb >= 0) {\n        // Poll for USB data\n        struct pollfd fds[1];\n        fds[0].fd = this->fd_usb;\n        fds[0].events = POLLIN;\n        fds[0].revents = 0;\n        int ret = poll(fds, 1, _timeoutMs);\n\n        if (ret > 0) {\n            if (fds[0].revents & POLLIN) {\n                // Read data from USB\n                char buf[1024];\n                ssize_t count = read(this->fd_usb, buf, sizeof(buf));\n                if (count < 0) {\n                    gzerr << \"Error reading from USB device: \" << strerror(errno) << \"", "CodeBleu_score": 33.285959654300235}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tif (isOpen())  {\n\t\tio_service_.stop();\n\t\tserial_port_.close();\n\t\tif (io_thread_.joinable())  {\n\t\t\tio_thread_.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 55.936886028760945}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(this->mutex);\n\tif (this->isOpen) {\n\t\tthis->ioService.stop();\n\t\tthis->serialDevice->close();\n\t\tif (this->ioThread.joinable()) {\n\t\t\tthis->ioThread.join();\n\t\t}\n\t\tthis->isOpen = false;\n\t}\n}", "CodeBleu_score": 27.705618396265073}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(this->mutex);\n\tif (this->isOpen()) {\n\t\tthis->ioService.stop();\n\t\tthis->serialDevice.close();\n\t\tif (this->ioThread.joinable()) {\n\t\t\tthis->ioThread.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 29.071888852156224}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(ignition::math::Vector3d position, ignition::math::Vector3d position_1, ignition::math::Vector3d position_2, ignition::math::Vector3d value_1, ignition::math::Vector3d value_2) {\n\t\tdouble distance = position_1.Distance(position_2);\n\t\tdouble distance_1 = position_1.Distance(position);\n\t\tdouble distance_2 = position_2.Distance(position);\n\t\tdouble ratio_1 = distance_2 / distance;\n\t\tdouble ratio_2 = distance_1 / distance;\n\t\tignition::math::Vector3d value = value_1 * ratio_1 + value_2 * ratio_2;\n\t\treturn value;\n\t}\n}", "CodeBleu_score": 34.06985135610218}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(const ignition::math::Vector3d& p1, const ignition::math::Vector3d& p2, const ignition::math::Vector3d& v1, const ignition::math::Vector3d& v2, const ignition::math::Vector3d& pos) {\n\t\tignition::math::Vector3d v;\n\t\tignition::math::Vector3d d = p2 - p1;\n\t\tignition::math::Vector3d w = pos - p1;\n\t\tv = v1 + (v2 - v1) * (w.Dot(d) / d.Dot(d));\n\t\treturn v;\n\t}\n}", "CodeBleu_score": 38.31333637022761}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tdouble x,\n\tconst std::vector<double> &xData,\n\tconst std::vector<ignition::math::Vector3d> &yData\n}", "CodeBleu_score": 15.723216453849902}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (this->time == _time)\n\t\treturn;\n\n\tif (this->loop) {\n\t\tthis->time = fmod(_time, this->length);\n\t} else {\n\t\tthis->time = std::max(0.0, std::min(_time, this->length));\n\t}\n\n\tif (this->time!= _time) {\n\t\tgzwarn << \"Animation time out of range, clamping to [\" << this->time << \"]\n\";\n\t}\n\n\t// Update the keyframe position\n\tthis->UpdateKeyFrame();\n}", "CodeBleu_score": 45.21742374971474}, {"code": "void Animation::SetTime(double _time){\n\t\tif (_time!= this->time) {\n\t\tthis->time = _time;\n\t\tif (this->looping) {\n\t\t\tthis->time = fmod(this->time, this->length);\n\t\t} else {\n\t\t\tthis->time = std::max(0.0, std::min(this->time, this->length));\n\t\t}\n\t\tthis->Update();\n\t}\n}", "CodeBleu_score": 45.40922796714123}, {"code": "void Animation::SetTime(double _time){\n\t\n}", "CodeBleu_score": 2.3054066121187096}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.set_frame(1)\n    self.set_type(0)\n    self.set_position(self.current_position[0], self.current_position[1], self.current_position[2], self.current_yaw)\n    print(\"Vehicle type: \" + str(self.vehicle_type))\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight mode: \" + str(self.flight_mode))\n\n", "CodeBleu_score": 25.023682442589205}, {"code": "def hover(self)\n\t\n    # Set the coordinate frame to 1 and the motion type to 0\n    self.coordinate_frame = 1\n    self.type_mask = 0\n    # Construct the target motion using the current position and yaw\n    self.position.x = self.current_pose.pose.position.x\n    self.position.y = self.current_pose.pose.position.y\n    self.position.z = self.current_pose.pose.position.z\n    self.yaw = self.current_pose.pose.orientation.w\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 39.589860976713496}, {"code": "def hover(self)\n\t\n\n    self.set_frame(1)\n    self.set_type(0)\n    target = PositionTarget()\n    target.header.stamp = rospy.Time.now()\n    target.header.frame_id = 1\n    target.coordinate_frame = 1\n    target.type_mask = 0b0000111111000111\n    target.position.x = self.pose.position.x\n    target.position.y = self.pose.position.y\n    target.position.z = self.pose.position.z\n    target.yaw = self.yaw\n    self.pub_target.publish(target)\n    rospy.loginfo(\"Vehicle type: %s, ID: %s, Flight Mode: %s\" % (self.vehicle_type, self.vehicle_id, self.flight_mode))\n\n", "CodeBleu_score": 21.529710332821917}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    else:\n        rospy.wait_for_service('mavros/set_mode')\n        try:\n            flightModeService = rospy.ServiceProxy('mavros/set_mode', SetMode)\n            isModeChanged = flightModeService(custom_mode=self.flightMode)\n            if isModeChanged.mode_sent:\n                print(\"Mode changed to \" + self.flightMode)\n            else:\n                print(\"Mode change to \" + self.flightMode + \" failed\")\n            return isModeChanged.mode_sent\n        except rospy.ServiceException as e:\n            print(\"Service set_mode call failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 38.72097558416724}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flightMode)\n            rospy.loginfo(\"Mode switched to %s\", self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.logerr(\"Mode switch failed. Service call failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 58.57545633092446}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy('/mavros/set_mode', SetMode)\n            isModeChanged = flightModeService(custom_mode=self.flight_mode)\n            if isModeChanged.mode_sent:\n                rospy.loginfo(\"Mode changed to %s\", self.flight_mode)\n                return True\n            else:\n                rospy.loginfo(\"Failed to change mode\")\n                return False\n        except rospy.ServiceException as e:\n            rospy.loginfo(\"flight mode service call failed: %s. Hovering.\", e)\n            return False\n\n", "CodeBleu_score": 52.171788224391925}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear, msg.angular)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear, msg.angular, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target_motion(msg.linear, msg.angular, 'enu')\n\n", "CodeBleu_score": 26.19087739490488}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target_motion(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n", "CodeBleu_score": 37.304597405172494}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = PositionTarget()\n        self.target_motion.header.stamp = rospy.Time.now()\n        self.target_motion.header.frame_id = self.frame_id\n        self.target_motion.type_mask = int('100111111000', 2)\n        self.target_motion.coordinate_frame = self.coordinate_frame\n        self.target_motion.velocity.x = msg.linear.x\n        self.target_motion.velocity.y = msg.linear.y\n        self.target_motion.velocity.z = msg.linear.z\n        self.target_motion.yaw_rate = msg.angular.z\n        self.target_motion.yaw = self.yaw\n        self.target_motion.position.x = self.x\n        self.target_motion.position.y = self.y\n        self.target_motion.position.z = self.z\n        self.target_motion_pub.publish(self.target_motion)\n\n", "CodeBleu_score": 29.078911477863567}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.mode!= \"OFFBOARD\":\n        if self.mode!= \"HOVER\":\n            if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n                self.hover_flag = 1\n                self.set_mode(\"HOVER\")\n                self.arm()\n                self.hover_action()\n            else:\n                self.hover_flag = 0\n                self.set_mode(\"OFFBOARD\")\n                self.arm()\n                self.offboard_action()\n        else:\n            if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n                self.hover_flag = 0\n                self.set_mode(\"OFFBOARD\")\n                self.arm()\n                self.offboard_action()\n    else:\n        if self.mode!= \"HOVER\":\n            if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n                self.hover_flag = 1\n                self.set_mode(\"HOVER\")\n                self.arm()\n                self.hover_action()\n            else:\n                self.hover_flag = 0\n                self.set_mode(\"OFFBOARD\")\n                self.arm()\n                self.offboard_action()\n        else:\n            if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n                self.hover_flag = 0\n                self.set_mode(\"OFFBOARD\")\n                self.arm()\n                self.offboard_action()\n\n", "CodeBleu_score": 50.1188524187427}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode!= \"OFFBOARD\":\n        self.set_mode(\"OFFBOARD\")\n        rospy.loginfo(\"OFFBOARD mode enabled\")\n\n    if self.flight_mode == \"OFFBOARD\":\n        if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n            if self.hover_flag == 0:\n                self.hover_flag = 1\n                self.set_mode(\"HOVER\")\n                rospy.loginfo(\"HOVER mode enabled\")\n        else:\n            if self.hover_flag == 1:\n                self.hover_flag = 0\n                self.set_mode(\"OFFBOARD\")\n                rospy.loginfo(\"OFFBOARD mode enabled\")\n\n", "CodeBleu_score": 39.63989884623583}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode(0, \"OFFBOARD\")\n    if self.hover_flag == 0 and (abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005):\n        self.hover_flag = 1\n        self.set_mode(0, \"HOVER\")\n        self.hover_action()\n\n", "CodeBleu_score": 57.25655192893415}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 24.58575872254351}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 24.58575872254351}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q[3], q[0], q[1], q[2]).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 26.04957448605886}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n\n    # Set the coordinate frame\n    self.pos_sp.coordinate_frame = PositionTarget.FRAME_BODY_NED\n\n    # Set the motion type\n    self.pos_sp.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ + PositionTarget.FORCE\n\n    # Construct the target motion\n    self.pos_sp.position.x = self.current_pose.pose.position.x\n    self.pos_sp.position.y = self.current_pose.pose.position.y\n    self.pos_sp.position.z = self.current_pose.pose.position.z\n    self.pos_sp.yaw = self.current_pose.pose.orientation.z\n\n    # Publish the target motion\n    self.pos_sp_pub.publish(self.pos_sp)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: HOVER\")\n\n", "CodeBleu_score": 27.349700824854228}, {"code": "def hover(self)\n\t\n    self.frame = PositionTarget.FRAME_BODY_NED\n    self.type = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ + PositionTarget.FORCE\n    self.target.position.x = self.pose.position.x\n    self.target.position.y = self.pose.position.y\n    self.target.position.z = self.pose.position.z\n    self.target.yaw = self.yaw\n    print \"Vehicle Type: \" + self.vehicle_type + \"", "CodeBleu_score": 33.333119205195935}, {"code": "def hover(self)\n\t\n    self.set_frame_and_type()\n    self.target_msg.coordinate_frame = self.frame\n    self.target_msg.type_mask = self.type_mask\n    self.target_msg.position.x = self.current_pose.position.x\n    self.target_msg.position.y = self.current_pose.position.y\n    self.target_msg.position.z = self.current_pose.position.z\n    self.target_msg.yaw = self.current_yaw\n    print(\"Vehicle type: {}\".format(self.vehicle_type))\n    print(\"Vehicle ID: {}\".format(self.vehicle_id))\n    print(\"Flight mode: {}\".format(self.flight_mode))\n\n", "CodeBleu_score": 25.388793125982833}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy('/mavros/set_mode', SetMode)\n            flightModeService(custom_mode=self.flight_mode)\n            print(\"Flight Mode: \", self.flight_mode)\n            return True\n        except rospy.ServiceException:\n            print(\"Flight Mode Switch Failed\")\n            return False\n\n", "CodeBleu_score": 48.079556034479964}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hoverFlag = True\n        self.hover()\n    else:\n        if self.flightModeService(custom_mode=self.flightMode):\n            rospy.loginfo(\"Vehicle is in %s mode\", self.flightMode)\n            return True\n        else:\n            rospy.logerr(\"Failed to set vehicle mode.\")\n            return False\n\n", "CodeBleu_score": 48.47342819023637}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hoverFlag = True\n        self.hover()\n        return True\n    elif self.flightModeService(custom_mode=self.flightMode):\n        rospy.loginfo(\"Switched to %s mode\", self.flightMode)\n        return True\n    else:\n        rospy.logerr(\"Failed to switch to %s mode\", self.flightMode)\n        return False\n\n", "CodeBleu_score": 50.22800586023819}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n    return self.total_reward\n\n", "CodeBleu_score": 48.393699464401564}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    self.local_pose[i] = msg\n    self.global_pose[i].pose.position.x = self.local_pose[i].pose.position.x + self.local_pose_bias[i][0]\n    self.global_pose[i].pose.position.y = self.local_pose[i].pose.position.y + self.local_pose_bias[i][1]\n    self.global_pose[i].pose.position.z = self.local_pose[i].pose.position.z + self.local_pose_bias[i][2]\n    self.global_pose[i].pose.orientation = self.local_pose[i].pose.orientation\n    if self.gcs_command == 'takeoff':\n        self.takeoff_target_pose[i].pose.position.x = self.local_pose[i].pose.position.x + self.takeoff_target_pose_bias[i][0]\n        self.takeoff_target_pose[i].pose.position.y = self.local_pose[i].pose.position.y + self.takeoff_target_pose_bias[i][1]\n        self.takeoff_target_pose[i].pose.position.z = self.local_pose[i].pose.position.z + self.takeoff_target_pose_bias[i][2]\n        self.takeoff_target_pose[i].pose.orientation = self.local_pose[i].pose.orientation\n    elif self.gcs_command == 'hover':\n        self.hover_target_pose[i].pose.position.x = self.local_pose[i].pose.position.x + self.hover_target_pose_bias[i][0]\n        self.hover_target_pose[i].pose.position.y = self.local_pose[i].pose.position.y + self.hover_target_pose_bias[i][1]\n        self.hover_target_pose[i].pose.position.z = self.local_pose[i].pose.position.z + self.hover_target_pose_bias[i][2]\n        self.hover_target_pose[i].pose.orientation = self.local_pose[i].pose.orientation", "CodeBleu_score": 26.640819638823732}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == i:\n        self.local_pose = msg\n        if self.command == 'takeoff':\n            self.takeoff_target_pose = copy.deepcopy(msg)\n            self.takeoff_target_pose.pose.position.z = 10.0\n        elif self.command == 'hover':\n            self.hover_target_pose = copy.deepcopy(msg)\n        self.global_pose = copy.deepcopy(msg)\n        self.global_pose.pose.position.x += self.bias_x\n        self.global_pose.pose.position.y += self.bias_y\n        self.global_pose.pose.position.z += self.bias_z\n\n", "CodeBleu_score": 31.681951721133878}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n            self.takeoff_target_pose.pose.position.z = self.takeoff_height\n            self.hover_target_pose = copy.deepcopy(self.takeoff_target_pose)\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n            self.hover_target_pose.pose.position.z = self.hover_height\n        elif self.gcs_command == \"land\":\n            self.land_target_pose = copy.deepcopy(self.local_pose)\n            self.land_target_pose.pose.position.z = 0.0\n        self.global_pose.latitude = self.local_pose.pose.position.x + self.lat_bias\n        self.global_pose.longitude = self.local_pose.pose.position.y + self.long_bias\n        self.global_pose.altitude = self.local_pose.pose.position.z + self.alt_bias\n\n", "CodeBleu_score": 27.79750889649041}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.pose.pose.position.z > 0.2:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 60.746289276015176}, {"code": "def takeoff_detection(self)\n\t\n    if self.current_state.armed and self.current_state.mode == \"OFFBOARD\" and self.current_state.system_status == 8 and self.current_state.is_rotating == False and self.current_state.is_in_air == True:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 51.755913114863894}, {"code": "def takeoff_detection(self)\n\t\n    if self.current_state.armed and self.current_state.mode == \"OFFBOARD\" and self.local_pos.pose.position.z > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 64.01826383897821}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Create a distance matrix of size (n x n) where n is the number of UAVs\n    n = len(orig_formation)\n    dist_matrix = numpy.zeros((n, n), dtype=int)\n\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    for i in range(n):\n        for j in range(n):\n            dist_matrix[i, j] = int(50 - numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j])))\n\n    return dist_matrix\n", "CodeBleu_score": 26.84663330685717}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Build distance matrix\n    distance_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i, j] = 50 - numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j]))\n            distance_matrix[i, j] = int(distance_matrix[i, j])\n    return distance_matrix\n", "CodeBleu_score": 28.190158414447637}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # calculate pairwise distances between UAVs in the original and changed formations\n    dist_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i, j] = numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j]))\n    # adjust the distances by subtracting them from 50 and converting to integers\n    dist_matrix = (50 - dist_matrix).astype(int)\n    return dist_matrix\n", "CodeBleu_score": 25.181080501331156}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    if self.visited_left[i]:\n        return False\n    self.visited_left[i] = True\n    for j in self.adj_list[i]:\n        if self.visited_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - self.match_weight[i][j]\n        if gap == 0:\n            self.visited_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_left[i] = j\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n", "CodeBleu_score": 35.39750837257383}, {"code": "def find_path(self, i)\n\t\n    if self.left_vertex[i] == True:\n        return False\n    self.left_vertex[i] = True\n    for j in range(self.n_right):\n        if self.right_vertex[j] == False and self.slack[j] == 0:\n            self.right_vertex[j] = True\n            if self.match[j] == -1 or self.find_path(self.match[j]):\n                self.match[j] = i\n                return True\n    for j in range(self.n_right):\n        if self.right_vertex[j] == False:\n            if self.slack[j] > self.weight[i][j] - self.left_label[i] - self.right_label[j]:\n                self.slack[j] = self.weight[i][j] - self.left_label[i] - self.right_label[j]\n    return False\n", "CodeBleu_score": 41.10101710996672}, {"code": "def find_path(self, i)\n\t\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in range(self.n):\n        if self.slack[j] == 0 and self.right_match[j] == -1:\n            self.right_match[j] = i\n            self.left_match[i] = j\n            return True\n        elif self.slack[j] == 0:\n            if find_path(self, self.right_match[j]):\n                self.right_match[j] = i\n                self.left_match[i] = j\n                return True\n    return False\n\n", "CodeBleu_score": 33.9221016491628}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    # initialize slack array for Kuhn-Munkres algorithm\n    slack = numpy.zeros(self.n)\n    # initialize visited array for Kuhn-Munkres algorithm\n    visited = numpy.zeros(self.n)\n    # initialize match array for Kuhn-Munkres algorithm\n    match = numpy.zeros(self.n)\n    # iterate over UAVs\n    for i in range(self.n):\n        # reset visited array for each UAV\n        visited.fill(0)\n        # initialize slack array for each UAV\n        slack.fill(float(\"inf\"))\n        # find a matching for the current UAV\n        while True:\n            # find an unmatched UAV\n            if visited[i] == 0:\n                # mark UAV as visited\n                visited[i] = 1\n                # find the minimum slack value for the current UAV\n                j = numpy.argmin(slack)\n                # find the minimum slack value for the current UAV\n                min_slack = slack[j]\n                # update the slack array for the current UAV\n                slack = numpy.where(visited == 0, slack - min_slack, slack)\n                # find the minimum slack value for the current UAV\n                min_slack = slack[j]\n                # update the slack array for the current UAV\n                slack = numpy.where(visited == 0, slack - min_slack, slack)\n                # find the minimum slack value for the current UAV\n                min_slack = slack[j]\n                # update the slack array for the current UAV\n                slack = numpy.where(visited == 0, slack - min_slack, slack)\n                # find the minimum slack value for the current UAV\n                min_slack = slack[j]\n                # update the slack array for the current UAV\n                slack = numpy.where(visited == 0, slack - min_slack, slack)\n                # find the minimum slack value for the current UAV\n                min_slack = slack[j]\n                # update the slack array for the current UAV\n                slack = numpy.where(visited == 0, slack - min_slack, slack)\n                # find the minimum slack value for the current UAV\n                min_slack = slack[j]\n                # update the slack array for the current UAV\n                slack = numpy.where(visited == 0, slack - min_slack, slack)\n                # find the minimum", "CodeBleu_score": 22.09303120013521}, {"code": "def KM(self)\n\t\n    match = [-1] * self.num_UAV\n    for UAV in range(self.num_UAV):\n        slack = [float(\"inf\")] * self.num_target\n        visited = [False] * self.num_target\n        while True:\n            visited[UAV] = True\n            min_slack = float(\"inf\")\n            min_slack_target = -1\n            for target in range(self.num_target):\n                if not visited[target]:\n                    slack_value = slack[target] - self.cost[UAV][target]\n                    if slack_value < min_slack:\n                        min_slack = slack_value\n                        min_slack_target = target\n            for target in range(self.num_target):\n                if visited[target]:\n                    self.label_UAV[target] += min_slack\n                    slack[target] -= min_slack\n                else:\n                    slack[target] -= min_slack\n            if match[min_slack_target] == -1:\n                break\n        while min_slack_target!= -1:\n            new_target = self.match_UAV[min_slack_target]\n            match[min_slack_target] = UAV\n            min_slack_target = new_target\n    return match\n\n", "CodeBleu_score": 27.217412998751268}, {"code": "def KM(self)\n\t\n    matchR = [-1] * self.num_uavs\n    u = [0] * self.num_uavs\n    v = [0] * self.num_uavs\n    p = [0] * self.num_uavs\n    way = [0] * self.num_uavs\n    for uav in range(self.num_uavs):\n        p = [-1] * self.num_uavs\n        matchR = [-1] * self.num_uavs\n        way = [0] * self.num_uavs\n        minv = [0] * self.num_uavs\n        used = [0] * self.num_uavs\n        d = [0] * self.num_uavs\n        d[0] = 0\n        for i in range(self.num_uavs):\n            p[0] = i\n            used[i] = True\n            for j in range(self.num_uavs):\n                if (self.adj_matrix[i][j] - u[i] - v[j]) < d[j]:\n                    d[j] = self.adj_matrix[i][j] - u[i] - v[j]\n                    way[j] = i\n            j = 0\n            while j < self.num_uavs:\n                p[j + 1] = -1\n                minv[j] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "CodeBleu_score": 27.83615309903647}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.779830147695577}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 27.09532694324272}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tif (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tROS_WARN(\"Standalone tag description not found for ID %d\", id);\n\t\t}\n\t\treturn false;\n\t}\n\tdescriptionContainer = standalone_tag_descriptions_[id];\n\treturn true;\n}", "CodeBleu_score": 31.482833020396438}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t// check the standalone_tag_descriptions_ map for the given ID\n\tauto it = standalone_tag_descriptions_.find(tagID);\n\t// if the description is not found and printWarning is true, log a warning message\n\tif (it == standalone_tag_descriptions_.end() && printWarning) {\n\t\tROS_WARN(\"Standalone tag ID %d not found.\", tagID);\n\t}\n\t// if found, set the descriptionContainer to the tag's description and return true; otherwise, return false\n\tif (it!= standalone_tag_descriptions_.end()) {\n\t\tdescriptionContainer = it->second;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.88521240328829}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tconst auto it = standalone_tag_descriptions_.find(tag_id);\n\tif (it == standalone_tag_descriptions_.end()) {\n\t\tif (print_warning) {\n\t\t\tROS_WARN(\"Standalone tag ID %d not found.\", tag_id);\n\t\t}\n\t\treturn false;\n\t}\n\tdescription_container = it->second;\n\treturn true;\n}", "CodeBleu_score": 33.96311140504338}]}
