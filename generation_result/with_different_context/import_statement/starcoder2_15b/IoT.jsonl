{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *p = (uint8_t *) desc;\n\tuint8_t len = 0;\n\tuint8_t id = 0;\n\n\twhile (1) {\n\t\tlen = p[0];\n\t\tid = p[1];\n\t\tif (len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (id == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p;\n\t\t}\n\t\tp += len;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 35.00265088076846}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_iface_desc_t UDC_DESC_STORAGE * iface_desc = (usb_iface_desc_t\n\t\t\tUDC_DESC_STORAGE *) desc;\n\tusb_desc_t UDC_DESC_STORAGE * desc_tmp = (usb_desc_t UDC_DESC_STORAGE *)\n\t\t\tdesc;\n\n\twhile (desc_tmp->bLength!= 0) {\n\t\tif (desc_tmp->bDescriptorType == desc_id) {\n\t\t\treturn desc_tmp;\n\t\t}\n\t\tdesc_tmp = (usb_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc_tmp\n\t\t\t\t+ desc_tmp->bLength);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 45.724428235606766}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_iface_desc_t UDC_DESC_STORAGE * iface_desc;\n\tuint8_t * desc_ptr;\n\tuint8_t desc_len;\n\n\tiface_desc = (usb_iface_desc_t UDC_DESC_STORAGE *) desc;\n\tdesc_ptr = (uint8_t *) desc;\n\tdesc_len = iface_desc->bLength;\n\n\twhile (desc_ptr < (uint8_t *) desc + desc_len) {\n\t\tif (desc_ptr->bDescriptorType == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\t}\n\n\t\tdesc_ptr += desc_ptr->bLength;\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 44.887770305644835}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *ptr = (uint8_t *) &config_desc;\n\tuint8_t *end = ptr + config_desc.wTotalLength;\n\tuint8_t *iface_desc = NULL;\n\tuint8_t *end_iface_desc;\n\tuint8_t *end_ep_desc;\n\tuint8_t *end_extra_desc;\n\tuint8_t *extra_desc;\n\tuint8_t *end_config_desc;\n\tuint8_t iface_desc_len;\n\tuint8_t ep_desc_len;\n\tuint8_t extra_desc_len;\n\tuint8_t config_desc_len;\n\tuint8_t i;\n\n\tif (config_desc.bNumInterfaces == 0) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= config_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\twhile (ptr < end) {\n\t\tswitch (ptr[1]) {\n\t\tcase USB_DT_INTERFACE:\n\t\t\tif (iface_desc == NULL) {\n\t\t\t\tiface_desc = ptr;\n\t\t\t}\n\t\t\tiface_desc_len = ptr[0];\n\t\t\tend_iface_desc = ptr + iface_desc_len;\n\t\t\tif (ptr[2] == iface_num && ptr[3] == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_ENDPOINT:\n\t\t\tep_desc_len = ptr[0];\n\t\t\tend_ep_desc = ptr + ep_desc_len;\n\t\t\tif (ptr[2] & 0x80) {\n\t\t\t\tif (iface_desc!= NULL) {\n\t\t\t\t\tif (iface_desc[3] == setting_num) {\n\t\t\t\t\t\tudc_ep_enable(ptr[2] & 0x0F, USB_EP_TYPE_CONTROL,\n\t\t\t\t\t\t\t\tUSB_EP_DIR_IN, 64, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (iface_desc!= NULL) {\n\t\t\t\t\tif (iface_desc[3] == setting_num) {\n\t\t\t\t\t\tudc_ep_enable(ptr[2] & 0x0F,", "CodeBleu_score": 41.877729162026064}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tstruct usb_desc_header *desc;\n\tstruct usb_desc_iter iter;\n\tstruct usb_desc_iter_res res;\n\tstruct usb_desc_iter_res iface_res;\n\tbool iface_found = false;\n\n\tif (udc_get_current_config() == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_get_num_interfaces()) {\n\t\treturn false;\n\t}\n\n\tdesc = (struct usb_desc_header *)udc_get_current_config();\n\tusb_desc_iter_init(&iter, desc, udc_get_current_config_size());\n\n\twhile (usb_desc_iter_next(&iter, &res)) {\n\t\tif (res.type == USB_DESC_INTERFACE) {\n\t\t\tif (iface_found) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (res.desc->bInterfaceNumber == iface_num) {\n\t\t\t\tiface_found = true;\n\t\t\t\tiface_res = res;\n\t\t\t}\n\t\t} else if (iface_found && res.type == USB_DESC_INTERFACE_SETTING) {\n\t\t\tif (res.desc->bAlternateSetting == setting_num) {\n\t\t\t\tiface_res = res;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (iface_found) {\n\t\tudc_set_iface_desc(iface_res.desc);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 42.5242462959128}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *p = (uint8_t*) &__udc_config_desc;\n\tuint8_t *p_end = p + __udc_config_desc.wTotalLength;\n\tuint8_t *p_iface = NULL;\n\tuint8_t *p_end_iface = NULL;\n\tuint8_t *p_setting = NULL;\n\tuint8_t *p_end_setting = NULL;\n\tuint8_t *p_desc = NULL;\n\tuint8_t *p_end_desc = NULL;\n\n\tif (__udc_config_desc.bNumInterfaces == 0) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= __udc_config_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\twhile (p < p_end) {\n\t\tif (p[1] == USB_DT_INTERFACE) {\n\t\t\tp_iface = p;\n\t\t\tp_end_iface = p + p_iface[0];\n\t\t\tif (p_iface[2] == iface_num) {\n\t\t\t\tp += p_iface[0];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (p[1] == USB_DT_CONFIG) {\n\t\t\tbreak;\n\t\t}\n\t\tp += p[0];\n\t}\n\n\tif (p >= p_end) {\n\t\treturn false;\n\t}\n\n\twhile (p < p_end_iface) {\n\t\tif (p[1] == USB_DT_INTERFACE) {\n\t\t\tp_setting = p;\n\t\t\tp_end_setting = p + p_setting[0];\n\t\t\tif (p_setting[3] == setting_num) {\n\t\t\t\tp += p_setting[0];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (p[1] == USB_DT_ENDPOINT) {\n\t\t\tp_desc = p;\n\t\t\tp_end_desc = p + p_desc[0];\n\t\t\tif (p_desc[2] & USB_ENDPOINT_IN) {\n\t\t\t\t__udc_ep_in_desc[p_desc[2] & 0x0F] = p_desc;\n\t\t\t} else {\n\t\t\t\t__udc_ep_out_", "CodeBleu_score": 38.52691901207421}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_status;\n\n\tif (req_len!= 2)\n\t\treturn false;\n\n\tep_status = 0;\n\tif (udc_ep_is_halted(req_ep))\n\t\tep_status = 1;\n\n\treq_payload[0] = ep_status;\n\treq_payload[1] = 0;\n\n\treturn true;\n}", "CodeBleu_score": 33.11529744332356}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep;\n\tuint8_t status;\n\n\tif (usb_setup.wLength!= 2)\n\t\treturn false;\n\n\tep = usb_setup.wIndex & 0x7F;\n\tif (ep >= UDC_EP_NUM)\n\t\treturn false;\n\n\tstatus = 0;\n\tif (udc_ep_is_halted(ep))\n\t\tstatus = 1;\n\n\tusb_setup_reply(2, &status);\n\treturn true;\n}", "CodeBleu_score": 31.02976991534031}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep = udi_req.req.wIndex;\n\tuint16_t status = 0;\n\n\tif (ep & 0x80) {\n\t\tif (udi_req.payload_size!= sizeof(uint16_t)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (udc_get_halt_status(ep)) {\n\t\t\tstatus = 1;\n\t\t}\n\t} else {\n\t\tif (udi_req.payload_size!= 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tudi_req.payload = &status;\n\tudi_req.payload_size = sizeof(uint16_t);\n\treturn true;\n}", "CodeBleu_score": 29.840873717035876}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_nb;\n\tuint8_t alt_setting;\n\tuint8_t *ptr;\n\tuint16_t size;\n\tbool result;\n\n\t// Check if the device is in a configured state\n\tif (udc_get_state()!= UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\n\t// Get the interface number and the alternate setting from the SETUP request\n\tiface_nb = udc_get_setup_windex();\n\talt_setting = udc_get_setup_wvalue() & 0xFF;\n\n\t// Check if the interface number is valid\n\tif (iface_nb >= udc_get_nb_interfaces()) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tptr = udc_get_interface_desc_ptr(iface_nb);\n\tsize = udc_get_interface_desc_size(iface_nb);\n\tptr[2] = iface_nb;\n\tptr[3] = 0;\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (alt_setting!= 0) {\n\t\tptr[3] = alt_setting;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\tresult = udi_get_setup_handler(iface_nb)(false);\n\n\t// Return the result of the handler's setup function\n\treturn result;\n}", "CodeBleu_score": 45.77032420880165}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_nb;\n\tuint8_t alt_setting;\n\tbool ret;\n\n\t/* Check if the device is in a configured state */\n\tif (!udc_d_is_valid_state(UDC_STATE_CONFIGURED)) {\n\t\treturn false;\n\t}\n\n\t/* Check if the requested interface number is valid */\n\tiface_nb = udi_g_ctrlreq.req.wIndex;\n\tif (iface_nb >= udc_d_get_nb_interfaces()) {\n\t\treturn false;\n\t}\n\n\t/* Update the interface descriptor to the default setting */\n\tif (udi_g_ctrlreq.req.wValue!= 0) {\n\t\treturn false;\n\t}\n\n\t/* Update the interface descriptor to the current alternate setting */\n\talt_setting = udi_g_ctrlreq.req.wValue >> 8;\n\tif (!udi_g_ctrlreq.callback.change_altsetting(iface_nb, alt_setting)) {\n\t\treturn false;\n\t}\n\n\t/* Forward the SETUP request to the corresponding UDI handler */\n\tret = udi_g_ctrlreq.callback.setup(iface_nb, alt_setting);\n\n\treturn ret;\n}", "CodeBleu_score": 49.85393112944982}, {"code": "static bool udc_req_iface(void){\n\t\tif (g_udd_usb_state!= UDD_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\n\tif (g_udd_g_ctrlreq.req.wIndex > UDC_NB_IFACE) {\n\t\treturn false;\n\t}\n\n\tif (g_udd_g_ctrlreq.req.wValue!= 0) {\n\t\tif (g_udd_g_ctrlreq.req.wValue > UDC_NB_IFACE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (g_udd_g_ctrlreq.req.wValue!= 0) {\n\t\tif (g_udd_g_ctrlreq.req.wValue > UDC_NB_IFACE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (g_udd_g_ctrlreq.req.wValue!= 0) {\n\t\tif (g_udd_g_ctrlreq.req.wValue > UDC_NB_IFACE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (g_udd_g_ctrlreq.req.wValue!= 0) {\n\t\tif (g_udd_g_ctrlreq.req.wValue > UDC_NB_IFACE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (g_udd_g_ctrlreq.req.wValue!= 0) {\n\t\tif (g_udd_g_ctrlreq.req.wValue > UDC_NB_IFACE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (g_udd_g_ctrlreq.req.wValue!= 0) {\n\t\tif (g_udd_g_ctrlreq.req.wValue > UDC_NB_IFACE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (g_udd_g_ctrlreq.req.wValue!= 0) {\n\t\tif (g_udd_g_ctrlreq.req.wValue > UDC_NB_IFACE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (g_udd_g_ctrlreq.req.wValue!= 0) {\n\t\tif (g_udd", "CodeBleu_score": 34.814574624662264}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\t// Initialize flags\n\tmsc_b_cbw_received = false;\n\tmsc_b_data_received = false;\n\tmsc_b_data_sent = false;\n\tmsc_b_state_error = false;\n\tmsc_b_stall_received = false;\n\tmsc_b_send_csw = false;\n\tmsc_b_new_cbw = false;\n\tmsc_b_new_data = false;\n\tmsc_b_new_state = false;\n\tmsc_b_cbw_ok = false;\n\tmsc_b_cbw_phase_error = false;\n\tmsc_b_cbw_length_error = false;\n\tmsc_b_cbw_lba_error = false;\n\tmsc_b_cbw_length_overflow = false;\n\tmsc_b_cbw_signature_error = false;\n\tmsc_b_cbw_data_dir_error = false;\n\tmsc_b_cbw_lun_error = false;\n\tmsc_b_cbw_cb_length_error = false;\n\tmsc_b_cbw_expected_data_error = false;\n\tmsc_b_cbw_expected_data_phase_error = false;\n\tmsc_b_csw_length_error = false;\n\tmsc_b_csw_signature_error = false;\n\tmsc_b_csw_status_error = false;\n\tmsc_b_csw_data_residue_error = false;\n\tmsc_b_csw_phase_error = false;\n\tmsc_b_csw_expected_data_error = false;\n\tmsc_b_csw_expected_data_phase_error = false;\n\tmsc_b_csw_expected_status_error = false;\n\tmsc_b_csw_expected_state_error = false;\n\tmsc_b_csw_expected_phase_error = false;\n\tmsc_b_data_in_sent = false;\n\tmsc_b_data_out_received = false;\n\tmsc_b_data_in_received = false;\n\tmsc_b_data_out_sent = false;\n\t", "CodeBleu_score": 7.085211048097268}, {"code": "bool udi_msc_enable(void){\n\t\t// Set initial states for several flags\n\tudi_msc_b_cbw_received = false;\n\tudi_msc_b_data_received = false;\n\tudi_msc_b_data_transmitted = false;\n\tudi_msc_b_csw_sent = false;\n\tudi_msc_b_error = false;\n\tudi_msc_b_state_reset = false;\n\tudi_msc_b_state_stall = false;\n\tudi_msc_b_state_cbw = false;\n\tudi_msc_b_state_data_in = false;\n\tudi_msc_b_state_data_out = false;\n\tudi_msc_b_state_csw = false;\n\tudi_msc_b_state_error = false;\n\n\t// Retrieve the number of LUNs\n\tudi_msc_nb_lun = udi_msc_get_nb_lun();\n\n\t// Check if there are any LUNs available\n\tif (udi_msc_nb_lun == 0) {\n\t\treturn false;\n\t}\n\n\t// Check if the external enable function succeeds\n\tif (!udi_msc_enable_ext()) {\n\t\treturn false;\n\t}\n\n\t// Unload the medium on each LUN\n\tudi_msc_unmount_all();\n\n\t// Start the MSC process by waiting for a CBW reception\n\tudi_msc_process();\n\n\treturn true;\n}", "CodeBleu_score": 22.832134135187275}, {"code": "bool udi_msc_enable(void){\n\t\tbool b_interface_ok = false;\n\n\t// Initialize the MSC interface\n\tudi_msc_init();\n\n\t// Check if the MSC interface is enabled\n\tif (UDI_MSC_ENABLE_EXT()) {\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc_init();\n\n\t\t// Initialize the MSC interface\n\t\tudi_msc", "CodeBleu_score": 17.51585817314944}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tuint8_t sense_key;\n\tuint8_t asc;\n\tuint8_t ascq;\n\tuint16_t csw_residue;\n\n\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\t// Transfer not successful, wait for MSC setup reset to restart CBW reception\n\t\treturn;\n\t}\n\n\t// Update sense data\n\tsense_key = SENSE_KEY_NO_SENSE;\n\tasc = 0;\n\tascq = 0;\n\n\t// Update CSW data residue\n\tcsw_residue = udi_msc_cbw.dCBWDataTransferLength - nb_sent;\n\tif (csw_residue == 0) {\n\t\t// Data transfer complete, process CSW\n\t\tudi_msc_process_csw(sense_key, asc, ascq);\n\t} else {\n\t\t// Data transfer not complete, update CSW data residue\n\t\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(csw_residue);\n\t}\n}", "CodeBleu_score": 47.8442338207683}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(nb_sent);\n\tUNUSED(ep);\n\n\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\t/* Transfer aborted, wait for a MSC setup reset to restart CBW reception */\n\t\treturn;\n\t}\n\n\t/* Update sense data */\n\tudi_msc_sense_data_update();\n\n\t/* Decrease data residue in CSW by the amount of data sent */\n\tudi_msc_csw_data_residue -= udi_msc_data_size;\n\n\t/* Process the updated CSW */\n\tudi_msc_csw_process();\n}", "CodeBleu_score": 61.807346921310454}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\t// Transfer aborted, wait for a MSC setup reset to restart CBW reception\n\t\treturn;\n\t}\n\t// Transfer successful, update sense data\n\tudi_msc_update_sense_data(MSC_SENSE_KEY_NO_SENSE, MSC_ASC_NO_ADDITIONAL_SENSE_INFORMATION, MSC_ASCQ_NO_ADDITIONAL_SENSE_INFORMATION);\n\t// Update CSW residue\n\tudi_msc_csw.dCSWDataResidue -= nb_sent;\n\t// Process CSW\n\tudi_msc_process_csw();\n}", "CodeBleu_score": 58.02674516818651}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tuint32_t residue = udi_msc_cbw.dCBWDataTransferLength - udi_msc_cbw.bCBWDataResidue;\n\n\tif (residue) {\n\t\tif (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\tudi_msc_stall_in();\n\t\t} else {\n\t\t\tudi_msc_stall_out();\n\t\t}\n\t}\n\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.bCBWDataResidue;\n\tudi_msc_csw.bCSWStatus = udi_msc_cbw.bCSWStatus;\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 53.980016891229255}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint32_t residue;\n\tuint8_t ep_nbr;\n\n\t/* Check if there is a non-zero data residue */\n\tresidue = le32_to_cpu(udi_msc_cbw.dCBWDataTransferLength) - udi_msc_cbw_data_residue;\n\tif (residue!= 0) {\n\t\t/* Stall the next request from the USB host on the appropriate endpoint based on the direction of the CBW */\n\t\tif (UDI_MSC_CBW_DIRECTION(udi_msc_cbw.bmCBWFlags)) {\n\t\t\tep_nbr = UDI_MSC_EP_IN;\n\t\t} else {\n\t\t\tep_nbr = UDI_MSC_EP_OUT;\n\t\t}\n\t\tudi_msc_stall_ep(ep_nbr);\n\t}\n\n\t/* Prepare the CSW by setting its tag and converting the data residue to little-endian format */\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(residue);\n\n\t/* Send the CSW */\n\tudi_msc_send_csw();\n}", "CodeBleu_score": 56.286761916069224}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint8_t ep_in = udi_msc_ep_in;\n\tuint8_t ep_out = udi_msc_ep_out;\n\n\t// Check if there is a non-zero data residue\n\tif (udi_msc_cbw_data_residue!= 0) {\n\t\t// Stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW)\n\t\tif (udi_msc_cbw_flags & UDI_MSC_CBW_DIR_IN) {\n\t\t\tudi_msc_stall_ep(ep_in);\n\t\t} else {\n\t\t\tudi_msc_stall_ep(ep_out);\n\t\t}\n\t}\n\n\t// Prepare the CSW by setting its tag and converting the data residue to little-endian format\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw_data_residue;\n\tudi_msc_csw.bCSWStatus = udi_msc_cbw_status;\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\n\tudi_msc_cbw_data_residue = 0;\n\tudi_msc_cbw_status = UDI_MSC_CSW_CMD_PASSED;\n\tudi_msc_cbw_flags = 0;\n\n\t// Send the CSW\n\tudi_msc_send_csw();\n}", "CodeBleu_score": 51.088518162178566}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port == 0) {\n\t\tif (b_enable) {\n\t\t\tif (cdc_serial_state[port].dtr == 0) {\n\t\t\t\tif (cdc_serial_state[port].rate == 1200) {\n\t\t\t\t\tscheduleReset(port);\n\t\t\t\t}\n\t\t\t\tcdc_serial_state[port].dtr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (cdc_serial_state[port].dtr == 1) {\n\t\t\t\tif (cdc_serial_state[port].rate == 1200) {\n\t\t\t\t\tcancelReset(port);\n\t\t\t\t}\n\t\t\t\tcdc_serial_state[port].dtr = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.76328336497785}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port == 0) {\n\t\tif (b_enable) {\n\t\t\tif (g_cdc_dtr_status == false) {\n\t\t\t\tif (g_cdc_baud_rate == 1200) {\n\t\t\t\t\tg_reset_delay = 1000;\n\t\t\t\t\tg_reset_scheduled = true;\n\t\t\t\t\tinitiateReset();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (g_cdc_dtr_status == true) {\n\t\t\t\tg_reset_delay = 0;\n\t\t\t\tg_reset_scheduled = false;\n\t\t\t\tcancelReset();\n\t\t\t}\n\t\t}\n\t\tg_cdc_dtr_status = b_enable;\n\t}\n}", "CodeBleu_score": 33.359802602368596}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= CDC_PORT_COUNT) {\n\t\treturn;\n\t}\n\tif (b_enable) {\n\t\tif (cdc_ports[port].dtr_rate == 1200) {\n\t\t\t/* If the DTR rate is 1200 and the DTR signal is disabled,\n\t\t\t * schedule a delayed system reset. */\n\t\t\tif (!cdc_ports[port].dtr_enabled) {\n\t\t\t\tinitiateReset();\n\t\t\t}\n\t\t} else {\n\t\t\t/* Cancel any scheduled reset. */\n\t\t\tcancelReset();\n\t\t}\n\t}\n\tcdc_ports[port].dtr_enabled = b_enable;\n}", "CodeBleu_score": 39.63609500648724}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tbool    request_handled = false;\n\tuint8_t request_index   = Usb_read_byte();\n\tuint8_t request_type    = Usb_read_byte();\n\tuint8_t descriptor_type = Usb_read_byte();\n\tuint8_t descriptor_index = Usb_read_byte();\n\n\tUsb_ack_receive_setup();\n\n\tif (request_type == 0xA1) {\n\t\tif (request_index == 0x04) {\n\t\t\tUsb_write_byte(sizeof(usb_string_microsoft_os_descriptor));\n\t\t\tUsb_write_byte(0);\n\t\t\tUsb_write_byte(descriptor_type);\n\t\t\tUsb_write_byte(descriptor_index);\n\t\t\trequest_handled = true;\n\t\t} else if (request_index == 0x05) {\n\t\t\tUsb_write_byte(sizeof(usb_string_microsoft_os_extended_properties_descriptor));\n\t\t\tUsb_write_byte(0);\n\t\t\tUsb_write_byte(descriptor_type);\n\t\t\tUsb_write_byte(descriptor_index);\n\t\t\trequest_handled = true;\n\t\t}\n\t}\n\n\tUsb_ack_control_in_ready_send();\n\n\treturn request_handled;\n}", "CodeBleu_score": 14.566770614508734}, {"code": "bool usb_task_other_requests(void){\n\t\tif (usb_setup_pkt.bmRequestType == 0x80) {\n\t\tif (usb_setup_pkt.bRequest == 0x06) {\n\t\t\tusb_setup_pkt.wValue = 0x0100;\n\t\t\tusb_setup_pkt.wIndex = 0x0409;\n\t\t\tusb_setup_pkt.wLength = 0x0004;\n\t\t\tusb_setup_pkt.bmRequestType = 0xC0;\n\t\t\tusb_setup_pkt.bRequest = 0x06;\n\t\t\treturn true;\n\t\t} else if (usb_setup_pkt.bRequest == 0x07) {\n\t\t\tusb_setup_pkt.wValue = 0x0100;\n\t\t\tusb_setup_pkt.wIndex = 0x0409;\n\t\t\tusb_setup_pkt.wLength = 0x0014;\n\t\t\tusb_setup_pkt.bmRequestType = 0xC0;\n\t\t\tusb_setup_pkt.bRequest = 0x07;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 16.247132113871785}, {"code": "bool usb_task_other_requests(void){\n\t\tbool    ret = false;\n\n\tswitch (g_usb_request.bRequest) {\n\tcase GET_EXTENDED_PROPERTIES:\n\t\t// Set up the extended properties descriptor\n\t\tg_usb_request.wValue = 0x0000;\n\t\tg_usb_request.wIndex = 0x0000;\n\t\tg_usb_request.wLength = sizeof(ext_prop_desc);\n\t\tg_usb_request.pData = ext_prop_desc;\n\t\tret = true;\n\t\tbreak;\n\n\tcase GET_MS_COMPAT_ID:\n\t\t// Set up the Microsoft-compatible ID descriptor\n\t\tg_usb_request.wValue = 0x0000;\n\t\tg_usb_request.wIndex = 0x0000;\n\t\tg_usb_request.wLength = sizeof(ms_compat_id_desc);\n\t\tg_usb_request.pData = ms_compat_id_desc;\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 24.757559467952333}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\n\tuint16_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPI_DR = 0xFF;\n\t\twhile (!(SPI_SR & SPI_SR_RXNE));\n\t\tbuf[i] = SPI_DR;\n\t}\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 48.11777945615351}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\n\tif (nbyte == 0)\n\t\treturn;\n\n\tfor (i = 0; i < (nbyte - 1); i++) {\n\t\tSPI_DR = 0xFF;\n\t\twhile ((SPI_SR & SPI_SR_RXNE) == 0)\n\t\t\t;\n\t\tbuf[i] = SPI_DR;\n\t}\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 47.77474404374426}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\twhile (nbyte--) {\n\t\tSPI_DR = 0xFF;\n\t\twhile ((SPI_SR & SPI_SR_RXNE) == 0)\n\t\t\t;\n\t\t*buf++ = SPI_DR;\n\t}\n\t*buf = spiRec();\n}", "CodeBleu_score": 30.424718475546136}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\n\t// Get the address of the relocated interrupt vector table\n\tconst uint32_t *vectorTable = (uint32_t *)SCB->VTOR;\n\n\t// Disable global interrupts\n\t__disable_irq();\n\n\t// Get the current handler for the specified IRQ\n\toldHandler = (pfnISR_Handler)vectorTable[irq + 16];\n\n\t// Replace the current handler with the new handler\n\tvectorTable[irq + 16] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original ISR handler\n\treturn oldHandler;\n}", "CodeBleu_score": 56.64038537240661}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler = NULL;\n\t/*\n\t * The function \"install_isr\" installs a new interrupt service routine (ISR) handler for a specified interrupt request (IRQ) and returns the original handler.\n\t * It first retrieves the address of the relocated interrupt vector table, then disables global interrupts to ensure atomic operation.\n\t * It retrieves the current handler for the specified IRQ, replaces it with the new handler, and then re-enables global interrupts.\n\t * Finally, it returns the original ISR handler.\n\t */\n\t/*\n\t * The function \"install_isr\" installs a new interrupt service routine (ISR) handler for a specified interrupt request (IRQ) and returns the original handler.\n\t * It first retrieves the address of the relocated interrupt vector table, then disables global interrupts to ensure atomic operation.\n\t * It retrieves the current handler for the specified IRQ, replaces it with the new handler, and then re-enables global interrupts.\n\t * Finally, it returns the original ISR handler.\n\t */\n\t/*\n\t * The function \"install_isr\" installs a new interrupt service routine (ISR) handler for a specified interrupt request (IRQ) and returns the original handler.\n\t * It first retrieves the address of the relocated interrupt vector table, then disables global interrupts to ensure atomic operation.\n\t * It retrieves the current handler for the specified IRQ, replaces it with the new handler, and then re-enables global interrupts.\n\t * Finally, it returns the original ISR handler.\n\t */\n\t/*\n\t * The function \"install_isr\" installs a new interrupt service routine (ISR) handler for a specified interrupt request (IRQ) and returns the original handler.\n\t * It first retrieves the address of the relocated interrupt vector table, then disables global interrupts to ensure atomic operation.\n\t * It retrieves the current handler for the specified IRQ, replaces it with the new handler, and then re-enables global interrupts.\n\t * Finally, it returns the original ISR handler.\n\t */\n\t/*\n\t * The function \"install_isr\" installs a new interrupt service routine (ISR) handler for a specified interrupt request (IRQ) and returns the original handler.\n\t * It first retrieves the address of the relocated interrupt vector table, then disables global interrupts to ensure atomic operation.\n\t * It retrieves the current handler for the specified IRQ, replaces it with the new handler, and then re-enables global interrupts.\n\t * Finally, it returns", "CodeBleu_score": 32.11340029907807}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\n\t/*\n\t * Retrieve the address of the relocated interrupt vector table\n\t */\n\tuint32_t *pVectorTable = (uint32_t *)SCB->VTOR;\n\n\t/*\n\t * Disable global interrupts to ensure atomic operation\n\t */\n\t__disable_irq();\n\n\t/*\n\t * Retrieve the current handler for the specified IRQ\n\t */\n\toldHandler = (pfnISR_Handler)pVectorTable[irq];\n\n\t/*\n\t * Replace the current handler with the new handler\n\t */\n\tpVectorTable[irq] = (uint32_t)newHandler;\n\n\t/*\n\t * Re-enable global interrupts\n\t */\n\t__enable_irq();\n\n\t/*\n\t * Return the original ISR handler\n\t */\n\treturn oldHandler;\n}", "CodeBleu_score": 49.685667375833006}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\tif (!USB_CDC_configured) return -1;\n\tif (USB_CDC_rx_buffer_head == USB_CDC_rx_buffer_tail) return -1;\n\treturn USB_CDC_rx_buffer[USB_CDC_rx_buffer_tail];\n}", "CodeBleu_score": 17.37061261518213}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (usb_serial_available()) {\n\t\tint c = usb_serial_getchar();\n\t\tif (c >= 0) {\n\t\t\tif (emergency_parser_enabled)\n\t\t\t\temergency_parser_char(c);\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 35.15515846269672}, {"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_buffer_index) {\n    return emergency_buffer[0];\n  }\n#endif\n\n  if (usb_serial_available()) {\n    char c = usb_serial_getchar();\n    if (c == -1) return -1;\n    process_char(c);\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 41.12149845785641}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (peek() >= 0) return read_char;\n\n\tif (!usb_configured()) return -1;\n\n\tint16_t c = -1;\n\twhile (c < 0) {\n\t\tif (usb_serial_available()) {\n\t\t\tc = usb_serial_getchar();\n\t\t\tif (c >= 0) {\n\t\t\t\tif (emergency_parser_enabled) emergency_parser_push(c);\n\t\t\t\tread_char = c;\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}", "CodeBleu_score": 35.5248004700459}, {"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser_enabled) {\n    if (emergency_parser.available())\n      return emergency_parser.read();\n  }\n#endif\n  if (SerialUSB.available()) {\n    return SerialUSB.read();\n  }\n  return -1;\n}", "CodeBleu_score": 36.62254573910726}, {"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser_enabled)\n    emergency_parser.update();\n#endif\n\n  if (peek() >= 0) return _buffer[_rpos++];\n\n  if (usb_cdc_enabled && usb_cdc_configured) {\n    if (usb_serial_available()) {\n      int c = usb_serial_getchar();\n      if (c >= 0) {\n        if (c == '\\r') c = '\n';\n        _buffer[_wpos++] = c;\n        if (_wpos >= _buffer_max) _wpos = 0;\n      }\n      return c;\n    }\n  }\n\n  return -1;\n}", "CodeBleu_score": 46.02849674335179}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_cdc_is_enabled()) {\n\t\treturn usb_cdc_rx_pending();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 17.55533609523228}, {"code": "int MarlinSerialUSB::available(){\n\t\treturn USB_Recv(USB_CDC_RX_EP, NULL, 0, NULL);\n}", "CodeBleu_score": 5.347470384212666}, {"code": "int MarlinSerialUSB::available(){\n\t\treturn _usb->op_cdc_is_connected()? _usb->available() : 0;\n}", "CodeBleu_score": 26.690081718950097}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint8_t byte;\n\tfor (size_t i = 0; i < size; ++i) {\n\t\tif (!read_byte(pos, &byte)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (writing) {\n\t\t\tvalue[i] = byte;\n\t\t}\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, byte);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.92416346893877}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\t// Read the data from the persistent storage\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (!read_byte(pos, value[i], crc, writing)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 39.19646069744424}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint8_t data;\n\tfor(size_t i = 0; i < size; i++) {\n\t\tif(!read_byte(pos, data)) {\n\t\t\treturn false;\n\t\t}\n\t\tif(writing && value) {\n\t\t\t*value = data;\n\t\t\tvalue++;\n\t\t}\n\t\tif(crc) {\n\t\t\t*crc = crc16_update(*crc, data);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 47.117100516457896}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\t// use hardware PWM if possible\n\tif (ledcWrite(pin, value))\n\t\treturn;\n\n\t// software PWM\n\t// find or create the PWM state for this pin\n\tPWMState *pwm = getPWMState(pin);\n\t// set the PWM frequency\n\tif (pwm->freq!= freq) {\n\t\t// update the frequency\n\t\tpwm->freq = freq;\n\t\t// calculate the timer interval\n\t\tpwm->interval = 1000000 / freq;\n\t\t// calculate the timer overflow count\n\t\tpwm->overflow = pwm->interval / 1000;\n\t\t// calculate the timer overflow remainder\n\t\tpwm->remainder = pwm->interval % 1000;\n\t}\n\t// set the PWM resolution\n\tif (pwm->res!= res) {\n\t\t// update the resolution\n\t\tpwm->res = res;\n\t\t// calculate the PWM resolution\n\t\tpwm->resolution = 1 << res;\n\t}\n\t// set the PWM value\n\tpwm->value = value;\n}", "CodeBleu_score": 20.522111593795326}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\t// check if the pin is valid\n\tif (pin < 0 || pin >= PIN_COUNT) {\n\t\treturn;\n\t}\n\n\t// check if the pin supports PWM\n\tif (!pins[pin].pwm) {\n\t\treturn;\n\t}\n\n\t// check if the value is in range\n\tif (value > (1 << res) - 1) {\n\t\treturn;\n\t}\n\n\t// check if the pin is already in use\n\tif (pwm[pin].in_use) {\n\t\t// check if the frequency is the same\n\t\tif (pwm[pin].freq!= freq) {\n\t\t\t// stop the timer\n\t\t\tledcDetachPin(pin);\n\t\t\t// set the frequency\n\t\t\tpwm[pin].freq = freq;\n\t\t\t// start the timer\n\t\t\tledcSetup(pwm[pin].channel, freq, res);\n\t\t\tledcAttachPin(pin, pwm[pin].channel);\n\t\t}\n\t} else {\n\t\t// set the frequency\n\t\tpwm[pin].freq = freq;\n\t\t// set the resolution\n\t\tpwm[pin].res = res;\n\t\t// set the channel\n\t\tpwm[pin].channel = pins[pin].pwm_channel;\n\t\t// set the in use flag\n\t\tpwm[pin].in_use = true;\n\t\t// start the timer\n\t\tledcSetup(pwm[pin].channel, freq, res);\n\t\tledcAttachPin(pin, pwm[pin].channel);\n\t}\n\n\t// set the PWM value\n\tledcWrite(pwm[pin].channel, value);\n}", "CodeBleu_score": 35.64972472546142}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin == 0) {\n\t\treturn;\n\t}\n\tif (pin >= 32) {\n\t\treturn;\n\t}\n\tif (pin < 18) {\n\t\tledcWrite(pin, value);\n\t\treturn;\n\t}\n\tif (pin < 22) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 22) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 23) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 26) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 27) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 32) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 33) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 34) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 35) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 36) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 39) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 4) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 5) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (pin == 12) {\n\t\tledcWrite(pin + 12, value);\n\t\treturn;\n\t}\n\tif (", "CodeBleu_score": 21.632732606354615}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == 24, \"Servo delay array length must be 24\");\n\tif (servo_attached) {\n\t\twrite(value);\n\t\tdelay(servo_delay[servo_channel]);\n\t\t#if DEACTIVATE_SERVOS_AFTER_MOVE\n\t\t\tdetach();\n\t\t#endif\n\t}\n}", "CodeBleu_score": 36.13858930407595}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == 16, \"Servo delay array length is not 16\");\n\tif (servo.attach(servoPin)) {\n\t\tservo.write(value);\n\t\tdelay(servoDelayArray[servoChannel]);\n\t}\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n\tservo.detach();\n#endif\n}", "CodeBleu_score": 47.31117210827765}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == 3, \"Servo delay array length is not 3\");\n\tif (attach(servo_pin)) {\n\t\twrite(value);\n\t\tdelay(servo_delay_array[servo_pin]);\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n\t\tdetach();\n#endif\n\t}\n}", "CodeBleu_score": 45.315302196772386}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tuint32_t port_data = 0;\n\tuint32_t i;\n\n\tfor (i = 0; i < I2S_MAX_PINS; i++) {\n\t\tif (i2s_pwm_duty_cycle[i] > 0) {\n\t\t\tif (i2s_pwm_tick_count[i] == 0) {\n\t\t\t\ti2s_pwm_tick_count[i] = i2s_pwm_duty_cycle[i];\n\t\t\t\ti2s_pwm_state[i] =!i2s_pwm_state[i];\n\t\t\t}\n\t\t\ti2s_pwm_tick_count[i]--;\n\t\t}\n\t\tif (i2s_pwm_state[i]) {\n\t\t\tport_data |= (1 << i);\n\t\t}\n\t}\n\n\t*i2s_dma_buffer_ptr++ = port_data;\n\tif (i2s_dma_buffer_ptr >= i2s_dma_buffer + I2S_BUFFER_SIZE) {\n\t\ti2s_dma_buffer_ptr = i2s_dma_buffer;\n\t}\n}", "CodeBleu_score": 27.245026241914427}, {"code": "void i2s_push_sample(){\n\t\tuint32_t i;\n\tuint32_t port_data = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tif (pwm[i].duty_cycle > 0) {\n\t\t\tif (pwm[i].tick_count == 0) {\n\t\t\t\tpwm[i].tick_count = pwm[i].duty_cycle;\n\t\t\t\tpwm[i].state =!pwm[i].state;\n\t\t\t}\n\t\t\tpwm[i].tick_count--;\n\t\t\tport_data |= (pwm[i].state << i);\n\t\t}\n\t}\n\t*dma_buffer_pos = port_data;\n\tdma_buffer_pos++;\n}", "CodeBleu_score": 30.28637808109108}, {"code": "void i2s_push_sample(){\n\t\tuint32_t port_data = 0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tif (i2s_pin_state[i] == I2S_PIN_STATE_OFF) {\n\t\t\tif (i2s_pin_duty_cycle[i] > 0) {\n\t\t\t\ti2s_pin_state[i] = I2S_PIN_STATE_ON;\n\t\t\t\ti2s_pin_tick_count[i] = i2s_pin_duty_cycle[i];\n\t\t\t}\n\t\t} else {\n\t\t\tif (i2s_pin_tick_count[i] == 0) {\n\t\t\t\ti2s_pin_state[i] = I2S_PIN_STATE_OFF;\n\t\t\t\ti2s_pin_tick_count[i] = i2s_pin_duty_cycle[i] + i2s_pin_period_count[i];\n\t\t\t}\n\t\t}\n\t\tif (i2s_pin_state[i] == I2S_PIN_STATE_ON) {\n\t\t\tport_data |= (1 << i);\n\t\t}\n\t\tif (i2s_pin_tick_count[i] > 0) {\n\t\t\ti2s_pin_tick_count[i]--;\n\t\t}\n\t}\n\ti2s_dma_buffer[i2s_dma_buffer_pos] = port_data;\n\ti2s_dma_buffer_pos++;\n\tif (i2s_dma_buffer_pos == I2S_DMA_BUFFER_SIZE) {\n\t\ti2s_dma_buffer_pos = 0;\n\t}\n}", "CodeBleu_score": 29.246166048031036}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tuint32_t timer_base = (uint32_t)HAL_TIMER_BASE_ADDR + (timer_num * HAL_TIMER_OFFSET);\n\tuint32_t timer_count = *((uint32_t *)(timer_base + HAL_TIMER_COUNT_OFFSET));\n\treturn (hal_timer_t)timer_count;\n}", "CodeBleu_score": 32.98729838700157}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tif (timer_num > 7) {\n\t\treturn 0;\n\t}\n\treturn timer_counters[timer_num];\n}", "CodeBleu_score": 19.240670570926348}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer = hal_timer_get_timer(timer_num);\n\treturn timer->timer_count;\n}", "CodeBleu_score": 28.024745910206782}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tif (pos >= _size) {\n\t\treturn false;\n\t}\n\n\tfor (int i = 0; i < size; i++) {\n\t\tif (pos >= _size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (writing) {\n\t\t\tvalue[i] = EEPROM.read(pos);\n\t\t}\n\t\tupdate_crc(crc, EEPROM.read(pos));\n\t\tpos++;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 51.170354238129164}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\t// Read the data from the EEPROM\n\tfor (size_t i = 0; i < size; ++i) {\n\t\t// Read the data from the EEPROM\n\t\t*value = EEPROM.read(pos);\n\n\t\t// Update the CRC\n\t\tif (crc) {\n\t\t\t*crc = _crc16_update(*crc, *value);\n\t\t}\n\n\t\t// Write the data to the buffer\n\t\tif (writing) {\n\t\t\t*value = *value;\n\t\t}\n\n\t\t// Increment the position pointer\n\t\t++pos;\n\t}\n\n\t// Return false upon completion\n\treturn false;\n}", "CodeBleu_score": 49.92127798293578}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\tif (writing) {\n\t\t\tvalue[i] = EEPROM.read(pos + i);\n\t\t}\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, EEPROM.read(pos + i));\n\t\t}\n\t}\n\tpos += size;\n\treturn false;\n}", "CodeBleu_score": 66.13910154731562}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (sdio_handle == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: SDIO handle is null\n\");\n\t\treturn false;\n\t}\n\tif (src == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: Source pointer is null\n\");\n\t\treturn false;\n\t}\n\n\tbool success = false;\n\tfor (int i = 0; i < SDIO_WRITE_RETRIES; i++) {\n\t\tif (HAL_SD_WriteBlocks(sdio_handle, (uint8_t *)src, block, 1, 1000) == HAL_OK) {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!success) {\n\t\tprintf(\"SDIO_WriteBlock: Write failed\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 43.42231938057159}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (hsd == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: SDIO handle is null\n\");\n\t\treturn false;\n\t}\n\tif (src == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: Source pointer is null\n\");\n\t\treturn false;\n\t}\n\tHAL_StatusTypeDef status;\n\tfor (int i = 0; i < SDIO_WRITE_RETRIES; i++) {\n\t\tstatus = HAL_SD_WriteBlocks(hsd, (uint8_t *)src, block, 1, 1000);\n\t\tif (status == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tprintf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n\treturn false;\n}", "CodeBleu_score": 44.19996839630131}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (!sdio_handle ||!src)\n\t\treturn false;\n\tfor (uint8_t i = 0; i < SDIO_MAX_RETRIES; i++) {\n\t\tif (HAL_SD_WriteBlocks(sdio_handle, (uint8_t*) src, block, 1, 1000) == HAL_OK)\n\t\t\treturn true;\n\t}\n\tprintf(\"SDIO_WriteBlock failed\n\");\n\treturn false;\n}", "CodeBleu_score": 30.785303642728636}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tuint32_t timer_prescale;\n\tuint32_t timer_reload;\n\tuint32_t timer_priority;\n\n\tassert(timer_num < TIMER_CHANNEL_MAX);\n\n\tswitch (timer_num) {\n\t\tcase TIMER_CHANNEL_TEMPERATURE:\n\t\t\ttimer_prescale = TIMER_TEMPERATURE_PRESCALE;\n\t\t\ttimer_priority = TIMER_TEMPERATURE_PRIORITY;\n\t\t\tbreak;\n\t\tcase TIMER_CHANNEL_STEPPER:\n\t\t\ttimer_prescale = TIMER_STEPPER_PRESCALE;\n\t\t\ttimer_priority = TIMER_STEPPER_PRIORITY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t\tbreak;\n\t}\n\n\ttimer_reload = HAL_clock_get_frequency(CLOCK_SOURCE_APB) / (timer_prescale * frequency);\n\n\ttimer_config_t config = {\n\t\t.prescaler = timer_prescale,\n\t\t.reload = timer_reload,\n\t\t.mode = TIMER_MODE_ONESHOT,\n\t\t.priority = timer_priority,\n\t\t.callback = HAL_timer_callback,\n\t};\n\n\tHAL_timer_configure(timer_num, &config);\n\tHAL_timer_start_counting(timer_num);\n}", "CodeBleu_score": 32.289770661294035}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tswitch (timer_num) {\n\tcase TIMER_TEMP:\n\t\ttimer_init(TIMER_TEMP, frequency, TEMP_TIMER_PRESCALE);\n\t\tbreak;\n\tcase TIMER_STEP:\n\t\ttimer_init(TIMER_STEP, frequency, STEPPER_TIMER_PRESCALE);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(false);\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 21.320746555175347}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tswitch (timer_num) {\n\tcase TEMP_TIMER:\n\t\t// Set the prescaler and frequency of the timer.\n\t\ttimer_init(TEMP_TIMER, temperature_timer_prescale, frequency);\n\t\t// Set the callback priority for temperature.\n\t\ttimer_set_callback_priority(TEMP_TIMER, TEMP_TIMER_PRIORITY);\n\t\tbreak;\n\tcase STEP_TIMER:\n\t\t// Set the prescaler and frequency of the timer.\n\t\ttimer_init(STEP_TIMER, stepper_timer_prescale, frequency);\n\t\t// Set the callback priority for stepper.\n\t\ttimer_set_callback_priority(STEP_TIMER, STEP_TIMER_PRIORITY);\n\t\tbreak;\n\tdefault:\n\t\t// If the timer channel is invalid, trigger an assertion failure.\n\t\tASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 27.05690886851612}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\t// open the file\n\tfile = fopen(filename, \"r+b\");\n\tif (file == NULL) {\n\t\treturn false;\n\t}\n\n\t// check the file size\n\tfseek(file, 0, SEEK_END);\n\tsize_t file_size = ftell(file);\n\tfseek(file, 0, SEEK_SET);\n\tif (file_size < size) {\n\t\t// fill the remainder of the buffer with a default erase value\n\t\tfor (size_t i = file_size; i < size; i++) {\n\t\t\tbuffer[i] = default_erase_value;\n\t\t}\n\t}\n\n\t// read the file's contents into the buffer\n\tfread(buffer, 1, size, file);\n\n\t// close the file\n\tfclose(file);\n\n\treturn true;\n}", "CodeBleu_score": 39.66801808201278}, {"code": "bool PersistentStore::access_start(){\n\t\tbool success = false;\n\tif (EEPROM_SIZE > 0) {\n\t\tif (EEPROM_FILENAME!= NULL) {\n\t\t\t// Open EEPROM file\n\t\t\tEEPROM_FILE = fopen(EEPROM_FILENAME, \"r+b\");\n\t\t\tif (EEPROM_FILE!= NULL) {\n\t\t\t\t// Get file size\n\t\t\t\tfseek(EEPROM_FILE, 0, SEEK_END);\n\t\t\t\tlong file_size = ftell(EEPROM_FILE);\n\t\t\t\tfseek(EEPROM_FILE, 0, SEEK_SET);\n\t\t\t\t// If file is smaller than EEPROM size, fill remainder of buffer with default erase value\n\t\t\t\tif (file_size < EEPROM_SIZE) {\n\t\t\t\t\tfor (long i = file_size; i < EEPROM_SIZE; i++) {\n\t\t\t\t\t\tfputc(EEPROM_DEFAULT_ERASE, EEPROM_FILE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Read file contents into buffer\n\t\t\t\tfread(EEPROM_BUFFER, sizeof(char), EEPROM_SIZE, EEPROM_FILE);\n\t\t\t\t// Close file\n\t\t\t\tfclose(EEPROM_FILE);\n\t\t\t\tsuccess = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn success;\n}", "CodeBleu_score": 41.94338958911226}, {"code": "bool PersistentStore::access_start(){\n\t\t// open the file\n\tEEPROM_file = SD.open(EEPROM_filename, FILE_READ);\n\tif (!EEPROM_file) {\n\t\t// file does not exist or cannot be opened\n\t\treturn false;\n\t}\n\n\t// check the file size\n\tint file_size = EEPROM_file.size();\n\tif (file_size < EEPROM_size) {\n\t\t// file is smaller than expected EEPROM size\n\t\t// fill the remainder of the buffer with the default erase value\n\t\tfor (int i = file_size; i < EEPROM_size; i++) {\n\t\t\tEEPROM_buffer[i] = EEPROM_erase_value;\n\t\t}\n\t} else if (file_size > EEPROM_size) {\n\t\t// file is larger than expected EEPROM size\n\t\t// truncate the file to the expected EEPROM size\n\t\tEEPROM_file.truncate(EEPROM_size);\n\t}\n\n\t// read the file's contents into the buffer\n\tEEPROM_file.read(EEPROM_buffer, EEPROM_size);\n\n\t// close the file\n\tEEPROM_file.close();\n\n\treturn true;\n}", "CodeBleu_score": 35.01150931785487}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t ret = 0;\n\n\tfor(i = 0; i < 8; i++) {\n\t\t// Set clock pin low\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\n\t\t// Write the most significant bit of the byte to the MOSI pin\n\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80)? GPIO_PIN_SET : GPIO_PIN_RESET);\n\n\t\t// Shift the byte left\n\t\tb <<= 1;\n\n\t\t// Toggle the clock pin high\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\n\t\t// Read the bit from the MISO pin\n\t\tret <<= 1;\n\t\tif(HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) {\n\t\t\tret |= 1;\n\t\t}\n\t}\n\n\t// Delay before returning the received byte\n\t__asm(\"nop\");\n\n\treturn ret;\n}", "CodeBleu_score": 36.15375226697497}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i, r = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tb <<= 1;\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin)) {\n\t\t\tr |= 0x01;\n\t\t}\n\t\tr <<= 1;\n\t}\n\tr >>= 1;\n\tHAL_Delay(1);\n\treturn r;\n}", "CodeBleu_score": 37.213157135187046}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t r = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_CLK_LOW();\n\t\tif (b & 0x80) {\n\t\t\tHAL_SPI_STM32_MOSI_HIGH();\n\t\t} else {\n\t\t\tHAL_SPI_STM32_MOSI_LOW();\n\t\t}\n\t\tb <<= 1;\n\t\tHAL_SPI_STM32_CLK_HIGH();\n\t\tif (HAL_SPI_STM32_MISO_READ()) {\n\t\t\tr |= 1;\n\t\t}\n\t\tr <<= 1;\n\t\tHAL_SPI_STM32_CLK_LOW();\n\t}\n\tHAL_SPI_STM32_CLK_LOW();\n\tHAL_Delay(1);\n\treturn r >> 1;\n}", "CodeBleu_score": 36.198885196096015}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 42.579826607808776}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 42.579826607808776}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tif (obj == NULL) return;\n\tif (obj->index >= SERIAL_RX_BUFFER_SIZE) return;\n\tuint8_t c = obj->device->regs->data;\n\tif (obj->device->regs->status & (1 << 4)) {\n\t\t// Parity error\n\t\tobj->parity_error = true;\n\t} else {\n\t\tobj->buffer[obj->index++] = c;\n\t\tobj->head = obj->index;\n\t\tif (obj->index >= SERIAL_RX_BUFFER_SIZE) {\n\t\t\tobj->overflow = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 32.787082431942935}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tif (obj->index >= RX_BUFFER_SIZE) obj->index = 0;\n\tuint8_t c = obj->regs->data;\n\tif (obj->regs->status & USART_SR_PE) {\n\t\tobj->regs->status = USART_SR_PE;\n\t\tobj->overflow = true;\n\t\treturn;\n\t}\n\tif (obj->regs->status & USART_SR_FE) {\n\t\tobj->regs->status = USART_SR_FE;\n\t\tobj->overflow = true;\n\t\treturn;\n\t}\n\tif (obj->regs->status & USART_SR_NE) {\n\t\tobj->regs->status = USART_SR_NE;\n\t\tobj->overflow = true;\n\t\treturn;\n\t}\n\tif (obj->regs->status & USART_SR_ORE) {\n\t\tobj->regs->status = USART_SR_ORE;\n\t\tobj->overflow = true;\n\t\treturn;\n\t}\n\tobj->buffer[obj->index++] = c;\n\tobj->regs->status = USART_SR_RXNE;\n\tif (obj->emergency_func) obj->emergency_func(c);\n}", "CodeBleu_score": 32.31662833241338}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t#if defined(SERIAL_RX_BUFFER_SIZE) && SERIAL_RX_BUFFER_SIZE > 0\n  // If no parity error occurs, read the byte and store it in the receive buffer if there is space available.\n  // Calculate the next buffer index and update the head pointer.\n  if (obj->device->USART->ISR & USART_ISR_PE) {\n    obj->device->USART->ICR = USART_ICR_PECF;\n  } else {\n    uint32_t next_head = (obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n    if (next_head!= obj->rx_tail) {\n      obj->rx_buffer[obj->rx_head] = obj->device->USART->RDR;\n      obj->rx_head = next_head;\n    }\n  }\n#endif\n}", "CodeBleu_score": 48.2989710603124}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (mf_timer_step_init) {\n\t\t\tif (!mf_timer_step_has_interrupt) {\n\t\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t\t\tmf_timer_step_has_interrupt = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse if (timer_num == MF_TIMER_TEMP) {\n\t\tif (mf_timer_temp_init) {\n\t\t\tif (!mf_timer_temp_has_interrupt) {\n\t\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t\t\tmf_timer_temp_has_interrupt = 1;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.51443595794556}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (HAL_timer_is_initialized(timer_num) &&!HAL_timer_has_interrupt(timer_num)) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (HAL_timer_is_initialized(timer_num) &&!HAL_timer_has_interrupt(timer_num)) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.97009454921431}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tswitch (timer_num) {\n\tcase MF_TIMER_STEP:\n\t\tif (!timer_step_initialized) {\n\t\t\ttimer_step_initialized = true;\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t}\n\t\tbreak;\n\tcase MF_TIMER_TEMP:\n\t\tif (!timer_temp_initialized) {\n\t\t\ttimer_temp_initialized = true;\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 44.60419985119521}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\n\t// Rabin-Karp search\n\thsep := hashStr(sep)\n\th := hashStr(s[n-m:])\n\tfor i := n - m; i >= 0; i-- {\n\t\tif h == hsep && equalStr(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t\tif i > 0 {\n\t\t\th = hashStr(s[i-1 : i+m-1])\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 35.72481644583061}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\n\thashsep, pow := hashStr(sep, n)\n\th := hashStr(s[n-m:n], n)\n\tif h == hashsep && equalStr(s[n-m:n], sep) {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\th *= primeRK\n\t\th += int64(s[i])\n\t\th -= int64(s[i+m]) * pow\n\t\tif h == hashsep && equalStr(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 48.20953955477424}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif n < m {\n\t\treturn -1\n\t}\n\th := hashStr(sep)\n\thash := hashStr(s[n-m:])\n\tif hash == h && equalStr(s[n-m:], sep) {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\thash *= primeRK\n\t\thash += uint32(s[i])\n\t\thash -= uint32(s[i+m]) * hm\n\t\tif hash == h && equalStr(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 46.49153549807089}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tmask := machine.DisableInterrupts()\n\n\t// If there is data in the transmit buffer, send it to the USB endpoint\n\tif usbcdc.txc > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// If there is no data in the transmit buffer, set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore the interrupt mask\n\tmachine.RestoreInterrupts(mask)\n}", "CodeBleu_score": 52.18962739076874}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tmask := interrupt.Disable()\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txcBuf.Len() > 0 {\n\t\t// Send data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// No data is available, so set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\t// Restore the interrupt mask\n\tinterrupt.Restore(mask)\n}", "CodeBleu_score": 58.91618531845126}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tmask := interrupt.Disable()\n\n\t// If there is data in the transmit buffer, send it to the USB endpoint\n\tif len(usbcdc.txc) > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// If there is no data in the transmit buffer, set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore the interrupt mask\n\tinterrupt.Restore(mask)\n}", "CodeBleu_score": 52.11059636367479}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.TWCR.Set(i2c.TWCR.Get() | (1 << i2c.TWINT) | (1 << i2c.TWSTA) | (1 << i2c.TWEN))\n\tfor!i2c.TWCR.IsSet(i2c.TWINT) {\n\t\tinterrupt.Yield()\n\t}\n\ti2c.TWDR.Set(uint8(address << 1) | (uint8(!write) << 0))\n\ti2c.TWCR.Set(i2c.TWCR.Get() | (1 << i2c.TWINT) | (1 << i2c.TWEN))\n\tfor!i2c.TWCR.IsSet(i2c.TWINT) {\n\t\tinterrupt.Yield()\n\t}\n}", "CodeBleu_score": 32.06359691542345}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.TWCR = (i2c.TWCR &^ (avr.TWSTA | avr.TWSTO)) | avr.TWINT | avr.TWEN\n\tfor (i2c.TWCR & avr.TWINT) == 0 {\n\t}\n\ti2c.TWDR = address | (1 - uint8(write))\n\ti2c.TWCR = avr.TWINT | avr.TWEN\n\tfor (i2c.TWCR & avr.TWINT) == 0 {\n\t}\n}", "CodeBleu_score": 34.056039557120926}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.TWCR = (1<<i2c.TWINT) | (1<<i2c.TWSTA) | (1<<i2c.TWEN)\n\tfor (i2c.TWCR & (1<<i2c.TWINT)) == 0 {\n\t}\n\ti2c.TWDR = (address << 1) | (uint8(write) << 0)\n\ti2c.TWCR = (1<<i2c.TWINT) | (1<<i2c.TWEN)\n\tfor (i2c.TWCR & (1<<i2c.TWINT)) == 0 {\n\t}\n}", "CodeBleu_score": 32.83494924457411}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif len <= 0 {\n\t\treturn nil\n\t}\n\n\tstartAddr := f.startAddr + uint32(start*f.blockSize)\n\tendAddr := startAddr + uint32(len*f.blockSize)\n\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Wen)\n\tfor addr := startAddr; addr < endAddr; addr += f.blockSize {\n\t\tnrf.NVMC.ERASEPAGE.Set(addr)\n\t\tfor nrf.NVMC.READY.Get()!= 1 {}\n\t}\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 43.307737081668066}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := f.startAddress + uint32(start)*uint32(f.blockSize)\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Een)\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(startAddress + uint32(i)*uint32(f.blockSize))\n\t\tfor nrf.NVMC.READY.Get() == 0 {\n\t\t}\n\t}\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\treturn nil\n}", "CodeBleu_score": 41.82624713686798}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := f.startAddr + uint32(start)*f.blockSize\n\tendAddr := startAddr + uint32(len)*f.blockSize\n\n\tnrf.NVMC.CONFIG.SetBits(nrf.NVMC_CONFIG_WEN_Een)\n\tfor addr := startAddr; addr < endAddr; addr += f.blockSize {\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(addr))\n\t\tfor nrf.NVMC.READY.HasBits(nrf.NVMC_READY_READY_Busy) {\n\t\t}\n\t}\n\tnrf.NVMC.CONFIG.SetBits(nrf.NVMC_CONFIG_WEN_Ren)\n\treturn nil\n}", "CodeBleu_score": 42.00185347825535}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, ErrNegativeOffset\n\t}\n\tif off >= int64(f.size) {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tstartAddr := f.base + uint32(off)\n\tendAddr := startAddr + uint32(len(p))\n\tif endAddr > f.base+f.size {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\n\t// Pad the data to the write block size.\n\tpadSize := int(f.writeBlockSize) - (len(p) % int(f.writeBlockSize))\n\tif padSize == int(f.writeBlockSize) {\n\t\tpadSize = 0\n\t}\n\tp = append(p, make([]byte, padSize)...)\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.CONFIG.SetBits(nrf.NVMC_CONFIG_WEN_Wen)\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(p); i += int(f.writeBlockSize) {\n\t\t// Wait for the flash memory to be ready.\n\t\tfor nrf.NVMC.READY.HasBits(nrf.NVMC_READY_READY_Busy) {}\n\n\t\t// Write the block.\n\t\tblock := (*[unsafe.Sizeof(uint32(0))]byte)(unsafe.Pointer(&p[i]))\n\t\taddr := (*[unsafe.Sizeof(uint32(0))]byte)(unsafe.Pointer(uintptr(startAddr) + uintptr(i)))\n\t\tbinary.LittleEndian.PutUint32(addr, binary.LittleEndian.Uint32(block))\n\t}\n\n\t// Disable write mode on the flash memory controller.\n\tnrf.NVMC.CONFIG.SetBits(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 34.19156863631402}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\tstart := f.start + uint32(off)\n\tp = pad(p, f.writeBlockSize)\n\tnrf.NVMC.CONFIG.SetBits(nrf.NVMC_CONFIG_WEN_Wen)\n\tfor len(p) > 0 {\n\t\tif err := f.wait(); err!= nil {\n\t\t\treturn n, err\n\t\t}\n\t\tbinary.LittleEndian.PutUint32(f.buf[:], uint32(start))\n\t\tcopy(f.buf[4:], p[:f.writeBlockSize])\n\t\tp = p[f.writeBlockSize:]\n\t\tstart += uint32(f.writeBlockSize)\n\t\tf.buf.Flush()\n\t}\n\treturn len(p), nil\n}", "CodeBleu_score": 33.880779181627155}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds\n\tif off < 0 || off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, ErrOutOfRange\n\t}\n\n\t// Calculate the start address for writing\n\tstart := uintptr(f.start) + uintptr(off)\n\n\t// Pad the byte slice to fit the write block size\n\tp = pad(p, f.writeBlockSize)\n\n\t// Enable write mode on the flash memory controller\n\tf.enableWrite()\n\n\t// Write the data in blocks\n\tfor len(p) > 0 {\n\t\t// Write the data to the flash memory\n\t\tnrf.NVMC.WriteWord.Set(uint32(start))\n\t\t*(*uint32)(unsafe.Pointer(start)) = binary.LittleEndian.Uint32(p)\n\n\t\t// Wait for the flash memory to be ready\n\t\tfor!f.isReady() {\n\t\t\t// Do nothing\n\t\t}\n\n\t\t// Update the start address and the byte slice\n\t\tstart += uintptr(f.writeBlockSize)\n\t\tp = p[f.writeBlockSize:]\n\t}\n\n\t// Return the number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 34.37087151143965}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err!= nil {\n\t\t// If the error is EINTR, try again\n\t\tif err == syscall.EINTR {\n\t\t\tdir, err = syscall.Fdopendir(dupFd)\n\t\t}\n\t\tif err!= nil {\n\t\t\t// Close the duplicated file descriptor\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\n\t// Return the directory pointer\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 60.118791063222176}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// duplicate the file descriptor\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"darwinOpenDir: syscall.Dup failed\", err\n\t}\n\n\t// loop until we either succeed or get an error other than \"syscall.EINTR\"\n\tfor {\n\t\t// attempt to open the directory\n\t\tdirPtr, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\t// we're done\n\t\t\treturn dirPtr, \"\", nil\n\t\t}\n\n\t\t// check for error other than \"syscall.EINTR\"\n\t\tif err!= syscall.EINTR {\n\t\t\t// close the duplicated file descriptor\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"darwinOpenDir: syscall.Fdopendir failed\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 52.063038331017154}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Attempt to open the directory\n\tdirPtr, err := syscall.Fdopendir(dupFd)\n\tif err == nil {\n\t\treturn dirPtr, \"\", nil\n\t}\n\t// Check for EINTR error\n\tif err!= syscall.EINTR {\n\t\t// Close the duplicated file descriptor\n\t\tsyscall.Close(dupFd)\n\t\treturn 0, \"\", err\n\t}\n\t// Keep trying to open the directory until it succeeds or encounters an error other than EINTR\n\tfor {\n\t\t// Open the directory\n\t\tdirPtr, err = syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\t// Check for EINTR error\n\t\tif err!= syscall.EINTR {\n\t\t\t// Close the duplicated file descriptor\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\t// Return the directory pointer and no error\n\treturn dirPtr, \"\", nil\n}", "CodeBleu_score": 54.77163001229874}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tconst esp_partition_t *running = esp_ota_get_running_partition();\n\tif (running == NULL) {\n\t\treturn 0;\n\t}\n\tconst esp_partition_pos_t pos = running->pos;\n\tconst size_t size = running->size;\n\tif (pos.offset == 0 && size == 0) {\n\t\treturn 0;\n\t}\n\tconst uint32_t start = pos.offset;\n\tconst uint32_t end = start + size;\n\tconst uint32_t flash_size = spi_flash_get_chip_size();\n\tif (end > flash_size) {\n\t\treturn 0;\n\t}\n\tconst uint32_t image_size = esp_image_get_image_len_from_partition(running);\n\tif (image_size == 0) {\n\t\treturn 0;\n\t}\n\tconst uint32_t image_end = start + image_size;\n\tif (image_end > end) {\n\t\treturn 0;\n\t}\n\tif (response == FREE_SPACE) {\n\t\treturn (end - image_end);\n\t}\n\treturn image_size;\n}", "CodeBleu_score": 51.413734167963085}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tconst esp_partition_t *partition = esp_ota_get_running_partition();\n\tuint32_t size = partition->size;\n\tif (response == SKETCH_SIZE_AVAILABLE) {\n\t\tif (partition->encrypted) {\n\t\t\tsize = 0;\n\t\t} else {\n\t\t\tsize -= partition->address;\n\t\t}\n\t}\n\treturn size;\n}", "CodeBleu_score": 33.268973806510694}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t* partition = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_FACTORY, NULL);\n\tif (partition == NULL) {\n\t\treturn 0;\n\t}\n\tesp_image_metadata_t metadata;\n\tif (esp_partition_get_image_metadata(partition, ESP_IMAGE_FLASH_SIZE_4MB, &metadata)!= ESP_OK) {\n\t\treturn 0;\n\t}\n\tif (response == SKETCH_SIZE_FREE) {\n\t\treturn partition->size - metadata.image_len;\n\t} else {\n\t\treturn metadata.image_len;\n\t}\n}", "CodeBleu_score": 42.959225079277275}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\t// Calculate the required disk sectors\n\tuint32_t disk_sectors = 2; // Boot sector and FAT\n\tdisk_sectors += (MSC_DATA_SIZE / MSC_SECTOR_SIZE); // Data sectors\n\n\t// Allocate memory for the RAM disk\n\tuint8_t *disk_memory = (uint8_t *)malloc(disk_sectors * MSC_SECTOR_SIZE);\n\tif (disk_memory == NULL) {\n\t\tLOG_ERROR(\"Failed to allocate memory for RAM disk\");\n\t\treturn false;\n\t}\n\n\t// Set up the boot sector and FAT\n\tmsc_update_setup_boot_sector(disk_memory, volume_label, serial_number, disk_sectors);\n\tmsc_update_setup_fat(disk_memory, disk_sectors);\n\n\t// Add a root directory entry for a firmware file if a partition is running\n\tif (partition_is_running()) {\n\t\tmsc_update_add_firmware_file(disk_memory, disk_sectors);\n\t}\n\n\t// Set up the MSC device with the RAM disk\n\tmsc_update_setup_device(disk_memory, disk_sectors);\n\n\treturn true;\n}", "CodeBleu_score": 26.118188509465362}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t sector_count = 0;\n\tuint8_t *disk_buffer = NULL;\n\tuint32_t disk_sector_count = 0;\n\tuint32_t disk_fat_sectors = 0;\n\tuint32_t disk_root_directory_sectors = 0;\n\tuint32_t disk_data_sectors = 0;\n\tuint32_t disk_first_data_sector = 0;\n\tuint32_t disk_root_directory_first_sector = 0;\n\tuint32_t disk_root_directory_last_sector = 0;\n\tuint32_t disk_root_directory_first_cluster = 0;\n\tuint32_t disk_root_directory_last_cluster = 0;\n\tuint32_t disk_root_directory_cluster_count = 0;\n\tuint32_t disk_root_directory_cluster_first_sector = 0;\n\tuint32_t disk_root_directory_cluster_last_sector = 0;\n\tuint32_t disk_root_directory_cluster_first_data_sector = 0;\n\tuint32_t disk_root_directory_cluster_last_data_sector = 0;\n\tuint32_t disk_root_directory_cluster_first_data_cluster = 0;\n\tuint32_t disk_root_directory_cluster_last_data_cluster = 0;\n\tuint32_t disk_root_directory_cluster_data_cluster_count = 0;\n\tuint32_t disk_root_directory_cluster_data_cluster_first_sector = 0;\n\tuint32_t disk_root_directory_cluster_data_cluster_last_sector = 0;\n\tuint32_t disk_root_directory_cluster_data_cluster_first_data_sector = 0;\n\tuint32_t disk_root_directory_cluster_data_cluster_last_data_sector = 0;\n\tuint32_t disk_root_directory_cluster_data_cluster_first_data_cluster = 0", "CodeBleu_score": 7.404819994388359}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t sectors_per_cluster = 1;\n\tuint32_t sectors_per_fat = 1;\n\tuint32_t sectors_per_root_directory = 1;\n\tuint32_t sectors_per_data_area = 0;\n\tuint32_t sectors_per_volume = 0;\n\tuint32_t cluster_count = 0;\n\tuint32_t cluster_root_directory = 0;\n\tuint32_t cluster_first_data = 0;\n\tuint32_t cluster_current = 0;\n\tuint32_t cluster_last = 0;\n\tuint32_t cluster_next = 0;\n\tuint32_t cluster_previous = 0;\n\tuint32_t cluster_index = 0;\n\tuint32_t cluster_count_free = 0;\n\tuint32_t cluster_count_used = 0;\n\tuint32_t cluster_count_total = 0;\n\tuint32_t cluster_count_root_directory = 0;\n\tuint32_t cluster_count_data_area = 0;\n\tuint32_t cluster_count_fat = 0;\n\tuint32_t cluster_count_boot_sector = 0;\n\tuint32_t cluster_count_volume = 0;\n\tuint32_t cluster_count_reserved = 0;\n\tuint32_t cluster_count_total_available = 0;\n\tuint32_t cluster_count_total_used = 0;\n\tuint32_t cluster_count_total_free = 0;\n\tuint32_t cluster_count_total_reserved = 0;\n\tuint32_t cluster_count_total_unallocated = 0;\n\tuint32_t cluster_count_total_allocated = 0;\n\tuint32_t cluster_count_total_bad = 0;\n\tuint32_t cluster_count_total_deleted = 0;\n\tuint32_t cluster_count_total_", "CodeBleu_score": 7.1136794197098645}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\t// Check if the offset is aligned with the flash sector size\n\tif (offset % SPI_FLASH_SEC_SIZE!= 0) {\n\t\tESP_LOGE(TAG, \"Offset is not aligned with flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\t// Erase the sector before writing new data\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase sector: %s\", esp_err_to_name(err));\n\t\treturn err;\n\t}\n\n\t// Write the data to the specified offset\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write data: %s\", esp_err_to_name(err));\n\t\treturn err;\n\t}\n\n\treturn ESP_OK;\n}", "CodeBleu_score": 50.22003360537087}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\t// check if the given offset is aligned with the flash sector size\n\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"offset %d is not aligned with sector size %d\", offset, partition->erase_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\t// erase the corresponding sector\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"failed to erase sector at offset %d\", offset);\n\t\treturn err;\n\t}\n\n\t// write the data to the specified offset\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 51.89283221480212}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"Offset %d is not aligned with flash sector size %d\", offset, partition->erase_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Error erasing flash sector at offset %d\", offset);\n\t\treturn err;\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Error writing flash at offset %d\", offset);\n\t\treturn err;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 49.846203275554025}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t outlen = 0;\n\twhile (*in && outlen < maxlen) {\n\t\tchar c = *in++;\n\t\tif (c >= '0' && c <= '9') c -= '0';\n\t\telse if (c >= 'A' && c <= 'F') c -= 'A' - 10;\n\t\telse if (c >= 'a' && c <= 'f') c -= 'a' - 10;\n\t\telse continue;\n\t\tout[outlen] = c << 4;\n\t\tc = *in++;\n\t\tif (c >= '0' && c <= '9') c -= '0';\n\t\telse if (c >= 'A' && c <= 'F') c -= 'A' - 10;\n\t\telse if (c >= 'a' && c <= 'f') c -= 'a' - 10;\n\t\telse continue;\n\t\tout[outlen++] |= c;\n\t}\n\treturn outlen;\n}", "CodeBleu_score": 40.06371838025278}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = 0;\n\tsize_t i = 0;\n\twhile (in[i]!= 0 && len < maxlen) {\n\t\tunsigned char c = in[i];\n\t\tif (c >= '0' && c <= '9')\n\t\t\tc -= '0';\n\t\telse if (c >= 'A' && c <= 'F')\n\t\t\tc -= 'A' - 10;\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\tc -= 'a' - 10;\n\t\telse\n\t\t\tcontinue;\n\t\tif (i & 1) {\n\t\t\tout[len++] |= c;\n\t\t} else {\n\t\t\tout[len] = (c << 4);\n\t\t}\n\t\ti++;\n\t}\n\treturn len;\n}", "CodeBleu_score": 42.761707468143264}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\twhile (*in && i < maxlen) {\n\t\tif (isxdigit(*in)) {\n\t\t\tunsigned char c = 0;\n\t\t\tif (isdigit(*in)) {\n\t\t\t\tc = *in - '0';\n\t\t\t} else if (islower(*in)) {\n\t\t\t\tc = *in - 'a' + 10;\n\t\t\t} else if (isupper(*in)) {\n\t\t\t\tc = *in - 'A' + 10;\n\t\t\t}\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tout[i / 2] = c << 4;\n\t\t\t} else {\n\t\t\t\tout[i / 2] |= c;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tin++;\n\t}\n\treturn i / 2;\n}", "CodeBleu_score": 52.45420591982507}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tint freeSize;\n\tif (this->txRingBuffer == NULL || this->txLock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(this->txLock, 1000) == pdTRUE) {\n\t\tfreeSize = this->txRingBuffer->getFreeSize();\n\t\txSemaphoreGive(this->txLock);\n\t\treturn freeSize;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 35.53361837120171}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_buffer == NULL || tx_lock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, 1000) == pdTRUE) {\n\t\tint size = tx_buffer->getFree();\n\t\txSemaphoreGive(tx_lock);\n\t\treturn size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 65.98451514463466}, {"code": "int HWCDC::availableForWrite(void){\n\t\tuint32_t free = 0;\n\tif (tx_buffer) {\n\t\tif (xSemaphoreTake(tx_lock, 1000 / portTICK_PERIOD_MS) == pdTRUE) {\n\t\t\tfree = tx_buffer->availableForStore();\n\t\t\txSemaphoreGive(tx_lock);\n\t\t}\n\t}\n\treturn free;\n}", "CodeBleu_score": 41.1339573455566}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t_onReceiveCB = function;\n\t_rxTimeout = 0;\n\t_onlyOnTimeout = onlyOnTimeout;\n\tif (_onReceiveCB) {\n\t\tuart_set_rx_timeout(uart_num, _rxTimeout);\n\t\tuart_set_rx_intr_en(uart_num, 1);\n\t\tuart_intr_config(uart_num, UART_RXFIFO_FULL_INT_ENA, 1, 1, 0);\n\t\tif (!_eventTaskCreated) {\n\t\t\txTaskCreatePinnedToCore(eventTask, \"eventTask\", 4096, this, 10, &_eventTaskHandle, 1);\n\t\t\t_eventTaskCreated = true;\n\t\t}\n\t} else {\n\t\tuart_set_rx_intr_en(uart_num, 0);\n\t\tuart_intr_config(uart_num, UART_RXFIFO_FULL_INT_ENA, 0, 1, 0);\n\t}\n}", "CodeBleu_score": 40.31209837636638}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\tif (_onReceiveCB) {\n\t\tuart_set_rx_timeout(uart_num, _rxTimeout);\n\t\tuart_set_word_length(uart_num, UART_DATA_8_BITS);\n\t\tuart_set_stop_bits(uart_num, UART_STOP_BITS_1);\n\t\tuart_set_parity(uart_num, UART_PARITY_DISABLE);\n\t\tuart_set_baudrate(uart_num, _baud);\n\t\tuart_set_line_inverse(uart_num, UART_INVERSE_RXD);\n\t\tuart_set_hw_flow_ctrl(uart_num, UART_HW_FLOWCTRL_DISABLE, UART_SW_FLOWCTRL_DISABLE);\n\t\tuart_set_rx_flow_ctrl_thresh(uart_num, 122);\n\t\tuart_flush(uart_num);\n\t\tuart_enable_rx_intr(uart_num);\n\t\tif (!_eventTaskCreated) {\n\t\t\txTaskCreatePinnedToCore(eventTask, \"uart_event_task\", 2048, this, 10, NULL, 1);\n\t\t\t_eventTaskCreated = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.45505830334657}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t_onReceiveCB = function;\n\t_rxTimeout = 0;\n\tif (_onReceiveCB!= NULL) {\n\t\t// Set FIFO full threshold\n\t\tuart_set_rx_fifo_full_thresh(uart_num, 1);\n\t\t// Create event task if it does not already exist\n\t\tif (_eventTask == NULL) {\n\t\t\txTaskCreatePinnedToCore(eventTask, \"EventTask\", 2048, this, 10, &_eventTask, 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.561768539857493}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) break;\n\t\t*buffer++ = (char)c;\n\t\tindex++;\n\t}\n\treturn index;\n}", "CodeBleu_score": 67.69131586324771}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) break;\n\t\t*buffer++ = (char)c;\n\t\tindex++;\n\t}\n\treturn index;\n}", "CodeBleu_score": 67.69131586324771}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) break;\n\t\tchar c2 = (char)c;\n\t\tbuffer[index++] = c2;\n\t\tif (c2 == terminator) break;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 65.69240681933938}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tSerial.printf(\"tone(%d, %d, %d)\n\", pin, frequency, duration);\n\tif (pin < 0 || pin >= LEDC_CHANNEL_MAX) {\n\t\tSerial.printf(\"tone: pin %d is out of range\n\", pin);\n\t\treturn;\n\t}\n\tif (ledc_channel_in_use[pin]) {\n\t\tSerial.printf(\"tone: pin %d is already in use\n\", pin);\n\t\treturn;\n\t}\n\tledc_channel_in_use[pin] = true;\n\tledc_tone_t tone = {\n\t\t.pin = pin,\n\t\t.frequency = frequency,\n\t\t.duration = duration,\n\t};\n\txQueueSend(ledc_tone_queue, &tone, 0);\n}", "CodeBleu_score": 52.531975045144705}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\t// log the pin, frequency, and duration\n\tSerial.print(\"tone(pin=\");\n\tSerial.print(pin);\n\tSerial.print(\", freq=\");\n\tSerial.print(frequency);\n\tSerial.print(\", duration=\");\n\tSerial.print(duration);\n\tSerial.println(\")\");\n\n\t// check if the pin is available or already in use\n\tif (ledc_is_pin_used(pin)) {\n\t\t// log an error message instructing to stop the current tone on the pin first\n\t\tSerial.println(\"Error: The pin is already in use. Stop the current tone on the pin first.\");\n\t\treturn;\n\t}\n\n\t// initialize the tone\n\tledc_timer_config_t ledc_timer = {\n\t\t.duty_resolution = LEDC_TIMER_13_BIT, // resolution of PWM duty\n\t\t.freq_hz = frequency,                 // frequency of PWM signal\n\t\t.speed_mode = LEDC_HIGH_SPEED_MODE,   // timer mode\n\t\t.timer_num = LEDC_TIMER_0             // timer index\n\t};\n\tledc_timer_config(&ledc_timer);\n\n\tledc_channel_config_t ledc_channel = {\n\t\t.channel    = LEDC_CHANNEL_0,\n\t\t.duty       = 0,\n\t\t.gpio_num   = pin,\n\t\t.speed_mode = LEDC_HIGH_SPEED_MODE,\n\t\t.hpoint     = 0,\n\t\t.timer_sel  = LEDC_TIMER_0\n\t};\n\tledc_channel_config(&ledc_channel);\n\n\t// send a start command with the pin, frequency, and duration to a queue\n\ttone_command_t command = {\n\t\t.pin = pin,\n\t\t.freq = frequency,\n\t\t.duration = duration\n\t};\n\txQueueSend(tone_queue, &command, portMAX_DELAY);\n}", "CodeBleu_score": 47.58711833578321}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\t// log the pin, frequency, and duration\n\tSerial.print(\"tone(\");\n\tSerial.print(pin);\n\tSerial.print(\", \");\n\tSerial.print(frequency);\n\tSerial.print(\", \");\n\tSerial.print(duration);\n\tSerial.println(\")\");\n\n\t// check if the pin is available or already in use\n\tif (ledc_channel_t ledc_channel = get_ledc_channel(pin)) {\n\t\t// initialize the tone\n\t\tledc_timer_config_t ledc_timer = {\n\t\t\t.duty_resolution = LEDC_TIMER_10_BIT,\n\t\t\t.freq_hz = frequency,\n\t\t\t.speed_mode = LEDC_LOW_SPEED_MODE,\n\t\t\t.timer_num = LEDC_TIMER_0,\n\t\t};\n\t\tledc_timer_config(&ledc_timer);\n\n\t\tledc_channel_config_t ledc_channel_config = {\n\t\t\t.channel = ledc_channel,\n\t\t\t.duty = 512,\n\t\t\t.gpio_num = pin,\n\t\t\t.intr_type = LEDC_INTR_DISABLE,\n\t\t\t.speed_mode = LEDC_LOW_SPEED_MODE,\n\t\t\t.timer_sel = LEDC_TIMER_0,\n\t\t};\n\t\tledc_channel_config(&ledc_channel_config);\n\n\t\t// send a start command with the pin, frequency, and duration to a queue\n\t\txQueueSend(tone_queue, &tone_command_t{pin, frequency, duration}, portMAX_DELAY);\n\t} else {\n\t\t// log an error message instructing to stop the current tone on the pin first\n\t\tSerial.println(\"Error: Pin already in use\");\n\t}\n}", "CodeBleu_score": 41.28233937449991}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (started) {\n\t\tif (enabled) {\n\t\t\tif (usb_version < 0x0210) {\n\t\t\t\tusb_version = 0x0210;\n\t\t\t\tusb_version_major = 2;\n\t\t\t\tusb_version_minor = 16;\n\t\t\t}\n\t\t} else {\n\t\t\tif (usb_version >= 0x0210) {\n\t\t\t\tusb_version = 0x0200;\n\t\t\t\tusb_version_major = 2;\n\t\t\t\tusb_version_minor = 0;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\twebusb = enabled;\n\treturn true;\n}", "CodeBleu_score": 50.994839134783355}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (USB::started()) {\n\t\tif (enabled) {\n\t\t\tUSB::descriptor(0x0210);\n\t\t}\n\t\tUSB::webUSB(enabled);\n\t\treturn false;\n\t}\n\twebUSBEnabled = enabled;\n\treturn true;\n}", "CodeBleu_score": 31.607477080826783}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (started) return false;\n\twebusb = enabled;\n\tif (enabled && (version < 0x0210)) version = 0x0210;\n\treturn true;\n}", "CodeBleu_score": 46.94834043437363}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t data;\n\twhile (_CDC->available()) {\n\t\t_CDC->read(&data, 1);\n\t\tif (_rxQueue.push(data)) {\n\t\t\t_rxQueueOverflows++;\n\t\t\t_onError(CDC_RX_QUEUE_OVERFLOW);\n\t\t}\n\t\t_onRXEvent(1);\n\t}\n}", "CodeBleu_score": 7.9918707943004845}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t buffer[64];\n\tuint8_t length = 0;\n\n\twhile (CDC_Device_BytesReceived(&VirtualSerial_CDC_Interface) && length < sizeof(buffer)) {\n\t\tbuffer[length++] = CDC_Device_ReceiveByte(&VirtualSerial_CDC_Interface);\n\t}\n\n\tif (length) {\n\t\tuint8_t i = 0;\n\t\twhile (i < length) {\n\t\t\tif (xQueueSend(rxQueue, &buffer[i], 0) == pdTRUE) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tuint8_t dropped = length - i;\n\t\t\t\txQueueSend(overflowQueue, &dropped, 0);\n\t\t\t\tLog.error(TAG, \"RX overflow (%d dropped)\", dropped);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\txQueueSend(receiveQueue, &i, 0);\n\t}\n}", "CodeBleu_score": 30.168797335856183}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t *rxBuf = (uint8_t *)malloc(CDC_BUF_SIZE);\n\tint bytesRead = 0;\n\tint bytesToRead = CDC_BUF_SIZE;\n\tint bytesDropped = 0;\n\n\twhile (bytesToRead > 0) {\n\t\tbytesRead = USBCDC::read(rxBuf, bytesToRead);\n\t\tbytesToRead -= bytesRead;\n\n\t\tfor (int i = 0; i < bytesRead; i++) {\n\t\t\tif (xQueueSend(rxQueue, &rxBuf[i], 0) == pdFALSE) {\n\t\t\t\tbytesDropped++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bytesDropped > 0) {\n\t\tCDC_Event_t cdcEvent;\n\t\tcdcEvent.type = USBCDC_RX_OVERFLOW;\n\t\tcdcEvent.data.rxOverflow.bytesDropped = bytesDropped;\n\t\txQueueSend(eventQueue, &cdcEvent, 0);\n\t\tESP_LOGE(TAG, \"RX overflow: %d bytes dropped\", bytesDropped);\n\t}\n\n\tif (bytesRead > 0) {\n\t\tCDC_Event_t cdcEvent;\n\t\tcdcEvent.type = USBCDC_RX_DATA;\n\t\tcdcEvent.data.rxData.bytesRead = bytesRead;\n\t\txQueueSend(eventQueue, &cdcEvent, 0);\n\t}\n\n\tfree(rxBuf);\n}", "CodeBleu_score": 38.66193321285088}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":name\")\n\tif robot, ok := a.robots[robotName]; ok {\n\t\tdevices := robot.DeviceNames()\n\t\tjson.NewEncoder(res).Encode(devices)\n\t} else {\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"no robot found with name \" + robotName})\n\t}\n}", "CodeBleu_score": 28.892966742675707}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.robotWithName(robotName)\n\tif robot == nil {\n\t\ta.sendErrorResponse(res, 404, fmt.Sprintf(\"No robot was found with the name '%s'\", robotName))\n\t\treturn\n\t}\n\tdevices := []string{}\n\tfor _, d := range robot.Devices() {\n\t\tdevices = append(devices, d.Name())\n\t}\n\ta.sendJSONResponse(res, 200, devices)\n}", "CodeBleu_score": 49.34623744854206}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\":name\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, `{\"error\": \"robot not found\"}`)\n\t\treturn\n\t}\n\tdevices := robot.Devices()\n\tdata, err := json.Marshal(devices)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, `{\"error\": \"internal server error\"}`)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(data)\n}", "CodeBleu_score": 35.87524917849504}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":name\")\n\trobot := a.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with name %q found.\n\", robotName)\n\t\treturn\n\t}\n\n\tvar connections []gobot.Connection\n\tfor _, c := range robot.Connections() {\n\t\tconnections = append(connections, c)\n\t}\n\n\tdata, err := json.Marshal(connections)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"Error: %s\n\", err)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(data)\n}", "CodeBleu_score": 45.5528028216745}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":name\")\n\n\trobot, err := a.master.GetRobot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with name %s found\", robotName)\n\t\treturn\n\t}\n\n\tvar connections []string\n\tfor _, connection := range robot.Connections() {\n\t\tconnections = append(connections, connection.Name())\n\t}\n\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 47.86869385769789}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\":name\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with name %s found\", name)\n\t\treturn\n\t}\n\n\tvar connections []string\n\tfor _, c := range robot.Connections() {\n\t\tconnections = append(connections, c.Name())\n\t}\n\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 45.13692066216773}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\n\t// Check if the device exists\n\tdevice, err := a.getRobotDevice(robotName, deviceName)\n\tif err!= nil {\n\t\t// If the device does not exist, write the error message as a JSON response\n\t\ta.sendErrorResponse(res, err)\n\t\treturn\n\t}\n\n\t// Execute the specified command on the device using the Gobot framework\n\tcommand := req.URL.Query().Get(\":command\")\n\terr = device.Command(command).Run()\n\tif err!= nil {\n\t\t// If an error occurs while executing the command, write the error message as a JSON response\n\t\ta.sendErrorResponse(res, err)\n\t\treturn\n\t}\n\n\t// Send a success response\n\ta.sendSuccessResponse(res, fmt.Sprintf(\"Command %s executed successfully on device %s\", command, deviceName))\n}", "CodeBleu_score": 49.4404832750535}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\tcommand := req.URL.Query().Get(\":command\")\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"Robot not found: %s\", robotName)\n\t\treturn\n\t}\n\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"Device not found: %s\", deviceName)\n\t\treturn\n\t}\n\n\terr := robot.Command(deviceName, command)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"Error executing command: %s\", err)\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(res, \"Command executed: %s\", command)\n}", "CodeBleu_score": 47.583999063082025}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\n\t// Get the robot and device from the Gobot framework\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.sendErrorResponse(res, 404, fmt.Sprintf(\"Robot %s not found\", robotName))\n\t\treturn\n\t}\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\ta.sendErrorResponse(res, 404, fmt.Sprintf(\"Device %s not found\", deviceName))\n\t\treturn\n\t}\n\n\t// Execute the specified command on the device\n\tcommand := req.URL.Query().Get(\":command\")\n\tif err := device.Command(command).Run(nil); err!= nil {\n\t\ta.sendErrorResponse(res, 500, fmt.Sprintf(\"Error executing command %s on device %s: %v\", command, deviceName, err))\n\t\treturn\n\t}\n\n\t// Send a success response\n\ta.sendSuccessResponse(res, fmt.Sprintf(\"Command %s executed on device %s\", command, deviceName))\n}", "CodeBleu_score": 47.62276082214208}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || subtle.ConstantTimeCompare([]byte(user), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 53.295671504836875}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || subtle.ConstantTimeCompare([]byte(user), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.37849735238533}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\tif len(parts)!= 2 || parts[0]!= \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 || subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(pair[1]), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.06831936158028}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tif!a.Connection().(gobot.AnalogReader).AnalogReadSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"analog read not supported\")\n\t}\n\n\traw, err := a.Connection().(gobot.AnalogReader).AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.scale\n\ta.lastRaw = raw\n\ta.lastVal = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 43.150639962525204}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.connection.AnalogReadSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"analog read not supported\")\n\t}\n\n\traw, err := a.connection.AnalogRead()\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scale(raw)\n\n\ta.lastRead = time.Now()\n\ta.lastRawValue = raw\n\ta.lastValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 48.051938133877464}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tif!a.connection.AnalogReadSupported() {\n\t\treturn 0, 0, gobot.NewError(\"analog sensor does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scale(raw)\n\n\ta.lastRawValue = raw\n\ta.lastValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 45.23632415041221}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.SetName(g.Name() + \"-sound\")\n\treturn g\n}", "CodeBleu_score": 42.970286688870814}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.SetName(g.Name() + pin)\n\treturn g\n}", "CodeBleu_score": 41.5898674686961}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.name = \"GroveSoundSensorDriver\"\n\treturn g\n}", "CodeBleu_score": 46.94344895761245}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Soft reset\n\td.writeRegister(CommandReg, PCD_RESETPHASE)\n\t// Wait for the PowerDown bit in CommandReg to be cleared\n\tfor i := 0; i < 100; i++ {\n\t\treg, err := d.readRegister(CommandReg)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif reg&0x10 == 0 {\n\t\t\treturn nil\n\t\t}\n\t\ttime.Sleep(10 * time.Microsecond)\n\t}\n\treturn fmt.Errorf(\"timeout during soft reset\")\n}", "CodeBleu_score": 42.462066203783515}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Reset the MFRC522\n\td.writeCommand(CommandReg, PCD_RESETPHASE)\n\n\t// Wait for the PowerDown bit in CommandReg to be cleared\n\tfor {\n\t\tn, err := d.readRegister(CommandReg)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif (n & (1 << 4)) == 0 {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(1 * time.Millisecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 45.74879645253213}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Send the SoftReset command.\n\tif err := d.writeRegister(CommandReg, PCD_SoftReset); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the PowerDown bit in CommandReg to be cleared.\n\tif err := d.waitForClear(CommandReg, 1, PCD_SoftReset); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the timer to time out.\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// Check if the PowerDown bit is still set.\n\treg, err := d.readRegister(CommandReg)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif reg&PCD_SoftReset!= 0 {\n\t\treturn fmt.Errorf(\"MFRC522: soft reset timed out\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.82430697225561}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) > 64 {\n\t\treturn 0, fmt.Errorf(\"length of backData is %d, exceeds 64\", len(backData))\n\t}\n\tfifoLevel := d.readRegister(FIFOLevelReg)\n\tif fifoLevel < uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"fifoLevel %d is less than length of backData %d\", fifoLevel, len(backData))\n\t}\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i] = d.readRegister(FIFODataReg)\n\t}\n\tlastBits := d.readRegister(ControlReg) & 0x07\n\treturn lastBits, nil\n}", "CodeBleu_score": 41.59238428023477}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) > 64 {\n\t\treturn 0, fmt.Errorf(\"backData len is too large\")\n\t}\n\n\t// Read the number of bytes in the FIFO buffer\n\tfifoLevel, err := d.readRegister(FIFO_LEVEL)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check that the number of bytes in the FIFO buffer matches the expected length of the byte slice\n\tif uint8(len(backData))!= fifoLevel {\n\t\treturn 0, fmt.Errorf(\"backData len is not equal to FIFO_LEVEL\")\n\t}\n\n\t// Read each byte from the FIFO buffer into the byte slice\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(FIFO_DATA)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the last bits received from the control register\n\tlastBits, err := d.readRegister(CONTROL)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits & 0x07, nil\n}", "CodeBleu_score": 48.844748485421256}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) > 64 {\n\t\treturn 0, fmt.Errorf(\"invalid length of backData\")\n\t}\n\tn := d.readRegister(FIFOLevelReg)\n\tif n > len(backData) {\n\t\treturn 0, fmt.Errorf(\"not enough data in FIFO buffer\")\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i] = d.readRegister(FIFODataReg)\n\t}\n\tlastBits := d.readRegister(ControlReg) & 0x07\n\treturn lastBits, nil\n}", "CodeBleu_score": 30.68577495883349}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Build command buffer\n\tcmd := make([]byte, 2)\n\tcmd[0] = PICC_CMD_HALT\n\tcmd[1] = 0\n\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\n\t// Append CRC_A\n\tcmd = append(cmd, crc[0])\n\tcmd = append(cmd, crc[1])\n\n\t// Send the command.\n\tif err := d.sendCommand(PCD_TRANSCEIVE, cmd); err!= nil {\n\t\treturn err\n\t}\n\n\t// A halted PICC will in general send an ACK.\n\tif d.responseBuffer[0]!= PICC_ACK[0] || d.responseBuffer[1]!= PICC_ACK[1] {\n\t\treturn fmt.Errorf(\"No valid response received from PICC.\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.350724466830894}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Build command buffer\n\tcmd := make([]byte, 9)\n\tcmd[0] = PCD_CMD_HALT_A\n\n\t// Calculate CRC_A\n\tcrc := calculateCRC(cmd[0:1])\n\tcmd[1] = crc[0]\n\tcmd[2] = crc[1]\n\n\t// Send the command.\n\t// The standard says:\n\t//\t\tIf the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the\n\t//\t\tHALT command, this response shall be interpreted as 'not acknowledge'.\n\t// We interpret that this way: Only STATUS_TIMEOUT is an success, all other results are an error.\n\tstatus := d.sendReciveData(cmd, 1)\n\tif status!= STATUS_TIMEOUT {\n\t\treturn fmt.Errorf(\"piccHalt: %s\", status)\n\t}\n\treturn nil\n}", "CodeBleu_score": 20.805520778345933}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"debug: halting communication with PICC\")\n\t}\n\n\t// Build command buffer\n\tcmd := make([]byte, 2)\n\tcmd[0] = PICC_CMD_HALT\n\tcmd[1] = 0\n\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\n\t// Add CRC_A\n\tcmd = append(cmd, crc[0])\n\tcmd = append(cmd, crc[1])\n\n\t// Send the command\n\tif err := d.sendCommand(cmd); err!= nil {\n\t\treturn err\n\t}\n\n\t// Receive the response\n\tif err := d.receiveResponse(1); err!= nil {\n\t\treturn err\n\t}\n\n\t// Check if the response is an error\n\tif d.response[0] == 0x00 {\n\t\treturn nil\n\t} else {\n\t\treturn fmt.Errorf(\"error halting communication with PICC: %s\", d.response[0])\n\t}\n}", "CodeBleu_score": 36.166597166400315}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build the command\n\tcmd := make([]byte, 16)\n\tcmd[0] = MFRC522_PICC_CMD_MF_READ\n\tcmd[1] = block\n\tcrc, err := d.calculateCRC(cmd[:2])\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tcmd = append(cmd, crc...)\n\n\t// Send the command\n\terr = d.sendCommand(MFRC522_CMD_TRANSCEIVE, cmd)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Receive the response\n\tresp, err := d.receiveResponse(16)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the status byte\n\tstatus := resp[resp[0]-1]\n\tif status!= MFRC522_STATUS_OK {\n\t\treturn nil, fmt.Errorf(\"piccRead: status: %x\", status)\n\t}\n\n\t// Check the CRC\n\tcrc, err = d.calculateCRC(resp[:resp[0]-2])\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif crc[0]!= resp[resp[0]-2] || crc[1]!= resp[resp[0]-1] {\n\t\treturn nil, fmt.Errorf(\"piccRead: CRC mismatch: %x %x %x\", crc[0], crc[1], resp[resp[0]-2:])\n\t}\n\n\t// Return the data\n\treturn resp[1:resp[0]-2], nil\n}", "CodeBleu_score": 40.10045841565142}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar status byte\n\tvar backData []byte\n\n\t// Send the command to read the block\n\tstatus = d.piccCommunicate(PICC_CMD_MF_READ, []byte{block})\n\tif status!= STATUS_OK {\n\t\treturn nil, fmt.Errorf(\"piccRead: piccCommunicate failed: %v\", status)\n\t}\n\n\t// Receive the data from the block\n\tbackData, status = d.piccCommunicate(PICC_CMD_MF_READ, []byte{0})\n\tif status!= STATUS_OK {\n\t\treturn nil, fmt.Errorf(\"piccRead: piccCommunicate failed: %v\", status)\n\t}\n\n\t// Check if the data length is valid\n\tif len(backData)!= 16 {\n\t\treturn nil, fmt.Errorf(\"piccRead: invalid data length: %v\", len(backData))\n\t}\n\n\treturn backData, nil\n}", "CodeBleu_score": 31.893067775788698}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Construct the read command\n\tcommand := []byte{PICC_CMD_MF_READ, block}\n\t// Calculate the CRC for the command\n\tcrc, err := d.calculateCRC(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Append the CRC to the command\n\tcommand = append(command, crc[0], crc[1])\n\t// Communicate with the RFID card using the command\n\tresponse, err := d.communicate(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Check if the response is valid\n\tif len(response) < 2 || response[0]!= PICC_CMD_MF_READ || response[1]!= STATUS_OK {\n\t\treturn nil, fmt.Errorf(\"invalid response: %v\", response)\n\t}\n\t// Return the data from the specified block\n\treturn response[2:18], nil\n}", "CodeBleu_score": 43.757545998455726}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too short\")\n\t}\n\n\t// Clear the collision register\n\terr := d.clearBitMask(MFRC522_REG_COLL, 0x80)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the request mode\n\tanswer[0] = reqMode\n\n\t// Transmit the request command\n\terr = d.transceiveData(answer, 1, answer, true)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check if the PICC responded with an error\n\tif answer[0] == MFRC522_STATUS_COLLISION {\n\t\t// Check if the PICC responded with a collision\n\t\tif (answer[1] & 0x20) == 0 {\n\t\t\t// Check if the PICC responded with a collision on the bit frame\n\t\t\tif (answer[1] & 0x13) == 1 {\n\t\t\t\t// Check if the PICC responded with a collision on the bit frame\n\t\t\t\treturn fmt.Errorf(\"collision on the bit frame\")\n\t\t\t} else {\n\t\t\t\t// Check if the PICC responded with a collision on a specific bit\n\t\t\t\treturn fmt.Errorf(\"collision on a specific bit\")\n\t\t\t}\n\t\t} else {\n\t\t\t// Check if the PICC responded with a collision on the byte frame\n\t\t\treturn fmt.Errorf(\"collision on the byte frame\")\n\t\t}\n\t} else if answer[0]!= MFRC522_STATUS_OK {\n\t\t// Check if the PICC responded with an error\n\t\treturn fmt.Errorf(\"error in response\")\n\t}\n\n\t// Check if the PICC responded with a valid response\n\tif answer[0] == MFRC522_STATUS_OK {\n\t\t// Check if the PICC responded with a valid response\n\t\treturn nil\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 55.87301855699379}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\t// Clear the collision bits in the status register\n\terr := d.clearRegisterBitMask(d.RegColl, 0x80)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Transmit request\n\tanswer[0] = reqMode\n\tanswer[1] = 0x00\n\terr = d.transceiveData(answer, 2, answer, 2, false)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Return the status of the request\n\treturn nil\n}", "CodeBleu_score": 53.15752138158528}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Verify the answer buffer has at least 2 bytes of space\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"Not enough space in answer buffer\")\n\t}\n\n\t// Clear the collision register\n\td.ClearBitMask(MFRC522_REG_COLL, 0x80)\n\n\t// Set the transmission to use only 7 bits of the last byte\n\tif reqMode == MFRC522_PICC_REQIDL {\n\t\td.SetBitMask(MFRC522_REG_BITFRAMING, 0x80)\n\t} else {\n\t\td.ClearBitMask(MFRC522_REG_BITFRAMING, 0x80)\n\t}\n\n\t// Send the request command\n\tanswer[0] = reqMode\n\tif err := d.transceive(answer, 1, answer, 1); err!= nil {\n\t\treturn err\n\t}\n\n\t// Return the status and the length of the response\n\treturn nil\n}", "CodeBleu_score": 43.44338696950404}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.stepPin.DigitalWrite(gobot.Low); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\tif err := d.stepPin.DigitalWrite(gobot.High); err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 63.146270888728296}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.StepPin.DigitalWrite(gobot.Low); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.StepDelay)\n\tif err := d.StepPin.DigitalWrite(gobot.High); err!= nil {\n\t\treturn err\n\t}\n\tif d.Direction == 1 {\n\t\td.StepNumber++\n\t} else {\n\t\td.StepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 61.0726803401209}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.StepPin.DigitalWrite(gobot.Low); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.StepDelay)\n\n\tif err := d.StepPin.DigitalWrite(gobot.High); err!= nil {\n\t\treturn err\n\t}\n\n\tif d.Direction == gobot.CW {\n\t\td.StepNumber++\n\t} else {\n\t\td.StepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 61.051365293409845}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.Lock()\n\tdefer d.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitor = make(chan bool)\n\td.distanceMonitorWg = &sync.WaitGroup{}\n\td.distanceMonitorWg.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorWg.Done()\n\n\t\tticker := time.NewTicker(d.interval)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopDistanceMonitor:\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tdistance, err := d.GetDistance()\n\t\t\t\tif err!= nil {\n\t\t\t\t\td.Logger(fmt.Sprintf(\"Error getting distance: %v\", err))\n\t\t\t\t} else {\n\t\t\t\t\td.distance = distance\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\n\treturn nil\n}", "CodeBleu_score": 44.4242677953792}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor is already running\")\n\t}\n\n\td.stopDistanceMonitor = make(chan bool)\n\td.distanceMonitorWaitGroup = &sync.WaitGroup{}\n\n\td.distanceMonitorWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorWaitGroup.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopDistanceMonitor:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err!= nil {\n\t\t\t\t\td.Logger(fmt.Sprintf(\"error measuring distance: %v\", err))\n\t\t\t\t} else {\n\t\t\t\t\td.Publish(d.Event(\"distance\"), distance)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(d.DistanceMonitorInterval)\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\treturn nil\n}", "CodeBleu_score": 48.055754637424876}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\tstop := make(chan bool)\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-stop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\td.mutex.Lock()\n\t\t\t\tdist, err := d.measureDistance()\n\t\t\t\td.mutex.Unlock()\n\t\t\t\tif err!= nil {\n\t\t\t\t\td.Logger.Error(err)\n\t\t\t\t} else {\n\t\t\t\t\td.Publish(d.Event(Distance), dist)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(d.Interval)\n\t\t\t}\n\t\t}\n\t}()\n\n\td.stopDistanceMonitor = stop\n\td.distanceMonitorWaitGroup = &wg\n\td.distanceMonitorRunning = true\n\n\treturn nil\n}", "CodeBleu_score": 40.512158661674604}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, timestamp time.Duration, change string, val uint32, tick uint32) {\n\t\tswitch change {\n\t\tcase system.RISING:\n\t\t\tstart = time.Now()\n\t\tcase system.FALLING:\n\t\t\td.duration <- time.Since(start)\n\t\t}\n\t}\n}", "CodeBleu_score": 39.65417140862858}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, timestamp time.Duration, event string, pinValue uint32, threshold uint32) {\n\t\tswitch event {\n\t\tcase \"rising\":\n\t\t\tstart = time.Now()\n\t\tcase \"falling\":\n\t\t\td.duration <- time.Since(start)\n\t\t\tstart = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.04195617888498}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, timestamp time.Duration, state string, value uint32, delta uint32) {\n\t\tswitch state {\n\t\tcase system.RISING:\n\t\t\tstart = time.Now()\n\t\tcase system.FALLING:\n\t\t\td.duration <- time.Since(start)\n\t\t}\n\t}\n}", "CodeBleu_score": 39.85003899474329}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor by setting the trigger pin to high for at least 10 microseconds.\n\td.triggerPin.DigitalWrite(1)\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.DigitalWrite(0)\n\n\t// Wait for the echo pin to go high, indicating that the sensor has started sending out the ultrasonic pulse.\n\tif err := d.waitForPin(1); err!= nil {\n\t\treturn err\n\t}\n\n\t// Start a timer to measure the time it takes for the echo pin to go low, indicating that the sensor has received the reflected ultrasonic pulse.\n\tstart := time.Now()\n\tif err := d.waitForPin(0); err!= nil {\n\t\treturn err\n\t}\n\td.lastMeasurement = time.Since(start)\n\n\treturn nil\n}", "CodeBleu_score": 55.23088883966949}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\td.trigger()\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measurementComplete:\n\t\t// Measurement completed successfully\n\t\td.measuredTime = d.pulseIn(d.measurementPin, gobot.High, d.timeout)\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// Timeout reached\n\t\treturn fmt.Errorf(\"timeout reached\")\n\t}\n}", "CodeBleu_score": 40.07876250796643}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\td.trig.DigitalWrite(1)\n\ttime.Sleep(d.trigPulse)\n\td.trig.DigitalWrite(0)\n\tstart := time.Now()\n\tfor d.echo.DigitalRead() == 0 {\n\t\tif time.Since(start) > d.timeout {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo pulse\")\n\t\t}\n\t}\n\tstart = time.Now()\n\tfor d.echo.DigitalRead() == 1 {\n\t\tif time.Since(start) > d.timeout {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo pulse\")\n\t\t}\n\t}\n\td.measuredTime = time.Since(start)\n\treturn nil\n}", "CodeBleu_score": 49.087680319516885}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get(\"PLATFORMIO_AUTH_TOKEN\")\n    if not token:\n        try:\n            state = self.get_state()\n            if state.get(\"access_token\") and state.get(\"expires_at\") > time.time():\n                token = state[\"access_token\"]\n            elif state.get(\"refresh_token\"):\n                try:\n                    state = self.refresh_authentication_token()\n                    token = state[\"access_token\"]\n                except HTTPClientError as e:\n                    raise UserSideException(\n                        \"Failed to refresh authentication token: %s\" % e\n                    )\n        except HTTPClientError as e:\n            raise UserSideException(\n                \"Failed to fetch authentication token: %s\" % e\n            )\n        except PlatformioException:\n            pass\n    return token\n\n", "CodeBleu_score": 39.750995480645464}, {"code": "def fetch_authentication_token(self)\n\t\n    if os.getenv(\"PLATFORMIO_AUTH_TOKEN\"):\n        return os.getenv(\"PLATFORMIO_AUTH_TOKEN\")\n\n    state = self.get_state()\n    if not state:\n        raise UserSideException(\"Please sign in to PlatformIO Account using `pio account login` command\")\n\n    if state.get(\"access_token\") and state.get(\"access_token_expire_at\") > time.time():\n        return state.get(\"access_token\")\n\n    if state.get(\"refresh_token\"):\n        try:\n            response = HTTPClient().fetch(\n                __accounts_api__ + \"/auth/refresh\",\n                method=\"POST\",\n                headers={\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\",\n                },\n                body=json.dumps(\n                    {\n                        \"refresh_token\": state.get(\"refresh_token\"),\n                        \"grant_type\": \"refresh_token\",\n                    }\n                ),\n            )\n            data = json.loads(response.body)\n            state[\"access_token\"] = data[\"access_token\"]\n            state[\"access_token_expire_at\"] = time.time() + data[\"expires_in\"]\n            self.set_state(state)\n            return data[\"access_token\"]\n        except HTTPClientError as e:\n            raise PlatformioException(\"Refresh token is not valid\")\n\n    raise UserSideException(\"Please sign in to PlatformIO Account using `pio account login` command\")", "CodeBleu_score": 41.89832636739774}, {"code": "def fetch_authentication_token(self)\n\t\n    if os.getenv(\"PLATFORMIO_AUTH_TOKEN\"):\n        return os.getenv(\"PLATFORMIO_AUTH_TOKEN\")\n\n    state = self.get_state()\n    if state and state.get(\"access_token\") and state.get(\"expires_at\") > time.time():\n        return state.get(\"access_token\")\n\n    if state and state.get(\"refresh_token\"):\n        try:\n            return self.refresh_token(state.get(\"refresh_token\"))\n        except HTTPClientError as e:\n            if e.response.status_code == 401:\n                self.remove_state()\n            raise UserSideException(e)\n\n    raise UserSideException(\n        \"Please log in using `pio account login` or set the environment variable `PLATFORMIO_AUTH_TOKEN`.\"\n    )\n\n", "CodeBleu_score": 33.79899849162917}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    if refresh_token is None:\n        return True\n    self.delete_session()\n    try:\n        HTTPClient().post(__accounts_api__ + \"/v1/logout\", data={\"refresh_token\": refresh_token})\n    except HTTPClientError as e:\n        if e.code!= 404:\n            raise PlatformioException(\"Unable to logout\")\n    return True\n\n", "CodeBleu_score": 41.13673756640204}, {"code": "def logout(self)\n\t\n    if self.is_logged_in():\n        try:\n            refresh_token = self.get_session_data().get(\"refresh_token\")\n            self.delete_session()\n            self.client.post(\"/v1/logout\", data={\"refresh_token\": refresh_token})\n            return True\n        except HTTPClientError as e:\n            if e.status_code!= 401:\n                raise UserSideException(\n                    \"Failed to logout: %s\" % e.message, e.status_code\n                )\n    return False\n\n", "CodeBleu_score": 47.51576177666475}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_session()\n    try:\n        __accounts_api__.logout(refresh_token)\n    except HTTPClientError as e:\n        if e.status_code!= 401:\n            raise UserSideException(e)\n    return True\n\n", "CodeBleu_score": 31.748833753003954}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.get_used_packages():\n        if pkg.metadata.optional:\n            continue\n        data = {\n            \"name\": pkg.metadata.name,\n            \"version\": pkg.metadata.version,\n            \"path\": pkg.path,\n        }\n        if pkg.metadata.spec.external:\n            data[\"url\"] = pkg.metadata.spec.url\n        result.append(data)\n    return result\n\n", "CodeBleu_score": 42.480377439045135}, {"code": "def dump_used_packages(self)\n\t\n    used_packages = []\n    for pkg in self.packages:\n        if pkg.optional:\n            continue\n        pkg_meta = self.get_package(pkg)\n        if pkg_meta.metadata.get(\"type\") == \"platform\":\n            pkg_meta.metadata[\"__pkg_type__\"] = \"platform\"\n        elif pkg_meta.metadata.get(\"type\") == \"tool\":\n            pkg_meta.metadata[\"__pkg_type__\"] = \"tool\"\n        else:\n            pkg_meta.metadata[\"__pkg_type__\"] = \"library\"\n        pkg_meta.metadata[\"__pkg_name__\"] = pkg.name\n        pkg_meta.metadata[\"__pkg_version__\"] = pkg.version\n        if pkg_meta.metadata.get(\"url\"):\n            pkg_meta.metadata[\"__pkg_url__\"] = pkg_meta.metadata.get(\"url\")\n        used_packages.append(pkg_meta.metadata)\n    return used_packages\n\n", "CodeBleu_score": 31.234838134671005}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for pkg in self.get_used_packages():\n        if pkg.is_optional():\n            continue\n        pkg_meta = self.get_package(pkg)\n        if pkg_meta.metadata.get(\"type\") == \"platform\":\n            pkg_name = pkg_meta.metadata.get(\"name\")\n        else:\n            pkg_name = pkg_meta.metadata.get(\"name\", pkg_meta.metadata.get(\"url\"))\n        pkg_ver = pkg_meta.metadata.get(\"version\")\n        packages.append(\n            {\n                \"name\": pkg_name,\n                \"version\": pkg_ver,\n                \"url\": pkg_meta.metadata.get(\"url\"),\n            }\n        )\n    return packages\n\n", "CodeBleu_score": 30.153922032532265}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_spec = env.get(\"platform\")\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env.name)\n    platform = PlatformFactory.newPlatform(platform_spec, autoinstall=autoinstall)\n    platform.set_project_env(env)\n    platform.configure_packages(env, targets)\n    return cls(platform)\n\n", "CodeBleu_score": 39.57036198430151}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform = cls.get_instance(env.get_platform(), autoinstall=autoinstall)\n    if not platform:\n        raise UndefinedEnvPlatformError(env.name)\n    platform.configure_default_packages(env)\n    if targets is not None:\n        platform.configure_default_packages(env, targets=targets)\n    return platform\n\n", "CodeBleu_score": 26.417353182270382}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_name = env.get(\"platform\")\n    if not platform_name:\n        raise UndefinedEnvPlatformError()\n    platform_cls = base.get_platform_cls(platform_name)\n    platform = platform_cls(platform_name, autoinstall=autoinstall)\n    platform.configure_default_packages(env)\n    platform.configure_project_packages(env, targets=targets)\n    return cls(platform, env)\n\n", "CodeBleu_score": 35.27351122582153}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(I2C_ADDR);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(I2C_ADDR, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 62.88768930758177}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(I2C_ADDR);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(I2C_ADDR, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 60.38386846755457}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 66.51085749887085}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tSetTimer(time_in_us);\n\t} else {\n\t\tDisableTimer();\n\t}\n\tDeepSleep();\n}", "CodeBleu_score": 41.77885487742999}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tif (time_in_us > 0) {\n\t\tSetSleep(true, true, true, true, true, true, true, true);\n\t\tSetTimer(time_in_us);\n\t} else {\n\t\tSetSleep(false, false, false, false, false, false, false, false);\n\t\tSetTimer(0);\n\t}\n\tSetSleep(true, true, true, true, true, true, true, true);\n\tif (time_in_us > 0) {\n\t\tdelayMicroseconds(time_in_us);\n\t}\n\tSetSleep(false, false, false, false, false, false, false, false);\n}", "CodeBleu_score": 52.554327631189835}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us) {\n\t\tEnableTimer(time_in_us);\n\t} else {\n\t\tDisableTimer();\n\t}\n\taxp192->DeepSleep();\n}", "CodeBleu_score": 32.471847630360784}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y;\n\tif (tteBar) {\n\t\ty = tteBar->y;\n\t} else {\n\t\ty = tte->y;\n\t}\n\t// store current y-coordinate\n\tint y_prev = y;\n\t// fill the rectangle with the specified color\n\tdraw_rect(0, y, tte->x, tte->y + tte->h, color);\n\t// increment y-coordinate\n\ty += tte->h;\n\tif (y >= tte->y + tte->h - tte->bottom_fixed) {\n\t\ty = tte->y;\n\t}\n\tif (tteBar) {\n\t\ttteBar->y = y;\n\t} else {\n\t\ttte->y = y;\n\t}\n\t// update the scroll address\n\ttte->scrollAddr = (uint16_t *) (tte->addr + y * tte->x);\n\treturn y_prev;\n}", "CodeBleu_score": 14.87316591971577}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = this->scroll_addr;\n\tif (y >= this->height - this->bottom_fixed_area) {\n\t\ty = this->top_fixed_area;\n\t\tif (this->tteBar) {\n\t\t\ty += this->top_fixed_area_alt;\n\t\t}\n\t} else {\n\t\ty += this->text_height;\n\t}\n\tthis->scroll_addr = y;\n\tthis->fill_rect(0, y, this->width, this->text_height, color);\n\treturn y;\n}", "CodeBleu_score": 7.703806026743598}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint prev_y = this->scroll_y;\n\tif (this->scroll_y + this->font_height >= this->height - this->bottom_fixed_area) {\n\t\tif (this->tteBar) {\n\t\t\tthis->scroll_y = this->top_fixed_area + this->font_height;\n\t\t} else {\n\t\t\tthis->scroll_y = this->top_fixed_area;\n\t\t}\n\t} else {\n\t\tthis->scroll_y += this->font_height;\n\t}\n\tthis->draw_fill_rect(this->scroll_x, this->scroll_y - this->font_height, this->width, this->font_height, color);\n\treturn prev_y;\n}", "CodeBleu_score": 8.292979194024802}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t//setup the access points\n\tif (!setupAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\t//setup the HTML content\n\tif (!setupHTMLContent(ssids)) {\n\t\treturn false;\n\t}\n\n\t//start the portal\n\tstart();\n\treturn true;\n}", "CodeBleu_score": 56.05934458757809}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setAccessPoints(ssids)) {\n\t\treturn false;\n\t}\n\tif (!this->setHTMLContent(access_points)) {\n\t\treturn false;\n\t}\n\tthis->start();\n\treturn true;\n}", "CodeBleu_score": 58.56335403415791}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!setup_access_points(ssids, access_points)) {\n\t\treturn false;\n\t}\n\tif (!setup_html()) {\n\t\treturn false;\n\t}\n\tstart();\n\treturn true;\n}", "CodeBleu_score": 57.98337075288777}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif(queue_enabled_flag) {\n\t\treturn;\n\t}\n\tqueue_enabled_flag = true;\n\tqueue.flush();\n\tqueue.clear();\n\tqueue.enqueue(text);\n\tqueue.enqueue(text_in);\n}", "CodeBleu_score": 8.085885253519201}, {"code": "void GpsInterface::enable_queue(){\n\t\tif(queue_enabled_flag) {\n\t\treturn;\n\t}\n\tqueue_enabled_flag = true;\n\tflush();\n}", "CodeBleu_score": 4.1866761154663825}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\treturn;\n\t}\n\tqueue_enabled_flag = true;\n\tflush_queue();\n}", "CodeBleu_score": 4.695937320631809}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea) {\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new Queue<String>();\n}", "CodeBleu_score": 35.956394444788856}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea!= NULL) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = NULL;\n\t}\n\tqueue_nmea = new Queue<char*>();\n}", "CodeBleu_score": 35.140176178128314}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea!= NULL) {\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new queue<string>;\n}", "CodeBleu_score": 33.951297934940804}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\t/*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n\n\tint32_t x, y;\n\tfor(y = area->y1; y <= area->y2; y++) {\n\t\tfor(x = area->x1; x <= area->x2; x++) {\n\t\t\tILI9341_Draw_Pixel(x, y, *color_p);  /* Put a pixel to the display.*/\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\n\tlv_disp_flush_ready(disp);               /* Indicate you are ready with the flushing*/\n}", "CodeBleu_score": 41.13803676349188}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\t//printf(\"flushing\n\");\n\tint32_t x, y;\n\t/*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 6.1076677688884}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint16_t c;\n\tuint8_t x, y;\n\tuint16_t x0 = area->x1;\n\tuint16_t x1 = area->x2;\n\tuint16_t y0 = area->y1;\n\tuint16_t y1 = area->y2;\n\n\tlcd_set_window(x0, y0, x1, y1);\n\tlcd_write_cmd(0x2C);\n\tfor (y = y0; y <= y1; y++) {\n\t\tfor (x = x0; x <= x1; x++) {\n\t\t\tc = color_p->full;\n\t\t\tlcd_write_data(c >> 8);\n\t\t\tlcd_write_data(c);\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 47.213225073797716}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\n\tif (menu->getMenuNodes() == NULL) {\n\t\treturn;\n\t}\n\n\tint i = 0;\n\tfor (i = 0; i < menu->getMenuNodes()->size(); i++) {\n\t\tMenuNode * node = menu->getMenuNodes()->at(i);\n\n\t\tif (node == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node->getName() == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"  \");\n\t\t}\n\n\t\tSerial.println(node->getName());\n\n\t\tshowMenuList(node->getMenu(), layer + 1);\n\t}\n\n\tSerial.println();\n}", "CodeBleu_score": 50.4749124695539}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tint i;\n\tMenuNode * node;\n\tfor (i = 0; i < menu->getNodeCount(); i++) {\n\t\tnode = menu->getNode(i);\n\t\tif (node->getType() == MENU_NODE_TYPE_SUBMENU) {\n\t\t\t// print indentation\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tSerial.print(\"  \");\n\t\t\t}\n\t\t\t// print node name\n\t\t\tSerial.println(node->getName());\n\t\t\t// show submenu\n\t\t\tshowMenuList((Menu*) node, layer + 1);\n\t\t} else {\n\t\t\t// print indentation\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tSerial.print(\"  \");\n\t\t\t}\n\t\t\t// print node name\n\t\t\tSerial.println(node->getName());\n\t\t}\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 52.484679574443724}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor(int i = 0; i < menu->getNodesCount(); i++) {\n\t\tfor(int j = 0; j < layer; j++) {\n\t\t\tprintf(\"  \");\n\t\t}\n\t\tprintf(\"%s\n\", menu->getNode(i)->getName());\n\t\tif(menu->getNode(i)->isMenu()) {\n\t\t\tshowMenuList(menu->getNode(i)->getMenu(), layer + 1);\n\t\t}\n\t}\n\tprintf(\"\n\");\n}", "CodeBleu_score": 46.69957944853734}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint generated = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char) random(65, 91);\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 17; j++) {\n\t\t\tif (j == 2 || j == 5 || j == 8 || j == 11 || j == 14) {\n\t\t\t\tmac += \":\";\n\t\t\t}\n\t\t\tmac += (char) random(48, 58);\n\t\t}\n\t\tgenerated++;\n\t\tSerial.print(generated);\n\t\tSerial.print(\" \");\n\t\tSerial.print(ssid);\n\t\tSerial.print(\" \");\n\t\tSerial.print(channel);\n\t\tSerial.print(\" \");\n\t\tSerial.println(mac);\n\t}\n\treturn generated;\n}", "CodeBleu_score": 40.10373853039473}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint channel;\n\tString mac;\n\tString ssid;\n\tfor (i = 0; i < count; i++) {\n\t\tchannel = random(1, 12);\n\t\tmac = randomMAC();\n\t\tssid = randomSSID();\n\t\tSerial.println(ssid + \" \" + channel + \" \" + mac);\n\t\taddSSID(ssid, channel, mac);\n\t}\n\treturn count;\n}", "CodeBleu_score": 28.146111839037925}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\t// create a list of SSIDs\n\tstd::list<SSID> ssid_list;\n\n\t// create a random number generator\n\tstd::random_device rd;\n\tstd::mt19937 gen(rd());\n\n\t// create a random number distribution\n\tstd::uniform_int_distribution<> channel_dist(1, 14);\n\tstd::uniform_int_distribution<> mac_dist(0, 255);\n\n\t// iterate through the count\n\tfor (int i = 0; i < count; i++) {\n\t\t// create a new SSID\n\t\tSSID ssid;\n\n\t\t// create a random SSID\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid.name += (char) ('a' + (rand() % 26));\n\t\t}\n\n\t\t// assign a random channel\n\t\tssid.channel = channel_dist(gen);\n\n\t\t// assign a random MAC address\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid.mac += (char) mac_dist(gen);\n\t\t}\n\n\t\t// add the SSID to the list\n\t\tssid_list.push_back(ssid);\n\n\t\t// print the SSID to the serial output\n\t\tSerial.print(ssid.name);\n\t\tSerial.print(\" \");\n\t\tSerial.print(ssid.channel);\n\t\tSerial.print(\" \");\n\t\tSerial.println(ssid.mac);\n\t}\n\n\t// return the number of generated SSIDs\n\treturn count;\n}", "CodeBleu_score": 33.85005728083383}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 48.4204446846163}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    try:\n        topic = publisher.create_topic(request={\"name\": topic_path})\n        print(f\"Created topic: {topic.name}\")\n    except AlreadyExists:\n        print(f\"Topic already exists: {topic.name}\")\n\n", "CodeBleu_score": 47.85563920330179}, {"code": "def create_topic(project_id, topic_name)\n\t\n    # Initialize a PublisherClient\n    publisher = pubsub_v1.PublisherClient()\n    # Construct the topic path using the provided project ID and topic name\n    topic_path = publisher.topic_path(project_id, topic_name)\n    # Create the topic\n    try:\n        topic = publisher.create_topic(topic_path)\n        # Print a confirmation message with the topic details\n        print(f\"Topic created: {topic}\")\n    except Exception as e:\n        print(f\"Error creating topic: {e}\")\n\n", "CodeBleu_score": 52.478888130736756}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        \"iat\": datetime.datetime.utcnow(),\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        \"aud\": project_id\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 49.266077566347946}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        \"iat\": datetime.datetime.utcnow(),\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        \"aud\": project_id\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 50.27694654516052}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 56.64796094364441}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    global pub_topic\n    global pub_client\n    global pub_message\n    global pub_qos\n    global pub_retain\n    global bucket_name\n    global bucket_location\n    global pub_message_json\n    global pub_message_dict\n    global pub_message_json_string\n    global pub_message_json_dict\n    global pub_message_json_dict_string\n    global pub_message_json_dict_string_pretty\n    global pub_message_json_dict_string_pretty_json\n    global pub_message_json_dict_string_pretty_json_dict\n    global pub_message_json_dict_string_pretty_json_dict_string\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json_dict\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json_dict_string\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty_json\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty_json_dict\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty_json_dict_string\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty_json\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty_json_dict\n    global pub_message_json_dict_string_pretty_json_dict_string_pretty_json_dict_string_pretty", "CodeBleu_score": 5.507876077465803}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print('Starting preview capture...')\n        os.system('raspistill -w 640 -h 480 -t 100 -e jpg -o /home/pi/Desktop/image.jpg')\n        print('Preview captured.')\n        print('Uploading image to bucket...')\n        upload_blob('image.jpg', 'image.jpg')\n        print('Image uploaded.')\n        print('Publishing image URL to event topic...')\n        publish_event('image.jpg')\n        print('Image URL published.')\n    else:\n        print('off')\n\n", "CodeBleu_score": 33.60445234814306}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message '{}' on topic '{}': QoS={}\".format(payload, message.topic, str(message.qos)))\n    if payload == \"on\":\n        print(\"Capturing preview image...\")\n        os.system(\"raspistill -o preview.jpg -t 1 -w 1024 -h 768 -q 100\")\n        print(\"Uploading preview image...\")\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket(os.environ[\"BUCKET\"])\n        blob = bucket.blob(\"preview.jpg\")\n        blob.upload_from_filename(\"preview.jpg\")\n        print(\"Generating signed URL...\")\n        url = blob.generate_signed_url(\n            version=\"v4\",\n            expiration=datetime.timedelta(minutes=5),\n            method=\"GET\",\n        )\n        print(\"Publishing URL to event topic...\")\n        client.publish(os.environ[\"EVENT_TOPIC\"], url, qos=1)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 43.734422023183924}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT device connection using the Python API.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--subscription_name\", required=True, help=\"Pub/Sub subscription name\")\n    parser.add_argument(\"--algorithm\", choices=(\"RS256\", \"ES256\"), default=\"ES256\", help=\"Which encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\"--ca_certs\", help=\"CA root from https://pki.google.com/roots.pem\")\n    parser.add_argument(\"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", default=\"mqtt.googleapis.com\", help=\"MQTT bridge hostname.\")\n    parser.add_argument(\"--mqtt_bridge_port\", type=int, default=8883, help=\"MQTT bridge port.\")\n    parser.add_argument(\"--message_type\", choices=(\"event\", \"state\"), default=\"event\", help=\"Message type (event or state).\")\n    parser.add_argument(\"--jwt_expires_minutes\", type=int, default=20, help=\"Expiration time, in minutes, for JWT tokens.\")\n    parser.add_argument(\"--verbosity\", choices=(\"DEBUG\", \"INFO\", \"ERROR\"), default=\"INFO\", help=\"Logging level.\")\n    return parser.parse_args()\n\n", "CodeBleu_score": 37.58946844326828}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name.\",\n    )\n    parser.add_argument(\n        \"--subscription_name\",\n        required=True,\n        help=\"Pub/Sub subscription name.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\"\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        default=8883,\n        help=\"MQTT bridge port.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        required=True,\n        help=\"Whether the message to be published is a device event or a device state.\",\n    )\n    parser.add_argument(\n        \"--device_file\",\n        default=\"device.json\",\n        help=\"Device metadata JSON file.\",\n    )\n    parser.add_argument(\n        \"--client_id\",\n        default=\"projects/YOUR_PROJECT_ID/locations/us-central1/registries/YOUR_REGISTRY_ID/devices/YOUR_DEVICE_ID\",\n        help=\"MQTT client ID.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        default=\"us-central1\",\n        help=\"GCP cloud region where the registry exists.\",\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        default=\"YOUR_REGISTRY_ID\",\n        help=\"Cloud IoT registry ID.\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        default=\"YOUR_DEVICE_ID\",\n        help=\"Cloud IoT device ID.\",\n    )\n    parser.add_argument(\n       ", "CodeBleu_score": 36.19758770801931}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='Pub/Sub subscription name')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--service_account_json',\n        default=os.environ.get(\"GOOGLE_APPLICATION_CREDENTIALS\"),\n        help='Path to service account json file')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--rsa_private_key_file',\n        default=os.environ.get(\"GOOGLE_APPLICATION_CREDENTIALS\"),\n        help='Path to RSA private key file, if algorithm is RS256.')\n    parser.add_argument(\n        '--token_ttl',\n        default=60,\n        help='Expiration time, in seconds, for JWT tokens.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        default=8883,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--ca_certs',\n        default=os.path.join(\n            os.path.dirname(__file__), 'roots.pem'),\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        default=10,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event','state'),\n        default='event',\n        help='Message type.')\n    parser.add_argument(\n        '--mqtt_device_command_topic',\n        help='MQTT device command topic. '\n             'If not provided, the MQTT device command topic is '\n             'auto-populated using the device registry path.')\n    parser.add_argument(\n        '--message_data',\n        default='Hello world!',\n        help='Message data.')\n    parser.", "CodeBleu_score": 35.888073327048964}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # Create a client for the Google Cloud IoT Core service.\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json,\n        scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    )\n    scoped_credentials = credentials.with_scopes(\n        [\n            \"https://www.googleapis.com/auth/cloud-platform\",\n            \"https://www.googleapis.com/auth/pubsub\",\n        ]\n    )\n    return discovery.build(\n        \"cloudiot\",\n        \"v1\",\n        credentials=scoped_credentials,\n        discoveryServiceUrl=\"https://cloudiot.googleapis.com/$discovery/rest?version=v1\",\n    )\n\n", "CodeBleu_score": 24.971015188418267}, {"code": "def get_client(service_account_json)\n\t\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(scopes)\n    discovery_url = '{}?version={}'.format(discovery_api_url, api_version)\n    return discovery.build('cloudiot', api_version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 33.979233125788376}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n    scoped_credentials = credentials.with_scopes(scopes)\n    discovery_api = discovery.build(\n        \"cloudiot\", api_version, credentials=credentials, discoveryServiceUrl=discovery_url\n    )\n    return discovery_api\n\n", "CodeBleu_score": 26.00260490361055}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = hash_method_to_asn1(hash_method)\n    if asn1_code is None:\n        raise ValueError(\"Invalid hash method\")\n    to_sign = asn1_code + hash_value\n    padded_hash = transform.pad_for_signing(to_sign, common.byte_size(priv_key.n))\n    signature = core.encrypt_int(int.from_bytes(padded_hash, \"big\"), priv_key.n, priv_key.d)\n    return signature.to_bytes(common.byte_size(priv_key.n), \"big\")\n\n", "CodeBleu_score": 37.29993161484343}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == 'SHA-1':\n        asn1_code = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == 'SHA-256':\n        asn1_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'SHA-384':\n        asn1_code = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'SHA-512':\n        asn1_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n    hash_value_asn1 = asn1_code + hash_value\n    padded_hash = transform.pad(hash_value_asn1, priv_key.n)\n    signature = core.encrypt_int(padded_hash, priv_key.n, priv_key.d)\n    return signature\n\n", "CodeBleu_score": 26.049005261419687}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    try:\n        asn1_code = common.HASH_ASN1[hash_method]\n    except KeyError:\n        raise ValueError('Invalid hash method')\n    hash_value = bytearray(hash_value)\n    hash_value.extend(asn1_code)\n    padded_hash = transform.pad(hash_value, len(priv_key.n))\n    return core.encrypt_int(int.from_bytes(padded_hash, 'big'), priv_key)\n\n", "CodeBleu_score": 31.916311802142474}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        if not isinstance(pub_key, core.PublicKey):\n            raise ValueError('Expected a PublicKey instance.')\n        if not isinstance(signature, bytes):\n            raise TypeError('Expected a bytes instance for the signature.')\n        if not isinstance(message, bytes):\n            raise TypeError('Expected a bytes instance for the message.')\n        if len(signature)!= pub_key.size_in_bytes():\n            raise ValueError('The signature is the wrong size.')\n        if not common.is_crypto_secure():\n            raise core.CryptoWarning('This computer is not cryptographically secure.')\n        signature_int = common.bytes_to_long(signature)\n        clear_signature = core.decrypt_int(signature_int, pub_key.n, pub_key.e)\n        clear_signature_bytes = common.long_to_bytes(clear_signature, pub_key.size_in_bytes())\n        padding_length = clear_signature_bytes[0]\n        if padding_length < 11:\n            raise core.VerificationError('Invalid padding.')\n        padding = clear_signature_bytes[1:padding_length + 1]\n        if not common.is_valid_pkcs1_padding(padding):\n            raise core.VerificationError('Invalid padding.')\n        hash_method = clear_signature_bytes[padding_length + 1]\n        if hash_method not in common.HASH_METHODS:\n            raise core.VerificationError('Invalid hash method.')\n        hash_length = common.HASH_METHODS[hash_method][0]\n        hash_ = clear_signature_bytes[padding_length + 2:]\n        if len(hash_)!= hash_length:\n            raise core.VerificationError('Invalid hash.')\n        expected_hash = common.hash_string(message, hash_method)\n        if hash_!= expected_hash:\n            raise core.VerificationError('Invalid hash.')\n        return common.HASH_METHODS[hash_method][1]\n    except core.VerificationError:\n        raise\n    except Exception as e:\n        raise core.VerificationError(str(e))\n\n", "CodeBleu_score": 39.0582253113733}, {"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        if not isinstance(pub_key, core.PublicKey):\n            raise core.VerificationError('Not a public key')\n        if not isinstance(signature, bytes):\n            raise core.VerificationError('Signature is not a byte string')\n        if not isinstance(message, bytes):\n            raise core.VerificationError('Message is not a byte string')\n        signature = common.bytes_to_long(signature)\n        if signature < 0:\n            raise core.VerificationError('Signature is not a positive integer')\n        if common.byte_size(signature) > common.byte_size(pub_key.n):\n            raise core.VerificationError('Signature is too large')\n        clearsig = core.decrypt_int(signature, pub_key)\n        if clearsig < 0:\n            raise core.VerificationError('Signature is not a positive integer')\n        if common.byte_size(clearsig) > common.byte_size(pub_key.n):\n            raise core.VerificationError('Signature is too large')\n        clearsig = common.long_to_bytes(clearsig)\n        if len(clearsig) < 8:\n            raise core.VerificationError('Signature is too short')\n        hash_name = clearsig[:8].decode('ascii')\n        if hash_name not in ('MD5', 'SHA-1', 'SHA-224', 'SHA-256', 'SHA-384', 'SHA-512'):\n            raise core.VerificationError('Unknown hash method')\n        if hash_name == 'MD5':\n            hash_method = hashlib.md5\n        elif hash_name == 'SHA-1':\n            hash_method = hashlib.sha1\n        elif hash_name == 'SHA-224':\n            hash_method = hashlib.sha224\n        elif hash_name == 'SHA-256':\n            hash_method = hashlib.sha256\n        elif hash_name == 'SHA-384':\n            hash_method = hashlib.sha384\n        elif hash_name == 'SHA-512':\n            hash_method = hashlib.sha512\n        else:\n            raise core.VerificationError('Unknown hash method')\n        h = hash_method()\n        h.update(message)\n        expected_hash = h.digest()\n        expected_hash = transform.int2bytes(expected_hash)\n       ", "CodeBleu_score": 35.006906521328105}, {"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        if isinstance(signature, str):\n            signature = signature.encode('latin1')\n        if isinstance(signature, bytes):\n            signature = core.bytes_to_long(signature)\n        if isinstance(signature, int):\n            pass\n        else:\n            raise ValueError('Invalid signature type: %s' % type(signature))\n    except Exception as e:\n        raise ValueError('Invalid signature: %s' % e)\n    else:\n        try:\n            if isinstance(message, str):\n                message = message.encode('latin1')\n            if isinstance(message, bytes):\n                pass\n            else:\n                raise ValueError('Invalid message type: %s' % type(message))\n        except Exception as e:\n            raise ValueError('Invalid message: %s' % e)\n        else:\n            try:\n                if not isinstance(pub_key, common.PublicKey):\n                    raise ValueError('Invalid public key')\n            except Exception as e:\n                raise ValueError('Invalid public key: %s' % e)\n            else:\n                try:\n                    signature = core.decrypt_int(signature, pub_key)\n                except Exception as e:\n                    raise ValueError('Invalid signature: %s' % e)\n                else:\n                    try:\n                        hash_name, padded_hash = transform.unpad(signature, pub_key.n)\n                    except Exception as e:\n                        raise ValueError('Invalid signature: %s' % e)\n                    else:\n                        try:\n                            expected_hash = core.bytes_to_long(core.hash(message, hash_name))\n                        except Exception as e:\n                            raise ValueError('Invalid message: %s' % e)\n                        else:\n                            if expected_hash!= padded_hash:\n                                raise ValueError('Invalid signature')\n                            return hash_name/pycfiles/django-apar-1.1.6.41.tar/0001_initial.cpython-37.py", "CodeBleu_score": 34.66309627525249}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tint32_t time_now = 0;\n\tint8_t ret = 0;\n\n\tif (get_time(&time_now) == 0) {\n\t\tupdateJWT(time_now);\n\t}\n\n\tret = connectMQTTClient();\n\n\tif (ret == 0) {\n\t\tmqtt_subscribe_flag = 1;\n\t}\n\n\tdebug_print(DBG_MQTT, \"MQTT connect attempt\n\");\n}", "CodeBleu_score": 16.62202600410529}, {"code": "static void connectMQTT(){\n\t\tint32_t time_now = 0;\n\tint32_t time_diff = 0;\n\ttime_now = get_time();\n\ttime_diff = time_now - last_time_update;\n\tif (time_diff > 300000) {\n\t\tif (time_now > 0) {\n\t\t\tlast_time_update = time_now;\n\t\t\tupdate_jwt(time_now);\n\t\t}\n\t}\n\tconnectToMQTTClient();\n\tmqtt_subscribe_flag = 1;\n\tdebug_print(DEBUG_PRINT_LEVEL_INFO, \"MQTT connection attempt\n\");\n}", "CodeBleu_score": 41.473511158215835}, {"code": "static void connectMQTT(){\n\t\t// Get current time\n\tstruct timespec currentTime;\n\tclock_gettime(CLOCK_REALTIME, &currentTime);\n\t// If time is valid, update JWT\n\tif (currentTime.tv_sec > 0) {\n\t\tupdateJWT(currentTime.tv_sec);\n\t}\n\t// Connect to MQTT client\n\tconnectMQTTClient();\n\t// Set flag to send MQTT SUBSCRIBE packet after connection is established\n\tmqttSubscribeFlag = 1;\n\t// Print debug message\n\tdebug_print(\"MQTT connection attempt\n\");\n}", "CodeBleu_score": 46.881064325293515}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tuint32_t limit = UINT32_MAX / 10;\n\tuint32_t digit;\n\tuint8_t  c;\n\n\tfor (int i = 0; i < width; i++) {\n\t\tc = str[i];\n\t\tif (c < '0' || c > '9') {\n\t\t\treturn NULL;\n\t\t}\n\t\tdigit = c - '0';\n\t\tif (value > limit) {\n\t\t\treturn NULL;\n\t\t}\n\t\tvalue = value * 10 + digit;\n\t}\n\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 27.272888036683785}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\n\tfor (int i = 0; i < width; i++) {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tvalue = value * 10 + *str - '0';\n\t\tstr++;\n\t}\n\n\t*num = value;\n\n\treturn str;\n}", "CodeBleu_score": 26.22302202154933}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\n\tfor (int i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\n\t\tvalue = value * 10 + (str[i] - '0');\n\t}\n\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 25.00904231103019}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t* cert_buf = build_state->cert_template;\n\tsize_t cert_size = build_state->cert_template_size;\n\tsize_t cert_offset = 0;\n\tsize_t cert_size_remaining = cert_size;\n\tsize_t cert_size_used = 0;\n\tconst atcacert_def_t* cert_def = build_state->cert_def;\n\tconst atcacert_def_t* issuer_cert_def = build_state->issuer_cert_def;\n\tconst uint8_t* public_key = build_state->public_key;\n\tconst uint8_t* private_key = build_state->private_key;\n\tconst uint8_t* ca_public_key = build_state->ca_public_key;\n\tconst uint8_t* ca_private_key = build_state->ca_private_key;\n\tconst uint8_t* ca_chain = build_state->ca_chain;\n\tconst size_t ca_chain_size = build_state->ca_chain_size;\n\tconst uint8_t* config_zone = build_state->config_zone;\n\tconst uint8_t* slot_config = build_state->slot_config;\n\tconst uint8_t* device_sn = build_state->device_sn;\n\tconst uint8_t* signer_id = build_state->signer_id;\n\tconst uint8_t* signer_id_size = build_state->signer_id_size;\n\tconst uint8_t* signer_cert = build_state->signer_cert;\n\tconst size_t signer_cert_size = build_state->signer_cert_size;\n\tconst uint8_t* signer_cert_key_id = build_state->signer_cert_key_id;\n\tconst size_t signer_cert_key_id_size = build_state->signer_cert_key_id_size;\n\tconst uint8_t* signer_cert_sn = build_state->signer_cert_sn;\n\tconst size_t signer_cert_sn_size = build_", "CodeBleu_score": 15.602458466220126}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tuint8_t* der_cert = build_state->cert_template;\n\tuint8_t* der_cert_end = der_cert + build_state->cert_template_size;\n\tuint8_t* der_cert_end_save = der_cert_end;\n\tuint8_t* der_cert_save = der_cert;\n\tint der_cert_size = 0;\n\tint der_cert_size_save = 0;\n\tuint8_t* der_cert_size_ptr = NULL;\n\tuint8_t* der_cert_size_ptr_save = NULL;\n\tuint8_t* der_cert_size_ptr_end = NULL;\n\tuint8_t* der_cert_size_ptr_end_save = NULL;\n\tuint8_t* der_cert_size_ptr_end_save_save = NULL;\n\tint der_cert_size_len = 0;\n\tint der_cert_size_len_save = 0;\n\tint der_cert_size_len_save_save = 0;\n\tint der_cert_size_len_save_save_save = 0;\n\tuint8_t* der_cert_size_ptr_save_save = NULL;\n\tuint8_t* der_cert_size_ptr_save_save_save = NULL;\n\tuint8_t* der_cert_size_ptr_end_save_save_save = NULL;\n\tint der_cert_size_len_save_save_save_save = 0;\n\tuint8_t* der_cert_size_ptr_save_save_save_save = NULL;\n\tuint8_t* der_cert_size_ptr_end_save_save_save_save = NULL;\n\tint der_cert_size_len_save_save_save_save_save = 0;\n\tuint8_t* der_cert_size_ptr_save_save_save_save_save = NULL;\n\tuint8_t* der_cert_size_ptr_end_save_save_save_save_save = NULL;\n\tint der_", "CodeBleu_score": 14.640456314261552}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tint cert_element_size = 0;\n\tint cert_size = 0;\n\tint cert_element_count = 0;\n\tint cert_element_index = 0;\n\tint cert_element_cert_index = 0;\n\tint cert_element_cert_size = 0;\n\tint cert_element_cert_offset = 0;\n\tint cert_element_cert_size_remaining = 0;\n\tint cert_element_cert_size_used = 0;\n\tint cert_element_cert_size_unused = 0;\n\tint cert_element_cert_size_cert = 0;\n\tint cert_element_cert_size_cert_remaining = 0;\n\tint cert_element_cert_size_cert_used = 0;\n\tint cert_element_cert_size_cert_unused = 0;\n\tint cert_element_cert_size_cert_size = 0;\n\tint cert_element_cert_size_cert_size_remaining = 0;\n\tint cert_element_cert_size_cert_size_used = 0;\n\tint cert_element_cert_size_cert_size_unused = 0;\n\tint cert_element_cert_size_cert_size_size = 0;\n\tint cert_element_cert_size_cert_size_size_remaining = 0;\n\tint cert_element_cert_size_cert_size_size_used = 0;\n\tint cert_element_cert_size_cert_size_size_unused = 0;\n\tint cert_element_cert_size_cert_size_cert = 0;\n\tint cert_element_cert_size_cert_size_cert_remaining = 0;\n\tint cert_element_cert_size_cert_size_cert_used = 0;\n\tint cert_element_cert_size_cert_size_cert_unused = 0;\n\tint cert_element_cert_size_cert_size_cert_size = 0;\n\tint cert_element_cert_size_cert_size_cert_size_remaining = 0;\n\tint", "CodeBleu_score": 7.982730154139903}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t tbs_digest[32];\n\tuint8_t sig_block[128];\n\tsize_t sig_size;\n\tuint8_t* tbs_start;\n\tuint8_t* tbs_end;\n\tsize_t   tbs_size;\n\tuint8_t  sig_start[32];\n\tuint8_t  sig_end[32];\n\tsize_t   sig_start_size;\n\tsize_t   sig_end_size;\n\tuint8_t  sig_start_offset;\n\tuint8_t  sig_end_offset;\n\tuint8_t  sig_block_size;\n\tuint8_t  tbs_digest_size;\n\tuint8_t  sig_block_offset;\n\tuint8_t  sig_block_size_offset;\n\tuint8_t  sig_block_size_size;\n\tuint8_t  sig_block_start_offset;\n\tuint8_t  sig_block_start_size;\n\tuint8_t  sig_block_end_offset;\n\tuint8_t  sig_block_end_size;\n\tuint8_t  sig_block_end_size_offset;\n\tuint8_t  sig_block_end_size_size;\n\tuint8_t  sig_block_end_size_value;\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Get the start and end of the TBS portion of the certificate\n\tret = atcacert_get_tbs_start_end(cert_def, cert, cert_size, &tbs_start, &tbs_end);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Get the size of the TBS portion of the certificate\n\ttbs_size = tbs_end - tbs_start;\n\n\t// Get the start and end of the signature block\n\tret = atcacert_get_sig_start_end(cert_", "CodeBleu_score": 43.09652582239176}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t digest[32];\n\tuint8_t signature[64];\n\tuint8_t public_key[64];\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, digest);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_get_subj_public_key(cert_def, cert, cert_size, public_key);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcah_verify_extern(digest, signature, public_key, ca_public_key);\n\n\treturn ret;\n}", "CodeBleu_score": 68.67256790400388}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tret = atcacert_read_cert_element(cert_def, cert, cert_size, CERT_ELEMENT_TBS_DIGEST, tbs_digest, sizeof(tbs_digest));\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_read_cert_element(cert_def, cert, cert_size, CERT_ELEMENT_SIGNATURE, signature, sizeof(signature));\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcah_verify_extern(ca_public_key, tbs_digest, signature);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 63.79515973131129}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tif(timer->next == timer)\n\t{\n\t\ttimer->next = timer->prev = 0;\n\t\treturn true;\n\t}\n\telse if(timer->next == 0)\n\t{\n\t\ttimer->prev->next = 0;\n\t\ttimer->prev = 0;\n\t\treturn true;\n\t}\n\telse if(timer->prev == 0)\n\t{\n\t\ttimer->next->prev = 0;\n\t\ttimer->next = 0;\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\ttimer->next->prev = timer->prev;\n\t\ttimer->prev->next = timer->next;\n\t\ttimer->next = timer->prev = 0;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 18.351548357941105}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tif (timer == NULL)\n\t{\n\t\treturn false;\n\t}\n\tif (timer->next == NULL && timer->prev == NULL)\n\t{\n\t\t*list = NULL;\n\t\treturn true;\n\t}\n\tif (timer->next!= NULL)\n\t{\n\t\ttimer->next->prev = timer->prev;\n\t}\n\tif (timer->prev!= NULL)\n\t{\n\t\ttimer->prev->next = timer->next;\n\t}\n\tif (*list == timer)\n\t{\n\t\t*list = timer->next;\n\t}\n\ttimer->next = NULL;\n\ttimer->prev = NULL;\n\treturn true;\n}", "CodeBleu_score": 27.295354208488902}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tif(list == NULL || *list == NULL || timer == NULL)\n\t\treturn false;\n\n\ttimerStruct_t *current = *list;\n\ttimerStruct_t *previous = NULL;\n\n\twhile(current!= NULL)\n\t{\n\t\tif(current == timer)\n\t\t{\n\t\t\tif(previous == NULL)\n\t\t\t\t*list = current->next;\n\t\t\telse\n\t\t\t\tprevious->next = current->next;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 32.429101879884634}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tstruct socket_info *socket_info;\n\n\tsocket_info = socket_get_info(socket);\n\n\tif (socket_info) {\n\t\tsocket_info->state = NOT_A_SOCKET;\n\t}\n\n\tif (close(socket) == SOCK_ERR_NO_ERROR) {\n\t\treturn BSD_SUCCESS;\n\t} else {\n\t\tswitch (m2m_errno) {\n\t\tcase SOCK_ERR_INVALID:\n\t\t\terrno = EBADF;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INVALID_ADDR:\n\t\t\terrno = EFAULT;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\terrno = EINVAL;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INVALID_OPT:\n\t\t\terrno = ENOPROTOOPT;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_CREATE:\n\t\t\terrno = ENOBUFS;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_BIND:\n\t\t\terrno = EADDRINUSE;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_LISTEN:\n\t\t\terrno = EOPNOTSUPP;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_ACCEPT:\n\t\t\terrno = EOPNOTSUPP;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_CONNECT:\n\t\t\terrno = EISCONN;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_SEND:\n\t\t\terrno = ECONNRESET;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_RECV:\n\t\t\terrno = ECONNRESET;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_SELECT:\n\t\t\terrno = EINVAL;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_SETSOCKOPT:\n\t\t\terrno = ENOPROTOOPT;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_GETSOCKOPT:\n\t\t\terrno = ENOPROTOOPT;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_SHUTDOWN:\n\t\t\terrno = ENOTCONN;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_CLOSE:\n\t\t\terrno = EBADF;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_BIND_IN_PROGRESS:\n\t\t\terrno = EADDRINUSE;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCK_LISTEN_", "CodeBleu_score": 42.61510305116845}, {"code": "int BSD_close(int socket){\n\t\tint ret = BSD_ERROR;\n\tstruct socket_info *info = BSD_get_socket_info(socket);\n\n\tif (info) {\n\t\tinfo->state = NOT_A_SOCKET;\n\t\tret = close(socket);\n\t\tif (ret < 0) {\n\t\t\tif (ret == SOCK_ERR_INVALID_ARG) {\n\t\t\t\tBSD_set_errno(BSD_EINVAL);\n\t\t\t} else if (ret == SOCK_ERR_INVALID) {\n\t\t\t\tBSD_set_errno(BSD_EINVAL);\n\t\t\t} else if (ret == SOCK_ERR_NOT_FOUND) {\n\t\t\t\tBSD_set_errno(BSD_EINVAL);\n\t\t\t} else if (ret == SOCK_ERR_IS_BOUND) {\n\t\t\t\tBSD_set_errno(BSD_EINVAL);\n\t\t\t} else if (ret == SOCK_ERR_IS_LISTENING) {\n\t\t\t\tBSD_set_errno(BSD_EINVAL);\n\t\t\t} else {\n\t\t\t\tBSD_set_errno(BSD_EIO);\n\t\t\t}\n\t\t\tret = BSD_ERROR;\n\t\t} else {\n\t\t\tret = BSD_SUCCESS;\n\t\t}\n\t} else {\n\t\tBSD_set_errno(BSD_EINVAL);\n\t\tret = BSD_ERROR;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 45.1925966310177}, {"code": "int BSD_close(int socket){\n\t\tint ret;\n\n\tsocket_t* socket_info;\n\n\tsocket_info = socket_info_get_by_id(socket);\n\n\tif (socket_info == NULL) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tsocket_info->state = SOCKET_STATE_NOT_A_SOCKET;\n\n\tret = close(socket);\n\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\terrno = EBADF;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INVALID_SOCKET:\n\t\t\terrno = EBADF;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INVALID_STATE:\n\t\t\terrno = EBADF;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_UNKNOWN:\n\t\t\terrno = EBADF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = EBADF;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 50.30755786170258}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint response;\n\n\tresponse = listen(socket, backlog);\n\n\tif (response < 0) {\n\t\tswitch (response) {\n\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\terrno = EINVAL;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INVALID:\n\t\t\terrno = EBADF;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_ADDRINUSE:\n\t\t\terrno = EADDRINUSE;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_ISCONN:\n\t\t\terrno = EISCONN;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INPROGRESS:\n\t\t\terrno = EALREADY;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_NOTCONN:\n\t\t\terrno = ENOTCONN;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_CONNABORTED:\n\t\t\terrno = ECONNABORTED;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_CONNRESET:\n\t\t\terrno = ECONNRESET;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_CONNREFUSED:\n\t\t\terrno = ECONNREFUSED;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_TIMEOUT:\n\t\t\terrno = ETIMEDOUT;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_NETUNREACH:\n\t\t\terrno = ENETUNREACH;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_HOSTUNREACH:\n\t\t\terrno = EHOSTUNREACH;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_WOULDBLOCK:\n\t\t\terrno = EWOULDBLOCK;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_MSGSIZE:\n\t\t\terrno = EMSGSIZE;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INPROGRESS:\n\t\t\terrno = EINPROGRESS;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_NAMETOOLONG:\n\t\t\terrno = ENAMETOOLONG;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_NOTSUPP:\n\t\t\terrno = ENOTSUP;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_OPNOTSUPP:\n\t\t\terrno = EOPNOTSUPP;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_SOCKCLOSED:\n\t\t\terrno = EBADF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 38.99605367297138}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint response;\n\n\tresponse = listen(socket, backlog);\n\n\tif (response < 0) {\n\t\tswitch (response) {\n\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\terrno = EINVAL;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INVALID:\n\t\t\terrno = EBADF;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_ADDRINUSE:\n\t\t\terrno = EADDRINUSE;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INPROGRESS:\n\t\t\terrno = EINPROGRESS;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_ISCONN:\n\t\t\terrno = EISCONN;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_NOTCONN:\n\t\t\terrno = ENOTCONN;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_CONNABORTED:\n\t\t\terrno = ECONNABORTED;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_CONNRESET:\n\t\t\terrno = ECONNRESET;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_TIMEOUT:\n\t\t\terrno = ETIMEDOUT;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_NETUNREACH:\n\t\t\terrno = ENETUNREACH;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_HOSTUNREACH:\n\t\t\terrno = EHOSTUNREACH;\n\t\t\tbreak;\n\t\tcase SOCK_ERR_CONNREFUSED:\n\t\t\terrno = ECONNREFUSED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 40.88578229016255}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint8_t response;\n\n\tresponse = m2m_wifi_listen(socket, backlog);\n\n\tif (response == SOCK_ERR_NO_ERROR) {\n\t\treturn BSD_SUCCESS;\n\t} else {\n\t\tdebug_printError(\"BSD_listen\", response, \"m2m_wifi_listen\");\n\t\treturn BSD_ERROR;\n\t}\n}", "CodeBleu_score": 30.301778202456376}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tstruct sockaddr_in * addr_in = (struct sockaddr_in *) addr;\n\tstruct sockaddr_in6 * addr_in6 = (struct sockaddr_in6 *) addr;\n\tint32_t ret;\n\n\tif (addr == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (addrlen == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (addr_in->sin_family == AF_INET) {\n\t\tret = accept(socket, (struct sockaddr *) addr_in, addrlen);\n\n\t\tif (ret < 0) {\n\t\t\tswitch (ret) {\n\t\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\t\terrno = EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_NO_SOCKET:\n\t\t\t\terrno = EBADF;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_ADDR_IN_USE:\n\t\t\t\terrno = EADDRINUSE;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_ADDR_NOT_AVAIL:\n\t\t\t\terrno = EADDRNOTAVAIL;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_CONN_ABORTED:\n\t\t\t\terrno = ECONNABORTED;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_CONN_RESET:\n\t\t\t\terrno = ECONNRESET;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_CONN_TIMEOUT:\n\t\t\t\terrno = ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_IN_PROGRESS:\n\t\t\t\terrno = EINPROGRESS;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_IS_CONN:\n\t\t\t\terrno = EISCONN;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_NET_UNREACH:\n\t\t\t\terrno = ENETUNREACH;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_NO_BUFF_SPACE:\n\t\t\t\terrno = ENOBUFS;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_WOULD_BLOCK:\n\t\t\t\terrno = EWOULDBLOCK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terrno = EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn ret;\n\t} else if (addr_in6->sin6_family == AF_INET6) {\n\t\tret = accept(socket, (struct sockaddr *) addr_in6, addrlen);\n\n\t\tif (ret <", "CodeBleu_score": 39.149608079265576}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tstruct sockaddr_in *addr_in;\n\tstruct sockaddr_in6 *addr_in6;\n\tstruct sockaddr_in addr_in_local;\n\tstruct sockaddr_in6 addr_in6_local;\n\tint32_t ret;\n\n\tif (addr == NULL) {\n\t\taddr = (struct bsd_sockaddr *) &addr_in_local;\n\t}\n\n\tif (addrlen == NULL) {\n\t\taddrlen = (socklen_t *) &addr_in_local;\n\t}\n\n\tif (addr->sa_family == AF_INET) {\n\t\taddr_in = (struct sockaddr_in *) addr;\n\t\taddr_in->sin_len = sizeof(struct sockaddr_in);\n\t\taddr_in->sin_family = AF_INET;\n\n\t\tret = socketAccept(socket, (struct sockaddr *) addr_in, addrlen);\n\t} else if (addr->sa_family == AF_INET6) {\n\t\taddr_in6 = (struct sockaddr_in6 *) addr;\n\t\taddr_in6->sin6_len = sizeof(struct sockaddr_in6);\n\t\taddr_in6->sin6_family = AF_INET6;\n\n\t\tret = socketAccept(socket, (struct sockaddr *) addr_in6, addrlen);\n\t} else {\n\t\terrno = EAFNOSUPPORT;\n\t\tret = -1;\n\t}\n\n\tif (ret < 0) {\n\t\tif (socket == SOCK_TCP_SERVER) {\n\t\t\terrno = ECONNABORTED;\n\t\t} else {\n\t\t\terrno = ECONNRESET;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 41.680314182067534}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tstruct sockaddr_in * addr_in = (struct sockaddr_in *)addr;\n\tint ret = 0;\n\n\tif (addr_in->sin_family!= AF_INET) {\n\t\tret = -1;\n\t\terrno = EAFNOSUPPORT;\n\t} else {\n\t\tret = accept(socket, (struct sockaddr *)addr_in, addrlen);\n\n\t\tif (ret < 0) {\n\t\t\tswitch (ret) {\n\t\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\t\terrno = EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_ADDR_IN_USE:\n\t\t\t\terrno = EADDRINUSE;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_ADDR_NOT_AVAIL:\n\t\t\t\terrno = EADDRNOTAVAIL;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_CONN_ABORTED:\n\t\t\t\terrno = ECONNABORTED;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_CONN_RESET:\n\t\t\t\terrno = ECONNRESET;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_DEST_UNREACH:\n\t\t\t\terrno = EHOSTUNREACH;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_HOST_UNREACH:\n\t\t\t\terrno = EHOSTUNREACH;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_IF:\n\t\t\t\terrno = EFAULT;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_IN_PROGRESS:\n\t\t\t\terrno = EINPROGRESS;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_INVALID:\n\t\t\t\terrno = EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_INVALID_SOCKET:\n\t\t\t\terrno = EBADF;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_ISCONN:\n\t\t\t\terrno = EISCONN;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_IS_CONNECTED:\n\t\t\t\terrno = EISCONN;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_MSG_SIZE:\n\t\t\t\terrno = EMSGSIZE;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_NET_DOWN:\n\t\t\t\terrno = ENETDOWN;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_NET_RESET:\n\t\t\t\terrno = ENETRESET;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_NET_UNREACH:\n\t\t\t\terrno = ENETUNREACH;\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_NO_", "CodeBleu_score": 34.911445519256944}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tint32_t status;\n\tuint32_t currentTime;\n\tuint32_t timeOffset;\n\n\t/* Get the current time in UNIX format */\n\tcurrentTime = getUnixTime();\n\n\t/* Check if the time is valid */\n\tif (currentTime == 0) {\n\t\t/* Print a debug message */\n\t\tprintf(\"Invalid time.\n\");\n\t\treturn;\n\t}\n\n\t/* Update the JWT with the current time offset */\n\ttimeOffset = currentTime - getUnixTimeAtBoot();\n\tupdateJWT(timeOffset);\n\n\t/* Initiate the MQTT connection */\n\tstatus = mqtt_connect(&mqttClient, &mqttNetwork, &mqttConnectInfo);\n\n\t/* Print a debug message */\n\tprintf(\"Connecting to MQTT broker... \");\n\n\t/* Check if the connection was successful */\n\tif (status == MQTT_CODE_SUCCESS) {\n\t\t/* Print a debug message */\n\t\tprintf(\"Connected.\n\");\n\n\t\t/* Set a flag to send an MQTT SUBSCRIBE packet once the connection is established */\n\t\tmqttSubscribeFlag = 1;\n\t} else {\n\t\t/* Print a debug message */\n\t\tprintf(\"Failed.\n\");\n\t}\n}", "CodeBleu_score": 43.0363158809977}, {"code": "static void connectMQTT(){\n\t\tif (isTimeValid()) {\n\t\tupdateJWT();\n\t\tif (mqtt_connect(&mqttClient, &mqttNetwork, &mqttConnectParams)!= MQTT_CODE_SUCCESS) {\n\t\t\tdebug_printError(\"MQTT connection failed\\r\n\");\n\t\t\treturn;\n\t\t}\n\t\tdebug_printInfo(\"MQTT connection established\\r\n\");\n\t\tsendSubscribe = true;\n\t} else {\n\t\tdebug_printError(\"Time is not valid\\r\n\");\n\t}\n}", "CodeBleu_score": 42.55893789767886}, {"code": "static void connectMQTT(){\n\t\tuint32_t time = 0;\n\n\tif (getTime(&time) == 0) {\n\t\tdebug_print(\"Time is valid\\r\n\");\n\t\tsetJWTTime(time);\n\t\tinitMQTTConnection();\n\t\tdebug_print(\"MQTT connect\\r\n\");\n\t\tsendMQTTSubscribe = 1;\n\t}\n}", "CodeBleu_score": 40.601080225440114}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tdebug_print_app_info(\"CLOUD_disconnect\n\");\n\tif (MQTT_get_connection_state() == MQTT_CONNECTED) {\n\t\tmqtt_client_info_t client_info;\n\t\tMQTT_get_client_info(&client_info);\n\t\tMQTT_disconnect(&client_info);\n\t}\n}", "CodeBleu_score": 52.161604658926684}, {"code": "void CLOUD_disconnect(void){\n\t\tif (mqtt_get_client_state() == MQTT_CLIENT_STATE_CONNECTED) {\n\t\tmqtt_client_connection_info_t client_connection_info;\n\t\tmqtt_get_client_connection_info(&client_connection_info);\n\t\tmqtt_disconnect(client_connection_info.client_id, client_connection_info.keep_alive_time);\n\t}\n\tdebug_print_app_entry(\"CLOUD_disconnect\");\n}", "CodeBleu_score": 48.0215861510378}, {"code": "void CLOUD_disconnect(void){\n\t\t/*\n\t * Logs a debug message indicating the disconnection.\n\t */\n\tDEBUG_PRINT(\"Cloud Disconnected\\r\n\");\n\n\t/*\n\t * If the MQTT connection state is \"CONNECTED\", it retrieves the client connection information and disconnects the MQTT client.\n\t */\n\tif (CLOUD_MQTT_CLIENT_STATE == CONNECTED) {\n\t\t/*\n\t\t * Retrieves the client connection information.\n\t\t */\n\t\tMQTT_Client *client = MQTT_get_client();\n\n\t\t/*\n\t\t * Disconnects the MQTT client.\n\t\t */\n\t\tMQTT_disconnect(client);\n\t}\n}", "CodeBleu_score": 46.84029547650573}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiInitParam param;\n\tint8_t ret;\n\tuint8_t u8IsMacAddrValid;\n\tuint8_t u8MacAddr[6];\n\n\t/* Initialize the BSP. */\n\tnm_bsp_init();\n\n\t/* Initialize Wi-Fi parameters structure. */\n\tmemset((uint8_t *) &param, 0, sizeof(tstrWifiInitParam));\n\n\t/* Initialize Wi-Fi driver with data and status callbacks. */\n\tparam.pfAppWifiCb = wifi_cb;\n\tret = m2m_wifi_init(&param);\n\tif (M2M_SUCCESS!= ret) {\n\t\tdebug_printError(\"wifi_connectToAp: m2m_wifi_init call error!\");\n\t\treturn false;\n\t}\n\n\t/* Initialize socket module. */\n\tsocketInit();\n\t/* Register socket callback function. */\n\tregisterSocketCallback(wifi_socket_cb, NULL);\n\n\t/* Initialize Wi-Fi credentials. */\n\tif (passed_wifi_creds == true) {\n\t\t/* Initialize Wi-Fi module. */\n\t\tm2m_wifi_deinit(NULL);\n\t\t/* Initialize Wi-Fi parameters structure. */\n\t\tmemset((uint8_t *) &param, 0, sizeof(tstrWifiInitParam));\n\t\t/* Initialize Wi-Fi driver with data and status callbacks. */\n\t\tparam.pfAppWifiCb = wifi_cb;\n\t\tret = m2m_wifi_init(&param);\n\t\tif (M2M_SUCCESS!= ret) {\n\t\t\tdebug_printError(\"wifi_connectToAp: m2m_wifi_init call error!\");\n\t\t\treturn false;\n\t\t}\n\t\t/* Initialize socket module. */\n\t\tsocketInit();\n\t\t/* Register socket callback function. */\n\t\tregisterSocketCallback(wifi_socket_cb, NULL);\n\n\t\t/* Initialize Wi-Fi module. */\n\t\tm2m_wifi_deinit(NULL);\n\n\t\t/* Initialize Wi-Fi parameters structure. */\n\t\tmemset((uint8_t *) &param, 0, sizeof(tstrWifiInitParam));\n\n\t\t/* Initialize Wi-Fi driver with data and status callbacks. */\n\t\tparam.pfAppWifiCb = wifi_cb;\n\n\t\tret = m2m_wifi_init", "CodeBleu_score": 41.416770692266994}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiInitParam param;\n\tint8_t ret;\n\tuint8_t u8IsMacAddrValid;\n\tuint8_t u8MacAddress[6];\n\ttstrM2MAPConfig strM2MAPConfig;\n\ttstrNetworkId strNetworkId;\n\ttstrAuthConfig strAuthConfig;\n\ttstrWifiConnInfo wifi_conn_info;\n\tuint8_t u8IsIpAddrValid;\n\tuint8_t u8IsGwAddrValid;\n\tuint8_t u8IsDnsAddrValid;\n\tuint8_t u8IsDhcpEnabled;\n\tuint8_t u8IsStaticIp;\n\tuint8_t u8IsStaticDns;\n\tuint8_t u8IsStaticGateway;\n\tuint8_t u8IsStaticIpAddr[4];\n\tuint8_t u8IsStaticDnsAddr[4];\n\tuint8_t u8IsStaticGatewayAddr[4];\n\n\tmemset(&param, 0, sizeof (param));\n\tparam.pfAppWifiCb = wifi_cb;\n\n\tret = m2m_wifi_init(&param);\n\n\tif (M2M_SUCCESS!= ret) {\n\t\tDEBUG_PRINT(\"m2m_wifi_init call error!", "CodeBleu_score": 26.117960105907756}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiInitParam param;\n\tint8_t ret;\n\tuint8_t wifi_creds = passed_wifi_creds;\n\n\t/* Initialize Wi-Fi parameters structure. */\n\tmemset((uint8_t *) &param, 0, sizeof(tstrWifiInitParam));\n\n\t/* Initialize Wi-Fi driver with data and status callbacks. */\n\tparam.pfAppWifiCb = wifi_callback;\n\tret = m2m_wifi_init(&param);\n\tif (M2M_SUCCESS!= ret) {\n\t\tDEBUG_PRINT(\"main: m2m_wifi_init call error!\\r\n\");\n\t\treturn false;\n\t}\n\n\t/* Initialize socket module. */\n\tsocketInit();\n\tregisterSocketCallback(socket_callback, resolve_callback);\n\n\t/* Connect to router. */\n\tif (wifi_creds == WIFI_NEW_CREDS) {\n\t\t/* Connect to router. */\n\t\tret = m2m_wifi_connect((char *) SSID, strlen(SSID), AUTH_TYPE,\n\t\t\t\t(char *) PASS, M2M_WIFI_CH_ALL);\n\t\tif (M2M_SUCCESS!= ret) {\n\t\t\tDEBUG_PRINT(\"main: m2m_wifi_connect call error!\\r\n\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t/* Connect to router. */\n\t\tret = m2m_wifi_default_connect();\n\t\tif (M2M_SUCCESS!= ret) {\n\t\t\tDEBUG_PRINT(\"main: m2m_wifi_connect call error!\\r\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 48.213402618110564}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t\ttry {\n\t\tconst client = new AWSAppSyncClient({\n\t\t\turl: awsconfig.aws_appsync_graphqlEndpoint,\n\t\t\tregion: awsconfig.aws_appsync_region,\n\t\t\tauth: {\n\t\t\t\ttype: AUTH_TYPE.AMAZON_COGNITO_USER_POOLS,\n\t\t\t\tjwtToken: async () => (await Auth.currentSession()).getIdToken().getJwtToken(),\n\t\t\t},\n\t\t});\n\t\tconst response = await client.query({\n\t\t\tquery: gql(queries.listSensors),\n\t\t});\n\t\tif (response.data.listSensors.items) {\n\t\t\tconsole.log('Retrieved sensors');\n\t\t\tfor (const sensor of response.data.listSensors.items) {\n\t\t\t\tconst marker = new maplibregl.Marker({\n\t\t\t\t\tcolor:'red',\n\t\t\t\t\tdraggable: false,\n\t\t\t\t}).setLngLat([sensor.longitude, sensor.latitude]).addTo(map);\n\t\t\t\tmarker.getElement().addEventListener('click', () => {\n\t\t\t\t\tconst popup = new maplibregl.Popup({\n\t\t\t\t\t\tcloseButton: true,\n\t\t\t\t\t\tcloseOnClick: true,\n\t\t\t\t\t}).setLngLat([sensor.longitude, sensor.latitude]).setHTML(`<h1>${sensor.name}</h1>`).addTo(map);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tconsole.log(error);\n\t}\n}", "CodeBleu_score": 37.566158308764784}, {"code": "async function DisplaySensors(map){\n\t\tconst client = new AWSAppSyncClient({\n\t\turl: aws_exports.aws_appsync_graphqlEndpoint,\n\t\tregion: aws_exports.aws_appsync_region,\n\t\tauth: {\n\t\t\ttype: AUTH_TYPE.API_KEY,\n\t\t\tapiKey: aws_exports.aws_appsync_apiKey,\n\t\t},\n\t});\n\n\tconst sensorData = await client.query({\n\t\tquery: queries.listSensors,\n\t});\n\tconsole.log(sensorData);\n\n\tif (sensorData.data.listSensors.items) {\n\t\tconsole.log('Retrieved sensors');\n\t\tsensorData.data.listSensors.items.forEach((sensor) => {\n\t\t\tconst marker = new maplibregl.Marker({\n\t\t\t\tcolor:'red',\n\t\t\t\tdraggable: false,\n\t\t\t})\n\t\t\t\t.setLngLat([sensor.longitude, sensor.latitude])\n\t\t\t\t.addTo(map);\n\t\t});\n\t}\n}", "CodeBleu_score": 39.66231293596734}, {"code": "async function DisplaySensors(map){\n\t\tconst client = createClient({\n\t\turl: 'https://90406692.execute-api.us-east-2.amazonaws.com/dev/graphql',\n\t});\n\n\tconst query = `query {\n\t\tlistSensors {\n\t\t\titems {\n\t\t\t\tsensorID\n\t\t\t\tsensorName\n\t\t\t\tsensorType\n\t\t\t\tsensorLocation {\n\t\t\t\t\tlatitude\n\t\t\t\t\tlongitude\n\t\t\t\t}\n\t\t\t\tsensorStatus\n\t\t\t}\n\t\t}\n\t}`;\n\n\ttry {\n\t\tconst response = await client.query({ query });\n\t\tconsole.log(response);\n\t\tif (response.data.listSensors.items) {\n\t\t\tconsole.log('Retrieved sensors');\n\t\t\tresponse.data.listSensors.items.forEach((sensor) => {\n\t\t\t\tconst marker = new maplibregl.Marker()\n\t\t\t\t\t.setLngLat([sensor.sensorLocation.longitude, sensor.sensorLocation.latitude])\n\t\t\t\t\t.addTo(map);\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(error);\n\t}\n}", "CodeBleu_score": 39.717529640791696}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = \"white\";\n\tmarker.style.border = \"2px solid #333\";\n\treturn marker;\n}", "CodeBleu_score": 43.27129665075824}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = 'blue';\n\tmarker.style.border = '2px solid #fff';\n\treturn marker;\n}", "CodeBleu_score": 43.69131738032458}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\nmarker.id = `sensor-${sensor.id}`;\nmarker.className ='sensor-marker';\nmarker.style.backgroundColor = '#333';\nmarker.style.border = '1px solid #333';\nmarker.style.width = '20px';\nmarker.style.height = '20px';\nmarker.style.borderRadius = '50%';\nmarker.style.cursor = 'pointer';\nreturn marker;\n}", "CodeBleu_score": 45.033327173633495}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    try:\n        module = async_import_module(f\"homeassistant.components.mfa.{module_name}\")\n    except ImportError as err:\n        _LOGGER.error(\"Unable to import MFA module %s: %s\", module_name, err)\n        raise HomeAssistantError(\n            f\"Unable to import MFA module {module_name}: {err}\"\n        ) from err\n\n    if module.REQUIREMENTS and not module.SKIP_PIP:\n        if not hass.data.get(module.DOMAIN):\n            requirements.async_process_requirements(\n                hass, module.DOMAIN, module.REQUIREMENTS\n            )\n        elif module.DOMAIN not in hass.data[module.DOMAIN].requirements:\n            requirements.async_process_requirements(\n                hass, module.DOMAIN, module.REQUIREMENTS\n            )\n\n    return module\n\n", "CodeBleu_score": 50.424122300002864}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    try:\n        module_path = f\"homeassistant.components.auth_providers.{module_name}\"\n        module = async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Unable to import module %s: %s\", module_path, err)\n        raise HomeAssistantError(\"Unable to import module\") from err\n\n    if module.REQUIREMENTS and not requirements.async_skip_pip(hass):\n        requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, f\"auth provider {module_name}\"\n        )\n\n    return module\n\n", "CodeBleu_score": 38.41540353173626}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    try:\n        mfa_module = await async_import_module(hass, f\"homeassistant.components.mfa.{module_name}\")\n    except ImportError as err:\n        _LOGGER.error(\"Failed to import MFA module %s: %s\", module_name, err)\n        raise HomeAssistantError(\n            f\"Failed to import MFA module {module_name}: {err}\"\n        ) from err\n    if not mfa_module.REQUIREMENTS:\n        return mfa_module\n    if not requirements.async_check_ha_requirements(hass, mfa_module.REQUIREMENTS):\n        if not requirements.async_install_and_check_requirements(\n            hass, module_name, mfa_module.REQUIREMENTS\n        ):\n            raise HomeAssistantError(\n                f\"Unable to install requirements for {module_name}: {mfa_module.REQUIREMENTS}\"\n            )\n    return mfa_module\n\n", "CodeBleu_score": 47.40309001929875}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id not in self._data:\n        self._data[user_id] = setup_data\n    else:\n        self._data[user_id] = setup_data\n\n", "CodeBleu_score": 24.36044429963577}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id not in self._user_data:\n        self._user_data[user_id] = {}\n    self._user_data[user_id][\"pin\"] = setup_data[\"pin\"]\n\n", "CodeBleu_score": 30.519904044290097}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n    # Save the data\n    await self.async_save_data()\n\n    # Return the data\n    return self.data[user_id]\n\n", "CodeBleu_score": 37.81866945594483}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._loaded:\n            return\n\n        data = await self._store.async_load()\n\n        if not data:\n            data = {}\n\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id,\n                {\n                    CONF_INCLUDE: data.get(user_id, {}).get(CONF_INCLUDE, []),\n                    CONF_EXCLUDE: data.get(user_id, {}).get(CONF_EXCLUDE, []),\n                },\n            )\n            for user_id in data\n        }\n        self._loaded = True\n\n", "CodeBleu_score": 40.43646643085639}, {"code": "async def _async_load(self) -> None\n\t\n    if self._loaded:\n        return\n    await self._init_lock.acquire()\n    try:\n        if self._loaded:\n            return\n        data = await self._store.async_load()\n        if data is None:\n            data = {}\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id,\n                user_data.get(CONF_INCLUDE, []),\n                user_data.get(CONF_EXCLUDE, []),\n            )\n            for user_id, user_data in data.items()\n        }\n    finally:\n        self._init_lock.release()\n\n", "CodeBleu_score": 38.85126400647}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._loaded:\n            return\n\n        data = await self._store.async_load()\n        if not data:\n            data = {}\n\n        self._settings = {\n            user_id: NotifySetting(user_id, settings)\n            for user_id, settings in data.items()\n        }\n        self._loaded = True\n\n", "CodeBleu_score": 38.16247032446206}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load_user_settings(user_id)\n\n    settings = self._user_settings.get(user_id)\n    if not settings:\n        return False\n\n    if not await self.hass.async_add_executor_job(\n        settings.validate_otp, user_input[\"otp\"]\n    ):\n        return False\n\n    return True\n\n", "CodeBleu_score": 42.21390073115342}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_user(user_id)\n    settings = await self.async_get_user_settings(user_id)\n    if settings is None:\n        return False\n    return await self.hass.async_add_executor_job(\n        settings.validate, user_input[CONF_OTP]\n    )\n\n", "CodeBleu_score": 44.12607258775497}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load()\n    settings = await self.async_get_user_settings(user_id)\n    if settings is None:\n        return False\n    return await self.hass.async_add_executor_job(\n        settings.validate, user_input.get(\"otp\")\n    )\n\n", "CodeBleu_score": 42.6667532408911}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 47.22039460883292}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n\n    area_id = device.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.390134801419954}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_entries.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.device_entries.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    if not device_entry.area_id:\n        return None\n    area_id = device_entry.area_id\n    area_entry = area_dict.get(area_id)\n    if area_entry is None:\n        return None\n    return area_entry.permissions\n\n", "CodeBleu_score": 63.50918815390819}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: dict[str, list[str]] = {}\n    seen_categories = set()\n    for p in policies:\n        for category in p:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                policy[category] = p[category]\n                for p2 in policies:\n                    if category in p2 and p2[category]!= p[category]:\n                        policy[category] = merge_category(policy[category], p2[category])\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 42.9657518609397}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_categories(\n                    [policy[category] for policy in policies]\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 61.65038491539415}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: dict[str, dict[str, dict[str, str]]] = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_categories(\n                    [policy[category] for policy in policies]\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 53.07976948188442}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        return await async_import_module(hass, f\"homeassistant.components.auth_provider.{provider}\")\n    except ImportError:\n        _LOGGER.error(\n            \"Unable to import authentication provider %s\",\n            provider,\n            exc_info=True,\n        )\n        raise HomeAssistantError(\n            f\"Unable to import authentication provider {provider}\"\n        ) from None\n\n", "CodeBleu_score": 22.709170861299913}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.components.auth_providers.{provider}\")\n    except ImportError:\n        _LOGGER.error(\n            \"Unable to import auth provider %s, is it installed and enabled?\", provider\n        )\n        raise HomeAssistantError(f\"Unable to import auth provider {provider}\") from None\n\n    if not module.REQUIREMENTS or not hass.config.skip_pip:\n        return module\n\n    processed_requirements = hass.config.processed_requirements\n    requirements_added = False\n\n    for requirement in module.REQUIREMENTS:\n        if requirement not in processed_requirements:\n            requirements_added = True\n            processed_requirements.add(requirement)\n\n    if requirements_added:\n        await requirements.async_process_requirements(\n            hass, module.DOMAIN, module.REQUIREMENTS\n        )\n\n    return module\n\n", "CodeBleu_score": 44.84173688122976}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, provider)\n    except ImportError as err:\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider}: {err}\"\n        ) from err\n\n    if not hasattr(module, \"REQUIREMENTS\") or not module.REQUIREMENTS:\n        return module\n\n    requirements.async_process_requirements(\n        hass,\n        module.REQUIREMENTS,\n        f\"auth provider {provider}\",\n        skip_if_missing=True,\n    )\n\n    return module\n\n", "CodeBleu_score": 40.18910946337391}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    self._users = await self.store.async_load() or []\n    self._users = [\n        self._normalize_user(user) for user in self._users if user.get(CONF_ID)\n    ]\n\n", "CodeBleu_score": 22.53293715310381}, {"code": "async def async_load(self) -> None\n\t\n    self.users = []\n    self.data = await self._store.async_load()\n    if self.data is None:\n        self.data = {}\n        return\n\n    for user in self.data.values():\n        if user.get(CONF_ID) is None:\n            user[CONF_ID] = _generate_id()\n\n    self._async_normalize_users()\n\n", "CodeBleu_score": 27.596120957382475}, {"code": "async def async_load(self) -> None\n\t\n    await self._store.async_load()\n    self._users = self._store.data or []\n    self._non_normalized_usernames = set()\n    for user in self._users:\n        if user[CONF_ID]!= normalize_username(user[CONF_ID]):\n            self._non_normalized_usernames.add(user[CONF_ID])\n\n", "CodeBleu_score": 20.690522246395602}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users.values():\n        if user.username == username:\n            password_hash = base64.b64decode(user.password_hash)\n            if not bcrypt.checkpw(password.encode(), password_hash):\n                raise InvalidAuth()\n            return\n    if not bcrypt.checkpw(b\"\", dummy_hash):\n        raise InvalidAuth()\n\n", "CodeBleu_score": 34.991650024762464}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[CONF_ID] == username:\n            if not bcrypt.checkpw(password.encode(), base64.b64decode(user[\"password\"])):\n                raise InvalidAuth()\n            return\n    if not bcrypt.checkpw(b\"\", dummy_hash):\n        raise InvalidAuth()\n\n", "CodeBleu_score": 37.42251502716349}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self._users.values():\n        if user[\"username\"] == username:\n            stored_password_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(), stored_password_hash):\n                return\n            raise InvalidAuth()\n    if bcrypt.checkpw(b\"dummy\", dummy_hash):\n        raise InvalidAuth()\n\n", "CodeBleu_score": 41.19900804087943}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    if username not in self.users:\n        raise ir.InvalidUser(f\"User {username} not found\")\n    del self.users[username]\n\n", "CodeBleu_score": 20.639444896487607}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    if username in self.users:\n        self.users.remove(username)\n        self.async_write_auth_store()\n    else:\n        raise InvalidUser(f\"User {username} not found\")\n\n", "CodeBleu_score": 23.302950344538264}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    for user in self._users:\n        if user.username == username:\n            self._users.remove(user)\n            self._save_users()\n            return\n    raise InvalidUser(username)\n\n", "CodeBleu_score": 27.312491248190852}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._initialized:\n        await self.async_initialize()\n    try:\n        self._data.pop(credentials.username)\n    except KeyError:\n        pass\n    await self.async_save_data()\n\n", "CodeBleu_score": 45.31884770410636}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._initialized:\n        await self._async_initialize()\n    try:\n        self._data.pop(credentials.username)\n    except KeyError:\n        pass\n    await self._async_save_data()\n\n", "CodeBleu_score": 44.79570970761036}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.initialized:\n        await self.async_initialize()\n\n    try:\n        self.users.pop(credentials.username)\n    except KeyError:\n        pass\n\n    await self.async_save()\n\n", "CodeBleu_score": 44.819775805698356}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    if not threads:\n        return joined\n\n    with ThreadPoolExecutor(max_workers=1) as executor:\n        for thread in threads:\n            timeout_for_thread = timeout / len(threads)\n            try:\n                executor.submit(thread.join, timeout_for_thread).result()\n            except TimeoutError:\n                pass\n            except Exception:\n                logging.error(f\"Error while joining thread {thread}: {traceback.format_exc()}\")\n            else:\n                joined.add(thread)\n            if thread.is_alive():\n                if log:\n                    logging.warning(f\"Thread {thread} is still running after {timeout} seconds\")\n                try:\n                    thread.raise_exception(SystemExit)\n                except Exception:\n                    logging.error(\n                        f\"Error while raising exception in thread {thread}: {traceback.format_exc()}\"\n                    )\n    return joined\n\n", "CodeBleu_score": 47.25157259166176}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        if log:\n            logging.info(\n                f\"Thread {thread.name} is still running, interrupting it\"\n            )\n        thread.raise_exception(SystemExit)\n    remaining_threads = threads - joined\n    if remaining_threads:\n        if log:\n            logging.info(\n                f\"Waiting for {len(remaining_threads)} threads to finish\"\n            )\n        start_time = time.time()\n        while remaining_threads and time.time() - start_time < timeout:\n            for thread in remaining_threads:\n                if not thread.is_alive() or not thread.ident:\n                    joined.add(thread)\n                    remaining_threads.remove(thread)\n            time.sleep(0.1)\n        if remaining_threads:\n            if log:\n                logging.info(\n                    f\"Threads {remaining_threads} did not finish in {timeout} seconds\"\n                )\n            for thread in remaining_threads:\n                if log:\n                    logging.info(\n                        f\"Thread {thread.name} is still running, interrupting it\"\n                    )\n                thread.raise_exception(SystemExit)\n    return joined\n\n", "CodeBleu_score": 44.21748695267025}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident is not None:\n                thread.join(timeout)\n                if thread.is_alive():\n                    joined.add(thread)\n                    if log:\n                        logging.warning(\n                            f\"Thread {thread.name} is still running after {timeout} seconds\"\n                        )\n            else:\n                joined.add(thread)\n        else:\n            joined.add(thread)\n    for thread in joined:\n        if thread.is_alive():\n            thread.raise_exception(SystemExit)\n    return joined\n\n", "CodeBleu_score": 38.598422385723964}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get all non-main, non-daemon, alive threads\n    non_main_threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.current_thread()\n        and not thread.isDaemon()\n        and thread.isAlive()\n    ]\n    # Calculate timeout for each thread\n    total_timeout = 5\n    timeout = total_timeout / len(non_main_threads)\n    # Join each thread\n    for thread in non_main_threads:\n        try:\n            thread.join(timeout)\n        except Exception:\n            logging.warning(\n                f\"Failed to join thread {thread.name} within {timeout} seconds.\"\n            )\n\n", "CodeBleu_score": 39.387681453510424}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    main_thread = threading.main_thread()\n    remaining_threads = [\n        thread for thread in threading.enumerate() if not thread.is_daemon() and thread!= main_thread\n    ]\n    if len(remaining_threads) == 0:\n        return\n    total_timeout = 10\n    timeout_per_thread = total_timeout / len(remaining_threads)\n    for thread in remaining_threads:\n        thread.join(timeout_per_thread)\n        if thread.is_alive():\n            logging.warning(f\"Could not join thread {thread.name} within {timeout_per_thread} seconds.\")\n\n", "CodeBleu_score": 39.421090397084946}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    main_thread = threading.main_thread()\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not main_thread and not thread.daemon\n    ]\n    if not threads:\n        return\n    logging.warning(\n        f\"Waiting for {len(threads)} non-main, non-daemon threads to finish.\"\n    )\n    timeout = 0.1\n    while threads:\n        for thread in threads:\n            thread.join(timeout)\n            if thread.is_alive():\n                logging.warning(\n                    f\"Thread {thread.name} is still alive after {timeout} seconds.\"\n                )\n            else:\n                threads.remove(thread)\n        timeout *= 2\n\n", "CodeBleu_score": 36.528753391940135}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self._remaining_with_setup_started = remaining_with_setup_started\n        self._loop.call_soon(self._loop.create_task, self._dispatch_internal(remaining_with_setup_started))\n\n def _dispatch_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_dispatch_internal\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 50.41948740327422}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._remaining_setups = remaining_with_setup_started\n        self._signal_internal_dispatcher()\n    else:\n        self._remaining_setups = {}\n\n", "CodeBleu_score": 40.457892332503654}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_setups:\n        self._remaining_setups = remaining_with_setup_started\n        self.dispatch_internal(\n            \"_async_dispatch\", remaining_with_setup_started\n        )  # type: ignore[arg-type]\n    else:\n        self._remaining_setups = {}\n\n", "CodeBleu_score": 41.27230104058155}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # get the current content of bluetooth.py\n    current_content = get_current_content(config)\n\n    # generate the content of bluetooth.py based on the provided integrations\n    generated_content = generate_content(integrations, config)\n\n    # if the current content of bluetooth.py is not None, compare it with the generated content\n    if current_content is not None:\n        # if the contents differ, add an error to the configuration indicating that bluetooth.py is not up to date\n        if current_content!= generated_content:\n            config.add_error(\n                \"bluetooth\",\n                \"The content of bluetooth.py is not up to date. Please run 'python3 -m script.hassfest --fix-bluetooth' to update it.\",\n            )\n\n    # store the generated content in the configuration cache\n    config.cache[\"bluetooth\"] = generated_content\n\n", "CodeBleu_score": 38.80471970571315}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    # Initialize the Bluetooth content\n    bluetooth_content = \"\"\n\n    # Iterate over the provided integrations\n    for integration in integrations.values():\n        # Skip integrations that are not Bluetooth-related\n        if not integration.is_bluetooth:\n            continue\n\n        # Generate the Bluetooth content for the current integration\n        integration_bluetooth_content = integration.get_bluetooth_content(config)\n\n        # Append the generated Bluetooth content to the overall Bluetooth content\n        bluetooth_content += integration_bluetooth_content\n\n    # If the Bluetooth content is empty, skip the validation\n    if not bluetooth_content:\n        return\n\n    # Read the current content of bluetooth.py\n    current_bluetooth_content = read_file(config.path(\"bluetooth.py\"))\n\n    # If the current content of bluetooth.py is different from the generated Bluetooth content, add an error to the configuration\n    if current_bluetooth_content!= bluetooth_content:\n        config.error(\n            \"bluetooth.py is not up to date\",\n            f\"The content of bluetooth.py is different from the generated Bluetooth content. Please run 'python3 -m homeassistant.scripts.hassfest_validate --bluetooth'.\",\n            fixable=True,\n        )", "CodeBleu_score": 41.28738163277465}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.is_component_enabled(\"bluetooth\"):\n        return\n\n    # Get the current content of bluetooth.py\n    current_content = get_current_content(config)\n\n    # Generate the content based on the provided integrations\n    generated_content = generate_content(integrations)\n\n    # Compare the current content with the generated content\n    if current_content!= generated_content:\n        # If the contents differ, add an error to the configuration\n        error = ConfigurationError(\n            \"The bluetooth.py file is not up to date. Please run 'python3 -m script.hassfest' to update it.\"\n        )\n        error.fixable = True\n        error.fix_suggestion = \"python3 -m script.hassfest\"\n        config.add_error(error)", "CodeBleu_score": 42.73363314520376}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp, err := resty.New().R().\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetBody(fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s&client_id=%s&client_secret=%s\", d.RefreshToken, d.AppKey, d.AppSecret)).\n\t\tPost(\"https://api.dropboxapi.com/oauth2/token\")\n\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode()!= http.StatusOK {\n\t\tlogger.Error(\"refreshToken\", zap.Any(\"resp\", resp))\n\t\treturn fmt.Errorf(\"refreshToken failed\")\n\t}\n\n\tvar tokenResp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}\n\terr = resp.JSON(&tokenResp)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\td.AccessToken = tokenResp.AccessToken\n\td.TokenType = tokenResp.TokenType\n\td.ExpiresIn = tokenResp.ExpiresIn\n\n\treturn nil\n}", "CodeBleu_score": 47.560717260869176}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp, err := resty.New().R().\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"client_id\":     d.ClientID,\n\t\t\t\"client_secret\": d.ClientSecret,\n\t\t}).\n\t\tPost(\"https://api.dropboxapi.com/oauth2/token\")\n\n\tif err!= nil {\n\t\tlogger.Error(err)\n\t\treturn err\n\t}\n\n\tif resp.StatusCode()!= http.StatusOK {\n\t\tlogger.Error(fmt.Sprintf(\"refresh token failed, response code: %d\", resp.StatusCode()))\n\t\treturn fmt.Errorf(\"refresh token failed, response code: %d\", resp.StatusCode())\n\t}\n\n\tvar tokenResp TokenResponse\n\terr = resp.JSON(&tokenResp)\n\tif err!= nil {\n\t\tlogger.Error(err)\n\t\treturn err\n\t}\n\n\td.AccessToken = tokenResp.AccessToken\n\tlogger.Info(\"refresh token success\", zap.String(\"access_token\", d.AccessToken))\n\treturn nil\n}", "CodeBleu_score": 48.348566276597715}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp, err := resty.New().R().\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetBody(fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s&client_id=%s&client_secret=%s\", d.RefreshToken, d.AppKey, d.AppSecret)).\n\t\tPost(d.TokenURL)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif resp.StatusCode()!= http.StatusOK {\n\t\tlogger.Error(\"refreshToken\", zap.Int(\"code\", resp.StatusCode()), zap.String(\"body\", resp.String()))\n\t\treturn fmt.Errorf(\"refreshToken: %d\", resp.StatusCode())\n\t}\n\ttoken := &base.Token{}\n\tif err := resp.JSON(token); err!= nil {\n\t\treturn err\n\t}\n\td.AccessToken = token.AccessToken\n\treturn nil\n}", "CodeBleu_score": 49.88226515859252}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tif callback == nil {\n\t\tcallback = func(req *resty.Request) {\n\t\t\treq.SetHeader(\"Authorization\", \"Bearer \"+d.token)\n\t\t\treq.SetHeader(\"X-Goog-Drive-Resource-Keys\", \"true\")\n\t\t}\n\t}\n\n\tvar body []byte\n\tvar err error\n\n\tretry := func() {\n\t\tbody, err = utils.Request(url, method, callback, resp)\n\t}\n\n\tretry()\n\n\tif err!= nil {\n\t\tif err.Error() == \"401\" {\n\t\t\tlog.Debug(\"401\")\n\t\t\tif d.RefreshToken() {\n\t\t\t\tretry()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn body, err\n}", "CodeBleu_score": 34.14273738391667}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tlog.Debug(\"request\", zap.String(\"url\", url), zap.String(\"method\", method))\n\t// Create a new HTTP client\n\tclient := resty.New()\n\t// Set the authorization header with the access token\n\tclient.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\t// Set the request method\n\tclient.SetMethod(method)\n\t// Set the request URL\n\tclient.SetHostURL(url)\n\t// Set the request parameters for supporting all drives\n\tclient.SetQueryParam(\"supportsAllDrives\", \"true\")\n\tclient.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\tclient.SetQueryParam(\"corpora\", \"allDrives\")\n\t// Set the request parameters for supporting Team Drives\n\tclient.SetQueryParam(\"includeTeamDriveItems\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"supportsTeamDrives\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"supportsTeamDrives\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"includeTeamDriveItems\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"supportsAllDrives\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"corpora\", \"allDrives\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"includeTeamDriveItems\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"supportsTeamDrives\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"supportsAllDrives\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"corpora\", \"allDrives\")\n\t// Set the request parameters for supporting shared drives\n\tclient.SetQueryParam(\"includeTeamDriveItems\", \"true\")\n\t// Set the request parameters for supporting shared drives\n\tclient", "CodeBleu_score": 23.21210411732732}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tclient := resty.New()\n\tif callback!= nil {\n\t\tcallback(client)\n\t}\n\treq := client.R().SetHeader(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\tif method == \"GET\" {\n\t\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\t\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\t}\n\treq.SetHeader(\"Content-Type\", \"application/json\")\n\treq.SetHeader(\"X-Goog-Drive-Resource-Keys\", \"true\")\n\tresp, err := req.Execute(method, url)\n\tif err!= nil {\n\t\tlog.Error(err)\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode() == 401 {\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\tif resp.StatusCode()!= 200 {\n\t\treturn nil, fmt.Errorf(\"request failed, status code: %d\", resp.StatusCode())\n\t}\n\tif resp!= nil {\n\t\tif err := resp.Error(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := resp.Unmarshal(resp); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn resp.Body(), nil\n}", "CodeBleu_score": 60.958488722349855}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Get the file size\n\tfileSize := stream.Size()\n\t// Calculate the chunk size based on the file size\n\tchunkSize := utils.CalculateChunkSize(fileSize)\n\t// Create a new HTTP client\n\tclient := resty.New()\n\t// Create a new context\n\tchunkCtx, cancel := context.WithCancel(ctx)\n\tdefer cancel()\n\t// Loop through the file in chunks\n\tfor {\n\t\t// Check if the context is canceled\n\t\tselect {\n\t\tcase <-chunkCtx.Done():\n\t\t\treturn chunkCtx.Err()\n\t\tdefault:\n\t\t}\n\t\t// Read the next chunk of data from the file\n\t\tchunk, err := stream.Read(chunkSize)\n\t\tif err!= nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\t// Create a new HTTP request\n\t\treq := client.R().\n\t\t\tSetContext(chunkCtx).\n\t\t\tSetBody(chunk).\n\t\t\tSetHeader(\"Content-Type\", \"application/octet-stream\").\n\t\t\tSetHeader(\"Content-Length\", strconv.Itoa(len(chunk))).\n\t\t\tSetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", stream.Offset(), stream.Offset()+len(chunk)-1, fileSize)).\n\t\t\tSetHeader(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\t\t// Send the HTTP request and get the response\n\t\tresp, err := req.Put(url)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// Check the HTTP status code\n\t\tswitch resp.StatusCode() {\n\t\tcase http.StatusOK:\n\t\t\treturn nil\n\t\tcase http.StatusCreated:\n\t\t\treturn nil\n\t\tcase http.StatusPartialContent:\n\t\t\t// Continue uploading the next chunk\n\t\t\tcontinue\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode())\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 33.65482456711407}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Get the file size\n\tsize, err := stream.Size()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Calculate the chunk size\n\tchunkSize := int64(d.chunkSize)\n\tif size < chunkSize {\n\t\tchunkSize = size\n\t}\n\n\t// Create a buffer for the chunk\n\tbuf := make([]byte, chunkSize)\n\n\t// Create a new request for the upload\n\treq := d.client.R().\n\t\tSetContext(ctx).\n\t\tSetHeader(\"Content-Type\", \"application/octet-stream\").\n\t\tSetBody(buf)\n\n\t// Loop through the file in chunks\n\tfor {\n\t\t// Read the chunk from the file\n\t\tn, err := stream.Read(buf)\n\t\tif err!= nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the chunk size\n\t\treq.SetContentLength(int64(n))\n\n\t\t// Send the chunk\n\t\tresp, err := req.Post(url)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check for context cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Check for an error in the response\n\t\tif resp.StatusCode()!= http.StatusOK {\n\t\t\treturn fmt.Errorf(\"error uploading chunk: %s\", resp.Status())\n\t\t}\n\n\t\t// Check if the file is fully uploaded\n\t\tif int64(n) < chunkSize {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.77413436616808}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Get the file size\n\tfileSize, err := stream.Size()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Calculate the chunk size based on the file size\n\tchunkSize := int64(1024 * 1024) // 1 MB\n\tif fileSize < chunkSize {\n\t\tchunkSize = fileSize\n\t}\n\n\t// Create a buffer to store the file contents\n\tbuf := make([]byte, chunkSize)\n\n\t// Initialize the offset and total bytes uploaded\n\toffset := int64(0)\n\ttotalUploaded := int64(0)\n\n\t// Loop until the entire file is uploaded\n\tfor {\n\t\t// Read a chunk from the file\n\t\tn, err := stream.Read(buf)\n\t\tif err!= nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// Check if the context is cancelled\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Upload the chunk to Google Drive\n\t\tresp, err := d.uploadChunk(ctx, buf[:n], url, offset)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Update the offset and total bytes uploaded\n\t\toffset += int64(n)\n\t\ttotalUploaded += int64(n)\n\n\t\t// Check if the entire file is uploaded\n\t\tif totalUploaded == fileSize {\n\t\t\tbreak\n\t\t}\n\n\t\t// Get the next upload URL from the response\n\t\turl = resp.Header.Get(\"Location\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 42.33114834625897}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn httper.Wrap(ctx, err, \"failed to bind request body\")\n\t}\n\n\tif req.MountPoint == \"\" {\n\t\treturn httper.Wrap(ctx, common_err.ErrClient, \"mount point is empty\")\n\t}\n\n\tif err := service.StorageService.Umount(req.MountPoint); err!= nil {\n\t\treturn httper.Wrap(ctx, err, \"failed to umount storage\")\n\t}\n\n\tif err := service.StorageService.DeleteConfig(req.MountPoint); err!= nil {\n\t\treturn httper.Wrap(ctx, err, \"failed to delete storage config\")\n\t}\n\n\treturn ctx.JSON(200, nil)\n}", "CodeBleu_score": 38.63513562311949}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn httper.BadRequest(ctx, err)\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn httper.ClientError(ctx, common_err.ErrInvalidParam)\n\t}\n\tif err := service.StorageService.Umount(req.MountPoint); err!= nil {\n\t\treturn httper.ServiceError(ctx, err)\n\t}\n\tif err := service.StorageService.DeleteConfig(req.MountPoint); err!= nil {\n\t\treturn httper.ServiceError(ctx, err)\n\t}\n\treturn httper.Success(ctx)\n}", "CodeBleu_score": 31.900565974164678}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tmountPoint := ctx.FormValue(\"mount_point\")\n\tif mountPoint == \"\" {\n\t\treturn httper.NewClientError(ctx, \"mount point is empty\")\n\t}\n\tif err := service.UmountStorage(mountPoint); err!= nil {\n\t\treturn httper.NewServiceError(ctx, err)\n\t}\n\tif err := service.DeleteStorageConfig(mountPoint); err!= nil {\n\t\treturn httper.NewServiceError(ctx, err)\n\t}\n\treturn ctx.JSON(200, map[string]string{\"message\": \"success\"})\n}", "CodeBleu_score": 32.28575173789984}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Response{\n\t\t\tCode:    common_err.ErrParam,\n\t\t\tMessage: \"param error\",\n\t\t})\n\t}\n\tif!file.IsExist(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Response{\n\t\t\tCode:    common_err.ErrParam,\n\t\t\tMessage: \"file not exist\",\n\t\t})\n\t}\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 48.883724459326835}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Response{\n\t\t\tCode:    -1,\n\t\t\tMessage: \"\u7f3a\u5c11\u6587\u4ef6\u8def\u5f84\",\n\t\t})\n\t}\n\tif!file.IsExist(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Response{\n\t\t\tCode:    -1,\n\t\t\tMessage: \"\u6587\u4ef6\u4e0d\u5b58\u5728\",\n\t\t})\n\t}\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 43.41352657292807}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrRequestParams)\n\t}\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrFileNotFound)\n\t}\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 33.301580969835776}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.New(err.Error()))\n\t}\n\tif err := service.NotifyMessage(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.New(err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, model.NewResponse(true, \"success\", nil))\n}", "CodeBleu_score": 56.79331990375695}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequestError(err))\n\t}\n\tif err := service.NotifyMessage(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, model.NewSuccessResponse(nil))\n}", "CodeBleu_score": 60.81261005659179}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequestError(err.Error()))\n\t}\n\tif err := service.NotifyMessage(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, model.NewSuccessResponse(\"success\"))\n}", "CodeBleu_score": 56.687396590385084}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\tservice.AddNotifyConn(ws)\n\tservice.StartNotify()\n\tfor {\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"Received message: %s\n\", msg)\n\t\tif err := ws.WriteMessage(msgType, msg); err!= nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tservice.RemoveNotifyConn(ws)\n\treturn nil\n}", "CodeBleu_score": 39.39519707370195}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the WebSocket connection to the list of connections\n\tservice.AddConnection(ws)\n\tdefer service.RemoveConnection(ws)\n\n\t// Start the message sending service if it is not already running\n\tservice.Start()\n\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the message type and message from the WebSocket connection\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Printf(\"Message type: %d\n\", mt)\n\t\tfmt.Printf(\"Message: %s\n\", message)\n\t\tfmt.Printf(\"Error: %v\n\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.8009047349016}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections.\n\tservice.Notify.Add(ws)\n\t// Ensure that the message sending service is running.\n\tservice.Notify.Start()\n\t// Enter a loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read a message from the WebSocket connection.\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\t// If an error occurs while reading the message, print the error and break out of the loop.\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Printf(\"msg: %s\n\", msg)\n\t}\n\t// Close the WebSocket connection.\n\tws.Close()\n\treturn nil\n}", "CodeBleu_score": 37.51806230590665}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar drive = utils.GetDriveModel()\n\tvar arch = runtime.GOARCH\n\tvar cpu = utils.GetCPUInfo()\n\n\tif cpu == nil {\n\t\treturn ctx.JSON(http.StatusOK, model.Response{\n\t\t\tCode:    http.StatusOK,\n\t\t\tMessage: \"success\",\n\t\t\tData: map[string]interface{}{\n\t\t\t\t\"drive\": drive,\n\t\t\t\t\"arch\":  arch,\n\t\t\t},\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, model.Response{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"success\",\n\t\tData: map[string]interface{}{\n\t\t\t\"drive\": drive,\n\t\t\t\"arch\":  arch,\n\t\t\t\"cpu\":   cpu,\n\t\t},\n\t})\n}", "CodeBleu_score": 33.66774761261888}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdrive, err := utils.GetDriveModel()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, model.Response{\n\t\t\tCode:    common_err.InternalServerError,\n\t\t\tMessage: common_err.E(common_err.InternalServerError).Error(),\n\t\t\tError:   err.Error(),\n\t\t})\n\t}\n\n\tarch := runtime.GOARCH\n\tcpuInfo, err := utils.GetCPUInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, model.Response{\n\t\t\tCode:    common_err.InternalServerError,\n\t\t\tMessage: common_err.E(common_err.InternalServerError).Error(),\n\t\t\tError:   err.Error(),\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, model.Response{\n\t\tCode:    common_err.Success,\n\t\tMessage: common_err.E(common_err.Success).Error(),\n\t\tData: map[string]interface{}{\n\t\t\t\"drive\":  drive,\n\t\t\t\"arch\":   arch,\n\t\t\t\"cpu\":    cpuInfo,\n\t\t\t\"system\": runtime.GOOS,\n\t\t},\n\t})\n}", "CodeBleu_score": 26.913875037345502}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdrive := utils.GetDriveModel()\n\tarch := runtime.GOARCH\n\tcpu := utils.GetCPUInfo()\n\tif cpu!= nil {\n\t\treturn ctx.JSON(http.StatusOK, types.Result{\n\t\t\tCode: 0,\n\t\t\tData: map[string]interface{}{\n\t\t\t\t\"drive\": drive,\n\t\t\t\t\"arch\":  arch,\n\t\t\t\t\"cpu\":   cpu,\n\t\t\t},\n\t\t})\n\t}\n\treturn ctx.JSON(http.StatusOK, types.Result{\n\t\tCode: 0,\n\t\tData: map[string]interface{}{\n\t\t\t\"drive\": drive,\n\t\t\t\"arch\":  arch,\n\t\t},\n\t})\n}", "CodeBleu_score": 25.37448571239861}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := &[]string{}\n\tnotRunning := &[]string{}\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\t*running = append(*running, service.Name)\n\t\t} else {\n\t\t\t*notRunning = append(*notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  running,\n\t\tfalse: notRunning,\n\t}, nil\n}", "CodeBleu_score": 61.14027143040215}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 73.40124916877771}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 73.92205929156628}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tif name == \"\" {\n\t\treturn\n\t}\n\tif i.bus == nil {\n\t\treturn\n\t}\n\tif i.bus.Publish(name, message)!= nil {\n\t\treturn\n\t}\n\ti.log.Info(\"SendNotify\", zap.String(\"name\", name), zap.Any(\"message\", message))\n}", "CodeBleu_score": 17.028482655505112}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessage[\"name\"] = name\n\tmessage[\"time\"] = time.Now().Format(\"2006-01-02 15:04:05\")\n\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Sugar.Error(err)\n\t\treturn\n\t}\n\terr = i.messageBus.Publish(name, string(jsonMessage))\n\tif err!= nil {\n\t\tlogger.Sugar.Error(err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 31.010044612107183}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings\n\tmessageJSON, err := json2.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to serialize message values to JSON\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to a message bus\n\terr = i.bus.Publish(name, messageJSON)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event to message bus\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Log any errors that occur during publishing\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event to message bus\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// If the response status code is not OK, log the failure along with the response details\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event to message bus\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 39.82226500695059}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\n\t\tc.config.RuntimePath,\n\t\tc.config.Address,\n\t\tc.config.Port,\n\t\tc.config.Token,\n\t)\n\n\treturn client\n}", "CodeBleu_score": 16.92904406837118}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tmessageBusClient := message_bus.NewClientWithResponses()\n\tmessageBusClient.SetHost(config.GetRuntimePath())\n\tmessageBusClient.SetBasePath(\"/message_bus\")\n\tmessageBusClient.SetScheme(\"http\")\n\treturn messageBusClient\n}", "CodeBleu_score": 21.432888051849154}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\tclient.SetServer(external.GetMessageBusAddress(c.RuntimePath))\n\treturn client\n}", "CodeBleu_score": 13.686693126207134}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \"::ffff:\") {\n\t\tip = strings.Split(ip, \"::ffff:\")[1]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 60.181827958442334}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = strings.TrimPrefix(ip, \"::ffff:\")\n\t}\n\tif strings.HasPrefix(ip, \"127.0.0.1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 54.133124783583355}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif strings.Contains(ip, \",\") {\n\t\tip = strings.Split(ip, \",\")[0]\n\t}\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 66.88825955709339}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// \u5b9a\u4e49\u6a21\u5757\u76ee\u5f55\u548c\u5165\u53e3\u6587\u4ef6\u8def\u5f84\n\tmodulesDir := filepath.Join(config.GetModulesDir(), \"system\")\n\tentryFile := filepath.Join(modulesDir, \"entry.json\")\n\n\t// \u786e\u4fdd\u5165\u53e3\u6587\u4ef6\u5b58\u5728\n\tif err := file.EnsureFile(entryFile); err!= nil {\n\t\tlogger.Error(\"failed to ensure entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// \u8bfb\u53d6\u6a21\u5757\u76ee\u5f55\u4e2d\u7684\u6240\u6709\u76ee\u5f55\n\tdirs, err := os.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tlogger.Error(\"failed to read modules dir\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// \u5b9a\u4e49\u5165\u53e3\u6587\u4ef6\u5185\u5bb9\u7684\u6570\u7ec4\n\tvar entries []map[string]interface{}\n\n\t// \u904d\u5386\u6a21\u5757\u76ee\u5f55\u4e2d\u7684\u6240\u6709\u76ee\u5f55\n\tfor _, dir := range dirs {\n\t\t// \u8df3\u8fc7\u975e\u76ee\u5f55\n\t\tif!dir.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// \u8bfb\u53d6\u6a21\u5757\u76ee\u5f55\u4e2d\u7684entry.json\u6587\u4ef6\n\t\tentryPath := filepath.Join(modulesDir, dir.Name(), \"entry.json\")\n\t\tentryBytes, err := os.ReadFile(entryPath)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"failed to read entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// \u5c06entry.json\u6587\u4ef6\u5185\u5bb9\u89e3\u6790\u4e3amap\n\t\tvar entry map[string]interface{}\n\t\tif err := json.Unmarshal(entryBytes, &entry); err!= nil {\n\t\t\tlogger.Error(\"failed to unmarshal entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// \u5c06\u89e3\u6790\u540e\u7684entry.json\u6587\u4ef6\u5185\u5bb9\u6dfb\u52a0\u5230\u6570\u7ec4\u4e2d\n\t\tentries = append(entries, entry)\n\t}\n\n\t// \u5c06\u6570\u7ec4\u8f6c\u6362\u4e3aJSON\u5b57\u7b26\u4e32\n\tentryJSON, err := json.Marshal(entries)\n\tif err!= nil {\n\t\tlogger.Error(\"failed to marshal entries\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// \u5c06JSON\u5b57\u7b26\u4e32\u5199\u5165\u5165\u53e3\u6587\u4ef6\n\tif err := os.WriteFile(entryFile, entryJSON, 0644); err!= nil {\n\t\tlogger.Error(\"failed to write entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 40.12922082773485}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmoduleDir := filepath.Join(config.Get().Module.ModuleDir)\n\tentryFile := filepath.Join(moduleDir, \"entry.json\")\n\tif!file.IsExist(moduleDir) {\n\t\tfile.CreateDir(moduleDir)\n\t}\n\tif!file.IsExist(entryFile) {\n\t\tfile.CreateFile(entryFile)\n\t}\n\tdirs, err := file.GetDirList(moduleDir)\n\tif err!= nil {\n\t\tlogger.Sugar.Error(\"\u83b7\u53d6\u6a21\u5757\u76ee\u5f55\u5217\u8868\u5931\u8d25\", err)\n\t\treturn\n\t}\n\tvar entries []model.Entry\n\tfor _, dir := range dirs {\n\t\tentryPath := filepath.Join(moduleDir, dir, \"entry.json\")\n\t\tif!file.IsExist(entryPath) {\n\t\t\tcontinue\n\t\t}\n\t\tentry, err := c.readEntry(entryPath)\n\t\tif err!= nil {\n\t\t\tlogger.Sugar.Error(\"\u8bfb\u53d6\u6a21\u5757\u5165\u53e3\u6587\u4ef6\u5931\u8d25\", err)\n\t\t\tcontinue\n\t\t}\n\t\tentries = append(entries, entry)\n\t}\n\tif len(entries) == 0 {\n\t\treturn\n\t}\n\tentryBytes, err := json.Marshal(entries)\n\tif err!= nil {\n\t\tlogger.Sugar.Error(\"\u5e8f\u5217\u5316\u6a21\u5757\u5165\u53e3\u6587\u4ef6\u5931\u8d25\", err)\n\t\treturn\n\t}\n\terr = file.Write(entryFile, entryBytes)\n\tif err!= nil {\n\t\tlogger.Sugar.Error(\"\u5199\u5165\u6a21\u5757\u5165\u53e3\u6587\u4ef6\u5931\u8d25\", err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 42.90215742737622}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// \u5b9a\u4e49\u6a21\u5757\u76ee\u5f55\u8def\u5f84\u548c\u5165\u53e3\u6587\u4ef6\u8def\u5f84\n\tmodulesDir := filepath.Join(config.GetConfig().System.ModulesDir, \"system\")\n\tentryFile := filepath.Join(modulesDir, \"entry.json\")\n\n\t// \u786e\u4fdd\u5165\u53e3\u6587\u4ef6\u5b58\u5728\n\tif!file.IsExist(entryFile) {\n\t\tif err := file.CreateFile(entryFile); err!= nil {\n\t\t\tlogger.Sugar().Errorw(\"create file error\", \"error\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// \u8bfb\u53d6\u6a21\u5757\u76ee\u5f55\u4e2d\u7684 entry.json \u6587\u4ef6\n\tfiles, err := file.GetFiles(modulesDir, \"entry.json\")\n\tif err!= nil {\n\t\tlogger.Sugar().Errorw(\"get files error\", \"error\", err)\n\t\treturn\n\t}\n\n\t// \u8bfb\u53d6\u6bcf\u4e2a entry.json \u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u5e76\u5c06\u5176\u5185\u5bb9\u5408\u5e76\u4e3a\u4e00\u4e2a JSON \u6570\u7ec4\n\tvar entries []string\n\tfor _, f := range files {\n\t\tcontent, err := file.ReadFile(f)\n\t\tif err!= nil {\n\t\t\tlogger.Sugar().Errorw(\"read file error\", \"error\", err)\n\t\t\tcontinue\n\t\t}\n\t\tentries = append(entries, string(content))\n\t}\n\n\t// \u5c06\u5408\u5e76\u540e\u7684 JSON \u6570\u7ec4\u5199\u5165\u5230 entry.json \u6587\u4ef6\u4e2d\n\tif err := file.WriteFile(entryFile, []byte(fmt.Sprintf(\"[%s]\", strings.Join(entries, \",\")))); err!= nil {\n\t\tlogger.Sugar().Errorw(\"write file error\", \"error\", err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 37.590946130313526}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get a list of network interfaces\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names from the system service\n\tnetworkNames, err := net.InterfaceNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no matching interface is found, return an error\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 63.11795803557183}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// \u83b7\u53d6\u7f51\u5361\u5217\u8868\n\tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\t// \u83b7\u53d6\u7f51\u7edc\u540d\u79f0\u5217\u8868\n\tnetNames, err := net.NetInterfaceNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\t// \u904d\u5386\u7f51\u5361\u5217\u8868\u548c\u7f51\u7edc\u540d\u79f0\u5217\u8868\uff0c\u67e5\u627e\u5339\u914d\u7684\u7f51\u5361\n\tfor _, iface := range ifaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\t// \u5982\u679c\u6ca1\u6709\u627e\u5230\u5339\u914d\u7684\u7f51\u5361\uff0c\u8fd4\u56de\u9519\u8bef\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 56.663296867527976}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := net.NetNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 63.32597499165532}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t iError = 0;\n\n\tif (pRequest == NULL) {\n\t\tiError = TPS_ERROR_INTERNAL;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Add a reference to the request object.\n\t */\n\taddRef(pRequest);\n\n\t/*\n\t * Increment the request count for the TSC object.\n\t */\n\tpTscObj->iRequestCount++;\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary, including total and current request counts.\n\t */\n\tif (pTscObj->pApplication!= NULL) {\n\t\tpTscObj->pApplication->iRequestCount++;\n\t\tpTscObj->pApplication->iCurrentRequestCount++;\n\t}\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tclientLog(LOG_DEBUG, \"Registered request %p for TSC object %p.\", pRequest, pTscObj);\n\ncleanup:\n\n\treturn iError;\n}", "CodeBleu_score": 27.579716013291666}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t iRet = 0;\n\tSTscObj *pAppTscObj = NULL;\n\tSTscObj *pAppTscObj2 = NULL;\n\tSTscObj *pAppTscObj3 = NULL;\n\tSAppObj *pAppObj = NULL;\n\tSAppObj *pAppObj2 = NULL;\n\tSAppObj *pAppObj3 = NULL;\n\tSRequestObj *pRequest2 = NULL;\n\tSRequestObj *pRequest3 = NULL;\n\tSRequestObj *pRequest4 = NULL;\n\tSRequestObj *pRequest5 = NULL;\n\tSRequestObj *pRequest6 = NULL;\n\tSRequestObj *pRequest7 = NULL;\n\tSRequestObj *pRequest8 = NULL;\n\tSRequestObj *pRequest9 = NULL;\n\tSRequestObj *pRequest10 = NULL;\n\tSRequestObj *pRequest11 = NULL;\n\tSRequestObj *pRequest12 = NULL;\n\tSRequestObj *pRequest13 = NULL;\n\tSRequestObj *pRequest14 = NULL;\n\tSRequestObj *pRequest15 = NULL;\n\tSRequestObj *pRequest16 = NULL;\n\tSRequestObj *pRequest17 = NULL;\n\tSRequestObj *pRequest18 = NULL;\n\tSRequestObj *pRequest19 = NULL;\n\tSRequestObj *pRequest20 = NULL;\n\tSRequestObj *pRequest21 = NULL;\n\tSRequestObj *pRequest22 = NULL;\n\tSRequestObj *pRequest23 = NULL;\n\tSRequestObj *pRequest24 = NULL;\n\tSRequestObj *pRequest25 = NULL;\n\tSRequestObj *pRequest26 = NULL;\n\tSRequestObj *pRequest27 = NULL;\n\tSRequestObj *pRequest28 = NULL;\n\tSRequestObj *pRequest29 = NULL;\n\tSRequestObj *pRequest30 = NULL;\n\tSRequestObj *pRequest31 = NULL;\n\tSRequestObj *pRequest32 = NULL;\n\tSRequestObj *pRequest33 = NULL;\n\tSRequestObj *pRequest34", "CodeBleu_score": 6.037032400834742}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tSTscAppObj *pAppObj = pTscObj->pAppObj;\n\tSTscAppObj *pAppObj2;\n\tint32_t iRet;\n\n\tif (pRequest == NULL) {\n\t\treturn ER_bad_arg;\n\t}\n\n\tif (pTscObj == NULL) {\n\t\treturn ER_bad_arg;\n\t}\n\n\tif (pTscObj->pRequestObj!= NULL) {\n\t\treturn ER_bad_arg;\n\t}\n\n\tif (pAppObj!= NULL) {\n\t\tpAppObj2 = (STscAppObj *) trefGetRef(pAppObj->pRef);\n\t\tif (pAppObj2!= NULL) {\n\t\t\tpAppObj = pAppObj2;\n\t\t\tpAppObj->iRequestCount++;\n\t\t\tpAppObj->iCurrentRequestCount++;\n\t\t\tpAppObj->iTotalRequestCount++;\n\t\t\tpAppObj->iTotalRequestCount2++;\n\t\t\tpAppObj->iTotalRequestCount3++;\n\t\t\ttrefPutRef(pAppObj->pRef);\n\t\t}\n\t}\n\n\tpRequest->pTscObj = pTscObj;\n\tpTscObj->pRequestObj = pRequest;\n\n\tpRequest->iRefCount++;\n\n\tlogDebug(\"debug_client\", \"registerRequest: pTscObj->pRequestObj = %p\", pTscObj->pRequestObj);\n\n\treturn ER_OK;\n}", "CodeBleu_score": 41.53092737095496}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest == NULL || exceptDb == NULL) {\n\t\treturn false;\n\t}\n\tif (strcmp(pRequest->pPrimaryDb, exceptDb)!= 0) {\n\t\tint i;\n\t\tfor (i = 0; i < pRequest->numDb; i++) {\n\t\t\tchar *pDb = pRequest->pDbList[i];\n\t\t\tif (pDb == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pDb[0] == '\"') {\n\t\t\t\tpDb++;\n\t\t\t}\n\t\t\tif (strcmp(pDb, exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 51.73499234098322}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar* dbName = pRequest->pPrimaryDb->name;\n\tif (dbName!= NULL && strcmp(dbName, exceptDb)!= 0) {\n\t\tSList *pList = pRequest->pDbList;\n\t\twhile (pList!= NULL) {\n\t\t\tchar *pDb = pList->data;\n\t\t\tif (pDb!= NULL) {\n\t\t\t\tif (pDb[0] == SCHEMA_PREFIX) {\n\t\t\t\t\tpDb++;\n\t\t\t\t}\n\t\t\t\tif (strcmp(pDb, exceptDb) == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpList = pList->next;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.30126389233982}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tSRequestDbObj *pDb;\n\tchar *pDbName;\n\tint i;\n\n\tif (pRequest->pPrimaryDb) {\n\t\tpDbName = pRequest->pPrimaryDb->name;\n\t\tif (pDbName) {\n\t\t\tif (strcmp(pDbName, exceptDb)!= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < pRequest->dbCnt; i++) {\n\t\tpDb = pRequest->ppDb[i];\n\t\tpDbName = pDb->name;\n\t\tif (pDbName) {\n\t\t\tif (strcmp(pDbName, exceptDb)!= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 40.70065873022982}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == T_ERROR_REDIRECT) {\n\t\tif (msgType!= T_MSG_TYPE_QUERY && msgType!= T_MSG_TYPE_QUERY_CANCEL && msgType!= T_MSG_TYPE_QUERY_STATUS && msgType!= T_MSG_TYPE_QUERY_RESULT) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 46.1472882572447}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool rfp;\n\n\trfp = false;\n\n\tif (code == 1000) {\n\t\tswitch (msgType) {\n\t\tcase TMSG_QUERY_REQUEST:\n\t\tcase TMSG_QUERY_CANCEL:\n\t\tcase TMSG_QUERY_RESULT:\n\t\tcase TMSG_QUERY_STATUS:\n\t\tcase TMSG_QUERY_STATISTICS:\n\t\t\trfp = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trfp = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rfp;\n}", "CodeBleu_score": 28.10050908258026}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == 200) {\n\t\treturn false;\n\t}\n\tif (code == 400) {\n\t\tif (msgType == TMSG_SQL_EXECUTE_REQUEST || msgType == TMSG_SQL_EXECUTE_REQUEST_BATCH || msgType == TMSG_SQL_EXECUTE_REQUEST_PREPARED || msgType == TMSG_SQL_EXECUTE_REQUEST_PREPARED_BATCH || msgType == TMSG_SQL_EXECUTE_REQUEST_PREPARED_BATCH_PARALLEL || msgType == TMSG_SQL_EXECUTE_REQUEST_PREPARED_PARALLEL) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 58.68377258134003}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashObj *pRequest;\n\tSRequest *pReq;\n\tSQuery *pQuery;\n\tSRequest *pReqNext;\n\n\t/* Acquire the request. */\n\tpRequest = pRequests->pFirst;\n\twhile (pRequest!= NULL) {\n\t\tpReq = (SRequest *)pRequest->pData;\n\n\t\t/* Acquire the next request before stopping the current request. */\n\t\tpReqNext = (SRequest *)pRequest->pNext->pData;\n\n\t\t/* Stop the query. */\n\t\tpQuery = pReq->pQuery;\n\t\tif (pQuery!= NULL) {\n\t\t\tstopQuery(pQuery);\n\t\t}\n\n\t\t/* Release the request. */\n\t\treleaseRequest(pReq);\n\n\t\t/* Move to the next request. */\n\t\tpRequest = pRequest->pNext;\n\t\tpRequest = pReqNext;\n\t}\n}", "CodeBleu_score": 40.54809601851649}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i;\n\tSHashObj *pRequest;\n\tSRequest *pReq;\n\tSQuery *pQuery;\n\n\tfor (i = 0; i < pRequests->iSize; i++) {\n\t\tpRequest = pRequests->ppObj[i];\n\n\t\twhile (pRequest!= NULL) {\n\t\t\tpReq = (SRequest *)pRequest->pData;\n\n\t\t\tif (pReq!= NULL) {\n\t\t\t\tpQuery = pReq->pQuery;\n\n\t\t\t\tif (pQuery!= NULL) {\n\t\t\t\t\tif (pQuery->pWorker!= NULL) {\n\t\t\t\t\t\tpQuery->pWorker->bStop = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pQuery->pHttp!= NULL) {\n\t\t\t\t\t\tpQuery->pHttp->bStop = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pQuery->pRpc!= NULL) {\n\t\t\t\t\t\tpQuery->pRpc->bStop = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pQuery->pSched!= NULL) {\n\t\t\t\t\t\tpQuery->pSched->bStop = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treleaseRequest(pReq);\n\t\t\t}\n\n\t\t\tpRequest = pRequest->pNext;\n\t\t}\n\t}\n}", "CodeBleu_score": 34.88006209743587}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSRequest *pRequest;\n\tSQuery *pQuery;\n\n\t// acquire request\n\tpRequest = tCacheAcquire(pRequests, pRequests->pHash->pFirst);\n\n\t// stop all queries\n\twhile (pRequest!= NULL) {\n\t\t// acquire query\n\t\tpQuery = pRequest->pQuery;\n\n\t\t// stop query\n\t\tif (pQuery!= NULL) {\n\t\t\tqueryStop(pQuery);\n\t\t}\n\n\t\t// release request\n\t\ttCacheRelease(pRequests, pRequest);\n\n\t\t// acquire next request\n\t\tpRequest = tCacheAcquire(pRequests, pRequest->pHash->pNext);\n\t}\n}", "CodeBleu_score": 41.885973301154294}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (tglobal.crashReportEnabled == 0) {\n\t\treturn;\n\t}\n\tif (tscCrashReportThread == NULL) {\n\t\treturn;\n\t}\n\ttscCrashReportThread->clientStop = 1;\n\twhile (tscCrashReportThread->clientStop!= 0) {\n\t\tosSleep(100);\n\t}\n}", "CodeBleu_score": 46.19452366216131}, {"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportEnabled == 0) {\n\t\treturn;\n\t}\n\tif (tscCrashReportThread == NULL) {\n\t\treturn;\n\t}\n\tif (tscCrashReportThread->clientStop == 1) {\n\t\treturn;\n\t}\n\ttscCrashReportThread->clientStop = 1;\n\twhile (tscCrashReportThread->clientStop == 1) {\n\t\tosSleep(100);\n\t}\n}", "CodeBleu_score": 45.84689114471747}, {"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportEnabled == 0) {\n\t\treturn;\n\t}\n\tif (tscCrashReportThread!= NULL) {\n\t\ttscCrashReportThread->clientStop = 1;\n\t\twhile (tscCrashReportThread->clientStop!= 0) {\n\t\t\tosSleep(1);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.23895159569964}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t i;\n\tint32_t rc;\n\tint32_t viewCount;\n\tint32_t viewId;\n\tint32_t viewColumnCount;\n\tint32_t viewColumnId;\n\tint32_t viewColumnIndex;\n\tint32_t viewColumnDataType;\n\tint32_t viewColumnDataLength;\n\tint32_t viewColumnDataScale;\n\tint32_t viewColumnDataPrecision;\n\tint32_t viewColumnDataFlags;\n\tint32_t viewColumnDataFlags2;\n\tchar *viewName;\n\tchar *viewOwner;\n\tchar *viewComment;\n\tchar *viewColumnNames;\n\tchar *viewColumnTypes;\n\tchar *viewColumnLengths;\n\tchar *viewColumnScales;\n\tchar *viewColumnPrecisions;\n\tchar *viewColumnFlags;\n\tchar *viewColumnFlags2;\n\tchar *viewColumnComments;\n\tchar *viewColumnDefaultValues;\n\tchar *viewColumnDefaultValuesNullFlags;\n\tchar *viewColumnDefaultValuesNullFlags2;\n\tchar *viewColumnDefaultValuesNullFlags3;\n\tchar *viewColumnDefaultValuesNullFlags4;\n\tchar *viewColumnDefaultValuesNullFlags5;\n\tchar *viewColumnDefaultValuesNullFlags6;\n\tchar *viewColumnDefaultValuesNullFlags7;\n\tchar *viewColumnDefaultValuesNullFlags8;\n\tchar *viewColumnDefaultValuesNullFlags9;\n\tchar *viewColumnDefaultValuesNullFlags10;\n\tchar *viewColumnDefaultValuesNullFlags11;\n\tchar *viewColumnDefaultValuesNullFlags12;\n\tchar *viewColumnDefaultValuesNullFlags13;\n\tchar *viewColumnDefaultValuesNullFlags14;\n\tchar *viewColumnDefaultValuesNullFlags15;\n\tchar *viewColumnDefaultValuesNullFlags16;\n\tchar *viewColumnDefaultValuesNullFlags17;\n\tchar *viewColumnDefaultValuesNullFlags18;\n\tchar *viewColumnDefaultValuesNullFlags19;\n\tchar *viewColumnDefaultValuesNullFlags20;\n\tchar *viewColumnDefaultValuesNullFlags21;\n\tchar *viewColumnDefaultValuesNullFlags", "CodeBleu_score": 6.256044390525625}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t err;\n\tint32_t i;\n\tint32_t j;\n\tint32_t k;\n\tint32_t viewCount;\n\tint32_t columnCount;\n\tint32_t columnCountNew;\n\tint32_t columnCountOld;\n\tint32_t columnCountDiff;\n\tint32_t columnCountDiffAbs;\n\tint32_t columnCountDiffSign;\n\tint32_t columnCountDiffSignAbs;\n\tint32_t columnCountDiffSignAbsOld;\n\tint32_t columnCountDiffSignAbsNew;\n\tint32_t columnCountDiffSignAbsDiff;\n\tint32_t columnCountDiffSignAbsDiffAbs;\n\tint32_t columnCountDiffSignAbsDiffSign;\n\tint32_t columnCountDiffSignAbsDiffSignAbs;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiff;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffAbs;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSign;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbs;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbsDiff;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbsDiffAbs;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbsDiffSign;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbsDiffSignAbs;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbsDiffSignAbsDiff;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbsDiffSignAbsDiffAbs;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbsDiffSignAbsDiffSign;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbsDiffSignAbsDiffSignAbs;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbsDiffSignAbsDiffSignAbsDiff;\n\tint32_t columnCountDiffSignAbsDiffSignAbsDiffSignAbsDiffSignAbs", "CodeBleu_score": 5.508421891766455}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t l = 0;\n\tint32_t m = 0;\n\tint32_t n = 0;\n\tint32_t o = 0;\n\tint32_t p = 0;\n\tint32_t q = 0;\n\tint32_t r = 0;\n\tint32_t s = 0;\n\tint32_t t = 0;\n\tint32_t u = 0;\n\tint32_t v = 0;\n\tint32_t w = 0;\n\tint32_t x = 0;\n\tint32_t y = 0;\n\tint32_t z = 0;\n\tint32_t a = 0;\n\tint32_t b = 0;\n\tint32_t c = 0;\n\tint32_t d = 0;\n\tint32_t e = 0;\n\tint32_t f = 0;\n\tint32_t g = 0;\n\tint32_t h = 0;\n\tint32_t ii = 0;\n\tint32_t jj = 0;\n\tint32_t kk = 0;\n\tint32_t ll = 0;\n\tint32_t mm = 0;\n\tint32_t nn = 0;\n\tint32_t oo = 0;\n\tint32_t pp = 0;\n\tint32_t qq = 0;\n\tint32_t rr = 0;\n\tint32_t ss = 0;\n\tint32_t tt = 0;\n\tint32_t uu = 0;\n\tint32_t vv = 0;\n\tint32_t ww = 0;\n\tint32_t", "CodeBleu_score": 8.104405565849236}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3CallbackData *data = (S3CallbackData *) callbackData;\n\tint64_t contentLength = 0;\n\n\tif (properties->contentLength > 0) {\n\t\tcontentLength = properties->contentLength;\n\t}\n\n\tdata->contentLength = contentLength;\n\n\treturn S3StatusOK;\n}", "CodeBleu_score": 60.33201096995363}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\t((S3GetObjectData *) callbackData)->contentLength = properties->contentLength;\n\treturn S3StatusOK;\n}", "CodeBleu_score": 46.29727370578941}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\t((S3GetObjectData *) callbackData)->contentLength = properties->contentLength;\n\treturn S3StatusOK;\n}", "CodeBleu_score": 46.29727370578941}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\t// Create the checkpoint backup directory\n\tif (mkdir(RSYNC_CHECKPOINT_BACKUP_DIR, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) < 0) {\n\t\tlogError(\"Failed to create checkpoint backup directory\");\n\t}\n\n\t// Remove empty directories\n\tremoveEmptyDirectories(RSYNC_CHECKPOINT_BACKUP_DIR);\n\n\t// Generate Rsync configuration file\n\tif (generateRsyncConfigFile() == 0) {\n\t\t// Construct Rsync daemon command\n\t\tchar *rsyncCommand = malloc(strlen(RSYNC_DAEMON_COMMAND) + strlen(RSYNC_CONFIG_FILE) + strlen(RSYNC_PORT) + 1);\n\t\tstrcpy(rsyncCommand, RSYNC_DAEMON_COMMAND);\n\t\tstrcat(rsyncCommand, RSYNC_CONFIG_FILE);\n\t\tstrcat(rsyncCommand, RSYNC_PORT);\n\n\t\t// Execute Rsync daemon command\n\t\tif (system(rsyncCommand) == 0) {\n\t\t\tlogInfo(\"Rsync server started successfully\");\n\t\t} else {\n\t\t\tlogError(\"Failed to start Rsync server\");\n\t\t}\n\n\t\tfree(rsyncCommand);\n\t}\n}", "CodeBleu_score": 27.754355638107764}, {"code": "void startRsync(){\n\t\tint pid = fork();\n\tif (pid == 0) {\n\t\t// Child process\n\t\tchar *args[] = {\"rsync\", \"--daemon\", \"--no-detach\", \"--config\", \"rsyncd.conf\", NULL};\n\t\texecvp(args[0], args);\n\t\texit(0);\n\t} else {\n\t\t// Parent process\n\t\tif (pid < 0) {\n\t\t\tLOG_ERROR(\"Failed to start Rsync server\");\n\t\t} else {\n\t\t\tLOG_INFO(\"Rsync server started\");\n\t\t}\n\t}\n}", "CodeBleu_score": 10.210907603764038}, {"code": "void startRsync(){\n\t\tint ret;\n\tchar *dir = getRsyncDir();\n\tret = mkdir(dir, 0777);\n\tif (ret!= 0) {\n\t\tlogMessage(LOG_ERR, \"Failed to create checkpoint backup directory %s\", dir);\n\t\treturn;\n\t}\n\tremoveEmptyDirs(dir);\n\tif (!generateRsyncConfFile()) {\n\t\tlogMessage(LOG_ERR, \"Failed to generate Rsync configuration file\");\n\t\treturn;\n\t}\n\tchar *command = (char *) malloc(1024);\n\tsprintf(command, \"rsync --daemon --config=%s --port=%d\", getRsyncConfFile(), getRsyncPort());\n\tret = system(command);\n\tif (ret!= 0) {\n\t\tlogMessage(LOG_ERR, \"Failed to start Rsync server\");\n\t} else {\n\t\tlogMessage(LOG_INFO, \"Rsync server started successfully\");\n\t}\n}", "CodeBleu_score": 28.59788074035803}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n\t}\n\tdispatcher.shutdown();\n}", "CodeBleu_score": 63.24942877330594}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n\tif (dispatcher!= null) {\n\t\tdispatcher.shutdown();\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher not found: \" + dispatcherId);\n\t}\n}", "CodeBleu_score": 63.634174385900934}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n\tif (dispatcher!= null) {\n\t\tdispatcher.shutdown();\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n\t}\n}", "CodeBleu_score": 64.51736890832747}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tList<TbActorId> filteredChildren = getChildren(parent).stream().filter(childFilter).collect(Collectors.toList());\n\tfor (TbActorId child : filteredChildren) {\n\t\tif (isRegistered(child)) {\n\t\t\tif (highPriority) {\n\t\t\t\tsendHighPriority(child, msg);\n\t\t\t} else {\n\t\t\t\tsend(child, msg);\n\t\t\t}\n\t\t} else {\n\t\t\tlog.warn(\"Failed to broadcast message to child [{}] of parent [{}]. Child is not registered.\", child, parent);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.93660317150706}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\t// Get the children of the parent actor from the map\n\tSet<TbActorId> children = childActors.get(parent);\n\tif (children == null) {\n\t\tlog.warn(\"[{}] No children for parent [{}]\", this, parent);\n\t\treturn;\n\t}\n\t// Filter the children based on the provided predicate\n\tList<TbActorId> filteredChildren = children.stream()\n\t\t\t.filter(childFilter)\n\t\t\t.collect(Collectors.toList());\n\t// Send the message to each filtered child actor with an optional high priority\n\tfor (TbActorId child : filteredChildren) {\n\t\ttry {\n\t\t\tif (highPriority) {\n\t\t\t\tchild.tell(msg, TbActorRef.HIGH_PRIORITY);\n\t\t\t} else {\n\t\t\t\tchild.tell(msg);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlog.warn(\"[{}] Failed to send message [{}] to child [{}]\", this, msg, child, e);\n\t\t}\n\t}\n}", "CodeBleu_score": 50.359934307162476}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tSet<TbActorId> children = getChildren(parent);\n\tif (children!= null) {\n\t\tchildren.stream().filter(childFilter).forEach(child -> {\n\t\t\tif (actorSystem.getActor(child)!= null) {\n\t\t\t\tactorSystem.tell(child, msg, highPriority);\n\t\t\t} else {\n\t\t\t\tlog.warn(\"Child actor not found: \" + child);\n\t\t\t}\n\t\t});\n\t}\n}", "CodeBleu_score": 46.15802865110307}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (isStopping.get()) {\n\t\tif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && highPriority) {\n\t\t\tif (state == TbActorState.STOPPED) {\n\t\t\t\tlog.debug(\"[{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}]", "CodeBleu_score": 22.333002778817956}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (isDestroyed.get()) {\n\t\tif (highPriority && msg.getType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\tif (reinitialize()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmsg.notifyActorStopped(TbActorStopReason.DESTROYED);\n\t\treturn;\n\t}\n\tif (highPriority) {\n\t\thighPriorityMsgs.add(msg);\n\t} else {\n\t\tnormalPriorityMsgs.add(msg);\n\t}\n\ttryProcessQueue();\n}", "CodeBleu_score": 44.677621875883446}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (!destroyInProgress.get()) {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t} else {\n\t\tif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && msg.getMsgData() instanceof RuleNodeUpdateMsgData) {\n\t\t\tRuleNodeUpdateMsgData ruleNodeUpdateMsgData = (RuleNodeUpdateMsgData) msg.getMsgData();\n\t\t\tif (ruleNodeUpdateMsgData.getRuleNodeId().equals(ruleChainId)) {\n\t\t\t\tif (ruleNodeUpdateMsgData.getRuleNode() == null) {\n\t\t\t\t\tlog.warn(\"[{}] Failed to initialize rule node [{}]!\", ruleChainId, ruleNodeUpdateMsgData.getRuleNodeId());\n\t\t\t\t\tif (ruleNodeUpdateMsgData.getRuleNodeError()!= null) {\n\t\t\t\t\t\tlog.warn(\"[{}] Failed to initialize rule node [{}]: {}\", ruleChainId, ruleNodeUpdateMsgData.getRuleNodeId(), ruleNodeUpdateMsgData.getRuleNodeError().getErrorMsg());\n\t\t\t\t\t}\n\t\t\t\t\treinitialize();\n\t\t\t\t} else {\n\t\t\t\t\tlog.warn(\"[{}] Reinitializing rule node [{}]!\", ruleChainId, ruleNodeUpdateMsgData.getRuleNodeId());\n\t\t\t\t\tif (ruleNodeUpdateMsgData.getRuleNodeError()!= null) {\n\t\t\t\t\t\tlog.warn(\"[{}] Reinitializing rule node [{}]: {}\", ruleChainId, ruleNodeUpdateMsgData.getRuleNodeId(), ruleNodeUpdateMsgData.getRuleNodeError().getErrorMsg());\n\t\t\t\t\t}\n\t\t\t\t\tinitialize();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.notify(TbActorError.ACTOR_STOPPED);\n\t\t}\n\t}\n}", "CodeBleu_score": 50.72415520563547}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t\t// TODO: implement here\n}", "CodeBleu_score": 0.8065760456678428}, {"code": "private void processMailbox(){\n\t\ttry {\n\t\twhile (true) {\n\t\t\tif (isStopped()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (processHighPriorityQueue()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (processNormalPriorityQueue()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (processLowPriorityQueue()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isStopped()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isHighPriorityQueueEmpty() && isNormalPriorityQueueEmpty() && isLowPriorityQueueEmpty()) {\n\t\t\t\tsetStatus(ActorStatus.FREE);\n\t\t\t\tscheduleProcessMailbox(getProcessMailboxDelay());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} catch (Exception e) {\n\t\tlog.error(\"Unexpected error while processing mailbox for actor: [{}]\", this, e);\n\t}\n}", "CodeBleu_score": 10.801697380817005}, {"code": "private void processMailbox(){\n\t\tif (this.stopReason.get()!= null) {\n\t\tlog.warn(\"Actor is already stopped. Stop reason: {}\", this.stopReason.get());\n\t\treturn;\n\t}\n\tif (this.stopped.get()) {\n\t\tlog.warn(\"Actor is already stopped. Stop reason: {}\", this.stopReason.get());\n\t\treturn;\n\t}\n\tif (this.status.get()!= TbActorStatus.FREE) {\n\t\tlog.warn(\"Actor is already busy. Status: {}\", this.status.get());\n\t\treturn;\n\t}\n\tthis.status.set(TbActorStatus.BUSY);\n\ttry {\n\t\tif (this.initFailure!= null) {\n\t\t\tthis.stopReason.set(this.initFailure);\n\t\t\tthis.destroy();\n\t\t\treturn;\n\t\t}\n\t\tif (this.throughputLimit > 0) {\n\t\t\tint processed = 0;\n\t\t\twhile (processed < this.throughputLimit) {\n\t\t\t\tif (processHighPriorityQueue()) {\n\t\t\t\t\tprocessed++;\n\t\t\t\t} else {\n\t\t\t\t\tif (processNormalPriorityQueue()) {\n\t\t\t\t\t\tprocessed++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tprocessHighPriorityQueue();\n\t\t\tprocessNormalPriorityQueue();\n\t\t}\n\t\tif (this.highPriorityQueue.isEmpty() && this.normalPriorityQueue.isEmpty()) {\n\t\t\tthis.status.set(TbActorStatus.FREE);\n\t\t\tthis.scheduleProcessing(0, TimeUnit.MILLISECONDS);\n\t\t} else {\n\t\t\tthis.status.set(TbActorStatus.BUSY);\n\t\t\tthis.scheduleProcessing(this.processingInterval, TimeUnit.MILLISECONDS);\n\t\t}\n\t} catch (Exception e) {\n\t\tlog.error(\"Unexpected error occurred while processing mailbox. Actor: {}, stop reason: {}\", this, this.stopReason.get(), e);\n\t\tthis.processFailure(e);\n\t}\n}", "CodeBleu_score": 20.572194980180306}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tdestroy(TbActorStopReason.UNKNOWN, cause);\n}", "CodeBleu_score": 5.187705648237158}, {"code": "public void destroy(Throwable cause){\n\t\tif (this.destroyed.compareAndSet(false, true)) {\n\t\tif (this.stopReason.compareAndSet(null, TbActorStopReason.DESTROYED)) {\n\t\t\tthis.dispatcher.schedule(this.destroyTask, this.destroyDelay, TimeUnit.MILLISECONDS);\n\t\t} else {\n\t\t\tthis.destroy(cause);\n\t\t}\n\t}\n}", "CodeBleu_score": 9.285049588223735}, {"code": "public void destroy(Throwable cause){\n\t\tthis.destroy(TbActorStopReason.UNKNOWN, cause);\n}", "CodeBleu_score": 4.147220411951694}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isNullUid()) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = tenantProfileService.findTenantProfileByTenantId(tenantId);\n\tif (tenantProfile == null && ignoreTenantNotFound) {\n\t\treturn true;\n\t}\n\tif (tenantProfile == null) {\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tRateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimitConfig().getTrigger();\n\tif (rateLimitsTrigger == null) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit() == null) {\n\t\treturn true;\n\t}\n\tString rateLimitKey = tenantId.toString() + \":\" + api.name() + \":\" + level;\n\tif (rateLimitsTrigger.getRateLimit().getPeriod() == null) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit().getPeriod().getUnit() == null) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit().getPeriod().getUnit() == TimeUnit.MINUTES) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit().getPeriod().getUnit() == TimeUnit.HOURS) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit().getPeriod().getUnit() == TimeUnit.DAYS) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit().getPeriod().getUnit() == TimeUnit.WEEKS) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit().getPeriod().getUnit() == TimeUnit.MONTHS) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit().getPeriod().getUnit() == TimeUnit.YEARS) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit().getPeriod().getUnit() == TimeUnit.MICROSECONDS) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit().getPeriod().getUnit() == TimeUnit.NANOSECONDS) {\n\t\treturn true;\n\t}\n\tif (rateLimitsTrigger.getRateLimit().getPeriod().getUnit() == TimeUnit.SECONDS) {\n\t\treturn true;\n\t}\n\tif", "CodeBleu_score": 43.02367985249515}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isNullUid()) {\n\t\treturn true;\n\t}\n\tTenantProfile profile = getTenantProfile(tenantId, ignoreTenantNotFound);\n\tif (profile!= null) {\n\t\tRateLimitsTrigger rateLimitsTrigger = profile.getRateLimitsTrigger();\n\t\tif (rateLimitsTrigger!= null) {\n\t\t\tboolean result = TbRateLimits.checkRateLimit(api, tenantId, level, rateLimitsTrigger);\n\t\t\tif (!result) {\n\t\t\t\tNotificationRuleProcessor.processRateLimitNotification(tenantId, api, level);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 33.04952579199957}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isNullUid()) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = tenantProfileService.findTenantProfileById(tenantId);\n\tif (tenantProfile == null) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tRateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimitsTrigger();\n\tif (rateLimitsTrigger == null) {\n\t\treturn true;\n\t}\n\tString rateLimitKey = String.format(\"%s:%s:%s\", api.name(), tenantId.toString(), level);\n\treturn tbRateLimits.checkRateLimit(rateLimitKey, rateLimitsTrigger.getRateLimit());\n}", "CodeBleu_score": 47.254385737525574}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong now = System.currentTimeMillis();\n\tlong expirationTime = now - inactivityTimeout;\n\tConcurrentMap<InetSocketAddress, DtlsSession> sessions = new ConcurrentHashMap<>(dtlsSessions);\n\tfor (Map.Entry<InetSocketAddress, DtlsSession> entry : sessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlog.debug(\"Evicting session for {} due to inactivity timeout\", entry.getKey());\n\t\t\tdtlsSessions.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 40.04388681326425}, {"code": "public void evictTimeoutSessions(){\n\t\t// TODO: implement evictTimeoutSessions\n}", "CodeBleu_score": 1.5735629692275181}, {"code": "public void evictTimeoutSessions(){\n\t\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\tfor (Map.Entry<InetSocketAddress, DtlsSession> entry : sessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlog.info(\"Removing session for peer {} due to inactivity\", entry.getKey());\n\t\t\tsessions.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 48.940205462097985}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (!CollectionUtils.isEmpty(timeseries)) {\n\t\treturn timeseries.entrySet().stream().map(entry -> {\n\t\t\tString key = entry.getKey();\n\t\t\tList<JsonNode> values = entry.getValue();\n\t\t\tif (!CollectionUtils.isEmpty(values)) {\n\t\t\t\tList<KvEntry> kvEntries = new ArrayList<>();\n\t\t\t\tfor (JsonNode value : values) {\n\t\t\t\t\tif (value.isBoolean()) {\n\t\t\t\t\t\tkvEntries.add(new BooleanDataEntry(value.asBoolean()));\n\t\t\t\t\t} else if (value.isDouble()) {\n\t\t\t\t\t\tkvEntries.add(new DoubleDataEntry(value.asDouble()));\n\t\t\t\t\t} else if (value.isLong()) {\n\t\t\t\t\t\tkvEntries.add(new LongDataEntry(value.asLong()));\n\t\t\t\t\t} else if (value.isTextual()) {\n\t\t\t\t\t\tkvEntries.add(new StringDataEntry(value.asText()));\n\t\t\t\t\t} else if (value.isObject()) {\n\t\t\t\t\t\tkvEntries.add(new JsonDataEntry(value.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn new BasicTsKvEntry(key, kvEntries);\n\t\t\t}\n\t\t\treturn null;\n\t\t}).filter(Objects::nonNull).collect(Collectors.toList());\n\t}\n\treturn Collections.emptyList();\n}", "CodeBleu_score": 39.25795910540143}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries == null || timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> result = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tif (values == null || values.isEmpty()) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (JsonNode value : values) {\n\t\t\tif (value.isTextual()) {\n\t\t\t\tresult.add(new BasicTsKvEntry(key, value.asText()));\n\t\t\t} else if (value.isBoolean()) {\n\t\t\t\tresult.add(new BasicTsKvEntry(key, value.asBoolean()));\n\t\t\t} else if (value.isDouble()) {\n\t\t\t\tresult.add(new BasicTsKvEntry(key, value.asDouble()));\n\t\t\t} else if (value.isLong()) {\n\t\t\t\tresult.add(new BasicTsKvEntry(key, value.asLong()));\n\t\t\t} else if (value.isObject()) {\n\t\t\t\tresult.add(new BasicTsKvEntry(key, value.toString()));\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 37.98676754517302}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (!CollectionUtils.isEmpty(timeseries)) {\n\t\treturn timeseries.entrySet().stream().map(entry -> {\n\t\t\tString key = entry.getKey();\n\t\t\tList<JsonNode> values = entry.getValue();\n\t\t\tList<KvEntry> kvEntries = new ArrayList<>();\n\t\t\tfor (JsonNode value : values) {\n\t\t\t\tif (value.isBoolean()) {\n\t\t\t\t\tkvEntries.add(new BooleanDataEntry(value.asBoolean()));\n\t\t\t\t} else if (value.isDouble()) {\n\t\t\t\t\tkvEntries.add(new DoubleDataEntry(value.asDouble()));\n\t\t\t\t} else if (value.isInt()) {\n\t\t\t\t\tkvEntries.add(new LongDataEntry(value.asLong()));\n\t\t\t\t} else if (value.isLong()) {\n\t\t\t\t\tkvEntries.add(new LongDataEntry(value.asLong()));\n\t\t\t\t} else if (value.isTextual()) {\n\t\t\t\t\tkvEntries.add(new StringDataEntry(value.asText()));\n\t\t\t\t} else if (value.isObject()) {\n\t\t\t\t\tkvEntries.add(new JsonDataEntry(value.toString()));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new BasicTsKvEntry(key, kvEntries);\n\t\t}).collect(Collectors.toList());\n\t}\n\treturn Collections.emptyList();\n}", "CodeBleu_score": 35.49967795853324}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refresh_token\", this.refreshToken);\n\ttry {\n\t\tResponseEntity<String> response = restTemplate.postForEntity(this.authEndpoint, requestMap, String.class);\n\t\tif (response.getStatusCode() == HttpStatus.OK) {\n\t\t\tJsonNode jsonNode = JacksonUtil.getJsonMapper().readTree(response.getBody());\n\t\t\tthis.token = jsonNode.get(\"access_token\").asText();\n\t\t\tthis.refreshToken = jsonNode.get(\"refresh_token\").asText();\n\t\t\tthis.tokenTimestamp = System.currentTimeMillis();\n\t\t}\n\t} catch (Exception e) {\n\t\tSystem.out.println(e.getMessage());\n\t}\n}", "CodeBleu_score": 46.361336234171006}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refresh_token\", refreshToken);\n\ttry {\n\t\tResponseEntity<String> response = restTemplate.postForEntity(authUrl, requestMap, String.class);\n\t\ttoken = response.getBody();\n\t\ttokenExpiration = System.currentTimeMillis();\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 51.973208860345686}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refresh_token\", getRefreshToken());\n\ttry {\n\t\tString response = sendPostRequest(getAuthEndpoint(), requestMap);\n\t\tupdateToken(response);\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t}\n}", "CodeBleu_score": 34.20309401074332}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\t// Get the current timestamp\n\tlong timestamp = System.currentTimeMillis();\n\t// Create the login request map with the credentials\n\tMap<String, Object> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", );\n\t// Send the login request to the authentication endpoint\n\tResponseEntity<Object> response = restTemplate.postForEntity(authUrl, loginRequest, Object.class);\n\t// Update the token information with the response data and the timestamp\n\ttoken = response.getBody();\n\ttokenTimestamp = timestamp;\n}", "CodeBleu_score": 65.63853675287896}, {"code": " private void doLogin(){\n\t\tlong timestamp = System.currentTimeMillis();\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", \"admin\");\n\tloginRequest.put(\"password\", \"\");\n\tResponseEntity<String> response = restTemplate.postForEntity(baseUrl + \"/api/auth/login\", loginRequest, String.class);\n\tString token = response.getBody();\n\tupdateTokenInfo(token, timestamp);\n}", "CodeBleu_score": 70.13059082106136}, {"code": " private void doLogin(){\n\t\tlong timestamp = System.currentTimeMillis();\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", \"\");\n\tloginRequest.put(\"password\", \"\");\n\tResponseEntity<JsonNode> response = restTemplate.postForEntity(getBaseUrl() + \"/api/auth/login\", loginRequest, JsonNode.class);\n\ttokenInfo.setToken(response.getBody().get(\"token\").asText());\n\ttokenInfo.setTimestamp(timestamp);\n}", "CodeBleu_score": 66.2650675761597}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\treturn Optional.of(restTemplate.getForObject(getRestUrl(\"/api/device/{deviceId}\"), Device.class, deviceId));\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.50023685602715}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\treturn Optional.of(restTemplate.getForObject(buildUri(\"/api/device/{deviceId}\", deviceId), Device.class));\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.29841687075315}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\tString url = \"/api/device/\" + deviceId;\n\ttry {\n\t\tResponseEntity<Device> response = restTemplate.exchange(url, HttpMethod.GET, null, new ParameterizedTypeReference<Device>() {\n\t\t});\n\t\tif (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\treturn Optional.of(response.getBody());\n\t\t}\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 58.700021842635095}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tSaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest(device, credentials);\n\ttry {\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(\n\t\t\t\t\"/api/device-with-credentials\",\n\t\t\t\trequest,\n\t\t\t\tDevice.class\n\t\t);\n\t\treturn Optional.ofNullable(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 67.6672368172144}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tSaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest(device, credentials);\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(getApiUrl(\"/api/device-with-credentials\"), request, Device.class);\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 71.17530869136584}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tSaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest(device, credentials);\n\ttry {\n\t\tResponseEntity<Device> response = restTemplate.exchange(\n\t\t\t\t\"/api/device-with-credentials\",\n\t\t\t\tHttpMethod.POST,\n\t\t\t\tnew HttpEntity<>(request, headers),\n\t\t\t\tDevice.class);\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 68.22862870391062}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tthis.brightness(0, arguments[0]);\n\t} else {\n\t\tconst v = Math.round(val * 15 / 100);\n\t\tthis.sendCommand(addr, 0x00, [v]);\n\t}\n\treturn this;\n}", "CodeBleu_score": 38.33417963585969}, {"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\tthis.setBrightness(addr);\n\t} else if (arguments.length == 2) {\n\t\tthis.setBrightness(addr, val);\n\t}\n\treturn this;\n}", "CodeBleu_score": 47.30917434234031}, {"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tthis.setBrightness(addr, val);\n\t} else {\n\t\tthis.setBrightness(addr, val);\n\t}\n\treturn this;\n}", "CodeBleu_score": 41.498862776298516}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tvar obj = Object.create(LedControl.prototype);\n\tfor (var prop in this) {\n\t\tif (typeof this[prop] === 'function') {\n\t\t\tobj[prop] = this[prop].bind(this, addr);\n\t\t} else {\n\t\t\tobj[prop] = this[prop];\n\t\t}\n\t}\n\treturn obj;\n}", "CodeBleu_score": 33.17720181355974}, {"code": "device(addr){\n\t\tlet bound = {};\n\tfor (let key in this) {\n\t\tif (typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t}\n\treturn bound;\n}", "CodeBleu_score": 38.128305044905424}, {"code": "device(addr){\n\t\tvar device = Object.create(LedControl.prototype);\n\tObject.assign(device, this);\n\tdevice.address = addr;\n\treturn device;\n}", "CodeBleu_score": 17.970669698948306}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (!callback || typeof callback!== 'function') {\n\t\t\t\tthrow new Error('callback must be a function');\n\t\t\t}\n\t\t\tlet promises = [];\n\t\t\tthis.forEach(item => {\n\t\t\t\tlet promise = item[method](duration);\n\t\t\t\tif (promise && typeof promise.then === 'function') {\n\t\t\t\t\tpromises.push(promise);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn Promise.all(promises).then(() => callback());\n\t\t};\n\t});\n}", "CodeBleu_score": 34.62996435037483}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('callback must be a function');\n\t\t\t}\n\t\t\tlet promises = [];\n\t\t\tthis.forEach(element => {\n\t\t\t\tlet promise = new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(element[method]());\n\t\t\t\t\t}, duration);\n\t\t\t\t});\n\t\t\t\tpromises.push(promise);\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 46.54634752225353}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('The callback must be a function.');\n\t\t\t}\n\t\t\tlet promises = [];\n\t\t\tthis.forEach(element => {\n\t\t\t\tpromises.push(element[method](duration));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 40.388859184029634}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\tvar input = \"\";\n\tvar incompleteSentence = \"\";\n\tvar serialPort = new SerialPort(this.port, {\n\t\tbaudRate: 9600,\n\t\tparser: SerialPort.parsers.readline(\"\\r\n\")\n\t});\n\tserialPort.on(\"open\", function() {\n\t\tserialPort.on(\"data\", function(data) {\n\t\t\tinput += data;\n\t\t\tvar sentences = input.split(\"\\r\n\");\n\t\t\tfor (var i = 0; i < sentences.length - 1; i++) {\n\t\t\t\tvar sentence = sentences[i];\n\t\t\t\tif (sentence.length > 0) {\n\t\t\t\t\tif (sentence.charAt(0) == \"$\") {\n\t\t\t\t\t\tparseNmeaSentence(sentence);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tincompleteSentence = sentences[sentences.length - 1];\n\t\t\tinput = \"\";\n\t\t});\n\t});\n}", "CodeBleu_score": 45.84007561448581}, {"code": "listen(){\n\t\tvar input = \"\";\n\tvar incompleteSentence = \"\";\n\tvar port = new SerialPort(this.portName, {\n\t\tbaudRate: this.baudRate,\n\t\tparser: SerialPort.parsers.readline(\"\\r\n\")\n\t});\n\n\tport.on(\"open\", () => {\n\t\tconsole.log(\"Serial port \" + this.portName + \" is open.\");\n\t});\n\n\tport.on(\"data\", (data) => {\n\t\tinput = incompleteSentence + data;\n\t\tvar sentences = input.split(\"\\r\n\");\n\t\tfor (var i = 0; i < sentences.length - 1; i++) {\n\t\t\tthis.parseNmeaSentence(sentences[i]);\n\t\t}\n\t\tincompleteSentence = sentences[sentences.length - 1];\n\t});\n}", "CodeBleu_score": 46.95405790615479}, {"code": "listen(){\n\t\tdef input = \"\"\n\twhile(true) {\n\t\tdef buffer = new byte[1024]\n\t\tdef count = serialPort.read(buffer)\n\t\tif(count > 0) {\n\t\t\tinput += new String(buffer, 0, count)\n\t\t\tdef sentences = input.split(\"\\r\n\")\n\t\t\tif(sentences.length > 1) {\n\t\t\t\tinput = sentences.last()\n\t\t\t\tsentences = sentences.dropRight(1)\n\t\t\t\tsentences.each {\n\t\t\t\t\tparseNmeaSentence(it)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 23.987772640674603}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tint num_channels = 0;\n\tint num_samples = 0;\n\tint buffer_size;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels_list[i] < config->num_channels) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (num_channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPT_OVERWRITE) {\n\t\tnum_samples = sequence->options & ADC_SEQ_OPT_OVERWRITE_MASK;\n\t} else {\n\t\tnum_samples = sequence->resolution * num_channels;\n\t}\n\n\tbuffer_size = num_samples * sizeof(uint32_t);\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"Insufficient memory for ADC sequence\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.18206750803469}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tstruct ad559x_data *data = dev->data;\n\tint num_active_channels = 0;\n\tint num_channels = 0;\n\tint buffer_size;\n\tint i;\n\n\tfor (i = 0; i < AD559X_MAX_CHANNELS; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tnum_active_channels++;\n\t\t}\n\t}\n\n\tnum_channels = config->num_channels;\n\n\tif (num_channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer_size = (num_active_channels * num_channels * sizeof(uint16_t));\n\n\tif (sequence->options) {\n\t\tbuffer_size += sizeof(uint32_t);\n\t}\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.53302664035572}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tuint8_t active_channels = 0;\n\tuint32_t needed_buffer_size;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Resolution is not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tfor (int i = 0; i < AD559X_MAX_CHANNELS; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tif (active_channels == 0) {\n\t\tLOG_ERR(\"No channels selected\");\n\t\treturn -EINVAL;\n\t}\n\n\tneeded_buffer_size = active_channels * (sequence->resolution / 8);\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.68310736176452}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *cfg = dev->config;\n\tstruct ad559x_data *drv_data = dev->data;\n\tstruct ad559x_adc_context *adc_context = &drv_data->adc_context;\n\tconst struct adc_ad559x_config *adc_cfg = &cfg->adc_cfg;\n\tint ret;\n\n\tif (sequence->resolution!= 16) {\n\t\tLOG_ERR(\"AD559x only supports 16-bit resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1) {\n\t\tLOG_ERR(\"AD559x only supports single channel reads\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels->channel_id >= AD559X_MAX_CHANNELS) {\n\t\tLOG_ERR(\"AD559x channel %d is not valid\", sequence->channels->channel_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < 2) {\n\t\tLOG_ERR(\"AD559x buffer size %d is too small\", sequence->buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\tadc_context->buffer = sequence->buffer;\n\tadc_context->buffer_size = sequence->buffer_size;\n\tadc_context->channel = sequence->channels->channel_id;\n\tadc_context->samples = sequence->options->oversampling;\n\n\tif (adc_context->samples == 0) {\n\t\tadc_context->samples = 1;\n\t}\n\n\tif (adc_cfg->start_read) {\n\t\tret = adc_cfg->start_read(dev, adc_context);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.526546017751414}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *const config = dev->config;\n\tstruct adc_ad559x_data *const data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= BIT(config->channel)) {\n\t\tLOG_ERR(\"invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling!= 0) {\n\t\tLOG_ERR(\"oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < 2) {\n\t\tLOG_ERR(\"buffer too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret!= 0) {\n\t\treturn ret;\n\t}\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}", "CodeBleu_score": 51.619103735131844}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tstruct ad559x_data *data = dev->data;\n\tuint8_t resolution;\n\tuint8_t channel;\n\tuint8_t num_channels;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Resolution mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 0) {\n\t\tLOG_ERR(\"Only channel 0 is supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate!= NULL) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling!= 0) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < sizeof(uint16_t)) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_channels = 0;\n\tfor (channel = 0; channel < 8; channel++) {\n\t\tif (sequence->channels & BIT(channel)) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (num_channels > 1) {\n\t\tLOG_ERR(\"Only one channel supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\tdata->context.device = dev;\n\tdata->context.sequence = sequence;\n\tdata->context.result = -EBUSY;\n\tdata->context.channels = sequence->channels;\n\n\tret = ad559x_read(dev, &data->context);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"ADC read failed\");\n\t\treturn ret;\n\t}\n\n\twhile (data->context.result == -EBUSY) {\n\t\tk_sleep(K_MSEC(1));\n\t}\n\n\treturn data->context.result;\n}", "CodeBleu_score": 46.4900259023246}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = CONTAINER_OF(ctx, struct adc_data, ctx);\n\tconst struct device *dev = data->dev;\n\tconst struct ad559x_config *config = dev->config;\n\tint i;\n\n\tLOG_DBG(\"ADC sampling start\");\n\n\t/* Set the channels to be sampled */\n\tfor (i = 0; i < data->num_channels; i++) {\n\t\tconfig->channel_config(dev, data->channels[i], true);\n\t}\n\n\t/* Initialize the repeat buffer with the data buffer */\n\tdata->repeat_buffer = data->buffer;\n\n\t/* Release the semaphore to signal the start of sampling */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 49.45362788867587}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = CONTAINER_OF(ctx, struct adc_data, adc_ctx);\n\n\tdata->adc_dev = device_get_binding(DT_INST_0_TI_AD5593R_ADC_0_BUS_NAME);\n\tif (data->adc_dev == NULL) {\n\t\tLOG_ERR(\"ADC device not found\");\n\t\treturn;\n\t}\n\n\tdata->adc_channel_list[0] = 0;\n\tdata->adc_channel_list[1] = 1;\n\tdata->adc_channel_list[2] = 2;\n\tdata->adc_channel_list[3] = 3;\n\tdata->adc_channel_list[4] = 4;\n\tdata->adc_channel_list[5] = 5;\n\tdata->adc_channel_list[6] = 6;\n\tdata->adc_channel_list[7] = 7;\n\n\tdata->adc_channel_list[8] = 8;\n\tdata->adc_channel_list[9] = 9;\n\tdata->adc_channel_list[10] = 10;\n\tdata->adc_channel_list[11] = 11;\n\tdata->adc_channel_list[12] = 12;\n\tdata->adc_channel_list[13] = 13;\n\tdata->adc_channel_list[14] = 14;\n\tdata->adc_channel_list[15] = 15;\n\n\tdata->adc_channel_list[16] = 16;\n\tdata->adc_channel_list[17] = 17;\n\tdata->adc_channel_list[18] = 18;\n\tdata->adc_channel_list[19] = 19;\n\tdata->adc_channel_list[20] = 20;\n\tdata->adc_channel_list[21] = 21;\n\tdata->adc_channel_list[22] = 22;\n\tdata->adc_channel_list[23] = 23;\n\n\tdata->adc_channel", "CodeBleu_score": 47.64339909313787}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_device_data *const dev_data = ctx->dev->data;\n\tstruct adc_device_config *const dev_cfg = ctx->dev->config;\n\tstruct ad559x_data *const ad559x = dev_data->ad559x;\n\tstruct ad559x_config *const ad559x_cfg = dev_cfg->ad559x_cfg;\n\tuint8_t channel;\n\tuint8_t channel_mask = 0;\n\tint i;\n\n\t/*\n\t * Check if the ADC context is valid. If not, return immediately.\n\t */\n\tif (ctx->buffer == NULL || ctx->repeat_buffer == NULL) {\n\t\tLOG_ERR(\"ADC context is not valid\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if the ADC context is already started. If so, return immediately.\n\t */\n\tif (ctx->state == ADC_CONTEXT_STARTED) {\n\t\tLOG_ERR(\"ADC context is already started\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Set the ADC context state to ADC_CONTEXT_STARTED.\n\t */\n\tctx->state = ADC_CONTEXT_STARTED;\n\n\t/*\n\t * Set the ADC context repeat buffer to the data buffer.\n\t */\n\tctx->repeat_buffer = ctx->buffer;\n\n\t/*\n\t * Set the ADC context repeat buffer size to the data buffer size.\n\t */\n\tctx->repeat_buffer_size = ctx->buffer_size;\n\n\t/*\n\t * Set the ADC context repeat buffer position to 0.\n\t */\n\tctx->repeat_buffer_position = 0;\n\n\t/*\n\t * Set the ADC context repeat buffer end to 0.\n\t */\n\tctx->repeat_buffer_end = 0;\n\n\t/*\n\t * Set the ADC context repeat buffer end to 0.\n\t */\n\tctx->repeat_buffer_end = 0;\n\n\t/*\n\t * Set the ADC context repeat buffer position to 0.\n\t */\n\tctx->repeat_buffer_position = 0;\n\n\t/*\n\t * Set the ADC context repeat buffer end to 0.\n\t */\n\tctx->repeat_buffer_end = 0;\n\n\t/*\n\t * Set the ADC context repeat buffer end to 0.\n\t */\n\t", "CodeBleu_score": 34.75318250717212}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_package *data = ctx->data;\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 62.41511480991184}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t\tctx->buffer_size = ctx->repeat_buffer_size;\n\t} else {\n\t\tctx->buffer = ctx->original_buffer;\n\t\tctx->buffer_size = ctx->original_buffer_size;\n\t}\n}", "CodeBleu_score": 43.830626319683994}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer = ctx->adc_data;\n\t}\n}", "CodeBleu_score": 47.471215868594754}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_context *ctx = &data->ctx;\n\tconst struct adc_ad559x_config *cfg = data->dev->config;\n\tstruct adc_sequence *sequence = &ctx->sequence;\n\tint ret;\n\tuint32_t buffer[ADC_MAX_RESOLUTION];\n\tuint8_t channel;\n\n\tLOG_DBG(\"ADC acquisition thread started\");\n\n\twhile (true) {\n\t\t/* Wait for a semaphore to be released */\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\t\t/* Check if the ADC context is complete */\n\t\tif (ctx->complete) {\n\t\t\tLOG_DBG(\"ADC context is complete\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Check if the ADC context is canceled */\n\t\tif (ctx->canceled) {\n\t\t\tLOG_DBG(\"ADC context is canceled\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Iterate through the active channels */\n\t\tfor (channel = 0; channel < sequence->channels; channel++) {\n\t\t\t/* Read the ADC value for the current channel */\n\t\t\tret = adc_ad559x_read(data->dev, &buffer[channel], channel);\n\n\t\t\t/* Check if the read was successful */\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read ADC value for channel %d: %d\", channel, ret);\n\n\t\t\t\t/* Mark the ADC context as complete */\n\t\t\t\tctx->complete = true;\n\n\t\t\t\t/* Break out of the loop */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Check if the ADC context is complete */\n\t\tif (ctx->complete) {\n\t\t\tLOG_DBG(\"ADC context is complete\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Check if the ADC context is canceled */\n\t\tif (ctx->canceled) {\n\t\t\tLOG_DBG(\"ADC context is canceled\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tadc_context_on_sampling_done(ctx, buffer, sequence->channels, 0);\n\t}\n\n\tLOG_DBG(\"ADC acquisition thread stopped\");\n}", "CodeBleu_score": 41.08156558798306}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint i;\n\tuint8_t channel;\n\tint16_t val;\n\tstruct adc_context *ctx = &data->ctx;\n\n\twhile (1) {\n\t\t/* Wait for the semaphore to be released */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Iterate through the active channels */\n\t\tfor (i = 0; i < ctx->channels; i++) {\n\t\t\tchannel = ctx->channel_id[i];\n\n\t\t\t/* Read the ADC value for the current channel */\n\t\t\tif (adc_ad559x_read(data->dev, channel, &val) < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read ADC value for channel %u\", channel);\n\t\t\t\tctx->status = ADC_STATUS_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Store the result in the buffer */\n\t\t\tsys_put_le16(val, &ctx->buffer[i]);\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tadc_context_complete(ctx, K_NO_WAIT);\n\t}\n}", "CodeBleu_score": 42.33946753583263}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint16_t adc_value;\n\tint ret;\n\n\twhile (1) {\n\t\t/* Wait for a semaphore to be released */\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\t\t/* Iterate through the active channels */\n\t\tfor (int i = 0; i < data->channel_count; i++) {\n\t\t\t/* Check if the channel is active */\n\t\t\tif (data->channel_mask & BIT(i)) {\n\t\t\t\t/* Read the ADC value */\n\t\t\t\tret = adc_channel_read(data->dev, &data->channels[i], &adc_value, 1);\n\n\t\t\t\t/* Check for errors */\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\t/* Log an error and mark the ADC context as complete */\n\t\t\t\t\tLOG_ERR(\"Error reading from ADC channel %d: %d\", i, ret);\n\t\t\t\t\tdata->complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Store the result in the buffer */\n\t\t\t\tdata->buffer[i] = adc_value;\n\t\t\t}\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tk_sem_give(&data->acq_done_sem);\n\t}\n}", "CodeBleu_score": 45.50710565891654}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tstruct ads1112_data *data = dev->data;\n\tconst struct ads1112_config *config = dev->config;\n\tuint16_t reg_value = 0;\n\tint ret;\n\n\tk_sleep(K_MSEC(config->ready_time));\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_value);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\twhile (!(reg_value & ADS1112_REG_CONFIG_OS_MASK)) {\n\t\tk_sleep(K_USEC(100));\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_value);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 67.0594071935448}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tuint16_t reg_val;\n\tint ret;\n\n\t/* Wait for the device to be ready for data reading */\n\tk_sleep(config->ready_time);\n\n\t/* Check the status of the device */\n\tret = i2c_burst_read_dt(&config->i2c, ADS1112_REG_CONFIG, (uint8_t *)&reg_val, sizeof(reg_val));\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* If the device is not ready, sleep for 100 microseconds and check again */\n\twhile (!(reg_val & ADS1112_REG_CONFIG_RDY)) {\n\t\tk_sleep(K_USEC(100));\n\n\t\tret = i2c_burst_read_dt(&config->i2c, ADS1112_REG_CONFIG, (uint8_t *)&reg_val, sizeof(reg_val));\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* If an error occurs during register reading, return the error code */\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* If the device is ready, return 0 */\n\treturn 0;\n}", "CodeBleu_score": 56.76519547173233}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tuint16_t config_reg;\n\tint ret;\n\n\t/* Wait for the device to be ready */\n\tk_sleep(K_MSEC(config->ready_time));\n\n\t/* Read the configuration register to check the status */\n\tret = i2c_burst_read_dt(&config->i2c, config->config_reg_addr, (uint8_t *)&config_reg, sizeof(config_reg));\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to read configuration register\");\n\t\treturn ret;\n\t}\n\n\t/* Check if the device is ready */\n\twhile (!(config_reg & ADS1112_CONFIG_REG_OS_MASK)) {\n\t\tk_sleep(K_MSEC(100));\n\t\tret = i2c_burst_read_dt(&config->i2c, config->config_reg_addr, (uint8_t *)&config_reg, sizeof(config_reg));\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read configuration register\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Clear the data ready flag */\n\tconfig_reg &= ~ADS1112_CONFIG_REG_OS_MASK;\n\tret = i2c_burst_write_dt(&config->i2c, config->config_reg_addr, (uint8_t *)&config_reg, sizeof(config_reg));\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to clear data ready flag\");\n\t\treturn ret;\n\t}\n\n\t/* Update the configuration register */\n\tdata->config_reg = config_reg;\n\n\treturn 0;\n}", "CodeBleu_score": 48.027090865824306}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_size;\n\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->options & ADC_SEQ_OPT_OVERFLOW) : sequence->resolution;\n\trequired_size = (sequence->options & ADC_SEQ_OPT_OVERFLOW)? (sequence->", "CodeBleu_score": 35.602314520796355}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint required_buffer_size = 0;\n\n\tif (sequence->options & ADC_SEQ_OPT_OVERWRITE) {\n\t\trequired_buffer_size = sequence->channels * sizeof(uint32_t);\n\t} else {\n\t\trequired_buffer_size = sequence->channels * sequence->resolution * sizeof(uint32_t);\n\t}\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size is insufficient for ADC sequence\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.33433533085717}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = 0;\n\n\tif (sequence->options & ADC_SEQ_OPT_OVERWRITE) {\n\t\tbuffer_size = sequence->channels * sizeof(uint32_t);\n\t} else {\n\t\tbuffer_size = sequence->channels * sequence->options * sizeof(uint32_t);\n\t}\n\n\tif (buffer_size < 0) {\n\t\tLOG_ERR(\"Buffer size is not sufficient for ADC sequence.\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.7780567904149}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->channels!= 1) {\n\t\tLOG_ERR(\"Unsupported number of channels\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unsupported options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution!= 16) {\n\t\tLOG_ERR(\"Unsupported resolution\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling!= 1) {\n\t\tLOG_ERR(\"Unsupported oversampling\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling_shift!= 0) {\n\t\tLOG_ERR(\"Unsupported oversampling shift\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\tLOG_ERR(\"NULL buffer\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < sizeof(uint16_t)) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels == 1) {\n\t\tif (sequence->channels->input_positive >= ADS1112_CHANNEL_MAX) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sequence->channels == 1) {\n\t\tif (sequence->channels->input_negative >= ADS1112_CHANNEL_MAX) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\tret = ads1112_adc_context_start(dev, wait);\n\n\tif (ret < 0) {\n\t\tLOG_ERR(\"ADC context start failed\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.91413101611088}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint result = 0;\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"options not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels!= 1) {\n\t\tLOG_ERR(\"only one channel is supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling) {\n\t\tLOG_ERR(\"oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution!= 16) {\n\t\tLOG_ERR(\"only 16 bit resolution is supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\tLOG_ERR(\"no buffer provided\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < 2) {\n\t\tLOG_ERR(\"buffer size too small\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data->adc_context.state!= ADC_STATE_IDLE) {\n\t\tLOG_ERR(\"ADC context not idle\");\n\t\treturn -EBUSY;\n\t}\n\n\tdata->adc_context.buffer = sequence->buffer;\n\tdata->adc_context.buffer_size = sequence->buffer_size;\n\n\tresult = ads1112_adc_context_start(dev, &data->adc_context, wait);\n\n\treturn result;\n}", "CodeBleu_score": 45.446893168940704}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_adc_config *config = dev->config;\n\tstruct ads1112_adc_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > 1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution!= 16) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling!= 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret!= 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\treturn adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 52.58346428518532}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tstruct audio_codec_config cfg;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Usage: %s <dev> <prop_id> [<prop_val>]\",\n\t\t\t    argv[0]);\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tcfg.prop_id = strtol(argv[2], NULL, 0);\n\tcfg.prop_val = strtol(argv[3], NULL, 0);\n\n\tret = audio_codec_apply_properties(dev, &cfg);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 49.961268087059565}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\tstruct audio_codec_config cfg;\n\tstruct audio_codec_prop_list prop_list;\n\tstruct audio_codec_prop *prop;\n\tint i;\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tcfg.props = &prop_list;\n\tcfg.props->count = argc - 2;\n\tcfg.props->props = malloc(cfg.props->count * sizeof(struct audio_codec_prop));\n\tif (!cfg.props->props) {\n\t\tshell_error(sh, \"Out of memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < cfg.props->count; i++) {\n\t\tprop = &cfg.props->props[i];\n\n\t\tprop->id = strtol(argv[i + 2], NULL, 0);\n\t\tif (prop->id < 0) {\n\t\t\tshell_error(sh, \"Invalid property id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprop->val = strtol(argv[i + 2], NULL, 0);\n\t\tif (prop->val < 0) {\n\t\t\tshell_error(sh, \"Invalid property value\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = audio_codec_configure(dev, &cfg);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply property\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.70284978228798}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\n\tif (argc!= 2) {\n\t\tshell_error(sh, \"Invalid number of arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Could not find %s\", argv[1]);\n\t\treturn -ENOEXEC;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tshell_print(sh, \"Properties applied\");\n\n\treturn 0;\n}", "CodeBleu_score": 55.619109785601516}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_i2s_cfg *cfg = dev->config;\n\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret;\n\n\tLOG_DBG(\"I2S trigger: %d\", cmd);\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = i2s_trigger(cfg->i2s_dev, I2S_DIR_PLAYBACK, I2S_CMD_START);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"I2S start failed: %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = i2s_trigger(cfg->i2s_dev, I2S_DIR_PLAYBACK, I2S_CMD_STOP);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"I2S stop failed: %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported I2S trigger command: %d\", cmd);\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 62.02244566452503}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_i2s_config *config = dev->config;\n\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state!= MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device not configured\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = i2s_trigger(config->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to start I2S device\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state!= MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device not active\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = i2s_trigger(config->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to stop I2S device\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t} else {\n\t\tLOG_ERR(\"Unsupported command\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.465418569319574}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *data = dev->data;\n\tstruct i2s_config *i2s_cfg = &data->i2s_cfg;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = i2s_trigger(i2s_cfg->i2s_dev, I2S_DIR_RX, I2S_CMD_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Failed to start I2S device\");\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid state to start I2S device\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = i2s_trigger(i2s_cfg->i2s_dev, I2S_DIR_RX, I2S_CMD_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Failed to stop I2S device\");\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid state to stop I2S device\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 55.21262569603832}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t command = 0;\n\n\tif (data->cursor_on) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_ON_CURSOR;\n\t}\n\n\tif (data->blink_on) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_ON_BLINK;\n\t}\n\n\tif (enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_ON_ENABLE;\n\t}\n\n\tauxdisplay_hd44780_send_command(dev, command);\n}", "CodeBleu_score": 64.60715038137937}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (data->cursor_pos_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_POS_BLINK;\n\t}\n\n\tif (data->cursor_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_send_cmd(dev, cmd);\n}", "CodeBleu_score": 65.67376472978027}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tstruct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0x08;\n\n\tif (enabled) {\n\t\tcmd |= 0x04;\n\t}\n\n\tif (data->cursor_on) {\n\t\tcmd |= 0x02;\n\t}\n\n\tif (data->blink_on) {\n\t\tcmd |= 0x01;\n\t}\n\n\tauxdisplay_hd44780_write_cmd(config->bus, config->rs, cmd);\n}", "CodeBleu_score": 41.992668569748034}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tconst struct device *gpio_dev;\n\tint ret;\n\n\tif (config->gpio_busy_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tgpio_dev = device_get_binding(config->gpio_busy_port);\n\tif (gpio_dev == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = gpio_pin_get_raw(gpio_dev, config->gpio_busy_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 63.8782103473924}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\tuint32_t busy_status;\n\n\tif (config->busy_gpiod_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_raw(config->busy_gpiod_port, config->busy_gpiod_pin, &busy_status);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn busy_status;\n}", "CodeBleu_score": 67.83525189920027}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (config->busy_gpiod_port == NULL) {\n\t\tLOG_ERR(\"Device not configured for busy status\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_raw(config->busy_gpiod_port, config->busy_gpiod_pin);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get busy status (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 62.63251536303238}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tret = i2c_write(config->i2c, buffer, sizeof(buffer), config->i2c_addr);\n\n\tk_msleep(config->delay);\n\n\treturn ret;\n}", "CodeBleu_score": 64.90541110662582}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tret = i2c_write(config->i2c, buffer, sizeof(buffer), config->i2c_addr);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to send special command 0x%02X to device at address 0x%02X\",\n\t\t\tbuffer[1], config->i2c_addr);\n\t\treturn ret;\n\t}\n\n\tk_msleep(config->delay_ms);\n\n\treturn 0;\n}", "CodeBleu_score": 60.40660418873416}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tret = i2c_write(config->i2c, buffer, sizeof(buffer), config->i2c_address);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->command_delay));\n\n\treturn ret;\n}", "CodeBleu_score": 65.82852206722491}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Invalid read size\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, config->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.62246094173689}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tint ret = 0;\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Requested read size is too big\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset % sizeof(uint32_t)!= 0) {\n\t\tLOG_ERR(\"Invalid read offset\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (size % sizeof(uint32_t)!= 0) {\n\t\tLOG_ERR(\"Invalid read size\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, config->mem + offset, size);\n\n\treturn ret;\n}", "CodeBleu_score": 60.12235324046752}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, config->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 64.16717087453885}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (size == 0 || size > config->size || offset > config->size - size ||\n\t    config->invalid) {\n\t\tLOG_ERR(\"Invalid write parameters\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(config->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 68.50721513895968}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size > config->size - offset) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (config->invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(config->ram + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.59386773388344}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *const dev_data = dev->data;\n\tstruct bbram_emul_config *const dev_config = dev->config;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > dev_config->size) {\n\t\tLOG_ERR(\"Write size %zu is too large for device of size %zu\", size,\n\t\t\tdev_config->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev_data->invalid) {\n\t\tLOG_ERR(\"Device is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 62.56795872162895}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device '%s' not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 83.06950647151027}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 85.75378797071377}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"cannot find device '%s'\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 81.68486121905273}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint ret;\n\n\tret = uart_fifo_read(dev, &h4_buf[h4_hdr_pos], H4_HDR_LEN - h4_hdr_pos);\n\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to read H4 header: %d\", ret);\n\t\treturn;\n\t}\n\n\th4_hdr_pos += ret;\n}", "CodeBleu_score": 22.707966518301827}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint bytes_read;\n\tint bytes_remaining = sizeof(struct h4_hdr);\n\n\twhile (bytes_remaining > 0) {\n\t\tbytes_read = uart_fifo_read(dev, (uint8_t *) &h4_hdr + (sizeof(struct h4_hdr) - bytes_remaining), bytes_remaining);\n\t\tif (bytes_read < 0) {\n\t\t\tLOG_ERR(\"Failed to read header data\");\n\t\t\treturn;\n\t\t}\n\t\tbytes_remaining -= bytes_read;\n\t}\n}", "CodeBleu_score": 32.68038325615256}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint bytes_read;\n\tint ret;\n\n\tbytes_read = 0;\n\tdo {\n\t\tret = uart_fifo_read(dev, (uint8_t *)h4_hdr + bytes_read, sizeof(h4_hdr) - bytes_read);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read header from H4 UART: %d\", ret);\n\t\t\treturn;\n\t\t}\n\n\t\tbytes_read += ret;\n\t} while (bytes_read < sizeof(h4_hdr));\n\n\th4_remaining = sys_get_le16(h4_hdr);\n}", "CodeBleu_score": 41.39234467123933}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read_len;\n\n\twhile (len > 0) {\n\t\tread_len = MIN(len, sizeof(buf));\n\t\tif (uart_fifo_read(uart, buf, read_len)!= read_len) {\n\t\t\tLOG_ERR(\"Failed to read from UART: %d\", errno);\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= read_len;\n\t}\n\n\treturn len;\n}", "CodeBleu_score": 44.15422188772568}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read_len;\n\tint ret;\n\n\twhile (len) {\n\t\tread_len = MIN(len, sizeof(buf));\n\t\tret = uart_fifo_read(uart, buf, read_len);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART: %d\", ret);\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= ret;\n\t}\n\n\treturn len;\n}", "CodeBleu_score": 48.810624928511736}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read_len;\n\n\twhile (len > 0) {\n\t\tread_len = MIN(len, sizeof(buf));\n\t\tif (uart_fifo_read(uart, buf, read_len)!= read_len) {\n\t\t\tLOG_ERR(\"Failed to read from UART\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= read_len;\n\t}\n\n\treturn len;\n}", "CodeBleu_score": 41.25550363761059}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t highest_priority = 0xff;\n\tstruct zbus_observer *obs;\n\n\tzbus_channel_lock(chan);\n\n\tZBUS_OBSERVER_FOR_EACH(obs, chan) {\n\t\tif (obs->priority < highest_priority && obs->enabled) {\n\t\t\thighest_priority = obs->priority;\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = highest_priority;\n\n\tzbus_channel_unlock(chan);\n}", "CodeBleu_score": 15.48363210114205}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t highest_observer_priority = 0xFF;\n\tstruct zbus_observer *observer;\n\tstruct zbus_channel_data *chan_data = chan->data;\n\n\tk_mutex_lock(&chan_data->mutex, K_FOREVER);\n\n\tSYS_SLIST_FOR_EACH_CONTAINER(&chan_data->observers, observer, node) {\n\t\tif (observer->priority < highest_observer_priority && observer->enabled) {\n\t\t\thighest_observer_priority = observer->priority;\n\t\t}\n\t}\n\n\tchan_data->highest_observer_priority = highest_observer_priority;\n\n\tk_mutex_unlock(&chan_data->mutex);\n}", "CodeBleu_score": 21.52270511066682}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obsv;\n\tuint8_t highest_priority = 0;\n\n\tzbus_channel_lock(chan);\n\tZBUS_OBSERVER_FOR_EACH(chan, obsv) {\n\t\tif (obsv->priority > highest_priority && obsv->enabled) {\n\t\t\thighest_priority = obsv->priority;\n\t\t}\n\t}\n\tzbus_channel_unlock(chan);\n\tchan->highest_observer_priority = highest_priority;\n}", "CodeBleu_score": 15.494406784709877}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observer *observer;\n\tstruct zbus_channel *channel;\n\tstruct zbus_channel_observer *next_observer;\n\tstruct zbus_channel *next_channel;\n\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&zbus_channels, channel, next_channel, {\n\t\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&channel->observers, observer, next_observer, {\n\t\t\tif (observer->observer == obs) {\n\t\t\t\tobserver->channel->update(observer->observer);\n\t\t\t}\n\t\t});\n\t});\n}", "CodeBleu_score": 16.814135340500272}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *obs_chan;\n\n\tSYS_SLIST_FOR_EACH_CONTAINER(&obs->channels, obs_chan, node) {\n\t\tif (obs_chan->observer == obs) {\n\t\t\tobs_chan->channel->update_fn(obs_chan->channel);\n\t\t}\n\t}\n}", "CodeBleu_score": 22.16112989148208}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tfor (int i = 0; i < ARRAY_SIZE(obs->channels); i++) {\n\t\tif (obs->channels[i]) {\n\t\t\tobs->channels[i]->update_channel_hop(obs);\n\t\t}\n\t}\n}", "CodeBleu_score": 20.951781440882517}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tARG_UNUSED(obs);\n\treturn 0;\n}", "CodeBleu_score": 8.374882378874055}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (obs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tif (zbus_obs_is_attached_to_thread(obs)) {\n\t\treturn -EALREADY;\n\t}\n\tif (zbus_obs_is_attached_to_isr(obs)) {\n\t\treturn -EALREADY;\n\t}\n\tobs->thread = k_current_get();\n\tobs->priority = k_thread_priority_get(obs->thread);\n\tobs->flags |= ZBUS_OBS_FLAG_THREAD;\n\tzbus_obs_update_channels(obs);\n\treturn 0;\n}", "CodeBleu_score": 43.9573018524299}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (obs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tif (k_is_in_isr()) {\n\t\treturn -EPERM;\n\t}\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\tint ret = 0;\n\tif (obs->thread!= NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tobs->thread = k_current_get();\n\t\tzbus_obs_update_priority(obs);\n\t}\n\tk_spin_unlock(&zbus_lock, key);\n\treturn ret;\n}", "CodeBleu_score": 44.046476037714164}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tuint32_t end_time;\n\tint ret;\n\tint key;\n\n\t__ASSERT(chan!= NULL, \"null channel\");\n\n\tif (timeout == K_NO_WAIT) {\n\t\treturn 0;\n\t}\n\n\tif (IS_ENABLED(CONFIG_KERNEL_COOPERATIVE) && timeout!= K_FOREVER) {\n\t\tend_time = k_uptime_get() + timeout;\n\t} else {\n\t\tend_time = K_FOREVER;\n\t}\n\n\tkey = z_xlock_key(&chan->lock);\n\tret = zbus_chan_notify_locked(chan, end_time);\n\tz_xunlock(&chan->lock, key);\n\n\treturn ret;\n}", "CodeBleu_score": 46.80378711708408}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tstruct zbus_channel_ctx ctx;\n\tk_timeout_t end_time;\n\tint ret;\n\n\t__ASSERT_NO_MSG(chan);\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tend_time = k_timeout_end_calc(timeout);\n\n\tctx.priority = k_thread_priority_get(k_current_get());\n\n\tret = zbus_chan_lock(chan, timeout);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (chan->notify) {\n\t\tret = chan->notify(chan, &ctx, end_time);\n\t} else {\n\t\tret = -ENOTSUP;\n\t}\n\n\tzbus_chan_unlock(chan);\n\n\treturn ret;\n}", "CodeBleu_score": 56.386305390100766}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint ret;\n\tk_timeout_t end_time;\n\tstruct zbus_channel_ctx ctx;\n\n\t__ASSERT_NO_MSG(chan!= NULL);\n\n\tif (timeout!= K_NO_WAIT) {\n\t\tend_time = k_uptime_get() + timeout;\n\t} else {\n\t\tend_time = timeout;\n\t}\n\n\tzbus_channel_ctx_init(&ctx, end_time, k_current_get());\n\n\tret = zbus_channel_lock(chan, &ctx);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = zbus_chan_notify_locked(chan, &ctx);\n\n\tzbus_channel_unlock(chan, &ctx);\n\n\treturn ret;\n}", "CodeBleu_score": 42.86155912632386}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t reg;\n\n\tif (Int > ETH_IT_ALL) {\n\t\treturn;\n\t}\n\n\treg = ETH->INT_EN;\n\tif (enable) {\n\t\treg |= Int;\n\t} else {\n\t\treg &= ~Int;\n\t}\n\tETH->INT_EN = reg;\n}", "CodeBleu_score": 29.157003053181796}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t regval;\n\tif (Int == ETH_INT_NORMAL) {\n\t\tregval = ETH_REG_READ(ETH_REG_IER);\n\t\tif (enable) {\n\t\t\tregval |= ETH_IER_NORMAL;\n\t\t} else {\n\t\t\tregval &= ~ETH_IER_NORMAL;\n\t\t}\n\t\tETH_REG_WRITE(ETH_REG_IER, regval);\n\t} else if (Int == ETH_INT_ABNORMAL) {\n\t\tregval = ETH_REG_READ(ETH_REG_IER);\n\t\tif (enable) {\n\t\t\tregval |= ETH_IER_ABNORMAL;\n\t\t} else {\n\t\t\tregval &= ~ETH_IER_ABNORMAL;\n\t\t}\n\t\tETH_REG_WRITE(ETH_REG_IER, regval);\n\t} else {\n\t\t/* do nothing */\n\t}\n}", "CodeBleu_score": 36.595409235086265}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (Int & ETH_IT_NORMAL) {\n\t\tif (enable) {\n\t\t\tETH->IEN |= ETH_IEN_NIE;\n\t\t} else {\n\t\t\tETH->IEN &= ~ETH_IEN_NIE;\n\t\t\tif (!ETH->IEN) ETH->IEN |= ETH_IEN_AISE;\n\t\t}\n\t}\n\tif (Int & ETH_IT_ABNORMAL) {\n\t\tif (enable) {\n\t\t\tETH->IEN |= ETH_IEN_AISE;\n\t\t} else {\n\t\t\tETH->IEN &= ~ETH_IEN_AISE;\n\t\t\tif (!ETH->IEN) ETH->IEN |= ETH_IEN_NIE;\n\t\t}\n\t}\n}", "CodeBleu_score": 35.339711724282544}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *desc;\n\tunsigned int i;\n\tunsigned int desc_addr;\n\n\tdesc_addr = ETH_GET_TX_DESC_ADDR();\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\tdesc = (ETH_TX_DESC *) desc_addr;\n\t\tif (desc->owner == 0) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc_addr += sizeof(ETH_TX_DESC);\n\t\tif (desc_addr == (ETH_GET_TX_DESC_ADDR() + (ETH_TX_DESC_CNT * sizeof(ETH_TX_DESC)))) {\n\t\t\tdesc_addr = ETH_GET_TX_DESC_ADDR();\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 45.384366148840655}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc;\n\tunsigned int i;\n\n\ttx_desc = (ETH_TX_DESC *)ETH_TX_DESC_BASE_ADDR;\n\tfor (i = 0; i < ETH_TX_DESC_COUNT; i++) {\n\t\tif (tx_desc->status & ETH_TX_DESC_STATUS_OWN) {\n\t\t\ttx_desc++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn tx_desc;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 32.9048570201977}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *desc;\n\tunsigned int i;\n\n\t/* Get the current transmit descriptor address */\n\tdesc = (ETH_TX_DESC *)ETH_GetTxDescAddr();\n\n\t/* Search for a free descriptor */\n\tfor (i = 0; i < ETH_NUM_TX_DESC; i++) {\n\t\t/* Check if the descriptor is owned by the device */\n\t\tif ((desc->control & ETH_TX_DESC_CONTROL_OWN) == 0) {\n\t\t\t/* Free descriptor found */\n\t\t\treturn desc;\n\t\t}\n\n\t\t/* Go to the next descriptor */\n\t\tdesc++;\n\n\t\t/* Check if the end of the descriptor list is reached */\n\t\tif (desc == (ETH_TX_DESC *)ETH_TX_DESC_BASE_ADDR) {\n\t\t\t/* Go back to the first descriptor */\n\t\t\tdesc = (ETH_TX_DESC *)ETH_TX_DESC_BASE_ADDR;\n\t\t}\n\t}\n\n\t/* No free descriptor found */\n\treturn 0;\n}", "CodeBleu_score": 48.192204207265135}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\treturn RT_EOK;\n}", "CodeBleu_score": 23.879569619933893}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tcy_rslt_t result;\n\tcy_stc_csd_idac_config_t idac_config;\n\tcy_stc_csd_context_t *context;\n\tcy_stc_csd_idac_context_t *idac_context;\n\tcy_stc_csd_config_t *config;\n\n\tif (device == RT_NULL) {\n\t\tLOG_E(\"device is null\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tcontext = (cy_stc_csd_context_t *) device->parent.user_data;\n\tif (context == RT_NULL) {\n\t\tLOG_E(\"context is null\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tconfig = &context->config;\n\tif (config == RT_NULL) {\n\t\tLOG_E(\"config is null\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tif (channel >= config->numChannels) {\n\t\tLOG_E(\"channel is out of range\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tidac_context = &context->idacContext[channel];\n\tif (idac_context == RT_NULL) {\n\t\tLOG_E(\"idac_context is null\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tresult = Cy_CSD_IDAC_Init(idac_context, &idac_config);\n\tif (result!= CY_RET_SUCCESS) {\n\t\tLOG_E(\"failed to initialize idac\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tresult = Cy_CSD_IDAC_Enable(idac_context);\n\tif (result!= CY_RET_SUCCESS) {\n\t\tLOG_E(\"failed to enable idac\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tresult = Cy_CSD_IDAC_SetValue(idac_context, *value);\n\tif (result!= CY_RET_SUCCESS) {\n\t\tLOG_E(\"failed to set idac value\");\n\t\treturn -RT_ERROR;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 47.03321993093691}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t ret = RT_EOK;\n\tcy_stc_csd_idac_config_t idac_config;\n\tcy_en_csd_idac_polarity_t idac_polarity;\n\tcy_en_csd_idac_mode_t idac_mode;\n\tcy_en_csd_idac_output_t idac_output;\n\tcy_en_csd_idac_ref_t idac_ref;\n\tcy_en_csd_idac_ref_mode_t idac_ref_mode;\n\tcy_en_csd_idac_ref_source_t idac_ref_source;\n\tcy_en_csd_idac_polarity_t idac_polarity_ref;\n\tcy_en_csd_idac_ref_t idac_ref_ref;\n\tcy_en_csd_idac_ref_mode_t idac_ref_mode_ref;\n\tcy_en_csd_idac_ref_source_t idac_ref_source_ref;\n\tcy_en_csd_idac_polarity_t idac_polarity_ref_ref;\n\tcy_en_csd_idac_ref_t idac_ref_ref_ref;\n\tcy_en_csd_idac_ref_mode_t idac_ref_mode_ref_ref;\n\tcy_en_csd_idac_ref_source_t idac_ref_source_ref_ref;\n\tcy_en_csd_idac_polarity_t idac_polarity_ref_ref_ref;\n\tcy_en_csd_idac_ref_t idac_ref_ref_ref_ref;\n\tcy_en_csd_idac_ref_mode_t idac_ref_mode_ref_ref_ref;\n\tcy_en_csd_idac_ref_source_t idac_ref_source_ref_ref_ref;\n\tcy_en_csd_idac_polarity_t idac_polarity_ref_ref_ref_ref;\n\tcy_en_csd_idac_ref_t idac_ref_ref_", "CodeBleu_score": 17.020357379182894}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t *p_addr = (rt_uint32_t *) addr;\n\trt_uint32_t *p_buf = (rt_uint32_t *) buf;\n\n\tif ((addr + size) > 0x00080000) {\n\t\trt_kprintf(\"Error: ifx_flash_read_32k: address + size exceeds flash memory end address.\n\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < (size / 4); i++) {\n\t\tp_buf[i] = p_addr[i];\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 45.32867717220688}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t read_addr = addr;\n\trt_uint32_t read_size = size;\n\trt_uint32_t end_addr = addr + size;\n\trt_uint8_t *p_buf = buf;\n\n\tif (end_addr > IFX_FLASH_SIZE) {\n\t\trt_kprintf(\"Error: ifx_flash_read_32k: end address exceeds flash memory's end address.\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < read_size; i++) {\n\t\t*p_buf = *(rt_uint8_t *)read_addr;\n\t\tp_buf++;\n\t\tread_addr++;\n\t}\n\n\treturn read_size;\n}", "CodeBleu_score": 44.83425010397192}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t flash_end = IFX_FLASH_BASE_ADDRESS + IFX_FLASH_SIZE;\n\trt_uint32_t flash_start = IFX_FLASH_BASE_ADDRESS;\n\n\tif (addr + size > flash_end) {\n\t\trt_kprintf(\"Invalid argument\n\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 44.364350741829426}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 29.825080229112366}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(cyhal_timer);\n}", "CodeBleu_score": 29.727987367272256}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 29.825080229112366}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\tint result;\n\n\tdo {\n\t\tresult = pthread_mutex_lock(&dfs_mutex);\n\t} while (result == EBUSY);\n\tassert(result == 0);\n}", "CodeBleu_score": 16.18802420964823}, {"code": "void dfs_lock(void){\n\t\tint result;\n\n\tdo {\n\t\tresult = pthread_mutex_lock(&dfs_mutex);\n\t} while (result == EBUSY);\n\n\tassert(result == 0);\n}", "CodeBleu_score": 16.18802420964823}, {"code": "void dfs_lock(void){\n\t\tint ret;\n\n\tdo {\n\t\tret = pthread_mutex_lock(&dfs_filesystem.mutex);\n\t} while (ret == EBUSY);\n\n\tassert(ret == 0);\n}", "CodeBleu_score": 11.684903054245282}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tif (fdt == NULL) {\n\t\treturn -1;\n\t}\n\n\tfor (fd = startfd; fd < DFS_FD_MAX; fd++) {\n\t\tif (fdt->fd_table[fd] == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\tif (fdt->expand(fdt) == 0) {\n\t\treturn fd_slot_alloc(fdt, startfd);\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 38.64206787070111}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\n\tfor (i = startfd; i < DFS_FD_MAX; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (dfs_fdtable_expand(fdt)!= 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 36.665101502494856}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\n\tfor (i = startfd; i < DFS_FD_MAX; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (dfs_fdtable_expand(fdt) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 37.569515457564194}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\trt_err_t err;\n\tconst char *err_str;\n\n\terr = error;\n\tif (err < 0) {\n\t\terr = -err;\n\t}\n\n\tswitch (err) {\n\tcase RT_EOK:\n\t\terr_str = \"OK\";\n\t\tbreak;\n\n\tcase RT_ERROR:\n\t\terr_str = \"RT_ERROR\";\n\t\tbreak;\n\n\tcase RT_ETIMEOUT:\n\t\terr_str = \"RT_ETIMEOUT\";\n\t\tbreak;\n\n\tcase RT_EFULL:\n\t\terr_str = \"RT_EFULL\";\n\t\tbreak;\n\n\tcase RT_EEMPTY:\n\t\terr_str = \"RT_EEMPTY\";\n\t\tbreak;\n\n\tcase RT_ENOMEM:\n\t\terr_str = \"RT_ENOMEM\";\n\t\tbreak;\n\n\tcase RT_ENOSYS:\n\t\terr_str = \"RT_ENOSYS\";\n\t\tbreak;\n\n\tcase RT_EBUSY:\n\t\terr_str = \"RT_EBUSY\";\n\t\tbreak;\n\n\tcase RT_EIO:\n\t\terr_str = \"RT_EIO\";\n\t\tbreak;\n\n\tcase RT_EINTR:\n\t\terr_str = \"RT_EINTR\";\n\t\tbreak;\n\n\tcase RT_EINVAL:\n\t\terr_str = \"RT_EINVAL\";\n\t\tbreak;\n\n\tdefault:\n\t\terr_str = \"EUNKNOW\";\n\t}\n\n\treturn err_str;\n}", "CodeBleu_score": 30.867253648446578}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tconst char *str = RT_NULL;\n\n\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tswitch (error) {\n\tcase RT_EOK:\n\t\tstr = \"OK\";\n\t\tbreak;\n\tcase RT_ERROR:\n\t\tstr = \"ERROR\";\n\t\tbreak;\n\tcase RT_ETIMEOUT:\n\t\tstr = \"ETIMEOUT\";\n\t\tbreak;\n\tcase RT_EFULL:\n\t\tstr = \"EFULL\";\n\t\tbreak;\n\tcase RT_EEMPTY:\n\t\tstr = \"EEMPTY\";\n\t\tbreak;\n\tcase RT_ENOMEM:\n\t\tstr = \"ENOMEM\";\n\t\tbreak;\n\tcase RT_ENOSYS:\n\t\tstr = \"ENOSYS\";\n\t\tbreak;\n\tcase RT_EBUSY:\n\t\tstr = \"EBUSY\";\n\t\tbreak;\n\tcase RT_EIO:\n\t\tstr = \"EIO\";\n\t\tbreak;\n\tcase RT_EINTR:\n\t\tstr = \"EINTR\";\n\t\tbreak;\n\tcase RT_EINVAL:\n\t\tstr = \"EINVAL\";\n\t\tbreak;\n\tcase RT_EPERM:\n\t\tstr = \"EPERM\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"EUNKNOW\";\n\t\tbreak;\n\t}\n\n\treturn str;\n}", "CodeBleu_score": 31.522867470277653}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tint err = (int)error;\n\n\tif (err < 0) {\n\t\terr = -err;\n\t}\n\n\tfor (i = 0; i < sizeof(err_strings) / sizeof(err_strings[0]); i++) {\n\t\tif (err_strings[i].num == err) {\n\t\t\treturn err_strings[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 56.78851615021403}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_uint8_t index;\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* search idle hook */\n\tfor (index = 0; index < RT_THREAD_IDLE_HOOK_NUMBER; index++) {\n\t\tif (rt_thread_idle_hook[index] == RT_NULL) {\n\t\t\trt_thread_idle_hook[index] = hook;\n\t\t\trt_hw_interrupt_enable(level);\n\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\trt_hw_interrupt_enable(level);\n\n\treturn -RT_EFULL;\n}", "CodeBleu_score": 46.57574364608267}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result = -RT_EFULL;\n\tstruct rt_thread_idle_hook *idle_hook;\n\n\t/* lock */\n\tlevel = rt_hw_interrupt_disable();\n\n\tidle_hook = rt_list_entry(rt_thread_idle_hook.next, struct rt_thread_idle_hook, list);\n\n\t/* find empty slot */\n\twhile (&idle_hook->list!= &rt_thread_idle_hook)\n\t{\n\t\tif (idle_hook->hook == RT_NULL)\n\t\t{\n\t\t\tidle_hook->hook = hook;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\n\t\tidle_hook = rt_list_entry(idle_hook->list.next, struct rt_thread_idle_hook, list);\n\t}\n\n\t/* unlock */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 43.54822176724321}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_uint8_t index;\n\trt_base_t level;\n\n\t/* lock interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* search empty item */\n\tfor (index = 0; index < RT_THREAD_IDLE_HOOK_MAX; index ++)\n\t{\n\t\tif (rt_thread_idle_sethook_list[index] == RT_NULL)\n\t\t{\n\t\t\t/* set hook */\n\t\t\trt_thread_idle_sethook_list[index] = hook;\n\n\t\t\t/* unlock interrupt */\n\t\t\trt_hw_interrupt_enable(level);\n\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* unlock interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn -RT_EFULL;\n}", "CodeBleu_score": 46.36691838286479}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\tstruct rt_thread *thread = rt_thread_self();\n\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* remove idle thread hook */\n\tif (thread->idle_hook == hook) {\n\t\tthread->idle_hook = RT_NULL;\n\t} else {\n\t\tresult = -RT_ENOSYS;\n\t}\n\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 20.770796659804358}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_uint8_t index;\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* find hook */\n\tfor (index = 0; index < RT_THREAD_IDLE_HOOK_MAX; index++) {\n\t\tif (rt_thread_idle_hook[index] == hook) {\n\t\t\t/* remove hook */\n\t\t\trt_thread_idle_hook[index] = RT_NULL;\n\n\t\t\t/* unlock scheduler */\n\t\t\trt_hw_interrupt_enable(level);\n\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\treturn -RT_ENOSYS;\n}", "CodeBleu_score": 46.602078652283375}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\tregister rt_uint8_t index;\n\n\trt_enter_critical();\n\n\tfor (index = 0; index < RT_THREAD_IDLE_HOOK_NUM; index++) {\n\t\tif (idle_hook[index] == hook) {\n\t\t\tidle_hook[index] = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index == RT_THREAD_IDLE_HOOK_NUM) {\n\t\tresult = -RT_ENOSYS;\n\t}\n\n\trt_exit_critical();\n\n\treturn result;\n}", "CodeBleu_score": 43.04674142557868}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\tregister rt_ubase_t temp;\n\tregister rt_thread_t thread;\n\tregister rt_list_t *list;\n\n\t/* disable interrupt */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* resume all thread in list */\n\tlist = susp_list;\n\twhile (list!= RT_NULL) {\n\t\t/* get thread from list */\n\t\tthread = rt_list_entry(list, rt_thread_t, tlist);\n\n\t\t/* resume from suspended list */\n\t\tif (thread->stat == RT_THREAD_SUSPEND) {\n\t\t\t/* change thread stat */\n\t\t\tthread->stat = RT_THREAD_READY;\n\n\t\t\t/* insert thread to thread ready list */\n\t\t\trt_list_remove(&(thread->tlist));\n\t\t\trt_thread_ready_insert(thread);\n\t\t}\n\n\t\t/* set error number */\n\t\tthread->error = thread_error;\n\n\t\t/* point to next */\n\t\tlist = list->next;\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(temp);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.33185475748742}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* ensure scheduler is unlocked */\n\trt_schedule_lock();\n\n\twhile (1) {\n\t\t/* get the first thread from suspension list */\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n\t\t/* if the suspension list is empty, break out */\n\t\tif (&thread->tlist == susp_list) break;\n\n\t\t/* remove the thread from the suspension list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* resume the thread */\n\t\trt_thread_resume(thread);\n\n\t\t/* set the thread error number */\n\t\tthread->error = thread_error;\n\n\t\t/* if the thread is in ready list, break out */\n\t\tif (thread->stat == RT_THREAD_READY) break;\n\t}\n\n\t/* resume scheduler */\n\trt_schedule_unlock();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 33.18003969982052}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\n\t/* ensure the scheduler is unlocked */\n\tRT_DEBUG_SCHEDULER_UNLOCK(thread_error);\n\n\t/* resume all threads in the suspension list */\n\twhile ((thread = rt_list_entry(susp_list->next, rt_thread_t, tlist))!= RT_NULL) {\n\t\t/* remove thread from suspension list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* set error */\n\t\tthread->error = thread_error;\n\n\t\t/* resume thread */\n\t\trt_thread_resume(thread);\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 35.41311345947226}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t device;\n\n\tif (name == RT_NULL)\n\t{\n\t\treturn RT_NULL;\n\t}\n\n\t/* save the current console device */\n\tdevice = rt_console_get_device();\n\n\t/* find the new console device */\n\tdevice = rt_device_find(name);\n\tif (device!= RT_NULL)\n\t{\n\t\t/* check if it is the same as the current device */\n\t\tif (device!= rt_console_get_device())\n\t\t{\n\t\t\t/* close the current console device */\n\t\t\tif (rt_console_get_device()!= RT_NULL)\n\t\t\t{\n\t\t\t\trt_device_close(rt_console_get_device());\n\t\t\t}\n\n\t\t\t/* open the new console device */\n\t\t\tif (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK)\n\t\t\t{\n\t\t\t\t/* set the new console device */\n\t\t\t\trt_console_set_device_impl(device);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* open the device failed, set the new console device to RT_NULL */\n\t\t\t\trt_console_set_device_impl(RT_NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn device;\n}", "CodeBleu_score": 52.20558392792084}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console;\n\trt_device_t new_console;\n\n\t/* get current console */\n\told_console = rt_console_get_device();\n\n\t/* get new console */\n\tnew_console = rt_device_find(name);\n\n\t/* if new console is different from current console */\n\tif (new_console!= old_console)\n\t{\n\t\t/* if new console is valid */\n\t\tif (new_console!= RT_NULL)\n\t\t{\n\t\t\t/* close current console */\n\t\t\tif (old_console!= RT_NULL)\n\t\t\t\trt_device_close(old_console);\n\n\t\t\t/* open new console */\n\t\t\trt_device_open(new_console, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\n\t\t\t/* set new console */\n\t\t\trt_console_set_device_impl(new_console);\n\t\t}\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 42.66440007976456}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console, new_console;\n\n\told_console = rt_console_get_device();\n\n\tif (old_console!= RT_NULL)\n\t{\n\t\tif (old_console->type == RT_Device_Class_Char)\n\t\t{\n\t\t\trt_device_close(old_console);\n\t\t}\n\t}\n\n\tnew_console = rt_device_find(name);\n\tif (new_console!= RT_NULL)\n\t{\n\t\tif (new_console->type == RT_Device_Class_Char)\n\t\t{\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK)\n\t\t\t{\n\t\t\t\trt_console_device_set(new_console);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 47.19673007196563}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_information *information;\n\tstruct rt_list_node *node;\n\tint length;\n\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\trt_spin_lock(&(information->object_list_lock));\n\n\tlength = 0;\n\tfor (node = information->object_list.next; node!= &(information->object_list); node = node->next) {\n\t\tlength ++;\n\t}\n\n\trt_spin_unlock(&(information->object_list_lock));\n\n\treturn length;\n}", "CodeBleu_score": 50.08840562700172}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_information *information;\n\tstruct rt_list_node *node;\n\tint count;\n\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\trt_enter_critical();\n\n\tcount = 0;\n\tfor (node = information->object_list.next; node!= &(information->object_list); node = node->next) {\n\t\tcount++;\n\t}\n\n\trt_exit_critical();\n\n\treturn count;\n}", "CodeBleu_score": 42.16161371770988}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\trt_object_t *object;\n\trt_list_t *list;\n\trt_object_class_t *object_class;\n\n\t/* get object class */\n\tobject_class = rt_object_get_class(type);\n\tif (object_class == RT_NULL)\n\t\treturn 0;\n\n\t/* lock object list */\n\trt_spin_lock(&(object_class->object_list_lock));\n\n\t/* get object list */\n\tlist = &(object_class->object_list);\n\n\t/* count objects */\n\tfor (object = rt_list_entry(list->next, rt_object_t, list);\n\t     object!= RT_NULL;\n\t     object = rt_list_entry(object->list.next, rt_object_t, list)) {\n\t\tcount ++;\n\t}\n\n\t/* unlock object list */\n\trt_spin_unlock(&(object_class->object_list_lock));\n\n\treturn count;\n}", "CodeBleu_score": 47.414434802156435}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* invoke detach hook */\n\tif (object->type_info->detach_hook!= RT_NULL) {\n\t\tobject->type_info->detach_hook(object);\n\t}\n\n\t/* get object information */\n\tstruct rt_object_information *information = object->type_info;\n\n\t/* lock object list */\n\trt_spin_lock(&information->list_lock);\n\n\t/* remove object from list */\n\trt_list_remove(&(information->object_list), &(object->list));\n\n\t/* unlock object list */\n\trt_spin_unlock(&information->list_lock);\n\n\t/* set object type to zero */\n\tobject->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 47.5136582081634}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\n\t/* invoke object detach hook */\n\tif (object->detach_hook!= RT_NULL)\n\t\tobject->detach_hook(object);\n\n\t/* remove object from list */\n\trt_object_remove(object);\n\n\t/* set object type to zero */\n\tobject->type = 0;\n}", "CodeBleu_score": 27.888798377135927}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tstruct rt_object_information *information;\n\trt_list_t *object_list;\n\trt_base_t level;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\t/* get object information */\n\tinformation = rt_object_get_information(object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\t/* detach object */\n\tif (information->detach_hook!= RT_NULL)\n\t{\n\t\tinformation->detach_hook(object);\n\t}\n\n\t/* remove object from list */\n\tobject_list = &information->object_list;\n\tlevel = rt_hw_interrupt_disable();\n\trt_list_remove(object_list, &(object->list));\n\trt_hw_interrupt_enable(level);\n\n\t/* set object type to 0 */\n\tobject->type = RT_Object_Class_None;\n}", "CodeBleu_score": 50.0957008849809}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\n\tif (obj!= RT_NULL) {\n\t\tif (obj->type == RT_Object_Class_Custom) {\n\t\t\tif (obj->destroy!= RT_NULL) {\n\t\t\t\tresult = obj->destroy(obj);\n\t\t\t}\n\t\t\trt_free(obj);\n\t\t} else {\n\t\t\tresult = -RT_ERROR;\n\t\t}\n\t} else {\n\t\tresult = -RT_ERROR;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 46.1303633130868}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n\t/* invoke destroy method */\n\tif (obj->parent.destroy!= RT_NULL) {\n\t\tif (obj->parent.destroy(obj)!= RT_EOK) {\n\t\t\treturn -RT_ERROR;\n\t\t}\n\t}\n\n\t/* delete object */\n\trt_object_delete(obj);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 42.44925286104834}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\tstruct rt_object_information *information;\n\trt_bool_t result;\n\n\t/* get object class information */\n\tinformation = (struct rt_object_information *)obj->type;\n\n\t/* check object type */\n\tRT_ASSERT(information->type == RT_Object_Class_Custom);\n\n\t/* check object */\n\tRT_ASSERT(obj!= RT_NULL);\n\n\t/* check if the object has a destroy method */\n\tif (information->destroy!= RT_NULL) {\n\t\t/* call the destroy method */\n\t\tresult = information->destroy(obj);\n\t} else {\n\t\t/* no destroy method */\n\t\tresult = RT_EOK;\n\t}\n\n\t/* delete the object */\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 47.75554664528319}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\n\tthread = rt_thread_self();\n\n\trt_enter_critical();\n\trt_object_detach(&(thread->parent.parent));\n\trt_list_remove(&(thread->tlist));\n\trt_list_insert_after(&(rt_thread_defunct), &(thread->tlist));\n\trt_exit_critical();\n\n\trt_schedule();\n}", "CodeBleu_score": 52.89148367691935}, {"code": "static void _thread_exit(void){\n\t\tstruct rt_thread *thread;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* enter critical */\n\trt_enter_critical();\n\n\t/* close thread */\n\trt_thread_close(thread);\n\n\t/* exit critical */\n\trt_exit_critical();\n\n\t/* schedule */\n\trt_schedule();\n}", "CodeBleu_score": 37.318293132590476}, {"code": "static void _thread_exit(void){\n\t\tstruct rt_thread *thread;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* close thread */\n\trt_thread_close(thread);\n\n\t/* change thread stat */\n\trt_thread_change_priority(thread, RT_THREAD_PRIORITY_MAX);\n\n\t/* add to defunct list */\n\trt_schedule_remove_thread(thread);\n\n\t/* switch to next thread */\n\trt_schedule();\n\n\t/* never reach here */\n}", "CodeBleu_score": 63.333351980696506}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\n\tthread = (struct rt_thread *)parameter;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* parameter check */\n\tRT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n\t/* set error number */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* insert thread to ready list */\n\trt_schedule_insert_thread(thread);\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* re-schedule */\n\trt_schedule();\n}", "CodeBleu_score": 49.49774321722911}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread;\n\n\t/* get thread control block from timer's parameter */\n\tthread = (rt_thread_t) parameter;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* parameter check */\n\tRT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n\t/* set error number */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* insert thread into ready list */\n\trt_schedule_insert_thread(thread);\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* re-schedule */\n\trt_schedule();\n}", "CodeBleu_score": 40.04357719608894}, {"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread = (struct rt_thread *)parameter;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* check thread status */\n\tif (thread->stat == RT_THREAD_STAT_SUSPEND)\n\t{\n\t\t/* set error number */\n\t\tthread->error = -RT_ETIMEOUT;\n\n\t\t/* remove thread from suspend list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* insert thread to ready list */\n\t\trt_schedule_insert_thread(thread);\n\n\t\t/* start thread */\n\t\trt_thread_startup(thread);\n\t}\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n}", "CodeBleu_score": 45.31158167391486}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_object_t object;\n\n\t/* lock the thread's spinlock */\n\trt_spin_lock(&thread->spinlock);\n\n\t/* check if the thread is waiting on a mutex */\n\tobject = thread->pending_object;\n\tif (object!= RT_NULL) {\n\t\t/* remove the thread from the mutex's waiting list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* clear the pending object */\n\t\tthread->pending_object = RT_NULL;\n\t}\n\n\t/* unlock the thread's spinlock */\n\trt_spin_unlock(&thread->spinlock);\n\n\t/* release all mutexes the thread has taken */\n\tif (thread->error == -RT_ERROR)\n\t\trt_mutex_release_all();\n\n\t/* restore the spinlock state */\n\trt_hw_interrupt_enable(thread->int_state);\n}", "CodeBleu_score": 31.74600545318275}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_ubase_t level;\n\trt_base_t ret;\n\n\t/* lock thread */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* if thread is waiting on a mutex, remove it from the mutex's waiting list */\n\tif (thread->stat & RT_THREAD_STAT_MUTEX) {\n\t\t/* detach thread from mutex */\n\t\tret = rt_mutex_detach((rt_mutex_t)thread->pending_object);\n\n\t\t/* if detach successfully, clear the pending object */\n\t\tif (ret == RT_EOK) {\n\t\t\tthread->pending_object = RT_NULL;\n\t\t\tthread->stat &= ~RT_THREAD_STAT_MUTEX;\n\t\t}\n\t}\n\n\t/* if thread has taken a mutex, release all mutexes it has taken */\n\tif (thread->stat & RT_THREAD_STAT_MUTEX_OWNER) {\n\t\trt_mutex_t mutex;\n\n\t\t/* get mutex */\n\t\tmutex = (rt_mutex_t)thread->mutex_list;\n\n\t\t/* release all mutexes */\n\t\twhile (mutex!= RT_NULL) {\n\t\t\t/* detach thread from mutex */\n\t\t\tret = rt_mutex_detach(mutex);\n\n\t\t\t/* if detach successfully, clear the pending object */\n\t\t\tif (ret == RT_EOK) {\n\t\t\t\tthread->pending_object = RT_NULL;\n\t\t\t\tthread->stat &= ~RT_THREAD_STAT_MUTEX;\n\t\t\t}\n\n\t\t\t/* get next mutex */\n\t\t\tmutex = mutex->owner_next;\n\t\t}\n\n\t\t/* clear mutex list */\n\t\tthread->mutex_list = RT_NULL;\n\t\tthread->stat &= ~RT_THREAD_STAT_MUTEX_OWNER;\n\t}\n\n\t/* restore thread's spinlock state */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 39.53569457218457}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\tregister rt_ubase_t temp;\n\tregister rt_list_t *list;\n\tregister rt_list_t *node;\n\tregister rt_list_t *next;\n\tregister rt_list_t *head;\n\tregister rt_list_t *tail;\n\tregister rt_list_t *mutex_list;\n\tregister rt_base_t level;\n\n\t/* get current interrupt status and disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* get thread's mutex list */\n\tmutex_list = &thread->mutex_list;\n\n\t/* get thread's waiting list */\n\tlist = &thread->thread_list;\n\n\t/* check if the thread is waiting on a mutex */\n\tif (list->next!= list)\n\t{\n\t\t/* get the mutex from the thread's waiting list */\n\t\tnode = list->next;\n\n\t\t/* get the mutex's waiting list */\n\t\thead = &((struct rt_mutex *)(node->prev))->parent.suspend_thread;\n\n\t\t/* get the mutex's waiting list tail */\n\t\ttail = &((struct rt_mutex *)(node->prev))->parent.thread_list;\n\n\t\t/* get the mutex's waiting list next node */\n\t\tnext = node->next;\n\n\t\t/* remove the thread from the mutex's waiting list */\n\t\trt_list_remove(node);\n\n\t\t/* check if the mutex's waiting list is empty */\n\t\tif (head->next == tail)\n\t\t{\n\t\t\t/* set the mutex's waiting list to the initial state */\n\t\t\trt_list_init(head);\n\t\t}\n\n\t\t/* check if the thread is waiting on the mutex */\n\t\tif (next!= list)\n\t\t{\n\t\t\t/* set the thread's waiting list to the initial state */\n\t\t\trt_list_init(list);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* set the thread's waiting list to the initial state */\n\t\t\trt_list_init(list);\n\n\t\t\t/* set the thread's pending object to the initial state */\n\t\t\tthread->pending_object = RT_NULL;\n\n\t\t\t/* set the thread's pending value to the initial state */\n\t\t\tthread->pending_value = 0;\n\t\t}\n\n\t\t/* set the thread's error number to the initial state */\n\t\tthread->", "CodeBleu_score": 45.27332051492577}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\trt_err_t result;\n\n\t/* check thread */\n\tRT_ASSERT(thread!= RT_NULL);\n\n\t/* check thread is in init state */\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n\t/* check thread is not a timer thread */\n\tRT_ASSERT(thread->type!= RT_Thread_Timer);\n\n\t/* check thread is not a idle thread */\n\tRT_ASSERT(thread->type!= RT_Thread_Idle);\n\n\t/* check thread is not a system thread */\n\tRT_ASSERT(thread->type!= RT_Thread_System);\n\n\t/* set thread name */\n\trt_strncpy(thread->name, thread->parent.name, RT_NAME_MAX);\n\n\t/* set thread priority */\n\tthread->current_priority = thread->init_priority;\n\n\t/* reset thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* startup thread */\n\tresult = rt_thread_resume(thread);\n\n\t/* trigger scheduler */\n\tif (result == RT_EOK) {\n\t\trt_schedule();\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 48.780233646816114}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(thread->type == RT_Object_Class_Thread);\n\n\t/* set the default name */\n\tif (thread->name == RT_NULL) {\n\t\tthread->name = \"default\";\n\t}\n\n\t/* set the default priority */\n\tif (thread->current_priority == 0) {\n\t\tthread->current_priority = RT_THREAD_PRIORITY_MAX / 2;\n\t}\n\n\t/* init thread stack */\n\trt_hw_stack_init(thread, (void (*)(void *parameter))thread->entry, thread->parameter, thread->stack_addr, thread->stack_size);\n\n\t/* set to suspend */\n\trt_thread_suspend(thread);\n\n\t/* start thread */\n\trt_thread_resume(thread);\n\n\t/* trigger scheduler */\n\trt_schedule();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 50.83367469504279}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\trt_err_t result;\n\trt_uint8_t temp;\n\n\t/* check thread */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n\t/* initialize thread */\n\trt_strncpy(thread->parent.name, thread->name, RT_NAME_MAX);\n\tthread->parent.flag = RT_OBJECT_FLAG_THREAD;\n\n\t/* set thread priority */\n\ttemp = thread->current_priority;\n\tthread->current_priority = thread->init_priority;\n\trt_thread_control(thread, RT_THREAD_CTRL_CHANGE_PRIORITY, &temp);\n\n\t/* set thread status */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* startup thread */\n\tresult = rt_thread_resume(thread);\n\tif (result == RT_EOK) {\n\t\t/* trigger scheduler */\n\t\trt_schedule();\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 44.56580264165399}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_timer_t timer;\n\n\t/* get highest level of skip list */\n\tlist = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\n\t/* check if the list is empty */\n\tif (list->next == list) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get first timer entry */\n\ttimer = rt_list_entry(list->next, rt_timer_t, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n\t/* set timeout tick */\n\t*timeout_tick = timer->timeout_tick;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 58.59881282255649}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_timer_t timer;\n\n\t/* get highest level */\n\tlist = timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\tif (list!= RT_NULL) {\n\t\t/* get first entry */\n\t\ttimer = rt_list_entry(list->next, rt_timer_t, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\t\t/* get timeout tick */\n\t\t*timeout_tick = timer->timeout_tick;\n\n\t\treturn RT_EOK;\n\t}\n\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 60.279131371476346}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_timer_t timer;\n\n\t/* get highest level of skip list */\n\tlist = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\n\t/* check if highest level of skip list is empty */\n\tif (list->next == list) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\t/* get first timer entry */\n\ttimer = rt_list_entry(list->next, rt_timer_t, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n\t/* set timeout tick */\n\t*timeout_tick = timer->timeout_tick;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 57.65445490302893}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* check input */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time!= 0);\n\n\t/* allocate object */\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL)\n\t{\n\t\treturn RT_NULL;\n\t}\n\n\t/* initialize object */\n\trt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);\n\n\t/* initialize timer */\n\ttimer->parent.flag = flag;\n\ttimer->timeout = timeout;\n\ttimer->parameter = parameter;\n\ttimer->init_tick = time;\n\ttimer->timeout_tick = time;\n\n\t/* insert timer to timer list */\n\t_rt_timer_insert(timer);\n\n\treturn timer;\n}", "CodeBleu_score": 55.71612130751979}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\tstruct rt_timer *timer;\n\n\t/* check parameter */\n\tRT_ASSERT(timeout!= RT_NULL);\n\n\t/* allocate object */\n\ttimer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* initialize object */\n\ttimer->parent.init = RT_NULL;\n\ttimer->parent.detach = RT_NULL;\n\n\t/* initialize timer */\n\ttimer->timeout_func = timeout;\n\ttimer->parameter = parameter;\n\ttimer->init_tick = time;\n\ttimer->timeout_tick = time;\n\ttimer->parent.flag = flag;\n\n\t/* initialize list */\n\trt_list_init(&(timer->row));\n\n\treturn (rt_timer_t)timer;\n}", "CodeBleu_score": 66.51428814677236}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* check parameters */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\n\t/* allocate object */\n\ttimer = (rt_timer_t) rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer!= RT_NULL) {\n\t\t/* initialize object */\n\t\ttimer->parent.init = RT_NULL;\n\t\ttimer->parent.detach = RT_NULL;\n\n\t\t/* initialize timer */\n\t\ttimer->timeout_func = timeout;\n\t\ttimer->parameter = parameter;\n\t\ttimer->init_tick = time;\n\t\ttimer->timeout_tick = time;\n\t\ttimer->parent.flag = flag;\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 49.60865763786432}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\tfor _, handler := range a.Handlers {\n\t\thandler(recorder, req)\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n\ta.Router.ServeHTTP(res, req)\n}", "CodeBleu_score": 46.83506700667957}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder to capture the response.\n\trecorder := httptest.NewRecorder()\n\n\t// Create a new request to pass to the router.\n\tnewReq := req.WithContext(req.Context())\n\n\t// Pass the request to the router and capture the response.\n\ta.router.ServeHTTP(recorder, newReq)\n\n\t// Copy the recorder's headers to the original response.\n\tfor k, v := range recorder.Header() {\n\t\tres.Header()[k] = v\n\t}\n\n\t// If the recorder's status code is 401, send a \"Not Authorized\" error response and return.\n\tif recorder.Code == http.StatusUnauthorized {\n\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\tres.Write([]byte(\"Not Authorized\"))\n\t\treturn\n\t}\n\n\t// If the recorder's status code is 404, send a \"Not Found\" error response and return.\n\tif recorder.Code == http.StatusNotFound {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"Not Found\"))\n\t\treturn\n\t}\n\n\t// Otherwise, forward the request to the router for further handling.\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 48.03756874709278}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tvar (\n\t\terr     error\n\t\thandler http.Handler\n\t)\n\n\t// The \"ServeHTTP\" method of the \"API\" struct is implemented to serve HTTP requests by passing them through a series of handlers.\n\t// The \"ServeHTTP\" method starts by initializing a \"recorder\" variable, which is used to record the response generated by the handlers.\n\t// It then iterates over the list of handlers defined in the \"API\" struct, calling each one in sequence.\n\t// For each handler, it captures the response using a recorder and copies the recorder's headers to the original response.\n\t// If any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\n\t// If all handlers pass without unauthorized status, it forwards the request to the router for further handling.\n\t// The \"ServeHTTP\" method is used as the implementation of the \"http.Handler\" interface, allowing the \"API\" struct to be used as a handler in an HTTP server.\n\trecorder := httptest.NewRecorder()\n\n\t// The \"ServeHTTP\" method is implemented to serve HTTP requests by passing them through a series of handlers.\n\t// The \"ServeHTTP\" method starts by initializing a \"recorder\" variable, which is used to record the response generated by the handlers.\n\t// It then iterates over the list of handlers defined in the \"API\" struct, calling each one in sequence.\n\t// For each handler, it captures the response using a recorder and copies the recorder's headers to the original response.\n\t// If any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\n\t// If all handlers pass without unauthorized status, it forwards the request to the router for further handling.\n\t// The \"ServeHTTP\" method is used as the implementation of the \"http.Handler\" interface, allowing the \"API\" struct to be used as a handler in an HTTP server.\n\tfor _, handler = range a.handlers {\n\t\thandler.ServeHTTP(recorder, req)\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(recorder.Code)\n\t\t\tres.Write([]byte(\"Not Authorized\"))", "CodeBleu_score": 53.05110782785156}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"\" || path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := robeaux.Asset(path)\n\tif err!= nil {\n\t\tres.WriteHeader(404)\n\t\treturn\n\t}\n\tswitch {\n\tcase strings.HasSuffix(path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase strings.HasSuffix(path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 47.86719767655914}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Retrieve the requested asset based on the URL path\n\tasset, err := a.robeaux.Asset(req.URL.Path)\n\tif err!= nil {\n\t\t// Return a 404 error if the asset is not found\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\n\t// Set the appropriate Content-Type header based on the file extension\n\tcontentType := \"text/plain\"\n\tswitch {\n\tcase strings.HasSuffix(req.URL.Path, \".js\"):\n\t\tcontentType = \"application/javascript\"\n\tcase strings.HasSuffix(req.URL.Path, \".css\"):\n\t\tcontentType = \"text/css\"\n\tcase strings.HasSuffix(req.URL.Path, \".html\"):\n\t\tcontentType = \"text/html\"\n\t}\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Write the asset content to the response\n\tres.Write(asset)\n}", "CodeBleu_score": 42.66372043909804}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Retrieve the requested asset based on the URL path\n\tasset := a.robeaux.Asset(req.URL.Path)\n\n\t// Check for errors\n\tif asset == nil {\n\t\t// If the asset is not found, return a 404 error\n\t\tres.WriteHeader(404)\n\t\treturn\n\t}\n\n\t// Set the appropriate Content-Type header based on the file extension (js, css, html)\n\text := strings.ToLower(req.URL.Path[strings.LastIndex(req.URL.Path, \".\")+1:])\n\tswitch ext {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t// Write the asset content to the response\n\tres.Write(asset)\n}", "CodeBleu_score": 47.90656963449318}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":name\")\n\trobot := a.master.Robot(robotName)\n\tif robot!= nil {\n\t\tconnections := robot.Connections()\n\t\tjson, err := json.Marshal(connections)\n\t\tif err!= nil {\n\t\t\tlog.Printf(\"error: %v\n\", err)\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write(json)\n\t} else {\n\t\tjson, err := json.Marshal(robeaux.Error{Message: fmt.Sprintf(\"No robot found with name %s\", robotName)})\n\t\tif err!= nil {\n\t\t\tlog.Printf(\"error: %v\n\", err)\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write(json)\n\t}\n}", "CodeBleu_score": 34.84773188807841}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\":name\")\n\trobot := a.master.Robot(name)\n\tif robot!= nil {\n\t\tconnections := robot.Connections()\n\t\tjson, err := json.Marshal(connections)\n\t\tif err!= nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write(json)\n\t} else {\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write([]byte(fmt.Sprintf(`{\"error\": \"No robot found with name '%s'\"}`, name)))\n\t}\n}", "CodeBleu_score": 34.50053338531992}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":name\")\n\trobot := a.master.Robot(robotName)\n\tif robot!= nil {\n\t\tconnections := robot.Connections()\n\t\tif len(connections) > 0 {\n\t\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tres.WriteHeader(http.StatusOK)\n\t\t\tjson.NewEncoder(res).Encode(connections)\n\t\t} else {\n\t\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tres.WriteHeader(http.StatusOK)\n\t\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"no connections found\"})\n\t\t}\n\t} else {\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusOK)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"no robot found\"})\n\t}\n}", "CodeBleu_score": 31.597542805122526}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || subtle.ConstantTimeCompare([]byte(user), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 53.295671504836875}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tuserpass, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!subtle.ConstantTimeCompare([]byte(userpass), []byte(username+\":\"+password)) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.844595280892236}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t\tif!checkBasicAuth(auth, username, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 54.047464985096084}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - (slope * fromMin)\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.36094839389383}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept for the scaling transformation\n\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\t// Calculate the scaled value\n\t\tscaled := slope * input + intercept\n\n\t\t// Clamp the scaled value within the target range\n\t\tif scaled < float64(toMin) {\n\t\t\tvalue = toMin\n\t\t} else if scaled > float64(toMax) {\n\t\t\tvalue = toMax\n\t\t} else {\n\t\t\tvalue = int(scaled)\n\t\t}\n\n\t\treturn value\n\t}\n}", "CodeBleu_score": 55.31322481786856}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.63205197792933}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection is nil\")\n\t}\n\n\tif!a.connection.AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw := a.connection.AnalogRead(a.pin)\n\tscaled := a.scale(float64(raw))\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 40.78289055372418}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection is nil\")\n\t}\n\n\tif!a.connection.AnalogRead(a.pin) {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support AnalogRead\")\n\t}\n\n\traw := a.connection.AnalogRead(a.pin)\n\tscaled := a.scale(raw)\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 45.066184210967386}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"No connection\")\n\t}\n\n\tif!a.connection.AnalogRead(a.pin) {\n\t\treturn 0, 0, fmt.Errorf(\"Connection does not support AnalogRead\")\n\t}\n\n\traw := a.connection.AnalogRead(a.pin)\n\tscaled := a.scale(raw)\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 45.87411515382002}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\treturn func(value int) float64 {\n\t\treturn m * float64(value) + n\n\t}\n}", "CodeBleu_score": 50.40787407133004}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax-fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(val int) float64 {\n\t\treturn m*float64(val) + n\n\t}\n}", "CodeBleu_score": 53.02809011992156}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax-fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(value int) float64 {\n\t\treturn m*float64(value) + n\n\t}\n}", "CodeBleu_score": 53.28079969341899}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tg := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               \"GrovePiezoVibrationSensorDriver\",\n\t}\n\tg.AddEvent(Vibration)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-g.Event(Data):\n\t\t\t\tdata := g.data\n\t\t\t\tif data > 1000 {\n\t\t\t\t\tg.Publish(Vibration, data)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\treturn g\n}", "CodeBleu_score": 38.317665563704786}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tg := &GrovePiezoVibrationSensorDriver{\n\t\tDriver: NewDriver(\"GrovePiezoVibrationSensor\", \"GrovePiezoVibrationSensor\", a, pin, opts...),\n\t}\n\tg.AddEvent(\"vibration\")\n\tg.Handle(func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tg.Publish(\"vibration\", true)\n\t\t}\n\t})\n\treturn g\n}", "CodeBleu_score": 32.42000587590044}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tg := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.SetName(\"GrovePiezoVibrationSensor\")\n\tg.AddEvent(Vibration)\n\tg.On(Data, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tg.Publish(Vibration, true)\n\t\t}\n\t})\n\treturn g\n}", "CodeBleu_score": 42.98359078543382}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency\n\ttonePeriod := 1000000 / hz\n\n\t// Calculate the tempo based on the buzzer's beats per minute (bpm)\n\ttempo := 60000 / d.bpm\n\n\t// Calculate the number of tone periods required to match the desired tempo\n\tnumPeriods := tempo / tonePeriod\n\n\t// Calculate the duration of each tone period\n\ttoneDuration := duration / numPeriods\n\n\t// Calculate the duration of each pause period\n\tpauseDuration := toneDuration / 2\n\n\t// Calculate the number of iterations required to match the desired duration\n\tnumIterations := int(duration / toneDuration)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period\n\tfor i := 0; i < numIterations; i++ {\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(toneDuration) * time.Millisecond)\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(pauseDuration) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 49.26496496772948}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\ttonePeriod := 1 / hz\n\ttempo := 60 / d.bpm\n\tonDuration := time.Duration(tonePeriod*tempo*1000) * time.Millisecond\n\toffDuration := time.Duration(tempo*1000) * time.Millisecond - onDuration\n\n\tfor i := 0; i < int(duration/tempo); i++ {\n\t\tif err := d.DigitalWrite(d.pin, 1); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(onDuration)\n\t\tif err := d.DigitalWrite(d.pin, 0); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(offDuration)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.65967211059555}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif err := d.Start(); err!= nil {\n\t\treturn err\n\t}\n\n\tdefer d.Stop()\n\n\t// calculate the tone period based on the given frequency\n\ttonePeriod := time.Duration(1000000 / hz)\n\n\t// calculate the tempo based on the buzzer's beats per minute\n\ttempo := time.Duration(60000 / d.Bpm)\n\n\t// calculate the number of times to repeat the tone based on the duration\n\trepeatCount := int(duration * float64(tempo) / float64(tonePeriod))\n\n\tfor i := 0; i < repeatCount; i++ {\n\t\t// turn the buzzer on\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// wait for the tone period\n\t\ttime.Sleep(tonePeriod)\n\n\t\t// turn the buzzer off\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// wait for the tempo\n\t\ttime.Sleep(tempo)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.36637298586327}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"no sleep pin configured\")\n\t}\n\td.Stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 29.527265116875796}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.067607079927328}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\td.Stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.257989130068808}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translatePin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin := system.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 51.65166265408805}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpin, err := a.newAnalogPin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 45.45578246830816}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := system.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 52.61622705634117}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tpin, err := a.getDigitalPin(id, true)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 50.78080064171733}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id, \"out\")\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn pin.DigitalWrite(val)\n}", "CodeBleu_score": 61.64156216346903}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id, gobot.DigitalWrite)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn pin.DigitalWrite(val)\n}", "CodeBleu_score": 62.238073453496526}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins found for %s\", a.Name())\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(a)\n\t}\n\n\tif p, ok := a.Pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpin, err := a.translateID(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tp, err := a.newDigitalPin(pin, opts...)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.Pins[id] = p\n\n\treturn p, nil\n}", "CodeBleu_score": 41.186549188036885}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins on adaptor\")\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(a)\n\t}\n\n\tif p, ok := a.Pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpin, err := a.translatePin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin.Init()\n\ta.Pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 35.19675501490111}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins on this adaptor\")\n\t}\n\n\tfor _, o := range opts {\n\t\to(a)\n\t}\n\n\tif pin, ok := a.Pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tvar err error\n\tvar pin gobot.DigitalPinner\n\tvar chip, line int\n\n\tif chip, line, err = a.translate(id); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif pin, err = a.newDigitalPin(id, chip, line); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif err = a.initPin(pin); err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.Pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 52.18298090174832}]}
