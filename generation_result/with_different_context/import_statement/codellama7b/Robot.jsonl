{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> required_files;\n  // get list of required files from server\n  auto required_files_response = _client.call(\"get_required_files\", folder);\n  if (required_files_response.has_error()) {\n    throw Exception(required_files_response.error());\n  }\n  required_files = required_files_response.get().as<std::vector<std::string>>();\n  // check if each file exists locally\n  for (auto &file : required_files) {\n    if (download) {\n      if (!FileTransfer::DownloadFile(file, _client.host())) {\n        throw Exception(\"File not found: \" + file);\n      }\n    } else {\n      if (!FileTransfer::FileExists(file)) {\n        throw Exception(\"File not found: \" + file);\n      }\n    }\n  }\n  return required_files;\n}", "CodeBleu_score": 56.64261512843352}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> required_files;\n  // Get the list of required files\n  auto response = _client.call(\n      \"get_required_files\",\n      folder,\n      download);\n  // Check if the response is valid\n  if (response.has_error()) {\n    throw Exception(response.error());\n  }\n  // Get the required files\n  required_files = response.get().as<std::vector<std::string>>();\n  return required_files;\n}", "CodeBleu_score": 40.914401701002404}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> required_files;\n  auto files = GetAvailableFiles(folder);\n  for (const auto &file : files) {\n    if (download) {\n      if (GetFileSize(file) == 0u) {\n        Log(\"Downloading file: \" + file);\n        DownloadFile(file);\n      } else {\n        Log(\"File found in cache: \" + file);\n      }\n    } else {\n      required_files.push_back(file);\n    }\n  }\n  return required_files;\n}", "CodeBleu_score": 48.65173617376166}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0 && transform.location.y == 0.0 &&\n        transform.location.z != 0.0) {\n      carla::log_warning(\"The transformation to spawn the actor with parent \",\n                         parent,\n                         \" is only in the 'z' axis. This may lead to an ill-formed transformation.\");\n    }\n  }\n  rpc::Actor actor = SpawnActorInternal(description, transform, parent, attachment_type, socket_name);\n  return actor;\n}", "CodeBleu_score": 45.933030293241714}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f && transform.location.z != 0.0f) {\n      carla::log_warning(\"The attachment type is SpringArm or SpringArmGhost, but the transformation is only in the 'z' axis. This can cause the actor to be spawned in an incorrect position.\");\n    }\n  }\n  return SpawnActorWithParentInternal(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 43.032487377631135}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n  // Check if the parent actor is valid.\n  if (parent != 0u) {\n    if (GetActor(parent) == nullptr) {\n      throw_exception(std::runtime_error(\"invalid parent actor id\"));\n    }\n  }\n\n  // Check if the attachment type is valid.\n  if (attachment_type != rpc::AttachmentType::Rigid &&\n      attachment_type != rpc::AttachmentType::SpringArm &&\n      attachment_type != rpc::AttachmentType::SpringArmGhost) {\n    throw_exception(std::runtime_error(\"invalid attachment type\"));\n  }\n\n  // Check if the socket name is valid.\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (socket_name.empty()) {\n      throw_exception(std::runtime_error(\"socket name must not be empty\"));\n    }\n  }\n\n  // Check if the transformation is valid.\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.z != 0.0f) {\n      std::cout << \"Warning: The location of the transformation is only in the 'z' axis. This might cause ill-formed transformations when the parent actor is not at the origin.\" << std::endl;\n    }\n  }\n\n  // Complete the actor spawning process.\n  return SpawnActor(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 53.52916074754507}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token = GetGBufferToken(ActorId, GBufferId);\n  std::vector<uint8_t> TokenData(token.begin(), token.end());\n  auto stream = streaming_client.Subscribe(ActorId, TokenData, callback);\n}", "CodeBleu_score": 40.431293792239295}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n    // Get the token for the G-buffer.\n    auto token = GetGbufferToken(ActorId, GBufferId);\n    // Copy the token data.\n    auto token_data = token.data();\n    // Subscribe to the streaming client using the provided callback function.\n    streaming_client.Subscribe(ActorId, token_data, callback);\n}", "CodeBleu_score": 36.97676676758106}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n    // get the token for the G-buffer\n    auto token_response = _client.call(\n      \"get_gbuffer_token\",\n      ActorId,\n      GBufferId);\n\n    // copy the token data\n    auto token_data = token_response.token_data;\n\n    // subscribe to the streaming client\n    _streaming_client->Subscribe(\n      token_data,\n      callback);\n\n}", "CodeBleu_score": 38.9994590977501}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::lock_guard<std::mutex> lock(mutex);\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(shared_from_this());\n  }\n  return navigation;\n}", "CodeBleu_score": 30.469198066843518}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation = GetNavigation();\n  if (navigation == nullptr) {\n    LOG_INFO(\"Creating new WalkerNavigation object\");\n    navigation = std::make_shared<WalkerNavigation>(shared_from_this());\n    SetNavigation(navigation);\n  }\n  return navigation;\n}", "CodeBleu_score": 41.54977629985496}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::lock_guard<std::mutex> lock(mutex);\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(*this);\n  }\n  return navigation;\n}", "CodeBleu_score": 28.935282218202335}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = system_clock::now();\n  while (episode.GetFrameNumber() < frame) {\n    if (system_clock::now() - start > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.Tick();\n  return true;\n}", "CodeBleu_score": 32.26458926947283}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = Clock::now();\n  while (true) {\n    if (episode.GetFrameNumber() >= frame) {\n      return true;\n    }\n    if (Clock::now() - start > timeout) {\n      return false;\n    }\n    episode.WaitForTick(timeout);\n  }\n}", "CodeBleu_score": 29.405604213252477}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  using namespace std::chrono_literals;\n  auto start_time = std::chrono::high_resolution_clock::now();\n  while (episode.GetFrameNumber() < frame) {\n    if (std::chrono::high_resolution_clock::now() - start_time > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTrafficManager().Tick();\n  return true;\n}", "CodeBleu_score": 40.79343251942205}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // 1. Send request to load new episode\n  const auto request = rpc::LoadEpisode(map_name, reset_settings, map_layers);\n  auto response = _client.call(request).as<rpc::LoadEpisodeResponse>();\n  const auto episode_id = response.episode_id;\n  // 2. Wait for episode to be loaded\n  auto episode = MakeEpisode(episode_id);\n  episode->WaitForReady(std::chrono::milliseconds(10000));\n  return episode;\n}", "CodeBleu_score": 35.71843821934979}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  if (map_name.empty()) {\n    throw_exception(std::runtime_error(\"map name is empty\"));\n  }\n  if (map_name.find(\":\") != std::string::npos) {\n    throw_exception(std::runtime_error(\"map name contains illegal character ':'\"));\n  }\n\n  // Setup a new episode.\n  auto episode_id = StartEpisode(map_name, reset_settings, map_layers);\n\n  // Wait for the episode to be ready.\n  auto episode_proxy = MakeEpisodeProxy(episode_id);\n  episode_proxy.WaitForReady(timeout_);\n\n  // Return the new episode.\n  return episode_proxy;\n}", "CodeBleu_score": 38.497567145182224}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  using namespace std::chrono_literals;\n  using namespace carla::client::detail;\n  using namespace carla::client;\n\n  // Load the new episode.\n  rpc::EpisodeSettings settings;\n  settings.set_synchronous_mode(true);\n  settings.set_no_rendering_mode(true);\n  settings.set_map_name(std::move(map_name));\n  settings.set_carla_settings(ResetSettings(reset_settings));\n  settings.set_map_layers(static_cast<uint32_t>(map_layers));\n\n  auto episode = EpisodeProxy(MakeSharedEpisode(settings));\n\n  // Wait until the episode is loaded.\n  const auto start_time = std::chrono::high_resolution_clock::now();\n  const auto timeout = std::chrono::duration_cast<std::chrono::milliseconds>(\n      std::chrono::high_resolution_clock::now() - start_time);\n  while (timeout < 10s) {\n    if (episode.GetId() != 0u) {\n      break;\n    }\n    std::this_thread::sleep_for(10ms);\n  }\n  if (episode.GetId() == 0u) {\n    throw std::runtime_error(\"Failed to load episode.\");\n  }\n\n  return episode;\n}", "CodeBleu_score": 42.6164154003825}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = controller.GetWalker();\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"Walker not found\"));\n  }\n  if (walker->GetEpisode() == nullptr) {\n    throw_exception(std::runtime_error(\"Episode is null\"));\n  }\n  if (walker->GetEpisode()->GetSimulator() == nullptr) {\n    throw_exception(std::runtime_error(\"Simulator is null\"));\n  }\n  if (walker->GetEpisode()->GetSimulator()->GetWalkerNavigation() == nullptr) {\n    walker->GetEpisode()->GetSimulator()->SetWalkerNavigation(std::make_shared<WalkerNavigation>(walker->GetEpisode()));\n  }\n  walker->GetEpisode()->GetSimulator()->GetWalkerNavigation()->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 53.64997491389714}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = GetWalker(controller.GetId());\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\n        \"Walker not found for controller with id \" + std::to_string(controller.GetId())));\n  }\n  if (walker->GetNavigation() == nullptr) {\n    walker->SetNavigation(std::make_shared<WalkerNavigation>(*walker));\n  }\n  walker->GetNavigation()->RegisterWalker(controller.GetId());\n}", "CodeBleu_score": 50.9360170345021}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker_id = controller.GetWalkerId();\n  auto walker_it = _walkers.find(walker_id);\n  if (walker_it == _walkers.end()) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n  auto &walker = walker_it->second;\n  if (walker->GetEpisode() == nullptr) {\n    throw std::runtime_error(\"Walker not associated with episode\");\n  }\n  if (walker->GetWalkerNavigation() == nullptr) {\n    walker->SetWalkerNavigation(\n        std::make_shared<WalkerNavigation>(\n            walker->GetEpisode(),\n            walker->GetId(),\n            _traffic_manager));\n  }\n  walker->GetWalkerNavigation()->RegisterWalker(controller.GetId());\n}", "CodeBleu_score": 46.29610886392362}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  SharedPtr<Actor> result = ActorFactory::Make(\n      *this,\n      blueprint,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n  RegisterActor(result, gc);\n  return result;\n}", "CodeBleu_score": 21.039218408536623}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n  // -- Check if the actor is already in the simulation.\n  if (IsActorIdValid(blueprint.MakeId())) {\n    throw_exception(std::runtime_error(\n        \"Actor with id \" + std::to_string(blueprint.MakeId()) + \" already exists\"));\n  }\n\n  // -- Spawn the actor.\n  auto actor = ActorFactory::MakeActor(blueprint, transform, parent, attachment_type, socket_name);\n\n  // -- Add the actor to the current episode.\n  AddActor(actor);\n\n  // -- Apply the garbage collection policy.\n  ApplyGarbageCollectionPolicy(gc);\n\n  // -- Log the actor creation.\n  LogActorCreation(actor);\n\n  // -- Return the actor.\n  return actor;\n}", "CodeBleu_score": 32.40687012209804}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  if (!blueprint.IsValid()) {\n    throw_exception(std::runtime_error(\"invalid actor blueprint\"));\n  }\n\n  if (parent == nullptr) {\n    return SpawnActorInternal(blueprint, transform, nullptr, gc);\n  } else {\n    return SpawnActorInternal(blueprint, transform, parent, gc, attachment_type, socket_name);\n  }\n}", "CodeBleu_score": 32.10727564212357}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(sensor.IsValid());\n  DEBUG_ASSERT(callback != nullptr);\n\n  if (!IsValid()) {\n    throw_exception(std::runtime_error(\"invalid simulator\"));\n  }\n\n  _stream_callbacks[sensor] = callback;\n  _client->SubscribeToStream(sensor.GetId(), [this, sensor] (auto &&data) {\n    auto deserializer = sensor::Deserializer::Make(data);\n    auto sensor_data = sensor::SensorData::Deserialize(deserializer);\n    sensor_data->SetEpisode(shared_from_this());\n    _stream_callbacks[sensor](sensor_data);\n  });\n}", "CodeBleu_score": 47.311256424174466}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (!sensor.IsValid()) {\n    throw_exception(std::runtime_error(\"invalid sensor\"));\n  }\n  if (!sensor.GetEpisode().IsValid()) {\n    throw_exception(std::runtime_error(\"invalid episode\"));\n  }\n  sensor.GetEpisode().Lock()->SubscribeToSensor(sensor, callback);\n}", "CodeBleu_score": 32.14671667831171}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (!IsEpisodeRunning()) {\n    throw_exception(std::logic_error(\"no episode running\"));\n  }\n  sensor.Subscribe(std::move(callback));\n}", "CodeBleu_score": 22.787022367957377}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  auto state = episode->Lock()->GetState();\n  for (auto it = walkers.begin(); it != walkers.end();) {\n    if (state.walkers.find(it->first) == state.walkers.end()) {\n      it = walkers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  if (walkers.empty()) {\n    return;\n  }\n\n  auto &navigation = episode->GetNavigation();\n\n  for (auto &walker : walkers) {\n    auto &walker_state = state.walkers.at(walker.first);\n    auto &walker_actor = walker.second;\n    auto walker_transform = walker_actor->GetTransform();\n    auto walker_speed = walker_actor->GetVelocity();\n    auto walker_control = walker_actor->GetWalkerControl();\n    navigation.UpdateWalker(walker.first, walker_transform, walker_speed, walker_control);\n  }\n\n  navigation.UpdateCrowd(walkers);\n\n  auto &simulator = episode->GetSimulator();\n  auto &commands = simulator.GetWalkerCommands();\n  commands.clear();\n  commands.reserve(walkers.size());\n  for (auto &walker : walkers) {\n    auto &walker_state = state.walkers.at(walker.first);\n    auto &walker_actor = walker.second;\n    auto walker_control = walker_actor->GetWalkerControl();\n    auto walker_transform = walker_actor->GetTransform();\n    auto walker_speed = walker_actor->GetVelocity();\n    auto &walker_control_state = walker_control.GetState();\n    if (walker_control_state.has_value()) {\n      commands.push_back(rpc::Command::WalkerControl(walker.first, walker_control_state.value()));\n    }\n", "CodeBleu_score": 44.66218686183779}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  if (episode->GetWalkers().empty()) {\n    return;\n  }\n  auto state = episode->GetState();\n  auto walkers = episode->GetWalkers();\n  for (auto &walker : walkers) {\n    auto transform = walker->GetActor()->GetTransform();\n    auto speed = walker->GetSpeed();\n    walker->SetWalkerTransform(transform);\n    walker->SetWalkerSpeed(speed);\n  }\n  auto &nav = episode->GetNavigation();\n  nav.UpdateCrowd(walkers);\n  nav.UpdateCrowdSimulation(walkers);\n  for (auto &walker : walkers) {\n    if (walker->IsDead()) {\n      nav.RemoveWalker(walker);\n      walker->DestroyController();\n    }\n  }\n}", "CodeBleu_score": 30.75737462505595}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  // Retrieve the current walkers from the crowd manager.\n  auto walkers = episode->GetWalkerNavigation().GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  // Retrieve the current state of the episode.\n  auto episode_state = episode->GetEpisodeState();\n\n  // Remove any walkers that no longer exist.\n  walkers.erase(\n      std::remove_if(\n          walkers.begin(),\n          walkers.end(),\n          [&episode_state](auto &walker) {\n            return episode_state->GetWalkerId(walker) == 0u;\n          }),\n      walkers.end());\n\n  // Update the vehicles in the crowd and the crowd itself in the navigation module.\n  episode->GetWalkerNavigation().UpdateCrowd(walkers);\n\n  // Get the current transforms and speeds of the walkers.\n  std::vector<carla::rpc::Transform> transforms;\n  std::vector<float> speeds;\n  for (auto &walker : walkers) {\n    transforms.push_back(walker.GetTransform());\n    speeds.push_back(walker.GetSpeed());\n  }\n\n  // Apply these states in a batch to the simulator.\n  auto commands = std::vector<carla::rpc::Command>();\n  commands.reserve(walkers.size());\n  for (size_t i = 0; i < walkers.size(); ++i) {\n    commands.push_back(carla::rpc::Command::ApplyWalkerControl(\n        walkers[i].GetId(),\n        carla::rpc::WalkerControl{\n          transforms[i],\n          speeds[i],\n          walkers[i].GetMaxSpeed(),\n          walkers[i].GetMaxAcceleration()}));\n  }\n  episode->GetEpisode().Lock()->ApplyCommands(commands);\n\n  // Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead.\n  for (auto &walker : walkers)", "CodeBleu_score": 45.305718962133845}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.id = _id;\n  description.type_id = _type_id;\n  description.attributes = std::move(attributes);\n  return description;\n}", "CodeBleu_score": 43.9123472561592}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.id = _id;\n  description.type_id = _type_id;\n  description.attributes = std::move(attributes);\n  return description;\n}", "CodeBleu_score": 43.9123472561592}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.id = _id;\n  description.blueprint = _blueprint_name;\n  description.attributes = _attributes;\n  return description;\n}", "CodeBleu_score": 42.79318024920512}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n  SharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\n  for (const auto &bp : _blueprints) {\n    if (bp.HasAttribute(name)) {\n      const auto &attr = bp.GetAttribute(name);\n      if (attr.HasValue(value)) {\n        result->Add(bp);\n      } else {\n        for (const auto &v : attr.GetRecommendedValues()) {\n          if (v == value) {\n            result->Add(bp);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 54.06971418998114}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n  auto result = MakeShared<BlueprintLibrary>();\n\n  for (auto &blueprint : _blueprints) {\n    if (blueprint.second.HasAttribute(name)) {\n      if (blueprint.second.GetAttribute(name) == value) {\n        result->Add(blueprint.first, blueprint.second);\n      } else {\n        for (auto &recommended_value : blueprint.second.GetAttribute(name).GetRecommendedValues()) {\n          if (recommended_value == value) {\n            result->Add(blueprint.first, blueprint.second);\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 48.75341353678533}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n  for (auto &blueprint : _blueprints) {\n    auto attributes = blueprint.second.GetAttributes();\n    auto it = attributes.find(name);\n    if (it != attributes.end()) {\n      auto attribute = it->second;\n      if (attribute.GetValue() == value) {\n        result->AddBlueprint(blueprint.first, blueprint.second);\n      } else {\n        for (auto &recommended_value : attribute.GetRecommendedValues()) {\n          if (recommended_value == value) {\n            result->AddBlueprint(blueprint.first, blueprint.second);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 60.42127849808867}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\n\tstd::string filePath = path + \"/\" + carla::version::GetVersion() + \"/\" + path;\n\n\tif (filePath.empty()) {\n\t\treturn false;\n\t}\n\n\tstd::ofstream file(filePath, std::ios::binary | std::ios::trunc);\n\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\tfile.write(reinterpret_cast<const char*>(content.data()), content.size());\n\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 44.678963104870874}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string filepath = path + \"/\" + std::string(CARLA_VERSION) + \".bin\";\n    std::ofstream file(filepath, std::ios::binary | std::ios::trunc);\n    if (file.is_open()) {\n        file.write(reinterpret_cast<const char*>(content.data()), content.size());\n        file.close();\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "CodeBleu_score": 43.22901679914245}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\n    std::string full_path = base_folder + path;\n    std::string version_path = full_path + \".\" + carla::version();\n\n    std::ofstream file(version_path, std::ios::binary | std::ios::trunc);\n\n    if (file.is_open()) {\n        file.write((char *)content.data(), content.size());\n        file.close();\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 44.34204760425896}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  auto location = transform.location;\n  location += _parent->GetBoundingBox().location;\n  auto rotation = transform.rotation;\n  auto extent = _parent->GetBoundingBox().extent;\n  auto x_extent = extent.x;\n  auto y_extent = extent.y;\n  auto z_extent = extent.z;\n  auto x_min = location.x - x_extent;\n  auto x_max = location.x + x_extent;\n  auto y_min = location.y - y_extent;\n  auto y_max = location.y + y_extent;\n  auto z_min = location.z - z_extent;\n  auto z_max = location.z + z_extent;\n  auto x_rot_min = x_min * std::cos(rotation.yaw) - y_min * std::sin(rotation.yaw);\n  auto x_rot_max = x_max * std::cos(rotation.yaw) - y_max * std::sin(rotation.yaw);\n  auto y_rot_min = x_min * std::sin(rotation.yaw) + y_min * std::cos(rotation.yaw);\n  auto y_rot_max = x_max * std::sin(rotation.yaw) + y_max * std::cos(rotation.yaw);\n  auto z_rot_min = z_min;\n  auto z_rot_max = z_max;\n  auto rot_bounds = std::make_shared<Bounds>(\n      frame,\n      std::vector<geom::Location>{\n          geom::Location{x_rot_min, y_rot_min, z_rot_min},\n          geom::Location{x_rot_max, y_rot_min, z_rot_min},\n          geom::Location{x_rot_max, y_rot_max, z_rot_min},\n          geom::Location{x_rot_min, y_rot_max, z_rot_min},\n          geom::Location{x_rot_min, y_rot_min, z_rot_max},\n          geom::", "CodeBleu_score": 39.85811361936054}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n    // Create a bounding box with the same dimensions as the parent bounding box.\n    const auto box = parent->GetBoundingBox();\n    const auto location = box.GetLocation() + transform.location;\n    const auto extent = box.GetExtent();\n    const auto yaw = transform.rotation.GetYaw();\n\n    // Compute the four corners of the bounding box by rotating the extents.\n    const auto x = extent.x;\n    const auto y = extent.y;\n    const auto z = extent.z;\n    const auto p1 = geom::Location(x, y, z);\n    const auto p2 = geom::Location(-x, y, z);\n    const auto p3 = geom::Location(x, -y, z);\n    const auto p4 = geom::Location(-x, -y, z);\n\n    // Rotate the corners of the bounding box.\n    const auto p1_rotated = geom::Rotate(p1, yaw, geom::Location());\n    const auto p2_rotated = geom::Rotate(p2, yaw, geom::Location());\n    const auto p3_rotated = geom::Rotate(p3, yaw, geom::Location());\n    const auto p4_rotated = geom::Rotate(p4, yaw, geom::Location());\n\n    // Compute the corners of the bounding box.\n    const auto p1_new = location + p1_rotated;\n    const auto p2_new = location + p2_rotated;\n    const auto p3_new = location + p3_rotated;\n    const auto p4_new = location + p4_rotated;\n\n    // Return a shared pointer to a Bounds object containing the frame number and the four corners.\n    return std::make_shared<Bounds>(frame, p1_new, p2_new, p3_new, p4_new);\n}", "CodeBleu_score": 45.34776106700016}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto &extent = GetExtent();\n  const auto &location = transform.location;\n  const auto &rotation = transform.rotation;\n  const auto &forward_vector = rotation.GetForwardVector();\n  const auto &right_vector = rotation.GetRightVector();\n  const auto &up_vector = rotation.GetUpVector();\n\n  const auto &min_x = location.x - extent.x;\n  const auto &max_x = location.x + extent.x;\n  const auto &min_y = location.y - extent.y;\n  const auto &max_y = location.y + extent.y;\n  const auto &min_z = location.z - extent.z;\n  const auto &max_z = location.z + extent.z;\n\n  const auto &min_x_new = min_x + forward_vector.x * extent.z + up_vector.x * extent.y;\n  const auto &max_x_new = max_x + forward_vector.x * extent.z + up_vector.x * extent.y;\n  const auto &min_y_new = min_y + forward_vector.y * extent.z + up_vector.y * extent.y;\n  const auto &max_y_new = max_y + forward_vector.y * extent.z + up_vector.y * extent.y;\n  const auto &min_z_new = min_z + forward_vector.z * extent.z + up_vector.z * extent.y;\n  const auto &max_z_new = max_z + forward_vector.z * extent.z + up_vector.z * extent.y;\n\n  const auto &min_x_rotated = min_x_new + right_vector.x * extent.x;\n  const auto &max_x_rotated = max_x_new + right_vector.x * extent.x;\n  const auto &min_y_rotated = min_y_new + right_vector.y * extent.y;\n  const auto &max_y_rotated = max_y_new + right_vector.y * extent.y;\n  const auto", "CodeBleu_score": 38.20692825126004}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto lights = _simulator->GetWorld()->GetLightManager().GetLights();\n  for (auto &light : lights) {\n    auto it = _lights.find(light.first);\n    if (it == _lights.end()) {\n      _lights.insert(std::make_pair(light.first, std::make_shared<Light>(light.first, light.second)));\n    } else {\n      it->second->UpdateLightState(light.second);\n    }\n  }\n}", "CodeBleu_score": 36.060903250760965}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(mutex_);\n  auto lights_state = _simulator->GetWorld()->GetLights();\n  for (auto &light_state : lights_state) {\n    if (light_state.GetId() == 0) {\n      continue;\n    }\n    auto it = _lights.find(light_state.GetId());\n    if (it != _lights.end()) {\n      it->second.SetLightState(light_state);\n    } else {\n      _lights[light_state.GetId()] = Light(light_state);\n    }\n  }\n}", "CodeBleu_score": 35.161759568113524}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n\n  _lights.clear();\n\n  for (const auto &light_state : _simulator->GetLightStates()) {\n    _lights[light_state.first] = light_state.second;\n  }\n}", "CodeBleu_score": 21.533934361064155}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!dirty_) {\n    return;\n  }\n\n  if (discard_client) {\n    dirty_ = false;\n    return;\n  }\n\n  auto message = std::make_shared<carla::rpc::LightStateList>();\n  message->reserve(light_states_.size());\n  for (const auto &i : light_states_) {\n    message->push_back(i.second);\n  }\n\n  auto client = GetWorld().GetClient().lock();\n  if (client != nullptr) {\n    client->SendCommand(std::make_unique<carla::command::ApplyLightState>(message));\n  }\n\n  dirty_ = false;\n}", "CodeBleu_score": 39.138843735793195}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(mutex_);\n  if (dirty_) {\n    // Create the message\n    carla::client::detail::Simulator::LightStateList light_state_list;\n    for (auto &it : light_state_map_) {\n      light_state_list.push_back(it.second);\n    }\n\n    // Send the message\n    if (discard_client) {\n      simulator_.SetLightStateList(light_state_list);\n    } else {\n      simulator_.SetLightStateList(light_state_list, true);\n    }\n\n    // Clear the changes and reset the dirty flag\n    light_state_map_.clear();\n    dirty_ = false;\n  }\n}", "CodeBleu_score": 36.52392633420344}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(mutex);\n  if (dirty) {\n    std::vector<carla::client::LightState> light_states;\n    light_states.reserve(lights.size());\n    for (auto &light : lights) {\n      light_states.push_back(light.second.GetLightState());\n    }\n    if (discard_client) {\n      simulator->SetLightStates(light_states, true);\n    } else {\n      simulator->SetLightStates(light_states);\n    }\n    dirty = false;\n  }\n}", "CodeBleu_score": 38.34192652127774}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    LOG_ERROR(\"Sensor ID is not 'sensor.other.v2x_custom'\");\n    return;\n  }\n  LOG_INFO(\"Sending message to server: \" + message);\n  _episode->Send(message);\n}", "CodeBleu_score": 50.645860641235565}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_debug(\"sensor.other.v2x_custom\", \"Sensor ID does not match. Expected 'sensor.other.v2x_custom', received '{}'.\", GetId());\n    return;\n  }\n  log_debug(\"sensor.other.v2x_custom\", \"Sending message to episode.\");\n  try {\n    context->send(message);\n  }\n  catch (const std::exception& e) {\n    log_error(\"sensor.other.v2x_custom\", \"Failed to send message to episode: {}\", e.what());\n  }\n}", "CodeBleu_score": 47.609912866933804}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  carla::log_debug(\"Send\");\n  if (sensor_id != \"sensor.other.v2x_custom\") {\n    carla::log_warning(\"Sensor ID does not match\");\n    return;\n  }\n  carla::log_debug(\"Sending message\");\n  episode->Send(message);\n}", "CodeBleu_score": 44.41103744489658}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    if (tm_port != 0u) {\n      carla::traffic_manager::TrafficManager::GetInstance().RegisterVehicle(*this, tm_port);\n    }\n  } else {\n    carla::traffic_manager::TrafficManager::GetInstance().UnregisterVehicle(*this);\n  }\n}", "CodeBleu_score": 45.092310614140764}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    carla::client::detail::Simulator::RegisterVehicle(*this, tm_port);\n  } else {\n    carla::client::detail::Simulator::UnregisterVehicle(*this);\n  }\n}", "CodeBleu_score": 35.91634426415333}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    carla::client::detail::Simulator::GetInstance().RegisterVehicle(this, tm_port);\n  } else {\n    carla::client::detail::Simulator::GetInstance().UnregisterVehicle(this);\n  }\n}", "CodeBleu_score": 43.322957115962204}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t  walker = walker_actor.Get();\n  if (walker != nullptr) {\n    walker->GetActorDefinition().SetSimulatePhysics(false);\n    walker->GetActorDefinition().SetEnableGravity(false);\n    walker->GetActorDefinition().SetCollisionEnabled(false);\n    walker->GetActorDefinition().SetNotifyRigidBodyCollision(false);\n    walker->GetActorDefinition().SetNotifyVehicleCollision(false);\n    walker->GetActorDefinition().SetNotifyWalkerCollision(true);\n    walker->GetActorDefinition().SetNotifyInWater(false);\n    walker->GetActorDefinition().SetCanCharacterStepUpOn(false);\n    walker->GetActorDefinition().SetCanSweep(false);\n    walker->GetActorDefinition().SetWalkerBoneIndex(0);\n    walker->GetActorDefinition().SetWalkerBoneName(\"pelvis\");\n    walker->GetActorDefinition().SetWalkerBoneOffset({0, 0, 0});\n    walker->GetActorDefinition().SetWalkerBoneRotationOffset({0, 0, 0});\n    walker->GetActorDefinition().SetWalkerBoneScale({1, 1, 1});\n    walker->GetActorDefinition().SetWalkerBoneOffset({0, 0, 0});\n    walker->GetActorDefinition().SetWalkerBoneRotationOffset({0, 0, 0});\n    walker->GetActorDefinition().SetWalkerBoneScale({1, 1, 1});\n    walker->GetActorDefinition().SetWalkerBoneOffset({0, 0, 0});\n    walker->GetActorDefinition().SetWalkerBoneRotationOffset({0, 0, 0});\n    walker->GetActorDefinition().SetWalkerBoneScale({1, 1, 1});\n    walker->GetActorDefinition().SetWalkerBoneOffset({0, 0, 0});\n    walker->GetActorDefinition().", "CodeBleu_score": 24.108555667418223}, {"code": "void WalkerAIController::Start(){\n\t  _episode->RegisterActor(*this);\n  _walker = _episode->GetActor(_actor_id);\n  _walker->DisableCollision();\n  _walker->DisablePhysics();\n  _walker->SetAutopilot(true);\n  _walker->SetSimulatePhysics(false);\n  _walker->SetEnableGravity(false);\n  _walker->SetEnableWalkerControl(true);\n\n  _navigation = std::make_unique<carla::client::detail::WalkerNavigation>(_episode->GetWorld());\n  _navigation->RegisterWalker(*_walker);\n  _navigation->SetWalkerSpeed(_walker, _speed);\n}", "CodeBleu_score": 42.31871985571674}, {"code": "void WalkerAIController::Start(){\n\t\n  // Get the walker actor.\n  auto walker = GetWalker();\n\n  // Register the AI controller with the episode.\n  GetEpisode().RegisterActor(GetId(), walker);\n\n  // Disable physics and collisions for the walker.\n  walker->SetEnableGravity(false);\n  walker->SetSimulatePhysics(false);\n  walker->SetActorEnableCollision(false);\n\n  // Get the navigation system.\n  auto navigation = GetEpisode().GetNavigationSystem();\n\n  // Add the walker to the navigation system with its current location.\n  navigation->AddWalker(walker, GetLocation());\n}", "CodeBleu_score": 42.209697684751305}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (max_speed < 0.0f) {\n    return;\n  }\n  auto navigation = GetEpisode().Lock()->GetNavigation();\n  if (!navigation) {\n    return;\n  }\n  auto walker = navigation->GetWalker(GetId());\n  if (!walker) {\n    return;\n  }\n  walker->SetMaxSpeed(max_speed);\n}", "CodeBleu_score": 48.25142647310571}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (max_speed < 0.0f) {\n    throw_exception(std::invalid_argument(\"max_speed must be positive\"));\n  }\n  if (auto *nav = GetEpisode().GetNavigation()) {\n    if (auto *walker = nav->GetWalker(GetId())) {\n      walker->SetMaxSpeed(max_speed);\n    } else {\n      LOG_ERROR(\"Walker with id\", GetId(), \"not found\");\n    }\n  } else {\n    LOG_ERROR(\"Navigation not found\");\n  }\n}", "CodeBleu_score": 52.761288483855616}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\n  if (max_speed <= 0.0f) {\n    return;\n  }\n\n  if (auto walker_navigation = _episode->GetWalkerNavigation()) {\n\n    auto walker = walker_navigation->GetWalker(GetId());\n    if (walker != nullptr) {\n      walker_navigation->SetMaxSpeed(*walker, max_speed);\n    } else {\n      UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Walker not found!\"));\n    }\n  } else {\n    UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Navigation not found!\"));\n  }\n}", "CodeBleu_score": 56.1033296394874}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  auto waypoints = _parent.GetPrevious(_map_matched_waypoint, distance);\n  for (auto &waypoint : waypoints) {\n    result.push_back(MakeShared<Waypoint>(_parent, waypoint));\n  }\n  return result;\n}", "CodeBleu_score": 63.71925892430097}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  auto waypoints = _map->GetPrevious(*this, distance);\n  for (auto &wp : waypoints) {\n    result.push_back(MakeShared<Waypoint>(_map, wp));\n  }\n  return result;\n}", "CodeBleu_score": 55.47877504796862}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  auto parent = GetParent();\n  if (parent == nullptr) {\n    return result;\n  }\n  auto waypoints = parent->GetWaypoints(GetTransform().location, distance);\n  for (auto &wp : waypoints) {\n    result.push_back(MakeShared<Waypoint>(wp, parent));\n  }\n  return result;\n}", "CodeBleu_score": 56.441211863191796}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t    std::vector<SharedPtr<Landmark>> landmarks;\n    std::unordered_set<SharedPtr<Signal>> signals;\n    GetSignalsInDistance(signals, distance, stop_at_junction);\n    for (auto &signal : signals) {\n      auto landmark = GetMap().GetLandmark(signal->GetId());\n      if (landmark != nullptr) {\n        landmarks.push_back(landmark);\n      }\n    }\n    return landmarks;\n  }", "CodeBleu_score": 37.08555099678078}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::unordered_set<SharedPtr<Signal>> signals_in_distance = GetSignalsInDistance(distance, stop_at_junction);\n  for (auto &signal : signals_in_distance) {\n    if (signal->GetType() == Signal::Type::Landmark) {\n      auto landmark = boost::static_pointer_cast<Landmark>(signal);\n      if (std::find(result.begin(), result.end(), landmark) == result.end()) {\n        result.push_back(landmark);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 44.399482749242814}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> landmarks;\n  std::unordered_set<SharedPtr<Signal>> signals;\n  std::vector<SharedPtr<Signal>> signals_in_distance = GetSignalsInDistance(distance, stop_at_junction);\n  for (auto &s : signals_in_distance) {\n    if (signals.find(s) == signals.end()) {\n      SharedPtr<Landmark> landmark = s->GetParent();\n      landmarks.push_back(landmark);\n      signals.insert(s);\n    }\n  }\n  return landmarks;\n}", "CodeBleu_score": 39.98641254214314}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  return _client.ApplySettings(settings, timeout);\n}", "CodeBleu_score": 9.8559846623171}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  if (settings.synchronous_mode) {\n    timeout = settings.fixed_delta_seconds.value_or(timeout);\n  }\n  auto id = _client.ApplySettings(settings, timeout);\n  if (settings.synchronous_mode) {\n    _synchronous_time_out = settings.fixed_delta_seconds.value_or(timeout);\n  }\n  return id;\n}", "CodeBleu_score": 17.376859520288484}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  // Apply the settings.\n  uint64_t result = _client.ApplyEpisodeSettings(settings, timeout);\n  if (result == 0u) {\n    return 0u;\n  }\n  // Verify the settings.\n  const size_t TICKS_TO_VERIFY = 10u;\n  for (size_t i = 0u; i < TICKS_TO_VERIFY; ++i) {\n    time_duration wait_time = settings.synchronous_mode ? 0s : timeout;\n    _client.Tick(wait_time);\n    if (settings.fixed_delta_seconds.has_value()) {\n      const auto delta_seconds = settings.fixed_delta_seconds.value();\n      if (delta_seconds != _client.GetEpisodeSettings().fixed_delta_seconds) {\n        log_warning(\"Applied delta seconds\", delta_seconds, \"but got\", _client.GetEpisodeSettings().fixed_delta_seconds);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 44.943841263179564}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  [](const geom::Vector2D &point, const geom::Vector2D &segment_start, const geom::Vector2D &segment_end) {\n    const auto segment_length_squared = geom::LengthSquared(segment_end - segment_start);\n    if (segment_length_squared == 0.0f) {\n      return std::make_pair(0.0f, geom::Length(point - segment_start));\n    }\n    const auto t = std::clamp(\n        (point - segment_start).Dot(segment_end - segment_start) / segment_length_squared,\n        0.0f, 1.0f);\n    const auto projection = segment_start + t * (segment_end - segment_start);\n    return std::make_pair(\n        geom::Length(projection - point),\n        geom::Length(projection - point) * t);\n  }\n}", "CodeBleu_score": 43.881525666069024}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  [](const geom::Vector2D &point, const geom::Vector2D &segment_begin, const geom::Vector2D &segment_end) {\n    const auto segment_length = segment_end - segment_begin;\n    const auto segment_length_squared = segment_length.LengthSquared();\n    if (segment_length_squared == 0.0f) {\n      return std::make_pair(0.0f, (point - segment_begin).Length());\n    }\n    const auto segment_direction = segment_length.Normalize();\n    const auto projection = segment_direction * (segment_length * (point - segment_begin) / segment_length_squared);\n    const auto distance_to_projection = (point - projection).Length();\n    const auto distance_to_segment = distance_to_projection / segment_length.Length();\n    return std::make_pair(distance_to_segment, distance_to_projection);\n  }\n}", "CodeBleu_score": 43.48756013894027}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\n  float a = 0.f;\n  float b = 0.f;\n\n  float d = 0.f;\n  float s = 0.f;\n\n  float sqrLength = 0.f;\n  float length = 0.f;\n\n  float t = 0.f;\n  float tSqr = 0.f;\n  float tSqr1 = 0.f;\n\n  float px = 0.f;\n  float py = 0.f;\n\n  float qx = 0.f;\n  float qy = 0.f;\n\n  float rx = 0.f;\n  float ry = 0.f;\n\n  float dx = 0.f;\n  float dy = 0.f;\n\n  float sx = 0.f;\n  float sy = 0.f;\n\n  float dSqr = 0.f;\n  float d = 0.f;\n\n  float sSqr = 0.f;\n  float s = 0.f;\n\n  float tSqr = 0.f;\n  float t = 0.f;\n\n  float tSqr1 = 0.f;\n\n  float px = 0.f;\n  float py = 0.f;\n\n  float qx = 0.f;\n  float qy = 0.f;\n\n  float rx = 0.f;\n  float ry = 0.f;\n\n  float dx = 0.f;\n  float dy = 0.f;\n\n  float sx = 0.f;\n  float sy = 0.f;\n\n  float dSqr = 0.f;\n  float d = 0.f;\n\n  float sSqr = 0.f;\n  float s = 0.f;\n\n  float tSqr = 0.f;\n  float t = 0.f;\n\n  float tSqr1 = 0.f;\n\n  float px = 0.f;\n  float py", "CodeBleu_score": 24.991046798734622}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  assert(vertices.size() > 2u);\n  const size_t initial_index = _vertices.size();\n  _vertices.insert(_vertices.end(), vertices.begin(), vertices.end());\n  for (size_t i = 0u; i < vertices.size() - 2u; ++i) {\n    _indices.push_back(initial_index);\n    _indices.push_back(initial_index + i + 1u);\n    _indices.push_back(initial_index + i + 2u);\n  }\n}", "CodeBleu_score": 51.563351836723584}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    assert(vertices.size() >= 3);\n    const size_t initial_index = _vertices.size();\n    for (size_t i = 0; i < vertices.size(); ++i) {\n        _vertices.push_back(vertices[i]);\n    }\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n        _indices.push_back(initial_index);\n        _indices.push_back(initial_index + i);\n        _indices.push_back(initial_index + i + 1);\n    }\n}", "CodeBleu_score": 52.012838040726585}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  assert(vertices.size() >= 3);\n  const auto initial_index = _vertices.size();\n  for (size_t i = 0; i < vertices.size(); ++i) {\n    _vertices.push_back(vertices[i]);\n    _indices.push_back(initial_index);\n    if (i + 1 < vertices.size()) {\n      _indices.push_back(initial_index + i + 1);\n      _indices.push_back(initial_index + i);\n    }\n  }\n}", "CodeBleu_score": 49.73342543706691}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message == nullptr) {\n    LogError(\"Primary::Write: message is null\");\n    return;\n  }\n  if (message->size() == 0) {\n    LogError(\"Primary::Write: message has zero size\");\n    return;\n  }\n\n  // Ensure the message is valid\n  if (!message->valid()) {\n    LogError(\"Primary::Write: message is invalid\");\n    return;\n  }\n\n  // Post the lambda to the strand\n  boost::asio::post(_strand, [this, message]() {\n    // Check if the socket is open\n    if (!_socket.is_open()) {\n      LogError(\"Primary::Write: socket is not open\");\n      return;\n    }\n\n    // Set the timeout\n    _timer.expires_from_now(std::chrono::seconds(10));\n\n    // Initiate the asynchronous write\n    boost::asio::async_write(\n        _socket,\n        boost::asio::buffer(message->data(), message->size()),\n        _strand.wrap(\n            boost::asio::bind_executor(\n                _strand,\n                std::bind(\n                    &Primary::handle_sent,\n                    this,\n                    std::placeholders::_1,\n                    std::placeholders::_2,\n                    message))));\n  });\n}", "CodeBleu_score": 34.68139328977172}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message->Validate()) {\n    auto self = shared_from_this();\n    auto lambda = [this, self, message]() {\n      if (IsOpen()) {\n        boost::asio::async_write(\n            _socket,\n            boost::asio::buffer(message->Data(), message->Size()),\n            boost::asio::bind_executor(_strand,\n              [this, self, message](boost::system::error_code ec, std::size_t) {\n                if (ec) {\n                  CARLA_LOG_ERROR(\"Write failed: \", ec.message());\n                  Close();\n                } else {\n                  HandleSent(message);\n                }\n              }));\n      }\n    };\n    boost::asio::post(_strand, std::move(lambda));\n  }\n}", "CodeBleu_score": 38.89386836955192}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message == nullptr) {\n    return;\n  }\n\n  if (!IsOpen()) {\n    return;\n  }\n\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  if (!IsOpen()) {\n    return;\n  }\n\n  if (!message->IsValid()) {\n    return;\n  }\n\n  _strand.post(\n      [this, message]() {\n        if (!IsOpen()) {\n          return;\n        }\n\n        if (!message->IsValid()) {\n          return;\n        }\n\n        _socket.async_write_some(\n            boost::asio::buffer(message->GetData(), message->GetSize()),\n            boost::asio::bind_executor(\n                _strand,\n                std::bind(\n                    &Primary::HandleSent,\n                    this,\n                    std::placeholders::_1,\n                    std::placeholders::_2,\n                    message)));\n      });\n}", "CodeBleu_score": 32.43822391957436}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if (timer.cancel()) {\n    LOG_INFO(\"primary\", \"cancelled timer\");\n  }\n  if (socket.is_open()) {\n    LOG_INFO(\"primary\", \"attempting to shut down and close socket\");\n    boost::system::error_code ignored_ec;\n    socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n    socket.close(ignored_ec);\n  }\n  if (ec) {\n    LOG_INFO(\"primary\", \"error closing socket\");\n  }\n  LOG_INFO(\"primary\", \"session closed\");\n  on_closed();\n}", "CodeBleu_score": 52.09775633980613}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if(ec == boost::asio::error::operation_aborted) {\n    return;\n  }\n  if(socket.is_open()) {\n    boost::system::error_code ignored_ec;\n    socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n    socket.close(ignored_ec);\n  }\n  if(ec) {\n    LOG_ERROR(\"Error closing socket: \", ec.message());\n  }\n  LOG_INFO(\"Session closed\");\n  on_closed(ec);\n}", "CodeBleu_score": 53.22511070637904}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if (timer_.cancel()) {\n    if (socket_.is_open()) {\n      boost::system::error_code ignored_ec;\n      socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n      socket_.close(ignored_ec);\n    }\n  }\n  if (on_closed_) {\n    on_closed_(ec);\n  }\n  CARLA_LOG_INFO(\"Session closed\");\n}", "CodeBleu_score": 56.35960017435806}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t  // Create the message\n  auto message = carla::streaming::detail::tcp::Message::Make(\n      carla::streaming::detail::tcp::MessageType::YOU_ALIVE,\n      carla::streaming::detail::Token{},\n      carla::streaming::detail::BufferView{});\n\n  // Log the sending\n  CARLA_LOG_INFO(\"Sending message \\\"Are you alive?\\\"\");\n\n  // Write the message\n  _router->Write(std::move(message));\n\n  // Wait for the response\n  auto response = _router->Read();\n\n  // Log the response\n  CARLA_LOG_INFO(\"Received response \\\"I am alive!\\\"\");\n}", "CodeBleu_score": 35.971070684662045}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  carla::streaming::detail::tcp::Message message;\n  message.write(carla::streaming::detail::YOU_ALIVE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOKEN_NONE);\n  message.write(carla::streaming::detail::TOK", "CodeBleu_score": 18.218370514437453}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  carla::streaming::detail::tcp::Message<carla::streaming::detail::Command> msg;\n  msg.header.command = carla::streaming::detail::Command::YOU_ALIVE;\n  msg.header.size = 0;\n  carla::streaming::detail::tcp::Buffer buffer = msg.ToBuffer();\n  LOG_DEBUG(\"Sending \\\"Are you alive?\\\" to the system\");\n  LOG_DEBUG(\"Sending \\\"Are you alive?\\\" to the system: \" + buffer.to_string());\n  _router->Write(buffer);\n  LOG_DEBUG(\"Waiting for the response from the system\");\n  _router->Read();\n}", "CodeBleu_score": 43.367621353318206}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  // Check if the sensor has been activated on any secondary server\n  if (primary.GetSensorActivation(sensor_id) == 0) {\n    // If not, log an error message\n    std::cout << \"Sensor \" << sensor_id << \" not activated on any secondary server.\" << std::endl;\n  } else {\n    // If it has, create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router\n    carla::streaming::detail::tcp::Message message;\n    message.Add(static_cast<uint8_t>(carla::multigpu::Command::ENABLE_ROS));\n    message.Add(sensor_id);\n    router.Send(message);\n\n    // Wait for and process the server's response\n    carla::streaming::detail::tcp::Message response = router.Wait();\n    if (response.GetCommand() == carla::multigpu::Command::ENABLE_ROS) {\n      // If the response is a successful ENABLE_ROS response, log a success message\n      std::cout << \"Sensor \" << sensor_id << \" enabled on secondary server.\" << std::endl;\n    } else {\n      // If the response is not a successful ENABLE_ROS response, log an error message\n      std::cout << \"Sensor \" << sensor_id << \" not enabled on secondary server.\" << std::endl;\n    }\n  }\n}", "CodeBleu_score": 44.687489364385065}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  std::string sensor_name = carla::streaming::detail::SensorName(sensor_id);\n  std::string sensor_type = carla::streaming::detail::SensorType(sensor_id);\n  std::string sensor_role = carla::streaming::detail::SensorRole(sensor_id);\n\n  // Check if sensor is enabled on any secondary server\n  if (carla::multigpu::primary::IsSensorEnabledOnAnyServer(sensor_id)) {\n    carla::multigpu::primary::SendCommandToAllServers(\n      carla::multigpu::commands::ENABLE_ROS,\n      sensor_id);\n\n    // Wait for and process response\n    carla::multigpu::primary::WaitForAndProcessResponse();\n  }\n  else {\n    std::cout << \"Sensor \" << sensor_name << \" of type \" << sensor_type << \" with role \" << sensor_role << \" is not enabled on any secondary server.\" << std::endl;\n  }\n}", "CodeBleu_score": 31.41057460681937}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  if (primary_->IsROSEnabled(sensor_id)) {\n    std::stringstream ss;\n    ss << \"Sensor \" << sensor_id << \" is already enabled for ROS.\";\n    CARLA_LOG_INFO(\"carla.multigpu\", ss.str());\n    return;\n  }\n\n  auto found = false;\n  for (auto& s : primary_->GetSecondaries()) {\n    if (s->IsROSEnabled(sensor_id)) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    std::stringstream ss;\n    ss << \"Sensor \" << sensor_id << \" is not enabled for ROS.\";\n    CARLA_LOG_ERROR(\"carla.multigpu\", ss.str());\n    return;\n  }\n\n  carla::streaming::detail::tcp::Message message;\n  message.Set(carla::streaming::detail::tcp::Command::ENABLE_ROS);\n  message.Add(sensor_id);\n\n  auto response = router_->Send(message);\n  if (response.GetCommand() != carla::streaming::detail::tcp::Command::ENABLE_ROS) {\n    CARLA_LOG_ERROR(\"carla.multigpu\", \"Invalid response to ENABLE_ROS.\");\n    return;\n  }\n\n  if (response.GetData().size() != 1u) {\n    CARLA_LOG_ERROR(\"carla.multigpu\", \"Invalid response to ENABLE_ROS.\");\n    return;\n  }\n\n  if (response.GetData()[0] != 1u) {\n    std::stringstream ss;\n    ss << \"Sensor \" << sensor_id << \" failed to enable for ROS.\";\n    CARLA_LOG_ERROR(\"carla.multigpu\", ss.str());\n    return;\n  }\n\n  primary_->EnableROS(sensor_id);\n}", "CodeBleu_score": 41.966950746374735}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\n  // Check if the sensor is already activated\n  if (primary.IsSensorActivated(sensor_id)) {\n    std::cout << \"Sensor \" << sensor_id << \" already activated\" << std::endl;\n    return primary.GetToken(sensor_id);\n  }\n\n  // Enable the sensor on a secondary server\n  std::cout << \"Enabling sensor \" << sensor_id << std::endl;\n  router.EnableSensor(sensor_id);\n\n  // Retrieve a new token\n  std::cout << \"Retrieving token for sensor \" << sensor_id << std::endl;\n  token_type token = router.GetToken(sensor_id);\n\n  // Update the maps\n  std::cout << \"Updating maps for sensor \" << sensor_id << std::endl;\n  primary.UpdateMap(sensor_id, token);\n\n  // Log the action\n  std::cout << \"Logging action for sensor \" << sensor_id << std::endl;\n  primary.LogAction(sensor_id, token);\n\n  return token;\n}", "CodeBleu_score": 37.52269388302053}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  auto it = _streams.find(sensor_id);\n  if (it != _streams.end()) {\n    _logger->info(\"Retrieving existing token for sensor {}\", sensor_id);\n    return it->second.token;\n  }\n  _logger->info(\"Enabling sensor {}\", sensor_id);\n  auto token = _router->Enable(sensor_id);\n  _streams.emplace(sensor_id, Stream{token, std::chrono::steady_clock::now()});\n  return token;\n}", "CodeBleu_score": 45.285516858258134}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    _logger->info(\"Sensor {} already activated. Returning existing token.\", sensor_id);\n    return it->second;\n  } else {\n    _logger->info(\"Sensor {} not activated. Enabling on secondary server and retrieving token.\", sensor_id);\n    auto token = _router->EnableSensor(sensor_id);\n    _tokens.emplace(sensor_id, token);\n    _logger->info(\"Sensor {} activated. New token is {}.\", sensor_id, token);\n    return token;\n  }\n}", "CodeBleu_score": 54.846441039993884}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  std::vector<char> file_data((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n  file.close();\n  return Load(file_data);\n}", "CodeBleu_score": 57.85790210054175}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file) {\n    return false;\n  }\n  file.seekg(0, std::ios::end);\n  std::streamsize size = file.tellg();\n  file.seekg(0, std::ios::beg);\n  std::vector<char> data(size);\n  file.read(data.data(), size);\n  file.close();\n  return Load(data);\n}", "CodeBleu_score": 54.327963461725815}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n\n  std::vector<uint8_t> file_data((std::istreambuf_iterator<char>(file)),\n                                 std::istreambuf_iterator<char>());\n  file.close();\n\n  return Load(file_data);\n}", "CodeBleu_score": 58.36499817722749}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (IsReady()) {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (auto it = walker_manager.FindAgent(id)) {\n      crowd->removeAgent(*it);\n      walker_manager.RemoveAgent(id);\n      return true;\n    } else if (auto it = vehicle_manager.FindAgent(id)) {\n      crowd->removeAgent(*it);\n      vehicle_manager.RemoveAgent(id);\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 41.146228300221}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (ready) {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (crowd != nullptr) {\n      if (walker_manager.Contains(id)) {\n        walker_manager.Remove(id);\n      } else if (vehicle_manager.Contains(id)) {\n        vehicle_manager.Remove(id);\n      } else {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 33.20050495444386}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (!IsReady()) {\n    return false;\n  }\n\n  std::lock_guard<std::mutex> lock(mutex);\n\n  auto walker_it = walker_map.find(id);\n  auto vehicle_it = vehicle_map.find(id);\n\n  if (walker_it != walker_map.end()) {\n    crowd->RemoveWalker(walker_it->second);\n    walker_map.erase(walker_it);\n    walker_manager.RemoveAgent(id);\n    return true;\n  } else if (vehicle_it != vehicle_map.end()) {\n    crowd->RemoveVehicle(vehicle_it->second);\n    vehicle_map.erase(vehicle_it);\n    vehicle_manager.RemoveAgent(id);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 56.98158888891134}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t  std::set<int> currentVehicles;\n  for (auto &v : _vehicles) {\n    currentVehicles.insert(v.first);\n  }\n\n  for (auto &v : vehicles) {\n    if (currentVehicles.find(v.id) != currentVehicles.end()) {\n      _vehicles[v.id].Update(v);\n    } else {\n      _vehicles[v.id] = v;\n    }\n    _vehicles[v.id].updated = true;\n  }\n\n  for (auto &v : _vehicles) {\n    if (!v.second.updated) {\n      _vehicles.erase(v.first);\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 56.28222760870203}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n  std::set<uint32_t> current_vehicles;\n\n  for (auto it = _vehicles.begin(); it != _vehicles.end(); ++it) {\n    current_vehicles.insert(it->first);\n  }\n\n  for (auto it = vehicles.begin(); it != vehicles.end(); ++it) {\n    if (current_vehicles.find(it->id) != current_vehicles.end()) {\n      _vehicles[it->id].Update(it->state);\n    } else {\n      _vehicles[it->id].Update(it->state);\n      _vehicles[it->id].SetUpdated(true);\n    }\n  }\n\n  for (auto it = _vehicles.begin(); it != _vehicles.end(); ++it) {\n    if (!it->second.IsUpdated()) {\n      _vehicles.erase(it->first);\n    }\n  }\n\n  return true;\n\n}", "CodeBleu_score": 49.17020208878304}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n  std::set<uint32_t> ids;\n  for (auto& v : _vehicles) {\n    ids.insert(v.first);\n  }\n\n  for (auto& v : vehicles) {\n    if (ids.find(v.id) != ids.end()) {\n      _vehicles[v.id].Update(v);\n    } else {\n      _vehicles[v.id] = v;\n    }\n    _vehicles[v.id].updated = true;\n  }\n\n  for (auto& v : _vehicles) {\n    if (!v.second.updated) {\n      _vehicles.erase(v.first);\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 55.71275015696621}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n  // Check if the actor is a walker.\n  auto it = _walkers.find(id);\n  if (it != _walkers.end()) {\n    return _walker_manager->HasVehicleNear(it->second, distance, direction);\n  }\n\n  // Check if the actor is a vehicle.\n  it = _vehicles.find(id);\n  if (it != _vehicles.end()) {\n    return _walker_manager->HasVehicleNear(it->second, distance, direction);\n  }\n\n  // If the actor is not found, return false.\n  return false;\n}", "CodeBleu_score": 50.381186025556325}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n  WalkerManager::WalkerPtr walker = WalkerManager::GetInstance()->GetWalker(id);\n\n  if (walker != nullptr) {\n\n    return walker->HasVehicleNear(distance, direction);\n\n  } else {\n\n    auto vehicle = WalkerManager::GetInstance()->GetVehicle(id);\n\n    if (vehicle != nullptr) {\n\n      return vehicle->HasVehicleNear(distance, direction);\n\n    } else {\n\n      return false;\n\n    }\n  }\n}", "CodeBleu_score": 42.53598679812859}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  bool result = false;\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Check if the actor is a walker\n  auto it = _walkers.find(id);\n  if (it != _walkers.end()) {\n    auto &walker = it->second;\n    // Check if the actor is a vehicle\n    auto it2 = _vehicles.find(id);\n    if (it2 != _vehicles.end()) {\n      auto &vehicle = it2->second;\n      // Check if the actor is a pedestrian\n      auto it3 = _pedestrians.find(id);\n      if (it3 != _pedestrians.end()) {\n        auto &pedestrian = it3->second;\n        // Check if the actor is a traffic light\n        auto it4 = _traffic_lights.find(id);\n        if (it4 != _traffic_lights.end()) {\n          auto &traffic_light = it4->second;\n          // Check if the actor is a traffic sign\n          auto it5 = _traffic_signs.find(id);\n          if (it5 != _traffic_signs.end()) {\n            auto &traffic_sign = it5->second;\n            // Check if the actor is a intersection\n            auto it6 = _intersections.find(id);\n            if (it6 != _intersections.end()) {\n              auto &intersection = it6->second;\n              // Check if the actor is a lane\n              auto it7 = _lanes.find(id);\n              if (it7 != _lanes.end()) {\n                auto &lane = it7->second;\n                // Check if the actor is a junction\n                auto it8 = _junctions.find(id);\n                if (it8 != _junctions.end()) {\n                  auto &junction = it8->second;\n                  // Check if the actor is a road\n                  auto it9 = _roads.find(id);\n                  if (it9 != _roads.end()) {\n                    auto &road = it9->second;\n                    //", "CodeBleu_score": 43.63084525716366}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\n  WalkerEventVisitor visitor(delta, id, info.route, info.route_index, info.last_location, info.last_rotation);\n  return boost::apply_visitor(visitor, info.event);\n}", "CodeBleu_score": 48.3219456538102}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  WalkerEventVisitor visitor(id, info, delta);\n  return boost::apply_visitor(visitor, info.event);\n}", "CodeBleu_score": 33.93814590680553}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  auto &walker = info.walker;\n  auto &route = info.route;\n  auto &route_point = info.route_point;\n\n  auto current_route_point = route.GetRoutePoint(route_point);\n  auto current_waypoint = walker->GetWaypoint(current_route_point);\n\n  WalkerEventVisitor visitor{*this, walker, current_route_point, current_waypoint, delta};\n  auto result = boost::variant2::visit(visitor, info.event);\n\n  if (result == EventResult::Success) {\n    route_point++;\n    if (route_point == route.GetRouteLength()) {\n      route_point = 0u;\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 43.98828547127188}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  pugi::xml_node road_node = xml.child(\"road\");\n  std::string id = road_node.attribute(\"id\").as_string();\n  map_builder.SetRoadId(id);\n  pugi::xml_node lanes_node = road_node.child(\"lanes\");\n  for (pugi::xml_node lane_section_node = lanes_node.child(\"laneSection\");\n      lane_section_node;\n      lane_section_node = lane_section_node.next_sibling(\"laneSection\")) {\n    std::string s_id = lane_section_node.attribute(\"id\").as_string();\n    double s = lane_section_node.attribute(\"s\").as_double();\n    double a = lane_section_node.attribute(\"a\").as_double();\n    double b = lane_section_node.attribute(\"b\").as_double();\n    double c = lane_section_node.attribute(\"c\").as_double();\n    double d = lane_section_node.attribute(\"d\").as_double();\n    double e = lane_section_node.attribute(\"e\").as_double();\n    double f = lane_section_node.attribute(\"f\").as_double();\n    double length = lane_section_node.attribute(\"length\").as_double();\n    map_builder.AddLaneSection(s_id, s, a, b, c, d, e, f, length);\n    ParseLanes(lane_section_node, map_builder);\n  }\n}", "CodeBleu_score": 53.85557708436779}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  // Iterate through each road node\n  for (auto road : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\n    // Extract the road ID\n    auto road_id = road.attribute(\"id\").as_int();\n\n    // Iterate through each lane section node\n    for (auto lane_section : road.children(\"lanes\")) {\n\n      // Extract the lane section ID\n      auto lane_section_id = lane_section.attribute(\"id\").as_int();\n\n      // Extract the left, center, and right lane nodes\n      auto left_lane = lane_section.child(\"left\");\n      auto center_lane = lane_section.child(\"center\");\n      auto right_lane = lane_section.child(\"right\");\n\n      // Parse the lanes\n      ParseLanes(left_lane, map_builder, road_id, lane_section_id, true);\n      ParseLanes(center_lane, map_builder, road_id, lane_section_id, false);\n      ParseLanes(right_lane, map_builder, road_id, lane_section_id, false);\n    }\n  }\n}", "CodeBleu_score": 46.140346405311014}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  pugi::xml_node road_node = xml.child(\"OpenDRIVE\").child(\"road\");\n  while (road_node != nullptr) {\n    std::string road_id = road_node.attribute(\"id\").as_string();\n\n    pugi::xml_node lane_section_node = road_node.child(\"lanes\");\n    while (lane_section_node != nullptr) {\n      std::vector<pugi::xml_node> lane_nodes;\n      lane_nodes.push_back(lane_section_node.child(\"lane\"));\n      lane_nodes.push_back(lane_section_node.child(\"left\"));\n      lane_nodes.push_back(lane_section_node.child(\"right\"));\n\n      ParseLanes(lane_nodes, map_builder, road_id);\n\n      lane_section_node = lane_section_node.next_sibling(\"lanes\");\n    }\n\n    road_node = road_node.next_sibling(\"road\");\n  }\n}", "CodeBleu_score": 40.362105064010194}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    std::cout << \"CarlaListenerImpl::on_publication_matched\" << std::endl;\n    if (info.current_count_change == 1) {\n        std::cout << \"New match\" << std::endl;\n        matched = true;\n        first_connection = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Match lost\" << std::endl;\n        matched = false;\n    } else {\n        std::cerr << \"Invalid count change \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 59.22503375174164}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\n    if (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched\" << std::endl;\n        m_matched = true;\n        m_firstConnection = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched\" << std::endl;\n        m_matched = false;\n    } else {\n        std::cout << \"Invalid count change \" << info.current_count_change << std::endl;\n    }\n\n    m_matchedCount = info.current_count_change;\n}", "CodeBleu_score": 63.89347448113789}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched = true;\n        std::cout << \"Subscriber matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n    } else {\n        std::cerr << \"Invalid publication matched status change.\" << std::endl;\n    }\n}", "CodeBleu_score": 55.95717100771632}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    if (info.total_count == 1) {\n      std::cout << \"Subscriber matched.\" << std::endl;\n      this->first_connected = true;\n    } else {\n      std::cout << \"Subscriber matched, count: \" << info.total_count << std::endl;\n    }\n  } else if (info.current_count_change == -1) {\n    std::cout << \"Subscriber unmatched, count: \" << info.total_count << std::endl;\n    if (info.total_count == 0) {\n      std::cout << \"Subscriber destroyed.\" << std::endl;\n      this->first_connected = false;\n      this->subscriber.reset();\n    }\n  } else {\n    std::cout << \"Subscriber changed count: \" << info.current_count_change << std::endl;\n  }\n  this->matched_count = info.total_count;\n}", "CodeBleu_score": 59.105769699839605}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    ++matched_count;\n    std::cout << \"Subscription matched \" << matched_count << std::endl;\n    if (matched_count == 1) {\n      first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    --matched_count;\n    std::cout << \"Subscription unmatched \" << matched_count << std::endl;\n    if (matched_count == 0) {\n      std::cout << \"Destroying subscriber \" << std::endl;\n      delete this;\n    }\n  } else {\n    std::cerr << \"Invalid count change \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 58.060250241578835}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    std::cout << \"Subscription matched for topic: \" << reader->get_topicdescription()->get_name() << \" with guid: \" << info.current_count_change << std::endl;\n    if (info.current_count_change == 1) {\n        ++matched_count;\n        if (matched_count == 1) {\n            first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        --matched_count;\n        if (matched_count == 0) {\n            first_connected = false;\n        }\n    } else {\n        std::cerr << \"Invalid count change detected: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 53.42533104312188}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    *handle = p_type->handle;\n    return true;\n}", "CodeBleu_score": 11.304109670289863}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_get_key) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    m_get_key(p_type, handle, force_md5);\n    return true;\n}", "CodeBleu_score": 15.967903089496085}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    bool result = false;\n    if (m_getKey) {\n        result = m_getKey(data, handle, force_md5);\n    }\n    return result;\n}", "CodeBleu_score": 10.798450536075906}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    FastBuffer fastbuffer((char*)payload->data, payload->max_size);\n    Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness();\n    payload->length = 0; //the length will be computed by the serializer\n    // Serialize encapsulation\n    p_type->serialize(ser);\n    if (ser.length() >= 0) {\n        payload->length = ser.length();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 51.46732907952604}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    FastBuffer fastbuffer((char*)payload->data, payload->max_size); // Object that manages the raw buffer.\n    Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness(); // Set encapsulation.\n    // Serialize encapsulation\n    ser.serialize(payload->encapsulation);\n\n\n    try {\n        // Serialize the object:\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    payload->length = (uint32_t)ser.getSerializedDataLength(); // Get the serialized length\n    return true;\n}", "CodeBleu_score": 65.91964437317685}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    FastBuffer fastbuffer{(uint8_t*)payload->data, payload->max_size}; // Object that manages the raw buffer.\n    Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness(); // Set encapsulation.\n    try {\n        p_type->serialize(ser); // Serialize the object.\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n    payload->length = (uint32_t)ser.getSerializedDataLength(); // Get the serialized length.\n    return true;\n}", "CodeBleu_score": 64.52252165524722}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// Check if target is already set\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// Check if message type is a message that should be tracked\n\tif (msg.msgid != MAVLINK_MSG_ID_VFR_HUD &&\n\t\tmsg.msgid != MAVLINK_MSG_ID_GLOBAL_POSITION_INT &&\n\t\tmsg.msgid != MAVLINK_MSG_ID_SYS_STATUS &&\n\t\tmsg.msgid != MAVLINK_MSG_ID_POWER_STATUS &&\n\t\tmsg.msgid != MAVLINK_MSG_ID_SYSTEM_TIME) {\n\t\treturn;\n\t}\n\n\t// Check if target system ID is set\n\tif (target_sysid == 0) {\n\t\t// Set target system ID\n\t\ttarget_sysid = msg.sysid;\n\n\t\t// Request position and air pressure data streams from target\n\t\tmavlink_message_t msg_req;\n\t\tmavlink_msg_request_data_stream_pack(target_sysid, target_compid, &msg_req, MAVLINK_DATA_STREAM_POSITION, 1, MAV_DATA_STREAM_HIGH_LATENCY);\n\t\tmavlink_msg_request_data_stream_pack(target_sysid, target_compid, &msg_req, MAVLINK_DATA_STREAM_AIR_PRESSURE, 1, MAV_DATA_STREAM_HIGH_LATENCY);\n\t\tmavlink_msg_request_data_stream_pack(target_sysid, target_compid, &msg_req, MAVLINK_DATA_STREAM_SYSTEM_TIME, 1, MAV_DATA_STREAM_HIGH_LATENCY);\n\t\tmavlink_send_message(target_sysid, &msg_req);\n\n\t\t// Request battery voltage data stream from target\n\t\tmavlink_message_t msg_req_batt;\n\t\tmav", "CodeBleu_score": 44.232203029026664}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    mavlink_message_t msg_out;\n\n    // Check if the target has already been set\n    if (target_set) {\n        return;\n    }\n\n    // Check if the message is a MAVLink message that should be tracked\n    if (msg.msgid != MAVLINK_MSG_ID_HEARTBEAT &&\n        msg.msgid != MAVLINK_MSG_ID_SYS_STATUS &&\n        msg.msgid != MAVLINK_MSG_ID_GLOBAL_POSITION_INT &&\n        msg.msgid != MAVLINK_MSG_ID_SYSTEM_TIME &&\n        msg.msgid != MAVLINK_MSG_ID_ATTITUDE &&\n        msg.msgid != MAVLINK_MSG_ID_ATTITUDE_QUATERNION &&\n        msg.msgid != MAVLINK_MSG_ID_VFR_HUD &&\n        msg.msgid != MAVLINK_MSG_ID_AIRSPEED &&\n        msg.msgid != MAVLINK_MSG_ID_ALTITUDE) {\n        return;\n    }\n\n    // Check if the target system ID has been set\n    if (target_sysid == 0) {\n        // Set the target system ID\n        target_sysid = msg.sysid;\n\n        // Request position and air pressure data streams from the target\n        mavlink_msg_request_data_stream_pack(msg.sysid, msg.compid, &msg_out, msg.sysid, msg.compid, MAV_DATA_STREAM_RAW_SENSORS, 100, 1);\n        send_mavlink_message(&msg_out);\n        mavlink_msg_request_data_stream_pack(msg.sysid, msg.compid, &msg_out, msg.sysid, msg.compid, MAV_DATA_STREAM_EXTENDED_STATUS, 100, 1);\n        send_mavlink_message(&msg_out);\n    }\n\n    // Set the target", "CodeBleu_score": 40.79135470281442}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\n    // If the target has been set, exit\n    if (target_set) {\n        return;\n    }\n\n    // Decode the message\n    mavlink_message_t msg_decoded;\n    mavlink_msg_decode(&msg, &msg_decoded);\n\n    // Check if the message type is one that should be tracked\n    if (msg_decoded.msgid != MAVLINK_MSG_ID_HEARTBEAT &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_SYS_STATUS &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_EXTENDED_SYS_STATE &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_ATTITUDE &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_LOCAL_POSITION_NED &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_ALTITUDE &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_GLOBAL_POSITION_INT &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_HIGH_LATENCY &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_HIGH_LATENCY2 &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_EXTENDED_SYS_STATE2 &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_ATTITUDE_QUATERNION &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_RC_CHANNELS &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_SERVO_OUTPUT_RAW &&\n        msg_decoded.msgid != MAVLINK_MSG_ID_RAW_IM", "CodeBleu_score": 28.627252067326204}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = Tracker::_handle_command_preflight_calibration_baro(msg);\n\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n\n    return result;\n}", "CodeBleu_score": 67.39857403517092}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = Tracker::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_barometer_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 62.595417914382814}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// Call the base class handler.\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n\t// If the base class handler accepted the command, set the flag to indicate that altitude calibration is needed on the next barometer update.\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_altitude_calibration_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 65.54291762407973}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    if (packet.param1 == 1.0) {\n        result = MAV_RESULT_ACCEPTED;\n        for (int i = 0; i < 4; i++) {\n            if (servo_states[i] != SERVO_STATE_ARMED) {\n                servo_states[i] = SERVO_STATE_ARMED;\n                servo_states_changed[i] = true;\n            }\n        }\n    } else if (packet.param1 == 0) {\n        result = MAV_RESULT_ACCEPTED;\n        for (int i = 0; i < 4; i++) {\n            if (servo_states[i] != SERVO_STATE_DISARMED) {\n                servo_states[i] = SERVO_STATE_DISARMED;\n                servo_states_changed[i] = true;\n            }\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 43.515258076209385}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// Check if the command is supported\n\tif (packet.param1 != 0.0f && packet.param1 != 1.0f) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\t// Check if the command is to arm or disarm\n\tif (packet.param1 == 1.0f) {\n\t\t// Arm the servos\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tif (servos[i].enabled) {\n\t\t\t\tservos[i].set_position(servos[i].home_position);\n\t\t\t}\n\t\t}\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\t// Disarm the servos\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tif (servos[i].enabled) {\n\t\t\t\tservos[i].set_position(0.0f);\n\t\t\t}\n\t\t}\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n}", "CodeBleu_score": 48.003901413257765}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t//TODO: implement\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 8.484763582851587}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i = 0; i < GCS_CHANNELS; i++) {\n\t\tif (gcs_channels[i].get_available_payload_space() > 10) {\n\t\t\tgcs_channels[i].send_request_datastream_position(sysid, compid);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.439226306767026}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i = 0; i < _channels.size(); i++) {\n        if (_channels[i].get_available_payload_space() >= 16) {\n            _channels[i].request_datastream_position(sysid, compid);\n        }\n    }\n}", "CodeBleu_score": 33.90773925199609}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (int i = 0; i < num_gcs; i++) {\n\t\tif (gcs_channels[i].get_available_payload_space() > 10) {\n\t\t\tgcs_channels[i].request_datastream_position(sysid, compid);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.203432559986187}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Get the AHRS instance\n\tAHRS* ahrs = Tracker::get_ahrs();\n\t// Check for a zero pitch cosine to avoid division by zero\n\tif (ahrs->get_pitch_cos() == 0) {\n\t\treturn false;\n\t}\n\t// Calculate the earth frame pitch and yaw using trigonometric conversions\n\tef_pitch = asin(ahrs->get_pitch_cos() * sin(pitch) + ahrs->get_pitch_sin() * cos(pitch) * cos(yaw));\n\tef_yaw = atan2(ahrs->get_pitch_sin() * sin(pitch) - ahrs->get_pitch_cos() * cos(pitch) * cos(yaw), cos(pitch));\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 52.06855129095601}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = Tracker::get_instance()->get_ahrs();\n\tif (ahrs == NULL) {\n\t\treturn false;\n\t}\n\tif (ahrs->get_pitch_cosine() == 0) {\n\t\treturn false;\n\t}\n\tfloat sin_pitch = ahrs->get_pitch_sine();\n\tfloat cos_pitch = ahrs->get_pitch_cosine();\n\tfloat sin_yaw = ahrs->get_yaw_sine();\n\tfloat cos_yaw = ahrs->get_yaw_cosine();\n\tef_pitch = asin(sin_pitch * cos_yaw * cos(pitch) + sin_yaw * sin(pitch));\n\tef_yaw = atan2(sin_pitch * cos_yaw * sin(pitch) - sin_yaw * cos(pitch), cos_pitch * cos_yaw - sin_yaw * sin(pitch));\n\treturn true;\n}", "CodeBleu_score": 41.442910785578704}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = Tracker::get_instance()->get_ahrs();\n\n\tif (ahrs->get_pitch_cos() != 0) {\n\t\tef_pitch = atan2(ahrs->get_pitch_sin(), ahrs->get_pitch_cos());\n\t\tef_yaw = yaw - atan2(ahrs->get_roll_sin(), ahrs->get_roll_cos());\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 41.967376302668654}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// Get the current target yaw and pitch from the tracker.\n\tint32_t target_yaw = tracker.get_target_yaw();\n\tint32_t target_pitch = tracker.get_target_pitch();\n\n\t// Get the current target distance from the tracker.\n\tfloat target_distance = tracker.get_target_distance();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.get_nav_status();\n\n\t// Get the current navigation status from the tracker.\n\tuint8_t nav_status = tracker.", "CodeBleu_score": 20.756901276853775}, {"code": "void Mode::update_auto(void){\n\t\t//Calculate the target yaw and pitch in centidegrees\n\ttarget_yaw = (int32_t)(((float)nav_data.nav_bearing * 10000.0f) / 36000.0f);\n\ttarget_pitch = (int32_t)(((float)nav_data.nav_altitude * 10000.0f) / 36000.0f);\n\n\t//Check if the direction is reversed\n\tif (nav_data.nav_bearing < 18000) {\n\t\ttarget_yaw = -target_yaw;\n\t}\n\n\t//Calculate the angle error\n\tangle_error_yaw = target_yaw - nav_data.nav_yaw;\n\tangle_error_pitch = target_pitch - nav_data.nav_pitch;\n\n\t//Convert the errors from earth frame to body frame\n\tangle_error_yaw = (int32_t)(angle_error_yaw * cos(nav_data.nav_pitch * 0.0001f) * 10000.0f);\n\tangle_error_pitch = (int32_t)(angle_error_pitch * cos(nav_data.nav_yaw * 0.0001f) * 10000.0f);\n\n\t//Check if the target distance is valid or no minimum distance is set\n\tif (nav_data.nav_distance_valid || !min_distance_set) {\n\t\t//Update the pitch and yaw servos\n\t\tTracker::set_yaw_pitch(angle_error_yaw, angle_error_pitch);\n\t}\n}", "CodeBleu_score": 29.38777158350042}, {"code": "void Mode::update_auto(void){\n\t\n    // Calculate the target yaw and pitch\n    int16_t yaw_target = 0;\n    int16_t pitch_target = 0;\n\n    // Calculate the target yaw\n    if (nav_status.nav_status == NAV_STATUS_NONE) {\n        yaw_target = 0;\n    } else if (nav_status.nav_status == NAV_STATUS_NORTH) {\n        yaw_target = 0;\n    } else if (nav_status.nav_status == NAV_STATUS_EAST) {\n        yaw_target = 18000;\n    } else if (nav_status.nav_status == NAV_STATUS_SOUTH) {\n        yaw_target = 18000;\n    } else if (nav_status.nav_status == NAV_STATUS_WEST) {\n        yaw_target = 36000;\n    } else if (nav_status.nav_status == NAV_STATUS_CENTER) {\n        yaw_target = 18000;\n    } else if (nav_status.nav_status == NAV_STATUS_LEFT) {\n        yaw_target = 27000;\n    } else if (nav_status.nav_status == NAV_STATUS_RIGHT) {\n        yaw_target = 9000;\n    } else if (nav_status.nav_status == NAV_STATUS_TURN_LEFT) {\n        yaw_target = 27000;\n    } else if (nav_status.nav_status == NAV_STATUS_TURN_RIGHT) {\n        yaw_target = 9000;\n    } else if (nav_status.nav_status == NAV_STATUS_TURN_LEFT_HARD) {\n        yaw_target = 27000;\n    } else if (nav_status.nav_status == NAV_STATUS_TURN_RIGHT_HARD) {\n        yaw_target = 9000;\n    } else if (nav_status.nav_status", "CodeBleu_score": 20.098699693601453}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t    // Update GPS data\n    update_GPS_data();\n\n    // Check if the GPS status is at least 3D fix\n    if (gps.status >= 3) {\n        // Check if the last message time has changed\n        if (gps.last_message_time != last_message_time) {\n            // Check if the GPS status is 3D fix\n            if (gps.status == 3) {\n                // Check if the GPS is valid\n                if (gps.valid) {\n                    // Check if the GPS has been initialized\n                    if (gps_initialized == false) {\n                        // Initialize the GPS\n                        initialize_GPS();\n                    }\n                    // Check if the GPS is valid and the GPS has been initialized\n                    else {\n                        // Check if the GPS is valid and the GPS has been initialized and the countdown has not reached zero\n                        if (gps.valid && gps_initialized && ground_start_countdown > 0) {\n                            // Decrement the countdown\n                            ground_start_countdown--;\n                        }\n                        // Check if the GPS is valid and the GPS has been initialized and the countdown has reached zero\n                        else if (gps.valid && gps_initialized && ground_start_countdown == 0) {\n                            // Check if the GPS is valid and the GPS has been initialized and the countdown has reached zero and the current location is valid\n                            if (gps.valid) {\n                                // Set the home location\n                                set_home_location();\n                            }\n                            // Check if the GPS is valid and the GPS has been initialized and the countdown has reached zero and the current location is invalid\n                            else {\n                                // Reset the countdown\n                                ground_start_countdown = GROUND_START_COUNTDOWN;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 39.770586498678234}, {"code": "void Tracker::update_GPS(void){\n\t\t// get GPS data\n\tif (gps.read()) {\n\t\t// check if the GPS status is at least 3D fix\n\t\tif (gps.status == 3) {\n\t\t\t// check if the last message time has changed\n\t\t\tif (gps.last_message_time != last_message_time) {\n\t\t\t\t// set the home location if the current location is valid\n\t\t\t\tif (gps.valid.location) {\n\t\t\t\t\t// set home location\n\t\t\t\t\thome_lat = gps.location.lat();\n\t\t\t\t\thome_lon = gps.location.lng();\n\t\t\t\t\thome_alt = gps.altitude;\n\t\t\t\t\thome_velocity = gps.speed;\n\t\t\t\t\t// reset the countdown\n\t\t\t\t\tground_start_countdown = 5;\n\t\t\t\t}\n\t\t\t\t// reset the last message time\n\t\t\t\tlast_message_time = gps.last_message_time;\n\t\t\t}\n\t\t\t// check if the GPS has a valid fix\n\t\t\tif (gps.valid.location) {\n\t\t\t\t// check if the GPS is within the ground start zone\n\t\t\t\tif (gps.location.distanceTo(home_lat, home_lon) < ground_start_zone) {\n\t\t\t\t\t// check if the countdown is not at zero\n\t\t\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\t\t\t// decrement the countdown\n\t\t\t\t\t\tground_start_countdown--;\n\t\t\t\t\t}\n\t\t\t\t\t// check if the countdown is at zero\n\t\t\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\t\t\t// set the home location\n\t\t\t\t\t\thome_lat = gps.location.lat();\n\t\t\t\t\t\thome_lon = gps.location.lng();\n\t\t\t\t\t\thome_alt = gps.altitude;\n\t\t\t\t\t\t", "CodeBleu_score": 42.745650482493915}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update the GPS data\n\tif (gps.available()) {\n\t\tgps.read();\n\t\t// Check if the last message time has changed\n\t\tif (last_message_time != gps.last_message_time) {\n\t\t\tlast_message_time = gps.last_message_time;\n\t\t\t// Check if the GPS status is at least 3D fix\n\t\t\tif (gps.fix.valid.location && gps.fix.valid.time) {\n\t\t\t\t// Check if the GPS is in the air\n\t\t\t\tif (!gps.fix.valid.altitude) {\n\t\t\t\t\t// If the GPS is in the air, reset the countdown\n\t\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN;\n\t\t\t\t}\n\t\t\t\t// Check if the GPS is on the ground\n\t\t\t\telse {\n\t\t\t\t\t// If the GPS is on the ground, set the home location if the countdown has reached one\n\t\t\t\t\tif (ground_start_countdown == 1) {\n\t\t\t\t\t\thome_latitude = gps.fix.latitude;\n\t\t\t\t\t\thome_longitude = gps.fix.longitude;\n\t\t\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN;\n\t\t\t\t\t}\n\t\t\t\t\t// If the GPS is on the ground, decrement the countdown\n\t\t\t\t\telse {\n\t\t\t\t\t\tground_start_countdown--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.672454981269226}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t//if (pitch > 0) {\n\t//\tpitch_onoff_servo.write(180);\n\t//}\n\t//else {\n\t//\tpitch_onoff_servo.write(0);\n\t//}\n\t//pitch_onoff_servo.write(180);\n}", "CodeBleu_score": 4.699969814793938}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // set the pitch servo\n    if (pitch < 0.0) {\n        pitch = 0.0;\n    }\n    else if (pitch > 1.0) {\n        pitch = 1.0;\n    }\n    if (pitch_servo_on) {\n        pitch_servo.write(pitch * 180.0);\n    }\n}", "CodeBleu_score": 14.373438954440182}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\n\tif (pitch_onoff_servo.attached()) {\n\t\tpitch_onoff_servo.write(pitch);\n\t}\n}", "CodeBleu_score": 12.164790786885222}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (AP_Arming_Plane::barometer_checks(display_failure)) {\n        if (g.ARMING_CHECK_BARO) {\n            if (abs(barometer.get_altitude_m() - barometer.get_reference_altitude()) > 10) {\n                if (display_failure) {\n                    hal.console->printf_P(PSTR(\"Barometer altitude check failed\n\"));\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 33.1320335593421}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    bool result = AP_Arming::barometer_checks(display_failure);\n    if (result) {\n        if (AP_Baro::barometer_present()) {\n            // check baro altitude against inertial altitude\n            if (g.ARMING_CHECK_BARO == 1) {\n                if (abs(barometer.get_altitude() - barometer.get_altitude_ref()) > 1.0f) {\n                    result = false;\n                    if (display_failure) {\n                        hal.console->printf_P(PSTR(\"Barometer altitude %d.%03d m, ref altitude %d.%03d m\n\"), (int)barometer.get_altitude(), (int)(barometer.get_altitude()*1000.0f)%1000, (int)barometer.get_altitude_ref(), (int)(barometer.get_altitude_ref()*1000.0f)%1000);\n                        hal.console->printf_P(PSTR(\"Barometer altitude check failed\n\"));\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 43.687732306659335}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    bool success = AP_Arming::barometer_checks(display_failure);\n    if (success) {\n        if (AP_Baro::baro_enabled() && AP_Baro::baro_present()) {\n            if (AP_Baro::baro_alt_ref_cm() == 0) {\n                if (display_failure) {\n                    hal.console->printf_P(PSTR(\"Barometer reference not set.\n\"));\n                }\n                success = false;\n            }\n        }\n    }\n    return success;\n}", "CodeBleu_score": 35.191531358481804}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    return (terrain_source != TerrainSource::Rangefinder) && (rtl_alt_type == RTL_AltType::Terrain);\n}", "CodeBleu_score": 6.4694670271646295}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (_terrain_source == TerrainSource::Rangefinder) {\n        return false;\n    }\n    if (_terrain_source == TerrainSource::Database && _rtl_altitude_type == RTL_AltitudeType::Terrain) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 54.76593035326609}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (_copter.terrain_source == TerrainSource::Rangefinder) {\n        return false;\n    }\n    if (_copter.rtl_alt_type == RTLAltitudeType::Terrain) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 54.47587764407372}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\n\t// run attitude controller\n\tattitude_control.rate_controller_run();\n\n\t// run position controller\n\tposition_control.rate_controller_run();\n\n\t// run altitude controller\n\taltitude_control.rate_controller_run();\n\n\t// run yaw controller\n\tyaw_control.rate_controller_run();\n\n\t// run motor controllers\n\tmotors.rate_controller_run();\n\n\t// run failsafe\n\tfailsafe.rate_controller_run();\n\n\t// run battery monitor\n\tbattery.rate_controller_run();\n\n\t// run estimator\n\testimator.rate_controller_run();\n\n\t// run logging\n\tlogging.rate_controller_run();\n\n\t// run GCS\n\tgcs.rate_controller_run();\n\n\t// run mixer\n\tmixer.rate_controller_run();\n\n\t// run sensor fusion\n\tsensor_fusion.rate_controller_run();\n\n\t// run barometer\n\tbarometer.rate_controller_run();\n\n\t// run compass\n\tcompass.rate_controller_run();\n\n\t// run airspeed\n\tairspeed.rate_controller_run();\n\n\t// run radio\n\tradio.rate_controller_run();\n\n\t// run telemetry\n\ttelemetry.rate_controller_run();\n\n\t// run mavlink\n\tmavlink.rate_controller_run();\n\n\t// run vtol\n\tvtol.rate_controller_run();\n\n\t// run power monitor\n\tpower_monitor.rate_controller_run();\n\n\t// run battery monitor\n\tbattery.rate_controller_run();\n\n\t// run throttle control\n\tthrottle.rate_controller_run();\n\n\t// run throttle control\n\tthrottle.rate_controller_run();\n\n\t// run esc\n\tesc.rate_controller_run();\n\n\t// run telemetry\n\ttelemetry.rate_controller_run();\n\n\t// run camera\n\tcamera.rate_controller_run();\n\n\t// run camera\n\tcamera.rate_controller_run();\n\n\t// run", "CodeBleu_score": 30.23413150828056}, {"code": "void Copter::run_rate_controller(){\n\t\n    // Get the time at the end of the loop\n    uint32_t now = get_micros();\n\n    // Calculate the time since the last loop\n    uint32_t dt = now - _last_run_loop_time;\n\n    // Set the last loop time\n    _last_run_loop_time = now;\n\n    // Run the rate controllers\n    attitude_control.rate_controller_run(dt);\n    position_control.rate_controller_run(dt);\n    motor_control.rate_controller_run(dt);\n\n    // Set the loop time for the rate controllers\n    attitude_control.set_dt(dt);\n    position_control.set_dt(dt);\n    motor_control.set_dt(dt);\n\n    // Set the loop time for the attitude controller\n    attitude_control.set_dt(dt);\n\n    // Set the loop time for the position controller\n    position_control.set_dt(dt);\n\n    // Set the loop time for the motor controller\n    motor_control.set_dt(dt);\n\n    // Set the loop time for the rate controller\n    rate_control.set_dt(dt);\n\n    // Set the loop time for the failsafe\n    failsafe.set_dt(dt);\n\n    // Set the loop time for the logging\n    logging.set_dt(dt);\n\n    // Set the loop time for the gps\n    gps.set_dt(dt);\n\n    // Set the loop time for the barometer\n    barometer.set_dt(dt);\n\n    // Set the loop time for the rangefinder\n    rangefinder.set_dt(dt);\n\n    // Set the loop time for the sonar\n    sonar.set_dt(dt);\n\n    // Set the loop time for the airspeed\n    airspeed.set_dt(dt);\n\n    // Set the loop time for the compass\n    compass.set_dt(dt);\n\n    // Set the loop time for the gps\n    gps.set_dt(dt);\n\n    // Set the loop time for the radio\n    radio.set_dt(dt);\n\n    // Set the loop time", "CodeBleu_score": 42.995116700465616}, {"code": "void Copter::run_rate_controller(){\n\t    // run the attitude controller\n    attitude_control.rate_controller_run();\n\n    // run the position controller\n    position_control.run_controller();\n\n    // run the altitude controller\n    altitude_control.run_controller();\n\n    // run the level controller\n    level_control.run_controller();\n\n    // run the yaw controller\n    yaw_control.run_controller();\n\n    // run the failsafe\n    failsafe.run();\n\n    // run the land detector\n    land_detector.update();\n\n    // run the battery monitor\n    battery.update();\n\n    // run the motor controller\n    motors.update();\n\n    // run the LEDs\n    leds.update();\n\n    // run the GPS\n    gps.update();\n\n    // run the compass\n    compass.update();\n\n    // run the airspeed sensor\n    airspeed.update();\n\n    // run the barometer\n    barometer.update();\n\n    // run the radio\n    radio.update();\n\n    // run the rangefinder\n    rangefinder.update();\n\n    // run the global position estimator\n    global_position_estimator.update();\n\n    // run the local position estimator\n    local_position_estimator.update();\n\n    // run the attitude estimator\n    attitude_estimator.update();\n\n    // run the position estimator\n    position_estimator.update();\n\n    // run the altitude estimator\n    altitude_estimator.update();\n\n    // run the level estimator\n    level_estimator.update();\n\n    // run the yaw estimator\n    yaw_estimator.update();\n\n    // run the navigator\n    navigator.update();\n\n    // run the mission manager\n    mission_manager.update();\n\n    // run the geofence\n    geofence.update();\n\n    // run the land detector\n    land_detector.update();\n\n    // run the battery monitor\n    battery.update();\n\n    // run the LEDs\n    leds.update();\n\n    // run the GPS\n   ", "CodeBleu_score": 31.526909989814556}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n\tif (old_loc.altitude_frame != new_loc.altitude_frame) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.lat != new_loc.lat || old_loc.lon != new_loc.lon) {\n\t\treturn false;\n\t}\n\n\t// Set new location as target\n\ttarget_location = new_loc;\n\n\treturn true;\n}", "CodeBleu_score": 42.18242051194413}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.alt == new_loc.alt && old_loc.lat == new_loc.lat && old_loc.lon == new_loc.lon) {\n\t\treturn false;\n\t}\n\ttarget_location = new_loc;\n\treturn true;\n}", "CodeBleu_score": 39.691934936187565}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n    if (old_loc.lat != new_loc.lat || old_loc.lng != new_loc.lng || old_loc.alt != new_loc.alt) {\n        return false;\n    }\n\n    target_location = new_loc;\n\n    return true;\n}", "CodeBleu_score": 43.48268486753473}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (aux_switch_pos == ch_flag) {\n        set_mode(mode);\n    } else {\n        if (mode == get_mode()) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 46.447129521010226}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        set_mode(mode);\n    } else if (get_mode() == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 46.077125265302044}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (aux_switch_pos_ == ch_flag) {\n        set_mode(mode);\n    } else if (aux_switch_pos_ != AuxSwitchPos::NONE && mode == mode_) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 51.70063747106519}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // save the trim values\n    // calculate the trim values from the control inputs of the roll and pitch channels\n    // convert them to radians\n    // add them to the AHRS trim\n    // log the event\n    // send a confirmation message with MAV_SEVERITY_INFO\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    // return\n    //", "CodeBleu_score": 2.54124819812564}, {"code": "void Copter::save_trim(){\n\t    // Calculate the trim values\n    float roll_trim = 0;\n    float pitch_trim = 0;\n    for (uint8_t i = 0; i < RC_CHANNELS_TRIM_CHANNELS; i++) {\n        roll_trim += rc_channels[i].control_in;\n        pitch_trim += rc_channels[RC_CHANNELS_TRIM_CHANNELS + i].control_in;\n    }\n    roll_trim /= RC_CHANNELS_TRIM_CHANNELS;\n    pitch_trim /= RC_CHANNELS_TRIM_CHANNELS;\n    // Convert to radians\n    roll_trim *= (M_PI / 180);\n    pitch_trim *= (M_PI / 180);\n    // Add to AHRS trim\n    attitude_control.set_trim(roll_trim, pitch_trim);\n    // Log the event\n    Log_Write_Event(LOG_CATEGORY_TRIM, LOG_EVENT_SAVED_TRIM);\n    // Send confirmation message\n    MAV_Send_Message(MAV_SEVERITY_INFO, MAV_MESSAGE_TRIM_SAVED);\n}", "CodeBleu_score": 45.48968017568554}, {"code": "void Copter::save_trim(){\n\t\t// Calculate the trim values\n\tfloat roll_trim = (float)(RC_Channels::rc_roll_in->control_in - RC_Channels::rc_roll_in->control_min) / (float)(RC_Channels::rc_roll_in->control_max - RC_Channels::rc_roll_in->control_min) * (float)RC_Channels::rc_roll_in->control_max;\n\tfloat pitch_trim = (float)(RC_Channels::rc_pitch_in->control_in - RC_Channels::rc_pitch_in->control_min) / (float)(RC_Channels::rc_pitch_in->control_max - RC_Channels::rc_pitch_in->control_min) * (float)RC_Channels::rc_pitch_in->control_max;\n\n\t// Convert the trim values to radians\n\troll_trim = (float)DEG_TO_RAD * roll_trim;\n\tpitch_trim = (float)DEG_TO_RAD * pitch_trim;\n\n\t// Add the trim values to the AHRS trim\n\tahrs.set_trim(roll_trim, pitch_trim);\n\n\t// Log the event\n\tDataFlash.Log_Event(MAV_SEVERITY_INFO, \"Trim saved\");\n\n\t// Send a confirmation message\n\tmavlink_log_info(mavlink_fd, \"[fc] Trim saved\");\n}", "CodeBleu_score": 46.588479064655296}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t  if (copter.get_position_valid()) {\n    float velocity_x = copter.get_velocity_x();\n    float velocity_y = copter.get_velocity_y();\n    float velocity_z = copter.get_velocity_z();\n    float velocity_squared = velocity_x * velocity_x + velocity_y * velocity_y + velocity_z * velocity_z;\n    if (velocity_squared > 0.00001) {\n      float look_ahead_yaw = atan2(velocity_y, velocity_x);\n      if (look_ahead_yaw < 0.0) {\n        look_ahead_yaw += 2.0 * M_PI;\n      }\n      return look_ahead_yaw;\n    }\n  }\n  return 0.0;\n}", "CodeBleu_score": 43.33536751578911}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Get the copter's velocity\n\tfloat velocity[3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tvelocity[i] = copter->get_velocity()[i];\n\t}\n\t// Calculate the speed squared\n\tfloat speed_squared = velocity[0] * velocity[0] + velocity[1] * velocity[1] + velocity[2] * velocity[2];\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (copter->get_position()[0] != 0 && speed_squared > 0.0001) {\n\t\t// Calculate the look-ahead yaw angle using the arctangent of the velocity components\n\t\tlook_ahead_yaw_angle = atan2(velocity[1], velocity[0]) * 180 / M_PI;\n\t\t// If the look-ahead yaw angle is negative, add 360 to it\n\t\tif (look_ahead_yaw_angle < 0) {\n\t\t\tlook_ahead_yaw_angle += 360;\n\t\t}\n\t}\n\t// Return the computed look-ahead yaw angle\n\treturn look_ahead_yaw_angle;\n}", "CodeBleu_score": 42.18861092431858}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t  // Get the velocity of the copter\n  float velocity = Copter::get_velocity();\n\n  // Check if the copter's position is valid\n  if (Copter::get_position_valid()) {\n    // Check if the copter's velocity exceeds a minimum threshold\n    if (velocity > MIN_SPEED) {\n      // Calculate the speed squared\n      float speed_squared = velocity * velocity;\n\n      // Calculate the look-ahead yaw angle\n      float look_ahead_yaw = atan(speed_squared);\n\n      // Return the computed look-ahead yaw angle\n      return look_ahead_yaw;\n    }\n  }\n\n  // Return zero if the copter's position is invalid or the speed is below the minimum threshold\n  return 0;\n}", "CodeBleu_score": 33.646168134997886}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (plane.g.rudder_arming_disabled || plane.g.throttle_zero) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (arming.armed()) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 44.043290872483084}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::RUDDER) {\n        if (plane.disable_rudder_arming || plane.throttle_zero()) {\n            return false;\n        }\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 39.96367347695764}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::RUDDER) {\n        if (g.rudder_arming == 0 || _plane->get_throttle_control() != 0) {\n            return false;\n        }\n    }\n    if (AP_Arming::arm_checks(method)) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 37.98681216840053}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // if we're already armed, don't do anything\n    if (armed) {\n        return true;\n    }\n\n    // if we're not armed and we're not in a state where we can arm, don't do anything\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not armed and we're not in a state where we can arm, don't do anything\n    if (do_arming_checks && !check_arming()) {\n        return false;\n    }\n\n    // if we're not armed and we're not in a state where we can arm, don't do anything\n    if (method != AP_Arming::ARMED && !arm_switch_is_active()) {\n        return false;\n    }\n\n    // set the arming state\n    armed = true;\n    arm_method = method;\n\n    // set the arming delay\n    arming_delay_start = hal.scheduler->millis();\n\n    // set the home location\n    home.set_from_current_position();\n\n    // set the home location in the AHRS system\n    ahrs.set_home(home);\n\n    // update the current location\n    update_current_location();\n\n    // set the arming delay\n    arming_delay_start = hal.scheduler->millis();\n\n    // send the status text\n    send_status_text(AP_ARMING_THROTTLE_ARMED);\n\n    return true;\n}", "CodeBleu_score": 52.3142582585064}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // check if arming is already in progress\n    if (_arming_state == ARMING_IN_PROGRESS) {\n        return false;\n    }\n\n    // check if arming is already complete\n    if (_arming_state == ARMED) {\n        return true;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == ARMING_FAILED) {\n        return false;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == DISARMED) {\n        return false;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == DISARMING) {\n        return false;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == DISARMED_BY_USER) {\n        return false;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == DISARMED_BY_MANUAL_DISARM) {\n        return false;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == DISARMED_BY_RC_DISARM) {\n        return false;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == DISARMED_BY_POWER_OFF) {\n        return false;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == DISARMED_BY_RADIO_SWITCH) {\n        return false;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == DISARMED_BY_RADIO_SWITCH_OR_POWER_OFF) {\n        return false;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == DISARMED_BY_RC_LOST) {\n        return false;\n    }\n\n    // check if arming is already failed\n    if (_arming_state == DISARMED_BY_RC_LOST_OR", "CodeBleu_score": 22.148915108319134}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// if we're already armed, just return\n\tif (_armed) {\n\t\treturn true;\n\t}\n\n\t// check the arming state\n\tif (!_arming_state.check_state()) {\n\t\treturn false;\n\t}\n\n\t// check the arming checks\n\tif (do_arming_checks) {\n\t\tif (!_arming_checks.check()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// check that the throttle is at the minimum required level\n\tif (!_throttle_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t// check that the GPS is healthy\n\tif (!_gps_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t// check that the airspeed is healthy\n\tif (!_airspeed_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t// check that the airspeed is healthy\n\tif (!_barometer_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t// check that the magnetometer is healthy\n\tif (!_mag_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t// check that the accelerometer is healthy\n\tif (!_acc_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t// check that the gyro is healthy\n\tif (!_gyro_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t// check that the ESCs are healthy\n\tif (!_esc_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t// check that the battery is healthy\n\tif (!_battery_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t// check that the radio is healthy\n\tif (!_radio_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t// check that the rc receiver is healthy\n\tif (!_rc_check.check(method)) {\n\t\treturn false;\n\t}\n\n\t", "CodeBleu_score": 31.59586670000005}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (armed) {\n\t\treturn true;\n\t}\n\n\tif (!(AP_Arming::pre_arm_checks(display_failure))) {\n\t\treturn false;\n\t}\n\n\tif (!(AP_Arming::disarm_button_configured())) {\n\t\tif (display_failure) {\n\t\t\tAP_Param::print_all();\n\t\t\tSerial.println(\"Disarm button not configured\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 60.62775174808168}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// check if we are already armed\n\tif (_armed) {\n\t\treturn true;\n\t}\n\n\t// check if we have a disarm button\n\tif (_disarm_switch_chan == 0) {\n\t\t// no disarm button, so return false\n\t\tif (display_failure) {\n\t\t\t_arm_failure_reason = AP_ARMING_FAIL_NO_DISARM_BUTTON;\n\t\t\t_arm_failure_time = hal.scheduler->millis();\n\t\t\tarm_failure_message();\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if disarm button is pressed\n\tif (channel_get(_disarm_switch_chan) < 1000) {\n\t\t// disarm button is pressed, so return false\n\t\tif (display_failure) {\n\t\t\t_arm_failure_reason = AP_ARMING_FAIL_DISARM_BUTTON_PRESSED;\n\t\t\t_arm_failure_time = hal.scheduler->millis();\n\t\t\tarm_failure_message();\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if we have a throttle channel\n\tif (_throttle_chan == 0) {\n\t\t// no throttle channel, so return false\n\t\tif (display_failure) {\n\t\t\t_arm_failure_reason = AP_ARMING_FAIL_NO_THROTTLE_CHANNEL;\n\t\t\t_arm_failure_time = hal.scheduler->millis();\n\t\t\tarm_failure_message();\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if throttle is above the minimum\n\tif (channel_get(_throttle_chan) < _throttle_min) {\n\t\t// throttle is below minimum, so return false\n\t\tif (display_failure) {\n\t\t\t_arm_failure_reason = AP_ARMING_FAIL_THROTTLE_BELOW_MIN;\n\t\t\t", "CodeBleu_score": 42.6113116536207}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (armed()) {\n        return true;\n    }\n\n    if (!_disarm_button) {\n        if (display_failure) {\n            _sub_display->display_text(AP_DISPLAY_TEXT_FAILURE, \"No disarm button\");\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 67.43952408325151}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cos(ahrs.yaw) - y * sin(ahrs.yaw);\n    float ne_y = x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 62.41280822119546}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x, ne_y;\n    float yaw = get_yaw();\n    float c = cos(yaw);\n    float s = sin(yaw);\n    ne_x = c * x - s * y;\n    ne_y = s * x + c * y;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 55.802885827847184}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cos(yaw) - y * sin(yaw);\n    float ne_y = x * sin(yaw) + y * cos(yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 57.63208266341391}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if the yaw angle and param4 values are within acceptable ranges\n\tif (packet.param1 < 0 || packet.param1 > 360 || packet.param4 < 0 || packet.param4 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading using the provided parameters\n\t_mavlink->set_yaw_target_angle(packet.param1, packet.param4);\n\n\t// Return MAV_RESULT_ACCEPTED\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 41.66618092617489}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_DENIED;\n\n    // check if we are in RTL\n    if (_mavlink->get_mode() == MAV_MODE_FLAG_AUTO_RTL) {\n        return result;\n    }\n\n    // check if we are in a manual mode\n    if (_mavlink->get_mode() & MAV_MODE_FLAG_MANUAL_INPUT_ENABLED) {\n        return result;\n    }\n\n    // check if we are in a mission\n    if (_mavlink->get_mode() & MAV_MODE_FLAG_CUSTOM_MODE_ENABLED) {\n        return result;\n    }\n\n    // check if we are in a failsafe state\n    if (_mavlink->get_mode() & MAV_MODE_FLAG_SAFETY_ARMED) {\n        return result;\n    }\n\n    // check if the yaw is within the range of 0-360 degrees\n    if (packet.param1 < 0.0f || packet.param1 > 360.0f) {\n        return result;\n    }\n\n    // check if the yaw speed is within the range of 0-10 degrees per second\n    if (packet.param2 < 0.0f || packet.param2 > 10.0f) {\n        return result;\n    }\n\n    // check if the yaw angle is within the range of 0-360 degrees\n    if (packet.param3 < 0.0f || packet.param3 > 360.0f) {\n        return result;\n    }\n\n    // check if the yaw speed is within the range of 0-10 degrees per second\n    if (packet.param4 < 0.0f || packet.param4 > 10.0f) {\n        return result;\n    }\n\n    // check if the yaw angle is within the range of 0-360 degrees\n    if (packet.param5 < 0.0f || packet.param5 > 360.0f) {\n       ", "CodeBleu_score": 44.554696172054584}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t\n\t// check if the yaw angle and param4 values are within acceptable ranges\n\tif (packet.param1 < -180 || packet.param1 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param2 < -180 || packet.param2 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param3 < 0 || packet.param3 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param4 < 0 || packet.param4 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// set the yaw heading using the provided parameters\n\tif (packet.param1 != 0) {\n\t\t_mavlink->set_yaw_target_deg(packet.param1);\n\t}\n\tif (packet.param2 != 0) {\n\t\t_mavlink->set_yaw_speed_deg_s(packet.param2);\n\t}\n\tif (packet.param3 != 0) {\n\t\t_mavlink->set_yaw_angle_deg(packet.param3);\n\t}\n\tif (packet.param4 != 0) {\n\t\t_mavlink->set_yaw_angle_max_deg(packet.param4);\n\t}\n\n\t// return MAV_RESULT_ACCEPTED\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 46.41274291896419}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n        return waypoint_bearing / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 39.74848820191295}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n        return (uint8_t) (waypoint_bearing / 2);\n    }\n    return 0;\n}", "CodeBleu_score": 40.36655528932883}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    switch (control_mode) {\n    case AUTO:\n    case GUIDED:\n        return (uint8_t)((waypoint_bearing + 18000) / 2);\n    default:\n        return 0;\n    }\n}", "CodeBleu_score": 18.142296460758928}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (log_enabled) {\n\t\tLogPacket packet = {0};\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tpacket.time = millis();\n\t\tpacket.type = LOG_TYPE_INT32;\n\t\tpacket.size = sizeof(int32_t);\n\t\tpacket.block_type = LOG_BLOCK_CRITICAL;\n\t\tpacket.block_size = sizeof(LogPacket) + sizeof(int32_t);\n\t\tpacket.block_index = 0;\n\t\tpacket.block_count = 1;\n\t\tpacket.block_total_size = packet.block_size;\n\t\tpacket.block_total_count = 1;\n\t\tpacket.block_total_index = 0;\n\t\tpacket.block_total_type = LOG_BLOCK_CRITICAL;\n\t\tpacket.block_total_index = 0;\n\t\tpacket.block_total_count = 1;\n\t\tpacket.block_total_type = LOG_BLOCK_CRITICAL;\n\t\tlogger.Write_Block(&packet);\n\t}\n}", "CodeBleu_score": 37.89319934275429}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (!logging_enabled) {\n\t\treturn;\n\t}\n\t// Create a log packet\n\tLogPacket packet;\n\tpacket.time = millis();\n\tpacket.id = id;\n\tpacket.value = value;\n\tpacket.critical = true;\n\t// Write the log packet to the logger\n\tlogger->Write_Packet(packet);\n}", "CodeBleu_score": 35.95256602666471}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (logging) {\n\t\tLogPacket packet = {0};\n\t\tpacket.ID = id;\n\t\tpacket.time = Get_Time();\n\t\tpacket.value = value;\n\t\tWrite_Critical_Block((uint8_t*)&packet, sizeof(packet));\n\t}\n}", "CodeBleu_score": 34.92372672089925}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\t// TODO: This function should be moved to the EKF\n\tif (home_set) {\n\t\treturn;\n\t}\n\n\t// TODO: This function should be moved to the EKF\n\tif (armed) {\n\t\t// TODO: This function should be moved to the EKF\n\t\tset_home_position();\n\n\t} else {\n\t\t// TODO: This function should be moved to the EKF\n\t\tset_home_position();\n\t}\n}", "CodeBleu_score": 20.210520196213622}, {"code": "void Sub::update_home_from_EKF(){\n\t\t// TODO\n}", "CodeBleu_score": 3.79541649619327}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_set) {\n\t\treturn;\n\t}\n\tif (armed) {\n\t\thome.lat = lat;\n\t\thome.lon = lon;\n\t\thome.alt = alt;\n\t\thome_set = true;\n\t} else {\n\t\tif (ekf_home_set) {\n\t\t\thome.lat = ekf_home.lat;\n\t\t\thome.lon = ekf_home.lon;\n\t\t\thome.alt = ekf_home.alt;\n\t\t\thome_set = true;\n\t\t} else {\n\t\t\thome.lat = lat;\n\t\t\thome.lon = lon;\n\t\t\thome.alt = alt;\n\t\t\thome_set = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 19.282299827846323}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t    if (!armed) {\n        throttle = 0;\n        spool.set_state(Spool::State::STOPPED);\n        attitude_controller.relax();\n        return;\n    }\n\n    spool.set_state(Spool::State::UNLIMITED_THROTTLE);\n    attitude_controller.run(pilot_inputs.roll, pilot_inputs.pitch, pilot_inputs.yaw, pilot_inputs.throttle);\n\n    motor_inputs.throttle = pilot_inputs.throttle;\n    motor_inputs.forward = pilot_inputs.throttle * cos(attitude_controller.get_pitch()) * cos(attitude_controller.get_roll());\n    motor_inputs.lateral = pilot_inputs.throttle * cos(attitude_controller.get_pitch()) * sin(attitude_controller.get_roll());\n    motor_inputs.vertical = pilot_inputs.throttle * sin(attitude_controller.get_pitch());\n}", "CodeBleu_score": 52.33244946676856}, {"code": "void ModeAcro::run(){\n\t\tif ( !armed ) {\n\t\tthrottle = 0;\n\t\tspool->setThrottle( throttle );\n\t\tattitude->relax();\n\t\treturn;\n\t}\n\n\tspool->setThrottle( throttle );\n\n\t// get pilot inputs\n\tfloat roll = pilot->getRoll();\n\tfloat pitch = pilot->getPitch();\n\tfloat yaw = pilot->getYaw();\n\tfloat throttle = pilot->getThrottle();\n\n\t// convert pilot inputs to body rates\n\tfloat phi = roll;\n\tfloat theta = pitch;\n\tfloat psi = yaw;\n\n\t// run attitude controller\n\tattitude->run( phi, theta, psi, throttle );\n\n\t// output pilot's throttle input without angle boost\n\tthrottle = pilot->getThrottle();\n\n\t// set motor inputs\n\tfloat throttle_out = throttle;\n\tfloat roll_out = attitude->getRoll();\n\tfloat pitch_out = attitude->getPitch();\n\tfloat yaw_out = attitude->getYaw();\n\n\t// set motor inputs\n\tmotor->set( throttle_out, roll_out, pitch_out, yaw_out );\n}", "CodeBleu_score": 40.68033297484955}, {"code": "void ModeAcro::run(){\n\t\tif (!armed) {\n\t\t// If not armed, set throttle to zero, relax attitude control, and exit.\n\t\tthrottle = 0;\n\t\trelaxAttitudeControl();\n\t\treturn;\n\t}\n\t// If armed, set the spool state to unlimited throttle and run the attitude controller.\n\tspoolState = SPOOL_STATE_UNLIMITED_THROTTLE;\n\trunAttitudeControl();\n\t// Set the forward and lateral motor inputs based on pilot controls.\n\tsetForwardAndLateralMotorInputs();\n}", "CodeBleu_score": 5.514965761910144}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set the mode to position control\n\t_control_mode.flag_control_position_enabled = true;\n\t_control_mode.flag_control_velocity_enabled = false;\n\t_control_mode.flag_control_climb_rate_enabled = false;\n\t_control_mode.flag_control_termination_enabled = false;\n\t_control_mode.flag_control_altitude_enabled = false;\n\t_control_mode.flag_control_position_lock_enabled = false;\n\t_control_mode.flag_control_velocity_lock_enabled = false;\n\t_control_mode.flag_control_climb_rate_lock_enabled = false;\n\n\t// initialize the waypoint controller\n\t_waypoint_position_reached = false;\n\t_waypoint_velocity_valid = false;\n\t_waypoint_set_on_land = false;\n\t_waypoint_index = 0;\n\t_waypoint_position = _global_position;\n\t_waypoint_velocity = _global_velocity;\n\t_waypoint_previous_position = _global_position;\n\t_waypoint_previous_velocity = _global_velocity;\n\t_waypoint_threshold_distance = _params.nav_loiter_radius;\n\t_waypoint_threshold_acceptance = _params.nav_loiter_radius;\n\t_waypoint_previous_threshold_distance = _waypoint_threshold_distance;\n\t_waypoint_previous_threshold_acceptance = _waypoint_threshold_acceptance;\n\t_waypoint_type = position;\n\t_waypoint_altitude_min = _global_position.alt;\n\t_waypoint_altitude_max = _global_position.alt;\n\t_waypoint_altitude_previous = _global_position.alt;\n\t_waypoint_altitude_acceptance = _params.nav_loiter_radius;\n\t_waypoint_altitude_previous_acceptance = _waypoint_altitude_acceptance;\n\t_waypoint_altitude_lock = false;\n\t_waypoint_altitude_lock_engaged = false;\n\t_way", "CodeBleu_score": 32.70803107143275}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set the mode to position control\n    _control_mode.flag_control_position_enabled = true;\n    _control_mode.flag_control_velocity_enabled = false;\n    _control_mode.flag_control_climb_rate_enabled = false;\n    _control_mode.flag_control_termination_enabled = false;\n\n    // set the current waypoint to the stopping point\n    _pos_sp_triplet.current.valid = true;\n    _pos_sp_triplet.current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n    _pos_sp_triplet.current.position = _pos_sp_triplet.previous.position;\n    _pos_sp_triplet.current.velocity = _pos_sp_triplet.previous.velocity;\n    _pos_sp_triplet.current.alt = _pos_sp_triplet.previous.alt;\n    _pos_sp_triplet.current.yaw = _pos_sp_triplet.previous.yaw;\n    _pos_sp_triplet.current.yawspeed = _pos_sp_triplet.previous.yawspeed;\n    _pos_sp_triplet.current.loiter_radius = _pos_sp_triplet.previous.loiter_radius;\n    _pos_sp_triplet.current.loiter_direction = _pos_sp_triplet.previous.loiter_direction;\n    _pos_sp_triplet.current.pitch_min = _pos_sp_triplet.previous.pitch_min;\n    _pos_sp_triplet.current.pitch_max = _pos_sp_triplet.previous.pitch_max;\n    _pos_sp_triplet.current.lat = _pos_sp_triplet.previous.lat;\n    _pos_sp_triplet.current.lon = _pos_sp_triplet.previous.lon;\n    _pos_sp_triplet.current.alt_is_relative = _pos_sp_triplet.previous", "CodeBleu_score": 35.71751502782119}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t_pos_sp_triplet.current.valid = false;\n\t_pos_sp_triplet.previous.valid = false;\n\t_pos_sp_triplet.next.valid = false;\n\t_pos_sp_triplet.current.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t_pos_sp_triplet.previous.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t_pos_sp_triplet.next.type = position_setpoint_s::SETPOINT_TYPE_POSITION;\n\t_pos_sp_triplet.current.position = _pos_sp;\n\t_pos_sp_triplet.previous.position = _pos_sp;\n\t_pos_sp_triplet.next.position = _pos_sp;\n\t_pos_sp_triplet.current.velocity = _vel_sp;\n\t_pos_sp_triplet.previous.velocity = _vel_sp;\n\t_pos_sp_triplet.next.velocity = _vel_sp;\n\t_pos_sp_triplet.current.acceleration = _acc_sp;\n\t_pos_sp_triplet.previous.acceleration = _acc_sp;\n\t_pos_sp_triplet.next.acceleration = _acc_sp;\n\t_pos_sp_triplet.current.yaw = _att_sp.yaw_body;\n\t_pos_sp_triplet.previous.yaw = _att_sp.yaw_body;\n\t_pos_sp_triplet.next.yaw = _att_sp.yaw_body;\n\t_pos_sp_triplet.current.yawspeed = _att_sp.yawspeed;\n\t_pos_sp_triplet.previous.yawspeed = _att_sp.yawspeed;\n\t_pos_sp_triplet.next.yawspeed = _att_sp.yawspeed;\n\t_pos_sp_triplet.current.loiter_radius =", "CodeBleu_score": 35.12801006125607}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set the guided mode to velocity controller\n\t_control_mode.flag_control_velocity_enabled = true;\n\t_control_mode.flag_control_altitude_enabled = false;\n\t_control_mode.flag_control_climb_rate_enabled = false;\n\t_control_mode.flag_control_position_enabled = false;\n\t_control_mode.flag_control_termination_enabled = false;\n\t_control_mode.flag_control_velocity_changed = true;\n\n\t// set vertical maximum speeds and acceleration using pilot-defined parameters\n\t_params.mc_airspeed_max = _params.vel_max_up;\n\t_params.mc_airspeed_trim = _params.vel_cruise;\n\t_params.auto_vel_max = _params.vel_max_up;\n\t_params.auto_vel_min = _params.vel_min;\n\t_params.auto_vel_max_down = _params.vel_max_down;\n\t_params.auto_accel_max = _params.acc_max_up;\n\t_params.auto_accel_max_vertical = _params.acc_max_down;\n\t_params.auto_accel_max_horizontal = _params.acc_hor_max;\n\t_params.auto_thrust_max = _params.thr_max;\n\t_params.auto_thrust_min = _params.thr_min;\n\n\t// initialize vertical and horizontal velocity controllers\n\t_vel_sp_prev.zero();\n\t_vel_err_d.zero();\n\t_vel_err_d_prev.zero();\n\t_vel_ff.zero();\n\t_vel_p_gain = _params.vel_p;\n\t_vel_i_gain = _params.vel_i;\n\t_vel_d_gain = _params.vel_d;\n\t_vel_ff.zero();\n\t_vel_sp(2) = 0.0f;\n\t_vel_int(2) = 0.0f;\n\t_vel_int_on = false;\n\n\t// set yaw control mode to AUT", "CodeBleu_score": 39.51664661601117}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialize vertical maximum speeds and acceleration\n\tvel_max_up = 1000.0f;\n\tvel_max_down = 1000.0f;\n\tacc_up = 200.0f;\n\tacc_down = 200.0f;\n\n\t// initialize vertical and horizontal velocity controllers\n\t_vel_control.init();\n\t_vel_control.set_vel_max_up(vel_max_up);\n\t_vel_control.set_vel_max_down(vel_max_down);\n\t_vel_control.set_acc_up(acc_up);\n\t_vel_control.set_acc_down(acc_down);\n\t_vel_control.set_vel_max_side(vel_max_side);\n\t_vel_control.set_vel_max_forward(vel_max_forward);\n\t_vel_control.set_vel_max_back(vel_max_back);\n\t_vel_control.set_acc_hor(acc_hor);\n\t_vel_control.set_vel_cruise(vel_cruise);\n\t_vel_control.set_yaw_rate_max(yaw_rate_max);\n\t_vel_control.set_throttle_min(throttle_min);\n\t_vel_control.set_throttle_max(throttle_max);\n\t_vel_control.set_throttle_cruise(throttle_cruise);\n\t_vel_control.set_throttle_slew_max(throttle_slew_max);\n\t_vel_control.set_time_const(time_const);\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\t_att_control.set_yaw_target_to_current_heading();\n\t_att_control.set_yaw_control_mode(Auto_Yaw_Control::AUTO_YAW_HOLD);\n}", "CodeBleu_score": 33.67445799906787}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t_vel_max_up = _params.vel_max_up;\n\t_vel_max_down = _params.vel_max_down;\n\t_acceleration_max_up = _params.acc_up_max;\n\t_acceleration_max_down = _params.acc_down_max;\n\t_vel_max_side = _params.vel_max_side;\n\t_acceleration_max_side = _params.acc_hor_max;\n\t_yaw_rate_max = _params.mc_att_yaw_p;\n\n\t_vel_control.reset(new VelPosControl(_vel_max_up, _vel_max_down, _vel_max_side, _acceleration_max_up, _acceleration_max_down, _acceleration_max_side, _yaw_rate_max, _params.alt_ctl_dz, _params.alt_ctl_dy, _params.alt_ctl_ddz, _params.alt_ctl_dz_thr));\n\t_vel_control->set_vel_max_up(_vel_max_up);\n\t_vel_control->set_vel_max_down(_vel_max_down);\n\t_vel_control->set_vel_max_side(_vel_max_side);\n\t_vel_control->set_acceleration_max_up(_acceleration_max_up);\n\t_vel_control->set_acceleration_max_down(_acceleration_max_down);\n\t_vel_control->set_acceleration_max_side(_acceleration_max_side);\n\t_vel_control->set_yaw_rate_max(_yaw_rate_max);\n\t_vel_control->set_vel_ff(_params.vel_ff);\n\t_vel_control->set_vel_ramp(_params.vel_ramp);\n\t_vel_control->set_thr_hover(_params.thr_hover);\n\t_vel_control->set_xy_p(_params.vel_p);\n\t_vel_control->set_z_p(_params", "CodeBleu_score": 36.19440014543268}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check for timeout\n\tif (millis() - last_action_time > GUIDED_TIMEOUT) {\n\t\treturn true;\n\t}\n\n\t// Check for altitude limits\n\tif (current_loc.alt < MIN_ALT) {\n\t\treturn true;\n\t}\n\n\tif (current_loc.alt > MAX_ALT) {\n\t\treturn true;\n\t}\n\n\t// Check for horizontal distance moved\n\tif (current_loc.distance_to(last_loc) > GUIDED_DISTANCE_LIMIT) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 22.863013595401448}, {"code": "bool ModeGuided::guided_limit_check(){\n\t  if (millis() - _start_time > _timeout) {\n    _mode_state = MANUAL;\n    _mode_state_time = millis();\n    return true;\n  }\n\n  if (_alt_min > 0 && _altitude < _alt_min) {\n    _mode_state = MANUAL;\n    _mode_state_time = millis();\n    return true;\n  }\n\n  if (_alt_max > 0 && _altitude > _alt_max) {\n    _mode_state = MANUAL;\n    _mode_state_time = millis();\n    return true;\n  }\n\n  if (_horiz_dist_max > 0 && _horiz_dist > _horiz_dist_max) {\n    _mode_state = MANUAL;\n    _mode_state_time = millis();\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 36.707178389792595}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tbool ret = false;\n\tif (time_since_command > 1000000) {\n\t\tret = true;\n\t}\n\tif (pos_sp_triplet.current.valid && pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n\t\tif (pos_sp_triplet.current.position.alt > _param_mpc_z_vel_max_up.get() + _global_pos.alt) {\n\t\t\tret = true;\n\t\t}\n\n\t\tif (pos_sp_triplet.current.position.alt < _param_mpc_z_vel_max_dn.get() + _global_pos.alt) {\n\t\t\tret = true;\n\t\t}\n\t}\n\n\tif (pos_sp_triplet.current.valid && pos_sp_triplet.current.type == position_setpoint_s::SETPOINT_TYPE_POSITION) {\n\t\tif (pos_sp_triplet.current.position.dist_xy(_global_pos) > _param_nav_loiter_rad.get()) {\n\t\t\tret = true;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 36.20224413406141}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tbool pass = true;\n\tros::Time last_request_time = ros::Time::now();\n\tros::Time last_response_time = ros::Time::now();\n\tros::Time last_failure_time = ros::Time::now();\n\tros::Time last_pass_time = ros::Time::now();\n\twhile (ros::ok()) {\n\t\tif (motor_test_requested) {\n\t\t\tlast_request_time = ros::Time::now();\n\t\t\tmotor_test_requested = false;\n\t\t}\n\t\tif (motor_test_passed) {\n\t\t\tlast_response_time = ros::Time::now();\n\t\t\tmotor_test_passed = false;\n\t\t}\n\t\tif (motor_test_failed) {\n\t\t\tlast_failure_time = ros::Time::now();\n\t\t\tmotor_test_failed = false;\n\t\t}\n\t\tif (motor_test_passed && (ros::Time::now() - last_pass_time).toSec() > 1.0) {\n\t\t\tpass = true;\n\t\t\tlast_pass_time = ros::Time::now();\n\t\t}\n\t\tif ((ros::Time::now() - last_request_time).toSec() > 0.5) {\n\t\t\tpass = false;\n\t\t\tbreak;\n\t\t}\n\t\tif ((ros::Time::now() - last_response_time).toSec() > 2.0) {\n\t\t\tpass = false;\n\t\t\tbreak;\n\t\t}\n\t\tif ((ros::Time::now() - last_failure_time).toSec() > 2.0) {\n\t\t\tpass = false;\n\t\t\tbreak;\n\t\t}\n\t\tros::spinOnce();\n\t}\n\tif (!pass) {\n\t\tstd_msgs::String msg;\n\t\tmsg.data = \"Motor test timed out.\";\n\t\tmotor_test_failure_pub.publish(msg);\n\t\tdisable_motor_test();\n\t\tarm_system();", "CodeBleu_score": 48.77942851569574}, {"code": "bool Sub::verify_motor_test(){\n\t    if(motor_test_pass) {\n        return true;\n    }\n    else {\n        if(millis() - motor_test_time > 2000) {\n            send_timeout_msg();\n            motor_test_pass = false;\n            disable_motor_test();\n            disable_system();\n            motor_test_fail_time = millis();\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n}", "CodeBleu_score": 44.36184547201018}, {"code": "bool Sub::verify_motor_test(){\n\t\tif (motor_test_start_time == 0) {\n\t\tmotor_test_start_time = millis();\n\t\treturn true;\n\t}\n\tif (millis() - motor_test_start_time > 1000) {\n\t\tif (motor_test_req_cnt == 0) {\n\t\t\tSerial.println(\"Motor test timed out\");\n\t\t\tpass = false;\n\t\t\tdisable_motor_test();\n\t\t\tarm_disarm(false);\n\t\t\tfailure_time = millis();\n\t\t\treturn false;\n\t\t}\n\t\tSerial.println(\"Motor test passed\");\n\t\treturn true;\n\t}\n\treturn true;\n}", "CodeBleu_score": 48.94771343021207}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target, pitch_target;\n\t\n\troll_target = wp_nav.get_roll_target();\n\tpitch_target = wp_nav.get_pitch_target();\n\t\n\t// If roll target is not set, set it to 0.\n\tif (roll_target == 0) {\n\t\troll_target = 0;\n\t}\n\t\n\t// If pitch target is not set, set it to 0.\n\tif (pitch_target == 0) {\n\t\tpitch_target = 0;\n\t}\n\t\n\t// If roll target is greater than max roll angle, set it to max roll angle.\n\tif (roll_target > max_roll_angle) {\n\t\troll_target = max_roll_angle;\n\t}\n\t\n\t// If pitch target is greater than max pitch angle, set it to max pitch angle.\n\tif (pitch_target > max_pitch_angle) {\n\t\tpitch_target = max_pitch_angle;\n\t}\n\t\n\t// If roll target is less than -max roll angle, set it to -max roll angle.\n\tif (roll_target < -max_roll_angle) {\n\t\troll_target = -max_roll_angle;\n\t}\n\t\n\t// If pitch target is less than -max pitch angle, set it to -max pitch angle.\n\tif (pitch_target < -max_pitch_angle) {\n\t\tpitch_target = -max_pitch_angle;\n\t}\n\t\n\t// Normalize roll target.\n\tif (roll_target > 0) {\n\t\troll_target = roll_target / max_roll_angle;\n\t} else {\n\t\troll_target = roll_target / -max_roll_angle;\n\t}\n\t\n\t// Normalize pitch target.\n\tif (pitch_target > 0) {\n\t\tpitch_target = pitch_target / max_pitch_angle;\n\t} else {\n\t\tpitch_target = pitch_target / -max_pitch_angle;\n\t}\n\t\n\t// Assign normalized roll and pitch targets to later", "CodeBleu_score": 27.436726771884818}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Get roll and pitch targets from wp_nav\n\tfloat wp_nav_rp[2] = {wp_nav.roll, wp_nav.pitch};\n\n\t// Constrain roll and pitch targets within a specified maximum angle range\n\tfor (int i = 0; i < 2; i++) {\n\t\tif (wp_nav_rp[i] > 18000) {\n\t\t\twp_nav_rp[i] = 18000;\n\n\t\t} else if (wp_nav_rp[i] < -18000) {\n\t\t\twp_nav_rp[i] = -18000;\n\t\t}\n\t}\n\n\t// Normalize roll and pitch targets\n\tfloat norm_rp[2] = {0, 0};\n\tfor (int i = 0; i < 2; i++) {\n\t\tnorm_rp[i] = (wp_nav_rp[i] + 18000) / 18000;\n\t}\n\n\t// Assign normalized values to lateral_out and forward_out\n\tlateral_out = norm_rp[0];\n\tforward_out = norm_rp[1];\n}", "CodeBleu_score": 31.883372062454345}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Get roll and pitch targets from wp_nav\n\tfloat roll_target = wp_nav.wp_cmd.roll;\n\tfloat pitch_target = wp_nav.wp_cmd.pitch;\n\n\t// Constrain roll and pitch targets\n\tif (roll_target > 36000) {\n\t\troll_target -= 36000;\n\t}\n\tif (roll_target < -36000) {\n\t\troll_target += 36000;\n\t}\n\tif (pitch_target > 36000) {\n\t\tpitch_target -= 36000;\n\t}\n\tif (pitch_target < -36000) {\n\t\tpitch_target += 36000;\n\t}\n\n\t// Normalize roll and pitch targets\n\tfloat roll_norm = (roll_target + 36000) / 36000.0f;\n\tfloat pitch_norm = (pitch_target + 36000) / 36000.0f;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 33.634364971321126}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// Read the barometer\n\tbarometer.update();\n\n\t// If the altitude is above zero, update the barometer calibration\n\tif (barometer.altitude() > 0) {\n\t\tbarometer_calibration = barometer.altitude();\n\t}\n\n\t// If a depth sensor is present, update the sensor health status based on the barometer's health\n\tif (depth_sensor != NULL) {\n\t\tdepth_sensor->set_health(barometer.healthy());\n\t}\n}", "CodeBleu_score": 57.29010814637265}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer.read()) {\n\t\tif (barometer.altitude() > 0) {\n\t\t\tif (barometer.healthy()) {\n\t\t\t\tif (barometer.altitude() > 50) {\n\t\t\t\t\tbarometer_calibration = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbarometer_calibration = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbarometer_calibration = 2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbarometer_calibration = 2;\n\t\t}\n\t}\n\telse {\n\t\tbarometer_calibration = 2;\n\t}\n}", "CodeBleu_score": 47.91286661500269}, {"code": "void Sub::read_barometer(){\n\t\t// Get the barometer data\n\tfloat altitude = barometer.readAltitude(sea_level_pressure);\n\tfloat pressure = barometer.readPressure();\n\tfloat temperature = barometer.readTemperature();\n\n\t// Check if the altitude is above zero\n\tif (altitude > 0) {\n\t\t// Update the barometer calibration\n\t\tupdate_barometer_calibration(altitude, pressure, temperature);\n\t}\n\n\t// Check if a depth sensor is present\n\tif (depth_sensor_present) {\n\t\t// Update the sensor health status\n\t\tupdate_sensor_health_status(altitude, pressure, temperature);\n\t}\n}", "CodeBleu_score": 50.88259192570986}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    if (inertial_nav_valid()) {\n        if (armed()) {\n            if (ekf_absolute_position_ok()) {\n                if (ekf_constant_position_mode_ok()) {\n                    return true;\n                }\n            }\n        } else {\n            if (ekf_predicted_position_ok()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "CodeBleu_score": 16.036152811698077}, {"code": "bool Sub::ekf_position_ok(){\n\t    if (inertial_nav) {\n        if (armed) {\n            if (ekf_position_valid) {\n                if (ekf_constant_pos_mode) {\n                    return false;\n                } else {\n                    return true;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 15.334006839263878}, {"code": "bool Sub::ekf_position_ok(){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_APM1\n    if (ahrs.failsafe_enabled()) {\n        return false;\n    }", "CodeBleu_score": 14.844964752747766}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (AP_Arming::gps_checks(display_failure) == false) {\n\t\treturn false;\n\t}\n\n\tif (!_ahrs.get_control_mode()->position) {\n\t\treturn true;\n\t}\n\n\tif (_ahrs.get_control_mode()->flag_control_velocity_enabled) {\n\t\tif (_ahrs.get_control_mode()->flag_control_velocity_enabled && !_ahrs.get_control_mode()->flag_control_altitude_enabled) {\n\t\t\tif (!_ahrs.get_control_mode()->flag_control_velocity_enabled) {\n\t\t\t\tif (display_failure) {\n\t\t\t\t\t_ahrs.print_message(\"Velocity control not enabled\");\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_ahrs.get_control_mode()->flag_control_altitude_enabled) {\n\t\tif (!_ahrs.get_control_mode()->flag_control_altitude_enabled) {\n\t\t\tif (display_failure) {\n\t\t\t\t_ahrs.print_message(\"Altitude control not enabled\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (_ahrs.get_control_mode()->flag_control_climb_rate_enabled) {\n\t\tif (!_ahrs.get_control_mode()->flag_control_climb_rate_enabled) {\n\t\t\tif (display_failure) {\n\t\t\t\t_ahrs.print_message(\"Climb rate control not enabled\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!_ahrs.get_control_mode()->flag_control_velocity_enabled && !_ahrs.get_control_mode()->flag_control_altitude_enabled) {\n\t\tif (display_failure) {\n\t\t\t_ahrs.print_message(\"No position or velocity control enabled\");\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!_ah", "CodeBleu_score": 34.4778830232623}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    bool ret = AP_Arming::gps_checks(display_failure);\n    if (ret) {\n        if (!ahrs.is_fusion_initialized()) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"GPS check failed: AHRS not initialized\n\"));\n            }\n            ret = false;\n        } else if (ahrs.failsafe()) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"GPS check failed: EKF failsafe active\n\"));\n            }\n            ret = false;\n        } else if (!ahrs.position_valid()) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"GPS check failed: position not valid\n\"));\n            }\n            ret = false;\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 47.210185474282945}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n    if (!_ahrs->is_initialised()) {\n        if (display_failure) {\n            hal.console->println_P(PSTR(\"AHRS not initialised\"));\n        }\n        return false;\n    }\n    if (_ekf->failsafe_status() == EKF_FAILSAFE_ENABLED) {\n        if (display_failure) {\n            hal.console->println_P(PSTR(\"EKF failsafe active\"));\n        }\n        return false;\n    }\n    if (!_ekf->position_valid()) {\n        if (display_failure) {\n            hal.console->println_P(PSTR(\"EKF position not valid\"));\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 51.16056233138509}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (method == AP_Arming::ARMED) {\n        if (do_arming_checks) {\n            if (!check_arming()) {\n                return false;\n            }\n        }\n        // update soft armed status\n        if (soft_armed()) {\n            set_soft_armed(false);\n        }\n        // set home location\n        if (home_location() == NULL) {\n            set_home_location(&(rover.get_location()));\n        }\n        // set initial simple mode heading\n        if (rover.simple_mode_enabled()) {\n            rover.set_simple_mode_heading(rover.get_heading());\n        }\n        // record home heading for sail vehicles\n        if (rover.get_vehicle_type() == AP_Rover::VEHICLE_SAIL) {\n            rover.set_home_heading(rover.get_heading());\n        }\n        // send arm/disarm status text\n        if (rover.get_vehicle_type() == AP_Rover::VEHICLE_SAIL) {\n            rover.send_status_text(AP_Rover::STATUS_TEXT_ARMING_SAIL);\n        } else {\n            rover.send_status_text(AP_Rover::STATUS_TEXT_ARMING);\n        }\n        return true;\n    }\n    if (method == AP_Arming::DISARMED) {\n        if (do_arming_checks) {\n            if (!check_disarming()) {\n                return false;\n            }\n        }\n        // update soft armed status\n        if (!soft_armed()) {\n            set_soft_armed(true);\n        }\n        // clear home location\n        if (home_location() != NULL) {\n            set_home_location(NULL);\n        }\n        // clear initial simple mode heading\n        if (rover.simple_mode_enabled()) {\n            rover.set_simple_mode_heading(0);\n        }\n        // send arm/disarm status text\n        if (rover.get_vehicle_type", "CodeBleu_score": 39.85823648528844}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // If we are already armed, don't allow arming again.\n    if (armed()) {\n        return false;\n    }\n\n    // If we are not armed, attempt to arm.\n    if (AP_Arming::arm(method, do_arming_checks)) {\n        // If we are armed, initialize the simple mode heading and set the home location.\n        if (armed()) {\n            // Initialize the simple mode heading.\n            if (AP_Rover::simple_mode) {\n                simple_mode_heading = _ahrs.yaw;\n            }\n\n            // Set the home location.\n            if (AP_Rover::home_is_set()) {\n                _home.set_location(location());\n            }\n\n            // Update the soft armed status.\n            if (AP_Rover::simple_mode) {\n                _soft_armed = true;\n            }\n\n            // Send an arm/disarm status text.\n            if (method == AP_Arming::INITIAL_ARM) {\n                _mavlink_log_info(_mavlink_fd, \"ARMED\");\n            } else {\n                _mavlink_log_info(_mavlink_fd, \"DISARMED\");\n            }\n\n            return true;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 44.42490029661448}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (armed) {\n        return true;\n    }\n\n    // if we're not armed, then we're not soft armed\n    soft_armed = false;\n\n    // if we're not armed, then we're not in a failsafe state\n    failsafe_state = AP_HAL::Util::get_soft_failsafe();\n\n    // if we're not armed, then we're not in a failsafe state\n    failsafe_state_old = failsafe_state;\n\n    // if we're not armed, then we're not in a failsafe state\n    failsafe_state_new = failsafe_state;\n\n    // if we're not armed, then we're not in a failsafe state\n    failsafe_state_new_old = failsafe_state;\n\n    // if we're not armed, then we're not in a failsafe state\n    failsafe_state_new_old_old = failsafe_state;\n\n    // if we're not armed, then we're not in a failsafe state\n    failsafe_state_new_old_old_old = failsafe_state;\n\n    // if we're not armed, then we're not in a failsafe state\n    failsafe_state_new_old_old_old_old = failsafe_state;\n\n    // if we're not armed, then we're not in a failsafe state\n    failsafe_state_new_old_old_old_old_old = failsafe_state;\n\n    // if we're not armed, then we're not in a failsafe state\n    failsafe_state_new_old_old_old_old_old_old = failsafe_state;\n\n    // if we're not armed, then we're not in a failsafe state\n    failsafe_state_new_old_old_old_old_old_old_old = failsafe_state;\n\n    // if we're not armed, then we're not in a failsafe state\n    failsa", "CodeBleu_score": 19.747834278528735}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (charging_enabled) {\n      // If charging is enabled but should not continue, disable it and record the time.\n      if (!charging_continue) {\n        charging_enabled = false;\n        charging_end_time = millis();\n      }\n    } else {\n      // If charging is not enabled, retry enabling charging after a specified delay, checking the conditions again to decide whether to enable or continue disabling charging.\n      if (millis() - charging_last_attempt_time >= charging_retry_delay) {\n        charging_last_attempt_time = millis();\n        if (charging_continue) {\n          charging_enabled = true;\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 44.80056934268395}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed && !charging_enabled) {\n    charging_enabled = true;\n    charging_start_time = millis();\n  }\n  else if (!charging_allowed && charging_enabled) {\n    charging_enabled = false;\n    charging_stop_time = millis();\n    charging_stop_time_valid = true;\n  }\n}", "CodeBleu_score": 26.312501515764623}, {"code": "void updateChargingEnabled(){\n\t\n  if (charging_allowed && !charging_enabled) {\n\n    charging_enabled = true;\n\n    charging_start_time = millis();\n\n  }\n\n  else if (!charging_allowed && charging_enabled) {\n\n    charging_enabled = false;\n\n    charging_end_time = millis();\n\n    charging_end_delay = millis() + 10000;\n\n  }\n\n  else if (charging_allowed && charging_enabled) {\n\n    if (millis() - charging_end_delay > 0) {\n\n      charging_enabled = false;\n\n      charging_end_time = millis();\n\n      charging_end_delay = millis() + 10000;\n\n    }\n\n  }\n\n}", "CodeBleu_score": 41.90516254576704}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\n  if (size < 4) {\n\n    return;\n\n  }\n\n  uint8_t *msg = (uint8_t *)message;\n\n  uint16_t crc = 0;\n\n  for (size_t i = 0; i < size; i++) {\n\n    crc = _crc_ccitt_update(crc, msg[i]);\n\n  }\n\n  msg[size] = (uint8_t)(crc >> 8);\n\n  msg[size + 1] = (uint8_t)(crc & 0xFF);\n\n  size += 2;\n\n  packetSerial.send(msg, size);\n\n}", "CodeBleu_score": 58.225244471822876}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (rosRunning && size >= 4) {\n    uint16_t crc = crc16_ccitt((uint8_t *)message, size);\n    uint8_t *messageWithCRC = (uint8_t *)message;\n    messageWithCRC[size] = crc >> 8;\n    messageWithCRC[size + 1] = crc & 0xFF;\n    packetSerial.send(message, size + 2);\n  }\n}", "CodeBleu_score": 56.83348600288154}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (rosRunning && size >= 4) {\n    uint8_t *msg = (uint8_t *)message;\n    uint8_t crc = 0;\n    for (size_t i = 0; i < size; i++) {\n      crc = crc8(crc, msg[i]);\n    }\n    msg[size] = crc;\n    packetSerial.write(msg, size + 1);\n  }\n}", "CodeBleu_score": 43.41363793938229}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t    // Initialize the sound module\n    if (!sound.begin()) {\n        Serial.println(\"Couldn't find sound module!\");\n        return false;\n    }\n    // Clear the buffer\n    sound.clearBuffer();\n    // Initialize the SD card\n    if (!SD.begin(SD_CS)) {\n        Serial.println(\"Couldn't find SD card!\");\n        return false;\n    }\n    // Get the number of sound files\n    numSounds = sound.getNumFiles();\n    // Return true if there are one or more sound files available\n    return numSounds > 0;\n}", "CodeBleu_score": 46.07511806132804}, {"code": "bool MP3Sound::begin(){\n\t\n  // Initialize the serial communication with the sound module\n  if (SerialMP3.begin(9600)) {\n    Serial.println(\"SerialMP3.begin() success\");\n  } else {\n    Serial.println(\"SerialMP3.begin() failed\");\n    return false;\n  }\n\n  // Clear any existing data in the buffer\n  while (SerialMP3.available()) {\n    SerialMP3.read();\n  }\n\n  // Initialize the sound module\n  if (SerialMP3.play()) {\n    Serial.println(\"SerialMP3.play() success\");\n  } else {\n    Serial.println(\"SerialMP3.play() failed\");\n    return false;\n  }\n\n  // Get the number of sound files available on the SD card\n  if (SerialMP3.available()) {\n    numSounds = SerialMP3.read();\n    Serial.print(\"Number of sounds: \");\n    Serial.println(numSounds);\n  } else {\n    Serial.println(\"No sounds available\");\n    return false;\n  }\n\n  // Initialize the sound files\n  for (int i = 0; i < numSounds; i++) {\n    if (SerialMP3.available()) {\n      soundFiles[i] = SerialMP3.read();\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 44.256439139757745}, {"code": "bool MP3Sound::begin(){\n\t    if (Serial.begin(9600, SERIAL_8N1, RX, TX) == false) {\n        return false;\n    }\n\n    Serial.println(\"\");\n    Serial.println(\"Initializing sound module...\");\n\n    Serial.println(\"\");\n    Serial.println(\"Clearing buffer...\");\n    Serial.println(\"\");\n\n    Serial.println(\"\");\n    Serial.println(\"Initializing sound module...\");\n\n    Serial.println(\"\");\n    Serial.println(\"Clearing buffer...\");\n    Serial.println(\"\");\n\n    Serial.println(\"\");\n    Serial.println(\"Initializing sound module...\");\n\n    Serial.println(\"\");\n    Serial.println(\"Clearing buffer...\");\n    Serial.println(\"\");\n\n    Serial.println(\"\");\n    Serial.println(\"Initializing sound module...\");\n\n    Serial.println(\"\");\n    Serial.println(\"Clearing buffer...\");\n    Serial.println(\"\");\n\n    Serial.println(\"\");\n    Serial.println(\"Initializing sound module...\");\n\n    Serial.println(\"\");\n    Serial.println(\"Clearing buffer...\");\n    Serial.println(\"\");\n\n    Serial.println(\"\");\n    Serial.println(\"Initializing sound module...\");\n\n    Serial.println(\"\");\n    Serial.println(\"Clearing buffer...\");\n    Serial.println(\"\");\n\n    Serial.println(\"\");\n    Serial.println(\"Initializing sound module...\");\n\n    Serial.println(\"\");\n    Serial.println(\"Clearing buffer...\");\n    Serial.println(\"\");\n\n    Serial.println(\"\");\n    Serial.println(\"Initializing sound module...\");\n\n    Serial.println(\"\");\n    Serial.println(\"Clearing buffer...\");\n    Serial.println(\"\");\n\n    Serial.println(\"\");\n    Serial.println(\"Initializing sound module...\");\n\n    Serial.println(\"\");\n    Serial.println(\"Clearing buffer...\");\n    Serial.println(\"\");\n\n    Serial.println(\"\");\n    Serial.println(\"Initializing sound module...\");\n\n    Serial.println(\"\");\n    Serial.println(\"Clearing buffer...\");\n    Serial.println(\"\");\n\n    Serial.println(\"\");\n    Serial.println(\"Initial", "CodeBleu_score": 26.028005005401745}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (playingMP3) {\n\t\treturn activeSounds.size();\n\t}\n\tSound *sound = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplaySound(sound);\n\treturn activeSounds.size();\n}", "CodeBleu_score": 39.77699329030385}, {"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (isPlaying) {\n\t\treturn activeSounds.size();\n\t}\n\tSound *sound = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplaySound(sound);\n\treturn activeSounds.size();\n}", "CodeBleu_score": 39.85402513659705}, {"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0 || playing)\n\t\treturn activeSounds.size();\n\telse {\n\t\tSound *snd = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\tplaySound(snd);\n\t\treturn activeSounds.size();\n\t}\n}", "CodeBleu_score": 38.089151140961995}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    WbCameraMemoryMappedFileRequest *req = (WbCameraMemoryMappedFileRequest *)wb_request_get_data(r);\n    WbCamera *c = d->pdata;\n    if (c->mapped_file) {\n      if (c->mapped_file->fd != req->fd) {\n        close(c->mapped_file->fd);\n        free(c->mapped_file);\n        c->mapped_file = NULL;\n      }\n    }\n    if (!c->mapped_file)\n      c->mapped_file = malloc(sizeof(WbCameraMemoryMappedFile));\n    c->mapped_file->fd = req->fd;\n    c->mapped_file->offset = req->offset;\n    c->mapped_file->size = req->size;\n    c->mapped_file->width = req->width;\n    c->mapped_file->height = req->height;\n    c->mapped_file->stride = req->stride;\n    c->mapped_file->format = req->format;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 42.17289388845737}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    WbDeviceTag tag = d->tag;\n    WbFieldCode code = r->c_camera_memory_mapped_file.field_code;\n    if (wb_robot_get_device_from_tag(tag) == NULL) {\n      fprintf(stderr, \"Error: %s() called with an invalid tag (%d).\n\", __FUNCTION__, tag);\n      return false;\n    }\n    if (wb_robot_get_device_from_field_code(tag, code) == NULL) {\n      fprintf(stderr, \"Error: %s() called with an invalid field code (%d).\n\", __FUNCTION__, code);\n      return false;\n    }\n    WbField *f = wb_robot_get_field(tag, code);\n    if (f->type != WB_FLOAT) {\n      fprintf(stderr, \"Error: %s() called with an invalid field type (%d).\n\", __FUNCTION__, f->type);\n      return false;\n    }\n    if (f->count != 1) {\n      fprintf(stderr, \"Error: %s() called with an invalid field count (%d).\n\", __FUNCTION__, f->count);\n      return false;\n    }\n    if (f->data[0] < 0.0) {\n      fprintf(stderr, \"Error: %s() called with an invalid value (%f).\n\", __FUNCTION__, f->data[0]);\n      return false;\n    }\n    wb_abstract_camera_cleanup_memory_mapped_file(d);\n    d->c_camera_memory_mapped_file.request = *r;\n    d->c_camera_memory_mapped_file.request_ready = true;\n    return true;\n  }\n  d->command_handled = false;\n  return false;\n}", "CodeBleu_score": 35.28646446435385}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *c = d->pdata;\n  bool command_handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (c->memory_mapped_file)\n        wb_abstract_camera_cleanup_memory_mapped_file(c);\n      wb_abstract_camera_setup_memory_mapped_file(c, r);\n      break;\n    }\n    default:\n      command_handled = false;\n  }\n  return command_handled;\n}", "CodeBleu_score": 61.329246889813426}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (!d) {\n    fprintf(stderr, \"Error: %s(): device is NULL.\n\", __FUNCTION__);\n    return -1;\n  }\n\n  if (d->type != WB_DEVICE_ABSTRACT_CAMERA) {\n    fprintf(stderr, \"Error: %s() called on a device which is not an AbstractCamera.\n\", __FUNCTION__);\n    return -1;\n  }\n\n  AbstractCamera *c = d->pdata;\n  if (c->height_changed) {\n    c->height_changed = false;\n    return c->height;\n  }\n\n  return -1;\n}", "CodeBleu_score": 37.134938384670406}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (!d) {\n    fprintf(stderr, \"Error: %s() called with null pointer.\n\", __FUNCTION__);\n    return -1;\n  }\n  if (d->type != WB_DEVICE_TYPE_ABSTRACT_CAMERA) {\n    fprintf(stderr, \"Error: %s() called for a non-abstract camera device.\n\", __FUNCTION__);\n    return -1;\n  }\n  AbstractCamera *ac = d->pdata;\n  if (ac->height < 0)\n    return -1;\n  return ac->height;\n}", "CodeBleu_score": 41.51494321044762}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (d->type != WB_DEVICE_ABSTRACT_CAMERA) {\n    fprintf(stderr, \"Error: %s() called on a non-abstract camera device.\n\", __FUNCTION__);\n    return -1;\n  }\n\n  AbstractCamera *ac = d->pdata;\n  if (ac->data_ready) {\n    return ac->height;\n  } else {\n    return -1;\n  }\n}", "CodeBleu_score": 43.33613812417635}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  WbDevice *d = robot_get_device_with_node(tag, WB_NODE_ACCELEROMETER, true);\n  if (!d) {\n    sampling_period = -1;\n  } else {\n    sampling_period = d->sampling_period;\n  }\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 41.11490742053533}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  if (tag == 0) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    return -1;\n  }\n  WbDevice *device = find_device(tag);\n  if (device == NULL) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    return -1;\n  }\n  if (device->type != ACCELEROMETER) {\n    fprintf(stderr, \"Error: %s() called on a device which is not an accelerometer.\n\", __FUNCTION__);\n    return -1;\n  }\n  WbAccelerometer *accelerometer = (WbAccelerometer *)device;\n  sampling_period = accelerometer->sampling_period;\n  return sampling_period;\n}", "CodeBleu_score": 49.132920144600845}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  WbDevice *d = robot_get_device_by_tag(tag);\n  if (d == NULL) {\n    fprintf(stderr, \"Error: %s() failed.\n\", __FUNCTION__);\n    return -1;\n  }\n  if (d->type != ACCELEROMETER) {\n    fprintf(stderr, \"Error: %s() failed, device %d is not an accelerometer.\n\", __FUNCTION__, tag);\n    return -1;\n  }\n  Accelerometer *accelerometer = d->pdata;\n  return accelerometer->sampling_period;\n}", "CodeBleu_score": 43.73389418657473}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 39.37179132599584}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *c_string = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dms(c_string);\n  free(c_string);\n  return dms;\n}", "CodeBleu_score": 41.2281893779458}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = dms;\n  free(dms);\n  return result;\n}", "CodeBleu_score": 43.090065346945124}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dAASSERT (g);\n    dUASSERT (g->type == dBoxClass, \"argument not a box\");\n    const dReal * R = dGeomGetRotation (g);\n    const dReal * P = dGeomGetPosition (g);\n    const dReal * b = ((dxBox*) g)->side;\n    dVector3 p;\n    dMULTIPLY0_331 (p,R,&x-P[0],&y-P[1],&z-P[2]);\n    if (p[0] < -b[0]) {\n        plane[0] = 1;\n        plane[1] = 0;\n        plane[2] = 0;\n        plane[3] = -b[0];\n    }\n    else if (p[0] > b[0]) {\n        plane[0] = -1;\n        plane[1] = 0;\n        plane[2] = 0;\n        plane[3] = b[0];\n    }\n    else if (p[1] < -b[1]) {\n        plane[0] = 0;\n        plane[1] = 1;\n        plane[2] = 0;\n        plane[3] = -b[1];\n    }\n    else if (p[1] > b[1]) {\n        plane[0] = 0;\n        plane[1] = -1;\n        plane[2] = 0;\n        plane[3] = b[1];\n    }\n    else if (p[2] < -b[2]) {\n        plane[0] = 0;\n        plane[1] = 0;\n        plane[2] = 1;\n        plane[3] = -b[2];\n    }\n    else if (p[2] > b[2]) {\n        plane[0] = 0;\n        plane[1] = 0;\n        plane[2] = -1;\n        plane[3] = b[2];\n    }\n    else {\n        plane[0] = 0;\n        plane[1] = 0;\n        plane[2]", "CodeBleu_score": 31.30919218800819}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  dUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n  const dReal *R = dGeomGetRotation (g);\n  const dReal *C = dGeomGetPosition (g);\n  dVector3 p;\n  dMULTIPLY0_331 (p,R,&x);\n  p[0] += C[0];\n  p[1] += C[1];\n  p[2] += C[2];\n  dVector3 n;\n  dMULTIPLY1_331 (n,R,&x);\n  dReal d = dFabs (n[0]);\n  if (dFabs (n[1]) > d) d = dFabs (n[1]);\n  if (dFabs (n[2]) > d) d = dFabs (n[2]);\n  if (dFabs (p[0]) > d) d = dFabs (p[0]);\n  if (dFabs (p[1]) > d) d = dFabs (p[1]);\n  if (dFabs (p[2]) > d) d = dFabs (p[2]);\n  dMULTIPLY1_331 (n,R,&y);\n  if (dFabs (n[0]) > d) d = dFabs (n[0]);\n  if (dFabs (n[1]) > d) d = dFabs (n[1]);\n  if (dFabs (n[2]) > d) d = dFabs (n[2]);\n  if (dFabs (p[0]) > d) d = dFabs (p[0]);\n  if (dFabs (p[1]) > d) d = dFabs (p[1]);\n  if (dFabs (p[2]) > d) d = dFabs (p[2]);\n  dMULTIPLY1_331 (n,R,&z);\n  if (dFabs (n[0]) > d) d = dFabs (n[0]);\n  if (dFabs (n[1]) > d) d", "CodeBleu_score": 31.437283819790434}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  dUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n  const dReal* R = dGeomGetRotation (g);\n  const dReal* p = dGeomGetPosition (g);\n  const dReal* b = dGeomBoxGetLengths (g);\n  dVector3 center;\n  dMULTIPLY0_331 (center, R, p);\n  dReal dx = x - center[0];\n  dReal dy = y - center[1];\n  dReal dz = z - center[2];\n  dReal dmin = dFabs (dx);\n  dReal dmax = dFabs (dx);\n  if (dFabs (dy) > dmax) dmax = dFabs (dy);\n  if (dFabs (dz) > dmax) dmax = dFabs (dz);\n  if (dFabs (dy) > dmin) dmin = dFabs (dy);\n  if (dFabs (dz) > dmin) dmin = dFabs (dz);\n  if (dmin > b[0]) {\n    if (dmin == dFabs (dx)) {\n      plane[0] = R[0];\n      plane[1] = R[3];\n      plane[2] = R[6];\n      plane[3] = center[0] - R[0]*b[0] - R[3]*b[1] - R[6]*b[2];\n    }\n    else {\n      plane[0] = R[1];\n      plane[1] = R[4];\n      plane[2] = R[7];\n      plane[3] = center[1] - R[1]*b[0] - R[4]*b[1] - R[7]*b[2];\n    }\n  }\n  else if (dmax > b[1]) {\n    if (dmax == dFabs (dy)) {\n      plane[0] = R[1];\n      plane[1] = R[4];\n      plane[2] = R[7];\n      plane[3] = center[1] - R[1]*b[", "CodeBleu_score": 44.5705638614174}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n    if (box == NULL) {\n        return 0;\n    }\n\n    if (immersion == NULL) {\n        return 0;\n    }\n\n    if (flags & ~(IMMERSION_BOX_FLAGS)) {\n        return 0;\n    }\n\n    if (flags & IMMERSION_BOX_INIT_BODY) {\n        if (box->body == NULL) {\n            return 0;\n        }\n    }\n\n    if (flags & IMMERSION_BOX_INIT_BODY_GEOM) {\n        if (box->body->geom == NULL) {\n            return 0;\n        }\n    }\n\n    if (flags & IMMERSION_BOX_INIT_BODY_DATA) {\n        if (box->body->data == NULL) {\n            return 0;\n        }\n    }\n\n    if (flags & IMMERSION_BOX_INIT_BODY_VELOCITY) {\n        if (box->body->velocity == NULL) {\n            return 0;\n        }\n    }\n\n    if (flags & IMMERSION_BOX_INIT_BODY_ACCELERATION) {\n        if (box->body->acceleration == NULL) {\n            return 0;\n        }\n    }\n\n    if (flags & IMMERSION_BOX_INIT_BODY_FORCE) {\n        if (box->body->force == NULL) {\n            return 0;\n        }\n    }\n\n    if (flags & IMMERSION_BOX_INIT_BODY_TORQUE) {\n        if (box->body->torque == NULL) {\n            return 0;\n        }\n    }\n\n    if (flags & IMMERSION_BOX_INIT_BODY_MASS) {\n        if (box->body->mass == NULL) {\n            return 0;\n        }\n    }\n\n    if (flags & IMMERSION_BOX_INIT_BODY_INERTIA) {\n        if (box->body->inertia == NULL", "CodeBleu_score": 36.25118147234169}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n  dIASSERT (box && immersion);\n  dIASSERT (box->body && (box->flags & dxBodyGyroscopic));\n\n  sBoxImmersionData data;\n\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.flags = flags;\n  data.immersion = immersion;\n\n  return dImmerseBox (data);\n}", "CodeBleu_score": 48.8096821591556}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n    // check the box\n    dAASSERT (box);\n    dAASSERT (box->body);\n    dAASSERT (box->body->world);\n    dAASSERT (box->body->world->immersion_kernel);\n    dAASSERT (box->body->world->immersion_kernel->immersion_data);\n    dAASSERT (box->body->world->immersion_kernel->immersion_data->outline);\n\n    // check the flags\n    dAASSERT (flags & dIMM_BOX_BODY);\n    dAASSERT (flags & dIMM_BOX_FLUID);\n\n    // check the immersion\n    dAASSERT (immersion);\n\n    // check the fluid plane\n    dAASSERT (fluidPlane);\n    dAASSERT (fluidPlane[3] == 1);\n\n    // initialize the immersion data\n    sBoxImmersionData *data = (sBoxImmersionData *)\n        box->body->world->immersion_kernel->immersion_data->outline;\n    data->box = box;\n    data->fluidPlane = fluidPlane;\n    data->immersion = immersion;\n    data->flags = flags;\n\n    // perform the immersion checking\n    return dImmerseBox (data);\n}", "CodeBleu_score": 39.702521704978736}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  if (!o1->data || !o2->data) return 0;\n  dxBox *box = (dxBox*) o1->data;\n  dxCapsule *capsule = (dxCapsule*) o2->data;\n  if (box->type != dBoxClass || capsule->type != dCapsuleClass) return 0;\n  if (!immersion) return 0;\n\n  dVector3 box_pos;\n  dMatrix3 box_R;\n  dGeomGetPosition (o1, box_pos);\n  dGeomGetRotation (o1, box_R);\n\n  dVector3 capsule_pos;\n  dMatrix3 capsule_R;\n  dGeomGetPosition (o2, capsule_pos);\n  dGeomGetRotation (o2, capsule_R);\n\n  dVector3 capsule_pos_box;\n  dMULTIPLY0_331 (capsule_pos_box, box_R, capsule_pos);\n  capsule_pos_box[0] -= box_pos[0];\n  capsule_pos_box[1] -= box_pos[1];\n  capsule_pos_box[2] -= box_pos[2];\n\n  dReal radius = capsule->radius;\n  dReal lz = box->lz;\n  dReal lx = box->lx;\n  dReal ly = box->ly;\n\n  dReal l = dSqrt (capsule_pos_box[0]*capsule_pos_box[0] + capsule_pos_box[1]*capsule_pos_box[1]);\n  if (l > lz) return 0;\n\n  dReal l1 = l - radius;\n  if (l1 > lz) return 0;\n\n  dReal l2 = l + radius;\n  if (l2 < 0) return 0;\n\n  dReal lz1 = l1 - lx;\n  if (lz1 > lz) return 0;\n\n  dReal lz2 = l2 - lx;\n  if (lz2 < ", "CodeBleu_score": 39.792402499070526}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  // Validate the input arguments\n  if (o1 == NULL || o2 == NULL || immersion == NULL) {\n    return 0;\n  }\n  if (o1->type != dBoxClass || o2->type != dCapsuleClass) {\n    return 0;\n  }\n  // Get the box and capsule\n  dxBox *box = (dxBox *) o1;\n  dxCapsule *capsule = (dxCapsule *) o2;\n  // Get the capsule's parameters\n  const dReal radius = capsule->radius;\n  const dReal length = capsule->length;\n  // Get the capsule's endpoints\n  dVector3 a, b;\n  dMultiply0_331 (a, capsule->R, capsule->lateral_surface.offset);\n  dMultiply0_331 (b, capsule->R, capsule->lateral_surface.offset2);\n  // Get the box's parameters\n  const dReal *const box_size = box->side;\n  // Get the box's vertices\n  dVector3 v[8];\n  dVector3Set (v[0], box_size[0], box_size[1], box_size[2]);\n  dVector3Set (v[1], box_size[0], box_size[1], -box_size[2]);\n  dVector3Set (v[2], box_size[0], -box_size[1], box_size[2]);\n  dVector3Set (v[3], box_size[0], -box_size[1], -box_size[2]);\n  dVector3Set (v[4], -box_size[0], box_size[1], box_size[2]);\n  dVector3Set (v[5], -box_size[0], box_size[1], -box_size[2]);\n  dVector3Set (v[6], -box_size[0], -box_size[1], box_size[2]);\n  dVector3Set (v[7], -box_size[0], -box_size[1], -box_", "CodeBleu_score": 39.428461552632854}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n  // Check the input arguments\n  if (!o1 || !o2 || !immersion) return 0;\n  if (o1->type != dBoxClass) return 0;\n  if (o2->type != dCapsuleClass) return 0;\n  if (!(flags & dIMMERSION_BOX_CAPSULE_BOTH)) return 0;\n\n  // Get the box and capsule geometries\n  dxBox *box = (dxBox *) o1;\n  dxCapsule *capsule = (dxCapsule *) o2;\n\n  // Get the box and capsule parameters\n  dReal radius = box->radius;\n  dVector3 side = box->side;\n  dReal length = capsule->length;\n  dReal radius2 = radius * radius;\n  dReal length2 = length * length;\n  dReal radius_to_length = radius / length;\n  dReal radius_to_length2 = radius_to_length * radius_to_length;\n  dReal radius_to_length4 = radius_to_length2 * radius_to_length2;\n  dReal radius_to_length6 = radius_to_length2 * radius_to_length4;\n  dReal radius_to_length8 = radius_to_length4 * radius_to_length4;\n  dReal radius_to_length10 = radius_to_length4 * radius_to_length6;\n  dReal radius_to_length12 = radius_to_length6 * radius_to_length6;\n  dReal radius_to_length14 = radius_to_length6 * radius_to_length8;\n  dReal radius_to_length16 = radius_to_length8 * radius_to_length8;\n  dReal radius_to_length18 = radius_to_length8 * radius_to_length10;\n  dReal radius_to_length20 = radius_to_length10 * radius_to_length10;\n  dReal radius_to_length22 = radius_to_length10 * radius_to_length12;\n  dReal radius_to_length24", "CodeBleu_score": 36.366495301126704}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\n\t// Calculate the normalized volume of the immersed hemisphere.\n\tdReal volume = 0.0;\n\tdReal volumeSum = 0.0;\n\tdReal volumeSum2 = 0.0;\n\tdReal volumeSum3 = 0.0;\n\tdReal volumeSum4 = 0.0;\n\tdReal volumeSum5 = 0.0;\n\tdReal volumeSum6 = 0.0;\n\tdReal volumeSum7 = 0.0;\n\tdReal volumeSum8 = 0.0;\n\tdReal volumeSum9 = 0.0;\n\tdReal volumeSum10 = 0.0;\n\tdReal volumeSum11 = 0.0;\n\tdReal volumeSum12 = 0.0;\n\tdReal volumeSum13 = 0.0;\n\tdReal volumeSum14 = 0.0;\n\tdReal volumeSum15 = 0.0;\n\tdReal volumeSum16 = 0.0;\n\tdReal volumeSum17 = 0.0;\n\tdReal volumeSum18 = 0.0;\n\tdReal volumeSum19 = 0.0;\n\tdReal volumeSum20 = 0.0;\n\tdReal volumeSum21 = 0.0;\n\tdReal volumeSum22 = 0.0;\n\tdReal volumeSum23 = 0.0;\n\tdReal volumeSum24 = 0.0;\n\tdReal volumeSum25 = 0.0;\n\tdReal volumeSum26 = 0.0;\n\tdReal volumeSum27 = 0.0;\n\tdReal volumeSum28 = 0.0;\n\tdReal volumeSum29 = 0.0;\n\tdReal volumeSum30 = 0.0;\n\tdReal volumeSum31 = 0.0;\n\tdReal volumeSum32 = 0.0;\n\tdReal volumeSum33 = 0.0;\n\tdReal volumeSum34 = 0.0;\n\tdReal volumeSum35 = 0.0;\n\td", "CodeBleu_score": 10.654638899934612}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\n\tdReal z0 = zIOverR;\n\tdReal z1 = zIOverR + 1.0;\n\tdReal z2 = zIOverR + 2.0;\n\tdReal z3 = zIOverR + 3.0;\n\n\tdReal sinTheta0 = dSqrt(1.0 - z0 * z0);\n\tdReal sinTheta1 = dSqrt(1.0 - z1 * z1);\n\tdReal sinTheta2 = dSqrt(1.0 - z2 * z2);\n\tdReal sinTheta3 = dSqrt(1.0 - z3 * z3);\n\n\tdReal tanTheta0_2 = tanTheta0 * tanTheta0;\n\tdReal tanTheta1_2 = tanTheta1 * tanTheta1;\n\tdReal tanTheta2_2 = tanTheta2 * tanTheta2;\n\tdReal tanTheta3_2 = tanTheta3 * tanTheta3;\n\n\tdReal V = (sinTheta0 * tanTheta0_2 + sinTheta1 * tanTheta1_2 + sinTheta2 * tanTheta2_2 + sinTheta3 * tanTheta3_2) / 3.0;\n\n\tdReal V0 = (sinTheta0 * tanTheta0_2 + sinTheta1 * tanTheta1_2) / 2.0;\n\tdReal V1 = (sinTheta1 * tanTheta1_2 + sinTheta2 * tanTheta2_2) / 2.0;\n\tdReal V2 = (sinTheta2 * tanTheta2_2 + sinTheta3 * tanTheta3_2) / 2.0;\n\n\treturn V0 + V1 + V2 + V;\n}", "CodeBleu_score": 36.983273886126575}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\t// Calculate the normalized volume of the hemisphere\n\t//\n\t// This is the integral of the hemisphere's volume element over the hemisphere\n\t//\n\t//                 1\n\t//    V = --------------------------------------------------\n\t//        12 * r * (1 + 2 * zIOverR) * (1 - zIOverR) * sin(theta)\n\t//\n\t//\n\t// The volume element is given by\n\t//\n\t//                 1\n\t//    dV = --------------------------------------------------\n\t//        12 * r * (1 + 2 * zIOverR) * (1 - zIOverR) * sin(theta)\n\t//\n\t//\n\t// This is the volume element for a hemisphere of radius r and zIOverR = z/r.\n\t//\n\t//\n\t// The integral of the volume element over the hemisphere is given by\n\t//\n\t//                                                 1\n\t//    V = ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "CodeBleu_score": 7.113525746126487}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  // Calculate the x-coordinate of the buoyancy center.\n  dReal xB = (zIOverR * tanTheta0 + zIOverR * sinTheta1) / 3;\n\n  // Return the x-coordinate of the buoyancy center.\n  return (xB * volume);\n}", "CodeBleu_score": 28.334526747921423}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\n    dReal xBuoyancyCenter = 0;\n\n    dReal x0 = 0;\n    dReal x1 = 0;\n    dReal x2 = 0;\n    dReal x3 = 0;\n    dReal x4 = 0;\n    dReal x5 = 0;\n    dReal x6 = 0;\n    dReal x7 = 0;\n    dReal x8 = 0;\n    dReal x9 = 0;\n    dReal x10 = 0;\n    dReal x11 = 0;\n    dReal x12 = 0;\n    dReal x13 = 0;\n    dReal x14 = 0;\n    dReal x15 = 0;\n    dReal x16 = 0;\n    dReal x17 = 0;\n    dReal x18 = 0;\n    dReal x19 = 0;\n    dReal x20 = 0;\n    dReal x21 = 0;\n    dReal x22 = 0;\n    dReal x23 = 0;\n    dReal x24 = 0;\n    dReal x25 = 0;\n    dReal x26 = 0;\n    dReal x27 = 0;\n    dReal x28 = 0;\n    dReal x29 = 0;\n    dReal x30 = 0;\n    dReal x31 = 0;\n    dReal x32 = 0;\n    dReal x33 = 0;\n    dReal x34 = 0;\n    dReal x35 = 0;\n    dReal x36 = 0;\n    dReal x37 = 0;\n    dReal x38 = 0;\n    dReal x39 = 0;\n    dReal x40 = 0;\n    dReal x41 = 0;\n    dReal x42 = 0;\n    dReal x43 = 0;\n    dReal x44 = 0;\n    dReal x45 = 0;\n   ", "CodeBleu_score": 10.1369788090176}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\n\tdReal x0 = 0;\n\tdReal x1 = 0;\n\tdReal x2 = 0;\n\tdReal x3 = 0;\n\tdReal x4 = 0;\n\n\tdReal y0 = 0;\n\tdReal y1 = 0;\n\tdReal y2 = 0;\n\tdReal y3 = 0;\n\tdReal y4 = 0;\n\n\tdReal z0 = 0;\n\tdReal z1 = 0;\n\tdReal z2 = 0;\n\tdReal z3 = 0;\n\tdReal z4 = 0;\n\n\tdReal x0p = 0;\n\tdReal x1p = 0;\n\tdReal x2p = 0;\n\tdReal x3p = 0;\n\tdReal x4p = 0;\n\n\tdReal y0p = 0;\n\tdReal y1p = 0;\n\tdReal y2p = 0;\n\tdReal y3p = 0;\n\tdReal y4p = 0;\n\n\tdReal z0p = 0;\n\tdReal z1p = 0;\n\tdReal z2p = 0;\n\tdReal z3p = 0;\n\tdReal z4p = 0;\n\n\tdReal x0pp = 0;\n\tdReal x1pp = 0;\n\tdReal x2pp = 0;\n\tdReal x3pp = 0;\n\tdReal x4pp = 0;\n\n\tdReal y0pp = 0;\n\tdReal y1pp = 0;\n\tdReal y2pp = 0;\n\tdReal y3pp = 0;\n\tdReal y4pp = 0;\n\n\tdReal z0pp = 0;\n\tdReal z1pp = 0;\n\tdReal z2pp = 0;\n\tdReal z3pp = 0;\n\tdReal z4pp = 0;\n\n\tdReal x0ppp = 0;\n\tdReal x1ppp = 0", "CodeBleu_score": 9.747689178614596}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n  dIASSERT (SAFE_CONTACT(immersion,1));\n\n  dIASSERT (o1->type == dCapsuleClass);\n  dIASSERT (o2->type == dTriMeshClass);\n\n  dxCapsule *capsule = (dxCapsule*) o1;\n  dxTriMesh *mesh = (dxTriMesh*) o2;\n\n  dVector3 p;\n  dVector3 p1;\n  dVector3 p2;\n  dVector3 p3;\n  dVector3 p4;\n  dVector3 p5;\n  dVector3 p6;\n  dVector3 p7;\n  dVector3 p8;\n  dVector3 p9;\n  dVector3 p10;\n  dVector3 p11;\n  dVector3 p12;\n  dVector3 p13;\n  dVector3 p14;\n  dVector3 p15;\n  dVector3 p16;\n  dVector3 p17;\n  dVector3 p18;\n  dVector3 p19;\n  dVector3 p20;\n  dVector3 p21;\n  dVector3 p22;\n  dVector3 p23;\n  dVector3 p24;\n  dVector3 p25;\n  dVector3 p26;\n  dVector3 p27;\n  dVector3 p28;\n  dVector3 p29;\n  dVector3 p30;\n  dVector3 p31;\n  dVector3 p32;\n  dVector3 p33;\n  dVector3 p34;\n  dVector3 p35;\n  dVector3 p36;\n  dVector3 p37;\n  dVector3 p38;\n  dVector3 p39;\n  dVector3 p40;\n  dVector3 p41;\n  dVector3 p42;\n  dVector3 p43;\n  dVector3 p44;\n  dVector3 p45;\n  dVector3 p46;\n ", "CodeBleu_score": 23.54837855079024}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n  dIASSERT (SAFE_CONTACT(immersion,1));\n\n  dIASSERT (o1->type == dCapsuleClass);\n  dIASSERT (o2->type == dTriMeshClass);\n\n  dCapsule *capsule = (dCapsule*) o1;\n  dTriMesh *mesh = (dTriMesh*) o2;\n\n  dVector3 p;\n  dVector3 n;\n  dVector3 d;\n  dVector3 v;\n  dVector3 v1;\n  dVector3 v2;\n  dVector3 v3;\n  dVector3 v4;\n  dVector3 v5;\n  dVector3 v6;\n  dVector3 v7;\n  dVector3 v8;\n  dVector3 v9;\n  dVector3 v10;\n  dVector3 v11;\n  dVector3 v12;\n  dVector3 v13;\n  dVector3 v14;\n  dVector3 v15;\n  dVector3 v16;\n  dVector3 v17;\n  dVector3 v18;\n  dVector3 v19;\n  dVector3 v20;\n  dVector3 v21;\n  dVector3 v22;\n  dVector3 v23;\n  dVector3 v24;\n  dVector3 v25;\n  dVector3 v26;\n  dVector3 v27;\n  dVector3 v28;\n  dVector3 v29;\n  dVector3 v30;\n  dVector3 v31;\n  dVector3 v32;\n  dVector3 v33;\n  dVector3 v34;\n  dVector3 v35;\n  dVector3 v36;\n  dVector3 v37;\n  dVector3 v38;\n  dVector3 v39;\n  dVector3 v40;\n  dVector3 v41;\n  dVector3 v42;\n  dVector3 v43;\n  dVector3 v44", "CodeBleu_score": 23.499864317947484}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n\tdIASSERT (SAFE_CAST (o1, dxGeom, dGeomCapsuleClass));\n\tdIASSERT (SAFE_CAST (o2, dxGeom, dGeomTriMeshClass));\n\tdIASSERT (flags & dGO_IMMERSION_CALCULATE_BUOYANCY_CENTER);\n\n\tdUASSERT (o1->recalculateAABB () == 0, \"capsule must be up-to-date\");\n\tdUASSERT (o2->recalculateAABB () == 0, \"trimesh must be up-to-date\");\n\n\tdUASSERT (immersion->immersionDepthRatio > 0, \"immersion depth ratio must be positive\");\n\tdUASSERT (immersion->immersionDepthRatio < 1, \"immersion depth ratio must be less than 1\");\n\n\tdUASSERT (immersion->immersionDepthRatio < immersion->immersionDepthRatioLimit, \"immersion depth ratio must be less than the limit\");\n\n\tdUASSERT (immersion->immersionDepthRatioLimit > 0, \"immersion depth ratio limit must be positive\");\n\tdUASSERT (immersion->immersionDepthRatioLimit < 1, \"immersion depth ratio limit must be less than 1\");\n\n\tdUASSERT (immersion->initialAngle >= 0, \"initial angle must be non-negative\");\n\tdUASSERT (immersion->initialAngle < M_PI, \"initial angle must be less than pi\");\n\n\tdUASSERT (immersion->finalAngle >= 0, \"final angle must be non-negative\");\n\tdUASSERT (immersion->finalAngle < M_PI, \"final angle must be less than pi\");\n\n\tdUASSERT (immersion->finalAngle >= immersion->initialAngle, \"final angle must be greater than or equal to the initial angle\");\n\n\tdUASSERT (immersion->volume >= 0, \"volume must be non-negative\");\n\n\tdImmersedCapsuleData *data = (dImmersedCapsule", "CodeBleu_score": 31.63897487675586}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t  std::string duration_str;\n  if (!getInput(\"duration\", duration_str)) {\n    return NodeStatus::SUCCESS;\n  }\n\n  float duration = std::stof(duration_str);\n  if (duration <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  timer_waiting_ = true;\n  timer_ = std::make_shared<Timer>(duration);\n  timer_->onTimeout([this]() {\n      timer_waiting_ = false;\n      this->setStatus(NodeStatus::SUCCESS);\n      this->emitSignal(\"done\");\n    });\n  timer_->start();\n\n  setStatus(NodeStatus::RUNNING);\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 52.463340011777916}, {"code": "NodeStatus SleepNode::onStart(){\n\t    // TODO: Implement code here\n    if (!getInput<int>(duration_, \"duration\")) {\n        return NodeStatus::SUCCESS;\n    }\n\n    if (duration_ <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n\n    setStatus(NodeStatus::RUNNING);\n    timer_waiting_ = true;\n\n    timer_ = std::make_shared<Timer>(duration_);\n    timer_->onExpired([this]() {\n        timer_waiting_ = false;\n        emitSignal(\"done\", duration_);\n    });\n\n    timer_->start();\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 54.87591351091009}, {"code": "NodeStatus SleepNode::onStart(){\n\t  if(!getInput<double>(\"duration\", duration_))\n    return NodeStatus::SUCCESS;\n\n  if(duration_ <= 0)\n    return NodeStatus::SUCCESS;\n\n  setStatus(NodeStatus::RUNNING);\n\n  timer_ = std::make_shared<rclcpp::Timer<SleepNode>>(\n    getNodeBaseInterface(),\n    getNodeTimersInterface(),\n    std::chrono::milliseconds(duration_),\n    std::bind(&SleepNode::onTimer, this));\n\n  timer_->reset();\n  timer_->start();\n\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 42.54984421352775}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // If the entry is not found, it returns NodeStatus::FAILURE\n    if (!this->blackboard->hasData(entry_name_)) {\n        return NodeStatus::FAILURE;\n    }\n\n    // Retrieves the entry and locks its mutex\n    auto entry = this->blackboard->getEntry(entry_name_);\n\n    // If the entry is not found, it returns NodeStatus::FAILURE\n    if (!entry) {\n        return NodeStatus::FAILURE;\n    }\n\n    // If the entry is found, it checks if the sequence ID has been updated\n    if (entry->sequence_id != sequence_id_) {\n        // Updates the sequence ID\n        sequence_id_ = entry->sequence_id;\n\n        // Returns NodeStatus::SUCCESS\n        return NodeStatus::SUCCESS;\n    }\n\n    // If the entry is found, it checks if the sequence ID has not been updated\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 44.73759375038559}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    std::lock_guard<std::mutex> guard(m_mutex);\n    auto entry = getContext()->getEntry(m_entry_name);\n    if (entry != nullptr) {\n        if (entry->getSequenceId() != m_previous_sequence_id) {\n            m_previous_sequence_id = entry->getSequenceId();\n            return NodeStatus::SUCCESS;\n        } else {\n            return NodeStatus::FAILURE;\n        }\n    } else {\n        return NodeStatus::FAILURE;\n    }\n}", "CodeBleu_score": 44.704660988967724}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // Check if the entry is in the blackboard.\n    if (!blackboard_.hasData(entry_name_)) {\n        return NodeStatus::FAILURE;\n    }\n\n    // Retrieve the entry.\n    Entry* entry = blackboard_.getEntry(entry_name_);\n\n    // Check if the entry has been updated.\n    if (entry->sequence_id() != last_sequence_id_) {\n        // Update the last sequence ID.\n        last_sequence_id_ = entry->sequence_id();\n        return NodeStatus::SUCCESS;\n    }\n\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 45.01381483839334}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t    if (m_success_threshold < 0) {\n        // If the success threshold is negative, it adjusts the value based on the number of child nodes, ensuring the result is non-negative.\n        return std::max(static_cast<size_t>(-m_success_threshold), m_children.size());\n    }\n    return m_success_threshold;\n}", "CodeBleu_score": 53.55583303481092}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (m_success_threshold < 0) {\n        return static_cast<size_t>(std::max(m_child_nodes.size() + m_success_threshold, 0));\n    }\n    return static_cast<size_t>(m_success_threshold);\n}", "CodeBleu_score": 55.565474406528104}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (m_success_threshold < 0) {\n        return (size_t) std::max(0, (int) m_children.size() + m_success_threshold);\n    }\n    return m_success_threshold;\n}", "CodeBleu_score": 53.74830006994459}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n        if (heartbeat_status_ == HeartbeatStatus::ACTIVE) {\n            if (heartbeat_time_ + heartbeat_timeout_ < std::chrono::steady_clock::now()) {\n                heartbeat_status_ = HeartbeatStatus::INACTIVE;\n                for (auto &bp : breakpoints_) {\n                    bp.second = false;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 33.42888323466583}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        if (m_last_heartbeat_time != 0) {\n            if (m_last_heartbeat_time + 1000 < std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count()) {\n                m_last_heartbeat_time = 0;\n                m_heartbeat_active = false;\n                for (auto& breakpoint : m_breakpoints) {\n                    breakpoint.second.set_active(false);\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 36.81998290311657}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        if (heartbeatStatus != lastHeartbeatStatus) {\n            lastHeartbeatStatus = heartbeatStatus;\n            if (heartbeatStatus) {\n                enableAllBreakpoints();\n            } else {\n                disableAllBreakpoints();\n            }\n        }\n    }\n}", "CodeBleu_score": 32.491625054715506}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> result;\n    std::vector<std::string> bb_names = split(bb_list, ',');\n    std::vector<std::string> bb_values;\n    std::vector<std::string> bb_types;\n    std::vector<std::string> bb_ids;\n    std::vector<std::string> bb_names_with_ids;\n    std::vector<std::string> bb_values_with_ids;\n    std::vector<std::string> bb_types_with_ids;\n\n    for (auto bb_name : bb_names) {\n        // Find the subtree corresponding to the blackboard name.\n        auto subtree = getSubtree(bb_name);\n        if (subtree == nullptr) {\n            // If the subtree is not found, we skip it.\n            continue;\n        }\n\n        // Lock the subtree.\n        subtree->lock();\n\n        // Get the blackboard value.\n        auto bb_value = subtree->getBlackboard()->getAsString(bb_name);\n        if (bb_value.empty()) {\n            // If the blackboard value is empty, we skip it.\n            continue;\n        }\n\n        // Get the blackboard type.\n        auto bb_type = subtree->getBlackboard()->getType(bb_name);\n        if (bb_type == nullptr) {\n            // If the blackboard type is empty, we skip it.\n            continue;\n        }\n\n        // Get the blackboard id.\n        auto bb_id = subtree->getBlackboard()->getId(bb_name);\n        if (bb_id.empty()) {\n            // If the blackboard id is empty, we skip it.\n            continue;\n        }\n\n        // Add the blackboard name, value and type to the lists.\n        bb_names.push_back(bb_name);\n        bb_values.push_back(bb_value);\n        bb_types.push_back(bb_type);\n        bb_ids.push_back(bb_id);\n        bb_names_", "CodeBleu_score": 38.47854880824837}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> msgpack_data;\n\n    // Create a JSON object to store the blackboards.\n    json::value blackboards_json = json::value::object();\n\n    // Split the list of blackboards into a vector of strings.\n    std::vector<std::string> bb_list_vector = split(bb_list, ',');\n\n    // Iterate through the list of blackboards.\n    for (std::string bb_name : bb_list_vector) {\n        // Find the corresponding subtree.\n        std::string subtree_name = getSubtreeName(bb_name);\n        BT::TreeNode* subtree = BT::getTree().getRoot()->getChild(subtree_name);\n\n        // If the subtree is valid, export the blackboard and add it to the JSON object.\n        if (subtree != nullptr) {\n            std::string bb_name_without_subtree_name = getBlackboardName(bb_name);\n            json::value bb_json = json::value::object();\n            subtree->exportBlackboard(bb_name_without_subtree_name, bb_json);\n            blackboards_json[bb_name] = bb_json;\n        }\n    }\n\n    // Convert the JSON object to MessagePack format and return it as a vector of uint8_t.\n    msgpack_data = json::to_msgpack(blackboards_json);\n    return msgpack_data;\n}", "CodeBleu_score": 40.41059176230367}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> msgpack_data;\n    std::stringstream ss;\n    ss << bb_list;\n    std::string bb_name;\n    std::string bb_data;\n    std::vector<uint8_t> data;\n    std::map<std::string, std::string> blackboards;\n    std::map<std::string, std::string> blackboards_data;\n    while (getline(ss, bb_name, ',')) {\n        if (blackboard_map_.find(bb_name) != blackboard_map_.end()) {\n            BT::TreeNode* subtree = blackboard_map_[bb_name];\n            if (subtree != nullptr) {\n                subtree->lock();\n                data = BT::convertToJSON(subtree);\n                bb_data = std::string((char*)data.data(), data.size());\n                blackboards[bb_name] = bb_data;\n                blackboards_data[bb_name] = bb_data;\n            }\n        }\n    }\n    msgpack_data = BT::convertToMsgPack(blackboards);\n    return msgpack_data;\n}", "CodeBleu_score": 40.63319581042715}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t    // std::lock_guard<std::mutex> lock(mutex_);\n\n    // if (node_uid == 0) {\n    //     return false;\n    // }\n\n    auto it = hooks_.find(node_uid);\n    if (it == hooks_.end()) {\n        return false;\n    }\n\n    Hook& hook = it->second;\n    std::unique_lock<std::mutex> lock(hook.mutex);\n\n    if (hook.status != BREAKPOINT) {\n        return false;\n    }\n\n    hook.status = result;\n    hook.remove = remove;\n    hook.ready = true;\n    hook.cond.notify_all();\n    return true;\n}", "CodeBleu_score": 45.08041884881187}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t    std::lock_guard<std::mutex> lock(m_mutex);\n\n    auto it = m_hooks.find(pos);\n    if (it == m_hooks.end()) {\n        return false;\n    }\n\n    auto& hook = it->second;\n    std::lock_guard<std::mutex> lock_hook(hook.mutex);\n\n    auto it_node = hook.nodes.find(node_uid);\n    if (it_node == hook.nodes.end()) {\n        return false;\n    }\n\n    auto& node = it_node->second;\n    if (!node.is_valid) {\n        return false;\n    }\n\n    if (node.status == NodeStatus::BREAKPOINT) {\n        node.status = result;\n        node.remove = remove;\n        node.ready = true;\n        hook.cond.notify_all();\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 58.095576127447316}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n\n    auto it = hooks_.find(node_uid);\n    if (it == hooks_.end()) {\n        return false;\n    }\n\n    auto& hook = it->second;\n\n    if (hook.status != BREAKPOINT) {\n        return false;\n    }\n\n    hook.result = result;\n    hook.remove = remove;\n    hook.ready = true;\n\n    hook.condition.notify_all();\n\n    return true;\n}", "CodeBleu_score": 43.94761029501165}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    NodeStatus status = NodeStatus::IDLE;\n\n    if (halt_requested_) {\n        halt_requested_ = false;\n        return NodeStatus::IDLE;\n    }\n\n    try {\n        status = tick();\n    }\n    catch (const std::exception& e) {\n        setStatus(NodeStatus::FAILURE);\n        std::cerr << \"Exception in \" << name_ << \"::executeTick(): \" << e.what() << std::endl;\n    }\n    catch (...) {\n        setStatus(NodeStatus::FAILURE);\n        std::cerr << \"Unknown exception in \" << name_ << \"::executeTick()\" << std::endl;\n    }\n\n    if (status == NodeStatus::RUNNING) {\n        setStatus(NodeStatus::RUNNING);\n        return NodeStatus::RUNNING;\n    }\n\n    if (status == NodeStatus::IDLE) {\n        setStatus(NodeStatus::IDLE);\n        return NodeStatus::IDLE;\n    }\n\n    if (status == NodeStatus::SUCCESS) {\n        setStatus(NodeStatus::SUCCESS);\n        return NodeStatus::SUCCESS;\n    }\n\n    if (status == NodeStatus::FAILURE) {\n        setStatus(NodeStatus::FAILURE);\n        return NodeStatus::FAILURE;\n    }\n\n    return NodeStatus::IDLE;\n}", "CodeBleu_score": 47.04638532139774}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n\n    // if the node is not halted and not running, start a new thread\n    if (!halt_requested_ && status_ != NodeStatus::RUNNING) {\n        status_ = NodeStatus::RUNNING;\n        halt_requested_ = false;\n        thread_ = std::thread(&BT::ThreadedAction::executeTickThread, this);\n    }\n\n    // if the node is halted, wait for the thread to finish\n    if (halt_requested_) {\n        thread_.join();\n        status_ = NodeStatus::IDLE;\n        halt_requested_ = false;\n        return NodeStatus::IDLE;\n    }\n\n    // if the node is running, return the current status\n    if (status_ == NodeStatus::RUNNING) {\n        return status_;\n    }\n\n    // if the node is IDLE, check for any stored exceptions and rethrow them\n    if (status_ == NodeStatus::IDLE) {\n        if (thread_exception_) {\n            std::rethrow_exception(thread_exception_);\n        }\n    }\n\n    // if the node is SUCCESS, check for any stored exceptions and rethrow them\n    if (status_ == NodeStatus::SUCCESS) {\n        if (thread_exception_) {\n            std::rethrow_exception(thread_exception_);\n        }\n    }\n\n    // if the node is FAILURE, check for any stored exceptions and rethrow them\n    if (status_ == NodeStatus::FAILURE) {\n        if (thread_exception_) {\n            std::rethrow_exception(thread_exception_);\n        }\n    }\n\n    return status_;\n}", "CodeBleu_score": 49.229892202344445}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status() == NodeStatus::IDLE) {\n    // The node is IDLE, so we start a new thread.\n    halt_requested_ = false;\n    thread_ = std::thread(&BT::ThreadedAction::executeAsync, this);\n  } else if (status() == NodeStatus::RUNNING) {\n    // The node is RUNNING, so we check for halt requests.\n    if (halt_requested_) {\n      // A halt request has been made, so we set the node status to IDLE.\n      status_ = NodeStatus::IDLE;\n      halt_requested_ = false;\n    }\n  }\n  // Check for any exceptions that occurred during the tick function.\n  if (exception_ptr_) {\n    std::rethrow_exception(exception_ptr_);\n  }\n  return status();\n}", "CodeBleu_score": 29.010857061203232}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto printNode = [&stream](const TreeNode* node, int depth) {\n        stream << std::string(depth * 2, ' ') << node->name() << std::endl;\n        if (node->type() == NodeType::CONTROL_NODE) {\n            const ControlNode* control_node = static_cast<const ControlNode*>(node);\n            for (const auto& child : control_node->children()) {\n                printNode(child.get(), depth + 1);\n            }\n        } else if (node->type() == NodeType::DECORATOR_NODE) {\n            const DecoratorNode* decorator_node = static_cast<const DecoratorNode*>(node);\n            printNode(decorator_node->child().get(), depth + 1);\n        }\n    };\n\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n    printNode(root_node, 0);\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 47.10561991104658}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    std::function<void(const TreeNode*, int)> print_tree_recursively = [&](const TreeNode* node, int depth) {\n        for (int i = 0; i < depth; ++i) {\n            stream << \"|   \";\n        }\n        stream << node->getName() << \"\n\";\n\n        if (node->isDecorator()) {\n            const auto* decorator_node = static_cast<const DecoratorNode*>(node);\n            print_tree_recursively(decorator_node->getChild(), depth + 1);\n        } else if (node->isControl()) {\n            const auto* control_node = static_cast<const ControlNode*>(node);\n            for (const auto& child : control_node->children()) {\n                print_tree_recursively(child.get(), depth + 1);\n            }\n        }\n    };\n\n    stream << \"--------------------------------------------------------------------------------\n\";\n    print_tree_recursively(root_node, 0);\n    stream << \"--------------------------------------------------------------------------------\n\";\n}", "CodeBleu_score": 46.94118395042842}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    // The lambda function that recursively prints the tree\n    auto print_node = [&print_node, &stream](const TreeNode* node) {\n        // Indent the output based on the depth of the node\n        stream << std::string(node->depth(), '\\t');\n\n        // Print the node's name\n        stream << node->name() << std::endl;\n\n        // If the node is a ControlNode, print its children\n        if (node->type() == NodeType::CONTROL_NODE) {\n            const ControlNode* control_node = static_cast<const ControlNode*>(node);\n            for (const auto& child : control_node->children()) {\n                print_node(child.get());\n            }\n        }\n        // If the node is a DecoratorNode, print its child\n        else if (node->type() == NodeType::DECORATOR_NODE) {\n            const DecoratorNode* decorator_node = static_cast<const DecoratorNode*>(node);\n            print_node(decorator_node->child().get());\n        }\n    };\n\n    // Begin with a separator line\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n\n    // Print the root node\n    print_node(root_node);\n\n    // End with a separator line\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 47.60438704079714}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (node == nullptr)\n        throw LogicError(\"applyRecursiveVisitor: node is null\");\n\n    visitor(node);\n\n    if (node->isDecorator()) {\n        auto decorator = static_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decorator->child(), visitor);\n    } else if (node->isControl()) {\n        auto control = static_cast<const ControlNode*>(node);\n        for (const auto& child : control->children())\n            applyRecursiveVisitor(child, visitor);\n    }\n}", "CodeBleu_score": 61.5577768118368}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (node == nullptr) {\n        throw LogicError(\"applyRecursiveVisitor: node is null\");\n    }\n    visitor(node);\n\n    if (node->getType() == TreeNode::kControl) {\n        for (auto child : node->children()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (node->getType() == TreeNode::kDecorator) {\n        auto decorator = static_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decorator->child(), visitor);\n    }\n}", "CodeBleu_score": 55.79626778079698}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (node == nullptr)\n    throw LogicError(\"applyRecursiveVisitor: node is null\");\n\n  visitor(node);\n\n  if (node->isDecorator()) {\n    auto decorator = static_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decorator->child(), visitor);\n  } else if (node->isControl()) {\n    auto control = static_cast<const ControlNode*>(node);\n    for (auto child : control->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  }\n}", "CodeBleu_score": 61.30369363901676}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    // Check if the registration ID already exists in the builders map.\n    if (builders_.find(manifest.registration_id) != builders_.end()) {\n        throw BehaviorTreeException(\"The registration ID '\" + manifest.registration_id +\n                                    \"' is already registered.\");\n    }\n\n    // Insert the builder and manifest into their respective maps.\n    builders_.insert(std::make_pair(manifest.registration_id, builder));\n    manifests_.insert(std::make_pair(manifest.registration_id, manifest));\n}", "CodeBleu_score": 48.25930358253289}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (builders_.count(manifest.registration_id) > 0) {\n        throw BehaviorTreeException(\n            \"Node with ID '\" + manifest.registration_id +\n            \"' already exists. Please, choose another registration ID.\");\n    }\n    builders_[manifest.registration_id] = builder;\n    manifests_[manifest.registration_id] = manifest;\n}", "CodeBleu_score": 43.77184465791104}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (builder_map_.count(manifest.registration_id) != 0) {\n        throw BehaviorTreeException(\"The ID '\" + manifest.registration_id +\n                                    \"' is already registered\");\n    }\n    builder_map_[manifest.registration_id] = builder;\n    manifest_map_[manifest.registration_id] = manifest;\n}", "CodeBleu_score": 45.33672209360196}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor](const std::string& ID,\n                                const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(ID, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest(ID, \"SimpleAction\", ports);\n\n  registerBuilder(std::move(builder), std::move(manifest));\n}", "CodeBleu_score": 65.74733242406386}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  registerSimpleAction(ID, tick_functor, std::move(ports),\n                       std::string(\"\"));\n}", "CodeBleu_score": 26.664285811000155}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor](const std::string& name,\n                                       const BT::NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest(ID, builder, ports);\n  registerBuilder(std::move(manifest));\n}", "CodeBleu_score": 60.582958430708004}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> blackboard_backups;\n    blackboard_backups.reserve(tree.GetSubtrees().size());\n\n    for (const auto& subtree : tree.GetSubtrees()) {\n        auto blackboard = std::make_shared<Blackboard>();\n        blackboard->Clone(subtree->GetBlackboard());\n        blackboard_backups.push_back(blackboard);\n    }\n\n    return blackboard_backups;\n}", "CodeBleu_score": 49.72500692302333}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> blackboard_backups;\n    blackboard_backups.reserve(tree.GetSubtrees().size());\n\n    for (const auto& subtree : tree.GetSubtrees()) {\n        Blackboard::Ptr blackboard_backup = std::make_shared<Blackboard>();\n        blackboard_backup->CloneFrom(subtree->GetBlackboard());\n        blackboard_backups.push_back(blackboard_backup);\n    }\n\n    return blackboard_backups;\n}", "CodeBleu_score": 48.68310775085697}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> blackboard_backup;\n    blackboard_backup.reserve(tree.GetSubtrees().size());\n\n    for (const auto& subtree : tree.GetSubtrees()) {\n        Blackboard::Ptr blackboard = std::make_shared<Blackboard>();\n        blackboard->Clone(subtree->GetBlackboard());\n        blackboard_backup.push_back(blackboard);\n    }\n\n    return blackboard_backup;\n}", "CodeBleu_score": 49.58267100983168}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(env, script);\n    if (!executor) {\n        return std::move(executor.error());\n    }\n\n    return executor->Execute();\n}", "CodeBleu_score": 62.11882968633593}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (!executor) {\n        return std::move(executor.error());\n    }\n    return executor->Execute(env);\n}", "CodeBleu_score": 67.73833034097034}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor->Execute(env);\n}", "CodeBleu_score": 73.26060244771452}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n\n    if (is_loaded()) {\n        throw RuntimeError(\"Library already loaded: \" + path);\n    }\n\n    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        std::string msg = \"Failed to load library: \" + path + \" with error: \" + dlerror();\n        throw RuntimeError(msg);\n    }\n\n    library_path_ = path;\n    library_handle_ = handle;\n}", "CodeBleu_score": 64.09620606434419}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n\n    if (is_loaded()) {\n        throw RuntimeError(\"Shared library already loaded: \" + path);\n    }\n\n    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        std::string error_msg(dlerror());\n        throw RuntimeError(\"Error loading library: \" + path + \"\n\" + error_msg);\n    }\n\n    library_path_ = path;\n    library_handle_ = handle;\n}", "CodeBleu_score": 60.791257170484606}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n\n    if (is_loaded()) {\n        throw RuntimeError(\"SharedLibrary::load\", \"Library already loaded: \" + path);\n    }\n\n    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    if (handle == nullptr) {\n        const char* error = dlerror();\n        throw RuntimeError(\"SharedLibrary::load\", \"Error loading library: \" + std::string(error));\n    }\n\n    path_ = path;\n    handle_ = handle;\n}", "CodeBleu_score": 58.9273221594874}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n\n    StringView stripped = str.substr(str.find_first_not_of(' '));\n    if (stripped.size() < 3) {\n        return false;\n    }\n\n    if (stripped[0] != '{' || stripped[stripped.size() - 1] != '}') {\n        return false;\n    }\n\n    if (stripped_pointer != nullptr) {\n        *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    }\n\n    return true;\n}", "CodeBleu_score": 30.23618513375671}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n    StringView stripped = str.trim();\n    if (stripped.size() < 3) {\n        return false;\n    }\n    if (stripped.front() != '{' || stripped.back() != '}') {\n        return false;\n    }\n    if (stripped_pointer != nullptr) {\n        *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    }\n    return true;\n}", "CodeBleu_score": 27.840960079854238}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n\n    auto stripped = str.trim();\n    if (stripped.size() < 3) {\n        return false;\n    }\n\n    if (stripped.front() != '{' || stripped.back() != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    }\n\n    return true;\n}", "CodeBleu_score": 28.202954575575607}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0;\n  double cost;\n  LineIterator it(x0, x1, y0, y1);\n  while (!it.isPastEnd()) {\n    cost = pointCost(it.getX(), it.getY());\n    if (cost < 0) {\n      return cost;\n    }\n    line_cost = std::max(line_cost, cost);\n    ++it;\n  }\n  return line_cost;\n}", "CodeBleu_score": 60.394150395800224}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  double point_cost = 0.0;\n\n  // Calculate the line cost\n  LineIterator line_iter(getCostmap(), x0, y0, x1, y1);\n  for (LineIterator line_iter(getCostmap(), x0, y0, x1, y1); line_iter != line_iter.end(); ++line_iter) {\n    point_cost = pointCost(line_iter.getX(), line_iter.getY());\n    if (point_cost < 0) {\n      return point_cost;\n    }\n    line_cost += point_cost;\n  }\n\n  return line_cost;\n}", "CodeBleu_score": 66.16834590280183}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  double cost = 0.0;\n  double resolution = getResolution();\n  double inv_resolution = 1.0 / resolution;\n  double delta_x = (x1 - x0) * inv_resolution;\n  double delta_y = (y1 - y0) * inv_resolution;\n  double delta_x2 = delta_x * delta_x;\n  double delta_y2 = delta_y * delta_y;\n  double delta_xy = delta_x * delta_y;\n  double delta_xy2 = delta_xy * delta_xy;\n  double delta_x_abs = std::abs(delta_x);\n  double delta_y_abs = std::abs(delta_y);\n  double delta_x_sign = delta_x / delta_x_abs;\n  double delta_y_sign = delta_y / delta_y_abs;\n  double delta_x_step = delta_x_abs * inv_resolution;\n  double delta_y_step = delta_y_abs * inv_resolution;\n  double delta_x_step2 = delta_x_step * delta_x_step;\n  double delta_y_step2 = delta_y_step * delta_y_step;\n  double delta_xy_step = delta_xy * inv_resolution;\n  double delta_xy_step2 = delta_xy_step * delta_xy_step;\n  double delta_x_step_sign = delta_x_sign * delta_x_step;\n  double delta_y_step_sign = delta_y_sign * delta_y_step;\n  double delta_x_step_abs = std::abs(delta_x_step);\n  double delta_y_step_abs = std::abs(delta_y_step);\n  double delta_x_step_sign_abs = delta_x_sign * delta_x_step_abs;\n  double delta_y_step_sign_abs = delta_y_sign * delta_y_step_abs;\n  double delta_x_step_sign_abs2 = delta_x_step_sign_abs * delta_", "CodeBleu_score": 23.67996080848134}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    if (path.empty())\n        return;\n\n    nav_msgs::Path gui_path;\n    gui_path.header = path[0].header;\n    gui_path.poses.resize(path.size());\n    for (unsigned int i = 0; i < path.size(); ++i)\n        gui_path.poses[i] = path[i];\n    pub.publish(gui_path);\n}", "CodeBleu_score": 64.16913188845734}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\n  if (path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.header = path.front().header;\n  gui_path.header.frame_id = \"map\";\n  gui_path.poses.resize(path.size());\n  for (size_t i = 0; i < path.size(); ++i)\n    gui_path.poses[i] = path[i];\n  pub.publish(gui_path);\n}", "CodeBleu_score": 64.08888230300828}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty()) {\n    ROS_WARN(\"Path is empty\");\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path.at(0).header.frame_id;\n  gui_path.header.stamp = path.at(0).header.stamp;\n  gui_path.poses.resize(path.size());\n  for (size_t i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path.at(i);\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 63.45667990617767}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  // Check if the robot is stopped based on its velocities\n  if ((base_odom.twist.twist.angular.z <= rot_stopped_velocity) &&\n      (base_odom.twist.twist.linear.x <= trans_stopped_velocity)) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 45.862165434832505}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  // Check if robot has stopped based on its odometry data\n  if (base_odom.twist.twist.linear.x <= trans_stopped_velocity &&\n      base_odom.twist.twist.angular.z <= rot_stopped_velocity) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 47.45831644395344}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  // Check if robot has stopped\n  if (base_odom.twist.twist.linear.x <= trans_stopped_velocity &&\n      base_odom.twist.twist.angular.z <= rot_stopped_velocity) {\n    ROS_DEBUG(\"Stopped\");\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 48.38951218802654}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  boost::mutex::scoped_lock lock(configuration_mutex_);\n\n  if (!setup_ && !restore_defaults) {\n    setup_ = true;\n    default_limits_ = config;\n  }\n\n  if (setup_ && restore_defaults) {\n    config = default_limits_;\n    setup_ = false;\n  }\n\n  current_limits_ = config;\n}", "CodeBleu_score": 68.44017730147952}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  boost::mutex::scoped_lock lock(config_mutex_);\n  if (setup_ && restore_defaults) {\n    config.setup(true);\n  } else if (!setup_) {\n    config.setup(false);\n    setup_ = true;\n  }\n  config.lock();\n  current_limits_ = config;\n  config.unlock();\n}", "CodeBleu_score": 60.6161792314382}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t    boost::mutex::scoped_lock l(configuration_mutex_);\n    if (!setup_) {\n        // set up default limits\n        default_limits_.max_vel_x = config.max_vel_x;\n        default_limits_.max_vel_y = config.max_vel_y;\n        default_limits_.max_vel_theta = config.max_vel_theta;\n        default_limits_.min_vel_x = config.min_vel_x;\n        default_limits_.min_vel_y = config.min_vel_y;\n        default_limits_.min_vel_theta = config.min_vel_theta;\n        default_limits_.max_acc_x = config.max_acc_x;\n        default_limits_.max_acc_y = config.max_acc_y;\n        default_limits_.max_acc_theta = config.max_acc_theta;\n        default_limits_.min_acc_x = config.min_acc_x;\n        default_limits_.min_acc_y = config.min_acc_y;\n        default_limits_.min_acc_theta = config.min_acc_theta;\n        default_limits_.max_vel_x_backwards = config.max_vel_x_backwards;\n        default_limits_.max_vel_y_backwards = config.max_vel_y_backwards;\n        default_limits_.max_vel_theta_backwards = config.max_vel_theta_backwards;\n        default_limits_.min_vel_x_backwards = config.min_vel_x_backwards;\n        default_limits_.min_vel_y_backwards = config.min_vel_y_backwards;\n        default_limits_.min_vel_theta_backwards = config.min_vel_theta_backwards;\n        default_limits_.max_acc_x_backwards = config.max_acc_x_backwards;\n        default_limits_.max_acc_y_backwards = config.max_acc_y_backwards;\n        default_limits_.max_acc_theta_backwards = config.max_acc_theta_backwards;\n        default_limits_.", "CodeBleu_score": 27.385780494786115}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\n  if (check_cell->isObstacle()) {\n    current_cell->setTargetDistance(std::numeric_limits<double>::max());\n    return false;\n  }\n\n  if (check_cell->isUnknown()) {\n    current_cell->setTargetDistance(std::numeric_limits<double>::max());\n    return false;\n  }\n\n  double distance = current_cell->getDistance() +\n      costmap.getCost(check_cell->getX(), check_cell->getY());\n\n  if (distance < current_cell->getTargetDistance()) {\n    current_cell->setTargetDistance(distance);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 44.087903245294804}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_x = check_cell->getCellX();\n  unsigned int cell_y = check_cell->getCellY();\n  unsigned int cell_index = cell_y * getSizeInCellsX() + cell_x;\n  unsigned int cell_index_x = cell_x;\n  unsigned int cell_index_y = cell_y;\n  unsigned int cost_index = cell_index_y * getSizeInCellsX() + cell_index_x;\n  unsigned int cost_index_x = cell_index_x;\n  unsigned int cost_index_y = cell_index_y;\n  unsigned int cost_index_xy = cell_index;\n  unsigned int cost_index_yx = cell_index;\n  double new_distance = std::numeric_limits<double>::infinity();\n  double new_distance_x = std::numeric_limits<double>::infinity();\n  double new_distance_y = std::numeric_limits<double>::infinity();\n  double new_distance_xy = std::numeric_limits<double>::infinity();\n  double new_distance_yx = std::numeric_limits<double>::infinity();\n  double current_distance = current_cell->getTargetDistance();\n  double current_distance_x = current_cell->getTargetDistanceX();\n  double current_distance_y = current_cell->getTargetDistanceY();\n  double current_distance_xy = current_cell->getTargetDistanceXY();\n  double current_distance_yx = current_cell->getTargetDistanceYX();\n  double current_distance_x_sq = current_distance_x * current_distance_x;\n  double current_distance_y_sq = current_distance_y * current_distance_y;\n  double current_distance_xy_sq = current_distance_xy * current_distance_xy;\n  double current_distance_yx_sq = current_distance_yx * current_distance_yx;\n  double current_distance_sq = current_distance * current_distance;\n  double current_distance_x_sq_plus_y_sq = current_distance_x_sq + current_distance_y_sq;\n  double current", "CodeBleu_score": 32.011244259593916}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  // Check if the cell is an obstacle\n  if (costmap.getCost(check_cell->x, check_cell->y) > costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    // If so, set the cell's target distance to the maximum obstacle cost\n    check_cell->target_distance = std::numeric_limits<float>::max();\n    return false;\n  }\n  // If not, calculate a new target distance\n  float new_distance = current_cell->distance + (check_cell->x - current_cell->x) * (check_cell->x - current_cell->x)\n      + (check_cell->y - current_cell->y) * (check_cell->y - current_cell->y);\n  // And update the cell's target distance if the new distance is shorter\n  if (new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n  }\n  return true;\n}", "CodeBleu_score": 51.853295207463646}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t    double cost = 0.0;\n    double scaling_factor = 0.0;\n    double max_footprint_cost = 0.0;\n    if (traj.empty()) {\n        ROS_ERROR(\"Trajectory is empty\");\n        return -9.0;\n    }\n\n    // Initialize the cost and scaling factor\n    if (sum_scores_) {\n        cost = 0.0;\n        scaling_factor = 0.0;\n    } else {\n        cost = std::numeric_limits<double>::max();\n        scaling_factor = std::numeric_limits<double>::max();\n    }\n\n    // Calculate the footprint cost for each point in the trajectory\n    for (auto &point : traj) {\n        double footprint_cost = scoreFootprint(point);\n        if (footprint_cost < 0.0) {\n            return footprint_cost;\n        }\n        if (sum_scores_) {\n            cost += footprint_cost;\n            scaling_factor += 1.0;\n        } else {\n            if (footprint_cost > cost) {\n                cost = footprint_cost;\n            }\n            if (footprint_cost > max_footprint_cost) {\n                max_footprint_cost = footprint_cost;\n            }\n        }\n    }\n\n    // Return the total cost\n    if (sum_scores_) {\n        return cost / scaling_factor;\n    } else {\n        return max_footprint_cost;\n    }\n}", "CodeBleu_score": 44.20195917316162}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  if (traj.empty()) {\n    ROS_ERROR(\"Empty trajectory passed to ObstacleCostFunction::scoreTrajectory\");\n    return -9;\n  }\n\n  double cost = 0;\n  double scaling = 1;\n  double min_score = 0;\n  double max_score = 0;\n\n  // initialize the cost and scaling factor based on the trajectory and speed parameters\n  if (traj.size() > 1) {\n    scaling = (traj.back().position.x - traj.front().position.x) / (traj.back().velocity.x - traj.front().velocity.x);\n  }\n\n  // calculate the footprint cost for each point in the trajectory\n  for (unsigned int i = 0; i < traj.size(); i++) {\n    double score = 0;\n    double dist = 0;\n\n    // calculate the footprint cost\n    if (!footprint_.empty()) {\n      for (unsigned int j = 0; j < footprint_.size(); j++) {\n        dist += (footprint_[j].x() - traj[i].position.x) * (footprint_[j].x() - traj[i].position.x);\n        dist += (footprint_[j].y() - traj[i].position.y) * (footprint_[j].y() - traj[i].position.y);\n      }\n      score = std::sqrt(dist);\n    }\n\n    // if the footprint cost is negative, return the cost immediately\n    if (score < 0) {\n      return score;\n    }\n\n    // if the footprint cost is non-negative, either sum the scores or take the maximum score\n    if (sum_scores_) {\n      cost += score;\n    } else {\n      if (i == 0) {\n        min_score = score;\n        max_score = score;\n      } else {\n        if (score > max_score) {\n          max_score = score;\n        }\n        if (score < min_score) {\n          min_score = score;\n        }\n      }\n    }", "CodeBleu_score": 52.55717896950779}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  // Initialize the cost and scaling factor based on the trajectory and speed parameters\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  if (traj.size() == 0) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: Trajectory is empty.\");\n    return -9.0;\n  }\n  if (traj[0].twist.linear.x < 0.0) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: Trajectory has negative speed.\");\n    return -9.0;\n  }\n  if (traj[0].twist.linear.x > max_speed_) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: Trajectory has speed greater than max_speed.\");\n    return -9.0;\n  }\n  if (traj.size() > 1) {\n    if (traj[1].twist.linear.x < 0.0) {\n      ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: Trajectory has negative speed.\");\n      return -9.0;\n    }\n    if (traj[1].twist.linear.x > max_speed_) {\n      ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: Trajectory has speed greater than max_speed.\");\n      return -9.0;\n    }\n  }\n  if (traj[0].twist.linear.x == 0.0) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: Trajectory has zero speed.\");\n    return -9.0;\n  }\n  if (traj[0].twist.linear.x < min_speed_) {\n    ROS_WARN(\"ObstacleCostFunction::scoreTrajectory: Trajectory has speed less than min_speed.\");\n    scaling_factor = min_speed_ / traj[0].twist.linear.x;\n  }\n  if (traj[0].twist.linear.x > max_speed_) {\n    ROS_WARN(\"ObstacleCostFunction::", "CodeBleu_score": 30.487735720563457}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    // Create footprint points\n    std::vector<geometry_msgs::Point> footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        double x_tmp = footprint_spec[i].x * scale;\n        double y_tmp = footprint_spec[i].y * scale;\n        footprint.push_back(geometry_msgs::Point(x_tmp, y_tmp, 0.0));\n    }\n\n    // Compute footprint cost\n    double footprint_cost = world_model->footprintCost(x, y, th, footprint, *costmap);\n\n    // Compute cell cost\n    double cell_cost = costmap->getCost(costmap->worldToMap(x, y));\n\n    // Compute cost\n    double cost = std::max(footprint_cost, cell_cost);\n\n    // If the cost is negative, return -6.0\n    if (cost < 0.0) {\n        return -6.0;\n    }\n\n    // If the position is off the map, return -7.0\n    if (costmap->isOutOfBounds(x, y)) {\n        return -7.0;\n    }\n\n    return cost;\n}", "CodeBleu_score": 64.37510317622797}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    // Check if the robot is off the map\n    if (!world_model->isInside(x, y)) {\n        return -7.0;\n    }\n\n    // Get the footprint cost\n    double footprint_cost = world_model->footprintCost(x, y, footprint_spec, costmap);\n\n    // If the cost is negative, return -6.0\n    if (footprint_cost < 0.0) {\n        return -6.0;\n    }\n\n    // If the cost is positive, return the maximum cost between the footprint cost and the cell cost at the given position\n    return std::max(footprint_cost, costmap->getCost(x, y));\n}", "CodeBleu_score": 34.69770741910529}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    // Transform the footprint into the robot's frame\n    std::vector<geometry_msgs::Point> transformed_footprint_spec;\n    for (std::size_t i = 0; i < footprint_spec.size(); ++i) {\n        geometry_msgs::Point p;\n        p.x = footprint_spec[i].x * cos(th) - footprint_spec[i].y * sin(th);\n        p.y = footprint_spec[i].x * sin(th) + footprint_spec[i].y * cos(th);\n        transformed_footprint_spec.push_back(p);\n    }\n\n    // Transform the footprint into the map frame\n    std::vector<geometry_msgs::Point> map_frame_footprint_spec;\n    for (std::size_t i = 0; i < transformed_footprint_spec.size(); ++i) {\n        geometry_msgs::Point p;\n        p.x = x + transformed_footprint_spec[i].x * scale;\n        p.y = y + transformed_footprint_spec[i].y * scale;\n        map_frame_footprint_spec.push_back(p);\n    }\n\n    // Compute the footprint cost\n    double footprint_cost = world_model->footprintCost(map_frame_footprint_spec, costmap);\n\n    // If the cost is negative, return -6.0\n    if (footprint_cost < 0.0) {\n        return -6.0;\n    }\n\n    // If the position is off the map, return -7.0\n    if (costmap->getCost(x, y) == costmap_2d::LETHAL_OBSTACLE) {\n        return -7.0;\n    }\n\n    // Otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n    return std::max(footprint_cost, costmap->getCost(x, y));\n}", "CodeBleu_score": 57.992019802631475}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic == odom_topic_)\n    return;\n\n  if (!odom_topic.empty()) {\n    odom_subscriber_ = node_handle_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n  } else {\n    odom_subscriber_.shutdown();\n  }\n\n  odom_topic_ = odom_topic;\n}", "CodeBleu_score": 38.34826202819386}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      sub_odom_.shutdown();\n      sub_odom_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      sub_odom_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.01420503509703}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    if (odom_topic != odom_topic_) {\n        odom_topic_ = odom_topic;\n        if (odom_topic_ == \"\") {\n            odom_sub_.shutdown();\n        } else {\n            odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n        }\n    }\n}", "CodeBleu_score": 48.940216815307174}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    float dist = (pos - prev).norm();\n    float angle = std::abs(std::atan2(pos.y() - prev.y(), pos.x() - prev.x()) - std::atan2(pos.z() - prev.z(), pos.x() - prev.x()));\n\n    if (dist > oscillation_distance_threshold_ || angle > oscillation_angle_threshold_) {\n        oscillation_flags_[0] = false;\n        oscillation_flags_[1] = false;\n    }\n}", "CodeBleu_score": 44.86470641524616}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  float dist = (pos - prev).norm();\n  float ang = std::fabs(pos[2] - prev[2]);\n  if (dist > 0.01 || ang > 0.1) {\n    oscillation_detected_ = false;\n    oscillation_counter_ = 0;\n  }\n}", "CodeBleu_score": 34.19992530824733}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    float dist = (pos - prev).norm();\n    float angle = std::abs(std::acos(pos.dot(prev) / (dist * pos.norm())));\n\n    if (dist > oscillation_distance_threshold_ || angle > oscillation_angle_threshold_) {\n        oscillation_detected_ = false;\n        oscillation_angle_ = 0.0f;\n    }\n}", "CodeBleu_score": 34.597344862507626}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // Check if the point is in the grid\n  if (!isInside(pt)) {\n    return;\n  }\n\n  // Check if the point is too close to its nearest neighbor\n  if (isTooClose(pt)) {\n    return;\n  }\n\n  // Calculate the grid index\n  int i = (int) floor(pt.x / resolution_);\n  int j = (int) floor(pt.y / resolution_);\n\n  // Insert the point into the corresponding cell\n  cells_[i][j].push_back(pt);\n}", "CodeBleu_score": 42.398747065861784}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\n    // determine grid coordinates\n    int x = (int)((pt.x - min_pt_.x) / resolution_);\n    int y = (int)((pt.y - min_pt_.y) / resolution_);\n    int z = (int)((pt.z - min_pt_.z) / resolution_);\n\n    // check if point is inside the grid\n    if (x < 0 || x >= cols_ || y < 0 || y >= rows_ || z < 0 || z >= depth_) {\n        return;\n    }\n\n    // check if point is too close to its nearest neighbor\n    if (dist(pt, get(x, y, z)) < min_dist_) {\n        return;\n    }\n\n    // calculate grid index\n    int index = x + y * cols_ + z * cols_ * rows_;\n\n    // insert the point into the corresponding cell\n    points_[index] = pt;\n}", "CodeBleu_score": 40.443999227045126}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tint x, y;\n\tdouble dx, dy;\n\tdouble dist;\n\tdouble min_dist = std::numeric_limits<double>::max();\n\tint min_idx = -1;\n\t\n\t// determine the grid coordinates of the point\n\tif (pt.x < x_min_ || pt.x > x_max_ || pt.y < y_min_ || pt.y > y_max_)\n\t\treturn;\n\t\n\tx = (pt.x - x_min_) / resolution_;\n\ty = (pt.y - y_min_) / resolution_;\n\t\n\t// determine the nearest neighbor\n\tfor (int i = 0; i < cells_[x][y].size(); ++i) {\n\t\tdx = pt.x - cells_[x][y][i].x;\n\t\tdy = pt.y - cells_[x][y][i].y;\n\t\tdist = dx*dx + dy*dy;\n\t\tif (dist < min_dist) {\n\t\t\tmin_dist = dist;\n\t\t\tmin_idx = i;\n\t\t}\n\t}\n\t\n\t// if the point is too close to its nearest neighbor, return\n\tif (min_dist < min_dist_threshold_)\n\t\treturn;\n\t\n\t// insert the point into the corresponding cell\n\tcells_[x][y].push_back(pt);\n}", "CodeBleu_score": 38.39656969063476}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = vel[i] + std::min(acclimits[i], sample_target_vel[i] - vel[i]) * dt;\n    } else if (sample_target_vel[i] < vel[i]) {\n      new_vel[i] = vel[i] - std::min(acclimits[i], vel[i] - sample_target_vel[i]) * dt;\n    } else {\n      new_vel[i] = sample_target_vel[i];\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 72.45951773017559}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n  for (int i = 0; i < 3; ++i) {\n    if (sample_target_vel[i] > vel[i]) {\n      if (vel[i] + acclimits[i] * dt > sample_target_vel[i]) {\n        new_vel[i] = vel[i] + acclimits[i] * dt;\n      } else {\n        new_vel[i] = sample_target_vel[i];\n      }\n    } else if (sample_target_vel[i] < vel[i]) {\n      if (vel[i] - acclimits[i] * dt < sample_target_vel[i]) {\n        new_vel[i] = vel[i] - acclimits[i] * dt;\n      } else {\n        new_vel[i] = sample_target_vel[i];\n      }\n    }\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 74.47322770443012}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i]) {\n      if (vel[i] + acclimits[i] * dt >= sample_target_vel[i]) {\n        new_vel[i] = sample_target_vel[i];\n      } else {\n        new_vel[i] = vel[i] + acclimits[i] * dt;\n      }\n    } else if (sample_target_vel[i] < vel[i]) {\n      if (vel[i] - acclimits[i] * dt <= sample_target_vel[i]) {\n        new_vel[i] = sample_target_vel[i];\n      } else {\n        new_vel[i] = vel[i] - acclimits[i] * dt;\n      }\n    } else {\n      new_vel[i] = vel[i];\n    }\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 71.39317785254391}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\n  // Get the current footprint of the robot\n  std::vector<geometry_msgs::Point> footprint = costmap_2d::footprintAsVector(costmap_ros_->getRobotFootprint());\n\n  // Create a queue to store the cells we've checked\n  std::queue<int> checked_cells;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check_next;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check_next_next;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check_next_next_next;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check_next_next_next_next;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check_next_next_next_next_next;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check_next_next_next_next_next_next;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check_next_next_next_next_next_next_next;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check_next_next_next_next_next_next_next_next;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check_next_next_next_next_next_next_next_next_next;\n\n  // Create a queue to store the cells we're currently checking\n  std::queue<int> cells_to_check_next_next_next_next_next_next_next_", "CodeBleu_score": 8.719818417556766}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\n  double diff = DBL_MAX;\n\n  // Check if the goal point is in the same cell as the robot\n  if (cell_x == x && cell_y == y) {\n    return 0;\n  }\n\n  // Get the robot's current cell coordinates\n  int curr_x = (int) floor(current_x_);\n  int curr_y = (int) floor(current_y_);\n\n  // If the robot is in a cell that is already on the global plan, return\n  if (cell_x == curr_x && cell_y == curr_y) {\n    return 0;\n  }\n\n  // Get the goal cell coordinates\n  int goal_x = (int) floor(x);\n  int goal_y = (int) floor(y);\n\n  // Get the current orientation of the robot\n  double curr_theta = angles::normalize_angle(tf2::getYaw(current_orientation_));\n\n  // Get the goal orientation\n  double goal_theta = angles::normalize_angle(tf2::getYaw(tf2::getRotation(goal_orientation_)));\n\n  // Get the angle between the robot's current heading and the direction to the goal point\n  double curr_to_goal_angle = angles::normalize_angle(tf2::getYaw(tf2::getRotation(current_orientation_)) - angles::normalize_angle(goal_theta - curr_theta));\n\n  // Get the angle between the robot's current heading and the direction to the goal point\n  double goal_to_curr_angle = angles::normalize_angle(tf2::getYaw(tf2::getRotation(goal_orientation_)) - angles::normalize_angle(curr_theta - goal_theta));\n\n  // Get the angle between the robot's current heading and the direction to the goal point\n  double curr_to_goal_angle_abs = angles::normalize_angle(tf2::getYaw(tf2::getRotation(current_orientation_)) - angles::normalize_angle(goal_theta - curr_theta));\n\n  // Get the angle between the robot's current heading and the direction to the goal point\n  double", "CodeBleu_score": 33.3973709013393}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double heading_diff = DBL_MAX;\n\n  // Get the world coordinates of the goal point\n  double goal_x = costmap_->getCostmap()->getOriginX() + cell_x * costmap_->getCostmap()->getResolution();\n  double goal_y = costmap_->getCostmap()->getOriginY() + cell_y * costmap_->getCostmap()->getResolution();\n\n  // Create a vector from the robot to the goal point\n  double dx = goal_x - x;\n  double dy = goal_y - y;\n\n  // Get the direction of the vector\n  double goal_theta = atan2(dy, dx);\n\n  // Get the angle between the robot's heading and the direction to the goal point\n  double diff = angles::shortest_angular_distance(heading, goal_theta);\n\n  // If the angle is less than pi/2, return the absolute value of the angle\n  if (diff < M_PI / 2) {\n    heading_diff = fabs(diff);\n  }\n\n  return heading_diff;\n}", "CodeBleu_score": 36.973244033843024}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n    // Evaluate the trajectory\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    // If the trajectory is valid, return true\n    if (cost >= 0) {\n        return true;\n    }\n\n    // Otherwise, log a warning\n    ROS_WARN_THROTTLE(1.0, \"Trajectory is invalid: cost = %f, vx = %f, vy = %f, vtheta = %f\", cost, vx, vy, vtheta);\n    return false;\n}", "CodeBleu_score": 72.50675441827524}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  if (cost >= 0) {\n    return true;\n  } else {\n    ROS_WARN_STREAM(\"Trajectory invalid: cost = \" << cost << \" vx = \" << vx_samp << \" vy = \" << vy_samp << \" vtheta = \" << vtheta_samp);\n    return false;\n  }\n}", "CodeBleu_score": 73.0263865510261}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    // Compute the cost of the trajectory\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    // If the cost is non-negative, the trajectory is considered valid\n    if (cost >= 0.0) {\n        return true;\n    }\n\n    // Otherwise, log a warning with the sample velocities and cost\n    ROS_WARN_STREAM(\"Invalid trajectory: \" << x << \", \" << y << \", \" << theta << \", \" << vx << \", \" << vy << \", \" << vtheta << \", \" << vx_samp << \", \" << vy_samp << \", \" << vtheta_samp << \", \" << cost);\n    return false;\n}", "CodeBleu_score": 70.30831234528814}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t\n  if (!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before running the behavior.\");\n    return;\n  }\n\n  if (global_costmap_ == nullptr || local_costmap_ == nullptr) {\n    ROS_ERROR(\"ClearCostmapRecovery is not able to clear costmaps because either the global or local costmap is NULL.\");\n    return;\n  }\n\n  if (affected_maps_ == AFFECTED_GLOBAL) {\n    ROS_WARN(\"ClearCostmapRecovery is about to clear the global costmap.\");\n    if (!invert_area_to_clear_) {\n      ROS_WARN(\"ClearCostmapRecovery is about to clear the global costmap outside the specified area.\");\n    } else {\n      ROS_WARN(\"ClearCostmapRecovery is about to clear the global costmap inside the specified area.\");\n    }\n  }\n\n  if (affected_maps_ == AFFECTED_LOCAL) {\n    ROS_WARN(\"ClearCostmapRecovery is about to clear the local costmap.\");\n    if (!invert_area_to_clear_) {\n      ROS_WARN(\"ClearCostmapRecovery is about to clear the local costmap outside the specified area.\");\n    } else {\n      ROS_WARN(\"ClearCostmapRecovery is about to clear the local costmap inside the specified area.\");\n    }\n  }\n\n  if (affected_maps_ == AFFECTED_GLOBAL_AND_LOCAL) {\n    ROS_WARN(\"ClearCostmapRecovery is about to clear both the global and local costmaps.\");\n    if (!invert_area_to_clear_) {\n      ROS_WARN(\"ClearCostmapRecovery is about to clear both the global and local costmaps outside the specified area.\");\n    } else {\n      ROS_WARN(\"ClearCostmapRecovery is about to clear both the global and local costmaps inside the specified area.\");\n    }\n  }\n\n  ros::WallTime start = ros::WallTime::now();\n  if (affected_maps_ == AFFECTED_GLOBAL)", "CodeBleu_score": 34.42165230639942}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t    if (!initialized_) {\n        ROS_ERROR(\"ClearCostmapRecovery::runBehavior: The object has not been initialized.\");\n        return;\n    }\n\n    if (!clear_global_costmap_ && !clear_local_costmap_) {\n        ROS_ERROR(\"ClearCostmapRecovery::runBehavior: No costmaps have been specified to clear.\");\n        return;\n    }\n\n    ros::Time start_time = ros::Time::now();\n\n    if (clear_global_costmap_) {\n        if (invert_area_to_clear_) {\n            ROS_WARN(\"ClearCostmapRecovery::runBehavior: Clearing outside the specified area.\");\n        }\n        else {\n            ROS_WARN(\"ClearCostmapRecovery::runBehavior: Clearing inside the specified area.\");\n        }\n        if (force_update_) {\n            ROS_WARN(\"ClearCostmapRecovery::runBehavior: Forcing an update of the global costmap.\");\n        }\n        if (clear_global_costmap_ && clear_local_costmap_) {\n            ROS_WARN(\"ClearCostmapRecovery::runBehavior: Clearing both the global and local costmaps.\");\n        }\n        else if (clear_global_costmap_) {\n            ROS_WARN(\"ClearCostmapRecovery::runBehavior: Clearing only the global costmap.\");\n        }\n        else {\n            ROS_WARN(\"ClearCostmapRecovery::runBehavior: Clearing only the local costmap.\");\n        }\n        if (!clear_global_costmap_ && !clear_local_costmap_) {\n            ROS_WARN(\"ClearCostmapRecovery::runBehavior: Clearing neither the global nor local costmap.\");\n        }\n        global_costmap_->clearCostmap(invert_area_to_clear_, force_update_);\n    }\n\n    if (clear_local_costmap_) {\n        if (invert_area_to_clear_) {\n            ROS_WARN(\"ClearCostmapRecovery::runBehavior: Clearing outside the specified area.\");\n        }\n        else {\n            ROS_WARN(\"ClearCostmapRecovery::runBehavior: Clearing inside", "CodeBleu_score": 37.26030741214065}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery::runBehavior() called before object initialized.\");\n    return;\n  }\n  if (costmap_2d_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery::runBehavior() called before costmap initialized.\");\n    return;\n  }\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery::runBehavior() called before local costmap initialized.\");\n    return;\n  }\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery::runBehavior() called before global costmap initialized.\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside of the specified area.\");\n  } else {\n    ROS_WARN(\"Clearing inside of the specified area.\");\n  }\n\n  ros::Time start_time = ros::Time::now();\n  if (affected_maps_ & AFFECTED_GLOBAL) {\n    if (invert_area_to_clear_) {\n      global_costmap_->getCostMap()->resetLayers();\n    } else {\n      global_costmap_->getCostMap()->resetLayers(affected_layers_);\n    }\n    global_costmap_->updateOrigin(global_costmap_->getCostMap()->getOrigin());\n    ROS_INFO(\"Global costmap cleared in %.3f seconds.\", (ros::Time::now() - start_time).toSec());\n  }\n  if (affected_maps_ & AFFECTED_LOCAL) {\n    if (invert_area_to_clear_) {\n      local_costmap_->getCostMap()->resetLayers();\n    } else {\n      local_costmap_->getCostMap()->resetLayers(affected_layers_);\n    }\n    local_costmap_->updateOrigin(local_costmap_->getCostMap()->getOrigin());\n    ROS_INFO(\"Local costmap cleared in %.3f seconds.\", (ros::Time::now() - start_time).toSec", "CodeBleu_score": 47.940494367710755}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  // If the polygon is empty, return\n  if (polygon.empty()) {\n    return;\n  }\n\n  // Create a PolygonOutlineCells object to collect the cells\n  PolygonOutlineCells polygon_outline_cells(this);\n\n  // Iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    unsigned int j = (i + 1) % polygon.size();\n    raytraceLine(polygon[i], polygon[j], polygon_outline_cells);\n  }\n\n  // If the polygon is not empty, it also closes the polygon by connecting the last point to the first\n  if (!polygon.empty()) {\n    raytraceLine(polygon.back(), polygon.front(), polygon_outline_cells);\n  }\n\n  // Copy the collected cells to the output vector\n  polygon_cells.clear();\n  polygon_cells.insert(polygon_cells.end(), polygon_outline_cells.cells.begin(), polygon_outline_cells.cells.end());\n}", "CodeBleu_score": 53.83954154649112}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t    if (polygon.empty())\n        return;\n\n    polygon_cells.clear();\n\n    // get the first point\n    MapLocation first_point = polygon.front();\n\n    // get the last point\n    MapLocation last_point = polygon.back();\n\n    // if the polygon is not closed, close it\n    if (first_point != last_point) {\n        polygon.push_back(first_point);\n    }\n\n    // iterate through the polygon points\n    for (unsigned int i = 0; i < polygon.size(); ++i) {\n        // get the current point\n        MapLocation current_point = polygon[i];\n\n        // get the next point\n        MapLocation next_point;\n\n        // if the next point is the first point, use the last point\n        if (i == polygon.size() - 1)\n            next_point = polygon[0];\n        else\n            next_point = polygon[i + 1];\n\n        // raytrace the line between the current point and the next point\n        raytraceLine(current_point, next_point, polygon_cells);\n    }\n\n    // if the polygon is not closed, remove the last point\n    if (first_point != last_point) {\n        polygon_cells.pop_back();\n    }\n}", "CodeBleu_score": 50.385469336196785}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  polygon_cells.clear();\n  if (polygon.empty()) {\n    return;\n  }\n  PolygonOutlineCells outline_cells;\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    MapLocation point = polygon[i];\n    MapLocation next_point = polygon[(i + 1) % polygon.size()];\n    raytraceLine(point, next_point, outline_cells);\n  }\n  polygon_cells.insert(polygon_cells.end(), outline_cells.begin(), outline_cells.end());\n  if (polygon_cells.size() > 1) {\n    MapLocation last_point = polygon_cells[polygon_cells.size() - 1];\n    MapLocation first_point = polygon_cells[0];\n    raytraceLine(last_point, first_point, outline_cells);\n    polygon_cells.insert(polygon_cells.end(), outline_cells.begin(), outline_cells.end());\n  }\n}", "CodeBleu_score": 46.776468229393174}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_msg_);\n}", "CodeBleu_score": 75.55406138498581}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  grid_msg_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_msg_.header.stamp = ros::Time::now();\n  pub.publish(grid_msg_);\n}", "CodeBleu_score": 56.53435476923298}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  grid_pub_.publish(grid_);\n}", "CodeBleu_score": 48.4055587527707}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // lock the mutex\n  costmap_->lock();\n\n  // get the resolution\n  double resolution = costmap_->getResolution();\n\n  // set the header\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.header.stamp = ros::Time::now();\n\n  // set the resolution\n  grid_.info.resolution = resolution;\n\n  // set the width and height\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // set the origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n\n  // set the origin orientation\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // populate the grid data\n  unsigned int index = 0;\n  for (unsigned int y = 0; y < grid_.info.height; ++y) {\n    for (unsigned int x = 0; x < grid_.info.width; ++x) {\n      grid_.data[index++] = translationTable_[costmap_->getCost(x, y)];\n    }\n  }\n\n  // unlock the mutex\n  costmap_->unlock();\n}", "CodeBleu_score": 64.70742594095388}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // Lock the costmap mutex and retrieve the resolution\n  boost::recursive_mutex::scoped_lock lock(costmap_->getMutex());\n  double resolution = costmap_->getResolution();\n\n  // Set the grid's header\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.header.stamp = ros::Time::now();\n\n  // Set the grid's resolution\n  grid_.info.resolution = resolution;\n\n  // Set the grid's width and height\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Set the grid's origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  origin_x_ = costmap_->getOriginX();\n  origin_y_ = costmap_->getOriginY();\n\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map\n  for (unsigned int i = 0; i < grid_.info.width; ++i) {\n    for (unsigned int j = 0; j < grid_.info.height; ++j) {\n      grid_.data[i * grid_.info.height + j] = costmap_->getCost(i, j);\n    }\n  }\n}", "CodeBleu_score": 64.54759978087381}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t    // Lock the mutex\n    costmap_->lock();\n\n    // Get the resolution\n    double resolution = costmap_->getResolution();\n\n    // Set the grid's header\n    grid_.header.frame_id = costmap_->getGlobalFrameID();\n    grid_.header.stamp = ros::Time::now();\n\n    // Set the grid's resolution\n    grid_.info.resolution = resolution;\n\n    // Set the grid's width and height\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    // Set the grid's origin\n    grid_.info.origin.position.x = costmap_->getOriginX();\n    grid_.info.origin.position.y = costmap_->getOriginY();\n    grid_.info.origin.position.z = 0.0;\n\n    // Set the grid's origin's orientation\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    // Save the origin coordinates\n    origin_x_ = costmap_->getOriginX();\n    origin_y_ = costmap_->getOriginY();\n\n    // Resize the grid data vector\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    // Populate the grid data from the costmap's character map\n    for (unsigned int i = 0; i < costmap_->getSizeInCellsX(); ++i) {\n        for (unsigned int j = 0; j < costmap_->getSizeInCellsY(); ++j) {\n            grid_.data[j * grid_.info.width + i] = costmap_->getCharMap()[j * costmap_->getSizeInCellsX() + i];\n        }\n    }\n\n    // Unlock the mutex\n    costmap_->unlock();\n}", "CodeBleu_score": 62.63707638059586}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n  // If the new footprint is the same as the old one, just return.\n  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // If the new footprint is not the same as the old one, try to convert the new footprint string to a polygon.\n  if (new_config.footprint.size() > 0) {\n    try {\n      // If the footprint is valid, set it.\n      tf2::fromMsg(new_config.footprint, footprint_);\n      // If the footprint is invalid, log an error.\n    } catch (tf2::InvalidArgumentException &e) {\n      ROS_ERROR(\"Costmap2DROS: Invalid footprint string in configuration: %s\", new_config.footprint.c_str());\n    }\n  }\n\n  // If the new footprint is not provided, set it based on the robot radius.\n  if (footprint_.size() == 0) {\n    footprint_.push_back(tf2::Vector3(-new_config.robot_radius, -new_config.robot_radius, 0));\n    footprint_.push_back(tf2::Vector3(-new_config.robot_radius, new_config.robot_radius, 0));\n    footprint_.push_back(tf2::Vector3(new_config.robot_radius, new_config.robot_radius, 0));\n    footprint_.push_back(tf2::Vector3(new_config.robot_radius, -new_config.robot_radius, 0));\n  }\n\n  // Make sure the footprint is convex.\n  if (!tf2::isConvex(footprint_)) {\n    ROS_ERROR(\"Costmap2DROS: Footprint is not convex!\");\n    return;\n  }\n\n  // Make sure the footprint is within the map bounds.\n  if (!isPointInFootprint(0, 0)) {\n    ROS_ERROR(\"Costmap2DROS: Footprint is not within the map bounds!\");", "CodeBleu_score": 57.47614371923606}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n    // If the footprint and robot radius are the same, return immediately.\n    if (new_config.footprint == old_config.footprint &&\n        new_config.robot_radius == old_config.robot_radius) {\n        return;\n    }\n\n    // If the new configuration contains a valid footprint string, convert it to a footprint and set it.\n    if (!new_config.footprint.empty()) {\n        std::vector<geometry_msgs::Point> footprint;\n        try {\n            footprint = tf2::tfMessageToVector3(new_config.footprint);\n        } catch (tf2::InvalidArgumentException &e) {\n            ROS_ERROR_STREAM(\"Costmap2DROS::readFootprintFromConfig: \" << e.what());\n            return;\n        }\n        if (!footprint.empty()) {\n            setFootprint(footprint);\n            return;\n        }\n    }\n\n    // If the footprint string is invalid, log an error.\n    if (!new_config.footprint.empty()) {\n        ROS_ERROR_STREAM(\"Costmap2DROS::readFootprintFromConfig: footprint string is invalid.\");\n    }\n\n    // If no valid footprint string is provided, set the footprint based on the robot radius.\n    setFootprintFromRadius(new_config.robot_radius);\n}", "CodeBleu_score": 65.12185576454561}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t    if (new_config.footprint.size() > 0) {\n        // If the footprint is specified, we need to convert it to a polygon.\n        if (new_config.footprint.size() > 4) {\n            // If the footprint is a polygon, we need to convert it to a polygon.\n            std::vector<geometry_msgs::Point> points;\n            for (unsigned int i = 0; i < new_config.footprint.size(); ++i) {\n                geometry_msgs::Point32 point;\n                point.x = new_config.footprint[i].x;\n                point.y = new_config.footprint[i].y;\n                points.push_back(point);\n            }\n            // Convert the polygon to a footprint.\n            std::vector<geometry_msgs::Point> footprint;\n            tf2::toMsg(tf2::transformPoints(tf2::Transform(new_config.footprint_pose.orientation,\n                                                           new_config.footprint_pose.position),\n                                            points),\n                       footprint);\n            // Set the footprint.\n            setFootprint(footprint);\n        } else {\n            // If the footprint is a circle, we need to convert it to a polygon.\n            std::vector<geometry_msgs::Point> footprint;\n            // Get the radius of the circle.\n            double radius = std::max(new_config.robot_radius, old_config.robot_radius);\n            // Get the center of the circle.\n            geometry_msgs::Point center;\n            center.x = new_config.footprint_pose.position.x;\n            center.y = new_config.footprint_pose.position.y;\n            // Create a circle.\n            for (double angle = 0; angle < 2 * M_PI; angle += M_PI / 180) {\n                geometry_msgs::Point point;\n                point.x = center.x + radius * cos(angle);\n                point.y = center.y + radius * sin(angle);\n                footprint.push_back(point);\n            }\n            // Set the foot", "CodeBleu_score": 42.442376816471}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\n    geometry_msgs::PoseStamped pose;\n\n    try {\n\n        // Get the robot's pose\n\n        if (!tf_->canTransform(\"base_link\", \"odom\", event.current_real)) {\n\n            ROS_WARN(\"Costmap2DROS: Cannot transform from base_link to odom.\");\n\n            return;\n\n        }\n\n        tf_->lookupTransform(\"base_link\", \"odom\", event.current_real, pose);\n\n        new_pose = pose;\n\n    } catch (tf2::TransformException &ex) {\n\n        ROS_WARN(\"Costmap2DROS: %s\", ex.what());\n\n        return;\n\n    }\n\n    if (new_pose.pose.position.x == 0 && new_pose.pose.position.y == 0) {\n\n        ROS_WARN(\"Costmap2DROS: Cannot transform from base_link to odom.\");\n\n        return;\n\n    }\n\n    // If the robot's pose has changed, reconfigure\n\n    if (new_pose.pose.position.x != old_pose.pose.position.x || new_pose.pose.position.y != old_pose.pose.position.y) {\n\n        reconfigure();\n\n    }\n\n    old_pose = new_pose;\n\n}", "CodeBleu_score": 40.80222824293989}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t    // get the robot's current pose\n    geometry_msgs::PoseStamped robot_pose;\n    if (!tf_->canTransform(\"map\", \"base_link\", event.current_real, robot_pose)) {\n        ROS_WARN(\"Could not retrieve robot pose. Cancelling reconfiguration.\");\n        return;\n    }\n\n    // store the pose\n    new_pose = robot_pose;\n\n    // clear the timer\n    movement_timer.stop();\n}", "CodeBleu_score": 48.53923752370653}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\n  // Attempt to get the robot's current pose\n  geometry_msgs::PoseStamped robot_pose;\n\n  if (!tf_->canTransform(global_frame_, robot_base_frame_, event.current_real.fromSec(0))) {\n\n    ROS_WARN(\"Failed to get robot pose, canceling reconfigure\");\n\n    return;\n\n  }\n\n  try {\n\n    tf_->lookupTransform(global_frame_, robot_base_frame_, event.current_real, robot_pose);\n\n  } catch (tf2::TransformException &ex) {\n\n    ROS_WARN(\"Failed to get robot pose, canceling reconfigure\");\n\n    return;\n\n  }\n\n  // Store the robot's current pose\n  new_pose = robot_pose.pose;\n\n}", "CodeBleu_score": 45.133470708666366}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  // Retrieve the list of plugins.\n  std::vector<costmap_2d::Layer *> layers = costmap_->getLayers();\n\n  // Check if the costmap was stopped.\n  if (stopped_) {\n    // Re-subscribe to topics by activating each plugin.\n    for (unsigned int i = 0; i < layers.size(); i++) {\n      layers[i]->activate();\n    }\n\n    // Set the stopped flag to false.\n    stopped_ = false;\n  }\n\n  // Set stop_updates_ to false.\n  stop_updates_ = false;\n\n  // Wait until ROS is running, the costmap is initialized, and the map update thread is active.\n  while (!ros::ok() || !initialized_ || !map_update_thread_->isRunning()) {\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 51.83410719172107}, {"code": "void Costmap2DROS::start(){\n\t\n    // If the costmap is stopped, reactivate the plugins and set the stopped flag to false.\n    if (stopped_) {\n\n        for (auto it = plugins_.begin(); it != plugins_.end(); it++) {\n\n            if (it->second->isStopped()) {\n\n                it->second->activate();\n            }\n        }\n\n        stopped_ = false;\n    }\n\n    // Wait until ROS is running, the costmap is initialized, and the map update thread is active.\n    while (!ros::ok() || !isInitialized() || !isActive()) {\n\n        ros::Duration(0.1).sleep();\n    }\n}", "CodeBleu_score": 38.928946481992305}, {"code": "void Costmap2DROS::start(){\n\t\n  // reactivate plugins if stopped\n  if (stopped_) {\n    for (auto &plugin : plugins_) {\n      plugin.second->activate();\n    }\n    stopped_ = false;\n  }\n\n  // wait until ROS is running and the map is initialized\n  while (!ros::ok() || !initialized_) {\n    ros::spinOnce();\n  }\n\n  // wait until the map update thread is active\n  while (!thread_running_) {\n    ros::spinOnce();\n  }\n\n}", "CodeBleu_score": 33.83719677416255}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\n    if (observation_keep_time_ == 0) {\n        observations_.clear();\n        return;\n    }\n\n    ros::Time oldest_allowed_observation = ros::Time::now() - ros::Duration(observation_keep_time_);\n\n    while (!observations_.empty() && observations_.front().header.stamp < oldest_allowed_observation) {\n        observations_.pop_front();\n    }\n}", "CodeBleu_score": 30.527036705339484}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  std::list<Observation>::iterator it = observations_.begin();\n  while (it != observations_.end()) {\n    if (observation_keep_time_ == 0 ||\n        (ros::Time::now() - it->observation_time).toSec() < observation_keep_time_) {\n      break;\n    }\n    it = observations_.erase(it);\n  }\n}", "CodeBleu_score": 32.15587508096745}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == 0) {\n    observations_.clear();\n  } else {\n    ros::Time current_time = ros::Time::now();\n    while (!observations_.empty()) {\n      if (observations_.front().header.stamp + observation_keep_time_ > current_time) {\n        break;\n      }\n      observations_.pop_front();\n    }\n  }\n}", "CodeBleu_score": 29.101874602285722}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n  // Get the yaw angles of the start and end pose\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Calculate the shortest angular distance between the yaws\n  double yaw_diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Calculate the change in angle for each pose\n  double yaw_increment = yaw_diff / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index; i <= end_index; i++) {\n    double yaw = start_yaw + (i - start_index) * yaw_increment;\n    tf2::Quaternion q;\n    q.setRPY(0, 0, yaw);\n    path[i].pose.orientation = tf2::toMsg(q);\n  }\n}", "CodeBleu_score": 65.4122786509215}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  if (start_index == end_index)\n    return;\n\n  // Get the start and end yaw angles\n  double start_yaw = tf2::getYaw(path.at(start_index).pose.orientation);\n  double end_yaw = tf2::getYaw(path.at(end_index).pose.orientation);\n\n  // Determine the shortest angular distance between the yaws\n  double yaw_diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Determine the number of poses in the path\n  int num_poses = path.size();\n\n  // Determine the incremental change in angle for each pose\n  double yaw_increment = yaw_diff / (num_poses - 1);\n\n  // Interpolate the yaw angles for each pose\n  for (int i = start_index; i < end_index; ++i) {\n    double yaw = start_yaw + yaw_increment * (i - start_index);\n    path.at(i).pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), yaw));\n  }\n}", "CodeBleu_score": 50.63759066993949}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n    if (start_index == end_index) {\n        return;\n    }\n\n    // Get the yaw angle at the start and end indices\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Calculate the shortest angular distance between the start and end yaw angles\n    double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Calculate the incremental change in angle for each pose\n    double delta_yaw_per_pose = delta_yaw / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index; i < end_index; i++) {\n        double yaw = angles::normalize_angle(start_yaw + i * delta_yaw_per_pose);\n        path[i].pose.orientation = tf2::createQuaternionMsgFromYaw(yaw);\n    }\n}", "CodeBleu_score": 63.91201895182835}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\n    // set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // call makePlan to generate a path\n    if (!makePlan(req.start, req.goal, resp.plan.header.frame_id, resp.plan.header.stamp, resp.plan.durations, resp.plan.waypoints)) {\n        ROS_ERROR(\"Failed to find a plan\");\n        return false;\n    }\n\n    // update the response with the success status and the generated path\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 0;\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.durations.resize(resp.plan.waypoints.size());\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 0;\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.durations.resize(resp.plan.waypoints.size());\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 0;\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.durations.resize(resp.plan.waypoints.size());\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 0;\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.durations.resize(resp.plan.waypoints.size());\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 0;\n    resp.plan.header.frame_id = \"map", "CodeBleu_score": 43.86855645195675}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\n    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    bool found_path = makePlan(req.start, req.goal, resp.plan.poses);\n\n    // Update the response with the success status and the generated path if a plan is found\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.out_of_bounds = false;\n    resp.reached_goal = false;\n    resp.trajectory_start = req.start;\n    resp.trajectory_end = req.goal;\n\n    if (found_path) {\n        resp.out_of_bounds = false;\n        resp.reached_goal = false;\n        resp.plan_found = true;\n        resp.plan_length = resp.plan.poses.size();\n    } else {\n        resp.out_of_bounds = true;\n        resp.reached_goal = false;\n        resp.plan_found = false;\n        resp.plan_length = 0;\n    }\n\n    return true;\n}", "CodeBleu_score": 49.8222567749523}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  geometry_msgs::PoseStamped start;\n  start.header.frame_id = \"map\";\n  start.pose = req.start;\n  geometry_msgs::PoseStamped goal;\n  goal.header.frame_id = \"map\";\n  goal.pose = req.goal;\n  std::vector<geometry_msgs::PoseStamped> plan;\n  bool success = makePlan(start, goal, plan);\n  resp.plan.header.frame_id = \"map\";\n  resp.plan.poses = plan;\n  resp.plan.header.stamp = ros::Time::now();\n  resp.plan_found = success;\n  return true;\n}", "CodeBleu_score": 52.982900787353095}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle nh;\n\n    make_plan_srv_ = nh.advertiseService(name + \"/make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n    goal_sub_ = nh.subscribe(name + \"/goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 54.17454295861128}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~\" + name);\n    private_nh.param(\"global_frame_id\", global_frame_id, std::string(\"map\"));\n    private_nh.param(\"global_frame_id\", global_frame_id, std::string(\"map\"));\n    private_nh.param(\"goal_topic\", goal_topic, std::string(\"move_base_simple/goal\"));\n    private_nh.param(\"plan_service\", plan_service, std::string(\"make_plan\"));\n    private_nh.param(\"pose_topic\", pose_topic, std::string(\"amcl_pose\"));\n    private_nh.param(\"pose_topic\", pose_topic, std::string(\"amcl_pose\"));\n    private_nh.param(\"planner_frequency\", planner_frequency, 1.0);\n    private_nh.param(\"planner_frequency\", planner_frequency, 1.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0);\n    private_nh.param(\"planner_patience\", planner_patience, 5.0", "CodeBleu_score": 41.682144592272856}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    // initialize ROS node handle\n    ros::NodeHandle private_nh(\"~/\" + name);\n\n    // advertise make_plan service\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n    // subscribe to goal topic\n    goal_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n\n    // initialize a tf2_ros TransformListener\n    tf_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);\n\n    // initialize a global_planner::PlannerCore object\n    planner_ = std::make_shared<global_planner::PlannerCore>(name, cmap->getCostmap(), cmap->getGlobalFrameID());\n\n    // initialize a navfn::MakeNavPlan object\n    make_plan_ = std::make_shared<navfn::MakeNavPlan>(name, cmap->getCostmap(), cmap->getGlobalFrameID());\n\n    // initialize a PoseStamped object\n    current_goal_ = std::make_shared<geometry_msgs::PoseStamped>();\n\n    // initialize a bool object\n    new_goal_ = false;\n}", "CodeBleu_score": 57.48142123335024}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < 0 || wx >= costmap_->getSizeInMetersX()) {\n    ROS_WARN(\"The world x coordinate is out of bounds.\");\n    return false;\n  }\n  if (wy < 0 || wy >= costmap_->getSizeInMetersY()) {\n    ROS_WARN(\"The world y coordinate is out of bounds.\");\n    return false;\n  }\n  mx = wx / costmap_->getResolution();\n  my = wy / costmap_->getResolution();\n  return true;\n}", "CodeBleu_score": 40.27346212984264}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\n\t// Check if the world coordinates are within the costmap's origin.\n\tif (wx < world_x_min_ || wx > world_x_max_ || wy < world_y_min_ || wy > world_y_max_) {\n\t\tROS_WARN(\"GlobalPlanner::worldToMap: world coordinates (%f, %f) are outside the costmap's bounds.\", wx, wy);\n\t\treturn false;\n\t}\n\n\t// Calculate the map coordinates.\n\tmx = (wx - world_x_min_) / resolution_;\n\tmy = (wy - world_y_min_) / resolution_;\n\n\t// Check if the map coordinates are within the costmap's size limits.\n\tif (mx < 0 || mx >= size_x_ || my < 0 || my >= size_y_) {\n\t\tROS_WARN(\"GlobalPlanner::worldToMap: map coordinates (%f, %f) are outside the costmap's size limits.\", mx, my);\n\t\treturn false;\n\t}\n\n\t// Return true if the map coordinates are within the costmap's size limits.\n\treturn true;\n}", "CodeBleu_score": 40.42220264857118}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (wx < 0 || wy < 0) {\n        ROS_ERROR(\"(wx, wy) is out of bounds.\");\n        return false;\n    }\n    if (wx > costmap_->getSizeInMetersX() || wy > costmap_->getSizeInMetersY()) {\n        ROS_ERROR(\"(wx, wy) is out of bounds.\");\n        return false;\n    }\n    mx = wx / costmap_->getResolution() + costmap_->getOriginX();\n    my = wy / costmap_->getResolution() + costmap_->getOriginY();\n    return true;\n}", "CodeBleu_score": 46.030710407445994}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, please call initialize() before using this planner\");\n        return;\n    }\n    ROS_DEBUG(\"Publishing a plan (%lu points)\", path.size());\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = map_frame_;\n    gui_path.header.stamp = ros::Time::now();\n    gui_path.poses = path;\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 55.06493125332329}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, please call initialize() before using this planner\");\n        return;\n    }\n    ROS_DEBUG(\"Publishing a plan!\");\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = map_frame_;\n    gui_path.header.stamp = ros::Time::now();\n    gui_path.poses.resize(path.size());\n    for (unsigned int i = 0; i < path.size(); ++i) {\n        gui_path.poses[i] = path[i];\n    }\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 83.84850063249971}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, please call initialize() before using this planner\");\n        return;\n    }\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = map_frame_;\n    gui_path.header.stamp = ros::Time::now();\n    gui_path.poses.resize(path.size());\n    for (unsigned int i = 0; i < path.size(); ++i) {\n        gui_path.poses[i] = path[i];\n    }\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 84.77846304735888}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG(\"Wrapping the goal in an action message\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 70.42251313107695}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG(\"Wrapping goal in action message\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 69.6655705357175}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG(\"Received goal\");\n\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 67.14142364480557}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (distance_squared_ < distance_squared_limit_) {\n    ROS_INFO(\"Moved far enough, stopping distance check.\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      remove_limit_thread_.reset();\n    }\n    remove_limit_thread_ = std::make_shared<std::thread>(&MoveSlowAndClear::removeLimit, this);\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 46.57184278444609}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  // Check if the robot has moved far enough\n  if (sqrt(limited_distance_sq_) < sqrt(current_distance_sq_)) {\n    // Log a message\n    ROS_INFO(\"Moved far enough, removing speed limit.\");\n\n    // Join and delete the remove limit thread\n    remove_limit_thread_.join();\n    remove_limit_thread_.detach();\n\n    // Start a new thread to remove the speed limit\n    remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n    // Stop the distance check timer\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 59.70025595058208}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (current_distance_squared_ < limit_distance_squared_) {\n    ROS_INFO(\"Moved far enough, stopping distance check\");\n    distance_check_timer_.stop();\n    if (remove_limit_thread_.joinable()) {\n      ROS_INFO(\"Joining remove limit thread\");\n      remove_limit_thread_.join();\n    }\n    remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeLimit, this);\n  }\n}", "CodeBleu_score": 58.30614863089569}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\n    // Get the current global pose of the robot.\n    getRobotPose(current_pose_);\n\n    // Generate a path from the current pose to the goal pose.\n    makePlan(current_pose_, *goal, plan_);\n\n}", "CodeBleu_score": 35.46385798524512}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the current global pose of the robot\n  geometry_msgs::PoseStamped global_pose;\n  getRobotPose(global_pose);\n\n  // Get the current global goal pose\n  geometry_msgs::PoseStamped global_goal = *goal;\n\n  // Make a path from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> global_plan;\n  makePlan(global_pose, global_goal, global_plan);\n}", "CodeBleu_score": 53.58709462867137}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the current pose of the robot.\n  rm::PoseStamped current_pose = getRobotPose();\n\n  // Generate a path from the current pose to the goal pose.\n  navfn_->makePlan(current_pose, *goal, plan_);\n\n  // If the plan is empty, return.\n  if (plan_.empty()) {\n    ROS_WARN(\"NavfnWithCostmap: Plan is empty.\");\n    return;\n  }\n\n  // Otherwise, publish the plan.\n  nav_msgs::Path path;\n  path.header.frame_id = \"map\";\n  path.header.stamp = ros::Time::now();\n  path.poses = plan_;\n  path_pub_.publish(path);\n}", "CodeBleu_score": 45.06836365878885}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    param_set_srv_.request.param_id = param_set.param_id;\n    param_set_srv_.request.param_value = param_set.param_value;\n    param_set_client_.call(param_set_srv_);\n}", "CodeBleu_score": 52.04833406014189}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    param_set_srv_.request.param_id = param_set.param_id;\n    param_set_srv_.request.param_value = param_set.param_value;\n    param_set_client_.call(param_set_srv_);\n}", "CodeBleu_score": 52.04833406014189}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    param_set_srv_.request.param_id = param_set.param_id;\n    param_set_srv_.request.param_value = param_set.param_value;\n\n    param_set_client_.call(param_set_srv_);\n}", "CodeBleu_score": 52.04833406014189}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t    // Wait for a connection\n    while (!connected) {\n        // Listen for incoming connections\n        if (listen(sock, 1) < 0) {\n            throw std::runtime_error(\"listen() failed\");\n        }\n        // Accept a connection\n        if ((new_sock = accept(sock, (struct sockaddr *)&client, (socklen_t *)&c)) < 0) {\n            throw std::runtime_error(\"accept() failed\");\n        }\n        // Connected\n        connected = true;\n        // Log\n        std::cout << \"Connected to ground station\" << std::endl;\n    }\n    // Loop to accept incoming connections, receive data, and process it\n    while (true) {\n        // Accept a connection\n        if ((new_sock = accept(sock, (struct sockaddr *)&client, (socklen_t *)&c)) < 0) {\n            throw std::runtime_error(\"accept() failed\");\n        }\n        // Receive data\n        if ((valread = recv(new_sock, buffer, 1024, 0)) <= 0) {\n            throw std::runtime_error(\"recv() failed\");\n        }\n        // Decode message\n        std::stringstream ss;\n        ss << buffer;\n        std::string msg;\n        ss >> msg;\n        // Publish message\n        if (msg.length() > 0) {\n            std::cout << \"Received message from ground station: \" << msg << std::endl;\n            publish(msg);\n        } else {\n            std::cout << \"Error: Received message from ground station is empty\" << std::endl;\n        }\n        // Close socket\n        close(new_sock);\n    }\n}", "CodeBleu_score": 47.379531889876596}, {"code": "void CommunicationBridge::serverFun(){\n\t\n    boost::shared_mutex::scoped_lock lock(mutex);\n\n    // Create a socket\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"ERROR opening socket\" << std::endl;\n        return;\n    }\n\n    // Setup the address structure\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    serv_addr.sin_port = htons(port);\n\n    // Bind\n    if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"ERROR on binding\" << std::endl;\n        return;\n    }\n\n    // Listen\n    listen(sockfd, 5);\n\n    // Accept and incoming connection\n    struct sockaddr_in cli_addr;\n    socklen_t clilen = sizeof(cli_addr);\n    int newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n    if (newsockfd < 0) {\n        std::cerr << \"ERROR on accept\" << std::endl;\n        return;\n    }\n\n    // Receive data from the ground station\n    char buffer[2048];\n    int n = recv(newsockfd, buffer, 2048, 0);\n    if (n < 0) {\n        std::cerr << \"ERROR reading from socket\" << std::endl;\n        return;\n    }\n\n    // Decode the message\n    std::string message = std::string(buffer);\n    std::vector<std::string> tokens = split(message, ',');\n    if (tokens.size() < 2) {\n        std::cerr << \"ERROR decoding message\" << std::endl;\n        return;\n    }\n\n    // Publish the", "CodeBleu_score": 43.44093046804909}, {"code": "void CommunicationBridge::serverFun(){\n\t\n    // create a TCP socket\n    boost::asio::io_service io_service;\n    boost::asio::ip::tcp::socket socket(io_service);\n\n    // create a TCP acceptor\n    boost::asio::ip::tcp::acceptor acceptor(io_service);\n\n    // bind to the specified port\n    boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port_);\n    acceptor.open(endpoint.protocol());\n    acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n    acceptor.bind(endpoint);\n    acceptor.listen();\n\n    // accept a connection\n    acceptor.accept(socket);\n\n    // enter a loop to handle further connections\n    while (true) {\n\n        // create a new socket for the next connection\n        boost::asio::ip::tcp::socket new_socket(io_service);\n\n        // accept a connection\n        acceptor.accept(new_socket);\n\n        // create a thread to handle the connection\n        boost::thread t(boost::bind(&CommunicationBridge::handleConnection, this, new_socket));\n\n        // wait for the thread to finish\n        t.join();\n    }\n}", "CodeBleu_score": 23.83349342599298}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\n  if (simulation_mode_) {\n    // Simulation mode\n    // Find the corresponding UAV\n    boost::shared_lock<boost::shared_mutex> lock(swarm_control_simulation_mutex_);\n    for (auto uav : swarm_control_simulation_) {\n      if (uav.getUAVID() == uav_cmd.uav_id) {\n        // Send the command to the UAV\n        uav.recvData(uav_cmd);\n      }\n    }\n  } else {\n    // Non-simulation mode\n    // Send the command to the UAV\n    uav_basic_.recvData(uav_cmd);\n  }\n}", "CodeBleu_score": 39.33017605221836}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (simulation_mode_) {\n        boost::shared_lock<boost::shared_mutex> lock(simulation_mutex_);\n        if (swarm_control_simulation_.find(uav_cmd.uav_id) != swarm_control_simulation_.end()) {\n            swarm_control_simulation_.at(uav_cmd.uav_id)->recvData(uav_cmd);\n        } else {\n            ROS_WARN(\"Received command for UAV %d but no UAV with that ID exists in simulation.\", uav_cmd.uav_id);\n        }\n    } else {\n        uav_basic_.recvData(uav_cmd);\n    }\n}", "CodeBleu_score": 42.50286920047846}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (uav_cmd.id == 0) {\n\t\tif (simulation_mode_) {\n\t\t\tfor (auto &uav : swarm_control_simulation_) {\n\t\t\t\tuav->recvData(uav_cmd);\n\t\t\t}\n\t\t} else {\n\t\t\tuav_basic_.recvData(uav_cmd);\n\t\t}\n\t} else {\n\t\tif (simulation_mode_) {\n\t\t\tfor (auto &uav : swarm_control_simulation_) {\n\t\t\t\tif (uav->getID() == uav_cmd.id) {\n\t\t\t\t\tuav->recvData(uav_cmd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.77018187997082}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    //Check if the mode is not EXITNX\n    if (mode_selection.mode != EXITNX) {\n        //Check if the mode is not REBOOTNX\n        if (mode_selection.mode != REBOOTNX) {\n            //Check if the mode is not CREATEMODE\n            if (mode_selection.mode != CREATEMODE) {\n                //Check if the mode is not DELETEMODE\n                if (mode_selection.mode != DELETEMODE) {\n                    //Check if the mode is not UPDATEMODE\n                    if (mode_selection.mode != UPDATEMODE) {\n                        //Check if the mode is not READMODE\n                        if (mode_selection.mode != READMODE) {\n                            //Check if the mode is not LISTMODE\n                            if (mode_selection.mode != LISTMODE) {\n                                //Check if the mode is not SHOWMODE\n                                if (mode_selection.mode != SHOWMODE) {\n                                    //Check if the mode is not RESETMODE\n                                    if (mode_selection.mode != RESETMODE) {\n                                        //Check if the mode is not READYMODE\n                                        if (mode_selection.mode != READYMODE) {\n                                            //Check if the mode is not BACKUPMODE\n                                            if (mode_selection.mode != BACKUPMODE) {\n                                                //Check if the mode is not RESTOREMODE\n                                                if (mode_selection.mode != RESTOREMODE) {\n                                                    //Check if the mode is not EXITMODE\n                                                    if (mode_selection.mode != EXITMODE) {\n                                                        //Check if the mode is not READYRESETMODE\n                                                        if (mode_selection.mode != READYRESETMODE) {\n                                                            //Check if the mode is not READYRESETMODE\n                                                            if (mode_selection.mode != READYREBOOTMODE) {\n                                                                //Check if the mode is not READYREBOOTMODE\n                                                                if (mode_selection.mode != READYEXITMODE) {\n                                ", "CodeBleu_score": 33.139883546703686}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\n    if (mode_selection.mode == \"REBOOTNX\") {\n        system(\"reboot\");\n    }\n    else if (mode_selection.mode == \"EXITNX\") {\n        system(\"exit\");\n    }\n    else {\n        if (mode_selection.use_mode == true) {\n            createMode(mode_selection.mode);\n        }\n        else {\n            deleteMode(mode_selection.mode);\n        }\n    }\n}", "CodeBleu_score": 50.32037121683135}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    switch (mode_selection.mode) {\n        case Mode::EXITNX:\n            if (mode_selection.use_mode) {\n                createMode(mode_selection.mode);\n            } else {\n                deleteMode(mode_selection.mode);\n            }\n            break;\n        case Mode::REBOOTNX:\n            if (mode_selection.use_mode) {\n                createMode(mode_selection.mode);\n            } else {\n                deleteMode(mode_selection.mode);\n            }\n            break;\n        default:\n            break;\n    }\n}", "CodeBleu_score": 46.62455926358531}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\n    // Get the current time\n    ros::Time current_time = ros::Time::now();\n\n    // Get the time since the last heartbeat\n    ros::Duration time_since_last_heartbeat = current_time - last_heartbeat_time;\n\n    // Increment the missed heartbeat counter\n    missed_heartbeat_count++;\n\n    // If the heartbeat is late, print a warning\n    if (time_since_last_heartbeat > heartbeat_timeout) {\n        ROS_WARN(\"Heartbeat is late.\");\n    }\n\n    // If the heartbeat is missing, print an error and set the disconnect_flag to true\n    if (missed_heartbeat_count >= heartbeat_missed_count_threshold) {\n        ROS_ERROR(\"Heartbeat is missing.\");\n        disconnect_flag = true;\n    }\n\n    // If the heartbeat is lost, print a warning and set the disconnect_flag to true\n    if (time_since_last_heartbeat > heartbeat_timeout) {\n        ROS_WARN(\"Heartbeat is lost.\");\n        disconnect_flag = true;\n    }\n\n    // If the heartbeat is late or lost, print an error and set the disconnect_flag to true\n    if (disconnect_flag) {\n        ROS_ERROR(\"Heartbeat is lost or late.\");\n        disconnect_flag = true;\n    }\n}", "CodeBleu_score": 30.02135247004728}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    boost::mutex::scoped_lock lock(heartbeat_mutex);\n\n    // check if heartbeat is received\n    if (heartbeat_count == 0) {\n        // if not, increment the missed heartbeat count\n        missed_heartbeat_count++;\n    } else {\n        // if so, reset the missed heartbeat count\n        missed_heartbeat_count = 0;\n    }\n\n    // if the heartbeat count is greater than the threshold, print an error message and trigger appropriate actions\n    if (missed_heartbeat_count > HEARTBEAT_THRESHOLD) {\n        ROS_ERROR(\"Heartbeat count exceeded threshold. Disconnecting from vehicle.\");\n        disconnect_flag = true;\n\n        // if the vehicle type is UAV, send a disconnect message to the vehicle\n        if (vehicle_type == \"uav\") {\n            ROS_INFO(\"Sending disconnect message to UAV.\");\n            sendDisconnectMessage();\n        }\n    }\n}", "CodeBleu_score": 21.77856748782788}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    boost::shared_lock<boost::shared_mutex> lock(heartbeat_mutex);\n    if (heartbeat_count == 0) {\n        heartbeat_count++;\n        return;\n    }\n    if (heartbeat_count == 1) {\n        ROS_ERROR(\"Heartbeat lost. Checking connection.\");\n        heartbeat_count++;\n        return;\n    }\n    if (heartbeat_count == 2) {\n        ROS_ERROR(\"Heartbeat lost. Checking connection.\");\n        heartbeat_count++;\n        return;\n    }\n    if (heartbeat_count == 3) {\n        ROS_ERROR(\"Heartbeat lost. Checking connection.\");\n        heartbeat_count++;\n        return;\n    }\n    if (heartbeat_count == 4) {\n        ROS_ERROR(\"Heartbeat lost. Checking connection.\");\n        heartbeat_count++;\n        return;\n    }\n    if (heartbeat_count == 5) {\n        ROS_ERROR(\"Heartbeat lost. Checking connection.\");\n        heartbeat_count++;\n        return;\n    }\n    if (heartbeat_count == 6) {\n        ROS_ERROR(\"Heartbeat lost. Checking connection.\");\n        heartbeat_count++;\n        return;\n    }\n    if (heartbeat_count == 7) {\n        ROS_ERROR(\"Heartbeat lost. Checking connection.\");\n        heartbeat_count++;\n        return;\n    }\n    if (heartbeat_count == 8) {\n        ROS_ERROR(\"Heartbeat lost. Checking connection.\");\n        heartbeat_count++;\n        return;\n    }\n    if (heartbeat_count == 9) {\n        ROS_ERROR(\"Heartbeat lost. Checking connection.\");\n        heartbeat_count++;\n        return;\n    }\n    if (heartbeat_count == 10) {\n        ROS_ERROR(\"Heartbeat lost. Checking connection.\");\n        heartbeat_count++;\n        return;\n   ", "CodeBleu_score": 29.15457776220496}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // std::cout << \"Received TCP message.\" << std::endl;\n\n    // Get drone ID\n    int id = msg->id;\n    std::stringstream ss;\n    ss << id;\n    std::string id_str = ss.str();\n\n    // Get trajectory data\n    std::vector<Bspline> bsplines;\n    std::vector<double> time_stamps;\n    std::vector<double> yaw_angles;\n    std::vector<geometry_msgs::Point> position_points;\n    std::vector<geometry_msgs::Point> velocity_points;\n    std::vector<geometry_msgs::Point> acceleration_points;\n    std::vector<geometry_msgs::Point> jerk_points;\n    std::vector<geometry_msgs::Point> snap_points;\n    std::vector<geometry_msgs::Point> position_points_prev;\n    std::vector<geometry_msgs::Point> velocity_points_prev;\n    std::vector<geometry_msgs::Point> acceleration_points_prev;\n    std::vector<geometry_msgs::Point> jerk_points_prev;\n    std::vector<geometry_msgs::Point> snap_points_prev;\n    std::vector<double> yaw_angles_prev;\n    std::vector<double> yaw_angles_next;\n\n    for (int i = 0; i < msg->bsplines.size(); i++) {\n        Bspline bspline;\n        bspline.degree = msg->bsplines[i].degree;\n        bspline.order = msg->bsplines[i].order;\n        bspline.knots = msg->bsplines[i].knots;\n        bspline.position_points = msg->bsplines[i].position_points;\n        bspline.velocity_points = msg->bsplines[i].velocity_points;\n        bspline.acceleration_points = msg->bsplines[i].acceleration_points;\n        bspline.jerk_points = msg->bsplines[i].jerk_points;\n", "CodeBleu_score": 40.305495209250566}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    int drone_id = msg->drone_id;\n    std::vector<prometheus_msgs::Bspline> bsplines = msg->bsplines;\n    std::vector<prometheus_msgs::Bspline> bsplines_temp;\n\n    // 1. \u521d\u59cb\u5316\n    for (int i = 0; i < bsplines.size(); i++)\n    {\n        prometheus_msgs::Bspline bspline;\n        bspline.drone_id = drone_id;\n        bspline.bspline_id = bsplines[i].bspline_id;\n        bspline.bspline_type = bsplines[i].bspline_type;\n        bspline.knots = bsplines[i].knots;\n        bspline.points = bsplines[i].points;\n        bspline.yaw_points = bsplines[i].yaw_points;\n\n        bsplines_temp.push_back(bspline);\n    }\n\n    // 2. \u53d1\u9001\n    for (int i = 0; i < bsplines_temp.size(); i++)\n    {\n        // 1. \u521d\u59cb\u5316\n        prometheus_msgs::Bspline bspline;\n        bspline.drone_id = bsplines_temp[i].drone_id;\n        bspline.bspline_id = bsplines_temp[i].bspline_id;\n        bspline.bspline_type = bsplines_temp[i].bspline_type;\n        bspline.knots = bsplines_temp[i].knots;\n        bspline.points = bsplines_temp[i].points;\n        bspline.yaw_points = bsplines_temp[i].yaw_points;\n\n        // 2. \u53d1\u9001\n        if (bspline.bspline_type == 1)\n        {\n            std::vector<prometheus_msgs::Bspline> bspline_temp;\n           ", "CodeBleu_score": 42.87727132369279}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\n    // Get the drone ID\n    int drone_id = msg->drone_id;\n\n    // Get the trajectories\n    std::vector<Bspline> trajectories;\n    trajectories.resize(msg->trajectories.size());\n\n    // Initialize the Bspline structs\n    for(int i = 0; i < msg->trajectories.size(); i++) {\n        trajectories[i].id = msg->trajectories[i].id;\n        trajectories[i].n_dims = msg->trajectories[i].n_dims;\n        trajectories[i].n_knots = msg->trajectories[i].n_knots;\n        trajectories[i].n_ctrl_pts = msg->trajectories[i].n_ctrl_pts;\n        trajectories[i].n_ctrl_pts_per_dim = msg->trajectories[i].n_ctrl_pts_per_dim;\n        trajectories[i].knots = msg->trajectories[i].knots;\n        trajectories[i].ctrl_pts = msg->trajectories[i].ctrl_pts;\n        trajectories[i].ctrl_pts_yaw = msg->trajectories[i].ctrl_pts_yaw;\n    }\n\n    // Encode the data\n    std::string encoded_data = encodeMultiBsplines(drone_id, trajectories);\n\n    // Send the data\n    comm_->send(encoded_data);\n}", "CodeBleu_score": 41.97326500760854}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud using an octree\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree;\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n    octree.compress();\n\n    // Store the compressed data\n    pcl::PointCloud<pcl::PointXYZ> cloud_out;\n    octree.getPointCloud(cloud_out);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 msg_out;\n    pcl::toROSMsg(cloud_out, msg_out);\n\n    // Ensure to release dynamically allocated memory\n    cloud.reset();\n    cloud_out.clear();\n\n    // Return the new message\n    return msg_out;\n}", "CodeBleu_score": 34.53485869446188}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n  // Convert the PointCloud2 message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZRGB>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Compress the point cloud using an octree\n  pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZRGB>);\n  pcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree;\n  octree.setInputCloud(cloud);\n  octree.addPointsFromInputCloud();\n  octree.getPointRepresentation()->setColorImportance(1.0);\n  octree.getPointRepresentation()->setHeightImportance(0.0);\n  octree.getPointRepresentation()->setIntensityImportance(0.0);\n  octree.getPointRepresentation()->setSpatialImportance(1.0);\n  octree.compress(*cloud_compressed);\n\n  // Create a new PointCloud2 message with the compressed data\n  sensor_msgs::PointCloud2 msg_compressed;\n  pcl::toROSMsg(*cloud_compressed, msg_compressed);\n\n  // Release dynamically allocated memory\n  cloud.reset();\n  cloud_compressed.reset();\n\n  return msg_compressed;\n}", "CodeBleu_score": 35.83047674461789}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n    // Declare a point cloud object\n    pcl::PointCloud<pcl::PointXYZRGB> cloud;\n\n    // Convert the input message to a point cloud\n    pcl::fromROSMsg(msg, cloud);\n\n    // Create a compressed point cloud object\n    pcl::PointCloud<pcl::PointXYZRGB> compressed_cloud;\n\n    // Compress the point cloud\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree;\n    octree.setInputCloud(cloud.makeShared());\n    octree.addPointsFromInputCloud();\n    octree.getCompressedPointCloud(compressed_cloud);\n\n    // Create a new point cloud message\n    sensor_msgs::PointCloud2 compressed_msg;\n\n    // Convert the compressed point cloud to a message\n    pcl::toROSMsg(compressed_cloud, compressed_msg);\n\n    // Set the frame_id of the compressed message to the same as the input message\n    compressed_msg.header.frame_id = msg.header.frame_id;\n\n    // Set the stamp of the compressed message to the same as the input message\n    compressed_msg.header.stamp = msg.header.stamp;\n\n    // Release dynamically allocated memory\n    compressed_cloud.clear();\n\n    // Return the compressed message\n    return compressed_msg;\n}", "CodeBleu_score": 32.1019960026152}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < multi_uav_state_.uav_state.size(); i++) {\n        if (multi_uav_state_.uav_state[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_.uav_state[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 61.665713275504565}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto it = multi_uav_state_.begin(); it != multi_uav_state_.end(); it++) {\n        if (it->uav_id == uav_state.uav_id) {\n            *it = uav_state;\n        }\n    }\n}", "CodeBleu_score": 43.05210209645941}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto it = multi_uav_state_.begin(); it != multi_uav_state_.end(); ++it) {\n        if (it->uav_id == uav_state.uav_id) {\n            it->x = uav_state.x;\n            it->y = uav_state.y;\n            it->z = uav_state.z;\n            it->vx = uav_state.vx;\n            it->vy = uav_state.vy;\n            it->vz = uav_state.vz;\n            it->roll = uav_state.roll;\n            it->pitch = uav_state.pitch;\n            it->yaw = uav_state.yaw;\n            it->pitch_rate = uav_state.pitch_rate;\n            it->roll_rate = uav_state.roll_rate;\n            it->yaw_rate = uav_state.yaw_rate;\n            it->battery_percentage = uav_state.battery_percentage;\n            it->remaining_flight_time = uav_state.remaining_flight_time;\n            it->altitude_above_home = uav_state.altitude_above_home;\n            it->altitude_above_ground = uav_state.altitude_above_ground;\n            it->current_waypoint_index = uav_state.current_waypoint_index;\n            it->current_waypoint_latitude = uav_state.current_waypoint_latitude;\n            it->current_waypoint_longitude = uav_state.current_waypoint_longitude;\n            it->current_waypoint_altitude = uav_state.current_waypoint_altitude;\n            it->current_waypoint_yaw = uav_state.current_waypoint_yaw;\n            it->current_waypoint_vx = uav_state.current_waypoint_vx;\n            it->current_waypoint_vy = uav_state.current_waypoint_vy;\n            it->current_waypoint_vz = uav_", "CodeBleu_score": 35.99224059818554}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    // Declare and initialize MultiUGVState message\n    swarm_control_msgs::MultiUGVState m_ugv_state_msg;\n\n    // Initialize UGV count\n    int ugv_count = 0;\n\n    // Iterate through each UGV state in the MultiUGVState message\n    for (int i = 0; i < m_multi_ugv_state.ugv_state.size(); i++) {\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        m_ugv_state_msg.ugv_state[ugv_count].ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n        m_ugv_state_msg.ugv_state[ugv_count].battery = m_multi_ugv_state.ugv_state[i].battery;\n        m_ugv_state_msg.ugv_state[ugv_count].position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        m_ugv_state_msg.ugv_state[ugv_count].position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        m_ugv_state_msg.ugv_state[ugv_count].position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        m_ugv_state_msg.ugv_state[ugv_count].velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        m_ugv_state_msg.ugv_state[ugv_count].velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n        m_ugv_state_msg.ugv_state[ugv_count].velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n        m_ugv_state_msg.ugv_state[ugv_", "CodeBleu_score": 44.18471356408042}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\n    // Create a MultiUGVState message\n    swarm_control_msgs::MultiUGVState multi_ugv_state;\n\n    // Iterate through each UGV state\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\n        // Create a UGVState message\n        swarm_control_msgs::UGVState ugv_state;\n\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        ugv_state.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n        ugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n        ugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        ugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        ugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        ugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        ugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n        ugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n        ugv_state.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n        ugv_state.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n        ugv_state.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n        ugv_state.attitude.w = m_multi_ugv_state.ug", "CodeBleu_score": 40.52594896798901}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\n    // Initialize a MultiUGVState message\n    swarm_control_msgs::MultiUGVState multi_ugv_state;\n\n    // Iterate through each UGV state\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        swarm_control_msgs::UGVState ugv_state;\n        ugv_state.id = m_multi_ugv_state.ugv_states[i].id;\n        ugv_state.battery = m_multi_ugv_state.ugv_states[i].battery;\n        ugv_state.position.x = m_multi_ugv_state.ugv_states[i].position.x;\n        ugv_state.position.y = m_multi_ugv_state.ugv_states[i].position.y;\n        ugv_state.position.z = m_multi_ugv_state.ugv_states[i].position.z;\n        ugv_state.velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n        ugv_state.velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n        ugv_state.velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n        ugv_state.attitude.x = m_multi_ugv_state.ugv_states[i].attitude.x;\n        ugv_state.attitude.y = m_multi_ugv_state.ugv_states[i].attitude.y;\n        ugv_state.attitude.z = m_multi_ugv_state.ugv_states[i].attitude.z;\n        ugv_state.attitude.w = m_multi_ugv_state.ugv_states[i].attitude.w;\n\n        // In", "CodeBleu_score": 39.78350013142723}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n\n    Eigen::MatrixXd predicted_pos = Eigen::MatrixXd::Zero(num_moving_obj_, 3);\n    Eigen::MatrixXd dist_error = Eigen::MatrixXd::Zero(num_moving_obj_, 1);\n    Eigen::MatrixXd dist_error_sqr = Eigen::MatrixXd::Zero(num_moving_obj_, 1);\n\n    // compute predicted positions of moving objects\n    for (int i = 0; i < num_moving_obj_; i++) {\n        for (int j = 0; j < num_moving_obj_control_pts_[i]; j++) {\n            predicted_pos.row(i) += BsplineOptimizer::basis_matrix_.block(0, j, 3, 1) * q.row(moving_obj_control_pts_[i][j]);\n        }\n    }\n\n    // compute distance error\n    for (int i = 0; i < num_moving_obj_; i++) {\n        dist_error.row(i) = moving_obj_pos_[i] - predicted_pos.row(i);\n        dist_error_sqr.row(i) = dist_error.row(i).cwiseProduct(dist_error.row(i));\n    }\n\n    // update cost and gradient\n    for (int i = 0; i < num_moving_obj_; i++) {\n        cost += dist_error_sqr.row(i)(0);\n        gradient.block(3 * i, 0, 3, 1) = 2 * dist_error.row(i);\n    }\n\n    // update cost and gradient\n    for (int i = 0; i < num_moving_obj_; i++) {\n        cost += dist_error_sqr.row(i)(0);\n        gradient.block(3 * i, 0, 3, 1) = 2 * dist_error.row(i);\n    }\n\n    // update cost and gradient\n    for (int i = 0; i < num_", "CodeBleu_score": 36.50878857785385}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n    // initialize gradient and cost\n    gradient.setZero(n_dim_, n_ctrl_pts_);\n    cost = 0;\n\n    // compute predicted positions of moving objects\n    Eigen::MatrixXd pred_pos = Eigen::MatrixXd::Zero(n_dim_, n_ctrl_pts_);\n    for (int i = 0; i < n_ctrl_pts_; i++) {\n        pred_pos.col(i) = getPredPos(q, i);\n    }\n\n    // iterate through control points\n    for (int i = 0; i < n_ctrl_pts_; i++) {\n        // compute distance between control point and moving objects\n        double dist = 0;\n        for (int j = 0; j < n_moving_obj_; j++) {\n            dist += (pred_pos.col(i) - moving_obj_pos_[j]).norm();\n        }\n\n        // if distance is less than clearance, update cost and gradient\n        if (dist < clearance_) {\n            cost += (dist - clearance_) * (dist - clearance_);\n            gradient.col(i) += 2 * (dist - clearance_) * (pred_pos.col(i) - moving_obj_pos_[0]);\n        }\n    }\n}", "CodeBleu_score": 39.85702438240438}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0;\n    gradient.setZero(n_moving_objects_, 3);\n    for (int i = 0; i < n_moving_objects_; i++) {\n        double dist = 0;\n        for (int j = 0; j < n_control_points_; j++) {\n            Eigen::Vector3d pos = bspline_.calcPosition(j, q);\n            dist += (moving_objects_[i].pos - pos).norm();\n        }\n        if (dist < clearance_) {\n            cost += dist;\n            gradient.row(i) = moving_objects_[i].pos - bspline_.calcPosition(0, q);\n        }\n    }\n}", "CodeBleu_score": 34.80012937093874}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize cost\n\tcost = 0;\n\tgradient.setZero(q.rows(), q.cols());\n\n\t// Iterate through control points\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Compute positional error\n\t\tEigen::VectorXd error = q.row(i) - ref_points_.row(i);\n\t\t// Compute velocity vector\n\t\tEigen::VectorXd velocity = (q.row(i) - q.row(i - 1)) / dt_;\n\n\t\t// Compute cost and gradient\n\t\tcost += a2_ * error.transpose() * error;\n\t\tgradient.row(i) += 2 * a2_ * error;\n\n\t\t// Compute cost and gradient\n\t\tcost += b2_ * velocity.transpose() * velocity;\n\t\tgradient.row(i) += 2 * b2_ * velocity;\n\t}\n}", "CodeBleu_score": 24.579574714200486}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n  // Initialize cost to zero\n  cost = 0;\n\n  // Iterate through the control points\n  for (int i = 0; i < (int)q.rows(); i++) {\n\n    // Compute positional error and velocity vector\n    Eigen::Vector3d pos_error = q.row(i) - ref_points_.row(i);\n    Eigen::Vector3d vel = (q.row(i) - q.row(i - 1)) / dt_;\n\n    // Compute cost and gradient\n    cost += a2_ * pos_error.squaredNorm() + b2_ * vel.squaredNorm();\n    gradient.row(i) += 2 * a2_ * pos_error + 2 * b2_ * vel;\n  }\n}", "CodeBleu_score": 23.24822266726404}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0;\n    gradient.setZero();\n    for (int i = 0; i < q.cols(); i++) {\n        Eigen::Vector3d error = q.col(i) - ref_points_[i];\n        Eigen::Vector3d velocity = (q.col(i) - q.col(i - 1)) / dt_;\n        double a2 = 1.0 / (error.squaredNorm() + 1.0);\n        double b2 = 1.0 / (velocity.squaredNorm() + 1.0);\n        double cost_i = a2 * b2 * error.dot(error);\n        double gradient_i = 2 * a2 * b2 * error.dot(velocity);\n        cost += cost_i;\n        gradient.col(i) += gradient_i * velocity;\n    }\n}", "CodeBleu_score": 33.82554486889773}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t  double jerk = 0.0;\n  int dim = getDim();\n  int num_knots = getNumKnots();\n  int num_control_points = getNumControlPoints();\n  int num_control_points_minus_one = num_control_points - 1;\n  double knot_time_diff = getKnotTime(num_knots - 1) - getKnotTime(0);\n  double knot_time_diff_squared = knot_time_diff * knot_time_diff;\n  double knot_time_diff_cubed = knot_time_diff_squared * knot_time_diff;\n  double knot_time_diff_fourth = knot_time_diff_cubed * knot_time_diff;\n  double knot_time_diff_fifth = knot_time_diff_fourth * knot_time_diff;\n  double knot_time_diff_sixth = knot_time_diff_fifth * knot_time_diff;\n  double knot_time_diff_seventh = knot_time_diff_sixth * knot_time_diff;\n  double knot_time_diff_eighth = knot_time_diff_seventh * knot_time_diff;\n  double knot_time_diff_ninth = knot_time_diff_eighth * knot_time_diff;\n  double knot_time_diff_tenth = knot_time_diff_ninth * knot_time_diff;\n  double knot_time_diff_eleventh = knot_time_diff_tenth * knot_time_diff;\n  double knot_time_diff_twelfth = knot_time_diff_eleventh * knot_time_diff;\n  double knot_time_diff_thirteenth = knot_time_diff_twelfth * knot_time_diff;\n  double knot_time_diff_fourteenth = knot_time_diff_thirteenth * knot_time_diff;\n  double knot_time_diff_fifteenth = kn", "CodeBleu_score": 26.19273941972167}, {"code": "double UniformBspline::getJerk(){\n\t  double jerk = 0.0;\n  for (int i = 0; i < control_points_.size(); i++) {\n    for (int j = 0; j < control_points_[i].size(); j++) {\n      jerk += (control_points_[i][j] * control_points_[i][j]) * (knot_times_[i+1] - knot_times_[i]);\n    }\n  }\n  return jerk;\n}", "CodeBleu_score": 41.434480183896}, {"code": "double UniformBspline::getJerk(){\n\t    // First, we compute the third derivative of the spline to obtain the jerk trajectory.\n    UniformBspline jerkTraj = this->getThirdDerivative();\n\n    // We then retrieve the knot times and control points of the jerk trajectory.\n    std::vector<double> jerkKnotTimes = jerkTraj.getKnotTimes();\n    std::vector<std::vector<double>> jerkControlPoints = jerkTraj.getControlPoints();\n\n    // We iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times.\n    double jerk = 0;\n    for (int i = 0; i < jerkControlPoints.size(); i++) {\n        for (int j = 0; j < jerkControlPoints[i].size(); j++) {\n            jerk += pow(jerkControlPoints[i][j], 2) * (jerkKnotTimes[i + 1] - jerkKnotTimes[i]);\n        }\n    }\n\n    // Finally, we return the total jerk value.\n    return jerk;\n}", "CodeBleu_score": 47.65364791505496}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1;\n\treturn pos;\n}", "CodeBleu_score": 60.79764647195039}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t  Eigen::Vector4d pos;\n  pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n  return pos;\n}", "CodeBleu_score": 48.8002199910955}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    // Calculate 3D position from pixel coordinates and depth\n    Eigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1.0;\n\n    return pos;\n}", "CodeBleu_score": 64.68252545356489}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    rcvDroneOdomCallbackBase(odom, getDroneIdFromOdom(odom));\n  }\n  catch (std::exception& e) {\n    ROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n  }\n}", "CodeBleu_score": 37.93829562555994}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        int drone_id = std::stoi(odom.child_frame_id.substr(1));\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (std::exception& e) {\n        ROS_WARN_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n    }\n}", "CodeBleu_score": 56.74388307063438}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    rcvDroneOdomCallbackBase(odom, getDroneIdFromChildFrameId(odom.child_frame_id));\n  } catch (const std::invalid_argument& e) {\n    std::cerr << e.what() << std::endl;\n  }\n}", "CodeBleu_score": 40.90402830239711}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n    // Check if the drone is present in the image\n    if (true_pixel[0] >= 0 && true_pixel[1] >= 0) {\n        // Compute the pose of the drone in the camera frame\n        Eigen::Vector3d drone_pos_cam = this->camera_model.unproject(true_pixel);\n\n        // Compute the pose of the drone in the world frame\n        Eigen::Vector3d drone_pos_world = this->camera_model.pose * drone_pos_cam;\n\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d drone_pos_error = drone_pos_world - this->drone_pos_world[drone_id];\n\n        // Check if the drone is within the detection range\n        if (drone_pos_error.norm() < this->drone_detection_range) {\n            // Update the debug result\n            this->debug_result[drone_id] = true;\n\n            // Publish the drone pose error\n            this->drone_pose_error_pub.publish(this->drone_pose_error_msg);\n        }\n        else {\n            // Update the debug result\n            this->debug_result[drone_id] = false;\n        }\n    }\n    else {\n        // Update the debug result\n        this->debug_result[drone_id] = false;\n    }\n}", "CodeBleu_score": 32.483019134694814}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Get the drone's true pose in the camera frame\n    Eigen::Vector3d true_pose = this->get_true_pose(drone_id, true_pixel);\n\n    // Get the drone's true pose in the world frame\n    Eigen::Vector3d world_pose = this->get_world_pose(true_pose);\n\n    // Check if the drone is in the camera frame\n    if (this->check_drone_in_frame(true_pose)) {\n        // Compute the pose error\n        Eigen::Vector3d pose_error = this->compute_pose_error(true_pose, world_pose);\n\n        // Update the debug result\n        this->debug_result.id = drone_id;\n        this->debug_result.true_pose = true_pose;\n        this->debug_result.world_pose = world_pose;\n        this->debug_result.pose_error = pose_error;\n        this->debug_result.found = true;\n    } else {\n        // Update the debug result\n        this->debug_result.id = drone_id;\n        this->debug_result.true_pose = true_pose;\n        this->debug_result.world_pose = world_pose;\n        this->debug_result.pose_error = Eigen::Vector3d::Zero();\n        this->debug_result.found = false;\n    }\n\n    // Publish the pose error\n    this->publish_pose_error(this->debug_result.pose_error);\n}", "CodeBleu_score": 29.060869947741462}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Get the drone's pose in the world frame\n    geometry_msgs::PoseStamped drone_pose = getDronePose(drone_id);\n\n    // Get the drone's pose in the camera frame\n    Eigen::Vector3d drone_position_camera = getDronePositionCamera(drone_id);\n    Eigen::Quaterniond drone_orientation_camera = getDroneOrientationCamera(drone_id);\n\n    // Get the camera's pose in the world frame\n    geometry_msgs::PoseStamped camera_pose = getCameraPose();\n\n    // Get the camera's pose in the camera frame\n    Eigen::Vector3d camera_position_camera = getCameraPositionCamera();\n    Eigen::Quaterniond camera_orientation_camera = getCameraOrientationCamera();\n\n    // Get the camera's intrinsics\n    Eigen::Vector2d focal_length = getCameraFocalLength();\n    Eigen::Vector2d principal_point = getCameraPrincipalPoint();\n\n    // Get the drone's true position in the world frame\n    Eigen::Vector3d drone_position_world = getDronePositionWorld(drone_id);\n    Eigen::Quaterniond drone_orientation_world = getDroneOrientationWorld(drone_id);\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d drone_position_camera_true = getDronePositionCameraTrue(drone_id);\n    Eigen::Quaterniond drone_orientation_camera_true = getDroneOrientationCameraTrue(drone_id);\n\n    // Get the camera's true position in the world frame\n    Eigen::Vector3d camera_position_world = getCameraPositionWorld();\n    Eigen::Quaterniond camera_orientation_world = getCameraOrientationWorld();\n\n    // Get the camera's true position in the camera frame\n    Eigen::Vector3d camera_position_camera_true = getCameraPositionCameraTrue();\n    Eigen::Quaterniond camera_orientation_camera_true = getCameraOrientationCameraTrue();\n\n    // Get the camera'", "CodeBleu_score": 14.866702590930625}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getParent() != nullptr) {\n        current = current->getParent();\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 76.6566733214921}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\n    vector<GridNodePtr> path;\n    path.push_back(current);\n\n    while (current->getParent() != nullptr) {\n        current = current->getParent();\n        path.push_back(current);\n    }\n\n    return path;\n}", "CodeBleu_score": 76.91755233504588}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\n\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\n\twhile (current->getParent() != nullptr) {\n\t\tcurrent = current->getParent();\n\t\tpath.push_back(current);\n\t}\n\n\treturn path;\n}", "CodeBleu_score": 71.22222056290752}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    bool success = true;\n    Vector3d start_pt_adjusted = start_pt;\n    Vector3d end_pt_adjusted = end_pt;\n    if (grid_map_->IsInside(start_pt)) {\n        start_idx = grid_map_->GetIndex(start_pt);\n        if (grid_map_->IsInObstacle(start_idx)) {\n            // If the start point is inside an obstacle, attempt to adjust it\n            success = AdjustPointByIteration(start_pt, start_pt_adjusted, end_pt, end_pt_adjusted);\n            if (success) {\n                start_idx = grid_map_->GetIndex(start_pt_adjusted);\n            }\n        }\n    }\n    else {\n        // If the start point is not inside the grid, attempt to adjust it\n        success = AdjustPointByIteration(start_pt, start_pt_adjusted, end_pt, end_pt_adjusted);\n        if (success) {\n            start_idx = grid_map_->GetIndex(start_pt_adjusted);\n        }\n    }\n    if (grid_map_->IsInside(end_pt)) {\n        end_idx = grid_map_->GetIndex(end_pt);\n        if (grid_map_->IsInObstacle(end_idx)) {\n            // If the end point is inside an obstacle, attempt to adjust it\n            success = AdjustPointByIteration(end_pt, end_pt_adjusted, start_pt, start_pt_adjusted);\n            if (success) {\n                end_idx = grid_map_->GetIndex(end_pt_adjusted);\n            }\n        }\n    }\n    else {\n        // If the end point is not inside the grid, attempt to adjust it\n        success = AdjustPointByIteration(end_pt, end_pt_adjusted, start_pt, start_pt_adjusted);\n        if (success) {\n            end_idx = grid_map_->GetIndex(end_pt_adjusted);\n        }\n", "CodeBleu_score": 38.43319833198719}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert to grid indices.\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Adjust start and end points if they are inside obstacles.\n\tif (IsInObstacle(start_idx)) {\n\t\tif (!AdjustStartPoint(start_idx, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (IsInObstacle(end_idx)) {\n\t\tif (!AdjustEndPoint(start_idx, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 30.282927501090533}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start and end points to indices\n\tbool start_idx_success = ConvertToIndex(start_pt, start_idx);\n\tbool end_idx_success = ConvertToIndex(end_pt, end_idx);\n\tif (!start_idx_success || !end_idx_success) {\n\t\treturn false;\n\t}\n\n\t// Check if start and end points are in obstacles\n\tbool start_in_obstacle = false;\n\tbool end_in_obstacle = false;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (start_idx[i] < 0 || start_idx[i] >= map_size_[i]) {\n\t\t\tstart_in_obstacle = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (end_idx[i] < 0 || end_idx[i] >= map_size_[i]) {\n\t\t\tend_in_obstacle = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start_in_obstacle || end_in_obstacle) {\n\t\t// Adjust start and end points\n\t\tif (start_in_obstacle) {\n\t\t\tVector3i start_idx_adj = start_idx;\n\t\t\tVector3i end_idx_adj = end_idx;\n\t\t\tVector3d start_pt_adj = start_pt;\n\t\t\tVector3d end_pt_adj = end_pt;\n\t\t\tbool start_idx_adj_success = false;\n\t\t\tbool end_idx_adj_success = false;\n\t\t\twhile (!start_idx_adj_success) {\n\t\t\t\tstart_idx_adj_success = ConvertToIndex(start_pt_adj, start_idx_adj);\n\t\t\t\tif (!start_idx_adj_success) {\n\t\t\t\t\t// Move start point away from end point\n\t\t\t\t\tdouble dist_to_end = (start_pt_adj - end_pt_adj).norm", "CodeBleu_score": 32.48541477683816}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    int min_id[3], max_id[3];\n    Eigen::Vector3d min_pos_tmp, max_pos_tmp;\n    min_pos_tmp = min_pos;\n    max_pos_tmp = max_pos;\n    for (int i = 0; i < 3; i++) {\n        min_id[i] = static_cast<int>(std::floor(min_pos_tmp[i] / resolution_));\n        max_id[i] = static_cast<int>(std::ceil(max_pos_tmp[i] / resolution_));\n    }\n    for (int i = min_id[0]; i < max_id[0]; i++) {\n        for (int j = min_id[1]; j < max_id[1]; j++) {\n            for (int k = min_id[2]; k < max_id[2]; k++) {\n                occupancy_buffer_inflate_[i][j][k] = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 35.516162322909246}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    // Check if the region is valid\n    if (min_pos[0] < 0 || min_pos[0] >= occupancy_buffer_.size() || min_pos[1] < 0 || min_pos[1] >= occupancy_buffer_[0].size() || min_pos[2] < 0 || min_pos[2] >= occupancy_buffer_[0][0].size() ||\n        max_pos[0] < 0 || max_pos[0] >= occupancy_buffer_.size() || max_pos[1] < 0 || max_pos[1] >= occupancy_buffer_[0].size() || max_pos[2] < 0 || max_pos[2] >= occupancy_buffer_[0][0].size()) {\n        ROS_WARN(\"Invalid region for resetting buffer\");\n        return;\n    }\n    // Iterate over the region\n    for (int i = min_pos[0]; i < max_pos[0]; i++) {\n        for (int j = min_pos[1]; j < max_pos[1]; j++) {\n            for (int k = min_pos[2]; k < max_pos[2]; k++) {\n                occupancy_buffer_inflate_[i][j][k] = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 39.21799147465448}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\n    // Convert the min_pos and max_pos to grid coordinates\n    Eigen::Vector3d min_id = getGridCoord(min_pos);\n    Eigen::Vector3d max_id = getGridCoord(max_pos);\n\n    // Check if the buffer is within the map limits\n    if (min_id[0] >= 0 && min_id[1] >= 0 && min_id[2] >= 0 &&\n        max_id[0] < occupancy_buffer_.size() && max_id[1] < occupancy_buffer_[0].size() &&\n        max_id[2] < occupancy_buffer_[0][0].size()) {\n        // Iterate over the grid coordinates\n        for (int i = min_id[0]; i <= max_id[0]; i++) {\n            for (int j = min_id[1]; j <= max_id[1]; j++) {\n                for (int k = min_id[2]; k <= max_id[2]; k++) {\n                    occupancy_buffer_inflate_[i][j][k] = 0;\n                    distance_buffer_inflate_[i][j][k] = 0.0;\n                }\n            }\n        }\n    }\n    else {\n        ROS_WARN(\"The buffer is outside the map limits. The buffer is not reset.\");\n    }\n}", "CodeBleu_score": 30.7131186676128}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d closest_pt = pt;\n    double max_trans_x = (double)map_size_x_ / 2 - 0.5;\n    double min_trans_x = -max_trans_x;\n    double max_trans_y = (double)map_size_y_ / 2 - 0.5;\n    double min_trans_y = -max_trans_y;\n    double max_trans_z = (double)map_size_z_ / 2 - 0.5;\n    double min_trans_z = -max_trans_z;\n    if (diff[0] > max_trans_x) {\n        closest_pt[0] = pt[0] - max_trans_x;\n    } else if (diff[0] < min_trans_x) {\n        closest_pt[0] = pt[0] - min_trans_x;\n    }\n    if (diff[1] > max_trans_y) {\n        closest_pt[1] = pt[1] - max_trans_y;\n    } else if (diff[1] < min_trans_y) {\n        closest_pt[1] = pt[1] - min_trans_y;\n    }\n    if (diff[2] > max_trans_z) {\n        closest_pt[2] = pt[2] - max_trans_z;\n    } else if (diff[2] < min_trans_z) {\n        closest_pt[2] = pt[2] - min_trans_z;\n    }\n    return closest_pt;\n}", "CodeBleu_score": 36.29543032098292}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n    Eigen::Vector3d diff_vec = pt - camera_pt;\n    Eigen::Vector3d min_vec;\n    Eigen::Vector3d max_vec;\n\n    if (diff_vec[0] > 0) {\n        min_vec[0] = diff_vec[0];\n        max_vec[0] = diff_vec[0];\n    }\n    else {\n        min_vec[0] = 0;\n        max_vec[0] = 0;\n    }\n\n    if (diff_vec[1] > 0) {\n        min_vec[1] = diff_vec[1];\n        max_vec[1] = diff_vec[1];\n    }\n    else {\n        min_vec[1] = 0;\n        max_vec[1] = 0;\n    }\n\n    if (diff_vec[2] > 0) {\n        min_vec[2] = diff_vec[2];\n        max_vec[2] = diff_vec[2];\n    }\n    else {\n        min_vec[2] = 0;\n        max_vec[2] = 0;\n    }\n\n    double min_scale = 0;\n    double max_scale = 0;\n\n    if (min_vec[0] != 0) {\n        min_scale = (map_x_max_ - pt[0]) / min_vec[0];\n    }\n    if (min_vec[1] != 0) {\n        double temp = (map_y_max_ - pt[1]) / min_vec[1];\n        if (temp < min_scale) {\n            min_scale = temp;\n        }\n    }\n    if (min_vec[2] != 0) {\n        double temp = (map_z_max_ - pt[2]) / min_vec[2];\n        if (temp < min_scale) {\n            min_scale = temp;\n        }\n    }\n\n    if (max_vec[0] != 0) {\n        max_scale = (map_x_max_ - pt[0]) / max_", "CodeBleu_score": 32.744999804233}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  double min_x = diff.x() < 0 ? -1 : 1;\n  double max_x = diff.x() < 0 ? 0 : (map_size_.x() - 1);\n  double min_y = diff.y() < 0 ? -1 : 1;\n  double max_y = diff.y() < 0 ? 0 : (map_size_.y() - 1);\n  double min_z = diff.z() < 0 ? -1 : 1;\n  double max_z = diff.z() < 0 ? 0 : (map_size_.z() - 1);\n\n  double x_scale = (max_x - min_x) / diff.x();\n  double y_scale = (max_y - min_y) / diff.y();\n  double z_scale = (max_z - min_z) / diff.z();\n\n  double min_scale = std::min(std::min(x_scale, y_scale), z_scale);\n  double scale = min_scale < 0 ? 0 : min_scale;\n  return camera_pt + diff * scale;\n}", "CodeBleu_score": 35.009184839435}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\n    // Update last update time\n    lastOccupancyUpdateTime = ros::Time::now();\n\n    // Check if an update is needed\n    if (lastOdometryUpdateTime + updatePeriod > ros::Time::now()) {\n        return;\n    }\n\n    // Check if depth data is available\n    if (depthImage.empty()) {\n        ROS_WARN(\"[GridMap]: No depth image received.\");\n        depthDataTimeout = true;\n        return;\n    }\n\n    // Check if odometry is available\n    if (odometry.header.stamp.isZero()) {\n        ROS_WARN(\"[GridMap]: No odometry received.\");\n        odometryTimeout = true;\n        return;\n    }\n\n    // Clear and inflate local map\n    localMap.clear();\n    localMap.inflate();\n\n    // Project depth image into points\n    std::vector<cv::Point3f> points;\n    cv::projectPoints(cv::Mat(depthImage), cv::Mat(odometry.pose.pose.position), cv::Mat(odometry.pose.pose.orientation), cv::Mat(cameraIntrinsics), cv::Mat(distortionCoefficients), points);\n\n    // Process points with raycasting\n    for (auto point : points) {\n        if (point.z > 0) {\n            processPointWithRaycasting(point);\n        }\n    }\n\n    // Update occupancy grid\n    updateOccupancyGrid();\n\n    // Check if local map has been updated\n    if (localMap.isUpdated()) {\n        // Clear and inflate local map\n        localMap.clear();\n        localMap.inflate();\n\n        // Update occupancy grid\n        updateOccupancyGrid();\n    }\n\n    // Reset flags\n    depthDataTimeout = false;\n    odometryTimeout = false;\n}", "CodeBleu_score": 34.9844314156741}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\n    // Update the last occupancy update time\n    last_occupancy_update_time_ = ros::Time::now();\n\n    // Check if an update is needed\n    if (last_depth_image_time_ + update_period_ < last_occupancy_update_time_) {\n        // If an update is needed, project the depth image into points and process them with raycasting\n        processDepthImage();\n        // If the local map has been updated, clear and inflate the local map\n        if (local_map_updated_) {\n            clearLocalMap();\n            inflateLocalMap();\n        }\n    }\n\n    // If the odometry has been updated, set the odometry flag\n    if (last_odometry_time_ + update_period_ < last_occupancy_update_time_) {\n        odometry_updated_ = true;\n    }\n\n    // If the depth image has been updated, set the depth image flag\n    if (last_depth_image_time_ + update_period_ < last_occupancy_update_time_) {\n        depth_image_updated_ = true;\n    }\n\n    // If the odometry has not been updated, set the odometry timeout flag\n    if (odometry_updated_ == false) {\n        odometry_timeout_ = true;\n    }\n\n    // If the depth image has not been updated, set the depth image timeout flag\n    if (depth_image_updated_ == false) {\n        depth_image_timeout_ = true;\n    }\n}", "CodeBleu_score": 38.291413114934336}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\n    // Get the time of the latest odometry update\n    if (odom_subscriber.getNumPublishers() > 0) {\n        if (odom_subscriber.getNumPublishers() > 0) {\n            if (odom_subscriber.getNumPublishers() > 0) {\n                if (odom_subscriber.getNumPublishers() > 0) {\n                    if (odom_subscriber.getNumPublishers() > 0) {\n                        if (odom_subscriber.getNumPublishers() > 0) {\n                            if (odom_subscriber.getNumPublishers() > 0) {\n                                if (odom_subscriber.getNumPublishers() > 0) {\n                                    if (odom_subscriber.getNumPublishers() > 0) {\n                                        if (odom_subscriber.getNumPublishers() > 0) {\n                                            if (odom_subscriber.getNumPublishers() > 0) {\n                                                if (odom_subscriber.getNumPublishers() > 0) {\n                                                    if (odom_subscriber.getNumPublishers() > 0) {\n                                                        if (odom_subscriber.getNumPublishers() > 0) {\n                                                            if (odom_subscriber.getNumPublishers() > 0) {\n                                                                if (odom_subscriber.getNumPublishers() > 0) {\n                                                                    if (odom_subscriber.getNumPublishers() > 0) {\n                                                                        if (odom_subscriber.getNumPublishers() > 0) {\n                                                                            if (odom_subscriber.getNumPublishers() > 0) {\n                                                                                if (odom_subscriber.getNumPublishers() > 0) {\n                                                                                    if (odom_subscriber.getNumPublish", "CodeBleu_score": 28.02427638741878}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\t// Initialize variables\n\tfloat total_fmeasure = 0;\n\tfloat total_gt_count = 0;\n\tfloat total_dt_count = 0;\n\tfloat total_precision = 0;\n\tfloat total_recall = 0;\n\tfloat total_gt_area = 0;\n\tfloat total_dt_area = 0;\n\tfloat total_intersection_area = 0;\n\tfloat total_union_area = 0;\n\tfloat total_iou = 0;\n\tfloat total_dice = 0;\n\tfloat total_hausdorff = 0;\n\tfloat total_hausdorff_distance = 0;\n\tfloat total_hausdorff_percentage = 0;\n\n\t// Iterate through images\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\t// Load image\n\t\tMat image = imread(image_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n\t\tif (image.empty()) {\n\t\t\tcout << \"Could not read image: \" << image_fns[i] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Load ground truth\n\t\tvector<Ellipse> gt_ellipses;\n\t\tif (!_ellipse_load_gt(gt_fns[i], gt_ellipses, gt_angle_radians)) {\n\t\t\tcout << \"Could not read ground truth: \" << gt_fns[i] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Load detected ellipses\n\t\tvector<Ellipse> dt_ellipses;\n\t\tif (!_ellipse_load_dt(dt_fns[i], dt_ellipses)) {\n\t\t\tcout << \"Could not read detected ellipses: \" << dt_fns[i] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Calculate average F-measure\n\t\tfloat fmeasure = _ellipse_evaluate_single(image, gt_ellipses, dt_ellipses);\n\t\ttotal_f", "CodeBleu_score": 51.91300589657247}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float total_f_measure = 0.0f;\n    int total_images = 0;\n    for (int i = 0; i < image_fns.size(); i++) {\n        // Load image\n        Mat image = imread(image_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n        // Load ground truth\n        vector<Ellipse> gt_ellipse;\n        if (gt_fns[i] != \"\") {\n            gt_ellipse = _read_ellipse_file(gt_fns[i], gt_angle_radians);\n        }\n        // Load detected ellipses\n        vector<Ellipse> dt_ellipse;\n        if (dt_fns[i] != \"\") {\n            dt_ellipse = _read_ellipse_file(dt_fns[i], gt_angle_radians);\n        }\n        // Evaluate\n        float f_measure = _ellipse_evaluate_single(image, gt_ellipse, dt_ellipse);\n        // Accumulate\n        total_f_measure += f_measure;\n        total_images++;\n    }\n    return total_f_measure / total_images;\n}", "CodeBleu_score": 55.31028193427021}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n\t// Number of images\n\tint n_images = image_fns.size();\n\n\t// Accumulated F-measure\n\tfloat f_measure = 0;\n\n\t// Iterate through the images\n\tfor (int i = 0; i < n_images; i++) {\n\n\t\t// Load the image\n\t\tMat img = imread(image_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n\n\t\t// Load the ground truth\n\t\tvector<Ellipse> gt;\n\t\tload_ellipse_file(gt_fns[i], gt, gt_angle_radians);\n\n\t\t// Load the detected ellipses\n\t\tvector<Ellipse> dt;\n\t\tload_ellipse_file(dt_fns[i], dt, gt_angle_radians);\n\n\t\t// Calculate the F-measure\n\t\tfloat f = ellipse_f_measure(img, gt, dt);\n\n\t\t// Accumulate the F-measure\n\t\tf_measure += f;\n\n\t}\n\n\t// Return the average F-measure\n\treturn f_measure / n_images;\n\n}", "CodeBleu_score": 55.47723091701994}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle_1 = atan2(y - foci[1], x - foci[0]);\n    float angle_2 = atan2(y - foci[3], x - foci[2]);\n    float angle_diff = angle_2 - angle_1;\n    if (angle_diff < -M_PI) {\n        angle_diff += 2 * M_PI;\n    } else if (angle_diff > M_PI) {\n        angle_diff -= 2 * M_PI;\n    }\n    return angle_diff;\n}", "CodeBleu_score": 46.987602676588565}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    if (foci == nullptr) {\n        return 0.0f;\n    }\n    float a = foci[0];\n    float b = foci[1];\n    float d = sqrt(x * x + y * y);\n    float t = atan2(y, x);\n    float angle_1 = atan2(a * sin(t), b * cos(t));\n    float angle_2 = atan2(b * sin(t), a * cos(t));\n    float angle = angle_2 - angle_1;\n    if (angle > M_PI) {\n        angle -= 2 * M_PI;\n    }\n    return angle;\n}", "CodeBleu_score": 40.62502571863929}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle1, angle2;\n\n    if (foci != NULL) {\n        angle1 = atan2(y - foci[1], x - foci[0]);\n        angle2 = atan2(y - foci[3], x - foci[2]);\n    }\n    else {\n        angle1 = 0.0;\n        angle2 = 0.0;\n    }\n\n    float angle = angle1 - angle2;\n    if (angle > M_PI) {\n        angle -= 2.0 * M_PI;\n    }\n    else if (angle < -M_PI) {\n        angle += 2.0 * M_PI;\n    }\n\n    return angle;\n}", "CodeBleu_score": 54.538290480730936}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n    double sum_above = 0.0;\n    double sum_below = 0.0;\n    for (int i = start; i <= end; i++) {\n        if (vp1[i].x < min_x) {\n            min_x = vp1[i].x;\n        }\n        if (vp1[i].x > max_x) {\n            max_x = vp1[i].x;\n        }\n        if (vp1[i].y < min_y) {\n            min_y = vp1[i].y;\n        }\n        if (vp1[i].y > max_y) {\n            max_y = vp1[i].y;\n        }\n        sum_above += (max_x - vp1[i].x) * (vp1[i].y - min_y);\n        sum_below += (vp1[i].x - min_x) * (max_y - vp1[i].y);\n    }\n    return (sum_above < sum_below);\n}", "CodeBleu_score": 38.99848637472275}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint xmin, xmax, ymin, ymax;\n\tdouble area_above = 0, area_below = 0;\n\n\txmin = xmax = vp1[start].x;\n\tymin = ymax = vp1[start].y;\n\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < xmin)\n\t\t\txmin = vp1[i].x;\n\t\tif (vp1[i].x > xmax)\n\t\t\txmax = vp1[i].x;\n\t\tif (vp1[i].y < ymin)\n\t\t\tymin = vp1[i].y;\n\t\tif (vp1[i].y > ymax)\n\t\t\tymax = vp1[i].y;\n\t}\n\n\tfor (int i = start + 1; i < end; i++) {\n\t\tarea_above += (vp1[i].x - vp1[start].x) * (vp1[i].y + vp1[start].y);\n\t\tarea_below += (vp1[i].x - vp1[start].x) * (vp1[i].y - vp1[start].y);\n\t}\n\n\tarea_above *= 0.5;\n\tarea_below *= 0.5;\n\n\tif (area_above < area_below)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "CodeBleu_score": 37.02811539957367}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint i;\n\tdouble min_x, max_x, min_y, max_y, integral_above, integral_below;\n\tmin_x = vp1[end].x;\n\tmax_x = vp1[start].x;\n\tmin_y = vp1[end].y;\n\tmax_y = vp1[start].y;\n\tfor (i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\tintegral_above = (max_x - min_x) * (max_y + min_y) / 2;\n\tintegral_below = (max_x - min_x) * (min_y + max_y) / 2;\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 30.645491146040698}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    // \u68c0\u6d4b\u5230T\n    if (msg->detected_objects.size() != 0) {\n        for (int i = 0; i < msg->detected_objects.size(); i++) {\n            if (msg->detected_objects[i].id == \"T\") {\n                num_regain++;\n                num_lost = 0;\n                break;\n            }\n        }\n    } else {\n        num_regain = 0;\n        num_lost++;\n    }\n\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n\n    for (int i = 0; i < msg->detected_objects.size(); i++) {\n        if (msg->detected_objects[i].id == \"T\") {\n            ellipse_det.sight_angle = msg->detected_objects[i].sight_angle;\n            ellipse_det.sight_distance = msg->detected_objects[i].sight_distance;\n            ellipse_det.center_x = msg->detected_objects[i].center_x;\n            ellipse_det.center_y = msg->detected_objects[i].center_y;\n            ellipse_det.major_axis_angle = msg->detected_objects[i].major_axis_angle;\n            ellipse_det.major_axis_length = msg->detected_objects[i].major_axis_length;\n            ellipse_det.minor_axis_angle = msg->detected_objects[i].minor_axis_angle;\n            ellipse_det.minor_axis_length = msg->detected_objects[i].minor_axis_length;\n            ellipse_det.orientation = msg->detected_objects[i].orientation;\n            ellipse_det.position_x = msg->detected_objects[i].position_x;\n            ellipse_det.position_y = msg->detected_objects[i].position_y;\n            ellipse_", "CodeBleu_score": 54.86379441146853}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\n    int i;\n\n    for (i = 0; i < msg->detections.size(); i++) {\n\n        if (msg->detections[i].label == \"T\") {\n\n            ellipse_det.num_regain++;\n\n            ellipse_det.num_lost = 0;\n\n            if (ellipse_det.num_regain > VISION_THRES) {\n\n                ellipse_det.is_detected = true;\n\n                ellipse_det.num_regain = 0;\n\n            }\n\n        } else {\n\n            ellipse_det.num_lost++;\n\n            ellipse_det.num_regain = 0;\n\n            if (ellipse_det.num_lost > VISION_THRES) {\n\n                ellipse_det.is_detected = false;\n\n                ellipse_det.num_lost = 0;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < msg->detections.size(); i++) {\n\n        if (msg->detections[i].label == \"T\") {\n\n            ellipse_det.sight_angle[0] = msg->detections[i].sight_angle[0];\n\n            ellipse_det.sight_angle[1] = msg->detections[i].sight_angle[1];\n\n        }\n\n    }\n\n}", "CodeBleu_score": 43.45209441019405}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\n    // \u68c0\u6d4b\u5230\u76ee\u6807\n    if (msg->detections.size() > 0) {\n\n        // \u68c0\u6d4b\u5230\u76ee\u6807\n        for (int i = 0; i < msg->detections.size(); i++) {\n\n            if (msg->detections[i].id == \"T\") {\n\n                ellipse_det.is_detected = true;\n\n                ellipse_det.num_regain++;\n\n                ellipse_det.num_lost = 0;\n\n                // \u66f4\u65b0\u76ee\u6807\u4f4d\u7f6e\n                ellipse_det.x = msg->detections[i].position.x;\n\n                ellipse_det.y = msg->detections[i].position.y;\n\n                ellipse_det.z = msg->detections[i].position.z;\n\n                // \u66f4\u65b0\u76ee\u6807\u671d\u5411\n                ellipse_det.sight_angle.x = msg->detections[i].sight_angle.x;\n\n                ellipse_det.sight_angle.y = msg->detections[i].sight_angle.y;\n\n                ellipse_det.sight_angle.z = msg->detections[i].sight_angle.z;\n\n                // \u66f4\u65b0\u76ee\u6807\u534a\u957f\u8f74\n                ellipse_det.a = msg->detections[i].a;\n\n                ellipse_det.b = msg->detections[i].b;\n\n                ellipse_det.c = msg->detections[i].c;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n    else {\n\n        ellipse_det.is_detected = false;\n\n        ellipse_det.num_regain = 0;\n\n        ellipse_det.num_lost++;\n\n    }\n\n    // \u66f4\u65b0\u76ee\u6807\u662f\u5426\u53ef\u89c1\n    if (ellipse_det.num_lost > VISION_THRES) {\n\n        ellipse_det.is_detected = false;\n\n    }", "CodeBleu_score": 31.010158403916044}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    if(occupy_map_ptr_->getOccupancy(cur_pos) < safe_distance) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "CodeBleu_score": 33.67475372937774}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tif (Occupy_map_ptr_->getOccupancy(cur_pos[0], cur_pos[1], cur_pos[2])) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 25.25727585514269}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    bool safe = true;\n    Eigen::Vector3d cur_pos_f;\n    cur_pos_f << cur_pos.x(), cur_pos.y(), cur_pos.z();\n    for (int i = 0; i < occupy_map_ptr_->getNumObstacle(); i++) {\n        Eigen::Vector3d obs_pos;\n        obs_pos << occupy_map_ptr_->getObstaclePosX(i), occupy_map_ptr_->getObstaclePosY(i), occupy_map_ptr_->getObstaclePosZ(i);\n        double dist = (obs_pos - cur_pos_f).norm();\n        if (dist < safe_distance) {\n            safe = false;\n            break;\n        }\n    }\n    return safe;\n}", "CodeBleu_score": 43.160514541895495}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\n\tpath_nodes_.push_back(end_node);\n\n\twhile (end_node != start_node_) {\n\t\tend_node = end_node->parent;\n\t\tpath_nodes_.push_back(end_node);\n\t}\n\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n\n}", "CodeBleu_score": 42.190480192382665}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\tpath_nodes_.push_back(current_node);\n\twhile (current_node->parent != nullptr) {\n\t\tcurrent_node = current_node->parent;\n\t\tpath_nodes_.push_back(current_node);\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 63.42900239304959}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\n\t// The path is empty until the end node is reached.\n\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\n\t// Follow the parent pointers to the start node.\n\twhile (current_node != nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->getParent();\n\t}\n\n\t// Reverse the order of path_nodes_ to present the path from start to end.\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 52.34231030093562}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n    // If the UGV is not in the map, return\n    if(!in_map[id])\n        return;\n\n    // Get the odometry data\n    geometry_msgs::PoseStamped pose_nei = odom->pose;\n\n    // Get the UGV's position\n    double x_nei = pose_nei.pose.position.x;\n    double y_nei = pose_nei.pose.position.y;\n    double z_nei = pose_nei.pose.position.z;\n\n    // Get the UGV's yaw\n    double yaw_nei = tf::getYaw(pose_nei.pose.orientation);\n\n    // Get the UGV's linear velocity\n    double vx_nei = odom->twist.twist.linear.x;\n    double vy_nei = odom->twist.twist.linear.y;\n    double vz_nei = odom->twist.twist.linear.z;\n\n    // Get the UGV's angular velocity\n    double w_nei = odom->twist.twist.angular.z;\n\n    // Get the UGV's ID\n    int id_nei = id;\n\n    // Get the UGV's distance from the start position\n    double dist_nei = sqrt(pow(x_nei - start_x, 2) + pow(y_nei - start_y, 2));\n\n    // Update the state of the UGV\n    state_nei[id_nei] = {x_nei, y_nei, z_nei, yaw_nei, vx_nei, vy_nei, vz_nei, w_nei, dist_nei};\n\n    // Check if the UGV is in the start position\n    if(dist_nei < 5.0)\n        get_nei_state[id_nei] = true;\n    else\n        get_nei_state[id_nei] = false;\n}", "CodeBleu_score": 37.26318111645912}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n    // In simulation mode, check the distance from the start position\n    if(simulation_mode_) {\n        geometry_msgs::Pose start_pose;\n        start_pose.position.x = start_x_;\n        start_pose.position.y = start_y_;\n        start_pose.position.z = start_z_;\n        start_pose.orientation.w = 1.0;\n\n        // Calculate the distance from the start position\n        double dist = sqrt(pow(start_pose.position.x - odom->pose.pose.position.x, 2) + pow(start_pose.position.y - odom->pose.pose.position.y, 2) + pow(start_pose.position.z - odom->pose.pose.position.z, 2));\n\n        // If the distance exceeds 5 meters, set the get_nei_state flag to false\n        if(dist > 5.0) {\n            get_nei_state_[id] = false;\n        }\n        else {\n            get_nei_state_[id] = true;\n        }\n    }\n\n    // Update the state of the neighboring UGV\n    state_nei_[id][0] = odom->pose.pose.position.x;\n    state_nei_[id][1] = odom->pose.pose.position.y;\n    state_nei_[id][2] = odom->pose.pose.position.z;\n}", "CodeBleu_score": 48.97777191047703}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n  state_nei[id][0] = odom->pose.pose.position.x;\n  state_nei[id][1] = odom->pose.pose.position.y;\n  state_nei[id][2] = odom->pose.pose.position.z;\n\n  if(sim_mode) {\n    if(sqrt(pow(state_nei[id][0] - start_x, 2) + pow(state_nei[id][1] - start_y, 2)) > 5) {\n      get_nei_state[id] = false;\n    } else {\n      get_nei_state[id] = true;\n    }\n  } else {\n    get_nei_state[id] = true;\n  }\n\n}", "CodeBleu_score": 56.08324537879681}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    // If odometry is not ready, return immediately\n    if (!odom_ready) {\n        return;\n    }\n\n    // Increment the update counter\n    update_counter++;\n\n    // If the update counter is not a multiple of five, return immediately\n    if (update_counter % 5 != 0) {\n        return;\n    }\n\n    // Set the sensor_ready flag to true\n    sensor_ready = true;\n\n    // Convert the point cloud data to a PCL point cloud\n    pcl::fromROSMsg(*msg, *cloud);\n\n    // Update the Astar map\n    astar_map.update(cloud);\n\n    // Reset the update counter\n    update_counter = 0;\n\n    // Publish the Astar map\n    astar_map.publish_map();\n\n    // Publish the point cloud\n    pub_pointcloud.publish(msg);\n\n    // Publish the global plan\n    publish_global_plan();\n\n    // Publish the local plan\n    publish_local_plan();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_path();\n\n    // Publish the local path\n    publish_local_", "CodeBleu_score": 53.013184523753324}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    // If odometry is not ready, return immediately.\n    if (!odom_ready)\n        return;\n\n    // If sensor_ready is true, increment the update counter.\n    if (sensor_ready)\n        update_counter++;\n\n    // If the update counter is divisible by five, update the Astar map and reset the update counter.\n    if (update_counter % 5 == 0) {\n        update_map(msg);\n        update_counter = 0;\n    }\n\n    // Set the sensor_ready flag to true.\n    sensor_ready = true;\n}", "CodeBleu_score": 45.20208069212549}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odometry_ready) return;\n    sensor_ready = true;\n    if (++update_count >= 5) {\n        update_count = 0;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*msg, *cloud_ptr);\n        astar.update_map(cloud_ptr);\n    }\n}", "CodeBleu_score": 42.2397569583053}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n    // Check if the global map has been updated yet\n    if (!get_gpcl) {\n\n        // Set the global map update flag\n        get_gpcl = true;\n\n        // Convert the sensor message to a point cloud\n        pcl::fromROSMsg(*global_point, *global_point_cloud);\n\n        // Store the point cloud\n        global_point_cloud_ptr = global_point_cloud;\n\n        // Inflate the point cloud\n        inflate_cloud();\n\n        // Publish the global map\n        publish_global_map();\n    }\n}", "CodeBleu_score": 63.07337109381231}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, *global_pcl);\n\t\tglobal_pcl->header = global_point->header;\n\t\tglobal_pcl->sensor_origin_ = global_point->sensor_origin_;\n\t\tglobal_pcl->sensor_orientation_ = global_point->sensor_orientation_;\n\t\tglobal_pcl->width = global_point->width;\n\t\tglobal_pcl->height = global_point->height;\n\t\tglobal_pcl->is_dense = global_point->is_dense;\n\t\tglobal_pcl->is_bigendian = global_point->is_bigendian;\n\t\tglobal_pcl->point_step = global_point->point_step;\n\t\tglobal_pcl->row_step = global_point->row_step;\n\t\tglobal_pcl->is_dense = global_point->is_dense;\n\t\tglobal_pcl->data = global_point->data;\n\t\tglobal_pcl->fields = global_point->fields;\n\t\tglobal_pcl->is_bigendian = global_point->is_bigendian;\n\t\tglobal_pcl->is_dense = global_point->is_dense;\n\t\tglobal_pcl->is_bigendian = global_point->is_bigendian;\n\t\tglobal_pcl->is_dense = global_point->is_dense;\n\t\tglobal_pcl->is_bigendian = global_point->is_bigendian;\n\t\tglobal_pcl->is_dense = global_point->is_dense;\n\t\tglobal_pcl->is_bigendian = global_point->is_bigendian;\n\t\tglobal_pcl->is_dense = global_point->is_dense;\n\t\tglobal_pcl->is_bigendian = global_point->is_bigendian;\n\t\tglobal_pcl->is_dense = global_point->is_dense;\n\t\tglobal_", "CodeBleu_score": 43.83173905982328}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  // check if the global map has been updated yet\n  if (!get_gpcl) {\n    // set the flag\n    get_gpcl = true;\n    // convert the sensor message to a point cloud\n    pcl::fromROSMsg(*global_point, global_point_cloud);\n    // store the point cloud\n    global_point_cloud_ptr = boost::make_shared<pcl::PointCloud<pcl::PointXYZI> >(global_point_cloud);\n    // inflate the point cloud\n    inflate_point_cloud(global_point_cloud_ptr);\n    // publish the inflated point cloud\n    publish_inflated_point_cloud(global_point_cloud_ptr, inflated_point_cloud_pub);\n  }\n}", "CodeBleu_score": 51.552770897130664}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // Creating a PointCloud2 message to store the laser scan data\n    sensor_msgs::PointCloud2 local_point_cloud;\n\n    // Projecting the laser scan data into a PointCloud2 message\n    sensor_msgs::LaserScan local_laser_scan = *local_point;\n    pcl::PointCloud<pcl::PointXYZ> local_laser_scan_pcl;\n    pcl::fromROSMsg(local_laser_scan, local_laser_scan_pcl);\n\n    // Creating a PointCloud2 message to store the odometry data\n    nav_msgs::Odometry odom_msg;\n\n    // Converting the odometry data into a PointCloud2 message\n    odom_msg = odom;\n    pcl::PointCloud<pcl::PointXYZ> odom_pcl;\n    pcl::fromROSMsg(odom_msg, odom_pcl);\n\n    // Creating a PointCloud2 message to store the merged data\n    sensor_msgs::PointCloud2 merged_point_cloud;\n\n    // Merging the laser scan and odometry data into a PointCloud2 message\n    pcl::PointCloud<pcl::PointXYZ> merged_point_cloud_pcl;\n    pcl::PointCloud<pcl::PointXYZ> merged_point_cloud_pcl_filtered;\n\n    // Creating a PointCloud2 message to store the filtered data\n    sensor_msgs::PointCloud2 filtered_point_cloud;\n\n    // Creating a PointCloud2 message to store the filtered data\n    sensor_msgs::PointCloud2 filtered_point_cloud_filtered;\n\n    // Creating a PointCloud2 message to store the map\n    sensor_msgs::PointCloud2 map_point_cloud;\n\n    // Creating a PointCloud2 message to store the map\n    sensor_msgs::PointCloud2 map_point_cloud_filtered;\n\n    // Creating a PointCloud2 message to store the map\n    sensor_msgs::PointCloud2 map_point_cloud_filtered_filtered;\n\n    // Creating a PointCloud2 message to store the map\n    sensor_msgs::PointCloud", "CodeBleu_score": 40.75874884868648}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // Convert the laser scan data to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*local_point, cloud);\n\n    // Create a point cloud for the map\n    pcl::PointCloud<pcl::PointXYZ> map;\n\n    // If in simulation mode, merge the local map with the odometry data\n    if (simulation_mode) {\n        pcl::transformPointCloud(local_map, map, odom.pose.pose);\n    }\n\n    // If not in simulation mode, merge the local map with the odometry data\n    else {\n        pcl::transformPointCloud(local_map, map, local_map_odom.pose.pose);\n    }\n\n    // Create a point cloud for the laser scan data\n    pcl::PointCloud<pcl::PointXYZ> laser;\n\n    // Convert the laser scan data to a pcl::PointCloud\n    pcl::fromROSMsg(*local_point, laser);\n\n    // Create a point cloud for the merged laser scan and local map\n    pcl::PointCloud<pcl::PointXYZ> merged;\n\n    // Merge the laser scan and local map\n    pcl::concatenatePointCloud(laser, map, merged);\n\n    // Create a point cloud for the projected laser scan\n    pcl::PointCloud<pcl::PointXYZ> projected;\n\n    // Project the laser scan into a PointCloud2 format\n    pcl::ProjectInliers<pcl::PointXYZ> proj;\n    proj.setInputCloud(merged.makeShared());\n    proj.setModelType(pcl::SACMODEL_PLANE);\n    proj.setInputTarget(map.makeShared());\n    proj.setAngleThreshold(0.0174532925);\n    proj.setDistanceThreshold(0.05);\n    proj.filter(projected);\n\n    // Create a point cloud for the filtered projected laser scan\n    pcl::PointCloud<pcl::PointXYZ> filtered;", "CodeBleu_score": 45.12235273230986}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // Project the laser scan into a PointCloud2 format\n    sensor_msgs::PointCloud2 laser_scan_point_cloud;\n    pcl::PointCloud<pcl::PointXYZ> laser_scan_point_cloud_pcl;\n\n    // Convert the laser scan into a PointCloud2 format\n    laser_scan_to_point_cloud(local_point, laser_scan_point_cloud);\n\n    // Convert the laser scan into a pcl::PointCloud\n    pcl::fromROSMsg(laser_scan_point_cloud, laser_scan_point_cloud_pcl);\n\n    // If in simulation mode, merge the local map with the provided odometry data\n    if (simulation_mode) {\n        // Merge the local map with the provided odometry data\n        merge_local_map_odometry(laser_scan_point_cloud_pcl, odom);\n    }\n\n    // Otherwise, update the occupancy map using the laser scan\n    else {\n        // Update the occupancy map using the laser scan\n        update_occupancy_map(laser_scan_point_cloud_pcl);\n    }\n}", "CodeBleu_score": 49.39114022469187}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Convert the global point cloud map to a ROS message.\n    pcl::PointCloud<pcl::PointXYZI> global_pcl;\n    pcl::fromROSMsg(global_pcl_map, global_pcl);\n    // Convert the inflated point cloud map to a ROS message.\n    pcl::PointCloud<pcl::PointXYZI> inflated_pcl;\n    pcl::fromROSMsg(inflate_pcl_map, inflated_pcl);\n    // Convert the global point cloud map to a ROS message.\n    pcl::PointCloud<pcl::PointXYZI> global_pcl_map_filtered;\n    pcl::fromROSMsg(global_pcl_map_filtered_pub, global_pcl_map_filtered);\n    // Convert the inflated point cloud map to a ROS message.\n    pcl::PointCloud<pcl::PointXYZI> inflated_pcl_map_filtered;\n    pcl::fromROSMsg(inflate_pcl_map_filtered_pub, inflated_pcl_map_filtered);\n\n    // Publish the global point cloud map.\n    global_pcl_pub.publish(global_pcl);\n    // Publish the inflated point cloud map.\n    inflate_pcl_pub.publish(inflated_pcl);\n    // Publish the global point cloud map filtered.\n    global_pcl_map_filtered_pub.publish(global_pcl_map_filtered);\n    // Publish the inflated point cloud map filtered.\n    inflate_pcl_map_filtered_pub.publish(inflated_pcl_map_filtered);\n}", "CodeBleu_score": 41.53449160068985}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Convert the global point cloud map to a ROS message\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(global_pcl_map, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_msg.header.stamp = ros::Time::now();\n    // Publish the global point cloud map\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // Convert the inflated point cloud map to a ROS message\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(inflate_pcl_map, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_msg.header.stamp = ros::Time::now();\n    // Publish the inflated point cloud map\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 55.35865104400166}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // ROS_INFO(\"Publishing point clouds\");\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::PointCloud<pcl::PointXYZ> inflated_cloud;\n    pcl::PointCloud<pcl::PointXYZ> inflated_cloud_filtered;\n    pcl::PointCloud<pcl::PointXYZ> inflated_cloud_filtered_final;\n    pcl::PointCloud<pcl::PointXYZ> inflated_cloud_filtered_final_voxel;\n\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered;\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered_final;\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered_final_voxel;\n\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered_final_voxel_filtered;\n\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered_final_voxel_filtered_final;\n\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered_final_voxel_filtered_final_filtered;\n\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered_final_voxel_filtered_final_filtered_final;\n\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered_final_voxel_filtered_final_filtered_final_filtered;\n\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered_final_voxel_filtered_final_filtered_final_filtered_final_filtered;\n\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered_final_voxel_filtered_final_filtered_final_filtered_final_filtered_final_filtered;\n\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered_final_voxel_filtered_final_filtered_final_filtered_final_filtered_final_", "CodeBleu_score": 9.906942631313855}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n  if(odom_ready)\n    sensor_ready = true;\n\n  if(sensor_ready) {\n    if(map_update_flag) {\n      map_update_flag = false;\n      map_update(msg);\n    }\n  }\n}", "CodeBleu_score": 48.377139899691834}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    // Check if odometry is ready\n    if (odom_ready == true) {\n        sensor_ready = true;\n    }\n\n    // Update map\n    if (sensor_ready == true) {\n        // Convert the sensor_msgs::PointCloud2 message to a pcl::PointCloud<pcl::PointXYZ>\n        pcl::fromROSMsg(*msg, *cloud);\n\n        // Update the A* algorithm's map\n        if (map_ready == true) {\n            // Update the map\n            map.updateMap(*cloud, odom.pose.pose.position);\n\n            // Update the map with the new point cloud data\n            map.updateMapWithPointCloud(*cloud, odom.pose.pose.position);\n\n            // Update the map with the new point cloud data\n            map.updateMapWithPointCloud(*cloud, odom.pose.pose.position);\n        }\n    }\n}", "CodeBleu_score": 49.300611219864585}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    if (odom_ready) {\n        sensor_ready = true;\n        update_map();\n    }\n\n}", "CodeBleu_score": 18.6722067708685}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n  // Get the current time\n  ros::Time t = ros::Time::now();\n\n  // Get the current state of the robot\n  quadruped_base_state_ = quadruped_base_state_subscriber_.getMsg();\n\n  // Get the current state of the feet\n  quadruped_feet_state_ = quadruped_feet_state_subscriber_.getMsg();\n\n  // Get the current state of the joints\n  quadruped_joint_state_ = quadruped_joint_state_subscriber_.getMsg();\n\n  // Get the current state of the body\n  quadruped_body_state_ = quadruped_body_state_subscriber_.getMsg();\n\n  // Get the current state of the IMU\n  quadruped_imu_state_ = quadruped_imu_state_subscriber_.getMsg();\n\n  // Get the current state of the battery\n  quadruped_battery_state_ = quadruped_battery_state_subscriber_.getMsg();\n\n  // Get the current state of the battery\n  quadruped_battery_state_ = quadruped_battery_state_subscriber_.getMsg();\n\n  // Get the current state of the battery\n  quadruped_battery_state_ = quadruped_battery_state_subscriber_.getMsg();\n\n  // Get the current state of the battery\n  quadruped_battery_state_ = quadruped_battery_state_subscriber_.getMsg();\n\n  // Get the current state of the battery\n  quadruped_battery_state_ = quadruped_battery_state_subscriber_.getMsg();\n\n  // Get the current state of the battery\n  quadruped_battery_state_ = quadruped_battery_state_subscriber_.getMsg();\n\n  // Get the current state of the battery\n  quadruped_battery_state_ = quadruped_battery_state_subscriber_.getMsg();\n\n  // Get the current state of the battery\n  quad", "CodeBleu_score": 31.65861847303163}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Get current time\n  ros::Time current_time = ros::Time::now();\n\n  // Get the current robot state\n  quadruped_common::RobotState current_state;\n  current_state.header.stamp = current_time;\n  current_state.header.frame_id = \"quadruped\";\n  quadruped_common::getRobotState(current_state);\n\n  // Get the current robot state\n  quadruped_common::RobotState previous_state;\n  previous_state.header.stamp = current_time - ros::Duration(1.0 / CONTROL_LOOP_RATE);\n  previous_state.header.frame_id = \"quadruped\";\n  quadruped_common::getRobotState(previous_state);\n\n  // Get the current robot state\n  quadruped_common::RobotState previous_previous_state;\n  previous_previous_state.header.stamp = current_time - ros::Duration(2.0 / CONTROL_LOOP_RATE);\n  previous_previous_state.header.frame_id = \"quadruped\";\n  quadruped_common::getRobotState(previous_previous_state);\n\n  // Get the current robot state\n  quadruped_common::RobotState previous_previous_previous_state;\n  previous_previous_previous_state.header.stamp = current_time - ros::Duration(3.0 / CONTROL_LOOP_RATE);\n  previous_previous_previous_state.header.frame_id = \"quadruped\";\n  quadruped_common::getRobotState(previous_previous_previous_state);\n\n  // Get the current robot state\n  quadruped_common::RobotState previous_previous_previous_previous_state;\n  previous_previous_previous_previous_state.header.stamp = current_time - ros::Duration(4.0 / CONTROL_LOOP_RATE);\n  previous_previous_previous_previous_state.header.frame_id = \"quadruped\";\n  quadruped_common::getRobotState(previous_previous_previous_previous_state);\n\n ", "CodeBleu_score": 37.72433047202582}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n    // Get the current time\n    ros::Time current_time = ros::Time::now();\n\n    // Check if we have received a new body pose\n    if (current_time - last_body_pose_time_ > body_pose_timeout_) {\n        ROS_WARN_STREAM(\"Body pose timeout. Using last pose.\");\n        body_pose_ = last_body_pose_;\n    }\n\n    // Check if we have received a new body twist\n    if (current_time - last_body_twist_time_ > body_twist_timeout_) {\n        ROS_WARN_STREAM(\"Body twist timeout. Using last twist.\");\n        body_twist_ = last_body_twist_;\n    }\n\n    // Check if we have received a new body wrench\n    if (current_time - last_body_wrench_time_ > body_wrench_timeout_) {\n        ROS_WARN_STREAM(\"Body wrench timeout. Using last wrench.\");\n        body_wrench_ = last_body_wrench_;\n    }\n\n    // Check if we have received a new body acceleration\n    if (current_time - last_body_acceleration_time_ > body_acceleration_timeout_) {\n        ROS_WARN_STREAM(\"Body acceleration timeout. Using last acceleration.\");\n        body_acceleration_ = last_body_acceleration_;\n    }\n\n    // Check if we have received a new body torque\n    if (current_time - last_body_torque_time_ > body_torque_timeout_) {\n        ROS_WARN_STREAM(\"Body torque timeout. Using last torque.\");\n        body_torque_ = last_body_torque_;\n    }\n\n    // Check if we have received a new body joint positions\n    if (current_time - last_body_joint_positions_time_ > body_joint_positions_timeout_) {\n        ROS_WARN_STREAM(\"Body joint positions timeout. Using last joint positions.\");\n        body_joint_positions_ = last_body_joint_positions_;\n    }\n\n    //", "CodeBleu_score": 31.33588895351931}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\n    // Create a ContactsStamped message\n    quadruped_msgs::ContactsStamped contacts_msg;\n\n    // Populate the message with the current gait phase of each leg\n    contacts_msg.contacts.resize(4);\n    contacts_msg.contacts[0].phase = current_gait_phase_;\n    contacts_msg.contacts[1].phase = current_gait_phase_;\n    contacts_msg.contacts[2].phase = current_gait_phase_;\n    contacts_msg.contacts[3].phase = current_gait_phase_;\n\n    // Publish the message\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.header.frame_id = \"world\";\n    foot_contacts_publisher_.publish(contacts_msg);\n\n}", "CodeBleu_score": 51.25226028355524}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\n    if (foot_contacts_publishing_enabled_) {\n        if (!use_sim_time_) {\n            ROS_WARN_THROTTLE(1, \"Foot contacts are being published, but use_sim_time is false. This is not recommended.\");\n        }\n        if (publish_contacts_as_array_) {\n            std::vector<bool> foot_contacts_array;\n            foot_contacts_array.push_back(foot_contacts[0]);\n            foot_contacts_array.push_back(foot_contacts[1]);\n            foot_contacts_array.push_back(foot_contacts[2]);\n            foot_contacts_array.push_back(foot_contacts[3]);\n            contacts_array_msg_.data = foot_contacts_array;\n            contacts_array_publisher_.publish(contacts_array_msg_);\n        } else {\n            contacts_msg_.contacts.clear();\n            contacts_msg_.contacts.resize(4);\n            contacts_msg_.contacts[0].contact_body_name = \"front_left_foot\";\n            contacts_msg_.contacts[1].contact_body_name = \"front_right_foot\";\n            contacts_msg_.contacts[2].contact_body_name = \"rear_left_foot\";\n            contacts_msg_.contacts[3].contact_body_name = \"rear_right_foot\";\n            contacts_msg_.contacts[0].contact_point.x = 0.0;\n            contacts_msg_.contacts[0].contact_point.y = 0.0;\n            contacts_msg_.contacts[0].contact_point.z = 0.0;\n            contacts_msg_.contacts[1].contact_point.x = 0.0;\n            contacts_msg_.contacts[1].contact_point.y = 0.0;\n            contacts_msg_.contacts[1].contact_point.z = 0.0;\n            contacts_msg_.contacts[2].contact_point.x = 0.0;\n            contacts_msg_.contacts[2].contact_point.y = 0.0", "CodeBleu_score": 41.000012240389886}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\n    if (foot_contacts_publisher_ == nullptr) {\n        return;\n    }\n\n    if (robot_is_in_gazebo_) {\n        return;\n    }\n\n    ContactsStamped contacts_stamped;\n    contacts_stamped.header.stamp = ros::Time::now();\n    contacts_stamped.header.frame_id = \"base_link\";\n\n    for (int leg_index = 0; leg_index < 4; leg_index++) {\n        contacts_stamped.contacts.push_back(Contact());\n        contacts_stamped.contacts.back().contact_state = foot_contacts[leg_index] ? ContactState::CONTACT : ContactState::NO_CONTACT;\n        contacts_stamped.contacts.back().robot_side = static_cast<RobotSide>(leg_index);\n    }\n\n    foot_contacts_publisher_->publish(contacts_stamped);\n}", "CodeBleu_score": 36.01210389196059}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    joint_msg = Joints()\n    joint_msg.header.stamp = rospy.Time.now()\n    joint_msg.header.frame_id = \"base_link\"\n    joint_msg.joints = joints.joints[0:12]\n    self.joints_pub.publish(joint_msg)\n\n    joint_traj = JointTrajectory()\n    joint_traj.header.stamp = rospy.Time.now()\n    joint_traj.header.frame_id = \"base_link\"\n    joint_traj.joint_names = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    joint_traj.points = []\n    point = JointTrajectoryPoint()\n    point.positions = joint_msg.joints\n    point.time_from_start = rospy.Duration(1.0)\n    joint_traj.points.append(point)\n    self.traj_pub.publish(joint_traj)\n}", "CodeBleu_score": 48.95216167619454}, {"code": "def joints_cmd_callback(self, joints){\n\t    self.joints_msg.header.stamp = rospy.Time.now()\n    self.joints_msg.header.frame_id = \"base_link\"\n    self.joints_msg.name = joints.name\n    self.joints_msg.position = joints.position\n    self.joints_msg.velocity = joints.velocity\n    self.joints_msg.effort = joints.effort\n    self.joints_pub.publish(self.joints_msg)\n\n    self.trajectory_msg.header.stamp = rospy.Time.now()\n    self.trajectory_msg.header.frame_id = \"base_link\"\n    self.trajectory_msg.joint_names = joints.name\n    self.trajectory_msg.points.append(JointTrajectoryPoint(positions=joints.position, time_from_start=rospy.Duration(self.trajectory_duration)))\n    self.trajectory_pub.publish(self.trajectory_msg)\n\n", "CodeBleu_score": 35.387521355869254}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create a joints message with the first 12 joint positions\n    joints_msg = Joints()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.header.frame_id = \"base_link\"\n    joints_msg.name = joints.name[0:12]\n    joints_msg.position = joints.position[0:12]\n    joints_msg.velocity = joints.velocity[0:12]\n    joints_msg.effort = joints.effort[0:12]\n    self.pub_joints.publish(joints_msg)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    trajectory = JointTrajectory()\n    trajectory.header.stamp = rospy.Time.now()\n    trajectory.header.frame_id = \"base_link\"\n    trajectory.joint_names = joints.name[0:12]\n    trajectory.points.append(JointTrajectoryPoint())\n    trajectory.points[0].positions = joints.position[0:12]\n    trajectory.points[0].velocities = [0.0] * 12\n    trajectory.points[0].accelerations = [0.0] * 12\n    trajectory.points[0].time_from_start.secs = 1\n    trajectory.points[0].time_from_start.nsecs = 0\n    self.pub_trajectory.publish(trajectory)\n}", "CodeBleu_score": 42.24140336801804}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\n    // Initialize foot contact states to false\n    for (int i = 0; i < 4; i++) {\n        contact_states[i] = false;\n    }\n\n    // For each contact in the message, split the collision string to identify the contact link\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        std::string collision = _msg->contact(i).collision2();\n        std::vector<std::string> split;\n        boost::split(split, collision, boost::is_any_of(\"/\"));\n        std::string contact_link = split[split.size() - 1];\n\n        // If a contact matches one of the foot links, set the corresponding foot contact state to true\n        if (contact_link == \"l_foot_contact\") {\n            contact_states[0] = true;\n        } else if (contact_link == \"r_foot_contact\") {\n            contact_states[1] = true;\n        } else if (contact_link == \"l_foot_contact_2\") {\n            contact_states[2] = true;\n        } else if (contact_link == \"r_foot_contact_2\") {\n            contact_states[3] = true;\n        }\n    }\n}", "CodeBleu_score": 54.25622212865135}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\n  std::string link_name;\n\n  for (int i = 0; i < _msg->contact_size(); i++) {\n\n    link_name = _msg->contact(i).collision2();\n\n    if (link_name.find(\"foot_link\") != std::string::npos) {\n\n      std::cout << \"Contact: \" << link_name << std::endl;\n\n      if (link_name.find(\"left_foot_link\") != std::string::npos) {\n\n        left_contact = true;\n\n      }\n\n      else if (link_name.find(\"right_foot_link\") != std::string::npos) {\n\n        right_contact = true;\n\n      }\n\n    }\n\n  }\n\n}", "CodeBleu_score": 39.417745420450544}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  static std::vector<std::string> foot_links = {\n    \"foot_0_link\",\n    \"foot_1_link\",\n    \"foot_2_link\",\n    \"foot_3_link\",\n    \"foot_4_link\",\n    \"foot_5_link\",\n    \"foot_6_link\",\n    \"foot_7_link\"\n  };\n\n  static std::vector<bool> foot_contacts = {\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false\n  };\n\n  for (auto &contact : _msg->contacts) {\n    std::vector<std::string> collision_parts;\n    boost::split(collision_parts, contact.collision2, boost::is_any_of(\"::\"));\n    std::string collision_name = collision_parts.at(collision_parts.size() - 1);\n    for (int i = 0; i < foot_links.size(); i++) {\n      if (collision_name.find(foot_links.at(i)) != std::string::npos) {\n        foot_contacts.at(i) = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 41.023885288519935}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  // Check if the controller is active\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Check if the input is valid\n  if (current_state_.position_W.size() != 3) {\n    std::cout << \"LeePositionController::CalculateRotorVelocities: invalid state\" << std::endl;\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Calculate desired acceleration\n  Eigen::Vector3d desired_acceleration = Eigen::Vector3d::Zero();\n  desired_acceleration = kp_ * (desired_state_.position_W - current_state_.position_W);\n\n  // Calculate desired angular acceleration\n  Eigen::Vector3d desired_angular_acceleration = Eigen::Vector3d::Zero();\n  desired_angular_acceleration = kp_ * (desired_state_.orientation_W_B * current_state_.orientation_W_B.inverse()).log();\n\n  // Project thrust onto body z-axis\n  double thrust = thrust_input_;\n  desired_acceleration(2) = 0.0;\n  desired_angular_acceleration(2) = 0.0;\n\n  // Combine angular acceleration and thrust into a single vector\n  Eigen::Vector3d desired_velocity = Eigen::Vector3d::Zero();\n  desired_velocity = desired_acceleration + desired_angular_acceleration.cross(thrust * current_state_.orientation_W_B.inverse().getRotationVector());\n\n  // Calculate rotor velocities\n  rotor_velocities->setZero();\n  for (int i = 0; i < 4; i++) {\n    (*rotor_velocities)(i) = sqrt(desired_velocity.dot(rotor_velocity_matrix_.col(i)));\n  }\n}", "CodeBleu_score": 42.520642946918436}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Calculate desired acceleration and angular acceleration\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_angular_acceleration;\n  CalculateDesiredAccelerationAndAngularAcceleration(&desired_acceleration, &desired_angular_acceleration);\n\n  // Project desired acceleration onto body z-axis\n  Eigen::Vector3d desired_acceleration_body_z = body_z_ * desired_acceleration.dot(body_z_);\n\n  // Combine angular acceleration and thrust\n  Eigen::Vector3d desired_acceleration_body = desired_angular_acceleration + desired_acceleration_body_z;\n\n  // Compute rotor velocities\n  rotor_velocities->setZero();\n  rotor_velocities->block<3, 1>(0, 0) = rotor_velocities_matrix_ * desired_acceleration_body;\n  rotor_velocities->block<3, 1>(3, 0) = rotor_velocities_matrix_ * desired_angular_acceleration;\n\n  // Ensure non-negative values\n  for (int i = 0; i < 6; ++i) {\n    rotor_velocities->coeffRef(i) = std::max(rotor_velocities->coeff(i), 0.0);\n  }\n\n  // Take the square root of each component\n  for (int i = 0; i < 6; ++i) {\n    rotor_velocities->coeffRef(i) = std::sqrt(rotor_velocities->coeff(i));\n  }\n}", "CodeBleu_score": 49.530150528164974}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t    // Check if the controller is active\n    if (!active_) {\n        // If not, set all rotor velocities to zero\n        rotor_velocities->setZero();\n    } else {\n        // Otherwise, compute the desired acceleration and angular acceleration\n        Eigen::Vector3d desired_acceleration, desired_angular_acceleration;\n        CalculateDesiredAccelerationAndAngularAcceleration(&desired_acceleration, &desired_angular_acceleration);\n\n        // Project thrust onto the body z-axis\n        Eigen::Vector3d thrust_body = attitude_estimator_->GetThrustBody();\n        Eigen::Vector3d thrust_body_z = attitude_estimator_->GetThrustBodyZ();\n        double thrust_body_z_norm = thrust_body_z.norm();\n        if (thrust_body_z_norm > 0.0) {\n            thrust_body_z /= thrust_body_z_norm;\n        } else {\n            thrust_body_z.setZero();\n        }\n        double thrust_body_z_dot = thrust_body_z.dot(thrust_body);\n        thrust_body_z *= thrust_body_z_dot;\n        thrust_body -= thrust_body_z;\n\n        // Combine angular acceleration and thrust into a single vector\n        Eigen::Vector3d desired_acceleration_body = attitude_estimator_->GetThrustBody().cross(desired_angular_acceleration);\n        desired_acceleration_body += thrust_body;\n\n        // Compute rotor velocities\n        rotor_velocities->setZero();\n        rotor_velocities->segment(0, 3) = rotor_velocity_matrix_ * desired_acceleration_body;\n        rotor_velocities->segment(3, 3) = rotor_velocity_matrix_ * desired_angular_acceleration;\n\n        // Ensure rotor velocities are non-negative\n        for (int i = 0; i < rotor_velocities->size(); ++i) {\n", "CodeBleu_score": 40.43628733761287}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\n  // Get the current vehicle state\n  Eigen::Vector3d position = this->vehicle_state_.position;\n  Eigen::Vector3d velocity = this->vehicle_state_.velocity;\n  Eigen::Vector3d acceleration_command = this->vehicle_state_.acceleration_command;\n\n  // Transform the vehicle velocity to the world frame\n  Eigen::Vector3d velocity_world_frame = this->vehicle_state_.orientation * velocity;\n\n  // Compute the position error\n  Eigen::Vector3d position_error = this->vehicle_state_.position_command - position;\n\n  // Compute the velocity error\n  Eigen::Vector3d velocity_error = velocity_world_frame - this->vehicle_state_.velocity_command;\n\n  // Compute the desired acceleration\n  Eigen::Vector3d desired_acceleration = (this->kp_position_ * position_error + this->kd_position_ * velocity_error) / this->vehicle_state_.mass + this->kp_velocity_ * velocity_error;\n\n  // Adjust for the commanded acceleration\n  desired_acceleration += acceleration_command;\n\n  // Copy the desired acceleration into the output vector\n  (*acceleration) = desired_acceleration;\n}", "CodeBleu_score": 39.278184976100185}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\n\t// Compute the position and velocity errors\n\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tComputeErrors(&position_error, &velocity_error);\n\n\t// Compute the desired acceleration\n\t*acceleration = position_gain_.cwiseProduct(position_error) + velocity_gain_.cwiseProduct(velocity_error);\n\n\t// Adjust the desired acceleration for vehicle mass, gravity, and commanded acceleration\n\t*acceleration += gravity_ + commanded_acceleration_;\n\n\t// Transform the desired acceleration to the vehicle frame\n\t*acceleration = transform_to_vehicle_frame_.linear() * (*acceleration);\n\n}", "CodeBleu_score": 27.71630884281494}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\n\t// Get the current position and velocity in the world frame\n\tEigen::Vector3d position_world_frame = _vehicle_position.position;\n\tEigen::Vector3d velocity_world_frame = _vehicle_position.velocity;\n\n\t// Get the current position and velocity in the body frame\n\tEigen::Vector3d position_body_frame = _vehicle_position.position - _vehicle_position.orientation.rotate(_vehicle_position.position_body);\n\tEigen::Vector3d velocity_body_frame = _vehicle_position.velocity - _vehicle_position.orientation.rotate(_vehicle_position.velocity_body);\n\n\t// Get the current position and velocity in the local frame\n\tEigen::Vector3d position_local_frame = _vehicle_position.position - _vehicle_position.orientation.rotate(_vehicle_position.position_local);\n\tEigen::Vector3d velocity_local_frame = _vehicle_position.velocity - _vehicle_position.orientation.rotate(_vehicle_position.velocity_local);\n\n\t// Get the current position and velocity in the local frame\n\tEigen::Vector3d position_body_frame_cmd = _vehicle_position.position_cmd - _vehicle_position.orientation.rotate(_vehicle_position.position_cmd_body);\n\tEigen::Vector3d velocity_body_frame_cmd = _vehicle_position.velocity_cmd - _vehicle_position.orientation.rotate(_vehicle_position.velocity_cmd_body);\n\n\t// Get the current position and velocity in the local frame\n\tEigen::Vector3d position_local_frame_cmd = _vehicle_position.position_cmd - _vehicle_position.orientation.rotate(_vehicle_position.position_cmd_local);\n\tEigen::Vector3d velocity_local_frame_cmd = _vehicle_position.velocity_cmd - _vehicle_position.orientation.rotate(_vehicle_position.velocity_cmd_local);\n\n\t// Get the current position and velocity in the", "CodeBleu_score": 20.323638545373207}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  if (rotor_velocities == nullptr) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is a nullptr\" << std::endl;\n    return;\n  }\n\n  if (rotor_velocities->size() != 4) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities has \" << rotor_velocities->size() << \" elements, but 4 are expected\" << std::endl;\n    return;\n  }\n\n  if (thrust_reference_ == 0) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: thrust_reference is 0\" << std::endl;\n    return;\n  }\n\n  if (thrust_reference_ < 0) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: thrust_reference is negative\" << std::endl;\n    return;\n  }\n\n  if (rotor_velocities->maxCoeff() > 1) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities contains a value greater than 1\" << std::endl;\n    return;\n  }\n\n  if (rotor_velocities->minCoeff() < 0) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities contains a value less than 0\" << std::endl;\n    return;\n  }\n\n  rotor_velocities->resize(4);\n\n  Eigen::Vector4d desired_angular_acceleration = thrust_reference_ * thrust_to_torque_matrix_.inverse() * desired_angular_acceleration_;\n\n  for (int i = 0; i < 4; i++) {\n    rotor_velocities->coeffRef(i) = std::max(1.0, rotor_velocities_matrix_.coeff(i", "CodeBleu_score": 38.995814875111016}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t    if (rotor_velocities == nullptr) {\n        std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is nullptr\" << std::endl;\n        return;\n    }\n\n    if (rotor_velocities->size() != 4) {\n        std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is not of size 4\" << std::endl;\n        return;\n    }\n\n    Eigen::VectorXd desired_angular_acceleration = this->CalculateDesiredAngularAcceleration();\n\n    if (desired_angular_acceleration.size() != 3) {\n        std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: desired_angular_acceleration is not of size 3\" << std::endl;\n        return;\n    }\n\n    Eigen::VectorXd thrust_reference = this->CalculateThrustReference();\n\n    if (thrust_reference.size() != 3) {\n        std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: thrust_reference is not of size 3\" << std::endl;\n        return;\n    }\n\n    Eigen::VectorXd desired_angular_acceleration_and_thrust_reference = Eigen::VectorXd::Zero(3 + 3);\n    desired_angular_acceleration_and_thrust_reference << desired_angular_acceleration, thrust_reference;\n\n    *rotor_velocities = this->rotor_velocities_matrix_ * desired_angular_acceleration_and_thrust_reference;\n\n    for (int i = 0; i < 4; i++) {\n        if ((*rotor_velocities)(i) < 1) {\n            (*rotor_velocities)(i) = 1;\n        }\n    }\n\n    *rotor_velocities = (*rotor_velocities).cwiseSqrt();\n}", "CodeBleu_score": 41.9987576534532}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t    // Check if the input is valid\n    if (rotor_velocities == nullptr) {\n        std::cerr << \"ERROR: AttitudeControllerSamy::CalculateRotorVelocities: The input vector is nullptr\" << std::endl;\n        return;\n    }\n    // Check if the input size is valid\n    if (rotor_velocities->size() != this->rotor_velocities_.size()) {\n        std::cerr << \"ERROR: AttitudeControllerSamy::CalculateRotorVelocities: The input vector size is invalid\" << std::endl;\n        return;\n    }\n    // Check if the parameters are valid\n    if (this->rotor_velocities_.size() != this->parameters_.size()) {\n        std::cerr << \"ERROR: AttitudeControllerSamy::CalculateRotorVelocities: The parameters vector size is invalid\" << std::endl;\n        return;\n    }\n\n    // Calculate the desired angular acceleration\n    Eigen::VectorXd desired_angular_acceleration = this->CalculateDesiredAngularAcceleration();\n    // Combine the thrust reference and the desired angular acceleration into a single vector\n    Eigen::VectorXd combined_vector = this->parameters_ + desired_angular_acceleration;\n    // Multiply the combined vector with the rotor velocity matrix\n    *rotor_velocities = this->rotor_velocities_matrix_ * combined_vector;\n    // Ensure the rotor velocities are at least one\n    *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(this->rotor_velocities_.size()));\n    // Take the square root of each component\n    *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 40.51857568609854}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n    if start_index == -1:\n        print(\"The start time is not in the bag file.\")\n        return None\n    if end_index == -1:\n        print(\"The end time is not in the bag file.\")\n        return None\n    if start_index > end_index:\n        print(\"The start time is later than the end time.\")\n        return None\n    if start_index == end_index:\n        print(\"The start time and end time are the same.\")\n        return None\n    new_bag = copy.deepcopy(self)\n    new_bag.bag_data = self.bag_data[start_index:end_index]\n    new_bag.start_time = start_time\n    new_bag.end_time = end_time\n    new_bag.time_step = new_bag.bag_data[1].header.stamp.secs - new_bag.bag_data[0].header.stamp.secs\n    new_bag.time_step = new_bag.time_step + (new_bag.bag_data[1].header.stamp.nsecs - new_bag.bag_data[0].header.stamp.nsecs) / 1000000000\n    return new_bag\n\n", "CodeBleu_score": 40.00409233446083}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_index_from_time(start_time)\n    end_index = self.get_index_from_time(end_time)\n    copy_of_self = copy.deepcopy(self)\n    copy_of_self.times = copy_of_self.times[start_index:end_index]\n    copy_of_self.poses = copy_of_self.poses[start_index:end_index]\n    copy_of_self.velocities = copy_of_self.velocities[start_index:end_index]\n    copy_of_self.accelerations = copy_of_self.accelerations[start_index:end_index]\n    copy_of_self.orientations = copy_of_self.orientations[start_index:end_index]\n    copy_of_self.angular_velocities = copy_of_self.angular_velocities[start_index:end_index]\n    copy_of_self.angular_accelerations = copy_of_self.angular_accelerations[start_index:end_index]\n    return copy_of_self\n\n", "CodeBleu_score": 16.35632576485049}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices for the start and end times\n    start_index = self.time_index(start_time)\n    end_index = self.time_index(end_time)\n    # Make a deep copy of the object\n    copied_object = copy.deepcopy(self)\n    # Update each attribute of the copied object to contain only the sliced data\n    copied_object.time = copied_object.time[start_index:end_index]\n    copied_object.position = copied_object.position[start_index:end_index]\n    copied_object.orientation = copied_object.orientation[start_index:end_index]\n    copied_object.velocity = copied_object.velocity[start_index:end_index]\n    copied_object.acceleration = copied_object.acceleration[start_index:end_index]\n    copied_object.angular_velocity = copied_object.angular_velocity[start_index:end_index]\n    copied_object.angular_acceleration = copied_object.angular_acceleration[start_index:end_index]\n    return copied_object\n\n", "CodeBleu_score": 17.059016434385004}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation from the message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert the rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one by comparing position and yaw values\n    if not (self.last_point.x == point.x and self.last_point.y == point.y and self.last_point.z == point.z and self.last_yaw == euler[2]):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.points.append(point)\n        self.yaws.append(euler[2])\n        self.msg_times.append(msg_time)\n        self.bag_times.append(bag_time)\n        # Set the last_point and last_yaw to the new point and yaw\n        self.last_point = point\n        self.last_yaw = euler[2]\n\n", "CodeBleu_score": 26.305861182078218}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.position\n    orientation = waypoint_msg.pose.orientation\n    # Convert the rotation to Euler angles\n    quaternion = (orientation.x, orientation.y, orientation.z, orientation.w)\n    euler = tf.transformations.euler_from_quaternion(quaternion)\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the waypoint is different from the last one\n    if not self.waypoints[-1].point.x == point.x or not self.waypoints[-1].point.y == point.y or not self.waypoints[-1].point.z == point.z or not self.waypoints[-1].yaw == euler[2]:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.waypoint_yaws.append(euler[2])\n        self.waypoint_times.append(msg_time)\n        self.bag_times.append(bag_time)\n\n", "CodeBleu_score": 21.9822200941744}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    self.waypoint_msg = waypoint_msg\n    self.msg_time = msg_time\n    self.bag_time = bag_time\n    self.waypoint_position = waypoint_msg.pose.position\n    self.waypoint_orientation = waypoint_msg.pose.orientation\n    self.waypoint_yaw = tf.transformations.euler_from_quaternion(\n        [self.waypoint_orientation.x, self.waypoint_orientation.y, self.waypoint_orientation.z, self.waypoint_orientation.w])[2]\n    if self.waypoint_position.x != self.last_waypoint_position.x or self.waypoint_position.y != self.last_waypoint_position.y or self.waypoint_yaw != self.last_waypoint_yaw:\n        self.waypoint_position_array.append(self.waypoint_position)\n        self.waypoint_yaw_array.append(self.waypoint_yaw)\n        self.waypoint_time_array.append(self.msg_time)\n        self.last_waypoint_position = self.waypoint_position\n        self.last_waypoint_yaw = self.waypoint_yaw\n\n", "CodeBleu_score": 23.62337031295632}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu':\n        self.imu_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.imu_bag_time.append(bag_time)\n        self.imu_x.append(msg.linear_acceleration.x)\n        self.imu_y.append(msg.linear_acceleration.y)\n        self.imu_z.append(msg.linear_acceleration.z)\n    elif topic == '/imu_raw':\n        self.imu_raw_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.imu_raw_bag_time.append(bag_time)\n        self.imu_raw_x.append(msg.linear_acceleration.x)\n        self.imu_raw_y.append(msg.linear_acceleration.y)\n        self.imu_raw_z.append(msg.linear_acceleration.z)\n    elif topic == '/imu_corrected':\n        self.imu_corrected_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.imu_corrected_bag_time.append(bag_time)\n        self.imu_corrected_x.append(msg.linear_acceleration.x)\n        self.imu_corrected_y.append(msg.linear_acceleration.y)\n        self.imu_corrected_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 25.602658574331137}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu0/data':\n        self.imu0_acc_x.append(msg.linear_acceleration.x)\n        self.imu0_acc_y.append(msg.linear_acceleration.y)\n        self.imu0_acc_z.append(msg.linear_acceleration.z)\n        self.imu0_time.append(msg.header.stamp.to_sec())\n        self.bag_time.append(bag_time)\n    elif topic == '/imu1/data':\n        self.imu1_acc_x.append(msg.linear_acceleration.x)\n        self.imu1_acc_y.append(msg.linear_acceleration.y)\n        self.imu1_acc_z.append(msg.linear_acceleration.z)\n        self.imu1_time.append(msg.header.stamp.to_sec())\n        self.bag_time.append(bag_time)\n    elif topic == '/imu2/data':\n        self.imu2_acc_x.append(msg.linear_acceleration.x)\n        self.imu2_acc_y.append(msg.linear_acceleration.y)\n        self.imu2_acc_z.append(msg.linear_acceleration.z)\n        self.imu2_time.append(msg.header.stamp.to_sec())\n        self.bag_time.append(bag_time)\n    elif topic == '/imu3/data':\n        self.imu3_acc_x.append(msg.linear_acceleration.x)\n        self.imu3_acc_y.append(msg.linear_acceleration.y)\n        self.imu3_acc_z.append(msg.linear_acceleration.z)\n        self.imu3_time.append(msg.header.stamp.to_sec())\n        self.bag_time.append(bag_time)\n    elif topic == '/imu4/data':\n        self.", "CodeBleu_score": 24.771243887808684}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu0/data\":\n        self.acceleration_x = msg.linear_acceleration.x\n        self.acceleration_y = msg.linear_acceleration.y\n        self.acceleration_z = msg.linear_acceleration.z\n        self.time = msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9\n        self.bag_time = bag_time\n\n", "CodeBleu_score": 29.095159046700726}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create figure\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration Data\")\n    # Create subplot\n    ax = fig.add_subplot(1, 1, 1)\n    # Plot accelerations\n    ax.plot(self.acceleration_data['x'], label=\"x\")\n    ax.plot(self.acceleration_data['y'], label=\"y\")\n    ax.plot(self.acceleration_data['z'], label=\"z\")\n    # Add labels and legend\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    ax.legend(loc=\"upper left\")\n    # Save plot\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        filename = \"acceleration\" + plot_suffix + \".png\"\n        fig.savefig(filename)\n\n", "CodeBleu_score": 31.283888019665696}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.bag_data is None:\n        return\n    if self.bag_data.acceleration_data is None:\n        return\n    if self.bag_data.acceleration_data.x is None:\n        return\n    if self.bag_data.acceleration_data.y is None:\n        return\n    if self.bag_data.acceleration_data.z is None:\n        return\n    if self.bag_data.acceleration_data.time is None:\n        return\n    if self.bag_data.acceleration_data.time.size < 2:\n        return\n    if self.bag_data.acceleration_data.time.size != self.bag_data.acceleration_data.x.size:\n        return\n    if self.bag_data.acceleration_data.time.size != self.bag_data.acceleration_data.y.size:\n        return\n    if self.bag_data.acceleration_data.time.size != self.bag_data.acceleration_data.z.size:\n        return\n    if self.bag_data.acceleration_data.time.size != self.bag_data.acceleration_data.x_std.size:\n        return\n    if self.bag_data.acceleration_data.time.size != self.bag_data.acceleration_data.y_std.size:\n        return\n    if self.bag_data.acceleration_data.time.size != self.bag_data.acceleration_data.z_std.size:\n        return\n    if self.bag_data.acceleration_data.time.size != self.bag_data.acceleration_data.x_mean.size:\n        return\n    if self.bag_data.acceleration_data.time.size != self.bag_data.acceleration_data.y_mean.size:\n        return\n    if self.bag_data.acceleration_data.time.size != self.bag_data.acceler", "CodeBleu_score": 14.076084065826278}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create the figure\n    pyplot.figure(figsize=(10, 10))\n    # Create the subplot\n    pyplot.subplot(211)\n    # Set the title\n    pyplot.title('Acceleration')\n    # Set the x-axis label\n    pyplot.xlabel('Time (s)')\n    # Set the y-axis label\n    pyplot.ylabel('Acceleration (m/s^2)')\n    # Set the x-axis limits\n    pyplot.xlim(0, self.bag_duration)\n    # Set the y-axis limits\n    pyplot.ylim(-15, 15)\n    # Plot the x-axis\n    pyplot.plot([0, self.bag_duration], [0, 0], color='black', linewidth=1)\n    # Plot the y-axis\n    pyplot.plot([0, 0], [-15, 15], color='black', linewidth=1)\n    # Plot the data\n    for topic in self.acceleration_topics:\n        # Get the data\n        data = self.get_topic_data(topic)\n        # Get the topic name\n        topic_name = topic.split('/')[-1]\n        # Plot the data\n        pyplot.plot(data['time'], data['x'], label='x (' + topic_name + ')')\n        pyplot.plot(data['time'], data['y'], label='y (' + topic_name + ')')\n        pyplot.plot(data['time'], data['z'], label='z (' + topic_name + ')')\n    # Add a legend\n    pyplot.legend()\n    # Save the plot if saving plots is enabled\n    if self.save_plots:\n        if plot_suffix is not None:\n            filename = self.plot_prefix + '_accelerations_' + plot_suffix + '.png'\n        else:\n            filename = self.plot_prefix + '_accelerations.png'\n        pyplot.savefig(filename, dpi=100)\n        pyplot.close()\n\n", "CodeBleu_score": 35.73026646457649}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    for pose_index in pose_indeces:\n        for pose_index_2 in pose_indeces:\n            if pose_index != pose_index_2:\n                self.compare_two_xyz(pose_index, pose_index_2)\n\n", "CodeBleu_score": 18.44997030035655}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # check if there are at least two pose indices\n    if len(pose_indeces) < 2:\n        print(\"Not enough pose indices to compare!\")\n        return\n\n    # get the first pose index\n    pose_index_1 = pose_indeces[0]\n\n    # for each pose index, compare the position with the first pose index\n    for pose_index_2 in pose_indeces[1:]:\n        # compare the two positions\n        self.compare_two_xyz(pose_index_1, pose_index_2)\n\n        # update the pose index\n        pose_index_1 = pose_index_2\n\n", "CodeBleu_score": 31.332167386492383}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for pose_index in pose_indeces:\n        compare_two_xyz(self, pose_index, pose_indeces[pose_indeces.index(pose_index)+1:])\n", "CodeBleu_score": 13.711894557311217}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    if start_time is None:\n        start_time = self.bag.get_start_time()\n    if end_time is None:\n        end_time = self.bag.get_end_time()\n    for collision in self.wrench:\n        if start_time <= collision.header.stamp.to_sec() <= end_time:\n            collision_times.append(collision.header.stamp.to_sec())\n    return collision_times\n\n", "CodeBleu_score": 33.090198024118514}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.times:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 35.804509419301326}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is not None and end_time is not None:\n            if collision.header.stamp.secs >= start_time and collision.header.stamp.secs <= end_time:\n                collision_times.append(collision.header.stamp.secs)\n        elif start_time is not None:\n            if collision.header.stamp.secs >= start_time:\n                collision_times.append(collision.header.stamp.secs)\n        elif end_time is not None:\n            if collision.header.stamp.secs <= end_time:\n                collision_times.append(collision.header.stamp.secs)\n        else:\n            collision_times.append(collision.header.stamp.secs)\n    return collision_times\n\n", "CodeBleu_score": 38.620347997571436}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 29.32422071502378}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 35.617081494174855}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 35.617081494174855}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  const float multiplier = (noise_stddev_ / 0.001f) * (1.0f / 10000.0f);\n  Eigen::VectorXf data_vec(width * height);\n  for (uint32_t i = 0; i < width * height; ++i) {\n    data_vec[i] = data[i];\n  }\n\n  const float rms_noise = ComputeRMSNoise(data_vec);\n  const float noise_value = rms_noise * multiplier;\n\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (data[i] > 0.0f && data[i] < 10.0f) {\n      data[i] += noise_value *\n                 (std::rand() / static_cast<float>(RAND_MAX) - 0.5f);\n    } else {\n      data[i] = bad_point_value_;\n    }\n  }\n}", "CodeBleu_score": 53.16353473572132}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (!data) {\n    return;\n  }\n\n  float multiplier = 0.0;\n  if (this->camera_params_.fx != 0.0 && this->camera_params_.fy != 0.0 &&\n      this->camera_params_.cx != 0.0 && this->camera_params_.cy != 0.0) {\n    multiplier = 1.0 /\n                 (sqrt(this->camera_params_.fx * this->camera_params_.fy));\n  }\n\n  Eigen::VectorXf data_eigen(width * height);\n  for (uint32_t i = 0; i < width * height; i++) {\n    data_eigen(i) = data[i] * multiplier;\n  }\n\n  // Compute RMS noise\n  float rms_noise = this->ComputeRMSNoise(data_eigen);\n\n  // Compute noise values\n  Eigen::VectorXf noise_values = this->ComputeNoiseValues(rms_noise);\n\n  // Add noise\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data[i] > this->bad_point_value_ &&\n        data[i] < this->good_point_value_) {\n      data[i] += noise_values(i);\n    } else {\n      data[i] = this->bad_point_value_;\n    }\n  }\n}", "CodeBleu_score": 45.779829964981}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n  // Calculate multiplier\n  float multiplier = 1.0f;\n  if (std::abs(fx_) > 0.000001f) {\n    multiplier = 1.0f / fx_;\n  }\n\n  // Map to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_eigen(data, width * height);\n\n  // Compute RMS noise and noise values\n  float rms_noise = ComputeRMSNoise();\n  float noise_value = rms_noise * multiplier;\n\n  // Add noise\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_eigen(i) > 0.0f) {\n      data_eigen(i) += noise_value * noise_distribution_(engine_);\n    } else {\n      data_eigen(i) = bad_point_value_;\n    }\n  }\n}", "CodeBleu_score": 53.968299947082386}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get simulation time\n  common::Time current_time = model->GetWorld()->GetSimTime();\n  ros::Time ros_time(current_time.sec, current_time.nsec);\n\n  // Convert to ROS time\n  ros::Time ros_time_converted = ros_time + ros::Duration(1.0);\n\n  // Write to bag file\n  trajectory_bag_->write(waypoint_topic_, ros_time_converted, *trajectory_msg);\n}", "CodeBleu_score": 50.17684453004468}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time current_ros_time = ros::Time::now();\n  ros::Time current_sim_time = ros::Time(world_->GetSimTime().Double());\n  ros::Duration sim_to_ros_time = current_ros_time - current_sim_time;\n  ros::Time current_time = current_ros_time + sim_to_ros_time;\n  trajectory_msgs::MultiDOFJointTrajectory trajectory_msg_ros;\n  trajectory_msg_ros.header.stamp = current_time;\n  trajectory_msg_ros.header.frame_id = \"world\";\n  trajectory_msg_ros.header.seq = waypoint_count_;\n  trajectory_msg_ros.joint_names = trajectory_msg->joint_names;\n  trajectory_msg_ros.points = trajectory_msg->points;\n  trajectory_msg_ros.points.front().time_from_start = ros::Duration(0);\n  trajectory_msg_ros.points.front().transforms.front().translation.z = 0.0;\n  trajectory_msg_ros.points.front().transforms.front().rotation.x = 0.0;\n  trajectory_msg_ros.points.front().transforms.front().rotation.y = 0.0;\n  trajectory_msg_ros.points.front().transforms.front().rotation.z = 0.0;\n  trajectory_msg_ros.points.front().transforms.front().rotation.w = 1.0;\n  trajectory_msg_ros.points.back().time_from_start = ros::Duration(1.0);\n  trajectory_msg_ros.points.back().transforms.front().translation.z = 0.0;\n  trajectory_msg_ros.points.back().transforms.front().rotation.x = 0.0;\n  trajectory_msg_ros.points.back().transforms.front().rotation.y = 0.0;\n  trajectory_msg_ros.points.back().transforms.front().rotation.z = 0.0;\n  traject", "CodeBleu_score": 40.54843894323999}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time current_time = ros::Time::now();\n  ros::Time simulation_time(current_time.sec - start_time.sec,\n                            current_time.nsec - start_time.nsec);\n\n  trajectory_msgs::MultiDOFJointTrajectory trajectory_msg_ros;\n  trajectory_msg_ros.header.stamp = simulation_time;\n  trajectory_msg_ros.header.frame_id = \"world\";\n  trajectory_msg_ros.points = trajectory_msg->points;\n  trajectory_msg_ros.joint_names = trajectory_msg->joint_names;\n\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, simulation_time,\n             trajectory_msg_ros);\n}", "CodeBleu_score": 49.41411351880029}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  ros::Time ros_now = ros::Time::now();\n  ros::Duration ros_now_to_now(now.Double());\n  ros::Time ros_time = ros_now + ros_now_to_now;\n  mav_msgs::Actuators msg;\n  msg.header.stamp = ros_time;\n  for (int i = 0; i < motor_joints_.size(); i++) {\n    double motor_velocity = motor_joints_[i]->GetVelocity(0);\n    msg.motor_speed.push_back(motor_velocity);\n  }\n  actuator_velocities_publisher_.publish(msg);\n}", "CodeBleu_score": 41.51979539193276}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  ros::Time ros_time = ros::Time::now();\n  ros::Duration ros_time_offset = ros_time - ros::Time(now.sec, now.nsec);\n  mav_msgs::Actuators motor_velocities;\n  motor_velocities.header.stamp = ros_time - ros_time_offset;\n  for (unsigned int i = 0; i < motor_joint_names_.size(); i++) {\n    motor_velocities.motor_velocities.push_back(motor_joint_velocities_[i]);\n  }\n  motor_velocities_publisher_.publish(motor_velocities);\n  motor_velocities_bag_.write(motor_topic_, ros_time, motor_velocities);\n}", "CodeBleu_score": 43.19925178947028}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t    // Convert Gazebo time to ROS time\n    ros::Time ros_now = ros::Time::now();\n    ros::Duration ros_elapsed = ros_now - ros_last_time_;\n    ros_last_time_ = ros_now;\n\n    // Prepare message\n    mav_msgs::Actuators msg;\n    msg.header.stamp = ros_now;\n    msg.header.frame_id = \"base_link\";\n\n    // Iterate through motor joints\n    for (unsigned int i = 0; i < motor_joints_.size(); i++) {\n        // Get joint velocity\n        double joint_velocity = motor_joints_[i]->GetVelocity(0);\n\n        // Get joint name\n        std::string joint_name = motor_joints_[i]->GetName();\n\n        // Get motor index\n        unsigned int motor_index = 0;\n        for (unsigned int j = 0; j < motor_names_.size(); j++) {\n            if (motor_names_[j] == joint_name) {\n                motor_index = j;\n                break;\n            }\n        }\n\n        // Set motor velocity\n        msg.motor_speed[motor_index] = joint_velocity;\n    }\n\n    // Write data to bag\n    motor_velocities_publisher_.publish(msg);\n}", "CodeBleu_score": 43.76346078150445}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    std::cout << \"RollPitchYawrateThrustCallback called.\" << std::endl;\n  }\n\n  // Convert normalized roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder.\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll() * M_PI_2;\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch() * M_PI_2;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yawrate();\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Set the throttle value from the thrust message.\n  double throttle = thrust / max_thrust_;\n\n  // Compute the control surface angles.\n  double aileron_angle = roll_angle;\n  double elevator_angle = pitch_angle;\n  double rudder_angle = yaw_rate * M_PI_2;\n\n  // Set the control surface angles.\n  aileron_joint_->SetAngle(0, aileron_angle);\n  elevator_joint_->SetAngle(0, elevator_angle);\n  rudder_joint_->SetAngle(0, rudder_angle);\n  throttle_joint_->SetForce(0, throttle);\n}", "CodeBleu_score": 46.219873358530315}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_print_)\n    gzdbg << __FUNCTION__ << \" called\" << std::endl;\n\n  // Convert roll, pitch, and yaw rate to control surface angles\n  double roll_control_surface_angle =\n      roll_pitch_yawrate_thrust_msg->roll() * roll_control_surface_angle_limit_;\n  double pitch_control_surface_angle =\n      roll_pitch_yawrate_thrust_msg->pitch() * pitch_control_surface_angle_limit_;\n  double yaw_rate_control_surface_angle =\n      roll_pitch_yawrate_thrust_msg->yaw_rate() * yaw_rate_control_surface_angle_limit_;\n\n  // Set the throttle value from the thrust message\n  double throttle = roll_pitch_yawrate_thrust_msg->throttle();\n\n  // Set the control surface angles\n  this->SetControlSurfaceAngles(roll_control_surface_angle, pitch_control_surface_angle,\n                                yaw_rate_control_surface_angle, throttle);\n}", "CodeBleu_score": 45.38098911625881}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  // If debug printing is enabled, log that the callback was called\n  if (debug_print_) {\n    std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // Convert normalized roll, pitch, and yaw rate to control surface angles\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll() *\n      roll_pitch_yawrate_thrust_msg->roll_max();\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch() *\n      roll_pitch_yawrate_thrust_msg->pitch_max();\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate() *\n      roll_pitch_yawrate_thrust_msg->yaw_rate_max();\n\n  // Set the throttle value\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust() /\n      roll_pitch_yawrate_thrust_msg->thrust_max();\n\n  // Set the control surface angles\n  double aileron = roll_angle;\n  double elevator = pitch_angle;\n  double rudder = yaw_rate;\n\n  // Set the control surface angles to the control surface actuators\n  aileron_actuator_->SetForce(0, aileron);\n  elevator_actuator_->SetForce(0, elevator);\n  rudder_actuator_->SetForce(0, rudder);\n  throttle_actuator_->SetForce(0, throttle);\n\n  // Publish the control surface angles\n  if (publish_control_surface_angles_) {\n    GzControlSurfaceAnglesMsgPtr control_surface_angles_msg(\n        new GzControlSurfaceAnglesMsg);\n    control_surface_angles_msg->set_aileron(aileron);\n    control_surface_angles_msg->set_elevator(elevator);\n    control_surface_angles_msg->set", "CodeBleu_score": 40.403015031674705}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll file descriptors\n  int poll_ret = poll(this->fds, this->num_fds, _timeoutMs);\n  if (poll_ret < 0) {\n    gzerr << \"poll() failed: \" << strerror(errno) << std::endl;\n    return;\n  }\n  else if (poll_ret == 0) {\n    // Timeout\n    return;\n  }\n\n  // Check for new data\n  for (int i = 0; i < this->num_fds; ++i) {\n    if (this->fds[i].revents & POLLIN) {\n      // Receive data\n      ssize_t ret = recv(this->fds[i].fd, this->buffer, this->buffer_size, 0);\n      if (ret < 0) {\n        gzerr << \"recv() failed: \" << strerror(errno) << std::endl;\n        return;\n      }\n      else if (ret == 0) {\n        // Connection closed\n        gzerr << \"Connection closed\" << std::endl;\n        return;\n      }\n\n      // Parse MAVLink messages\n      mavlink_message_t msg;\n      mavlink_status_t status;\n      unsigned char *buf = this->buffer;\n      while (mavlink_parse_char(this->system_id, this->component_id, buf, &msg,\n                                &status)) {\n        // Handle message\n        this->handleMessage(msg);\n\n        // Get next message\n        buf += status.len;\n      }\n    }\n  }\n}", "CodeBleu_score": 48.37635533286099}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for data\n  int nfds = poll(this->fds_, this->num_fds_, timeout.tv_sec * 1000 + timeout.tv_usec / 1000);\n  if (nfds == 0) {\n    // Timeout\n    return;\n  } else if (nfds == -1) {\n    // Error\n    gzerr << \"poll() failed: \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  // Data is available\n  for (int i = 0; i < this->num_fds_; ++i) {\n    if (this->fds_[i].revents & POLLIN) {\n      // Data is available on the file descriptor\n      if (this->fds_[i].fd == this->serial_fd_) {\n        // Data is available on the serial port\n        this->readSerialPort();\n      } else {\n        // Data is available on the Gazebo link\n        this->readGazeboLink(_dt);\n      }\n    }\n  }\n}", "CodeBleu_score": 38.97590690535048}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  struct timeval tv;\n  tv.tv_sec = _dt;\n  tv.tv_usec = (_timeoutMs - (_dt * 1000)) * 1000;\n\n  // Poll for MAVLink messages.\n  int poll_ret = poll(this->pollFds, this->pollFdsCount, _timeoutMs);\n\n  // If data is available, read it.\n  if (poll_ret > 0) {\n    // Read the data.\n    ssize_t bytes_read = read(this->pollFds[0].fd, this->buffer,\n                              this->bufferSize);\n    if (bytes_read < 0) {\n      gzerr << \"Failed to read from Gazebo MAVLink interface\n\";\n      return;\n    }\n\n    // Parse the data.\n    unsigned char *buf = this->buffer;\n    unsigned char *buf_end = buf + bytes_read;\n    mavlink_message_t msg;\n    while (buf < buf_end) {\n      buf = mavlink_parse_char(this->mavlink_system.sysid,\n                               this->mavlink_system.compid,\n                               buf, &msg, buf_end);\n      if (buf == NULL) {\n        continue;\n      }\n\n      // Handle the message.\n      this->handleMessage(msg);\n    }\n  }\n}", "CodeBleu_score": 45.71286161248533}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t    std::lock_guard<std::mutex> lock(mutex_);\n    if (open_) {\n        io_service_.stop();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n        serial_port_.close();\n        open_ = false;\n    }\n}", "CodeBleu_score": 58.47522209344294}, {"code": "void GazeboMavlinkInterface::close() {\n\t  boost::mutex::scoped_lock lock(mutex);\n  if (open_) {\n    io_service.stop();\n    serial_port.close();\n    if (io_thread.joinable()) {\n      io_thread.join();\n    }\n    open_ = false;\n  }\n}", "CodeBleu_score": 58.19960032397008}, {"code": "void GazeboMavlinkInterface::close() {\n\t    std::lock_guard<std::mutex> lk(this->mutex);\n    if(this->is_open) {\n        this->io_service.stop();\n        this->serial_port.close();\n        if(this->io_thread.joinable()) {\n            this->io_thread.join();\n        }\n        this->is_open = false;\n    }\n}", "CodeBleu_score": 29.22155249063381}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    double x0, y0, z0, x1, y1, z1, x, y, z;\n    x0 = x0;\n    y0 = y0;\n    z0 = z0;\n    x1 = x1;\n    y1 = y1;\n    z1 = z1;\n    x = x;\n    y = y;\n    z = z;\n\n    // Calculate the interpolated value\n    ignition::math::Vector3d interpolated_vector;\n    interpolated_vector.X(x0 + (x - x0) * (x1 - x0) / (y1 - y0));\n    interpolated_vector.Y(y0 + (y - y0) * (y1 - y0) / (z1 - z0));\n    interpolated_vector.Z(z0 + (z - z0) * (z1 - z0) / (z1 - z0));\n\n    return interpolated_vector;\n}", "CodeBleu_score": 35.93721796168987}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  double x1, y1, z1, x2, y2, z2;\n  double x3, y3, z3;\n\n  x1 = this->linear_interpolation_points[0].x();\n  y1 = this->linear_interpolation_points[0].y();\n  z1 = this->linear_interpolation_points[0].z();\n  x2 = this->linear_interpolation_points[1].x();\n  y2 = this->linear_interpolation_points[1].y();\n  z2 = this->linear_interpolation_points[1].z();\n\n  x3 = x1 + (x2 - x1) * (position - x1) / (x2 - x1);\n  y3 = y1 + (y2 - y1) * (position - x1) / (x2 - x1);\n  z3 = z1 + (z2 - z1) * (position - x1) / (x2 - x1);\n\n  return ignition::math::Vector3d(x3, y3, z3);\n}", "CodeBleu_score": 39.928074046558585}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    // This function, GazeboWindPlugin::LinearInterpolation, performs linear interpolation for a given position.", "CodeBleu_score": 6.286119586828473}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t  if (_time < 0) {\n    gzerr << \"Animation time cannot be less than zero.\n\";\n    return;\n  }\n\n  if (_time > this->Length()) {\n    gzerr << \"Animation time cannot be greater than animation length.\n\";\n    return;\n  }\n\n  if (this->loop && _time > this->Length()) {\n    _time = fmod(_time, this->Length());\n  }\n  else if (!this->loop && _time > this->Length()) {\n    _time = this->Length();\n  }\n\n  if (_time != this->time) {\n    this->time = _time;\n    this->Update(this->time);\n  }\n}", "CodeBleu_score": 48.01479761575518}, {"code": "void Animation::SetTime(double _time){\n\t  if (_time < 0)\n    _time = 0;\n  else if (_time > this->Length())\n    _time = this->Length();\n\n  if (_time == this->time)\n    return;\n\n  this->time = _time;\n  if (this->loop) {\n    this->time = fmod(this->time, this->Length());\n  }\n\n  this->Update();\n}", "CodeBleu_score": 49.728272510876266}, {"code": "void Animation::SetTime(double _time){\n\t  if (_time < 0) {\n    gzwarn << \"Animation::SetTime: time is less than zero. Setting time to 0.\n\";\n    _time = 0;\n  }\n\n  if (_time > this->length) {\n    gzwarn << \"Animation::SetTime: time is greater than the animation length. Setting time to animation length.\n\";\n    _time = this->length;\n  }\n\n  if (this->loop) {\n    _time = fmod(_time, this->length);\n  }\n  else {\n    _time = std::min(std::max(_time, 0.0), this->length);\n  }\n\n  if (this->time != _time) {\n    this->time = _time;\n    this->timePosChanged();\n  }\n}", "CodeBleu_score": 49.80921721283722}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n\n    # Set the coordinate frame to 1 (local NED)\n    self.set_coordinate_frame(1)\n\n    # Set the motion type to 0 (hover)\n    self.set_motion_type(0)\n\n    # Construct a target motion using the current position and yaw\n    self.construct_target_motion(0, 0, 0, 0, 0, 0, 0)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: {}\".format(self.vehicle_type))\n    print(\"Vehicle ID: {}\".format(self.vehicle_id))\n    print(\"Flight mode: {}\".format(self.flight_mode))\n\n", "CodeBleu_score": 23.21618885133932}, {"code": "def hover(self)\n\t\n    self.target_pose.coordinate_frame = 1\n    self.target_pose.type_mask = 0\n    self.target_pose.position.x = self.current_pose.pose.position.x\n    self.target_pose.position.y = self.current_pose.pose.position.y\n    self.target_pose.position.z = self.current_pose.pose.position.z\n    self.target_pose.velocity.x = 0\n    self.target_pose.velocity.y = 0\n    self.target_pose.velocity.z = 0\n    self.target_pose.acceleration_or_force.x = 0\n    self.target_pose.acceleration_or_force.y = 0\n    self.target_pose.acceleration_or_force.z = 0\n    self.target_pose.yaw = self.current_pose.pose.orientation\n    self.target_pose.yaw_rate = 0\n    self.motion_pub.publish(self.target_pose)\n    self.print_vehicle_type()\n    self.print_vehicle_id()\n    self.print_flight_mode()\n\n", "CodeBleu_score": 27.66517854256997}, {"code": "def hover(self)\n\t\n    self.target_pose.coordinate_frame = 1\n    self.target_pose.type_mask = 0\n    self.target_pose.position.x = self.position.x\n    self.target_pose.position.y = self.position.y\n    self.target_pose.position.z = self.position.z\n    self.target_pose.orientation = self.orientation\n    self.target_pose.velocity.x = 0\n    self.target_pose.velocity.y = 0\n    self.target_pose.velocity.z = 0\n    self.target_pose.acceleration.x = 0\n    self.target_pose.acceleration.y = 0\n    self.target_pose.acceleration.z = 0\n    self.target_pose.yaw = self.yaw\n    self.target_pose.yaw_rate = 0\n    self.target_pose.thrust = 0\n    self.target_pose.type_mask = 0\n    self.target_pose.autocontinue = 1\n    self.target_pose.force = 1\n    self.target_pose.header.stamp = rospy.Time.now()\n    self.target_pose.header.frame_id = \"map\"\n    self.target_pose.header.seq = self.seq\n    self.seq += 1\n    self.pub_target_pose.publish(self.target_pose)\n    self.print_info()\n\n", "CodeBleu_score": 25.97072670842383}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            self.success_message(\"Flight mode switched to \" + self.flight_mode)\n        except:\n            self.failure_message(\"Flight mode switch failed\")\n\n", "CodeBleu_score": 33.80128144566946}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print('Flight mode switched to {}'.format(self.flight_mode))\n            return True\n        except rospy.ServiceException:\n            print('Flight mode switch failed')\n            return False\n\n", "CodeBleu_score": 38.40479462231978}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == \"HOVER\":\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print(\"Mode switch successful\")\n            return True\n        except rospy.ServiceException as e:\n            print(\"Mode switch failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 34.663256979951534}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = PositionTarget()\n        self.target_motion.coordinate_frame = 1\n        self.target_motion.type_mask = 1\n        self.target_motion.velocity.x = msg.linear.x\n        self.target_motion.velocity.y = msg.linear.y\n        self.target_motion.velocity.z = msg.linear.z\n        self.target_motion.velocity_body.x = msg.linear.x\n        self.target_motion.velocity_body.y = msg.linear.y\n        self.target_motion.velocity_body.z = msg.linear.z\n        self.target_motion.acceleration_body.x = 0\n        self.target_motion.acceleration_body.y = 0\n        self.target_motion.acceleration_body.z = 0\n        self.target_motion.acceleration_world.x = 0\n        self.target_motion.acceleration_world.y = 0\n        self.target_motion.acceleration_world.z = 0\n        self.target_motion.yaw_rate = msg.angular.z\n        self.target_motion.yaw_rate_body = msg.angular.z\n        self.target_motion.thrust = 0\n\n", "CodeBleu_score": 27.12265299694306}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n\n    # Check if the hover flag is set\n    if self.hover_flag:\n        # If so, call the hover state transition function\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n        # Set the hover flag to False\n        self.hover_flag = False\n        # Set the hold flag to False\n        self.hold_flag = False\n    # Check if the hold flag is set\n    elif self.hold_flag:\n        # If so, call the hold state transition function\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n        # Set the hold flag to False\n        self.hold_flag = False\n    # If neither flag is set, set the coordinate frame to 1 and the motion type to 1\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        # Construct the target motion using the message components\n        self.target_motion = PositionTarget()\n        self.target_motion.coordinate_frame = self.coordinate_frame\n        self.target_motion.type_mask = self.motion_type\n        self.target_motion.velocity.x = msg.linear.x\n        self.target_motion.velocity.y = msg.linear.y\n        self.target_motion.velocity.z = msg.linear.z\n        self.target_motion.acceleration_or_force.x = msg.angular.x\n        self.target_motion.acceleration_or_force.y = msg.angular.y\n        self.target_motion.acceleration_or_force.z = msg.angular.z\n\n", "CodeBleu_score": 45.83271938025463}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    elif self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, \"enu\")\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_position.x = msg.linear.x\n        self.target_position.y = msg.linear.y\n        self.target_position.z = msg.linear.z\n        self.target_velocity.x = msg.angular.x\n        self.target_velocity.y = msg.angular.y\n        self.target_velocity.z = msg.angular.z\n\n", "CodeBleu_score": 47.889641004710676}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n\n    if self.flight_mode == 'HOVER':\n        if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n    else:\n        if (abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005):\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n\n", "CodeBleu_score": 72.36557432061144}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != \"HOVER\":\n        if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.set_mode_client(self.flight_mode)\n            rospy.loginfo(\"Hover state transition: flight mode set to OFFBOARD\")\n        else:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.set_mode_client(self.flight_mode)\n            rospy.loginfo(\"Hover state transition: flight mode set to HOVER\")\n\n", "CodeBleu_score": 67.80396514119934}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n\n    if self.flight_mode != \"HOVER\":\n        if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02) or (abs(w) > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.set_mode(self.flight_mode)\n\n    if self.flight_mode == \"HOVER\":\n        if (abs(x) < 0.02) and (abs(y) < 0.02) and (abs(z) < 0.02) and (abs(w) < 0.005):\n            self.hover_flag = 1\n\n    if self.hover_flag == 1:\n        self.flight_mode = \"HOVER\"\n        self.set_mode(self.flight_mode)\n\n", "CodeBleu_score": 48.556946234139374}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 24.58575872254351}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q.w, q.x, q.y, q.z).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 30.1393927143279}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw_pitch_roll[0]\n    return yaw\n\n", "CodeBleu_score": 43.33134117915923}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n\n    # Update the coordinate frame and motion type\n    self.target_pose.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.target_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ + PositionTarget.FORCE\n\n    # Construct a target motion using the current position and yaw values\n    self.target_pose.position.x = self.current_pose.pose.position.x\n    self.target_pose.position.y = self.current_pose.pose.position.y\n    self.target_pose.position.z = self.current_pose.pose.position.z\n    self.target_pose.orientation.x = self.current_pose.pose.orientation.x\n    self.target_pose.orientation.y = self.current_pose.pose.orientation.y\n    self.target_pose.orientation.z = self.current_pose.pose.orientation.z\n    self.target_pose.orientation.w = self.current_pose.pose.orientation.w\n    self.target_pose.velocity.x = 0\n    self.target_pose.velocity.y = 0\n    self.target_pose.velocity.z = 0\n    self.target_pose.acceleration_or_force.x = 0\n    self.target_pose.acceleration_or_force.y = 0\n    self.target_pose.acceleration_or_force.z = 0\n\n    # Send the target motion to the vehicle\n    self.set_pose_target_velocity_body(self.target_pose)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    rospy.loginfo(\"Vehicle type: \" + self.vehicle_type + \" with ID: \" + self.vehicle_id + \" is now in hover mode.\")\n\n", "CodeBleu_score": 28.734991735097402}, {"code": "def hover(self)\n\t\n    # Set the coordinate frame and motion type\n    self.target.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.target.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE\n\n    # Construct the target message\n    self.target.position.x = self.position.x\n    self.target.position.y = self.position.y\n    self.target.position.z = self.position.z\n    self.target.yaw = self.yaw\n\n    # Send the target message\n    self.set_position_target_local_ned_service(self.target)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    rospy.loginfo(\"Vehicle type: %s, Vehicle ID: %s, Flight Mode: Hover\", self.vehicle_type, self.vehicle_id)\n\n", "CodeBleu_score": 24.956757363890475}, {"code": "def hover(self)\n\t\n    # Update the coordinate frame and motion type\n    self.target.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.target.type_mask = int('010111111000', 2)\n\n    # Construct the target message\n    self.target.position.x = self.local_pos.pose.position.x\n    self.target.position.y = self.local_pos.pose.position.y\n    self.target.position.z = self.local_pos.pose.position.z\n\n    self.target.velocity.x = 0\n    self.target.velocity.y = 0\n    self.target.velocity.z = 0\n\n    self.target.acceleration_or_force.x = 0\n    self.target.acceleration_or_force.y = 0\n    self.target.acceleration_or_force.z = 0\n\n    self.target.yaw = self.local_pos.pose.orientation.z\n    self.target.yaw_rate = 0\n\n    # Send the target message\n    self.set_mode_client(base_mode=0, custom_mode='OFFBOARD')\n    self.send_target_pose(self.target)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight mode: \", \"Hover\")\n\n", "CodeBleu_score": 25.842163345762593}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    rospy.loginfo(\"Switching flight mode to: \" + self.flight_mode)\n    if self.flight_mode == \"HOVER\":\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            rospy.loginfo(\"Switched flight mode to: \" + self.flight_mode)\n            return True\n        except rospy.ServiceException, e:\n            rospy.logerr(\"Failed to switch flight mode: \" + str(e))\n            return False\n\n", "CodeBleu_score": 41.521564233756976}, {"code": "def flight_mode_switch(self)\n\t\n    self.hover = True\n    self.hover_flag = True\n    if self.flight_mode == 'HOVER':\n        self.hover()\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            rospy.loginfo('Flight mode switched to ' + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.logerr('Failed to switch flight mode: ' + str(e))\n            return False\n\n", "CodeBleu_score": 53.23278696570597}, {"code": "def flight_mode_switch(self)\n\t\n    rospy.loginfo(\"Flight mode switch\")\n    if self.flight_mode == \"HOVER\":\n        self.hover()\n    else:\n        try:\n            rospy.loginfo(\"Switching to flight mode \" + self.flight_mode)\n            self.flightModeService(custom_mode=self.flight_mode)\n            rospy.loginfo(\"Flight mode switched to \" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.loginfo(\"Flight mode switch failed: \" + str(e))\n            return False\n\n", "CodeBleu_score": 44.12387414553097}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 51.10360294045804}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 51.10360294045804}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 51.10360294045804}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.id:\n        self.local_pose = msg\n        self.local_pose.pose.position.x -= self.global_position.position.x\n        self.local_pose.pose.position.y -= self.global_position.position.y\n        self.local_pose.pose.position.z -= self.global_position.position.z\n        if self.local_pose.pose.position.z > 1.5:\n            self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z\n            self.hover_target_pose.pose.position.z = self.local_pose.pose.position.z\n\n", "CodeBleu_score": 24.748430659746255}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        if self.takeoff_state == 1:\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.hover_state == 1:\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose.position.x = self.local_pose.position.x + self.global_position.position.x\n        self.global_pose.position.y = self.local_pose.position.y + self.global_position.position.y\n        self.global_pose.position.z = self.local_pose.position.z + self.global_position.position.z\n        self.global_pose.orientation = self.local_pose.orientation\n\n", "CodeBleu_score": 32.51742161385125}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == i:\n        self.local_pose[i] = msg\n        if self.local_pose[i].pose.position.x == 0 and self.local_pose[i].pose.position.y == 0 and self.local_pose[i].pose.position.z == 0:\n            self.local_pose[i].pose.position.x = self.local_pose[i].pose.position.x + self.local_pose[i].pose.position.x\n            self.local_pose[i].pose.position.y = self.local_pose[i].pose.position.y + self.local_pose[i].pose.position.y\n            self.local_pose[i].pose.position.z = self.local_pose[i].pose.position.z + self.local_pose[i].pose.position.z\n        if self.local_pose[i].pose.orientation.x == 0 and self.local_pose[i].pose.orientation.y == 0 and self.local_pose[i].pose.orientation.z == 0 and self.local_pose[i].pose.orientation.w == 0:\n            self.local_pose[i].pose.orientation.x = self.local_pose[i].pose.orientation.x + self.local_pose[i].pose.orientation.x\n            self.local_pose[i].pose.orientation.y = self.local_pose[i].pose.orientation.y + self.local_pose[i].pose.orientation.y\n            self.local_pose[i].pose.orientation.z = self.local_pose[i].pose.orientation.z + self.local_pose[i].pose.orientation.z\n            self.local_pose[i].pose.orientation.w = self.local_pose[i].pose.orientation.w + self.local_pose[i].pose.orientation.w\n        if self.local_pose[i].header.frame_id == \"map\":\n            self.global_pose[i] = self.local_pose[i]\n            self.global_pose[i].pose.position.x = self.global_pose[i].pose.", "CodeBleu_score": 23.72886269309724}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.position[2] > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 55.51174264980296}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.position[2] > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 55.51174264980296}, {"code": "def takeoff_detection(self)\n\t\n    return self.state.armed and self.state.position[2] > 0.2\n\n", "CodeBleu_score": 34.685276541821096}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Convert the formations to numpy arrays\n    orig_formation = numpy.array(orig_formation)\n    change_formation = numpy.array(change_formation)\n    # Construct the distance matrix\n    dist_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i, j] = numpy.linalg.norm(orig_formation[i] - change_formation[j]) - 50\n    return dist_matrix\n\n", "CodeBleu_score": 24.487473218544626}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = numpy.zeros((len(orig_formation),len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i][j] = numpy.linalg.norm(orig_formation[i]-change_formation[j])-50\n    return distance_matrix\n\n", "CodeBleu_score": 26.455102436131956}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    dist_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i, j] = numpy.linalg.norm(orig_formation[i] - change_formation[j]) - 50\n    return dist_matrix\n", "CodeBleu_score": 24.716017382122814}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.left_vertex[i].visited = True\n    for j in self.right_vertex[i].adjacent:\n        if self.right_vertex[j].visited == False:\n            gap = self.right_vertex[i].label - self.left_vertex[i].label\n            if gap == 0:\n                if self.find_path(j) == True:\n                    self.right_vertex[i].visited = True\n                    self.update_match(i, j)\n                    return True\n            else:\n                if self.right_vertex[j].slack == 0 or gap < self.right_vertex[j].slack:\n                    self.right_vertex[j].slack = gap\n                    self.right_vertex[j].predecessor = i\n    return False\n\n", "CodeBleu_score": 32.0322024869037}, {"code": "def find_path(self, i)\n\t\n    # mark the left vertex as visited\n    self.graph[i][0] = 1\n    # iterate through adjacent right vertices\n    for j in range(1, self.n + 1):\n        # if the right vertex is already visited, continue\n        if self.graph[i][j] == 1:\n            continue\n        # calculate the gap between labels\n        gap = self.labels[i] - self.labels[j]\n        # if the gap is zero, mark the right vertex as visited and check if it can either find a path or update the match\n        if gap == 0:\n            self.graph[i][j] = 1\n            self.graph[j][i] = 1\n            if self.find_path(j):\n                return True\n            # if the gap is not zero, update the slack value for the right vertex\n            else:\n                self.graph[j][2] = self.graph[i][2] + self.graph[i][j]\n        # if the gap is not zero, update the slack value for the right vertex\n        else:\n            self.graph[j][2] = min(self.graph[i][2] + self.graph[i][j], gap)\n    return False\n\n", "CodeBleu_score": 36.2878421717013}, {"code": "def find_path(self, i)\n\t\n    self.visited[i] = True\n    for j in self.adj[i]:\n        if self.visited[j] == False:\n            self.gap[j] = self.gap[i] + self.label[i] - self.label[j]\n            if self.gap[j] == 0:\n                self.visited[j] = True\n                if self.find_path(j) == True:\n                    return True\n                else:\n                    self.update_match(i, j)\n            elif self.gap[j] < self.slack[j]:\n                self.slack[j] = self.gap[j]\n                self.pi[j] = i\n    return False\n\n", "CodeBleu_score": 37.10770187400705}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    # Initialization\n    n = self.n\n    m = self.m\n    slack = self.slack\n    label = self.label\n    visit = self.visit\n    UAV = self.UAV\n    UAV_ID = self.UAV_ID\n    UAV_ID_list = self.UAV_ID_list\n    UAV_ID_list_2 = self.UAV_ID_list_2\n    UAV_ID_list_3 = self.UAV_ID_list_3\n    UAV_ID_list_4 = self.UAV_ID_list_4\n    UAV_ID_list_5 = self.UAV_ID_list_5\n    UAV_ID_list_6 = self.UAV_ID_list_6\n    UAV_ID_list_7 = self.UAV_ID_list_7\n    UAV_ID_list_8 = self.UAV_ID_list_8\n    UAV_ID_list_9 = self.UAV_ID_list_9\n    UAV_ID_list_10 = self.UAV_ID_list_10\n    UAV_ID_list_11 = self.UAV_ID_list_11\n    UAV_ID_list_12 = self.UAV_ID_list_12\n    UAV_ID_list_13 = self.UAV_ID_list_13\n    UAV_ID_list_14 = self.UAV_ID_list_14\n    UAV_ID_list_15 = self.UAV_ID_list_15\n    UAV_ID_list_16 = self.UAV_ID_list_16\n    UAV_ID_list_17 = self.UAV_ID_list_17\n    UAV_ID_list_18 = self.UAV_ID_list_18\n    UAV_ID_list_19 = self.UAV_ID_list_19\n    UAV_ID_list_20 = self.UAV_ID_list_20\n    UAV_ID_list_", "CodeBleu_score": 7.203624272272719}, {"code": "def KM(self)\n\t\n    # Initialize visit arrays\n    visit = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize slack variables\n    slack = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize label arrays\n    label = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize the label array for the right side of the bipartite graph\n    label_r = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize the label array for the left side of the bipartite graph\n    label_l = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize the label array for the left side of the bipartite graph\n    label_l_old = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize the label array for the right side of the bipartite graph\n    label_r_old = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize the label array for the right side of the bipartite graph\n    label_r_old_old = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize the label array for the left side of the bipartite graph\n    label_l_old_old = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize the label array for the right side of the bipartite graph\n    label_r_old_old_old = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize the label array for the left side of the bipartite graph\n    label_l_old_old_old = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize the label array for the right side of the bipartite graph\n    label_r_old_old_old_old = numpy.zeros((self.UAV_num, self.UAV_num))\n    # Initialize the label array for the left side of the", "CodeBleu_score": 15.634769492046408}, {"code": "def KM(self)\n\t\n    # Initialize the slack array\n    slack = numpy.zeros((self.num_uavs, self.num_tasks))\n    # Initialize the visit array\n    visit = numpy.zeros((self.num_uavs, self.num_tasks), dtype=bool)\n    # Initialize the label array\n    label = numpy.zeros((self.num_uavs, self.num_tasks), dtype=int)\n    # Initialize the slack array\n    slack_min = numpy.zeros((self.num_uavs, self.num_tasks), dtype=int)\n    # Initialize the label array\n    label_min = numpy.zeros((self.num_uavs, self.num_tasks), dtype=int)\n    # Initialize the label array\n    label_min_index = numpy.zeros((self.num_uavs, self.num_tasks), dtype=int)\n    # Initialize the label array\n    label_min_index_min = numpy.zeros((self.num_uavs, self.num_tasks), dtype=int)\n    # Initialize the label array\n    label_min_index_min_min = numpy.zeros((self.num_uavs, self.num_tasks), dtype=int)\n    # Initialize the label array\n    label_min_index_min_min_min = numpy.zeros((self.num_uavs, self.num_tasks), dtype=int)\n    # Initialize the label array\n    label_min_index_min_min_min_min = numpy.zeros((self.num_uavs, self.num_tasks), dtype=int)\n    # Initialize the label array\n    label_min_index_min_min_min_min_min = numpy.zeros((self.num_uavs, self.num_tasks), dtype=int)\n    # Initialize the label array\n    label_min_index_min_min_min_min_min_min = numpy.zeros((self.num_uavs, self.num_tasks), dtype=int)\n    # Initialize the label array\n    label_min_index_min_min_min_min_min_min_min = numpy", "CodeBleu_score": 14.539911040046983}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = (20, 100, 100)\n    upper_yellow = (30, 255, 255)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 46.45006548587249}, {"code": "def yellow_dectection(image)\n\t\n    hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = (20, 100, 100)\n    upper_yellow = (30, 255, 255)\n    mask = cv2.inRange(hsv_img, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 43.970625118446435}, {"code": "def yellow_dectection(image)\n\t\n\n    # Converting the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Creating a mask for yellow color\n    mask = cv2.inRange(hsv, (20, 100, 100), (30, 255, 255))\n\n    # Applying the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 21.084117785810303}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tstd::stringstream ss;\n\tss << \"Tag ID \" << tagID << \" not found in standalone_tag_descriptions_ map.\";\n\tif (printWarning) {\n\t\tROS_WARN_STREAM(ss.str());\n\t}\n\treturn false;\n}", "CodeBleu_score": 15.773356290772195}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    const std::map<int, TagDescription> &standalone_tag_descriptions,\n    int id,\n    TagDescription &descriptionContainer,\n    bool printWarning\n}", "CodeBleu_score": 5.284850833862049}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n\tif (standalone_tag_descriptions_.find(id) != standalone_tag_descriptions_.end()) {\n\n\t\tdescriptionContainer = standalone_tag_descriptions_[id];\n\n\t\treturn true;\n\n\t} else if (printWarning) {\n\n\t\tROS_WARN_STREAM(\"Standalone tag description not found for ID \" << id);\n\n\t}\n\n\treturn false;\n\n}", "CodeBleu_score": 28.545077238920495}]}
