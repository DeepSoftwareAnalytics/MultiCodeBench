{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bDescriptorType != desc_id) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc\n\t\t\t\t+ desc->bLength);\n\t\tif (desc->bLength == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn desc;\n}", "CodeBleu_score": 28.99757303344282}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)desc +\n\t\t\t\tdesc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 35.389005083118064}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc != NULL) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc +\n\t\t\t\tdesc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 39.87800649378508}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (udc_configured && iface_num < USBD_MAX_NUM_INTERFACES) {\n\t\tusb_descriptor_configuration_t *config_desc = (usb_descriptor_configuration_t *)&udc_configuration_descriptor;\n\t\tusb_descriptor_interface_t *iface_desc = (usb_descriptor_interface_t *)(config_desc->bLength + config_desc);\n\t\tuint8_t iface_count = 0;\n\t\twhile (iface_count < config_desc->bNumInterfaces) {\n\t\t\tif (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tiface_desc = (usb_descriptor_interface_t *)((iface_desc->bLength + iface_desc) + iface_desc->bNumEndpoints);\n\t\t\tiface_count++;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 37.87124458521026}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (udc_config_desc == NULL || iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\tuint8_t *desc = (uint8_t *)udc_config_desc;\n\twhile (desc < (uint8_t *)udc_config_desc + udc_config_desc->wTotalLength) {\n\t\tif (desc[1] == USB_DESC_INTERFACE) {\n\t\t\tif (desc[2] == iface_num && desc[3] == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdesc += desc[0];\n\t}\n\treturn false;\n}", "CodeBleu_score": 32.286097580586436}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (udc_current_config == NULL) {\n\t\treturn false;\n\t}\n\tif (iface_num >= udc_current_config->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tuint8_t *desc = udc_current_config->desc;\n\tuint8_t desc_len = udc_current_config->desc_len;\n\tuint8_t *desc_end = desc + desc_len;\n\n\twhile (desc < desc_end) {\n\t\tif (desc[1] == USB_DESC_INTERFACE) {\n\t\t\tif (desc[2] == iface_num && desc[3] == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdesc += desc[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 32.13656854692179}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = (uint8_t)((uint16_t)udc_req_setup.wIndex & 0x0F);\n\tuint8_t ep_status = 0;\n\n\tif (udc_req_setup.wLength != 2) {\n\t\treturn false;\n\t}\n\n\tif (udc_ep_get_halt_status(ep_num)) {\n\t\tep_status = 1;\n\t}\n\n\tudc_req_response.payload[0] = ep_status;\n\tudc_req_response.payload[1] = ep_status;\n\tudc_req_response.payload_size = 2;\n\n\treturn true;\n}", "CodeBleu_score": 35.61475766572595}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint16_t ep_addr;\n\tuint16_t ep_num;\n\tuint16_t ep_status;\n\tuint8_t *payload;\n\n\t/* get the endpoint address */\n\tep_addr = udc_req_get_addr();\n\n\t/* get the endpoint number */\n\tep_num = udc_ep_addr_to_num(ep_addr);\n\n\t/* get the endpoint status */\n\tep_status = udc_ep_get_status(ep_num);\n\n\t/* get the request payload */\n\tpayload = udc_req_get_payload();\n\n\t/* check if the request length matches the size of the endpoint status variable */\n\tif (udc_req_get_length() != 2) {\n\t\treturn false;\n\t}\n\n\t/* set the response payload */\n\tpayload[0] = (ep_status >> 8) & 0xFF;\n\tpayload[1] = ep_status & 0xFF;\n\n\t/* set the response length */\n\tudc_req_set_length(2);\n\n\t/* set the response status */\n\tudc_req_set_status(UDC_REQ_STATUS_OK);\n\n\treturn true;\n}", "CodeBleu_score": 32.19161201207926}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num;\n\tuint8_t ep_status;\n\tuint8_t ep_num_bits;\n\tuint8_t *response_payload;\n\tuint8_t response_payload_len;\n\n\tep_num = udc_req_get_w_value() & 0x0F;\n\tif (udc_req_get_w_length() != 2) {\n\t\treturn false;\n\t}\n\n\tif (ep_num == 0) {\n\t\tep_status = (udc_ep0_state == UDC_EP0_STATE_STALLED) ? 1 : 0;\n\t} else {\n\t\tep_num_bits = 1 << (ep_num - 1);\n\t\tep_status = (udc_ep_state & ep_num_bits) ? 1 : 0;\n\t}\n\n\tresponse_payload = udc_req_get_response_payload();\n\tresponse_payload_len = udc_req_get_response_payload_len();\n\tif (response_payload_len < 2) {\n\t\treturn false;\n\t}\n\n\tresponse_payload[0] = ep_status;\n\tresponse_payload[1] = 0;\n\tudc_req_set_response_payload_len(2);\n\treturn true;\n}", "CodeBleu_score": 40.144303070752116}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface = UDC_SETUP_REQUEST.wIndex;\n\tuint8_t alt = UDC_SETUP_REQUEST.wValue;\n\tif (!udc_configured || iface >= UDC_NUM_INTERFACES) {\n\t\treturn false;\n\t}\n\tudi_interfaces_conf_t *p = &udi_interfaces_conf[iface];\n\tif (p->udi_desc->bInterfaceNumber != iface) {\n\t\treturn false;\n\t}\n\tif (p->udi_desc->bAlternateSetting != alt) {\n\t\treturn false;\n\t}\n\tudi_interfaces_conf_t *p_default = &udi_interfaces_conf[iface];\n\tif (p_default->udi_desc->bAlternateSetting == alt) {\n\t\treturn false;\n\t}\n\tp->udi_desc->bAlternateSetting = alt;\n\tp_default->udi_desc->bAlternateSetting = 0;\n\tif (p->udi_desc->bInterfaceClass == 0xFF) {\n\t\treturn true;\n\t}\n\treturn p->udi_api->setup(p->udi_desc, alt);\n}", "CodeBleu_score": 50.069858858194635}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface = (uint8_t)(UDC_SETUP_REQUEST_VALUE & 0xFF);\n\tuint8_t alt = (uint8_t)(UDC_SETUP_REQUEST_INDEX & 0xFF);\n\n\tif (UDC_DEVICE_STATE != CONFIGURED_STATE) {\n\t\treturn false;\n\t}\n\n\tif (iface >= UDI_END_OF_INTERFACE) {\n\t\treturn false;\n\t}\n\n\tif (alt > 0) {\n\t\tif (udi_get_alt_setting(iface) == alt) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (udi_get_alt_setting(iface) != 0) {\n\t\tudi_set_alt_setting(iface, 0);\n\t}\n\n\tif (udi_get_alt_setting(iface) != alt) {\n\t\tudi_set_alt_setting(iface, alt);\n\t}\n\n\tif (udi_get_alt_setting(iface) != alt) {\n\t\treturn false;\n\t}\n\n\treturn udi_setup_request();\n}", "CodeBleu_score": 48.36339504452995}, {"code": "static bool udc_req_iface(void){\n\t\tif (UDC_STATE == UDC_STATE_CONFIGURED) {\n\t\tif (UDC_IFACE_NUM == UDC_SETUP_IFNUM) {\n\t\t\tif (UDC_SETUP_IFNUM == UDI_ENDPOINT_IN(0)) {\n\t\t\t\tif (UDC_SETUP_ALT == 0) {\n\t\t\t\t\tUDC_SETUP_IFNUM = UDC_IFACE_NUM;\n\t\t\t\t\tUDC_SETUP_ALT = 0;\n\t\t\t\t\tudi_setup_t *setup = (udi_setup_t *)UDC_SETUP_BUF;\n\t\t\t\t\tsetup->wIndex = UDC_SETUP_IFNUM;\n\t\t\t\t\tsetup->wValue = UDC_SETUP_ALT;\n\t\t\t\t\tif (udi_setup_call_t(setup)) {\n\t\t\t\t\t\tUDC_SETUP_STATUS = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tUDC_SETUP_IFNUM = UDC_IFACE_NUM;\n\t\t\t\t\tUDC_SETUP_ALT = 0;\n\t\t\t\t\tudi_setup_t *setup = (udi_setup_t *)UDC_SETUP_BUF;\n\t\t\t\t\tsetup->wIndex = UDC_SETUP_IFNUM;\n\t\t\t\t\tsetup->wValue = UDC_SETUP_ALT;\n\t\t\t\t\tif (udi_setup_call_t(setup)) {\n\t\t\t\t\t\tUDC_SETUP_STATUS = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (UDC_SETUP_ALT == 0) {\n\t\t\t\t\tUDC_SETUP_IFNUM = UDC_IFACE_NUM;\n\t\t\t\t\tUDC_SETUP_ALT = 0;\n\t\t\t\t\tudi_setup_t *setup", "CodeBleu_score": 32.45806462741766}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\t// Initialize the MSC interface\n\tudi_msc_init();\n\n\t// Get the number of Logical Unit Numbers (LUNs)\n\tlun_number = udi_msc_get_lun();\n\n\t// Check if there are any LUNs available\n\tif (lun_number == 0) {\n\t\treturn false;\n\t}\n\n\t// Unload the medium on each LUN\n\tfor (uint8_t i = 0; i < lun_number; i++) {\n\t\tudi_msc_unload_medium(i);\n\t}\n\n\t// Start the MSC process\n\tudi_msc_start();\n\n\treturn true;\n}", "CodeBleu_score": 30.945356792094586}, {"code": "bool udi_msc_enable(void){\n\t\t// Check if the USB MSC interface is already enabled\n\tif (udi_msc_enabled()) {\n\t\treturn true;\n\t}\n\n\t// Initialize the MSC interface\n\tudi_msc_init();\n\n\t// Get the number of LUNs\n\tuint8_t nb_lun = udi_msc_get_lun();\n\n\t// Check if there is at least one LUN available\n\tif (nb_lun == 0) {\n\t\treturn false;\n\t}\n\n\t// Unload the medium on each LUN\n\tfor (uint8_t i = 0; i < nb_lun; i++) {\n\t\tudi_msc_unload_medium(i);\n\t}\n\n\t// Enable the USB MSC interface\n\tudi_msc_enable();\n\n\t// Wait for a CBW reception\n\tudi_msc_wait_for_cbw();\n\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 39.34718939253406}, {"code": "bool udi_msc_enable(void){\n\t\t// Check if the LUNs are available\n\tif (udi_msc_get_lun_num() == 0) {\n\t\t// No LUNs available\n\t\treturn false;\n\t}\n\n\t// Unload the medium on each LUN\n\tfor (uint8_t i = 0; i < UDI_MSC_LUN_NUM; i++) {\n\t\tudi_msc_unload_medium(i);\n\t}\n\n\t// Enable the MSC interface\n\treturn udi_msc_enable_ext();\n}", "CodeBleu_score": 26.509988642207784}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(nb_sent);\n\tUNUSED(ep);\n\n\tif (status != UDD_EP_TRANSFER_OK) {\n\t\tudi_msc_csw_fail(UDI_MSC_CSW_PHASE_ERROR);\n\t\treturn;\n\t}\n\n\t// Update CSW data residue\n\tudi_msc_cbw.dDataResidue -= udi_msc_data_length;\n\n\t// Update sense data\n\tudi_msc_sense_data.SenseKey = UDI_MSC_SENSE_NO_SENSE;\n\tudi_msc_sense_data.AdditionalSenseCode = UDI_MSC_ASC_NO_ADDITIONAL_SENSE_INFORMATION;\n\tudi_msc_sense_data.AdditionalSenseQualifier = UDI_MSC_ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;\n\n\t// Process CSW\n\tudi_msc_process_csw();\n}", "CodeBleu_score": 52.98526551171771}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(ep);\n\tUNUSED(nb_sent);\n\n\t// Check status of transfer\n\tif (status != UDD_EP_TRANSFER_OK) {\n\t\t// If error, send CSW with error code\n\t\tudi_msc_csw_send(MSC_CSW_PHASE_ERROR);\n\t}\n\n\t// If no error, update sense data\n\tudi_msc_update_sense();\n\n\t// Decrease residue in CSW\n\tudi_msc_csw_residue_dec(nb_sent);\n\n\t// If no residue, send CSW\n\tif (udi_msc_csw_residue_is_zero()) {\n\t\tudi_msc_csw_send(MSC_CSW_PHASE_COMMAND);\n\t}\n}", "CodeBleu_score": 51.32060491253891}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tuint8_t *data_ptr;\n\tuint8_t *data_ptr_prev;\n\tuint16_t nb_data;\n\tuint16_t nb_data_prev;\n\tuint16_t nb_data_tot;\n\tuint16_t nb_data_tot_prev;\n\tuint16_t nb_data_tot_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t nb_data_tot_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev", "CodeBleu_score": 16.3091047014642}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\t// Check if the CSW is valid\n\tif (udi_msc_csw.dCSWDataResidue != 0) {\n\t\t// Check if the CSW has an error\n\t\tif (udi_msc_cbw.bCSWStatus != 0) {\n\t\t\t// Stall the IN endpoint\n\t\t\tudi_msc_stall_in_endpoint();\n\t\t} else {\n\t\t\t// Stall the OUT endpoint\n\t\t\tudi_msc_stall_out_endpoint();\n\t\t}\n\t}\n\n\t// Prepare the CSW\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n\tudi_msc_csw.bCSWStatus = udi_msc_cbw.bCSWStatus;\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\n\t// Convert the CSW data residue to little-endian format\n\tudi_msc_csw.dCSWDataResidue = udi_le16_to_cpu(udi_msc_csw.dCSWDataResidue);\n\n\t// Send the CSW\n\tudi_msc_send_csw();\n}", "CodeBleu_score": 50.94180185173916}, {"code": "static void udi_msc_csw_process(void){\n\t\tif (udi_msc_cbw.dCBWDataTransferLength != 0) {\n\t\tif (udi_msc_cbw.bmCBWFlags & MSC_CBW_DIRECTION_IN) {\n\t\t\tudi_msc_trans_in_ack();\n\t\t} else {\n\t\t\tudi_msc_trans_out_ack();\n\t\t}\n\t}\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_swap_data(udi_msc_csw.dCSWDataResidue);\n\tudi_msc_csw.bCSWStatus = MSC_CSW_COMMAND_PASSED;\n\tudi_msc_trans_in_ack();\n}", "CodeBleu_score": 51.84006790255997}, {"code": "static void udi_msc_csw_process(void){\n\t\t// If there is a non-zero data residue, stall the next request on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW)\n\tif (udi_msc_csw.dCSWDataResidue) {\n\t\tif (udi_msc_cbw.bmCBWFlags & 0x80) {\n\t\t\tudi_msc_stall_out_ep(udi_msc_cbw.bCBWLUN);\n\t\t} else {\n\t\t\tudi_msc_stall_in_ep(udi_msc_cbw.bCBWLUN);\n\t\t}\n\t}\n\n\t// Prepare the CSW by setting its tag and converting the data residue to little-endian format\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_swap_data(udi_msc_csw.dCSWDataResidue);\n\n\t// Send the CSW\n\tudi_msc_send_csw();\n}", "CodeBleu_score": 57.93902272964131}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port == 0) {\n\t\tif (b_enable) {\n\t\t\t// DTR is enabled\n\t\t\t// Cancel any pending reset\n\t\t\tcancelReset();\n\t\t} else {\n\t\t\t// DTR is disabled\n\t\t\t// Schedule a reset\n\t\t\tscheduleReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 23.798138824160507}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (b_enable) {\n        if (dtr_rate_1200[port] == true) {\n            cancelReset(port);\n        }\n    } else {\n        if (dtr_rate_1200[port] == true) {\n            scheduleReset(port);\n        }\n    }\n    dtr_rate_1200[port] = b_enable;\n}", "CodeBleu_score": 42.3398603556864}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\n    // Get the DTR status\n    bool b_dtr = false;\n    usb_task_cdc_get_dtr(port, &b_dtr);\n\n    // Update the DTR status\n    if (b_enable) {\n        usb_task_cdc_set_dtr_status(port, b_dtr);\n    }\n    else {\n        usb_task_cdc_set_dtr_status(port, false);\n    }\n\n    // Check if the DTR rate is 1200\n    if (usb_task_cdc_get_dtr_rate(port) == 1200) {\n\n        // If the DTR signal is disabled, schedule a delayed system reset\n        if (!b_dtr) {\n            usb_task_cdc_schedule_reset(port);\n        }\n        // If the DTR signal is enabled, cancel any scheduled reset\n        else {\n            usb_task_cdc_cancel_reset(port);\n        }\n    }\n}", "CodeBleu_score": 38.60424371197889}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t  // Check request type\n  if (USB_REQ_TYPE_VENDOR == (usb_setup.bmRequestType & USB_REQ_TYPE_MASK)) {\n    // Check request index\n    if (usb_setup.bRequest == 0x04) {\n      // Set pointer and size for Microsoft-compatible ID descriptor\n      usb_setup.wLength = sizeof(usb_microsoft_compatible_id_descriptor);\n      usb_setup.wValue = 0x0000;\n      usb_setup.wIndex = 0x0000;\n      usb_setup.wLength = sizeof(usb_microsoft_compatible_id_descriptor);\n      usb_setup.wValue = 0x0000;\n      usb_setup.wIndex = 0x0000;\n      usb_setup.wLength = sizeof(usb_microsoft_compatible_id_descriptor);\n      usb_setup.wValue = 0x0000;\n      usb_setup.wIndex = 0x0000;\n      return true;\n    }\n    else if (usb_setup.bRequest == 0x05) {\n      // Set pointer and size for extended properties descriptor\n      usb_setup.wLength = sizeof(usb_extended_properties_descriptor);\n      usb_setup.wValue = 0x0000;\n      usb_setup.wIndex = 0x0000;\n      usb_setup.wLength = sizeof(usb_extended_properties_descriptor);\n      usb_setup.wValue = 0x0000;\n      usb_setup.wIndex = 0x0000;\n      usb_setup.wLength = sizeof(usb_extended_properties_descriptor);\n      usb_setup.wValue = 0x0000;\n      usb_setup.wIndex = 0x0000;\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 32.35515477544131}, {"code": "bool usb_task_other_requests(void){\n\t    uint8_t *payload = usb_control_request_payload;\n    uint8_t size = usb_control_request_size;\n    uint8_t request = usb_control_request_request;\n    uint8_t request_type = usb_control_request_request_type;\n    uint8_t request_index = usb_control_request_request_index;\n    uint8_t request_index_2 = usb_control_request_request_index_2;\n    uint8_t request_length = usb_control_request_length;\n    uint8_t request_length_2 = usb_control_request_length_2;\n    uint8_t request_length_3 = usb_control_request_length_3;\n\n    if (request_type == 0x00) {\n        // Standard request\n        if (request_index == 0x06) {\n            // SET_ADDRESS\n            if (request_length != 0) {\n                return false;\n            }\n            usb_control_request_payload = NULL;\n            usb_control_request_size = 0;\n            usb_control_request_length = 0;\n            usb_control_request_length_2 = 0;\n            usb_control_request_length_3 = 0;\n            usb_control_request_request_index = 0;\n            usb_control_request_request_index_2 = 0;\n            usb_control_request_request = 0;\n            usb_control_request_request_type = 0;\n            usb_control_request_type = 0;\n            usb_control_request_type_recipient = 0;\n            usb_control_request_type_direction = 0;\n            usb_control_request_type_type = 0;\n            usb_control_request_type_zero = 0;\n            usb_control_request_type_index = 0;\n            usb_control_request_type_length = 0;\n            usb_control_request_type_value = 0;\n", "CodeBleu_score": 9.691907837887653}, {"code": "bool usb_task_other_requests(void){\n\t\t// Check the request type\n\tif (usb_request_type == USB_REQUEST_TYPE_STANDARD) {\n\t\t// Standard request\n\t\tswitch (usb_request_index) {\n\t\t\tcase USB_REQUEST_INDEX_GET_DESCRIPTOR:\n\t\t\t\t// Get descriptor request\n\t\t\t\t// Check the request recipient\n\t\t\t\tif (usb_request_recipient == USB_REQUEST_RECIPIENT_DEVICE) {\n\t\t\t\t\t// Device descriptor\n\t\t\t\t\tif (usb_request_value == 0x0100) {\n\t\t\t\t\t\t// Device descriptor\n\t\t\t\t\t\tusb_request_size = sizeof(usb_device_descriptor);\n\t\t\t\t\t\tusb_request_payload = (uint8_t *)&usb_device_descriptor;\n\t\t\t\t\t} else if (usb_request_value == 0x0200) {\n\t\t\t\t\t\t// Configuration descriptor\n\t\t\t\t\t\tusb_request_size = sizeof(usb_configuration_descriptor);\n\t\t\t\t\t\tusb_request_payload = (uint8_t *)&usb_configuration_descriptor;\n\t\t\t\t\t} else if (usb_request_value == 0x0300) {\n\t\t\t\t\t\t// String descriptor\n\t\t\t\t\t\tusb_request_size = sizeof(usb_string_descriptor_0);\n\t\t\t\t\t\tusb_request_payload = (uint8_t *)&usb_string_descriptor_0;\n\t\t\t\t\t} else if (usb_request_value == 0x0409) {\n\t\t\t\t\t\t// Microsoft OS descriptor\n\t\t\t\t\t\tusb_request_size = sizeof(usb_microsoft_os_descriptor);\n\t\t\t\t\t\tusb_request_payload = (uint8_t *)&usb_microsoft_os_descriptor;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Unknown descriptor\n\t\t\t\t\t\tusb_request_size = 0;\n\t\t\t\t\t", "CodeBleu_score": 26.934870316309762}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0) {\n        return;\n    }\n    uint16_t i;\n    for (i = 0; i < nbyte; i++) {\n        *buf = spiRec();\n        buf++;\n    }\n    *buf = spiRec();\n}", "CodeBleu_score": 48.01027893405851}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\tfor (i = 0; i < nbyte; i++) {\n\t\tSPDR = 0xFF;\n\t\twhile (!(SPSR & (1 << SPIF)));\n\t\tbuf[i] = SPDR;\n\t}\n\tspiRec();\n}", "CodeBleu_score": 40.73988879200944}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint8_t i;\n\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPDR = 0xFF;\n\t\twhile (!(SPSR & (1 << SPIF)));\n\t\tbuf[i] = SPDR;\n\t}\n\tSPDR = 0xFF;\n\twhile (!(SPSR & (1 << SPIF)));\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 46.184997734444075}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n    uint32_t *vectors = (uint32_t *)SCB->VTOR;\n\n    /* Disable interrupts */\n    __disable_irq();\n\n    /* Get current handler */\n    oldHandler = (pfnISR_Handler)vectors[irq];\n\n    /* Set new handler */\n    vectors[irq] = (uint32_t)newHandler;\n\n    /* Enable interrupts */\n    __enable_irq();\n\n    /* Return old handler */\n    return oldHandler;\n}", "CodeBleu_score": 50.849540465152266}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n    uint32_t *vectors = (uint32_t *)SCB->VTOR;\n    uint32_t *irqVector = (uint32_t *)(vectors + irq);\n    uint32_t irqPriority = NVIC_GetPriority(irq);\n\n    __disable_irq();\n    oldHandler = (pfnISR_Handler)irqVector[0];\n    irqVector[0] = (uint32_t)newHandler;\n    NVIC_SetPriority(irq, irqPriority);\n    __enable_irq();\n\n    return oldHandler;\n}", "CodeBleu_score": 46.548523682016075}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler = 0;\n\tuint32_t *vector_table = (uint32_t*)SCB->VTOR;\n\tuint32_t *irq_handler = (uint32_t*)&vector_table[irq];\n\tif (irq < 16) {\n\t\toldHandler = (pfnISR_Handler)irq_handler[0];\n\t\tirq_handler[0] = (uint32_t)newHandler;\n\t} else {\n\t\toldHandler = (pfnISR_Handler)irq_handler[1];\n\t\tirq_handler[1] = (uint32_t)newHandler;\n\t}\n\treturn oldHandler;\n}", "CodeBleu_score": 41.11060727392698}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_configuration) {\n    if (usb_serial_buffer_head != usb_serial_buffer_tail) {\n      return usb_serial_buffer[usb_serial_buffer_tail];\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 17.62813626268581}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (USB_Available()) {\n    if (emergency_parser_enabled) {\n      if (emergency_parser_state == 0) {\n        if (USB_RX_BUFFER == 0x18) {\n          emergency_parser_state = 1;\n          return 0;\n        }\n      }\n      else if (emergency_parser_state == 1) {\n        if (USB_RX_BUFFER == 0x95) {\n          emergency_parser_state = 2;\n          return 0;\n        }\n      }\n      else if (emergency_parser_state == 2) {\n        if (USB_RX_BUFFER == 0x18) {\n          emergency_parser_state = 3;\n          return 0;\n        }\n      }\n      else if (emergency_parser_state == 3) {\n        if (USB_RX_BUFFER == 0x95) {\n          emergency_parser_state = 4;\n          return 0;\n        }\n      }\n      else if (emergency_parser_state == 4) {\n        if (USB_RX_BUFFER == 0x18) {\n          emergency_parser_state = 5;\n          return 0;\n        }\n      }\n      else if (emergency_parser_state == 5) {\n        if (USB_RX_BUFFER == 0x95) {\n          emergency_parser_state = 6;\n          return 0;\n        }\n      }\n      else if (emergency_parser_state == 6) {\n        if (USB_RX_BUFFER == 0x18) {\n          emergency_parser_state = 7;\n          return 0;\n        }\n      }\n      else if (emergency_parser_state == 7) {\n        if (USB_RX_BUFFER == 0x95) {\n          emergency_parser_state = 8;\n          return 0;\n        }\n      }\n      else if (emergency_parser_state ==", "CodeBleu_score": 35.98923057220025}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_serial_available()) {\n    return usb_serial_peek();\n  }\n  return -1;\n}", "CodeBleu_score": 8.05801519905667}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  if (rx_buffer_head != rx_buffer_tail) {\n    uint8_t c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % BUFFER_SIZE;\n    return c;\n  }\n\n  if (!is_usb_enabled()) return -1;\n  if (!is_usb_configured()) return -1;\n\n  if (usb_available()) {\n    uint8_t c = usb_serial_getchar();\n    if (emergency_parser_enabled) emergency_parser_rx_byte(c);\n    return c;\n  }\n\n  return -1;\n}", "CodeBleu_score": 40.994142779154366}, {"code": "int MarlinSerialUSB::read(){\n\t  if (rx_buffer_head != rx_buffer_tail) {\n    uint8_t c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % BUFFER_SIZE;\n    return c;\n  }\n  if (!is_usb_enabled) return -1;\n  if (!is_usb_configured) return -1;\n  if (usb_available() <= 0) return -1;\n  uint8_t c = usb_serial->getc();\n  if (emergency_parser_enabled) emergency_parser.add(c);\n  return c;\n}", "CodeBleu_score": 37.172034970925885}, {"code": "int MarlinSerialUSB::read(){\n\t  int c;\n  if (rx_buffer_head != rx_buffer_tail) {\n    c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) & SERIAL_BUFFER_MASK;\n    return c;\n  }\n  if (!usb_configuration) return -1;\n  if (usb_cdc_line_rtsdtr == 0) return -1;\n  if (usb_cdc_line_rtsdtr & 2) return -1;\n  if (!(UCSR0A & _BV(RXC0))) return -1;\n  c = UDR0;\n  if (emergency_parser_enabled) emergency_parser_rx_input(c);\n  return c;\n}", "CodeBleu_score": 39.38202532766779}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (SerialUSB.available()) {\n    return SerialUSB.available();\n  }\n  else {\n    return SerialUSB.cdcAvailableForWrite();\n  }\n}", "CodeBleu_score": 39.56833474033413}, {"code": "int MarlinSerialUSB::available(){\n\t  if (USB_Available()) {\n    return USB_Available();\n  }\n  else {\n    return 0;\n  }\n}", "CodeBleu_score": 32.74944377348078}, {"code": "int MarlinSerialUSB::available(){\n\t  if (rx_buffer_head != rx_buffer_tail) {\n    // Data is in the buffer\n    return rx_buffer_head - rx_buffer_tail;\n  }\n\n  if (!(USB_DeviceState[0] == DEVICE_STATE_Configured)) {\n    // USB not configured, return 0\n    return 0;\n  }\n\n  if (USB_Device_CDC_IsReady()) {\n    // USB ready, return 0\n    return 0;\n  }\n\n  // USB not ready, return -1\n  return -1;\n}", "CodeBleu_score": 31.92254090522344}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t    for (size_t i = 0; i < size; i++) {\n        if (pos >= _size) {\n            return false;\n        }\n        if (writing) {\n            *value++ = read_byte(pos++);\n        }\n        if (crc) {\n            *crc = _crc_update(*crc, read_byte(pos++));\n        } else {\n            pos++;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 45.44561333733883}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (pos + size > _size) {\n    return false;\n  }\n\n  if (crc != nullptr) {\n    if (writing) {\n      *crc = 0;\n    }\n    for (size_t i = 0; i < size; i++) {\n      value[i] = read_byte(pos + i);\n      if (writing) {\n        *crc += value[i];\n      }\n    }\n  }\n  else {\n    for (size_t i = 0; i < size; i++) {\n      value[i] = read_byte(pos + i);\n    }\n  }\n\n  pos += size;\n  return true;\n}", "CodeBleu_score": 44.47128525214437}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (writing) {\n    while (size--) {\n      uint8_t v = read_byte(pos++);\n      if (value) *value++ = v;\n      if (crc) *crc = _crc_update(*crc, v);\n    }\n  }\n  else {\n    while (size--) {\n      uint8_t v = read_byte(pos++);\n      if (value) *value++ = v;\n      if (crc) *crc = _crc_update(*crc, v);\n    }\n  }\n  return false;\n}", "CodeBleu_score": 47.177131872538524}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\t// Check if the pin is valid\n\tif (pin >= NUM_DIGITAL_PINS) {\n\t\treturn;\n\t}\n\n\t// Check if the pin is already in use by a software PWM\n\tif (pwm_state[pin].mode == PWM_MODE_SOFTWARE) {\n\t\t// Set the PWM value\n\t\tpwm_state[pin].value = value;\n\t\tpwm_state[pin].res = res;\n\t\tpwm_state[pin].freq = freq;\n\t\tpwm_state[pin].next_update = 0;\n\t\treturn;\n\t}\n\n\t// Check if the pin is already in use by hardware PWM\n\tif (pwm_state[pin].mode == PWM_MODE_HARDWARE) {\n\t\t// Set the PWM value\n\t\tpwm_state[pin].value = value;\n\t\tpwm_state[pin].res = res;\n\t\tpwm_state[pin].freq = freq;\n\t\tpwm_state[pin].next_update = 0;\n\n\t\t// Set the PWM value\n\t\tledcWrite(pwm_state[pin].channel, value);\n\t\treturn;\n\t}\n\n\t// Check if a hardware PWM channel is available\n\tif (pwm_count < NUM_PWM_CHANNELS) {\n\t\t// Set the PWM value\n\t\tpwm_state[pin].value = value;\n\t\tpwm_state[pin].res = res;\n\t\tpwm_state[pin].freq = freq;\n\t\tpwm_state[pin].next_update = 0;\n\n\t\t// Set the PWM value\n\t\tledcWrite(pwm_count, value);\n\t\tpwm_state[pin].channel = pwm_count;\n\t\tpwm_state[pin].mode = PWM_MODE_HARDWARE;\n\t\tpwm_count++;\n\t\treturn;\n\t}\n\n\t// Check if a software P", "CodeBleu_score": 36.840621676360705}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin >= NUM_DIGITAL_PINS) return;\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value == 255) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (value > 255) {\n    #ifdef DEBUG_ESP_PORT\n      DEBUG_ESP_PORT.print(\"analogWrite: value > 255: \");\n      DEBUG_ESP_PORT.println(value);\n    #endif\n    return;\n  }\n  if (freq == 0) {\n    #ifdef DEBUG_ESP_PORT\n      DEBUG_ESP_PORT.print(\"analogWrite: freq == 0: \");\n      DEBUG_ESP_PORT.println(freq);\n    #endif\n    return;\n  }\n  if (res == 0) {\n    #ifdef DEBUG_ESP_PORT\n      DEBUG_ESP_PORT.print(\"analogWrite: res == 0: \");\n      DEBUG_ESP_PORT.println(res);\n    #endif\n    return;\n  }\n  if (pin >= NUM_DIGITAL_PINS) {\n    #ifdef DEBUG_ESP_PORT\n      DEBUG_ESP_PORT.print(\"analogWrite: pin >= NUM_DIGITAL_PINS: \");\n      DEBUG_ESP_PORT.println(pin);\n    #endif\n    return;\n  }\n  if (pin >= NUM_ANALOG_INPUTS) {\n    #ifdef DEBUG_ESP_PORT\n      DEBUG_ESP_PORT.print(\"analogWrite: pin >= NUM_ANALOG_INPUTS: \");\n      DEBUG_ESP_PORT.println(pin);\n    #endif\n    return;\n  }\n  if (value > 255) {\n    #ifdef DEBUG_ESP_PORT\n      DEBUG_ESP_PORT.print(\"analogWrite: value > 255: \");\n      DEBUG_ESP_PORT.println(value);\n    #endif\n    return;\n", "CodeBleu_score": 32.470708427550896}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (freq == 0) {\n\t\treturn;\n\t}\n\t// Try to use hardware PWM first\n\tif (ledcWrite(pin, value, freq, res)) {\n\t\treturn;\n\t}\n\t// If hardware PWM is not available, try to use software PWM\n\t// If pin is already in use, return\n\tif (pwm_state[pin].pin != pin) {\n\t\treturn;\n\t}\n\t// If pin is not in use, allocate a slot and start the timer if necessary\n\tif (pwm_state[pin].pin == pin) {\n\t\t// Allocate a slot\n\t\tpwm_state[pin].pin = pin;\n\t\tpwm_state[pin].value = value;\n\t\tpwm_state[pin].freq = freq;\n\t\tpwm_state[pin].res = res;\n\t\tpwm_state[pin].timer = 0;\n\t\tpwm_state[pin].count = 0;\n\t\tpwm_state[pin].started = false;\n\t\tpwm_state[pin].last_value = 0;\n\t\tif (pwm_count == 0) {\n\t\t\t// Start timer\n\t\t\tpwm_state[pin].timer = timerBegin(PWM_TIMER, PWM_FREQUENCY, true);\n\t\t\ttimerAttachInterrupt(pwm_state[pin].timer, &pwm_isr, true);\n\t\t\ttimerAlarmWrite(pwm_state[pin].timer, 1000000 / PWM_FREQUENCY, true);\n\t\t\ttimerAlarmEnable(pwm_state[pin].timer);\n\t\t\tpwm_count++;\n\t\t}\n\t}\n\t// Set the PWM value\n\tpwm_state[pin].value = value;\n}", "CodeBleu_score": 34.27693812688912}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  if (value < 0 || value > 180) {\n    Serial.println(\"Error: Servo value out of bounds\");\n    return;\n  }\n\n  if (value == current_value) {\n    return;\n  }\n\n  current_value = value;\n\n  if (servo_delay_array_length != 0) {\n    if (servo_delay_array_length != SERVO_DELAY_ARRAY_LENGTH) {\n      static_assert(false, \"Error: servo_delay_array_length does not match SERVO_DELAY_ARRAY_LENGTH\");\n    }\n\n    if (servo_channel < 0 || servo_channel >= servo_delay_array_length) {\n      Serial.println(\"Error: Servo channel out of bounds\");\n      return;\n    }\n\n    if (!servo.attach(servo_pin, value)) {\n      Serial.println(\"Error: Servo failed to attach\");\n      return;\n    }\n\n    delay(servo_delay_array[servo_channel]);\n\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      servo.detach();\n    }\n  } else {\n    if (!servo.attach(servo_pin, value)) {\n      Serial.println(\"Error: Servo failed to attach\");\n      return;\n    }\n\n    delay(DEFAULT_SERVO_DELAY);\n\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      servo.detach();\n    }\n  }\n}", "CodeBleu_score": 43.22372930883288}, {"code": "void Servo::move(const int value){\n\t  // Verify the servo delay array length\n  static_assert(sizeof(servoDelay) == sizeof(servoDelay) / sizeof(servoDelay[0]), \"The length of the servo delay array is not the same as the number of servo channels\");\n\n  // Attach the servo if it is not already attached\n  if (!servoAttached) {\n    servo.attach(servoPin);\n    servoAttached = true;\n  }\n\n  // Move the servo to the desired value\n  servo.write(value);\n\n  // Wait for the specified delay\n  delay(servoDelay[servoChannel]);\n\n  // Detach the servo if the \"DEACTIVATE_SERVOS_AFTER_MOVE\" condition is enabled\n  #if DEACTIVATE_SERVOS_AFTER_MOVE\n    servo.detach();\n    servoAttached = false;\n  #endif\n}", "CodeBleu_score": 45.93881872850123}, {"code": "void Servo::move(const int value){\n\t    static_assert(SERVO_DELAY_ARRAY_LENGTH == 16, \"The length of the servo delay array must be 16.\");\n    if (servo.attach(servoPin)) {\n        servo.write(value);\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n            servo.detach();\n        }\n        delay(servoDelay[servoChannel]);\n    }\n}", "CodeBleu_score": 50.44824187026962}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t  // Update PWM states\n  for (uint8_t i = 0; i < NUM_PINS; i++) {\n    if (pins[i].duty_cycle > 0) {\n      pins[i].duty_cycle--;\n      if (pins[i].duty_cycle == 0) {\n        pins[i].state = !pins[i].state;\n        pins[i].duty_cycle = pins[i].period;\n      }\n    }\n  }\n\n  // Write port data to DMA buffer\n  for (uint8_t i = 0; i < NUM_PINS; i++) {\n    if (pins[i].port_data == 0) {\n      dma_buffer[dma_buffer_pos] = 0;\n    } else {\n      dma_buffer[dma_buffer_pos] = 1;\n    }\n    dma_buffer_pos++;\n    if (dma_buffer_pos == DMA_BUFFER_SIZE) {\n      dma_buffer_pos = 0;\n    }\n  }\n}", "CodeBleu_score": 34.58089381996835}, {"code": "void i2s_push_sample(){\n\t    int i;\n    uint16_t pwm_data;\n    uint8_t pwm_data_high, pwm_data_low;\n    uint8_t pwm_data_high_prev, pwm_data_low_prev;\n    uint8_t pwm_data_high_next, pwm_data_low_next;\n    uint8_t pwm_data_high_next_prev, pwm_data_low_next_prev;\n    uint8_t pwm_data_high_next_next, pwm_data_low_next_next;\n    uint8_t pwm_data_high_next_next_prev, pwm_data_low_next_next_prev;\n\n    for (i = 0; i < 8; i++) {\n        pwm_data_high = 0;\n        pwm_data_low = 0;\n        pwm_data_high_prev = 0;\n        pwm_data_low_prev = 0;\n        pwm_data_high_next = 0;\n        pwm_data_low_next = 0;\n        pwm_data_high_next_prev = 0;\n        pwm_data_low_next_prev = 0;\n        pwm_data_high_next_next = 0;\n        pwm_data_low_next_next = 0;\n        pwm_data_high_next_next_prev = 0;\n        pwm_data_low_next_next_prev = 0;\n\n        pwm_data = pwm_data_high | pwm_data_low;\n\n        if (pwm_tick_count[i] == 0) {\n            pwm_tick_count[i] = pwm_period[i];\n            if (pwm_state[i] == 0) {\n                pwm_state[i] = 1;\n            } else {\n                pwm_state[i] = 0;\n", "CodeBleu_score": 28.335361730213016}, {"code": "void i2s_push_sample(){\n\t\tuint8_t i;\n\tuint8_t j;\n\tuint8_t k;\n\tuint8_t pwm_count;\n\tuint8_t pwm_state;\n\tuint8_t pwm_tick_count;\n\tuint8_t pwm_tick_period;\n\tuint8_t pwm_tick_period_offset;\n\tuint8_t pwm_duty_cycle;\n\tuint8_t pwm_duty_cycle_offset;\n\tuint8_t pwm_duty_cycle_offset_mask;\n\tuint8_t pwm_duty_cycle_mask;\n\tuint8_t pwm_duty_cycle_mask_offset;\n\tuint8_t pwm_duty_cycle_mask_offset_mask;\n\tuint8_t pwm_duty_cycle_mask_offset_mask_offset;\n\tuint8_t pwm_duty_cycle_mask_offset_mask_offset_mask;\n\tuint8_t pwm_duty_cycle_mask_offset_mask_offset_mask_offset;\n\tuint8_t pwm_duty_cycle_mask_offset_mask_offset_mask_offset_mask;\n\tuint8_t pwm_duty_cycle_mask_offset_mask_offset_mask_offset_mask_offset;\n\tuint8_t pwm_duty_cycle_mask_offset_mask_offset_mask_offset_mask_offset_mask;\n\tuint8_t pwm_duty_cycle_mask_offset_mask_offset_mask_offset_mask_offset_mask_offset;\n\tuint8_t pwm_duty_cycle_mask_offset_mask_offset_mask_offset_mask_offset_mask_offset_mask;\n\tuint8_t pwm_duty_cycle_mask_offset_mask_offset_mask_offset_mask_offset_mask_offset_mask_offset;\n\tuint8_t pwm_duty_cycle_mask_offset", "CodeBleu_score": 5.658308850820309}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t count;\n\n    if (timer_num >= HAL_TIMER_COUNT) {\n        return 0;\n    }\n\n    count = HAL_timer_get_count_internal(timer_num);\n\n    return count;\n}", "CodeBleu_score": 34.46213525143491}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t timer_count;\n\n    if (timer_num > 3) {\n        return 0;\n    }\n\n    timer_count = hal_timer_count[timer_num];\n\n    return timer_count;\n}", "CodeBleu_score": 37.65730401046395}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t timer_count;\n\n    if (timer_num >= HAL_TIMER_MAX_NUM) {\n        return 0;\n    }\n\n    timer_count = HAL_timer_config[timer_num].timer_count;\n\n    return timer_count;\n}", "CodeBleu_score": 38.06273574750712}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\n  if (writing) {\n    for (size_t i = 0; i < size; i++) {\n      *value++ = eeprom_read_byte((uint8_t *)(pos + i));\n      *crc += *value;\n    }\n  }\n  else {\n    for (size_t i = 0; i < size; i++) {\n      *value++ = eeprom_read_byte((uint8_t *)(pos + i));\n    }\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 62.29597280648957}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\n  if (pos < 0) return false;\n\n  if (writing) {\n\n    uint8_t *ptr = value;\n\n    for (size_t i = 0; i < size; i++) {\n\n      *ptr++ = eeprom_read_byte((uint8_t *)(EEPROM_START_ADDRESS + pos));\n\n      if (crc) *crc += *ptr;\n\n      pos++;\n    }\n  }\n  else {\n\n    pos += size;\n  }\n\n  return false;\n}", "CodeBleu_score": 58.66908033834298}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    value[i] = read_byte(pos);\n    if (crc != NULL) {\n      *crc = _crc_ccitt_update(*crc, value[i]);\n    }\n    if (writing) {\n      write_byte(pos, value[i]);\n    }\n  }\n  return false;\n}", "CodeBleu_score": 57.64533656780784}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    if (sdio == nullptr) {\n        printf(\"SDIO_WriteBlock: SDIO handle is null.\n\");\n        return false;\n    }\n    if (src == nullptr) {\n        printf(\"SDIO_WriteBlock: Source pointer is null.\n\");\n        return false;\n    }\n    if (block >= SD_BLOCKS) {\n        printf(\"SDIO_WriteBlock: Block number is out of range.\n\");\n        return false;\n    }\n    bool success = false;\n    for (int i = 0; i < SDIO_MAX_RETRIES; i++) {\n        success = sdio->writeBlock(block, src);\n        if (success) {\n            break;\n        }\n    }\n    if (success) {\n        printf(\"SDIO_WriteBlock: Successfully wrote block %u.\n\", block);\n    } else {\n        printf(\"SDIO_WriteBlock: Failed to write block %u.\n\", block);\n    }\n    return success;\n}", "CodeBleu_score": 38.17600533477491}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (sdio_handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tif (HAL_SD_WriteBlocks(sdio_handle, (uint8_t *)src, block, 1, 1000) != HAL_OK) {\n\t\tHAL_SD_ErrorTypeDef error = HAL_SD_GetError(sdio_handle);\n\t\tswitch (error) {\n\t\tcase HAL_SD_ERROR_NONE:\n\t\t\tbreak;\n\t\tcase HAL_SD_ERROR_CMD_CRC_FAIL:\n\t\t\tprintf(\"HAL_SD_ERROR_CMD_CRC_FAIL", "CodeBleu_score": 32.437818766146584}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (sdio == NULL || src == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: SDIO or source pointer is null.\n\");\n\t\treturn false;\n\t}\n\n\tfor (int i = 0; i < MAX_RETRIES; i++) {\n\t\tif (sdio_write_block(sdio, block, src)) {\n\t\t\treturn true;\n\t\t}\n\t\tprintf(\"SDIO_WriteBlock: Write failed.\n\");\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.386741610929306}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tuint8_t prescale;\n\tswitch (timer_num) {\n\t\tcase TEMP_TIMER:\n\t\t\tprescale = (uint8_t)((F_CPU / frequency) - 1);\n\t\t\t// Set the prescale register\n\t\t\tTCCR1B = (TCCR1B & 0xF8) | prescale;\n\t\t\t// Enable timer overflow interrupt\n\t\t\tTIMSK1 |= _BV(TOIE1);\n\t\t\tbreak;\n\t\tcase STEP_TIMER:\n\t\t\tprescale = (uint8_t)((F_CPU / frequency) - 1);\n\t\t\t// Set the prescale register\n\t\t\tTCCR2B = (TCCR2B & 0xF8) | prescale;\n\t\t\t// Enable timer overflow interrupt\n\t\t\tTIMSK2 |= _BV(TOIE2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Assert if the timer channel is invalid\n\t\t\tassert(false);\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 24.838895095296447}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    switch (timer_num) {\n        case TIMER_TEMP:\n            // set the prescale for the temperature timer\n            TIMER_TEMP->CTRL |= TIMER_TEMP_PRESCALE;\n            // set the frequency for the temperature timer\n            TIMER_TEMP->CTRL = TIMER_TEMP_CTRL_FREQ(frequency);\n            // set the callback priority for the temperature timer\n            TIMER_TEMP->CTRL |= TIMER_TEMP_CALLBACK_PRIORITY;\n            // enable the temperature timer\n            TIMER_TEMP->CTRL |= TIMER_TEMP_ENABLE;\n            break;\n        case TIMER_STEP:\n            // set the prescale for the stepper timer\n            TIMER_STEP->CTRL |= TIMER_STEP_PRESCALE;\n            // set the frequency for the stepper timer\n            TIMER_STEP->CTRL = TIMER_STEP_CTRL_FREQ(frequency);\n            // set the callback priority for the stepper timer\n            TIMER_STEP->CTRL |= TIMER_STEP_CALLBACK_PRIORITY;\n            // enable the stepper timer\n            TIMER_STEP->CTRL |= TIMER_STEP_ENABLE;\n            break;\n        default:\n            // trigger an assertion failure\n            HAL_assert_fail();\n            break;\n    }\n}", "CodeBleu_score": 29.128564132439116}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    switch (timer_num) {\n        case TIMER_TEMP:\n            TIMER_SET_PRESCALE(timer_num, TIMER_PRESCALE_TEMP);\n            TIMER_SET_CALLBACK_PRIORITY(timer_num, TIMER_CALLBACK_PRIORITY_TEMP);\n            TIMER_SET_FREQUENCY(timer_num, frequency);\n            TIMER_START(timer_num);\n            break;\n        case TIMER_STEP:\n            TIMER_SET_PRESCALE(timer_num, TIMER_PRESCALE_STEP);\n            TIMER_SET_CALLBACK_PRIORITY(timer_num, TIMER_CALLBACK_PRIORITY_STEP);\n            TIMER_SET_FREQUENCY(timer_num, frequency);\n            TIMER_START(timer_num);\n            break;\n        default:\n            assert(0);\n            break;\n    }\n}", "CodeBleu_score": 38.13205041940867}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  // Open the file\n  file = SD.open(file_name, FILE_READ);\n  if (!file) {\n    // File doesn't exist, or can't be opened\n    return false;\n  }\n\n  // Get file size\n  file_size = file.size();\n\n  // Check if file is large enough\n  if (file_size < EEPROM_SIZE) {\n    // File is too small; fill with erase value\n    memset(buffer, EEPROM_ERASE_BYTE, EEPROM_SIZE);\n  }\n  else {\n    // File is large enough; read contents\n    file.read(buffer, EEPROM_SIZE);\n  }\n\n  // Close the file\n  file.close();\n\n  // Return success\n  return true;\n}", "CodeBleu_score": 25.4473663300764}, {"code": "bool PersistentStore::access_start(){\n\t  if (!open()) {\n    return false;\n  }\n  if (file.size() < size()) {\n    memset(buffer, erase_value, size());\n    file.write(buffer, size());\n  }\n  else {\n    file.read(buffer, size());\n  }\n  close();\n  return true;\n}", "CodeBleu_score": 19.184781331429683}, {"code": "bool PersistentStore::access_start(){\n\t  if (!file_opened) {\n    if (!file.open(file_name, O_RDWR)) {\n      return false;\n    }\n    file_opened = true;\n  }\n  if (file.size() < size) {\n    memset(buffer, erase_value, size);\n    file.write(buffer, size);\n  }\n  else {\n    file.read(buffer, size);\n  }\n  file.close();\n  return true;\n}", "CodeBleu_score": 28.638202235621208}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t r = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SpiClockLow();\n\t\tHAL_SPI_STM32_SpiMosiWrite(b & 0x80);\n\t\tHAL_SPI_STM32_SpiClockHigh();\n\t\tr = (r << 1) | HAL_SPI_STM32_SpiMisoRead();\n\t\tb = b << 1;\n\t}\n\tHAL_SPI_STM32_SpiClockLow();\n\tHAL_SPI_STM32_SpiClockHigh();\n\tHAL_SPI_STM32_SpiClockLow();\n\tHAL_SPI_STM32_SpiClockHigh();\n\tHAL_SPI_STM32_SpiClockLow();\n\tHAL_SPI_STM32_SpiClockHigh();\n\tHAL_SPI_STM32_SpiClockLow();\n\tHAL_SPI_STM32_SpiClockHigh();\n\treturn r;\n}", "CodeBleu_score": 36.67337338649872}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t i;\n    uint8_t r = 0;\n    for (i = 0; i < 8; i++) {\n        HAL_SPI_STM32_SpiTransfer_Mode_3_Bit(b & 0x80);\n        b <<= 1;\n    }\n    r = HAL_SPI_STM32_SpiTransfer_Mode_3_Bit(0);\n    HAL_SPI_STM32_SpiTransfer_Mode_3_Delay();\n    return r;\n}", "CodeBleu_score": 40.024384943447124}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t r = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SpiTransfer_Mode_0(b & 0x80);\n\t\tb <<= 1;\n\t\tr <<= 1;\n\t\tr |= HAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\t}\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_SpiTransfer_Mode_0(0);\n\tHAL_SPI_STM32_", "CodeBleu_score": 28.575950943911877}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 84.07596204999733}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.79020628658785}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.79020628658785}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c;\n\n  c = obj->serial->read();\n\n  if (rx_buffer_head != rx_buffer_tail) {\n    rx_buffer[rx_buffer_head] = c;\n    rx_buffer_head = (rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n\n  if (rx_buffer_head == rx_buffer_tail) {\n    rx_buffer_tail = (rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n\n  if (rx_buffer_head == rx_buffer_tail) {\n    rx_buffer_head = rx_buffer_tail = 0;\n  }\n\n  if (rx_overruns) {\n    rx_overruns--;\n  }\n\n  if (rx_crc_index < 0) {\n    rx_crc_index = 0;\n  }\n  if (rx_crc_index < 2) {\n    rx_crc_ccitt ^= c;\n  }\n  rx_crc_index++;\n\n  if (rx_state == STATE_RX_PROCESS_NEXT) {\n    rx_state = STATE_RX_PROCESS;\n  }\n}", "CodeBleu_score": 31.684954168862244}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  int c = obj->serial->read();\n  if (c == -1) return;\n\n  if (obj->serial->parityError()) return;\n\n  if (rx_buffer_head == rx_buffer_tail) {\n    rx_buffer_overflow = true;\n    return;\n  }\n\n  rx_buffer[rx_buffer_head] = c;\n  rx_buffer_head = (rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n}", "CodeBleu_score": 33.55407384189076}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c = obj->serial->read();\n  if (c == 0x00) return;\n  if (rx_buffer_head == rx_buffer_tail) {\n    // Buffer is full\n    rx_buffer_tail = (rx_buffer_tail + 1) & SERIAL_BUFFER_MASK;\n  }\n  rx_buffer[rx_buffer_head] = c;\n  rx_buffer_head = (rx_buffer_head + 1) & SERIAL_BUFFER_MASK;\n  if (rx_buffer_head == rx_buffer_tail) {\n    // Buffer is full\n    rx_buffer_tail = (rx_buffer_tail + 1) & SERIAL_BUFFER_MASK;\n  }\n}", "CodeBleu_score": 29.767151421188686}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    switch (timer_num) {\n        case MF_TIMER_STEP:\n            if (MF_TIMER_STEP_INITIALIZED && !MF_TIMER_STEP_INTERRUPT_ATTACHED) {\n                MF_TIMER_STEP_INTERRUPT_ATTACHED = true;\n                attachInterruptVector(MF_TIMER_STEP_INTERRUPT_VECTOR, Step_Handler);\n            }\n            break;\n        case MF_TIMER_TEMP:\n            if (MF_TIMER_TEMP_INITIALIZED && !MF_TIMER_TEMP_INTERRUPT_ATTACHED) {\n                MF_TIMER_TEMP_INTERRUPT_ATTACHED = true;\n                attachInterruptVector(MF_TIMER_TEMP_INTERRUPT_VECTOR, Temp_Handler);\n            }\n            break;\n        default:\n            break;\n    }\n}", "CodeBleu_score": 33.90535629614126}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        if (step_timer_isr_enabled == false) {\n            step_timer_isr_enabled = true;\n            NVIC_EnableIRQ(TIMER_STEP_IRQn);\n        }\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n        if (temp_timer_isr_enabled == false) {\n            temp_timer_isr_enabled = true;\n            NVIC_EnableIRQ(TIMER_TEMP_IRQn);\n        }\n    }\n}", "CodeBleu_score": 31.401847716600773}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\n    switch (timer_num) {\n        case MF_TIMER_STEP:\n            if (MF_TIMER_STEP_INITIALIZED && !MF_TIMER_STEP_INTERRUPT_ATTACHED) {\n                MF_TIMER_STEP_INTERRUPT_ATTACHED = true;\n                NVIC_EnableIRQ(TIM1_UP_IRQn);\n            }\n            break;\n        case MF_TIMER_TEMP:\n            if (MF_TIMER_TEMP_INITIALIZED && !MF_TIMER_TEMP_INTERRUPT_ATTACHED) {\n                MF_TIMER_TEMP_INTERRUPT_ATTACHED = true;\n                NVIC_EnableIRQ(TIM3_IRQn);\n            }\n            break;\n    }\n}", "CodeBleu_score": 36.0151706312379}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(s) == 0 || len(sep) == 0 {\n\t\treturn -1\n\t}\n\n\t// Convert the input string and the separator to byte slices.\n\tvar (\n\t\tstr []byte\n\t\tsep []byte\n\t)\n\n\tswitch s := s.(type) {\n\tcase string:\n\t\tstr = []byte(s)\n\tcase []byte:\n\t\tstr = s\n\tdefault:\n\t\tpanic(\"The input string must be a string or a byte slice.\")\n\t}\n\n\tswitch sep := sep.(type) {\n\tcase string:\n\t\tsep = []byte(sep)\n\tcase []byte:\n\t\tsep = sep\n\tdefault:\n\t\tpanic(\"The separator must be a string or a byte slice.\")\n\t}\n\n\t// Calculate the hash of the substring and the separator.\n\tvar (\n\t\tsubHash = Hash(sep)\n\t\tsepHash = Hash(sep)\n\t)\n\n\t// Calculate the hash of the main string.\n\tvar mainHash int64\n\n\tfor i := 0; i < len(str); i++ {\n\t\tmainHash = (mainHash - int64(str[i])*int64(math.Pow(256, float64(len(str)-i-1)))) % int64(math.Pow(256, float64(len(str))))\n\t\tmainHash = (mainHash*256 + int64(str[i])) % int64(math.Pow(256, float64(len(str))))\n\t}\n\n\t// Calculate the hash of the main string from the end towards the beginning.\n\tvar mainHashRev int64\n\n\tfor i := 0; i < len(str); i++ {\n\t\tmainHashRev = (mainHashRev - int64(str[len(str)-i-1])*int64(math.Pow(256, float64(len(str)-i-1)))) % int64(math.Pow(256, float64(len(str))))\n\t\tmainHashRev =", "CodeBleu_score": 27.125806824604737}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tvar (\n\t\thash, pow, sepHash uint64\n\t\tsepLen, sLen       int\n\t)\n\tif sepLen, sLen = len(sep), len(s); sepLen == 0 {\n\t\treturn sLen\n\t}\n\tif sepLen > sLen {\n\t\treturn -1\n\t}\n\tfor i := 0; i < sepLen; i++ {\n\t\thash = hash*256 + uint64(s[i])\n\t}\n\tpow = 1\n\tfor i := 0; i < sepLen-1; i++ {\n\t\tpow = pow * 256\n\t}\n\tsepHash = hash\n\tfor i := sepLen; i < sLen; i++ {\n\t\thash = hash - uint64(s[i-sepLen])*pow + uint64(s[i])\n\t\tif hash == sepHash {\n\t\t\tfor j := 0; j < sepLen; j++ {\n\t\t\t\tif s[i-sepLen+j] != sep[j] {\n\t\t\t\t\tgoto next\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i - sepLen\n\t\t}\n\tnext:\n\t}\n\treturn -1\n}", "CodeBleu_score": 34.42820612765294}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// If the length of the substring is greater than the length of the string, return -1.\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\t// If the length of the substring is equal to the length of the string, return 0 if the substring matches the string; otherwise, return -1.\n\tif len(s) == len(sep) {\n\t\tif s == sep {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\t}\n\t// If the length of the substring is less than the length of the string, calculate the hash of the substring and the hash of the main string.\n\thashSub, hashStr := Hash(sep), Hash(s)\n\t// If the hash of the substring is equal to the hash of the main string, return 0 if the substring matches the main string; otherwise, return -1.\n\tif hashSub == hashStr {\n\t\tif s == sep {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\t}\n\t// Calculate the hash of the substring and the hash of the main string from the end of the main string to the beginning.\n\thashSubRev := HashReverse(sep)\n\thashStrRev := HashReverse(s)\n\t// If the hash of the substring is equal to the hash of the main string from the end of the main string to the beginning, return the length of the main string minus the length of the substring.\n\tif hashSubRev == hashStrRev {\n\t\tif s[len(s)-len(sep):] == sep {\n\t\t\treturn len(s) - len(sep)\n\t\t}\n\t\treturn -1\n\t}\n\t// If the hash of the substring is not equal to the hash of the main string from the end of the main string to the beginning, calculate the hash of the substring and the hash of the main string from the end of the main string to the beginning.\n\thashSubRev = HashReverse(sep)\n\thashStrRev = HashReverse(s)\n\t// If the hash of the substring is equal to the hash of the main string from the end of the main string to the beginning, return the length of the main string minus the", "CodeBleu_score": 26.770768468874518}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txc != 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 44.18956292533823}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tinterrupt.Disable()\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txc != 0 {\n\t\t// Send data to the USB endpoint\n\t\tusb.SendUSBInPacket(usbcdc.ep, usbcdc.txb, usbcdc.txc)\n\t\t// Set the transmit buffer pointer and counter to zero\n\t\tusbcdc.txb = 0\n\t\tusbcdc.txc = 0\n\t} else {\n\t\t// Set the waitTxc flag to false\n\t\tusbcdc.waitTxc = false\n\t}\n\t// Restore interrupts\n\tinterrupt.Enable()\n}", "CodeBleu_score": 44.53109841228988}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tinterrupt.Disable()\n\n\t// Check if there is data in the transmit buffer\n\tif len(usbcdc.TxBuf) > 0 {\n\t\t// Send data to the USB endpoint\n\t\tusb.SendUSBInPacket(usbcdc.TxEndp, usbcdc.TxBuf)\n\t} else {\n\t\t// No data in the buffer\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore interrupts\n\tinterrupt.Enable()\n}", "CodeBleu_score": 45.183139824847736}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Disable interrupts\n\tinterrupt.Disable()\n\n\t// Clear interrupt flag\n\ti2c.clearInterrupt()\n\n\t// Send start condition\n\ti2c.sendStart()\n\n\t// Wait for start condition to be transmitted\n\tfor i2c.status()&(1<<TWINT) == 0 {\n\t}\n\n\t// Send address\n\ti2c.write(address<<1 | uint8(write))\n\n\t// Wait for address to be transmitted\n\tfor i2c.status()&(1<<TWINT) == 0 {\n\t}\n\n\t// Enable interrupts\n\tinterrupt.Enable()\n}", "CodeBleu_score": 29.05625997994606}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.clearInterrupt()\n\ti2c.setStart()\n\ti2c.waitForInterrupt()\n\ti2c.setAddress(address, write)\n\ti2c.waitForInterrupt()\n}", "CodeBleu_score": 22.83119674685132}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.ctrl.Store(0)\n\ti2c.ctrl.Store(I2C_START)\n\tfor i2c.ctrl.Load()&I2C_START != 0 {\n\t}\n\ti2c.data.Store(address << 1 | uint8(write))\n\tfor i2c.ctrl.Load()&I2C_RW != 0 {\n\t}\n}", "CodeBleu_score": 28.12377846527454}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || start >= f.size {\n\t\treturn ErrOutOfRange\n\t}\n\tif start+len*f.blockSize > f.size {\n\t\treturn ErrOutOfRange\n\t}\n\tif len <= 0 {\n\t\treturn nil\n\t}\n\tif f.eraseSize > 0 && f.eraseSize != f.blockSize {\n\t\treturn ErrInvalidEraseSize\n\t}\n\tif f.eraseSize == 0 {\n\t\tf.eraseSize = f.blockSize\n\t}\n\t// Wait for any ongoing flash operations to complete.\n\tfor f.busy() {\n\t}\n\t// Configure flash for erasing.\n\tf.enableErase()\n\t// Erase blocks.\n\tfor i := start; i < start+len*f.blockSize; i += f.blockSize {\n\t\t// Erase block.\n\t\tf.erase(i)\n\t\t// Wait until block is erased.\n\t\tfor f.busy() {\n\t\t}\n\t}\n\t// Set flash back to read mode.\n\tf.disableErase()\n\treturn nil\n}", "CodeBleu_score": 38.901576686857396}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn ErrBadArguments\n\t}\n\tif start+len > f.numBlocks {\n\t\treturn ErrBadArguments\n\t}\n\tif len == 0 {\n\t\treturn nil\n\t}\n\tf.mutex.Lock()\n\tdefer f.mutex.Unlock()\n\tif f.erase() != nil {\n\t\treturn ErrFlashErase\n\t}\n\tif f.waitReady() != nil {\n\t\treturn ErrFlashErase\n\t}\n\tfor i := int64(0); i < len; i++ {\n\t\tif f.eraseBlock(start+i) != nil {\n\t\t\treturn ErrFlashErase\n\t\t}\n\t\tif f.waitReady() != nil {\n\t\t\treturn ErrFlashErase\n\t\t}\n\t}\n\tif f.setReadMode() != nil {\n\t\treturn ErrFlashErase\n\t}\n\treturn nil\n}", "CodeBleu_score": 38.2335091680098}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || start >= f.numBlocks {\n\t\treturn errOutOfRange\n\t}\n\tif start+len > f.numBlocks {\n\t\treturn errOutOfRange\n\t}\n\tif len <= 0 {\n\t\treturn errInvalidLen\n\t}\n\tif f.readOnly {\n\t\treturn errReadOnly\n\t}\n\tif f.isBusy() {\n\t\treturn errBusy\n\t}\n\t// Configure the flash for erasing.\n\tf.config(true)\n\t// Calculate the start address of the first block to be erased.\n\tstartAddr := uint32(start * f.blockSize)\n\t// Erase each block.\n\tfor i := int64(0); i < len; i++ {\n\t\t// Erase the block.\n\t\tf.erase(startAddr)\n\t\t// Wait for the flash to finish erasing.\n\t\tif f.isBusy() {\n\t\t\treturn errBusy\n\t\t}\n\t\t// Increment the start address by the block size.\n\t\tstartAddr += f.blockSize\n\t}\n\t// Set the flash back to read mode.\n\tf.config(false)\n\treturn nil\n}", "CodeBleu_score": 36.14384037331935}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off >= f.size {\n\t\treturn 0, ErrInvalidOffset\n\t}\n\tif off+int64(len(p)) > f.size {\n\t\treturn 0, ErrInvalidOffset\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// Calculate start address and pad byte slice to fit the write block size.\n\taddr := f.start + uint32(off)\n\tpad := f.blockSize - (addr - f.start) % f.blockSize\n\tif pad == f.blockSize {\n\t\tpad = 0\n\t}\n\tp = append(p, make([]byte, pad)...)\n\n\t// Enable flash memory controller.\n\tnrf.NVMC.CONFIG = nrf.NVMC_CONFIG_WEN_Wen\n\tfor nrf.NVMC.READY == 0 {\n\t}\n\n\t// Write data in blocks.\n\tfor len(p) > 0 {\n\t\t// Calculate number of bytes to write in this block.\n\t\tn = len(p)\n\t\tif n > int(f.blockSize) {\n\t\t\tn = int(f.blockSize)\n\t\t}\n\n\t\t// Write data.\n\t\tfor i := 0; i < n; i++ {\n\t\t\tnrf.UICR.NRFFW[addr+uint32(i)] = uint32(p[i])\n\t\t}\n\n\t\t// Wait for flash memory to be ready.\n\t\tfor nrf.NVMC.READY == 0 {\n\t\t}\n\n\t\t// Move to the next block.\n\t\tp = p[n:]\n\t\taddr += uint32(n)\n\t}\n\n\t// Disable flash memory controller.\n\tnrf.NVMC.CONFIG = nrf.NVMC_CONFIG_WEN_Ren\n\tfor nrf.NVMC.READY == 0 {\n\t}\n\n\t// Return number of bytes written.\n\treturn len(p) - pad, nil\n}", "CodeBleu_score": 30.956656652682824}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, ErrNegativeOffset\n\t}\n\tif off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off%int64(f.writeBlockSize) != 0 {\n\t\treturn 0, ErrUnalignedOffset\n\t}\n\tif len(p)%f.writeBlockSize != 0 {\n\t\treturn 0, ErrUnalignedSize\n\t}\n\tvar (\n\t\tflashAddress uint32 = uint32(off)\n\t\tdata         []byte = p\n\t\twriteSize    int    = len(p)\n\t)\n\t// Write data in blocks.\n\tfor writeSize > 0 {\n\t\t// Check if the write operation exceeds the flash memory bounds.\n\t\tif flashAddress+uint32(writeSize) > f.size {\n\t\t\twriteSize = int(f.size - flashAddress)\n\t\t}\n\t\t// Pad the byte slice to fit the write block size.\n\t\tif writeSize%f.writeBlockSize != 0 {\n\t\t\twriteSize += f.writeBlockSize - writeSize%f.writeBlockSize\n\t\t}\n\t\t// Enable write mode on the flash memory controller.\n\t\tnrf.NVMC.CONFIG = nrf.NVMC_CONFIG_WEN_Wen\n\t\t// Wait for the flash memory controller to be ready.\n\t\tfor nrf.NVMC.READY == nrf.NVMC_READY_READY_Busy {\n\t\t}\n\t\t// Write the data in blocks.\n\t\tfor i := 0; i < writeSize; i += f.writeBlockSize {\n\t\t\t// Write the data in the flash memory.\n\t\t\tbinary.LittleEndian.PutUint32(f.flashMemory[flashAddress:], binary.LittleEndian.Uint32(data[i:]))\n\t\t\t// Increment the flash memory address.\n\t\t\tflashAddress +=", "CodeBleu_score": 31.923423685932008}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, ErrNegativeOffset\n\t}\n\tif off >= f.size {\n\t\treturn 0, ErrOutOfRange\n\t}\n\tif off+int64(len(p)) > f.size {\n\t\treturn 0, ErrOutOfRange\n\t}\n\n\tif f.writeSize > 0 {\n\t\tp = pad(p, f.writeSize)\n\t}\n\n\tn = len(p)\n\taddr := f.baseAddress + off\n\tfor len(p) > 0 {\n\t\tif addr > f.baseAddress+f.size {\n\t\t\treturn 0, ErrOutOfRange\n\t\t}\n\t\tif addr+uint32(len(p)) > f.baseAddress+f.size {\n\t\t\tp = p[:f.baseAddress+f.size-addr]\n\t\t}\n\t\tif err := f.enableWrite(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif err := f.write(addr, p); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif err := f.waitReady(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\taddr += uint32(len(p))\n\t\tp = p[len(p):]\n\t}\n\n\treturn n, nil\n}", "CodeBleu_score": 31.252608184333848}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, err.Error(), err\n\t}\n\t// Attempt to open the directory.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\t// Close the duplicated file descriptor.\n\t\tsyscall.Close(dupFd)\n\t\t// Return the error message.\n\t\treturn 0, err.Error(), err\n\t}\n\t// Return the directory pointer.\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 49.59348914951976}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the provided file descriptor.\n\tdupFD, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(dupFD)\n\n\t// Attempt to open the directory.\n\tvar dirp uintptr\n\tfor {\n\t\tdirp, err = syscall.Fdopendir(dupFD)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Return the directory pointer.\n\treturn dirp, \"\", nil\n}", "CodeBleu_score": 69.99077771314704}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the provided file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Open the directory.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\t// Close the duplicated file descriptor.\n\t\tsyscall.Close(dupFd)\n\t\treturn 0, \"\", err\n\t}\n\t// Return the directory pointer.\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 54.5694476868681}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n  const esp_partition_t* running = esp_ota_get_running_partition();\n\n  if (running->type != ESP_PARTITION_TYPE_APP) {\n\n    return 0;\n\n  }\n\n  if (esp_ota_get_partition_description(running, nullptr) != ESP_OK) {\n\n    return 0;\n\n  }\n\n  if (response == sketchSize_t::freeSpace) {\n\n    return running->size - running->address;\n\n  }\n\n  return running->address;\n\n}", "CodeBleu_score": 39.161569555985295}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    const esp_partition_t *running = esp_ota_get_running_partition();\n    if (running == NULL) {\n        return 0;\n    }\n\n    if (response == sketchSize_t::FREE_SPACE) {\n        return running->size;\n    }\n\n    if (esp_ota_get_partition_description(running, NULL, NULL, NULL) != ESP_OK) {\n        return 0;\n    }\n\n    return running->size;\n}", "CodeBleu_score": 39.650523811024904}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n    const esp_partition_t *partition = esp_ota_get_running_partition();\n\n    if (partition == NULL) {\n\n        return 0;\n\n    }\n\n    if (partition->size > 0x40000000) {\n\n        return 0;\n\n    }\n\n    if (partition->size == 0) {\n\n        return 0;\n\n    }\n\n    if (partition->type != ESP_PARTITION_TYPE_APP) {\n\n        return 0;\n\n    }\n\n    uint32_t ota_size = 0;\n\n    if (esp_ota_get_next_update_partition(NULL) == partition) {\n\n        ota_size = partition->size;\n\n    }\n\n    if (ota_size > 0) {\n\n        return ota_size;\n\n    }\n\n    if (response == sketchSize_t::FREE_SPACE) {\n\n        return partition->size - esp_ota_get_partition_used_size(partition);\n\n    }\n\n    return partition->size;\n\n}", "CodeBleu_score": 40.4033966332642}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\t// Calculate the required disk sectors\n\tuint32_t required_sectors = 1;\n\trequired_sectors += (volume_label != NULL) ? 1 : 0;\n\trequired_sectors += (serial_number != 0) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired_sectors += (msc_firmware_partition != NULL) ? 1 : 0;\n\trequired", "CodeBleu_score": 16.453985783295483}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\t// calculate the required disk sectors\n\tuint32_t required_sectors = 1;\n\tif (msc_update_firmware_file_size > 0) {\n\t\trequired_sectors += (msc_update_firmware_file_size + (msc_update_firmware_file_size % 512)) / 512;\n\t}\n\tif (msc_update_partition_table_size > 0) {\n\t\trequired_sectors += (msc_update_partition_table_size + (msc_update_partition_table_size % 512)) / 512;\n\t}\n\trequired_sectors += 1; // reserve one sector for the boot sector\n\trequired_sectors += 1; // reserve one sector for the FAT\n\trequired_sectors += 1; // reserve one sector for the root directory\n\trequired_sectors += 1; // reserve one sector for the root directory entry\n\trequired_sectors += 1; // reserve one sector for the end of the FAT\n\tif (msc_update_firmware_file_size > 0) {\n\t\trequired_sectors += 1; // reserve one sector for the firmware file\n\t}\n\n\t// allocate memory for the RAM disk\n\tmsc_update_ram_disk = malloc(required_sectors * 512);\n\tif (msc_update_ram_disk == NULL) {\n\t\tmsc_update_error_code = MSC_UPDATE_ERROR_ALLOCATION_FAILED;\n\t\treturn false;\n\t}\n\n\t// set up the boot sector\n\tmsc_update_boot_sector.jmp_instruction[0] = 0xEB;\n\tmsc_update_boot_sector.jmp_instruction[1] = 0x00;\n\tmsc_update_boot_sector.jmp_instruction[2] = 0x90;\n\tmsc_update_boot_sector.oem_name[0] = 'M';\n\tmsc_update_boot_sector.oem_name[1] =", "CodeBleu_score": 21.17168777770175}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\n\t// Calculate the required disk sectors\n\tuint32_t disk_sectors = (MSC_UPDATE_DISK_SIZE + MSC_UPDATE_SECTOR_SIZE - 1) / MSC_UPDATE_SECTOR_SIZE;\n\n\t// Allocate memory for the RAM disk\n\tmsc_update_ramdisk = (uint8_t *)malloc(disk_sectors * MSC_UPDATE_SECTOR_SIZE);\n\tif (msc_update_ramdisk == NULL) {\n\t\tmsc_update_error(\"Allocation failed for RAM disk\");\n\t\treturn false;\n\t}\n\n\t// Set up the boot sector\n\tmsc_update_boot_sector_t *boot_sector = (msc_update_boot_sector_t *)msc_update_ramdisk;\n\tmemset(boot_sector, 0, MSC_UPDATE_SECTOR_SIZE);\n\tboot_sector->jump[0] = 0xEB;\n\tboot_sector->jump[1] = 0x3C;\n\tboot_sector->jump[2] = 0x90;\n\tboot_sector->oem_name[0] = 'M';\n\tboot_sector->oem_name[1] = 'S';\n\tboot_sector->oem_name[2] = 'D';\n\tboot_sector->oem_name[3] = 'O';\n\tboot_sector->oem_name[4] = 'S';\n\tboot_sector->oem_name[5] = ' ';\n\tboot_sector->oem_name[6] = 'D';\n\tboot_sector->oem_name[7] = 'O';\n\tboot_sector->oem_name[8] = 'S';\n\tboot_sector->oem_name[9] = ' ';\n\tboot_sector->oem_name[10] = 'C';\n\tboot_sector->oem_name[11] = 'O';\n\tboot_sector->oem_name[12] = 'M';\n\tboot_sector->oem_name[13] =", "CodeBleu_score": 22.423967329065558}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tif (offset % SPI_FLASH_SEC_SIZE != 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x is not a multiple of flash sector size 0x%x\", offset, SPI_FLASH_SEC_SIZE);\n\t\terr = ESP_ERR_INVALID_ARG;\n\t}\n\telse {\n\t\tif (offset % SPI_FLASH_SEC_SIZE != 0) {\n\t\t\tESP_LOGE(TAG, \"Offset 0x%x is not a multiple of flash sector size 0x%x\", offset, SPI_FLASH_SEC_SIZE);\n\t\t\terr = ESP_ERR_INVALID_ARG;\n\t\t}\n\t\telse {\n\t\t\tif (offset % SPI_FLASH_SEC_SIZE != 0) {\n\t\t\t\tESP_LOGE(TAG, \"Offset 0x%x is not a multiple of flash sector size 0x%x\", offset, SPI_FLASH_SEC_SIZE);\n\t\t\t\terr = ESP_ERR_INVALID_ARG;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuint32_t erase_offset = offset & (~(SPI_FLASH_SEC_SIZE - 1));\n\t\t\t\tESP_LOGI(TAG, \"Erasing sector at offset 0x%x\", erase_offset);\n\t\t\t\terr = spi_flash_erase_range(erase_offset, SPI_FLASH_SEC_SIZE);\n\t\t\t\tif (err != ESP_OK) {\n\t\t\t\t\tESP_LOGE(TAG, \"Failed to erase sector at offset 0x%x\", erase_offset);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tESP_LOGI(TAG, \"Writing %d bytes to offset 0x%x\", size, offset);\n\t\t\t\t\terr = spi_flash_write(offset, data, size);\n\t\t\t\t\tif (err !=", "CodeBleu_score": 43.19171677751233}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    uint32_t aligned_offset = offset & ~(SPI_FLASH_SEC_SIZE - 1);\n    if (aligned_offset != offset) {\n        ESP_LOGE(TAG, \"Offset 0x%x is not sector aligned\", offset);\n        return ESP_ERR_INVALID_ARG;\n    }\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"Update region overruns partition size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n    if (size % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Update size is not a multiple of sector size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n    err = spi_flash_erase_range(partition->address + aligned_offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Sector erase failed during update\");\n        return err;\n    }\n    err = spi_flash_write(partition->address + offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Update write failed\");\n        return err;\n    }\n    return ESP_OK;\n}", "CodeBleu_score": 48.688636971052254}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n\n    if (offset % FLASH_SECTOR_SIZE != 0) {\n        ESP_LOGE(TAG, \"offset is not aligned with the flash sector size\");\n        err = ESP_ERR_INVALID_ARG;\n        return err;\n    }\n\n    if (size % FLASH_SECTOR_SIZE != 0) {\n        ESP_LOGE(TAG, \"size is not aligned with the flash sector size\");\n        err = ESP_ERR_INVALID_SIZE;\n        return err;\n    }\n\n    if (partition->encrypted) {\n        ESP_LOGE(TAG, \"partition is encrypted\");\n        err = ESP_ERR_INVALID_ARG;\n        return err;\n    }\n\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"write out of partition bounds\");\n        err = ESP_ERR_INVALID_ARG;\n        return err;\n    }\n\n    if (offset % FLASH_SECTOR_SIZE != 0) {\n        ESP_LOGE(TAG, \"offset is not aligned with the flash sector size\");\n        err = ESP_ERR_INVALID_ARG;\n        return err;\n    }\n\n    if (size % FLASH_SECTOR_SIZE != 0) {\n        ESP_LOGE(TAG, \"size is not aligned with the flash sector size\");\n        err = ESP_ERR_INVALID_SIZE;\n        return err;\n    }\n\n    if (partition->encrypted) {\n        ESP_LOGE(TAG, \"partition is encrypted\");\n        err = ESP_ERR_INVALID_ARG;\n        return err;\n    }\n\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"write out of partition bounds\");\n        err = ESP_ERR_INVALID_ARG;\n        return err;\n    }\n\n    err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"failed to erase flash sector\");\n        return err", "CodeBleu_score": 46.465903006544316}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t len = 0;\n  while (*in && len < maxlen) {\n    if (isxdigit(*in)) {\n      out[len] = (isdigit(*in) ? *in - '0' : toupper(*in) - 'A' + 10) << 4;\n      in++;\n      if (isxdigit(*in)) {\n        out[len] += isdigit(*in) ? *in - '0' : toupper(*in) - 'A' + 10;\n        in++;\n        len++;\n      }\n    }\n    in++;\n  }\n  return len;\n}", "CodeBleu_score": 43.42346044002511}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i, j, len = 0;\n    for (i = 0; i < maxlen; i++) {\n        if (in[i] == '\\0') {\n            break;\n        }\n        if (in[i] == ' ') {\n            continue;\n        }\n        if (in[i] >= '0' && in[i] <= '9') {\n            j = in[i] - '0';\n        } else if (in[i] >= 'A' && in[i] <= 'F') {\n            j = in[i] - 'A' + 10;\n        } else if (in[i] >= 'a' && in[i] <= 'f') {\n            j = in[i] - 'a' + 10;\n        } else {\n            break;\n        }\n        if (i % 2 == 0) {\n            out[len] = j << 4;\n        } else {\n            out[len++] |= j;\n        }\n    }\n    return len;\n}", "CodeBleu_score": 46.1951089356712}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t len = 0;\n    while (*in && len < maxlen) {\n        if (isxdigit((unsigned char)*in)) {\n            out[len++] = (unsigned char)strtol(in, (char**)&in, 16);\n        }\n        in++;\n    }\n    return len;\n}", "CodeBleu_score": 32.140592085868676}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_buffer == NULL)\n\t\treturn 0;\n\tif (tx_buffer->lock == 0)\n\t\treturn 0;\n\tif (xSemaphoreTake(tx_buffer->lock, USB_TX_TIMEOUT) == pdTRUE) {\n\t\tint free = tx_buffer->size - tx_buffer->count;\n\t\txSemaphoreGive(tx_buffer->lock);\n\t\treturn free;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 36.48984410553056}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (!initialized) return 0;\n\tif (!lock) return 0;\n\tif (xSemaphoreTake(lock, timeout) == pdTRUE) {\n\t\tint size = CDC_TX_RING_BUFFER_SIZE - cdc_tx_ring_buffer_head - 1;\n\t\tif (size < 0) size = CDC_TX_RING_BUFFER_SIZE + size;\n\t\txSemaphoreGive(lock);\n\t\treturn size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 47.20928288523904}, {"code": "int HWCDC::availableForWrite(void){\n\t\n    if (!tx_buffer_initialized || !tx_buffer_lock_initialized) {\n        return 0;\n    }\n\n    if (xSemaphoreTake(tx_buffer_lock, TX_BUFFER_LOCK_WAIT_MS / portTICK_PERIOD_MS) == pdTRUE) {\n        int free_size = tx_buffer_size - tx_buffer_count;\n        xSemaphoreGive(tx_buffer_lock);\n        return free_size;\n    }\n\n    return 0;\n}", "CodeBleu_score": 47.57879000477889}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  if (function == NULL) {\n    _onReceiveCB = NULL;\n    _rxTimeout = 0;\n  } else {\n    _onReceiveCB = function;\n    _rxTimeout = onlyOnTimeout ? 0 : 1;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n  if (!_rx_buffer_full_irq) {\n    return;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n  if (!_rx_buffer_full_irq) {\n    return;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n  if (!_rx_buffer_full_irq) {\n    return;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n  if (!_rx_buffer_full_irq) {\n    return;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n  if (!_rx_buffer_full_irq) {\n    return;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n  if (!_rx_buffer_full_irq) {\n    return;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n  if (!_rx_buffer_full_irq) {\n    return;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n  if (!_rx_buffer_full_irq) {\n    return;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n  if (!_rx_buffer_full_irq) {\n    return;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n  if (!_rx_buffer_full_irq) {\n    return;\n  }\n\n  // If we're not using the interrupt method, don't create the task.\n ", "CodeBleu_score": 41.36750261512617}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  //lock mutex\n  xSemaphoreTake(xMutex, portMAX_DELAY);\n  //assign callback function\n  _onReceiveCB = function;\n  //configure receive timeout behavior\n  if (onlyOnTimeout) {\n    _rxTimeout = 0;\n  } else {\n    _rxTimeout = _rxBuf.size();\n  }\n  //if callback function is not NULL, set FIFO full threshold and create event task if it does not already exist\n  if (function != NULL) {\n    uart_set_rx_full_thresh(uart_num, _rxBuf.size());\n    if (xReceiveTask == NULL) {\n      xReceiveTask = xTaskGetCurrentTaskHandle();\n      xTaskCreatePinnedToCore(HardwareSerial::_receiveTask, \"HardwareSerial::_receiveTask\", 4096, (void *)this, 1, &_receiveTaskHandle, 1);\n    }\n  } else {\n    uart_set_rx_full_thresh(uart_num, 1);\n    if (xReceiveTask != NULL) {\n      vTaskDelete(_receiveTaskHandle);\n      xReceiveTask = NULL;\n    }\n  }\n  //unlock mutex\n  xSemaphoreGive(xMutex);\n}", "CodeBleu_score": 50.16695068806727}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n  xSemaphoreTake(this->tx_mutex, portMAX_DELAY);\n\n  this->_onReceiveCB = function;\n\n  if (onlyOnTimeout) {\n\n    this->setRxTimeout(this->_rxTimeout);\n\n  } else {\n\n    this->setRxTimeout(0);\n\n  }\n\n  xSemaphoreGive(this->tx_mutex);\n\n}", "CodeBleu_score": 19.025827992282323}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    buffer[index++] = (char)c;\n  }\n\n  return index;\n}", "CodeBleu_score": 83.9024256768018}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    buffer[index++] = (char)c;\n  }\n  return index;\n}", "CodeBleu_score": 69.60713856642839}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    buffer[index++] = (char)c;\n    if (c == terminator) {\n      break;\n    }\n  }\n  return index;\n}", "CodeBleu_score": 68.36401909562034}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    // Check if the pin is available or already in use.\n    if (pin >= TONE_PIN_COUNT || tone_pins[pin].status == TONE_PIN_IN_USE) {\n        // If the pin is in use, log an error message instructing to stop the current tone on the pin first.\n        if (tone_pins[pin].status == TONE_PIN_IN_USE) {\n            Serial.println(\"Error: pin \" + String(pin) + \" is already in use. Please stop the current tone on the pin first.\");\n        }\n        // If the pin is not available, log an error message instructing to use a pin between 0 and 29.\n        else {\n            Serial.println(\"Error: pin \" + String(pin) + \" is not available. Please use a pin between 0 and 29.\");\n        }\n        return;\n    }\n\n    // Log the pin, frequency, and duration.\n    Serial.println(\"Starting tone on pin \" + String(pin) + \" with frequency \" + String(frequency) + \" Hz and duration \" + String(duration) + \" ms.\");\n\n    // Initialize the tone.\n    tone_pins[pin].status = TONE_PIN_IN_USE;\n    tone_pins[pin].frequency = frequency;\n    tone_pins[pin].duration = duration;\n    tone_pins[pin].pin = pin;\n    tone_pins[pin].timer = 0;\n    tone_pins[pin].duty = 0;\n\n    // Send a start command with the pin, frequency, and duration to a queue.\n    xQueueSend(tone_queue, &tone_pins[pin], portMAX_DELAY);\n}", "CodeBleu_score": 41.676075468378535}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\t// TODO: Implement this function\n}", "CodeBleu_score": 3.7308020343026738}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (frequency < 1) {\n    return;\n  }\n  if (pin >= LEDC_CHANNEL_MAX) {\n    return;\n  }\n  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (frequency < 1) {\n    return;\n  }\n  if (pin >= LEDC_CHANNEL_MAX) {\n    return;\n  }\n  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (frequency < 1) {\n    return;\n  }\n  if (pin >= LEDC_CHANNEL_MAX) {\n    return;\n  }\n  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (frequency < 1) {\n    return;\n  }\n  if (pin >= LEDC_CHANNEL_MAX) {\n    return;\n  }\n  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (frequency < 1) {\n    return;\n  }\n  if (pin >= LEDC_CHANNEL_MAX) {\n    return;\n  }\n  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (duration == 0) {\n    noTone(pin);\n    return;\n  }\n  if (frequency < 1) {\n    return;\n  }\n  if (pin >= LEDC_CH", "CodeBleu_score": 36.679151858618845}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!started) {\n\t\twebUSBEnabled = enabled;\n\t\treturn true;\n\t}\n\tif (enabled) {\n\t\tif (usbVersion < 0x0210) {\n\t\t\twebUSBEnabled = false;\n\t\t\treturn true;\n\t\t}\n\t\twebUSBEnabled = true;\n\t} else {\n\t\twebUSBEnabled = false;\n\t}\n\treturn false;\n}", "CodeBleu_score": 39.51872759208438}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usbStarted) {\n\t\tif (enabled) {\n\t\t\twebUSBEnabled = true;\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\tusbVersion = 0x0210;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tif (enabled) {\n\t\tif (usbVersion < 0x0210) {\n\t\t\tusbVersion = 0x0210;\n\t\t}\n\t\tif (webUSBEnabled) {\n\t\t\treturn false;\n\t\t}\n\t\twebUSBEnabled = true;\n\t\tif (webUSBEnabled) {\n\t\t\t// Start WebUSB\n\t\t\tif (webUSBStart()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twebUSBEnabled = false;\n\t\tif (webUSBEnabled) {\n\t\t\t// Stop WebUSB\n\t\t\tif (webUSBStop()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 48.946182712000294}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (this->usbStarted) {\n    if (enabled) {\n      if (this->webUSBEnabled) {\n        return false;\n      }\n      if (this->usbVersion < 0x0210) {\n        return true;\n      }\n      this->webUSBEnabled = true;\n      this->webUSBEnabled = this->webUSB.begin(this->webUSBVendorID, this->webUSBProductID, this->webUSBSerialNumber, this->webUSBManufacturerString, this->webUSBProductString, this->webUSBSerialNumberString);\n      if (this->webUSBEnabled) {\n        this->webUSB.setPacketSize(this->webUSBPacketSize);\n      }\n    } else {\n      if (!this->webUSBEnabled) {\n        return false;\n      }\n      this->webUSBEnabled = false;\n      this->webUSB.end();\n    }\n  } else {\n    this->webUSBEnabled = enabled;\n  }\n  return false;\n}", "CodeBleu_score": 28.259231843080958}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t buf[USB_CDC_RX_BUFFER_SIZE];\n\tuint8_t bytesRead = 0;\n\tuint8_t bytesDropped = 0;\n\tuint8_t i;\n\n\tbytesRead = usb_cdc_read_buffer(buf, USB_CDC_RX_BUFFER_SIZE);\n\n\tif (bytesRead > 0) {\n\t\tfor (i = 0; i < bytesRead; i++) {\n\t\t\tif (!_rxQueue.post(buf[i])) {\n\t\t\t\tbytesDropped++;\n\t\t\t\tlogError(bytesDropped);\n\t\t\t}\n\t\t}\n\n\t\tif (bytesDropped > 0) {\n\t\t\tpostOverflowEvent(bytesDropped);\n\t\t}\n\n\t\tpostReceiveEvent(bytesRead);\n\t}\n}", "CodeBleu_score": 25.219259211512036}, {"code": "void USBCDC::_onRX(){\n\t  // Check if we have data\n  if (usb_cdc_available()) {\n    // Read data\n    uint8_t data = usb_cdc_getc();\n    // Check if the queue is full\n    if (!_rxQueue.full()) {\n      // If it isn't, post the data\n      _rxQueue.post(data);\n      // Post a receive event\n      _postEvent(USBCDC_EVENT_RECEIVE, 1);\n    } else {\n      // If it is, post an overflow event\n      _postEvent(USBCDC_EVENT_OVERFLOW, 1);\n      // Log an error\n      _log(USBCDC_ERROR_RX_OVERFLOW, 0, 0);\n    }\n  }\n}", "CodeBleu_score": 10.212517951123097}, {"code": "void USBCDC::_onRX(){\n\t\tuint32_t rx_length;\n\tuint32_t dropped_bytes = 0;\n\tuint8_t rx_buffer[USB_CDC_RX_BUFFER_SIZE];\n\n\t// read data from the USB CDC RX buffer\n\trx_length = CDC_Receive_FS(rx_buffer, USB_CDC_RX_BUFFER_SIZE);\n\n\t// loop through the data and post each byte to the receive queue\n\tfor (uint32_t i = 0; i < rx_length; i++) {\n\t\tif (this->rx_queue.size() < this->rx_queue_size) {\n\t\t\tthis->rx_queue.push(rx_buffer[i]);\n\t\t} else {\n\t\t\tdropped_bytes++;\n\t\t\tthis->rx_overflow_queue.push(rx_buffer[i]);\n\t\t\tthis->logger.error(\"USBCDC::_onRX: RX queue overflow\");\n\t\t}\n\t}\n\n\t// post the receive event\n\tif (rx_length > 0) {\n\t\tthis->rx_event.post(rx_length);\n\t}\n\n\t// post the overflow event\n\tif (dropped_bytes > 0) {\n\t\tthis->rx_overflow_event.post(dropped_bytes);\n\t}\n}", "CodeBleu_score": 29.34661903680783}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tvar err error\n\tvar robotName = strings.TrimSpace(req.URL.Query().Get(\":robotName\"))\n\n\t// Check if the robot exists\n\tif !a.Robots.Exists(robotName) {\n\t\terr = a.writeJSON(res, http.StatusNotFound, robeaux.Error{\n\t\t\tMessage: fmt.Sprintf(\"no robot with name %s found\", robotName),\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error writing JSON response: %v\", err)\n\t\t}\n\t\treturn\n\t}\n\n\t// Get devices for robot\n\tdevices, err := a.Robots.Devices(robotName)\n\tif err != nil {\n\t\terr = a.writeJSON(res, http.StatusInternalServerError, robeaux.Error{\n\t\t\tMessage: fmt.Sprintf(\"error getting devices for robot %s: %v\", robotName, err),\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error writing JSON response: %v\", err)\n\t\t}\n\t\treturn\n\t}\n\n\t// Write JSON response\n\terr = a.writeJSON(res, http.StatusOK, devices)\n\tif err != nil {\n\t\tlog.Printf(\"error writing JSON response: %v\", err)\n\t}\n}", "CodeBleu_score": 41.91604528256374}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimSpace(req.URL.Query().Get(\":robotName\"))\n\n\tif robotName == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"{\\\"error\\\": \\\"robot name not specified\\\"}\"))\n\t\treturn\n\t}\n\n\tif _, ok := a.robots[robotName]; !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"{\\\"error\\\": \\\"no robot with name \" + robotName + \"\\\"}\"))\n\t\treturn\n\t}\n\n\tdevices := []robeaux.Device{}\n\tfor _, device := range a.robots[robotName].Devices() {\n\t\tdevices = append(devices, device)\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(\"{\\\"devices\\\": \" + string(robeaux.JSON(devices)) + \"}\"))\n}", "CodeBleu_score": 43.97443676776259}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\tlog.Printf(\"robotDevices: %s\", name)\n\n\ta.RLock()\n\tdefer a.RUnlock()\n\n\tif _, ok := a.robots[name]; !ok {\n\t\tlog.Printf(\"robot %s not found\", name)\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\":\"robot not found\"}`))\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\n\tdevices := []robeaux.Device{}\n\tfor _, d := range a.robots[name].Devices() {\n\t\tdevices = append(devices, robeaux.Device{\n\t\t\tName: d.Name(),\n\t\t\tDriver: d.Driver().Name(),\n\t\t\tConnection: d.Driver().Connection(),\n\t\t})\n\t}\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 41.82804195319091}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\tlog.Printf(\"Retrieving connections of robot %s\n\", name)\n\n\trobot, err := a.store.GetRobot(name)\n\tif err != nil {\n\t\tif err == gobot.ErrRobotNotFound {\n\t\t\tres.WriteHeader(http.StatusNotFound)\n\t\t\tfmt.Fprintf(res, \"No robot with name %s found\n\", name)\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Error while retrieving robot %s: %s\n\", name, err)\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"Error while retrieving robot %s: %s\n\", name, err)\n\t\treturn\n\t}\n\n\tconnections := []robeaux.Connection{}\n\tfor _, conn := range robot.Connections() {\n\t\tconnections = append(connections, robeaux.Connection{\n\t\t\tName: conn.Name,\n\t\t\tType: conn.Type,\n\t\t\tPort: conn.Port,\n\t\t})\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 39.747591633094146}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\tif robotName == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(res, \"Robot name not specified\")\n\t\treturn\n\t}\n\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(res, \"Robot not found\")\n\t\treturn\n\t}\n\n\tconnections := make([]robeaux.Connection, 0)\n\tfor _, connection := range robot.Connections() {\n\t\tconnections = append(connections, robeaux.Connection{\n\t\t\tName: connection.Name(),\n\t\t\tAdaptor: connection.Adaptor().Name(),\n\t\t\tDriver: connection.Driver().Name(),\n\t\t\tConnection: connection.Connection(),\n\t\t})\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 41.96169970236769}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\tif robotName == \"\" {\n\t\thttp.Error(res, \"Robot name not specified\", http.StatusBadRequest)\n\t\treturn\n\t}\n\trobot, err := a.Robots.GetRobot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections := make([]robeaux.Connection, 0, len(robot.Connections))\n\tfor _, conn := range robot.Connections {\n\t\tconnections = append(connections, robeaux.Connection{\n\t\t\tName: conn.Name,\n\t\t\tType: conn.Type,\n\t\t})\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tif err := json.NewEncoder(res).Encode(connections); err != nil {\n\t\tlog.Println(err)\n\t}\n}", "CodeBleu_score": 43.98122614341578}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the device exists\n\tif !a.robotExists(robotName) {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot '%s' not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tif !a.deviceExists(robotName, deviceName) {\n\t\thttp.Error(res, fmt.Sprintf(\"Device '%s' not found\", deviceName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Retrieve the command from the request body\n\tcommand := &robeaux.Command{}\n\terr := json.NewDecoder(req.Body).Decode(command)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Execute the command on the device\n\terr = a.gobot.Robots[robotName].Devices[deviceName].Command(command.Command, command.Arguments...)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 49.5755626714539}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot and device names are empty.\n\tif robotName == \"\" || deviceName == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"Missing robot or device name.\"}`))\n\t\treturn\n\t}\n\n\t// Get the command from the URL query parameter.\n\tcommand := req.URL.Query().Get(\"command\")\n\n\t// Check if the command is empty.\n\tif command == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"Missing command.\"}`))\n\t\treturn\n\t}\n\n\t// Check if the command is valid.\n\tif !isValidCommand(command) {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"Invalid command.\"}`))\n\t\treturn\n\t}\n\n\t// Get the robot from the database.\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\tlog.Println(\"Error retrieving robot from database:\", err)\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(`{\"error\": \"Error retrieving robot from database.\"}`))\n\t\treturn\n\t}\n\n\t// Check if the robot exists.\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"Robot does not exist.\"}`))\n\t\treturn\n\t}\n\n\t// Check if the robot is connected.\n\tif !robot.Connected {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"Robot is not connected.\"}`))\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tif !robot.HasDevice(deviceName) {", "CodeBleu_score": 45.79689301802324}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get robot name from query parameter\n\trobotName := req.URL.Query().Get(\"robot\")\n\n\t// Get device name from query parameter\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Get command name from query parameter\n\tcommandName := req.URL.Query().Get(\"command\")\n\n\t// Get command parameters from query parameter\n\tcommandParameters := req.URL.Query().Get(\"parameters\")\n\n\t// Check if robot name is empty\n\tif robotName == \"\" {\n\t\t// Write error response\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"Robot name is empty\"))\n\t\treturn\n\t}\n\n\t// Check if device name is empty\n\tif deviceName == \"\" {\n\t\t// Write error response\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"Device name is empty\"))\n\t\treturn\n\t}\n\n\t// Check if command name is empty\n\tif commandName == \"\" {\n\t\t// Write error response\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"Command name is empty\"))\n\t\treturn\n\t}\n\n\t// Check if command parameters is empty\n\tif commandParameters == \"\" {\n\t\t// Write error response\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"Command parameters are empty\"))\n\t\treturn\n\t}\n\n\t// Get the robot\n\trobot, err := a.Robot(robotName)\n\tif err != nil {\n\t\t// Write error response\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\t// Check if the device exists\n\tif _, err := robot.Device(deviceName); err != nil {\n\t\t// Write error response\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\t// Get the command\n\tcommand, err := robot.Device(deviceName).Command(commandName)\n\t", "CodeBleu_score": 47.13823525266582}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username)) == 1 && subtle.ConstantTimeCompare([]byte(pair[1]), []byte(password)) == 1 {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n}", "CodeBleu_score": 48.5354254710726}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Authentication succeeded\n\t\t// Proceed to the next handler\n\t\t// ...\n\t}\n}", "CodeBleu_score": 50.43363720128864}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If user is authorized, continue with the handler chain...\n\t\t// ...\n\t}\n}", "CodeBleu_score": 50.55644452804026}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// lock the sensor\n\tif err := a.lock(); err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\t// check if the connection supports analog reading\n\tif !a.connection.SupportsAnalogRead() {\n\t\ta.unlock()\n\t\treturn 0, 0.0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\t// get the raw sensor value\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\ta.unlock()\n\t\treturn 0, 0.0, err\n\t}\n\n\t// scale the raw value\n\tvar scaledValue float64\n\tswitch a.scale {\n\tcase Scale_1x:\n\t\tscaledValue = float64(rawValue)\n\tcase Scale_2x:\n\t\tscaledValue = float64(rawValue) / 2.0\n\tcase Scale_4x:\n\t\tscaledValue = float64(rawValue) / 4.0\n\tcase Scale_8x:\n\t\tscaledValue = float64(rawValue) / 8.0\n\tcase Scale_16x:\n\t\tscaledValue = float64(rawValue) / 16.0\n\t}\n\n\t// update the last read values\n\ta.lastRead = time.Now()\n\ta.lastReadRawValue = rawValue\n\ta.lastReadScaledValue = scaledValue\n\n\t// unlock the sensor\n\ta.unlock()\n\n\t// return the raw and scaled values\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 44.66066872460054}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0.0, fmt.Errorf(\"analog reading not supported by connection\")\n\t}\n\n\t// Lock the sensor for reading\n\tif err := a.connection.Lock(a.pin); err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\tdefer a.connection.Unlock(a.pin)\n\n\t// Read the raw value\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tvar scaled float64\n\tswitch a.scale {\n\tcase 1024:\n\t\tscaled = float64(raw) / 1024.0\n\tcase 1000:\n\t\tscaled = float64(raw) / 1000.0\n\tcase 100:\n\t\tscaled = float64(raw) / 100.0\n\tcase 10:\n\t\tscaled = float64(raw) / 10.0\n\tcase 1:\n\t\tscaled = float64(raw)\n\tdefault:\n\t\tscaled = float64(raw) / float64(a.scale)\n\t}\n\n\t// Update the last read values\n\ta.lastRead.raw = raw\n\ta.lastRead.scaled = scaled\n\n\t// Return the raw and scaled values\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 45.67362781424874}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif !a.SupportsAnalogReading() {\n\t\treturn 0, 0.0, fmt.Errorf(\"AnalogReading is not supported by the driver\")\n\t}\n\ta.Lock()\n\tdefer a.Unlock()\n\trawValue, err := a.connection.Read()\n\tif err != nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"AnalogReading failed: %v\", err)\n\t}\n\ta.lastRead = time.Now()\n\ta.lastRaw = rawValue\n\ta.lastScaled = a.Scale(rawValue)\n\treturn rawValue, a.lastScaled, nil\n}", "CodeBleu_score": 46.664772181653916}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := &GroveSoundSensorDriver{\n\t\tname:     \"GroveSoundSensor\",\n\t\tpin:      pin,\n\t\tinterval: 100 * time.Millisecond,\n\t\tsound:    make(chan float64),\n\t\tsoundSrc: NewAnalogSensorDriver(a, pin),\n\t}\n\ts.AddEvent(\"sound\")\n\ts.AddEvent(\"calibrate\")\n\ts.AddCommand(\"Calibrate\")\n\ts.AddCommand(\"Sound\")\n\ts.soundSrc.SetName(s.name)\n\ts.soundSrc.SetConnected(s.connected)\n\ts.soundSrc.SetRead(s.read)\n\ts.soundSrc.SetReadContinuous(s.readContinuous)\n\ts.soundSrc.SetStop(s.stop)\n\treturn s\n}", "CodeBleu_score": 32.54159138745394}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := &GroveSoundSensorDriver{\n\t\tname:         gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:          pin,\n\t\tAnalogReader: a,\n\t\tthreshold:    0,\n\t\thigh:         1,\n\t\tlow:          0,\n\t}\n\ts.AddEvent(gobot.DefaultName(\"Threshold\"))\n\ts.AddEvent(gobot.DefaultName(\"High\"))\n\ts.AddEvent(gobot.DefaultName(\"Low\"))\n\n\treturn s\n}", "CodeBleu_score": 35.40233687907187}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tname:        \"GroveSoundSensor\",\n\t\tpin:         pin,\n\t\tanalogPin:   a,\n\t\tthreshold:   1023,\n\t\tsoundEvents: make(chan float64),\n\t}\n\treturn d\n}", "CodeBleu_score": 33.41861657462433}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write the soft reset command to the command register\n\td.writeRegister(CommandReg, SoftReset)\n\n\t// Wait for the soft reset command to complete\n\ttime.Sleep(10 * time.Microsecond)\n\n\t// Check the status register to see if the command is still active\n\tstatus := d.readRegister(CommandReg)\n\tif status&0x01 == 0x01 {\n\t\treturn fmt.Errorf(\"softReset: Soft reset command is still active\")\n\t}\n\n\t// Return nil if the command is not active\n\treturn nil\n}", "CodeBleu_score": 30.52911143973268}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.setBitMask(commandReg, softReset)\n\ttime.Sleep(10 * time.Millisecond)\n\tstatus := d.getStatus()\n\tif status & (statusMask << 3) != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed: status = %v\", status)\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.8352671877653}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Reset baud rate divider\n\td.writeRegister(RegisterTxModeReg, 0x00)\n\t// Reset ModWidthReg\n\td.writeRegister(RegisterModWidthReg, 0x26)\n\t// Reset the CommandReg\n\td.writeRegister(RegisterCommandReg, 0x00)\n\t// Reset the ComIEnReg\n\td.writeRegister(RegisterComIEnReg, 0x00)\n\t// Reset the DivIEnReg\n\td.writeRegister(RegisterDivIEnReg, 0x00)\n\t// Reset the ComIrqReg\n\td.writeRegister(RegisterComIrqReg, 0x7F)\n\t// Reset the DivIrqReg\n\td.writeRegister(RegisterDivIrqReg, 0x00)\n\t// Reset the ErrorReg\n\td.writeRegister(RegisterErrorReg, 0x00)\n\t// Reset the Status1Reg\n\td.writeRegister(RegisterStatus1Reg, 0x00)\n\t// Reset the Status2Reg\n\td.writeRegister(RegisterStatus2Reg, 0x00)\n\t// Reset the FIFOLevelReg\n\td.writeRegister(RegisterFIFOLevelReg, 0x01)\n\t// Reset the WaterLevelReg\n\td.writeRegister(RegisterWaterLevelReg, 0x01)\n\t// Reset the ControlReg\n\td.writeRegister(RegisterControlReg, 0x00)\n\t// Reset the BitFramingReg\n\td.writeRegister(RegisterBitFramingReg, 0x00)\n\t// Reset the CollReg\n\td.writeRegister(RegisterCollReg, 0x00)\n\t// Reset the RxSelReg\n\td.writeRegister(RegisterRxSelReg, 0x01)\n\t// Reset the RxThresholdReg\n\td.writeRegister(RegisterRxThresholdReg, 0x00)\n\t// Reset the DemodReg\n\td.writeRegister(RegisterDemodReg, 0x00)\n\t// Reset the", "CodeBleu_score": 14.346897609875276}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check buffer capacity\n\tif len(backData) > 32 {\n\t\treturn 0, fmt.Errorf(\"FIFO buffer too small\")\n\t}\n\n\t// Get the number of bytes in the FIFO buffer\n\tn, err := d.readRegister(FIFODataReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the number of bytes in the FIFO buffer is equal to the number of bytes requested\n\tif n != len(backData) {\n\t\treturn 0, fmt.Errorf(\"Wrong number of bytes received: %d != %d\", n, len(backData))\n\t}\n\n\t// Read the bytes from the FIFO buffer\n\terr = d.readRegisterSlice(FIFODataReg, backData)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Read the control register to get the last bits received\n\treturn d.readRegister(ControlReg)\n}", "CodeBleu_score": 44.892854733975824}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tvar status uint8\n\tvar i uint8\n\tvar n uint8\n\tvar tmp uint8\n\n\t// Check buffer capacity.\n\tif len(backData) > d.FIFODataReg.GetBits(7, 0) {\n\t\treturn 0, fmt.Errorf(\"Buffer is too small. Expected %d bytes, got %d\", d.FIFODataReg.GetBits(7, 0), len(backData))\n\t}\n\n\t// Read the FIFO data.\n\tfor i = 0; i < len(backData); i++ {\n\t\tn = d.FIFODataReg.GetBits(7, 0)\n\t\tif n == 0 {\n\t\t\treturn 0, fmt.Errorf(\"FIFO is empty\")\n\t\t}\n\t\tif i == 0 {\n\t\t\ttmp = d.FIFODataReg.GetBits(7, 0)\n\t\t}\n\t\tbackData[i] = d.FIFODataReg.GetBits(7, 0)\n\t}\n\n\t// Read the control register.\n\tstatus = d.ControlReg.GetBits(7, 0)\n\n\t// Return the value of the control register.\n\treturn status, nil\n}", "CodeBleu_score": 29.710254210840542}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check if there are any bytes to be read from the FIFO buffer\n\tstatus := d.readRegister(FIFOLevelReg)\n\tif status&0x80 == 0x00 {\n\t\treturn 0, fmt.Errorf(\"readFifo: No bytes available in FIFO buffer\")\n\t}\n\n\t// Check if there are enough bytes available in the FIFO buffer to read the expected number of bytes\n\tif status&0x7F < uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"readFifo: Not enough bytes available in FIFO buffer\")\n\t}\n\n\t// Read the bytes from the FIFO buffer\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i] = d.readRegister(FIFODataReg)\n\t}\n\n\t// Read the control register to get the last bits received\n\treturn d.readRegister(ControlReg), nil\n}", "CodeBleu_score": 32.32897713500422}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Create a new Halt command.\n\tcmd := []byte{piccHalt}\n\n\t// Calculate the CRC_A for the command.\n\tcrc := d.calculateCRC(cmd)\n\n\t// Append the CRC to the command.\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Send the command.\n\tresponse, err := d.transceive(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if response is valid.\n\tif response[0] != piccHaltResponse {\n\t\treturn fmt.Errorf(\"Halt response error: %v\", response[0])\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 33.67577322430134}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"Halting PICC\")\n\t}\n\n\t// Build command\n\tcmd := []byte{piccHalt}\n\n\t// Calculate CRC_A\n\tcrc := d.calcCRC(cmd)\n\n\t// Append CRC_A to command\n\tcmd = append(cmd, crc)\n\n\t// Send command\n\t_, err := d.transceive(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 30.40247129689423}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Create a new command buffer.\n\tcommandBuffer := []byte{piccHaltCommand}\n\n\t// Calculate the CRC_A of the command.\n\tcrc := d.calcCRC(commandBuffer)\n\n\t// Append CRC to the command buffer.\n\tcommandBuffer = append(commandBuffer, crc)\n\n\t// Send the command.\n\tresponse, err := d.transceive(commandBuffer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if response is valid.\n\tif len(response) != 2 || response[0] != piccHaltResponseSize {\n\t\treturn fmt.Errorf(\"Invalid response from PICC: %v\", response)\n\t}\n\n\t// Check if response is OK.\n\tif response[1] != piccHaltResponseCode {\n\t\treturn fmt.Errorf(\"Error from PICC: %v\", response[1])\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 37.53408272475042}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// The command is the same for all cards.\n\tcommand := []byte{MF1_REQIDL, MF1_REQALL, 0, 0, 0, 0}\n\n\t// Transmit the command.\n\tstatus, data := d.transceive(command)\n\tif status != StatusOk {\n\t\treturn nil, fmt.Errorf(\"Error while reading data: 0x%02X\", status)\n\t}\n\n\t// Copy the 4 bytes of data starting at the block address into the result buffer.\n\tresult := make([]byte, 16)\n\tcopy(result, data[block*4:block*4+4])\n\n\treturn result, nil\n}", "CodeBleu_score": 21.368184261285002}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// The command is the same for all blocks.\n\tcommand := []byte{MF1_REQIDL, MF1_REQALL, 0x20}\n\t// Append the block address to the command.\n\tcommand = append(command, block)\n\t// Calculate the CRC_A for the command.\n\tcrc := d.calcCRC(command)\n\t// Append the CRC_A to the command.\n\tcommand = append(command, crc[0])\n\tcommand = append(command, crc[1])\n\t// Send the command.\n\tstatus := d.pcdWrite(command)\n\tif status != MI_OK {\n\t\treturn nil, fmt.Errorf(\"Error: MI_ERR (status: 0x%02X)\", status)\n\t}\n\t// Allocate memory for the response buffer.\n\tresponse := make([]byte, 18)\n\t// Fill the response buffer with zeros.\n\tfor i := 0; i < 18; i++ {\n\t\tresponse[i] = 0\n\t}\n\t// Perform the MFRC522-to-PCD communication to receive the data from the PICC.\n\tstatus = d.pcdComMF522ToPCD(command, response)\n\tif status != MI_OK {\n\t\treturn nil, fmt.Errorf(\"Error: MI_ERR (status: 0x%02X)\", status)\n\t}\n\t// Verify the checksum of the response.\n\tif d.verify(response, 0x20) != 0 {\n\t\treturn nil, fmt.Errorf(\"Error: CRC_ERR\")\n\t}\n\t// Copy the received data to the output buffer.\n\tdata := make([]byte, 16)\n\tfor i := 0; i < 16; i++ {\n\t\tdata[i] = response[i+1]\n\t}\n\treturn data, nil\n}", "CodeBleu_score": 37.404473309989115}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Construct the command to read a 16 byte data block from the specified block.\n\t// See 7.3.10 in http://www.nxp.com/documents/data_sheet/MF1S503x.pdf\n\t// The command is 4 bytes long. The first 2 bytes are the command header.\n\t// The next byte is the block address. The last byte is the CRC.\n\tvar cmd []byte = []byte{0x30, 0x00}\n\tcmd = append(cmd, block)\n\t// The CRC is calculated from the command header and block address.\n\tcrc := d.calculateCRC(cmd)\n\tcmd = append(cmd, crc)\n\t// Send the command.\n\tif err := d.writeBytes(cmd); err != nil {\n\t\treturn nil, err\n\t}\n\t// Read the response.\n\tresponse, err := d.readBytes(18)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Check the response status.\n\tif response[0] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"read failed: %d\", response[0])\n\t}\n\t// Return the data.\n\treturn response[1:17], nil\n}", "CodeBleu_score": 40.215608088481645}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Sanity check\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Clear the bits in the collision register that are used in this function\n\td.clearCollReg()\n\n\t// Set the bits in the collision register that are used in this function\n\td.setCollReg(0x80)\n\n\t// Repeat Cascade Level 1 to get the UID of the card\n\tif reqMode == REQA {\n\t\td.setBitMask(d.CollReg, 0x04)\n\t} else if reqMode == HLTA {\n\t\td.clearBitMask(d.CollReg, 0x04)\n\t}\n\n\t// Transceive the data\n\t_, err := d.transceive([]byte{reqMode})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Copy the 4 uint8_ts into the answer buffer\n\tcopy(answer, d.buffer[0:4])\n\n\t// Return the error code from the PICC\n\treturn d.getError()\n}", "CodeBleu_score": 51.39046299473421}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tvar (\n\t\tstatus  uint8\n\t\tbackLen uint8\n\t\tbuf     []byte\n\t)\n\t// Check buffer size\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"Buffer too small!\")\n\t}\n\t// Clear the bits in the collision register that are used for receiving the answer\n\td.clearCollReg()\n\t// Set the transmission to use only 7 bits of the last byte\n\td.setBitMask(d.regTxControl, 0x01<<4)\n\t// Transceive the bytes\n\tstatus, backLen, buf = d.transceive([]byte{reqMode, 0})\n\tif status != MI_OK || backLen != 0 || len(buf) != 0 {\n\t\treturn fmt.Errorf(\"Error while requesting PICC: %v\", status)\n\t}\n\t// Copy the 4 bytes from the answer\n\tcopy(answer, buf)\n\treturn nil\n}", "CodeBleu_score": 43.18754115299305}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tvar err error\n\tvar cmd []byte\n\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: answer buffer too small\")\n\t}\n\n\t// Clear the bits in the collision register that are used to indicate a collision.\n\td.clearCollReg()\n\n\t// Set the bits in the FIFO that indicate which buffer to use for the data to write to the PICC.\n\t// This is done in the command because it also indicates which buffer to use for the reply from the PICC.\n\tswitch reqMode {\n\tcase REQA_CMD:\n\t\tcmd = []byte{REQA_CMD, 0x20}\n\tcase WUPA_CMD:\n\t\tcmd = []byte{WUPA_CMD, 0x20}\n\tcase MFAUTHENT_CMD:\n\t\tcmd = []byte{MFAUTHENT_CMD, 0x20}\n\tdefault:\n\t\treturn fmt.Errorf(\"piccRequest: invalid request mode\")\n\t}\n\n\t// Transceive the command.\n\terr = d.transceive(cmd, answer, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check that the response is valid.\n\tif answer[0] != cmd[0] {\n\t\treturn fmt.Errorf(\"piccRequest: received invalid response\")\n\t}\n\n\t// Return the answer code.\n\treturn nil\n}", "CodeBleu_score": 47.895812292620846}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif d.stepPin == nil {\n\t\treturn fmt.Errorf(\"step pin not set\")\n\t}\n\tif d.direction == 1 {\n\t\tif d.stepNumber >= d.stepsPerRevolution {\n\t\t\td.stepNumber = 0\n\t\t} else {\n\t\t\td.stepNumber++\n\t\t}\n\t} else {\n\t\tif d.stepNumber <= 0 {\n\t\t\td.stepNumber = d.stepsPerRevolution\n\t\t} else {\n\t\t\td.stepNumber--\n\t\t}\n\t}\n\td.stepPin.DigitalWrite(gobot.Low)\n\ttime.Sleep(d.stepDelay)\n\td.stepPin.DigitalWrite(gobot.High)\n\treturn nil\n}", "CodeBleu_score": 37.65718285260062}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == nil {\n\t\treturn fmt.Errorf(\"step pin not set\")\n\t}\n\n\tif d.direction == DirectionClockwise {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\td.stepPin.Write(gpio.Low)\n\ttime.Sleep(d.stepDelay)\n\td.stepPin.Write(gpio.High)\n\n\treturn nil\n}", "CodeBleu_score": 39.3180877890546}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\t// if the motor is not running, do nothing\n\tif d.running == false {\n\t\treturn nil\n\t}\n\t// set the step pin low\n\tif err := d.stepPin.DigitalWrite(gobot.Low); err != nil {\n\t\treturn err\n\t}\n\t// wait for the delay\n\ttime.Sleep(time.Duration(d.delay) * time.Microsecond)\n\t// set the step pin high\n\tif err := d.stepPin.DigitalWrite(gobot.High); err != nil {\n\t\treturn err\n\t}\n\t// increment or decrement the step number\n\tif d.direction == FORWARD {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 65.91702438174349}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorRunning = true\n\td.stopDistanceMonitor = make(chan struct{})\n\td.wg.Add(1)\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopDistanceMonitor:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.Distance(); err != nil {\n\t\t\t\t\tfmt.Println(err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Duration(d.DistanceInterval) * time.Millisecond)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 44.523446498643985}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitoring {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitoring = true\n\td.distanceMonitorWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorWaitGroup.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopDistanceMonitor:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\td.distanceMonitoring = true\n\t\t\t\tdistance, err := d.Distance()\n\t\t\t\tif err != nil {\n\t\t\t\t\td.distanceMonitoring = false\n\t\t\t\t\td.distanceMonitorWaitGroup.Done()\n\t\t\t\t\td.Error(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\td.DistanceMonitor(distance)\n\t\t\t\ttime.Sleep(d.DistanceInterval)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 47.59907428663993}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorRunning = true\n\td.distanceMonitorStop = make(chan bool)\n\td.distanceMonitorWg = &sync.WaitGroup{}\n\td.distanceMonitorWg.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorWg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.Distance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Println(\"error during distance measurement: \", err)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"distance: %f\n\", distance)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Second * 1)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 49.9045079334458}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTime time.Time\n\treturn func(int, time.Duration, string, uint32, uint32) {\n\t\tif startTime.IsZero() {\n\t\t\tstartTime = time.Now()\n\t\t} else {\n\t\t\td.event <- time.Since(startTime)\n\t\t\tstartTime = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 31.71468128518054}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTime time.Time\n\treturn func(level int, duration time.Duration, edge string, timestamp uint32, value uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\td.distance = float64(duration.Nanoseconds()) / 29. / 2.\n\t\t\td.event <- gobot.Event{\n\t\t\t\t\"name\":    \"distance\",\n\t\t\t\t\"distance\": d.distance,\n\t\t\t}\n\t\t\tstartTime = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.12648507752331}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, event string, value uint32, errno uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\td.pulseDuration <- time.Since(start)\n\t\t}\n\t}\n}", "CodeBleu_score": 35.12560644008097}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\tvar err error\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\td.pin.DigitalWrite(HIGH)\n\ttime.Sleep(10 * time.Millisecond)\n\td.pin.DigitalWrite(LOW)\n\td.pin.UltrasonicRead(func(distance uint, err error) {\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"failed to read ultrasonic sensor: %v\", err)\n\t\t} else {\n\t\t\td.distance = distance\n\t\t}\n\t})\n\tselect {\n\tcase <-time.After(time.Second):\n\t\terr = fmt.Errorf(\"timeout\")\n\tcase <-d.done:\n\t\terr = fmt.Errorf(\"stopped\")\n\t}\n\treturn err\n}", "CodeBleu_score": 43.51703603146639}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the mutex\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\td.connection.DigitalWrite(d.triggerPin, 1)\n\ttime.Sleep(10 * time.Microsecond)\n\td.connection.DigitalWrite(d.triggerPin, 0)\n\n\t// Wait for the sensor to finish measuring\n\t// If the measurement takes longer than 20ms, return an error\n\tstart := time.Now()\n\tfor {\n\t\tif time.Since(start) > 20*time.Millisecond {\n\t\t\treturn fmt.Errorf(\"Timeout while measuring distance\")\n\t\t}\n\t\tif d.connection.DigitalRead(d.echoPin) == 1 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Store the time the echo pin went high\n\td.echoHighTime = time.Since(start)\n\n\treturn nil\n}", "CodeBleu_score": 48.75250520411332}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\td.connection.DigitalWrite(d.trigPin, 1)\n\ttime.Sleep(10 * time.Millisecond)\n\td.connection.DigitalWrite(d.trigPin, 0)\n\ttime.Sleep(10 * time.Millisecond)\n\td.connection.DigitalWrite(d.echoPin, 1)\n\td.connection.DigitalWrite(d.echoPin, 0)\n\tvar timeout = make(chan bool, 1)\n\tgo func() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\ttimeout <- true\n\t}()\n\tselect {\n\tcase <-timeout:\n\t\treturn fmt.Errorf(\"timeout\")\n\tcase <-d.echo:\n\t\treturn nil\n\t}\n}", "CodeBleu_score": 42.33676724211063}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    access_token = os.getenv(\"PLATFORMIO_ACCESS_TOKEN\")\n    if not access_token:\n        access_token = self.get_access_token()\n        if not access_token:\n            raise UserSideException(\"Account not authorized\")\n    return access_token\n\n", "CodeBleu_score": 15.820084324981076}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        if \"PLATFORMIO_AUTH_TOKEN\" in os.environ:\n            return os.environ[\"PLATFORMIO_AUTH_TOKEN\"]\n        elif self._access_token and self._access_token_expiration > time.time():\n            return self._access_token\n        elif self._refresh_token and self._refresh_token_expiration > time.time():\n            self._access_token, self._access_token_expiration = self._refresh_access_token()\n            return self._access_token\n        else:\n            raise AccountNotAuthorized()\n    except AccountNotAuthorized:\n        raise AccountNotAuthorized(\n            \"Please login to PlatformIO account to continue. \"\n            \"See https://docs.platformio.org/en/latest/core/user/account/login.html for details\"\n        )\n\n", "CodeBleu_score": 29.785555299557583}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        if \"PLATFORMIO_ACCESS_TOKEN\" in os.environ:\n            return os.environ[\"PLATFORMIO_ACCESS_TOKEN\"]\n        if \"PLATFORMIO_ACCESS_TOKEN\" in app.get_state():\n            if time.time() < app.get_state()[\"PLATFORMIO_ACCESS_TOKEN_EXPIRES\"]:\n                return app.get_state()[\"PLATFORMIO_ACCESS_TOKEN\"]\n            if \"PLATFORMIO_REFRESH_TOKEN\" in app.get_state():\n                return __accounts_api__.fetch_authentication_token(\n                    app.get_state()[\"PLATFORMIO_REFRESH_TOKEN\"]\n                )\n    except Exception as e:\n        raise UserSideException(\n            \"Failed to fetch authentication token: %s\" % str(e)\n        ) from e\n    raise UserSideException(\"Failed to fetch authentication token\")\n\n", "CodeBleu_score": 27.622048444617693}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        # retrieve the refresh token\n        refresh_token = self.get_refresh_token()\n        # delete the local session\n        self.delete_session()\n        # attempt to send a POST request to the logout endpoint\n        http = HTTPClient(\n            url=__accounts_api__ + \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer \" + refresh_token},\n        )\n        http.request(\"POST\")\n    except (HTTPClientError, UserSideException, PlatformioException):\n        # ignore the AccountError\n        pass\n    return True\n\n", "CodeBleu_score": 46.49263345791014}, {"code": "def logout(self)\n\t\n    try:\n        # retrieve refresh token\n        refresh_token = self.get_refresh_token()\n        # delete local session\n        self.delete_session()\n        # send POST request to logout\n        http_client = HTTPClient()\n        http_client.post(\n            \"/v1/logout\",\n            headers={\n                \"Authorization\": \"Bearer {}\".format(refresh_token),\n                \"Content-Type\": \"application/json\",\n            },\n        )\n    except HTTPClientError as e:\n        if e.code != 401:\n            raise\n    return True\n\n", "CodeBleu_score": 43.11048216332449}, {"code": "def logout(self)\n\t\n    if not self.is_logged_in():\n        raise UserSideException(\"You are not logged in!\")\n    refresh_token = self.get_refresh_token()\n    self.delete_session()\n    try:\n        HTTPClient().post(\"/v1/logout\", {\"refresh_token\": refresh_token})\n    except HTTPClientError:\n        pass\n    return True\n\n", "CodeBleu_score": 61.99920181415833}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for name, package in self.packages.items():\n        if package.optional:\n            continue\n        package_spec = PackageSpec(name, package.version)\n        if package_spec.is_external():\n            packages.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                    \"source\": package_spec.source,\n                }\n            )\n        else:\n            packages.append({\"name\": package.name, \"version\": package.version})\n    return packages\n\n", "CodeBleu_score": 31.760233133374992}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        result.append({\n            \"name\": package.name,\n            \"version\": package.version,\n            \"url\": package.url,\n            \"description\": package.description,\n            \"author\": package.author,\n            \"maintainer\": package.maintainer,\n            \"license\": package.license,\n            \"url\": package.url,\n            \"frameworks\": package.frameworks,\n            \"architectures\": package.architectures,\n            \"platforms\": package.platforms,\n            \"features\": package.features,\n            \"dependencies\": package.dependencies,\n            \"optional\": package.optional,\n            \"external\": package.external,\n            \"custom\": package.custom\n        })\n    return result\n\n", "CodeBleu_score": 22.803077185223408}, {"code": "def dump_used_packages(self)\n\t\n    used_packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        package_spec = PackageSpec(package.name, package.version)\n        if package_spec.is_external():\n            package_spec.url = package.url\n        used_packages.append(package_spec)\n    return used_packages\n\n", "CodeBleu_score": 22.877837686025277}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not targets:\n        targets = []\n    if not isinstance(targets, list):\n        targets = [targets]\n    if not env:\n        raise UndefinedEnvPlatformError()\n    config = ProjectConfig.get_instance()\n    platform_spec = config.get(\"env:\" + env, \"platform\")\n    if not platform_spec:\n        raise UndefinedEnvPlatformError()\n    platform = cls.get_platform_by_spec(platform_spec)\n    if not platform:\n        if autoinstall:\n            platform = cls.autoinstall_platform(platform_spec)\n        else:\n            raise UnknownPlatform(platform_spec)\n    if not isinstance(platform, cls):\n        raise ValueError(\"Invalid platform class\")\n    platform.set_environment(env)\n    platform.configure_packages(targets, autoinstall)\n    return platform\n\n", "CodeBleu_score": 40.26272738877079}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not env:\n        raise UndefinedEnvPlatformError(\"Environment is not specified\")\n    if not targets:\n        targets = []\n    config = ProjectConfig.get_instance()\n    platform = config.get(\n        \"env:%s:platform\" % env,\n        config.get(\"platform\", None),\n        var_type=str,\n        project_only=True,\n    )\n    if not platform:\n        raise UndefinedEnvPlatformError(\n            \"Platform is not specified for the environment %s\" % env\n        )\n    try:\n        platform_cls = base.PlatformBase.get_platform_class(platform)\n    except UnknownPlatform:\n        if autoinstall:\n            platform_cls = base.PlatformBase.install_platform(platform)\n        else:\n            raise\n    if not platform_cls:\n        raise UnknownPlatform(\n            \"Platform %s is not installed\" % platform,\n            \"Run `platformio platform install %s`\" % platform,\n        )\n    platform_inst = platform_cls(\n        config.get(\"env:%s:framework\" % env, None, var_type=str, project_only=True)\n    )\n    platform_inst.configure_env(env, autoinstall=autoinstall)\n    platform_inst.configure_packages(\n        env,\n        targets,\n        config.get(\n            \"env:%s:packages\" % env,\n            config.get(\"packages\", None),\n            var_type=list,\n            project_only=True,\n        ),\n        config.get(\n            \"env:%s:lib_deps\" % env,\n            config.get(\"lib_deps\", None),\n            var_type=list,\n            project_only=True,\n        ),\n        config.get(\n            \"env:%s:lib_ignore\" % env,\n            config.get(\"lib_ignore\", None),\n            var_type=list,\n            project_only=True,\n        ),\n        config.get(\n            \"env:%s:extra_scripts\" % env,\n            config.get(\"extra_scripts\", None),\n            var_type=list,\n            project_only=True,\n        ),\n", "CodeBleu_score": 34.21675491932636}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not targets:\n        targets = []\n    if not env:\n        raise UndefinedEnvPlatformError()\n    if not isinstance(env, str):\n        raise ValueError(\"Environment name should be a string\")\n    if not isinstance(targets, list):\n        raise ValueError(\"Targets should be a list\")\n    if not isinstance(autoinstall, bool):\n        raise ValueError(\"Autoinstall should be a boolean\")\n\n    config = ProjectConfig.get_instance()\n    env_data = config.envs[env]\n    if not env_data:\n        raise UndefinedEnvPlatformError()\n    if not env_data.get(\"platform\"):\n        raise UndefinedEnvPlatformError()\n\n    platform = cls(env_data[\"platform\"], autoinstall)\n    platform.configure_env(env, targets)\n    platform.configure_packages(env, targets)\n    return platform\n\n", "CodeBleu_score": 36.77006559413216}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(AXP192_ADDR);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(AXP192_ADDR, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 63.29111195816427}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(AXP192_ADDR);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(AXP192_ADDR, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 63.29111195816427}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire.beginTransmission(AXP192_ADDR);\n    Wire.write(Addr);\n    Wire.endTransmission();\n    Wire.requestFrom(AXP192_ADDR, Size);\n    for (uint8_t i = 0; i < Size; i++) {\n        Buff[i] = Wire.read();\n    }\n}", "CodeBleu_score": 65.04664261341225}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  if (time_in_us == 0) {\n    SetSleep();\n    SetPowerOutPut(AXP192_DCDC2, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC1, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC3, AXP192_OFF);\n    SetPowerOutPut(AXP192_LDO2, AXP192_OFF);\n    SetPowerOutPut(AXP192_LDO3, AXP192_OFF);\n    SetPowerOutPut(AXP192_LDO4, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC4, AXP192_OFF);\n    SetPowerOutPut(AXP192_EXTEN, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC1, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC3, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC4, AXP192_OFF);\n    SetPowerOutPut(AXP192_LDO2, AXP192_OFF);\n    SetPowerOutPut(AXP192_LDO3, AXP192_OFF);\n    SetPowerOutPut(AXP192_LDO4, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC2, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC1, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC3, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC4, AXP192_OFF);\n    SetPowerOutPut(AXP192_EXTEN", "CodeBleu_score": 24.35496361712173}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  uint8_t reg = 0x00;\n  if (time_in_us > 0) {\n    reg |= 0x01;\n    SetTimer(time_in_us);\n  }\n  WriteByte(0x32, reg);\n  WriteByte(0x33, reg);\n  WriteByte(0x34, reg);\n  WriteByte(0x35, reg);\n  WriteByte(0x36, reg);\n  WriteByte(0x37, reg);\n  WriteByte(0x38, reg);\n  WriteByte(0x39, reg);\n  WriteByte(0x3A, reg);\n  WriteByte(0x3B, reg);\n  WriteByte(0x3C, reg);\n  WriteByte(0x3D, reg);\n  WriteByte(0x3E, reg);\n  WriteByte(0x3F, reg);\n  WriteByte(0x40, reg);\n  WriteByte(0x41, reg);\n  WriteByte(0x42, reg);\n  WriteByte(0x43, reg);\n  WriteByte(0x44, reg);\n  WriteByte(0x45, reg);\n  WriteByte(0x46, reg);\n  WriteByte(0x47, reg);\n  WriteByte(0x48, reg);\n  WriteByte(0x49, reg);\n  WriteByte(0x4A, reg);\n  WriteByte(0x4B, reg);\n  WriteByte(0x4C, reg);\n  WriteByte(0x4D, reg);\n  WriteByte(0x4E, reg);\n  WriteByte(0x4F, reg);\n  WriteByte(0x50, reg);\n  WriteByte(0x51, reg);\n  WriteByte(0x52, reg);\n  WriteByte(0x53, reg);\n  WriteByte(0x54, reg);\n  WriteByte(0x55, reg);\n  WriteByte(0x56, reg);\n  WriteByte(0x57, reg);\n  WriteByte", "CodeBleu_score": 34.3048674626954}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    if (time_in_us > 0) {\n        SetSleep();\n        SetWakeupTimer(time_in_us);\n    } else {\n        SetSleep();\n    }\n    SetPowerOutPut(AXP192_LDO2, AXP192_OFF);\n    SetPowerOutPut(AXP192_LDO3, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC2, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC3, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC4, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC1, AXP192_OFF);\n    SetPowerOutPut(AXP192_DCDC5, AXP192_OFF);\n    SetPowerOutPut(AXP192_EXTEN, AXP192_OFF);\n    SetPowerOutPut(AXP192_GPIO0, AXP192_OFF);\n    SetPowerOutPut(AXP192_GPIO1, AXP192_OFF);\n    SetPowerOutPut(AXP192_GPIO2, AXP192_OFF);\n    SetPowerOutPut(AXP192_GPIO3, AXP192_OFF);\n    SetPowerOutPut(AXP192_GPIO4, AXP192_OFF);\n    SetPowerOutPut(AXP192_GPIO5, AXP192_OFF);\n    SetPowerOutPut(AXP192_GPIO6, AXP192_OFF);\n    SetPowerOutPut(AXP192_GPIO7, AXP192_OFF);\n    SetPowerOutPut(AXP192_GPIO8, AXP192_OFF);\n    SetPowerOutPut(AXP1", "CodeBleu_score": 41.72675800979045}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint old_y = this->y;\n\tint old_x = this->x;\n\tthis->y += this->height;\n\tif (this->y >= this->height - this->bottom_fixed_area) {\n\t\tthis->y = this->top_fixed_area;\n\t}\n\tthis->fill_rectangle(this->x, this->y, this->width, this->height, color);\n\tthis->update_scroll_address();\n\tthis->x = old_x;\n\tthis->y = old_y;\n\treturn old_y;\n}", "CodeBleu_score": 8.043378957532962}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint prev_y = y;\n\tint prev_x = x;\n\tint prev_h = h;\n\tint prev_w = w;\n\tint prev_s = s;\n\tint prev_c = c;\n\tint prev_f = f;\n\tint prev_b = b;\n\tint prev_a = a;\n\tint prev_g = g;\n\tint prev_d = d;\n\tint prev_i = i;\n\tint prev_r = r;\n\tint prev_l = l;\n\tint prev_t = t;\n\tint prev_e = e;\n\tint prev_p = p;\n\tint prev_u = u;\n\tint prev_k = k;\n\tint prev_y_scroll = y_scroll;\n\tint prev_y_scroll_max = y_scroll_max;\n\tint prev_y_scroll_min = y_scroll_min;\n\tint prev_y_scroll_step = y_scroll_step;\n\tint prev_y_scroll_wrap = y_scroll_wrap;\n\tint prev_y_scroll_top = y_scroll_top;\n\tint prev_y_scroll_bottom = y_scroll_bottom;\n\tint prev_y_scroll_top_alt = y_scroll_top_alt;\n\tint prev_y_scroll_bottom_alt = y_scroll_bottom_alt;\n\tint prev_y_scroll_top_alt_2 = y_scroll_top_alt_2;\n\tint prev_y_scroll_bottom_alt_2 = y_scroll_bottom_alt_2;\n\tint prev_y_scroll_top_alt_3 = y_scroll_top_alt_3;\n\tint prev_y_scroll_bottom_alt_3 = y_scroll_bottom_alt_3;\n\tint prev_y_scroll_top_alt_4 = y_scroll_top_alt_4;\n\tint prev_y_scroll_bottom_alt_4 = y_scroll_bottom_alt_4;\n\tint prev_y_scroll_top_alt_5 = y_scroll_top_alt_5;\n\tint prev_y_scroll_bottom", "CodeBleu_score": 4.80687587202847}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint old_y = y;\n\n\t// check if the top fixed area should be used\n\tif (y < tteBar) {\n\t\ty = tteBar;\n\t}\n\n\t// fill the new line with the specified color\n\tfillRect(x, y, width, height, color);\n\n\t// increment the y-coordinate\n\ty += height;\n\n\t// wrap around if it exceeds the display boundaries minus the bottom fixed area\n\tif (y > height + tteBar) {\n\t\ty = tteBar;\n\t}\n\n\t// update the scroll address\n\tsetScroll(x, y);\n\n\treturn old_y;\n}", "CodeBleu_score": 20.864618333415592}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t    if (!_portal.begin()) {\n        return false;\n    }\n\n    if (!_portal.set_html(HTML_HEADER, HTML_FOOTER, HTML_CSS)) {\n        return false;\n    }\n\n    if (!_portal.set_access_points(access_points)) {\n        return false;\n    }\n\n    if (!_portal.set_ssids(ssids)) {\n        return false;\n    }\n\n    if (!_portal.set_on_connect(on_connect)) {\n        return false;\n    }\n\n    if (!_portal.set_on_disconnect(on_disconnect)) {\n        return false;\n    }\n\n    if (!_portal.set_on_portal_start(on_portal_start)) {\n        return false;\n    }\n\n    if (!_portal.set_on_portal_stop(on_portal_stop)) {\n        return false;\n    }\n\n    if (!_portal.set_on_portal_timeout(on_portal_timeout)) {\n        return false;\n    }\n\n    if (!_portal.set_on_portal_timeout_start(on_portal_timeout_start)) {\n        return false;\n    }\n\n    if (!_portal.set_on_portal_timeout_stop(on_portal_timeout_stop)) {\n        return false;\n    }\n\n    if (!_portal.set_on_portal_timeout_tick(on_portal_timeout_tick)) {\n        return false;\n    }\n\n    if (!_portal.set_on_portal_tick(on_portal_tick)) {\n        return false;\n    }\n\n    if (!_portal.set_on_portal_wifi_scan_done(on_portal_wifi_scan_done)) {\n        return false;\n    }\n\n    if (!_portal.set_on_portal_wifi_scan_start(on_portal_wifi_scan_start)) {\n        return false;\n    }\n\n    if (!_portal.set_on_portal_wifi_scan_tick(on_portal_wifi_scan_tick)) {\n        return false;\n   ", "CodeBleu_score": 40.91101593831311}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!portal.begin()) {\n\t\treturn false;\n\t}\n\tif (!portal.set_access_points(access_points)) {\n\t\treturn false;\n\t}\n\tif (!portal.set_html_content(html_content)) {\n\t\treturn false;\n\t}\n\tif (!portal.set_ssids(ssids)) {\n\t\treturn false;\n\t}\n\tif (!portal.start()) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 48.340536145793585}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  if (ssids == NULL || access_points == NULL) {\n    return false;\n  }\n\n  // Set up the access points\n  for (int i = 0; i < access_points->getLength(); i++) {\n    if (WiFi.softAP(access_points->get(i).getSSID(), access_points->get(i).getPassword()) != WL_CONNECTED) {\n      return false;\n    }\n  }\n\n  // Set up the HTML content\n  if (!setupHTML(ssids)) {\n    return false;\n  }\n\n  // Start the portal\n  if (!startPortal()) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 49.847055328874866}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t    if (queue_enabled_flag) {\n        if (queue == nullptr) {\n            queue = new Queue(GPS_QUEUE_SIZE);\n        }\n        if (text == nullptr) {\n            text = new Text();\n        }\n        if (text_in == nullptr) {\n            text_in = new Text();\n        }\n    }\n    else {\n        if (queue != nullptr) {\n            queue->flush();\n            delete queue;\n            queue = nullptr;\n        }\n        if (text != nullptr) {\n            delete text;\n            text = nullptr;\n        }\n        if (text_in != nullptr) {\n            delete text_in;\n            text_in = nullptr;\n        }\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 10.522265739466793}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (queue == NULL) {\n\t\t\tqueue = new Queue<GpsData>(MAX_QUEUE_SIZE);\n\t\t\ttext = new Text(MAX_TEXT_SIZE);\n\t\t\ttext_in = new Text(MAX_TEXT_SIZE);\n\t\t}\n\t} else {\n\t\tif (queue != NULL) {\n\t\t\tdelete queue;\n\t\t\tdelete text;\n\t\t\tdelete text_in;\n\t\t\tqueue = NULL;\n\t\t\ttext = NULL;\n\t\t\ttext_in = NULL;\n\t\t}\n\t\tqueue = new Queue<GpsData>(MAX_QUEUE_SIZE);\n\t\ttext = new Text(MAX_TEXT_SIZE);\n\t\ttext_in = new Text(MAX_TEXT_SIZE);\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 11.699640792805491}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (queue != NULL) {\n\t\t\tif (text != NULL) {\n\t\t\t\tif (text_in != NULL) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue_enabled_flag = true;\n\n\tqueue = new Queue<char>(queue_size);\n\ttext = new char[text_size];\n\ttext_in = new char[text_size];\n\n\treturn;\n}", "CodeBleu_score": 9.903265191624243}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea != NULL) {\n\t\twhile (!queue_nmea->empty()) {\n\t\t\tqueue_nmea->pop();\n\t\t}\n\t}\n\telse {\n\t\tqueue_nmea = new std::queue<std::string>();\n\t}\n}", "CodeBleu_score": 36.43638036479667}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (queue_nmea != NULL) {\n        while (queue_nmea->size() > 0) {\n            queue_nmea->pop();\n        }\n    }\n    else {\n        queue_nmea = new queue<string>();\n    }\n}", "CodeBleu_score": 44.82083428534727}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (queue_nmea != NULL) {\n        delete queue_nmea;\n    }\n    queue_nmea = new std::queue<std::string>();\n}", "CodeBleu_score": 37.927951737389044}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n    // 1. Start a write transaction\n    //    This function is required before any write to the display memory.\n    //    It informs the display controller that we are about to write to its memory.\n    //    It also sets the address window to the area to be updated.\n    //    The address window is set to the area to be updated.\n    //    This function must be called before any write to the display memory.\n    //    It informs the display controller that we are about to write to its memory.\n    //    It also sets the address window to the area to be updated.\n    //    The address window is set to the area to be updated.\n    //    This function must be called before any write to the display memory.\n    //    It informs the display controller that we are about to write to its memory.\n    //    It also sets the address window to the area to be updated.\n    //    The address window is set to the area to be updated.\n    //    This function must be called before any write to the display memory.\n    //    It informs the display controller that we are about to write to its memory.\n    //    It also sets the address window to the area to be updated.\n    //    The address window is set to the area to be updated.\n    //    This function must be called before any write to the display memory.\n    //    It informs the display controller that we are about to write to its memory.\n    //    It also sets the address window to the area to be updated.\n    //    The address window is set to the area to be updated.\n    //    This function must be called before any write to the display memory.\n    //    It informs the display controller that we are about to write to its memory.\n    //    It also sets the address window to the area to be updated.\n    //    The address window is set to the area to be updated.\n    //    This function must be called before any write to the display memory.\n    //    It informs the display controller that we are about to write to its memory.\n    //    It also sets the address window to the area to be updated.\n    //    The address window is set to the area to be updated.\n    //    This function must be called before any write to", "CodeBleu_score": 3.2240065919312872}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t x;\n    uint32_t y;\n\n    uint32_t i;\n    uint32_t j;\n    uint32_t k;\n\n    uint32_t x_act;\n    uint32_t y_act;\n\n    uint32_t size_flush;\n    uint32_t size_buf;\n\n    uint32_t *color_p32;\n\n    uint32_t offset;\n\n    uint32_t color_index;\n\n    uint32_t color;\n\n    uint32_t color_temp;\n\n    uint32_t color_temp_part;\n\n    uint32_t color_part;\n\n    uint32_t color_part_2;\n\n    uint32_t color_part_3;\n\n    uint32_t color_part_4;\n\n    uint32_t color_part_5;\n\n    uint32_t color_part_6;\n\n    uint32_t color_part_7;\n\n    uint32_t color_part_8;\n\n    uint32_t color_part_9;\n\n    uint32_t color_part_10;\n\n    uint32_t color_part_11;\n\n    uint32_t color_part_12;\n\n    uint32_t color_part_13;\n\n    uint32_t color_part_14;\n\n    uint32_t color_part_15;\n\n    uint32_t color_part_16;\n\n    uint32_t color_part_17;\n\n    uint32_t color_part_18;\n\n    uint32_t color_part_19;\n\n    uint32_t color_part_20;\n\n    uint32_t color_part_21;\n\n    uint32_t color_part_22;\n\n    uint32_t color_part_23;\n\n    uint32_t color_part_24", "CodeBleu_score": 6.22592220318239}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t x;\n    uint32_t y;\n\n    /*\n     * Put the area's coordinates on the display\n     */\n    lv_area_t a;\n    a.x1 = area->x1;\n    a.x2 = area->x2;\n    a.y1 = area->y1;\n    a.y2 = area->y2;\n\n    /*\n     * Put the coordinates on the display\n     */\n    my_disp_drv_t *my_disp_drv = (my_disp_drv_t *)disp->driver;\n    my_disp_drv->disp_flush(disp, &a, color_p);\n  }", "CodeBleu_score": 29.37945979091272}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->getSize(); i++) {\n\t\tif (menu->getNode(i)->getType() == MENU_NODE) {\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tcout << \"  \";\n\t\t\t}\n\t\t\tcout << menu->getNode(i)->getName() << endl;\n\t\t\tshowMenuList(menu->getNode(i)->getMenu(), layer + 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.574367471357405}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tMenuNode * menuNode = menu->getFirst();\n\twhile (menuNode != NULL) {\n\t\tif (menuNode->getMenu() == NULL) {\n\t\t\tfor (int i = 0; i < layer; i++) {\n\t\t\t\tcout << \"\\t\";\n\t\t\t}\n\t\t\tcout << menuNode->getName() << endl;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < layer; i++) {\n\t\t\t\tcout << \"\\t\";\n\t\t\t}\n\t\t\tcout << menuNode->getName() << endl;\n\t\t\tshowMenuList(menuNode->getMenu(), layer + 1);\n\t\t}\n\t\tmenuNode = menuNode->getNext();\n\t}\n}", "CodeBleu_score": 44.57960379465503}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tMenuNode * node = menu->getFirstNode();\n\twhile (node != NULL) {\n\t\tfor (int i = 0; i < layer; i++) {\n\t\t\tprintf(\"  \");\n\t\t}\n\t\tprintf(\"%s\n\", node->getName());\n\t\tshowMenuList(node->getSubmenu(), layer + 1);\n\t\tnode = node->getNextNode();\n\t}\n}", "CodeBleu_score": 45.89846791692768}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint len;\n\tint j;\n\tchar ssid[7];\n\tchar mac[18];\n\tint channel;\n\n\t// Generate SSIDs\n\tfor (i = 0; i < count; i++) {\n\t\t// Generate a random MAC address\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tmac[j] = (char)random(0, 255);\n\t\t}\n\n\t\t// Generate a random channel\n\t\tchannel = random(1, 14);\n\n\t\t// Generate a random SSID\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tssid[j] = (char)random(0, 255);\n\t\t}\n\t\tssid[6] = '\\0';\n\n\t\t// Print the generated SSID\n\t\tSerial.print(F(\"SSID: \"));\n\t\tSerial.println(ssid);\n\n\t\t// Add the generated SSID to the list\n\t\tlen = strlen(ssid);\n\t\tif (len < 32) {\n\t\t\tstrcpy(ssidList[i], ssid);\n\t\t\tstrcpy(macList[i], mac);\n\t\t\tchannelList[i] = channel;\n\t\t}\n\t}\n\n\t// Return the number of generated SSIDs\n\treturn i;\n}", "CodeBleu_score": 37.612667648159395}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    char ssid[7];\n    int i;\n    for (i = 0; i < count; i++) {\n        // generate random ssid\n        for (int j = 0; j < 6; j++) {\n            ssid[j] = (char)random(97, 123);\n        }\n        ssid[6] = '\\0';\n        // generate random channel\n        int channel = random(1, 14);\n        // generate random MAC address\n        char mac[18];\n        sprintf(mac, \"%02X:%02X:%02X:%02X:%02X:%02X\", random(256), random(256), random(256), random(256), random(256), random(256));\n        // add to list\n        WiFiScan::addSSID(ssid, channel, mac);\n        // print to serial\n        Serial.println(ssid);\n    }\n    return i;\n}", "CodeBleu_score": 47.63985813899112}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int i;\n  int generated = 0;\n  char ssid[6];\n  char mac[18];\n\n  for (i = 0; i < count; i++) {\n    generateSSID(ssid);\n    generateMAC(mac);\n    addSSID(ssid, mac);\n    generated++;\n    Serial.print(F(\"Generated SSID: \"));\n    Serial.print(ssid);\n    Serial.print(F(\" with MAC: \"));\n    Serial.println(mac);\n  }\n  return generated;\n}", "CodeBleu_score": 37.35564487738875}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n\n    # [START pubsub_create_topic]\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n\n    # TODO(developer): Replace this topic name with a unique topic name for your project.\n    topic_name = \"projects/{}/topics/{}\".format(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_name)\n\n    print(\"Topic created: {}\".format(topic))\n    # [END pubsub_create_topic]\n\n", "CodeBleu_score": 62.4668396209897}, {"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n    publisher_client = pubsub_v1.PublisherClient()\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n    topic = publisher_client.create_topic(topic_path)\n    print(f\"Topic created: {topic.name}\")\n\n", "CodeBleu_score": 65.56858243468665}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher_client = pubsub_v1.PublisherClient()\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n    try:\n        publisher_client.create_topic(topic_path)\n        print(f\"Topic {topic_name} created.\")\n    except Exception as e:\n        print(e)\n\n", "CodeBleu_score": 36.7006846972532}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT.\n    print('Creating JWT using {} from private key file {}'.format(algorithm, private_key_file))\n\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT.\n    print('Creating JWT using {} from private key file {}'.format(algorithm, private_key_file))\n\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT.\n    print('Creating JWT using {} from private key file {}'.format(algorithm, private_key_file))\n\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT.\n    print('Creating JWT using {} from private key file {}'.format(algorithm, private_key_file))\n\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }", "CodeBleu_score": 66.76559797416522}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    encoded_token = jwt.encode(token, private_key, algorithm=algorithm)\n    return encoded_token\n\n", "CodeBleu_score": 62.71196642469021}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 60.06236055043718}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode()\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(payload, message.topic, message.qos))\n    if payload == 'on':\n        print('Received message \\'on\\' on topic \\'{}\\' with QoS {}'.format(message.topic, message.qos))\n        capture_image()\n        upload_image()\n        publish_image_url()\n    elif payload == 'off':\n        print('Received message \\'off\\' on topic \\'{}\\' with QoS {}'.format(message.topic, message.qos))\n", "CodeBleu_score": 32.25850348981357}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Received message: \" + payload)\n    topic = message.topic\n    qos = message.qos\n    print(\"Received message on topic \" + topic + \" with QoS \" + str(qos))\n    if payload == \"on\":\n        capture_preview()\n    else:\n        print(\"Received message: \" + payload)\n\n", "CodeBleu_score": 22.44823377739123}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n\n    payload = message.payload.decode()\n    print(\"Received message '{}' on topic '{}' with QoS {}\".format(payload, message.topic, message.qos))\n\n    if payload == \"on\":\n        print(\"Capturing preview image...\")\n        preview_image = capture_preview_image()\n        print(\"Uploading preview image to bucket...\")\n        upload_file_to_bucket(preview_image)\n        print(\"Publishing preview image URL to MQTT event topic...\")\n        publish_preview_image_url()\n    elif payload == \"off\":\n        print(\"Received payload 'off'.\")\n    else:\n        print(\"Received unknown payload '{}'.\".format(payload))\n\n", "CodeBleu_score": 31.068156802695746}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Arguments for Google Cloud IoT Core MQTT device connection.\")\n    parser.add_argument(\n        \"--project_id\", help=\"Google Cloud project ID\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\")\n    )\n    parser.add_argument(\"--region\", help=\"Google Cloud region\", default=\"us-central1\")\n    parser.add_argument(\"--registry_id\", help=\"Registry ID\", default=\"my-registry\")\n    parser.add_argument(\"--device_id\", help=\"Device ID\", default=\"my-device\")\n    parser.add_argument(\"--private_key_file\", help=\"RSA private key file\", default=\"rsa_private.pem\")\n    parser.add_argument(\"--algorithm\", help=\"Encryption algorithm\", default=\"RS256\")\n    parser.add_argument(\"--ca_certs\", help=\"CA root certificate\", default=\"roots.pem\")\n    parser.add_argument(\"--num_messages\", type=int, help=\"Number of messages to publish.\", default=10)\n    parser.add_argument(\"--message_type\", help=\"Message type: event or state\", default=\"event\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", help=\"MQTT bridge hostname\", default=\"mqtt.googleapis.com\")\n    parser.add_argument(\"--mqtt_bridge_port\", type=int, help=\"MQTT bridge port\", default=8883)\n    parser.add_argument(\"--jwt_expires_minutes\", type=int, help=\"JWT expires minutes\", default=20)\n    parser.add_argument(\"--subscription_id\", help=\"Subscription ID\", default=\"my-subscription\")\n    parser.add_argument(\"--pubsub_topic\", help=\"Pubsub topic\", default=\"projects/my-project/topics/my-topic\")\n    parser.add_argument(\"--message_data\", help=\"Message data\", default=\"Hello World!\")\n    parser.add_argument(\"--attributes\", help=\"Message attributes\", default=\"\")\n    parser.add_argument(\"--num_subscribers\", type=int,", "CodeBleu_score": 31.967828240792816}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Command line arguments for Google Cloud IoT Core MQTT device connection.')\n    parser.add_argument('--project_id', help='GCP cloud project name.', default=os.environ.get('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument('--region', help='GCP cloud region name.', default='us-central1')\n    parser.add_argument('--registry_id', help='Cloud IoT Core registry ID.  (registry is a collection of devices)', required=True)\n    parser.add_argument('--device_id', help='Cloud IoT Core device ID.', required=True)\n    parser.add_argument('--private_key_file', help='Path to private key file.', required=True)\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--ca_certs', help='CA root cert file to use to verify GCP server cert.', default='roots.pem')\n    parser.add_argument('--num_messages', type=int, default=10, help='Number of messages to publish.')\n    parser.add_argument('--message_type', choices=('event', 'state'), default='event', help='Whether to publish \"event\" messages or \"state\" messages.')\n    parser.add_argument('--mqtt_bridge_hostname', help='MQTT bridge hostname.', default='mqtt.googleapis.com')\n    parser.add_argument('--mqtt_bridge_port', choices=(8883, 443), default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', type=int, default=20, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--wait_time', type=int, default=5, help='Time to wait for a message to be published.')\n    parser.add_argument", "CodeBleu_score": 34.50840865208479}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='MQTT device connection parameters.')\n    parser.add_argument(\n        '--project_id', help='GCP cloud project name.', default=os.environ.get('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument(\n        '--subscription_name', help='GCP Pub/Sub subscription name.')\n    parser.add_argument(\n        '--device_id', help='GCP IoT Core device ID.', required=True)\n    parser.add_argument(\n        '--private_key_file', help='Path to private key file.', required=True)\n    parser.add_argument(\n        '--algorithm', help='Encryption algorithm to use to generate the JWT.', default='RS256')\n    parser.add_argument(\n        '--cloud_region', help='GCP cloud region.', default='us-central1')\n    parser.add_argument(\n        '--ca_certs', help='CA root certificate.',\n        default='roots.pem')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        help='MQTT bridge hostname.',\n        default='mqtt.googleapis.com')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        help='MQTT bridge port.',\n        type=int,\n        default=8883)\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        help='Expiration time, in minutes, for JWT tokens.',\n        default=20)\n    parser.add_argument(\n        '--jwt_audience',\n        help='Audience to be used when generating JWT tokens.',\n        default='mqtt@sandbox.googleapis.com')\n    parser.add_argument(\n        '--message_type', help='Type of message to publish.', default='event')\n    parser.add_argument(\n        '--registry_id', help='GCP IoT Core registry ID.', required=True)\n    parser.add_argument(\n        '--message_data', help='", "CodeBleu_score": 34.35349430684371}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(\n        ['https://www.googleapis.com/auth/cloud-platform'])\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n    return discovery.build('cloudiot', 'v1', credentials=scoped_credentials,\n                            discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 23.75764644168545}, {"code": "def get_client(service_account_json)\n\t\n    # Create a Google Cloud Pub/Sub client\n    pubsub_client = pubsub.PublisherClient()\n    # Create a Google Cloud IoT Core client\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(\n        ['https://www.googleapis.com/auth/cloud-platform'])\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n    service = discovery.build(\n        'cloudiot', 'v1', credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url)\n    return pubsub_client, service\n\n", "CodeBleu_score": 27.147602634493058}, {"code": "def get_client(service_account_json)\n\t\n    # Create an http object to authorize the API call\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(\n        ['https://www.googleapis.com/auth/cloud-platform'])\n    # Create an http object to authorize the API call\n    http_auth = scoped_credentials.authorize(httplib2.Http())\n    # Setup discovery service\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n    service = discovery.build('cloudiot', 'v1', http=http_auth,\n                              discoveryServiceUrl=discovery_url)\n    return service\n\n", "CodeBleu_score": 25.771220999254908}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_code = common.get_hash_code(hash_method)\n    if not hash_method_code:\n        raise core.RSAError(\"Invalid hash method\")\n    hash_value = transform.bytes2int(hash_value)\n    hash_value = transform.int2bytes(hash_value, 20)\n    hash_value = transform.int2bytes(hash_value, 160)\n    hash_value = transform.int2bytes(hash_value, 128)\n    hash_value = transform.int2bytes(hash_value, 112)\n    hash_value = transform.int2bytes(hash_value, 96)\n    hash_value = transform.int2bytes(hash_value, 80)\n    hash_value = transform.int2bytes(hash_value, 64)\n    hash_value = transform.int2bytes(hash_value, 48)\n    hash_value = transform.int2bytes(hash_value, 32)\n    hash_value = transform.int2bytes(hash_value, 16)\n    hash_value = transform.int2bytes(hash_value, 8)\n    hash_value = transform.int2bytes(hash_value, 1)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash_value = transform.int2bytes(hash_value, 0)\n    hash", "CodeBleu_score": 24.516555542868023}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_code = transform.hash_to_asn1(hash_method)\n    if hash_code is None:\n        raise core.RSAError(\"Invalid hash method\")\n    hash_value = transform.hash_to_asn1(hash_method, hash_value)\n    if hash_value is None:\n        raise core.RSAError(\"Invalid hash value\")\n    padded = transform.pad_pkcs1_15(hash_value, priv_key.key_size)\n    return priv_key.encrypt(padded)\n\n", "CodeBleu_score": 31.322180905214925}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_code = transform.get_hash_code(hash_method)\n    if not hash_method_code:\n        raise ValueError('Invalid hash method.')\n    hash_value = core.bytes2long(hash_value)\n    hash_value = transform.pad_hash(hash_value, hash_method)\n    hash_value = transform.asn1_encode(hash_method_code, hash_value)\n    return priv_key.sign(hash_value, transform.get_padding(priv_key))\n\n", "CodeBleu_score": 33.05156719319533}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError('message must be bytes')\n    if not isinstance(signature, bytes):\n        raise TypeError('signature must be bytes')\n    if not isinstance(pub_key, core.PublicKey):\n        raise TypeError('pub_key must be PublicKey')\n    if not isinstance(pub_key.key, core.PublicKey):\n        raise TypeError('pub_key must be PublicKey')\n    if not pub_key.key.has_private():\n        raise ValueError('pub_key must be a public key')\n    if not pub_key.key.key_size == pub_key.key.public_size:\n        raise ValueError('pub_key must be a public key')\n    if not pub_key.key.key_size == pub_key.key.private_size:\n        raise ValueError('pub_key must be a public key')\n    if not pub_key.key.key_size == pub_key.key.hash_size:\n        raise ValueError('pub_key must be a public key')\n    if not pub_key.key.key_size == pub_key.key.block_size:\n        raise ValueError('pub_key must be a public key')\n    if not pub_key.key.key_size == pub_key.key.padding_size:\n        raise ValueError('pub_key must be a public key')\n    if not pub_key.key.key_size == pub_key.key.signature_size:\n        raise ValueError('pub_key must be a public key')\n    if not pub_key.key.key_size == pub_key.key.cipher_size:\n        raise ValueError('pub_key must be a public key')\n    if not pub_key.key.key_size == pub_key.key.key_size:\n        raise ValueError('pub_key must be a public key')\n    if not pub_key.key.key_size == pub_key.key.key_size:\n        raise ValueError('pub_key must be a public key')\n    if not pub_key.key.key_size == pub_key.key.key_size:\n       ", "CodeBleu_score": 17.858048633881136}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError(\"message must be bytes\")\n    if not isinstance(signature, bytes):\n        raise TypeError(\"signature must be bytes\")\n    if not isinstance(pub_key, core.PublicKey):\n        raise TypeError(\"pub_key must be a PublicKey object\")\n    if not pub_key.is_valid():\n        raise ValueError(\"pub_key must be a valid PublicKey object\")\n    if not pub_key.is_encrypted():\n        raise ValueError(\"pub_key must be an encrypted PublicKey object\")\n    if not pub_key.is_verifying_key():\n        raise ValueError(\"pub_key must be a verifying key\")\n    if not pub_key.is_public():\n        raise ValueError(\"pub_key must be a public key\")\n    if not pub_key.is_valid_for_signing():\n        raise ValueError(\"pub_key must be valid for signing\")\n    if not pub_key.is_valid_for_encryption():\n        raise ValueError(\"pub_key must be valid for encryption\")\n    if not pub_key.is_valid_for_decryption():\n        raise ValueError(\"pub_key must be valid for decryption\")\n    if not pub_key.is_valid_for_signing():\n        raise ValueError(\"pub_key must be valid for signing\")\n    if not pub_key.is_valid_for_encryption():\n        raise ValueError(\"pub_key must be valid for encryption\")\n    if not pub_key.is_valid_for_decryption():\n        raise ValueError(\"pub_key must be valid for decryption\")\n    if not pub_key.is_valid_for_signing():\n        raise ValueError(\"pub_key must be valid for signing\")\n    if not pub_key.is_valid_for_encryption():\n        raise ValueError(\"pub_key must be valid for encryption\")\n    if not pub_key.is_valid_for_decryption():\n        raise ValueError(\"pub_key must be valid for decryption\")\n    if not pub_key.is_valid_for_signing():\n        raise ValueError(\"pub_key must be valid", "CodeBleu_score": 17.01525301994849}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError(\"message must be bytes\")\n    if not isinstance(signature, bytes):\n        raise TypeError(\"signature must be bytes\")\n    if not isinstance(pub_key, core.PublicKey):\n        raise TypeError(\"pub_key must be a PublicKey object\")\n    if pub_key.key_size != 1024:\n        raise ValueError(\"pub_key must be a 1024-bit key\")\n    if len(signature) != pub_key.key_size // 8:\n        raise ValueError(\"signature must be %d bytes long\" % (pub_key.key_size // 8))\n    if not pub_key.is_valid():\n        raise ValueError(\"pub_key is invalid\")\n    if not pub_key.is_encrypted():\n        raise ValueError(\"pub_key must be encrypted\")\n    if not pub_key.is_public():\n        raise ValueError(\"pub_key must be a public key\")\n    if not pub_key.is_signature_key():\n        raise ValueError(\"pub_key must be a signature key\")\n\n    # Convert the signature to an integer\n    sig_int = common.bytes_to_long(signature)\n\n    # Decrypt the signature\n    sig_int = pub_key.decrypt(sig_int)\n\n    # Determine the hash method used\n    hash_method = common.get_hash_method(pub_key.hash_method)\n\n    # Compute the hash of the message\n    message_hash = hash_method.hash(message)\n\n    # Reconstruct the expected padded hash\n    expected_hash = transform.reconstruct_hash(pub_key.hash_method, sig_int)\n\n    # Check if the expected padded hash matches the clear signature\n    if expected_hash != message_hash:\n        raise core.VerificationError(\"signature is invalid\")\n\n    # Return the hash method name\n    return hash_method.name\n\n", "CodeBleu_score": 35.89967366804434}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t    struct tm timeinfo;\n\n    if (getLocalTime(&timeinfo) != 0) {\n        crypto_updateJWT(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);\n    }\n\n    mqtt_connect();\n\n    mqtt_sendSubscribePacket();\n\n    PRINT_DEBUG(\"MQTT connection attempt...\n\");\n}", "CodeBleu_score": 43.01005361489151}, {"code": "static void connectMQTT(){\n\t    if (isValidTime()) {\n        updateJWT();\n    }\n    if (connectToMQTT()) {\n        sendMQTTSubscribePacket();\n    }\n    PRINT_DEBUG(\"MQTT connection attempt\n\");\n}", "CodeBleu_score": 19.590052195568276}, {"code": "static void connectMQTT(){\n\t\n\ttime_t currentTime = getCurrentTime();\n\n\tif (currentTime == 0) {\n\n\t\tdebugPrintlnString(\"[ERROR] Failed to get current time.\", DBG_ERROR);\n\n\t\treturn;\n\n\t}\n\n\tif (updateJWT(currentTime) == false) {\n\n\t\tdebugPrintlnString(\"[ERROR] Failed to update JWT.\", DBG_ERROR);\n\n\t\treturn;\n\n\t}\n\n\tif (mqttConnect() == false) {\n\n\t\tdebugPrintlnString(\"[ERROR] Failed to connect to MQTT client.\", DBG_ERROR);\n\n\t\treturn;\n\n\t}\n\n\tmqttSubscribeFlag = true;\n\n\tdebugPrintlnString(\"[INFO] MQTT connection attempt.\", DBG_INFO);\n\n}", "CodeBleu_score": 41.0321769347797}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    int i;\n    uint32_t value = 0;\n\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        value = value * 10 + (str[i] - '0');\n    }\n\n    *num = value;\n    return str + width;\n}", "CodeBleu_score": 27.137219152325144}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t val = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tval = (val * 10) + (str[i] - '0');\n\t}\n\t*num = val;\n\treturn str + width;\n}", "CodeBleu_score": 27.14128946665948}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tint i;\n\tuint32_t n = 0;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + (str[i] - '0');\n\t}\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 26.350323495678246}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tuint8_t* p = NULL;\n\tuint8_t* end = NULL;\n\tuint8_t* tbs = NULL;\n\tuint8_t* tbs_end = NULL;\n\tuint8_t* cert_end = NULL;\n\tuint8_t* cert_end_orig = NULL;\n\tuint8_t* cert_end_orig_orig = NULL;\n\tuint8_t* cert_end_temp = NULL;\n\tuint8_t* cert_end_temp_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig_orig_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig_orig_orig_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig = NULL;\n\tuint8_t* cert_end_temp_orig_orig_orig_orig", "CodeBleu_score": 10.248365294206957}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tatcacert_cert_element_t* cert_element = NULL;\n\tuint8_t* cert_element_data = NULL;\n\tuint8_t* cert_element_data_end = NULL;\n\tuint8_t* cert_element_data_start = NULL;\n\tsize_t cert_element_data_size = 0;\n\tsize_t cert_element_data_size_max = 0;\n\tuint8_t* cert_element_data_temp = NULL;\n\tsize_t cert_element_data_temp_size = 0;\n\tuint8_t* cert_element_data_temp_end = NULL;\n\tuint8_t* cert_element_data_temp_start = NULL;\n\tsize_t cert_element_data_temp_size_max = 0;\n\tuint8_t* cert_element_data_temp_temp = NULL;\n\tsize_t cert_element_data_temp_temp_size = 0;\n\tuint8_t* cert_element_data_temp_temp_end = NULL;\n\tuint8_t* cert_element_data_temp_temp_start = NULL;\n\tuint8_t* cert_element_data_temp_temp_temp = NULL;\n\tsize_t cert_element_data_temp_temp_temp_size = 0;\n\tuint8_t* cert_element_data_temp_temp_temp_end = NULL;\n\tuint8_t* cert_element_data_temp_temp_temp_start = NULL;\n\tuint8_t* cert_element_data_temp_temp_temp_temp = NULL;\n\tsize_t cert_element_data_temp_temp_temp_temp_size = 0;\n\tuint8_t* cert_element_data_temp_temp_temp_temp_end = NULL;\n\tuint8_t* cert_element_data_temp_temp_temp_temp_start = NULL;\n\tuint8_t* cert_element_data_temp_temp_temp_temp_temp = NULL;\n\tsize_t cert_element_data_temp_temp_temp_temp", "CodeBleu_score": 10.70255704207705}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tsize_t cert_size = 0;\n\tuint8_t cert_der[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_2[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_3[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_4[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_5[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_6[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_7[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_8[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_9[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_10[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_11[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_12[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_13[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_14[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_15[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_16[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_17[ATCACERT_CERT_MAX_SIZE];\n\tuint8_t cert_der_temp_18[ATCACERT_CERT_", "CodeBleu_score": 8.576830932215893}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int                     ret = 0;\n    atca_cert_hw_ctx_t      ctx;\n    uint8_t                 tbs_digest[32];\n    uint8_t                 signature[64];\n    size_t                  signature_size = 0;\n    size_t                  tbs_digest_size = 0;\n    const atcacert_cert_element_t* cert_elements = NULL;\n    const atcacert_cert_element_t* cert_elements_end = NULL;\n    const atcacert_cert_element_t* cert_element = NULL;\n    const atcacert_cert_element_t* cert_element_end = NULL;\n    const atcacert_cert_element_t* cert_element_compound = NULL;\n    const atcacert_cert_element_t* cert_element_compound_end = NULL;\n    const atcacert_cert_element_t* cert_element_compound_element = NULL;\n    const atcacert_cert_element_t* cert_element_compound_element_end = NULL;\n    const atcacert_cert_element_t* cert_element_compound_element_subelement = NULL;\n    const atcacert_cert_element_t* cert_element_compound_element_subelement_end = NULL;\n    const atcacert_cert_element_t* cert_element_compound_element_subelement_subelement = NULL;\n    const atcacert_cert_element_t* cert_element_compound_element_subelement_subelement_end = NULL;\n    const atcacert_cert_element_t* cert_element_compound_element_subelement_subelement_subelement = NULL;\n    const atcacert_cert_element_t* cert_element_compound_element_subelement_subelement_subelement_end = NULL;\n    const atcacert_cert_element_t* cert_element_compound_element_subelement_subelement_subelement_subelement = NULL;\n    const atcacert_cert_element_t* cert", "CodeBleu_score": 18.401727099993945}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = 0;\n\n    // Check for null parameters\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Verify the certificate\n    ret = atcacert_verify_cert_hw_tbs_digest(cert_def, cert, cert_size, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 45.32236284129202}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = 0;\n    uint8_t tbs_digest[32];\n\n    // Check for null parameters\n    if (!cert_def || !cert || !ca_public_key)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Retrieve the TBS digest\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Verify the TBS digest against the signature\n    ret = atcacert_verify_signature(tbs_digest, cert_def->sig_length, cert + cert_def->sig_pos, ca_public_key);\n\n    return ret;\n}", "CodeBleu_score": 48.486595511651366}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *current = &list;\n    timerStruct_t * volatile *next;\n    while(*current != NULL) {\n        next = &(*current)->next;\n        if(*current == timer) {\n            *current = *next;\n            break;\n        }\n        current = next;\n    }\n    return true;\n}", "CodeBleu_score": 23.92663749061301}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *prev;\n    timerStruct_t * volatile *next;\n\n    prev = &list[0];\n    next = list[0];\n\n    while (next != NULL) {\n        if (next == timer) {\n            *prev = next[1];\n            return true;\n        }\n\n        prev = &next[1];\n        next = next[1];\n    }\n\n    return false;\n}", "CodeBleu_score": 24.718476633314108}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *prev = &list[0];\n    timerStruct_t * volatile *next = &list[1];\n\n    while (*prev != NULL)\n    {\n        if (*next == timer)\n        {\n            *prev = *next;\n            *next = NULL;\n            break;\n        }\n        else\n        {\n            prev = next;\n            next = &(*next)[1];\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 29.92044554578569}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\n\tint ret;\n\n\tstruct sockaddr_in sock_addr;\n\n\tstruct socket_info *socket_info;\n\n\tif (socket < 0 || socket > MAX_SOCKETS) {\n\n\t\treturn BSD_INVALID_SOCKET;\n\n\t}\n\n\tsocket_info = &(socket_table[socket]);\n\n\tif (socket_info->state != SOCKET_STATE_IN_USE) {\n\n\t\treturn BSD_INVALID_SOCKET;\n\n\t}\n\n\tmemcpy(&sock_addr, &(socket_info->sock_addr), sizeof(struct sockaddr_in));\n\n\tsocket_info->state = SOCKET_STATE_NOT_A_SOCKET;\n\n\tret = sl_Close(socket_info->sd);\n\n\tif (ret < 0) {\n\n\t\tif (ret == SL_ERROR_BSD_EBADF) {\n\n\t\t\treturn BSD_INVALID_SOCKET;\n\n\t\t}\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\treturn BSD_SUCCESS;\n\n}", "CodeBleu_score": 41.64795118825111}, {"code": "int BSD_close(int socket){\n\t\tint error;\n\tSOCKET_INFO *sock;\n\tSOCKET_INFO *prev;\n\tSOCKET_INFO *next;\n\t\n\tif(socket < 0 || socket >= MAX_SOCKETS) {\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tsock = &(socket_info[socket]);\n\t\n\tif(sock->state != SOCKET_STATE_OPEN) {\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tsock->state = SOCKET_STATE_NOT_A_SOCKET;\n\t\n\terror = close(socket);\n\t\n\tif(error == SOCK_ERR_NO_ERROR) {\n\t\treturn BSD_SUCCESS;\n\t}\n\t\n\tif(error == SOCK_ERR_INVALID_ARG) {\n\t\treturn BSD_ERROR_INVALID_ARG;\n\t}\n\t\n\tif(error == SOCK_ERR_INVALID) {\n\t\treturn BSD_ERROR_INVALID_SOCKET;\n\t}\n\t\n\tif(error == SOCK_ERR_IN_PROGRESS) {\n\t\treturn BSD_ERROR_IN_PROGRESS;\n\t}\n\t\n\tif(error == SOCK_ERR_WOULD_BLOCK) {\n\t\treturn BSD_ERROR_WOULD_BLOCK;\n\t}\n\t\n\tif(error == SOCK_ERR_ADDR_IN_USE) {\n\t\treturn BSD_ERROR_ADDR_IN_USE;\n\t}\n\t\n\tif(error == SOCK_ERR_ADDR_NOT_AVAIL) {\n\t\treturn BSD_ERROR_ADDR_NOT_AVAIL;\n\t}\n\t\n\tif(error == SOCK_ERR_CONN_ABORTED) {\n\t\treturn BSD_ERROR_CONN_ABORTED;\n\t}\n\t\n\tif(error == SOCK_ERR_CONN_RESET) {\n\t\treturn BSD_ERROR_CONN_RESET;\n\t}\n\t\n\tif(error == SOCK_ERR_IS_CONNECTED) {\n\t\t", "CodeBleu_score": 41.62942311221664}, {"code": "int BSD_close(int socket){\n\t\n\tSOCKET_INFO *socketInfo;\n\n\tint status;\n\n\t/*\n\t * Retrieve the socket information and check if it exists.\n\t */\n\tsocketInfo = BSD_getSocketInfo(socket);\n\n\tif (socketInfo == NULL) {\n\n\t\treturn BSD_INVALID_SOCKET;\n\n\t}\n\n\t/*\n\t * Set the socket state to \"NOT_A_SOCKET\".\n\t */\n\tsocketInfo->state = NOT_A_SOCKET;\n\n\t/*\n\t * Call the close function and check for errors.\n\t */\n\tstatus = sl_Close(socket);\n\n\tif (status < 0) {\n\n\t\t/*\n\t\t * Set the appropriate error number based on the error type.\n\t\t */\n\t\tswitch (status) {\n\n\t\t\tcase SL_ERROR_BSD_EBADF:\n\n\t\t\t\tset_errno(BSD_EBADF);\n\n\t\t\t\tbreak;\n\n\t\t\tcase SL_ERROR_BSD_ENOTSOCK:\n\n\t\t\t\tset_errno(BSD_ENOTSOCK);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tset_errno(BSD_ERROR);\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\t/*\n\t * Return success.\n\t */\n\treturn BSD_SUCCESS;\n\n}", "CodeBleu_score": 51.13830014913867}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\n\tint result;\n\n\tresult = listen(socket, backlog);\n\n\tif (result != 0) {\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\treturn BSD_SUCCESS;\n\n}", "CodeBleu_score": 19.0597466341832}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint retVal = BSD_SUCCESS;\n\n\tint res = listen(socket, backlog);\n\tif (res != 0) {\n\t\tretVal = BSD_ERROR;\n\t\tswitch (res) {\n\t\t\tcase SOCK_ERR_INVALID:\n\t\t\t\tBSD_set_error(BSD_ERR_INVALID_SOCKET);\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_INVALID_ADDR:\n\t\t\t\tBSD_set_error(BSD_ERR_INVALID_ADDR);\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\t\tBSD_set_error(BSD_ERR_INVALID_ARG);\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_NO_ERROR:\n\t\t\t\tBSD_set_error(BSD_ERR_UNKNOWN);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBSD_set_error(BSD_ERR_UNKNOWN);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn retVal;\n}", "CodeBleu_score": 44.117506460451246}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint response = listen(socket, backlog);\n\t\n\tif (response != 0) {\n\t\tDEBUG_PRINT(\"BSD_listen: listen returned %d\\r\n\", response);\n\t\t\n\t\treturn BSD_ERROR;\n\t}\n\t\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 16.23873714628109}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret;\n\tint sock;\n\tstruct sockaddr_in *addr_in;\n\tsocklen_t addrlen_in;\n\t\n\tif (addr == NULL) {\n\t\treturn BSD_ERR_NULL_PTR;\n\t}\n\t\n\tif (addrlen == NULL) {\n\t\treturn BSD_ERR_NULL_PTR;\n\t}\n\t\n\tif (socket < 0) {\n\t\treturn BSD_ERR_INVALID_SOCKET;\n\t}\n\t\n\tif (*addrlen < sizeof(struct sockaddr_in)) {\n\t\treturn BSD_ERR_INVALID_ARG;\n\t}\n\t\n\tif ((*addr).sa_family != AF_INET) {\n\t\treturn BSD_ERR_INVALID_ARG;\n\t}\n\t\n\taddr_in = (struct sockaddr_in *)addr;\n\taddrlen_in = *addrlen;\n\t\n\tret = accept(socket, (struct sockaddr *)addr_in, &addrlen_in);\n\t\n\tif (ret == SOCK_ERR_NO_ERROR) {\n\t\t*addrlen = addrlen_in;\n\t\treturn BSD_SUCCESS;\n\t}\n\t\n\tif (ret == SOCK_ERR_INVALID_ARG) {\n\t\treturn BSD_ERR_INVALID_ARG;\n\t}\n\t\n\tif (ret == SOCK_ERR_INVALID) {\n\t\treturn BSD_ERR_INVALID;\n\t}\n\t\n\tif (ret == SOCK_ERR_INVALID_SOCK) {\n\t\treturn BSD_ERR_INVALID_SOCKET;\n\t}\n\t\n\tif (ret == SOCK_ERR_BUFFER_FULL) {\n\t\treturn BSD_ERR_BUFFER_FULL;\n\t}\n\t\n\tif (ret == SOCK_ERR_ADDR_ALLOC) {\n\t\treturn BSD_ERR_ADDR_ALLOC;\n\t}\n\t\n\tif (ret == SOCK_ERR_ADDR_IN_USE) {\n\t\treturn", "CodeBleu_score": 41.11226687574872}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint32_t ret;\n\tint32_t socket_index;\n\tuint32_t addr_len;\n\n\t/* Check the socket address length */\n\tif (addrlen == NULL) {\n\t\treturn BSD_ERR_INVALID_ARG;\n\t}\n\n\t/* Check the socket address pointer */\n\tif (addr == NULL) {\n\t\treturn BSD_ERR_INVALID_ARG;\n\t}\n\n\t/* Check the socket */\n\tif (socket < 0 || socket >= MAX_SOCKET) {\n\t\treturn BSD_ERR_INVALID_SOCKET;\n\t}\n\n\t/* Check if the socket is already in use */\n\tif (socket_table[socket].in_use == false) {\n\t\treturn BSD_ERR_SOCKET_NOT_IN_USE;\n\t}\n\n\t/* Check the socket type */\n\tif (socket_table[socket].type != BSD_SOCK_STREAM) {\n\t\treturn BSD_ERR_SOCKET_NOT_STREAM;\n\t}\n\n\t/* Check if the socket is already in use */\n\tif (socket_table[socket].state != BSD_SOCKET_STATE_LISTEN) {\n\t\treturn BSD_ERR_SOCKET_NOT_LISTEN;\n\t}\n\n\t/* Get the socket index */\n\tsocket_index = socket_table[socket].socket_index;\n\n\t/* Check if the socket is already in use */\n\tif (socket_table[socket].state != BSD_SOCKET_STATE_LISTEN) {\n\t\treturn BSD_ERR_SOCKET_NOT_LISTEN;\n\t}\n\n\t/* Get the address length */\n\taddr_len = *addrlen;\n\n\t/* Call the accept function */\n\tret = sl_SocketAccept(socket_index, (SlSockAddr_t *)addr, &addr_len);\n\n\t/* Check the return value */\n\tif (ret < 0) {\n\t\t/* Set the error */\n\t\tswitch (ret) {\n\t\tcase SL_ERROR_BSD_SOC_WOULD_B", "CodeBleu_score": 36.027954874989675}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret;\n\tstruct sockaddr_in sockaddr_in;\n\tsocklen_t sockaddr_in_len = sizeof(struct sockaddr_in);\n\n\tif (addr != NULL) {\n\t\tmemset(&sockaddr_in, 0, sizeof(struct sockaddr_in));\n\t\tret = accept(socket, (struct sockaddr *)&sockaddr_in, &sockaddr_in_len);\n\t\tif (ret == -1) {\n\t\t\treturn ret;\n\t\t}\n\t\taddr->sa_family = sockaddr_in.sin_family;\n\t\taddr->sa_data[0] = sockaddr_in.sin_addr.s_addr & 0xFF;\n\t\taddr->sa_data[1] = (sockaddr_in.sin_addr.s_addr >> 8) & 0xFF;\n\t\taddr->sa_data[2] = (sockaddr_in.sin_addr.s_addr >> 16) & 0xFF;\n\t\taddr->sa_data[3] = (sockaddr_in.sin_addr.s_addr >> 24) & 0xFF;\n\t\taddr->sa_data[4] = sockaddr_in.sin_port & 0xFF;\n\t\taddr->sa_data[5] = (sockaddr_in.sin_port >> 8) & 0xFF;\n\t\t*addrlen = sizeof(struct bsd_sockaddr);\n\t} else {\n\t\tret = accept(socket, NULL, NULL);\n\t\tif (ret == -1) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 33.2615532221277}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\n\tuint32_t currentTime = getUNIXtime();\n\n\tif (currentTime == 0) {\n\n\t\tprintf(\"Error: Invalid time. Cannot connect to MQTT broker.\n\");\n\n\t\treturn;\n\n\t}\n\n\tupdateJWT(currentTime);\n\n\tprintf(\"Attempting to connect to MQTT broker...\n\");\n\n\tmqtt_core_connect();\n\n\tmqtt_core_subscribe();\n\n}", "CodeBleu_score": 50.21142057686936}, {"code": "static void connectMQTT(){\n\t\n    // Get the current time in UNIX format\n    uint32_t time = getTime();\n\n    // Check if the time is valid\n    if (time == 0) {\n        debugPrintlnString(\"[ERROR] Invalid time.\");\n        return;\n    }\n\n    // Update the JWT with the current time offset\n    updateJWT(time);\n\n    // Initiate the MQTT connection\n    mqtt_core_connect();\n\n    // Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n    mqtt_core_setSubscribeFlag();\n\n    debugPrintlnString(\"[INFO] MQTT connection initiated.\");\n}", "CodeBleu_score": 48.29383870101569}, {"code": "static void connectMQTT(){\n\t\ttime_t t = time(NULL);\n\tif (t != (time_t) 0) {\n\t\tstruct tm *tm = gmtime(&t);\n\t\tuint32_t time_offset = (uint32_t) (tm->tm_hour * 3600 + tm->tm_min * 60 + tm->tm_sec);\n\t\tupdateJWT(time_offset);\n\t\tmqtt_connect();\n\t\tmqtt_subscribe();\n\t} else {\n\t\tDEBUG_PRINT(\"Failed to get time\");\n\t}\n}", "CodeBleu_score": 20.794214496385074}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\n\tif (CLOUD_getConnectionState() == CONNECTED) {\n\n\t\tCLOUD_getClientConnectionInfo(&client_connection_info);\n\n\t\tCLOUD_disconnectMQTTClient();\n\n\t\tCLOUD_setConnectionState(DISCONNECTED);\n\n\t\tCLOUD_setConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n\n\t\tCLOUD_setClientConnectionInfo(NULL, NULL);\n", "CodeBleu_score": 40.191556429857165}, {"code": "void CLOUD_disconnect(void){\n\t\n    if (CLOUD_getMQTTConnectionState() == CONNECTED) {\n\n        MQTT_disconnect();\n\n        CLOUD_setMQTTConnectionState(DISCONNECTED);\n\n        CLOUD_setMQTTClientConnected(false);\n\n        CLOUD_setMQTTClientDisconnected(true);\n\n        CLOUD_setMQTTClientDisconnecting(false);\n\n        DEBUG_PRINT(\"MQTT client disconnected\");\n\n    }\n\n    if (CLOUD_getWiFiConnectionState() == CONNECTED) {\n\n        WIFI_disconnect();\n\n        CLOUD_setWiFiConnectionState(DISCONNECTED);\n\n        CLOUD_setWiFiDisconnected(true);\n\n        CLOUD_setWiFiDisconnecting(false);\n\n        DEBUG_PRINT(\"WiFi disconnected\");\n\n    }\n\n}", "CodeBleu_score": 48.74706277363696}, {"code": "void CLOUD_disconnect(void){\n\t\n    // Disconnect from the cloud service.\n    CLOUD_disconnectFromCloud();\n\n    // Log the disconnection.\n    DEBUG_PRINT(\"Disconnected from the cloud service.\n\");\n\n    // If the MQTT connection state is \"CONNECTED\", disconnect the MQTT client.\n    if (MQTT_CLIENT_CONNECTED == MQTT_getConnectionState()) {\n\n        // Retrieve the client connection information.\n        MQTT_ClientConnectionInfo_t clientConnectionInfo;\n        MQTT_getClientConnectionInfo(&clientConnectionInfo);\n\n        // Disconnect the MQTT client.\n        MQTT_disconnect(&clientConnectionInfo);\n    }\n}", "CodeBleu_score": 48.989062755368025}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\t\n\t// Set the Wi-Fi status to \"connecting\"\n\twifi_status = WIFI_STATUS_CONNECTING;\n\t\n\t// Print out the current status\n\tprintf(\"\n\n\\rConnecting to Wi-Fi AP...\n\n\\r\");\n\t\n\t// Connect to the access point using either new credentials or default credentials\n\tif (passed_wifi_creds) {\n\t\t\n\t\t// Connect to the access point using the specified SSID, authentication type, and password\n\t\tif (m2m_wifi_connect((char*) ssid, strlen(ssid), (m2m_wifi_auth_t) auth_type, (char*) password, M2M_WIFI_CH_ALL) != M2M_SUCCESS) {\n\t\t\t\n\t\t\t// Log an error message\n\t\t\tprintf(\"Error: Failed to connect to Wi-Fi AP\n\n\\r\");\n\t\t\t\n\t\t\t// Update the networking error status\n\t\t\tnetworking_error = true;\n\t\t\t\n\t\t\t// Return false\n\t\t\treturn false;\n\t\t}\n\t\t\n\t} else {\n\t\t\n\t\t// Connect to the access point using the default Wi-Fi settings\n\t\tif (m2m_wifi_default_connect() != M2M_SUCCESS) {\n\t\t\t\n\t\t\t// Log an error message\n\t\t\tprintf(\"Error: Failed to connect to Wi-Fi AP\n\n\\r\");\n\t\t\t\n\t\t\t// Update the networking error status\n\t\t\tnetworking_error = true;\n\t\t\t\n\t\t\t// Return false\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 47.13074272683678}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n    bool result = false;\n\n    // Disconnect from the AP if we are already connected\n\n    m2m_wifi_disconnect();\n\n    // Connect to the AP\n\n    if (passed_wifi_creds) {\n\n        m2m_wifi_connect((char*)wifi_ssid, strlen(wifi_ssid), wifi_security, (char*)wifi_password, M2M_WIFI_CH_ALL);\n\n    } else {\n\n        m2m_wifi_connect((char*)DEFAULT_WIFI_SSID, strlen(DEFAULT_WIFI_SSID), DEFAULT_WIFI_SECURITY, (char*)DEFAULT_WIFI_PASSWORD, M2M_WIFI_CH_ALL);\n\n    }\n\n    // Wait for connection\n\n    while (1) {\n\n        if (m2m_wifi_get_connection_state() != M2M_WIFI_CONNECTED) {\n\n            if (m2m_wifi_get_connection_state() == M2M_WIFI_DISCONNECTED) {\n\n                printf(\"Wi-Fi connection failed. Error code: %d\n\", m2m_wifi_get_last_error());\n\n                break;\n\n            }\n\n            // Wait for 100ms\n\n            m2m_wifi_handle_events(NULL);\n\n            delay_ms(100);\n\n        } else {\n\n            printf(\"Wi-Fi connected successfully.\n\");\n\n            result = true;\n\n            break;\n\n        }\n\n    }\n\n    return result;\n\n}", "CodeBleu_score": 42.24689993238681}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n", "CodeBleu_score": 1.603301960152807}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t    // Create a GraphQL client\n    const client = new AWSAppSyncClient({\n        url: \"https://xxxxxxxxxx.appsync-api.us-east-1.amazonaws.com/graphql\",\n        region: \"us-east-1\",\n        auth: {\n            type: \"API_KEY\",\n            apiKey: \"da2-xxxxxxxxxxxxx\"\n        }\n    });\n\n    // Create a GraphQL query\n    const query = gql`\n        query {\n            listSensors {\n                items {\n                    id\n                    name\n                    location {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        }\n    `;\n\n    // Send the GraphQL query to fetch sensor data\n    const result = await client.query({ query });\n\n    // If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\n    if (result.data.listSensors.items) {\n        console.log(\"Sensors retrieved: \" + result.data.listSensors.items);\n\n        // Iterate through each sensor to create a marker\n        for (const sensor of result.data.listSensors.items) {\n            // Create a marker\n            const marker = new maplibregl.Marker({\n                color: \"#3bb2d0\",\n                draggable: false\n            })\n                .setLngLat([sensor.location.longitude, sensor.location.latitude])\n                .setPopup(new maplibregl.Popup({ offset: 25 })\n                    .setHTML(\"<h3>\" + sensor.name + \"</h3>\"))\n                .addTo(map);\n        }\n    }\n}", "CodeBleu_score": 33.86852391109648}, {"code": "async function DisplaySensors(map){\n\t    try {\n        const client = new AWSAppSyncClient({\n            url: 'https://013w42889y33p82098829q47j.appsync-api.us-east-1.amazonaws.com/graphql',\n            region: 'us-east-1',\n            auth: {\n                type: 'API_KEY',\n                apiKey: 'da2-bjh2345678901234567890'\n            }\n        });\n\n        const query = gql`\n            query GetSensors {\n                getSensors {\n                    id\n                    name\n                    location {\n                        lat\n                        lng\n                    }\n                }\n            }\n        `;\n\n        const response = await client.query({ query });\n\n        if (response.data.getSensors.length > 0) {\n            console.log('Retrieved sensors: ' + response.data.getSensors.length);\n\n            for (let i = 0; i < response.data.getSensors.length; i++) {\n                let sensor = response.data.getSensors[i];\n\n                let marker = new maplibregl.Marker()\n                    .setLngLat([sensor.location.lng, sensor.location.lat])\n                    .addTo(map);\n\n                marker.getElement().innerHTML = sensor.name;\n            }\n        }\n    } catch (error) {\n        console.log(error);\n    }\n}", "CodeBleu_score": 36.33949493591104}, {"code": "async function DisplaySensors(map){\n\t  try {\n    const client = new AWSAppSyncClient({\n      url: 'https://0992794504986435585-e.appsync-api.us-east-1.amazonaws.com/graphql',\n      region: 'us-east-1',\n      auth: {\n        type: 'API_KEY',\n        apiKey: 'da2-76kp236xm242lq3r3v4z52n2q'\n      }\n    });\n    const query = gql`\n    query {\n      getSensors {\n        id\n        name\n        longitude\n        latitude\n      }\n    }\n    `;\n    const data = await client.query({ query });\n    console.log('Retrieved sensors: ', data.data.getSensors);\n    data.data.getSensors.forEach(sensor => {\n      console.log('Creating marker for sensor: ', sensor.name);\n      new mapboxgl.Marker({ color: 'red' })\n        .setLngLat([sensor.longitude, sensor.latitude])\n        .addTo(map);\n    });\n  } catch (err) {\n    console.error(err);\n  }\n}", "CodeBleu_score": 38.6155280003842}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'marker';\n  marker.style.background = '#000000';\n  marker.style.border = 'solid 2px #000000';\n  return marker;\n}", "CodeBleu_score": 41.25530005615}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const sensorMarker = document.createElement('div');\n  sensorMarker.id = sensor.id;\n  sensorMarker.className = 'sensor-marker';\n  sensorMarker.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';\n  sensorMarker.style.border = '1px solid #000000';\n  return sensorMarker;\n}", "CodeBleu_score": 43.392680199096574}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"marker\";\n  marker.style.backgroundColor = \"blue\";\n  marker.style.border = \"solid\";\n  marker.style.borderWidth = \"1px\";\n  marker.style.borderColor = \"black\";\n  marker.style.width = \"20px\";\n  marker.style.height = \"20px\";\n  marker.style.borderRadius = \"50%\";\n  marker.style.cursor = \"pointer\";\n  return marker;\n}", "CodeBleu_score": 43.120332508146454}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError:\n        _LOGGER.error(\"Failed to import MFA module %s\", module_name)\n        raise HomeAssistantError(f\"Failed to import MFA module {module_name}\")\n    if module.REQUIREMENTS:\n        if not hass.config.skip_pip:\n            await requirements.async_process_requirements(hass, module_path)\n    return module\n\n", "CodeBleu_score": 27.097110838970156}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError as err:\n        logging.getLogger(__name__).error(\n            \"Failed to import %s: %s\", module_path, err\n        )\n        raise HomeAssistantError(\n            f\"Failed to import {module_path}: {err}\"\n        ) from err\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not hass.config.skip_pip:\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n    return module\n\n", "CodeBleu_score": 45.74491830924372}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError as err:\n        logging.getLogger(__name__).error(\n            \"Failed to import MFA module %s: %s\", module_name, err\n        )\n        raise HomeAssistantError(\n            f\"Failed to import MFA module {module_name}: {err}\"\n        ) from err\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, const=\"setup of MFA module\"\n        )\n\n    return module\n\n", "CodeBleu_score": 43.17051833449146}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.user_data:\n        self.user_data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.user_data[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n", "CodeBleu_score": 34.58217319806948}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n", "CodeBleu_score": 33.71592039459607}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if \"pin\" in setup_data:\n        pin = setup_data[\"pin\"]\n    else:\n        return\n    if not await self.async_user_has_pin(user_id):\n        self._data[user_id] = {\"pin\": pin}\n    else:\n        self._data[user_id][\"pin\"] = pin\n\n", "CodeBleu_score": 44.41964929398057}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    if self.initialized:\n        return\n    self.lock.acquire()\n    if self.initialized:\n        self.lock.release()\n        return\n    self.initialized = True\n    self.lock.release()\n    self.user_settings = await self.hass.async_add_executor_job(self._load)\n\n", "CodeBleu_score": 22.469875528871974}, {"code": "async def _async_load(self) -> None\n\t\n    if self._initialized:\n        return\n    self._initialized = True\n    self._lock.acquire()\n    try:\n        if not self._store.async_check_existing():\n            self._settings = OrderedDict()\n            return\n        data = await self._store.async_load()\n        if not data:\n            self._settings = OrderedDict()\n            return\n        self._settings = OrderedDict()\n        for user in data:\n            self._settings[user] = NotifySetting(user, data[user])\n    finally:\n        self._lock.release()\n\n", "CodeBleu_score": 26.692972619195704}, {"code": "async def _async_load(self) -> None\n\t\n    if self._initialized:\n        return\n    async with self._init_lock:\n        if self._initialized:\n            return\n        self._data = await self.async_load()\n        if self._data is None:\n            self._data = {}\n        self._settings = OrderedDict()\n        for user_id, user_data in self._data.items():\n            self._settings[user_id] = NotifySetting(user_id, user_data)\n        self._initialized = True\n\n", "CodeBleu_score": 35.94864769295326}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    settings = await self.async_get_settings(user_id)\n    if not settings:\n        return False\n    if not user_input.get(CONF_INCLUDE):\n        user_input[CONF_INCLUDE] = []\n    if not user_input.get(CONF_EXCLUDE):\n        user_input[CONF_EXCLUDE] = []\n    return await self.async_validate_settings(settings, user_input)\n\n", "CodeBleu_score": 42.25029766671994}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self._hass.data[DOMAIN][\"users\"][user_id] = user_input\n    if user_id not in self._hass.data[DOMAIN][\"settings\"]:\n        return False\n    settings = self._hass.data[DOMAIN][\"settings\"][user_id]\n    if not settings.get(\"enabled\", False):\n        return False\n    if not settings[\"otp\"]:\n        return False\n    if not settings[\"otp_secret\"]:\n        return False\n    if not settings[\"otp_period\"]:\n        return False\n    if not settings[\"otp_digits\"]:\n        return False\n    if not settings[\"otp_algorithm\"]:\n        return False\n    if not settings[\"otp_type\"]:\n        return False\n    if not settings[\"otp_counter\"]:\n        return False\n    if not settings[\"otp_issuer\"]:\n        return False\n    return True\n\n", "CodeBleu_score": 42.42531803849256}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if user_id not in self.user_settings:\n        return False\n    user_settings = self.user_settings[user_id]\n    if user_input is None:\n        user_input = {}\n    user_input = {**user_settings, **user_input}\n    if user_input[\"service\"] not in self.services:\n        return False\n    service = self.services[user_input[\"service\"]]\n    if \"validate\" not in service:\n        return True\n    return await service[\"validate\"](user_input)\n\n", "CodeBleu_score": 40.068898019863155}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 60.28098499167264}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n\n    # Fetch the entity entry\n    entity_entry = perm_lookup.get_entity_entry(entity_id)\n\n    # If the entity entry is not found, return None\n    if entity_entry is None:\n        return None\n\n    # Fetch the device entry\n    device_entry = perm_lookup.get_device_entry(entity_entry.device_id)\n\n    # If the device entry is not found, return None\n    if device_entry is None:\n        return None\n\n    # If the device entry does not have an associated area, return None\n    if device_entry.area_id is None:\n        return None\n\n    # Return the permissions for the area\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 62.918645838745334}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 60.28098499167264}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    new_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, values in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                new_policy[category] = values\n            else:\n                new_policy[category] = list(set(new_policy[category] + values))\n    return cast(PolicyType, new_policy)\n\n", "CodeBleu_score": 45.193073942069574}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n\n    new_policy = {}\n    seen_categories = set()\n\n    for policy in policies:\n        for category, values in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                new_policy[category] = values\n\n    for policy in policies:\n        for category, values in policy.items():\n            if category in seen_categories:\n                new_policy[category] = new_policy[category] + values\n\n    return cast(PolicyType, new_policy)\n\n", "CodeBleu_score": 44.05488900913408}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    new_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, items in policy.items():\n            if category not in seen_categories:\n                new_policy[category] = items\n                seen_categories.add(category)\n            else:\n                new_policy[category] = {**new_policy[category], **items}\n    return cast(PolicyType, new_policy)\n\n", "CodeBleu_score": 54.04115305337203}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\"Error importing %s: %s\", provider, err)\n        raise HomeAssistantError(\n            f\"Error importing {provider}: {err}\"\n        ) from err\n\n    if not hasattr(module, \"AuthProvider\"):\n        _LOGGER.error(\"No AuthProvider class in %s\", provider)\n        raise HomeAssistantError(\n            f\"No AuthProvider class in {provider}\"\n        )\n\n    return module\n\n", "CodeBleu_score": 38.53072361048864}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        hass.components.persistent_notification.async_create(\n            f\"Error loading auth provider module {provider}: {err}\",\n            title=\"Failed to load auth provider module\",\n        )\n        raise HomeAssistantError(\n            f\"Error loading auth provider module {provider}: {err}\"\n        ) from err\n    if hasattr(module, \"REQUIREMENTS\"):\n        await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, const=\"auth provider\"\n        )\n    return module\n\n", "CodeBleu_score": 41.1258977689546}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        hass.components.persistent_notification.async_create(\n            f\"Error: Could not load auth provider {provider}: {err}\",\n            \"Home Assistant Authentication Setup Error\",\n        )\n        raise HomeAssistantError(\n            f\"Could not load auth provider {provider}: {err}\"\n        ) from None\n\n    if \"async_setup_auth\" not in module:\n        return module\n\n    try:\n        await module.async_setup_auth(hass)\n    except Exception as err:  # pylint: disable=broad-except\n        hass.components.persistent_notification.async_create(\n            f\"Error: Could not set up auth provider {provider}: {err}\",\n            \"Home Assistant Authentication Setup Error\",\n        )\n        raise HomeAssistantError(\n            f\"Could not set up auth provider {provider}: {err}\"\n        ) from None\n\n    return module\n\n", "CodeBleu_score": 40.472172196985284}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self.store.async_load()\n        if data is None:\n            self.users = []\n        else:\n            self.users = data\n    except HomeAssistantError:\n        self.users = []\n\n", "CodeBleu_score": 30.67635330764043}, {"code": "async def async_load(self) -> None\n\t\n    self._users = []\n    try:\n        data = await self.store.async_load()\n        if data is None:\n            return\n        if isinstance(data, Mapping):\n            self._users = [\n                User(username=username, password=password)\n                for username, password in data.items()\n            ]\n        else:\n            self._users = data\n    except HomeAssistantError:\n        # Migration from old format\n        self._users = []\n\n", "CodeBleu_score": 31.387044886240332}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        self._users = await self._store.async_load()\n        if self._users is None:\n            self._users = {}\n        else:\n            for user in self._users:\n                if not isinstance(user, str):\n                    raise HomeAssistantError(\"Invalid user data\")\n    except (TypeError, ValueError):\n        self._users = {}\n\n", "CodeBleu_score": 24.363613757908343}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    normalized_username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", b\"\")\n    for user in self.users:\n        if user[\"username\"] == normalized_username:\n            if bcrypt.hashpw(password.encode(\"utf-8\"), user[\"password\"].encode(\"utf-8\")) == user[\"password\"]:\n                return\n            raise InvalidAuth\n    if bcrypt.hashpw(password.encode(\"utf-8\"), dummy_hash) == dummy_hash:\n        raise InvalidAuth\n    raise InvalidAuth\n\n", "CodeBleu_score": 37.67170267553693}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    # Normalize username\n    username = username.lower()\n    # Initialize dummy hash to prevent timing attacks\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    # Iterate through all users to find a matching username\n    for user in self.users:\n        if user[\"username\"] == username:\n            # If a user is found, it decodes the stored password hash and uses bcrypt's timing-safe check to compare the provided password with the stored hash\n            stored_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                return\n            # If the passwords do not match, it raises an \"InvalidAuth\" exception\n            raise InvalidAuth\n    # If no matching user is found, it performs a dummy hash check and raises an \"InvalidAuth\" exception\n    bcrypt.checkpw(dummy_hash, dummy_hash)\n    raise InvalidAuth\n\n", "CodeBleu_score": 43.135328024587075}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = \"$2b$12$123456789012345678901234567890123456789012345678901\"\n    if username not in self.users:\n        bcrypt.checkpw(dummy_hash, dummy_hash)\n        raise InvalidAuth\n    user = self.users[username]\n    bcrypt.checkpw(password.encode(\"utf-8\"), user[\"hash\"].encode(\"utf-8\"))\n\n", "CodeBleu_score": 29.57631815306613}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    if not self.users:\n        return\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    del self.users[username]\n\n", "CodeBleu_score": 18.621003201462287}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    del self.users[username]\n\n", "CodeBleu_score": 21.015291000075692}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = normalize_username(username)\n    if username in self._users:\n        del self._users[username]\n        self.async_schedule_save()\n    else:\n        raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 23.19270311288179}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not hasattr(self, \"_store\"):\n        await self.async_initialize()\n    await self._store.async_save(credentials.id, {})\n\n", "CodeBleu_score": 33.00462425366094}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        self.data = {}\n    if credentials.id in self.data:\n        del self.data[credentials.id]\n        await self.async_save()\n\n", "CodeBleu_score": 35.194421949683985}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        self.data = {}\n    if credentials.auth_id not in self.data:\n        self.data[credentials.auth_id] = {}\n    if credentials.username not in self.data[credentials.auth_id]:\n        self.data[credentials.auth_id][credentials.username] = {}\n    del self.data[credentials.auth_id][credentials.username]\n    await self.async_save()\n\n", "CodeBleu_score": 35.86755171843835}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread.join(timeout=timeout)\n            if thread.is_alive():\n                if log:\n                    logging.info(f\"Thread {thread.ident} is still running.\")\n                thread.interrupt()\n        else:\n            joined.add(thread)\n    try:\n        raise SystemExit\n    except SystemExit:\n        pass\n    return joined\n\n", "CodeBleu_score": 43.850893156093065}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread.join(timeout=timeout)\n            if thread.is_alive():\n                if log:\n                    logging.warning(f\"Thread {thread.ident} is still running.\")\n                try:\n                    thread.interrupt()\n                except (AttributeError, RuntimeError):\n                    pass\n            else:\n                joined.add(thread)\n        else:\n            joined.add(thread)\n    try:\n        raise SystemExit\n    except SystemExit:\n        pass\n    return joined\n\n", "CodeBleu_score": 41.508147584330615}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads = set()\n    for thread in threads:\n        if thread.ident is None:\n            joined_threads.add(thread)\n        else:\n            thread.join(timeout=timeout)\n            if thread.is_alive():\n                if log:\n                    logging.warning(\n                        f\"Thread with identifier {thread.ident} is still running.\"\n                    )\n                try:\n                    thread.raise_exception()\n                except SystemExit:\n                    pass\n            else:\n                joined_threads.add(thread)\n    return joined_threads\n\n", "CodeBleu_score": 41.70612557552066}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    logging.info(\"Shutting down...\")\n    threads = []\n    for thread in threading.enumerate():\n        if thread is not threading.current_thread():\n            if not thread.daemon:\n                threads.append(thread)\n    for thread in threads:\n        logging.info(\"Waiting for thread: %s\", thread.name)\n        thread.join(timeout=deadlock_safe_shutdown.timeout / len(threads))\n    logging.info(\"Shutdown complete.\")\n\n", "CodeBleu_score": 29.406328212492994}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    logging.info(\"Shutting down...\")\n    threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.daemon]\n    if threads:\n        logging.info(f\"Found {len(threads)} non-daemon threads: {[t.name for t in threads]}\")\n        for thread in threads:\n            logging.info(f\"Joining thread '{thread.name}' with timeout {thread.shutdown_timeout}\")\n            thread.join(timeout=thread.shutdown_timeout)\n            if thread.is_alive():\n                logging.warning(f\"Thread '{thread.name}' is still alive after timeout {thread.shutdown_timeout}\")\n    logging.info(\"Shutdown complete\")\n\n", "CodeBleu_score": 30.671881409509815}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    logging.info(\"Shutting down...\")\n    threads = []\n    for thread in threading.enumerate():\n        if thread.name != \"MainThread\" and not thread.daemon and thread.is_alive():\n            threads.append(thread)\n    if not threads:\n        logging.info(\"No threads to join.\")\n        return\n    logging.info(\"Threads to join: %s\", \", \".join([thread.name for thread in threads]))\n    timeout = 0.1\n    for thread in threads:\n        logging.info(\"Thread %s: %s\", thread.name, thread.is_alive())\n        thread.join(timeout)\n        if thread.is_alive():\n            logging.warning(\"Thread %s is still alive after %s seconds.\", thread.name, timeout)\n    logging.info(\"Shutdown complete.\")\n\n", "CodeBleu_score": 31.117892340913272}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        if remaining_with_setup_started != self._remaining_with_setup_started:\n            self._remaining_with_setup_started = remaining_with_setup_started\n            self._dispatch_signal(self.SIGNAL_INTERNAL_DISPATCHER, remaining_with_setup_started)\n    else:\n        if self._remaining_with_setup_started:\n            self._remaining_with_setup_started = remaining_with_setup_started\n            self._dispatch_signal(self.SIGNAL_INTERNAL_DISPATCHER, remaining_with_setup_started)\n\n", "CodeBleu_score": 34.99868590699619}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self._remaining_setups:\n        if remaining_with_setup_started:\n            self._dispatcher.dispatch(\n                signal=\"internal_dispatcher\",\n                data=remaining_with_setup_started,\n            )\n        self._remaining_setups = remaining_with_setup_started\n\n", "CodeBleu_score": 38.327550702088196}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._dispatcher.dispatch(signal=self._INTERNAL_DISPATCHER_SIGNAL, data=remaining_with_setup_started)\n    self._remaining_with_setup_started = remaining_with_setup_started\n\n", "CodeBleu_score": 37.02513318208291}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    # Generate the bluetooth.py content\n    bluetooth_content = generate_bluetooth_content(integrations)\n\n    # Get the current bluetooth.py content\n    current_bluetooth_content = get_current_bluetooth_content()\n\n    # Compare the bluetooth.py content with the current bluetooth.py content\n    if bluetooth_content != current_bluetooth_content:\n        # If the contents differ, add an error to the configuration\n        config.add_error(\n            \"The bluetooth.py file is not up to date. Please run the update command to fix this issue.\"\n        )\n\n        # Add a fixable suggestion to the configuration\n        config.add_suggestion(\n            \"Run the update command to fix this issue.\",\n            \"update\",\n            \"Update bluetooth.py\",\n            \"update\",\n            \"Update bluetooth.py\",\n        )\n\n", "CodeBleu_score": 37.13971607511946}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    # Generate the bluetooth.py content\n    bluetooth_content = generate_bluetooth_content(integrations)\n\n    # Check if the bluetooth.py content is up to date\n    if config.bluetooth_content != bluetooth_content:\n\n        # If the bluetooth.py content is not up to date, add an error to the configuration and provide a fixable suggestion\n        config.errors.append(\n            {\n                \"type\": \"bluetooth\",\n                \"message\": \"The content of bluetooth.py is not up to date. Please run the integration validator again.\",\n                \"suggestion\": \"Please run the integration validator again.\",\n            }\n        )\n\n    # Store the bluetooth.py content in the configuration cache\n    config.bluetooth_content = bluetooth_content\n\n", "CodeBleu_score": 34.7604252998925}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    # Create a list of all bluetooth integrations\n    bluetooth_integrations: list[Integration] = []\n    for integration in integrations:\n        if integrations[integration].bluetooth_support:\n            bluetooth_integrations.append(integrations[integration])\n\n    # Create a list of all bluetooth domains\n    bluetooth_domains: list[str] = []\n    for integration in bluetooth_integrations:\n        bluetooth_domains.append(integration.domain)\n\n    # Create a list of all bluetooth entities\n    bluetooth_entities: list[str] = []\n    for integration in bluetooth_integrations:\n        for entity in integration.entities:\n            bluetooth_entities.append(entity.name)\n\n    # Create a list of all bluetooth entities with a device_class\n    bluetooth_entities_with_device_class: list[str] = []\n    for integration in bluetooth_integrations:\n        for entity in integration.entities:\n            if entity.device_class is not None:\n                bluetooth_entities_with_device_class.append(entity.name)\n\n    # Create a list of all bluetooth entities with a device_class\n    bluetooth_entities_with_device_class_and_icon: list[str] = []\n    for integration in bluetooth_integrations:\n        for entity in integration.entities:\n            if entity.device_class is not None and entity.icon is not None:\n                bluetooth_entities_with_device_class_and_icon.append(entity.name)\n\n    # Create a list of all bluetooth entities with a device_class\n    bluetooth_entities_with_device_class_and_unit: list[str] = []\n    for integration in bluetooth_integrations:\n        for entity in integration.entities:\n            if entity.device_class is not None and entity.unit is not None:\n                bluetooth_entities_with_device_class_and_unit.append(entity.name)\n\n    # Create a list of all bluetooth entities with a device_class\n    bluetooth_entities_with_device_class_and_unit_and", "CodeBleu_score": 17.978958881717737}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tclient := resty.New()\n\tresp, err := client.R().\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.refreshToken,\n\t\t\t\"client_id\":     d.appKey,\n\t\t\t\"client_secret\": d.appSecret,\n\t\t}).\n\t\tPost(\"https://api.dropboxapi.com/oauth2/token\")\n\tif err != nil {\n\t\tlogger.Log.Error(\"refresh token error\", zap.Error(err))\n\t\treturn err\n\t}\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Log.Error(\"refresh token error\", zap.String(\"message\", resp.String()))\n\t\treturn fmt.Errorf(\"refresh token error\")\n\t}\n\tvar tokenResp struct {\n\t\tAccessToken  string `json:\"access_token\"`\n\t\tTokenType    string `json:\"token_type\"`\n\t\tExpiresIn    int    `json:\"expires_in\"`\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t}\n\terr = resp.Unmarshal(&tokenResp)\n\tif err != nil {\n\t\tlogger.Log.Error(\"refresh token error\", zap.Error(err))\n\t\treturn err\n\t}\n\td.accessToken = tokenResp.AccessToken\n\td.refreshToken = tokenResp.RefreshToken\n\td.expiresIn = tokenResp.ExpiresIn\n\treturn nil\n}", "CodeBleu_score": 48.03792005096974}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp, err := resty.New().R().SetFormData(map[string]string{\n\t\t\"grant_type\":    \"refresh_token\",\n\t\t\"refresh_token\": d.refreshToken,\n\t\t\"client_id\":     d.clientId,\n\t\t\"client_secret\": d.clientSecret,\n\t}).Post(d.tokenUrl)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Log.Error(\"Dropbox refresh token failed\", zap.Int(\"status\", resp.StatusCode()), zap.String(\"body\", resp.String()))\n\t\treturn fmt.Errorf(\"Dropbox refresh token failed\")\n\t}\n\tvar result map[string]interface{}\n\terr = resp.Unmarshal(&result)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.accessToken = result[\"access_token\"].(string)\n\td.refreshToken = result[\"refresh_token\"].(string)\n\treturn nil\n}", "CodeBleu_score": 52.33359846523719}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tlogger.Info(\"refresh token\")\n\tclient := resty.New()\n\tresp, err := client.R().\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"client_id\":     d.ClientID,\n\t\t\t\"client_secret\": d.ClientSecret,\n\t\t}).\n\t\tPost(d.TokenURL)\n\n\tif err != nil {\n\t\tlogger.Error(\"refresh token error\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"refresh token error\", zap.Error(err))\n\t\treturn fmt.Errorf(\"status code %d\", resp.StatusCode())\n\t}\n\n\tvar token Token\n\terr = resp.Unmarshal(&token)\n\tif err != nil {\n\t\tlogger.Error(\"refresh token error\", zap.Error(err))\n\t\treturn err\n\t}\n\n\td.AccessToken = token.AccessToken\n\td.RefreshToken = token.RefreshToken\n\td.ExpiresIn = token.ExpiresIn\n\n\tlogger.Info(\"refresh token success\", zap.String(\"access_token\", token.AccessToken))\n\n\treturn nil\n}", "CodeBleu_score": 49.66699081973049}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar (\n\t\terr  error\n\t\tbody []byte\n\t)\n\tfor i := 0; i < 3; i++ {\n\t\treq := d.client.R().\n\t\t\tSetHeader(\"Authorization\", \"Bearer \"+d.token.AccessToken).\n\t\t\tSetHeader(\"Content-Type\", \"application/json\").\n\t\t\tSetHeader(\"Accept\", \"application/json\").\n\t\t\tSetHeader(\"Accept-Charset\", \"UTF-8\").\n\t\t\tSetHeader(\"GData-Version\", \"3.0\").\n\t\t\tSetHeader(\"X-GData-Key\", \"key=\"+d.conf.ClientID).\n\t\t\tSetHeader(\"X-Origin\", \"https://www.casaos.tech\").\n\t\t\tSetHeader(\"X-JavaScript-User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36\").\n\t\t\tSetHeader(\"X-Requested-With\", \"XMLHttpRequest\").\n\t\t\tSetHeader(\"Referer\", \"https://www.casaos.tech/\").\n\t\t\tSetHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36\").\n\t\t\tSetHeader(\"Origin\", \"https://www.casaos.tech\").\n\t\t\tSetHeader(\"Sec-Fetch-Site\", \"same-site\").\n\t\t\tSetHeader(\"Sec-Fetch-Mode\", \"cors\").\n\t\t\tSetHeader(\"Sec-Fetch-Dest\", \"empty\").\n\t\t\tSetHeader(\"Accept-Language\", \"zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\").\n\t\t\tSetHeader(\"Cookie\",", "CodeBleu_score": 17.93299651727737}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar body []byte\n\tvar err error\n\tvar req *resty.Request\n\n\tfor i := 0; i < 2; i++ {\n\t\treq = d.client.R().SetHeader(\"Authorization\", \"Bearer \"+d.token)\n\t\tif callback != nil {\n\t\t\tcallback(req)\n\t\t}\n\t\tif method == \"GET\" {\n\t\t\tbody, err = req.Get(url).Bytes()\n\t\t} else if method == \"POST\" {\n\t\t\tbody, err = req.Post(url).Bytes()\n\t\t} else if method == \"PATCH\" {\n\t\t\tbody, err = req.Patch(url).Bytes()\n\t\t} else if method == \"PUT\" {\n\t\t\tbody, err = req.Put(url).Bytes()\n\t\t} else if method == \"DELETE\" {\n\t\t\tbody, err = req.Delete(url).Bytes()\n\t\t}\n\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tif err.Error() == \"401 Unauthorized\" {\n\t\t\t\t// token expired, refresh it\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif resp != nil {\n\t\terr = json.Unmarshal(body, resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}", "CodeBleu_score": 51.66222526065769}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar err error\n\tvar body []byte\n\tvar req *resty.Request\n\tfor i := 0; i < 3; i++ {\n\t\treq = d.client.R().\n\t\t\tSetHeader(\"Authorization\", \"Bearer \"+d.accessToken).\n\t\t\tSetHeader(\"Content-Type\", \"application/json\").\n\t\t\tSetHeader(\"User-Agent\", \"CasaOS\").\n\t\t\tSetHeader(\"Accept\", \"application/json\").\n\t\t\tSetHeader(\"Accept-Charset\", \"utf-8\").\n\t\t\tSetHeader(\"Accept-Encoding\", \"gzip, deflate\").\n\t\t\tSetHeader(\"X-Goog-AuthUser\", \"0\").\n\t\t\tSetHeader(\"GData-Version\", \"3.0\").\n\t\t\tSetHeader(\"X-Origin\", \"https://casaos.io\").\n\t\t\tSetHeader(\"X-GUploader-UploadID\", \"AEnB2Uqm9-H9r168975251176\").\n\t\t\tSetHeader(\"X-GUploader-UploadProtocol\", \"resumable\").\n\t\t\tSetHeader(\"X-GUploader-UploadURL\", \"https://www.googleapis.com/upload/drive/v3/files?uploadType=resumable\").\n\t\t\tSetHeader(\"X-GUploader-UploadContentType\", \"application/json\").\n\t\t\tSetHeader(\"X-GUploader-UploadContentLength\", \"124\").\n\t\t\tSetHeader(\"X-GUploader-UploadMetadata\", \"{\\\"name\\\":\\\"test.txt\\\",\\\"parents\\\":[\\\"17i_lQ3J8lq2mU9kJl50N8qpQR2G4bF3\\\"],\\\"mimeType\\\":\\\"text/plain\\\"}\").\n\t\t\tSetHeader(\"X-GUploader-UploadContentLength\", \"124\").\n\t\t\tSetHeader(\"X-GUploader-UploadContentType\", \"application/json\").\n\t\t\tSetHeader(\"X-GUploader-UploadMetadata\", \"{\\\"name\\\":\\\"test.txt\\\",\\\"parents\\\":[\\\"17i_lQ3J8", "CodeBleu_score": 18.12819305175451}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tvar (\n\t\terr error\n\t\treq *resty.Request\n\t\tres *resty.Response\n\t)\n\t// Create a new request with the correct headers and method.\n\treq = d.client.R().\n\t\tSetContext(ctx).\n\t\tSetFileReader(\"file\", stream.FileInfo.Name, stream.Reader)\n\n\tif d.chunkSize != 0 {\n\t\treq.SetHeader(\"Content-Type\", \"application/octet-stream\")\n\t\treq.SetHeader(\"Content-Length\", strconv.FormatInt(stream.FileInfo.Size, 10))\n\t}\n\n\t// Upload each chunk sequentially.\n\tfor {\n\t\t// If the context is cancelled, return an error.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// If the stream is at EOF, return nil.\n\t\tif stream.EOF() {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Upload the next chunk.\n\t\tres, err = req.Execute(\"PUT\", url)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the response is not successful, return the error.\n\t\tif err = res.Error(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the response is not successful, return the error.\n\t\tif err = res.Error(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the response is not successful, return the error.\n\t\tif err = res.Error(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Update the upload progress.\n\t\td.updateProgress(stream.Offset(), stream.Size(), stream.FileInfo.Size)\n\t}\n}", "CodeBleu_score": 38.15783831678491}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// The chunk size is calculated using the recommended chunk size from Google Drive.\n\t// https://developers.google.com/drive/api/v3/manage-uploads#resumable\n\tchunkSize := 32 * 1024 * 1024\n\t// The total number of bytes in the file.\n\ttotalBytes := stream.Size()\n\t// The number of bytes that have been uploaded so far.\n\tbytesUploaded := int64(0)\n\t// The number of bytes that are left to upload.\n\tbytesLeft := totalBytes\n\t// The number of bytes that are uploaded in the current chunk.\n\tbytesUploadedInCurrentChunk := int64(0)\n\t// The number of bytes that are left to upload in the current chunk.\n\tbytesLeftInCurrentChunk := int64(0)\n\t// The number of bytes that are uploaded in the previous chunk.\n\tbytesUploadedInPreviousChunk := int64(0)\n\t// The number of bytes that are left to upload in the previous chunk.\n\tbytesLeftInPreviousChunk := int64(0)\n\t// The number of bytes that are uploaded in the current chunk.\n\tbytesUploadedInCurrentChunk = int64(0)\n\t// The number of bytes that are left to upload in the current chunk.\n\tbytesLeftInCurrentChunk = int64(0)\n\t// The number of bytes that are uploaded in the previous chunk.\n\tbytesUploadedInPreviousChunk = int64(0)\n\t// The number of bytes that are left to upload in the previous chunk.\n\tbytesLeftInPreviousChunk = int64(0)\n\t// The number of times the current chunk has been retried.\n\tchunkRetryCount := int64(0)\n\t// The number of times the previous chunk has been retried.\n\tpreviousChunkRetryCount := int64(0)\n\t// The number of times the current chunk has been retried.\n\tcurrentChunkRetryCount := int64(0)\n\t// The number of times the previous chunk has been retried.\n\tpreviousChunkRetryCount := int64(0)\n\t// The number of times the", "CodeBleu_score": 19.596788951367273}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 1024 // 1GB\n\t// chunkSize := 1024 * 1024 // 1MB\n\t// chunkSize := 1024 // 1KB\n\n\tvar offset int64\n\tfor {\n\t\t// Read the chunk\n\t\tchunk := make([]byte, chunkSize)\n\t\tn, err := stream.ReadAt(chunk, offset)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a new request with the chunk\n\t\treq := resty.NewRequest().SetContext(ctx).SetBody(chunk[:n]).SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+int64(n)-1, stream.Size()))\n\t\t// Send the request and handle the response\n\t\tresp, err := req.Put(url)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif resp.StatusCode() != http.StatusOK {\n\t\t\treturn fmt.Errorf(\"status code: %d\", resp.StatusCode())\n\t\t}\n\t\toffset += int64(n)\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.6279508821303}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req model.UmountStorageRequest\n\terr := ctx.Bind(&req)\n\tif err != nil {\n\t\tlogger.LOGD.Error(\"unmount storage request bind error\", zap.Any(\"error\", err))\n\t\treturn httper.HttpErrMsgs(ctx, err.Error(), err.Error())\n\t}\n\tif strings.TrimSpace(req.MountPoint) == \"\" {\n\t\tlogger.LOGD.Error(\"unmount storage request mount point empty\", zap.Any(\"error\", err))\n\t\treturn httper.HttpErrMsgs(ctx, \"mount point is empty\", \"mount point is empty\")\n\t}\n\tif strings.TrimSpace(req.MountPoint) == \"/\" {\n\t\tlogger.LOGD.Error(\"unmount storage request mount point empty\", zap.Any(\"error\", err))\n\t\treturn httper.HttpErrMsgs(ctx, \"mount point is not allowed\", \"mount point is not allowed\")\n\t}\n\terr = service.NewStorageService().UmountStorage(req.MountPoint)\n\tif err != nil {\n\t\tlogger.LOGD.Error(\"unmount storage request error\", zap.Any(\"error\", err))\n\t\treturn httper.HttpErrMsgs(ctx, \"unmount storage request error\", err.Error())\n\t}\n\treturn ctx.JSON(200, common_err.SUCCESS)\n}", "CodeBleu_score": 40.69125876197497}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\n\tmountPoint := ctx.FormValue(\"mount_point\")\n\tif mountPoint == \"\" {\n\t\treturn httper.HttpErrInfo(ctx, \"mount point is empty\", common_err.INVALID_PARAMS, nil)\n\t}\n\n\tlogger.Instance().Info(\"umount storage\", zap.String(\"mount_point\", mountPoint))\n\n\t// \u68c0\u67e5\u662f\u5426\u5b58\u5728\n\tif !service.Storage.IsExist(mountPoint) {\n\t\treturn httper.HttpErrInfo(ctx, \"mount point is not exist\", common_err.INVALID_PARAMS, nil)\n\t}\n\n\t// \u68c0\u67e5\u662f\u5426\u6302\u8f7d\n\tif !service.Storage.IsMounted(mountPoint) {\n\t\treturn httper.HttpErrInfo(ctx, \"mount point is not mounted\", common_err.INVALID_PARAMS, nil)\n\t}\n\n\t// \u68c0\u67e5\u662f\u5426\u662f\u6b63\u5728\u6267\u884c\u7684\u4efb\u52a1\n\tif service.Task.IsExecuting(mountPoint) {\n\t\treturn httper.HttpErrInfo(ctx, \"mount point is executing task\", common_err.INVALID_PARAMS, nil)\n\t}\n\n\t// \u68c0\u67e5\u662f\u5426\u6709\u4efb\u52a1\u5728\u6267\u884c\n\tif service.Task.IsExecuting() {\n\t\treturn httper.HttpErrInfo(ctx, \"mount point is executing task\", common_err.INVALID_PARAMS, nil)\n\t}\n\n\t// \u68c0\u67e5\u662f\u5426\u6709\u4efb\u52a1\u5728\u6267\u884c\n\tif service.Task.IsExecuting() {\n\t\treturn httper.HttpErrInfo(ctx, \"mount point is executing task\", common_err.INVALID_PARAMS, nil)\n\t}\n\n\t// \u68c0\u67e5\u662f\u5426\u6709\u4efb\u52a1\u5728\u6267\u884c\n\tif service.Task.IsExecuting() {\n\t\treturn httper.HttpErrInfo(ctx, \"mount point is executing task\", common_err.INVALID_PARAMS, nil)\n\t}\n\n\t// \u68c0\u67e5\u662f\u5426\u6709\u4efb\u52a1\u5728\u6267\u884c\n\tif service.Task.", "CodeBleu_score": 34.79819283456247}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar mountPoint model.MountPoint\n\tif err := httper.BindJsonBody(ctx, &mountPoint); err != nil {\n\t\tlogger.Log.Error(\"unmount storage failed\", zap.Error(err))\n\t\treturn httper.HandleError(ctx, common_err.NewBusinessError(common_err.UNMOUNT_STORAGE_FAILED, err.Error()))\n\t}\n\n\tif strings.TrimSpace(mountPoint.MountPoint) == \"\" {\n\t\tlogger.Log.Error(\"unmount storage failed\", zap.Error(err))\n\t\treturn httper.HandleError(ctx, common_err.NewBusinessError(common_err.UNMOUNT_STORAGE_FAILED, \"mount point is empty\"))\n\t}\n\n\tif err := service.GetStorageService().UnmountStorage(mountPoint); err != nil {\n\t\tlogger.Log.Error(\"unmount storage failed\", zap.Error(err))\n\t\treturn httper.HandleError(ctx, common_err.NewBusinessError(common_err.UNMOUNT_STORAGE_FAILED, err.Error()))\n\t}\n\n\treturn ctx.JSON(200, httper.JsonObject{\n\t\t\"code\": 200,\n\t\t\"msg\":  \"success\",\n\t\t\"data\": nil,\n\t})\n}", "CodeBleu_score": 40.60897873808098}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewErrMsg(1000001, \"path is missing\"))\n\t}\n\tif !file.IsExist(path) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewErrMsg(1000002, \"file not exist\"))\n\t}\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewErrMsg(1000003, err.Error()))\n\t}\n\tdefer file.Close()\n\tfileInfo, _ := file.Stat()\n\tvar size int64 = 512\n\tif fileInfo.Size() < size {\n\t\tsize = fileInfo.Size()\n\t}\n\tbuffer := make([]byte, size)\n\t_, err = file.Read(buffer)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewErrMsg(1000004, err.Error()))\n\t}\n\tfileType, err := filetype.Match(buffer)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewErrMsg(1000005, err.Error()))\n\t}\n\tctx.Response().Header().Set(\"Content-Type\", fileType.MIME.Value)\n\tctx.Response().Header().Set(\"Content-Disposition\", \"attachment; filename=\"+filepath.Base(path))\n\treturn ctx.Stream(http.StatusOK, file)\n}", "CodeBleu_score": 40.71171079620643}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Error: \"Missing file path\"})\n\t}\n\tfilePath = utils.GetAbsPath(filePath)\n\tif !utils.FileExists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Error: \"File does not exist\"})\n\t}\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Error: err.Error()})\n\t}\n\tdefer file.Close()\n\tfileInfo, _ := file.Stat()\n\thttp.ServeContent(ctx.Response(), ctx.Request(), fileInfo.Name(), fileInfo.ModTime(), file)\n\treturn nil\n}", "CodeBleu_score": 39.51889410103012}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"path is required\"})\n\t}\n\tfilePath = path.Clean(filePath)\n\tfilePath = filepath.Join(\"/\", filePath)\n\tif !strings.HasPrefix(filePath, \"/\") {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"path must start with /\"})\n\t}\n\tif !strings.HasPrefix(filePath, \"/home\") {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"path must start with /home\"})\n\t}\n\tif !strings.HasPrefix(filePath, \"/home/admin\") {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"path must start with /home/admin\"})\n\t}\n\tif strings.Contains(filePath, \"..\") {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"path must not contain ..\"})\n\t}\n\tif !strings.HasSuffix(filePath, \".jpg\") && !strings.HasSuffix(filePath, \".png\") && !strings.HasSuffix(filePath, \".jpeg\") {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"path must be a file\"})\n\t}\n\tfilePath = strings.TrimPrefix(filePath, \"/home/admin\")\n\tfilePath = filepath.Join(\"/home/admin\", filePath)\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"file not found\"})\n\t}\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"file not found\"})\n\t}\n\tdefer file.Close()\n", "CodeBleu_score": 38.53211825529693}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := new(model.NotifyMessage)\n\tif err := ctx.Bind(message); err != nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\tif err := service.NotifyService.SendNotify(name, message); err != nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, model.Response{Success: oasis_err2.SUCCESS, Message: oasis_err2.GetMsg(oasis_err2.SUCCESS)})\n}", "CodeBleu_score": 60.00350923783952}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message model.NotifyMessage\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\n\tif err := service.NotifyServiceInstance().SendNotify(message.Name, message.Message); err != nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\"status\":  \"success\",\n\t\t\"message\": \"success\",\n\t})\n}", "CodeBleu_score": 45.582212081808436}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message model.NotifyMessage\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.NewBadRequestError(err)\n\t}\n\tif err := service.NotifyServiceInstance().SendNotify(name, message); err != nil {\n\t\treturn common_err.NewInternalServerError(err)\n\t}\n\treturn ctx.JSON(http.StatusOK, model.Response{\n\t\tStatus:  http.StatusOK,\n\t\tMessage: \"success\",\n\t})\n}", "CodeBleu_score": 57.54000627907161}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade HTTP request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add new WebSocket connection to the list of connections.\n\tservice.NotifyService.Add(ws)\n\t// Ensure that the message sending service is running.\n\tservice.NotifyService.Start()\n\n\t// Loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read message from the WebSocket connection.\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tfmt.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type and message.\n\t\tfmt.Printf(\"recv: %s\", message)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\tservice.NotifyService.Remove(ws)\n\n\treturn nil\n}", "CodeBleu_score": 44.48310088093467}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tfmt.Println(\"NotifyWS\")\n\tws, err := service.UpgradeToWebSocket(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the WebSocket connection to the list of connections\n\tservice.AddConnection(ws)\n\tdefer service.RemoveConnection(ws)\n\n\t// Ensure that the message sending service is running\n\tservice.StartMessageSendingService()\n\tdefer service.StopMessageSendingService()\n\n\t// Loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tfmt.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Printf(\"message: %s", "CodeBleu_score": 41.039371069916015}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade HTTP request to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn err\n\t}\n\n\t// Add new WebSocket connection to the list of connections\n\tservice.NotifyService.AddConnection(ws)\n\n\t// Start the message sending service\n\tgo service.NotifyService.SendMessages()\n\n\t// Loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read message from WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print message type, message, and any errors\n\t\tfmt.Printf(\"Received: %s\", message)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.27278316567963}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\tcpuInfo   string\n\t\tdriveInfo string\n\t)\n\tif runtime.GOOS == \"windows\" {\n\t\tcpuInfo = getCPUInfo()\n\t\tdriveInfo = getDriveInfo()\n\t} else {\n\t\tcpuInfo = getCPUInfoUnix()\n\t\tdriveInfo = getDriveInfoUnix()\n\t}\n\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\"cpu\":   cpuInfo,\n\t\t\"drive\": driveInfo,\n\t})\n}", "CodeBleu_score": 20.423389774897093}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar cpuInfo model.CpuInfo\n\tvar cpuInfo2 model.CpuInfo\n\tvar memInfo model.MemInfo\n\tvar diskInfo model.DiskInfo\n\tvar netInfo model.NetInfo\n\tvar sysInfo model.SysInfo\n\tvar sysInfo2 model.SysInfo\n\tvar sysInfo3 model.SysInfo\n\tvar sysInfo4 model.SysInfo\n\tvar sysInfo5 model.SysInfo\n\tvar sysInfo6 model.SysInfo\n\tvar sysInfo7 model.SysInfo\n\tvar sysInfo8 model.SysInfo\n\tvar sysInfo9 model.SysInfo\n\tvar sysInfo10 model.SysInfo\n\tvar sysInfo11 model.SysInfo\n\tvar sysInfo12 model.SysInfo\n\tvar sysInfo13 model.SysInfo\n\tvar sysInfo14 model.SysInfo\n\tvar sysInfo15 model.SysInfo\n\tvar sysInfo16 model.SysInfo\n\tvar sysInfo17 model.SysInfo\n\tvar sysInfo18 model.SysInfo\n\tvar sysInfo19 model.SysInfo\n\tvar sysInfo20 model.SysInfo\n\tvar sysInfo21 model.SysInfo\n\tvar sysInfo22 model.SysInfo\n\tvar sysInfo23 model.SysInfo\n\tvar sysInfo24 model.SysInfo\n\tvar sysInfo25 model.SysInfo\n\tvar sysInfo26 model.SysInfo\n\tvar sysInfo27 model.SysInfo\n\tvar sysInfo28 model.SysInfo\n\tvar sysInfo29 model.SysInfo\n\tvar sysInfo30 model.SysInfo\n\tvar sysInfo31 model.SysInfo\n\tvar sysInfo32 model.SysInfo\n\tvar sysInfo33 model.SysInfo\n\tvar sysInfo34 model.SysInfo\n\tvar sysInfo35 model.SysInfo\n\tvar sysInfo36 model.SysInfo\n\tvar sysInfo37 model.SysInfo\n\tvar sysInfo38 model.SysInfo\n\tvar sysInfo39 model.SysInfo\n\tvar sysInfo4", "CodeBleu_score": 3.0750349259623238}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// \u83b7\u53d6\u786c\u4ef6\u4fe1\u606f\n\tvar hardwareInfo model.HardwareInfo\n\thardwareInfo.CPUArchitecture = runtime.GOARCH\n\thardwareInfo.CPUModel = runtime.GOARCH\n\thardwareInfo.CPUCount = runtime.NumCPU()\n\thardwareInfo.DriveModel = runtime.GOOS\n\thardwareInfo.DriveCount = port.GetDiskCount()\n\thardwareInfo.DriveTotal = port.GetDiskTotal()\n\thardwareInfo.DriveFree = port.GetDiskFree()\n\thardwareInfo.DriveUsed = port.GetDiskUsed()\n\thardwareInfo.DriveUsage = port.GetDiskUsage()\n\thardwareInfo.DriveInfo = port.GetDiskInfo()\n\thardwareInfo.DriveType = port.GetDiskType()\n\thardwareInfo.DriveSerial = port.GetDiskSerial()\n\thardwareInfo.DriveSize = port.GetDiskSize()\n\thardwareInfo.DriveMount = port.GetDiskMount()\n\thardwareInfo.DriveFs = port.GetDiskFs()\n\thardwareInfo.DriveUsedPercent = port.GetDiskUsedPercent()\n\thardwareInfo.DriveUsedInGb = port.GetDiskUsedInGb()\n\thardwareInfo.DriveFreeInGb = port.GetDiskFreeInGb()\n\thardwareInfo.DriveTotalInGb = port.GetDiskTotalInGb()\n\thardwareInfo.DriveUsageInPercent = port.GetDiskUsageInPercent()\n\thardwareInfo.DriveUsedInPercent = port.GetDiskUsedInPercent()\n\thardwareInfo.DriveFreeInPercent = port.GetDiskFreeInPercent()\n\thardwareInfo.DriveTotalInPercent = port.GetDiskTotalInPercent()\n\thardwareInfo.DriveUsedInTb = port.GetDiskUsedInTb()\n\thardwareInfo.DriveFreeInTb = port.GetDiskFreeInTb()\n\thardwareInfo.DriveTotalInTb", "CodeBleu_score": 16.27989183960237}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tstopped := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tstopped = append(stopped, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &stopped,\n\t}, nil\n}", "CodeBleu_score": 68.46322602150309}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning, notRunning := make([]string, 0), make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 73.15902922770508}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar running []string\n\tvar notRunning []string\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 73.9205589273657}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tif i.isOnline {\n\t\t// \u53d1\u9001\u901a\u77e5\n\t\ti.socket.Emit(\"notify\", name, message)\n\t}\n}", "CodeBleu_score": 11.235238024536564}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Create a new notification instance\n\tnotify := &notify.Notification{\n\t\tName:      name,\n\t\tMessage:   message,\n\t\tCreatedAt: time.Now(),\n\t}\n\n\t// Marshal the notification message to JSON\n\tmsg, err := json2.Marshal(notify)\n\tif err != nil {\n\t\tlogger.Log.Error(\"Failed to marshal notification message\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the notification to the message bus\n\tif err := i.bus.Publish(common.NotifyTopic, msg); err != nil {\n\t\tlogger.Log.Error(\"Failed to publish notification message\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 33.78945017176566}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tlogger.Info(\"send notify\", zap.String(\"name\", name), zap.Any(\"message\", message))\n\tmessage[\"time\"] = time.Now().Format(\"2006-01-02 15:04:05\")\n\tmessage[\"name\"] = name\n\tmessage[\"type\"] = \"notify\"\n\tmessage[\"notify_id\"] = common.GetUuid()\n\tmessage[\"notify_type\"] = \"server\"\n\t//message[\"notify_id\"] = common.GetUuid()\n\tmessage[\"notify_time\"] = time.Now().Format(\"2006-01-02 15:04:05\")\n\tmessage[\"notify_type\"] = \"server\"\n\tmessage[\"notify_status\"] = \"unread\"\n\tmessage[\"notify_url\"] = \"\"\n\tmessage[\"notify_user\"] = \"\u7cfb\u7edf\"\n\tmessage[\"notify_title\"] = \"\"\n\tmessage[\"notify_content\"] = \"\"\n\tmessage[\"notify_icon\"] = \"\"\n\tmessage[\"notify_user\"] = \"\u7cfb\u7edf\"\n\tmessage[\"notify_time\"] = time.Now().Format(\"2006-01-02 15:04:05\")\n\tmessage[\"notify_type\"] = \"server\"\n\tmessage[\"notify_status\"] = \"unread\"\n\tmessage[\"notify_url\"] = \"\"\n\tmessage[\"notify_user\"] = \"\u7cfb\u7edf\"\n\tmessage[\"notify_title\"] = \"\"\n\tmessage[\"notify_content\"] = \"\"\n\tmessage[\"notify_icon\"] = \"\"\n\tmessage[\"notify_user\"] = \"\u7cfb\u7edf\"\n\tmessage[\"notify_time\"] = time.Now().Format(\"2006-01-02 15:04:05\")\n\tmessage[\"notify_type\"] = \"server\"\n\tmessage[\"notify_status\"] = \"unread\"\n\tmessage[\"notify_url\"] = \"\"\n\tmessage[\"notify_user\"] = \"\u7cfb\u7edf\"\n\tmessage[\"notify_title\"] = \"\"\n\tmessage[\"notify_content\"] = \"\"\n\tmessage[\"notify_icon\"] = \"\"\n\tmessage[\"notify_user\"] = \"\u7cfb\u7edf\"\n\tmessage[\"notify_time\"] = time.Now().Format(\"2", "CodeBleu_score": 28.94828328209368}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\treturn message_bus.NewClientWithResponses(c.wsServer)\n}", "CodeBleu_score": 7.165503352694672}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tvar client = message_bus.NewClientWithResponses()\n\tvar server = c.GetMessageBusAddress()\n\tif server != \"\" {\n\t\tclient.SetServer(server)\n\t} else {\n\t\tclient.SetServer(\"ws://localhost:8080\")\n\t}\n\treturn client\n}", "CodeBleu_score": 27.112858933894397}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\treturn message_bus.NewClientWithResponses(c.Config.GetString(\"message_bus_address\"))\n}", "CodeBleu_score": 9.860957099517547}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\treturn strings.Split(ip, \":\")[0]\n}", "CodeBleu_score": 31.822622327779175}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\treturn strings.Split(ip, \",\")[0]\n}", "CodeBleu_score": 32.13291882306569}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\treturn strings.Split(ip, \":\")[0]\n}", "CodeBleu_score": 31.822622327779175}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tlogger.Info(\"Start to generate system entry\")\n\t// The modules directory path.\n\tmodulesPath := filepath.Join(config.AppInfo.RootPath, \"modules\")\n\t// The entry file path.\n\tentryFilePath := filepath.Join(config.AppInfo.RootPath, \"modules\", \"system\", \"entry.json\")\n\t// The array of entry files.\n\tvar entries []string\n\t// The array of module entry files.\n\tvar moduleEntries []string\n\t// The array of module entry file paths.\n\tvar moduleEntryPaths []string\n\t// The array of module entry file paths.\n\tvar moduleEntryPaths2 []string\n\t// The array of module entry files.\n\tvar moduleEntryFiles []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles2 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles3 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles4 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles5 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles6 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles7 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles8 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles9 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles10 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles11 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles12 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles13 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles14 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles15 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles16 []string\n\t// The array of module entry file paths.\n\tvar moduleEntryFiles17 []string\n\t// The array of module entry file paths.\n\tvar", "CodeBleu_score": 16.930978290784054}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the modules directory path\n\tmodulesDirPath := filepath.Join(config.AppConfig.RootPath, \"modules\")\n\t// Get the entry file path\n\tentryFilePath := filepath.Join(modulesDirPath, \"entry.json\")\n\t// Create the modules directory if it does not exist\n\tif !file.DirExists(modulesDirPath) {\n\t\terr := os.MkdirAll(modulesDirPath, 0777)\n\t\tif err != nil {\n\t\t\tlogger.Log.Error(\"Failed to create modules directory\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\t// Create the entry file if it does not exist\n\tif !file.FileExists(entryFilePath) {\n\t\terr := file.CreateFile(entryFilePath)\n\t\tif err != nil {\n\t\t\tlogger.Log.Error(\"Failed to create entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\t// Read the entry file\n\tentryFileContent, err := file.ReadFile(entryFilePath)\n\tif err != nil {\n\t\tlogger.Log.Error(\"Failed to read entry file\", zap.Error(err))\n\t\treturn\n\t}\n\t// Read the modules directory for entry.json files\n\tmodulesDirEntryFilePaths, err := file.GetFilePaths(modulesDirPath, \"entry.json\")\n\tif err != nil {\n\t\tlogger.Log.Error(\"Failed to read modules directory for entry.json files\", zap.Error(err))\n\t\treturn\n\t}\n\t// Concatenate the content of each entry.json file into a single JSON array\n\tvar entryFileContents []byte\n\tfor _, moduleDirEntryFilePath := range modulesDirEntryFilePaths {\n\t\tmoduleDirEntryFileContent, err := file.ReadFile(moduleDirEntryFilePath)\n\t\tif err != nil {\n\t\t\tlogger.Log.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t\tentryFileContents = append(entryFileContents, moduleDirEntryFileContent...)\n\t}\n\t// Write the concatenated content to the entry file\n\terr = file", "CodeBleu_score": 42.830870407907774}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Ensure the modules directory exists.\n\tif _, err := os.Stat(common.ModulesPath); os.IsNotExist(err) {\n\t\terr = os.MkdirAll(common.ModulesPath, 0777)\n\t\tif err != nil {\n\t\t\tlogger.Log.Error(\"Failed to create modules directory\", zap.Error(err))\n\t\t}\n\t}\n\t// Ensure the entry file exists.\n\tif _, err := os.Stat(common.EntryFile); os.IsNotExist(err) {\n\t\t_, err = os.Create(common.EntryFile)\n\t\tif err != nil {\n\t\t\tlogger.Log.Error(\"Failed to create entry file\", zap.Error(err))\n\t\t}\n\t}\n\t// Read each module directory for entry.json files.\n\tfiles, err := filepath.Glob(common.ModulesPath + \"/*\")\n\tif err != nil {\n\t\tlogger.Log.Error(\"Failed to read modules directory\", zap.Error(err))\n\t}\n\tvar modules []interface{}\n\tfor _, file := range files {\n\t\t// Ensure the file exists.\n\t\tif _, err := os.Stat(file); os.IsNotExist(err) {\n\t\t\tcontinue\n\t\t}\n\t\t// Read the file.\n\t\tdata, err := os.ReadFile(file)\n\t\tif err != nil {\n\t\t\tlogger.Log.Error(\"Failed to read module entry file\", zap.Error(err))\n\t\t}\n\t\t// Ensure the file content is valid JSON.\n\t\tif !gjson.ValidBytes(data) {\n\t\t\tlogger.Log.Error(\"Invalid JSON in module entry file\", zap.String(\"file\", file))\n\t\t\tcontinue\n\t\t}\n\t\t// Append the file content to the modules array.\n\t\tmodules = append(modules, gjson.ParseBytes(data))\n\t}\n\t// Concatenate the modules array into a single JSON array.\n\tdata, err := json.Marshal(modules)\n\tif err != nil {\n\t\tlogger.Log.Error(\"Failed to marshal modules array\", zap.Error(", "CodeBleu_score": 44.70300855935984}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range interfaces {\n\t\tif i.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif i.Flags&net.FlagLoopback != 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\tmac := strings.Replace(i.HardwareAddr.String(), \":\", \"\", -1)\n\t\tif len(mac) == 12 {\n\t\t\treturn mac, nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no mac address found\")\n}", "CodeBleu_score": 58.100615539849755}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\taddrs, err := net.InterfaceAddrs()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range interfaces {\n\t\tif i.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif i.Flags&net.FlagLoopback != 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\tmac := i.HardwareAddr.String()\n\t\tif mac == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net2.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net2.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net2.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue // not an ipv4 address\n\t\t\t}\n\t\t\treturn mac, nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no suitable network interface found\")\n}", "CodeBleu_score": 55.57616215975418}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range interfaces {\n\t\tif i.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif i.Flags&net.FlagLoopback != 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\tmac := i.HardwareAddr.String()\n\t\tif mac == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\treturn mac, nil\n\t}\n\treturn \"\", errors.New(\"no MAC address found\")\n}", "CodeBleu_score": 59.735910179720186}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t nRet;\n\tSAppInfo *pAppInfo;\n\n\tnRet = 0;\n\n\t/* Add a reference to the request object */\n\tpRequest->nRefCount++;\n\n\t/* Increment the request count for the TSC object */\n\tpTscObj->nRequestCount++;\n\n\t/* Update the application's request summary */\n\tpAppInfo = pTscObj->pAppInfo;\n\tif (pAppInfo) {\n\t\tpAppInfo->nTotalRequestCount++;\n\t\tpAppInfo->nCurrentRequestCount++;\n\t}\n\n\t/* Log debug information */\n\tif (g_fLogDebug) {\n\t\tlogDebug(\"registerRequest: TSC=%s, Request=%s, RequestCount=%d, RefCount=%d\", pTscObj->pszTscName, pRequest->pszRequestName, pTscObj->nRequestCount, pRequest->nRefCount);\n\t}\n\n\treturn nRet;\n}", "CodeBleu_score": 29.959731603713934}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t rc = TS_SUCCESS;\n\n    if (pRequest == NULL) {\n        rc = TS_ERROR;\n        TLOG_ERROR(\"pRequest is NULL\n\");\n        goto done;\n    }\n\n    if (pTscObj == NULL) {\n        rc = TS_ERROR;\n        TLOG_ERROR(\"pTscObj is NULL\n\");\n        goto done;\n    }\n\n    if (pTscObj->pApplication == NULL) {\n        TLOG_ERROR(\"pTscObj->pApplication is NULL\n\");\n        goto done;\n    }\n\n    if (pTscObj->pApplication->pSummary == NULL) {\n        TLOG_ERROR(\"pTscObj->pApplication->pSummary is NULL\n\");\n        goto done;\n    }\n\n    TRefInc(pRequest);\n\n    TMutexLock(&pTscObj->pApplication->pSummary->mutex);\n    pTscObj->pApplication->pSummary->totalRequestCount++;\n    pTscObj->pApplication->pSummary->currentRequestCount++;\n    TMutexUnlock(&pTscObj->pApplication->pSummary->mutex);\n\n    TLOG_DEBUG(\"registerRequest: %s %s %s %d\n\", pTscObj->pApplication->pSummary->appName, pTscObj->pApplication->pSummary->appId, pTscObj->pApplication->pSummary->version, pTscObj->pApplication->pSummary->totalRequestCount);\n\ndone:\n    return rc;\n}", "CodeBleu_score": 39.02620479634648}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\n\tint32_t rc = 0;\n\n\tif (pRequest && pTscObj) {\n\n\t\tpRequest->pTscObj = pTscObj;\n\n\t\tpTscObj->pRequest = pRequest;\n\n\t\tpTscObj->requestCount++;\n\n\t\tif (pTscObj->pAppInfo) {\n\n\t\t\tpTscObj->pAppInfo->requestCount++;\n\n\t\t\tpTscObj->pAppInfo->currentRequestCount++;\n\n\t\t}\n\n\t\tlogDebug(\"registerRequest: Request %d registered with TSC %d\", pRequest->requestId, pTscObj->tscId);\n\n\t\trc = 1;\n\n\t}\n\n\treturn rc;\n\n}", "CodeBleu_score": 35.70451580999807}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tint i;\n\tint len;\n\tchar *db = NULL;\n\n\tif (pRequest->db != NULL) {\n\t\tif (strcmp(pRequest->db, exceptDb) == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pRequest->nDb; i++) {\n\t\tdb = pRequest->dbs[i];\n\t\tif (db != NULL) {\n\t\t\tlen = strlen(db);\n\t\t\tif (db[len - 1] == '.') {\n\t\t\t\tdb[len - 1] = '\\0';\n\t\t\t}\n\t\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 57.49831877246487}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    char *db = NULL;\n    bool result = true;\n\n    db = pRequest->db;\n    if (db && exceptDb && strcmp(db, exceptDb) != 0) {\n        result = false;\n    }\n\n    if (result) {\n        char *schema = NULL;\n        int dbLen = 0;\n        int schemaLen = 0;\n\n        dbLen = strlen(db);\n        schema = strchr(db, '.');\n        if (schema) {\n            schemaLen = strlen(schema);\n            if (dbLen > schemaLen) {\n                dbLen -= schemaLen;\n                db[dbLen] = '\\0';\n                if (exceptDb && strcmp(db, exceptDb) != 0) {\n                    result = false;\n                }\n            }\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 43.930985078133844}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (pRequest == NULL || exceptDb == NULL)\n        return false;\n\n    char* db = pRequest->db;\n    if (db == NULL)\n        return false;\n\n    if (strcmp(db, exceptDb) != 0) {\n        char* dbs = pRequest->dbs;\n        if (dbs == NULL)\n            return false;\n\n        char* dbs_ptr = dbs;\n        while (true) {\n            char* next_db = strchr(dbs_ptr, ',');\n            if (next_db == NULL)\n                next_db = dbs_ptr + strlen(dbs_ptr);\n\n            if (next_db == dbs_ptr)\n                break;\n\n            char* db_end = next_db;\n            if (next_db > dbs_ptr)\n                db_end--;\n\n            if (db_end - dbs_ptr > 0) {\n                char* db_name = (char*)t_malloc(db_end - dbs_ptr + 1);\n                strncpy(db_name, dbs_ptr, db_end - dbs_ptr);\n                db_name[db_end - dbs_ptr] = '\\0';\n\n                if (strcmp(db_name, exceptDb) != 0) {\n                    t_free(db_name);\n                    return false;\n                }\n\n                t_free(db_name);\n            }\n\n            dbs_ptr = next_db + 1;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 44.243494918528484}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\n\tbool rc = false;\n\n\tswitch (code) {\n\n\t\tcase TERR_NO_RESOURCES:\n\n\t\tcase TERR_INTERNAL_ERROR:\n\n\t\tcase TERR_NOT_IMPLEMENTED:\n\n\t\tcase TERR_NOT_FOUND:\n\n\t\tcase TERR_NOT_ALLOWED:\n\n\t\tcase TERR_NOT_AUTHORIZED:\n\n\t\tcase TERR_NOT_AUTHENTICATED:\n\n\t\tcase TERR_NOT_SUPPORTED:\n\n\t\tcase TERR_BAD_PARAMETER:\n\n\t\tcase TERR_BAD_REQUEST:\n\n\t\tcase TERR_BAD_RESPONSE:\n\n\t\tcase TERR_BAD_STATE:\n\n\t\tcase TERR_BAD_VERSION:\n\n\t\tcase TERR_BAD_SESSION:\n\n\t\tcase TERR_BAD_MESSAGE:\n\n\t\tcase TERR_BAD_USER:\n\n\t\tcase TERR_BAD_PASSWORD:\n\n\t\tcase TERR_BAD_TOKEN:\n\n\t\tcase TERR_BAD_TIMESTAMP:\n\n\t\tcase TERR_BAD_SIGNATURE:\n\n\t\tcase TERR_BAD_CERTIFICATE:\n\n\t\tcase TERR_BAD_PRIVATE_KEY:\n\n\t\tcase TERR_BAD_PUBLIC_KEY:\n\n\t\tcase TERR_BAD_NONCE:\n\n\t\tcase TERR_BAD_CHALLENGE:\n\n\t\tcase TERR_BAD_TOKEN_TYPE:\n\n\t\tcase TERR_BAD_TOKEN_FORMAT:\n\n\t\tcase TERR_BAD_TOKEN_VERSION:\n\n\t\tcase TERR_BAD_TOKEN_LENGTH:\n\n\t\tcase TERR_BAD_TOKEN_SIGNATURE:\n\n\t\tcase TERR_BAD_TOKEN_EXPIRY:\n\n\t\tcase TERR_BAD_TOKEN_", "CodeBleu_score": 21.92997981089938}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == TERR_RPC_REDIRECT) {\n        switch (msgType) {\n            case TMSG_RPC_CALL:\n            case TMSG_RPC_CALL_ONEWAY:\n            case TMSG_RPC_CALL_ASYNC:\n            case TMSG_RPC_CALL_ASYNC_ONEWAY:\n            case TMSG_RPC_CALL_REPLY:\n                return false;\n            default:\n                return true;\n        }\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 44.701856341448085}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TS_ERR_NO_SUCH_FUNCTION) {\n\t\treturn (msgType != TMSG_FUNCTION_REMOVE && msgType != TMSG_FUNCTION_LIST && msgType != TMSG_FUNCTION_ADD && msgType != TMSG_FUNCTION_UPDATE);\n\t} else if (code == TS_ERR_NO_SUCH_USER) {\n\t\treturn (msgType != TMSG_USER_REMOVE && msgType != TMSG_USER_LIST && msgType != TMSG_USER_ADD && msgType != TMSG_USER_UPDATE);\n\t} else if (code == TS_ERR_NO_SUCH_CACHE) {\n\t\treturn (msgType != TMSG_CACHE_REMOVE && msgType != TMSG_CACHE_LIST && msgType != TMSG_CACHE_ADD && msgType != TMSG_CACHE_UPDATE);\n\t} else if (code == TS_ERR_NO_SUCH_HOST) {\n\t\treturn (msgType != TMSG_HOST_REMOVE && msgType != TMSG_HOST_LIST && msgType != TMSG_HOST_ADD && msgType != TMSG_HOST_UPDATE);\n\t} else if (code == TS_ERR_NO_SUCH_PROFILE) {\n\t\treturn (msgType != TMSG_PROFILE_REMOVE && msgType != TMSG_PROFILE_LIST && msgType != TMSG_PROFILE_ADD && msgType != TMSG_PROFILE_UPDATE);\n\t} else if (code == TS_ERR_NO_SUCH_PLUGIN) {\n\t\treturn (msgType != TMSG_PLUGIN_REMOVE && msgType != TMSG_PLUGIN_LIST && msgType != TMSG_PLUGIN_ADD && msgType != TMSG_PLUGIN_UPDATE);\n\t} else if (code == TS_ERR_NO_SUCH_REMAP) {\n\t\treturn (msgType != TMSG_REMAP_REMOVE && msgType != TMSG_REMAP_LIST &&", "CodeBleu_score": 31.81803205641309}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\n\tif (!pRequests) {\n\n\t\treturn;\n\n\t}\n\n\tint nRequests = SHashGetCount(pRequests);\n\n\tif (nRequests <= 0) {\n\n\t\treturn;\n\n\t}\n\n\tint nRequestId = 0;\n\n\tSRequest *pRequest = NULL;\n\n\tSHashIterator hIterator;\n\n\tSHashInitIterator(pRequests, &hIterator);\n\n\twhile (SHashNext(&hIterator, &nRequestId, (void **)&pRequest)) {\n\n\t\tif (pRequest) {\n\n\t\t\tif (pRequest->pQuery) {\n\n\t\t\t\tpRequest->pQuery->bStop = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}", "CodeBleu_score": 35.13158688196519}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t    int i;\n    TRequest *pRequest;\n    TQuery *pQuery;\n\n    if (pRequests == NULL) {\n        return;\n    }\n\n    for (i = 0; i < pRequests->size; i++) {\n        pRequest = (TRequest *) pRequests->buckets[i];\n        while (pRequest != NULL) {\n            if (pRequest->requestId != -1) {\n                pQuery = pRequest->pQuery;\n                if (pQuery != NULL) {\n                    stopQuery(pQuery);\n                }\n            }\n            pRequest = pRequest->pNext;\n        }\n    }\n}", "CodeBleu_score": 38.86698451756326}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t    int i;\n    char *pRequestId;\n    Request *pRequest;\n\n    if (pRequests == NULL)\n        return;\n\n    for (i = 0; i < pRequests->size; i++) {\n        pRequestId = (char *)pRequests->array[i].key;\n        if (pRequestId == NULL)\n            continue;\n\n        pRequest = (Request *)pRequests->array[i].value;\n        if (pRequest == NULL)\n            continue;\n\n        if (pRequest->valid == true) {\n            if (pRequest->query != NULL) {\n                stopQuery(pRequest->query);\n            }\n        }\n\n        releaseRequest(pRequest);\n    }\n}", "CodeBleu_score": 38.369182507175324}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t  if (!g_crashReporting) {\n    return;\n  }\n\n  if (!__sync_bool_compare_and_swap(&g_clientStop, 0, 1)) {\n    tlog(TLOG_WARN, \"crash report thread already stopped\n\");\n    return;\n  }\n\n  while (g_clientStop) {\n    osSleep(1000);\n  }\n}", "CodeBleu_score": 53.642061713450886}, {"code": "void tscStopCrashReport(){\n\t  if (tcrashReportEnabled) {\n    if (!__sync_bool_compare_and_swap(&clientStop, 0, 1)) {\n      tlog(LOG_WARNING, \"Crash report thread is already stopped\");\n      return;\n    }\n    while (clientStop) {\n      osSleep(1000);\n    }\n  }\n}", "CodeBleu_score": 50.76755420366166}, {"code": "void tscStopCrashReport(){\n\t\n  if (g_crashReportingEnabled) {\n\n    if (!TAtomicCompareAndSwap32(&g_clientStop, 0, 1)) {\n\n      tlog(TLOG_WARN, \"Crash report thread is already stopped, not attempting to stop it again.\n\");\n\n      return;\n\n    }\n\n    tlog(TLOG_INFO, \"Stopping crash report thread.\n\");\n\n    while (TAtomicGet32(&g_clientStop) == 1) {\n\n      tsleep(100000);\n\n    }\n\n    tlog(TLOG_INFO, \"Crash report thread has stopped.\n\");\n\n  }\n\n}", "CodeBleu_score": 52.86190349545501}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\n\tint32_t i;\n\tint32_t j;\n\tint32_t rc;\n\tint32_t numViews;\n\tint32_t numCols;\n\tint32_t numColsInView;\n\tint32_t numColsInCatalog;\n\tint32_t numColsInResponse;\n\tint32_t numColsInCatalogArray;\n\tint32_t numColsInResponseArray;\n\tint32_t numColsInCatalogArrayElement;\n\tint32_t numColsInResponseArrayElement;\n\tint32_t numColsInCatalogArrayElementArray;\n\tint32_t numColsInResponseArrayElementArray;\n\tint32_t numColsInCatalogArrayElementArrayElement;\n\tint32_t numColsInResponseArrayElementArrayElement;\n\tint32_t numColsInCatalogArrayElementArrayElementArray;\n\tint32_t numColsInResponseArrayElementArrayElementArray;\n\tint32_t numColsInCatalogArrayElementArrayElementArrayElement;\n\tint32_t numColsInResponseArrayElementArrayElementArrayElement;\n\tint32_t numColsInCatalogArrayElementArrayElementArrayElementArray;\n\tint32_t numColsInResponseArrayElementArrayElementArrayElementArray;\n\tint32_t numColsInCatalogArrayElementArrayElementArrayElementArrayElement;\n\tint32_t numColsInResponseArrayElementArrayElementArrayElementArrayElement;\n\tint32_t numColsInCatalogArrayElementArrayElementArrayElementArrayElementArray;\n\tint32_t numColsInResponseArrayElementArrayElementArrayElementArrayElementArray;\n\tint32_t numColsInCatalogArrayElementArrayElementArrayElementArrayElementArrayElement;\n\tint32_t numColsInResponseArrayElementArrayElementArrayElementArrayElementArrayElement;\n\tint32_t numColsInCatalogArrayElementArrayElementArrayElementArrayElementArrayElementArray;\n\tint32_t numColsInResponseArrayElementArrayElementArrayElement", "CodeBleu_score": 6.39967729177121}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tstruct HbViewInfoRsp *pRsp = NULL;\n\tstruct HbViewInfo *pViewInfo = NULL;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t viewId = 0;\n\tint32_t viewColCount = 0;\n\tint32_t viewColCountOld = 0;\n\tint32_t viewColCountNew = 0;\n\tint32_t viewColCountDiff = 0;\n\tint32_t viewColCountDiffAbs = 0;\n\tint32_t viewColCountDiffSign = 0;\n\tint32_t viewColCountDiffSignOld = 0;\n\tint32_t viewColCountDiffSignNew = 0;\n\tint32_t viewColCountDiffSignAbs = 0;\n\tint32_t viewColCountDiffSignAbsOld = 0;\n\tint32_t viewColCountDiffSignAbsNew = 0;\n\tint32_t viewColCountDiffSignAbsMax = 0;\n\tint32_t viewColCountDiffSignAbsMaxOld = 0;\n\tint32_t viewColCountDiffSignAbsMaxNew = 0;\n\tint32_t viewColCountDiffAbsMax = 0;\n\tint32_t viewColCountDiffAbsMaxOld = 0;\n\tint32_t viewColCountDiffAbsMaxNew = 0;\n\tint32_t viewColCountDiffAbsMaxMin = 0;\n\tint32_t viewColCountDiffAbsMaxMinOld = 0;\n\tint32_t viewColCountDiffAbsMaxMinNew = 0;\n\tint32_t viewColCountDiffAbsMaxMinSign = 0;\n\tint32_t viewColCountDiffAbsMaxMinSignOld = 0;\n\tint32_t viewColCountDiffAbsMaxMinSignNew = 0;\n\tint32_t viewColCountDiffAbsMaxMinSignAbs = 0;\n\tint32_", "CodeBleu_score": 8.71592483773253}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t i, j;\n\tint32_t numViews;\n\tstruct SViewInfo *viewInfo;\n\tstruct SViewInfo *viewInfoArray;\n\tstruct SViewInfo *viewInfoTemp;\n\tstruct SViewInfo *viewInfoTemp2;\n\tstruct SViewInfo *viewInfoTemp3;\n\tstruct SViewInfo *viewInfoTemp4;\n\tstruct SViewInfo *viewInfoTemp5;\n\tstruct SViewInfo *viewInfoTemp6;\n\tstruct SViewInfo *viewInfoTemp7;\n\tstruct SViewInfo *viewInfoTemp8;\n\tstruct SViewInfo *viewInfoTemp9;\n\tstruct SViewInfo *viewInfoTemp10;\n\tstruct SViewInfo *viewInfoTemp11;\n\tstruct SViewInfo *viewInfoTemp12;\n\tstruct SViewInfo *viewInfoTemp13;\n\tstruct SViewInfo *viewInfoTemp14;\n\tstruct SViewInfo *viewInfoTemp15;\n\tstruct SViewInfo *viewInfoTemp16;\n\tstruct SViewInfo *viewInfoTemp17;\n\tstruct SViewInfo *viewInfoTemp18;\n\tstruct SViewInfo *viewInfoTemp19;\n\tstruct SViewInfo *viewInfoTemp20;\n\tstruct SViewInfo *viewInfoTemp21;\n\tstruct SViewInfo *viewInfoTemp22;\n\tstruct SViewInfo *viewInfoTemp23;\n\tstruct SViewInfo *viewInfoTemp24;\n\tstruct SViewInfo *viewInfoTemp25;\n\tstruct SViewInfo *viewInfoTemp26;\n\tstruct SViewInfo *viewInfoTemp27;\n\tstruct SViewInfo *viewInfoTemp28;\n\tstruct SViewInfo *viewInfoTemp29;\n\tstruct SViewInfo *viewInfoTemp30;\n\tstruct SViewInfo *viewInfoTemp31;\n\tstruct SViewInfo *viewInfoTemp32;\n\tstruct SViewInfo *viewInfoTemp33;\n\tstruct SViewInfo *viewInfoTemp34;\n\tstruct SViewInfo *viewInfoTemp35;\n\tstruct SViewInfo *viewInfoTemp36;\n\tstruct SViewInfo *viewInfoTemp37;", "CodeBleu_score": 6.454577363190768}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3CpResponsePropertiesCallbackData *data = (S3CpResponsePropertiesCallbackData *)callbackData;\n    S3Status status = S3StatusOK;\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 70.2358420879412}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3CpResponsePropertiesCallbackData *data = (S3CpResponsePropertiesCallbackData *) callbackData;\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    }\n    else {\n        data->contentLength = 0;\n    }\n    return S3StatusOK;\n}", "CodeBleu_score": 74.82486078755241}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\n    S3CpCallbackData *data = (S3CpCallbackData *) callbackData;\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    }\n    else {\n        data->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 77.04589046930874}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tchar *checkpointBackupDir = getenv(\"CHECKPOINT_BACKUP_DIR\");\n\tchar *rsyncPort = getenv(\"RSYNC_PORT\");\n\tchar *rsyncConfigFile = getenv(\"RSYNC_CONFIG_FILE\");\n\tchar *rsyncLogFile = getenv(\"RSYNC_LOG_FILE\");\n\tchar *rsyncLogLevel = getenv(\"RSYNC_LOG_LEVEL\");\n\tchar *rsyncLogFormat = getenv(\"RSYNC_LOG_FORMAT\");\n\tchar *rsyncDaemon = getenv(\"RSYNC_DAEMON\");\n\tchar *rsyncDaemonOptions = getenv(\"RSYNC_DAEMON_OPTIONS\");\n\n\tif (checkpointBackupDir == NULL) {\n\t\tlogError(\"CHECKPOINT_BACKUP_DIR environment variable not set\");\n\t\treturn;\n\t}\n\n\tif (rsyncPort == NULL) {\n\t\tlogError(\"RSYNC_PORT environment variable not set\");\n\t\treturn;\n\t}\n\n\tif (rsyncConfigFile == NULL) {\n\t\tlogError(\"RSYNC_CONFIG_FILE environment variable not set\");\n\t\treturn;\n\t}\n\n\tif (rsyncLogFile == NULL) {\n\t\tlogError(\"RSYNC_LOG_FILE environment variable not set\");\n\t\treturn;\n\t}\n\n\tif (rsyncLogLevel == NULL) {\n\t\tlogError(\"RSYNC_LOG_LEVEL environment variable not set\");\n\t\treturn;\n\t}\n\n\tif (rsyncLogFormat == NULL) {\n\t\tlogError(\"RSYNC_LOG_FORMAT environment variable not set\");\n\t\treturn;\n\t}\n\n\tif (rsyncDaemon == NULL) {\n\t\tlogError(\"RSYNC_DAEMON environment variable not set\");\n\t\treturn;\n\t}\n\n\tif (rsyncDaemonOptions == NULL) {\n\t\tlogError(\"RSYNC_DAEMON_OPTIONS environment variable not set\");\n\t\treturn;\n\t}\n\n\tif (mkdir(checkpointBackupDir, 0700) != 0", "CodeBleu_score": 11.959571023463116}, {"code": "void startRsync(){\n\t\tchar *rsyncConfigFile = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncConfigFilePath = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncCommand = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncPort = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncDirectory = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncDirectoryPath = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogFile = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogFilePath = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectory = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath2 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath3 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath4 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath5 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath6 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath7 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath8 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath9 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath10 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath11 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath12 = (char*)malloc(sizeof(char)*100);\n\tchar *rsyncLogDirectoryPath13 = (char*)malloc(sizeof(char)*100);\n", "CodeBleu_score": 2.872003000754923}, {"code": "void startRsync(){\n\t\tchar cmd[1024];\n\tchar cmd2[1024];\n\tchar *args[4];\n\tchar *args2[4];\n\tchar *port = \"873\";\n\tchar *configFile = \"rsync.conf\";\n\tchar *rsyncPath = \"rsync\";\n\tchar *rsyncPath2 = \"rsync\";\n\tchar *rsyncPath3 = \"rsync\";\n\tchar *rsyncPath4 = \"rsync\";\n\tchar *rsyncPath5 = \"rsync\";\n\tchar *rsyncPath6 = \"rsync\";\n\tchar *rsyncPath7 = \"rsync\";\n\tchar *rsyncPath8 = \"rsync\";\n\tchar *rsyncPath9 = \"rsync\";\n\tchar *rsyncPath10 = \"rsync\";\n\tchar *rsyncPath11 = \"rsync\";\n\tchar *rsyncPath12 = \"rsync\";\n\tchar *rsyncPath13 = \"rsync\";\n\tchar *rsyncPath14 = \"rsync\";\n\tchar *rsyncPath15 = \"rsync\";\n\tchar *rsyncPath16 = \"rsync\";\n\tchar *rsyncPath17 = \"rsync\";\n\tchar *rsyncPath18 = \"rsync\";\n\tchar *rsyncPath19 = \"rsync\";\n\tchar *rsyncPath20 = \"rsync\";\n\tchar *rsyncPath21 = \"rsync\";\n\tchar *rsyncPath22 = \"rsync\";\n\tchar *rsyncPath23 = \"rsync\";\n\tchar *rsyncPath24 = \"rsync\";\n\tchar *rsyncPath25 = \"rsync\";\n\tchar *rsyncPath26 = \"rsync\";\n\tchar *rsyncPath27 = \"rsync\";\n\tchar *rsyncPath28 = \"rsync\";\n\tchar *rsyncPath29 = \"rsync\";\n\tchar *rsyncPath30 = \"rsync\";\n\tchar *rsyncPath31 = \"rsync\";\n\tchar *rsyncPath32 = \"rsync\";\n\tchar *rsyncPath33 = \"rsync", "CodeBleu_score": 4.973580129863055}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n}", "CodeBleu_score": 91.45110903459917}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n    dispatcher.destroy();\n}", "CodeBleu_score": 72.99390938064239}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.destroy();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n}", "CodeBleu_score": 80.25260842399479}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    Lock lock = childrenLocks.get(parent);\n    lock.lock();\n    try {\n        Set<TbActorId> children = childrenMap.get(parent);\n        if (children != null) {\n            List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n            if (highPriority) {\n                for (TbActorId child : filteredChildren) {\n                    highPriorityExecutor.submit(() -> {\n                        TbActorRef childRef = getOrCreateChild(child);\n                        childRef.tell(msg);\n                    });\n                }\n            } else {\n                for (TbActorId child : filteredChildren) {\n                    TbActorRef childRef = getOrCreateChild(child);\n                    childRef.tell(msg);\n                }\n            }\n        } else {\n            log.warn(\"[{}] Failed to broadcast message to children: {}\", parent, msg);\n        }\n    } finally {\n        lock.unlock();\n    }\n}", "CodeBleu_score": 47.84757492226605}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Lock lock = childrenLocks.computeIfAbsent(parent, id -> new ReentrantLock());\n        lock.lock();\n        try {\n            Set<TbActorId> children = children.get(parent);\n            if (children != null) {\n                List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n                if (highPriority) {\n                    filteredChildren.forEach(child -> highPriorityMsgProcessor.addMsg(child, msg));\n                } else {\n                    filteredChildren.forEach(child -> msgProcessor.addMsg(child, msg));\n                }\n            } else {\n                log.warn(\"[{}] Failed to find children of parent actor: {}\", parent, msg);\n            }\n        } finally {\n            lock.unlock();\n        }\n    }", "CodeBleu_score": 44.73354758967721}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Lock lock = childActors.get(parent);\n        if (lock != null) {\n            lock.lock();\n            try {\n                List<TbActorId> children = childActors.get(parent).stream().filter(childFilter).collect(Collectors.toList());\n                if (children.size() > 0) {\n                    if (highPriority) {\n                        children.forEach(child -> sendToChild(parent, child, msg));\n                    } else {\n                        children.forEach(child -> sendToChild(parent, child, msg));\n                    }\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n    }", "CodeBleu_score": 44.89399471482761}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (isDestroying()) {\n        if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (highPriority) {\n                if (reinitialize()) {\n                    log.info(\"[{}] Reinitialized actor.\", getName());\n                } else {\n                    log.info(\"[{}] Failed to reinitialize actor.\", getName());\n                }\n            } else {\n                msg.onFailure(new TbActorError(TbActorError.Type.ACTOR_TERMINATED, \"Actor is being terminated!\"));\n            }\n        } else {\n            msg.onFailure(new TbActorError(TbActorError.Type.ACTOR_TERMINATED, \"Actor is being terminated!\"));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    }\n}", "CodeBleu_score": 52.932587756082626}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    processQueue();\n}", "CodeBleu_score": 27.358847044772638}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (destroyed) {\n        if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (reinit) {\n                try {\n                    init();\n                    log.info(\"[{}] Reinitialized actor after failure.\", id);\n                } catch (Exception e) {\n                    log.warn(\"[{}] Failed to reinitialize actor after failure.\", id, e);\n                }\n            } else {\n                msg.getCallback().onFailure(new TbActorError(TbActorError.Type.ACTOR_TERMINATED, \"Actor is terminated!\"));\n            }\n        } else {\n            msg.getCallback().onFailure(new TbActorError(TbActorError.Type.ACTOR_TERMINATED, \"Actor is terminated!\"));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        if (highPriority && !isProcessing.get()) {\n            processQueue();\n        }\n    }\n}", "CodeBleu_score": 58.166385595514484}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    if (isStopped()) {\n        return;\n    }\n    if (isInitialized()) {\n        if (isActive()) {\n            long startTime = System.currentTimeMillis();\n            int processed = processHighPriorityMailbox();\n            if (processed < highPriorityMailboxSize) {\n                processed += processNormalPriorityMailbox();\n            }\n            long endTime = System.currentTimeMillis();\n            long elapsed = endTime - startTime;\n            if (elapsed < 1) {\n                try {\n                    Thread.sleep(1 - elapsed);\n                } catch (InterruptedException e) {\n                    log.trace(\"[{}] Interrupted during sleep\", getActorId());\n                }\n            }\n            if (processed > 0) {\n                log.trace(\"[{}] Processed {} messages in {} ms\", getActorId(), processed, elapsed);\n            }\n        }\n    }\n    scheduleProcessing();\n}", "CodeBleu_score": 24.268674226116325}, {"code": "private void processMailbox(){\n\t    int msgCount = 0;\n    int msgSize = 0;\n    long startTime = System.currentTimeMillis();\n    long startProcessingTime = startTime;\n    long startProcessingTimeNanos = System.nanoTime();\n    long lastProcessingTime = startTime;\n    long lastProcessingTimeNanos = startProcessingTimeNanos;\n    while (msgCount < maxMsgPerSec && msgSize < maxMsgSizePerSec) {\n        if (highPriorityMailbox.isEmpty() && normalPriorityMailbox.isEmpty()) {\n            if (status != ActorStatus.FREE) {\n                status = ActorStatus.FREE;\n                if (log.isTraceEnabled()) {\n                    log.trace(\"[{}] Processing mailbox is empty. Set actor to free\", getActorId());\n                }\n            }\n            if (processing) {\n                processing = false;\n                if (log.isTraceEnabled()) {\n                    log.trace(\"[{}] Processing mailbox is empty. Set actor to free\", getActorId());\n                }\n            }\n            if (log.isTraceEnabled()) {\n                log.trace(\"[{}] Processing mailbox is empty. Set actor to free\", getActorId());\n            }\n            long processingTime = System.currentTimeMillis() - startProcessingTime;\n            long processingTimeNanos = System.nanoTime() - startProcessingTimeNanos;\n            if (processingTime > 0 || processingTimeNanos > 0) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"[{}] Processing mailbox is empty. Set actor to free. Processing time: {} ms, {} ns\", getActorId(), processingTime, processingTimeNanos);\n                }\n            }\n            long lastProcessingTimeDelta = System.currentTimeMillis() - lastProcessingTime;\n            long lastProcessingTimeDeltaNanos = System.nanoTime() - lastProcessingTimeNanos;\n            if (lastProcessingTimeDelta > 0 || lastProcessingTimeDeltaNanos > 0) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"[{}] Processing mailbox is empty.", "CodeBleu_score": 23.93400585727008}, {"code": "private void processMailbox(){\n\t    try {\n        while (true) {\n            if (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n                if (stopped) {\n                    log.debug(\"[{}] Actor stopped\", getName());\n                    break;\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"[{}] Actor is free\", getName());\n                    }\n                    if (mailboxProcessor != null) {\n                        mailboxProcessor.onFree();\n                    }\n                    if (mailboxProcessor != null) {\n                        mailboxProcessor.onIdle();\n                    }\n                    if (idleStrategy.idle(getContext().getDispatcher())) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"[{}] Actor is idle\", getName());\n                        }\n                        if (mailboxProcessor != null) {\n                            mailboxProcessor.onIdle();\n                        }\n                        if (idleStrategy.idle(getContext().getDispatcher())) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"[{}] Actor is blocked\", getName());\n                            }\n                            if (mailboxProcessor != null) {\n                                mailboxProcessor.onBlocked();\n                            }\n                            if (blockedStrategy.blocked(getContext().getDispatcher())) {\n                                if (log.isDebugEnabled()) {\n                                    log.debug(\"[{}] Actor is stopped\", getName());\n                                }\n                                if (mailboxProcessor != null) {\n                                    mailboxProcessor.onStopped();\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"[{}] Actor is busy\", getName());\n                }\n                if (mailboxProcessor != null) {\n                    mailboxProcessor.onBusy();\n                }\n                if (idleStrategy.idle(getContext().getDispatcher())) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"[{}] Actor is", "CodeBleu_score": 21.099803820594374}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (stopReason.compareAndSet(null, TbActorStopReason.DESTROYED)) {\n        log.debug(\"[{}] Stopping actor due to: {}\", getActorId(), cause.getMessage());\n        try {\n            if (destroyFunction != null) {\n                destroyFunction.accept(cause);\n            }\n        } catch (Exception e) {\n            log.warn(\"[{}] Failed to destroy actor due to: {}\", getActorId(), e.getMessage());\n        }\n    }\n}", "CodeBleu_score": 30.14832757582564}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason.compareAndSet(null, TbActorStopReason.DESTROY)) {\n        log.info(\"[{}] Destroying actor\", getActorId());\n        dispatcher.schedule(() -> {\n            try {\n                if (isReady()) {\n                    setReady(false);\n                    log.trace(\"[{}] Actor is ready\", getActorId());\n                }\n                if (destroy() != null) {\n                    log.trace(\"[{}] Actor is destroyed\", getActorId());\n                }\n                if (isReady()) {\n                    log.trace(\"[{}] Actor is ready\", getActorId());\n                }\n                if (stopReason.get() == TbActorStopReason.DESTROY) {\n                    stopReason.set(TbActorStopReason.DESTROYED);\n                    log.trace(\"[{}] Actor is destroyed\", getActorId());\n                }\n            } catch (Throwable e) {\n                log.warn(\"[{}] Failed to destroy actor\", getActorId(), e);\n            }\n            if (stopReason.get() == TbActorStopReason.DESTROY) {\n                stopReason.set(TbActorStopReason.DESTROYED);\n            }\n            if (cause != null) {\n                log.warn(\"[{}] Actor destroyed with cause\", getActorId(), cause);\n            }\n            if (!messages.isEmpty()) {\n                log.warn(\"[{}] Actor destroyed with {} messages in queue\", getActorId(), messages.size());\n            }\n        }, 0, TimeUnit.MILLISECONDS);\n    }\n}", "CodeBleu_score": 39.980175120327516}, {"code": "public void destroy(Throwable cause){\n\t    destroy(TbActorStopReason.INTERNAL_ERROR, cause);\n}", "CodeBleu_score": 5.19143567073113}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.isNullUid()) {\n        return true;\n    }\n    if (tenantId.getId().equals(ModelConstants.NULL_UUID)) {\n        return true;\n    }\n    if (tenantId.getId().equals(ModelConstants.SYSTEM_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId.getId(), key -> {\n        try {\n            return tenantProfileService.findTenantProfileById(tenantId, false);\n        } catch (Exception e) {\n            if (ignoreTenantNotFound) {\n                log.trace(\"[{}] Failed to find tenant profile.\", tenantId, e);\n                return null;\n            } else {\n                throw new TenantProfileNotFoundException(tenantId);\n            }\n        }\n    });\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            log.trace(\"[{}] Failed to find tenant profile.\", tenantId);\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitsTrigger trigger = new RateLimitsTrigger(tenantId, level);\n    TbRateLimits limits = tenantProfile.getProfileData().getRateLimits();\n    if (limits == null) {\n        return true;\n    }\n    return limits.checkRateLimit(api, trigger);\n}", "CodeBleu_score": 52.91814096427745}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.isNullUid()) {\n        return true;\n    }\n    if (tenantId.getId().equals(ModelConstants.NULL_UUID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getTenantProfile(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    RateLimitsTrigger trigger = new RateLimitsTrigger();\n    trigger.setTenantId(tenantId);\n    trigger.setApi(api);\n    trigger.setLevel(level);\n    trigger.setTenantProfileId(tenantProfile.getId());\n    trigger.setTenantProfileName(tenantProfile.getName());\n    return rateLimitProcessor.checkRateLimit(trigger);\n}", "CodeBleu_score": 37.50726486184676}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.isSystem()) {\n        return true;\n    }\n    TenantProfile tenantProfile = getTenantProfile(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    RateLimitsTrigger rateLimitsTrigger = new RateLimitsTrigger(api, tenantId, level);\n    TbRateLimits rateLimits = tenantProfile.getRateLimits();\n    if (rateLimits == null) {\n        return true;\n    }\n    if (rateLimits.checkLimit(rateLimitsTrigger)) {\n        if (rateLimitsTrigger.isTriggered()) {\n            notificationRuleProcessor.process(rateLimitsTrigger);\n        }\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 42.617678061898026}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\t\tlong now = System.currentTimeMillis();\n\t\tlong expirationTime = now - inactivityTimeout;\n\t\tfor (ConcurrentMap.Entry<InetSocketAddress, DtlsSession> entry : sessions.entrySet()) {\n\t\t\tDtlsSession session = entry.getValue();\n\t\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\t\tlog.debug(\"Removing DTLS session for {}\", entry.getKey());\n\t\t\t\tsessions.remove(entry.getKey());\n\t\t\t}\n\t\t}\n\t}", "CodeBleu_score": 38.26016037921388}, {"code": "public void evictTimeoutSessions(){\n\t    long now = System.currentTimeMillis();\n    long expiration = now - dtlsSessionTimeout;\n    for (ConcurrentMap.Entry<InetSocketAddress, DtlsSession> entry : sessions.entrySet()) {\n        DtlsSession session = entry.getValue();\n        if (session.getLastActivityTime() < expiration) {\n            log.info(\"Evicting session {}\", session.getPeerAddress());\n            sessions.remove(session.getPeerAddress());\n        }\n    }\n}", "CodeBleu_score": 39.46952240471761}, {"code": "public void evictTimeoutSessions(){\n\t    long now = System.currentTimeMillis();\n    long expirationTime = now - inactivityTimeout;\n    log.debug(\"Evicting sessions older than {}\", expirationTime);\n    for (ConcurrentMap.Entry<InetSocketAddress, DtlsSession> entry : sessions.entrySet()) {\n        DtlsSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            log.debug(\"Evicting session {}\", session);\n            removeSession(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 39.46813822914139}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> entries = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        for (JsonNode value : entry.getValue()) {\n            entries.add(new BasicTsKvEntry(value.get(\"t\").asLong(), parseValue(entry.getKey(), value.get(\"v\"))));\n        }\n    }\n    return entries;\n}", "CodeBleu_score": 38.88806322848237}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!CollectionUtils.isEmpty(timeseries)) {\n        return timeseries.entrySet().stream().flatMap(entry -> {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            return values.stream().map(value -> {\n                long ts = value.get(\"ts\").asLong();\n                String strValue = value.get(\"value\").asText();\n                switch (value.get(\"type\").asText()) {\n                    case \"boolean\":\n                        return new BasicTsKvEntry(ts, new BooleanDataEntry(key, strValue.equals(\"true\")));\n                    case \"double\":\n                        return new BasicTsKvEntry(ts, new DoubleDataEntry(key, Double.valueOf(strValue)));\n                    case \"long\":\n                        return new BasicTsKvEntry(ts, new LongDataEntry(key, Long.valueOf(strValue)));\n                    case \"string\":\n                        return new BasicTsKvEntry(ts, new StringDataEntry(key, strValue));\n                    case \"json\":\n                        return new BasicTsKvEntry(ts, new JsonDataEntry(key, strValue));\n                    default:\n                        throw new RuntimeException(\"Unknown data type: \" + value.get(\"type\").asText());\n                }\n            });\n        }).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 44.87682829807203}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (CollectionUtils.isEmpty(timeseries)) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> ts = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        List<TsKvEntry> list = entry.getValue().stream().map(jsonNode -> {\n            try {\n                return parseTsKvEntry(entry.getKey(), jsonNode);\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to parse timeseries data!\", e);\n            }\n        }).collect(Collectors.toList());\n        ts.addAll(list);\n    }\n    return ts;\n}", "CodeBleu_score": 46.33641743480217}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refresh_token\", refreshToken);\n    requestMap.put(\"grant_type\", \"refresh_token\");\n    requestMap.put(\"client_id\", clientId);\n    requestMap.put(\"client_secret\", clientSecret);\n    requestMap.put(\"scope\", \"read write\");\n    requestMap.put(\"username\", username);\n    requestMap.put(\"password\", password);\n    String requestBody = getRequestBody(requestMap);\n    HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n    HttpEntity<String> request = new HttpEntity<>(requestBody, headers);\n    String response = restTemplate.postForObject(authUrl, request, String.class);\n    if (!response.contains(\"error\")) {\n        JsonNode jsonNode = mapper.readTree(response);\n        accessToken = jsonNode.get(\"access_token\").asText();\n        refreshToken = jsonNode.get(\"refresh_token\").asText();\n        expirationTime = jsonNode.get(\"expires_in\").asLong();\n        tokenExpirationTime = System.currentTimeMillis() + expirationTime * 1000;\n    }\n}", "CodeBleu_score": 42.71425282076097}, {"code": "public void refreshToken(){\n\t    // TODO: Implement function\n}", "CodeBleu_score": 1.6078250809239212}, {"code": "public void refreshToken(){\n\t    String refreshToken = getRefreshToken();\n    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"grant_type\", \"refresh_token\");\n    requestMap.put(\"refresh_token\", refreshToken);\n    requestMap.put(\"client_id\", clientId);\n    requestMap.put(\"client_secret\", clientSecret);\n    requestMap.put(\"scope\", \"read write\");\n    String responseBody = httpRequest(tokenUrl, \"POST\", requestMap, null, null);\n    JsonNode response = mapper.readTree(responseBody);\n    JsonNode accessTokenNode = response.get(\"access_token\");\n    if (accessTokenNode != null) {\n        String accessToken = accessTokenNode.textValue();\n        JsonNode expiresInNode = response.get(\"expires_in\");\n        if (expiresInNode != null) {\n            int expiresIn = expiresInNode.intValue();\n            long expirationTime = System.currentTimeMillis() + expiresIn * 1000;\n            setAccessToken(accessToken, expirationTime);\n        }\n    }\n}", "CodeBleu_score": 40.7973446250381}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        headers.setBearerAuth(token);\n        HttpEntity<String> request = new HttpEntity<>(headers);\n        ResponseEntity<JwtToken> response = restTemplate.exchange(URL, HttpMethod.GET, request, JwtToken.class);\n        token = response.getBody().getToken();\n        refreshToken = response.getBody().getRefreshToken();\n        tokenExpirationTime = System.currentTimeMillis() + response.getBody().getExpiresIn() * 1000;\n    }", "CodeBleu_score": 33.31063176487412}, {"code": " private void doLogin(){\n\t        try {\n            HttpHeaders headers = new HttpHeaders();\n            headers.setContentType(MediaType.APPLICATION_JSON);\n            headers.setBasicAuth(username, password);\n            HttpEntity<String> request = new HttpEntity<>(headers);\n            RestTemplate restTemplate = new RestTemplate();\n            ResponseEntity<String> response = restTemplate.exchange(\n                    \"http://localhost:8080/api/auth/login\", HttpMethod.POST, request, String.class);\n            String token = JacksonUtil.fromString(response.getBody(), JsonNode.class).get(\"token\").asText();\n            this.token = token;\n            this.tokenExpirationTime = System.currentTimeMillis() + 3600000;\n        } catch (Exception e) {\n            System.out.println(\"Unable to login\");\n        }\n    }", "CodeBleu_score": 33.213931095120294}, {"code": " private void doLogin(){\n\t    String url = \"https://api.thingsboard.io/api/auth/login\";\n    Map<String, String> params = new HashMap<>();\n    params.put(\"username\", \"YOUR_USERNAME\");\n    params.put(\"password\", \"YOUR_PASSWORD\");\n    String response = HttpUtils.doPost(url, params);\n    System.out.println(response);\n }", "CodeBleu_score": 31.986385550347457}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    return Optional.ofNullable(getDeviceByIdAsync(deviceId).get());\n}", "CodeBleu_score": 7.047690038310879}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        return Optional.ofNullable(restTemplate.getForObject(DEVICE_URL + \"/{deviceId}\", Device.class, deviceId.getId()));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 50.541790236614425}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> responseEntity = restTemplate.getForEntity(buildUrl(DEVICE_BY_ID_URL, deviceId.getId()), Device.class);\n        return Optional.ofNullable(responseEntity.getBody());\n    } catch (HttpClientErrorException exception) {\n        if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw exception;\n        }\n    }\n}", "CodeBleu_score": 80.54816351751208}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    return saveDeviceWithCredentials(new SaveDeviceWithCredentialsRequest(device, credentials));\n}", "CodeBleu_score": 11.02125294824718}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest();\n        request.setDevice(device);\n        request.setDeviceCredentials(credentials);\n        return Optional.of(restTemplate.postForObject(BASE_URL + \"/api/device-with-credentials\", request, Device.class));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 56.279518334919906}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest(device, credentials);\n        return Optional.of(restTemplate.postForObject(\"/api/device-with-credentials\", request, Device.class));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 60.51959064770621}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t    if (arguments.length == 1) {\n        val = addr;\n        addr = null;\n    }\n    if (addr == null) {\n        this.devices.forEach(function (device) {\n            device.brightness(val);\n        });\n    } else {\n        this.devices.forEach(function (device) {\n            if (device.address == addr) {\n                device.brightness(val);\n            }\n        });\n    }\n    return this;\n}", "CodeBleu_score": 55.689020764225205}, {"code": "brightness(addr, val){\n\t    var brightness = function (addr, val) {\n        if (arguments.length === 1) {\n            for (var i = 0; i < this.devices.length; i++) {\n                this.devices[i].brightness(val);\n            }\n        } else if (arguments.length === 2) {\n            this.devices[addr].brightness(val);\n        } else {\n            throw \"Invalid number of arguments\";\n        }\n        return this;\n    };\n    return brightness.apply(this, arguments);\n}", "CodeBleu_score": 42.299506357623564}, {"code": "brightness(addr, val){\n\t  if (arguments.length === 1) {\n    this.devices.forEach(function(device) {\n      device.brightness(val);\n    });\n  } else if (arguments.length === 2) {\n    this.devices.forEach(function(device) {\n      if (device.address === addr) {\n        device.brightness(val);\n      }\n    });\n  } else {\n    throw new Error('Invalid number of arguments');\n  }\n  return this;\n}", "CodeBleu_score": 55.44967296258563}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    const self = this;\n    const obj = {};\n    for (const key in self) {\n        if (typeof self[key] === 'function') {\n            obj[key] = self[key].bind(self, addr);\n        }\n    }\n    return obj;\n}", "CodeBleu_score": 27.44798163604132}, {"code": "device(addr){\n\t  var obj = {};\n  for (var key in LedControl.prototype) {\n    if (LedControl.prototype.hasOwnProperty(key)) {\n      obj[key] = LedControl.prototype[key].bind(this, addr);\n    }\n  }\n  return obj;\n}", "CodeBleu_score": 27.644281899340623}, {"code": "device(addr){\n\t  let self = this;\n  let methods = Object.getOwnPropertyNames(Object.getPrototypeOf(self));\n  let device = {};\n\n  methods.forEach(method => {\n    if (typeof self[method] === 'function') {\n      device[method] = self[method].bind(self, addr);\n    }\n  });\n\n  return device;\n}", "CodeBleu_score": 31.27051220004794}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = (...args) => {\n            const duration = args[args.length - 1];\n            const callback = args[args.length - 2];\n            const promises = [];\n            const collection = this;\n            this.forEach(element => {\n                promises.push(new Promise(resolve => {\n                    const methodCall = element[method](...args);\n                    if (methodCall instanceof Promise) {\n                        methodCall.then(resolve);\n                    } else {\n                        resolve();\n                    }\n                }));\n            });\n            if (typeof callback === \"function\") {\n                Promise.all(promises).then(() => {\n                    callback();\n                });\n            }\n            return this;\n        };\n    });\n}", "CodeBleu_score": 39.54783822247325}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        if (target[method] === undefined) {\n            throw new Error(`The method \"${method}\" does not exist on the target object.`);\n        }\n        target[`${method}Async`] = (...args) => {\n            if (args.length === 0) {\n                throw new Error(`The method \"${method}\" requires at least one argument.`);\n            }\n            if (args.length === 1 && args[0] instanceof Array) {\n                return target[method](...args[0]);\n            }\n            if (args.length === 2 && args[0] instanceof Array && typeof args[1] === \"number\") {\n                return target[method](...args[0], args[1]);\n            }\n            if (args.length === 3 && args[0] instanceof Array && typeof args[1] === \"number\" && typeof args[2] === \"function\") {\n                return target[method](...args[0], args[1], args[2]);\n            }\n            throw new Error(`The method \"${method}\" requires one, two or three arguments.`);\n        };\n        target[`${method}AsyncCallback`] = (...args) => {\n            if (args.length === 0) {\n                throw new Error(`The method \"${method}\" requires at least one argument.`);\n            }\n            if (args.length === 1 && args[0] instanceof Array) {\n                return target[method](...args[0]);\n            }\n            if (args.length === 2 && args[0] instanceof Array && typeof args[1] === \"number\") {\n                return target[method](...args[0], args[1]);\n            }\n            if (args.length === 3 && args[0] instanceof Array && typeof args[1] === \"number\" && typeof args[2] === \"function\") {\n                return target[method](...args[0], args[1], args[2]);\n            }\n            throw new Error(`The method \"${method}\" requires one, two or three arguments.`);\n        };\n    });\n}", "CodeBleu_score": 20.528369021560422}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = function(duration, callback) {\n            if (duration === undefined) duration = 1000;\n            if (callback === undefined) callback = function() {};\n            if (typeof duration !== 'number') throw new TypeError('duration must be a number');\n            if (typeof callback !== 'function') throw new TypeError('callback must be a function');\n            const promises = [];\n            this.forEach(element => {\n                promises.push(new Promise((resolve, reject) => {\n                    setTimeout(() => {\n                        try {\n                            element[method]();\n                            resolve();\n                        } catch (error) {\n                            reject(error);\n                        }\n                    }, duration);\n                }));\n            });\n            return new Promise((resolve, reject) => {\n                Promise.all(promises).then(() => {\n                    callback();\n                    resolve();\n                }).catch(error => {\n                    reject(error);\n                });\n            });\n        };\n    });\n}", "CodeBleu_score": 41.48159373328979}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t  // Initialize input string\n  var input = '';\n  // Read loop\n  serial.on('data', function(data) {\n    // Append data to input string\n    input += data;\n    // Split input string into sentences\n    var sentences = input.split('\\r\n');\n    // Process each sentence\n    for (var i = 0; i < sentences.length; i++) {\n      // If the sentence is not empty\n      if (sentences[i].length > 0) {\n        // Parse the sentence\n        var sentence = parseNmeaSentence(sentences[i]);\n        // If the sentence was parsed successfully\n        if (sentence) {\n          // Process the sentence\n          processNmeaSentence(sentence);\n        }\n      }\n    }\n    // Retain any incomplete sentence for the next read\n    input = sentences[sentences.length - 1];\n  });\n}", "CodeBleu_score": 40.6440963315709}, {"code": "listen(){\n\t  // initialize the input string\n  String input = \"\";\n  // start listening to the serial port\n  while (Serial.available() > 0) {\n    // read the next character from the serial port\n    char c = Serial.read();\n    // if the character is a newline, we have a complete sentence\n    if (c == '\n') {\n      // process the sentence\n      parseNmeaSentence(input);\n      // clear the input string\n      input = \"\";\n    } else {\n      // otherwise, append the character to the input string\n      input += c;\n    }\n  }\n}", "CodeBleu_score": 13.68796552716961}, {"code": "listen(){\n\t  String input = \"\";\n  while (true) {\n    if (Serial.available() > 0) {\n      char c = Serial.read();\n      if (c == '\\r') {\n        input += '\n';\n      } else {\n        input += c;\n      }\n      if (c == '\n') {\n        if (input.length() > 0) {\n          parseNmeaSentence(input);\n        }\n        input = \"\";\n      }\n    }\n  }\n}", "CodeBleu_score": 17.694770962095525}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tint num_channels = 0;\n\tint needed_buffer_size;\n\tint ret;\n\n\tif (sequence->options) {\n\t\tret = adc_context_busy(&adc_ad559x_data.ctx);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Previous conversion not finished\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels_buffer[i].channel_id !=\n\t\t    ADC_CHANNEL_ID_DISABLED) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = num_channels * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer size %d is insufficient\",\n\t\t\tsequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 59.39804065298806}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\treturn 0;\n}", "CodeBleu_score": 10.074846604246273}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\treturn 0;\n}", "CodeBleu_score": 10.074846604246273}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint i, ret;\n\n\tif (sequence->resolution != ADC_RESOLUTION_16_BIT) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i].channel_id >= AD559X_NUM_CHANNELS) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < sequence->channels) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}", "CodeBleu_score": 54.48274267036488}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tint i;\n\tint ret;\n\tuint16_t *buffer = sequence->buffer;\n\n\tif (sequence->channels > AD559X_CHANNEL_COUNT) {\n\t\tLOG_ERR(\"Too many channels (%d) specified\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution != 16) {\n\t\tLOG_ERR(\"Unsupported resolution (%d bits)\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < sequence->channels) {\n\t\tLOG_ERR(\"Buffer size (%d) is insufficient for %d channels\",\n\t\t\tsequence->buffer_size, sequence->channels);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * If the ADC context is already busy, return an error.\n\t */\n\tif (data->ctx.state != ADC_STATE_READY) {\n\t\tLOG_ERR(\"ADC busy\");\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Set the buffer and start the ADC read operation.\n\t */\n\tdata->ctx.sequence = sequence;\n\tdata->ctx.buffer = buffer;\n\tdata->ctx.buffer_size = sequence->buffer_size;\n\tdata->ctx.remaining_conversions = sequence->channels;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Start the ADC read operation.\n\t */\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tad559x_read_channel(data->ad559x, sequence->channels[i]);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 61.28990087061411}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *cfg = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_context *ctx = &data->ctx;\n\tint error;\n\n\tadc_context_lock(ctx, false, NULL);\n\n\tadc_context_buffers_setup(ctx, sequence, &data->buffer, sizeof(data->buffer));\n\n\tadc_context_prepare(ctx, sequence);\n\n\t/* Check if the resolution of the sequence matches the expected resolution. */\n\tif (sequence->resolution != ADC_RESOLUTION) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/* Check if the channels are valid. */\n\tif (sequence->channels > ADC_CHANNEL_COUNT) {\n\t\tLOG_ERR(\"Invalid channel count\");\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/* Check if the buffer is sufficient. */\n\tif (ctx->buffer_size < sequence->channels) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\t/* Start the ADC read. */\n\tadc_ad559x_start_read_conversion(dev, sequence->channels);\n\n\terror = adc_context_wait_for_completion(ctx);\n\nexit:\n\tadc_context_release(ctx, error);\n\n\treturn error;\n}", "CodeBleu_score": 52.411164132455646}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->data;\n\tstruct adc_reg_seq_entry *entries = ctx->sequence;\n\tint i;\n\n\tfor (i = 0; i < ctx->sequence_length; i++) {\n\t\tdata->buffer[i] = entries[i].sampling_delay;\n\t}\n\n\tad559x_start_sampling(data->dev, data->buffer, ctx->sequence_length);\n}", "CodeBleu_score": 29.979217482533155}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->data;\n\tconst struct adc_sequence *sequence = ctx->sequence;\n\tconst struct adc_sequence_options *options = sequence->options;\n\tconst struct adc_channel_cfg *channels = sequence->channels;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels_len; i++) {\n\t\tdata->buffer[i] = channels[i].channel_id;\n\t}\n\n\tif (options->extra_samplings > 0) {\n\t\tdata->buffer_size = sequence->channels_len + options->extra_samplings;\n\t} else {\n\t\tdata->buffer_size = sequence->channels_len;\n\t}\n\n\tdata->buffer_ready = 0;\n\tdata->repeat_buffer = data->buffer;\n\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 32.56993362456915}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tconst struct adc_driver_api *api = ctx->dev->driver_api;\n\tstruct adc_data *data = ctx->data;\n\n\tif (ctx->sequence.channels) {\n\t\tapi->channel_setup(ctx->dev, &ctx->sequence);\n\t}\n\n\tif (ctx->sequence.buffer) {\n\t\tdata->buffer = ctx->sequence.buffer;\n\t}\n\n\tif (ctx->sequence.buffer_size) {\n\t\tdata->buffer_size = ctx->sequence.buffer_size;\n\t}\n\n\tif (ctx->sequence.resolution) {\n\t\tdata->resolution = ctx->sequence.resolution;\n\t}\n\n\tif (ctx->sequence.oversampling) {\n\t\tdata->oversampling = ctx->sequence.oversampling;\n\t}\n\n\tif (ctx->sequence.calibrate) {\n\t\tdata->calibrate = ctx->sequence.calibrate;\n\t}\n\n\tif (ctx->sequence.calibrate_channel) {\n\t\tdata->calibrate_channel = ctx->sequence.calibrate_channel;\n\t}\n\n\tif (ctx->sequence.calibrate_result) {\n\t\tdata->calibrate_result = ctx->sequence.calibrate_result;\n\t}\n\n\tif (ctx->sequence.calibrate_result_size) {\n\t\tdata->calibrate_result_size = ctx->sequence.calibrate_result_size;\n\t}\n\n\tif (ctx->sequence.calibrate_factor) {\n\t\tdata->calibrate_factor = ctx->sequence.calibrate_factor;\n\t}\n\n\tif (ctx->sequence.calibrate_offset) {\n\t\tdata->calibrate_offset = ctx->sequence.calibrate_offset;\n\t}\n\n\tif (ctx->sequence.calibrate_target_raw) {\n\t\tdata->calibrate_target_raw = ctx->sequence.calibrate_target_raw;\n\t}\n\n\tif (ctx->sequence.calibrate_target_volt) {\n\t\tdata->calibrate_", "CodeBleu_score": 42.42752051833742}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer = ctx->data_container->data;\n\t}\n}", "CodeBleu_score": 47.83398727771599}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer = ctx->buffer_pool;\n\t}\n}", "CodeBleu_score": 46.77549169405723}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer = ctx->buffer_single;\n\t}\n}", "CodeBleu_score": 46.85724995274003}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t\tfor (int i = 0; i < data->channels; i++) {\n\t\t\tif (data->ctx[i].acquisition_func(data, &data->ctx[i])) {\n\t\t\t\tLOG_ERR(\"ADC channel %d acquisition failed\", i);\n\t\t\t\tdata->ctx[i].state = ADC_STATE_COMPLETE;\n\t\t\t}\n\t\t}\n\t\tk_sem_give(&data->sem);\n\t\tk_sem_take(&data->sem_done, K_FOREVER);\n\t}\n}", "CodeBleu_score": 28.913769402813944}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (int i = 0; i < data->channels; i++) {\n\t\t\tif (data->active_channels & BIT(i)) {\n\t\t\t\tif (adc_ad559x_read_channel(data->dev, i,\n\t\t\t\t\t\t\t   &data->buffer[i]) < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d\", i);\n\t\t\t\t\tdata->status = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tk_sem_give(&data->sem);\n\t}\n}", "CodeBleu_score": 34.74209394503251}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t\tfor (int i = 0; i < data->channels; i++) {\n\t\t\tif (data->active_channels & BIT(i)) {\n\t\t\t\tif (adc_ad559x_read_channel(data, i) != 0) {\n\t\t\t\t\tLOG_ERR(\"ADC read failed\");\n\t\t\t\t\tdata->error_callback(data->dev, data->sequence);\n\t\t\t\t\tdata->state = ADC_STATE_ACQ_ERROR;\n\t\t\t\t\tgoto end_of_loop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nend_of_loop:\n\t\tk_sem_give(&data->sem);\n\t\tif (data->state == ADC_STATE_ACQ_DONE) {\n\t\t\tk_sem_give(&data->sem_done);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.05255916530096}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint ret;\n\tuint8_t reg_val;\n\tuint8_t reg_addr = ADS1112_REG_CONFIG;\n\tuint8_t ready_mask = ADS1112_CONFIG_DRDY_MASK;\n\tuint8_t ready_val = ADS1112_CONFIG_DRDY_MASK;\n\tconst struct ads1112_config *cfg = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\n\t/*\n\t * The ADS1112 device has a ready time of 100 microseconds.\n\t * Wait for the device to be ready for data reading.\n\t */\n\tk_sleep(K_USEC(100));\n\n\t/*\n\t * Read the configuration register to check the status.\n\t */\n\tret = ads1112_read_reg(dev, reg_addr, &reg_val);\n\tif (ret) {\n\t\tLOG_ERR(\"ADS1112: Error reading config register\");\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If the device is not ready, wait for 100 microseconds and check the status again.\n\t */\n\twhile (reg_val & ready_mask) {\n\t\tk_sleep(K_USEC(100));\n\t\tret = ads1112_read_reg(dev, reg_addr, &reg_val);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"ADS1112: Error reading config register\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * If the device is ready, return 0.\n\t */\n\tif (reg_val == ready_val) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the device is not ready, return -EAGAIN.\n\t */\n\treturn -EAGAIN;\n}", "CodeBleu_score": 49.37703531654151}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *cfg = dev->config;\n\tuint8_t status;\n\n\tif (i2c_reg_read_byte(cfg->i2c, cfg->i2c_address, ADS1112_REG_CONFIG, &status) != 0) {\n\t\tLOG_ERR(\"Error reading configuration register\");\n\t\treturn -EIO;\n\t}\n\n\twhile (status & ADS1112_CONFIG_DRDY_MASK) {\n\t\tk_sleep(K_USEC(100));\n\t\tif (i2c_reg_read_byte(cfg->i2c, cfg->i2c_address, ADS1112_REG_CONFIG, &status) != 0) {\n\t\t\tLOG_ERR(\"Error reading configuration register\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.526028502518756}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *cfg = dev->config;\n\tuint8_t reg_value;\n\tint ret;\n\tint i;\n\tfor (i = 0; i < cfg->ready_time; i++) {\n\t\tk_sleep(100);\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_value);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"Error reading configuration register\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (reg_value & ADS1112_CONFIG_DRDY) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tLOG_ERR(\"Device not ready\");\n\treturn -EIO;\n}", "CodeBleu_score": 40.11703621560382}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tconst struct adc_sequence_options *options = sequence->options;\n\tint num_samplings = sequence->num_samples;\n\tint num_extra_samplings = options->extra_samplings;\n\tint required_buffer_size;\n\n\tif (options->extra_samplings_delay) {\n\t\tnum_extra_samplings += options->extra_samplings;\n\t}\n\n\trequired_buffer_size = num_samplings + num_extra_samplings;\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"The buffer size is insufficient for the sequence.\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.012116082369715}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tif (sequence->options) {\n\t\tLOG_ERR(\"ADS1112 driver does not support options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < sequence->num_samples) {\n\t\tLOG_ERR(\"ADS1112 driver requires a buffer size of at least %d\", sequence->num_samples);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 52.212746499503226}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint8_t num_samplings = sequence->options;\n\tuint8_t num_extra_samplings = sequence->extra_samplings;\n\tuint8_t buffer_size = sequence->buffer_size;\n\tuint8_t required_buffer_size = num_samplings + num_extra_samplings;\n\n\tif (buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"ADS1112: Buffer size %d is insufficient for %d samplings, including %d extra samplings\",\n\t\t\t\tbuffer_size, num_samplings, num_extra_samplings);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.37733462876113}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tstruct ads1112_config *config = dev->config;\n\tint ret;\n\n\tif (!sequence->buffer) {\n\t\tLOG_ERR(\"No destination buffer provided\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > ADS1112_CHANNEL_COUNT) {\n\t\tLOG_ERR(\"Not enough channels in buffer\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling > ADS1112_OVERSAMPLING_COUNT) {\n\t\tLOG_ERR(\"Invalid oversampling value\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution > ADS1112_RESOLUTION_COUNT) {\n\t\tLOG_ERR(\"Invalid resolution value\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling == ADS1112_OVERSAMPLING_COUNT) {\n\t\tLOG_ERR(\"Invalid oversampling value\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling == ADS1112_OVERSAMPLING_COUNT) {\n\t\tLOG_ERR(\"Invalid oversampling value\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling == ADS1112_OVERSAMPLING_COUNT) {\n\t\tLOG_ERR(\"Invalid oversampling value\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling == ADS1112_OVERSAMPLING_COUNT) {\n\t\tLOG_ERR(\"Invalid oversampling value\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling == ADS1112_OVER", "CodeBleu_score": 42.281702131902264}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unsupported options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels > 1) {\n\t\tLOG_ERR(\"Unsupported channel count\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < 1) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = ads1112_adc_start_conversion(data);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to start conversion\");\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = ads1112_adc_wait_for_completion(data);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 49.09048036504399}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->channels > 1) {\n\t\tLOG_ERR(\"Only single channel conversion supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Only oversampling factor of 0 supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Only 12 bit resolution supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 58.91149745141758}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret;\n\tstruct device *dev;\n\tstruct audio_codec_properties prop;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_properties_init(&prop);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Unable to initialize audio codec properties\");\n\t\treturn ret;\n\t}\n\n\tprop.gain_control = (bool) atoi(argv[2]);\n\tprop.mute_control = (bool) atoi(argv[3]);\n\tprop.mic_gain_control = (bool) atoi(argv[4]);\n\tprop.mic_mute_control = (bool) atoi(argv[5]);\n\tprop.mic_boost_control = (bool) atoi(argv[6]);\n\tprop.mic_boost_gain = atoi(argv[7]);\n\tprop.mic_boost_time = atoi(argv[8]);\n\tprop.mic_boost_period = atoi(argv[9]);\n\tprop.mic_boost_threshold = atoi(argv[10]);\n\tprop.mic_boost_hysteresis = atoi(argv[11]);\n\tprop.mic_boost_attack = atoi(argv[12]);\n\tprop.mic_boost_decay = atoi(argv[13]);\n\tprop.mic_boost_release = atoi(argv[14]);\n\tprop.mic_boost_pre_delay = atoi(argv[15]);\n\tprop.mic_boost_post_delay = atoi(argv[16]);\n\tprop.mic_boost_noise_gate = (bool) atoi(argv[17]);\n\tprop.mic_boost_noise_gate_threshold = atoi(argv[18]);\n\tprop.mic_boost_noise_gate_ratio = atoi(argv[19]);\n\tprop.mic_boost_noise_gate_attack = atoi(argv[20]);", "CodeBleu_score": 55.399169653588686}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint err;\n\tstruct device *dev;\n\tstruct audio_codec_properties prop;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Set the properties */\n\tprop.gain = atoi(argv[2]);\n\tprop.mute = atoi(argv[3]);\n\tprop.bass = atoi(argv[4]);\n\tprop.treble = atoi(argv[5]);\n\tprop.balance = atoi(argv[6]);\n\tprop.eq_mode = atoi(argv[7]);\n\n\terr = audio_codec_set_properties(dev, &prop);\n\tif (err) {\n\t\tshell_error(sh, \"Unable to set properties\");\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 61.8082057208363}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\n    int ret;\n    struct device *dev;\n    struct audio_codec_properties prop;\n\n    if (argc != 2) {\n        SHELL_ERR(sh, \"Incorrect number of arguments\");\n        return -EINVAL;\n    }\n\n    dev = device_get_binding(argv[1]);\n\n    if (!dev) {\n        SHELL_ERR(sh, \"Device not found\");\n        return -ENODEV;\n    }\n\n    ret = audio_codec_get_properties(dev, &prop);\n\n    if (ret) {\n        SHELL_ERR(sh, \"Could not get properties\");\n        return ret;\n    }\n\n    ret = audio_codec_set_properties(dev, &prop);\n\n    if (ret) {\n        SHELL_ERR(sh, \"Could not set properties\");\n        return ret;\n    }\n\n    return 0;\n}", "CodeBleu_score": 55.44550389013114}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint err;\n\tstruct mpxxdtyy_data *dev_data = dev->data;\n\tconst struct mpxxdtyy_config *dev_cfg = dev->config;\n\n\tif (dev_data->state == DMIC_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tLOG_ERR(\"DMIC is already active\");\n\t\t\treturn -EINVAL;\n\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\terr = i2s_trigger(dev_cfg->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"Failed to stop I2S device\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tdev_data->state = DMIC_STATE_CONFIGURED;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dev_data->state == DMIC_STATE_CONFIGURED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\terr = i2s_trigger(dev_cfg->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"Failed to start I2S device\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tdev_data->state = DMIC_STATE_ACTIVE;\n\t\t\treturn 0;\n\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tLOG_ERR(\"DMIC is already inactive\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"DMIC is in an invalid state\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.062663577639775}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    int err;\n    const struct mpxxdtyy_config *cfg = dev->config;\n    struct mpxxdtyy_data *data = dev->data;\n\n    if (data->state == MPXXDTYY_STATE_UNINITIALIZED) {\n        LOG_ERR(\"Device not initialized\");\n        return -ENODEV;\n    }\n\n    if (data->state == MPXXDTYY_STATE_DISABLED) {\n        LOG_ERR(\"Device disabled\");\n        return -EPERM;\n    }\n\n    if (data->state == MPXXDTYY_STATE_ACTIVE) {\n        if (cmd == DMIC_TRIGGER_START) {\n            LOG_ERR(\"Device already active\");\n            return -EPERM;\n        }\n    }\n\n    if (data->state == MPXXDTYY_STATE_CONFIGURED) {\n        if (cmd == DMIC_TRIGGER_STOP) {\n            LOG_ERR(\"Device not active\");\n            return -EPERM;\n        }\n    }\n\n    if (cmd == DMIC_TRIGGER_START) {\n        if (data->state != MPXXDTYY_STATE_CONFIGURED) {\n            LOG_ERR(\"Device not configured\");\n            return -EPERM;\n        }\n\n        err = i2s_trigger(dev, I2S_DIR_RX, I2S_TRIGGER_START);\n        if (err != 0) {\n            LOG_ERR(\"Failed to start I2S RX\");\n            return err;\n        }\n\n        data->state = MPXXDTYY_STATE_ACTIVE;\n        LOG_DBG(\"Device started\");\n    } else if (cmd == DMIC_TRIGGER_STOP) {\n        if (data->state != MPXXDTYY_STATE_ACTIVE) {\n            LOG_ERR(\"Device not active\");\n            return -EPERM;\n        }\n\n        err = i2s_trigger(dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n        if (err != 0) {\n            LOG_ERR(\"Failed to stop I2", "CodeBleu_score": 48.07287526542559}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\n\t/*\n\t * The variable \"ret\" is used to store the return value of the function.\n\t */\n\tint ret = 0;\n\n\t/*\n\t * The variable \"dev_data\" is a pointer to the device's private data structure.\n\t */\n\tstruct mpxxdtyy_data *dev_data = DEV_DATA(dev);\n\n\t/*\n\t * The variable \"i2s_dev\" is a pointer to the I2S device's structure.\n\t */\n\tconst struct device *i2s_dev = dev_data->i2s_dev;\n\n\t/*\n\t * The variable \"i2s_cmd\" is used to store the I2S command.\n\t */\n\tstruct i2s_config i2s_cmd;\n\n\t/*\n\t * The variable \"i2s_state\" is used to store the I2S device's state.\n\t */\n\tenum i2s_state i2s_state;\n\n\t/*\n\t * The variable \"i2s_err\" is used to store the I2S device's error code.\n\t */\n\tint i2s_err;\n\n\t/*\n\t * The variable \"i2s_err_str\" is used to store the I2S device's error string.\n\t */\n\tconst char *i2s_err_str;\n\n\t/*\n\t * The variable \"i2s_err_str_len\" is used to store the length of the I2S device's error string.\n\t */\n\tsize_t i2s_err_str_len;\n\n\t/*\n\t * The variable \"i2s_err_str_buf\" is used to store the I2S device's error string.\n\t */\n\tchar i2s_err_str_buf[128];\n\n\t/*\n\t * The variable \"i2s_err_str_buf_len\" is used to store the length of the I2S device's error string.\n\t */\n\tsize_t i2s_err_str_buf_len;\n\n\t/*\n\t * The variable \"i2s_err_str_buf_len\" is used to store", "CodeBleu_score": 12.246964114429591}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tuint8_t cmd;\n\tuint8_t data;\n\tuint8_t cursor;\n\tuint8_t blink;\n\tuint8_t pos;\n\tuint8_t pos_blink;\n\tuint8_t pos_blink_cursor;\n\tuint8_t pos_cursor;\n\tuint8_t pos_cursor_blink;\n\tuint8_t pos_cursor_blink_cursor;\n\tuint8_t pos_cursor_blink_cursor_enabled;\n\tuint8_t pos_cursor_blink_cursor_disabled;\n\tuint8_t pos_cursor_blink_disabled;\n\tuint8_t pos_cursor_disabled;\n\tuint8_t pos_cursor_enabled;\n\tuint8_t pos_enabled;\n\tuint8_t pos_enabled_cursor;\n\tuint8_t pos_enabled_cursor_blink;\n\tuint8_t pos_enabled_cursor_blink_cursor;\n\tuint8_t pos_enabled_cursor_blink_cursor_disabled;\n\tuint8_t pos_enabled_cursor_blink_cursor_enabled;\n\tuint8_t pos_enabled_cursor_blink_disabled;\n\tuint8_t pos_enabled_cursor_disabled;\n\tuint8_t pos_enabled_cursor_enabled;\n\tuint8_t pos_enabled_disabled;\n\tuint8_t pos_enabled_enabled;\n\tuint8_t pos_enabled_enabled_cursor;\n\tuint8_t pos_enabled_enabled_cursor_blink;\n\tuint8_t pos_enabled_enabled_cursor_blink_cursor;\n\tuint8_t pos_enabled_enabled_cursor_blink_cursor_disabled;\n\tuint8_t pos_enabled_enabled_cursor_blink_cursor_enabled;\n\tuint8_t pos_enabled_enabled_cursor_blink_disabled;\n\tuint8_t pos_enabled_enabled_cursor_disabled;\n\tuint8_t pos_enabled_enabled_cursor_enabled;\n\tuint8_t pos_enabled_enabled_disabled;\n\tuint8_t pos_enabled_enabled_enabled;\n\tuint8_", "CodeBleu_score": 8.632976361125953}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ENABLE;\n\t}\n\n\tif (data->blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_BLINK_ENABLE;\n\t}\n\n\tif (data->cursor) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ENABLE;\n\t}\n\n\tif (data->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK_ENABLE;\n\t}\n\n\tif (data->cursor_position) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_POSITION;\n\t}\n\n\tif (data->display_shift) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_SHIFT;\n\t}\n\n\tcmd |= data->display_mode;\n\n\tauxdisplay_hd44780_write_command(dev, cmd);\n}", "CodeBleu_score": 70.16304777954278}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *cfg = dev->config;\n\tuint8_t cmd = 0x00;\n\tuint8_t data = 0x00;\n\n\t/*\n\t * The function \"auxdisplay_hd44780_get_config\" retrieves the configuration of the HD44780 auxiliary display.", "CodeBleu_score": 24.715689631898595}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\n\tif (!config->busy_gpio_port) {\n\t\tLOG_ERR(\"Busy GPIO port is not defined.\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 34.46563773023479}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *cfg = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\n\tif (!cfg->busy_port) {\n\t\tLOG_ERR(\"Busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (gpio_pin_get(cfg->busy_port, cfg->busy_pin)) {\n\t\tLOG_ERR(\"Busy GPIO pin is high\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 52.50584301713239}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\tuint32_t level;\n\n\tif (!config->busy_gpio_port) {\n\t\tLOG_ERR(\"No busy GPIO port defined.\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_raw(config->busy_gpio_port, config->busy_gpio_pin);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get busy GPIO pin (err %d).\", ret);\n\t\treturn ret;\n\t}\n\n\tlevel = ret;\n\tif (level == config->busy_gpio_inactive_level) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}", "CodeBleu_score": 58.55476113291509}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tint ret;\n\tuint8_t buf[2];\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\n\tLOG_DBG(\"Entering function %s\", __func__);\n\n\tbuf[0] = (uint8_t)command;\n\tbuf[1] = (uint8_t)command;\n\n\tret = i2c_write(config->i2c_dev, buf, sizeof(buf), config->i2c_addr);\n\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Error writing special command %d to device %s\", command, dev->name);\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\n\treturn ret;\n}", "CodeBleu_score": 60.79162010262576}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\tconst struct auxdisplay_serlcd_config *cfg = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = cfg->special_command_prefix;\n\tbuffer[1] = command;\n\n\tret = i2c_write(dev, buffer, 2, cfg->i2c_address);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"I2C write failed with error %d\", ret);\n\t\treturn ret;\n\t}\n\n\tk_sleep(cfg->command_delay);\n\n\treturn ret;\n}", "CodeBleu_score": 55.72991083224497}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config * const config = dev->config;\n\tstruct auxdisplay_serlcd_data * const data = dev->data;\n\tuint8_t buffer[2];\n\tint result;\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = (uint8_t)command;\n\n\tresult = i2c_write(data->i2c_device, buffer, sizeof(buffer), config->i2c_address);\n\n\tif (result < 0) {\n\t\tLOG_ERR(\"Could not send special command %d to device %s\", command, config->i2c_label);\n\t\treturn result;\n\t}\n\n\tk_sleep(config->delay_after_special_command);\n\n\treturn result;\n}", "CodeBleu_score": 52.921914617795615}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *emul = dev->data;\n\tsize_t available_size = emul->size - offset;\n\n\tif (size > available_size) {\n\t\tLOG_ERR(\"Read size %zu exceeds available size %zu\", size,\n\t\t\tavailable_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > emul->size) {\n\t\tLOG_ERR(\"Read size %zu exceeds memory size %zu\", size,\n\t\t\temul->size);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, emul->memory + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 57.19048842076959}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *emul = dev->data;\n\tint err = 0;\n\n\tif (offset + size > emul->mem_size) {\n\t\tLOG_ERR(\"Read out of bounds\");\n\t\terr = -EINVAL;\n\t} else if (offset + size < offset) {\n\t\tLOG_ERR(\"Read would wrap around\");\n\t\terr = -EINVAL;\n\t} else {\n\t\tmemcpy(data, emul->mem + offset, size);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 53.78937721597241}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *emul = dev->data;\n\n\tif (offset + size > emul->size) {\n\t\tLOG_ERR(\"Reading %zu bytes from offset %zu exceeds memory size %zu\",\n\t\t\tsize, offset, emul->size);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, emul->mem + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 60.978763285558536}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tLOG_ERR(\"Not implemented\");\n\treturn -ENOTSUP;\n}", "CodeBleu_score": 23.3368090170225}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *emul = dev->data;\n\tint err = 0;\n\n\tif (offset > emul->size) {\n\t\tLOG_ERR(\"BBRAM write: offset out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (size > emul->size - offset) {\n\t\tLOG_ERR(\"BBRAM write: size out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (emul->invalid) {\n\t\tLOG_ERR(\"BBRAM write: invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(emul->mem + offset, data, size);\n\n\treturn err;\n}", "CodeBleu_score": 54.32456700046393}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_emul_data = dev->data;\n\tconst struct bbram_emul_cfg *bbram_emul_cfg = dev->config;\n\n\tif (offset > bbram_emul_cfg->size) {\n\t\tLOG_ERR(\"Write offset is beyond the end of the BBRAM\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (size > bbram_emul_cfg->size - offset) {\n\t\tLOG_ERR(\"Write size is too large\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_data->invalid) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(bbram_emul_data->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 58.80665457005458}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc != 2) {\n\t\tshell_error(sh, \"Device name not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 78.82664507321782}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"No device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 70.34157340788325}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 3) {\n\t\tshell_error(sh, \"Device argument missing\");\n\t\treturn -ENOEXEC;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[2]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENOEXEC;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 74.4913733744906}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint r;\n\tuint8_t *hdr = (uint8_t *)&h4_hdr;\n\tuint8_t *ptr = hdr;\n\tuint8_t *end = hdr + sizeof(h4_hdr);\n\tuint8_t *p = hdr;\n\tuint8_t *q = hdr;\n\tuint8_t *rptr = hdr;\n\tuint8_t *rend = hdr + sizeof(h4_hdr);\n\tuint8_t *buf = (uint8_t *)&h4_buf;\n\tuint8_t *endbuf = buf + sizeof(h4_buf);\n\tuint8_t *bufptr = buf;\n\tuint8_t *bufend = buf + sizeof(h4_buf);\n\tuint8_t *pbuf = buf;\n\tuint8_t *pbufend = buf + sizeof(h4_buf);\n\tuint8_t *qbuf = buf;\n\tuint8_t *qbufend = buf + sizeof(h4_buf);\n\tuint8_t *rbuf = buf;\n\tuint8_t *rbufend = buf + sizeof(h4_buf);\n\n\t/*\n\t * Read the header data from the UART FIFO.\n\t */\n\twhile (ptr < end) {\n\t\tr = uart_fifo_read(dev, ptr, end - ptr);\n\t\tif (r < 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART FIFO (%d)\", r);\n\t\t\treturn;\n\t\t}\n\t\tptr += r;\n\t}\n\n\t/*\n\t * Calculate the number of bytes read.\n\t */\n\th4_hdr_len = ptr - hdr;\n\n\t/*\n\t * Copy the header data to the buffer.\n\t */\n\tmemcpy(buf, hdr, h4_hdr_len);\n\n\t/*\n\t * Calculate the number of bytes already read.\n\t */\n\th4_buf_len = h4_hdr_len;\n\n\t/*\n\t * Calculate the number of bytes to read.\n\t */\n", "CodeBleu_score": 27.944058252590985}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint err;\n\tint read;\n\tint remaining;\n\tuint8_t *ptr;\n\tstruct bt_hci_cmd_hdr cmd;\n\tstruct bt_hci_acl_hdr acl;\n\tstruct bt_hci_event_hdr evt;\n\tstruct bt_hci_evt_hdr_ref *ref;\n\tstruct net_buf *buf;\n\n\t/*\n\t * The function \"h4_read_hdr\" reads header data from a UART device into a buffer.", "CodeBleu_score": 26.987700758898335}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tuint8_t buf[4];\n\tint i;\n\tint err;\n\n\t/*\n\t * Read the header data from the UART device.\n\t */\n\terr = uart_fifo_read(dev, buf, 4);\n\tif (err < 0) {\n\t\tLOG_ERR(\"Failed to read H4 header (%d)\", err);\n\t\treturn;\n\t}\n\n\t/*\n\t * Calculate the number of bytes already read.\n\t */\n\ti = 4 - err;\n\n\t/*\n\t * Attempt to read the remaining bytes from the UART FIFO into the header buffer.\n\t */\n\terr = uart_fifo_read(dev, buf + i, err);\n\tif (err < 0) {\n\t\tLOG_ERR(\"Failed to read H4 header (%d)\", err);\n\t\treturn;\n\t}\n\n\t/*\n\t * Update the remaining byte count based on the number of bytes successfully read.\n\t */\n\ti += err;\n\n\t/*\n\t * Check if the header is complete.\n\t */\n\tif (i < 4) {\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if the header is valid.\n\t */\n\tif (buf[0] != 0x04 || buf[1] != 0x00 || buf[2] != 0x00) {\n\t\tLOG_ERR(\"Invalid H4 header\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if the packet length is valid.\n\t */\n\tif (buf[3] > 255) {\n\t\tLOG_ERR(\"Invalid H4 packet length\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Set the remaining byte count to the packet length.\n\t */\n\tuart_line_ctrl_set(dev, UART_LINE_CTRL_RTS, 0);\n\tuart_line_ctrl_set(dev, UART_LINE_CTRL_DTR, 0);\n\tuart_line_ctrl_set(dev, UART_LINE_CTRL_RTS, 1);\n\tuart_line_ctrl_", "CodeBleu_score": 34.01374636989301}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read;\n\n\tread = uart_fifo_read(uart, buf, sizeof(buf));\n\tif (read != len) {\n\t\tLOG_ERR(\"Failed to discard %zu bytes (%zu)\", len, read);\n\t}\n\n\treturn read;\n}", "CodeBleu_score": 50.32952050874611}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t n;\n\tsize_t i;\n\n\tfor (i = 0; i < len; i += n) {\n\t\tn = min(len - i, sizeof(buf));\n\t\tif (uart_fifo_read(uart, buf, n) != n) {\n\t\t\tLOG_ERR(\"Failed to discard %zu bytes (%zu bytes read)\",\n\t\t\t\t\tlen, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}", "CodeBleu_score": 35.492602372316824}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tstatic uint8_t buf[33];\n\tsize_t ret;\n\tsize_t i;\n\n\tret = uart_fifo_read(uart, buf, min(sizeof(buf), len));\n\tif (ret == 0) {\n\t\tLOG_ERR(\"Failed to discard %zu bytes (%d)\", len, errno);\n\t}\n\n\tfor (i = 0; i < ret; i++) {\n\t\tLOG_WRN(\"Discarded 0x%02x\", buf[i]);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 47.54224752034249}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint highest_observer_priority = -1;\n\tint observer_priority;\n\tint observer_enabled;\n\tstruct zbus_observer *observer;\n\tsys_snode_t *node;\n\n\tk_mutex_lock(&chan->mutex, K_FOREVER);\n\tSYS_SLIST_FOR_EACH_NODE(&chan->observers, node) {\n\t\tobserver = CONTAINER_OF(node, struct zbus_observer, node);\n\t\tobserver_priority = observer->priority;\n\t\tobserver_enabled = observer->enabled;\n\n\t\tif (observer_enabled && (observer_priority > highest_observer_priority)) {\n\t\t\thighest_observer_priority = observer_priority;\n\t\t}\n\t}\n\tchan->highest_observer_priority = highest_observer_priority;\n\tk_mutex_unlock(&chan->mutex);\n}", "CodeBleu_score": 24.278369576215407}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint i;\n\tint new_hop = 0;\n\n\tfor (i = 0; i < chan->num_observers; i++) {\n\t\tif (chan->observers[i].enabled && chan->observers[i].priority > new_hop) {\n\t\t\tnew_hop = chan->observers[i].priority;\n\t\t}\n\t}\n\n\tchan->hop = new_hop;\n}", "CodeBleu_score": 20.299340955908367}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint i;\n\tint highest = 0;\n\tstruct zbus_observer *observer;\n\tsys_slist_t *list = &chan->observers;\n\n\tsys_slist_lock(list);\n\tfor (i = 0; i < sys_slist_peek_count(list); i++) {\n\t\tobserver = (struct zbus_observer *)sys_slist_get(list);\n\t\tif (observer->enabled && (observer->priority > highest)) {\n\t\t\thighest = observer->priority;\n\t\t}\n\t}\n\tsys_slist_unlock(list);\n\n\tchan->highest_observer_priority = highest;\n}", "CodeBleu_score": 25.91683223013562}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel *channel;\n\n\tfor (channel = zbus_get_first_channel(); channel != NULL; channel = zbus_get_next_channel(channel)) {\n\t\tif (channel->obs == obs) {\n\t\t\tchannel->update(channel);\n\t\t}\n\t}\n}", "CodeBleu_score": 17.564417269165634}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel *channel;\n\tstruct zbus_channel_observation *obs_chan;\n\tsys_slist_t *list = &obs->channels;\n\tsys_snode_t *node;\n\tsys_snode_t *next;\n\tsys_slist_for_each_no_lock(node, list) {\n\t\tsys_slist_for_each_no_lock_safe(node, next, list) {\n\t\t\tobs_chan = (struct zbus_channel_observation *)node;\n\t\t\tchannel = obs_chan->channel;\n\t\t\tif (obs_chan->observer == obs) {\n\t\t\t\tchannel->update(channel);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 18.997173192362414}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    for (int i = 0; i < CHANNELS_MAX; i++) {\n        if (channels[i].obs == obs) {\n            channels[i].update(obs);\n        }\n    }\n}", "CodeBleu_score": 17.50502307291259}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tint ret;\n\tint i;\n\tstruct zbus_channel *chan;\n\n\tif (z_is_in_isr()) {\n\t\tLOG_ERR(\"Cannot attach an observer in an ISR\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!obs) {\n\t\tLOG_ERR(\"Cannot attach a null observer\");\n\t\treturn -EINVAL;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\n\tif (obs->priority < CONFIG_ZBUS_THREAD_PRIORITY_MIN) {\n\t\tobs->priority = CONFIG_ZBUS_THREAD_PRIORITY_MIN;\n\t}\n\n\tfor (i = 0; i < CONFIG_ZBUS_CHANNEL_COUNT; i++) {\n\t\tchan = obs->channels[i];\n\t\tif (chan) {\n\t\t\tzbus_chan_update_observers(chan);\n\t\t}\n\t}\n\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 43.09577848811604}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    return 0;\n}", "CodeBleu_score": 6.203992247536536}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tint ret;\n\tint i;\n\n\tif (k_is_in_isr()) {\n\t\treturn -EPERM;\n\t}\n\n\tif (obs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\n\tif (obs->thread_prio != K_LOWEST_THREAD_PRIO) {\n\t\tobs->thread_prio = K_LOWEST_THREAD_PRIO;\n\n\t\tfor (i = 0; i < obs->num_channels; i++) {\n\t\t\tobs->channels[i]->num_observers++;\n\t\t}\n\t}\n\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 41.13280771066739}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tif (!chan) {\n\t\treturn -EINVAL;\n\t}\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\tk_timeout_t end_time = k_uptime_get() + timeout;\n\tk_prio_t priority = k_current_get()->base.prio;\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\tint err = zbus_chan_notify_locked(chan, end_time, priority);\n\tk_spin_unlock(&chan->lock, key);\n\treturn err;\n}", "CodeBleu_score": 32.33664810302371}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint ret;\n\tk_spinlock_key_t key;\n\n\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tkey = k_spin_lock(&chan->lock);\n\n\tif (chan->pending_tx) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tchan->pending_tx = true;\n\n\tchan->tx_end_time = k_uptime_get() + timeout;\n\n\tk_spin_unlock(&chan->lock, key);\n\n\tret = zbus_chan_notify_locked(chan);\n\n\tif (ret) {\n\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\tk_spin_unlock(&chan->lock, key);\n\treturn ret;\n}", "CodeBleu_score": 45.49315734132006}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tif (chan == NULL) {\n\t\tLOG_ERR(\"zbus_chan_notify: channel is null\");\n\t\treturn -EINVAL;\n\t}\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\tk_timeout_t end_time = k_uptime_get() + timeout;\n\tk_poll_signal_init(&chan->context.signal);\n\tchan->context.prio = K_LOWEST_APPLICATION_THREAD_PRIO;\n\tk_mutex_lock(&chan->lock, K_FOREVER);\n\tint err = zbus_chan_notify_locked(chan, end_time);\n\tk_mutex_unlock(&chan->lock);\n\treturn err;\n}", "CodeBleu_score": 43.13272979508787}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    if (enable) {\n        if (Int == ETH_IT_PMT) {\n            ETH->INTEN |= ETH_INTEN_PMTIE;\n        } else if (Int == ETH_IT_PMT_WKUP) {\n            ETH->INTEN |= ETH_INTEN_PMTWKIE;\n        } else if (Int == ETH_IT_RX_OVR) {\n            ETH->INTEN |= ETH_INTEN_RXOVRIE;\n        } else if (Int == ETH_IT_RX_BUF) {\n            ETH->INTEN |= ETH_INTEN_RXBUIE;\n        } else if (Int == ETH_IT_RX_STS) {\n            ETH->INTEN |= ETH_INTEN_RXSTSIE;\n        } else if (Int == ETH_IT_RX_STP) {\n            ETH->INTEN |= ETH_INTEN_RXSTPIE;\n        } else if (Int == ETH_IT_TX_STS) {\n            ETH->INTEN |= ETH_INTEN_TXSTSIE;\n        } else if (Int == ETH_IT_TX_STP) {\n            ETH->INTEN |= ETH_INTEN_TXSTPIE;\n        } else if (Int == ETH_IT_WKUP) {\n            ETH->INTEN |= ETH_INTEN_WKUIE;\n        } else if (Int == ETH_IT_SOFT) {\n            ETH->INTEN |= ETH_INTEN_SOFTIE;\n        } else if (Int == ETH_IT_MR) {\n            ETH->INTEN |= ETH_INTEN_MRXIE;\n        } else if (Int == ETH_IT_MR_WKUP) {\n            ETH->INTEN |= ETH_INTEN_MRWKIE;\n        } else if (Int == ETH_IT_SLK) {\n            ETH->INTEN |= ETH_INTEN_SLKIE;\n", "CodeBleu_score": 33.80164529592782}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\n  if (Int == ETH_INT_RX_OVERFLOW) {\n    if (enable)\n      ETH->INTEN |= ETH_INTEN_RXOVREN;\n    else\n      ETH->INTEN &= ~ETH_INTEN_RXOVREN;\n  }\n  else if (Int == ETH_INT_RX_FRAME_RECEIVED) {\n    if (enable)\n      ETH->INTEN |= ETH_INTEN_RXFRAEN;\n    else\n      ETH->INTEN &= ~ETH_INTEN_RXFRAEN;\n  }\n  else if (Int == ETH_INT_RX_FRAME_CRC_ERROR) {\n    if (enable)\n      ETH->INTEN |= ETH_INTEN_RXCRCEN;\n    else\n      ETH->INTEN &= ~ETH_INTEN_RXCRCEN;\n  }\n  else if (Int == ETH_INT_RX_FRAME_ALIGNMENT_ERROR) {\n    if (enable)\n      ETH->INTEN |= ETH_INTEN_RXALIGEN;\n    else\n      ETH->INTEN &= ~ETH_INTEN_RXALIGEN;\n  }\n  else if (Int == ETH_INT_RX_DRIBBLE_BIT_ERROR) {\n    if (enable)\n      ETH->INTEN |= ETH_INTEN_RXDRIBEN;\n    else\n      ETH->INTEN &= ~ETH_INTEN_RXDRIBEN;\n  }\n  else if (Int == ETH_INT_RX_MII_ERROR) {\n    if (enable)\n      ETH->INTEN |= ETH_INTEN_RXMIIEN;\n    else\n      ETH->INTEN &= ~ETH_INTEN_RXMIIEN;\n  }\n  else if (Int == ETH_INT_RX_RUNT_FRAME) {\n    if (enable)\n      ETH->INTEN |= ETH_INT", "CodeBleu_score": 35.213906150042654}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (enable) {\n\t\tif (Int == ETH_INT_RX_OVERFLOW) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXOVREN;\n\t\t} else if (Int == ETH_INT_RX_FRAME_LOST) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXFLSTEN;\n\t\t} else if (Int == ETH_INT_RX_WATCHDOG_TIMEOUT) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXWTOEN;\n\t\t} else if (Int == ETH_INT_RX_EARLY_END) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXEREN;\n\t\t} else if (Int == ETH_INT_RX_GOOD_FRAME) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXGFEN;\n\t\t} else if (Int == ETH_INT_RX_UNICAST_FRAME) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXUFEN;\n\t\t} else if (Int == ETH_INT_RX_BROADCAST_FRAME) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXBFEN;\n\t\t} else if (Int == ETH_INT_RX_MULTICAST_FRAME) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXMFEN;\n\t\t} else if (Int == ETH_INT_RX_FRAME_FILTERED) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXFFEN;\n\t\t} else if (Int == ETH_INT_TX_GOOD_FRAME) {\n\t\t\tETH->INTEN |= ETH_INTEN_TXGFEN;\n\t\t} else if (Int == ETH_INT_TX_EARLY_END) {\n\t\t\tET", "CodeBleu_score": 31.741149219291565}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc = (ETH_TX_DESC *)(ETH_BASE + ETH_TX_DESC_BASE);\n\tuint32_t i;\n\n\tfor (i = 0; i < ETH_TX_DESC_COUNT; i++) {\n\t\tif ((pTxDesc->Status & ETH_TX_DESC_STATUS_OWN) == 0) {\n\t\t\treturn pTxDesc;\n\t\t}\n\t\tpTxDesc++;\n\t\tif (pTxDesc == (ETH_TX_DESC *)(ETH_BASE + ETH_TX_DESC_BASE + ETH_TX_DESC_SIZE * ETH_TX_DESC_COUNT)) {\n\t\t\tpTxDesc = (ETH_TX_DESC *)(ETH_BASE + ETH_TX_DESC_BASE);\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 31.622724402620506}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\tpTxDesc = (ETH_TX_DESC *)(ETH_BASE_ADDR + ETH_TX_DESC_LIST_ADDR);\n\n\tfor (i = 0; i < ETH_TX_DESC_LIST_SIZE; i++) {\n\t\tif ((pTxDesc->Status & ETH_TX_DESC_STATUS_OWN) == 0) {\n\t\t\treturn pTxDesc;\n\t\t}\n\t\tpTxDesc++;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 32.21252386487924}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\n\tETH_TX_DESC *tx_desc;\n\n\ttx_desc = (ETH_TX_DESC *)(ETH_BASE + ETH_TX_DESC_BASE);\n\n\twhile (tx_desc->status & ETH_TX_DESC_STATUS_OWN) {\n\n\t\tif (tx_desc == (ETH_TX_DESC *)(ETH_BASE + ETH_TX_DESC_BASE)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\ttx_desc--;\n\t}\n\n\treturn tx_desc;\n}", "CodeBleu_score": 45.22808248139212}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    CY_DAC_PRT(\"cyp_adc_convert\n\");\n    return RT_EOK;\n}", "CodeBleu_score": 23.952359093682933}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_uint32_t status;\n\tstruct cyp_dac_device *dac_device = (struct cyp_dac_device *)device;\n\n\tstatus = Cy_CSDIDAC_OutputEnable(dac_device->base, channel, *value);\n\tif (status != CY_CSDIDAC_SUCCESS) {\n\t\trt_kprintf(\"cyp_adc_convert: Cy_CSDIDAC_OutputEnable failed with status %d\n\", status);\n\t\treturn RT_ERROR;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 47.586580987128414}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_uint32_t ret = RT_EOK;\n\n    if (channel >= CY_CSDIDAC_CHANNEL_COUNT) {\n        return -RT_EINVAL;\n    }\n\n    if (value == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    if (*value > 0xFF) {\n        return -RT_EINVAL;\n    }\n\n    if (device == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    Cy_CSDIDAC_OutputEnable(device, channel, *value);\n\n    return ret;\n}", "CodeBleu_score": 49.33319068578709}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > IFX_FLASH_END_ADDR) {\n        rt_kprintf(\"ifx_flash_read_32k: invalid argument\n\");\n        return -1;\n    }\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n    return size;\n}", "CodeBleu_score": 43.30038882509222}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > IFX_FLASH_32K_END) {\n        rt_kprintf(\"Error: flash read out of range\n\");\n        return -RT_EINVAL;\n    }\n\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *((rt_uint8_t *)addr + i);\n    }\n    return size;\n}", "CodeBleu_score": 44.26421729982625}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    rt_uint32_t *buf32;\n\n    if (addr + size > IFX_FLASH_32K_END) {\n        rt_kprintf(\"Error: Address 0x%08x exceeds flash memory's end address 0x%08x\n\", addr, IFX_FLASH_32K_END);\n        return -RT_EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *((rt_uint8_t *)addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 50.80446221668515}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    struct rt_hwtimer_device *hwtimer = (struct rt_hwtimer_device *)timer->parent.user_data;\n    RT_ASSERT(hwtimer != RT_NULL);\n    cyhal_timer_t *cyhal_timer = (cyhal_timer_t *)hwtimer->priv;\n    RT_ASSERT(cyhal_timer != RT_NULL);\n    return cyhal_timer_read(cyhal_timer);\n}", "CodeBleu_score": 53.962524449815334}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    rt_uint32_t count = 0;\n    struct rt_hwtimer_device *hwtimer = (struct rt_hwtimer_device *)timer;\n\n    if (hwtimer == RT_NULL) {\n        return 0;\n    }\n\n    count = cyhal_timer_read((cyhal_timer_t *)hwtimer->parent.user_data);\n\n    return count;\n}", "CodeBleu_score": 53.89105386159812}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    rt_uint32_t count = 0;\n    rt_uint32_t ret = RT_EOK;\n\n    RT_ASSERT(timer != RT_NULL);\n\n    struct rt_hwtimer_device *hwtimer = (struct rt_hwtimer_device *)timer->parent.user_data;\n\n    ret = cyhal_timer_read(hwtimer->timer, &count);\n    if (ret != CY_RSLT_SUCCESS) {\n        rt_kprintf(\"cyhal_timer_read failed\n\");\n    }\n\n    return count;\n}", "CodeBleu_score": 52.69742304088223}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    int ret = 0;\n\n    ret = dfs_lock_wait(0);\n\n    if (ret != DFS_OK) {\n        DFS_ASSERT(0);\n    }\n}", "CodeBleu_score": 18.47875168451875}, {"code": "void dfs_lock(void){\n\t    int ret = 0;\n\n    ret = aos_mutex_lock(&g_dfs_lock, AOS_WAIT_FOREVER);\n    if (ret != 0) {\n        DFS_ASSERT(0);\n    }\n}", "CodeBleu_score": 21.193151357990963}, {"code": "void dfs_lock(void){\n\t    int ret;\n\n    ret = aos_mutex_lock(&g_dfs_lock, AOS_WAIT_FOREVER);\n    if (ret != 0) {\n        LOGE(TAG, \"aos_mutex_lock fail %d\n\", ret);\n        assert(0);\n    }\n}", "CodeBleu_score": 21.719234776636114}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fdt[i] == NULL) {\n            return i;\n        }\n    }\n\n    if (fdt->maxfd >= fdt->maxfd_limit) {\n        return -1;\n    }\n\n    fdt->maxfd++;\n\n    return fdt->maxfd - 1;\n}", "CodeBleu_score": 37.54856620968429}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fd[i] == NULL) {\n            return i;\n        }\n    }\n\n    /* no empty slot found, try to expand the fd table */\n    return fd_table_expand(fdt, startfd);\n}", "CodeBleu_score": 31.745585573444778}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fd[i] == NULL) {\n            return i;\n        }\n    }\n\n    /* no empty slot found, try to expand the fd table */\n    if (fdt->maxfd < fdt->maxfd_alloc) {\n        fdt->fd = (struct dfs_fd **)realloc(fdt->fd, (fdt->maxfd_alloc + DFS_FD_INCREMENT) * sizeof(struct dfs_fd *));\n        if (fdt->fd == NULL) {\n            return -1;\n        }\n\n        memset(fdt->fd + fdt->maxfd, 0, DFS_FD_INCREMENT * sizeof(struct dfs_fd *));\n        fdt->maxfd += DFS_FD_INCREMENT;\n        fdt->maxfd_alloc += DFS_FD_INCREMENT;\n\n        return fdt->maxfd - 1;\n    }\n\n    return -1;\n}", "CodeBleu_score": 38.70438434298883}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    int i;\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    for (i = 0; i < sizeof(rt_err_str_table) / sizeof(struct rt_err_str_item); i++) {\n        if (error == rt_err_str_table[i].no) {\n            return rt_err_str_table[i].str;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 62.007126871419004}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    int i;\n\n    if (error < 0)\n        error = -error;\n\n    for (i = 0; i < RT_ERROR_END; i ++) {\n        if (error == rt_err_table[i].no) {\n            return rt_err_table[i].desc;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 59.88100056526757}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    const char *str_error;\n    int i;\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    for (i = 0; i < sizeof(str_error_tab) / sizeof(str_error_tab[0]); i ++) {\n        if (str_error_tab[i].err_code == error) {\n            str_error = str_error_tab[i].err_str;\n            break;\n        }\n    }\n\n    if (str_error == RT_NULL) {\n        str_error = \"EUNKNOW\";\n    }\n\n    return str_error;\n}", "CodeBleu_score": 61.36491939543247}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_spin_lock(&idle_hook_lock);\n    if (idle_hook_list[idle_hook_index].hook == RT_NULL) {\n        idle_hook_list[idle_hook_index].hook = hook;\n        rt_spin_unlock(&idle_hook_lock);\n        return RT_EOK;\n    }\n    rt_spin_unlock(&idle_hook_lock);\n    return -RT_EFULL;\n}", "CodeBleu_score": 30.409530553523208}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_spin_lock(&rt_thread_idle_spin);\n\n    if (rt_thread_idle_hooks[rt_thread_idle_hook_index].hook != RT_NULL)\n    {\n        rt_spin_unlock(&rt_thread_idle_spin);\n\n        return -RT_EFULL;\n    }\n    else\n    {\n        rt_thread_idle_hooks[rt_thread_idle_hook_index].hook = hook;\n        rt_thread_idle_hooks[rt_thread_idle_hook_index].parameter = RT_NULL;\n\n        rt_spin_unlock(&rt_thread_idle_spin);\n\n        return RT_EOK;\n    }\n}", "CodeBleu_score": 33.74167292492117}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\treturn RT_EOK;\n}", "CodeBleu_score": 7.009679975445407}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_base_t level;\n    struct rt_thread *idle;\n\n    idle = rt_thread_self();\n    if (idle->idle_hooks == RT_NULL) return -RT_ERROR;\n\n    level = rt_hw_interrupt_disable();\n    if (idle->idle_hooks->hook == hook)\n    {\n        idle->idle_hooks = idle->idle_hooks->next;\n    }\n    else\n    {\n        struct rt_thread_idle_hooks *hook_ptr;\n        for (hook_ptr = idle->idle_hooks; hook_ptr->next != RT_NULL; hook_ptr = hook_ptr->next)\n        {\n            if (hook_ptr->next->hook == hook)\n            {\n                hook_ptr->next = hook_ptr->next->next;\n                break;\n            }\n        }\n    }\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 35.81668519652752}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\trt_list_t *l;\n\n\tlevel = rt_hw_interrupt_disable();\n\tfor (l = &_idle_hook_list; l != l->next; l = l->next) {\n\t\tif (l->next == &_idle_hook_list) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next->next->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next->next->next->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next->next->next->next->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next->next->next->next->next->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next->next->next->next->next->next->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next->next->next->next->next->next->next->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next->next->next->next->next->next->next->next->next->next == l) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l->next->next->next->next->next->next->next->", "CodeBleu_score": 18.662918949757017}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_thread_t tid;\n    rt_base_t level;\n    rt_list_t *l;\n\n    level = rt_hw_interrupt_disable();\n    tid = rt_thread_self();\n    for (l = &tid->idle_hook; l != tid->idle_hook_list; l = l->next) {\n        if (l->next == (rt_list_t *)hook) {\n            l->next = l->next->next;\n            rt_hw_interrupt_enable(level);\n            return RT_EOK;\n        }\n    }\n    rt_hw_interrupt_enable(level);\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 37.68470735082048}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_list_t *l;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* dequeue thread from suspend list */\n    while (!rt_list_isempty(susp_list))\n    {\n        /* get first thread */\n        l = susp_list->next;\n\n        /* get thread */\n        thread = rt_list_entry(l, struct rt_thread, tlist);\n\n        /* dequeue thread */\n        rt_list_remove(l);\n\n        /* resume thread */\n        rt_thread_resume(thread, thread_error);\n    }\n\n    /* leave critical */\n    rt_exit_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 41.95944338406973}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_list_t *node;\n\n    /*\n     * The function \"rt_suspend_thread\" suspends the current thread and adds it to the specified suspension list.\n     * The function \"rt_suspend_thread\" suspends the current thread and adds it to the specified suspension list.\n     * The function \"rt_suspend_thread\" suspends the current thread and adds it to the specified suspension list.\n     * The function \"rt_suspend_thread\" suspends the current thread and adds it to the specified suspension list.\n     */\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /*\n     * The function \"rt_enter_critical\" disables interrupts and returns the previous interrupt status.\n     * The function \"rt_enter_critical\" disables interrupts and returns the previous interrupt status.\n     * The function \"rt_enter_critical\" disables interrupts and returns the previous interrupt status.\n     * The function \"rt_enter_critical\" disables interrupts and returns the previous interrupt status.\n     */\n    rt_base_t level = rt_enter_critical();\n\n    /*\n     * The function \"rt_list_isempty\" checks whether the given list is empty.\n     * The function \"rt_list_isempty\" checks whether the given list is empty.\n     * The function \"rt_list_isempty\" checks whether the given list is empty.\n     * The function \"rt_list_isempty\" checks whether the given list is empty.\n     */\n    if (rt_list_isempty(susp_list))\n    {\n        /*\n         * The function \"rt_exit_critical\" re-enables interrupts and returns the previous interrupt status.\n         * The function \"rt_exit_critical\" re-enables interrupts and returns the previous interrupt status.\n         * The function \"rt_exit_critical\" re-enables interrupts and returns the previous interrupt status.\n         * The function \"rt_exit_critical\" re-enables interrupts and returns the previous interrupt status.\n         */\n        rt_exit_critical(level", "CodeBleu_score": 20.815711785298053}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_list_t *node;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check parameter */\n    if (susp_list == RT_NULL)\n    {\n        return -RT_EINVAL;\n    }\n\n    /* check suspend list */\n    if (rt_list_isempty(susp_list))\n    {\n        return -RT_ERROR;\n    }\n\n    /* dequeue thread from suspend list */\n    while ((node = rt_list_pop_front(susp_list)))\n    {\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n\n        /* thread is not initialized */\n        if (thread->stat == RT_THREAD_CLOSE)\n        {\n            rt_kprintf(\"thread %.*s is not initialized\n\", RT_NAME_MAX, thread->name);\n            continue;\n        }\n\n        /* thread is not suspended */\n        if (thread->stat != RT_THREAD_SUSPEND)\n        {\n            rt_kprintf(\"thread %.*s is not suspended\n\", RT_NAME_MAX, thread->name);\n            continue;\n        }\n\n        /* thread is not in suspend list */\n        if (!rt_list_isempty(&(thread->tlist)))\n        {\n            rt_kprintf(\"thread %.*s is not in suspend list\n\", RT_NAME_MAX, thread->name);\n            continue;\n        }\n\n        /* resume thread */\n        thread->stat = RT_THREAD_READY;\n        rt_schedule();\n\n        /* notify thread resume */\n        if (thread->thread_info & RT_THREAD_INFO_TID_MASK)\n        {\n            rt_sem_release(thread->tid);\n        }\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 34.60566161915249}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console;\n    rt_device_t new_console;\n\n    RT_ASSERT(name != RT_NULL);\n\n    /* get old console device */\n    old_console = rt_console_get_device();\n\n    /* find new console device */\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL)\n    {\n        rt_kprintf(\"rt_console_set_device: can't find device:%s\n\", name);\n        return old_console;\n    }\n\n    /* check new console device */\n    if ((new_console->type != RT_Device_Class_Char) ||\n        (new_console->rx_indicate == RT_NULL) ||\n        (new_console->open_flag != (RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM)))\n    {\n        rt_kprintf(\"rt_console_set_device: invalid device:%s\n\", name);\n        return old_console;\n    }\n\n    /* close old console device */\n    if (old_console != RT_NULL)\n    {\n        rt_device_close(old_console);\n    }\n\n    /* open new console device */\n    if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK)\n    {\n        rt_kprintf(\"rt_console_set_device: open device:%s failed\n\", name);\n        return old_console;\n    }\n\n    /* set new console device */\n    rt_console_set_device(new_console);\n\n    return old_console;\n}", "CodeBleu_score": 52.42138390514508}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console, new_console;\n    rt_err_t ret;\n\n    old_console = rt_console_get_device();\n    if (old_console)\n    {\n        ret = rt_device_close(old_console);\n        if (ret != RT_EOK)\n        {\n            rt_kprintf(\"rt_console_set_device: close old console device failed.\n\");\n            return old_console;\n        }\n    }\n\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL)\n    {\n        rt_kprintf(\"rt_console_set_device: can't find device:%s.\n\", name);\n        return old_console;\n    }\n\n    ret = rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (ret != RT_EOK)\n    {\n        rt_kprintf(\"rt_console_set_device: open new console device failed.\n\");\n        return old_console;\n    }\n\n    rt_console_set_device(new_console);\n\n    return old_console;\n}", "CodeBleu_score": 53.049754536851545}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console, new_console;\n    rt_err_t ret;\n\n    old_console = rt_console_get_device();\n    if (old_console == RT_NULL)\n    {\n        rt_kprintf(\"no console device\n\");\n        return RT_NULL;\n    }\n\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL)\n    {\n        rt_kprintf(\"can't find device:%s\n\", name);\n        return RT_NULL;\n    }\n\n    if (new_console == old_console)\n    {\n        rt_kprintf(\"console device is same\n\");\n        return old_console;\n    }\n\n    ret = rt_device_control(old_console, RT_DEVICE_CTRL_SET_INT, RT_NULL);\n    if (ret != RT_EOK)\n    {\n        rt_kprintf(\"set int err\n\");\n        return RT_NULL;\n    }\n\n    ret = rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (ret != RT_EOK)\n    {\n        rt_kprintf(\"open new console err\n\");\n        return RT_NULL;\n    }\n\n    ret = rt_device_control(new_console, RT_DEVICE_CTRL_SET_INT, RT_NULL);\n    if (ret != RT_EOK)\n    {\n        rt_kprintf(\"set int err\n\");\n        return RT_NULL;\n    }\n\n    rt_console_set_device(new_console);\n\n    return old_console;\n}", "CodeBleu_score": 50.31818138830536}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int length = 0;\n    rt_object_t object;\n    rt_list_t *node;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check object type */\n    if (type >= RT_Object_Class_End)\n    {\n        return 0;\n    }\n\n    /* get object list */\n    object = rt_object_get_head(type);\n    if (object == RT_NULL)\n    {\n        return 0;\n    }\n\n    /* lock object list */\n    rt_object_list_lock(type);\n\n    /* get the length */\n    for (node = object->list.next; node != object->list.prev; node = node->next)\n    {\n        length ++;\n    }\n\n    /* unlock object list */\n    rt_object_list_unlock(type);\n\n    return length;\n}", "CodeBleu_score": 47.76345343305076}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int length = 0;\n    rt_list_t *node;\n    rt_object_t object;\n\n    rt_enter_critical();\n    for (node = rt_object_list[type].next; node != &rt_object_list[type]; node = node->next) {\n        object = rt_list_entry(node, struct rt_object, list);\n        length ++;\n    }\n    rt_exit_critical();\n\n    return length;\n}", "CodeBleu_score": 31.169804654500034}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int length = 0;\n    rt_object_t object;\n    rt_list_t *node;\n\n    /* get object list */\n    rt_object_list_t list = RT_NULL;\n    switch (type)\n    {\n    case RT_Object_Class_Static:\n        list = &rt_object_list;\n        break;\n    case RT_Object_Class_Device:\n        list = &rt_device_list;\n        break;\n    case RT_Object_Class_Timer:\n        list = &rt_timer_list;\n        break;\n    case RT_Object_Class_Semaphore:\n        list = &rt_semaphore_list;\n        break;\n    case RT_Object_Class_Event:\n        list = &rt_event_list;\n        break;\n    case RT_Object_Class_Mutex:\n        list = &rt_mutex_list;\n        break;\n    case RT_Object_Class_MailBox:\n        list = &rt_mail_box_list;\n        break;\n    case RT_Object_Class_MessageQueue:\n        list = &rt_message_queue_list;\n        break;\n    case RT_Object_Class_MemHeap:\n        list = &rt_memheap_list;\n        break;\n    case RT_Object_Class_MemPool:\n        list = &rt_mempool_list;\n        break;\n    case RT_Object_Class_Pipe:\n        list = &rt_pipe_list;\n        break;\n    case RT_Object_Class_Thread:\n        list = &rt_thread_list;\n        break;\n    case RT_Object_Class_Module:\n        list = &rt_module_list;\n        break;\n    default:\n        break;\n    }\n    if (list == RT_NULL)\n    {\n        return 0;\n    }\n\n    /* lock object list */\n    rt_spin_lock(&list->lock);\n\n    /* get count of object */\n    for (node = list->object_list.next;", "CodeBleu_score": 38.13534329548756}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_object_t parent;\n    rt_object_info_t object_info;\n    rt_list_t *list;\n\n    if (object != RT_NULL) {\n        /* get object information */\n        object_info = &(object->object_info);\n\n        /* get parent */\n        parent = object_info->parent.object;\n\n        /* detach object */\n        object_info->parent.object = RT_NULL;\n        object_info->parent.type   = RT_Object_Class_Static;\n\n        /* detach from parent */\n        if (parent != RT_NULL) {\n            list = &(parent->object_info.sibling_list);\n            rt_list_remove(list);\n        }\n\n        /* invoke detach hook function */\n        if (object_info->ops->detach_hook != RT_NULL) {\n            object_info->ops->detach_hook(object);\n        }\n    }\n}", "CodeBleu_score": 39.61234443008066}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_object_information_t object_info;\n\n    if (object != RT_NULL) {\n        object_info = &(object->object_info);\n\n        /* invoke object detach hook */\n        if (object_info->ops->detach != RT_NULL) {\n            object_info->ops->detach(object);\n        }\n\n        /* lock object */\n        rt_object_lock(object);\n\n        /* remove object from object list */\n        rt_object_list_remove(object_info);\n\n        /* unlock object */\n        rt_object_unlock(object);\n\n        /* set object type to RT_Object_Class_Static */\n        object->type = RT_Object_Class_Static;\n    }\n}", "CodeBleu_score": 35.67189761774186}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_object_information_t object_info;\n\n    if (object == RT_NULL)\n        return;\n\n    object_info = object->object_info;\n    if (object_info == RT_NULL)\n        return;\n\n    /* lock object */\n    rt_spin_lock(&(object_info->lock));\n\n    /* detach object */\n    if (object_info->object_number != 0)\n        object_info->object_number --;\n    object->type = RT_Object_Static;\n\n    /* unlock object */\n    rt_spin_unlock(&(object_info->lock));\n}", "CodeBleu_score": 47.71873707207931}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t ret = RT_EOK;\n    rt_custom_object_ops_t *ops;\n\n    if (obj == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    ops = (rt_custom_object_ops_t *)obj->ops;\n    if (ops->destroy != RT_NULL) {\n        ret = ops->destroy(obj);\n    }\n\n    rt_free(obj);\n\n    return ret;\n}", "CodeBleu_score": 48.40390136073146}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n    rt_custom_class_t class_type;\n\n    RT_ASSERT(obj != RT_NULL);\n\n    class_type = obj->type & RT_Object_Class_Mask;\n    if (class_type != RT_Object_Class_Custom) {\n        return -RT_ERROR;\n    }\n\n    if (obj->ops->destructor != RT_NULL) {\n        result = obj->ops->destructor(obj);\n    }\n\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 48.39851891376767}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n\n    if (obj == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    if (obj->type != RT_Object_Class_Custom) {\n        return -RT_EINVAL;\n    }\n\n    if (obj->flag & RT_Object_Flag_Static) {\n        return -RT_EPERM;\n    }\n\n    if (obj->ops->destructor != RT_NULL) {\n        result = obj->ops->destructor(obj);\n    }\n\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 48.30669425466099}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n    register rt_ubase_t level;\n\n    thread = rt_thread_self();\n\n    /* thread exit cleanup */\n    if (thread->cleanup != RT_NULL) {\n        thread->cleanup(thread);\n    }\n\n    /* thread exit scheduler */\n    level = rt_hw_interrupt_disable();\n    rt_thread_detach(thread);\n    rt_hw_interrupt_enable(level);\n\n    rt_schedule();\n}", "CodeBleu_score": 62.72083213848714}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread = rt_thread_self();\n\n    /* thread cleanup */\n    if (thread->cleanup != RT_NULL) {\n        thread->cleanup(thread);\n    }\n\n    /* thread-local storage cleanup */\n    rt_tls_cleanup(thread);\n\n    /* thread-specific data cleanup */\n    rt_thread_cleanup(thread);\n\n    /* leave interrupt */\n    rt_interrupt_leave();\n\n    /* scheduling */\n    rt_schedule();\n}", "CodeBleu_score": 56.76871005556083}, {"code": "static void _thread_exit(void){\n\t\n    struct rt_thread *thread = rt_thread_self();\n\n    rt_enter_critical();\n\n    /* thread exit */\n    if (thread->stat == RT_THREAD_CLOSE)\n    {\n        rt_exit_critical();\n\n        return;\n    }\n\n    thread->stat = RT_THREAD_CLOSE;\n\n    rt_exit_critical();\n\n    rt_schedule();\n}", "CodeBleu_score": 53.41785143691351}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t)parameter;\n\n    RT_ASSERT(thread != RT_NULL);\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_exit_critical();\n        return;\n    }\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to ready list */\n    rt_list_insert_after(&(thread->tlist), &(thread->scheduler->ready_list));\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 43.62027601526898}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t)parameter;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* check thread status */\n    if (thread->stat != RT_THREAD_SUSPEND)\n    {\n        rt_exit_critical();\n        LOG_E(\"thread %s is not in suspend state\", thread->name);\n        return;\n    }\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to ready list */\n    rt_list_insert_after(&(thread->tlist), &(thread->scheduler->ready_list));\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 44.540720174207486}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t) parameter;\n\n    RT_ASSERT(thread != RT_NULL);\n\n    /* thread should be in suspend list */\n    RT_ASSERT(rt_list_isempty(&(thread->tlist)) == RT_FALSE);\n\n    /* thread should be suspend */\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_INIT);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_CLOSE);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_RUNNING);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_READY);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_INVALID);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_STAT_MASK);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_DELETE);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_STAT_END);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_STAT_RUNNING);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_STAT_READY);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_STAT_SUSPEND);\n\n    /* thread should not be initialized */\n    RT_ASSERT(thread->stat != RT_THREAD_STAT_INIT);\n\n    /* thread should not be initialized */\n    RT_ASSERT(", "CodeBleu_score": 39.43855271243022}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_list_t *l;\n    rt_mutex_t mutex;\n\n    /* lock thread */\n    rt_spin_lock(&thread->lock);\n\n    /* check if thread is waiting on a mutex */\n    l = thread->wait_list.next;\n    while (l != &thread->wait_list) {\n        /* get mutex */\n        mutex = rt_list_entry(l, struct rt_mutex, wait_list);\n\n        /* remove thread from mutex */\n        rt_list_remove(&mutex->wait_list);\n        mutex->owner_thread = RT_NULL;\n        mutex->owner_count = 0;\n\n        /* clear pending object */\n        rt_thread_pending_clr(thread, RT_THREAD_PRIORITY_MAX);\n\n        /* release mutex */\n        rt_sem_release(&mutex->parent.parent.sem);\n\n        /* get next */\n        l = l->next;\n    }\n\n    /* release all mutexes */\n    l = thread->mutex_list.next;\n    while (l != &thread->mutex_list) {\n        /* get mutex */\n        mutex = rt_list_entry(l, struct rt_mutex, owner_list);\n\n        /* remove thread from mutex */\n        rt_list_remove(&mutex->owner_list);\n        mutex->owner_count --;\n\n        /* clear pending object */\n        rt_thread_pending_clr(thread, mutex->parent.parent.level);\n\n        /* release mutex */\n        rt_sem_release(&mutex->parent.parent.sem);\n\n        /* get next */\n        l = l->next;\n    }\n\n    /* unlock thread */\n    rt_spin_unlock(&thread->lock);\n}", "CodeBleu_score": 43.32081323570242}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_mutex_t mutex;\n\n    RT_ASSERT(thread != RT_NULL);\n\n    /* lock thread */\n    rt_spin_lock(&thread->lock);\n\n    /* check if thread is waiting on a mutex */\n    if (thread->stat & RT_THREAD_STAT_MUTEX_WAIT) {\n        /* get mutex */\n        mutex = thread->waiting_mutex;\n\n        /* remove thread from mutex's waiting list */\n        rt_list_remove(&(thread->tlist));\n\n        /* clear pending object */\n        thread->waiting_mutex = RT_NULL;\n        thread->stat &= ~RT_THREAD_STAT_MUTEX_WAIT;\n\n        /* release all mutexes */\n        while (mutex) {\n            /* release mutex */\n            rt_mutex_release(mutex);\n\n            /* get next mutex */\n            mutex = thread->waiting_mutex;\n        }\n    }\n\n    /* release thread */\n    rt_spin_unlock(&thread->lock);\n}", "CodeBleu_score": 42.85912121043132}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_list_t *l;\n    rt_mutex_t mutex;\n\n    /* lock thread */\n    rt_spin_lock(&thread->lock);\n\n    /* check if the thread is waiting on a mutex */\n    l = thread->wait_list.next;\n    while (l != &thread->wait_list) {\n        mutex = rt_list_entry(l, struct rt_mutex, wait_list);\n\n        /* remove it from mutex waiting list */\n        rt_list_remove(l);\n        mutex->wait_list.next = mutex->wait_list.prev = RT_NULL;\n\n        /* clear pending object */\n        mutex->owner_thread = RT_NULL;\n        mutex->owner_count = 0;\n        mutex->owner_priority = 0;\n        mutex->owner_state = RT_MUTEX_OWNER_STATE_UNKNOWN;\n\n        /* detach thread */\n        rt_thread_detach(thread);\n\n        /* unlock thread */\n        rt_spin_unlock(&thread->lock);\n\n        /* release all mutexes */\n        rt_mutex_release(mutex);\n\n        /* lock thread */\n        rt_spin_lock(&thread->lock);\n    }\n\n    /* unlock thread */\n    rt_spin_unlock(&thread->lock);\n}", "CodeBleu_score": 43.36907004363092}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t ret;\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->type == RT_THREAD_CUSTOM);\n\n    if (thread->stat != RT_THREAD_INIT) {\n        rt_kprintf(\"thread %s is not in the INIT state", "CodeBleu_score": 32.77137978876393}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->type == RT_THREAD_CUSTOM);\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT) {\n        return -RT_ERROR;\n    }\n\n    /* thread is not initialized */\n    if (thread->type != RT_THREAD_CUSTOM) {\n        return -RT_ERROR;\n    }\n\n    /* thread is not initialized */\n    if (thread->entry_arg == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    /* thread is not initialized */\n    if (thread->thread_stack == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    /* thread is not initialized */\n    if (thread->sp == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    /* thread is not initialized */\n    if (thread->stack_size == 0) {\n        return -RT_ERROR;\n    }\n\n    /* thread is not initialized */\n    if (thread->stack_size < RT_MIN_STACK_SIZE) {\n        return -RT_ERROR;\n    }\n\n    /* calculate priority attributes */\n    thread->current_priority = thread->init_priority;\n    thread->number = _rt_thread_get_number();\n\n    /* reset thread object and ready to schedule */\n    thread->stat = RT_THREAD_READY;\n    thread->error = RT_EOK;\n    thread->sp = thread->thread_stack + thread->stack_size;\n\n    /* insert thread to ready list */\n    rt_list_insert_before(&(thread->tlist), &(thread->scheduler->ready_thread));\n\n    /* resume thread */\n    result = rt_thread_resume(thread);\n    if (result != RT_EOK) {\n        return result;\n    }\n\n    /* trigger a schedule */\n    r", "CodeBleu_score": 43.7086906233141}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->type == RT_THREAD_CUSTOM);\n\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"starting thread:%s\n\", thread->name));\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread priority:%d, priority level:%d\n\", thread->current_priority, thread->number));\n\n    /* reset thread stat */\n    thread->stat = RT_THREAD_READY;\n\n    /* init thread priority */\n    thread->number = rt_thread_priority_convert(thread->init_priority, RT_THREAD_PRIORITY_MAX);\n\n    /* init thread error number */\n    thread->error = RT_EOK;\n\n    /* init thread cleanup list */\n    thread->cleanup = RT_NULL;\n\n    /* init thread stack frame */\n    rt_hw_stack_init(thread);\n\n    /* insert to ready queue */\n    rt_list_insert_after(rt_thread_ready_head, &(thread->tlist));\n\n    /* change to ready state */\n    rt_thread_switch_add(thread);\n\n    /* schedule */\n    rt_schedule();\n\n    return RT_EOK;\n}", "CodeBleu_score": 50.1099476139762}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_tick_t tick;\n    rt_timer_entry_t timer_entry;\n    rt_uint8_t level;\n\n    /* get the first timer entry */\n    timer_entry = (rt_timer_entry_t)timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]->next;\n    if (timer_entry == timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])\n    {\n        *timeout_tick = RT_TICK_MAX;\n        return -RT_ETIMEOUT;\n    }\n\n    /* get the timer entry's timeout tick */\n    tick = timer_entry->timeout_tick;\n\n    /* get the timer entry's level */\n    level = timer_entry->level;\n\n    /* get the next entry */\n    timer_entry = (rt_timer_entry_t)timer_entry->next;\n\n    /* check if the timer entry's level is not the highest level */\n    while (level != 0)\n    {\n        /* get the timer entry's timeout tick */\n        tick = tick < timer_entry->timeout_tick ? tick : timer_entry->timeout_tick;\n\n        /* get the next entry */\n        timer_entry = (rt_timer_entry_t)timer_entry->next;\n\n        /* get the timer entry's level */\n        level --;\n    }\n\n    *timeout_tick = tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 45.945916494624925}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_timer_t timer;\n    rt_list_t *timer_head;\n\n    timer_head = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n    timer = rt_list_entry(timer_head->next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n    if (timer->timeout > *timeout_tick)\n        *timeout_tick = timer->timeout;\n\n    return RT_EOK;\n}", "CodeBleu_score": 56.40634559212623}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_timer_t timer;\n\n    /* get the first timer entry */\n    timer = rt_list_entry(timer_list[0].next, struct rt_timer, row);\n\n    /* get the timeout tick */\n    *timeout_tick = timer->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 34.49318267641513}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    timer->parent.type = RT_Object_Class_Timer;\n    timer->parent.is_static = RT_FALSE;\n    timer->timeout = timeout;\n    timer->parameter = parameter;\n    timer->init_tick = time;\n    timer->flag = flag;\n    timer->parent.name = name;\n\n    /* initialize suspend list and activated list */\n    rt_list_init(&(timer->suspend_list));\n    rt_list_init(&(timer->activated_list));\n\n    /* initialize timer */\n    timer->timeout_tick = 0;\n    timer->remain_tick = 0;\n    timer->init_tick = time;\n    timer->flag = flag;\n\n    return timer;\n}", "CodeBleu_score": 55.10811672402585}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    timer = (rt_timer_t) rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n    {\n        LOG_E(\"create timer: allocate object memory failed!\");\n        return RT_NULL;\n    }\n\n    timer->parent.type = RT_Object_Class_Timer;\n    timer->timeout_func = timeout;\n    timer->parameter    = parameter;\n    timer->init_tick    = time;\n    timer->timeout_tick = time;\n    timer->flag         = flag;\n    timer->parent.name  = name;\n\n    /* set timer to inactive */\n    timer->parent.flag  = RT_Object_Flag_Inactive;\n\n    rt_list_init(&(timer->sibling_node));\n    rt_list_init(&(timer->timeout_list_node));\n\n    /* initialize timer list */\n    rt_list_insert_after(&(timer->timeout_list_node), &(timer->sibling_node));\n\n    /* initialize timer list */\n    rt_list_insert_after(&(timer->timeout_list_node), &(timer->sibling_node));\n\n    return timer;\n}", "CodeBleu_score": 50.14495958927372}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n    rt_uint32_t level;\n\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    timer->timeout_func = timeout;\n    timer->parameter = parameter;\n    timer->init_tick = time;\n    timer->timeout_tick = time;\n    timer->parent.type = RT_Object_Class_Timer;\n    timer->parent.flag = flag;\n    timer->parent.ref_count = 0;\n\n    /* initialize suspend list */\n    rt_list_init(&(timer->suspend_list));\n\n    /* initialize timer list */\n    rt_list_init(&(timer->row));\n\n    /* initialize timer flag */\n    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;\n\n    /* initialize timer */\n    timer->timeout_flag = RT_FALSE;\n    timer->parent.flag &= ~RT_TIMER_FLAG_CYCLE;\n    timer->parent.flag &= ~RT_TIMER_FLAG_ONE_SHOT;\n\n    /* initialize timer */\n    level = rt_hw_interrupt_disable();\n    rt_list_insert_before(&(rt_timer_list), &(timer->row));\n    rt_hw_interrupt_enable(level);\n\n    rt_object_activate(&(timer->parent));\n\n    return timer;\n}", "CodeBleu_score": 53.426698546601436}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tres.WriteHeader(rec.Code)\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 40.219607488238665}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 10.654331898169428}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tif a.debug {\n\t\tlog.Printf(\"[DEBUG] %s %s\n\", req.Method, req.URL)\n\t}\n\n\t// get the API key from the request\n\tapiKey := req.Header.Get(\"X-API-KEY\")\n\tif apiKey == \"\" {\n\t\tapiKey = req.FormValue(\"api_key\")\n\t}\n\n\t// check if the API key is valid\n\tif !a.keys[apiKey] {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// check if the request is a GET request\n\tif req.Method == \"GET\" {\n\t\ta.get(res, req)\n\t\treturn\n\t}\n\n\t// check if the request is a POST request\n\tif req.Method == \"POST\" {\n\t\ta.post(res, req)\n\t\treturn\n\t}\n\n\t// check if the request is a PUT request\n\tif req.Method == \"PUT\" {\n\t\ta.put(res, req)\n\t\treturn\n\t}\n\n\t// check if the request is a DELETE request\n\tif req.Method == \"DELETE\" {\n\t\ta.delete(res, req)\n\t\treturn\n\t}\n\n\thttp.Error(res, \"Method Not Allowed\", http.StatusMethodNotAllowed)\n}", "CodeBleu_score": 33.86395141258916}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// The function \"robeaux\" serves static assets in response to HTTP requests.\n\t// It retrieves the requested asset based on the URL path and checks for errors.\n\t// If the asset is found, it sets the appropriate Content-Type header based on the file extension (js, css, html).\n\t// It then writes the asset content to the response.\n\t// If an error occurs while retrieving the asset, it returns a 404 error.\n\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tif strings.HasPrefix(path, \"/api\") {\n\t\ta.api(res, req)\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/gobot.io\") {\n\t\ta.gobotio(res, req)\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/gobot.io/x\") {\n\t\ta.gobotiox(res, req)\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/gobot.io/x/gobot\") {\n\t\ta.gobotioxgobot(res, req)\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/gobot.io/x/gobot/v2\") {\n\t\ta.gobotioxgobotv2(res, req)\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/gobot.io/x/gobot/v2/api\") {\n\t\ta.gobotioxgobotv2api(res, req)\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/gobot.io/x/gobot/v2/api/robeaux\") {\n\t\ta.gobotioxgobotv2apirobeaux(res, req)\n\t\treturn\n\t}\n\tif strings.HasPrefix(path, \"/gobot.io/x/gobot/v2/platforms\") {\n\t\ta.gobotioxgobotv", "CodeBleu_score": 33.03453784247022}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tvar (\n\t\tw = res\n\t\tr = req\n\t)\n\n\tif r.Method != \"GET\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tpath := r.URL.Path\n\tif !strings.HasPrefix(path, \"/\") {\n\t\tpath = \"/\" + path\n\t\tr.URL.Path = path\n\t}\n\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\n\tasset, err := a.assets.Open(path)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer asset.Close()\n\n\text := strings.TrimPrefix(path, \"/\")\n\text = strings.Split(ext, \".\")[1]\n\n\tw.Header().Set(\"Content-Type\", mimeType(ext))\n\n\tif _, err := w.Write([]byte(robeaux.Asset(path))); err != nil {\n\t\tlog.Printf(\"error writing response: %v\", err)\n\t}\n}", "CodeBleu_score": 44.477965341141655}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tlog.Printf(\"robeaux: %s %s\", req.Method, req.URL)\n\n\tif req.Method == \"GET\" {\n\t\t// serve static assets\n\t\tif strings.HasPrefix(req.URL.Path, \"/js/\") {\n\t\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\t\t} else if strings.HasPrefix(req.URL.Path, \"/css/\") {\n\t\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\t\t} else if strings.HasPrefix(req.URL.Path, \"/html/\") {\n\t\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\t} else if strings.HasPrefix(req.URL.Path, \"/fonts/\") {\n\t\t\tres.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t\t}\n\n\t\tif strings.HasPrefix(req.URL.Path, \"/fonts/\") {\n\t\t\t// serve fonts\n\t\t\tres.Write([]byte(a.assets.Fonts[req.URL.Path[len(\"/fonts/\"):]]))\n\t\t\treturn\n\t\t}\n\n\t\t// serve other static assets\n\t\tasset, ok := a.assets.Assets[req.URL.Path]\n\t\tif !ok {\n\t\t\tlog.Printf(\"robeaux: 404 %s\", req.URL.Path)\n\t\t\thttp.Error(res, \"404\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tres.Write([]byte(asset))\n\t\treturn\n\t}\n\n\tlog.Printf(\"robeaux: %s %s\", req.Method, req.URL)\n\n\t// serve API requests\n\tif req.URL.Path == \"/api/gobot\" {\n\t\ta.apiGobot(res, req)\n\t\treturn\n\t}\n\n\tlog.Printf(\"robeaux: 404 %s\", req.URL.Path)\n\thttp.Error(res, \"404\", http.StatusNotFound)\n}", "CodeBleu_score": 44.52753969800176}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\n\ta.master.Robots()\n\tfor _, robot := range a.master.Robots() {\n\t\tif robot.Name() == robotName {\n\t\t\tconnections := make([]robeaux.Connection, 0)\n\t\t\tfor _, connection := range robot.Connections() {\n\t\t\t\tconnections = append(connections, robeaux.Connection{\n\t\t\t\t\tName:      connection.Name(),\n\t\t\t\t\tAdaptor:   connection.Adaptor().Name(),\n\t\t\t\t\tConnected: connection.Connected(),\n\t\t\t\t\tPins:      connection.Pins(),\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tjson.NewEncoder(res).Encode(robeaux.Connections{\n\t\t\t\tRobot: robeaux.Robot{\n\t\t\t\t\tName: robot.Name(),\n\t\t\t\t},\n\t\t\t\tConnections: connections,\n\t\t\t})\n\n\t\t\treturn\n\t\t}\n\t}\n\n\tjson.NewEncoder(res).Encode(robeaux.Error{\n\t\tError: fmt.Sprintf(\"no robot found with name %s\", robotName),\n\t})\n}", "CodeBleu_score": 43.25521485082234}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL.\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/v1/robots/\")\n\n\t// Find the robot in the master instance.\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"{\\\"error\\\":\\\"no robot found with name \" + robotName + \"\\\"}\"))\n\t\treturn\n\t}\n\n\t// Gather the robot's connections.\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format.\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\t// If there was an error converting the connections to JSON format, write a JSON error message indicating that an error occurred.\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(\"{\\\"error\\\":\\\"\" + err.Error() + \"\\\"}\"))\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections.\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 33.890233137875526}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Parse the robot name from the request URL.\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/v1/robots/\")\n\n\t// Find the robot with the specified name.\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(`{\"error\":\"No robot found with name %s\"}`, robotName)))\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot.\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format.\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\tlog.Printf(\"Error marshaling connections: %v\", err)\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(`{\"error\":\"Error marshaling connections\"}`))\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections.\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 31.207209104514146}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tconst realm = \"Restricted\"\n\t\tconst wwwAuthenticate = \"WWW-Authenticate\"\n\n\t\t// Check the request Authorization header for a username and password.\n\t\tif u, p, ok := r.BasicAuth(); ok {\n\t\t\t// Check the username and password against the expected values.\n\t\t\tif subtle.ConstantTimeCompare([]byte(u), []byte(username)) == 1 && subtle.ConstantTimeCompare([]byte(p), []byte(password)) == 1 {\n\t\t\t\t// If the credentials are correct, call the next handler.\n\t\t\t\tnext(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// If the credentials are not correct, set the WWW-Authenticate header and return a 401 response.\n\t\tw.Header().Set(wwwAuthenticate, \"Basic realm=\"+realm)\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\tw.Write([]byte(\"Not authorized\n\"))\n\t}\n}", "CodeBleu_score": 47.86447593716933}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"\\\"\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If we got this far, we can be sure that the user is authenticated.\n\t\t// So we just call the next handler in the chain.\n\t\tnext := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"Welcome, \" + username + \"!\"))\n\t\t})\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 50.940228371657184}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\t// If we're here, the user is authenticated, so we call the next handler in the chain.\n\t\tr.Header.Del(\"Authorization\")\n\t\tr.SetBasicAuth(username, password)\n\t\tr.Header.Set(\"X-Forwarded-User\", username)\n\t\tr.Header.Set(\"X-Forwarded-Password\", password)\n\t\tr.Header.Set(\"X-Forwarded-Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password)))\n\t\tr.Header.Set(\"X-Forwarded-Basic-Auth\", \"true\")\n\t\tr.Header.Set(\"X-Forwarded-Username\", username)\n\t\tr.Header.Set(\"X-Forwarded-Password\", password)\n\t\tr.Header.Set(\"X-Forwarded-Basic-Auth\", \"true\")\n\t\tr.Header.Set(\"X-Forwarded-User\", username)\n\t\tr.Header.Set(\"X-Forwarded-Password\", password)\n\t\tr.Header.Set(\"X-Forwarded-Basic-Auth\", \"true\")\n\t\tr.Header.Set(\"X-Forwarded-User\", username)\n\t\tr.Header.Set(\"X-Forwarded-Password\", password)\n\t\t", "CodeBleu_score": 47.39603014535899}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tvar slope, intercept float64\n\tif fromMin != fromMax {\n\t\tslope = (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\t\tintercept = float64(toMin) - slope * float64(fromMin)\n\t}\n\treturn func(input float64) (value int) {\n\t\tif input < fromMin {\n\t\t\treturn toMin\n\t\t} else if input > fromMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn int(slope * input + intercept)\n\t}\n}", "CodeBleu_score": 58.65495292779359}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope * float64(fromMin)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 55.15683323530966}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope * float64(fromMin)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 54.83918623780962}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tvar (\n\t\trawValue int\n\t\tscaledValue float64\n\t\terr error\n\t)\n\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection != nil {\n\t\trawValue, err = a.connection.AnalogRead(a.pin)\n\t\tif err != nil {\n\t\t\treturn 0, 0, err\n\t\t}\n\n\t\tif a.scale == 1 {\n\t\t\tscaledValue = float64(rawValue)\n\t\t} else {\n\t\t\tscaledValue = float64(rawValue) / float64(a.scale)\n\t\t}\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 48.42313489245159}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif a.connection.SupportsAnalogRead() {\n\t\ta.mutex.Lock()\n\t\tdefer a.mutex.Unlock()\n\t\traw, err := a.connection.AnalogRead(a.pin)\n\t\tif err != nil {\n\t\t\treturn 0, 0, err\n\t\t}\n\t\ta.lastRaw = raw\n\t\ta.lastScaled = a.scale(raw)\n\t\treturn raw, a.lastScaled, nil\n\t}\n\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog read\", a.connection.Name())\n}", "CodeBleu_score": 51.38719310463063}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif !a.connection.AnalogRead {\n\t\treturn 0, 0.0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 45.21612544513385}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(value int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\t\tn := toMax - (m * float64(fromMax))\n\t\treturn m * float64(value) + n\n\t}\n}", "CodeBleu_score": 51.339169319742375}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - (m * float64(fromMin))\n\treturn func(value int) float64 {\n\t\treturn m * float64(value) + n\n\t}\n}", "CodeBleu_score": 49.30472869421901}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(input int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\t\tn := toMin - (m * float64(fromMin))\n\t\treturn m * float64(input) + n\n\t}\n}", "CodeBleu_score": 51.7490371134}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\ts := &GrovePiezoVibrationSensorDriver{\n\t\tname:       gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tpin:        pin,\n\t\tanalogRead: a,\n\t\tthreshold:  1000,\n\t\tgobot.Eventer:     gobot.NewEventer(),\n\t\tgobot.Publisher:   gobot.NewPublisher(\"Vibration\"),\n\t\tgobot.Commander:   gobot.NewCommander(),\n\t\tgobot.Connection:  gobot.NewConnection(),\n\t\tgobot.DigitalRead: gobot.NewDigitalRead(pin),\n\t}\n\n\ts.AddEvent(\"Vibration\")\n\n\ts.AddCommand(\"Threshold\", func(params map[string]interface{}) interface{} {\n\t\tif val, ok := params[\"Threshold\"]; ok {\n\t\t\ts.Threshold(val.(int))\n\t\t\treturn nil\n\t\t}\n\t\treturn s.Threshold()\n\t})\n\n\ts.AddCommand(\"Read\", func(params map[string]interface{}) interface{} {\n\t\treturn s.Read()\n\t})\n\n\ts.AddCommand(\"Name\", func(params map[string]interface{}) interface{} {\n\t\tif val, ok := params[\"Name\"]; ok {\n\t\t\ts.SetName(val.(string))\n\t\t\treturn nil\n\t\t}\n\t\treturn s.Name()\n\t})\n\n\ts.AddCommand(\"Connection\", func(params map[string]interface{}) interface{} {\n\t\tif val, ok := params[\"Connection\"]; ok {\n\t\t\ts.SetConnection(val.(gobot.Connection))\n\t\t\treturn nil\n\t\t}\n\t\treturn s.Connection()\n\t})\n\n\ts.AddCommand(\"Start\", func(params map[string]interface{}) interface{} {\n\t\ts.Start()\n\t\treturn nil\n\t})\n\n\ts.AddCommand(\"Halt\", func(params map[string]interface{}) interface{} {\n\t\ts.Halt()\n\t\treturn nil\n", "CodeBleu_score": 30.826587938269935}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:   \"GrovePiezoVibrationSensor\",\n\t\tpin:    pin,\n\t\treader: a,\n\t\tthreshold: 1000,\n\t\tinterval: 100 * time.Millisecond,\n\t}\n\n\td.AddEvent(\"vibration\")\n\n\tif err := d.SetEvent(d.vibrationEvent); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 39.5762644749743}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:       gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tpin:        pin,\n\t\tanalogRead: a,\n\t\tthreshold:  1000,\n\t\tvibrating:  false,\n\t\tvibration:  gobot.DefaultName(\"Vibration\"),\n\t\tgobot.Eventer:         eventer{make(map[string][]gobot.Listener)},\n\t\tgobot.Publisher:       NewGrovePiezoVibrationSensorPublisher(),\n\t\tgobot.DigitalReader:   NewGrovePiezoVibrationSensorReader(),\n\t\tgobot.AnalogReader:    NewGrovePiezoVibrationSensorAnalogReader(),\n\t\tgobot.DigitalWriter:   NewGrovePiezoVibrationSensorWriter(),\n\t\tgobot.AnalogWriter:    NewGrovePiezoVibrationSensorAnalogWriter(),\n\t\tgobot.DigitalPwmWriter: NewGrovePiezoVibrationSensorPwmWriter(),\n\t}\n\n\td.AddEvent(\"Vibration\")\n\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase gobot.Name:\n\t\t\td.SetName(opt.(gobot.Name))\n\t\tcase gobot.AnalogPin:\n\t\t\td.pin = opt.(gobot.AnalogPin)\n\t\tcase gobot.DigitalPin:\n\t\t\td.pin = opt.(gobot.DigitalPin)\n\t\tcase gobot.AnalogThreshold:\n\t\t\td.threshold = opt.(gobot.AnalogThreshold)\n\t\t}\n\t}\n\n\td.AddEvent(\"Vibration\")\n\n\tif err := d.SetPin(d.pin); err != nil {\n\t\tpanic(err)\n\t}\n\n\td.AddEvent(\"Vibration\")\n\n\tif err := d.SetThreshold(d.threshold", "CodeBleu_score": 38.47300181053317}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// calculate the tone period\n\tperiod := 1000000 / (hz * d.BPM)\n\t// calculate the duration in milliseconds\n\tduration = duration * 1000\n\t// calculate the number of periods\n\tperiods := duration / period\n\t// calculate the time between periods\n\tinterval := duration / periods\n\t// create a channel to handle the buzzer's pulses\n\tpulses := make(chan bool)\n\t// create a channel to handle the buzzer's errors\n\terrors := make(chan error)\n\t// start a goroutine to handle the buzzer's pulses\n\tgo func() {\n\t\tfor i := 0; i < int(periods); i++ {\n\t\t\t// toggle the buzzer on\n\t\t\tif err := d.Toggle(); err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// wait for the interval\n\t\t\ttime.Sleep(time.Duration(interval) * time.Millisecond)\n\t\t\t// toggle the buzzer off\n\t\t\tif err := d.Toggle(); err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// wait for the interval\n\t\t\ttime.Sleep(time.Duration(interval) * time.Millisecond)\n\t\t}\n\t\t// close the pulses channel\n\t\tclose(pulses)\n\t}()\n\t// wait for the pulses to complete\n\t<-pulses\n\t// wait for the errors to complete\n\tif err := <-errors; err != nil {\n\t\treturn err\n\t}\n\t// return no error\n\treturn nil\n}", "CodeBleu_score": 43.7528874879018}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period\n\tperiod := 1.0 / (hz * (60.0 / d.beatsPerMinute))\n\n\t// Calculate the tone duration\n\tduration = duration / (60.0 / d.beatsPerMinute)\n\n\t// Toggle the buzzer on and off for the duration of the tone\n\tfor i := 0.0; i < duration; i++ {\n\t\t// Toggle the buzzer on\n\t\tif err := d.toggleOn(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(period * 1000))\n\n\t\t// Toggle the buzzer off\n\t\tif err := d.toggleOff(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(period * 1000))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.60554221504324}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.isClosed {\n\t\treturn fmt.Errorf(\"buzzer is closed\")\n\t}\n\n\tif err := d.setPinMode(gpioPinOutput); err != nil {\n\t\treturn err\n\t}\n\n\t// Calculate the tone period (in microseconds) based on the given frequency and the tempo.\n\tperiod := 1000000 / (hz * d.beatsPerMinute)\n\n\t// Calculate the duration (in microseconds) based on the given duration and the tempo.\n\tduration = duration * 1000000 / (d.beatsPerMinute * 60)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period.\n\tfor i := 0; i < int(duration); i += int(period) {\n\t\tif err := d.setPinValue(gpioPinValueHigh); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Microsecond * time.Duration(period))\n\t\tif err := d.setPinValue(gpioPinValueLow); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Microsecond * time.Duration(period))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 37.313223117307494}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\n\td.stop()\n\n\td.sleepPin.Set(gpio.Low)\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 30.26193927414813}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.SleepPin == 0 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stop()\n\td.sleeping = true\n\td.sleepPin.DigitalWrite(gobot.Low)\n\treturn nil\n}", "CodeBleu_score": 27.59478791774618}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stop()\n\td.sleeping = true\n\td.connection.DigitalWrite(d.sleepPin, 0)\n\treturn nil\n}", "CodeBleu_score": 28.546545405910496}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpath, params, err := a.analogPinPathAndParams(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp := &analogPin{\n\t\tname:     id,\n\t\tpath:     path,\n\t\tparams:   params,\n\t\tadaptor:  a,\n\t\treadings: make(chan float64, 10),\n\t}\n\ta.pins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 52.93790975620979}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, err := a.analogPinPath(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin, err := a.newAnalogPin(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 51.021138950992}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.pinsMutex.Lock()\n\tdefer a.pinsMutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, err := a.analogPath(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := NewAnalogPin(a, path, id)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 51.84749362080484}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.DigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 65.52304060066496}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tp, err := a.getDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn p.Write(val)\n}", "CodeBleu_score": 61.2998082985339}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, ok := a.digitalPins[id]\n\tif !ok {\n\t\treturn fmt.Errorf(\"DigitalPinsAdaptor.DigitalWrite: invalid pin: %s\", id)\n\t}\n\n\tif err := pin.Out(val); err != nil {\n\t\treturn fmt.Errorf(\"DigitalPinsAdaptor.DigitalWrite: %s\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 52.97815730660792}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.digitalPins) == 0 {\n\t\treturn nil, fmt.Errorf(\"digitalPinsAdaptor.digitalPin: no pins connected\")\n\t}\n\n\tpin, ok := a.digitalPins[id]\n\tif !ok {\n\t\t// Translate the ID to obtain chip and line information.\n\t\tchip, line, err := a.digitalPinTranslate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Create a new digital pin.\n\t\tpin = &DigitalPin{\n\t\t\tchip:  chip,\n\t\t\tline:  line,\n\t\t\tstate: gpio.Low,\n\t\t\topts:  opts,\n\t\t}\n\n\t\t// Initialize the digital pin.\n\t\tif err := a.digitalPinInit(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Store the digital pin.\n\t\ta.digitalPins[id] = pin\n\t} else {\n\t\t// Apply the provided options to the digital pin.\n\t\tfor _, opt := range opts {\n\t\t\tif !opt(pin) {\n\t\t\t\treturn nil, fmt.Errorf(\"digitalPinsAdaptor.digitalPin: invalid option\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the configured digital pin.\n\treturn pin, nil\n}", "CodeBleu_score": 55.04951607130304}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.digitalPins) == 0 {\n\t\treturn nil, fmt.Errorf(\"digitalPin: No pins configured on adaptor\")\n\t}\n\n\tpin, err := a.digitalPinByID(id, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 23.858178083707642}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.digitalPins) == 0 {\n\t\treturn nil, fmt.Errorf(\"No pins found\")\n\t}\n\tfor _, pin := range a.digitalPins {\n\t\tif pin.ID() == id {\n\t\t\tfor _, opt := range opts {\n\t\t\t\tif !opt(pin) {\n\t\t\t\t\treturn nil, fmt.Errorf(\"Failed to apply option to pin %v\", id)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pin, nil\n\t\t}\n\t}\n\tpin, err := a.newDigitalPin(id, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.digitalPins = append(a.digitalPins, pin)\n\treturn pin, nil\n}", "CodeBleu_score": 44.27173139782076}]}
