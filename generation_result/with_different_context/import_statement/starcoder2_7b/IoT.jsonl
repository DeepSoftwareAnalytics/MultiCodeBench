{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc = NULL;\n\tuint8_t desc_len = desc->bLength;\n\n\twhile (desc_len) {\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc_len);\n\t\tdesc_len = next_desc->bLength;\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn next_desc;\n}", "CodeBleu_score": 40.268391284570704}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_type;\n\tuint8_t desc_len;\n\tuint8_t desc_len_tmp;\n\n\twhile (desc!= NULL) {\n\t\tdesc_type = desc->bDescriptorType;\n\t\tdesc_len = desc->bLength;\n\t\tif (desc_type == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\n\t\tif (desc_len <= 2) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdesc_len_tmp = desc_len;\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc +\n\t\t\t\tdesc_len_tmp);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 43.44389163964683}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len = desc->bLength;\n\twhile (desc_len) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc_len = desc->bLength;\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc_len);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 38.073925010970655}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\t// Check if there is a valid configuration\n\tif (usb_configuration == 0) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is within bounds\n\tif (iface_num >= usb_configuration->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the descriptors\n\tfor (uint8_t i = 0; i < usb_configuration->bNumInterfaces; i++) {\n\t\t// Check if the current descriptor is an interface descriptor\n\t\tif (usb_configuration->interface[i].bDescriptorType == USB_DESCRIPTOR_TYPE_INTERFACE) {\n\t\t\t// Check if the interface number and setting number match\n\t\t\tif (usb_configuration->interface[i].bInterfaceNumber == iface_num && usb_configuration->interface[i].bAlternateSetting == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no matching interface descriptor is found, return false\n\treturn false;\n}", "CodeBleu_score": 35.09581185885563}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t i;\n\tuint8_t *p_desc;\n\tuint8_t desc_len;\n\tuint8_t desc_type;\n\tuint8_t desc_subtype;\n\n\tif (g_usb_cfg_desc.bNumInterfaces == 0) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= g_usb_cfg_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tp_desc = (uint8_t *) g_usb_cfg_desc.bConfigurationValue;\n\tdesc_len = g_usb_cfg_desc.wTotalLength;\n\n\tfor (i = 0; i < g_usb_cfg_desc.bNumInterfaces; i++) {\n\t\tif (p_desc[0] == USB_DTYPE_INTERFACE) {\n\t\t\tdesc_type = p_desc[1];\n\t\t\tdesc_subtype = p_desc[2];\n\t\t\tif ((desc_type == USB_DTYPE_INTERFACE) && (desc_subtype == USB_DTYPE_INTERFACE_DESC)) {\n\t\t\t\tif (p_desc[3] == iface_num) {\n\t\t\t\t\tif (p_desc[4] == setting_num) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp_desc += p_desc[0];\n\t\tdesc_len -= p_desc[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 43.77881989545511}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\t// Check if there is a valid configuration\n\tif (usb_configuration == 0) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is within bounds\n\tif (iface_num >= usb_configuration->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the descriptors, starting from the beginning of the configuration descriptor\n\tuint8_t* desc = (uint8_t*) usb_configuration;\n\twhile (desc < (uint8_t*) usb_configuration + usb_configuration->wTotalLength) {\n\t\t// Check if the descriptor is an interface descriptor\n\t\tif (desc[1] == USB_DT_INTERFACE) {\n\t\t\t// Check if the interface number and setting number match\n\t\t\tif (desc[2] == iface_num && desc[3] == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Move to the next descriptor\n\t\tdesc += desc[0];\n\t}\n\n\t// No matching interface descriptor found\n\treturn false;\n}", "CodeBleu_score": 35.480635565294776}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = (uint8_t) usb_setup_packet.wIndex;\n\tuint8_t ep_dir = (uint8_t) (ep_num & 0x80);\n\tuint8_t ep_num_in_dir = (uint8_t) (ep_num & 0x7F);\n\n\tif (usb_setup_packet.wLength!= 2) {\n\t\treturn false;\n\t}\n\n\tuint16_t ep_status = 0;\n\n\tif (ep_dir == USB_DIR_IN) {\n\t\tep_status = udc_ep_in_status[ep_num_in_dir];\n\t} else {\n\t\tep_status = udc_ep_out_status[ep_num_in_dir];\n\t}\n\n\tif (ep_status & USB_EP_HALT) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\tusb_response_payload[0] = (uint8_t) (ep_status & 0xFF);\n\tusb_response_payload[1] = (uint8_t) ((ep_status >> 8) & 0xFF);\n\n\treturn true;\n}", "CodeBleu_score": 42.06127388069783}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (req_length!= sizeof(uint8_t)) {\n\t\treturn false;\n\t}\n\n\tuint8_t ep_status = 0;\n\tif (hal_usb_ep_is_halted(ep_addr)) {\n\t\tep_status = 1;\n\t}\n\n\tmemcpy(req_payload, &ep_status, sizeof(ep_status));\n\n\treturn true;\n}", "CodeBleu_score": 22.266028398591132}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = (uint8_t) (g_req.wValue >> 8);\n\tuint8_t ep_dir = (uint8_t) (g_req.wValue & 0x80);\n\tuint8_t ep_type = (uint8_t) (g_req.wIndex >> 8);\n\tuint8_t ep_status;\n\tuint8_t *ep_status_ptr;\n\tbool status;\n\n\tif (g_req.wLength!= 1) {\n\t\treturn false;\n\t}\n\n\tif ((ep_num == 0) || (ep_num > 15)) {\n\t\treturn false;\n\t}\n\n\tif ((ep_type == 0) || (ep_type > 3)) {\n\t\treturn false;\n\t}\n\n\tif (ep_dir == 0) {\n\t\tep_status = (uint8_t) (udc_ep_in_status(ep_num, ep_type) & 0x01);\n\t} else {\n\t\tep_status = (uint8_t) (udc_ep_out_status(ep_num, ep_type) & 0x01);\n\t}\n\n\tep_status_ptr = (uint8_t *) (g_req.wValue & 0xFF);\n\t*ep_status_ptr = ep_status;\n\n\tstatus = true;\n\n\treturn status;\n}", "CodeBleu_score": 41.79798929305177}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tif (udc_state!= UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\tif (setup.wIndex > udc_config.bNumInterfaces) {\n\t\treturn false;\n\t}\n\tudc_iface_desc.bAlternateSetting = 0;\n\tif (!udc_iface_desc_set()) {\n\t\treturn false;\n\t}\n\tudc_iface_desc.bAlternateSetting = setup.wValueL;\n\tif (!udc_iface_desc_set()) {\n\t\treturn false;\n\t}\n\treturn udc_iface_setup_handler();\n}", "CodeBleu_score": 40.25501272114479}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t bInterfaceNumber = 0;\n\tuint8_t bAlternateSetting = 0;\n\tbool bInterfaceValid = false;\n\tbool bAlternateSettingValid = false;\n\tbool bStatus = false;\n\n\tif (usb_dev_state!= USB_DEV_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\n\tbInterfaceNumber = usb_setup.wIndex & 0xFF;\n\tbAlternateSetting = (usb_setup.wIndex >> 8) & 0xFF;\n\n\tfor (uint8_t i = 0; i < usb_dev_desc.bNumConfigurations; i++) {\n\t\tif (usb_dev_desc.pConfiguration[i].bInterfaceNumber == bInterfaceNumber) {\n\t\t\tbInterfaceValid = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bInterfaceValid) {\n\t\tfor (uint8_t i = 0; i < usb_dev_desc.pConfiguration[0].bNumInterfaces; i++) {\n\t\t\tif (usb_dev_desc.pConfiguration[0].pInterface[i].bInterfaceNumber == bInterfaceNumber) {\n\t\t\t\tfor (uint8_t j = 0; j < usb_dev_desc.pConfiguration[0].pInterface[i].bNumAltSetting; j++) {\n\t\t\t\t\tif (usb_dev_desc.pConfiguration[0].pInterface[i].pAltSetting[j].bAlternateSetting == bAlternateSetting) {\n\t\t\t\t\t\tbAlternateSettingValid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bAlternateSettingValid) {\n\t\tbStatus = true;\n\t\tusb_dev_desc.pConfiguration[0].pInterface[0].pAltSetting[0].pEndpoint[0].bEndpointAddress = 0x81;\n\t\tusb_dev_desc.pConfiguration[0].pInterface[0].pAltSetting[0].pEndpoint[0].bEndpointSize = 8;\n\t\tusb_dev_desc.pConfiguration[0].pInterface[0].pAltSetting[0].pEndpoint[0].bEndpointType = USB_EP_TYPE_INTERRUPT;\n\t\tusb_dev_desc.pConfiguration[0].", "CodeBleu_score": 29.249828151354006}, {"code": "static bool udc_req_iface(void){\n\t\tbool res = true;\n\tuint8_t ifnum = (uint8_t) (g_setup_pkt.wIndex & 0xFF);\n\tuint8_t alt = (uint8_t) (g_setup_pkt.wValue & 0xFF);\n\n\tif (g_dev_state!= UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\n\tif (ifnum >= g_dev_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t/* update the interface descriptor */\n\tg_if_desc[ifnum].bAlternateSetting = alt;\n\tres = udc_update_if_desc(ifnum);\n\n\tif (res) {\n\t\t/* update the current alternate setting */\n\t\tg_cur_alt_setting[ifnum] = alt;\n\t}\n\n\t/* forward the SETUP request to the corresponding UDI handler */\n\tif (res) {\n\t\tres = udc_req_iface_setup(ifnum);\n\t}\n\n\treturn res;\n}", "CodeBleu_score": 46.91599900583717}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\tudi_msc_cbw_state = UDI_MSC_CBW_ST_CBW_RECEIVED;\n\tudi_msc_data_state = UDI_MSC_DATA_ST_CBW_RECEIVED;\n\tudi_msc_state = UDI_MSC_ST_CBW_RECEIVED;\n\tudi_msc_cbw_data_ptr = NULL;\n\tudi_msc_cbw_data_size = 0;\n\tudi_msc_cbw_lun = 0;\n\tudi_msc_cbw_cb_length = 0;\n\tudi_msc_cbw_cb_signature = 0;\n\tudi_msc_cbw_cb_tag = 0;\n\tudi_msc_cbw_cb_lun = 0;\n\tudi_msc_cbw_cb_flags = 0;\n\tudi_msc_cbw_cb_length = 0;\n\tudi_msc_cbw_cb_lun = 0;\n\tudi_msc_cbw_cb_flags = 0;\n\tudi_msc_cbw_cb_length = 0;\n\tudi_msc_cbw_cb_lun = 0;\n\tudi_msc_cbw_cb_flags = 0;\n\tudi_msc_cbw_cb_length = 0;\n\tudi_msc_cbw_cb_lun = 0;\n\tudi_msc_cbw_cb_flags = 0;\n\tudi_msc_cbw_cb_length = 0;\n\tudi_msc_cbw_cb_lun = 0;\n\tudi_msc_cbw_cb_flags = 0;\n\tudi_msc_cbw_cb_length = 0;\n\tudi_msc_cbw_cb_lun = 0;\n\tudi_msc_cbw_cb_flags = 0;\n\tudi_msc_cbw_cb_length = 0;\n\tudi_msc_cbw_cb_lun = 0;\n\tudi_msc_cbw_cb_flags = 0;\n\tudi_msc_cbw_cb_length = 0;\n\tudi_msc_cbw_cb_", "CodeBleu_score": 28.51743494171865}, {"code": "bool udi_msc_enable(void){\n\t\tudi_msc_cbw_state_t cbw_state;\n\tudi_msc_cbw_t *cbw;\n\tuint8_t lun;\n\tbool lun_found;\n\tbool enable_result;\n\n\t/* Retrieve the number of LUNs */\n\tudi_msc_nb_lun = udi_msc_get_nb_lun();\n\t/* If no LUNs are available or if the external enable function fails */\n\tif (udi_msc_nb_lun == 0 ||!udi_msc_enable_ext()) {\n\t\treturn false;\n\t}\n\t/* Initialize the MSC process */\n\tudi_msc_cbw_state = UDI_MSC_CBW_STATE_IDLE;\n\tudi_msc_cbw_data_len = 0;\n\tudi_msc_cbw_data_ptr = NULL;\n\tudi_msc_cbw_tag = 0;\n\tudi_msc_cbw_lun = 0;\n\tudi_msc_cbw_cb_length = 0;\n\tudi_msc_cbw_cb_signature = 0;\n\tudi_msc_cbw_cb_lun = 0;\n\tudi_msc_cbw_cb_data_transfer_length = 0;\n\tudi_msc_cbw_cb_data_transfer_direction = 0;\n\tudi_msc_cbw_cb_data_transfer_length_msb = 0;\n\tudi_msc_cbw_cb_data_transfer_length_lsb = 0;\n\tudi_msc_cbw_cb_data_transfer_length_lsb_msb = 0;\n\tudi_msc_cbw_cb_data_transfer_length_lsb_msb_msb = 0;\n\tudi_msc_cbw_cb_data_transfer_length_lsb_msb_msb_msb = 0;\n\tudi_msc_cbw_cb_data_transfer_length_lsb_msb_msb_msb_msb = 0;\n\tudi_msc_cbw_cb_data_transfer_length_lsb_msb_msb_msb_msb_msb", "CodeBleu_score": 21.638289402337314}, {"code": "bool udi_msc_enable(void){\n\t\tbool result = true;\n\n\tudi_msc_cbw_received = false;\n\tudi_msc_cbw_data_received = false;\n\tudi_msc_cbw_data_sent = false;\n\tudi_msc_cbw_data_received_in_progress = false;\n\tudi_msc_cbw_data_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error = false;\n\tudi_msc_cbw_data_transfer_error_sent = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress = false;\n\tudi_msc_cbw_data_transfer_error_sent_in_progress =", "CodeBleu_score": 13.871342518367339}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\tudi_msc_cbw_reset();\n\t\treturn;\n\t}\n\n\tudi_msc_cbw.data_residue -= nb_sent;\n\tif (udi_msc_cbw.data_residue == 0) {\n\t\tudi_msc_cbw_process();\n\t}\n}", "CodeBleu_score": 51.70471825496805}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\tudi_msc_cbw_reset();\n\t\treturn;\n\t}\n\tudi_msc_cbw.data_residue -= nb_sent;\n\tudi_msc_process_csw(ep);\n}", "CodeBleu_score": 55.707138099728425}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\t(void) ep;\n\t(void) status;\n\n\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\tudi_msc_cbw_reset();\n\t} else {\n\t\tudi_msc_sense_data_update(nb_sent);\n\t\tudi_msc_csw_data_update(nb_sent);\n\t}\n}", "CodeBleu_score": 53.2014621141388}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\t/* Check if there is a non-zero data residue */\n\tif (udi_msc_csw.residue) {\n\t\t/* Stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW) */\n\t\tif (udi_msc_cbw.data_transfer_direction == UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\tudi_msc_stall_in_endpoint(udi_msc_cbw.cbw.tag);\n\t\t} else {\n\t\t\tudi_msc_stall_out_endpoint(udi_msc_cbw.cbw.tag);\n\t\t}\n\n\t\t/* Prepare the CSW by setting its tag and converting the data residue to little-endian format */\n\t\tudi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n\t\tudi_msc_csw.tag = udi_msc_cbw.cbw.tag;\n\t\tudi_msc_csw.residue = udi_msc_csw.residue;\n\t\tudi_msc_csw.status = UDI_MSC_CSW_STATUS_FAIL;\n\n\t\t/* Send the CSW */\n\t\tudi_msc_send_csw();\n\t} else {\n\t\t/* Prepare the CSW by setting its tag and status */\n\t\tudi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n\t\tudi_msc_csw.tag = udi_msc_cbw.cbw.tag;\n\t\tudi_msc_csw.residue = 0;\n\t\tudi_msc_csw.status = UDI_MSC_CSW_STATUS_PASS;\n\n\t\t/* Send the CSW */\n\t\tudi_msc_send_csw();\n\t}\n}", "CodeBleu_score": 40.05926992823553}, {"code": "static void udi_msc_csw_process(void){\n\t\t// If there is a non-zero data residue\n\tif (udi_msc_csw.residue) {\n\t\t// If the data residue is greater than the maximum packet size\n\t\tif (udi_msc_csw.residue > UDI_MSC_MAX_PACKET_SIZE) {\n\t\t\t// Stall the next request from the USB host on the appropriate endpoint\n\t\t\tudi_msc_stall_endpoint(udi_msc_csw.tag, UDI_MSC_EP_DIR_IN);\n\t\t}\n\t\t// Prepare the CSW\n\t\tudi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n\t\tudi_msc_csw.tag = udi_msc_csw.tag;\n\t\tudi_msc_csw.residue = udi_msc_csw.residue;\n\t\tudi_msc_csw.status = UDI_MSC_CSW_STATUS_OK;\n\t\t// Send the CSW\n\t\tudi_msc_send_csw();\n\t}\n}", "CodeBleu_score": 48.707151845631564}, {"code": "static void udi_msc_csw_process(void){\n\t\t// Get the data residue\n\tuint32_t data_residue = udi_msc_get_data_residue();\n\n\t// If there is a non-zero data residue\n\tif (data_residue!= 0) {\n\t\t// Stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW)\n\t\tudi_msc_stall_next_request(udi_msc_get_cbw_dir());\n\n\t\t// Prepare the CSW\n\t\tudi_msc_prepare_csw();\n\n\t\t// Send the CSW\n\t\tudi_msc_send_csw();\n\t}\n}", "CodeBleu_score": 10.627117890174704}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_PORT_COUNT) {\n\t\treturn;\n\t}\n\n\tif (b_enable) {\n\t\tusb_task_cdc_dtr_set(port);\n\t\tif (usb_task_cdc_dtr_rate_get(port) == 1200) {\n\t\t\tusb_task_cdc_dtr_rate_set(port, 0);\n\t\t\tusb_task_cdc_dtr_rate_set(port, 1200);\n\t\t}\n\t} else {\n\t\tusb_task_cdc_dtr_set(port, false);\n\t\tif (usb_task_cdc_dtr_rate_get(port) == 1200) {\n\t\t\tusb_task_cdc_dtr_rate_set(port, 0);\n\t\t\tusb_task_cdc_dtr_rate_set(port, 1200);\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.72709101978603}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\t// If the DTR rate is 1200, schedule a delayed system reset.\n\t\tif (cdc_dtr_rate[port] == 1200) {\n\t\t\tcdc_dtr_rate[port] = 0;\n\t\t\tcdc_dtr_status[port] = true;\n\t\t\tinitiateReset();\n\t\t}\n\t\telse {\n\t\t\t// If the DTR rate is not 1200, enable the DTR signal.\n\t\t\tcdc_dtr_status[port] = true;\n\t\t}\n\t}\n\telse {\n\t\t// Disable the DTR signal.\n\t\tcdc_dtr_status[port] = false;\n\n\t\t// If the DTR rate is 1200, schedule a delayed system reset.\n\t\tif (cdc_dtr_rate[port] == 1200) {\n\t\t\tcdc_dtr_rate[port] = 0;\n\t\t\tcdc_dtr_status[port] = true;\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 35.15144139945804}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\t// If the DTR signal is enabled, cancel any scheduled reset\n\t\tcancelReset();\n\t} else {\n\t\t// If the DTR signal is disabled, check if the DTR rate is 1200\n\t\tif (cdc_dtr_rate == 1200) {\n\t\t\t// If the DTR rate is 1200, schedule a reset\n\t\t\tscheduleReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 24.552562465610468}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tbool handled = false;\n\tuint8_t *ptr = NULL;\n\tuint16_t size = 0;\n\n\tif (usb_request.bmRequestType == 0x21) {\n\t\tif (usb_request.bRequest == 0x04) {\n\t\t\tptr = (uint8_t *) &usb_id_descriptor;\n\t\t\tsize = sizeof(usb_id_descriptor);\n\t\t\thandled = true;\n\t\t} else if (usb_request.bRequest == 0x05) {\n\t\t\tptr = (uint8_t *) &usb_extended_descriptor;\n\t\t\tsize = sizeof(usb_extended_descriptor);\n\t\t\thandled = true;\n\t\t}\n\t}\n\n\tif (handled) {\n\t\tusb_request.wLength = size;\n\t\tusb_request.wIndex = 0;\n\t\tusb_request.wValue = 0;\n\t\tusb_request.data = ptr;\n\t}\n\n\treturn handled;\n}", "CodeBleu_score": 33.06369311351267}, {"code": "bool usb_task_other_requests(void){\n\t\t// Check the request type\n\tif (USB_setup.bmRequestType == 0x21) {\n\t\t// Check the request index\n\t\tif (USB_setup.bRequest == 0x04) {\n\t\t\t// Set up pointers and sizes for Microsoft-compatible ID and extended properties descriptors\n\t\t\tUSB_data_ptr = (uint8_t *) &USB_string_descriptor_microsoft_compatible_id;\n\t\t\tUSB_data_size = sizeof(USB_string_descriptor_microsoft_compatible_id);\n\t\t} else if (USB_setup.bRequest == 0x05) {\n\t\t\t// Set up pointers and sizes for Microsoft-compatible ID and extended properties descriptors\n\t\t\tUSB_data_ptr = (uint8_t *) &USB_string_descriptor_microsoft_compatible_id;\n\t\t\tUSB_data_size = sizeof(USB_string_descriptor_microsoft_compatible_id);\n\t\t} else {\n\t\t\t// Request index is not recognized\n\t\t\treturn false;\n\t\t}\n\n\t\t// Update the control request payload and size accordingly\n\t\tUSB_setup.wLength = USB_data_size;\n\t\treturn true;\n\t}\n\n\t// Request type is not recognized\n\treturn false;\n}", "CodeBleu_score": 20.806711322728123}, {"code": "bool usb_task_other_requests(void){\n\t\tswitch (usb_request_index) {\n\t\tcase 0x04:\n\t\t\tusb_request_payload_size = usb_id_descriptor_size;\n\t\t\tusb_request_payload = usb_id_descriptor;\n\t\t\treturn true;\n\t\tcase 0x05:\n\t\t\tusb_request_payload_size = usb_extended_descriptor_size;\n\t\t\tusb_request_payload = usb_extended_descriptor;\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}", "CodeBleu_score": 16.053334631347507}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\n\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPI1_DR = 0;\n\t\twhile ((SPI1_SR & SPI_SR_RXNE) == 0);\n\t\tbuf[i] = SPI1_DR;\n\t}\n\n\tSPI1_DR = 0;\n\twhile ((SPI1_SR & SPI_SR_RXNE) == 0);\n\tbuf[i] = SPI1_DR;\n\n\tspiRec(buf[i]);\n}", "CodeBleu_score": 42.35841107139855}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint8_t i;\n\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPI0_D = 0xFF;\n\t\twhile (!(SPI0_S & SPI_S_SPRF_MASK));\n\t\tbuf[i] = SPI0_D;\n\t}\n\tSPI0_D = 0xFF;\n\twhile (!(SPI0_S & SPI_S_SPRF_MASK));\n\tbuf[nbyte - 1] = SPI0_D;\n}", "CodeBleu_score": 44.34037381836871}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint8_t i;\n\n\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nbyte; i++) {\n\t\tspiSend(0);\n\t\twhile (!(SPSR & (1 << SPIF)));\n\t\tbuf[i] = SPDR;\n\t}\n\n\tspiSend(0);\n\twhile (!(SPSR & (1 << SPIF)));\n\tbuf[nbyte] = SPDR;\n}", "CodeBleu_score": 50.719925416565225}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *pVectorTable;\n\tuint32_t *pVectorTable_relocated;\n\tuint32_t *pVectorTable_backup;\n\tuint32_t *pVectorTable_backup_relocated;\n\tuint32_t *pVectorTable_backup_relocated_end;\n\tuint32_t *pVectorTable_relocated_end;\n\tuint32_t *pVectorTable_end;\n\tuint32_t *pVectorTable_end_backup;\n\tuint32_t *pVectorTable_end_backup_relocated;\n\tuint32_t *pVectorTable_end_relocated;\n\tuint32_t *pVectorTable_end_relocated_end;\n\n\tpVectorTable = (uint32_t *)__vector_table;\n\tpVectorTable_relocated = (uint32_t *)__vector_table_relocated;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Retrieve the current handler for the specified IRQ\n\toldHandler = (pfnISR_Handler)pVectorTable_relocated[irq];\n\n\t// Replace the handler with the new handler\n\tpVectorTable_relocated[irq] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\treturn oldHandler;\n}", "CodeBleu_score": 42.728788851418884}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler = 0;\n\tif (irq < 32) {\n\t\toldHandler = (pfnISR_Handler) *(&__VECTOR_TABLE + irq);\n\t\t*(&__VECTOR_TABLE + irq) = (uint32_t) newHandler;\n\t}\n\treturn oldHandler;\n}", "CodeBleu_score": 44.373006732965194}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *vectorTable = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr2 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr3 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr4 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr5 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr6 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr7 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr8 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr9 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr10 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr11 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr12 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr13 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr14 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr15 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr16 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr17 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr18 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr19 = (uint32_t *)0x0;\n\tuint32_t *vectorTableAddr20 = (uint3", "CodeBleu_score": 6.201765019902052}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\treturn -1;\n}", "CodeBleu_score": 3.463852886057403}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (CDC_IsConnected()) {\n\t\tif (CDC_IsRxReady()) {\n\t\t\treturn CDC_ReadChar();\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n}", "CodeBleu_score": 9.701257911456326}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (CDC_IsConnected()) {\n\t\tif (CDC_IsRxReady()) {\n\t\t\treturn CDC_Receive_DATA();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 8.362270658039623}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char) {\n\t\tint c = pending_char;\n\t\tpending_char = 0;\n\t\treturn c;\n\t}\n\tif (usb_cdc_enabled) {\n\t\tif (usb_cdc_available()) {\n\t\t\treturn usb_cdc_read();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 35.84833180933822}, {"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(MARLIN_USB_SERIAL)\n  if (pending) {\n    char c = pending;\n    pending = 0;\n    return c;\n  }\n  if (!usb_cdc_enabled ||!usb_cdc_configured) return -1;\n  if (usb_cdc_available() > 0) {\n    char c = usb_cdc_read();\n    if (emergency_parser && c == emergency_parser->get_trigger_char()) {\n      emergency_parser->parse(c);\n      return -1;\n    }\n    return c;\n  }\n  return -1;\n#else\n  return -1;\n#endif\n}", "CodeBleu_score": 51.256727496649916}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char) {\n\t\tchar c = pending_char;\n\t\tpending_char = 0;\n\t\treturn c;\n\t}\n\tif (usb_cdc_enabled && usb_cdc_configured) {\n\t\tif (usb_cdc_available()) {\n\t\t\treturn usb_cdc_read();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 36.121907714435544}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t#if defined(USBCON)\n  return (CDC_Serial.available());\n#else\n  return 0;\n#endif\n}", "CodeBleu_score": 28.767405783470146}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (cdc_enabled) {\n\t\tif (cdc_enabled && cdc_connected) {\n\t\t\treturn cdc_rx_buffer.available();\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn serial_rx_buffer.available();\n\t}\n}", "CodeBleu_score": 38.08102313725153}, {"code": "int MarlinSerialUSB::available(){\n\t\treturn (CDC_IsConnected() && CDC_Receive(&rx_buffer, 1))? 1 : 0;\n}", "CodeBleu_score": 12.321972144568644}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tint i;\n\tuint8_t v;\n\tfor (i = 0; i < size; i++) {\n\t\tif (pos >= m_size) {\n\t\t\treturn false;\n\t\t}\n\t\tv = read(pos);\n\t\tif (writing) {\n\t\t\t*value++ = v;\n\t\t}\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, v);\n\t\t}\n\t\tpos++;\n\t}\n\treturn true;\n}", "CodeBleu_score": 47.76769115815881}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tbool result = true;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (pos >= _size) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (writing) {\n\t\t\tvalue[i] = _data[pos];\n\t\t}\n\t\tif (crc!= nullptr) {\n\t\t\t*crc = CRC16::updateCRC(*crc, _data[pos]);\n\t\t}\n\t\tpos++;\n\t}\n\treturn result;\n}", "CodeBleu_score": 42.256503944422555}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (pos < 0) {\n\t\treturn false;\n\t}\n\tif (pos >= (int)m_data_size) {\n\t\treturn false;\n\t}\n\tif (pos + (int)size > (int)m_data_size) {\n\t\tsize = (size_t)(m_data_size - pos);\n\t}\n\tif (value!= NULL) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tuint8_t b;\n\t\t\tif (!read_data(pos, b)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (writing) {\n\t\t\t\tvalue[i] = b;\n\t\t\t}\n\t\t\tif (crc!= NULL) {\n\t\t\t\t*crc = crc16_update(*crc, b);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tuint8_t b;\n\t\t\tif (!read_data(pos, b)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (crc!= NULL) {\n\t\t\t\t*crc = crc16_update(*crc, b);\n\t\t\t}\n\t\t}\n\t}\n\tpos += (int)size;\n\treturn true;\n}", "CodeBleu_score": 40.00357951778833}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin < 0 || pin >= PIN_COUNT) {\n\t\treturn;\n\t}\n\tif (value > ((1 << res) - 1)) {\n\t\treturn;\n\t}\n\tif (freq!= PWM_FREQUENCY) {\n\t\treturn;\n\t}\n\tif (res!= 8) {\n\t\treturn;\n\t}\n\n\tif (pin_pwm_state[pin]!= NULL) {\n\t\tpin_pwm_state[pin]->value = value;\n\t} else {\n\t\tpin_pwm_state[pin] = new pin_pwm_state_t();\n\t\tpin_pwm_state[pin]->pin = pin;\n\t\tpin_pwm_state[pin]->value = value;\n\t\tpin_pwm_state[pin]->freq = freq;\n\t\tpin_pwm_state[pin]->res = res;\n\t\tpin_pwm_state[pin]->timer = NULL;\n\t\tpin_pwm_state[pin]->channel = -1;\n\t\tpin_pwm_state[pin]->next = NULL;\n\t\tpin_pwm_state[pin]->prev = NULL;\n\t\tif (pwm_state_count == 0) {\n\t\t\tpwm_state_count++;\n\t\t\tpwm_state_first = pin_pwm_state[pin];\n\t\t\tpwm_state_last = pin_pwm_state[pin];\n\t\t\tpwm_state_timer = timerBegin(0, 80, true);\n\t\t\ttimerAttachInterrupt(pwm_state_timer, &pwm_state_timer_interrupt, true);\n\t\t\ttimerWrite(pwm_state_timer, 1000000 / PWM_FREQUENCY);\n\t\t\ttimerAlarmEnable(pwm_state_timer);\n\t\t} else {\n\t\t\tpwm_state_count++;\n\t\t\tpin_pwm_state[pin]->prev = pwm_state_last;\n\t\t\tpwm_state_last->next = pin_pwm_state[pin];\n\t\t\tpwm_state_last = pin_pwm_state[pin];\n\t\t}\n\t}\n}", "CodeBleu_score": 40.1227157311388}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (value > (1 << res)) {\n\t\tESP_LOGW(TAG, \"analogWrite: value %d out of range 0..%d\", value, (1 << res) - 1);\n\t\treturn;\n\t}\n\tif (pin >= PIN_COUNT) {\n\t\tESP_LOGE(TAG, \"analogWrite: pin %d out of range 0..%d\", pin, PIN_COUNT - 1);\n\t\treturn;\n\t}\n\tif (freq < 1) {\n\t\tESP_LOGE(TAG, \"analogWrite: frequency %d out of range 1..%d\", freq, UINT32_MAX);\n\t\treturn;\n\t}\n\tif (res < 1 || res > 16) {\n\t\tESP_LOGE(TAG, \"analogWrite: resolution %d out of range 1..16\", res);\n\t\treturn;\n\t}\n\tif (freq > UINT32_MAX / (1 << res)) {\n\t\tESP_LOGE(TAG, \"analogWrite: frequency %d too high for resolution %d\", freq, res);\n\t\treturn;\n\t}\n\n\tif (freq!= PWM_FREQUENCY) {\n\t\tESP_LOGW(TAG, \"analogWrite: frequency %d ignored (use PWM_FREQUENCY)\", freq);\n\t}\n\n\tif (res!= PWM_RESOLUTION) {\n\t\tESP_LOGW(TAG, \"analogWrite: resolution %d ignored (use PWM_RESOLUTION)\", res);\n\t}\n\n\tif (pin < PIN_COUNT) {\n\t\tif (pin < 16) {\n\t\t\t// Hardware PWM\n\t\t\tif (freq!= PWM_FREQUENCY) {\n\t\t\t\tESP_LOGW(TAG, \"analogWrite: frequency %d ignored (use PWM_FREQUENCY)\", freq);\n\t\t\t}\n\t\t\tif (res!= PWM_RESOLUTION) {\n\t\t\t\tESP_LOGW(TAG, \"analogWrite: resolution %d ignored (use PWM_RESOLUTION)\", res);\n\t\t\t}\n\t\t\tledcWrite(pin, value);\n\t\t\treturn;\n\t\t}\n\t\t// Software PWM\n\t\tif (pin >= PIN_COUNT) {\n\t\t\tESP_LOGE(TAG, \"analogWrite: pin %d out of range ", "CodeBleu_score": 37.56476462226416}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\t// Check if pin is valid\n\tif (pin >= NUM_DIGITAL_PINS) {\n\t\treturn;\n\t}\n\n\t// Check if pin is already used for PWM\n\tif (digitalPinToPWMChannel(pin)!= -1) {\n\t\treturn;\n\t}\n\n\t// Check if pin is already used for software PWM\n\tif (pwmState[pin].active) {\n\t\treturn;\n\t}\n\n\t// Check if PWM channel is free\n\tuint8_t channel = -1;\n\tfor (uint8_t i = 0; i < PWM_CHANNELS; i++) {\n\t\tif (!pwmState[i].active) {\n\t\t\tchannel = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Check if any PWM channel is free\n\tif (channel == -1) {\n\t\treturn;\n\t}\n\n\t// Start PWM timer if needed\n\tif (pwmTimer == 0) {\n\t\t// Set timer to 80MHz\n\t\ttimer_config_t config = {\n\t\t\t.divider = 80,\n\t\t\t.counter_dir = TIMER_COUNT_UP,\n\t\t\t.counter_en = TIMER_PAUSE,\n\t\t\t.alarm_en = TIMER_ALARM_EN,\n\t\t\t.auto_reload = true,\n\t\t};\n\t\ttimer_init(TIMER_GROUP_0, TIMER_0, &config);\n\n\t\t// Set timer to 80MHz\n\t\ttimer_set_counter_value(TIMER_GROUP_0, TIMER_0, 0x00000000ULL);\n\n\t\t// Set timer alarm to 12.5MHz\n\t\ttimer_set_alarm_value(TIMER_GROUP_0, TIMER_0, 12500000ULL);\n\n\t\t// Enable timer interrupt\n\t\ttimer_enable_intr(TIMER_GROUP_0, TIMER_0);\n\t\ttimer_isr_register(TIMER_GROUP_0, TIMER_0, timer_isr, NULL, ESP_INTR_FLAG_IRAM, NULL);\n\n\t\t// Start timer\n\t\ttimer_start(TIMER_GROUP_0, TIMER_0);\n\n\t\t// Store timer reference\n\t\tpwmTimer = TIMER_0;\n\t}\n\n\t// Set PWM channel\n\tpwmState[channel].pin = pin;\n", "CodeBleu_score": 45.19956009721279}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#if defined(ARDUINO) && ARDUINO >= 100\n    static_assert(SERVO_DELAY_ARRAY_LENGTH == 8, \"SERVO_DELAY_ARRAY_LENGTH must be 8\");\n#endif\n\n    if (servo.attach(pin)) {\n        servo.write(value);\n        delay(SERVO_DELAY_ARRAY[channel]);\n\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n            servo.detach();\n        }\n    }\n}", "CodeBleu_score": 44.469029410002705}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == 8, \"SERVO_DELAY_ARRAY_LENGTH must be 8\");\n\tif (this->servo.attach(this->pin)) {\n\t\tthis->servo.write(value);\n\t\tdelay(SERVO_DELAY_ARRAY[this->channel]);\n\t\t#if DEACTIVATE_SERVOS_AFTER_MOVE == 1\n\t\t\tthis->servo.detach();\n\t\t#endif\n\t}\n}", "CodeBleu_score": 29.781564174890384}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == 4, \"The length of the servo delay array must be 4.\");\n\tif (servo.attach(SERVO_PIN, MIN_SERVO_PULSE_WIDTH, MAX_SERVO_PULSE_WIDTH)) {\n\t\tservo.write(value);\n\t\tdelay(SERVO_DELAY_ARRAY[SERVO_PIN]);\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tservo.detach();\n\t\t}\n\t}\n}", "CodeBleu_score": 48.73053540007314}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tint i;\n\tfor (i = 0; i < I2S_NUM_CHANNELS; i++) {\n\t\tif (i2s_channels[i].active) {\n\t\t\tif (i2s_channels[i].tick_count == 0) {\n\t\t\t\tif (i2s_channels[i].current_state) {\n\t\t\t\t\ti2s_channels[i].current_state = 0;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_channels[i].current_state = 1;\n\t\t\t\t}\n\t\t\t\ti2s_channels[i].tick_count = i2s_channels[i].tick_period;\n\t\t\t} else {\n\t\t\t\ti2s_channels[i].tick_count--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < I2S_NUM_CHANNELS; i++) {\n\t\ti2s_channels[i].port_data |= i2s_channels[i].current_state << i;\n\t}\n\ti2s_dma_buffer[i2s_dma_buffer_pos] = i2s_channels[0].port_data;\n\ti2s_dma_buffer_pos++;\n}", "CodeBleu_score": 32.59844415032693}, {"code": "void i2s_push_sample(){\n\t\tfor (uint8_t i = 0; i < I2S_NUM_CHANNELS; i++) {\n\t\tif (i2s_channels[i].active) {\n\t\t\tif (i2s_channels[i].tick_count == 0) {\n\t\t\t\ti2s_channels[i].tick_count = i2s_channels[i].tick_period;\n\t\t\t\ti2s_channels[i].port_data ^= i2s_channels[i].pin_mask;\n\t\t\t} else {\n\t\t\t\ti2s_channels[i].tick_count--;\n\t\t\t}\n\t\t}\n\t}\n\n\ti2s_dma_buffer[i2s_dma_buffer_pos++] = i2s_channels[0].port_data;\n\tif (i2s_dma_buffer_pos == I2S_DMA_BUFFER_SIZE) {\n\t\ti2s_dma_buffer_pos = 0;\n\t}\n}", "CodeBleu_score": 30.50228724274512}, {"code": "void i2s_push_sample(){\n\t\tuint8_t pin_data = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tif (i2s_pins[i].active_pwm) {\n\t\t\tif (i2s_pins[i].pwm_tick_count == 0) {\n\t\t\t\tif (i2s_pins[i].pin_state) {\n\t\t\t\t\ti2s_pins[i].pin_state = 0;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pins[i].pin_state = 1;\n\t\t\t\t}\n\t\t\t\ti2s_pins[i].pwm_tick_count = i2s_pins[i].pwm_duty_cycle;\n\t\t\t} else {\n\t\t\t\ti2s_pins[i].pwm_tick_count--;\n\t\t\t}\n\t\t\tif (i2s_pins[i].pin_state) {\n\t\t\t\tpin_data |= (1 << i);\n\t\t\t}\n\t\t}\n\t}\n\ti2s_buffer[i2s_buffer_position++] = pin_data;\n\tif (i2s_buffer_position == i2s_buffer_length) {\n\t\ti2s_buffer_position = 0;\n\t}\n}", "CodeBleu_score": 30.543951406927626}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t count;\n\tswitch (timer_num) {\n\tcase 0:\n\t\tcount = (hal_timer_t) TIMER_0_COUNT;\n\t\tbreak;\n\tcase 1:\n\t\tcount = (hal_timer_t) TIMER_1_COUNT;\n\t\tbreak;\n\tcase 2:\n\t\tcount = (hal_timer_t) TIMER_2_COUNT;\n\t\tbreak;\n\tcase 3:\n\t\tcount = (hal_timer_t) TIMER_3_COUNT;\n\t\tbreak;\n\tdefault:\n\t\tcount = 0;\n\t}\n\treturn count;\n}", "CodeBleu_score": 29.114973576801074}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer_count;\n\tuint8_t timer_config_index = timer_num / 2;\n\tuint8_t timer_config_offset = timer_num % 2;\n\tuint8_t timer_config_offset_mask = timer_config_offset? 0x000000FF : 0x0000FF00;\n\tuint8_t timer_config_offset_shift = timer_config_offset? 0 : 8;\n\tuint32_t timer_config_value = (uint32_t) timer_config_offset_mask & (*((uint32_t *) (TIMER_CONFIG_BASE + timer_config_index)));\n\ttimer_count = (hal_timer_t) (timer_config_value >> timer_config_offset_shift);\n\treturn timer_count;\n}", "CodeBleu_score": 34.5533793796109}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn timer_get_count(timer_num);\n}", "CodeBleu_score": 13.703296291452144}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tuint8_t *data = (uint8_t*)value;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tdata[i] = EEPROM.read(pos);\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, data[i]);\n\t\t}\n\t\tif (writing) {\n\t\t\tdata[i] = EEPROM.read(pos);\n\t\t}\n\t\tpos++;\n\t}\n\treturn true;\n}", "CodeBleu_score": 54.94068924210058}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tuint8_t *ptr = value;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (!read_data(pos, *ptr, crc, writing)) {\n\t\t\treturn false;\n\t\t}\n\t\tptr++;\n\t}\n\treturn true;\n}", "CodeBleu_score": 52.20394629287468}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tuint8_t *p = value;\n\tfor (size_t i = 0; i < size; i++) {\n\t\t*p = EEPROM.read(pos);\n\t\tpos++;\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, *p);\n\t\t}\n\t\tif (writing) {\n\t\t\tp++;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 57.360427921147725}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\t// Check that the SDIO handle and source pointer are not null\n\tif (hsd.Instance == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\t// Try to write the block, retrying up to a defined number of times if the write operation fails\n\tfor (uint8_t i = 0; i < SDIO_MAX_RETRIES; i++) {\n\t\tif (HAL_SD_WriteBlocks(&hsd, (uint32_t *)src, block, 1, SDIO_MAX_TIMEOUT) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// If all retries fail, print an error message and return false\n\tprintf(\"SDIO write failed\n\");\n\treturn false;\n}", "CodeBleu_score": 34.346239276517544}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tuint32_t retry = 0;\n\tbool result = false;\n\tuint32_t status;\n\tuint32_t error;\n\n\tif (SDIO_Handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tif (HAL_SDIO_WriteBlock(SDIO_Handle, (uint8_t*) src, block, 1000) == HAL_OK) {\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = HAL_SDIO_GetStatus(SDIO_Handle);\n\t\terror = HAL_SDIO_GetError(SDIO_Handle);\n\t\tretry++;\n\t} while (retry < SDIO_MAX_RETRIES);\n\n\tif (retry >= SDIO_MAX_RETRIES) {\n\t\tprintf(\"SDIO write block %u failed: status = 0x%08x, error = 0x%08x\n\", block, status, error);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 44.81037315832198}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tuint8_t i = 0;\n\tuint8_t status = 0;\n\n\tif (hsd.Instance == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\twhile (i < SDIO_MAX_RETRIES) {\n\t\tstatus = HAL_SD_WriteBlocks(hsd.Instance, (uint8_t*) src, block, 1, 1000);\n\t\tif (status == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t\ti++;\n\t}\n\n\tprintf(\"SDIO_WriteBlock: Error writing block %d\n\", block);\n\treturn false;\n}", "CodeBleu_score": 39.077325745457955}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_TEMPERATURE) {\n\t\ttemperature_timer_prescale = frequency / TEMPERATURE_FREQUENCY;\n\t\ttemperature_timer_callback_priority = TEMPERATURE_TIMER_PRIORITY;\n\t} else if (timer_num == TIMER_STEPPER) {\n\t\tstepper_timer_prescale = frequency / STEPPER_FREQUENCY;\n\t\tstepper_timer_callback_priority = STEPPER_TIMER_PRIORITY;\n\t} else {\n\t\tassert(0);\n\t}\n\ttimer_start(timer_num, frequency, timer_num == TIMER_TEMPERATURE? temperature_timer_callback_priority : stepper_timer_callback_priority);\n}", "CodeBleu_score": 42.236638451688535}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMPERATURE_TIMER) {\n\t\tHAL_timer_start_temperature(frequency, TEMPERATURE_TIMER_PRESCALE);\n\t} else if (timer_num == STEP_TIMER) {\n\t\tHAL_timer_start_stepper(frequency, STEPPER_TIMER_PRESCALE);\n\t} else {\n\t\tassert(0);\n\t}\n}", "CodeBleu_score": 26.027033103224483}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tassert_param(timer_num < TIMER_NUM_MAX);\n\tassert_param(frequency > 0);\n\tif (timer_num == TIMER_TEMPERATURE) {\n\t\ttemperature_timer_start(frequency);\n\t} else if (timer_num == TIMER_STEPPER) {\n\t\tstepper_timer_start(frequency);\n\t} else {\n\t\tassert_failed(__FILE__, __LINE__);\n\t}\n}", "CodeBleu_score": 34.69577614756142}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\t// Open the EEPROM file\n\tif (!file.open(EEPROM_FILE, O_RDWR)) {\n\t\treturn false;\n\t}\n\n\t// Check the file size\n\tif (file.size() < EEPROM_SIZE) {\n\t\t// The file is smaller than the expected EEPROM size; fill the remainder of the buffer with a default erase value\n\t\tmemset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n\t} else {\n\t\t// The file is of sufficient size; read the file's contents into the buffer\n\t\tfile.read(buffer, EEPROM_SIZE);\n\t}\n\n\t// Close the file\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 16.411617381795025}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open the file\n\tif (file.open(filename, O_RDWR | O_CREAT)) {\n\t\t// Check the file size\n\t\tif (file.size() < EEPROM_SIZE) {\n\t\t\t// Fill the remainder of the buffer with a default erase value\n\t\t\tfor (unsigned int i = file.size(); i < EEPROM_SIZE; i++) {\n\t\t\t\tbuffer[i] = EEPROM_ERASE_VALUE;\n\t\t\t}\n\t\t}\n\t\t// Read the file's contents into the buffer\n\t\tfile.read(buffer, EEPROM_SIZE);\n\t\t// Close the file\n\t\tfile.close();\n\t\treturn true;\n\t}\n\t// If the file cannot be opened, return false\n\treturn false;\n}", "CodeBleu_score": 21.36176092199788}, {"code": "bool PersistentStore::access_start(){\n\t\tif (file.open(filename, O_RDWR | O_CREAT)) {\n\t\t// file exists\n\t\tfile.seek(0, SEEK_END);\n\t\tint filesize = file.tell();\n\t\tfile.seek(0, SEEK_SET);\n\t\tif (filesize < EEPROM_SIZE) {\n\t\t\t// file is smaller than expected, fill the remainder with default erase value\n\t\t\tchar* buffer = (char*)malloc(EEPROM_SIZE);\n\t\t\tmemset(buffer, 0xFF, EEPROM_SIZE);\n\t\t\tfile.write(buffer, EEPROM_SIZE);\n\t\t\tfree(buffer);\n\t\t}\n\t\t// read file contents into buffer\n\t\tfile.seek(0, SEEK_SET);\n\t\tfile.read(buffer, EEPROM_SIZE);\n\t\tfile.close();\n\t\treturn true;\n\t} else {\n\t\t// file does not exist or cannot be opened\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 36.89492414858472}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t ret = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_GPIO_PORT, SPI_SCK_PIN, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_GPIO_PORT, SPI_MOSI_PIN, b & 0x80);\n\t\tHAL_GPIO_WritePin(SPI_GPIO_PORT, SPI_SCK_PIN, GPIO_PIN_SET);\n\t\tret = ret << 1;\n\t\tret |= HAL_GPIO_ReadPin(SPI_GPIO_PORT, SPI_MISO_PIN);\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(1);\n\treturn ret;\n}", "CodeBleu_score": 41.05949803985663}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t rx = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SpiWrite(b & 0x80);\n\t\tHAL_SPI_STM32_SpiClockToggle();\n\t\trx = rx << 1;\n\t\trx |= HAL_SPI_STM32_SpiRead();\n\t\tb = b << 1;\n\t}\n\tHAL_SPI_STM32_SpiDelay();\n\treturn rx;\n}", "CodeBleu_score": 30.996406620815243}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\t// Set clock low\n\t\tHAL_SPI_STM32_SetClockPin(0);\n\t\t// Write most significant bit of byte to MOSI pin\n\t\tHAL_SPI_STM32_SetMosiPin(b & 0x80);\n\t\t// Toggle clock pin high\n\t\tHAL_SPI_STM32_SetClockPin(1);\n\t\t// Read bit from MISO pin\n\t\tr = (r << 1) | HAL_SPI_STM32_GetMosiPin();\n\t\t// Shift byte left\n\t\tb <<= 1;\n\t}\n\t// Introduce a small delay before returning the received byte\n\tHAL_SPI_STM32_Delay(1);\n\treturn r;\n}", "CodeBleu_score": 35.4704198782681}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 42.579826607808776}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tuint32_t tmpreg = 0x00000000;\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\ttmpreg = RCC->AHBENR;\n\t/* Set or reset the specified AHB peripheral clock */\n\tif (NewState!= DISABLE) {\n\t\ttmpreg |= RCC_AHBPeriph;\n\t} else {\n\t\ttmpreg &= ~RCC_AHBPeriph;\n\t}\n\tRCC->AHBENR = tmpreg;\n}", "CodeBleu_score": 62.73793171595867}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c;\n\tuint8_t *rxbuf;\n\tuint16_t rxlen;\n\tuint8_t rxhead;\n\tuint8_t rxtail;\n\tuint8_t rxcount;\n\tuint8_t rxparity;\n\tuint8_t rxparity_error;\n\tuint8_t rxparity_error_count;\n\tuint8_t rxparity_error_detected;\n\tuint8_t rxparity_error_detected_count;\n\tuint8_t rxparity_error_detected_count_max;\n\tuint8_t rxparity_error_detected_count_min;\n\tuint8_t rxparity_error_detected_count_max_min;\n\tuint8_t rxparity_error_detected_count_max_min_max;\n\tuint8_t rxparity_error_detected_count_max_min_min;\n\tuint8_t rxparity_error_detected_count_max_min_min_max;\n\tuint8_t rxparity_error_detected_count_max_min_min_min;\n\tuint8_t rxparity_error_detected_count_max_min_min_min_max;\n\tuint8_t rxparity_error_detected_count_max_min_min_min_min;\n\tuint8_t rxparity_error_detected_count_max_min_min_min_min_max;\n\tuint8_t rxparity_error_detected_count_max_min_min_min_min_min;\n\tuint8_t rxparity_error_detected_count_max_min_min_min_min_min_max;\n\tuint8_t rxparity_error_detected_count_max_min_min_min_min_min_min;\n\tuint8_t rxparity_error_detected_count_max_min_min_min_min_min_min_max;\n\tuint8_t rxparity_error_detected_count_max_min_min_min_min_min_min_min;\n\tuint8_t rxparity_error_detected_count_max_min_min_min_min_min_min_min_max", "CodeBleu_score": 2.9637749456960614}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c = obj->s_rbr;\n\n\tif (obj->s_fcr & 0x01) {\n\t\tif (obj->s_fcr & 0x02) {\n\t\t\tif (obj->s_fcr & 0x04) {\n\t\t\t\tif (obj->s_fcr & 0x08) {\n\t\t\t\t\tif (obj->s_fcr & 0x10) {\n\t\t\t\t\t\tif (obj->s_fcr & 0x20) {\n\t\t\t\t\t\t\tif (obj->s_fcr & 0x40) {\n\t\t\t\t\t\t\t\tif (obj->s_fcr & 0x80) {\n\t\t\t\t\t\t\t\t\t// 8-bit data, no parity, 2 stop bits\n\t\t\t\t\t\t\t\t\tif (obj->s_fcr & 0x100) {\n\t\t\t\t\t\t\t\t\t\t// 16-bit data, no parity, 2 stop bits\n\t\t\t\t\t\t\t\t\t\tif (obj->s_fcr & 0x200) {\n\t\t\t\t\t\t\t\t\t\t\t// 8-bit data, even parity, 2 stop bits\n\t\t\t\t\t\t\t\t\t\t\tif (obj->s_fcr & 0x400) {\n\t\t\t\t\t\t\t\t\t\t\t\t// 8-bit data, odd parity, 2 stop bits\n\t\t\t\t\t\t\t\t\t\t\t\tif (obj->s_fcr & 0x800) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// 8-bit data, no parity, 1 stop bit\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (obj->s_fcr & 0x1000) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 16-bit data, no parity, 1 stop bit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (obj->s_fcr & 0x2000) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 8-bit data, even parity, 1 stop bit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (obj->s_fcr & 0x4000) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 8-bit data, odd parity, 1 stop bit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (obj->s_fcr & 0x8000) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 8-bit data, no parity, 1.5 stop bits\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (obj->s_fcr & 0x10000) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 16-bit data, no parity, 1.5 stop bits\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (obj->s_fcr", "CodeBleu_score": 20.351382185135}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c = obj->serial->S1DRL;\n\tif (c & 0x100) {\n\t\t// Parity error\n\t\treturn;\n\t}\n\n\tif (obj->rx_buffer_head < obj->rx_buffer_tail + obj->rx_buffer_size) {\n\t\tobj->rx_buffer[obj->rx_buffer_head++] = c;\n\t\tif (obj->rx_buffer_head >= obj->rx_buffer_size) {\n\t\t\tobj->rx_buffer_head = 0;\n\t\t}\n\t}\n\tif (obj->emergency_parser) {\n\t\tobj->emergency_parser->process_byte(c);\n\t}\n}", "CodeBleu_score": 35.400293826189554}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tNVIC_EnableIRQ(TIMER_A0_IRQn);\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tNVIC_EnableIRQ(TIMER_A1_IRQn);\n\t}\n}", "CodeBleu_score": 22.891979049301032}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tNVIC_EnableIRQ(TIMER_STEP_IRQn);\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tNVIC_EnableIRQ(TIMER_TEMP_IRQn);\n\t}\n}", "CodeBleu_score": 22.98897887113763}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t}\n}", "CodeBleu_score": 31.170644631853882}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\treturn lastIndexRabinKarp(s, sep)\n}", "CodeBleu_score": 2.3042240669040837}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\treturn LastIndexRabinKarpHash[T](s, sep)\n}", "CodeBleu_score": 9.752988348065545}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(s) == 0 {\n\t\treturn -1\n\t}\n\n\tvar (\n\t\tsepHash uint64\n\t\tsepLen  = len(sep)\n\t\tsepLast = sep[sepLen-1]\n\t)\n\tsepHash = RabinKarpHash[sepLen]\n\tfor i := sepLen - 1; i >= 0; i-- {\n\t\tsepHash = (sepHash * Prime32) + uint64(sep[i])\n\t}\n\n\tvar (\n\t\thash uint64\n\t\tlenS = len(s)\n\t\tlenS1 = lenS - 1\n\t)\n\tfor i := lenS1; i >= 0; i-- {\n\t\thash = (hash*Prime32) + uint64(s[i])\n\t\tif i <= lenS1-sepLen {\n\t\t\tif hash == sepHash && s[i:i+sepLen] == sep {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 40.996730084912905}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.lock.Lock()\n\tusbcdc.waitTxc = false\n\tusbcdc.lock.Unlock()\n\n\tusbcdc.SendUSBInPacket()\n}", "CodeBleu_score": 24.02633723277846}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.Lock()\n\tif usbcdc.waitTxc {\n\t\tusbcdc.waitTxc = false\n\t\tusbcdc.Unlock()\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.Unlock()\n\t}\n}", "CodeBleu_score": 31.64500069652333}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.lock.Lock()\n\tif usbcdc.waitTxc {\n\t\tusbcdc.waitTxc = false\n\t\tusbcdc.lock.Unlock()\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.lock.Unlock()\n\t}\n}", "CodeBleu_score": 33.30397714631157}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag\n\ti2c.control.Clear()\n\t// Put a start condition on the SDA line\n\ti2c.sda.Set()\n\t// Enable the I2C module\n\ti2c.control.Set()\n\n\t// Wait for the start condition to be transmitted\n\tfor!i2c.control.Get() {\n\t}\n\n\t// Write the 7-bit shifted peripheral address to the bus\n\ti2c.bus.Write(address << 1 | uint8(write))\n}", "CodeBleu_score": 27.17211977878995}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.Clear()\n\ti2c.control.SetStart()\n\ti2c.control.SetEnable()\n\tfor!i2c.control.IsStart() {\n\t}\n\ti2c.bus.Write(address << 1 | (uint8(write) << 0))\n}", "CodeBleu_score": 27.657845591771448}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.Clear()\n\ti2c.control.Start()\n\tfor!i2c.control.Interrupt() {\n\t\tinterrupt.Sleep()\n\t}\n\ti2c.bus.Write(address << 1 | (write? 0 : 1))\n}", "CodeBleu_score": 28.02266443167205}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn ErrInvalidArgument\n\t}\n\n\t// Calculate the start address of the blocks to be erased.\n\tstartAddr := start * f.blockSize\n\n\t// Wait for any ongoing flash operations to complete.\n\tfor nrf.FICR.FlashConfig.Read()&nrf.FICR_FLASHCONFIG_ERASE_MASK!= 0 {\n\t}\n\n\t// Configure the flash for erasing.\n\tnrf.FICR.FlashConfig.Set(nrf.FICR_FLASHCONFIG_ERASE_ERASEALL)\n\n\t// Erase each block.\n\tfor i := int64(0); i < len; i++ {\n\t\t// Calculate the address of the block to be erased.\n\t\tblockAddr := startAddr + i*f.blockSize\n\n\t\t// Wait until the flash is no longer busy.\n\t\tfor nrf.FICR.FlashConfig.Read()&nrf.FICR_FLASHCONFIG_ERASE_MASK!= 0 {\n\t\t}\n\n\t\t// Erase the block.\n\t\tnrf.FICR.FlashConfig.Set(nrf.FICR_FLASHCONFIG_ERASE_ERASE)\n\t\tnrf.FICR.FlashBase.Set(blockAddr)\n\t\tnrf.FICR.FlashConfig.Set(nrf.FICR_FLASHCONFIG_ERASE_ERASEALL)\n\t}\n\n\t// Set the flash back to read mode.\n\tnrf.FICR.FlashConfig.Set(nrf.FICR_FLASHCONFIG_ERASE_READ)\n\n\treturn nil\n}", "CodeBleu_score": 34.3049313528919}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn ErrInvalidBlockNumber\n\t}\n\tif start+len > f.blockCount {\n\t\treturn ErrInvalidBlockNumber\n\t}\n\n\t// Calculate the start address based on the block number and block size.\n\tstartAddr := start * f.blockSize\n\n\t// Wait for any ongoing flash operations to complete.\n\tf.flash.Wait()\n\n\t// Configure the flash for erasing.\n\tf.flash.Erase(nrf.FlashErasePage)\n\n\t// Erase each block in the range.\n\tfor i := start; i < start+len; i++ {\n\t\t// Calculate the address of the block to be erased.\n\t\tblockAddr := i * f.blockSize\n\n\t\t// Wait until the flash is no longer busy.\n\t\tf.flash.Wait()\n\n\t\t// Erase the block.\n\t\tf.flash.ErasePage(blockAddr)\n\n\t\t// Wait until the flash is no longer busy.\n\t\tf.flash.Wait()\n\t}\n\n\t// Set the flash back to read mode.\n\tf.flash.Read()\n\n\treturn nil\n}", "CodeBleu_score": 45.22645481426404}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// 1. Calculate the start address based on the block number and block size\n\tstartAddress := start * f.BlockSize\n\n\t// 2. Wait for any ongoing flash operations to complete\n\tf.Flash.Wait()\n\n\t// 3. Configure the flash for erasing\n\tf.Flash.ConfigureForErase()\n\n\t// 4. Erase each block in the range\n\tfor i := start; i < start+len; i++ {\n\t\t// Calculate the start address of the current block\n\t\tblockStartAddress := i * f.BlockSize\n\n\t\t// Erase the block\n\t\tf.Flash.EraseBlock(blockStartAddress)\n\n\t\t// Wait until the flash is no longer busy\n\t\tf.Flash.Wait()\n\t}\n\n\t// 5. Set the flash back to read mode\n\tf.Flash.ConfigureForRead()\n\n\t// 6. Return nil to indicate successful completion\n\treturn nil\n}", "CodeBleu_score": 37.799310431358386}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off > f.Size() {\n\t\treturn 0, errOutOfBounds\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tstartAddr := f.StartAddr + uint32(off)\n\tendAddr := startAddr + uint32(len(p))\n\tif endAddr > f.StartAddr+f.Size() {\n\t\treturn 0, errOutOfBounds\n\t}\n\t// Pad the byte slice to fit the write block size.\n\tif len(p)%f.BlockSize!= 0 {\n\t\tpadded := make([]byte, len(p)+(f.BlockSize-len(p)%f.BlockSize))\n\t\tcopy(padded, p)\n\t\tp = padded\n\t}\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN)\n\t// Write the data in blocks.\n\tfor i := 0; i < len(p); i += f.BlockSize {\n\t\t// Write the data to the flash memory.\n\t\tbinary.LittleEndian.PutUint32(f.buf, startAddr+uint32(i))\n\t\tfor j := 0; j < f.BlockSize; j++ {\n\t\t\tf.buf[4+j] = p[i+j]\n\t\t}\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(f.buf[0:4]))\n\t\t// Wait for the flash memory to be ready.\n\t\tfor!nrf.NVMC.READY.HasBits(nrf.NVMC_READY_READY) {\n\t\t}\n\t\t// Increment the start address for the next block.\n\t\tstartAddr += uint32(f.BlockSize)\n\t}\n\t// Disable write mode on the flash memory controller.\n\tnrf.NVMC.CONFIG.Clear(nrf.NVMC_CONFIG_WEN)\n\t// Return the number of bytes written.\n\treturn len(p), nil\n}", "CodeBleu_score": 38.74936489693302}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\n\t// Calculate the start address for writing.\n\tstartAddr := f.startAddr + uint32(off)\n\n\t// Pad the byte slice to fit the write block size.\n\tpaddedData := make([]byte, len(p))\n\tcopy(paddedData, p)\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.Flash.Enable()\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(paddedData); i += FlashBlockSize {\n\t\t// Calculate the start address for writing.\n\t\tstartAddr := f.startAddr + uint32(off+int64(i))\n\n\t\t// Write the data to the flash memory.\n\t\tnrf.Flash.Write(startAddr, paddedData[i:i+FlashBlockSize])\n\n\t\t// Wait for the flash memory to be ready.\n\t\tfor!nrf.Flash.Ready() {\n\t\t}\n\t}\n\n\t// Disable write mode on the flash memory controller.\n\tnrf.Flash.Disable()\n\n\t// Return the number of bytes written.\n\treturn len(p), nil\n}", "CodeBleu_score": 31.125156364206386}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds.\n\tif off+int64(len(p)) > f.size {\n\t\treturn 0, ErrWriteOutOfBounds\n\t}\n\n\t// Calculate the start address for writing.\n\tstartAddr := f.baseAddr + uint32(off)\n\n\t// Pad the byte slice to fit the write block size.\n\tif len(p)%f.writeBlockSize!= 0 {\n\t\tp = append(p, make([]byte, f.writeBlockSize-len(p)%f.writeBlockSize)...)\n\t}\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.Flash.Enable()\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\t// Write the data block to the flash memory.\n\t\tnrf.Flash.Write(startAddr+uint32(i), binary.LittleEndian.Uint32(*(*uint32)(unsafe.Pointer(&p[i]))))\n\n\t\t// Wait for the flash memory to be ready.\n\t\tfor nrf.Flash.Ready() == false {\n\t\t}\n\t}\n\n\t// Disable write mode on the flash memory controller.\n\tnrf.Flash.Disable()\n\n\treturn len(p), nil\n}", "CodeBleu_score": 35.590736384038934}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar dirp uintptr\n\tvar err error\n\tfor {\n\t\tdirp, err = syscall.Fdopendir(int(fd))\n\t\tif err == nil {\n\t\t\treturn dirp, \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tsyscall.Close(int(fd))\n\treturn dirp, err.Error(), err\n}", "CodeBleu_score": 44.56280073072716}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, err.Error(), err\n\t}\n\t// Attempt to open the directory using syscall.Fdopendir.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err!= nil {\n\t\t// If the error is not \"syscall.EINTR\", close the duplicated file descriptor and return the error.\n\t\tif err!= syscall.EINTR {\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, err.Error(), err\n\t\t}\n\t\t// If the error is \"syscall.EINTR\", close the duplicated file descriptor and attempt to open the directory again.\n\t\tsyscall.Close(dupFd)\n\t\tdir, err = syscall.Fdopendir(dupFd)\n\t\tif err!= nil {\n\t\t\treturn 0, err.Error(), err\n\t\t}\n\t}\n\t// If the directory was successfully opened, return the directory pointer.\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 47.97719702902073}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, err.Error(), err\n\t}\n\tdefer syscall.Close(dupFd)\n\n\t// Open the directory using syscall.Fdopendir.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err!= nil {\n\t\treturn 0, err.Error(), err\n\t}\n\n\t// Check for errors.\n\tif err := syscall.GetErrno(); err!= 0 {\n\t\t// Close the directory and return the error.\n\t\tsyscall.Close(uintptr(dir))\n\t\treturn 0, err.Error(), err\n\t}\n\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 48.06159954385542}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tuint32_t freeSpace;\n\tesp_partition_t partition;\n\tesp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_FACTORY, NULL);\n\tif (it == NULL) {\n\t\treturn 0;\n\t}\n\tpartition = *esp_partition_next(it);\n\tesp_partition_iterator_release(it);\n\tif (response) {\n\t\tfreeSpace = esp_get_free_heap_size();\n\t\tfreeSpace += partition.size - partition.address;\n\t\treturn freeSpace;\n\t}\n\treturn partition.size;\n}", "CodeBleu_score": 43.89197280562654}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running = esp_ota_get_running_partition();\n\tconst esp_partition_pos_t *start_addr = esp_partition_find_first(running->type, running->subtype, NULL);\n\tconst esp_partition_pos_t *end_addr = esp_partition_find_last(running->type, running->subtype, start_addr);\n\tif (response) {\n\t\treturn end_addr->offset - start_addr->offset;\n\t} else {\n\t\treturn end_addr->offset;\n\t}\n}", "CodeBleu_score": 51.03783693725779}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t partition;\n\tesp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_FACTORY, NULL);\n\n\tif (it == NULL) {\n\t\treturn 0;\n\t}\n\n\tpartition = *esp_partition_next(it);\n\n\tif (response) {\n\t\treturn esp_get_free_heap_size();\n\t} else {\n\t\treturn partition.size;\n\t}\n}", "CodeBleu_score": 35.148394655252204}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t required_sectors;\n\tuint32_t *disk;\n\tuint32_t i;\n\tuint32_t *fat;\n\tuint32_t *root_dir;\n\tuint32_t *dir_entry;\n\tuint32_t *data_start;\n\tuint32_t *data_end;\n\tuint32_t *data;\n\tuint32_t *data_end_aligned;\n\tuint32_t *data_end_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t *data_end_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_", "CodeBleu_score": 4.393876180828854}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\t// Calculate the number of sectors required for the disk\n\tuint32_t num_sectors = sizeof(msc_boot_sector) / MSC_SECTOR_SIZE + sizeof(msc_fat_sector) / MSC_SECTOR_SIZE;\n\tif (partition_running()) {\n\t\tnum_sectors += sizeof(msc_dir_entry) / MSC_SECTOR_SIZE;\n\t}\n\n\t// Allocate memory for the RAM disk\n\tmsc_ram_disk = malloc(num_sectors * MSC_SECTOR_SIZE);\n\tif (msc_ram_disk == NULL) {\n\t\tlog_error(\"Failed to allocate memory for RAM disk\");\n\t\treturn false;\n\t}\n\n\t// Set up the boot sector\n\tmsc_boot_sector *boot_sector = (msc_boot_sector *) msc_ram_disk;\n\tboot_sector->jump_instruction = 0xEB;\n\tboot_sector->jump_instruction_offset = 0x0000;\n\tboot_sector->oem_identifier[0] = 'M';\n\tboot_sector->oem_identifier[1] = 'S';\n\tboot_sector->oem_identifier[2] = 'D';\n\tboot_sector->oem_identifier[3] = 'O';\n\tboot_sector->oem_identifier[4] = 'S';\n\tboot_sector->oem_identifier[5] = '5';\n\tboot_sector->oem_identifier[6] = '1';\n\tboot_sector->oem_identifier[7] ='';\n\tboot_sector->oem_identifier[8] ='';\n\tboot_sector->oem_identifier[9] ='';\n\tboot_sector->oem_identifier[10] ='';\n\tboot_sector->oem_identifier[11] ='';\n\tboot_sector->oem_identifier[12] ='';\n\tboot_sector->oem_identifier[13] ='';\n\tboot_sector->oem_identifier[14] ='';\n\tboot_sector->oem_identifier[15] ='';\n\tboot_sector->oem_identifier[16] ='';\n\tboot_sector->oem_identifier[17]", "CodeBleu_score": 23.054433595927563}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t i;\n\tuint32_t sectors_per_fat;\n\tuint32_t sectors_per_cluster;\n\tuint32_t fat_size_in_sectors;\n\tuint32_t root_dir_size_in_sectors;\n\tuint32_t data_size_in_sectors;\n\tuint32_t total_size_in_sectors;\n\tuint32_t total_size_in_bytes;\n\tuint8_t *disk;\n\tuint32_t disk_sectors;\n\tuint32_t disk_sector_size;\n\tuint32_t disk_sectors_per_cluster;\n\tuint32_t disk_sectors_per_fat;\n\tuint32_t disk_sectors_per_track;\n\tuint32_t disk_heads;\n\tuint32_t disk_sectors_per_fat_entry;\n\tuint32_t disk_sectors_per_cluster_entry;\n\tuint32_t disk_sectors_per_track_entry;\n\tuint32_t disk_heads_entry;\n\tuint32_t disk_sectors_per_fat_entry_bytes;\n\tuint32_t disk_sectors_per_cluster_entry_bytes;\n\tuint32_t disk_sectors_per_track_entry_bytes;\n\tuint32_t disk_heads_entry_bytes;\n\tuint32_t disk_sectors_per_fat_entry_bits;\n\tuint32_t disk_sectors_per_cluster_entry_bits;\n\tuint32_t disk_sectors_per_track_entry_bits;\n\tuint32_t disk_heads_entry_bits;\n\tuint32_t disk_sectors_per_fat_entry_bytes_bits;\n\tuint32_t disk_sectors_per_cluster_entry_bytes_bits;\n\tuint32_t disk_sectors_per_track_entry_bytes_bits;\n\tuint32_t disk_heads_entry_bytes_bits;\n\t", "CodeBleu_score": 8.034549139117509}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t ret;\n\n\tif (offset % partition->erase_size == 0) {\n\t\tret = esp_partition_erase_range(partition, offset, size);\n\t\tif (ret!= ESP_OK) {\n\t\t\tESP_LOGW(TAG, \"Failed to erase range at offset 0x%x\", offset);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = esp_partition_write(partition, offset, data, size);\n\tif (ret!= ESP_OK) {\n\t\tESP_LOGW(TAG, \"Failed to write data to offset 0x%x\", offset);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 52.71679532436936}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tif (offset % partition->erase_size == 0) {\n\t\terr = esp_partition_erase_range(partition, offset, size);\n\t\tif (err!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Error erasing flash sector at offset 0x%x\", offset);\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Error writing to flash at offset 0x%x\", offset);\n\t}\n\treturn err;\n}", "CodeBleu_score": 57.44594669830308}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\t// Check if the offset is aligned with the flash sector size.\n\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGW(TAG, \"Offset is not aligned with flash sector size. Erasing sector at offset 0x%x\", offset & ~(partition->erase_size - 1));\n\t\t// Erase the sector at the given offset.\n\t\tesp_err_t err = esp_partition_erase_range(partition, offset & ~(partition->erase_size - 1), partition->erase_size);\n\t\tif (err!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Failed to erase sector at offset 0x%x\", offset & ~(partition->erase_size - 1));\n\t\t\treturn err;\n\t\t}\n\t}\n\t// Write the data to the given offset.\n\tesp_err_t err = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write to offset 0x%x\", offset);\n\t}\n\treturn err;\n}", "CodeBleu_score": 47.455621337258066}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = 0;\n\twhile (*in && len < maxlen) {\n\t\tif (isxdigit(*in)) {\n\t\t\tunsigned char c = 0;\n\t\t\tif (*in >= '0' && *in <= '9') {\n\t\t\t\tc = *in - '0';\n\t\t\t} else if (*in >= 'a' && *in <= 'f') {\n\t\t\t\tc = *in - 'a' + 10;\n\t\t\t} else if (*in >= 'A' && *in <= 'F') {\n\t\t\t\tc = *in - 'A' + 10;\n\t\t\t}\n\t\t\tif (len & 1) {\n\t\t\t\tout[len / 2] |= c;\n\t\t\t} else {\n\t\t\t\tout[len / 2] = c << 4;\n\t\t\t}\n\t\t\tlen++;\n\t\t}\n\t\tin++;\n\t}\n\treturn len / 2;\n}", "CodeBleu_score": 58.676290712244906}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = 0;\n\twhile (*in && len < maxlen) {\n\t\tif (isxdigit(*in)) {\n\t\t\tunsigned char c = 0;\n\t\t\tif (isdigit(*in))\n\t\t\t\tc = *in - '0';\n\t\t\telse if (isupper(*in))\n\t\t\t\tc = *in - 'A' + 10;\n\t\t\telse\n\t\t\t\tc = *in - 'a' + 10;\n\t\t\tif (*++in && isxdigit(*in)) {\n\t\t\t\tc <<= 4;\n\t\t\t\tif (isdigit(*in))\n\t\t\t\t\tc |= *in - '0';\n\t\t\t\telse if (isupper(*in))\n\t\t\t\t\tc |= *in - 'A' + 10;\n\t\t\t\telse\n\t\t\t\t\tc |= *in - 'a' + 10;\n\t\t\t}\n\t\t\t*out++ = c;\n\t\t\tlen++;\n\t\t}\n\t\tin++;\n\t}\n\treturn len;\n}", "CodeBleu_score": 32.4131955014389}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\tsize_t j = 0;\n\twhile (in[i]!= '\\0' && j < maxlen) {\n\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\tout[j] = (in[i] - '0') << 4;\n\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\tout[j] = (in[i] - 'A' + 10) << 4;\n\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\tout[j] = (in[i] - 'a' + 10) << 4;\n\t\t} else {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\tout[j] |= (in[i] - '0');\n\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\tout[j] |= (in[i] - 'A' + 10);\n\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\tout[j] |= (in[i] - 'a' + 10);\n\t\t} else {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\treturn j;\n}", "CodeBleu_score": 36.16416727271519}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_ring_buffer!= NULL && tx_lock!= NULL) {\n\t\tif (xSemaphoreTake(tx_lock, 1000) == pdTRUE) {\n\t\t\tint free_space = tx_ring_buffer->availableForWrite();\n\t\t\txSemaphoreGive(tx_lock);\n\t\t\treturn free_space;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 49.863885266535334}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (m_pUsb!= NULL && m_pUsb->m_pTxBuffer!= NULL) {\n\t\tif (m_pUsb->m_pTxBuffer->available() > 0) {\n\t\t\treturn m_pUsb->m_pTxBuffer->available();\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 20.743491641810152}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_ring_buffer == NULL || tx_ring_buffer->lock == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (tx_ring_buffer->lock->take(1000) == 0) {\n\t\treturn 0;\n\t}\n\n\tint free_size = tx_ring_buffer->free_size();\n\n\ttx_ring_buffer->lock->give();\n\n\treturn free_size;\n}", "CodeBleu_score": 47.72366721107101}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\tif (_onReceiveCB!= NULL) {\n\t\tif (_rxTimeout!= 0) {\n\t\t\tuart_set_hw_flow_ctrl(UART_NUM_0, UART_HW_FLOWCTRL_CTS_RTS, 0);\n\t\t\tuart_set_rx_timeout(UART_NUM_0, _rxTimeout);\n\t\t} else {\n\t\t\tuart_set_hw_flow_ctrl(UART_NUM_0, UART_HW_FLOWCTRL_DISABLE, 0);\n\t\t\tuart_set_rx_timeout(UART_NUM_0, 0);\n\t\t}\n\t\tuart_set_rx_fifo_thresh(UART_NUM_0, 1);\n\t\tif (_rxQueue == NULL) {\n\t\t\t_rxQueue = xQueueCreate(16, sizeof(uint8_t));\n\t\t\txTaskCreatePinnedToCore(rxTask, \"rxTask\", 2048, this, 1, &_rxTask, 1);\n\t\t}\n\t} else {\n\t\tuart_set_hw_flow_ctrl(UART_NUM_0, UART_HW_FLOWCTRL_DISABLE, 0);\n\t\tuart_set_rx_timeout(UART_NUM_0, 0);\n\t\tuart_set_rx_fifo_thresh(UART_NUM_0, 0);\n\t\tif (_rxQueue!= NULL) {\n\t\t\tvQueueDelete(_rxQueue);\n\t\t\t_rxQueue = NULL;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.133199555355674}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tif (function) {\n\t\t_onReceiveCB = function;\n\t\t_onlyOnTimeout = onlyOnTimeout;\n\t\tif (_rxTimeout!= 0) {\n\t\t\t_rxTimeoutEnabled = true;\n\t\t}\n\t\tif (_rxTask == NULL) {\n\t\t\txTaskCreatePinnedToCore(serialEventTask, \"serialEvent\", 1024, this, 1, &_rxTask, 0);\n\t\t}\n\t\tuart_set_rx_timeout(UART_NUM_0, _rxTimeout);\n\t\tuart_set_fifo_full_thresh(UART_NUM_0, 1);\n\t}\n}", "CodeBleu_score": 45.411544101191595}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\txSemaphoreTake(_mutex, portMAX_DELAY);\n\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\tif (_onReceiveCB) {\n\t\tuart_set_rx_timeout(UART_NUM_0, _rxTimeout);\n\t\tif (!_receiveTask) {\n\t\t\txTaskCreate(receiveTask, \"uart_rx\", 1024, this, 1, &_receiveTask);\n\t\t}\n\t} else {\n\t\tuart_set_rx_timeout(UART_NUM_0, 0);\n\t\tif (_receiveTask) {\n\t\t\tvTaskDelete(_receiveTask);\n\t\t\t_receiveTask = NULL;\n\t\t}\n\t}\n\txSemaphoreGive(_mutex);\n}", "CodeBleu_score": 43.392312475789886}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t n = 0;\n\twhile (n < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = c;\n\t\tn++;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn n;\n}", "CodeBleu_score": 57.81982576373539}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\treturn readBytesUntil(terminator, (uint8_t *)buffer, length);\n}", "CodeBleu_score": 18.362456948468164}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\tsize_t n = 0;\n\twhile (n < (length - 1)) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = c;\n\t\tn++;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*buffer = 0;\n\treturn n;\n}", "CodeBleu_score": 67.65239025960803}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\t// Check if the pin is available\n\tif (available_pins[pin - 33] == 1) {\n\t\t// If the pin is available, log the pin, frequency, and duration\n\t\tSerial.print(\"Pin \");\n\t\tSerial.print(pin);\n\t\tSerial.print(\" is available.\n\");\n\t\tSerial.print(\"Frequency: \");\n\t\tSerial.print(frequency);\n\t\tSerial.print(\" Hz\n\");\n\t\tSerial.print(\"Duration: \");\n\t\tSerial.print(duration);\n\t\tSerial.print(\" ms\n\");\n\n\t\t// Initialize the tone\n\t\tledcSetup(pin, frequency, 8);\n\n\t\t// Send a start command with the pin, frequency, and duration to a queue\n\t\txQueueSend(queue, &pin, 1000);\n\t\txQueueSend(queue, &frequency, 1000);\n\t\txQueueSend(queue, &duration, 1000);\n\n\t\t// Set the pin as unavailable\n\t\tavailable_pins[pin - 33] = 0;\n\t}\n\t// If the pin is in use, log an error message\n\telse {\n\t\tSerial.print(\"Pin \");\n\t\tSerial.print(pin);\n\t\tSerial.print(\" is in use.\n\");\n\t\tSerial.print(\"Stop the current tone on the pin first.\n\");\n\t}\n}", "CodeBleu_score": 33.97528506863235}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (pinAvailable(pin)) {\n\t\tpinMode(pin, OUTPUT);\n\t\txQueueSend(queue, &pin, 0);\n\t\txQueueSend(queue, &frequency, 0);\n\t\txQueueSend(queue, &duration, 0);\n\t} else {\n\t\tSerial.print(\"Error: pin \");\n\t\tSerial.print(pin);\n\t\tSerial.println(\" is already in use.\");\n\t}\n}", "CodeBleu_score": 28.217059389562984}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (pin == 2 || pin == 4 || pin == 12 || pin == 13 || pin == 14) {\n\t\tif (ledc_is_in_use(pin)) {\n\t\t\tSerial.println(\"Tone on pin \" + String(pin) + \" is already in use\");\n\t\t} else {\n\t\t\tledc_init_pin(pin, frequency);\n\t\t\tledc_start(pin);\n\t\t\txQueueSend(queue, &pin, 0);\n\t\t\txQueueSend(queue, &frequency, 0);\n\t\t\txQueueSend(queue, &duration, 0);\n\t\t}\n\t} else {\n\t\tSerial.println(\"Pin \" + String(pin) + \" is not a valid pin for tone\");\n\t}\n}", "CodeBleu_score": 34.02785427480306}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!USB::started()) {\n\t\t_webUSB = enabled;\n\t\tif (enabled) {\n\t\t\tif (USB::version() < 0x0210) {\n\t\t\t\tUSB::start(0x0210);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 31.240253678131552}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (enabled) {\n\t\tif (webUSBEnabled) {\n\t\t\treturn false;\n\t\t}\n\t\twebUSBEnabled = true;\n\t\tif (version < 0x0210) {\n\t\t\tversion = 0x0210;\n\t\t}\n\t} else {\n\t\twebUSBEnabled = false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 46.350454012476604}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usbStarted) {\n\t\twebUSBEnabled = enabled;\n\t\treturn true;\n\t}\n\tif (enabled) {\n\t\tif (usbVersion < 0x0210) {\n\t\t\treturn false;\n\t\t}\n\t}\n\twebUSBEnabled = enabled;\n\treturn true;\n}", "CodeBleu_score": 42.185591958190805}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t data[CDC_RX_BUFFER_SIZE];\n\tuint8_t length;\n\tuint8_t i;\n\n\twhile (true) {\n\t\tlength = CDC_RX_BUFFER_SIZE;\n\t\tif (CDC_ReceiveData(data, &length) == CDC_OK) {\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tif (this->rxQueue.put(data[i]) == false) {\n\t\t\t\t\tthis->log.error(\"USB CDC RX queue overflow\");\n\t\t\t\t\tthis->rxQueue.setOverflow(length - i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tthis->rxQueue.setLength(i);\n\t\t\t\tthis->rxQueue.post();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 24.099586566097265}, {"code": "void USBCDC::_onRX(){\n\t\t// Read data into buffer\n\tuint32_t bytesRead = 0;\n\tuint32_t bytesDropped = 0;\n\tuint32_t bytesReceived = 0;\n\twhile (bytesRead < USBCDC_BUFFER_SIZE) {\n\t\t// Read data into buffer\n\t\tuint32_t bytesReadThisTime = 0;\n\t\tuint8_t* buffer = _buffer + bytesRead;\n\t\tif (_read(buffer, USBCDC_BUFFER_SIZE - bytesRead, &bytesReadThisTime)!= USBCDC_RESULT_OK) {\n\t\t\t// Error reading data\n\t\t\t_postOverflowEvent(bytesDropped, bytesReceived);\n\t\t\treturn;\n\t\t}\n\t\tbytesRead += bytesReadThisTime;\n\t\tbytesDropped += bytesReadThisTime;\n\n\t\t// Check for end of data\n\t\tif (bytesReadThisTime == 0) {\n\t\t\t// End of data\n\t\t\t_postReceiveEvent(bytesReceived);\n\t\t\treturn;\n\t\t}\n\n\t\t// Send data to receive queue\n\t\tuint32_t bytesSent = 0;\n\t\twhile (bytesSent < bytesReadThisTime) {\n\t\t\t// Send data to receive queue\n\t\t\tuint32_t bytesSentThisTime = 0;\n\t\t\tif (_receiveQueue.push(_buffer + bytesRead + bytesSent, bytesReadThisTime)!= QUEUE_RESULT_OK) {\n\t\t\t\t// Queue full\n\t\t\t\t_postOverflowEvent(bytesDropped, bytesReceived);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbytesSent += bytesSentThisTime;\n\t\t\tbytesReceived += bytesSentThisTime;\n\t\t}\n\t}\n}", "CodeBleu_score": 33.3239569714075}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t data;\n\twhile (CDC_Receive(&data, 1, 0) == 1) {\n\t\tif (rxBuffer.put(data)) {\n\t\t\trxQueue.post(1);\n\t\t} else {\n\t\t\trxQueue.post(0);\n\t\t\tlog.error(\"USB CDC RX buffer overflow\");\n\t\t}\n\t}\n}", "CodeBleu_score": 8.57020842638445}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL path.\n\trobotName := pat.Param(req, \"robotName\")\n\n\t// Check if a robot with the given name exists.\n\trobot, err := a.gobot.Robot(robotName)\n\tif err!= nil {\n\t\t// If the robot does not exist, return a JSON response with an error message.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the given name.\"})\n\t\treturn\n\t}\n\n\t// If the robot exists, gather its devices into a JSON format and write this JSON response to the HTTP response writer.\n\tdevices := robot.Devices()\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 30.073719917107173}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := pat.Param(req, \"robotName\")\n\n\t// Check if a robot with the given name exists\n\trobot, err := a.GetRobot(robotName)\n\tif err!= nil {\n\t\t// If the robot does not exist, return a JSON response with an error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the specified name\"})\n\t\treturn\n\t}\n\n\t// If the robot exists, gather its devices into a JSON format and write this JSON response to the HTTP response writer\n\tdevices := robot.Devices()\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 29.12020637920058}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tif robotName == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"{\\\"error\\\":\\\"No robot name provided\\\"}\"))\n\t\treturn\n\t}\n\trobot := a.robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"{\\\"error\\\":\\\"No robot with name %s\\\"}\", robotName)))\n\t\treturn\n\t}\n\tres.WriteHeader(http.StatusOK)\n\tdevices := robot.Devices()\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 31.354763213669678}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := pat.Param(req, \"robot\")\n\tif robot, ok := a.robots[robotName]; ok {\n\t\tconnections := robot.Connections()\n\t\tdata, err := json.Marshal(connections)\n\t\tif err!= nil {\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\tres.Write([]byte(err.Error()))\n\t\t} else {\n\t\t\tres.WriteHeader(http.StatusOK)\n\t\t\tres.Write(data)\n\t\t}\n\t} else {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"No robot with name '%s' was found.\", robotName)))\n\t}\n}", "CodeBleu_score": 30.00295113921718}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\trobot, err := a.gobot.Robot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with name %s was found\", robotName)\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"Error converting connections to JSON: %s\", err)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 35.577326460975925}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := pat.Param(req, \"robot\")\n\n\t// Check if the robot exists\n\t_, err := a.gobot.Robot(robotName)\n\tif err!= nil {\n\t\t// Write an error message to the HTTP response indicating that no robot with the specified name was found\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with name %s was found\", robotName)\n\t\treturn\n\t}\n\n\t// Get the connections of the specified robot\n\tconnections, err := a.gobot.Robot(robotName).Connections()\n\tif err!= nil {\n\t\t// Write an error message to the HTTP response indicating that an error occurred while retrieving the connections of the robot\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"An error occurred while retrieving the connections of the robot: %v\", err)\n\t\treturn\n\t}\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// Write an error message to the HTTP response indicating that an error occurred while converting the connections to JSON format\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"An error occurred while converting the connections to JSON format: %v\", err)\n\t\treturn\n\t}\n\n\t// Write the connections in JSON format to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(res, \"%s\", connectionsJSON)\n}", "CodeBleu_score": 39.88890958827036}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\tif robotName == \"\" || deviceName == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"Robot and device names are required\"))\n\t\treturn\n\t}\n\n\trobot, err := a.getRobot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\tdevice, err := robot.GetDevice(deviceName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\tswitch command {\n\tcase \"start\":\n\t\terr = device.Start()\n\tcase \"stop\":\n\t\terr = device.Stop()\n\tcase \"pause\":\n\t\terr = device.Pause()\n\tcase \"resume\":\n\t\terr = device.Resume()\n\tdefault:\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"Invalid command\"))\n\t\treturn\n\t}\n\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n}", "CodeBleu_score": 42.33075775947259}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot exists.\n\trobot, err := a.GetRobot(robotName)\n\tif err!= nil {\n\t\t// If the robot does not exist, write an error message as a JSON response.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Robot %s not found\", robotName)))\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tdevice, err := robot.GetDevice(deviceName)\n\tif err!= nil {\n\t\t// If the device does not exist, write an error message as a JSON response.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Device %s not found\", deviceName)))\n\t\treturn\n\t}\n\n\t// Get the command from the URL query parameters.\n\tcommand := req.URL.Query().Get(\"command\")\n\n\t// Execute the command on the device.\n\terr = device.Command(command)\n\tif err!= nil {\n\t\t// If an error occurs while executing the command, write the error message as a JSON response.\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\t// Write a success message as a JSON response.\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(\"Command executed successfully\"))\n}", "CodeBleu_score": 46.179596573665464}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\t// Check if the robot exists.\n\tif _, ok := a.robots[robotName];!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"Robot not found: %s\", robotName)\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tif _, ok := a.robots[robotName].Devices[deviceName];!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"Device not found: %s\", deviceName)\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\terr := a.robots[robotName].Devices[deviceName].Commands[command].Execute()\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"Error executing command: %s\", err.Error())\n\t\treturn\n\t}\n\n\t// Write the response.\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(res, \"Command executed successfully\")\n}", "CodeBleu_score": 45.89320754788175}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header value\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\n\t\t// If the header is empty, respond with a \"401 Unauthorized\" status and an error message\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted Area\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"401 Unauthorized\n\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Extract the username and password from the \"Authorization\" header\n\t\tauthHeaderParts := strings.Split(authHeader, \" \")\n\t\tif len(authHeaderParts)!= 2 ||!strings.EqualFold(authHeaderParts[0], \"Basic\") {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"401 Unauthorized\n\"))\n\t\t\treturn\n\t\t}\n\t\tauthString, err := base64.StdEncoding.DecodeString(authHeaderParts[1])\n\t\tif err!= nil {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"401 Unauthorized\n\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password with the provided credentials\n\t\tauth := strings.Split(string(authString), \":\")\n\t\tif len(auth)!= 2 ||!subtle.ConstantTimeCompare([]byte(auth[0]), []byte(username)) ||!subtle.ConstantTimeCompare([]byte(auth[1]), []byte(password)) {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"401 Unauthorized\n\"))\n\t\t\treturn\n\t\t}\n\n\t\t// If the comparison succeeds, proceed to the next handler\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 47.43262243808347}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\n\t\t// If the \"Authorization\" header is empty, respond with a \"401 Unauthorized\" status and an error message.\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"401 Unauthorized", "CodeBleu_score": 53.33900952211265}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Get the username and password from the authorization header\n\t\t// The format of the authorization header is \"Basic base64encoded(username:password)\"\n\t\t// The base64 encoded string is decoded and split by the colon character\n\t\t// The first part is the username and the second part is the password\n\t\tcred, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tcred = bytes.SplitN(cred, []byte(\":\"), 2)\n\n\t\t// Check if the username and password match the expected values\n\t\tif subtle.ConstantTimeCompare(cred[0], []byte(username)) == 1 && subtle.ConstantTimeCompare(cred[1], []byte(password)) == 1 {\n\t\t\t// If they match, proceed to the next handler\n\t\t\tnext.ServeHTTP(w, r)\n\t\t} else {\n\t\t\t// If they don't match, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t}\n\t}\n}", "CodeBleu_score": 52.00460731365393}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tvar err error\n\tvar raw int\n\tvar scaled float64\n\n\t// Lock the sensor for reading\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif!a.connection.AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\t// Read the raw sensor value\n\traw, err = a.connection.AnalogRead()\n\tif err!= nil {\n\t\treturn 0, 0, fmt.Errorf(\"failed to read analog sensor: %v\", err)\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaled = float64(raw) * a.scaleFactor + a.offset\n\n\t// Update the last read values\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\ta.lastReadTime = time.Now()\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 44.040414534535245}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection is nil\")\n\t}\n\tif!a.connection.AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog read\")\n\t}\n\traw, err := a.connection.AnalogRead()\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := a.scale(raw)\n\ta.lastRead = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 44.17282125929901}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif!a.connection.AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\t// Read the raw sensor value\n\traw, err := a.connection.AnalogRead()\n\tif err!= nil {\n\t\treturn 0, 0, fmt.Errorf(\"failed to read analog sensor: %v\", err)\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaled := float64(raw)\n\tif a.min!= 0 || a.max!= 0 {\n\t\tscaled = float64(raw-a.min) / float64(a.max-a.min) * 100\n\t}\n\n\t// Update the last read values\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 46.63032149650987}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.Name = \"GroveSoundSensorDriver\"\n\treturn d\n}", "CodeBleu_score": 26.571733222157885}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.SetName(\"GroveSoundSensorDriver\")\n\treturn g\n}", "CodeBleu_score": 46.991957339274734}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(\"GroveSoundSensorDriver\")\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: d,\n\t}\n}", "CodeBleu_score": 40.4375807538079}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(CommandReg, PCD_RESETPHASE)\n\ttime.Sleep(time.Millisecond * 10)\n\tif d.readRegister(CommandReg) & (1 << 4) == 0 {\n\t\treturn fmt.Errorf(\"softReset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 21.902660587795918}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.WriteRegister(CommandReg, SoftReset); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(time.Millisecond * 10)\n\tstatus, err := d.ReadRegister(CommandReg)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif (status & 0x10)!= 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 60.21552746683313}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Soft reset\n\terr := d.WriteRegister(CommandReg, SoftReset)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// The datasheet says 78ms after soft reset\n\ttime.Sleep(78 * time.Millisecond)\n\n\t// Check if the bit is set\n\tstatus, err := d.ReadRegister(CommandReg)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif status&SoftReset == SoftReset {\n\t\treturn fmt.Errorf(\"MFRC522: Soft reset timeout\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 59.2268079479573}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Number of bytes in FIFO buffer\n\tfifoSize, err := d.readRegister(RegFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// If there are no bytes in the FIFO buffer, return an error\n\tif fifoSize == 0 {\n\t\treturn 0, fmt.Errorf(\"no bytes in FIFO\")\n\t}\n\n\t// If the number of bytes in the FIFO buffer does not match the length of the byte slice, return an error\n\tif fifoSize!= uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"FIFO size does not match buffer length\")\n\t}\n\n\t// Read each byte from the FIFO buffer into the byte slice\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(RegFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tlastBits, err := d.readRegister(RegControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 52.623678245632576}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// The FIFO buffer size is 16 bytes.\n\tfifoSize := 16\n\n\t// Check the FIFO buffer size.\n\tfifoSize, err := d.getFifoSize()\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the FIFO buffer size is sufficient to read the data.\n\tif fifoSize < uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"FIFO buffer size is too small to read the data. FIFO size: %d, data length: %d\", fifoSize, len(backData))\n\t}\n\n\t// Read the data from the FIFO buffer.\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(MFRC522_FIFO_DATA)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received.\n\tcontrol, err := d.readRegister(MFRC522_CONTROL)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn control, nil\n}", "CodeBleu_score": 55.48498141908639}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check the number of bytes available in the FIFO.\n\tfifoSize, err := d.readRegister(FIFOLevelReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// If the number of bytes available in the FIFO does not match the expected length of the byte slice, return an error.\n\tif fifoSize!= uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"FIFO size mismatch: expected %d bytes, got %d\", len(backData), fifoSize)\n\t}\n\n\t// Read each byte from the FIFO into the byte slice.\n\tfor i := range backData {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received.\n\tlastBits, err := d.readRegister(ControlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 45.77033740234352}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Printf(\"piccHalt\n\")\n\t}\n\t// Build command buffer\n\tcmd := make([]byte, 2)\n\tcmd[0] = MFRC522_HALT\n\tcmd[1] = 0\n\t// Calculate CRC\n\tcrc := d.calculateCRC(cmd)\n\t// Append CRC to command buffer\n\tcmd = append(cmd, crc...)\n\t// Transmit command\n\tstatus, _ := d.toCard(MFRC522_TRANSCEIVE, cmd)\n\t// Check response status\n\tif status!= MFRC522_STATUS_COLLISION {\n\t\treturn fmt.Errorf(\"piccHalt: no collision\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 24.605588093477927}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.Debug {\n\t\tfmt.Println(\"piccHalt\")\n\t}\n\n\t// Prepare MFRC522 command\n\tbuffer := make([]byte, 4)\n\tbuffer[0] = d.PICC_CMD_HALT\n\tbuffer[1] = 0\n\tbuffer[2] = 0\n\tbuffer[3] = 0\n\n\t// Calculate CRC\n\tcrc := d.calcCRC(buffer)\n\n\t// Append crc to buffer\n\tbuffer = append(buffer, crc...)\n\n\t// Transmit command\n\terr := d.writeRaw(buffer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Receive response\n\tresponse, err := d.readRaw(4)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check response\n\tif response[0]!= d.PICC_CMD_HALT {\n\t\treturn fmt.Errorf(\"Halt command was not acknowledged. Response code: %02X\", response[0])\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.38090611365315}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.Debug {\n\t\tfmt.Println(\"piccHalt\")\n\t}\n\tcommand := []byte{PICC_HALT}\n\tcrc := d.calculateCRC(command)\n\tcommand = append(command, crc...)\n\tstatus, err := d.sendCommand(command)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status!= STATUS_OK {\n\t\treturn fmt.Errorf(\"piccHalt: %s\", d.getErrorMessage(status))\n\t}\n\treturn nil\n}", "CodeBleu_score": 38.34624310795311}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar err error\n\tvar data []byte\n\tvar response []byte\n\tvar size uint8\n\n\t// Sanity check\n\tif block > 63 {\n\t\treturn nil, fmt.Errorf(\"invalid block number\")\n\t}\n\n\t// Prepare the read command\n\tcommand := []byte{PICC_CMD_MF_READ, byte(block), 0x00}\n\n\t// Calculate CRC\n\tcrc, err := d.calculateCRC(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Append CRC to command\n\tcommand = append(command, crc...)\n\n\t// Transmit command\n\tresponse, err = d.transmit(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check for errors\n\tif response[PICC_MF_DATA_MAX_SIZE] & 0x0F!= 0x00 {\n\t\treturn nil, fmt.Errorf(\"error reading block\")\n\t}\n\n\t// Retrieve data\n\tsize = response[PICC_MF_DATA_MAX_SIZE] & 0x0F\n\tdata = response[1 : 1+size]\n\n\treturn data, nil\n}", "CodeBleu_score": 45.48541759047182}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar data []byte\n\tvar err error\n\tvar status byte\n\n\t// Sanity check\n\tif block > 63 {\n\t\treturn data, fmt.Errorf(\"Invalid block number: %d\", block)\n\t}\n\n\t// Prepare the command buffer\n\tvar cmd []byte\n\tcmd = append(cmd, piccReadCommand)\n\tcmd = append(cmd, byte(block))\n\tcmd = append(cmd, 0xff)\n\tcmd = append(cmd, 0xff)\n\n\t// Calculate CRC_A\n\tvar crc []byte\n\tcrc, err = d.calcCRC(cmd)\n\tif err!= nil {\n\t\treturn data, err\n\t}\n\tcmd = append(cmd, crc[0])\n\tcmd = append(cmd, crc[1])\n\n\t// Transmit the data\n\tstatus, err = d.transceive(cmd)\n\tif err!= nil {\n\t\treturn data, err\n\t}\n\n\t// Check for success\n\tif status!= statusSuccess {\n\t\treturn data, fmt.Errorf(\"Read error: %d\", status)\n\t}\n\n\t// Read the data from the FIFO\n\tdata, err = d.readFIFO()\n\tif err!= nil {\n\t\treturn data, err\n\t}\n\n\t// Check for success\n\tif len(data)!= 16 {\n\t\treturn data, fmt.Errorf(\"Read error: %d\", status)\n\t}\n\n\treturn data, nil\n}", "CodeBleu_score": 31.861283201387213}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare MFRC522 command buffer\n\tvar buffer [18]byte\n\tbuffer[0] = 0x30 // MFRC522 command: READ\n\tbuffer[1] = byte(block) // MFRC522 command: READ\n\n\t// Calculate CRC_A\n\tvar crc [2]byte\n\terr := d.calcCRC(buffer[0:2], &crc)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Append CRC_A\n\tbuffer[2] = crc[0]\n\tbuffer[3] = crc[1]\n\n\t// Transmit command\n\terr = d.writeRegister(d.CommandReg, buffer[0:4])\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Get response\n\terr = d.waitReady()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Read 16 bytes from the specified block\n\tvar data [16]byte\n\terr = d.readRegister(d.FIFODataReg, data[:])\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn data[:], nil\n}", "CodeBleu_score": 35.43562538820873}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Sanity check\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"Invalid answer buffer length\")\n\t}\n\n\t// Reset bits after collision\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// Transmit the request\n\terr := d.transceive(answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check for collision\n\tvalue := d.readRegister(CollReg)\n\tif (value & 0x20) == 0x20 {\n\t\treturn fmt.Errorf(\"Collision error\")\n\t}\n\n\t// Switch on the transmission of the last bits in case only 7 bits are used in the request\n\tswitch reqMode {\n\tcase PICC_CMD_MF_AUTH_KEY_A:\n\t\td.setBitMask(TxControlReg, 0x03)\n\tdefault:\n\t\td.clearBitMask(TxControlReg, 0x03)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 54.856886790288094}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Check for correct answer buffer size\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: Answer buffer size is too small\")\n\t}\n\t// Clear the bits in the collission register\n\td.writeRegister(RegisterColl, 0x80)\n\t// Transceive the data\n\terr := d.transceive(reqMode, answer)\n\t// Check for errors\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Check the number of bytes of the received data\n\tif len(answer)!= 0 && answer[0] == 0x00 {\n\t\treturn fmt.Errorf(\"piccRequest: No data received\")\n\t}\n\t// Check the CRC_A of the received data\n\tif len(answer) > 2 && answer[len(answer)-2]!= 0x00 {\n\t\treturn fmt.Errorf(\"piccRequest: CRC_A is not valid!\")\n\t}\n\t// Check the number of bytes of the received data\n\tif len(answer) > 1 && answer[len(answer)-1]!= 0x00 {\n\t\treturn fmt.Errorf(\"piccRequest: The number of received bytes is not valid!\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 57.19736865277953}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Sanity check\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"Not enough space in answer buffer\")\n\t}\n\n\t// Reset ModWidth to 0\n\td.ModWidth = 0\n\n\t// Clear all previously received data\n\td.clearBitMask(CollReg, 0x80)\n\n\t// Tell card we want to do a REQA or WUPA command\n\tif (reqMode == PICC_CMD_REQA) || (reqMode == PICC_CMD_WUPA) {\n\t\td.ModWidth = 7\n\t}\n\n\t// Set the number of bits that will be transmitted\n\tif (reqMode == PICC_CMD_REQA) || (reqMode == PICC_CMD_WUPA) {\n\t\td.BitFraming = (d.BitFraming & 0x07) | 0x08\n\t} else {\n\t\td.BitFraming = (d.BitFraming & 0x07) | 0x00\n\t}\n\n\t// Start the transmission\n\terr := d.transceive(d.buffer, d.buffer, d.buffer, d.buffer, d.buffer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// The PICC must respond with a 4 bit ACK\n\tif (d.buffer[0] & 0x0F)!= 0x0A {\n\t\treturn fmt.Errorf(\"Did not receive ACK from PICC\")\n\t}\n\n\t// Store response in the output parameters\n\tanswer[0] = d.buffer[0]\n\tanswer[1] = d.buffer[1]\n\n\treturn nil\n}", "CodeBleu_score": 46.93887082069899}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\t// Lock the valueMutex to ensure thread safety while accessing shared variables.\n\td.valueMutex.Lock()\n\t// Trigger a valid step by setting the step pin low, waiting for a delay, and setting the step pin high.\n\tif d.direction == 1 {\n\t\td.stepPin.Write(0)\n\t\ttime.Sleep(time.Duration(d.delay) * time.Millisecond)\n\t\td.stepPin.Write(1)\n\t\td.stepNumber++\n\t} else if d.direction == -1 {\n\t\td.stepPin.Write(0)\n\t\ttime.Sleep(time.Duration(d.delay) * time.Millisecond)\n\t\td.stepPin.Write(1)\n\t\td.stepNumber--\n\t}\n\t// Unlock the valueMutex to allow other threads to access shared variables.\n\td.valueMutex.Unlock()\n\treturn nil\n}", "CodeBleu_score": 34.88664992116679}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.stepPin.Write(d.stepPin.Low()); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.delay)\n\tif err := d.stepPin.Write(d.stepPin.High()); err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == d.directionCW {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 64.13969172377986}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif err := d.stepPin.DigitalWrite(d.stepPinLow); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.delay)\n\tif err := d.stepPin.DigitalWrite(d.stepPinHigh); err!= nil {\n\t\treturn err\n\t}\n\tif d.direction == \"forward\" {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 65.01042063324304}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitor!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitor = &distanceMonitor{\n\t\tdistance: make(chan float64),\n\t\tstop:     d.stopDistanceMonitor,\n\t\twait:     &sync.WaitGroup{},\n\t}\n\n\td.distanceMonitor.wait.Add(1)\n\tgo d.distanceMonitor.measure(d.interval)\n\n\treturn nil\n}", "CodeBleu_score": 40.87696052937954}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.running {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.running = true\n\td.stop = make(chan bool)\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.measureDistance()\n\t\t\t\tif err!= nil {\n\t\t\t\t\tgobot.DefaultLogger.Errorf(\"distance monitor error: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.Distance = distance\n\t\t\t\t}\n\t\t\t\ttime.Sleep(d.interval)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 49.70453929688555}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitor!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitor = &distanceMonitor{\n\t\tstop: d.stopDistanceMonitor,\n\t}\n\td.distanceMonitor.waitGroup.Add(1)\n\tgo d.distanceMonitor.measureDistance(d.interval)\n\treturn nil\n}", "CodeBleu_score": 37.5439340924562}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, event string, start, end uint32) {\n\t\tswitch event {\n\t\tcase \"rising\":\n\t\t\td.start = start\n\t\tcase \"falling\":\n\t\t\td.duration = time.Duration(end-start) * time.Nanosecond\n\t\t\td.distance = d.duration.Nanoseconds() / 58\n\t\t\td.channel <- d.distance\n\t\t}\n\t}\n}", "CodeBleu_score": 44.37119294370448}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, eventName string, value uint32, timestamp uint32) {\n\t\tswitch eventName {\n\t\tcase \"rising\":\n\t\t\td.start = time.Now()\n\t\tcase \"falling\":\n\t\t\td.duration = time.Since(d.start)\n\t\t\td.distance = duration.Nanoseconds() / 1000000\n\t\t\td.notify()\n\t\t}\n\t}\n}", "CodeBleu_score": 35.301409796911756}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, event string, value uint32, timestamp uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\td.durationChan <- time.Since(start)\n\t\t}\n\t}\n}", "CodeBleu_score": 35.73283782404418}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.trigger()\n\tselect {\n\tcase <-d.done:\n\t\treturn fmt.Errorf(\"timeout\")\n\tcase d.distance = <-d.distanceChan:\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.662560950445993}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.trigger.On()\n\ttime.Sleep(d.pulseDuration)\n\td.trigger.Off()\n\n\tselect {\n\tcase <-d.done:\n\t\treturn fmt.Errorf(\"timeout\")\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\tcase <-d.done:\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n}", "CodeBleu_score": 39.223977314010796}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif err := d.sensor.Trigger(); err!= nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase <-d.sensor.Measurements():\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n}", "CodeBleu_score": 39.81999141947622}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    # Check if the token is available in the environment variables.\n    if self.token:\n        return self.token\n\n    # Check the local state for a valid access token and its expiration time.\n    if self.state.get(\"access_token\") and self.state.get(\"access_token_expires_at\") > time.time():\n        return self.state.get(\"access_token\")\n\n    # Check if a refresh token is available.\n    if self.state.get(\"refresh_token\"):\n        # Attempt to fetch a new access token using the refresh token.\n        try:\n            response = self.client.post(\n                \"/api/v1/account/token\",\n                json={\n                    \"grant_type\": \"refresh_token\",\n                    \"refresh_token\": self.state.get(\"refresh_token\"),\n                },\n            )\n        except HTTPClientError as exc:\n            if exc.code!= 400:\n                raise\n            response = None\n\n        # If the request was successful, update the local state with the new authentication data and return the new access token.\n        if response and response.get(\"access_token\"):\n            self.state[\"access_token\"] = response.get(\"access_token\")\n            self.state[\"access_token_expires_at\"] = time.time() + response.get(\"expires_in\")\n            self.state[\"refresh_token\"] = response.get(\"refresh_token\")\n            return response.get(\"access_token\")\n\n    # If all methods fail, raise an \"AccountNotAuthorized\" exception.\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 48.44459009512474}, {"code": "def fetch_authentication_token(self)\n\t\n    if \"PLATFORMIO_ACCESS_TOKEN\" in os.environ:\n        return os.environ[\"PLATFORMIO_ACCESS_TOKEN\"]\n    if self._get_local_state(\"token\"):\n        return self._get_local_state(\"token\")\n    if self._get_local_state(\"refresh_token\"):\n        try:\n            return self._refresh_token()\n        except HTTPClientError as exc:\n            if exc.status_code == 401:\n                self._clear_local_state()\n                raise AccountNotAuthorized(\n                    \"Your access token is expired. Please re-authorize the application.\"\n                )\n            else:\n                raise exc\n    raise AccountNotAuthorized(\"Please re-authorize the application.\")\n\n", "CodeBleu_score": 30.6461417179011}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        access_token = os.environ['PLATFORMIO_ACCOUNT_ACCESS_TOKEN']\n    except KeyError:\n        try:\n            access_token = self.local_state.get('access_token')\n            expires_at = self.local_state.get('expires_at')\n            if access_token and expires_at and time.time() < expires_at:\n                return access_token\n            refresh_token = self.local_state.get('refresh_token')\n            if not refresh_token:\n                raise __accounts_api__.AccountNotAuthorized()\n            response = self.request(\n                'POST',\n                '/oauth2/token',\n                data={\n                    'grant_type':'refresh_token',\n                   'refresh_token': refresh_token,\n                    'client_id': self.client_id,\n                    'client_secret': self.client_secret,\n                }\n            )\n            access_token = response.get('access_token')\n            expires_at = time.time() + response.get('expires_in')\n            self.local_state.update({\n                'access_token': access_token,\n                'expires_at': expires_at,\n            })\n            return access_token\n        except KeyError:\n            raise __accounts_api__.AccountNotAuthorized()\n\n", "CodeBleu_score": 38.792822991576614}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        if refresh_token is None:\n            return False\n        self.delete_session()\n        try:\n            response = self.http.post(\n                \"/v1/logout\", {\"refresh_token\": refresh_token}, timeout=10\n            )\n        except HTTPClientError:\n            return True\n        if response.status_code == 200:\n            return True\n        else:\n            raise UserSideException(\n                \"Logout failed. Status code: %s\" % response.status_code\n            )\n    except HTTPClientError:\n        return False\n\n", "CodeBleu_score": 46.96182618495472}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        if refresh_token:\n            self.delete_session()\n            try:\n                self.http_client.post(\n                    \"/v1/logout\",\n                    data={\"refresh_token\": refresh_token},\n                    headers={\"Authorization\": \"Bearer %s\" % self.get_access_token()},\n                )\n            except HTTPClientError:\n                pass\n            return True\n    except HTTPClientError:\n        pass\n    return False\n\n", "CodeBleu_score": 51.67326819685696}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        if refresh_token:\n            self.delete_local_session()\n            self.post(\"/v1/logout\", data={\"refresh_token\": refresh_token})\n            return True\n        return False\n    except HTTPClientError as e:\n        if e.status_code == 400:\n            return True\n        raise e\n\n", "CodeBleu_score": 49.715434022317126}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    # List of non-optional packages with their names and versions\n    packages = []\n    # Iterate through the packages\n    for package in self.get_installed_packages():\n        # Skip optional packages\n        if package.metadata.get(\"optional\", False):\n            continue\n        # Collect metadata for the others\n        metadata = {\n            \"name\": package.name,\n            \"version\": package.version,\n            \"source_url\": package.source_url,\n        }\n        # If the package is external, include the source URL\n        if package.metadata.get(\"external\", False):\n            metadata[\"source_url\"] = package.source_url\n        # Add the package to the list\n        packages.append(metadata)\n    # Return the list of packages\n    return packages\n\n", "CodeBleu_score": 33.05470189076643}, {"code": "def dump_used_packages(self)\n\t\n    self.used_packages = []\n    for pkg in self.packages:\n        if not pkg.is_optional:\n            pkg_spec = PackageSpec(pkg.name, pkg.version)\n            pkg_meta = pkg_spec.get_metadata()\n            if pkg_meta:\n                self.used_packages.append({\n                    \"name\": pkg_spec.name,\n                    \"version\": pkg_spec.version,\n                    \"url\": pkg_meta.get(\"url\", None)\n                })\n    return self.used_packages\n\n", "CodeBleu_score": 29.682070533278853}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for package in self.packages:\n        if package.spec.optional:\n            continue\n        if package.spec.external:\n            packages.append({\n                \"name\": package.name,\n                \"version\": package.version,\n                \"source\": package.spec.external,\n            })\n        else:\n            packages.append({\n                \"name\": package.name,\n                \"version\": package.version,\n            })\n    return packages\n\n", "CodeBleu_score": 25.91970671262732}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    env_name = env.lower()\n    if not env_name:\n        raise UndefinedEnvPlatformError(env)\n\n    # Load environment specification\n    env_spec = ProjectConfig.get_instance().get_env_platform(env_name)\n    if not env_spec:\n        raise UndefinedEnvPlatformError(env)\n\n    # Create an instance of the class\n    return cls(env_spec, targets, autoinstall)\n\n", "CodeBleu_score": 38.62964379180141}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    env_platform = ProjectConfig.get_instance().get_env_platform(env)\n    if not env_platform:\n        raise UndefinedEnvPlatformError(env)\n    return cls.from_spec(env_platform, targets=targets, autoinstall=autoinstall)\n\n", "CodeBleu_score": 21.93775216290001}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    try:\n        platform = ProjectConfig.get_instance().get_platform_spec(env)\n    except UnknownPlatform:\n        raise UndefinedEnvPlatformError(env)\n\n    return cls(platform, targets, autoinstall)\n\n", "CodeBleu_score": 30.097172638539902}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 66.51085749887085}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 68.97880803785503}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tuint8_t AddrBuff[2];\n\tAddrBuff[0] = Addr;\n\tAddrBuff[1] = 0;\n\tI2C_Write(AddrBuff, 2);\n\tI2C_Read(Buff, Size);\n}", "CodeBleu_score": 23.258730019524126}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us!= 0) {\n\t\tEnableTimer(time_in_us);\n\t}\n\telse {\n\t\tDisableTimer();\n\t}\n\tInitiateDeepSleep();\n}", "CodeBleu_score": 40.45333802040015}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep(true);\n\tif (time_in_us > 0) {\n\t\t// Enable timer\n\t\tAXP192_write_reg(AXP192_TIMER_CTL, 0x80);\n\t\t// Set timer\n\t\tAXP192_write_reg(AXP192_TIMER, (time_in_us >> 8) & 0xFF);\n\t\tAXP192_write_reg(AXP192_TIMER + 1, time_in_us & 0xFF);\n\t} else {\n\t\t// Disable timer\n\t\tAXP192_write_reg(AXP192_TIMER_CTL, 0x00);\n\t}\n\t// Initiate deep sleep\n\tAXP192_write_reg(AXP192_POWER_CTL, 0x04);\n}", "CodeBleu_score": 39.94002043453868}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tEnableTimerWakeup(time_in_us);\n\t} else {\n\t\tDisableTimerWakeup();\n\t}\n\tEnterDeepSleep();\n}", "CodeBleu_score": 48.57636599934446}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = _scroll_addr;\n\tif (y + _font_height > _display_height - _fixed_bottom) {\n\t\ty = _fixed_top;\n\t}\n\tif (y + _font_height > _display_height - _fixed_bottom) {\n\t\ty = _fixed_top_tteBar;\n\t}\n\t_display->fillRect(0, y, _display_width, _font_height, color);\n\ty += _font_height;\n\t_scroll_addr = y;\n\treturn y;\n}", "CodeBleu_score": 17.96065718645328}, {"code": "int Display::scroll_line(uint32_t color){\n\t\t// get the current y-coordinate\n\tint y = this->scroll_addr;\n\t// fill a rectangle with the specified color\n\tthis->fill_rect(0, y, this->width, y + this->font_height, color);\n\t// increment the y-coordinate by the height of a text line\n\ty += this->font_height;\n\t// wrap around if it exceeds the display boundaries minus the bottom fixed area\n\tif (y > this->height - this->font_height) {\n\t\ty = 0;\n\t}\n\t// use alternative top fixed area coordinates if a specific condition (tteBar) is met\n\tif (this->tteBar) {\n\t\ty = this->font_height;\n\t}\n\t// update the scroll address\n\tthis->scroll_addr = y;\n\t// return the previous y-coordinate\n\treturn y - this->font_height;\n}", "CodeBleu_score": 6.443936544451827}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y_prev = y_scroll;\n\ty_scroll += font_height;\n\tif (y_scroll >= (display_height - font_height - fixed_area_bottom)) {\n\t\ty_scroll = fixed_area_top;\n\t}\n\tif (tteBar) {\n\t\ty_scroll = fixed_area_top_tte;\n\t}\n\t// fill rectangle\n\tdisplay.fillRect(0, y_prev, display_width, font_height, color);\n\treturn y_prev;\n}", "CodeBleu_score": 19.613877139922657}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\tif (!this->setHtmlContent(ssids)) {\n\t\treturn false;\n\t}\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 59.55315089581513}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setup_access_points(access_points)) {\n\t\treturn false;\n\t}\n\tif (!this->setup_html_content(ssids)) {\n\t\treturn false;\n\t}\n\tthis->start_portal();\n\treturn true;\n}", "CodeBleu_score": 57.72725320227108}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t//setup access points\n\tif (!this->setupAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\t//setup HTML content\n\tif (!this->setupHTML(ssids)) {\n\t\treturn false;\n\t}\n\t//start portal\n\tthis->portal.begin();\n\treturn true;\n}", "CodeBleu_score": 57.28082101856323}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (queue_size == 0) {\n\t\t\tqueue_size = GPS_QUEUE_SIZE;\n\t\t\tqueue = (char*) malloc(queue_size * sizeof(char));\n\t\t\ttext = (char*) malloc(queue_size * sizeof(char));\n\t\t\ttext_in = (char*) malloc(queue_size * sizeof(char));\n\t\t}\n\t} else {\n\t\tqueue_size = GPS_QUEUE_SIZE;\n\t\tqueue = (char*) malloc(queue_size * sizeof(char));\n\t\ttext = (char*) malloc(queue_size * sizeof(char));\n\t\ttext_in = (char*) malloc(queue_size * sizeof(char));\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 8.212172691276464}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag == false) {\n\t\t//flush the queue\n\t\twhile (queue.available()) {\n\t\t\tqueue.read();\n\t\t}\n\t\t//set the queue_enabled_flag\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 6.415941230029413}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (!queue_enabled_flag) {\n\t\tqueue_enabled_flag = true;\n\t\tqueue.flush();\n\t\ttext.flush();\n\t\ttext_in.flush();\n\t}\n}", "CodeBleu_score": 6.481067063572055}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (nmea_queue!= NULL) {\n\t\tdelete nmea_queue;\n\t\tnmea_queue = NULL;\n\t}\n\tnmea_queue = new Queue<NmeaSentence>();\n}", "CodeBleu_score": 38.612130269501385}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea!= NULL) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = new Queue<string>();\n\t}\n\telse {\n\t\tqueue_nmea = new Queue<string>();\n\t}\n}", "CodeBleu_score": 39.4027148861063}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea!= NULL) {\n\t\tthis->queue_nmea->flush();\n\t\tdelete this->queue_nmea;\n\t}\n\tthis->queue_nmea = new Queue<char*>();\n}", "CodeBleu_score": 17.808216142199758}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint32_t w, h;\n\tw = (area->x2 - area->x1 + 1);\n\th = (area->y2 - area->y1 + 1);\n\n\tuint32_t x_offset = area->x1;\n\tuint32_t y_offset = area->y1;\n\n\tuint32_t x_start = x_offset;\n\tuint32_t y_start = y_offset;\n\n\tuint32_t x_end = x_start + w - 1;\n\tuint32_t y_end = y_start + h - 1;\n\n\tuint32_t x_index = 0;\n\tuint32_t y_index = 0;\n\n\tuint32_t x_diff = x_end - x_start;\n\tuint32_t y_diff = y_end - y_start;\n\n\tuint32_t x_diff_1 = x_diff - 1;\n\tuint32_t y_diff_1 = y_diff - 1;\n\n\tuint32_t x_diff_2 = x_diff - 2;\n\tuint32_t y_diff_2 = y_diff - 2;\n\n\tuint32_t x_diff_3 = x_diff - 3;\n\tuint32_t y_diff_3 = y_diff - 3;\n\n\tuint32_t x_diff_4 = x_diff - 4;\n\tuint32_t y_diff_4 = y_diff - 4;\n\n\tuint32_t x_diff_5 = x_diff - 5;\n\tuint32_t y_diff_5 = y_diff - 5;\n\n\tuint32_t x_diff_6 = x_diff - 6;\n\tuint32_t y_diff_6 = y_diff - 6;\n\n\tuint32_t x_diff_7 = x_diff - 7;\n\tuint32_t y_diff_7 = y_diff - 7;\n\n\tuint32_t x_diff_8 = x_diff - ", "CodeBleu_score": 33.4085305465721}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint32_t w = (uint32_t)(area->x2 - area->x1 + 1);\n\tuint32_t h = (uint32_t)(area->y2 - area->y1 + 1);\n\tuint32_t row_size = w * 2;\n\tuint32_t buf_size = row_size * h;\n\tuint8_t *buf = malloc(buf_size);\n\tuint8_t *buf_tmp = buf;\n\tuint32_t x, y;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\t*buf_tmp++ = color_p->full >> 8;\n\t\t\t*buf_tmp++ = color_p->full;\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\tILI9341_Write_Command(0x2C);\n\tILI9341_Write_Data_Multiple(buf, buf_size);\n\tfree(buf);\n}", "CodeBleu_score": 39.825434725520026}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint32_t w = (uint32_t)(area->x2 - area->x1 + 1);\n\tuint32_t h = (uint32_t)(area->y2 - area->y1 + 1);\n\tuint32_t row, col;\n\tuint32_t index;\n\tuint8_t *fb = disp->driver.fb;\n\tuint32_t bpp = disp->driver.info.pixel_format == LV_IMG_CF_INDEXED_1BIT? 1 : disp->driver.info.pixel_format == LV_IMG_CF_INDEXED_2BIT? 2 : disp->driver.info.pixel_format == LV_IMG_CF_INDEXED_4BIT? 4 : disp->driver.info.pixel_format == LV_IMG_CF_INDEXED_8BIT? 8 : disp->driver.info.pixel_format == LV_IMG_CF_TRUE_COLOR? 24 : disp->driver.info.pixel_format == LV_IMG_CF_TRUE_COLOR_ALPHA? 32 : 0;\n\tuint32_t bytes_per_pixel = bpp / 8;\n\tuint32_t bytes_per_line = w * bytes_per_pixel;\n\tuint32_t byte_offset = 0;\n\n\tfor (row = 0; row < h; row++) {\n\t\tfor (col = 0; col < w; col++) {\n\t\t\tindex = (row * bytes_per_line) + (col * bytes_per_pixel);\n\t\t\tfb[byte_offset + index] = color_p->blue;\n\t\t\tfb[byte_offset + index + 1] = color_p->green;\n\t\t\tfb[byte_offset + index + 2] = color_p->red;\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 38.497346924267845}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < layer; i++) {\n\t\tcout << \"\\t\";\n\t}\n\n\tcout << menu->getName() << endl;\n\n\tfor (int i = 0; i < layer; i++) {\n\t\tcout << \"\\t\";\n\t}\n\n\tcout << \"Options:\" << endl;\n\n\tfor (int i = 0; i < layer + 1; i++) {\n\t\tcout << \"\\t\";\n\t}\n\n\tcout << \"1. Back\" << endl;\n\n\tfor (int i = 0; i < menu->getMenuSize(); i++) {\n\t\tshowMenuList(menu->getMenuNode(i), layer + 1);\n\t}\n}", "CodeBleu_score": 47.08929573482295}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\t// Iterate through all nodes in the menu\n\tfor (int i = 0; i < menu->size(); i++) {\n\t\t// Print the name of the node with indentation proportional to the layer level\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \"\\t\";\n\t\t}\n\t\tcout << menu->get(i)->getName() << endl;\n\t\t// If the node has children, call this function recursively to print the children\n\t\tif (menu->get(i)->hasChildren()) {\n\t\t\tshowMenuList(menu->get(i)->getChildren(), layer + 1);\n\t\t}\n\t}\n\t// Print an empty line after listing all nodes\n\tcout << endl;\n}", "CodeBleu_score": 45.65241562431914}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tMenuNode * temp = menu->getHead();\n\tint i;\n\tfor (i = 0; i < layer; i++)\n\t\tcout << \" \";\n\twhile (temp!= NULL) {\n\t\tcout << temp->getName() << endl;\n\t\tshowMenuList(temp->getSubMenu(), layer + 1);\n\t\ttemp = temp->getNext();\n\t}\n\tcout << endl;\n}", "CodeBleu_score": 41.646254696478714}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\t// Iterate through the given count.\n\tfor (int i = 0; i < count; i++) {\n\t\t// Generate a random SSID.\n\t\tString SSID = generateSSID();\n\t\t// Generate a random channel.\n\t\tint channel = generateChannel();\n\t\t// Generate a random MAC address.\n\t\tString MAC = generateMAC();\n\t\t// Print the SSID to the serial output.\n\t\tSerial.println(SSID + \" \" + channel + \" \" + MAC);\n\t}\n\treturn count;\n}", "CodeBleu_score": 23.215710836348958}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint ssidCount = 0;\n\tString ssid;\n\tint channel;\n\tString mac;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tssid = \"\";\n\t\tchannel = random(1, 13);\n\t\tmac = \"\";\n\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char)random(97, 122);\n\t\t}\n\n\t\tfor (int j = 0; j < 12; j++) {\n\t\t\tmac += (char)random(48, 57);\n\t\t}\n\n\t\tWiFi.softAP(ssid.c_str(), \"\", channel, false);\n\t\tWiFi.softAPmacAddress(mac.c_str());\n\n\t\tSerial.print(\"SSID: \");\n\t\tSerial.println(ssid);\n\n\t\tSerial.print(\"Channel: \");\n\t\tSerial.println(channel);\n\n\t\tSerial.print(\"MAC: \");\n\t\tSerial.println(mac);\n\n\t\tSerial.println();\n\n\t\tssidCount++;\n\t}\n\n\treturn ssidCount;\n}", "CodeBleu_score": 41.041808136353104}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint ssidCount = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char)random(33, 126);\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tmac += (char)random(33, 126);\n\t\t\tif (j < 4) {\n\t\t\t\tmac += \":\";\n\t\t\t}\n\t\t}\n\t\tWiFiScan::addSSID(ssid, channel, mac);\n\t\tssidCount++;\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 38.738928848689255}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher_client = pubsub_v1.PublisherClient()\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n    topic = pubsub_v1.Topic(name=topic_path)\n    topic = publisher_client.create_topic(request={\"name\": topic_path, \"topic\": topic})\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 38.519554269168424}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = pubsub_v1.Topic(name=topic_path)\n    response = publisher.create_topic(request={\"name\": topic_path, \"topic\": topic})\n    print(\"Topic created: {}\".format(response.name))\n\n", "CodeBleu_score": 51.991904140221315}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = pubsub_v1.Topic(name=topic_path)\n    try:\n        topic = publisher.create_topic(topic)\n        print(\"Created topic {}.\".format(topic.name))\n    except Exception as e:\n        print(\"Failed to create topic {}: {}\".format(topic_path, e))\n\n", "CodeBleu_score": 55.42997162242781}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 76.4527720693834}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    private_key = open(private_key_file, 'r').read()\n    iat = datetime.datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    iat = iat.strftime('%Y-%m-%d %H:%M:%S')\n    exp = exp.strftime('%Y-%m-%d %H:%M:%S')\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': project_id\n    }\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n    return encoded_jwt\n\n", "CodeBleu_score": 44.18950845726361}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n\n    # Create a JWT to authenticate as a service account.\n    jwt_payload = {\n        # The time that the token was issued at\n        'iat': datetime.datetime.utcnow(),\n        # The time the token expires.\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        # Your Google Cloud Platform project ID.\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    return jwt.encode(jwt_payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 54.60858301675265}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message '\" + str(message.payload.decode(\"utf-8\")) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos))\n    if message.payload.decode(\"utf-8\") == \"on\":\n        # Capture a preview image\n        os.system(\"raspistill -o preview.jpg\")\n        # Upload the image to a specified bucket\n        client = storage.Client()\n        bucket = client.get_bucket(BUCKET_NAME)\n        blob = bucket.blob(FILE_NAME)\n        blob.upload_from_filename(FILE_NAME)\n        # Publish the file's URL to an MQTT event topic\n        event_topic = EVENT_TOPIC + \"/preview.jpg\"\n        client.publish(event_topic, blob.public_url)\n        print(\"Published preview image to \" + event_topic)\n    else:\n        print(\"Received 'off'\")\n\n", "CodeBleu_score": 40.45774940651119}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message from {}: {}\".format(message.topic, message.payload))\n    if message.payload.decode(\"utf-8\") == \"on\":\n        print(\"Capturing image...\")\n        capture_image()\n        print(\"Uploading image...\")\n        upload_image()\n        print(\"Publishing image URL...\")\n        publish_image_url()\n    elif message.payload.decode(\"utf-8\") == \"off\":\n        print(\"off\")\n\n", "CodeBleu_score": 22.22425205202035}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos))\n    if message.payload == b'on':\n        print(\"Capturing image\")\n        # Capture image\n        os.system('raspistill -o preview.jpg')\n        # Upload image to storage\n        print(\"Uploading image to storage\")\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket(BUCKET_NAME)\n        blob = bucket.blob(IMAGE_NAME)\n        blob.upload_from_filename(IMAGE_NAME)\n        # Publish image URL to event topic\n        print(\"Publishing image URL\")\n        publish_image_url(IMAGE_NAME)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 36.03281660861226}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"\"\"\\", "CodeBleu_score": 1.0351657469471631}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\"--subscription_name\", default=os.environ.get(\"SUBSCRIPTION_NAME\"))\n    return parser.parse_args()\n\n", "CodeBleu_score": 41.178470808231296}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection')\n    parser.add_argument('--project_id',\n                        help='Google Cloud project ID',\n                        required=False)\n    parser.add_argument('--subscription_name',\n                        help='Google Cloud Pub/Sub subscription name',\n                        required=True)\n    return parser.parse_args()\n\n", "CodeBleu_score": 33.95564841932362}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/v1/projects/{project_id}/locations/{location}/registries/{registry_id}'.format(project_id=os.environ['GOOGLE_CLOUD_PROJECT'], location='us-central1', registry_id='my-registry')\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n    credentials = credentials.with_scopes(scopes)\n    client = discovery.build('cloudiot', version, credentials=credentials, discoveryServiceUrl=discovery_url)\n    return client\n\n", "CodeBleu_score": 45.97803561607385}, {"code": "def get_client(service_account_json)\n\t\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/v1/projects/{}/locations/us-central1/registries/{}'\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n    scoped_credentials = credentials.with_scopes(scopes)\n    client = discovery.build('cloudiot', version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n    return client\n\n", "CodeBleu_score": 22.476891405515815}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/cloudiot\",\n    ]\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n    credentials = credentials.with_scopes(\n        [\"https://www.googleapis.com/auth/pubsub\"]\n    )\n    client = discovery.build(\"cloudiot\", \"v1\", credentials=credentials)\n    return client\n\n", "CodeBleu_score": 21.34521859696317}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = hash_method.to_asn1()\n    if not hash_method_asn1:\n        raise common.HashMethodNotFound(hash_method)\n    hash_value_asn1 = hash_method_asn1 + hash_value\n    padded_hash = transform.pad_for_signing(hash_value_asn1, priv_key.bits)\n    return core.encrypt_int(padded_hash, priv_key)\n\n", "CodeBleu_score": 27.565026568309086}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = common.hash_method_to_asn1(hash_method)\n    if hash_method_asn1 is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_value_asn1 = transform.bytes_to_integer(hash_value)\n    padded_hash_value = transform.pad_for_signing(hash_value_asn1, hash_method_asn1)\n    signature = transform.integer_to_bytes(priv_key.decrypt(padded_hash_value))\n    return signature\n\n", "CodeBleu_score": 36.10729973723648}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_asn1 = common.hash_methods[hash_method]\n    hash_asn1_len = len(hash_asn1)\n    hash_value_len = len(hash_value)\n    if hash_value_len!= hash_asn1_len:\n        raise ValueError(\"Hash value length does not match hash method\")\n    padded_hash = hash_asn1 + hash_value\n    if priv_key.key_size < len(padded_hash) * 8:\n        raise ValueError(\"Key size is too small for hash method\")\n    padded_hash = transform.pad(padded_hash, priv_key.key_size)\n    signature = core.encrypt_int(padded_hash, priv_key.n, priv_key.e)\n    return signature\n\n", "CodeBleu_score": 31.812724748355947}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    sig_int = transform.bytes_to_int(signature)\n    # Decrypt the signature\n    clear_sig = pub_key.decrypt(sig_int)\n    # Determine the hash method used\n    hash_method = common.hash_method_for_key(pub_key)\n    # Compute the hash of the message\n    message_hash = hash_method(message).digest()\n    # Reconstruct the padded hash\n    padded_hash = transform.int_to_bytes(transform.pad_hash(message_hash, pub_key.key_size))\n    # If the expected padded hash does not match the clear signature, raise a verification error\n    if padded_hash!= clear_sig:\n        raise common.VerificationError(\"Signature does not match message digest.\")\n    # If the verification is successful, return the hash method name\n    return hash_method.name\n\n", "CodeBleu_score": 20.966882248460973}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError('message must be bytes')\n    if not isinstance(signature, bytes):\n        raise TypeError('signature must be bytes')\n    if not isinstance(pub_key, core.PublicKey):\n        raise TypeError('public key must be PublicKey')\n    if len(signature)!= pub_key.size:\n        raise ValueError('signature length must be equal to public key size')\n\n    # Convert the signature to an integer\n    sig_int = transform.bytes_to_int(signature)\n\n    # Decrypt the signature to obtain the clear signature\n    clear_sig = pub_key.decrypt(sig_int, common.RAW)\n\n    # Determine the hash method used\n    if pub_key.hash_method == common.SHA1:\n        hash_method ='sha1'\n    elif pub_key.hash_method == common.SHA224:\n        hash_method ='sha224'\n    elif pub_key.hash_method == common.SHA256:\n        hash_method ='sha256'\n    elif pub_key.hash_method == common.SHA384:\n        hash_method ='sha384'\n    elif pub_key.hash_method == common.SHA512:\n        hash_method ='sha512'\n    else:\n        raise ValueError('unknown hash method')\n\n    # Compute the hash of the message\n    hash_obj = getattr(hashlib, hash_method)()\n    hash_obj.update(message)\n    hash_int = transform.bytes_to_int(hash_obj.digest())\n\n    # Reconstruct the expected padded hash\n    padded_hash = transform.int_to_bytes(hash_int, pub_key.size)\n\n    # If the expected padded hash does not match the clear signature, raise a verification error\n    if padded_hash!= clear_sig:\n        raise core.VerificationError('signature does not match')\n\n    # If the verification is successful, return the hash method name\n    return hash_method\n\n", "CodeBleu_score": 36.05885885310227}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    sig = common.b2i(signature)\n    # Decrypt the signature\n    clear_sig = pub_key.decrypt(sig)\n    # Determine the hash method\n    if pub_key.e == 65537:\n        hash_method = \"sha1\"\n    else:\n        hash_method = \"sha256\"\n    # Compute the hash of the message\n    if hash_method == \"sha1\":\n        hash_func = hashlib.sha1\n    elif hash_method == \"sha256\":\n        hash_func = hashlib.sha256\n    hash_obj = hash_func()\n    hash_obj.update(message)\n    hash_val = hash_obj.digest()\n    # Reconstruct the expected padded hash\n    if pub_key.e == 65537:\n        padded_hash = transform.pad(hash_val, 11)\n    else:\n        padded_hash = transform.pad(hash_val, 31)\n    # Compare the expected padded hash to the clear signature\n    if padded_hash!= clear_sig:\n        raise core.VerificationError(\"Signature does not match hash.\")\n    return hash_method\n\n", "CodeBleu_score": 27.854013594339445}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tint32_t status;\n\tuint32_t currentTime;\n\tcurrentTime = get_current_time();\n\tif (currentTime!= 0) {\n\t\tstatus = update_JWT(currentTime);\n\t\tif (status!= 0) {\n\t\t\tDEBUG_PRINT(\"Error updating JWT\");\n\t\t}\n\t}\n\tstatus = connect_MQTT_client();\n\tif (status == 0) {\n\t\tDEBUG_PRINT(\"MQTT connection established\");\n\t\tmqtt_subscribe_flag = 1;\n\t} else {\n\t\tDEBUG_PRINT(\"MQTT connection failed\");\n\t}\n}", "CodeBleu_score": 42.67241288002806}, {"code": "static void connectMQTT(){\n\t\tuint32_t time = 0;\n\tif (clock_get_time(&time)) {\n\t\tupdateJWT(time);\n\t\tmqtt_connect();\n\t\tmqtt_subscribe = true;\n\t\tDEBUG_PRINT(\"MQTT connection established.\n\");\n\t} else {\n\t\tDEBUG_PRINT(\"MQTT connection failed.\n\");\n\t}\n}", "CodeBleu_score": 20.843259537913063}, {"code": "static void connectMQTT(){\n\t\tuint32_t currentTime = 0;\n\tcurrentTime = get_current_time();\n\tif (currentTime > 0) {\n\t\tupdate_jwt(currentTime);\n\t}\n\tconnect_to_mqtt_client();\n\tsend_mqtt_subscribe = 1;\n\tDEBUG_PRINT(\"MQTT connection attempt\n\");\n}", "CodeBleu_score": 29.795466146490813}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tvalue = value * 10 + (str[i] - '0');\n\t}\n\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 26.342415643378075}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t temp = 0;\n\tint i;\n\n\tif (str == NULL || num == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9')\n\t\t\treturn str;\n\t\ttemp = temp * 10 + (str[i] - '0');\n\t}\n\n\t*num = temp;\n\treturn str + width;\n}", "CodeBleu_score": 25.85037649152487}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tint i;\n\tuint32_t n = 0;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + (str[i] - '0');\n\t}\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 26.350323495678246}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tint i;\n\tuint8_t* p = NULL;\n\tuint8_t* p_end = NULL;\n\tuint8_t* p_tmp = NULL;\n\tuint8_t* p_tmp_end = NULL;\n\tuint8_t* p_tmp_start = NULL;\n\tuint8_t* p_tmp_end_start = NULL;\n\tuint8_t* p_tmp_end_end = NULL;\n\tuint8_t* p_tmp_end_end_start = NULL;\n\tuint8_t* p_tmp_end_end_end = NULL;\n\tuint8_t* p_tmp_end_end_end_start = NULL;\n\tuint8_t* p_tmp_end_end_end_end = NULL;\n\tuint8_t* p_tmp_end_end_end_end_start = NULL;\n\tuint8_t* p_tmp_end_end_end_end_end = NULL;\n\tuint8_t* p_tmp_end_end_end_end_end_start = NULL;\n\tuint8_t* p_tmp_end_end_end_end_end_end = NULL;\n\tuint8_t* p_tmp_end_end_end_end_end_end_start = NULL;\n\tuint8_t* p_tmp_end_end_end_end_end_end_end = NULL;\n\tuint8_t* p_tmp_end_end_end_end_end_end_end_start = NULL;\n\tuint8_t* p_tmp_end_end_end_end_end_end_end_end = NULL;\n\tuint8_t* p_tmp_end_end_end_end_end_end_end_end_start = NULL;\n\tuint8_t* p_tmp_end_end_end_end_end_end_end_end_end = NULL;\n\tuint8_t* p_tmp_end_end_end_end_end_end_end_end_end_start = NULL;\n\tuint8_t* p_tmp_end_end_end", "CodeBleu_score": 10.6225131086305}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tuint8_t* cert_data = NULL;\n\tuint8_t* cert_data_ptr = NULL;\n\tuint8_t* cert_data_end = NULL;\n\tuint8_t* cert_data_end_ptr = NULL;\n\tuint8_t* cert_data_end_ptr_temp = NULL;\n\tuint8_t* cert_data_end_ptr_temp2 = NULL;\n\tuint8_t* cert_data_end_ptr_temp3 = NULL;\n\tuint8_t* cert_data_end_ptr_temp4 = NULL;\n\tuint8_t* cert_data_end_ptr_temp5 = NULL;\n\tuint8_t* cert_data_end_ptr_temp6 = NULL;\n\tuint8_t* cert_data_end_ptr_temp7 = NULL;\n\tuint8_t* cert_data_end_ptr_temp8 = NULL;\n\tuint8_t* cert_data_end_ptr_temp9 = NULL;\n\tuint8_t* cert_data_end_ptr_temp10 = NULL;\n\tuint8_t* cert_data_end_ptr_temp11 = NULL;\n\tuint8_t* cert_data_end_ptr_temp12 = NULL;\n\tuint8_t* cert_data_end_ptr_temp13 = NULL;\n\tuint8_t* cert_data_end_ptr_temp14 = NULL;\n\tuint8_t* cert_data_end_ptr_temp15 = NULL;\n\tuint8_t* cert_data_end_ptr_temp16 = NULL;\n\tuint8_t* cert_data_end_ptr_temp17 = NULL;\n\tuint8_t* cert_data_end_ptr_temp18 = NULL;\n\tuint8_t* cert_data_end_ptr_temp19 = NULL;\n\tuint8_t* cert_data_end_ptr_temp20 = NULL;\n\tuint8_t* cert_data_end_ptr_temp21 = NULL;\n\tuint8_t* cert_data_end_ptr", "CodeBleu_score": 10.501346525454277}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = ATCACERT_E_SUCCESS;\n\tuint8_t i;\n\tuint8_t* cert_data = build_state->cert_data;\n\tuint16_t cert_size = build_state->cert_size;\n\tuint16_t cert_offset = build_state->cert_offset;\n\tuint16_t cert_len = 0;\n\tuint16_t cert_offset_next = 0;\n\tuint8_t* cert_data_next = NULL;\n\tuint8_t* cert_data_next_next = NULL;\n\tuint16_t cert_len_next = 0;\n\tuint16_t cert_offset_next_next = 0;\n\tuint8_t* cert_data_next_next_next = NULL;\n\tuint16_t cert_len_next_next = 0;\n\tuint16_t cert_offset_next_next_next = 0;\n\tuint8_t* cert_data_next_next_next_next = NULL;\n\tuint16_t cert_len_next_next_next = 0;\n\tuint16_t cert_offset_next_next_next_next = 0;\n\tuint8_t* cert_data_next_next_next_next_next = NULL;\n\tuint16_t cert_len_next_next_next_next = 0;\n\tuint16_t cert_offset_next_next_next_next_next = 0;\n\tuint8_t* cert_data_next_next_next_next_next_next = NULL;\n\tuint16_t cert_len_next_next_next_next_next = 0;\n\tuint16_t cert_offset_next_next_next_next_next_next = 0;\n\tuint8_t* cert_data_next_next_next_next_next_next_next = NULL;\n\tuint16_t cert_len_next_next_next_next_next_next = 0;\n\tuint16_t cert_offset_next_next_next_next_next_", "CodeBleu_score": 14.647192149995785}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint result = ATCACERT_E_SUCCESS;\n\tuint8_t tbs_digest[ATCA_SHA2_256_DIGEST_SIZE];\n\tuint8_t signature[ATCA_SHA2_256_DIGEST_SIZE];\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\t// Get the TBS digest\n\tresult = atcacert_get_tbs_digest_hw(cert_def, cert, cert_size, tbs_digest);\n\tif (result!= ATCACERT_E_SUCCESS) {\n\t\treturn result;\n\t}\n\n\t// Get the signature\n\tresult = atcacert_get_signature_hw(cert_def, cert, cert_size, signature);\n\tif (result!= ATCACERT_E_SUCCESS) {\n\t\treturn result;\n\t}\n\n\t// Verify the TBS digest against the signature\n\tresult = atcacert_verify_hw(tbs_digest, signature, ca_public_key);\n\tif (result!= ATCACERT_E_SUCCESS) {\n\t\treturn result;\n\t}\n\n\treturn ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 64.08715530302109}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\tuint8_t tmp_buf[64];\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (cert_size < cert_def->cert_size) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Get the digest of the certificate's TBS portion\n\tret = atcacert_get_cert_tbs_digest_hw(cert_def, cert, cert_size, tbs_digest);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Get the signature of the certificate\n\tret = atcacert_get_cert_signature_hw(cert_def, cert, cert_size, signature);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Verify the signature against the CA public key and the TBS digest\n\tret = atcacert_verify_signature_hw(ca_public_key, tbs_digest, signature, tmp_buf);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ATCA_SUCCESS;\n}", "CodeBleu_score": 69.50225693817983}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t digest[ATCA_SHA2_256_DIGEST_SIZE];\n\tuint8_t signature[ATCA_SIG_SIZE];\n\tuint8_t tbs_digest[ATCA_SHA2_256_DIGEST_SIZE];\n\tuint8_t ca_public_key_fixed[ATCA_PUB_KEY_SIZE];\n\tuint8_t ca_public_key_fixed_size = 0;\n\n\tif (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (cert_def->type == ATCA_CERT_TYPE_X509_CERT) {\n\t\tca_public_key_fixed_size = ATCA_PUB_KEY_SIZE;\n\t}\n\telse if (cert_def->type == ATCA_CERT_TYPE_PKCS7_SIGNED_DATA) {\n\t\tca_public_key_fixed_size = ATCA_PUB_KEY_SIZE_2048;\n\t}\n\telse {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Copy public key to fixed size buffer\n\tif (ca_public_key_fixed_size!= ATCA_PUB_KEY_SIZE) {\n\t\tmemcpy(ca_public_key_fixed, ca_public_key, ca_public_key_fixed_size);\n\t\tmemset(&ca_public_key_fixed[ca_public_key_fixed_size], 0, ATCA_PUB_KEY_SIZE - ca_public_key_fixed_size);\n\t}\n\telse {\n\t\tmemcpy(ca_public_key_fixed, ca_public_key, ca_public_key_fixed_size);\n\t}\n\n\t// Get the digest of the certificate's TBS portion\n\tret = atcacert_get_tbs_digest_hw(cert_def, cert, cert_size, tbs_digest);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Get the signature of the certificate\n\tret = atcacert_get_signature_hw(cert", "CodeBleu_score": 52.57528426435848}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t *current = *list;\n\ttimerStruct_t *prev = NULL;\n\n\tif(current == NULL)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\twhile(current!= timer)\n\t\t{\n\t\t\tprev = current;\n\t\t\tcurrent = current->next;\n\t\t}\n\n\t\tif(current == timer)\n\t\t{\n\t\t\tif(prev == NULL)\n\t\t\t{\n\t\t\t\t*list = current->next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprev->next = current->next;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n}", "CodeBleu_score": 28.0551894973188}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile *tmp = list;\n\ttimerStruct_t * volatile *prev = list;\n\twhile(*tmp!= NULL)\n\t{\n\t\tif(*tmp == timer)\n\t\t{\n\t\t\t*prev = (*tmp)->next;\n\t\t\treturn true;\n\t\t}\n\t\tprev = tmp;\n\t\ttmp = &(*tmp)->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 21.01765235720146}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile *list_iter = list;\n\twhile(*list_iter!= NULL)\n\t{\n\t\tif(*list_iter == timer)\n\t\t{\n\t\t\t*list_iter = timer->next;\n\t\t\treturn true;\n\t\t}\n\t\tlist_iter = &(*list_iter)->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 20.041295803049685}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tif (socket >= 0 && socket < BSD_MAX_SOCKETS) {\n\t\tif (BSD_sockets[socket].state == BSD_SOCKET_OPEN) {\n\t\t\tBSD_sockets[socket].state = BSD_SOCKET_NOT_A_SOCKET;\n\t\t\tif (close(BSD_sockets[socket].socket) == -1) {\n\t\t\t\tBSD_sockets[socket].state = BSD_SOCKET_ERROR;\n\t\t\t\tBSD_sockets[socket].error = BSD_ERROR_CLOSE;\n\t\t\t\treturn BSD_ERROR;\n\t\t\t}\n\t\t\treturn BSD_SUCCESS;\n\t\t}\n\t}\n\tBSD_sockets[socket].state = BSD_SOCKET_ERROR;\n\tBSD_sockets[socket].error = BSD_ERROR_CLOSE;\n\treturn BSD_ERROR;\n}", "CodeBleu_score": 37.00024128548475}, {"code": "int BSD_close(int socket){\n\t\tsocket_t *socket_ptr = (socket_t *) socket;\n\tif (socket_ptr == NULL) {\n\t\treturn BSD_ERROR;\n\t}\n\tif (socket_ptr->state == NOT_A_SOCKET) {\n\t\treturn BSD_ERROR;\n\t}\n\tsocket_ptr->state = NOT_A_SOCKET;\n\tsocket_ptr->socket = INVALID_SOCKET;\n\tif (close(socket)!= 0) {\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 37.379419300886404}, {"code": "int BSD_close(int socket){\n\t\tint status = BSD_SUCCESS;\n\tBSD_SOCKET_INFO *bsd_socket_info;\n\tbsd_socket_info = BSD_get_socket_info(socket);\n\tif (bsd_socket_info == NULL) {\n\t\tstatus = BSD_ERROR;\n\t\tBSD_set_error(BSD_ERROR_SOCKET_NOT_FOUND);\n\t\treturn status;\n\t}\n\tif (bsd_socket_info->state!= BSD_SOCKET_NOT_A_SOCKET) {\n\t\tif (bsd_socket_info->state == BSD_SOCKET_BOUND) {\n\t\t\tBSD_set_error(BSD_ERROR_SOCKET_NOT_CLOSED);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tbsd_socket_info->state = BSD_SOCKET_NOT_A_SOCKET;\n\t\tif (close(bsd_socket_info->socket) == SOCKET_ERROR) {\n\t\t\tstatus = BSD_ERROR;\n\t\t\tBSD_set_error(BSD_ERROR_SOCKET_NOT_CLOSED);\n\t\t}\n\t}\n\treturn status;\n}", "CodeBleu_score": 43.82307061168907}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint status;\n\n\tstatus = listen(socket, backlog);\n\n\tif (status < 0) {\n\t\tBSD_set_error(status);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 23.92730634100199}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret;\n\tret = listen(socket, backlog);\n\tif(ret < 0) {\n\t\tBSD_set_errno(ret);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 23.564927637505463}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret = listen(socket, backlog);\n\tif (ret!= SOCK_ERR_NO_ERROR) {\n\t\tDEBUG_PRINT(\"BSD_listen: error %d\n\", ret);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 18.446376106507824}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = 0;\n\n\tif (socket < 0) {\n\t\tret = BSD_EPROTOTYPE;\n\t} else {\n\t\tif (socket == BSD_AF_INET) {\n\t\t\tret = BSD_accept4(socket, addr, addrlen, 0);\n\t\t} else {\n\t\t\tret = BSD_EAFNOSUPPORT;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 23.801516185379647}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = 0;\n\tint sock_fd = 0;\n\n\t/*\n\t * Check if the socket is a valid socket\n\t */\n\tif (socket >= 0) {\n\t\tsock_fd = socket;\n\t} else {\n\t\tret = BSD_EINVAL;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Check if the address family is supported\n\t */\n\tif (addr->sa_family == AF_INET) {\n\t\tret = socket_accept(sock_fd, addr, addrlen);\n\t} else {\n\t\tret = BSD_EAFNOSUPPORT;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Check if the accept function failed\n\t */\n\tif (ret < 0) {\n\t\t/*\n\t\t * Set the error based on the socket value\n\t\t */\n\t\tif (sock_fd == BSD_INVALID_SOCKET) {\n\t\t\tret = BSD_EBADF;\n\t\t} else {\n\t\t\tret = BSD_ECONNABORTED;\n\t\t}\n\t}\n\ndone:\n\treturn ret;\n}", "CodeBleu_score": 34.18897054430187}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint accept_ret = 0;\n\tint socket_ret = 0;\n\tint addr_family = 0;\n\tint socket_family = 0;\n\n\tif (addr!= NULL) {\n\t\tsocket_ret = BSD_getsockname(socket, addr, addrlen);\n\t\tif (socket_ret!= 0) {\n\t\t\treturn socket_ret;\n\t\t}\n\t}\n\n\taddr_family = addr->sa_family;\n\tsocket_family = BSD_get_socket_family(socket);\n\n\tif (addr_family!= socket_family) {\n\t\tBSD_set_error(BSD_EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\n\taccept_ret = BSD_accept(socket, addr, addrlen);\n\tif (accept_ret < 0) {\n\t\tif (socket_ret < 0) {\n\t\t\tBSD_set_error(BSD_ECONNABORTED);\n\t\t} else {\n\t\t\tBSD_set_error(BSD_ECONNRESET);\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn accept_ret;\n}", "CodeBleu_score": 38.9755540280861}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\t// Get the current time in UNIX format\n\ttime_t unixTime = time(NULL);\n\n\t// Check if the time is valid\n\tif (unixTime!= -1) {\n\t\t// Update the JWT with the current time offset\n\t\tupdateJWT(unixTime);\n\n\t\t// Initiate the MQTT connection\n\t\tmqtt_connect();\n\n\t\t// Print a debug message to indicate the connection attempt\n\t\tDEBUG_PRINT(\"Attempting MQTT connection...\\r\n\");\n\n\t\t// Set a flag to send an MQTT SUBSCRIBE packet once the connection is established\n\t\tmqtt_subscribe_flag = 1;\n\t}\n}", "CodeBleu_score": 20.409064720910035}, {"code": "static void connectMQTT(){\n\t\tchar timeBuffer[20];\n\ttime_t currentTime = time(NULL);\n\n\tif (currentTime!= -1) {\n\t\tsprintf(timeBuffer, \"%ld\", currentTime);\n\t\tupdateJWT(timeBuffer);\n\n\t\tif (mqtt_connect() == MQTT_SUCCESS) {\n\t\t\tDEBUG_PRINT(\"MQTT connection established\n\");\n\t\t\tmqtt_subscribe = 1;\n\t\t} else {\n\t\t\tDEBUG_PRINT(\"MQTT connection failed\n\");\n\t\t}\n\t} else {\n\t\tDEBUG_PRINT(\"Failed to get current time\n\");\n\t}\n}", "CodeBleu_score": 49.29722720716796}, {"code": "static void connectMQTT(){\n\t\tif (isValidTime()) {\n\t\tupdateJWT();\n\t\tint8_t mqtt_connection_status = m2m_connect_mqtt_server();\n\t\tif (mqtt_connection_status == M2M_SUCCESS) {\n\t\t\tDEBUG_PRINT(\"MQTT connection established\n\");\n\t\t\tsend_MQTT_SUBSCRIBE_packet = 1;\n\t\t} else {\n\t\t\tDEBUG_PRINT(\"MQTT connection failed\n\");\n\t\t}\n\t} else {\n\t\tDEBUG_PRINT(\"Time is not valid\n\");\n\t}\n}", "CodeBleu_score": 39.77402339073129}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tif (CLOUD_state == CLOUD_CONNECTED) {\n\t\tCLOUD_state = CLOUD_DISCONNECTED;\n\t\tDEBUG_print(\"Cloud service disconnected.\n\");\n\t\tif (mqtt_connection_state == MQTT_CONNECTED) {\n\t\t\tDEBUG_print(\"Cloud service disconnecting MQTT client.\n\");\n\t\t\tmqtt_disconnect();\n\t\t}\n\t}\n}", "CodeBleu_score": 46.914878261224814}, {"code": "void CLOUD_disconnect(void){\n\t\tif (CLOUD_isConnected()) {\n\t\tDEBUG_PRINT(\"CLOUD_disconnect: Disconnecting from the cloud service...\n\");\n\t\tmqtt_disconnect();\n\t} else {\n\t\tDEBUG_PRINT(\"CLOUD_disconnect: No connection to the cloud service.\n\");\n\t}\n}", "CodeBleu_score": 21.2423143796464}, {"code": "void CLOUD_disconnect(void){\n\t\tDEBUG_PRINT_INFO(\"Cloud Service: Disconnecting from cloud service...\n\");\n\tif (mqtt_get_connection_state() == MQTT_CONNECTION_STATE_CONNECTED) {\n\t\tmqtt_disconnect();\n\t}\n\tDEBUG_PRINT_INFO(\"Cloud Service: Disconnected from cloud service.\n\");\n}", "CodeBleu_score": 48.860308221095686}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiInitParam param;\n\tint8_t ret;\n\tuint8_t wifi_creds = passed_wifi_creds;\n\n\tif (passed_wifi_creds == 0) {\n\t\twifi_creds = 1;\n\t}\n\n\tmemset(&param, 0, sizeof(tstrWifiInitParam));\n\n\tparam.pfAppWifiCb = wifi_cb;\n\n\tret = m2m_wifi_init(&param);\n\n\tif (ret!= M2M_SUCCESS) {\n\t\tdebug_print(\"wifi_connectToAp: m2m_wifi_init call failed, error code %d\\r\n\", ret);\n\t\treturn false;\n\t}\n\n\tif (wifi_creds == 1) {\n\t\tret = m2m_wifi_connect((char *) SSID, sizeof(SSID), AUTH_TYPE, (char *) PASS,\n\t\t\t\tM2M_WIFI_CH_ALL);\n\t} else {\n\t\tret = m2m_wifi_connect((char *) SSID, sizeof(SSID), AUTH_TYPE, (char *) PASS,\n\t\t\t\tM2M_WIFI_CH_ALL);\n\t}\n\n\tif (ret!= M2M_SUCCESS) {\n\t\tdebug_print(\"wifi_connectToAp: m2m_wifi_connect call failed, error code %d\\r\n\", ret);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 48.941117058698026}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiInitParam param;\n\n\ttstrM2mWifiAuthParam wifi_auth_param;\n\n\tif (passed_wifi_creds) {\n\n\t\t/*\n\t\t * If new credentials are provided, use them to connect to the access point.\n\t\t */\n\t\twifi_auth_param.u8AuthType = wifi_creds.auth_type;\n\n\t\twifi_auth_param.au8Password = ;\n\n\t\twifi_auth_param.au8SSID = wifi_creds.ssid;\n\n\t\twifi_auth_param.u16SSIDLength = strlen(wifi_creds.ssid);\n\n\t\tparam.pfAppWifiCb = wifi_cb;\n\n\t\tm2m_wifi_connect((char *) wifi_creds.ssid, wifi_auth_param.u16SSIDLength, wifi_auth_param.u8AuthType, wifi_auth_param.au8Password, &param);\n\n\t} else {\n\n\t\t/*\n\t\t * If no new credentials are provided, use the default Wi-Fi settings to connect to the access point.\n\t\t */\n\t\tparam.pfAppWifiCb = wifi_cb;\n\n\t\tm2m_wifi_connect((char *) DEFAULT_WIFI_SSID, strlen(DEFAULT_WIFI_SSID), DEFAULT_WIFI_AUTH_TYPE, DEFAULT_WIFI_PASSWORD, &param);\n\n\t}\n\n\t/*\n\t * If the connection fails, log an error message and update the networking error status.\n\t */\n\tif (wifi_status == WIFI_CONNECTING) {\n\n\t\tdebug_print(\"Connecting to Wi-Fi...\n\");\n\n\t} else if (wifi_status == WIFI_DISCONNECTED) {\n\n\t\tdebug_print(\"Wi-Fi connection failed.\n\");\n\n\t\tnetworking_error_status = true;\n\n\t}\n\n\t/*\n\t * If the connection succeeds, return true.\n\t */\n\tif (wifi_status == WIFI_CONNECTED) {\n\n\t\treturn true;\n\n\t} else {\n\n\t\treturn false;\n\n\t}\n\n}", "CodeBleu_score": 42.940562565427655}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiInitParam param;\n\n\tparam.pfAppWifiCb = wifi_cb;\n\n\t/* Initialize Wi-Fi parameters structure. */\n\tmemset((uint8_t *) &param, 0, sizeof(tstrWifiInitParam));\n\n\t/* Initialize Wi-Fi driver with data and status callbacks. */\n\tif (m2m_wifi_init(&param)!= M2M_SUCCESS) {\n\t\tdebug_print(\"wifi_connectToAp: Failed to initialize Wi-Fi driver.\n\");\n\t\treturn false;\n\t}\n\n\t/* Connect to an access point. */\n\tif (passed_wifi_creds) {\n\t\tdebug_print(\"wifi_connectToAp: Connecting to SSID: %s, authentication type: %d, password: %s.\n\", wifi_creds.ssid, wifi_creds.auth_type, wifi_creds.password);\n\t\tif (m2m_wifi_connect((char *) wifi_creds.ssid, strlen(wifi_creds.ssid), wifi_creds.auth_type, (char *) wifi_creds.password, NULL)!= M2M_SUCCESS) {\n\t\t\tdebug_print(\"wifi_connectToAp: Failed to connect to SSID: %s.\n\", wifi_creds.ssid);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tdebug_print(\"wifi_connectToAp: Connecting to default Wi-Fi settings.\n\");\n\t\tif (m2m_wifi_connect(NULL, 0, 0, NULL, NULL)!= M2M_SUCCESS) {\n\t\t\tdebug_print(\"wifi_connectToAp: Failed to connect to default Wi-Fi settings.\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 41.347603403552206}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t\tconst client = new ApolloClient({\n\t\tlink: new HttpLink({\n\t\t\turi: process.env.REACT_APP_API_URL,\n\t\t\tfetch: fetch,\n\t\t}),\n\t\tcache: new InMemoryCache(),\n\t});\n\n\ttry {\n\t\tconst result = await client.query({\n\t\t\tquery: gql`\n\t\t\t\tquery {\n\t\t\t\t\tlistSensors {\n\t\t\t\t\t\titems {\n\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tlatitude\n\t\t\t\t\t\t\tlongitude\n\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t});\n\n\t\tif (result.data.listSensors.items.length > 0) {\n\t\t\tconsole.log(\"Retrieved sensors: \", result.data.listSensors.items);\n\n\t\t\tresult.data.listSensors.items.forEach((sensor) => {\n\t\t\t\tnew maplibregl.Marker({\n\t\t\t\t\telement: document.createElement(\"div\"),\n\t\t\t\t})\n\t\t\t\t\t.setLngLat([sensor.longitude, sensor.latitude])\n\t\t\t\t\t.addTo(map);\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(error);\n\t}\n}", "CodeBleu_score": 39.6778814743663}, {"code": "async function DisplaySensors(map){\n\t\n/**\n * The function \"DisplaySensors\" asynchronously retrieves a list of sensors and displays them on a map.", "CodeBleu_score": 4.047169995458106}, {"code": "async function DisplaySensors(map){\n\t\t// Create a client to send GraphQL queries\n\tconst client = new GraphQLClient(\n\t\t\"https://xxxxxxxx.appsync-api.us-east-1.amazonaws.com/graphql\",\n\t\t{\n\t\t\tregion: \"us-east-1\",\n\t\t\tauth: {\n\t\t\t\ttype: \"API_KEY\",\n\t\t\t\tapiKey: \"\",\n\t\t\t},\n\t\t}\n\t);\n\n\t// Send a GraphQL query to retrieve sensor data\n\tconst { data } = await client.query({\n\t\tquery: gql`\n\t\t\tquery {\n\t\t\t\tlistSensors {\n\t\t\t\t\titems {\n\t\t\t\t\t\tid\n\t\t\t\t\t\tname\n\t\t\t\t\t\tdescription\n\t\t\t\t\t\tlocation {\n\t\t\t\t\t\t\tlatitude\n\t\t\t\t\t\t\tlongitude\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`,\n\t});\n\n\t// Log the retrieval of sensors\n\tconsole.log(\"Retrieved sensors:\");\n\n\t// If the response contains data, log the retrieval of sensors and iterate through each sensor\n\tif (data) {\n\t\tdata.listSensors.items.forEach((sensor) => {\n\t\t\t// Log the sensor\n\t\t\tconsole.log(sensor);\n\n\t\t\t// Create a marker for the sensor\n\t\t\tconst marker = new maplibregl.Marker()\n\t\t\t\t.setLngLat([sensor.location.longitude, sensor.location.latitude])\n\t\t\t\t.addTo(map);\n\t\t});\n\t}\n}", "CodeBleu_score": 37.04066447263522}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = 'rgba(0, 102, 153, 0.8)';\n\tmarker.style.borderColor = 'rgba(0, 102, 153, 0.8)';\n\tmarker.style.borderWidth = '2px';\n\tmarker.style.borderStyle ='solid';\n\tmarker.style.borderRadius = '50%';\n\tmarker.style.width = '20px';\n\tmarker.style.height = '20px';\n\tmarker.style.display = 'flex';\n\tmarker.style.justifyContent = 'center';\n\tmarker.style.alignItems = 'center';\n\tmarker.style.cursor = 'pointer';\n\tmarker.style.fontSize = '15px';\n\tmarker.style.color = 'white';\n\tmarker.style.fontWeight = 'bold';\n\tmarker.style.textAlign = 'center';\n\tmarker.innerHTML = sensor.id;\n\treturn marker;\n}", "CodeBleu_score": 40.215994996417834}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = '#000';\n\tmarker.style.border = '2px solid #fff';\n\treturn marker;\n}", "CodeBleu_score": 43.01387509677106}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = '#343a40';\n\tmarker.style.border = '3px solid #343a40';\n\treturn marker;\n}", "CodeBleu_score": 43.17266782730337}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        mfa_module = async_import_module(hass, module_path)\n    except ImportError as err:\n        logging.error(\"Unable to import %s: %s\", module_path, err)\n        raise ImportError(f\"Unable to import {module_path}\") from err\n    if mfa_module is None:\n        raise ImportError(f\"Unable to import {module_path}\")\n    if not hasattr(mfa_module, \"requirements\"):\n        return mfa_module\n    if mfa_module.requirements is None:\n        return mfa_module\n    if not requirements.async_check_requirements(hass, mfa_module.requirements):\n        raise HomeAssistantError(\n            f\"Unable to install {module_name} requirements. \"\n            f\"Please check your internet connection and try again.\"\n        )\n    return mfa_module\n\n", "CodeBleu_score": 41.76116021348665}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n\n    # Construct the module path\n    module_path = f\"homeassistant.components.{module_name}\"\n\n    # Attempt to import the module\n    try:\n        module = async_import_module(module_path)\n    except ImportError as error:\n        # Raise an error if the import fails\n        _LOGGER.error(\"Failed to import module %s: %s\", module_path, error)\n        raise HomeAssistantError(f\"Failed to import module {module_path}: {error}\") from error\n\n    # Process module requirements\n    if requirements.HAS_PIP and not requirements.PIP_SKIPPED:\n        # Process requirements\n        await requirements.async_process_requirements(hass, module_path)\n\n    # Return the loaded module\n    return module\n\n", "CodeBleu_score": 30.080190061662154}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        mfa_module = async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Failed to import %s: %s\", module_path, err)\n        raise ImportError(f\"Failed to import {module_path}: {err}\")\n\n    if not requirements.async_process_requirements(hass, module_name, mfa_module):\n        return mfa_module\n\n    return mfa_module\n\n", "CodeBleu_score": 29.360431483773553}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n    return True\n\n", "CodeBleu_score": 35.27506592053247}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Extract the PIN from the setup data\n    pin = setup_data.get(\"pin\")\n    # Check if the user already has an entry in the internal data list\n    if user_id in self.data:\n        # Update the PIN for the user\n        self.data[user_id][\"pin\"] = pin\n    else:\n        # Add a new entry for the user with the PIN\n        self.data[user_id] = {\"pin\": pin}\n    # Return True to indicate that the setup was successful\n    return True\n\n", "CodeBleu_score": 35.67866189014771}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Extract the PIN from the setup data\n    pin = setup_data[\"pin\"]\n\n    # Check if the user already has an entry in the internal data list\n    if user_id in self.data:\n        # Update the PIN for the user\n        self.data[user_id][\"pin\"] = pin\n    else:\n        # Add a new entry with the user ID and PIN to the data list\n        self.data[user_id] = {\"pin\": pin}\n\n    # Return the setup data\n    return setup_data\n", "CodeBleu_score": 37.50703108130836}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    self._init_lock.acquire()\n    try:\n        if self._user_data is None:\n            self._user_data = await self.async_load()\n            if self._user_data is None:\n                self._user_data = {}\n    finally:\n        self._init_lock.release()\n\n", "CodeBleu_score": 21.826735187110312}, {"code": "async def _async_load(self) -> None\n\t\n    self.hass.data[DOMAIN] = {}\n    self.hass.data[DOMAIN][DATA_NOTIFY_SETTINGS] = {}\n    try:\n        async with self.hass.data_entry_flow.async_get_lock():\n            if DATA_NOTIFY_SETTINGS in self.hass.data:\n                self.hass.data[DOMAIN][DATA_NOTIFY_SETTINGS] = self.hass.data[DATA_NOTIFY_SETTINGS]\n                del self.hass.data[DATA_NOTIFY_SETTINGS]\n    except KeyError:\n        pass\n    if self.hass.data[DOMAIN][DATA_NOTIFY_SETTINGS] == {}:\n        self.hass.data[DOMAIN][DATA_NOTIFY_SETTINGS] = {\n            entry.data[CONF_NAME]: NotifySetting(\n                entry.data[CONF_NAME],\n                entry.data[CONF_PLATFORM],\n                entry.data[CONF_DATA],\n                entry.data[CONF_EXCLUDE],\n                entry.data[CONF_INCLUDE],\n            )\n            for entry in self.hass.data_entries.async_entries(DOMAIN)\n        }\n\n", "CodeBleu_score": 27.94704432999576}, {"code": "async def _async_load(self) -> None\n\t\n    if self._initialized:\n        return\n    async with self._init_lock:\n        if self._initialized:\n            return\n        self._initialized = True\n        data = await self._async_load_data()\n        if not data:\n            data = {}\n        self._data = {\n            user_id: NotifySetting(\n                user_id=user_id,\n                data=data.get(user_id, {})\n            )\n            for user_id in self._hass.data[DOMAIN].users\n        }\n\n", "CodeBleu_score": 41.44784700102737}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    # Load the user settings\n    await self.hass.async_add_executor_job(self.load_user_settings, user_id)\n    # Retrieve the notification settings for the specified user\n    settings = self.get_user_settings(user_id)\n    # If no settings are found for the user, return False\n    if settings is None:\n        return False\n    # Validate the user input by verifying the OTP using an executor job\n    await self.hass.async_add_executor_job(self.validate_otp, user_id, user_input)\n    return True\n\n", "CodeBleu_score": 48.50805023392255}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    # Load the user settings\n    user_settings = await self.async_load_user_settings(user_id)\n\n    # If no settings are found, return False\n    if not user_settings:\n        return False\n\n    # Retrieve the notification settings for the specified user\n    notification_settings = user_settings.get(\"notification\")\n\n    # If no notification settings are found, return False\n    if not notification_settings:\n        return False\n\n    # Validate the user input by verifying the OTP using an executor job\n    otp_valid = await self.hass.async_add_executor_job(self.validate_otp, user_input[\"otp\"], notification_settings)\n\n    # Return True if the validation passes\n    return otp_valid\n\n", "CodeBleu_score": 45.141550390458306}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    return await self.hass.async_add_executor_job(\n        self.validate, user_id, user_input\n    )\n\n", "CodeBleu_score": 25.158122953780975}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device:\n        return None\n    if not device.area_id:\n        return None\n    return area_dict.get(device.area_id)\n\n", "CodeBleu_score": 44.77868384625145}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None or device.area_id is None:\n        return None\n    area = area_dict.get(device.area_id)\n    if area is None:\n        return None\n    return area.permissions\n\n", "CodeBleu_score": 62.07751598232258}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id, None)\n\n", "CodeBleu_score": 47.46167767889325}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, value in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                if category in merged_policy:\n                    merged_policy[category] = merge_categories(merged_policy[category], value)\n                else:\n                    merged_policy[category] = value\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 50.67430278438101}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, rules in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = rules\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 48.147606259830376}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, values in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                if category not in merged_policy:\n                    merged_policy[category] = values\n                else:\n                    merged_policy[category] = {**merged_policy[category], **values}\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 46.43478890198986}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    # Attempt to import the specified provider module\n    try:\n        module = async_import_module(hass, provider)\n    except ImportError as err:\n        # Log an error if the import fails\n        logging.error(\n            \"Failed to import authentication provider module %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Failed to import authentication provider module {provider}: {err}\"\n        ) from err\n\n    # If the module has no additional requirements or the requirements should be skipped, return the module\n    if not hasattr(module, \"AUTH_REQUIREMENTS\") or not module.AUTH_REQUIREMENTS:\n        return module\n\n    # Process the module's requirements\n    hass.data[CONF_ID] = HassKey(module.AUTH_REQUIREMENTS)\n    hass.data[CONF_NAME] = provider\n    hass.data[CONF_TYPE] = \"auth_provider\"\n    hass.data[CONF_ID] = HassKey(module.AUTH_REQUIREMENTS)\n    hass.data[CONF_NAME] = provider\n    hass.data[CONF_TYPE] = \"auth_provider\"\n    hass.data[CONF_ID] = HassKey(module.AUTH_REQUIREMENTS)\n    hass.data[CONF_NAME] = provider\n    hass.data[CONF_TYPE] = \"auth_provider\"\n    hass.data[CONF_ID] = HassKey(module.AUTH_REQUIREMENTS)\n    hass.data[CONF_NAME] = provider\n    hass.data[CONF_TYPE] = \"auth_provider\"\n    hass.data[CONF_ID] = HassKey(module.AUTH_REQUIREMENTS)\n    hass.data[CONF_NAME] = provider\n    hass.data[CONF_TYPE] = \"auth_provider\"\n    hass.data[CONF_ID] = HassKey(module.AUTH_REQUIREMENTS)\n    hass.data[CONF_NAME] = provider\n    hass.data[CONF_TYPE] = \"auth_provider\"\n    hass.data[CONF_ID] = HassKey(module.AUTH_REQUIREMENTS)\n    hass.data[CONF_NAME] = provider\n    hass.data[CONF_TYPE] = \"auth_provider\"\n    hass.data[CONF_ID] = HassKey(module.AUTH_REQUIREMENTS)\n    hass.data[CONF_NAME] = provider\n    hass.data[CONF_TYPE] = \"", "CodeBleu_score": 36.803301445815265}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    module = async_import_module(provider)\n    if module is None:\n        raise HomeAssistantError(\n            f\"Could not import {provider} module. Please check your configuration.\"\n        )\n    if not hasattr(module, \"AUTH_PROVIDERS\"):\n        return module\n    for requirement in module.AUTH_PROVIDERS.get(\"requirements\", []):\n        if not await requirements.async_process_requirements(\n            hass, requirement, skip_requirements=True\n        ):\n            raise HomeAssistantError(\n                f\"Could not load {provider} module due to missing requirement: {requirement}\"\n            )\n    return module\n\n", "CodeBleu_score": 33.717136350755304}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = async_import_module(provider)\n    except ImportError as err:\n        _LOGGER.error(\"Could not import authentication provider module %s: %s\", provider, err)\n        raise HomeAssistantError(\"Could not import authentication provider module\") from err\n\n    if not requirements.async_check_requirements(hass, module.AUTH_REQUIREMENTS):\n        return module\n\n    if requirements.async_skip_requirements(hass, module.AUTH_REQUIREMENTS):\n        return module\n\n    hass.data[HassKey(requirements.REQUIREMENTS_KEY)] = requirements.async_process_requirements(\n        hass, module.AUTH_REQUIREMENTS\n    )\n    return module\n\n", "CodeBleu_score": 40.13457968218991}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if not await self.async_load_data():\n        self.data = {}\n    else:\n        self.data = await self.async_load_data()\n    self._normalize_usernames()\n\n", "CodeBleu_score": 21.925425688434164}, {"code": "async def async_load(self) -> None\n\t\n    self._users: dict[str, dict[str, Any]] = await self.async_load()\n    if self._users is None:\n        self._users = {}\n    if not isinstance(self._users, dict):\n        raise HomeAssistantError(\"User data is not a dict\")\n\n    for user in self._users.values():\n        if not isinstance(user, dict):\n            raise HomeAssistantError(\"User data is not a dict\")\n\n        if \"name\" not in user:\n            raise HomeAssistantError(\"User data is missing 'name' field\")\n\n        if not isinstance(user[\"name\"], str):\n            raise HomeAssistantError(\"User data is not a string\")\n\n        if \"password\" not in user:\n            raise HomeAssistantError(\"User data is missing 'password' field\")\n\n        if not isinstance(user[\"password\"], str):\n            raise HomeAssistantError(\"User data is not a string\")\n\n        if \"salt\" not in user:\n            raise HomeAssistantError(\"User data is missing'salt' field\")\n\n        if not isinstance(user[\"salt\"], str):\n            raise HomeAssistantError(\"User data is not a string\")\n\n        if \"hash\" not in user:\n            raise HomeAssistantError(\"User data is missing 'hash' field\")\n\n        if not isinstance(user[\"hash\"], str):\n            raise HomeAssistantError(\"User data is not a string\")\n\n        if \"id\" not in user:\n            raise HomeAssistantError(\"User data is missing 'id' field\")\n\n        if not isinstance(user[\"id\"], str):\n            raise HomeAssistantError(\"User data is not a string\")\n\n        if \"is_owner\" not in user:\n            raise HomeAssistantError(\"User data is missing 'is_owner' field\")\n\n        if not isinstance(user[\"is_owner\"], bool):\n            raise HomeAssistantError(\"User data is not a boolean\")\n\n        if \"is_admin\" not in user:\n            raise HomeAssistantError(\"User data is missing 'is_admin' field\")\n\n        if not isinstance(user[\"is_admin\"], bool):\n            raise HomeAssistantError(\"User data is not a boolean\")\n\n        if \"is_hidden\" not in user:\n            raise HomeAssistantError(\"User data is missing 'is_hidden' field\")\n\n        if not isinstance(user[\"is_hidden\"], bool):\n            raise HomeAssistantError(\"User data is not a boolean\")\n\n        if \"is_system\" not in user:\n            raise HomeAssistantError(\"", "CodeBleu_score": 17.283269571821787}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        self._users = await self.hass.async_add_executor_job(self._async_load)\n    except Exception as err:\n        raise HomeAssistantError(\n            \"Error loading user data from storage: {}\".format(err)\n        ) from err\n\n", "CodeBleu_score": 27.631860583831585}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    normalized_username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n\n    for user in self.data:\n        if user[\"username\"].lower() == normalized_username:\n            stored_hash = user[\"hash\"]\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid username or password\")\n\n    if bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 34.42254269435588}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt(rounds=10))\n    for user in self.data:\n        if user[\"username\"] == username:\n            user_hash = user[\"password\"]\n            if bcrypt.checkpw(password.encode(\"utf-8\"), base64.b64decode(user_hash)):\n                return\n            else:\n                raise InvalidAuth(\"Invalid credentials\")\n    if bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        raise InvalidAuth(\"Invalid credentials\")\n    raise InvalidAuth(\"Invalid credentials\")\n\n", "CodeBleu_score": 34.63232318928895}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = b\"\"\n    for user in self.users:\n        if user.username == username:\n            user_hash = base64.b64decode(user.password)\n            if bcrypt.checkpw(password.encode(), user_hash):\n                return\n            else:\n                raise InvalidAuth()\n    raise InvalidAuth()\n\n", "CodeBleu_score": 33.276387104237706}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    if username == \"admin\":\n        raise InvalidUser(\"Cannot remove admin user\")\n    try:\n        self.data[username]\n    except KeyError:\n        raise InvalidUser(\"User not found\")\n    del self.data[username]\n\n", "CodeBleu_score": 24.012820079037027}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.data[self.normalize_username(username)] = None\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 12.74222058549558}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    if username not in self.users:\n        raise InvalidUser(f\"User {username} not found\")\n    del self.users[username]\n\n", "CodeBleu_score": 13.442776804324563}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not credentials.data:\n        await self.async_initialize()\n    try:\n        await self.async_remove_user(credentials.username)\n        await self.async_save()\n    except ValueError:\n        pass\n\n", "CodeBleu_score": 44.04598905813324}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    try:\n        await self._async_remove_credentials(credentials)\n    except Exception:\n        _LOGGER.exception(\"Error removing credentials\")\n\n", "CodeBleu_score": 24.423425892227943}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not credentials.data:\n        await self.async_initialize()\n    try:\n        await self.async_remove(credentials.username)\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 38.508207589365284}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n\n    joined = set()\n    for thread in threads:\n        if thread.is_alive():\n            try:\n                thread.join(timeout)\n            except RuntimeError:\n                pass\n            if thread.is_alive():\n                if log:\n                    logging.warning(\n                        \"Thread %s is still running after %s seconds\",\n                        thread.name,\n                        timeout,\n                    )\n                joined.add(thread)\n                thread.interrupt_main()\n    return joined\n\n", "CodeBleu_score": 40.21371285549489}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads = set()\n    for thread in threads:\n        if thread.is_alive():\n            try:\n                thread.join(timeout=timeout)\n            except RuntimeError:\n                if log:\n                    logging.info(f\"Thread {thread.ident} is still running.\")\n                thread.interrupt_main()\n            if thread.is_alive():\n                joined_threads.add(thread)\n    return joined_threads\n\n", "CodeBleu_score": 43.32619805587134}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    # Calculate the timeout for each thread\n    timeouts = {thread: timeout - (time.time() - thread.start_time) for thread in threads}\n    # Join or interrupt the threads\n    joined = set()\n    for thread in threads:\n        try:\n            thread.join(timeouts[thread])\n        except TimeoutError:\n            thread.interrupt()\n        if thread.is_alive():\n            joined.add(thread)\n            if log:\n                logging.warning(f\"Thread {thread.name} is still running\")\n        else:\n            joined.add(thread)\n    # Raise a SystemExit exception in any remaining threads\n    for thread in threads:\n        if thread not in joined:\n            try:\n                thread.join(0.01)\n            except TimeoutError:\n                thread.interrupt()\n            if thread.is_alive():\n                raise SystemExit(f\"Thread {thread.name} did not exit\")\n    return joined\n\n", "CodeBleu_score": 38.62775178368815}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get all non-main, non-daemon, alive threads\n    threads = [t for t in threading.enumerate() if t.is_alive() and t is not threading.main_thread() and not t.daemon]\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = time.time() + SHUTDOWN_TIMEOUT\n    thread_timeouts = [timeout / len(threads)] * len(threads)\n    # Attempt to join each thread within the calculated timeout\n    for i, thread in enumerate(threads):\n        try:\n            thread.join(thread_timeouts[i])\n        except Exception as e:\n            logging.warning(f\"Failed to join thread {thread}: {e}\")\n\n", "CodeBleu_score": 32.29597002183975}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    main_thread = threading.current_thread()\n    main_thread_id = id(main_thread)\n    threads = threading.enumerate()\n    threads_to_join = []\n    for thread in threads:\n        if id(thread)!= main_thread_id and not thread.daemon and thread.is_alive():\n            threads_to_join.append(thread)\n    if len(threads_to_join) == 0:\n        logging.warning(\"No threads to join.\")\n        return\n    total_timeout = 5\n    for thread in threads_to_join:\n        timeout = total_timeout / len(threads_to_join)\n        logging.warning(f\"Attempting to join thread {thread.name} with timeout {timeout} seconds.\")\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            logging.warning(f\"Failed to join thread {thread.name} with error {e}\")\n\n", "CodeBleu_score": 34.182597071048356}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n\n    # Get the total shutdown timeout\n    shutdown_timeout = get_shutdown_timeout()\n\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if not thread.is_alive() or thread.daemon or thread.name == \"MainThread\"]\n\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = shutdown_timeout / len(threads)\n\n    # Attempt to join each thread within the calculated timeout and log a warning if joining a thread fails\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            logging.warning(f\"Failed to join thread {thread.name}: {e}\")\n\n", "CodeBleu_score": 30.71245698166205}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self.dispatch_internal_signal(\n            InternalSignal.DISPATCHER_SETUP_STARTED,\n            remaining_with_setup_started,\n        )\n    self.has_remaining_setups = bool(remaining_with_setup_started)\n\n", "CodeBleu_score": 45.050516157448854}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._setups_started:\n        self._loop.call_soon_threadsafe(\n            self._loop.create_task,\n            self._internal_dispatch(remaining_with_setup_started),\n        )\n        self._setups_started = bool(remaining_with_setup_started)\n\n", "CodeBleu_score": 51.2792522899256}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._dispatch_signal(self._internal_dispatcher_signal, remaining_with_setup_started)\n        self._remaining_setups = remaining_with_setup_started\n    else:\n        self._remaining_setups = {}\n\n def _dispatch_signal(self, signal: asyncio.Signal, *args: Any) -> None:\n    \"\"\"The function \"_dispatch_signal\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 41.017256807831025}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # If the bluetooth.py file is not present, there is nothing to validate.\n    if not os.path.exists(config.path_to_bluetooth_py):\n        return\n\n    # Read the current content of bluetooth.py.\n    with open(config.path_to_bluetooth_py, \"r\", encoding=\"utf-8\") as file:\n        current_content = file.read()\n\n    # Generate the content for bluetooth.py.\n    generated_content = generate_bluetooth_py(integrations, config)\n\n    # If the contents are different, add an error to the configuration.\n    if generated_content!= current_content:\n        config.add_error(\n            \"bluetooth.py\",\n            \"bluetooth.py is not up to date. \"\n            \"Please run 'ha integration validate' to update it.\",\n        )\n        config.add_suggestion(\n            \"bluetooth.py\",\n            \"Run 'ha integration validate' to update it.\",\n        )\n\n", "CodeBleu_score": 41.908017291360544}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # If the Bluetooth content is not present, it is generated and validated.\n    if not config.bluetooth:\n        config.bluetooth = generate_bluetooth_content(integrations)\n        validate_bluetooth_content(config.bluetooth)\n    # If specific integrations are not being validated, it reads the current content of bluetooth.py and compares it with the generated content.\n    elif config.bluetooth.integrations:\n        current_bluetooth_content = read_bluetooth_content()\n        if current_bluetooth_content!= config.bluetooth:\n            config.errors.append(\n                {\n                    \"type\": \"bluetooth\",\n                    \"fixable\": True,\n                    \"message\": (\n                        \"The Bluetooth content is not up to date. \"\n                        \"Please run `ha core check bluetooth` to fix the issue.\"\n                    ),\n                }\n            )\n\n", "CodeBleu_score": 35.29858029438207}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Create a temporary directory to store the generated Bluetooth content.\n    temp_dir = tempfile.mkdtemp()\n\n    # Create a temporary file to store the generated Bluetooth content.\n    temp_file = os.path.join(temp_dir, \"bluetooth.py\")\n\n    # Generate the Bluetooth content based on the provided integrations.\n    generate_bluetooth_content(integrations, temp_file)\n\n    # Read the current content of bluetooth.py.\n    current_content = config.get_path(\"bluetooth.py\")\n\n    # Compare the generated content with the current content of bluetooth.py.\n    if current_content!= read_file(temp_file):\n        # Add an error to the configuration indicating that bluetooth.py is not up to date.\n        config.add_error(\n            \"bluetooth.py\",\n            \"bluetooth.py is not up to date. Please run `ha generate bluetooth` to update it.\",\n        )\n\n        # Add a suggestion to the configuration indicating how to fix the error.\n        config.add_suggestion(\n            \"bluetooth.py\",\n            \"Run `ha generate bluetooth` to update it.\",\n        )\n\n", "CodeBleu_score": 46.87682761286632}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create a new HTTP client\n\tclient := resty.New()\n\n\t// Create a new POST request\n\treq := client.R().SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetBody(fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s&client_id=%s&client_secret=%s\", d.RefreshToken, d.AppKey, d.AppSecret))\n\n\t// Send the POST request to the Dropbox OAuth2 token endpoint\n\tresp, err := client.Post(\"https://api.dropboxapi.com/oauth2/token\")\n\tif err!= nil {\n\t\tlogger.Log.Error(\"Failed to send POST request to the Dropbox OAuth2 token endpoint\", zap.Error(err))\n\t\treturn err\n\t}\n\n\t// Check the response status code\n\tif resp.StatusCode()!= http.StatusOK {\n\t\tlogger.Log.Error(\"Failed to refresh the access token\", zap.Int(\"status code\", resp.StatusCode()))\n\t\treturn fmt.Errorf(\"failed to refresh the access token: %s\", resp.Status())\n\t}\n\n\t// Unmarshal the response body into a map\n\tvar response map[string]interface{}\n\tif err := resp.Unmarshal(&response); err!= nil {\n\t\tlogger.Log.Error(\"Failed to unmarshal the response body\", zap.Error(err))\n\t\treturn err\n\t}\n\n\t// Check if the \"access_token\" key exists in the response\n\tif _, ok := response[\"access_token\"];!ok {\n\t\tlogger.Log.Error(\"Failed to refresh the access token\", zap.String(\"message\", \"access_token not found in the response\"))\n\t\treturn fmt.Errorf(\"failed to refresh the access token: access_token not found in the response\")\n\t}\n\n\t// Update the access token\n\td.AccessToken = response[\"access_token\"].(string)\n\n\treturn nil\n}", "CodeBleu_score": 42.65251341827664}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tlog := logger.GetLogger()\n\tlog.Debug(\"refreshToken()\")\n\n\t// Create a REST client\n\tclient := resty.New()\n\n\t// Create a POST request\n\treq := client.R().SetBody(fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s&client_id=%s&client_secret=%s\", d.RefreshToken, d.AppKey, d.AppSecret))\n\n\t// Send the request and get the response\n\tresp, err := req.Post(\"https://api.dropboxapi.com/oauth2/token\")\n\tif err!= nil {\n\t\tlog.Error(\"refreshToken() error\", zap.Error(err))\n\t\treturn err\n\t}\n\n\t// Check the response status code\n\tif resp.StatusCode()!= http.StatusOK {\n\t\tlog.Error(\"refreshToken() error\", zap.Int(\"StatusCode\", resp.StatusCode()))\n\t\treturn fmt.Errorf(\"refreshToken() error: %v\", resp.StatusCode())\n\t}\n\n\t// Parse the response body\n\tvar data map[string]interface{}\n\terr = resp.Unmarshal(&data)\n\tif err!= nil {\n\t\tlog.Error(\"refreshToken() error\", zap.Error(err))\n\t\treturn err\n\t}\n\n\t// Update the access token\n\td.AccessToken = data[\"access_token\"].(string)\n\n\treturn nil\n}", "CodeBleu_score": 44.56603961028534}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tclient := resty.New()\n\tresp, err := client.R().\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\": \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"client_id\": d.AppKey,\n\t\t\t\"client_secret\": d.AppSecret,\n\t\t}).\n\t\tSetResult(base.TokenResponse{}).\n\t\tPost(d.TokenEndpoint)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif resp.StatusCode()!= http.StatusOK {\n\t\tlogger.Log.Error(\"Failed to refresh token\",\n\t\t\tzap.String(\"error\", fmt.Sprintf(\"Error refreshing token: %v\", resp.Status())),\n\t\t\tzap.String(\"status\", fmt.Sprintf(\"Status: %v\", resp.Status())),\n\t\t\tzap.String(\"body\", fmt.Sprintf(\"Body: %v\", resp.Body())),\n\t\t)\n\t\treturn fmt.Errorf(\"failed to refresh token: %v\", resp.Status())\n\t}\n\ttoken := resp.Result().(*base.TokenResponse)\n\td.AccessToken = token.AccessToken\n\treturn nil\n}", "CodeBleu_score": 50.3957936796976}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar err error\n\tvar respBody []byte\n\tvar retryCount int = 0\n\tvar respCode int\n\n\tfor retryCount < 3 {\n\t\tretryCount++\n\t\treq := resty.New()\n\t\treq.SetDebug(d.debug)\n\t\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\t\treq.SetHeader(\"Content-Type\", \"application/json\")\n\t\treq.SetHeader(\"Accept\", \"application/json\")\n\t\treq.SetHeader(\"X-Goog-Api-Client\", \"gl-go/1.18.0 gdcl/20200201\")\n\t\treq.SetHeader(\"X-Goog-User-Project\", d.userProject)\n\t\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\t\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\t\treq.SetHeader(\"X-Goog-Upload-File-Name\", \"test.txt\")\n\t\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\t\treq.SetHeader(\"X-Goog-Upload-Command\", \"upload\")\n\t\treq.SetHeader(\"X-Goog-Upload-Offset\", \"0\")\n\t\treq.SetHeader(\"X-Goog-Upload-Size-Received\", \"0\")\n\t\treq.SetHeader(\"X-Goog-Upload-File-Size\", \"0\")\n\t\treq.SetHeader(\"X-Goog-Upload-Metadata-Fields\", \"name,mimeType,description,starred,trashed,parents\")\n\t\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\t\treq.SetHeader(\"X-Goog-Upload-Command\", \"finish\")\n\t\treq.SetHeader(\"X-Goog-Upload-File-Name\", \"test.txt\")\n\t\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\t\treq.SetHeader(\"X-Goog-Upload-Command\", \"upload\")\n\t\treq.SetHeader(\"X-Goog-Upload-Offset\", \"0\")\n\t\treq.SetHeader(\"X-Goog-Upload-Size-Received\", \"0\")\n\t\treq.SetHeader(\"X-Goog-Upload", "CodeBleu_score": 20.13128507213611}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// Initialize a new request with the specified URL and method.\n\treq := resty.R().SetResult(resp).SetError(resp)\n\treq.SetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.accessToken))\n\treq.SetHeader(\"Content-Type\", \"application/json\")\n\treq.SetHeader(\"X-Goog-Api-Client\", \"gl-go/1.13.7 gdcl/20200128\")\n\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start,upload,finish\")\n\treq.SetHeader(\"X-Goog-Upload-File-Name\", \"file\")\n\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start,upload,finish\")\n\treq.SetHeader(\"X-Goog-Upload-File-Name\", \"file\")\n\treq.SetHeader(\"X-Goog-Upload-File-Size\", strconv.FormatInt(d.fileSize, 10))\n\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start,upload,finish\")\n\treq.SetHeader(\"X-Goog-Upload-File-Name\", \"file\")\n\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start,upload,finish\")\n\treq.SetHeader(\"X-Goog-Upload-File-Name\", \"file\")\n\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start,upload,finish\")\n\treq.SetHeader(\"X-Goog-Upload-File-Name\", \"file\")\n\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start,upload,finish\")\n\treq.SetHeader(\"X-Goog-Upload-File", "CodeBleu_score": 18.332426310136963}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// Create a new request with the specified method and URL.\n\treq := resty.R().SetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.token.AccessToken)).\n\t\tSetHeader(\"Content-Type\", \"application/json\").\n\t\tSetHeader(\"Accept\", \"application/json\").\n\t\tSetQueryParam(\"supportsAllDrives\", \"true\")\n\n\t// Set the request method.\n\tswitch method {\n\tcase \"GET\":\n\t\treq = req.Get(url)\n\tcase \"POST\":\n\t\treq = req.Post(url)\n\tcase \"PUT\":\n\t\treq = req.Put(url)\n\tcase \"DELETE\":\n\t\treq = req.Delete(url)\n\t}\n\n\t// If a callback is provided, call it to customize the request.\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\n\t// Send the request and get the response.\n\tresp, err := req.Execute()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// If the response is not successful, check if it's a 401 error and refresh the token if it is.\n\tif resp.StatusCode() == http.StatusUnauthorized {\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\t// If a response structure is provided, set the response body to it.\n\tif resp!= nil {\n\t\tresp.Body = resp.RawBody\n\t}\n\n\t// Return the response body or an error if the request failed.\n\tif resp!= nil && resp.StatusCode() == http.StatusOK {\n\t\treturn resp.Body(), nil\n\t}\n\treturn nil, fmt.Errorf(\"request failed with status code %d\", resp.StatusCode())\n}", "CodeBleu_score": 51.37756222345633}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Initialize the chunk size and the total bytes uploaded.\n\tchunkSize := int64(10 * 1024 * 1024)\n\ttotalUploaded := int64(0)\n\n\t// Create a new HTTP client.\n\tclient := resty.New()\n\tclient.SetTimeout(d.Timeout)\n\n\t// Loop until the entire file is uploaded.\n\tfor {\n\t\t// Check if the context has been canceled.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Read the next chunk of data from the stream.\n\t\tchunk, err := stream.ReadChunk(chunkSize)\n\t\tif err!= nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// Calculate the range of the current chunk.\n\t\tstart := totalUploaded\n\t\tend := start + int64(len(chunk)) - 1\n\n\t\t// Create a new request.\n\t\treq := client.R().SetBody(chunk)\n\n\t\t// Set the Content-Range header.\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", start, end, stream.Size()))\n\n\t\t// Set the Content-Length header.\n\t\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(chunk)))\n\n\t\t// Set the Content-Type header.\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\n\t\t// Set the If-Range header.\n\t\treq.Header.Set(\"If-Range\", stream.Etag())\n\n\t\t// Set the Range header.\n\t\treq.Header.Set(\"Range\", fmt.Sprintf(\"bytes=%d-\", totalUploaded))\n\n\t\t// Set the Authorization header.\n\t\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.Token.AccessToken))\n\n\t\t// Send the request and get the response.\n\t\tresp, err := req.Put(url)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check the status code.\n\t\tif resp.StatusCode() == http.StatusRequestedRangeNotSatisfiable {\n\t\t\t// The server does not support the range requested.\n\t\t\t// This means the file has been partially", "CodeBleu_score": 40.409980334997385}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// get the chunk size\n\tchunkSize := d.chunkSize\n\tif chunkSize == 0 {\n\t\tchunkSize = 5 * 1024 * 1024\n\t}\n\n\t// calculate the number of chunks\n\tnumChunks := int(stream.Size()) / chunkSize\n\tif int(stream.Size())%chunkSize!= 0 {\n\t\tnumChunks++\n\t}\n\n\t// create a new client\n\tclient := resty.New()\n\n\t// create a new request\n\treq := client.R().SetContext(ctx)\n\n\t// set the request method\n\treq.SetMethod(\"POST\")\n\n\t// set the request URL\n\treq.SetURL(url)\n\n\t// set the request headers\n\treq.SetHeader(\"Content-Type\", \"application/octet-stream\")\n\n\t// set the request body\n\treq.SetBody(stream)\n\n\t// set the request timeout\n\treq.SetTimeout(10 * time.Minute)\n\n\t// set the request retry count\n\treq.SetRetryCount(5)\n\n\t// set the request retry wait time\n\treq.SetRetryWaitTime(1 * time.Second)\n\n\t// set the request retry max wait time\n\treq.SetRetryMaxWaitTime(30 * time.Second)\n\n\t// create a new progress bar\n\tprogressBar := utils.NewProgressBar(numChunks)\n\n\t// upload each chunk sequentially\n\tfor i := 0; i < numChunks; i++ {\n\t\t// calculate the start and end offsets of the current chunk\n\t\tstartOffset := int64(i * chunkSize)\n\t\tendOffset := int64((i + 1) * chunkSize)\n\t\tif endOffset > stream.Size() {\n\t\t\tendOffset = stream.Size()\n\t\t}\n\n\t\t// set the request body\n\t\treq.SetBody(stream.GetRange(startOffset, endOffset))\n\n\t\t// set the request headers\n\t\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", startOffset, endOffset-1, stream.Size()))\n\n\t\t// send the request\n\t\tresp, err := req.Execute()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// update the progress bar\n\t\tprogress", "CodeBleu_score": 42.40045844565542}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size based on the file size and the maximum allowed chunk size.\n\tchunkSize := d.maxChunkSize\n\tif d.maxChunkSize > stream.Size() {\n\t\tchunkSize = stream.Size()\n\t}\n\n\t// Create a new HTTP client with a timeout of 10 seconds.\n\tclient := resty.New().SetTimeout(10 * time.Second)\n\n\t// Create a new request with the chunked transfer encoding header.\n\treq, err := client.R().SetHeader(\"Transfer-Encoding\", \"chunked\").SetBody(stream)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Iterate over the chunks of the file and upload each chunk sequentially.\n\tfor offset := 0; offset < stream.Size(); offset += chunkSize {\n\t\t// Check if the context is canceled.\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Calculate the remaining bytes in the file.\n\t\tremainingBytes := stream.Size() - offset\n\n\t\t// Calculate the chunk size based on the remaining bytes and the maximum allowed chunk size.\n\t\tif remainingBytes < chunkSize {\n\t\t\tchunkSize = remainingBytes\n\t\t}\n\n\t\t// Set the offset and length headers for the current chunk.\n\t\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+chunkSize-1, stream.Size()))\n\t\treq.SetHeader(\"Content-Length\", strconv.Itoa(chunkSize))\n\n\t\t// Send the request to the URL.\n\t\tresp, err := req.Post(url)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check the response status code.\n\t\tif resp.StatusCode()!= http.StatusCreated {\n\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode())\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.79777947401584}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar (\n\t\tmountPoint string\n\t\terr        error\n\t)\n\n\t// Get the mount point from the request context.\n\tmountPoint = ctx.QueryParam(\"mount_point\")\n\n\t// If the mount point is empty, return a client error response.\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ClientError(\"Mount point is empty.\"))\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err = service.UnmountStorage(mountPoint); err!= nil {\n\t\t// If unmounting fails, return a service error response.\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ServerError(err.Error()))\n\t}\n\n\t// Delete the corresponding configuration.\n\tif err = service.DeleteStorageConfig(mountPoint); err!= nil {\n\t\t// If deleting the configuration fails, return a service error response.\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ServerError(err.Error()))\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, common_err.Success(\"Storage unmounted successfully.\"))\n}", "CodeBleu_score": 31.584034886830857}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar (\n\t\tmountPoint string\n\t\terr        error\n\t)\n\t// Get the mount point from the request context.\n\tmountPoint = ctx.QueryParam(\"mount_point\")\n\t// If the mount point is empty, return a client error.\n\tif mountPoint == \"\" {\n\t\treturn httper.NewClientError(\"mount_point is empty\", common_err.ErrClient)\n\t}\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err = service.UnmountStorage(mountPoint); err!= nil {\n\t\t// If unmounting fails, return a service error.\n\t\treturn httper.NewServiceError(err)\n\t}\n\t// Get the configuration for the specified mount point.\n\tconfig, err := service.GetStorageConfig(mountPoint)\n\tif err!= nil {\n\t\treturn httper.NewServiceError(err)\n\t}\n\t// Delete the configuration.\n\tif err = service.DeleteStorageConfig(config); err!= nil {\n\t\treturn httper.NewServiceError(err)\n\t}\n\t// Return a success response.\n\treturn httper.NewSuccessResponse(nil)\n}", "CodeBleu_score": 26.295158979787196}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Get the mount point from the request context\n\tmountPoint := ctx.QueryParam(\"mount_point\")\n\t// Check if the mount point is empty\n\tif mountPoint == \"\" {\n\t\t// Return a client error response\n\t\treturn httper.NewClientErrorResponse(ctx, common_err.ErrInvalidMountPoint)\n\t}\n\t// Attempt to unmount the storage at the specified mount point\n\terr := service.UnmountStorage(mountPoint)\n\t// Check if the unmounting failed\n\tif err!= nil {\n\t\t// Return a service error response\n\t\treturn httper.NewServiceErrorResponse(ctx, err)\n\t}\n\t// Get the storage configuration from the request context\n\tstorageConfig := ctx.Get(\"storage_config\").(*model.StorageConfig)\n\t// Delete the storage configuration\n\terr = service.DeleteStorageConfig(storageConfig)\n\t// Check if the deletion failed\n\tif err!= nil {\n\t\t// Return a service error response\n\t\treturn httper.NewServiceErrorResponse(ctx, err)\n\t}\n\t// Return a success response\n\treturn httper.NewSuccessResponse(ctx, nil)\n}", "CodeBleu_score": 33.318823535541156}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfile_path := ctx.QueryParam(\"file_path\")\n\t// Check if the file path is provided\n\tif file_path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"File path is required\")\n\t}\n\t// Check if the file exists\n\tif!file.Exists(file_path) {\n\t\treturn ctx.JSON(http.StatusNotFound, \"File not found\")\n\t}\n\t// Read the file contents\n\tfile_data, err := ioutil.ReadFile(file_path)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Failed to read file\")\n\t}\n\t// Get the file name from the file path\n\tfile_name := path.Base(file_path)\n\t// Get the file extension from the file name\n\tfile_extension := path.Ext(file_name)\n\t// Get the file mime type from the file extension\n\tfile_mime_type := filetype.GetMIMEType(file_data)\n\t// Create a new HTTP response\n\tres := ctx.Response()\n\t// Set the file name and mime type in the response headers\n\tres.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+file_name)\n\tres.Header().Set(\"Content-Type\", file_mime_type)\n\t// Write the file data to the response\n\t_, err = res.Write(file_data)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Failed to write file to response\")\n\t}\n\t// Return the HTTP response\n\treturn nil\n}", "CodeBleu_score": 37.193354546537485}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfile_path := ctx.QueryParam(\"file_path\")\n\tif file_path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewError(common_err.InvalidParameter))\n\t}\n\tfile_path = path.Join(model.GetLocalPath(), file_path)\n\tif!file.IsExist(file_path) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewError(common_err.FileNotExist))\n\t}\n\tfile_info, err := os.Stat(file_path)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewError(common_err.FileNotExist))\n\t}\n\tif file_info.IsDir() {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewError(common_err.FileIsDir))\n\t}\n\tfile_name := file_info.Name()\n\tfile_type := filetype.DetectFile(file_path)\n\tfile_type_str := file_type.MIME.Value\n\tfile_type_str = strings.ReplaceAll(file_type_str, \" \", \"\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \"/\", \"_\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \";\", \"_\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \":\", \"_\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \"+\", \"_\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \"-\", \"_\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \".\", \"_\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \",\", \"_\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \"?\", \"_\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \"(\", \"_\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \")\", \"_\")\n\tfile_type_str = strings.ReplaceAll(file_type_str, \"[\", \"_\")\n\tfile_type_str = strings", "CodeBleu_score": 35.795073157011394}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrInvalidParam.Error())\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrFileNotExist.Error())\n\t}\n\n\t// Read the file contents\n\tfileContents, err := ioutil.ReadFile(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ErrInternalServer.Error())\n\t}\n\n\t// Get the file type from the file extension\n\tfileExtension := filepath.Ext(filePath)\n\tfileType := filetype.Match(fileContents)\n\n\t// Set the content type based on the file type\n\tcontentType := \"application/octet-stream\"\n\tswitch fileType.MIME.Value {\n\tcase \"image/jpeg\":\n\t\tcontentType = \"image/jpeg\"\n\tcase \"image/png\":\n\t\tcontentType = \"image/png\"\n\tcase \"image/gif\":\n\t\tcontentType = \"image/gif\"\n\tcase \"text/plain\":\n\t\tcontentType = \"text/plain\"\n\tcase \"application/pdf\":\n\t\tcontentType = \"application/pdf\"\n\tcase \"application/zip\":\n\t\tcontentType = \"application/zip\"\n\tcase \"application/vnd.ms-excel\":\n\t\tcontentType = \"application/vnd.ms-excel\"\n\tcase \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":\n\t\tcontentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n\tcase \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":\n\t\tcontentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\n\tcase \"application/vnd.openxmlformats-officedocument.presentationml.presentation\":\n\t\tcontentType = \"application/vnd.openxmlformats-officedocument.presentationml.presentation\"\n\tcase \"application/vnd.oasis.opendocument.text\":\n\t\tcontentType", "CodeBleu_score": 32.8851738819267}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn common_err.BadRequest(ctx, err.Error())\n\t}\n\tname := ctx.Param(\"name\")\n\tif err := service.SendNotifyMessage(name, message); err!= nil {\n\t\treturn common_err.BadRequest(ctx, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, model.Response{\n\t\tStatus:  \"success\",\n\t\tMessage: \"Notification sent successfully\",\n\t})\n}", "CodeBleu_score": 50.76216084007079}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\tif err := service.Notify(name, message); err!= nil {\n\t\treturn common_err.NewInternalServerError(err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, model.NewResponse(nil))\n}", "CodeBleu_score": 46.91040477799792}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the name parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, common_err.ErrInvalidRequest.Error())\n\t}\n\n\t// Send the notification using the name and message.\n\terr := service.SendNotification(name, message)\n\tif err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, model.Response{\n\t\tStatus:  \"success\",\n\t\tMessage: \"Notification sent successfully.\",\n\t})\n}", "CodeBleu_score": 53.77101389499466}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\tfmt.Println(err)\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections\n\tconnections = append(connections, conn)\n\n\t// Start the message sending service if it is not already running\n\tif!messageSendingServiceRunning {\n\t\tmessageSendingServiceRunning = true\n\t\tgo sendMessage()\n\t}\n\n\t// Loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err!= nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn err\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(\"Message Type:\", messageType)\n\t\tfmt.Println(\"Message:\", string(message))\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}", "CodeBleu_score": 40.22985717025437}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP GET request to a WebSocket connection.\n\tws, err := websocket.Upgrade(ctx.Response(), ctx.Request(), nil, 1024, 1024)\n\tif _, ok := err.(websocket.HandshakeError); ok {\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\treturn ctx.String(http.StatusBadRequest, \"Not a websocket handshake\")\n\t} else if err!= nil {\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, \"Internal Server Error\"))\n\t\treturn ctx.String(http.StatusInternalServerError, \"Cannot setup WebSocket connection\")\n\t}\n\t// Add the new WebSocket connection to a list of connections.\n\tservice.AddConnection(ws)\n\t// Ensure that the message sending service is running.\n\tservice.StartMessageSendingService()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t// Read the next message from the WebSocket connection.\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\t// If there is an error reading the message, close the WebSocket connection and remove it from the list of connections.\n\t\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, \"Internal Server Error\"))\n\t\t\tservice.RemoveConnection(ws)\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type and message.\n\t\tfmt.Printf(\"Received message: %s\n\", message)\n\t\t// Parse the message as a JSON object.\n\t\tvar msg types.Notify\n\t\terr = json.Unmarshal(message, &msg)\n\t\tif err!= nil {\n\t\t\t// If there is an error parsing the message as a JSON object, print the error.\n\t\t\tfmt.Println(\"Error parsing message as JSON:\", err)\n\t\t}\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Printf(\"Message type: %s\n\", msg.Type)\n\t\tfmt.Printf(\"Message: %s\n\", msg.Message)\n\t\tfmt.Printf(\"Error: %v\n\", msg.Error)\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.63004649337714}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tupgrader := websocket.Upgrader{}\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections\n\tservice.AddConnection(ws)\n\n\t// Start the message sending service if it is not already running\n\tif!service.IsRunning() {\n\t\tgo service.Start()\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\t// If an error occurs while reading the message, close the WebSocket connection and return the error\n\t\t\tws.Close()\n\t\t\treturn err\n\t\t}\n\n\t\t// Parse the message as a notification\n\t\tnotification := types.Notification{}\n\t\terr = json.Unmarshal(message, &notification)\n\t\tif err!= nil {\n\t\t\t// If an error occurs while parsing the message, close the WebSocket connection and return the error\n\t\t\tws.Close()\n\t\t\treturn err\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Printf(\"Notification Type: %s\nMessage: %s\nError: %v\n\", notification.Type, notification.Message, notification.Error)\n\t}\n}", "CodeBleu_score": 40.41509713658386}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Initialize the \"hardwareInfo\" variable to an empty string.\n\tvar hardwareInfo string\n\n\t// Retrieve the system architecture and drive model.\n\thardwareInfo = fmt.Sprintf(\"System Architecture: %s\nDrive Model: %s\n\", runtime.GOARCH, runtime.GOOS)\n\n\t// If the \"hardwareInfo\" variable is empty, return an error.\n\tif hardwareInfo == \"\" {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common.Response{\n\t\t\tStatus:  \"error\",\n\t\t\tMessage: \"Failed to retrieve system hardware information.\",\n\t\t})\n\t}\n\n\t// Return the \"hardwareInfo\" variable as a JSON response.\n\treturn ctx.JSON(http.StatusOK, common.Response{\n\t\tStatus:  \"success\",\n\t\tMessage: \"Successfully retrieved system hardware information.\",\n\t\tData:    hardwareInfo,\n\t})\n}", "CodeBleu_score": 23.21018435394316}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// get hardware info\n\thardwareInfo, err := utils.GetHardwareInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common.NewErrorResponse(err.Error()))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common.NewSuccessResponse(hardwareInfo))\n}", "CodeBleu_score": 15.121131976650826}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\terr error\n\t\tinfo *model.HardwareInfo\n\t)\n\tif info, err = service.GetSystemHardwareInfo(); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewError(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, info)\n}", "CodeBleu_score": 16.993219997261093}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunningServices := make([]string, 0)\n\tnotRunningServices := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 62.31835951045524}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 70.57881417774232}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tvar running, notRunning []string\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 78.42321632717038}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t//fmt.Println(\"send notify\", name, message)\n\tif i.notifyClient == nil {\n\t\treturn\n\t}\n\ti.notifyClient.Publish(name, message)\n}", "CodeBleu_score": 8.476504549126297}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message to JSON\n\tdata, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to serialize message to JSON\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Create the notification object\n\tnotification := &notify.Notification{\n\t\tName:    name,\n\t\tMessage: string(data),\n\t}\n\n\t// Publish the notification to the message bus\n\terr = i.bus.Publish(name, notification)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish notification\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 33.4715231195656}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Convert the message map to JSON strings\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to marshal message to JSON\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus\n\terr = i.bus.Publish(name, string(messageJSON))\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event to message bus\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 36.11193447844091}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\tif address, err := c.Runtime().Get(\"message_bus\"); err == nil {\n\t\tclient.SetServer(address)\n\t} else {\n\t\tclient.SetServer(message_bus.DefaultErrorServer)\n\t}\n\treturn client\n}", "CodeBleu_score": 27.923210423580148}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\tif c.RuntimePath!= nil {\n\t\tif address, err := c.RuntimePath.GetMessageBusAddress(); err == nil {\n\t\t\tclient.SetServer(address)\n\t\t} else {\n\t\t\tclient.SetServer(message_bus.ErrorServer)\n\t\t}\n\t} else {\n\t\tclient.SetServer(message_bus.ErrorServer)\n\t}\n\treturn client\n}", "CodeBleu_score": 33.52445284999487}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// initialize the client\n\tclient := message_bus.NewClientWithResponses(c.runtime.Path())\n\t// attempt to retrieve the message bus address\n\taddress := c.config.GetString(\"message_bus.address\")\n\t// if the address is found, set the client's server to the retrieved address\n\tif address!= \"\" {\n\t\tclient.SetServer(address)\n\t} else {\n\t\t// otherwise, set the server to a default error message\n\t\tclient.SetServer(\"Error: message bus address not found\")\n\t}\n\t// return the initialized client\n\treturn client\n}", "CodeBleu_score": 26.050744627050378}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\t// Check if the request contains the \"x-forwarded-for\" header and extract the first IP\n\txForwardedFor := request.Header.Get(\"x-forwarded-for\")\n\tif xForwardedFor!= \"\" {\n\t\tips := strings.Split(xForwardedFor, \",\")\n\t\treturn strings.TrimSpace(ips[0])\n\t}\n\n\t// If the \"x-forwarded-for\" header is not available, use the request's remote address\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 49.56178183969822}, {"code": "func GetIP(request *http.Request) string{\n\t\t// Get the \"x-forwarded-for\" header\n\tforwardedFor := request.Header.Get(\"x-forwarded-for\")\n\n\t// If the header is present, extract the first IP address\n\tif forwardedFor!= \"\" {\n\t\t// Split the IP addresses by comma\n\t\tips := strings.Split(forwardedFor, \",\")\n\n\t\t// Return the first IP address\n\t\treturn strings.TrimSpace(ips[0])\n\t}\n\n\t// If the header is not present, use the request's remote address\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\n\t// If the IP address is a loopback address, convert it to \"127.0.0.1\"\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\t// Return the IP address\n\treturn ip\n}", "CodeBleu_score": 49.84376607597146}, {"code": "func GetIP(request *http.Request) string{\n\t\txForwardedFor := request.Header.Get(\"X-Forwarded-For\")\n\tif xForwardedFor!= \"\" {\n\t\tip := strings.Split(xForwardedFor, \",\")[0]\n\t\tif ip!= \"\" {\n\t\t\treturn ip\n\t\t}\n\t}\n\n\tip := request.RemoteAddr\n\tif ip!= \"\" {\n\t\tip = strings.Split(ip, \":\")[0]\n\t\tif ip!= \"\" {\n\t\t\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\t\t\treturn \"127.0.0.1\"\n\t\t\t}\n\t\t\treturn ip\n\t\t}\n\t}\n\n\treturn \"\"\n}", "CodeBleu_score": 52.61946167063796}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Check if the entry file exists\n\tif _, err := os.Stat(c.entryFilePath); os.IsNotExist(err) {\n\t\t// Create the entry file if it does not exist\n\t\tif err := os.Create(c.entryFilePath); err!= nil {\n\t\t\tlogger.Error(\"Error creating entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Create the entry file if it does not exist\n\tif err := os.Create(c.entryFilePath); err!= nil {\n\t\tlogger.Error(\"Error creating entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Read the entry file\n\tentryFile, err := os.OpenFile(c.entryFilePath, os.O_RDWR|os.O_APPEND, 0666)\n\tif err!= nil {\n\t\tlogger.Error(\"Error opening entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Create the entry file if it does not exist\n\tif err := os.Create(c.entryFilePath); err!= nil {\n\t\tlogger.Error(\"Error creating entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Read the entry file\n\tentryFile, err = os.OpenFile(c.entryFilePath, os.O_RDWR|os.O_APPEND, 0666)\n\tif err!= nil {\n\t\tlogger.Error(\"Error opening entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Close the entry file\n\tdefer entryFile.Close()\n\n\t// Read the modules directory\n\tmodulesDir, err := os.Open(c.modulesDir)\n\tif err!= nil {\n\t\tlogger.Error(\"Error opening modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Close the modules directory\n\tdefer modulesDir.Close()\n\n\t// Read the entry file\n\tentryFile, err = os.OpenFile(c.entryFilePath, os.O_RDWR|os.O_APPEND, 0666)\n\tif err!= nil {\n\t\tlogger.Error(\"Error opening entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Close the entry file\n\tdefer entryFile.Close()\n\n\t", "CodeBleu_score": 42.769499830493196}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the system entry path from the config file\n\tentryPath := config.SystemEntryPath\n\n\t// Check if the entry file exists\n\tif _, err := os.Stat(entryPath); os.IsNotExist(err) {\n\t\t// If the entry file does not exist, create it\n\t\tfile.CreateFile(entryPath)\n\t}\n\n\t// Create an empty array to store the module entries\n\tvar moduleEntries []model.ModuleEntry\n\n\t// Iterate through each module directory in the modules directory\n\tfor _, moduleDir := range config.ModulesDir {\n\t\t// Get the module directory path\n\t\tmoduleDirPath := filepath.Join(config.ModulesDir, moduleDir)\n\n\t\t// Check if the module directory exists\n\t\tif _, err := os.Stat(moduleDirPath); os.IsNotExist(err) {\n\t\t\t// If the module directory does not exist, skip it\n\t\t\tcontinue\n\t\t}\n\n\t\t// Iterate through each file in the module directory\n\t\tfor _, file := range file.GetFilesInDir(moduleDirPath) {\n\t\t\t// Get the file path\n\t\t\tfilePath := filepath.Join(moduleDirPath, file)\n\n\t\t\t// Check if the file is an entry file\n\t\t\tif file == \"entry.json\" {\n\t\t\t\t// If the file is an entry file, read its content\n\t\t\t\tcontent, err := file.ReadFile(filePath)\n\t\t\t\tif err!= nil {\n\t\t\t\t\t// Log the error\n\t\t\t\t\tlogger.Error(\"Failed to read module entry file\",\n\t\t\t\t\t\tzap.String(\"module\", moduleDir),\n\t\t\t\t\t\tzap.String(\"file\", file),\n\t\t\t\t\t\tzap.Error(err),\n\t\t\t\t\t)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Unmarshal the content into a module entry\n\t\t\t\tvar moduleEntry model.ModuleEntry\n\t\t\t\terr = json.Unmarshal(content, &moduleEntry)\n\t\t\t\tif err!= nil {\n\t\t\t\t\t// Log the error\n\t\t\t\t\tlogger.Error(\"Failed to unmarshal module entry file\",\n\t\t\t\t\t\tzap.String(\"module\", moduleDir),\n\t\t\t\t\t\tzap.String(\"file\", file),\n\t\t\t\t\t\tzap.Error(err),\n\t\t\t\t\t)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Append the module entry to the array\n\t\t\t\tmoduleEntries = append(moduleEntries, moduleEntry)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Marshal the module entries into JSON\n\tmoduleEntriesJSON, err := json.Marshal(moduleEntries)", "CodeBleu_score": 40.1127634719258}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tc.logger.Info(\"Generate system entry\")\n\tc.logger.Info(\"Generate system entry\", zap.String(\"entry\", c.entryFile))\n\t// 1. \u8bfb\u53d6\u6240\u6709\u6a21\u5757\u7684entry.json\u6587\u4ef6\n\t// 2. \u5408\u5e76\u5230\u4e00\u4e2a\u6570\u7ec4\u4e2d\n\t// 3. \u5199\u5165\u5230entry.json\u6587\u4ef6\u4e2d\n\t// 1. read all entry.json files in modules directory\n\t// 2. consolidate into a single JSON array\n\t// 3. write to the entry file path\n\t// 1. read all entry.json files in modules directory\n\t// 2. consolidate into a single JSON array\n\t// 3. write to the entry file path\n\tc.logger.Info(\"Generate system entry\", zap.String(\"entry\", c.entryFile))\n\t// 1. read all entry.json files in modules directory\n\t// 2. consolidate into a single JSON array\n\t// 3. write to the entry file path\n\t// 1. read all entry.json files in modules directory\n\t// 2. consolidate into a single JSON array\n\t// 3. write to the entry file path\n\tmodules, err := filepath.Glob(c.modulesDir + \"/*\")\n\tif err!= nil {\n\t\tc.logger.Error(\"Generate system entry\", zap.Error(err))\n\t\treturn\n\t}\n\tc.logger.Info(\"Generate system entry\", zap.String(\"modules\", fmt.Sprintf(\"%v\", modules)))\n\t// 1. read all entry.json files in modules directory\n\t// 2. consolidate into a single JSON array\n\t// 3. write to the entry file path\n\t// 1. read all entry.json files in modules directory\n\t// 2. consolidate into a single JSON array\n\t// 3. write to the entry file path\n\tvar entries []model.SystemEntry\n\tfor _, module := range modules {\n\t\t// 1. read all entry.json files in modules directory\n\t\t// 2. consolidate into a single JSON array\n\t\t// 3. write to the entry file path\n\t\t// 1. read all entry.json files in modules directory\n\t\t// 2. consolidate into a single JSON array\n\t\t// 3", "CodeBleu_score": 23.756405400031323}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t//get list of network interfaces\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\t//get list of network names\n\tnetworkNames, err := net.InterfaceNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\t//iterate over interfaces\n\tfor _, i := range interfaces {\n\t\t//iterate over network names\n\t\tfor _, n := range networkNames {\n\t\t\t//check if interface name matches network name\n\t\t\tif i.Name == n {\n\t\t\t\t//return MAC address\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\t//no matching interface found\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 66.48069759363699}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, i := range interfaces {\n\t\taddrs, err := i.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net2.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"127.0.0.1\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"0.0.0.0\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"169.254.0.0\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"192.168.127.12\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"172.16.17.32\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"192.168.3.11\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"192.168.3.11\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"192.168.3.11\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"192.168.127.12\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"172.16.31.10\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"172.16.17.32\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.String() == \"172.16.31.10\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ip.", "CodeBleu_score": 51.65331427469134}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get list of network interfaces\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get list of network names\n\tnames, err := net.InterfaceNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over interfaces and names\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range names {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"No matching interface found\")\n}", "CodeBleu_score": 63.43829538170173}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\trc = -1;\n\t} else {\n\t\trc = trefAddRef(&pRequest->ref);\n\t\tif (rc == 0) {\n\t\t\tpTscObj->requestCount++;\n\t\t\tif (pTscObj->appInfo!= NULL) {\n\t\t\t\tpTscObj->appInfo->requestCount++;\n\t\t\t}\n\t\t\ttlog(LOG_INFO, \"Request %d registered for TSC %d.\", pRequest->id, pTscObj->id);\n\t\t} else {\n\t\t\ttlog(LOG_ERR, \"Error registering request %d for TSC %d.\", pRequest->id, pTscObj->id);\n\t\t}\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 25.19452118550099}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\tSAppObj *pAppObj = NULL;\n\tint32_t reqCount = 0;\n\n\t/*\n\t * Add a reference to the request object and increment the request count for the associated TSC object.\n\t */\n\trc = trefAdd(&pRequest->ref, 1);\n\tif (rc == 0) {\n\t\treqCount = tscGetRequestCount(pTscObj);\n\t\tif (reqCount > 0) {\n\t\t\trc = tscSetRequestCount(pTscObj, reqCount + 1);\n\t\t}\n\t}\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary, including total and current request counts.\n\t */\n\tif (rc == 0) {\n\t\tpAppObj = tscGetAppObj(pTscObj);\n\t\tif (pAppObj!= NULL) {\n\t\t\trc = appUpdateRequestSummary(pAppObj, pRequest);\n\t\t}\n\t}\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tif (rc == 0) {\n\t\tlogDebug(\"registerRequest\", \"Registered request %p for TSC %p\", pRequest, pTscObj);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 39.301707856121006}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t lRetVal = T_SUCCESS;\n\n\tif (pTscObj!= NULL) {\n\t\tif (pTscObj->lRequestCount < MAX_REQUESTS) {\n\t\t\tpTscObj->lRequestCount++;\n\t\t\tif (pTscObj->lRequestCount > pTscObj->lMaxRequestCount) {\n\t\t\t\tpTscObj->lMaxRequestCount = pTscObj->lRequestCount;\n\t\t\t}\n\t\t\tif (pTscObj->pAppInfo!= NULL) {\n\t\t\t\tpTscObj->pAppInfo->lTotalRequests++;\n\t\t\t\tpTscObj->pAppInfo->lCurrentRequests++;\n\t\t\t}\n\t\t\tpRequest->lRefCount++;\n\t\t\tpRequest->pTscObj = pTscObj;\n\t\t\tpRequest->lStartTime = ttime();\n\t\t\tpRequest->lEndTime = 0;\n\t\t\tpRequest->lTotalTime = 0;\n\t\t\tpRequest->lTotalData = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;\n\t\t\tpRequest->lTotalDataReceived = 0;\n\t\t\tpRequest->lTotalDataSent = 0;", "CodeBleu_score": 29.236108432050866}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar* dbName = NULL;\n\tchar* dbName1 = NULL;\n\tchar* dbName2 = NULL;\n\tchar* dbName3 = NULL;\n\tchar* dbName4 = NULL;\n\tchar* dbName5 = NULL;\n\tchar* dbName6 = NULL;\n\tchar* dbName7 = NULL;\n\tchar* dbName8 = NULL;\n\tchar* dbName9 = NULL;\n\tchar* dbName10 = NULL;\n\tchar* dbName11 = NULL;\n\tchar* dbName12 = NULL;\n\tchar* dbName13 = NULL;\n\tchar* dbName14 = NULL;\n\tchar* dbName15 = NULL;\n\tchar* dbName16 = NULL;\n\tchar* dbName17 = NULL;\n\tchar* dbName18 = NULL;\n\tchar* dbName19 = NULL;\n\tchar* dbName20 = NULL;\n\tchar* dbName21 = NULL;\n\tchar* dbName22 = NULL;\n\tchar* dbName23 = NULL;\n\tchar* dbName24 = NULL;\n\tchar* dbName25 = NULL;\n\tchar* dbName26 = NULL;\n\tchar* dbName27 = NULL;\n\tchar* dbName28 = NULL;\n\tchar* dbName29 = NULL;\n\tchar* dbName30 = NULL;\n\tchar* dbName31 = NULL;\n\tchar* dbName32 = NULL;\n\tchar* dbName33 = NULL;\n\tchar* dbName34 = NULL;\n\tchar* dbName35 = NULL;\n\tchar* dbName36 = NULL;\n\tchar* dbName37 = NULL;\n\tchar* dbName38 = NULL;\n\tchar* dbName39 = NULL;\n\tchar* dbName40 = NULL;\n\tchar* dbName41 = NULL;\n\tchar* dbName42 = NULL;\n\tchar* dbName43 = NULL;\n\tchar* dbName44 = NULL;\n\tchar* dbName45 = NULL;\n\tchar* dbName46 = NULL;\n\tchar* dbName4", "CodeBleu_score": 5.593326423953926}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar* db = NULL;\n\tchar* db_tmp = NULL;\n\tbool isExceptDb = false;\n\tif (pRequest == NULL) {\n\t\treturn false;\n\t}\n\tif (pRequest->db == NULL) {\n\t\treturn false;\n\t}\n\tif (strcmp(pRequest->db, exceptDb) == 0) {\n\t\treturn false;\n\t}\n\tdb = strdup(pRequest->db);\n\tif (db == NULL) {\n\t\treturn false;\n\t}\n\tdb_tmp = strchr(db, '.');\n\tif (db_tmp!= NULL) {\n\t\t*db_tmp = '\\0';\n\t}\n\tif (strcmp(db, exceptDb) == 0) {\n\t\tisExceptDb = true;\n\t}\n\tif (db_tmp!= NULL) {\n\t\t*db_tmp = '.';\n\t}\n\twhile (db_tmp!= NULL) {\n\t\tdb_tmp = strchr(db_tmp + 1, '.');\n\t\tif (db_tmp!= NULL) {\n\t\t\t*db_tmp = '\\0';\n\t\t}\n\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\tisExceptDb = true;\n\t\t}\n\t\tif (db_tmp!= NULL) {\n\t\t\t*db_tmp = '.';\n\t\t}\n\t}\n\tfree(db);\n\treturn isExceptDb;\n}", "CodeBleu_score": 48.126549719025455}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar* dbName = NULL;\n\tchar* dbName2 = NULL;\n\tchar* dbName3 = NULL;\n\tchar* dbName4 = NULL;\n\tchar* dbName5 = NULL;\n\tchar* dbName6 = NULL;\n\tchar* dbName7 = NULL;\n\tchar* dbName8 = NULL;\n\tchar* dbName9 = NULL;\n\tchar* dbName10 = NULL;\n\tchar* dbName11 = NULL;\n\tchar* dbName12 = NULL;\n\tchar* dbName13 = NULL;\n\tchar* dbName14 = NULL;\n\tchar* dbName15 = NULL;\n\tchar* dbName16 = NULL;\n\tchar* dbName17 = NULL;\n\tchar* dbName18 = NULL;\n\tchar* dbName19 = NULL;\n\tchar* dbName20 = NULL;\n\tchar* dbName21 = NULL;\n\tchar* dbName22 = NULL;\n\tchar* dbName23 = NULL;\n\tchar* dbName24 = NULL;\n\tchar* dbName25 = NULL;\n\tchar* dbName26 = NULL;\n\tchar* dbName27 = NULL;\n\tchar* dbName28 = NULL;\n\tchar* dbName29 = NULL;\n\tchar* dbName30 = NULL;\n\tchar* dbName31 = NULL;\n\tchar* dbName32 = NULL;\n\tchar* dbName33 = NULL;\n\tchar* dbName34 = NULL;\n\tchar* dbName35 = NULL;\n\tchar* dbName36 = NULL;\n\tchar* dbName37 = NULL;\n\tchar* dbName38 = NULL;\n\tchar* dbName39 = NULL;\n\tchar* dbName40 = NULL;\n\tchar* dbName41 = NULL;\n\tchar* dbName42 = NULL;\n\tchar* dbName43 = NULL;\n\tchar* dbName44 = NULL;\n\tchar* dbName45 = NULL;\n\tchar* dbName46 = NULL;\n\tchar* dbName47 = NULL;\n\tchar* dbName", "CodeBleu_score": 5.593326423953926}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == E_CLIENT_RPC_REDIRECT && msgType!= M_CLIENT_RPC_PING && msgType!= M_CLIENT_RPC_PING_REPLY && msgType!= M_CLIENT_RPC_PING_TIMEOUT) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 30.613585111308566}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == CLIENT_RPC_REDIRECT_CODE) {\n\t\tif (msgType!= MSG_CLIENT_RPC_REQUEST) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 26.7014718163775}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == 1000) {\n\t\tif (msgType!= 1000 && msgType!= 1001 && msgType!= 1002 && msgType!= 1003 && msgType!= 1004 && msgType!= 1005 && msgType!= 1006 && msgType!= 1007 && msgType!= 1008 && msgType!= 1009 && msgType!= 1010 && msgType!= 1011 && msgType!= 1012 && msgType!= 1013 && msgType!= 1014 && msgType!= 1015 && msgType!= 1016 && msgType!= 1017 && msgType!= 1018 && msgType!= 1019 && msgType!= 1020 && msgType!= 1021 && msgType!= 1022 && msgType!= 1023 && msgType!= 1024 && msgType!= 1025 && msgType!= 1026 && msgType!= 1027 && msgType!= 1028 && msgType!= 1029 && msgType!= 1030 && msgType!= 1031 && msgType!= 1032 && msgType!= 1033 && msgType!= 1034 && msgType!= 1035 && msgType!= 1036 && msgType!= 1037 && msgType!= 1038 && msgType!= 1039 && msgType!= 1040 && msgType!= 1041 && msgType!= 1042 && msgType!= 1043 && msgType!= 1044 && msgType!= 1045 && msgType!= 1046 && msgType!= 1047 && msgType!= 1048 && msgType!= 1049 && msgType!= 1050 && msgType!= 1051 && msgType!= 1052 && msgType!= 1053 && msgType!= 1054 && msg", "CodeBleu_score": 14.239101793565215}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i;\n\tSRequest *pRequest;\n\tSQuery *pQuery;\n\tfor (i = 0; i < pRequests->iCount; i++) {\n\t\tpRequest = (SRequest *) pRequests->pArray[i];\n\t\tif (pRequest!= NULL) {\n\t\t\tpQuery = pRequest->pQuery;\n\t\t\tif (pQuery!= NULL) {\n\t\t\t\tstopQuery(pQuery);\n\t\t\t}\n\t\t\treleaseRequest(pRequest);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.94494854647288}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashObjIter iter;\n\tSHashObjEntry *pEntry;\n\tSRequest *pRequest;\n\tSQuery *pQuery;\n\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\t/* Iterate through the hash table of requests */\n\tshobj_iter_init(&iter, pRequests);\n\twhile ((pEntry = shobj_iter_next(&iter))!= NULL) {\n\t\t/* Acquire the request */\n\t\tpRequest = (SRequest *) pEntry->data;\n\n\t\t/* Check if the request is valid */\n\t\tif (pRequest!= NULL && pRequest->pQuery!= NULL) {\n\t\t\t/* Get the query associated with the request */\n\t\t\tpQuery = pRequest->pQuery;\n\n\t\t\t/* Stop the query */\n\t\t\tquery_stop(pQuery);\n\n\t\t\t/* Release the request */\n\t\t\treleaseRequest(pRequest);\n\t\t}\n\t}\n}", "CodeBleu_score": 42.57990518518148}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashObj *pRequest;\n\tSRequest *pReq;\n\tSQuery *pQuery;\n\tint i;\n\n\tfor (i = 0; i < pRequests->nSize; i++) {\n\t\tpRequest = pRequests->ppHash[i];\n\t\twhile (pRequest) {\n\t\t\tpReq = (SRequest *) pRequest->pData;\n\t\t\tpQuery = pReq->pQuery;\n\t\t\tif (pQuery) {\n\t\t\t\tif (pQuery->pQuery) {\n\t\t\t\t\tif (pQuery->pQuery->pRequest) {\n\t\t\t\t\t\tpQuery->pQuery->pRequest->bStop = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpRequest = pRequest->pNext;\n\t\t}\n\t}\n}", "CodeBleu_score": 33.07234530260629}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (tscIsCrashReportEnabled()) {\n\t\tif (atomic_compare_exchange_strong(&tscClientStop, &tscClientStop, 1)) {\n\t\t\ttscLog(LOG_INFO, \"Stopping crash report thread\");\n\t\t\twhile (tscClientStop) {\n\t\t\t\tosSleep(1000);\n\t\t\t}\n\t\t} else {\n\t\t\ttscLog(LOG_INFO, \"Crash report thread is already stopped\");\n\t\t}\n\t}\n}", "CodeBleu_score": 45.109937850216234}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportEnabled()) {\n\t\treturn;\n\t}\n\tint stop = 1;\n\tif (tatomic_cas_int(&tscClientStop, 0, 1) == 0) {\n\t\treturn;\n\t}\n\twhile (stop) {\n\t\tosSleep(1000);\n\t\tstop = tscClientStop;\n\t}\n}", "CodeBleu_score": 47.061626695558815}, {"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportEnabled == 0) {\n\t\treturn;\n\t}\n\tint result = tscClientStop;\n\twhile (result!= 0) {\n\t\tresult = tscClientStop;\n\t}\n}", "CodeBleu_score": 35.65419004999984}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t l = 0;\n\tint32_t m = 0;\n\tint32_t n = 0;\n\tint32_t o = 0;\n\tint32_t p = 0;\n\tint32_t q = 0;\n\tint32_t r = 0;\n\tint32_t s = 0;\n\tint32_t t = 0;\n\tint32_t u = 0;\n\tint32_t v = 0;\n\tint32_t w = 0;\n\tint32_t x = 0;\n\tint32_t y = 0;\n\tint32_t z = 0;\n\tint32_t aa = 0;\n\tint32_t ab = 0;\n\tint32_t ac = 0;\n\tint32_t ad = 0;\n\tint32_t ae = 0;\n\tint32_t af = 0;\n\tint32_t ag = 0;\n\tint32_t ah = 0;\n\tint32_t ai = 0;\n\tint32_t aj = 0;\n\tint32_t ak = 0;\n\tint32_t al = 0;\n\tint32_t am = 0;\n\tint32_t an = 0;\n\tint32_t ao = 0;\n\tint32_t ap = 0;\n\tint32_t aq = 0;\n\tint32_t ar = 0;\n\tint32_t as = 0;\n\tint32_t at = 0;\n\tint32_t au = 0;\n\tint32_t av = 0;\n\tint32_t aw = 0;\n\tint32_t ax", "CodeBleu_score": 8.069126398742975}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t numViews = 0;\n\tint32_t numCols = 0;\n\tint32_t numCols2 = 0;\n\tint32_t numCols3 = 0;\n\tint32_t numCols4 = 0;\n\tint32_t numCols5 = 0;\n\tint32_t numCols6 = 0;\n\tint32_t numCols7 = 0;\n\tint32_t numCols8 = 0;\n\tint32_t numCols9 = 0;\n\tint32_t numCols10 = 0;\n\tint32_t numCols11 = 0;\n\tint32_t numCols12 = 0;\n\tint32_t numCols13 = 0;\n\tint32_t numCols14 = 0;\n\tint32_t numCols15 = 0;\n\tint32_t numCols16 = 0;\n\tint32_t numCols17 = 0;\n\tint32_t numCols18 = 0;\n\tint32_t numCols19 = 0;\n\tint32_t numCols20 = 0;\n\tint32_t numCols21 = 0;\n\tint32_t numCols22 = 0;\n\tint32_t numCols23 = 0;\n\tint32_t numCols24 = 0;\n\tint32_t numCols25 = 0;\n\tint32_t numCols26 = 0;\n\tint32_t numCols27 = 0;\n\tint32_t numCols28 = 0;\n\tint32_t numCols29 = 0;\n\tint32_t numCols30 = 0;\n\tint32_t numCols31 = 0;\n\tint32_t numCols", "CodeBleu_score": 8.181448472758284}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t numViews = 0;\n\tint32_t numCols = 0;\n\tint32_t numColsInView = 0;\n\tint32_t numColsInCatalog = 0;\n\tint32_t numColsInViewMetadata = 0;\n\tint32_t numColsInCatalogMetadata = 0;\n\tint32_t numColsInViewMetadataInCatalog = 0;\n\tint32_t numColsInCatalogMetadataInView = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadata = 0;\n\tint32_t numColsInViewMetadataInCatalogMetadata = 0;\n\tint32_t numColsInViewMetadataInCatalogMetadataInView = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadata = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadataInCatalog = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadataInCatalogMetadata = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadataInCatalogMetadataInView = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadataInCatalogMetadataInViewMetadata = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadataInCatalogMetadataInViewMetadataInCatalog = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadataInCatalogMetadataInViewMetadataInCatalogMetadata = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadataInCatalogMetadataInViewMetadataInCatalogMetadataInView = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadataInCatalogMetadataInViewMetadataInCatalogMetadataInViewMetadata = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadataInCatalogMetadataInViewMetadataInCatalogMetadataInViewMetadataInCatalog = 0;\n\tint32_t numColsInCatalogMetadataInViewMetadataInCatalogMetadataInViewMetadataInCatalogMetadataInViewMetadataInCatalogMetadata = 0;", "CodeBleu_score": 8.718019310118612}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3ResponsePropertiesCallbackData *data = (S3ResponsePropertiesCallbackData *) callbackData;\n\n\tif (properties->content_length > 0) {\n\t\tdata->contentLength = properties->content_length;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 64.90841956842137}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3CallbackData *data = (S3CallbackData *)callbackData;\n\tif (properties->content_length > 0) {\n\t\tdata->contentLength = properties->content_length;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\treturn status;\n}", "CodeBleu_score": 66.62040484653126}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3CallbackData *data = (S3CallbackData *)callbackData;\n\tif (properties->content_length > 0) {\n\t\tdata->contentLength = properties->content_length;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\treturn status;\n}", "CodeBleu_score": 66.62040484653126}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tchar *backupDir = getBackupDir();\n\tchar *rsyncConf = getRsyncConf();\n\tchar *rsyncPort = getRsyncPort();\n\tchar *rsyncCommand = getRsyncCommand(rsyncPort, rsyncConf);\n\tchar *rsyncLog = getRsyncLog();\n\n\t// Create the backup directory if it does not exist\n\tif (mkdir(backupDir, S_IRWXU) == -1) {\n\t\tlogError(\"Could not create backup directory\");\n\t} else {\n\t\t// Remove empty directories\n\t\tremoveEmptyDirs(backupDir);\n\n\t\t// Generate the Rsync configuration file\n\t\tif (generateRsyncConf(rsyncConf) == 0) {\n\t\t\t// Start the Rsync daemon\n\t\t\tif (system(rsyncCommand) == 0) {\n\t\t\t\tlogInfo(\"Rsync server started successfully\");\n\t\t\t} else {\n\t\t\t\tlogError(\"Could not start Rsync server\");\n\t\t\t}\n\t\t} else {\n\t\t\tlogError(\"Could not generate Rsync configuration file\");\n\t\t}\n\t}\n\n\tfree(backupDir);\n\tfree(rsyncConf);\n\tfree(rsyncPort);\n\tfree(rsyncCommand);\n\tfree(rsyncLog);\n}", "CodeBleu_score": 28.834599841595853}, {"code": "void startRsync(){\n\t\tchar *command;\n\tchar *directory = getCheckpointBackupDirectory();\n\tchar *port = getRsyncPort();\n\tchar *config = getRsyncConfig();\n\tchar *log = getRsyncLog();\n\tchar *pid = getRsyncPid();\n\tchar *err = getRsyncError();\n\tchar *daemon = getRsyncDaemon();\n\n\tif (createDirectory(directory) == 0) {\n\t\tremoveEmptyDirectories(directory);\n\t\tif (generateRsyncConfig(config) == 0) {\n\t\t\tcommand = malloc(strlen(daemon) + strlen(port) + strlen(config) + strlen(log) + strlen(pid) + strlen(err) + 10);\n\t\t\tsprintf(command, \"%s -p %s -f %s -d -l %s -L %s -E %s -m %s\", daemon, port, config, log, pid, err, directory);\n\t\t\tif (system(command) == 0) {\n\t\t\t\tlogRsyncServerStarted();\n\t\t\t} else {\n\t\t\t\tlogRsyncServerFailed();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.47828168133569}, {"code": "void startRsync(){\n\t\t// Create the checkpoint backup directory if it doesn't already exist\n\tif (mkdir(CHECKPOINT_BACKUP_DIR, 0777) == -1) {\n\t\t// Log an error if the directory creation failed\n\t\tlogError(\"Failed to create checkpoint backup directory\");\n\t}\n\n\t// Remove empty directories in the checkpoint backup directory\n\tremoveEmptyDirs(CHECKPOINT_BACKUP_DIR);\n\n\t// Generate the Rsync configuration file\n\tif (generateConfigFile() == 0) {\n\t\t// Construct and execute a command to start the Rsync daemon with the specified port and configuration file\n\t\tchar command[1024];\n\t\tsprintf(command, \"rsync --daemon --config=%s --port=%d\", CONFIG_FILE, RSYNC_PORT);\n\t\tif (system(command) == 0) {\n\t\t\t// Log that the Rsync server started successfully\n\t\t\tlogInfo(\"Started Rsync server\");\n\t\t} else {\n\t\t\t// Log an error if the Rsync server failed to start\n\t\t\tlogError(\"Failed to start Rsync server\");\n\t\t}\n\t}\n}", "CodeBleu_score": 20.006294141940234}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tlog.debug(\"Destroying dispatcher [{}]...\", dispatcherId);\n\tdispatcher.remove(dispatcherId);\n\tlog.debug(\"Dispatcher [{}] destroyed.\", dispatcherId);\n}", "CodeBleu_score": 24.731242343687832}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatcherId == null || dispatcherId.isEmpty()) {\n\t\tthrow new IllegalArgumentException(\"Dispatcher ID is null or empty\");\n\t}\n\tfinal Lock lock = new ReentrantLock();\n\tlock.lock();\n\ttry {\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\t\t\tif (dispatcher.isStarted()) {\n\t\t\t\tdispatcher.stop();\n\t\t\t}\n\t\t\tdispatchers.remove(dispatcherId);\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t\t}\n\t} finally {\n\t\tlock.unlock();\n\t}\n}", "CodeBleu_score": 50.10209849646981}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tlog.debug(\"Destroying dispatcher with id: {}\", dispatcherId);\n\tdispatcher.remove(dispatcherId);\n}", "CodeBleu_score": 15.678615157965503}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tSet<TbActorId> children = children.keySet();\n\tchildren.stream().filter(childFilter).forEach(child -> {\n\t\tif (child.isLocal()) {\n\t\t\tif (highPriority) {\n\t\t\t\tmsg.setHighPriority(true);\n\t\t\t}\n\t\t\tchild.tell(msg);\n\t\t} else {\n\t\t\tlog.warn(\"Child actor {} is not registered\", child);\n\t\t}\n\t});\n}", "CodeBleu_score": 42.46549477573538}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t//        log.trace(\"Broadcasting message {} to children of {}\", msg, parent);\n        Set<TbActorId> children = childrenMap.get(parent);\n        if (children == null) {\n            log.trace(\"No children found for {}\", parent);\n            return;\n        }\n        List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n        for (TbActorId child : filteredChildren) {\n            try {\n                if (highPriority) {\n                    highPriorityExecutor.execute(() -> send(child, msg));\n                } else {\n                    send(child, msg);\n                }\n            } catch (Exception e) {\n                log.warn(\"Failed to send message {} to child {} of {}\", msg, child, parent, e);\n            }\n        }\n    }", "CodeBleu_score": 54.04726010602654}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tif (childFilter == null) {\n\t\tchildFilter = id -> true;\n\t}\n\tSet<TbActorId> children = childrenMap.get(parent);\n\tif (children!= null) {\n\t\tfor (TbActorId child : children) {\n\t\t\tif (childFilter.test(child)) {\n\t\t\t\tsend(child, msg, highPriority);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.04135356740567}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (highPriority) {\n\t\thighPriorityMsgs.add(msg);\n\t} else {\n\t\tnormalPriorityMsgs.add(msg);\n\t}\n\tif (!destroying.get()) {\n\t\tprocessQueue();\n\t} else if (highPriority && msg.getType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\tif (initializationFailed.get()) {\n\t\t\tinitialize(false);\n\t\t}\n\t} else {\n\t\tmsg.notifyStopped(TbActorStopReason.DESTROYED);\n\t}\n}", "CodeBleu_score": 39.632688430581425}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (destroyed.get()) {\n\t\tif (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\ttry {\n\t\t\t\treinitialize();\n\t\t\t} catch (Exception e) {\n\t\t\t\tnotifyStopped(msg, TbActorStopReason.REINITIALIZATION_FAILED, e);\n\t\t\t}\n\t\t} else {\n\t\t\tnotifyStopped(msg, TbActorStopReason.DESTROYED);\n\t\t}\n\t\treturn;\n\t}\n\tif (highPriority) {\n\t\thighPriorityMsgs.add(msg);\n\t} else {\n\t\tnormalPriorityMsgs.add(msg);\n\t}\n\tprocessQueue();\n}", "CodeBleu_score": 47.779127932435486}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (destroyed.get()) {\n\t\tif (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\tif (initFailed.get()) {\n\t\t\t\tinitFailed.set(false);\n\t\t\t\tinit();\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.notifyStopped(TbActorStopReason.DESTROYED);\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\ttry {\n\t\t\tprocessQueue();\n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"Error while processing queue\", e);\n\t\t}\n\t}\n}", "CodeBleu_score": 52.42613344684111}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t//    while (true) {", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\t\ttry {\n\t\tif (isStopping.get()) {\n\t\t\tlog.debug(\"Actor {} is stopping\", this);\n\t\t\treturn;\n\t\t}\n\t\tif (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n\t\t\tlog.debug(\"Actor {} has no messages in its mailbox\", this);\n\t\t\tif (status.compareAndSet(ActorStatus.FREE, ActorStatus.BUSY)) {\n\t\t\t\tlog.debug(\"Actor {} is free\", this);\n\t\t\t\tscheduleMailboxProcessing();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (isStopping.get()) {\n\t\t\tlog.debug(\"Actor {} is stopping\", this);\n\t\t\treturn;\n\t\t}\n\t\tif (highPriorityQueue.isEmpty()) {\n\t\t\tlog.debug(\"Actor {} has no high priority messages in its mailbox\", this);\n\t\t}\n\t\tif (normalPriorityQueue.isEmpty()) {\n\t\t\tlog.debug(\"Actor {} has no normal priority messages in its mailbox\", this);\n\t\t}\n\t\tif (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n\t\t\tlog.debug(\"Actor {} has no messages in its mailbox\", this);\n\t\t\tif (status.compareAndSet(ActorStatus.FREE, ActorStatus.BUSY)) {\n\t\t\t\tlog.debug(\"Actor {} is free\", this);\n\t\t\t\tscheduleMailboxProcessing();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint highPriorityQueueSize = highPriorityQueue.size();\n\t\tint normalPriorityQueueSize = normalPriorityQueue.size();\n\t\tint mailboxSize = highPriorityQueueSize + normalPriorityQueueSize;\n\t\tif (mailboxSize > maxMailboxSize) {\n\t\t\tlog.debug(\"Actor {} has too many messages in its mailbox ({} > {})\", this, mailboxSize, maxMailboxSize);\n\t\t\tif (status.compareAndSet(ActorStatus.FREE, ActorStatus.BUSY)) {\n\t\t\t\tlog.debug(\"Actor {} is free\", this);\n\t\t\t\tscheduleMailboxProcessing();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (highPriorityQueueSize > maxHighPriorityQueueSize) {\n\t\t\tlog.debug(\"Actor {} has too many high priority messages in its mailbox ({} > {})\", this, highPriorityQueueSize, maxHighPriorityQueueSize);\n\t\t\tif (status.compareAndSet(ActorStatus.FREE, ActorStatus.BUSY)) {\n\t\t\t\tlog.debug(\"Actor {} is free", "CodeBleu_score": 17.30103903602655}, {"code": "private void processMailbox(){\n\t\tif (status.get()!= Status.RUNNING) {\n\t\treturn;\n\t}\n\ttry {\n\t\t// Process high priority messages\n\t\tprocessQueue(highPriorityQueue, highPriorityLimit, highPriorityProcessStrategy);\n\t\t// Process normal priority messages\n\t\tprocessQueue(normalPriorityQueue, normalPriorityLimit, normalPriorityProcessStrategy);\n\t} catch (ActorInitializationException e) {\n\t\tlog.error(\"Actor {} initialization failed\", actorName, e);\n\t\tstop(TbActorStopReason.ACTOR_INITIALIZATION_FAILED, e);\n\t} catch (Exception e) {\n\t\tlog.error(\"Actor {} process failed\", actorName, e);\n\t\tprocessFailureStrategy.apply(e);\n\t}\n}", "CodeBleu_score": 14.930915964939304}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tdestroy(cause, null);\n}", "CodeBleu_score": 3.6512156333113763}, {"code": "public void destroy(Throwable cause){\n\t\tif (destroyed.compareAndSet(false, true)) {\n\t\tif (stopReason == null) {\n\t\t\tstopReason = TbActorStopReason.DESTROYED;\n\t\t}\n\t\tif (cause == null) {\n\t\t\tcause = new TbActorError(stopReason, \"Actor \" + this + \" destroyed without cause\");\n\t\t}\n\t\tdispatcher.executor().schedule(() -> {\n\t\t\ttry {\n\t\t\t\tdestroy(stopReason, cause);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.warn(\"Error destroying actor \" + this, t);\n\t\t\t}\n\t\t}, 0, TimeUnit.MILLISECONDS);\n\t\tnotifyAll(new TbActorMsg(MsgType.ACTOR_DESTROYED, this, stopReason, cause));\n\t}\n}", "CodeBleu_score": 39.91219302523242}, {"code": "public void destroy(Throwable cause){\n\t\tif (isDestroyed()) {\n\t\tlog.warn(\"Actor {} already destroyed\", this);\n\t\treturn;\n\t}\n\tif (isStopping()) {\n\t\tlog.warn(\"Actor {} already stopping\", this);\n\t\treturn;\n\t}\n\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.CAUSE;\n\t}\n\tif (cause == null) {\n\t\tcause = new Exception(\"Actor \" + this + \" destroyed without cause\");\n\t}\n\tif (isReady()) {\n\t\ttry {\n\t\t\tsetReady(false);\n\t\t\tdestroy(stopReason, cause);\n\t\t\tnotifyAllQueued(stopReason, cause);\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"Exception during destroying actor {}\", this, t);\n\t\t}\n\t}\n\tdestroyed.set(true);\n}", "CodeBleu_score": 36.91408894110933}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.equals(TenantId.SYSTEM_TENANT_ID)) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = getTenantProfile(tenantId);\n\tif (tenantProfile == null && ignoreTenantNotFound) {\n\t\treturn true;\n\t} else if (tenantProfile == null) {\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tif (tenantProfile.getRateLimit()!= null && tenantProfile.getRateLimit().isEnabled()) {\n\t\tRateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimit().getRateLimitsTrigger();\n\t\tif (rateLimitsTrigger!= null && rateLimitsTrigger.isEnabled()) {\n\t\t\tint limit = rateLimitsTrigger.getLimit();\n\t\t\tint period = rateLimitsTrigger.getPeriod();\n\t\t\tString key = tenantId.getId() + \".\" + api.name() + \".\" + level;\n\t\t\tCache<String, TbRateLimits> cache = cache.get(key);\n\t\t\tif (cache == null) {\n\t\t\t\tcache = Caffeine.newBuilder().expireAfterWrite(period, TimeUnit.SECONDS).build();\n\t\t\t\tcache.put(key, new TbRateLimits(limit, period));\n\t\t\t}\n\t\t\tTbRateLimits tbRateLimits = cache.get(key);\n\t\t\tif (tbRateLimits!= null) {\n\t\t\t\tif (tbRateLimits.increment() > limit) {\n\t\t\t\t\tprocessRateLimitNotification(tenantId, api, level);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 48.110331677283284}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = tenantProfileService.findTenantProfileByTenantId(tenantId);\n\tif (tenantProfile == null) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tif (tenantProfile.getRateLimit() == null) {\n\t\treturn true;\n\t}\n\tTbRateLimits tbRateLimits = tenantProfile.getRateLimit();\n\tCache<String, RateLimitsTrigger> cache = Caffeine.newBuilder()\n\t\t\t.expireAfterWrite(tbRateLimits.getRateLimitCacheTtl(), TimeUnit.MILLISECONDS)\n\t\t\t.maximumSize(tbRateLimits.getRateLimitCacheMaxSize())\n\t\t\t.build();\n\tString key = tenantId.getId() + \"_\" + api.name() + \"_\" + level;\n\tRateLimitsTrigger rateLimitsTrigger = cache.getIfPresent(key);\n\tif (rateLimitsTrigger == null) {\n\t\trateLimitsTrigger = new RateLimitsTrigger(tbRateLimits, api, level);\n\t\tcache.put(key, rateLimitsTrigger);\n\t}\n\tif (rateLimitsTrigger.isRateLimitExceeded()) {\n\t\tnotificationRuleProcessor.processRateLimitNotification(tenantId, api, level);\n\t}\n\treturn!rateLimitsTrigger.isRateLimitExceeded();\n}", "CodeBleu_score": 49.302481722917015}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId == null) {\n\t\treturn true;\n\t}\n\tif (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = tenantProfileService.findTenantProfileByTenantId(tenantId);\n\tif (tenantProfile == null && ignoreTenantNotFound) {\n\t\treturn true;\n\t}\n\tif (tenantProfile == null) {\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tTbRateLimits rateLimits = tenantProfile.getRateLimits();\n\tif (rateLimits == null) {\n\t\treturn true;\n\t}\n\tCache<String, RateLimitsTrigger> cache = rateLimitsTriggerCache.get(tenantId);\n\tif (cache == null) {\n\t\tcache = Caffeine.newBuilder()\n\t\t\t\t.expireAfterWrite(rateLimits.getTriggerCacheExpirationTime(), TimeUnit.MILLISECONDS)\n\t\t\t\t.build();\n\t\trateLimitsTriggerCache.put(tenantId, cache);\n\t}\n\tRateLimitsTrigger trigger = cache.getIfPresent(api.name());\n\tif (trigger == null) {\n\t\ttrigger = new RateLimitsTrigger(api, rateLimits);\n\t\tcache.put(api.name(), trigger);\n\t}\n\tif (trigger.isLimitExceeded()) {\n\t\tNotificationRuleProcessor.processNotificationRules(tenantId, api, level);\n\t}\n\treturn!trigger.isLimitExceeded();\n}", "CodeBleu_score": 50.43128509592929}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong timeout = 10000;\n\tlong expirationTime = System.currentTimeMillis() - timeout;\n\tConcurrentMap<InetSocketAddress, DtlsSession> sessions = new ConcurrentHashMap<>();\n\tsessions.entrySet().removeIf(entry -> entry.getValue().getLastActivityTime() < expirationTime);\n\tlog.info(\"Removed {} DTLS sessions\", sessions.size());\n}", "CodeBleu_score": 40.71353757276176}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong timeout = getInactivityTimeout();\n\tlong expirationTime = currentTime - timeout;\n\tConcurrentMap<InetSocketAddress, DTLSClientSession> sessions = getSessions();\n\tsessions.forEach((address, session) -> {\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\tlog.info(\"Removing DTLS session for {} due to inactivity timeout\", address);\n\t\t\tsessions.remove(address);\n\t\t}\n\t});\n}", "CodeBleu_score": 36.13421693140161}, {"code": "public void evictTimeoutSessions(){\n\t\tlong now = System.currentTimeMillis();\n\tlong expirationTime = now - inactivityTimeout;\n\tConcurrentMap<InetSocketAddress, DTLSServerSession> sessions = dtlsSessions;\n\tfor (DTLSServerSession session : sessions.values()) {\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\tlog.debug(\"Removing DTLS session for {}:{} due to inactivity\", session.getLocalAddress().getAddress(), session.getLocalAddress().getPort());\n\t\t\tsessions.remove(session.getLocalAddress());\n\t\t}\n\t}\n}", "CodeBleu_score": 35.262226615930636}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (CollectionUtils.isEmpty(timeseries)) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> result = new ArrayList<>();\n\ttimeseries.forEach((key, values) -> {\n\t\tif (values.size() == 1) {\n\t\t\tJsonNode value = values.get(0);\n\t\t\tif (value.isBoolean()) {\n\t\t\t\tresult.add(new BooleanDataEntry(key, value.asBoolean()));\n\t\t\t} else if (value.isDouble()) {\n\t\t\t\tresult.add(new DoubleDataEntry(key, value.asDouble()));\n\t\t\t} else if (value.isInt()) {\n\t\t\t\tresult.add(new LongDataEntry(key, value.asLong()));\n\t\t\t} else if (value.isTextual()) {\n\t\t\t\tresult.add(new StringDataEntry(key, value.asText()));\n\t\t\t} else if (value.isValueNode()) {\n\t\t\t\tresult.add(new JsonDataEntry(key, value));\n\t\t\t}\n\t\t} else {\n\t\t\tList<BaseAttributeKvEntry> entries = values.stream().map(node -> new AttributeKvEntry(key, node)).collect(Collectors.toList());\n\t\t\tresult.add(new BasicTsKvEntry(key, entries));\n\t\t}\n\t});\n\treturn result;\n}", "CodeBleu_score": 46.78158694907643}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (CollectionUtils.isEmpty(timeseries)) {\n\t\treturn Collections.emptyList();\n\t}\n\treturn timeseries.entrySet().stream().flatMap(e -> e.getValue().stream().map(v -> toTimeseriesEntry(e.getKey(), v))).collect(Collectors.toList());\n}", "CodeBleu_score": 20.154094727640746}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (CollectionUtils.isEmpty(timeseries)) {\n\t\treturn Collections.emptyList();\n\t}\n\treturn timeseries.entrySet().stream().map(entry -> {\n\t\tList<BaseAttributeKvEntry> attributeKvEntries = new ArrayList<>();\n\t\tfor (JsonNode value : entry.getValue()) {\n\t\t\tattributeKvEntries.add(toAttributeKvEntry(value));\n\t\t}\n\t\treturn new BasicTsKvEntry(entry.getKey(), attributeKvEntries);\n\t}).collect(Collectors.toList());\n}", "CodeBleu_score": 34.370957211889085}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tMap<String, String> requestBody = new HashMap<>();\n\trequestBody.put(\"refresh_token\", refreshToken);\n\trequestBody.put(\"grant_type\", \"refresh_token\");\n\trequestBody.put(\"client_id\", clientId);\n\trequestBody.put(\"client_secret\", clientSecret);\n\trequestBody.put(\"scope\", scope);\n\trequestBody.put(\"platform\", platform);\n\trequestBody.put(\"platform_version\", platformVersion);\n\trequestBody.put(\"device_id\", deviceId);\n\trequestBody.put(\"device_secret\", deviceSecret);\n\trequestBody.put(\"device_name\", deviceName);\n\trequestBody.put(\"device_type\", deviceType);\n\trequestBody.put(\"device_os\", deviceOs);\n\trequestBody.put(\"device_os_version\", deviceOsVersion);\n\trequestBody.put(\"device_manufacturer\", deviceManufacturer);\n\trequestBody.put(\"device_model\", deviceModel);\n\trequestBody.put(\"device_serial\", deviceSerial);\n\trequestBody.put(\"device_firmware_version\", deviceFirmwareVersion);\n\trequestBody.put(\"device_hardware_version\", deviceHardwareVersion);\n\trequestBody.put(\"device_app_version\", deviceAppVersion);\n\trequestBody.put(\"device_app_build_version\", deviceAppBuildVersion);\n\trequestBody.put(\"device_app_build_date\", deviceAppBuildDate);\n\trequestBody.put(\"device_app_build_type\", deviceAppBuildType);\n\trequestBody.put(\"device_app_build_flavor\", deviceAppBuildFlavor);\n\trequestBody.put(\"device_app_build_flavor_version\", deviceAppBuildFlavorVersion);\n\trequestBody.put(\"device_app_build_flavor_build_date\", deviceAppBuildFlavorBuildDate);\n\trequestBody.put(\"device_app_build_flavor_build_type\", deviceAppBuildFlavorBuildType);\n\trequestBody.put(\"device_app_build_flavor_build_flavor\", deviceAppBuildFlavorBuildFlavor);\n\trequestBody.put(\"device_app_build_flavor_build_flavor_version\", deviceAppBuildFlavorBuildFlavorVersion);\n\trequestBody.put(\"device_app_build_flavor_build_", "CodeBleu_score": 23.394579289797896}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refresh_token\", refreshToken);\n\trequestMap.put(\"grant_type\", \"refresh_token\");\n\trequestMap.put(\"client_id\", clientId);\n\trequestMap.put(\"client_secret\", clientSecret);\n\trequestMap.put(\"scope\", scope);\n\trequestMap.put(\"redirect_uri\", redirectUri);\n\tMap<String, String> response = restTemplate.postForObject(tokenEndpoint, requestMap, Map.class);\n\taccessToken = response.get(\"access_token\");\n\trefreshToken = response.get(\"refresh_token\");\n\ttokenExpirationTime = System.currentTimeMillis() + Long.parseLong(response.get(\"expires_in\")) * 1000;\n}", "CodeBleu_score": 45.861146209558534}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refresh_token\", refreshToken);\n\trequestMap.put(\"grant_type\", \"refresh_token\");\n\trequestMap.put(\"client_id\", clientId);\n\trequestMap.put(\"client_secret\", clientSecret);\n\tString response = sendRequest(requestMap, \"POST\", \"/oauth/token\");\n\tif (!isEmpty(response)) {\n\t\tresponse = response.replace(\"\\\"\", \"\");\n\t\tString[] responseArray = response.split(\",\");\n\t\tfor (String responsePair : responseArray) {\n\t\t\tString[] pair = responsePair.split(\":\");\n\t\t\tif (pair[0].equals(\"access_token\")) {\n\t\t\t\taccessToken = pair[1];\n\t\t\t} else if (pair[0].equals(\"refresh_token\")) {\n\t\t\t\trefreshToken = pair[1];\n\t\t\t} else if (pair[0].equals(\"expires_in\")) {\n\t\t\t\texpiresIn = Integer.parseInt(pair[1]);\n\t\t\t}\n\t\t}\n\t\ttokenTimestamp = System.currentTimeMillis();\n\t}\n}", "CodeBleu_score": 42.805733934280674}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\t// The function \"doLogin\" performs a login operation by sending a POST request with the username and password to the authentication endpoint.\n\t// It captures the current timestamp, creates a login request map with the credentials, and sends the request to the \"/api/auth/login\" URL.\n\t// Upon receiving the response, it updates the token information with the response data and the timestamp.\n\t// The function \"doLogin\" performs a login operation by sending a POST request with the username and password to the authentication endpoint.\n\t// It captures the current timestamp, creates a login request map with the credentials, and sends the request to the \"/api/auth/login\" URL.\n\t// Upon receiving the response, it updates the token information with the response data and the timestamp.\n\t// The function \"doLogin\" performs a login operation by sending a POST request with the username and password to the authentication endpoint.\n\t// It captures the current timestamp, creates a login request map with the credentials, and sends the request to the \"/api/auth/login\" URL.\n\t// Upon receiving the response, it updates the token information with the response data and the timestamp.\n\t// The function \"doLogin\" performs a login operation by sending a POST request with the username and password to the authentication endpoint.\n\t// It captures the current timestamp, creates a login request map with the credentials, and sends the request to the \"/api/auth/login\" URL.\n\t// Upon receiving the response, it updates the token information with the response data and the timestamp.\n\t// The function \"doLogin\" performs a login operation by sending a POST request with the username and password to the authentication endpoint.\n\t// It captures the current timestamp, creates a login request map with the credentials, and sends the request to the \"/api/auth/login\" URL.\n\t// Upon receiving the response, it updates the token information with the response data and the timestamp.\n\t// The function \"doLogin\" performs a login operation by sending a POST request with the username and password to the authentication endpoint.\n\t// It captures the current timestamp, creates a login request map with the credentials, and sends the request to the \"/api/auth/login\" URL.\n\t// Upon receiving the response, it updates the token information with the response data and the timestamp.\n\t// The function \"doLogin\" performs a login operation by sending", "CodeBleu_score": 1.3779295561275005}, {"code": " private void doLogin(){\n\t\tString url = \"http://localhost:8080/api/auth/login\";\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", \"admin\");\n\tloginRequest.put(\"password\", \"\");\n\tRestTemplate restTemplate = new RestTemplate();\n\tResponseEntity<String> response = restTemplate.postForEntity(url, loginRequest, String.class);\n\tString responseBody = response.getBody();\n\tSystem.out.println(responseBody);\n}", "CodeBleu_score": 49.49656296469792}, {"code": " private void doLogin(){\n\t\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", );\n\tString loginResponse = sendPostRequest(loginRequest, \"/api/auth/login\");\n\tif (loginResponse!= null) {\n\t\tString token = getJsonValue(loginResponse, \"token\");\n\t\tif (token!= null) {\n\t\t\ttokenInfo.setToken(token);\n\t\t\ttokenInfo.setTimestamp(System.currentTimeMillis());\n\t\t}\n\t}\n}", "CodeBleu_score": 51.817063498443886}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn getDeviceById(deviceId, null);\n}", "CodeBleu_score": 6.442408619513598}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn getDeviceById(deviceId, null);\n}", "CodeBleu_score": 6.442408619513598}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn getDeviceById(deviceId, null);\n}", "CodeBleu_score": 6.442408619513598}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\treturn saveDeviceWithCredentials(device, credentials, null);\n}", "CodeBleu_score": 9.595657006565938}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\treturn saveDeviceWithCredentials(device, credentials, null);\n}", "CodeBleu_score": 9.595657006565938}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tif (device == null) {\n\t\tthrow new IllegalArgumentException(\"device is null\");\n\t}\n\tif (credentials == null) {\n\t\tthrow new IllegalArgumentException(\"credentials is null\");\n\t}\n\tSaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest(device, credentials);\n\ttry {\n\t\tOptional<Device> result = this.restTemplate.postForObject(this.restUrl + \"/api/device-with-credentials\", request, Device.class);\n\t\treturn result;\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 61.302051611312926}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\treturn this.command(\"brightness\", [addr, val]);\n}", "CodeBleu_score": 5.811129883122054}, {"code": "brightness(addr, val){\n\t\tif (typeof addr === 'number' && typeof val === 'number') {\n\t\tthis.send(0x01, addr, val);\n\t\treturn this;\n\t} else if (typeof addr === 'number' && typeof val === 'undefined') {\n\t\tthis.send(0x02, addr);\n\t\treturn this;\n\t} else if (typeof addr === 'undefined' && typeof val === 'undefined') {\n\t\tthis.send(0x03);\n\t\treturn this;\n\t} else {\n\t\tthrow new Error('Invalid arguments');\n\t}\n}", "CodeBleu_score": 39.211472471660656}, {"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\tthis.setBrightness(addr, val);\n\t\treturn this;\n\t}\n\telse if (arguments.length == 2) {\n\t\tthis.setBrightness(addr, val);\n\t\treturn this;\n\t}\n\telse {\n\t\treturn this;\n\t}\n}", "CodeBleu_score": 47.01253972787006}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tlet dev = {};\n\tfor (let key in LedControl.prototype) {\n\t\tif (LedControl.prototype.hasOwnProperty(key)) {\n\t\t\tdev[key] = LedControl.prototype[key].bind(this, addr);\n\t\t}\n\t}\n\treturn dev;\n}", "CodeBleu_score": 26.043747343713434}, {"code": "device(addr){\n\t\tvar self = this;\n\tvar obj = {};\n\tObject.keys(LedControl.prototype).forEach(function(key) {\n\t\tobj[key] = LedControl.prototype[key].bind(self);\n\t});\n\tObject.keys(this).forEach(function(key) {\n\t\tobj[key] = self[key].bind(self);\n\t});\n\treturn obj;\n}", "CodeBleu_score": 33.378152782832494}, {"code": "device(addr){\n\t\tvar obj = Object.create(LedControl.prototype);\n\tfor (var key in LedControl.prototype) {\n\t\tif (LedControl.prototype.hasOwnProperty(key)) {\n\t\t\tobj[key] = LedControl.prototype[key].bind(this, addr);\n\t\t}\n\t}\n\treturn obj;\n}", "CodeBleu_score": 25.116625491787893}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function(...args) {\n\t\t\tconst promises = this.map(element => {\n\t\t\t\treturn new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\telement[method](...args);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}, 1000);\n\t\t\t\t});\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tif (typeof args[args.length - 1] === 'function') {\n\t\t\t\t\targs[args.length - 1]();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 29.9819271274216}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method + 'Reconciliation'] = (duration = 1000, callback = () => {}) => {\n\t\t\tif (!isFunction(callback)) {\n\t\t\t\tthrow new TypeError('The callback must be a function.');\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\ttarget.forEach(element => {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\telement[method]();\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 25.89512277777105}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function (duration, callback) {\n\t\t\tif (!callback || typeof callback!== 'function') {\n\t\t\t\tthrow new TypeError('The callback must be a function.');\n\t\t\t}\n\n\t\t\tlet promises = [];\n\t\t\tthis.forEach(element => {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\telement[method]();\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}, duration || 1000);\n\t\t\t\t}));\n\t\t\t});\n\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 29.98044427105233}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\tthis.input = \"\";\n\tthis.port.on(\"data\", (data) => {\n\t\tthis.input += data.toString();\n\t\tconst sentences = this.input.split(\"\\r\n\");\n\t\tthis.input = sentences.pop();\n\t\tsentences.forEach((sentence) => {\n\t\t\tthis.parseNmeaSentence(sentence);\n\t\t});\n\t});\n}", "CodeBleu_score": 26.024483397127575}, {"code": "listen(){\n\t\t// Initialize input string and read loop\n\tvar input = \"\";\n\tvar port = new SerialPort(this.port, { baudRate: this.baudRate });\n\tport.on(\"data\", (data) => {\n\t\t// Append data to input string\n\t\tinput += data;\n\t\t// Split input string into sentences\n\t\tvar sentences = input.split(\"\\r\n\");\n\t\t// Process each sentence\n\t\tfor (var i = 0; i < sentences.length - 1; i++) {\n\t\t\t// Parse NMEA sentence\n\t\t\tthis.parseNmeaSentence(sentences[i]);\n\t\t}\n\t\t// Retain incomplete sentence\n\t\tinput = sentences[sentences.length - 1];\n\t});\n}", "CodeBleu_score": 52.626086144888305}, {"code": "listen(){\n\t\tvar input = \"\";\n\tvar incompleteSentence = \"\";\n\tvar port = this.port;\n\tvar parser = this;\n\tvar parseNmeaSentence = this.parseNmeaSentence;\n\n\tport.on(\"data\", function(data) {\n\t\tinput += data;\n\t\tvar sentences = input.split(\"\\r\n\");\n\t\tinput = sentences.pop();\n\n\t\tfor (var i = 0; i < sentences.length; i++) {\n\t\t\tvar sentence = incompleteSentence + sentences[i];\n\t\t\tincompleteSentence = parseNmeaSentence(sentence);\n\t\t}\n\t});\n}", "CodeBleu_score": 37.8486755961005}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tsize_t size = 0;\n\tsize_t i;\n\n\t/*\n\t * The buffer size is calculated as the number of active channels multiplied by the size of each data sample.\n\t * The number of active channels is calculated by counting the channels that are enabled in the sequence.\n\t */\n\tfor (i = 0; i < sequence->channels_size; i++) {\n\t\tif (sequence->channels[i] < data->channels_size) {\n\t\t\tsize += sizeof(uint16_t);\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < size) {\n\t\tLOG_ERR(\"Insufficient memory for buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.329346522593866}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tint num_channels = 0;\n\tint buffer_size = 0;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels_length; i++) {\n\t\tif (sequence->channels[i] < config->channels_num) {\n\t\t\tnum_channels++;\n\t\t\tbuffer_size += sizeof(uint16_t);\n\t\t}\n\t}\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size is insufficient for ADC sequence\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.286073407255515}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *cfg = dev->config;\n\tconst struct ad559x_channel_cfg *channel_cfg = cfg->channels;\n\tsize_t num_channels = cfg->num_channels;\n\tsize_t sample_size = sizeof(uint16_t);\n\tsize_t buffer_size = sequence->buffer_size;\n\tsize_t active_channels = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tif (channel_cfg[i].channel_id == sequence->channel_ids[0]) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tif (buffer_size < active_channels * sample_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 42.36344262197316}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_context *ctx = dev->data;\n\tstruct adc_sequence *sequence_copy = NULL;\n\tstruct adc_sequence *sequence_copy_temp = NULL;\n\tstruct ad559x_context *ad559x_ctx = dev->data;\n\tint ret = 0;\n\tuint32_t adc_resolution = 0;\n\tuint32_t adc_buffer_size = 0;\n\tuint32_t adc_buffer_size_temp = 0;\n\tuint32_t adc_buffer_size_temp_1 = 0;\n\tuint32_t adc_buffer_size_temp_2 = 0;\n\tuint32_t adc_buffer_size_temp_3 = 0;\n\tuint32_t adc_buffer_size_temp_4 = 0;\n\tuint32_t adc_buffer_size_temp_5 = 0;\n\tuint32_t adc_buffer_size_temp_6 = 0;\n\tuint32_t adc_buffer_size_temp_7 = 0;\n\tuint32_t adc_buffer_size_temp_8 = 0;\n\tuint32_t adc_buffer_size_temp_9 = 0;\n\tuint32_t adc_buffer_size_temp_10 = 0;\n\tuint32_t adc_buffer_size_temp_11 = 0;\n\tuint32_t adc_buffer_size_temp_12 = 0;\n\tuint32_t adc_buffer_size_temp_13 = 0;\n\tuint32_t adc_buffer_size_temp_14 = 0;\n\tuint32_t adc_buffer_size_temp_15 = 0;\n\tuint32_t adc_buffer_size_temp_16 = 0;\n\tuint32_t adc_buffer_size_temp_17 = 0;\n\tuint32_t adc_buffer_size_temp_18 = 0;\n\tuint32_t adc_buffer_size_temp_19 = 0;\n\tuint", "CodeBleu_score": 13.319728840420977}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tLOG_DBG(\"ADC: AD559x start read\");\n\tstruct adc_context *ctx = dev->data;\n\tstruct ad559x_dev *ad559x = dev->driver_data;\n\tint ret;\n\tuint32_t val;\n\tuint8_t ch_mask = 0;\n\tuint8_t ch_count = 0;\n\n\tif (sequence->channels == NULL) {\n\t\tLOG_ERR(\"ADC: AD559x invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_SCAN_END) {\n\t\tLOG_ERR(\"ADC: AD559x scan end not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < sequence->buffer_size_max) {\n\t\tLOG_ERR(\"ADC: AD559x buffer too small\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution!= 12) {\n\t\tLOG_ERR(\"ADC: AD559x invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (int i = 0; i < sequence->channel_count; i++) {\n\t\tif (sequence->channels[i] >= 8) {\n\t\t\tLOG_ERR(\"ADC: AD559x invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tch_mask |= 1 << sequence->channels[i];\n\t\tch_count++;\n\t}\n\n\tif (ch_count == 0) {\n\t\tLOG_ERR(\"ADC: AD559x no channels selected\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ch_count > 4) {\n\t\tLOG_ERR(\"ADC: AD559x too many channels selected\");\n\t\treturn -EINVAL;\n\t}\n\n\tctx->buffer = sequence->buffer;\n\tctx->buffer_size = sequence->buffer_size;\n\tctx->buffer_pos = 0;\n\n\tret = ad559x_read(ad559x, AD559X_REG_STATUS, &val);\n\tif (ret) {\n\t\tLOG_ERR(\"ADC: AD559x read failed\");\n\t\treturn ret;\n\t", "CodeBleu_score": 43.914558754683355}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_context *adc_ctx = dev->data;\n\tstruct ad559x_config *config = dev->config;\n\tstruct ad559x_data *data = dev->data;\n\tuint32_t resolution = 0;\n\tint ret;\n\n\tif (sequence->channels == NULL) {\n\t\tLOG_ERR(\"Invalid argument: channels is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels_length > AD559X_MAX_CHANNELS) {\n\t\tLOG_ERR(\"Invalid argument: channels_length is too large\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (int i = 0; i < sequence->channels_length; i++) {\n\t\tif (sequence->channels[i] > AD559X_MAX_CHANNELS) {\n\t\t\tLOG_ERR(\"Invalid argument: channel %d is too large\", sequence->channels[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sequence->resolution > AD559X_MAX_RESOLUTION) {\n\t\tLOG_ERR(\"Invalid argument: resolution is too large\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution < AD559X_MIN_RESOLUTION) {\n\t\tLOG_ERR(\"Invalid argument: resolution is too small\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\tLOG_ERR(\"Invalid argument: buffer is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < sequence->channels_length) {\n\t\tLOG_ERR(\"Invalid argument: buffer size is too small\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (int i = 0; i < sequence->channels_length; i++) {\n\t\tresolution |= sequence->channels[i];\n\t}\n\n\tif (resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid argument: resolution does not match the expected resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ad559x_set_buffer(data, sequence->buffer);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to set buffer\");\n\t\treturn ret;\n\t}\n\n\tret = ad559x", "CodeBleu_score": 48.20880918643809}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_sequence *seq = &ctx->adc_seq;\n\tint err;\n\n\tseq->buffer = ctx->adc_buf;\n\tseq->buffer_length = sizeof(ctx->adc_buf);\n\n\terr = adc_read(ctx->adc_dev, seq);\n\tif (err) {\n\t\tLOG_ERR(\"Failed to start sampling\");\n\t}\n}", "CodeBleu_score": 38.41817921179484}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_sequence seq = {\n\t\t.buffer = ctx->data,\n\t\t.buffer_size = sizeof(ctx->data),\n\t\t.resolution = 16,\n\t\t.channels = {\n\t\t\tADC_CHANNEL_CONFIG_INPUT_POS(ctx->channel),\n\t\t\tADC_CHANNEL_CONFIG_INPUT_NEG(ctx->channel),\n\t\t},\n\t\t.options = 0,\n\t\t.context = ctx,\n\t};\n\n\tadc_read(ctx->adc_dev, &seq);\n}", "CodeBleu_score": 18.84271656616285}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_sequence seq;\n\n\tseq.options = 0;\n\tseq.buffer = ctx->adc_buffer;\n\tseq.buffer_size = sizeof(ctx->adc_buffer);\n\tseq.resolution = 16;\n\tseq.channels = BIT(ctx->channel);\n\tseq.format = ADC_FORMAT_SIGNED;\n\tseq.oversampling = 1;\n\tseq.sampling_frequency = 1000000;\n\n\tadc_read(ctx->adc_dev, &seq);\n}", "CodeBleu_score": 45.02416539294638}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->data_container = ctx->repeat_data_container;\n\t} else {\n\t\tctx->data_container = ctx->single_data_container;\n\t}\n\n\tctx->data_container->buffer_pointer = ctx->data_container->buffer;\n}", "CodeBleu_score": 45.680415347694264}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = ctx->buffer;\n\t}\n}", "CodeBleu_score": 47.04822149301768}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_buffer *buffer = NULL;\n\tif (repeat_sampling) {\n\t\tbuffer = ctx->repeat_buffer;\n\t} else {\n\t\tbuffer = ctx->buffer;\n\t}\n\n\tif (buffer == NULL) {\n\t\treturn;\n\t}\n\n\tbuffer->buffer_pointer = buffer->buffer;\n}", "CodeBleu_score": 44.83716113052773}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint ret;\n\tint channel;\n\tint channel_count;\n\tstruct adc_context *ctx;\n\tstruct adc_context *ctx_next;\n\tstruct adc_context *ctx_prev;\n\tstruct adc_context *ctx_first;\n\tstruct adc_context *ctx_last;\n\tstruct adc_context *ctx_cur;\n\n\tLOG_DBG(\"AD559X acquisition thread started\");\n\n\t/*\n\t * The semaphore is used to signal that the sampling is done.\n\t * It is released by the main thread after all channels are read.\n\t */\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\t/*\n\t * The \"ctx_first\" and \"ctx_last\" pointers are used to store the first and last\n\t * ADC context in the list of active contexts.\n\t */\n\tctx_first = NULL;\n\tctx_last = NULL;\n\n\t/*\n\t * The \"ctx_cur\" pointer is used to iterate through the list of active contexts.\n\t */\n\tctx_cur = NULL;\n\n\t/*\n\t * The \"channel_count\" variable is used to store the number of active channels.\n\t */\n\tchannel_count = 0;\n\n\t/*\n\t * The \"ctx\" pointer is used to store the current ADC context.\n\t */\n\tctx = NULL;\n\n\t/*\n\t * The \"ctx_prev\" and \"ctx_next\" pointers are used to store the previous and next\n\t * ADC context in the list of active contexts.\n\t */\n\tctx_prev = NULL;\n\tctx_next = NULL;\n\n\t/*\n\t * The \"channel\" variable is used to store the current channel.\n\t */\n\tchannel = 0;\n\n\t/*\n\t * The \"ret\" variable is used to store the return value of the ADC driver functions.\n\t */\n\tret = 0;\n\n\t/*\n\t * The \"data->active_contexts\" lock is used to protect the list of active contexts.\n\t */\n\tk_mutex_lock(&data->active_contexts, K_FOREVER);\n\n\t/*\n\t * The \"ctx_cur\" pointer is used to iterate through the list of active contexts.\n\t */\n\tctx_cur = data->active_contexts;\n\n\t/*\n\t * The \"channel_count\" variable is used to store the number of active channels", "CodeBleu_score": 20.986758752348845}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_context *ctx = &data->ctx;\n\tstruct adc_sequence *sequence = &ctx->sequence;\n\tstruct adc_channel_cfg *channel_cfg = sequence->channel_cfg;\n\tstruct adc_channel_buf *channel_buf = sequence->channel_buf;\n\tstruct adc_channel_cfg *channel_cfg_end = channel_cfg + sequence->channels;\n\tstruct adc_channel_buf *channel_buf_end = channel_buf + sequence->channels;\n\tint ret;\n\n\twhile (true) {\n\t\tret = k_sem_take(&ctx->sem, K_FOREVER);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"Failed to take semaphore\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (channel_cfg = sequence->channel_cfg; channel_cfg < channel_cfg_end; channel_cfg++, channel_buf++) {\n\t\t\tret = adc_read(channel_cfg, channel_buf);\n\t\t\tif (ret!= 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d\", channel_cfg->channel_id);\n\t\t\t\tctx->complete = true;\n\t\t\t}\n\t\t}\n\n\t\tk_sem_give(&ctx->sem);\n\t}\n}", "CodeBleu_score": 37.02270887596146}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint err;\n\tint i;\n\tint j;\n\tint k;\n\tint l;\n\tint m;\n\tint n;\n\tint o;\n\tint p;\n\tint q;\n\tint r;\n\tint s;\n\tint t;\n\tint u;\n\tint v;\n\tint w;\n\tint x;\n\tint y;\n\tint z;\n\tint aa;\n\tint ab;\n\tint ac;\n\tint ad;\n\tint ae;\n\tint af;\n\tint ag;\n\tint ah;\n\tint ai;\n\tint aj;\n\tint ak;\n\tint al;\n\tint am;\n\tint an;\n\tint ao;\n\tint ap;\n\tint aq;\n\tint ar;\n\tint as;\n\tint at;\n\tint au;\n\tint av;\n\tint aw;\n\tint ax;\n\tint ay;\n\tint az;\n\tint ba;\n\tint bb;\n\tint bc;\n\tint bd;\n\tint be;\n\tint bf;\n\tint bg;\n\tint bh;\n\tint bi;\n\tint bj;\n\tint bk;\n\tint bl;\n\tint bm;\n\tint bn;\n\tint bo;\n\tint bp;\n\tint bq;\n\tint br;\n\tint bs;\n\tint bt;\n\tint bu;\n\tint bv;\n\tint bw;\n\tint bx;\n\tint by;\n\tint bz;\n\tint ca;\n\tint cb;\n\tint cc;\n\tint cd;\n\tint ce;\n\tint cf;\n\tint cg;\n\tint ch;\n\tint ci;\n\tint cj;\n\tint ck;\n\tint cl;\n\tint cm;\n\tint cn;\n\tint co;\n\tint cp;\n\tint cq;\n\tint cr;\n\tint cs;\n\tint ct;\n\tint cu;\n\tint cv;\n\tint cw;\n\tint cx;\n\tint cy;\n\tint cz;\n\tint da;\n\tint db;\n\tint dc;\n\tint dd;\n\tint", "CodeBleu_score": 4.458475055311393}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *cfg = dev->config;\n\n\tconst uint8_t ready_time = cfg->ready_time;\n\n\tuint8_t config_reg = 0;\n\n\tint ret;\n\n\tfor (uint8_t i = 0; i < ready_time; i++) {\n\t\tk_sleep(K_MSEC(100));\n\n\t\tret = i2c_reg_read_byte(dev, ADS1112_REG_CONFIG, &config_reg);\n\n\t\tif (ret!= 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (config_reg & ADS1112_CONFIG_RDY) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EIO;\n}", "CodeBleu_score": 44.49635086942361}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tuint8_t config_reg;\n\tint ret = 0;\n\tint err = 0;\n\tconst struct ads1112_config *cfg = dev->config;\n\tk_sleep(K_MSEC(cfg->ready_time_ms));\n\tdo {\n\t\terr = i2c_burst_read(dev, cfg->i2c_addr, ADS1112_REG_CONFIG, &config_reg, 1);\n\t\tif (err!= 0) {\n\t\t\treturn err;\n\t\t}\n\t\tif ((config_reg & ADS1112_CONFIG_DRDY) == 0) {\n\t\t\tk_sleep(K_USEC(100));\n\t\t}\n\t} while ((config_reg & ADS1112_CONFIG_DRDY) == 0);\n\treturn ret;\n}", "CodeBleu_score": 47.31070165312268}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint ret;\n\tuint8_t config;\n\tk_sleep(K_MSEC(ADS1112_DATA_READY_TIME_MS));\n\tret = ads1112_read_register(dev, ADS1112_REG_CONFIG, &config);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\twhile (config & ADS1112_CONFIG_DRDY) {\n\t\tk_sleep(K_USEC(100));\n\t\tret = ads1112_read_register(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 55.65748627359075}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tif (sequence->options & ADC_SEQUENCE_OPTIONS_UPDATE_BUFFER) {\n\t\t/*\n\t\t * If the buffer is updated, the buffer size must be at least as large as the number of samplings.\n\t\t */\n\t\tif (sequence->buffer_size < sequence->buffer_length) {\n\t\t\tLOG_ERR(\"Buffer size (%d) is less than required size (%d) for ADC sequence\", sequence->buffer_size, sequence->buffer_length);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If the buffer is not updated, the buffer size must be at least as large as the number of samplings plus the number of extra samplings.\n\t\t */\n\t\tif (sequence->buffer_size < sequence->buffer_length + sequence->extra_samplings) {\n\t\t\tLOG_ERR(\"Buffer size (%d) is less than required size (%d) for ADC sequence\", sequence->buffer_size, sequence->buffer_length + sequence->extra_samplings);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.437083851270145}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = 0;\n\tint extra_samplings = 0;\n\tint required_buffer_size = 0;\n\n\tif (sequence->options & ADC_SCAN_END) {\n\t\textra_samplings = 1;\n\t}\n\n\tif (sequence->options & ADC_REPEAT) {\n\t\textra_samplings = sequence->options & ADC_REPEAT_CNT;\n\t}\n\n\trequired_buffer_size = sequence->buffer_size + extra_samplings;\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size (%d) is less than required size (%d)\", sequence->buffer_size, required_buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.5431860484716}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = sequence->options & ADC_SEQUENCE_OPTIONS_BUFFER_SIZE;\n\tint num_samplings = sequence->options & ADC_SEQUENCE_OPTIONS_SAMPLE_COUNT;\n\tint extra_samplings = sequence->options & ADC_SEQUENCE_OPTIONS_EXTRA_SAMPLINGS;\n\tint required_buffer_size = num_samplings + extra_samplings;\n\n\tif (buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size (%d) is less than required size (%d)\", buffer_size, required_buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 35.92175214621222}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *cfg = dev->config;\n\n\tint ret;\n\n\tstruct adc_context *adc_ctx = adc_context_get(dev);\n\n\tif (adc_ctx->state!= ADC_CONTEXT_STATE_UNINITIALIZED) {\n\t\tLOG_ERR(\"ADC context already initialized\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (sequence->options & ADC_SINGLE_ENDED) {\n\t\tLOG_ERR(\"Single ended mode not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_DIFF) {\n\t\tLOG_ERR(\"Differential mode not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels == 0) {\n\t\tLOG_ERR(\"No channels specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > 4) {\n\t\tLOG_ERR(\"Too many channels specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_REF_INTERNAL) {\n\t\tLOG_ERR(\"Internal reference not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_GAIN_MASK) {\n\t\tLOG_ERR(\"Gain not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution < 8 || sequence->resolution > 16) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling < 1 || sequence->oversampling > 16) {\n\t\tLOG_ERR(\"Invalid oversampling\");\n\t\treturn -EINVAL;\n\t}\n\n\tadc_ctx->sequence = sequence;\n\n\tadc_ctx->state = ADC_CONTEXT_STATE_RUNNING;\n\n\tret = ads1112_adc_read_start(dev);\n\n\tif (ret!= 0) {\n\t\tadc_ctx->state = ADC_CONTEXT_STATE_UNINITIALIZED;\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = k_sem_take(&adc_ctx->sem, K_FOREVER);\n\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"Failed to wait for ADC read completion\");\n\t\t\tadc_ctx->state =", "CodeBleu_score": 42.00341557655349}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_adc_context *adc_ctx = dev->data;\n\tstruct ads1112_adc_sequence *seq = sequence->buffer;\n\tint ret;\n\n\tif (adc_ctx->read_ctx.state!= ADS1112_ADC_READ_CONTEXT_STATE_IDLE) {\n\t\treturn -EBUSY;\n\t}\n\n\tif (sequence->options & ADC_SCAN_END) {\n\t\t/*\n\t\t * The sequence is not valid.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tadc_ctx->read_ctx.state = ADS1112_ADC_READ_CONTEXT_STATE_RUNNING;\n\tadc_ctx->read_ctx.sequence = seq;\n\tadc_ctx->read_ctx.wait = wait;\n\tadc_ctx->read_ctx.result = 0;\n\tadc_ctx->read_ctx.result_index = 0;\n\n\tret = ads1112_adc_read_context_start(dev);\n\n\treturn ret;\n}", "CodeBleu_score": 39.55433606984351}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tstruct adc_context *context = &data->context;\n\n\tif (sequence == NULL) {\n\t\tLOG_ERR(\"Invalid sequence\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels_size!= 1) {\n\t\tLOG_ERR(\"Only one channel is supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\tLOG_ERR(\"Invalid buffer\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_ASYNC) {\n\t\tLOG_ERR(\"Async not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_CONTINUOUS) {\n\t\tLOG_ERR(\"Continuous not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution!= 12) {\n\t\tLOG_ERR(\"Only 12-bit resolution is supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling!= 1) {\n\t\tLOG_ERR(\"Only 1x oversampling is supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tcontext->sequence = sequence;\n\n\tif (context->state!= ADS1112_CONTEXT_STATE_IDLE) {\n\t\tLOG_ERR(\"Context is busy\");\n\t\treturn -EBUSY;\n\t}\n\n\tcontext->state = ADS1112_CONTEXT_STATE_READ;\n\n\tif (wait) {\n\t\twhile (context->state!= ADS1112_CONTEXT_STATE_IDLE) {\n\t\t\tk_sleep(K_MSEC(10));\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.74073414503193}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Usage: apply_prop <device>\");\n\t\treturn -1;\n\t}\n\n\tconst struct device *dev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -1;\n\t}\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Usage: apply_prop <device> <property>\");\n\t\treturn -1;\n\t}\n\n\tint prop = atoi(argv[2]);\n\tif (prop < 0 || prop > 2) {\n\t\tshell_error(sh, \"Invalid property\");\n\t\treturn -1;\n\t}\n\n\tint ret = codec_apply_property(dev, prop);\n\tif (ret!= 0) {\n\t\tshell_error(sh, \"Error applying property\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.73594305406625}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Usage: apply_prop <codec_name>\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = codec_apply_properties(dev);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 62.37793716568193}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties to codec device\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.37330257352492}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret = 0;\n\tstruct mpxxdtyy_data *data = dev->data;\n\tstruct mpxxdtyy_config *config = dev->config;\n\n\tLOG_DBG(\"Triggering I2S command for %s\", dev->name);\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_STOPPED) {\n\t\t\tret = i2s_send_command(config->i2s_dev, I2S_CMD_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_STARTED;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Failed to start I2S for %s\", dev->name);\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_DBG(\"I2S already started for %s\", dev->name);\n\t\t}\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_STARTED) {\n\t\t\tret = i2s_send_command(config->i2s_dev, I2S_CMD_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_STOPPED;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Failed to stop I2S for %s\", dev->name);\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_DBG(\"I2S already stopped for %s\", dev->name);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command for %s\", dev->name);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 53.38442147538605}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_i2s_config *config = dev->config;\n\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret;\n\n\tLOG_DBG(\"Triggering I2S command for device %s\", dev->name);\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state!= DMIC_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device not configured\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tret = i2s_start(config->i2s_dev);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"I2S start failed\");\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state!= DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device not active\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tret = i2s_stop(config->i2s_dev);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"I2S stop failed\");\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 57.57262969502608}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *data = dev->data;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tint ret = 0;\n\tuint8_t i2s_cmd;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state!= DMIC_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device not configured\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\ti2s_cmd = I2S_CMD_TX_START;\n\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state!= DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device not active\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\ti2s_cmd = I2S_CMD_TX_STOP;\n\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"Unknown trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2s_send_command(config->i2s, i2s_cmd, K_FOREVER);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"I2S send command failed\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 62.64104887540714}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t command = 0;\n\n\tif (enabled) {\n\t\tcommand |= config->display_on_command;\n\t}\n\telse {\n\t\tcommand &= ~config->display_on_command;\n\t}\n\n\tif (config->cursor_on) {\n\t\tcommand |= config->cursor_on_command;\n\t}\n\telse {\n\t\tcommand &= ~config->cursor_on_command;\n\t}\n\n\tif (config->cursor_blink) {\n\t\tcommand |= config->cursor_blink_command;\n\t}\n\telse {\n\t\tcommand &= ~config->cursor_blink_command;\n\t}\n\n\tif (config->display_shift) {\n\t\tcommand |= config->display_shift_command;\n\t}\n\telse {\n\t\tcommand &= ~config->display_shift_command;\n\t}\n\n\tcommand |= config->display_mode_command;\n\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 0);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 1);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 0);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 1);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 0);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 1);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 0);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 1);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 0);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 1);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 0);\n\tgpio_pin_write(config->gpio_port, config->gpio_pin, 1);\n\tgpio_pin_write(config->gpio_", "CodeBleu_score": 42.363991034483874}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t command = 0x00;\n\n\tif (enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (config->display_mode.cursor_blink) {\n\t\tcommand |= AUXDISPLAY_HD44780_CURSOR_BLINK;\n\t}\n\n\tif (config->display_mode.cursor_visible) {\n\t\tcommand |= AUXDISPLAY_HD44780_CURSOR_VISIBLE;\n\t}\n\n\tif (config->display_mode.cursor_position == AUXDISPLAY_HD44780_CURSOR_POSITION_LEFT) {\n\t\tcommand |= AUXDISPLAY_HD44780_CURSOR_POSITION_LEFT;\n\t}\n\n\tauxdisplay_hd44780_send_command(dev, command);\n}", "CodeBleu_score": 59.95976473122445}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tuint8_t cmd = 0x00;\n\n\tif (enabled) {\n\t\tcmd |= 0x08;\n\t}\n\n\tif (auxdisplay_get_cursor_blink(dev)) {\n\t\tcmd |= 0x01;\n\t}\n\n\tif (auxdisplay_get_cursor_visible(dev)) {\n\t\tcmd |= 0x02;\n\t}\n\n\tauxdisplay_send_command(dev, cmd);\n}", "CodeBleu_score": 25.765709653119433}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\n\tif (config->busy_gpio.port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get_raw(config->busy_gpio.port, config->busy_gpio.pin);\n}", "CodeBleu_score": 75.80197822023234}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = -ENOTSUP;\n\n\tif (config->busy_gpio.port!= NULL) {\n\t\tgpio_pin_t pin = config->busy_gpio.pin;\n\t\tgpio_pin_get_dt(&pin);\n\t\tret = gpio_pin_get_raw(config->busy_gpio.port, pin);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 65.31822472871954}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\tuint32_t pin_status;\n\n\tif (config->busy_gpio.port == NULL) {\n\t\tLOG_ERR(\"The busy GPIO port is not defined.\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_raw(config->busy_gpio.port, config->busy_gpio.pin, &pin_status);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"The busy GPIO pin could not be read.\");\n\t\treturn ret;\n\t}\n\n\treturn pin_status;\n}", "CodeBleu_score": 66.37127698174325}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\n\tuint8_t buffer[2];\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tint result = i2c_write(dev->config->i2c_bus, config->i2c_address, buffer, 2, 0);\n\n\tk_sleep(config->special_command_delay);\n\n\treturn result;\n}", "CodeBleu_score": 62.57387597053469}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\n\tuint8_t buffer[2];\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tint result = i2c_write(config->i2c_dev, config->i2c_addr, buffer, 2);\n\n\tif (result == 0) {\n\t\tk_sleep(K_MSEC(config->special_command_delay));\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 64.17215768016085}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\n\tuint8_t buffer[2];\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tint result = i2c_write(config->i2c_dev, config->i2c_addr, buffer, 2, 0);\n\n\tif (result!= 0) {\n\t\tLOG_ERR(\"I2C write failed\");\n\t}\n\n\tk_busy_wait(config->special_command_delay_us);\n\n\treturn result;\n}", "CodeBleu_score": 60.26507980104622}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\n\tLOG_DBG(\"bbram_emul_read: dev=%p, offset=%zu, size=%zu, data=%p\",\n\t\tdev, offset, size, data);\n\n\t/* Check if the read size is valid */\n\tif (size > config->size) {\n\t\tLOG_ERR(\"Invalid read size: %zu\", size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation does not exceed the memory bounds */\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Read operation exceeds memory bounds: offset=%zu, size=%zu\",\n\t\t\toffset, size);\n\t\treturn -EIO;\n\t}\n\n\t/* Check if the read operation does not involve invalid memory */\n\tif (offset & 0x3) {\n\t\tLOG_ERR(\"Read operation involves invalid memory: offset=%zu\",\n\t\t\toffset);\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data from the device's memory to the provided buffer */\n\tmemcpy(data, config->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 60.99790005030216}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_data *bbram_emul = dev->data;\n\tLOG_DBG(\"bbram_emul_read\");\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > bbram_emul->size) {\n\t\tLOG_ERR(\"read out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\tLOG_ERR(\"data is null\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &bbram_emul->data[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 48.659351960258455}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *drv_data = dev->data;\n\tint ret;\n\n\tLOG_DBG(\"bbram_emul_read: offset = %zu, size = %zu\", offset, size);\n\n\t/* Check if the requested read size is valid. */\n\tif (size == 0 || offset + size > config->size) {\n\t\tLOG_ERR(\"Invalid read size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation does not exceed the memory bounds. */\n\tif (offset + size > drv_data->size) {\n\t\tLOG_ERR(\"Read exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation does not involve invalid memory. */\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Read involves invalid memory\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Copy the data from the specified offset in the device's memory to the provided buffer. */\n\tmemcpy(data, drv_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 67.73148277220665}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *emul_data = (struct bbram_emul_data *) dev->data;\n\tuint8_t *mem = emul_data->mem;\n\tuint8_t *mem_end = mem + emul_data->size;\n\n\tLOG_DBG(\"bbram_emul_write: offset = %zu, size = %zu\", offset, size);\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset >= emul_data->size) {\n\t\tLOG_ERR(\"bbram_emul_write: offset %zu out of bounds\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > emul_data->size) {\n\t\tLOG_ERR(\"bbram_emul_write: write size %zu out of bounds\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (emul_data->state == BBRAM_EMUL_STATE_INVALID) {\n\t\tLOG_ERR(\"bbram_emul_write: device in invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (emul_data->state == BBRAM_EMUL_STATE_WRITE_PROTECTED) {\n\t\tLOG_ERR(\"bbram_emul_write: device in write-protected state\");\n\t\treturn -EPERM;\n\t}\n\n\tif (emul_data->state == BBRAM_EMUL_STATE_ERASE_PROTECTED) {\n\t\tLOG_ERR(\"bbram_emul_write: device in erase-protected state\");\n\t\treturn -EPERM;\n\t}\n\n\tif (emul_data->state == BBRAM_EMUL_STATE_ERASED) {\n\t\tLOG_ERR(\"bbram_emul_write: device in erased state\");\n\t\treturn -EPERM;\n\t}\n\n\tif (emul_data->state == BBRAM_EMUL_STATE_ERASED_AND_WRITE_PROTECTED) {\n\t\tLOG_ERR(\"bbram_emul_write: device in erased-and-write-protected state\");\n\t\treturn -EPERM;\n\t}\n\n\tif (em", "CodeBleu_score": 46.914733969507125}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tLOG_DBG(\"bbram_emul_write: offset=%zu, size=%zu\", offset, size);\n\tif (size > BBRAM_EMUL_SIZE) {\n\t\tLOG_ERR(\"bbram_emul_write: invalid size %zu\", size);\n\t\treturn -EINVAL;\n\t}\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\tLOG_ERR(\"bbram_emul_write: invalid offset %zu\", offset);\n\t\treturn -EINVAL;\n\t}\n\tif (bbram_emul_state!= BBRAM_EMUL_STATE_READY) {\n\t\tLOG_ERR(\"bbram_emul_write: invalid state %d\", bbram_emul_state);\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(bbram_emul_data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 49.271101714905626}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_emul = dev->data;\n\n\tif (size > config->size) {\n\t\tLOG_ERR(\"Write size is too large\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Write size is too large\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_emul->state!= BBRAM_EMUL_STATE_VALID) {\n\t\tLOG_ERR(\"BBRAM is not in a valid state\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_emul->data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 67.54824580313073}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device name\");\n\t\treturn -1;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_bind(*bbram_dev);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"failed to bind to device\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 71.23646802158154}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst struct device *dev;\n\tint ret;\n\n\tif (argc!= 2) {\n\t\tshell_error(sh, \"Wrong number of arguments\");\n\t\treturn -1;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_bind(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Could not bind to device\");\n\t\treturn ret;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 63.85386293962472}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing argument: device\");\n\t\treturn -1;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Could not get device %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 74.17357366269613}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct hci_uart *uart = dev->data;\n\n\t/* Calculate the number of bytes already read. */\n\tuint8_t read_len = uart->hdr_read_len;\n\n\t/* Attempt to read the remaining bytes from the UART FIFO into the header buffer. */\n\tssize_t ret = uart_fifo_read(dev, &uart->hdr[read_len], uart->hdr_len - read_len);\n\n\t/* If the read operation fails, log an error message. */\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Unable to read header data from UART FIFO\");\n\t}\n\n\t/* Otherwise, update the remaining byte count based on the number of bytes successfully read. */\n\telse {\n\t\tuart->hdr_read_len += ret;\n\t}\n}", "CodeBleu_score": 31.812834875158668}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct hci_acl_hdr *hdr = (struct hci_acl_hdr *)dev->config->buffer;\n\n\tuint8_t *buf = (uint8_t *)hdr;\n\n\tsize_t bytes_read = 0;\n\n\tint err = uart_fifo_read(dev, buf + bytes_read, sizeof(*hdr) - bytes_read, &bytes_read);\n\n\tif (err) {\n\t\tLOG_ERR(\"Failed to read header (err %d)\", err);\n\n\t\treturn;\n\t}\n\n\tif (bytes_read < sizeof(*hdr)) {\n\t\tLOG_ERR(\"Failed to read header (read %d)\", bytes_read);\n\n\t\treturn;\n\t}\n\n\thdr->len = sys_le16_to_cpu(hdr->len);\n\n\tLOG_DBG(\"Read header: len %u handle %u\", hdr->len, sys_le16_to_cpu(hdr->handle));\n}", "CodeBleu_score": 42.22971845322353}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_uart_data *data = dev->data;\n\tuint32_t bytes_read;\n\tint err;\n\n\t/*\n\t * Calculate the number of bytes already read.\n\t */\n\tbytes_read = data->bytes_read;\n\n\t/*\n\t * Attempt to read the remaining bytes from the UART FIFO into the header buffer.\n\t */\n\terr = uart_fifo_read(data->uart_dev, data->hdr_buf + bytes_read, data->hdr_len - bytes_read, &bytes_read);\n\n\tif (err) {\n\t\tLOG_ERR(\"Failed to read H4 header: %d\", err);\n\t} else {\n\t\t/*\n\t\t * Update the remaining byte count based on the number of bytes successfully read.\n\t\t */\n\t\tdata->bytes_read += bytes_read;\n\t}\n}", "CodeBleu_score": 49.648566781643034}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read;\n\tint err;\n\n\tbytes_read = 0;\n\n\twhile (len > 0) {\n\t\terr = uart_read(uart, buf, MIN(len, ARRAY_SIZE(buf)));\n\t\tif (err < 0) {\n\t\t\tLOG_ERR(\"UART read failed: %d\", err);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbytes_read += err;\n\t\tlen -= err;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 47.2277784849456}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t tmp[33];\n\tsize_t bytes_read;\n\tsize_t bytes_remaining = len;\n\twhile (bytes_remaining > 0) {\n\t\tbytes_read = uart_fifo_read(uart, tmp, bytes_remaining > 33? 33 : bytes_remaining);\n\t\tif (bytes_read == 0) {\n\t\t\tLOG_ERR(\"UART read failed\");\n\t\t\treturn 0;\n\t\t}\n\t\tbytes_remaining -= bytes_read;\n\t}\n\treturn len;\n}", "CodeBleu_score": 32.35995756025948}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read;\n\n\tbytes_read = uart_fifo_read(uart, buf, len);\n\n\tif (bytes_read!= len) {\n\t\tLOG_ERR(\"Failed to read %u bytes from UART\", len);\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 50.50425998392699}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t highest_hop = 0;\n\tuint8_t observer_hop;\n\tuint8_t observer_priority;\n\tstruct zbus_observer *observer;\n\tfor (observer = chan->observers; observer; observer = observer->next) {\n\t\tif (observer->enabled) {\n\t\t\tobserver_priority = observer->priority;\n\t\t\tobserver_hop = observer_priority >> 4;\n\t\t\tif (observer_hop > highest_hop) {\n\t\t\t\thighest_hop = observer_hop;\n\t\t\t}\n\t\t}\n\t}\n\tchan->highest_observer_hop = highest_hop;\n}", "CodeBleu_score": 27.681329791656072}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tuint8_t highest_priority = 0;\n\tuint8_t priority;\n\n\tif (chan->priority_lock) {\n\t\treturn;\n\t}\n\n\tchan->priority_lock = true;\n\n\tfor (obs = chan->observers; obs!= NULL; obs = obs->next) {\n\t\tpriority = obs->priority;\n\t\tif (obs->enabled && priority > highest_priority) {\n\t\t\thighest_priority = priority;\n\t\t}\n\t}\n\n\tchan->highest_priority = highest_priority;\n\n\tchan->priority_lock = false;\n}", "CodeBleu_score": 26.70498861343936}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tuint8_t highest_hop = 0;\n\n\tzbus_channel_lock(chan);\n\tfor (obs = chan->observers; obs!= NULL; obs = obs->next) {\n\t\tif (obs->priority > highest_hop && obs->enabled) {\n\t\t\thighest_hop = obs->priority;\n\t\t}\n\t}\n\tchan->highest_hop = highest_hop;\n\tzbus_channel_unlock(chan);\n}", "CodeBleu_score": 23.98163111986077}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tLOG_DBG(\"update_all_channels_hop\");\n\tstruct zbus_channel *channel;\n\tstruct zbus_observer *obs_channel;\n\tstruct zbus_observer *obs_channel_next;\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&zbus_channels, channel, obs_channel, obs_channel_next, node) {\n\t\tif (obs_channel == obs) {\n\t\t\tupdate_channel_hop(channel);\n\t\t}\n\t}\n}", "CodeBleu_score": 15.068633012734617}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tfor (int i = 0; i < NUM_CHANNELS; i++) {\n\t\tif (channels[i].observer == obs) {\n\t\t\tupdate_channel_hop(&channels[i]);\n\t\t}\n\t}\n}", "CodeBleu_score": 16.375413929268746}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observer *channel_obs;\n\tstruct zbus_channel *channel;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(zbus_channel_observers); i++) {\n\t\tchannel_obs = &zbus_channel_observers[i];\n\t\tchannel = channel_obs->channel;\n\n\t\tif (channel_obs->obs == obs) {\n\t\t\tupdate_channel_hop(channel);\n\t\t}\n\t}\n}", "CodeBleu_score": 17.386266314494993}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tLOG_DBG(\"zbus_obs_attach_to_thread\");\n\treturn 0;\n}", "CodeBleu_score": 7.9815568916832005}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (IS_ENABLED(CONFIG_ZBUS_DEBUG_ASSERTIONS)) {\n\t\tZBUS_ASSERT_NOT_IN_ISR();\n\t\tZBUS_ASSERT(obs!= NULL);\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_spinlock);\n\tobs->priority = k_thread_priority_get(k_current_get());\n\tzbus_update_channels(obs);\n\tk_spin_unlock(&zbus_spinlock, key);\n\treturn 0;\n}", "CodeBleu_score": 22.934088305488523}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (obs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tif (IS_ENABLED(CONFIG_ZBUS_OBS_THREAD_PRIORITY_LOCKING)) {\n\t\tif (k_is_in_isr()) {\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tk_spinlock_key_t key = k_spin_lock(&zbus_obs_thread_lock);\n\t\tobs->priority = k_sched_get_priority_max(K_SCHED_PRIORITY_THREAD);\n\t\tfor (int i = 0; i < ARRAY_SIZE(obs->channels); i++) {\n\t\t\tif (obs->channels[i]!= NULL) {\n\t\t\t\tzbus_channel_set_priority(obs->channels[i], obs->priority);\n\t\t\t}\n\t\t}\n\t\tk_spin_unlock(&zbus_obs_thread_lock, key);\n\t}\n\treturn 0;\n}", "CodeBleu_score": 45.896499111214645}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tstruct k_sem sem;\n\tint err;\n\n\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_IN_ISR()) {\n\t\ttimeout = ISR_TIMEOUT(timeout);\n\t}\n\n\tk_sem_init(&sem, 0, UINT_MAX);\n\tk_sem_take(&chan->sem, timeout);\n\terr = k_sem_status_get(&chan->sem);\n\n\treturn err;\n}", "CodeBleu_score": 26.769203132220987}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint ret = 0;\n\tk_timeout_t end_time;\n\tstruct zbus_channel_context *context;\n\tstruct k_sem *sem;\n\tstruct k_mutex *mutex;\n\n\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = k_timeout_adjust(timeout, k_cycle_get_32());\n\t}\n\n\tend_time = k_uptime_get() + timeout;\n\tcontext = &chan->context;\n\tsem = &context->sem;\n\tmutex = &context->mutex;\n\n\tk_mutex_lock(mutex, K_FOREVER);\n\n\tif (context->state == ZBUS_CHAN_STATE_WAITING) {\n\t\tcontext->state = ZBUS_CHAN_STATE_NOTIFYING;\n\t\tcontext->end_time = end_time;\n\t\tk_sem_give(sem);\n\t} else {\n\t\tret = -EBUSY;\n\t}\n\n\tk_mutex_unlock(mutex);\n\n\treturn ret;\n}", "CodeBleu_score": 42.31997675497451}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint ret;\n\tk_timeout_t new_timeout;\n\n\tif (!chan) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (k_is_in_isr()) {\n\t\tnew_timeout = k_timeout_adjust(timeout, k_cycle_get_32());\n\t} else {\n\t\tnew_timeout = timeout;\n\t}\n\n\tk_mutex_lock(&chan->lock, new_timeout);\n\tret = zbus_chan_notify_locked(chan);\n\tk_mutex_unlock(&chan->lock);\n\n\treturn ret;\n}", "CodeBleu_score": 29.174220962929265}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t tmpreg;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_IT(Int));\n\n\t/* Get the ETHERNET_DMA_IT register value */\n\ttmpreg = ETH->DMA_IT;\n\n\tif (enable) {\n\t\t/* Enable the selected ETHERNET DMA interrupts */\n\t\ttmpreg |= Int;\n\t} else {\n\t\t/* Disable the selected ETHERNET DMA interrupts */\n\t\ttmpreg &= ~Int;\n\t}\n\n\t/* Set the ETHERNET_DMA_IT register */\n\tETH->DMA_IT = tmpreg;\n}", "CodeBleu_score": 32.484020635196046}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\tassert_param(IS_FUNCTIONAL_STATE(enable));\n\n\tif (enable) {\n\t\t/* Enable the interrupt */\n\t\tETH->IER |= Int;\n\t} else {\n\t\t/* Disable the interrupt */\n\t\tETH->IDR |= Int;\n\t}\n}", "CodeBleu_score": 27.579585874837598}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (enable) {\n\t\tETH->DMAIER |= Int;\n\t} else {\n\t\tETH->DMAIER &= ~Int;\n\t}\n}", "CodeBleu_score": 18.716272014954484}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\tpTxDesc = (ETH_TX_DESC *)ETH_TX_DESC_BASE;\n\tfor (i = 0; i < ETH_TX_DESC_NUM; i++) {\n\t\tif (pTxDesc->Status & ETH_TX_DESC_STATUS_OWN) {\n\t\t\treturn 0;\n\t\t}\n\t\tpTxDesc++;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 32.342593641486076}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pDesc = 0;\n\tuint32_t regVal;\n\tuint32_t regVal2;\n\tuint32_t regVal3;\n\tuint32_t regVal4;\n\tuint32_t regVal5;\n\tuint32_t regVal6;\n\tuint32_t regVal7;\n\tuint32_t regVal8;\n\tuint32_t regVal9;\n\tuint32_t regVal10;\n\tuint32_t regVal11;\n\tuint32_t regVal12;\n\tuint32_t regVal13;\n\tuint32_t regVal14;\n\tuint32_t regVal15;\n\tuint32_t regVal16;\n\tuint32_t regVal17;\n\tuint32_t regVal18;\n\tuint32_t regVal19;\n\tuint32_t regVal20;\n\tuint32_t regVal21;\n\tuint32_t regVal22;\n\tuint32_t regVal23;\n\tuint32_t regVal24;\n\tuint32_t regVal25;\n\tuint32_t regVal26;\n\tuint32_t regVal27;\n\tuint32_t regVal28;\n\tuint32_t regVal29;\n\tuint32_t regVal30;\n\tuint32_t regVal31;\n\tuint32_t regVal32;\n\tuint32_t regVal33;\n\tuint32_t regVal34;\n\tuint32_t regVal35;\n\tuint32_t regVal36;\n\tuint32_t regVal37;\n\tuint32_t regVal38;\n\tuint32_t regVal39;\n\tuint32_t regVal40;\n\tuint32_t regVal41;\n\tuint32_t regVal42;\n\tuint32", "CodeBleu_score": 4.71846876040106}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tunsigned int i;\n\tETH_TX_DESC *pDesc;\n\n\tfor (i = 0; i < ETH_TX_DESC_NUM; i++) {\n\t\tpDesc = &g_pEthTxDesc[i];\n\n\t\tif (pDesc->bInUse == 0) {\n\t\t\tpDesc->bInUse = 1;\n\t\t\treturn pDesc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 24.436808871821377}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tstruct cyp_dac_device *cyp_dac = (struct cyp_dac_device *)device;\n\tCy_CSD_Type *cyp_csd = cyp_dac->cyp_csd;\n\tCy_CSDIDAC_Type *cyp_idac = cyp_dac->cyp_idac;\n\tCy_CSDIDAC_Output_Type cyp_idac_output = (Cy_CSDIDAC_Output_Type)channel;\n\n\tif (cyp_csd == 0 || cyp_idac == 0) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/* Enable the DAC output */\n\tif (Cy_CSDIDAC_OutputEnable(cyp_idac, cyp_idac_output, *value)!= CY_CSDIDAC_STATUS_SUCCESS) {\n\t\treturn RT_ERROR;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 42.80819022556364}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tstruct cyp_adc_device *adc_device = (struct cyp_adc_device *)device;\n\trt_err_t result = RT_EOK;\n\n\tif (device == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (channel >= adc_device->channel_count) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (value == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (adc_device->channel[channel].state == CYP_ADC_STATE_DISABLE) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (Cy_CSD_InitChannel(adc_device->base, channel)!= CY_CSD_SUCCESS) {\n\t\trt_kprintf(\"cyp_adc_convert: failed to initialize channel %d", "CodeBleu_score": 42.96557840193198}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\t/* Check if the device is not null. */\n\tif (device == RT_NULL) {\n\t\trt_kprintf(\"The device is null.\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\t/* Retrieve the corresponding DAC channel. */\n\tstruct cyp_dac_device *cyp_device = (struct cyp_dac_device *)device;\n\tstruct cyp_dac_config *cyp_config = &cyp_device->config;\n\tstruct cyp_dac_data *cyp_data = &cyp_device->data;\n\n\t/* Enable the DAC output. */\n\tif (Cy_CSDIDAC_OutputEnable(cyp_data->base, channel, CY_CSDIDAC_OUTPUT_ENABLE)!= CY_CSDIDAC_STATUS_SUCCESS) {\n\t\trt_kprintf(\"The DAC output failed to enable.\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\t/* Return success. */\n\treturn RT_EOK;\n}", "CodeBleu_score": 43.79011393193104}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tint ret = 0;\n\tif (addr + size > 0x800000) {\n\t\trt_kprintf(\"ifx_flash_read_32k: invalid argument\n\");\n\t\tret = -RT_EINVAL;\n\t} else {\n\t\trt_memcpy(buf, (void *) addr, size);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 21.546632391256036}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif ((addr + size) > 0x80000) {\n\t\trt_kprintf(\"ifx_flash_read_32k: invalid argument\n\");\n\t\treturn -1;\n\t}\n\n\trt_uint32_t i;\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(volatile rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 43.9048310731657}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint8_t *p = buf;\n\n\tif (addr + size > 0x800000) {\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\t*p++ = *(volatile rt_uint8_t *) (addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 40.73054434583258}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\t/*\n\t* The function \"timer_counter_get\" retrieves the current count value of a hardware timer.\nIt first asserts that the provided timer is not null.\nThen, it retrieves the timer object from the timer's user data and reads the current count using the \"cyhal_timer_read\" function.\nFinally, it returns the count value.\n\t*/\n\tcyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n\trt_uint32_t count = cyhal_timer_read(cyhal_timer);\n\treturn count;\n}", "CodeBleu_score": 53.316156760773644}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\trt_uint32_t count = 0;\n\tstruct rt_hwtimer_info *info = (struct rt_hwtimer_info *)timer->parent.user_data;\n\tcyhal_timer_read(info->timer, &count);\n\treturn count;\n}", "CodeBleu_score": 47.857055490745275}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tif (timer == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 32.38185537925092}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\twhile (dfs_mutex_lock(&dfs_mutex, 1)!= EOK);\n}", "CodeBleu_score": 11.468866303919384}, {"code": "void dfs_lock(void){\n\t\twhile (xSemaphoreTake(dfs_mutex, portMAX_DELAY)!= pdTRUE) {\n\t\tassert(false);\n\t}\n}", "CodeBleu_score": 16.457853941365954}, {"code": "void dfs_lock(void){\n\t\tint result;\n\tdo {\n\t\tresult = pthread_mutex_lock(&dfs_mutex);\n\t} while (result!= 0);\n\tassert(result == 0);\n}", "CodeBleu_score": 10.628713891155607}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tfor (i = startfd; i < fdt->fd_size; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tfor (i = 0; i < startfd; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 30.905766481496116}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\n\tfor (i = startfd; i < fdt->size; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (fdt->size >= fdt->maxsize) {\n\t\treturn -1;\n\t}\n\n\tfdt->maxsize *= 2;\n\n\tfdt->fds = realloc(fdt->fds, fdt->maxsize * sizeof(struct dfs_fd *));\n\n\tfor (i = fdt->size; i < fdt->maxsize; i++) {\n\t\tfdt->fds[i] = NULL;\n\t}\n\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 39.33504886542838}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint fd;\n\n\tfor (i = startfd; i < fdt->size; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\tfd = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == fdt->size) {\n\t\tfor (i = 0; i < startfd; i++) {\n\t\t\tif (fdt->fds[i] == NULL) {\n\t\t\t\tfd = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i == fdt->size) {\n\t\t/* expand the fd table */\n\t\tstruct dfs_fdtable *newfdt = kmalloc(sizeof(struct dfs_fdtable) + (fdt->size + DFS_FD_TABLE_EXPAND_SIZE) * sizeof(struct dfs_file *), 0);\n\t\tif (newfdt == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(newfdt, fdt, sizeof(struct dfs_fdtable) + fdt->size * sizeof(struct dfs_file *));\n\t\tkfree(fdt);\n\t\tfdt = newfdt;\n\n\t\tfor (i = fdt->size; i < fdt->size + DFS_FD_TABLE_EXPAND_SIZE; i++) {\n\t\t\tfdt->fds[i] = NULL;\n\t\t}\n\t\tfdt->size += DFS_FD_TABLE_EXPAND_SIZE;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 40.06602403953075}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tconst char *error_str;\n\n\t/*\n\t * Convert the error code to a positive value if it is negative.\n\t */\n\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\t/*\n\t * Iterate through an array of known error strings to find a match for the error code.\n\t */\n\tfor (i = 0; i < sizeof(rt_err_table) / sizeof(rt_err_table[0]); i++) {\n\t\tif (rt_err_table[i].err == error) {\n\t\t\terror_str = rt_err_table[i].err_str;\n\t\t\tgoto __exit;\n\t\t}\n\t}\n\n\t/*\n\t * If no match is found, return \"EUNKNOW\".\n\t */\n\terror_str = \"EUNKNOW\";\n\n__exit:\n\treturn error_str;\n}", "CodeBleu_score": 61.82081339792494}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (int i = 0; i < RT_ERROR_MAX; i++) {\n\t\tif (rt_error_table[i].err == error) {\n\t\t\treturn rt_error_table[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 50.74359375692994}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint32_t err = error;\n\tif (err < 0) {\n\t\terr = -err;\n\t}\n\n\tconst char *err_str = \"EUNKNOW\";\n\tconst char *err_str_array[] = {\n\t\t\"EOK\",\n\t\t\"EPERM\",\n\t\t\"EBUSY\",\n\t\t\"EIO\",\n\t\t\"EINTR\",\n\t\t\"EINVAL\",\n\t\t\"EAGAIN\",\n\t\t\"EFAULT\",\n\t\t\"ENOTSUP\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"EEXIST\",\n\t\t\"EBUSY\",\n\t\t\"", "CodeBleu_score": 9.305670374647717}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\tif (rt_thread_idle_hook_list_num >= RT_THREAD_IDLE_HOOK_LIST_SIZE) {\n\t\tresult = -RT_EFULL;\n\t} else {\n\t\trt_thread_idle_hook_list[rt_thread_idle_hook_list_num] = hook;\n\t\trt_thread_idle_hook_list_num++;\n\t}\n\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 27.847652513358383}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\trt_uint32_t i;\n\trt_thread_t thread;\n\n\tif (hook == RT_NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/* get the current thread */\n\tthread = rt_thread_self();\n\n\t/* lock the idle hook list */\n\tlevel = rt_hw_interrupt_disable();\n\t/* check the idle hook list */\n\tfor (i = 0; i < RT_THREAD_IDLE_HOOK_SIZE; i++) {\n\t\tif (thread->idle_hook[i] == RT_NULL) {\n\t\t\tthread->idle_hook[i] = hook;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= RT_THREAD_IDLE_HOOK_SIZE) {\n\t\tresult = -RT_EFULL;\n\t}\n\n\t/* unlock the idle hook list */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 46.070454604884866}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\n\t// Lock the spinlock\n\tlevel = rt_hw_interrupt_disable();\n\n\t// Iterate through the idle hook list\n\tfor (int i = 0; i < RT_THREAD_IDLE_HOOK_SIZE; i++) {\n\t\t// If an empty slot is found\n\t\tif (rt_thread_idle_hook_list[i] == RT_NULL) {\n\t\t\t// Assign the hook to that slot\n\t\t\trt_thread_idle_hook_list[i] = hook;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If no empty slot is available\n\tif (result!= RT_EOK) {\n\t\tresult = -RT_EFULL;\n\t}\n\n\t// Release the spinlock\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 56.977789285130555}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\trt_list_t *list;\n\trt_thread_idle_hook_t *hook_entry;\n\n\t/* lock the spinlock to ensure thread safety */\n\tlevel = rt_hw_interrupt_disable();\n\t/* iterate through the idle hook list to find the specified hook */\n\tlist = rt_thread_idle_hook_list;\n\twhile (list!= RT_NULL) {\n\t\thook_entry = rt_list_entry(list, rt_thread_idle_hook_t, list);\n\t\tif (hook_entry->hook == hook) {\n\t\t\t/* set the corresponding entry to null */\n\t\t\thook_entry->hook = RT_NULL;\n\t\t\t/* unlock the spinlock and return a success code */\n\t\t\trt_hw_interrupt_enable(level);\n\t\t\treturn result;\n\t\t}\n\t\tlist = list->next;\n\t}\n\t/* unlock the spinlock and return an error code indicating that the operation is not supported */\n\trt_hw_interrupt_enable(level);\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 37.94276495081732}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_list_t *list;\n\trt_list_t *list_node;\n\trt_thread_idle_hook_t *idle_hook;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\tlist = &rt_thread_idle_hook_list;\n\tlist_node = list->next;\n\twhile (list_node!= list) {\n\t\tidle_hook = rt_list_entry(list_node, rt_thread_idle_hook_t, list);\n\t\tif (idle_hook->hook == hook) {\n\t\t\trt_list_remove(&idle_hook->list);\n\t\t\trt_hw_interrupt_enable(level);\n\t\t\treturn RT_EOK;\n\t\t}\n\t\tlist_node = list_node->next;\n\t}\n\trt_hw_interrupt_enable(level);\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 37.61180717398317}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result;\n\n\t/*\n\t * The function \"rt_spin_lock\" locks the spinlock, which ensures that only one thread can execute the critical section at a time.\nThe lock is used to ensure thread safety.\n\t */\n\trt_spin_lock(&rt_thread_self()->spinlock, level);\n\n\t/*\n\t * The function \"rt_list_find\" searches the list for the specified item.\nIt iterates through the list, comparing each item with the specified item.\nIf the item is found, the function returns a pointer to the item.\nIf the item is not found, the function returns a null pointer.\n\t */\n\tif (rt_list_find(&rt_thread_self()->thread_idle_hook, hook)!= RT_NULL) {\n\t\t/*\n\t\t * The function \"rt_list_remove\" removes an item from the list.\nIt takes the list and the item to be removed as arguments.\nIt removes the item from the list and returns a success code.\nIf the item is not found in the list, it returns an error code indicating that the operation is not supported.\n\t\t */\n\t\tresult = rt_list_remove(&rt_thread_self()->thread_idle_hook, hook);\n\t}\n\telse {\n\t\tresult = -RT_ERROR;\n\t}\n\n\t/*\n\t * The function \"rt_spin_unlock\" unlocks the spinlock, which allows other threads to access the critical section.\nThe lock is used to ensure thread safety.\n\t */\n\trt_spin_unlock(&rt_thread_self()->spinlock, level);\n\n\treturn result;\n}", "CodeBleu_score": 24.61382760916928}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_list_t *node;\n\trt_thread_t *thread;\n\n\t/* suspend all thread */\n\trt_sched_lock();\n\n\t/* resume all thread */\n\twhile (susp_list->next!= susp_list) {\n\t\tnode = susp_list->next;\n\t\tthread = rt_list_entry(node, rt_thread_t, tlist);\n\t\trt_list_remove(node);\n\t\trt_thread_resume(thread);\n\t\tthread->error = thread_error;\n\t}\n\n\trt_sched_unlock();\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.33333546670759}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_list_t *node;\n\trt_list_t *next;\n\trt_thread_t *thread;\n\trt_base_t level;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* resume all thread from susp_list */\n\trt_list_for_each_entry_safe(node, next, susp_list, tlist) {\n\t\tthread = rt_list_entry(node, rt_thread_t, tlist);\n\t\trt_list_del(node);\n\t\tthread->error = thread_error;\n\t\trt_thread_resume(thread);\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 39.50043600544078}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t *thread;\n\trt_base_t level;\n\trt_list_t *list;\n\trt_list_t *next;\n\trt_list_t *prev;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* resume all threads in the suspension list */\n\tlist = susp_list;\n\twhile (list!= RT_NULL) {\n\t\tnext = list->next;\n\t\tprev = list->prev;\n\n\t\t/* get the thread */\n\t\tthread = rt_list_entry(list, rt_thread_t, tlist);\n\n\t\t/* remove from the suspension list */\n\t\trt_list_remove(list);\n\n\t\t/* resume the thread */\n\t\trt_thread_resume(thread);\n\n\t\t/* set the error code */\n\t\tthread->error = thread_error;\n\n\t\t/* set the suspend count */\n\t\tthread->suspend_count--;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* set the suspend list */\n\t\tthread->suspend_list = RT_NULL", "CodeBleu_score": 32.050964158823426}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = RT_NULL;\n\trt_device_t new_console = RT_NULL;\n\n\t/* get the old console device */\n\told_console = rt_console_get_device();\n\n\t/* find the new console device */\n\tnew_console = rt_device_find(name);\n\n\t/* check if the new console device is valid */\n\tif (new_console!= RT_NULL) {\n\t\t/* check if the new console device is the same as the old console device */\n\t\tif (new_console!= old_console) {\n\t\t\t/* check if the old console device exists */\n\t\t\tif (old_console!= RT_NULL) {\n\t\t\t\t/* close the old console device */\n\t\t\t\trt_device_close(old_console);\n\t\t\t}\n\n\t\t\t/* open the new console device */\n\t\t\trt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t\t}\n\t}\n\n\t/* return the old console device */\n\treturn old_console;\n}", "CodeBleu_score": 45.86993714609287}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = RT_NULL;\n\trt_device_t new_console = RT_NULL;\n\n\t/* find the new console device */\n\tnew_console = rt_device_find(name);\n\tif (new_console!= RT_NULL) {\n\t\t/* check if it is the same as the current console device */\n\t\tif (new_console!= rt_console_get_device()) {\n\t\t\t/* close the current console device */\n\t\t\tif (rt_console_get_device()!= RT_NULL) {\n\t\t\t\trt_device_close(rt_console_get_device());\n\t\t\t}\n\n\t\t\t/* open the new console device */\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\t/* set it as the new console device */\n\t\t\t\told_console = rt_console_set_device(new_console);\n\t\t\t} else {\n\t\t\t\t/* open the new console device failed, so set the old console device as the new console device */\n\t\t\t\told_console = new_console;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the new console device is the same as the current console device */\n\t\t\told_console = new_console;\n\t\t}\n\t} else {\n\t\t/* the new console device is not found */\n\t\told_console = new_console;\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 51.5136430767573}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = RT_NULL;\n\trt_device_t new_console = RT_NULL;\n\n\tRT_ASSERT(name!= RT_NULL);\n\n\told_console = rt_console_get_device();\n\tif (old_console!= RT_NULL) {\n\t\trt_device_close(old_console);\n\t}\n\n\tnew_console = rt_device_find(name);\n\tif (new_console!= RT_NULL) {\n\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\trt_console_set_device(new_console);\n\t\t}\n\t\telse {\n\t\t\trt_device_close(new_console);\n\t\t\tnew_console = RT_NULL;\n\t\t}\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 56.15678411551854}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_base_t level;\n\trt_list_t *list;\n\tstruct rt_object *object;\n\tint count = 0;\n\n\tRT_ASSERT(type >= RT_Object_Class_Unknown && type < RT_Object_Class_End);\n\n\t/* get the list of object */\n\tlist = &rt_object_list[type];\n\n\t/* lock the spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* iterate through the list, counting the number of objects */\n\trt_list_for_each_entry(object, list, list) {\n\t\tcount++;\n\t}\n\n\t/* release the spinlock */\n\trt_hw_interrupt_enable(level);\n\n\t/* return the count */\n\treturn count;\n}", "CodeBleu_score": 30.08619219506946}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_base_t level;\n\trt_list_t *list;\n\trt_list_t *node;\n\trt_list_t *next;\n\trt_object_t *object;\n\tint count = 0;\n\n\t/* Get the object list */\n\tlist = &__object_list[type];\n\n\t/* Lock the spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* Iterate through the list */\n\trt_list_foreach_entry_safe(node, next, list, rt_list_t) {\n\t\tobject = rt_list_entry(node, struct rt_object, list);\n\t\tcount++;\n\t}\n\n\t/* Unlock the spinlock */\n\trt_hw_interrupt_enable(level);\n\n\treturn count;\n}", "CodeBleu_score": 39.721580128804746}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_list_t *object_list;\n\trt_base_t level;\n\trt_list_t *list;\n\trt_list_t *node;\n\trt_object_t *object;\n\tint count = 0;\n\n\t/* Get the object list of the specified type. */\n\tobject_list = rt_object_get_list(type);\n\n\t/* Lock the spinlock to ensure thread safety. */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* Iterate through the object list, counting the number of objects. */\n\tlist = object_list;\n\tnode = list->next;\n\twhile (node!= list) {\n\t\tobject = rt_list_entry(node, rt_object_t, list);\n\t\tnode = node->next;\n\n\t\tcount++;\n\t}\n\n\t/* Release the spinlock and return the count. */\n\trt_hw_interrupt_enable(level);\n\n\treturn count;\n}", "CodeBleu_score": 36.941849647377836}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\n\t/* call object's detach function */\n\tif (object->type & RT_Object_Class_Type_Hook) {\n\t\tif (object->type & RT_Object_Class_Type_Static) {\n\t\t\tobject->type &= ~RT_Object_Class_Type_Static;\n\t\t\tobject->type |= RT_Object_Class_Type_Dynamic;\n\t\t} else {\n\t\t\tobject->type &= ~RT_Object_Class_Type_Dynamic;\n\t\t\tobject->type |= RT_Object_Class_Type_Static;\n\t\t}\n\t}\n\n\t/* remove object from the object list */\n\trt_list_remove(&object->list);\n\n\t/* unlock the spinlock */\n\trt_spinlock_release(&rt_object_list_lock);\n}", "CodeBleu_score": 42.01527880564778}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tstruct rt_object_information *info;\n\n\t/* check object is not null */\n\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* call hook function for detaching */\n\tif (object->type & RT_Object_Class) {\n\t\trt_object_class_detach(object);\n\t}\n\n\t/* get object information */\n\tinfo = object->parent.object.info;\n\n\t/* lock spinlock */\n\trt_spin_lock(&info->spinlock);\n\n\t/* remove object from list */\n\trt_list_remove(&object->parent.object.list);\n\n\t/* unlock spinlock */\n\trt_spin_unlock(&info->spinlock);\n\n\t/* set object type to zero */\n\tobject->type = 0;\n}", "CodeBleu_score": 45.36845272709724}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tif (object!= RT_NULL) {\n\t\t/* detach hook */\n\t\tif (object->type & RT_OBJECT_FLAG_DETACHABLE) {\n\t\t\trt_object_detach_hook(object);\n\t\t}\n\n\t\t/* remove from list */\n\t\trt_list_remove(&object->list);\n\n\t\t/* unlock spinlock */\n\t\trt_spinlock_release(&object->lock);\n\n\t\t/* set object type to zero */\n\t\tobject->type = 0;\n\t}\n}", "CodeBleu_score": 27.574969907286174}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\n\tif (obj!= RT_NULL) {\n\t\trt_custom_object_t custom_object = (rt_custom_object_t)obj;\n\t\tif (custom_object->type == RT_Object_Class_Type_Custom) {\n\t\t\tif (custom_object->destroy!= RT_NULL) {\n\t\t\t\tresult = custom_object->destroy(custom_object);\n\t\t\t}\n\t\t\trt_free(custom_object);\n\t\t} else {\n\t\t\tresult = -RT_ERROR;\n\t\t}\n\t} else {\n\t\tresult = -RT_ERROR;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 43.695840468330374}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\trt_custom_object_t custom_obj = RT_NULL;\n\n\t/* check if the object is valid */\n\tif (obj == RT_NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/* check if the object is a custom object */\n\tif (obj->type!= RT_Object_Class_Type_Custom) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/* get the custom object */\n\tcustom_obj = (rt_custom_object_t)obj;\n\n\t/* check if the object has a destroy method */\n\tif (custom_obj->destroy!= RT_NULL) {\n\t\t/* call the destroy method */\n\t\tresult = custom_obj->destroy(obj);\n\t}\n\n\t/* delete the object */\n\trt_free(obj);\n\n\t/* return the result of the destroy method */\n\treturn result;\n}", "CodeBleu_score": 45.52206441614555}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\t/*\n\t * If the object is not valid, return RT_ERROR.\n\t */\n\tif (obj == RT_NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/*\n\t * If the object is not a custom object, return RT_ERROR.\n\t */\n\tif (RT_OBJECT_CLASS_TYPE(obj)!= RT_Object_Class_Type_Custom) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/*\n\t * If the object has a destroy method, call it and store the return value.\n\t */\n\tif (RT_CUSTOM_OBJECT_CLASS(obj)->destroy!= RT_NULL) {\n\t\trt_err_t err = RT_CUSTOM_OBJECT_CLASS(obj)->destroy(obj);\n\t\tif (err!= RT_EOK) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/*\n\t * Delete the object.\n\t */\n\trt_object_delete(obj);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 38.93005187602729}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\trt_thread_t thread = rt_thread_self();\n\trt_enter_critical();\n\tthread->stat = RT_THREAD_STAT_DEFUNCT;\n\trt_thread_suspend(thread);\n\trt_thread_exit();\n}", "CodeBleu_score": 50.256886178954105}, {"code": "static void _thread_exit(void){\n\t\tstruct rt_thread *thread;\n\n\t/* get the current thread */\n\tthread = rt_thread_self();\n\n\t/* enter critical section */\n\trt_enter_critical();\n\n\t/* remove the thread from the thread list */\n\trt_thread_remove(thread);\n\n\t/* leave critical section */\n\trt_exit_critical();\n\n\t/* trigger a context switch to the next thread */\n\trt_schedule();\n}", "CodeBleu_score": 36.70981909580432}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t thread = rt_thread_self();\n\n\t/* enter critical */\n\trt_enter_critical();\n\n\t/* close the thread */\n\tthread->stat = RT_THREAD_CLOSE;\n\n\t/* add to defunct list */\n\trt_list_insert_before(&thread->tlist, &rt_thread_defunct_list);\n\n\t/* leave critical */\n\trt_exit_critical();\n\n\t/* switch to next thread */\n\trt_schedule();\n}", "CodeBleu_score": 47.02943028784987}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread = (rt_thread_t) parameter;\n\n\tif (thread == RT_NULL)\n\t\treturn;\n\n\trt_sched_lock();\n\n\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\trt_sched_unlock();\n\t\treturn;\n\t}\n\n\tthread->error = -RT_ETIMEOUT;\n\trt_list_remove(&(thread->tlist));\n\trt_list_insert_after(&(rt_thread_ready_list), &(thread->tlist));\n\n\trt_sched_unlock();\n\n\trt_schedule();\n}", "CodeBleu_score": 34.86589947323898}, {"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\trt_base_t level;\n\n\t/* parameter checking */\n\tthread = (struct rt_thread *)parameter;\n\tif (thread == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* verify thread is suspended */\n\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn;\n\t}\n\n\t/* set thread error number */\n\tthread->error = RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* insert thread into ready list */\n\trt_thread_ready(thread);\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\t/* reschedule */\n\trt_schedule();\n}", "CodeBleu_score": 46.99949911059134}, {"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\n\t/* parameter check */\n\tRT_ASSERT(parameter!= RT_NULL);\n\n\t/* get thread from parameter */\n\tthread = (struct rt_thread *)parameter;\n\n\t/* lock scheduler */\n\trt_schedule_lock();\n\n\t/* check thread is suspended */\n\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\trt_schedule_unlock();\n\t\treturn;\n\t}\n\n\t/* set thread error number */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&thread->tlist);\n\n\t/* insert thread to ready list */\n\trt_list_insert_after(&rt_thread_ready_list, &thread->tlist);\n\n\t/* unlock scheduler */\n\trt_schedule_unlock();\n\n\t/* reschedule */\n\trt_schedule();\n}", "CodeBleu_score": 46.61878669096106}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_list_t *list_node;\n\trt_list_t *list_next;\n\trt_mutex_t mutex;\n\trt_list_t *list;\n\trt_list_t *list_prev;\n\trt_list_t *list_end;\n\n\t/* get thread's spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check if the thread is waiting on a mutex */\n\tlist = &thread->wait_list;\n\tlist_node = list->next;\n\twhile (list_node!= list) {\n\t\t/* get the mutex */\n\t\tmutex = (rt_mutex_t) list_node;\n\t\t/* remove the thread from the mutex's waiting list */\n\t\tlist_prev = list_node->prev;\n\t\tlist_next = list_node->next;\n\t\tlist_prev->next = list_next;\n\t\tlist_next->prev = list_prev;\n\t\t/* clear the pending object */\n\t\tmutex->pending = RT_NULL;\n\t\t/* get next mutex */\n\t\tlist_node = list_next;\n\t}\n\n\t/* release all mutexes the thread has taken */\n\tlist = &thread->take_list;\n\tlist_node = list->next;\n\twhile (list_node!= list) {\n\t\t/* get the mutex */\n\t\tmutex = (rt_mutex_t) list_node;\n\t\t/* remove the thread from the mutex's taken list */\n\t\tlist_prev = list_node->prev;\n\t\tlist_next = list_node->next;\n\t\tlist_prev->next = list_next;\n\t\tlist_next->prev = list_prev;\n\t\t/* clear the pending object */\n\t\tmutex->owner = RT_NULL;\n\t\t/* get next mutex */\n\t\tlist_node = list_next;\n\t}\n\n\t/* restore the spinlock state */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 36.74258458527005}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_list_t *node;\n\trt_mutex_t mutex;\n\n\t/* lock the spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check if the thread is waiting on a mutex */\n\tnode = rt_list_entry(thread->to_be_detached, rt_list_t, node);\n\tif (node!= RT_NULL) {\n\t\t/* remove the thread from the mutex's waiting list */\n\t\trt_list_remove(&thread->to_be_detached);\n\n\t\t/* clear the pending object */\n\t\tthread->to_be_detached = RT_NULL;\n\t}\n\n\t/* release all mutexes the thread has taken */\n\twhile (thread->taken_mutexes!= RT_NULL) {\n\t\tmutex = rt_list_entry(thread->taken_mutexes, rt_mutex_t, taken_node);\n\t\trt_list_remove(&thread->taken_mutexes);\n\t\tmutex->owner = RT_NULL;\n\t}\n\n\t/* restore the spinlock state */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 42.26027425419386}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_list_t *list;\n\trt_list_t *n;\n\trt_base_t level;\n\trt_mutex_t *mutex;\n\trt_thread_t t;\n\trt_thread_t *tp;\n\n\t/* lock the thread's spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check if the thread is waiting on a mutex */\n\tlist = &thread->wait_list;\n\tfor (n = list->next; n!= list; n = n->next) {\n\t\tmutex = rt_list_entry(n, rt_mutex_t, thread_list);\n\t\t/* if the thread is waiting on this mutex, remove it from the mutex's waiting list */\n\t\tif (mutex->owner == thread) {\n\t\t\t/* remove the thread from the mutex's waiting list */\n\t\t\trt_list_remove(&mutex->thread_list, &thread->thread_list);\n\t\t\t/* clear the pending object */\n\t\t\tmutex->pending_thread = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* release all mutexes the thread has taken */\n\ttp = &thread->taken_mutex;\n\twhile (*tp) {\n\t\tmutex = *tp;\n\t\t/* remove the mutex from the thread's taken list */\n\t\t*tp = mutex->owner;\n\t\t/* clear the owner */\n\t\tmutex->owner = RT_NULL;\n\t\t/* release the mutex */\n\t\trt_mutex_release(mutex);\n\t}\n\n\t/* restore the spinlock state */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 37.38179856438408}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\trt_base_t level;\n\n\tif (thread == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (thread->init_flag!= RT_THREAD_INITED) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (thread->type!= RT_Thread) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* log thread name and priority */\n\trt_kprintf(\"thread start up: %s, priority = %d\n\", thread->name, thread->current_priority);\n\n\t/* calculate priority attribute */\n\trt_hw_interrupt_disable_irq();\n\tthread->attr.priority_group = (thread->current_priority >> 5);\n\tthread->attr.priority_value = (thread->current_priority & 0x1f);\n\trt_hw_interrupt_enable_irq();\n\n\t/* reset thread state */\n\trt_hw_interrupt_disable_irq();\n\tthread->state = RT_THREAD_SUSPEND;\n\trt_hw_interrupt_enable_irq();\n\n\t/* resume the thread */\n\trt_hw_interrupt_disable_irq();\n\trt_list_remove(&(thread->tlist));\n\trt_list_insert_after(&(thread->parent->thread_list), &(thread->tlist));\n\trt_hw_interrupt_enable_irq();\n\n\t/* trigger scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\trt_schedule();\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 41.307069797684335}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tif (thread == RT_NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\tif (thread->stat!= RT_THREAD_INIT) {\n\t\treturn RT_ERROR;\n\t}\n\n\tif (thread->type!= RT_Thread) {\n\t\treturn RT_ERROR;\n\t}\n\n\trt_kprintf(\"thread %s start up\n\", thread->name);\n\n\t/* calculate priority */\n\trt_uint8_t priority_level = RT_THREAD_PRIORITY_MAX - thread->current_priority;\n\tthread->static_priority = priority_level;\n\tthread->dynamic_priority = priority_level;\n\n\t/* set thread status */\n\trt_hw_interrupt_disable();\n\tthread->stat = RT_THREAD_SUSPEND;\n\trt_hw_interrupt_enable();\n\n\t/* resume the thread */\n\trt_hw_context_switch_to(&thread->sp);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 38.94973602486729}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\trt_err_t result = RT_EOK;\n\n\t/* check thread is not null */\n\tif (thread == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check thread is in the initialization state */\n\tif (thread->stat!= RT_THREAD_INIT) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check thread is of the correct type */\n\tif (thread->type!= RT_Thread) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* log the thread's name and priority */\n\trt_kprintf(\"thread '%s' startup, priority = %d\n\", thread->name, thread->current_priority);\n\n\t/* calculate priority attributes */\n\trt_thread_priority_to_ticks(thread);\n\n\t/* reset thread state */\n\trt_thread_suspend(thread);\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* trigger scheduler if available */\n\trt_schedule();\n\n\treturn result;\n}", "CodeBleu_score": 46.06916416975076}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_timer_t *timer;\n\trt_tick_t tick;\n\n\t/* get the highest level of the timer skip list */\n\tlist = &timer_list[0];\n\n\t/* if the list is empty, return an error */\n\tif (list->next == list) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\t/* get the first timer entry */\n\ttimer = rt_list_entry(list->next, rt_timer_t, timer_list);\n\n\t/* set the timeout tick */\n\ttick = timer->timeout;\n\n\t/* if the timer is periodic, add the period to the timeout tick */\n\tif (timer->flag & RT_TIMER_FLAG_PERIODIC) {\n\t\ttick += timer->period;\n\t}\n\n\t/* set the timeout tick */\n\t*timeout_tick = tick;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 42.29487848412896}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_tick_t timeout_tick_tmp;\n\trt_list_t *timer_list_tmp;\n\trt_list_t *timer_list_head;\n\n\t/* get the highest level of the timer skip list */\n\ttimer_list_tmp = timer_list + RT_TIMER_SKIP_LIST_LEVELS - 1;\n\ttimer_list_head = RT_LIST_GET_HEAD(timer_list_tmp);\n\n\t/* check if the highest level of the timer skip list is not empty */\n\tif (timer_list_head!= timer_list_tmp) {\n\t\t/* get the first timer entry */\n\t\trt_list_t *timer_entry = RT_LIST_GET_NEXT(timer_list_head, node);\n\n\t\t/* get the timeout tick from the timer entry */\n\t\ttimeout_tick_tmp = RT_TIMER_GET_TIMEOUT(timer_entry);\n\n\t\t/* set the provided timeout tick to the timer's timeout value */\n\t\t*timeout_tick = timeout_tick_tmp;\n\n\t\treturn RT_EOK;\n\t}\n\n\t/* return an error code */\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 44.9476582595827}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_list_head;\n\trt_tick_t timeout_tick_tmp;\n\n\ttimer_list_head = &timer_list[0];\n\n\tif (rt_list_isempty(timer_list_head)) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\ttimeout_tick_tmp = ((rt_timer_t *)rt_list_entry(timer_list_head->next, rt_timer_t, timer_list))->timeout;\n\n\tif (timeout_tick_tmp == 0) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\t*timeout_tick = timeout_tick_tmp;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 43.45179163295331}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\tstruct rt_timer *timer;\n\trt_err_t result = RT_EOK;\n\n\t/* check the timer name */\n\tif (name == RT_NULL)\n\t\treturn RT_NULL;\n\n\t/* check the timeout function */\n\tif (timeout == RT_NULL)\n\t\treturn RT_NULL;\n\n\t/* check the timeout time */\n\tif (time > RT_TICK_MAX)\n\t\treturn RT_NULL;\n\n\t/* allocate memory for timer object */\n\ttimer = (struct rt_timer *)rt_malloc(sizeof(struct rt_timer));\n\tif (timer == RT_NULL)\n\t\treturn RT_NULL;\n\n\t/* initialize the timer object */\n\ttimer->parent.flag = flag;\n\ttimer->parent.init_flag = RT_TIMER_INIT_FLAG_ACTIVATED;\n\ttimer->parent.parent.type = RT_Object_Class_Timer;\n\ttimer->parent.parent.name = name;\n\ttimer->parent.parent.flag = RT_OBJECT_FLAG_STATIC;\n\ttimer->parent.parent.user_data = parameter;\n\ttimer->parent.parent.init_flag = RT_OBJECT_INIT_FLAG_ACTIVATED;\n\n\t/* initialize the timer */\n\ttimer->parent.init_flag = RT_TIMER_INIT_FLAG_ACTIVATED;\n\ttimer->parent.time = time;\n\ttimer->parent.timeout = timeout;\n\n\t/* insert the timer to the timer list */\n\trt_list_insert_after(&rt_timer_list, &timer->parent.list);\n\n\treturn (rt_timer_t)timer;\n}", "CodeBleu_score": 47.80996675686037}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* allocate memory for timer */\n\ttimer = (rt_timer_t) rt_malloc(sizeof(struct rt_timer));\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* initialize timer */\n\trt_list_init(&(timer->list));\n\ttimer->flag = flag;\n\ttimer->init_tick = rt_tick_get();\n\ttimer->timeout_tick = time;\n\ttimer->timeout = timeout;\n\ttimer->parameter = parameter;\n\ttimer->parent.flag = RT_TIMER_FLAG_ACTIVATED;\n\ttimer->parent.init_tick = timer->init_tick;\n\ttimer->parent.timeout_tick = timer->timeout_tick;\n\ttimer->parent.timeout = timer->timeout;\n\ttimer->parent.parameter = timer->parameter;\n\ttimer->parent.parent.flag = RT_TIMER_FLAG_ACTIVATED;\n\ttimer->parent.parent.init_tick = timer->init_tick;\n\ttimer->parent.parent.timeout_tick = timer->timeout_tick;\n\ttimer->parent.parent.timeout = timer->timeout;\n\ttimer->parent.parent.parameter = timer->parameter;\n\n\t/* insert timer to timer list */\n\trt_list_insert_after(&(rt_timer_list), &(timer->list));\n\n\treturn timer;\n}", "CodeBleu_score": 45.27292306915346}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* allocate memory for timer object */\n\ttimer = (rt_timer_t) rt_malloc(sizeof(struct rt_timer));\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* initialize timer object */\n\ttimer->next    = RT_NULL;\n\ttimer->timeout = timeout;\n\ttimer->parameter = parameter;\n\ttimer->time    = time;\n\ttimer->flag    = flag;\n\ttimer->init_flag = 0;\n\trt_strncpy(timer->name, name, RT_NAME_MAX);\n\ttimer->name[RT_NAME_MAX] = '\\0';\n\n\treturn timer;\n}", "CodeBleu_score": 53.253950056926755}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tif req.Method == \"OPTIONS\" {\n\t\tres.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t\tres.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n\t\tres.Header().Set(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\")\n\t\tres.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\n\t// check if the request is authorized\n\tif!a.authorize(req) {\n\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\tres.Write([]byte(\"Not Authorized\"))\n\t\treturn\n\t}\n\n\t// serve the request\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 27.862512539987783}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 10.654331898169428}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\ta.logger.Debugf(\"API.ServeHTTP: %s %s\", req.Method, req.URL)\n\n\t// Create a recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\n\t// Run through the middleware\n\tfor _, m := range a.middleware {\n\t\tm.ServeHTTP(recorder, req)\n\n\t\t// If the middleware returned a 401 Unauthorized status, send a Not Authorized error\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\ta.logger.Debugf(\"API.ServeHTTP: %s %s: %s\", req.Method, req.URL, \"Not Authorized\")\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the middleware returned a 404 Not Found status, send a Not Found error\n\t\tif recorder.Code == http.StatusNotFound {\n\t\t\ta.logger.Debugf(\"API.ServeHTTP: %s %s: %s\", req.Method, req.URL, \"Not Found\")\n\t\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// If the router returned a 401 Unauthorized status, send a Not Authorized error\n\tif recorder.Code == http.StatusUnauthorized {\n\t\ta.logger.Debugf(\"API.ServeHTTP: %s %s: %s\", req.Method, req.URL, \"Not Authorized\")\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// If the router returned a 404 Not Found status, send a Not Found error\n\tif recorder.Code == http.StatusNotFound {\n\t\ta.logger.Debugf(\"API.ServeHTTP: %s %s: %s\", req.Method, req.URL, \"Not Found\")\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Copy the recorder's headers to the original response\n\tfor k, v := range recorder.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\n\t// Copy the recorder's body to the original response\n\tres.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 47.31615928123013}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the requested asset path from the URL\n\tpath := req.URL.Path\n\t// Check if the path is empty\n\tif path == \"\" {\n\t\t// If the path is empty, return a 404 error\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Check if the path starts with the static asset path prefix\n\tif!strings.HasPrefix(path, \"/static/\") {\n\t\t// If the path does not start with the static asset path prefix, return a 404 error\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Remove the static asset path prefix from the path\n\tpath = path[len(\"/static/\"):]\n\t// Check if the path is empty\n\tif path == \"\" {\n\t\t// If the path is empty, return a 404 error\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Get the asset content from the static asset map based on the path\n\tasset, ok := a.staticAssets[path]\n\tif!ok {\n\t\t// If the asset is not found, return a 404 error\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Set the Content-Type header based on the file extension of the asset\n\tswitch strings.ToLower(strings.TrimSuffix(path, \".\")) {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\t// Write the asset content to the response\n\t_, err := res.Write(asset)\n\tif err!= nil {\n\t\t// If an error occurs while writing the asset content, log the error and return a 500 error\n\t\tlog.Println(err)\n\t\thttp.Error(res, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 54.46969507349672}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tpath = strings.TrimPrefix(path, \"/\")\n\tpath = strings.TrimSuffix(path, \"/\")\n\tpath = fmt.Sprintf(\"assets/%s\", path)\n\thttp.ServeFile(res, req, path)\n}", "CodeBleu_score": 25.03822733801546}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tpath = strings.TrimPrefix(path, \"/\")\n\tpath = strings.TrimPrefix(path, \"api/\")\n\tpath = strings.TrimPrefix(path, \"robeaux/\")\n\tpath = fmt.Sprintf(\"./robeaux/%s\", path)\n\tlog.Printf(\"robeaux path: %s\", path)\n\tfile, err := a.assets.Open(path)\n\tif err!= nil {\n\t\tlog.Printf(\"robeaux error: %s\", err)\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tdefer file.Close()\n\tstat, err := file.Stat()\n\tif err!= nil {\n\t\tlog.Printf(\"robeaux error: %s\", err)\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", http.DetectContentType(stat.Mode()))\n\thttp.ServeContent(res, req, path, stat.ModTime(), file)\n}", "CodeBleu_score": 38.463188136999385}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\trobotName = strings.TrimSuffix(robotName, \"/connections\")\n\n\t// Find the robot with the specified name\n\trobot := a.master.Robot(robotName)\n\n\t// Check if the robot was found\n\tif robot == nil {\n\t\t// Write an error message if the robot was not found\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"No robot found with name %s\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\t// Get the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// Write an error message if the connections could not be converted to JSON\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\n\t\t\t\"error\": \"Could not convert connections to JSON\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(jsonConnections)\n}", "CodeBleu_score": 39.47098474586879}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := pat.Param(req, \"robotName\")\n\n\t// Find the robot with the specified name\n\trobot, err := a.master.GetRobot(robotName)\n\tif err!= nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\tjson.NewEncoder(res).Encode(robeaux.RobotNotFound{Name: robotName})\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// If the connections cannot be converted to JSON, write a JSON error message\n\t\tjson.NewEncoder(res).Encode(robeaux.JSONConversionError{Error: err.Error()})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Write(jsonConnections)\n}", "CodeBleu_score": 33.30641787199795}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\trobotName := pat.Param(req, \"name\")\n\n\t// Find the robot with the specified name.\n\trobot := a.master.Robot(robotName)\n\n\t// If the robot is found, gather its connections.\n\tif robot!= nil {\n\t\tconnections := robot.Connections()\n\t\t// Convert the connections to JSON format.\n\t\tconnectionsJSON, err := json.Marshal(connections)\n\t\tif err!= nil {\n\t\t\t// If an error occurs, write an error message to the response.\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\tres.Write([]byte(\"Internal Server Error\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Write the JSON response containing the connections.\n\t\tres.WriteHeader(http.StatusOK)\n\t\tres.Write(connectionsJSON)\n\t} else {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"No robot found with name '%s'\", robotName)))\n\t}\n}", "CodeBleu_score": 32.22862136740803}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Extract the \"Authorization\" header from the request.\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\t// If the header is empty, return a \"Not Authorized\" response with a 401 status code.\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t\t// Split the header into username and password.\n\t\tparts := strings.SplitN(authHeader, \" \", 2)\n\t\tif len(parts)!= 2 || parts[0]!= \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t\t// Decode the base64-encoded username and password from the header.\n\t\tdecoded, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t\t// Split the username and password into separate strings.\n\t\tcredentials := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(credentials)!= 2 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t\t// Compare the username and password against the expected values.\n\t\tif subtle.ConstantTimeCompare([]byte(credentials[0]), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(credentials[1]), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t", "CodeBleu_score": 46.13436290503065}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\n\t\t// If the header is empty, return a \"Not Authorized\" response with a 401 status code\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the \"Authorization\" header into \"Basic\" and the base64-encoded username and password\n\t\tauthHeaderParts := strings.Split(authHeader, \" \")\n\t\tif len(authHeaderParts)!= 2 || authHeaderParts[0]!= \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the base64-encoded username and password from the \"Authorization\" header\n\t\tdecodedAuthHeader, err := base64.StdEncoding.DecodeString(authHeaderParts[1])\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the username and password from the decoded \"Authorization\" header\n\t\tusernameAndPassword := strings.Split(string(decodedAuthHeader), \":\")\n\t\tif len(usernameAndPassword)!= 2 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password from the \"Authorization\" header with the provided username and password\n\t\tif subtle.ConstantTimeCompare([]byte(username), []byte(usernameAndPassword[0])) == 1 && subtle.ConstantTimeCompare([]byte(password), []byte(usernameAndPassword[1])) == 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the comparison fails, return a \"Not Authorized\" response with a 401 status code\n\t}\n}", "CodeBleu_score": 45.37029027995765}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Check if the request is using Basic Authentication\n\t\tif!strings.HasPrefix(auth, \"Basic \") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Remove the \"Basic \" prefix from the Authorization header\n\t\ttoken := strings.TrimPrefix(auth, \"Basic \")\n\n\t\t// Decode the base64-encoded username and password from the token\n\t\tdecoded, err := base64.StdEncoding.DecodeString(token)\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the decoded string into username and password\n\t\tparts := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(parts)!= 2 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password against the provided credentials\n\t\tif subtle.ConstantTimeCompare([]byte(parts[0]), []byte(username)) == 1 && subtle.ConstantTimeCompare([]byte(parts[1]), []byte(password)) == 1 {\n\t\t\t// If the credentials match, return a \"Not Found\" response with a 404 status code\n\t\t\thttp.Error(w, \"Not found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\t// If the credentials do not match, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response with a 401 status code\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized", "CodeBleu_score": 46.20610045907875}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.63205197792933}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.980882267028065}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.63205197792933}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.connection == nil {\n\t\treturn -1, -1, fmt.Errorf(\"connection is nil\")\n\t}\n\tif!a.connection.AnalogRead() {\n\t\treturn -1, -1, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\trawValue, err := a.connection.AnalogReadPin(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\tscaledValue := a.scale(rawValue)\n\ta.lastRaw = rawValue\n\ta.lastScaled = scaledValue\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 45.067700135779866}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif a.connection == nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"analogSensorRead: connection is nil\")\n\t}\n\tif a.connection.AnalogRead == nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"analogSensorRead: connection does not support analog reading\")\n\t}\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0.0, err\n\t}\n\tscaledValue := a.scaleValue(rawValue)\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 38.08024524767413}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection not initialized\")\n\t}\n\tif!a.connection.AnalogReadingSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaledValue := a.scale(rawValue)\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 50.442876632548476}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(value int) float64 {\n\t\treturn m*float64(value) + n\n\t}\n}", "CodeBleu_score": 40.602250804276316}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - m*float64(fromMin)\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}", "CodeBleu_score": 51.760163397295614}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(value int) float64 {\n\t\treturn m*float64(value) + n\n\t}\n}", "CodeBleu_score": 40.602250804276316}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(\"GrovePiezoVibrationSensorDriver\")\n\td.AddEvent(VibrationEvent{})\n\terr := d.On(DataEvent{}, func(e interface{}) {\n\t\tdata := e.(DataEvent)\n\t\tif data.Data > 1000 {\n\t\t\td.Publish(VibrationEvent{})\n\t\t}\n\t})\n\tif err!= nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 49.127706519505224}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.Name = \"GrovePiezoVibrationSensorDriver\"\n\td.Events = make(map[string]Event)\n\td.Events[\"vibration\"] = NewEvent(d.Name, \"vibration\")\n\td.Events[\"vibration\"].Attach(func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Events[\"vibration\"].Publish(data)\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 47.871029258160945}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(\"GrovePiezoVibrationSensorDriver\")\n\td.AddEvent(VibrationEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(VibrationOnEvent)\n\td.AddEvent(VibrationOffEvent)\n\td.AddEvent(V", "CodeBleu_score": 31.31611606899785}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn fmt.Errorf(\"Tone: hz must be greater than 0\")\n\t}\n\tif duration <= 0 {\n\t\treturn fmt.Errorf(\"Tone: duration must be greater than 0\")\n\t}\n\n\tperiod := time.Duration(1000000000 / hz)\n\ttempo := time.Duration(60000000 / d.BeatsPerMinute)\n\tdelay := time.Duration(period / 2)\n\n\tfor i := 0; i < int(duration*d.BeatsPerMinute/60); i++ {\n\t\td.digitalWrite(d.Pin, d.High)\n\t\ttime.Sleep(delay)\n\t\td.digitalWrite(d.Pin, d.Low)\n\t\ttime.Sleep(period - delay)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 32.75255535280988}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.buzzer == nil {\n\t\treturn fmt.Errorf(\"BuzzerDriver: Tone: buzzer not initialized\")\n\t}\n\tif hz <= 0 {\n\t\treturn fmt.Errorf(\"BuzzerDriver: Tone: hz must be greater than 0\")\n\t}\n\tif duration <= 0 {\n\t\treturn fmt.Errorf(\"BuzzerDriver: Tone: duration must be greater than 0\")\n\t}\n\n\td.buzzer.Tone(hz, duration)\n\treturn nil\n}", "CodeBleu_score": 19.42821887990009}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz < 0 {\n\t\treturn fmt.Errorf(\"Tone: frequency must be greater than or equal to 0\")\n\t}\n\tif duration < 0 {\n\t\treturn fmt.Errorf(\"Tone: duration must be greater than or equal to 0\")\n\t}\n\n\tif d.tone!= nil {\n\t\treturn fmt.Errorf(\"Tone: tone already in progress\")\n\t}\n\n\tif d.bpm == 0 {\n\t\treturn fmt.Errorf(\"Tone: bpm must be greater than 0\")\n\t}\n\n\td.tone = &tone{\n\t\thz:      hz,\n\t\tbpm:     d.bpm,\n\t\tperiod:  1000 / hz,\n\t\ton:      false,\n\t\tstart:   time.Now(),\n\t\tend:     time.Now().Add(time.Duration(duration) * time.Millisecond),\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 29.480997809064075}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.067607079927328}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.067607079927328}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\td.Stop()\n\td.sleepPin.Write(gobot.Low)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.12166491510242}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins map not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.translateID(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.newAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 52.28040723347102}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params := a.pinPath(id)\n\tpin := a.newAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 39.90258221980202}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pin map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translateAnalogPin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin, err := a.newAnalogPin(path, params)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 50.77016814851545}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.pin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 60.06780044948587}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.63907685129997}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.pin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\terr = pin.DigitalWrite(val)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 65.89039650089444}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.connected {\n\t\treturn nil, fmt.Errorf(\"digital pin %s not found\", id)\n\t}\n\n\tpin, ok := a.pins[id]\n\tif!ok {\n\t\tpin = a.newDigitalPin(id)\n\t\tif err := pin.Initialize(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t}\n\n\tfor _, opt := range opts {\n\t\tif!opt(pin) {\n\t\t\treturn nil, fmt.Errorf(\"digital pin %s not found\", id)\n\t\t}\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 43.06069378727963}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.connected {\n\t\treturn nil, fmt.Errorf(\"digitalPin: adaptor not connected\")\n\t}\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"digitalPin: no pins found\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\tvar (\n\t\terr  error\n\t\tchip int\n\t\tline int\n\t)\n\n\tif chip, line, err = a.translateID(id); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.newDigitalPin(chip, line)\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\tif err = pin.Initialize(); err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 50.70148481387764}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"digital pin '%s' is not connected\", id)\n\t}\n\tfor _, option := range opts {\n\t\toption(a)\n\t}\n\tpin, ok := a.Pins[id]\n\tif!ok {\n\t\tchip, line, err := a.translateDigitalPinID(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin, err = a.newDigitalPin(id, chip, line, opts...)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.Pins[id] = pin\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 52.448987817737724}]}
