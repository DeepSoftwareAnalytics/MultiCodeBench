{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t#ifdef CARLA_PLATFORM_WINDOWS\n  // Windows doesn't have a concept of a \"folder\".\n  return GetRequiredFiles(folder, download, true);\n#else\n  // Linux and macOS have a concept of a \"folder\".\n  return GetRequiredFiles(folder, download, false);\n#endif\n}", "CodeBleu_score": 22.768835158562393}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> required_files;\n\tstd::vector<std::string> files = GetRequiredFiles(folder);\n\tfor (const auto &file : files) {\n\t\tif (download) {\n\t\t\tif (FileExists(file)) {\n\t\t\t\tLogInfo(\"File found in cache: \" + file);\n\t\t\t} else {\n\t\t\t\tLogInfo(\"Downloading file: \" + file);\n\t\t\t\tDownloadFile(file);\n\t\t\t}\n\t\t}\n\t\trequired_files.push_back(file);\n\t}\n\treturn required_files;\n}", "CodeBleu_score": 45.343702306243216}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t#if defined(_WIN32)\n  std::string separator = \"\\\\\";\n#else\n  std::string separator = \"/\";\n#endif\n\n  std::vector<std::string> files;\n  std::string current_file;\n  std::string current_path = folder;\n\n  // Check if the folder exists\n  if (!boost::filesystem::exists(current_path)) {\n    throw std::runtime_error(\"Folder \" + current_path + \" does not exist\");\n  }\n\n  // Check if the folder is a directory\n  if (!boost::filesystem::is_directory(current_path)) {\n    throw std::runtime_error(\"Path \" + current_path + \" is not a directory\");\n  }\n\n  // Get all files in the folder\n  for (boost::filesystem::directory_iterator it(current_path); it!= boost::filesystem::directory_iterator(); ++it) {\n    current_file = it->path().filename().string();\n    if (current_file.find(\".carla\")!= std::string::npos) {\n      files.push_back(current_file);\n    }\n  }\n\n  // Check if the folder is empty\n  if (files.size() == 0) {\n    throw std::runtime_error(\"Folder \" + current_path + \" is empty\");\n  }\n\n  // Check if the download flag is set to true\n  if (download) {\n    // Iterate through all files in the folder\n    for (const auto &file : files) {\n      // Check if the file exists locally\n      if (boost::filesystem::exists(current_path + separator + file)) {\n        // Log that the file is found in the cache\n        log_info(\"File \" + file + \" found in cache\");\n      } else {\n        // Log that the file is not found in the cache\n        log_info(\"File \" + file + \" not found in cache\");\n        // Request the file\n        RequestFile(current_path + separator + file);\n      }\n    }\n  }\n\n  return files;\n}", "CodeBleu_score": 47.986035927336836}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifdef CARLA_CLIENT_WITH_ROS\n  if (description.type == rpc::ActorType::ActorType_Walker) {\n    if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n      if (transform.translation.x == 0.0f && transform.translation.y == 0.0f && transform.translation.z!= 0.0f) {\n        LOG_WARNING(\"Actor with type 'Walker' cannot be spawned with a 'SpringArm' or 'SpringArmGhost' attachment type with a translation in the 'z' axis. The 'z' axis will be ignored.\");\n      }\n    }\n  }\n#endif\n\n  auto &rpc_client = _rpc_client;\n  auto &rpc_streaming_client = _rpc_streaming_client;\n\n  const auto rpc_actor_id = rpc_client.SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n  const auto rpc_actor = rpc_streaming_client.GetActor(rpc_actor_id);\n\n  return rpc_actor;\n}", "CodeBleu_score": 51.90263078774245}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n#if CARLA_CLIENT_USE_ASSERT_CHECKING\n  if (description.type() == rpc::ActorType::INVALID) {\n    throw Exception(\"ActorDescription::type() is invalid.\");\n  }\n  if (description.type() == rpc::ActorType::WALKER_BONE) {\n    if (description.walker_bone_description().bone_name().empty()) {\n      throw Exception(\"WalkerBoneDescription::bone_name() is empty.\");\n    }\n  }\n  if (description.type() == rpc::ActorType::WALKER_CONTROLLER) {\n    if (description.walker_controller_description().control_mode() == rpc::WalkerControlMode::INVALID) {\n      throw Exception(\"WalkerControllerDescription::control_mode() is invalid.\");\n    }\n    if (description.walker_controller_description().control_mode() == rpc::WalkerControlMode::VELOCITY &&\n        description.walker_controller_description().velocity_control().max_speed() < 0.0f) {\n      throw Exception(\"WalkerControllerDescription::velocity_control().max_speed() is negative.\");\n    }\n    if (description.walker_controller_description().control_mode() == rpc::WalkerControlMode::ACCELERATION &&\n        description.walker_controller_description().acceleration_control().max_acceleration() < 0.0f) {\n      throw Exception(\"WalkerControllerDescription::acceleration_control().max_acceleration() is negative.\");\n    }\n    if (description.walker_controller_description().control_mode() == rpc::WalkerControlMode::ACCELERATION &&\n        description.walker_controller_description().acceleration_control().max_acceleration() < 0.0f) {\n      throw Exception(\"WalkerControllerDescription::acceleration_control().max_acceleration() is negative.\");\n    }\n    if (description.walker_controller_description().control_mode() == rpc::WalkerControlMode::ACCELERATION &&\n        description.walker_controller_description().acceleration_control().max_deceleration() < 0.0f) {\n      throw Exception(\"WalkerControllerDescription::acceleration_control().max_deceleration() is negative.\");\n    }\n    if (description.walker_controller_description().control_mode() == rpc::WalkerControlMode::ACCELERATION &&\n        description.walker_controller_description().acceleration_control().max_deceleration() < 0.0f) {\n      throw Exception(\"Walker", "CodeBleu_score": 25.39715088210305}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n#if CARLA_CLIENT_DEBUG_RPC_CALLS\n  std::cout << \"Client::SpawnActorWithParent(\" << description.DebugString() << \", \" << transform.DebugString() << \", \" << parent << \", \" << attachment_type << \", \" << socket_name << \")\" << std::endl;", "CodeBleu_score": 23.10510829980913}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n#if!defined(CARLA_SERVER)\n  if (IsConnected()) {\n    rpc::Response Response;\n    if (rpc::Client::GetGBufferToken(ActorId, GBufferId, Response)) {\n      rpc::GBufferToken Token;\n      if (Response.get_g_buffer_token(Token)) {\n        rpc::GBufferTokenData TokenData;\n        TokenData.set_token(Token.token());\n        rpc::Response Response2;\n        if (rpc::Client::CopyGBufferToken(TokenData, Response2)) {\n          rpc::GBufferToken Token2;\n          if (Response2.get_g_buffer_token(Token2)) {\n            if (streaming::Client::SubscribeToGBuffer(Token2.token(), callback)) {\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n#endif\n\n  throw std::runtime_error(\"Client::SubscribeToGBuffer: Not connected to server!\");\n}", "CodeBleu_score": 39.71567422802461}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t#if CARLA_PLATFORM_WINDOWS\n  throw std::runtime_error(\"This function is not supported on Windows.\");\n#else\n  // Retrieve the token for the G-buffer.\n  rpc::Response response = _client->rpc_GetGBufferToken(ActorId, GBufferId);\n\n  if (response.error) {\n    throw std::runtime_error(response.error);\n  }\n\n  // Copy the token data.\n  auto token_data = response.token_data;\n\n  // Subscribe to the streaming client.\n  _streaming_client->SubscribeToGBuffer(token_data, callback);\n#endif\n}", "CodeBleu_score": 41.975091948169386}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n//   rpc::GBufferToken token;\n//   rpc::Response response;\n//   rpc::GBufferTokenResponse response_token;\n\n//   // Send RPC request\n//   try {\n//     response = _client->GBufferToken(rpc::GBufferTokenRequest{ActorId, GBufferId});\n//   } catch (const rpc::rpc_error &e) {\n//     throw Exception(\"Client::SubscribeToGBuffer(): rpc::GBufferToken() failed\", e);\n//   }\n\n//   // Check for error\n//   if (response.HasError()) {\n//     throw Exception(\"Client::SubscribeToGBuffer(): rpc::GBufferToken() failed\", response.GetError());\n//   }\n\n//   // Copy token data\n//   response_token = response.GetGBufferTokenResponse();\n//   token.token = response_token.token;\n//   token.token_size = response_token.token_size;\n\n//   // Subscribe to streaming client\n//   _streaming_client->SubscribeToGBuffer(token, callback);\n}", "CodeBleu_score": 7.390850490544927}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (WalkerNavigation_ == nullptr) {\n\t\tWalkerNavigation_ = std::make_shared<WalkerNavigation>(Client_);\n\t\tWalkerNavigation_->SetEpisode(this);\n\t}\n\treturn WalkerNavigation_;\n}", "CodeBleu_score": 33.03666988598483}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (m_WalkerNavigation == nullptr) {\n\t\tm_WalkerNavigation = std::make_shared<WalkerNavigation>(m_Client->GetWorld());\n\t}\n\treturn m_WalkerNavigation;\n}", "CodeBleu_score": 29.487207676883255}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (WalkerNavigationPtr == nullptr) {\n\t\tWalkerNavigationPtr = std::make_shared<WalkerNavigation>(ClientPtr->GetWalker(), ClientPtr);\n\t\tWalkerNavigationPtr->SetEpisode(this);\n\t\tWalkerNavigationPtr->SetEpisodeId(EpisodeId);\n\t\tWalkerNavigationPtr->SetTrafficManager(ClientPtr->GetTrafficManager());\n\t}\n\treturn WalkerNavigationPtr;\n}", "CodeBleu_score": 44.594650575579614}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tconst auto &episode_state = episode.GetEpisodeState();\n\tif (episode_state.CurrentFrame >= frame) {\n\t\treturn true;\n\t}\n\tconst auto start = std::chrono::steady_clock::now();\n\twhile (episode_state.CurrentFrame < frame) {\n\t\tconst auto elapsed = std::chrono::steady_clock::now() - start;\n\t\tif (elapsed > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.GetTrafficManager().Tick();\n\treturn true;\n}", "CodeBleu_score": 48.23659488446373}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto &traffic_manager = episode.GetTrafficManager();\n\tauto &episode_state = episode.GetEpisodeState();\n\tauto &episode_state_frame = episode_state.GetFrame();\n\twhile (episode_state_frame < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (episode_state_frame == frame) {\n\t\t\tbreak;\n\t\t}\n\t\tif (episode_state_frame < frame) {\n\t\t\tepisode_state.Tick();\n\t\t\ttraffic_manager.Tick();\n\t\t}\n\t}\n\treturn episode_state_frame == frame;\n}", "CodeBleu_score": 36.064000225683856}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tif (frame < episode.GetCurrentFrame()) {\n\t\treturn false;\n\t}\n\n\t// TODO: Use a proper synchronization mechanism.\n\t//       This is a hack to make sure the traffic manager is ticked.\n\t//       This should be removed when the traffic manager is properly synchronized.\n\t//       See https://github.com/carla-simulator/carla/issues/1626.\n\tif (episode.GetTrafficManager()) {\n\t\tepisode.GetTrafficManager()->Tick();\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 14.263226549610247}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\t// Make sure the simulator is not already running.\n\tif (m_is_running) {\n\t\tthrow std::runtime_error(\"The simulator is already running.\");\n\t}\n\n\t// Make sure the map name is valid.\n\tif (map_name.empty()) {\n\t\tthrow std::runtime_error(\"The map name is empty.\");\n\t}\n\n\t// Make sure the map name is valid.\n\tif (!rpc::MapLayer_IsValid(map_layers)) {\n\t\tthrow std::runtime_error(\"The map layers are invalid.\");\n\t}\n\n\t// Make sure the map name is valid.\n\tif (!rpc::MapLayer_IsKnown(map_layers)) {\n\t\tthrow std::runtime_error(\"The map layers are unknown.\");\n\t}\n\n\t// Make sure the episode ID is not already loaded.\n\tif (m_episode_id!= 0) {\n\t\tthrow std::runtime_error(\"The episode is already loaded.\");\n\t}\n\n\t// Make sure the map name is valid.\n\tif (map_name.empty()) {\n\t\tthrow std::runtime_error(\"The map name is empty.\");\n\t}\n\n\t// Make sure the map name is valid.\n\tif (!rpc::MapLayer_IsValid(map_layers)) {\n\t\tthrow std::runtime_error(\"The map layers are invalid.\");\n\t}\n\n\t// Make sure the map name is valid.\n\tif (!rpc::MapLayer_IsKnown(map_layers)) {\n\t\tthrow std::runtime_error(\"The map layers are unknown.\");\n\t}\n\n\t// Make sure the episode ID is not already loaded.\n\tif (m_episode_id!= 0) {\n\t\tthrow std::runtime_error(\"The episode is already loaded.\");\n\t}\n\n\t// Make sure the map name is valid.\n\tif (map_name.empty()) {\n\t\tthrow std::runtime_error(\"The map name is empty.\");\n\t}\n\n\t// Make sure the map name is valid.\n\tif (!rpc::MapLayer_IsValid(map_layers)) {\n\t\tthrow std::runtime_error(\"The map layers are invalid.\");\n\t}\n\n\t// Make sure the map name is valid.\n\tif (!rpc::MapLayer_IsKnown(map_layers)) {\n\t\tthrow std::runtime_", "CodeBleu_score": 27.080979809873863}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy episode;\n\tEpisodeId episode_id = 0;\n\tEpisodeId previous_episode_id = 0;\n\tint attempts = 0;\n\twhile (episode_id == 0 && attempts < 100) {\n\t\ttry {\n\t\t\tepisode_id = _LoadEpisode(map_name, reset_settings, map_layers);\n\t\t\tif (episode_id!= previous_episode_id) {\n\t\t\t\tprevious_episode_id = episode_id;\n\t\t\t\tattempts = 0;\n\t\t\t}\n\t\t} catch (const TimeoutException &e) {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\t\tattempts++;\n\t\t}\n\t}\n\tif (episode_id == 0) {\n\t\tthrow std::runtime_error(\"Episode could not be loaded\");\n\t}\n\tepisode = EpisodeProxy(this, episode_id);\n\treturn episode;\n}", "CodeBleu_score": 34.347248387342674}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tauto episode_proxy = EpisodeProxy(this);\n\tepisode_proxy.Load(map_name, reset_settings, map_layers);\n\treturn episode_proxy;\n}", "CodeBleu_score": 15.49690066531304}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t#if CARLA_SERVER\n  if (controller.GetWalker() == nullptr) {\n    throw std::runtime_error(\"WalkerAIController::GetWalker() == nullptr\");\n  }\n  if (controller.GetEpisode() == nullptr) {\n    throw std::runtime_error(\"WalkerAIController::GetEpisode() == nullptr\");\n  }\n  if (controller.GetEpisode()->GetEpisodeId() == 0) {\n    throw std::runtime_error(\"WalkerAIController::GetEpisode()->GetEpisodeId() == 0\");\n  }\n  if (controller.GetWalker()->GetWalkerId() == 0) {\n    throw std::runtime_error(\"WalkerAIController::GetWalker()->GetWalkerId() == 0\");\n  }\n  if (controller.GetEpisode()->GetEpisodeId()!= controller.GetWalker()->GetWalkerId()) {\n    throw std::runtime_error(\"WalkerAIController::GetEpisode()->GetEpisodeId()!= WalkerAIController::GetWalker()->GetWalkerId()\");\n  }\n  if (controller.GetWalker()->GetWalkerId()!= controller.GetEpisode()->GetWalkerId()) {\n    throw std::runtime_error(\"WalkerAIController::GetWalker()->GetWalkerId()!= WalkerAIController::GetEpisode()->GetWalkerId()\");\n  }\n  if (controller.GetEpisode()->GetEpisodeId()!= controller.GetWalker()->GetWalkerId()) {\n    throw std::runtime_error(\"WalkerAIController::GetEpisode()->GetEpisodeId()!= WalkerAIController::GetWalker()->GetWalkerId()\");\n  }\n\n  if (controller.GetWalker()->GetWalkerId() == 0) {\n    throw std::runtime_error(\"WalkerAIController::GetWalker()->GetWalkerId() == 0\");\n  }\n\n  if (controller.GetWalker()->GetWalkerId()!= controller.GetEpisode()->GetWalkerId()) {\n    throw std::runtime_error(\"WalkerAIController::GetWalker()->GetWalkerId()!= WalkerAIController::GetEpisode()->GetWalkerId()\");\n  }\n\n  if (controller.GetEpisode()->GetEpisodeId()!= controller.GetWalker()->GetWalkerId()) {\n    throw std::runtime_error(\"WalkerAIController::GetEpisode()->GetEpisodeId()!= WalkerAIController::GetWalker()->GetWalkerId()\");\n  }\n\n  if (controller.GetEpisode()->GetEpisodeId() == 0) {\n    throw std::runtime_error(\"WalkerAIController::GetEpisode", "CodeBleu_score": 31.6172548599574}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t#if CARLA_SERVER_VERSION_MAJOR >= 0 && CARLA_SERVER_VERSION_MINOR >= 99\n  auto walker = _walker_ai_controllers.find(controller.GetID());\n  if (walker == _walker_ai_controllers.end()) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n\n  if (walker->second.episode == nullptr) {\n    walker->second.episode = std::make_shared<Episode>(this, walker->second.walker);\n  }\n\n  walker->second.episode->RegisterAIController(controller);\n#else\n  throw std::runtime_error(\"CARLA Server version is too old\");\n#endif\n}", "CodeBleu_score": 45.57723838513024}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t#if CARLA_SERVER\n  if (controller.GetEpisode() == nullptr) {\n    throw std::runtime_error(\"Episode is null\");\n  }\n  if (controller.GetEpisode()->GetWalker() == nullptr) {\n    throw std::runtime_error(\"Walker is null\");\n  }\n  if (controller.GetEpisode()->GetWalker()->GetNavigation() == nullptr) {\n    controller.GetEpisode()->GetWalker()->SetNavigation(std::make_shared<WalkerNavigation>(controller.GetEpisode()->GetWalker()));\n  }\n  controller.GetEpisode()->GetWalker()->GetNavigation()->RegisterAIController(controller.GetID());\n#endif\n}", "CodeBleu_score": 38.54569795496974}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#if CARLA_CLIENT_DEBUG_MODE\n  if (blueprint.GetID() == 0) {\n    throw Exception(\"Invalid actor blueprint provided.\");\n  }\n#endif\n\n  // Create the actor\n  SharedPtr<Actor> actor(ActorFactory::CreateActor(blueprint, transform, parent, attachment_type, socket_name));\n\n  // Register the actor in the current episode\n  _episode.RegisterActor(actor);\n\n  // Apply garbage collection policy\n  _episode.ApplyGarbageCollectionPolicy(actor, gc);\n\n  // Log the creation details\n  if (parent!= nullptr) {\n    LOG_INFO(\"Created actor '\" << blueprint.GetID() << \"' as child of '\" << parent->GetName() << \"' with attachment type '\" << attachment_type << \"' and socket name '\" << socket_name << \"'.\");\n  } else {\n    LOG_INFO(\"Created actor '\" << blueprint.GetID() << \"' with transform '\" << transform << \"'.\");\n  }\n\n  return actor;\n}", "CodeBleu_score": 42.14019309632558}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#if!defined(CARLA_NO_DEBUG)\n  if (blueprint.GetID() == 0) {\n    throw std::runtime_error(\"Blueprint ID is 0, cannot spawn actor.\");\n  }\n#endif // CARLA_NO_DEBUG\n\n  if (parent!= nullptr) {\n    if (parent->GetID() == 0) {\n      throw std::runtime_error(\"Parent actor ID is 0, cannot spawn actor.\");\n    }\n    if (parent->GetWorld()!= this) {\n      throw std::runtime_error(\"Parent actor is not in this world.\");\n    }\n    if (parent->GetEpisode()!= this->GetEpisode()) {\n      throw std::runtime_error(\"Parent actor is not in the same episode.\");\n    }\n  }\n\n  auto actor = ActorFactory::CreateActor(blueprint, transform, parent, attachment_type, socket_name);\n  if (actor == nullptr) {\n    throw std::runtime_error(\"Actor creation failed.\");\n  }\n\n  if (gc == GarbageCollectionPolicy::Delete) {\n    this->RegisterActor(actor, false);\n  } else {\n    this->RegisterActor(actor, true);\n  }\n\n  return actor;\n}", "CodeBleu_score": 42.090814255210276}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#if!defined(CARLA_SERVER)\n  auto &actor_factory = detail::ActorFactory::Get();\n  return actor_factory.CreateActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n#else\n  throw std::runtime_error(\"This function is not available in the server\");\n#endif\n}", "CodeBleu_score": 26.154803907849296}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#if CARLA_SERVER\n  if (!IsEpisodeValid()) {\n    throw Exception(\"Episode is not valid.\");\n  }\n\n  auto &sensor_data_stream = sensor.GetDataStream();\n  if (sensor_data_stream.IsValid()) {\n    sensor_data_stream.Subscribe(\n        [this, sensor_data_stream, callback](const sensor::SensorData &data) {\n          auto episode = GetEpisode();\n          if (episode) {\n            callback(episode->Deserialize(sensor_data_stream.GetId(), data));\n          } else {\n            throw Exception(\"Episode is not valid.\");\n          }\n        });\n  } else {\n    throw Exception(\"Sensor's data stream is not valid.\");\n  }\n#else\n  throw Exception(\"This function is not available on the client.\");\n#endif\n}", "CodeBleu_score": 37.55074228724108}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n//  CARLA_ASSERT_ZERO(m_episode_id);\n\n  if (m_episode_id == 0) {\n    throw Exception(\"Episode is not valid.\");\n  }\n\n  if (sensor.GetEpisodeId()!= m_episode_id) {\n    throw Exception(\"Sensor is not part of this episode.\");\n  }\n\n  // subscribe to sensor data\n  m_client->SubscribeToStream(sensor.GetStreamId(), callback);\n\n  // associate sensor data with current episode\n  sensor.SetEpisodeId(m_episode_id);\n}", "CodeBleu_score": 33.50107731877296}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n#if!defined(CARLA_SERVER)\n  if (!IsEpisodeValid()) {\n    throw Exception(\"Episode is invalid.\");\n  }\n\n  // subscribe to the sensor's data stream\n  auto stream_id = client->SubscribeToStream(sensor.GetStreamId());\n\n  // set up the callback\n  auto deserialize_callback = [this, callback](const std::uint8_t *data, std::size_t size) {\n    try {\n      auto sensor_data = sensor::Deserializer::Deserialize(data, size);\n      auto episode_id = sensor_data->GetEpisodeId();\n      if (episode_id!= current_episode_id) {\n        throw Exception(\"Episode is invalid.\");\n      }\n      callback(std::move(sensor_data));\n    } catch (const std::exception &e) {\n      throw Exception(e.what());\n    }\n  };\n\n  // set the callback\n  client->SetCallback(stream_id, deserialize_callback);\n#endif\n}", "CodeBleu_score": 47.35457177764283}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// Get the current list of walkers\n\tstd::vector<WalkerControl> walkers = episode->GetWalkerControls();\n\n\t// If there are no walkers, do nothing\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get the current state of the episode\n\tauto state = episode->GetEpisodeState();\n\n\t// Remove walkers that no longer exist\n\tfor (auto it = walkers.begin(); it!= walkers.end();) {\n\t\tif (state->WalkerExists(it->GetWalkerId())) {\n\t\t\t++it;\n\t\t} else {\n\t\t\tit = walkers.erase(it);\n\t\t}\n\t}\n\n\t// Update the crowd and the navigation module\n\tepisode->GetSimulator()->UpdateCrowd(walkers);\n\tepisode->GetNavigation()->Update(walkers);\n\n\t// Apply the walker states to the simulator\n\tfor (auto& walker : walkers) {\n\t\tauto transform = walker.GetTransform();\n\t\tauto speed = walker.GetSpeed();\n\n\t\tepisode->GetSimulator()->ApplyWalkerState(walker.GetWalkerId(), transform, speed);\n\t}\n\n\t// Check if any walker has been killed\n\tfor (auto& walker : walkers) {\n\t\tif (walker.IsDead()) {\n\t\t\tepisode->GetSimulator()->DestroyWalker(walker.GetWalkerId());\n\t\t\tepisode->GetNavigation()->DestroyWalker(walker.GetWalkerId());\n\t\t}\n\t}\n}", "CodeBleu_score": 34.79637821119408}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tif (episode->GetEpisodeState()!= EpisodeState::Running) {\n\t\treturn;\n\t}\n\n\t// Get the current walkers\n\tauto walkers = episode->GetEpisode().GetWalkerData();\n\n\t// If the list is empty, return\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get the current episode state\n\tauto state = episode->GetEpisodeState();\n\n\t// Remove any walkers that no longer exist\n\tfor (auto it = walkers.begin(); it!= walkers.end();) {\n\t\tif (state!= EpisodeState::Running) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the walker id\n\t\tauto walker_id = it->first;\n\n\t\t// Get the walker data\n\t\tauto walker_data = it->second;\n\n\t\t// Check if the walker is still alive\n\t\tif (walker_data.IsAlive()) {\n\t\t\t++it;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Remove the walker from the crowd\n\t\tepisode->GetEpisode().GetCrowd().RemoveAgent(walker_id);\n\n\t\t// Remove the walker from the navigation module\n\t\tepisode->GetEpisode().GetNavigation().RemoveAgent(walker_id);\n\n\t\t// Remove the walker from the walkers list\n\t\twalkers.erase(it++);\n\t}\n\n\t// Update the vehicles in the crowd and the crowd itself in the navigation module\n\tepisode->GetEpisode().GetCrowd().Update();\n\tepisode->GetEpisode().GetNavigation().Update();\n\n\t// Apply the states of the walkers in a batch to the simulator\n\tfor (auto &walker : walkers) {\n\t\tauto walker_id = walker.first;\n\t\tauto walker_data = walker.second;\n\n\t\t// Get the walker transform\n\t\tauto walker_transform = walker_data.GetTransform();\n\n\t\t// Get the walker speed\n\t\tauto walker_speed = walker_data.GetSpeed();\n\n\t\t// Apply the walker state\n\t\tepisode->GetEpisode().ApplyWalkerState(walker_id, walker_transform, walker_speed);\n\t}\n\n\t// Check if any walker has been killed\n\tfor (auto &walker : walkers) {\n\t\tauto walker_", "CodeBleu_score": 37.4051992318454}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// Load the current walkers\n\tconst auto &walkers = episode->GetWalkers();\n\t// Check if the list is empty\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get the current state of the episode\n\tauto state = episode->GetState();\n\t// Remove any walkers that no longer exist\n\tepisode->RemoveWalkers(state);\n\t// Update the vehicles in the crowd and the crowd itself in the navigation module\n\tepisode->GetNavigation()->Update(state);\n\n\t// Iterate over the walkers\n\tfor (auto &walker : walkers) {\n\t\t// Get the transform and speed of the walker\n\t\tconst auto &transform = walker.second->GetTransform();\n\t\tconst auto &speed = walker.second->GetSpeed();\n\t\t// Apply the transform and speed to the simulator\n\t\tepisode->GetSimulator()->ApplyWalkerControl(walker.first, transform, speed);\n\t}\n\n\t// Iterate over the walkers\n\tfor (auto &walker : walkers) {\n\t\t// Get the walker id\n\t\tconst auto &walker_id = walker.first;\n\t\t// Check if the walker has been killed\n\t\tif (walker.second->IsKilled()) {\n\t\t\t// Remove the walker from the crowd\n\t\t\tepisode->GetNavigation()->RemoveWalker(walker_id);\n\t\t\t// Destroy the controller\n\t\t\tepisode->GetSimulator()->DestroyWalkerController(walker_id);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.93356827178669}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_id(Id);\n\tdescription.set_uid(Uid);\n\tdescription.set_type(Type);\n\tdescription.set_role_name(RoleName);\n\tdescription.set_role_id(RoleId);\n\tdescription.set_role_index(RoleIndex);\n\tdescription.set_role_type(RoleType);\n\tdescription.set_role_attributes(RoleAttributes);\n\tdescription.set_role_num_attributes(RoleNumAttributes);\n\tdescription.set_role_num_actors(RoleNumActors);\n\tdescription.set_role_num_vehicles(RoleNumVehicles);\n\tdescription.set_role_num_pedestrians(RoleNumPedestrians);\n\tdescription.set_role_num_static(RoleNumStatic);\n\tdescription.set_role_num_traffic_lights(RoleNumTrafficLights);\n\tdescription.set_role_num_traffic_signs(RoleNumTrafficSigns);\n\tdescription.set_role_num_traffic_signals(RoleNumTrafficSignals);\n\tdescription.set_role_num_traffic_lights_vehicles(RoleNumTrafficLightsVehicles);\n\tdescription.set_role_num_traffic_lights_pedestrians(RoleNumTrafficLightsPedestrians);\n\tdescription.set_role_num_traffic_lights_static(RoleNumTrafficLightsStatic);\n\tdescription.set_role_num_traffic_lights_traffic_signals(RoleNumTrafficLightsTrafficSignals);\n\tdescription.set_role_num_traffic_lights_traffic_lights(RoleNumTrafficLightsTrafficLights);\n\tdescription.set_role_num_traffic_lights_traffic_signs(RoleNumTrafficLightsTrafficSigns);\n\tdescription.set_role_num_traffic_lights_traffic_lights_vehicles(RoleNumTrafficLightsTrafficLightsVehicles);\n\tdescription.set_role_num_traffic_lights_traffic_lights_pedestrians(RoleNumTrafficLightsTrafficLightsPedestrians);\n\tdescription.set_role_num_traffic_lights_traffic_lights_static(RoleNumTrafficLightsTrafficLightsStatic);\n\tdescription.set_role_num_traffic_lights_traffic_lights_traffic_signals(Role", "CodeBleu_score": 31.548350495011878}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription desc;\n\tdesc.set_id(this->ID);\n\tdesc.set_uid(this->UID);\n\tdesc.set_name(this->Name);\n\tdesc.set_type(this->Type);\n\tdesc.set_role_name(this->RoleName);\n\tdesc.set_role_id(this->RoleID);\n\tdesc.set_is_autopilot(this->IsAutopilot);\n\tdesc.set_is_spawn_point(this->IsSpawnPoint);\n\tdesc.set_is_spawn_point_group(this->IsSpawnPointGroup);\n\tdesc.set_is_static(this->IsStatic);\n\tdesc.set_is_walkable(this->IsWalkable);\n\tdesc.set_is_controllable(this->IsControllable);\n\tdesc.set_is_simulated(this->IsSimulated);\n\tdesc.set_is_synchronous_mode_only(this->IsSynchronousModeOnly);\n\tdesc.set_is_synchronous_mode_only_physics(this->IsSynchronousModeOnlyPhysics);\n\tdesc.set_is_synchronous_mode_only_vehicle(this->IsSynchronousModeOnlyVehicle);\n\tdesc.set_is_synchronous_mode_only_walker(this->IsSynchronousModeOnlyWalker);\n\tdesc.set_is_synchronous_mode_only_static(this->IsSynchronousModeOnlyStatic);\n\tdesc.set_is_synchronous_mode_only_sensor(this->IsSynchronousModeOnlySensor);\n\tdesc.set_is_synchronous_mode_only_em(this->IsSynchronousModeOnlyEM);\n\tdesc.set_is_synchronous_mode_only_traffic_light(this->IsSynchronousModeOnlyTrafficLight);\n\tdesc.set_is_synchronous_mode_only_traffic_sign(this->IsSynchronousModeOnlyTrafficSign);\n\tdesc.set_is_synchronous_mode_only_traffic_light_group(this->IsSynchronousModeOnlyTrafficLightGroup);\n\tdesc.set_is_synchronous_mode_only_traffic_sign_group(this->IsSynchronousModeOnlyTrafficSignGroup);\n\tdesc.", "CodeBleu_score": 29.507140915331103}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\n//  rpc::ActorDescription actor_description;\n//  actor_description.set_id(this->GetID());\n//  actor_description.set_uid(this->GetUID());\n//  actor_description.set_type(this->GetType());\n//  actor_description.set_role(this->GetRole());\n//  actor_description.set_spawn_point(this->GetSpawnPoint());\n//  actor_description.set_attributes(this->GetAttributes());\n//\n//  return actor_description;\n\n  rpc::ActorDescription actor_description;\n  actor_description.set_id(this->GetID());\n  actor_description.set_uid(this->GetUID());\n  actor_description.set_type(this->GetType());\n  actor_description.set_role(this->GetRole());\n  actor_description.set_spawn_point(this->GetSpawnPoint());\n  actor_description.set_attributes(this->GetAttributes());\n\n  return actor_description;\n}", "CodeBleu_score": 39.99265907832904}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> filtered_library = SharedPtr<BlueprintLibrary>(new BlueprintLibrary());\n\tfor (auto blueprint : *this) {\n\t\tif (blueprint.HasAttribute(name)) {\n\t\t\tif (blueprint.GetAttribute(name) == value) {\n\t\t\t\tfiltered_library->Add(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn filtered_library;\n}", "CodeBleu_score": 30.732796200734498}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto &blueprint : *this) {\n    if (blueprint.HasAttribute(name)) {\n      if (blueprint.GetAttribute(name) == value) {\n        result->Add(blueprint);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 31.25720573701869}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n//  std::cout << \"FilterByAttribute\" << std::endl;\n\n  std::vector<SharedPtr<Blueprint>> result;\n  result.reserve(m_Blueprints.size());\n\n  for (auto &blueprint : m_Blueprints) {\n    if (blueprint->HasAttribute(name)) {\n      auto attribute = blueprint->GetAttribute(name);\n      if (attribute->GetValue() == value) {\n        result.push_back(blueprint);\n      } else if (attribute->GetRecommendedValues().count(value)) {\n        result.push_back(blueprint);\n      }\n    }\n  }\n\n  return SharedPtr<BlueprintLibrary>(new BlueprintLibrary(result));\n}", "CodeBleu_score": 46.22895992710258}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = path + \"/\" + std::string(CARLA_VERSION) + \"/\" + path;\n\tstd::ofstream file(full_path, std::ios::binary);\n\tif (file.is_open()) {\n\t\tfile.write((char*)content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.41968788657535}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = std::string(path);\n\n\tif (full_path.empty()) {\n\t\treturn false;\n\t}\n\n\t// Construct full path\n\tfull_path = std::string(base_folder) + \"/\" + std::string(CARLA_VERSION_FULL) + \"/\" + full_path;\n\n\t// Validate path\n\tif (!ValidatePath(full_path)) {\n\t\treturn false;\n\t}\n\n\t// Open file in binary mode to truncate its contents\n\tstd::ofstream file(full_path, std::ios::binary);\n\n\t// Write content to file\n\tfile.write((char*)content.data(), content.size());\n\n\t// Close file\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 44.880823752823254}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = GetFullPath(path);\n\tif (!FileExists(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream file(full_path, std::ios::binary);\n\tif (file.is_open()) {\n\t\tfile.write((char*)content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 35.53160638596648}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n//  const auto parent_location = transform.GetLocation();\n//  const auto parent_extent = _parent_sensor->GetBoundingBox().GetExtent();\n//  const auto parent_yaw = transform.GetRotation().GetYaw();\n//\n//  const auto x_min = parent_location.x - parent_extent.x;\n//  const auto x_max = parent_location.x + parent_extent.x;\n//  const auto y_min = parent_location.y - parent_extent.y;\n//  const auto y_max = parent_location.y + parent_extent.y;\n//\n//  const auto x_min_rotated = x_min * std::cos(parent_yaw) - y_min * std::sin(parent_yaw);\n//  const auto x_max_rotated = x_max * std::cos(parent_yaw) - y_max * std::sin(parent_yaw);\n//  const auto y_min_rotated = x_min * std::sin(parent_yaw) + y_min * std::cos(parent_yaw);\n//  const auto y_max_rotated = x_max * std::sin(parent_yaw) + y_max * std::cos(parent_yaw);\n//\n//  const auto x_min_final = parent_location.x + x_min_rotated;\n//  const auto x_max_final = parent_location.x + x_max_rotated;\n//  const auto y_min_final = parent_location.y + y_min_rotated;\n//  const auto y_max_final = parent_location.y + y_max_rotated;\n//\n//  return std::make_shared<Bounds>(frame, {x_min_final, y_min_final}, {x_max_final, y_max_final});\n  return nullptr;\n}", "CodeBleu_score": 6.734853498423796}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n// Create a shared pointer to a Bounds object\n  std::shared_ptr<Bounds> bounds(new Bounds());\n", "CodeBleu_score": 7.230736916618069}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n// Create a new Bounds object and set the frame number to the given frame.\n  std::shared_ptr<const Bounds> bounds = std::make_shared<const Bounds>();\n  bounds->frame = frame;\n\n// Calculate the location of the bounding box by adding the parent's location to the transform's location.\n  bounds->location = transform.location + parent->GetBoundingBox().location;\n\n// Calculate the four corners of the bounding box by rotating the extents based on the yaw angle.\n  bounds->corners[0] = bounds->location - geom::Location(transform.rotation.RotateVector(geom::Vector3D(parent->GetBoundingBox().extent.x, -parent->GetBoundingBox().extent.y, 0.0)));\n  bounds->corners[1] = bounds->location - geom::Location(transform.rotation.RotateVector(geom::Vector3D(-parent->GetBoundingBox().extent.x, -parent->GetBoundingBox().extent.y, 0.0)));\n  bounds->corners[2] = bounds->location - geom::Location(transform.rotation.RotateVector(geom::Vector3D(-parent->GetBoundingBox().extent.x, parent->GetBoundingBox().extent.y, 0.0)));\n  bounds->corners[3] = bounds->location - geom::Location(transform.rotation.RotateVector(geom::Vector3D(parent->GetBoundingBox().extent.x, parent->GetBoundingBox().extent.y, 0.0)));\n\n// Return a shared pointer to the new Bounds object.\n  return bounds;\n}", "CodeBleu_score": 43.12090772741964}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Query the current state of the lights from the server\n\t_lights_state = _simulator->GetWorld()->GetLightsState();\n\n\t// Update the local light states\n\tfor (auto &light_state : _lights_state) {\n\t\tauto &light_id = light_state.first;\n\t\tauto &light_state = light_state.second;\n\n\t\tauto &light = _lights[light_id];\n\t\tlight.SetState(light_state);\n\t}\n\n\t// Create new light objects if they do not already exist in the _lights map\n\tfor (auto &light_state : _lights_state) {\n\t\tauto &light_id = light_state.first;\n\t\tauto &light_state = light_state.second;\n\n\t\tif (_lights.find(light_id) == _lights.end()) {\n\t\t\t_lights[light_id] = Light(light_state);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.20746763092508}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t// Get the light states from the server.\n\tauto light_states = _sim->GetLightStates();\n\t// Update the local light states.\n\tfor (const auto &light_state : light_states) {\n\t\t// Check if the light is already in the map.\n\t\tauto it = _lights.find(light_state.id);\n\t\tif (it == _lights.end()) {\n\t\t\t// The light is not in the map, create a new light object.\n\t\t\t_lights.emplace(light_state.id, Light(light_state));\n\t\t} else {\n\t\t\t// The light is already in the map, update the light object.\n\t\t\tit->second.Update(light_state);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.933455016678728}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto &server_lights = _simulator->GetServer()->GetLightStates();\n\tfor (auto &server_light : server_lights) {\n\t\tauto light_id = server_light.GetId();\n\t\tauto &light = _lights.find(light_id);\n\t\tif (light == _lights.end()) {\n\t\t\tlight = _lights.emplace(light_id, std::make_shared<Light>(server_light)).first;\n\t\t}\n\t\tlight->Update(server_light);\n\t}\n}", "CodeBleu_score": 34.823253486855016}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (dirty_) {\n\t\tif (discard_client) {\n\t\t\tclient_lights_state_.clear();\n\t\t}\n\t\tauto msg = std::make_shared<carla::rpc::LightState>();\n\t\tmsg->set_id(0);\n\t\tmsg->set_state(carla::rpc::LightState::ON);\n\t\tfor (const auto &light : server_lights_state_) {\n\t\t\tmsg->add_light_states()->CopyFrom(light.second);\n\t\t}\n\t\tmsg->set_id(1);\n\t\tmsg->set_state(carla::rpc::LightState::OFF);\n\t\tfor (const auto &light : server_lights_state_) {\n\t\t\tmsg->add_light_states()->CopyFrom(light.second);\n\t\t}\n\t\tmsg->set_id(2);\n\t\tmsg->set_state(carla::rpc::LightState::REAL_TIME);\n\t\tfor (const auto &light : server_lights_state_) {\n\t\t\tmsg->add_light_states()->CopyFrom(light.second);\n\t\t}\n\t\tmsg->set_id(3);\n\t\tmsg->set_state(carla::rpc::LightState::ON_WITH_INTENSITY);\n\t\tfor (const auto &light : server_lights_state_) {\n\t\t\tmsg->add_light_states()->CopyFrom(light.second);\n\t\t}\n\t\tmsg->set_id(4);\n\t\tmsg->set_state(carla::rpc::LightState::OFF_WITH_INTENSITY);\n\t\tfor (const auto &light : server_lights_state_) {\n\t\t\tmsg->add_light_states()->CopyFrom(light.second);\n\t\t}\n\t\tmsg->set_id(5);\n\t\tmsg->set_state(carla::rpc::LightState::REAL_TIME_WITH_INTENSITY);\n\t\tfor (const auto &light : server_lights_state_) {\n\t\t\tmsg->add_light_states()->CopyFrom(light.second);\n\t\t}\n\t\tif (!msg->light_states().empty()) {\n\t\t\tsimulator->GetClient()->Send(msg);\n\t\t}\n\t\tdirty_ = false;\n\t}\n}", "CodeBleu_score": 35.14430015924837}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (discard_client) {\n\t\tfor (auto &light : _lights) {\n\t\t\tlight.second.SetDirty(false);\n\t\t}\n\t} else {\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t\tif (_dirty) {\n\t\t\tauto message = std::make_shared<carla::rpc::LightStateUpdate>();\n\n\t\t\tfor (auto &light : _lights) {\n\t\t\t\tif (light.second.IsDirty()) {\n\t\t\t\t\tauto &light_state = light.second.Get();\n\t\t\t\t\tauto &light_state_update = message->lights.emplace_back();\n\n\t\t\t\t\tlight_state_update.id = light.first;\n\t\t\t\t\tlight_state_update.state = light_state;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_simulator->Send(message);\n\n\t\t\tfor (auto &light : _lights) {\n\t\t\t\tlight.second.SetDirty(false);\n\t\t\t}\n\n\t\t\t_dirty = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.70586486799198}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (discard_client) {\n\t\t// If the client is being discarded, then we need to clear the changes\n\t\t// and set the dirty flag to false.\n\t\tClearChanges();\n\t\t_dirty = false;\n\t\treturn;\n\t}\n\n\t// If there are no changes, then we don't need to update the server.\n\tif (!_dirty) {\n\t\treturn;\n\t}\n\n\t// Lock the mutex to ensure thread safety.\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Create a message containing the updated light states.\n\tauto message = carla::rpc::LightState();\n\tfor (const auto &light : _lights) {\n\t\tif (light.second.GetDirty()) {\n\t\t\tauto &rpc_light = message.lights.emplace_back();\n\t\t\trpc_light.id = light.second.GetId();\n\t\t\trpc_light.state = light.second.GetState();\n\t\t}\n\t}\n\n\t// Send the message to the server.\n\t_simulator->GetClient().Send(message);\n\n\t// Clear the changes and reset the dirty flag.\n\tClearChanges();\n\t_dirty = false;\n}", "CodeBleu_score": 40.96612702266972}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (sensor_id!= \"sensor.other.v2x_custom\") {\n\t\tLOG_WARNING(\"ServerSideSensor::Send: sensor_id is not'sensor.other.v2x_custom', this function is not supported for this sensor_id. Sensor ID: \" + sensor_id);\n\t\treturn;\n\t}\n\n\tauto &simulator = _GetSimulator();\n\tauto &episode = simulator.GetEpisode(episode_id);\n\n\tepisode.Send(sensor_id, message);\n}", "CodeBleu_score": 47.125634743205005}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->Id == \"sensor.other.v2x_custom\") {\n\t\tLOG_DEBUG(\"Sending message to episode\");\n\t\tthis->GetEpisode()->Send(message);\n\t}\n\telse {\n\t\tLOG_WARNING(\"ServerSideSensor::Send: Sensor's ID is not \\\"sensor.other.v2x_custom\\\". This function is only to be used with the custom sensor.\");\n\t}\n}", "CodeBleu_score": 46.98077311884918}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (sensor_id!= \"sensor.other.v2x_custom\") {\n\t\tLOG_WARNING(\"ServerSideSensor::Send: The sensor ID is not \\\"sensor.other.v2x_custom\\\". This function will not send a message to the episode.\");\n\t\treturn;\n\t}\n\n\tauto simulator = _simulator.lock();\n\tif (simulator) {\n\t\tsimulator->Send(message);\n\t} else {\n\t\tLOG_ERROR(\"ServerSideSensor::Send: The simulator is not available.\");\n\t}\n}", "CodeBleu_score": 45.74524395600822}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tif (tm_port == 0) {\n\t\t\tthrow std::runtime_error(\"TM port cannot be 0\");\n\t\t}\n\t\tauto &tm = GetWorld()->GetTrafficManager();\n\t\ttm.RegisterActor(this, tm_port);\n\t} else {\n\t\tauto &tm = GetWorld()->GetTrafficManager();\n\t\ttm.UnregisterActor(this);\n\t}\n}", "CodeBleu_score": 44.734862076126156}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tif (tm_port == 0) {\n\t\t\ttm_port = simulator->GetTrafficManager()->GetAvailablePort();\n\t\t}\n\t\tsimulator->GetTrafficManager()->RegisterVehicle(this, tm_port);\n\t} else {\n\t\tsimulator->GetTrafficManager()->UnregisterVehicle(this);\n\t}\n}", "CodeBleu_score": 44.285286011851746}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tif (tm_port == 0) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be zero.\");\n\t\t}\n\t\tif (tm_port == 255) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 255.\");\n\t\t}\n\t\tif (tm_port == 65535) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 65535.\");\n\t\t}\n\t\tif (tm_port == 65536) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 65536.\");\n\t\t}\n\t\tif (tm_port == 65537) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 65537.\");\n\t\t}\n\t\tif (tm_port == 65538) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 65538.\");\n\t\t}\n\t\tif (tm_port == 65539) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 65539.\");\n\t\t}\n\t\tif (tm_port == 65540) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 65540.\");\n\t\t}\n\t\tif (tm_port == 65541) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 65541.\");\n\t\t}\n\t\tif (tm_port == 65542) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 65542.\");\n\t\t}\n\t\tif (tm_port == 65543) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 65543.\");\n\t\t}\n\t\tif (tm_port == 65544) {\n\t\t\tthrow std::runtime_error(\"TrafficManager port number cannot be 65544.\");\n\t\t}\n\t\tif (tm_port == 65545) {\n\t\t\tthrow std::runtime_error(\"TrafficManager", "CodeBleu_score": 32.39249194177506}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\tauto walker = GetWalker();\n\tif (walker!= nullptr) {\n\t\tauto navigation = GetEpisode()->GetWalkerNavigation();\n\t\tnavigation->AddWalker(walker);\n\t\twalker->SetSimulatePhysics(false);\n\t\twalker->SetNotifyCollisions(false);\n\t}\n}", "CodeBleu_score": 36.22531250688466}, {"code": "void WalkerAIController::Start(){\n\t\tauto &walker = GetWalker();\n\tauto &navigation = GetNavigation();\n\tnavigation.AddWalker(walker);\n\twalker.SetAutopilot(true);\n\twalker.SetSimulatePhysics(false);\n\twalker.SetNotifyCollisions(false);\n}", "CodeBleu_score": 26.78571846009926}, {"code": "void WalkerAIController::Start(){\n\t\tauto &world = GetWorld();\n\tauto &walker = world.GetWalker(GetWalkerId());\n\tauto &nav = world.GetWalkerNavigation();\n\tnav.AddWalker(walker.GetActor(), walker.GetLocation());\n\tworld.SetWalkerPhysics(walker.GetActor(), false);\n\tworld.SetWalkerCollision(walker.GetActor(), false);\n}", "CodeBleu_score": 41.5228332258416}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (episode_id_ == -1) {\n\t\tlog_warning(\"Cannot set maximum speed for a walker that is not in an episode.\");\n\t\treturn;\n\t}\n\n\tauto &navigation = GetEpisode().GetWalkerNavigation();\n\tif (navigation.IsValid()) {\n\t\tauto walker = navigation.GetWalker();\n\t\tif (walker.IsValid()) {\n\t\t\twalker.SetMaxSpeed(max_speed);\n\t\t\treturn;\n\t\t}\n\t\tlog_warning(\"Cannot find walker with ID {} in episode {}.\", walker_id_, episode_id_);\n\t}\n\tlog_warning(\"Cannot set maximum speed for walker {} in episode {} because the episode is not navigable.\", walker_id_, episode_id_);\n}", "CodeBleu_score": 45.6573538024888}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (this->GetEpisode().IsNull()) {\n\t\treturn;\n\t}\n\n\tauto walker_navigation = this->GetEpisode().GetWalkerNavigation();\n\tif (walker_navigation.IsNull()) {\n\t\treturn;\n\t}\n\n\tauto walker = walker_navigation.GetWalker();\n\tif (walker.IsNull()) {\n\t\treturn;\n\t}\n\n\twalker_navigation.SetMaxSpeed(walker, max_speed);\n}", "CodeBleu_score": 39.1814495965615}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (episode_!= nullptr) {\n\t\tif (episode_->GetNavigation()!= nullptr) {\n\t\t\tif (episode_->GetNavigation()->GetWalker()!= nullptr) {\n\t\t\t\tif (!episode_->GetNavigation()->GetWalker()->SetMaxSpeed(max_speed)) {\n\t\t\t\t\tLOG_WARNING(\"Could not set maximum speed for walker\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG_WARNING(\"Could not find walker for episode\");\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_WARNING(\"Could not find navigation for episode\");\n\t\t}\n\t} else {\n\t\tLOG_WARNING(\"Could not find episode\");\n\t}\n}", "CodeBleu_score": 47.77033705740648}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> waypoints;\n\tauto previous_waypoints = map->GetPreviousWaypoints(this->id, distance);\n\tfor (auto &previous_waypoint : previous_waypoints) {\n\t\twaypoints.push_back(SharedPtr<Waypoint>(new Waypoint(previous_waypoint, map)));\n\t}\n\treturn waypoints;\n}", "CodeBleu_score": 47.13657902454514}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tif (distance < 0.0) {\n\t\tthrow std::invalid_argument(\"Distance must be positive.\");\n\t}\n\tauto previous_waypoints = _map->GetPreviousWaypoints(this, distance);\n\tfor (auto waypoint : previous_waypoints) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n\t}\n\treturn result;\n}", "CodeBleu_score": 47.26563025252116}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> previous_waypoints;\n\tauto waypoints = GetMap()->GetPreviousWaypoints(*this, distance);\n\tfor (auto& waypoint : waypoints) {\n\t\tprevious_waypoints.push_back(MakeShared<Waypoint>(waypoint));\n\t}\n\treturn previous_waypoints;\n}", "CodeBleu_score": 45.227409253976134}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\tstd::unordered_set<SharedPtr<Signal>> unique_signals;\n\tstd::vector<SharedPtr<Landmark>> result;\n\tfor (auto signal : signals) {\n\t\tif (unique_signals.find(signal)!= unique_signals.end()) {\n\t\t\tcontinue;\n\t\t}\n\t\tunique_signals.insert(signal);\n\t\tSharedPtr<Waypoint> waypoint = signal->GetWaypoint();\n\t\tif (waypoint!= nullptr) {\n\t\t\tresult.push_back(waypoint->GetLandmark());\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 42.673784897573896}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t//  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  std::vector<SharedPtr<Landmark>> landmarks;\n  std::unordered_set<std::string> signal_names;\n  for (auto &signal : signals) {\n    if (signal_names.find(signal->GetName()) == signal_names.end()) {\n      signal_names.insert(signal->GetName());\n      auto landmark = std::make_shared<Landmark>(signal->GetName(), signal->GetLocation(), signal->GetColor());\n      landmarks.push_back(landmark);\n    }\n  }\n  return landmarks;\n}", "CodeBleu_score": 39.88154725220355}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t//    std::vector<SharedPtr<Landmark>> landmarks;\n//    std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n//    std::unordered_set<std::string> signals_set;\n//    for (const auto &signal : signals) {\n//      if (signals_set.find(signal->GetId()) == signals_set.end()) {\n//        signals_set.insert(signal->GetId());\n//        landmarks.push_back(std::make_shared<Landmark>(signal, *this));\n//      }\n//    }\n//    return landmarks;\n}", "CodeBleu_score": 7.316929978744444}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\t// TODO: Implement this function.\n  return 0;\n}", "CodeBleu_score": 3.2297002042048955}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\n#if CARLA_SERVER_MODE\n\n  if (settings.has_fixed_delta_time()) {\n    const auto fixed_delta_time = time_duration{ settings.fixed_delta_time() };\n\n    if (fixed_delta_time!= GetFixedDeltaTime()) {\n      LogWarning(\"ApplySettings: Fixed delta time was changed to\", fixed_delta_time);\n      SetFixedDeltaTime(fixed_delta_time);\n    }\n  }\n\n  // If the settings include a timeout, use it. Otherwise, use the episode's networking timeout.\n  if (settings.has_timeout()) {\n    timeout = time_duration{ settings.timeout() };\n  }\n\n  // Apply settings.\n  return _simulator->ApplySettings(settings, timeout);\n\n#else\n\n  LogWarning(\"ApplySettings: This function is not available in client mode.\");\n  return 0;\n\n#endif\n\n}", "CodeBleu_score": 28.551305114553006}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\n//  CARLA_LOG_INFO(\"Applying settings\");\n\n  // Apply settings to the world\n  _world->ApplySettings(settings);\n\n  // Get the timeout\n  if (timeout == time_duration::zero()) {\n    timeout = time_duration(settings.timeout());\n  }\n\n  // Apply settings to the simulator\n  _simulator->ApplySettings(settings);\n\n  // Get the settings identifier\n  const uint64_t settings_id = _simulator->GetSettingsId();\n\n  // Get the timeout\n  const time_duration local_timeout = timeout;\n\n  // Get the number of ticks\n  const uint32_t ticks = settings.ticks();\n\n  // Get the fixed delta time\n  const float fixed_delta_time = settings.fixed_delta_time();\n\n  // Get the fixed delta time accuracy\n  const float fixed_delta_time_accuracy = settings.fixed_delta_time_accuracy();\n\n  // Get the fixed delta time accuracy\n  const float fixed_delta_time_accuracy_threshold = settings.fixed_delta_time_accuracy_threshold();\n\n  // Get the fixed delta time accuracy\n  const float fixed_delta_time_accuracy_tolerance = settings.fixed_delta_time_accuracy_tolerance();\n\n  // Get the fixed delta time accuracy\n  const float fixed_delta_time_accuracy_tolerance_threshold = settings.fixed_delta_time_accuracy_tolerance_threshold();\n\n  // Get the fixed delta time accuracy\n  const float fixed_delta_time_accuracy_tolerance_threshold_multiplier = settings.fixed_delta_time_accuracy_tolerance_threshold_multiplier();\n\n  // Get the fixed delta time accuracy\n  const float fixed_delta_time_accuracy_tolerance_threshold_multiplier_threshold = settings.fixed_delta_time_accuracy_tolerance_threshold_multiplier_threshold();\n\n  // Get the fixed delta time accuracy\n  const float fixed_delta_time_accuracy_tolerance_threshold_multiplier_threshold_multiplier = settings.fixed_delta_time_accuracy_tolerance_threshold_multiplier_threshold_multiplier();\n\n  // Get the fixed delta time accuracy\n  const float fixed_delta_time_accuracy_tolerance_threshold_multiplier_threshold_multiplier_threshold = settings.fixed_delta_time_accuracy_tolerance_threshold_multiplier_threshold_multiplier_threshold();\n\n  // Get the fixed delta time accuracy\n  const float fixed_delta_time_accuracy_tolerance_threshold_multiplier_threshold_multiplier_threshold_multiplier", "CodeBleu_score": 36.00615211841899}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst carla::geom::Vector2D &point,\n\tconst carla::geom::Vector2D &segment_start,\n\tconst carla::geom::Vector2D &segment_end\n}", "CodeBleu_score": 11.5869438361079}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst carla::geom::Vector2D &point,\n\tconst carla::geom::Vector2D &segment_start,\n\tconst carla::geom::Vector2D &segment_end\n}", "CodeBleu_score": 11.5869438361079}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst carla::geom::Vector2D &point,\n\tconst carla::geom::Vector2D &segment_start,\n\tconst carla::geom::Vector2D &segment_end\n}", "CodeBleu_score": 11.5869438361079}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tassert(vertices.size() >= 3);\n\n\tconst auto initial_index = AddVertex(vertices[0]);\n\n\tfor (auto it = vertices.begin() + 1; it!= vertices.end() - 1; ++it) {\n\t\tAddTriangle(initial_index, AddVertex(*it), AddVertex(*(it + 1)));\n\t}\n}", "CodeBleu_score": 44.263381443875225}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tassert(vertices.size() >= 3);\n\tconst auto first_vertex_index = static_cast<uint32_t>(vertices.size());\n\tAddVertices(vertices);\n\tfor (size_t i = 2; i < vertices.size(); ++i) {\n\t\tAddTriangle(first_vertex_index, first_vertex_index + i - 1, first_vertex_index + i);\n\t}\n}", "CodeBleu_score": 40.03000985992579}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tassert(vertices.size() >= 3);\n\tconst size_t initial_index = GetVertices().size();\n\tfor (size_t i = 0; i < vertices.size(); ++i) {\n\t\tAddVertex(vertices[i]);\n\t}\n\tfor (size_t i = 1; i < vertices.size() - 1; ++i) {\n\t\tAddTriangle(initial_index, initial_index + i, initial_index + i + 1);\n\t}\n}", "CodeBleu_score": 42.9301415939032}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (message->IsValid()) {\n\t\tboost::asio::post(m_strand, [this, message]() {\n\t\t\tif (m_socket.is_open()) {\n\t\t\t\tm_timeout.expires_from_now(std::chrono::milliseconds(100));\n\t\t\t\tboost::asio::async_write(m_socket, message->GetBuffer(), boost::asio::bind_executor(m_strand, [this, message](const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n\t\t\t\t\thandle_sent(error, message);\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tlog_error(\"Primary::Write - Socket is closed.\");\n\t\t\t}\n\t\t});\n\t} else {\n\t\tlog_error(\"Primary::Write - Message is not valid.\");\n\t}\n}", "CodeBleu_score": 31.5271707298941}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\n#if CARLA_DEBUG_MULTI_GPU_STREAMING\n    carla_debug(\"Primary::Write(%p)\", message.get());\n#endif\n\n    CARLA_ASSERT(message!= nullptr);\n\n    if (message->get_size() > 0) {\n        CARLA_ASSERT_INT2(message->get_size(), <=, CARLA_MULTI_GPU_STREAMING_MAX_MESSAGE_SIZE);\n\n        if (message->get_size() > CARLA_MULTI_GPU_STREAMING_MAX_MESSAGE_SIZE) {\n            carla_stderr(\"Primary::Write(%p) - Message size %u is too big\", message.get(), message->get_size());\n            return;\n        }\n\n        // send message\n        boost::asio::async_write(m_socket, boost::asio::buffer(message->get_data(), message->get_size()),\n                                 boost::asio::bind_executor(m_strand, [this, message](boost::system::error_code ec, std::size_t) {\n                                     if (ec) {\n                                         if (ec == boost::asio::error::eof) {\n                                             carla_stderr(\"Primary::Write(%p) - Connection closed\", message.get());\n                                         } else {\n                                             carla_stderr(\"Primary::Write(%p) - Error sending message: %s\", message.get(), ec.message().c_str());\n                                         }\n\n                                         // close connection\n                                         m_socket.close();\n                                     } else {\n                                         // message sent successfully\n                                         carla_debug(\"Primary::Write(%p) - Message sent\", message.get());\n                                     }\n                                 }));\n    }\n}", "CodeBleu_score": 32.834989900515495}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t#ifdef CARLA_DEBUG_MULTI_GPU_PRIMARY\n    carla_debug(\"Primary::Write(message={%p}) - message->type() = %s\", message.get(), message->type().c_str());\n#endif\n\n    if (!message) {\n        carla_stderr(\"Primary::Write(message={%p}) - message is NULL\", message.get());\n        return;\n    }\n\n    if (!message->IsValid()) {\n        carla_stderr(\"Primary::Write(message={%p}) - message is not valid\", message.get());\n        return;\n    }\n\n    // Post a lambda to the strand\n    m_strand.post([this, message]() {\n        if (!m_socket.is_open()) {\n            carla_stderr(\"Primary::Write(message={%p}) - socket is closed\", message.get());\n            return;\n        }\n\n        // Set a timeout\n        m_socket.expires_from_now(boost::posix_time::seconds(10));\n\n        // Initiate an asynchronous write\n        m_socket.async_write_some(boost::asio::buffer(message->data(), message->size()),\n                                  boost::asio::bind_executor(m_strand, [this, message](const boost::system::error_code& error, std::size_t bytes_transferred) {\n                                      this->HandleSent(error, bytes_transferred, message);\n                                  }));\n    });\n}", "CodeBleu_score": 36.00900183726088}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\n#ifdef CARLA_DEBUG_MULTI_GPU_PRIMARY\n  carla_debug(\"Primary::CloseNow() - called\");\n#endif\n\n  // Cancel the deadline timer.\n  m_deadlineTimer.cancel();\n\n  // If the socket is open, attempt to shut it down and close it.\n  if (m_socket.is_open()) {\n    boost::system::error_code ignored_ec;\n    m_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n    m_socket.close(ignored_ec);\n  }\n\n  // Trigger the on_closed callback.\n  if (m_on_closed)\n    m_on_closed();\n\n  // Log that the session has been closed.\n  carla_debug(\"Primary::CloseNow() - session closed\");\n}", "CodeBleu_score": 54.524542345521674}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer.\n\tm_deadline_timer.cancel();\n\n\t// Shut down the socket if it is still open.\n\tif (m_socket.is_open()) {\n\t\tm_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t}\n\n\t// Close the socket if it is still open.\n\tif (m_socket.is_open()) {\n\t\tm_socket.close(ec);\n\t}\n\n\t// Call the on_closed callback if it is not null.\n\tif (m_on_closed) {\n\t\tm_on_closed(ec);\n\t}\n\n\t// Log that the session has been closed.\n\tif (ec) {\n\t\tCARLA_SAFE_ASSERT_RETURN(ec == boost::asio::error::operation_aborted,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::eof,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::connection_reset,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::connection_aborted,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::broken_pipe,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::not_connected,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::would_block,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::in_progress,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::already_started,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::operation_not_supported,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::not_socket,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::address_family_not_supported,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::address_in_use,);\n\t\tCARLA_SAFE_ASSERT_RETURN(ec!= boost::asio::error::address_not_available,);", "CodeBleu_score": 42.17911222835939}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec) {\n\t\t// if the error code is provided, log it and return\n\t\tLOG(INFO) << \"Error closing socket: \" << ec.message();\n\t\treturn;\n\t}\n\n\t// cancel the deadline timer\n\tm_deadline_timer.cancel();\n\n\t// if the socket is open, try to shutdown and close the socket\n\tif (m_socket.is_open()) {\n\t\t// try to shutdown the socket\n\t\tboost::system::error_code ignored_ec;\n\t\tm_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t\t// if the socket is still open, close it\n\t\tif (m_socket.is_open()) {\n\t\t\tm_socket.close(ignored_ec);\n\t\t}\n\t}\n\n\t// trigger the on_closed callback\n\tm_on_closed();\n\n\t// log that the session has been closed\n\tLOG(INFO) << \"Session closed.\";\n}", "CodeBleu_score": 49.8390998047262}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tcarla::streaming::detail::tcp::Message msg;\n\tmsg.write(carla::streaming::detail::Token::YOU_ALIVE);\n\n\t// Log the sending action\n\tcarla::log(\"Sending 'Are you alive?'\");\n\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\tPrimary::GetRouter()->write(msg.buffer(), msg.size());\n\n\t// Wait for and log the response from the system\n\tcarla::streaming::detail::tcp::Message response;\n\tPrimary::GetRouter()->read(response.buffer(), response.size());\n\tcarla::log(\"Received 'I'm alive!'\");\n}", "CodeBleu_score": 41.49488838588653}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tauto buffer = std::make_shared<carla::streaming::detail::Buffer>();\n\tbuffer->Write(carla::streaming::detail::Token::YOU_ALIVE);\n\tbuffer->Write(carla::streaming::detail::Token::END_OF_MESSAGE);\n\tPrimary::GetRouter()->Write(buffer);\n\tPrimary::GetLogger()->Log(\"Primary sent YOU_ALIVE\");\n\tPrimary::GetLogger()->Log(\"Primary is waiting for a response\");\n\tPrimary::GetRouter()->WaitForResponse();\n\tPrimary::GetLogger()->Log(\"Primary received a response\");\n}", "CodeBleu_score": 33.931865428307425}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::string message = \"Are you alive?\";\n\tstd::vector<char> buffer(message.begin(), message.end());\n\tLog::log(\"Sending message: \" + message);\n\tPrimary::router->Write(buffer, YOU_ALIVE);\n\tLog::log(\"Waiting for response...\");\n\tstd::vector<char> response = Primary::router->Read();\n\tLog::log(\"Response received: \" + std::string(response.begin(), response.end()));\n}", "CodeBleu_score": 47.00373379338468}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t#ifdef CARLA_MULTIGPU_DEBUG_ENABLED\n    std::cout << \"PrimaryCommands::SendEnableForROS(\" << sensor_id << \")\" << std::endl;\n#endif\n\n    // Check if the sensor is already enabled on any server\n    if (m_enabled_sensors.find(sensor_id)!= m_enabled_sensors.end()) {\n        return;\n    }\n\n    // Create the buffer\n    std::vector<uint8_t> buffer;\n    buffer.reserve(sizeof(uint32_t));\n    buffer.insert(buffer.end(), reinterpret_cast<uint8_t*>(&sensor_id), reinterpret_cast<uint8_t*>(&sensor_id) + sizeof(uint32_t));\n\n    // Send the ENABLE_ROS command to the router\n    m_router->Send(buffer, Command::ENABLE_ROS);\n\n    // Wait for the response\n    while (m_router->HasPendingCommands()) {\n        // Process the response\n        m_router->ProcessCommands();\n    }\n\n    // Check if the sensor was enabled\n    if (m_enabled_sensors.find(sensor_id) == m_enabled_sensors.end()) {\n        std::stringstream ss;\n        ss << \"Sensor \" << sensor_id << \" was not found on any server\";\n        m_logger->Error(ss.str());\n    }\n}", "CodeBleu_score": 46.835971411331265}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\n\tif (m_primary->GetSensor(sensor_id) == nullptr) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer() == nullptr) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == 0) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == m_primary->GetServerID()) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == m_primary->GetServerID()) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == m_primary->GetServerID()) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == m_primary->GetServerID()) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == m_primary->GetServerID()) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == m_primary->GetServerID()) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == m_primary->GetServerID()) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == m_primary->GetServerID()) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == m_primary->GetServerID()) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->GetServer()->GetServerID() == m_primary->GetServerID()) {\n\t\treturn;\n\t}\n\n\tif (m_primary->GetSensor(sensor_id)->Get", "CodeBleu_score": 21.325747875356406}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t#ifdef CARLA_MULTI_GPU_LOG_ENABLE_ROS\n  carla_debug(\"PrimaryCommands::SendEnableForROS(%i)\", sensor_id);\n#endif\n\n  // If the sensor is not enabled, we do nothing\n  if (!m_sensors_enabled[sensor_id]) {\n    return;\n  }\n\n  // If the sensor is enabled, we send an ENABLE_ROS command to the server\n  if (m_router->SendEnableForROS(sensor_id)) {\n    // If the server accepts the command, we wait for a response\n    m_router->WaitForResponse(sensor_id);\n  }\n  else {\n    // If the server rejects the command, we log an error message\n    carla_stderr(\"PrimaryCommands::SendEnableForROS(): Error while enabling sensor %i\", sensor_id);\n  }\n}", "CodeBleu_score": 26.748027959187294}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tif (Primary::Get().IsSensorActivated(sensor_id)) {\n\t\tPrimary::Get().Log(\"PrimaryCommands::GetToken\", \"Sensor \" + std::to_string(sensor_id) + \" already activated\");\n\t\treturn Primary::Get().GetSensorToken(sensor_id);\n\t}\n\n\tPrimary::Get().Log(\"PrimaryCommands::GetToken\", \"Sensor \" + std::to_string(sensor_id) + \" not activated\");\n\n\t// enable the sensor on a secondary server\n\tif (Primary::Get().EnableSensor(sensor_id)) {\n\t\tPrimary::Get().Log(\"PrimaryCommands::GetToken\", \"Sensor \" + std::to_string(sensor_id) + \" enabled\");\n\t} else {\n\t\tPrimary::Get().Log(\"PrimaryCommands::GetToken\", \"Sensor \" + std::to_string(sensor_id) + \" not enabled\");\n\t}\n\n\t// retrieve a new token\n\ttoken_type new_token = Primary::Get().GetSensorToken(sensor_id);\n\n\t// update the maps\n\tPrimary::Get().UpdateMaps();\n\n\t// log the action\n\tPrimary::Get().Log(\"PrimaryCommands::GetToken\", \"New token for sensor \" + std::to_string(sensor_id) + \": \" + std::to_string(new_token));\n\n\treturn new_token;\n}", "CodeBleu_score": 30.436126685665755}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Check if sensor is already activated\n\tif (sensor_id_to_token.count(sensor_id) > 0) {\n\t\t// Log action\n\t\tlog_stream << \"GetToken: Sensor already activated. sensor_id: \" << sensor_id << std::endl;\n\n\t\t// Return existing token\n\t\treturn sensor_id_to_token[sensor_id];\n\t}\n\n\t// Sensor is not activated, so enable it on a secondary server\n\tstream_id sensor_id_on_secondary = enable_sensor_on_secondary(sensor_id);\n\n\t// Check if sensor is still not activated\n\tif (sensor_id_to_token.count(sensor_id_on_secondary) == 0) {\n\t\t// Sensor is still not activated, so return an invalid token\n\t\treturn token_type::INVALID;\n\t}\n\n\t// Sensor is activated, so get a new token for it\n\ttoken_type token = get_new_token(sensor_id_on_secondary);\n\n\t// Update maps\n\tsensor_id_to_token[sensor_id_on_secondary] = token;\n\ttoken_to_sensor_id[token] = sensor_id_on_secondary;\n\n\t// Log action\n\tlog_stream << \"GetToken: Sensor activated. sensor_id: \" << sensor_id << \", sensor_id_on_secondary: \" << sensor_id_on_secondary << \", token: \" << token << std::endl;\n\n\t// Return new token\n\treturn token;\n}", "CodeBleu_score": 43.03449340311405}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// Check if sensor is already activated\n\tauto it = m_sensor_map.find(sensor_id);\n\tif (it!= m_sensor_map.end()) {\n\t\t// Sensor is already activated\n\t\treturn it->second;\n\t}\n\n\t// Sensor is not activated, enable it on a secondary server\n\t// TODO: send the message to the secondary server\n\t// TODO: get a new token\n\t// TODO: update the maps\n\t// TODO: log the action\n\treturn token_type();\n}", "CodeBleu_score": 22.736532237798208}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\tstd::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n\tfile.close();\n\n\treturn Load(buffer);\n}", "CodeBleu_score": 55.28789170207278}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary | std::ios::in);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tfile.seekg(0, std::ios::end);\n\tconst std::size_t size = file.tellg();\n\tfile.seekg(0, std::ios::beg);\n\tstd::vector<char> buffer(size);\n\tfile.read(&buffer[0], size);\n\tfile.close();\n\treturn Load(buffer);\n}", "CodeBleu_score": 57.87178447035306}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\tfile.seekg(0, std::ios::end);\n\tconst auto size = file.tellg();\n\tfile.seekg(0, std::ios::beg);\n\n\tstd::vector<char> data(size);\n\tfile.read(data.data(), size);\n\tfile.close();\n\n\treturn Load(data);\n}", "CodeBleu_score": 54.14975750457971}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\tif (crowd == nullptr) {\n\t\tLOG_ERROR(\"Crowd is null\");\n\t\treturn false;\n\t}\n\tstd::lock_guard<std::mutex> lock(crowd_mutex);\n\tauto it = walker_map.find(id);\n\tif (it!= walker_map.end()) {\n\t\tcrowd->removeAgent(it->second);\n\t\tauto walker = it->second;\n\t\twalker_map.erase(it);\n\t\twalker_manager->RemoveWalker(walker);\n\t\treturn true;\n\t}\n\tit = vehicle_map.find(id);\n\tif (it!= vehicle_map.end()) {\n\t\tcrowd->removeAgent(it->second);\n\t\tauto vehicle = it->second;\n\t\tvehicle_map.erase(it);\n\t\tvehicle_manager->RemoveVehicle(vehicle);\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 64.33632010410741}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (IsReady() && crowd!= nullptr) {\n\t\tstd::lock_guard<std::mutex> lock(crowd_mutex);\n\t\tif (walker_manager.GetWalker(id)) {\n\t\t\twalker_manager.RemoveWalker(id);\n\t\t\treturn true;\n\t\t}\n\t\tif (vehicle_manager.GetVehicle(id)) {\n\t\t\tvehicle_manager.RemoveVehicle(id);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\treturn false;\n}", "CodeBleu_score": 31.894745951752878}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tif (m_crowd == nullptr) {\n\t\treturn false;\n\t}\n\tif (m_vehicle_manager.RemoveVehicle(id)) {\n\t\treturn true;\n\t}\n\tif (m_walker_manager.RemoveWalker(id)) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 25.9122833568739}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\t// TODO: Implement this function\n\t//std::lock_guard<std::mutex> lock(m_mutex);\n\t//std::set<uint64_t> current_ids;\n\t//for (auto &vehicle : m_vehicles) {\n\t//\tcurrent_ids.insert(vehicle.id);\n\t//}\n\t//for (auto &vehicle : vehicles) {\n\t//\tif (current_ids.count(vehicle.id) > 0) {\n\t//\t\t// Update\n\t//\t\tm_vehicles[vehicle.id].updated = true;\n\t//\t}\n\t//\telse {\n\t//\t\t// Add\n\t//\t\tm_vehicles[vehicle.id] = vehicle;\n\t//\t}\n\t//}\n\t//for (auto &vehicle : m_vehicles) {\n\t//\tif (!vehicle.second.updated) {\n\t//\t\tm_vehicles.erase(vehicle.first);\n\t//\t}\n\t//\telse {\n\t//\t\tvehicle.second.updated = false;\n\t//\t}\n\t//}\n\t//return true;\n\tstd::vector<VehicleCollisionInfo> new_vehicles;\n\tfor (auto &vehicle : vehicles) {\n\t\tif (m_vehicles.find(vehicle.id)!= m_vehicles.end()) {\n\t\t\tm_vehicles[vehicle.id].updated = true;\n\t\t}\n\t\telse {\n\t\t\tm_vehicles[vehicle.id] = vehicle;\n\t\t}\n\t}\n\tfor (auto &vehicle : m_vehicles) {\n\t\tif (!vehicle.second.updated) {\n\t\t\tm_vehicles.erase(vehicle.first);\n\t\t}\n\t\telse {\n\t\t\tvehicle.second.updated = false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 48.56587790397758}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\t// collect all currently mapped vehicle IDs\n\tstd::set<int> current_vehicle_ids;\n\tfor (auto const &vehicle : m_vehicles) {\n\t\tcurrent_vehicle_ids.insert(vehicle.second->GetID());\n\t}\n\n\t// add or update vehicles\n\tfor (auto const &vehicle : vehicles) {\n\t\tif (vehicle.vehicle_id == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (current_vehicle_ids.find(vehicle.vehicle_id) == current_vehicle_ids.end()) {\n\t\t\t// vehicle is not mapped yet, add it\n\t\t\tm_vehicles[vehicle.vehicle_id] = std::make_shared<Vehicle>(vehicle.vehicle_id, vehicle.vehicle_type, vehicle.vehicle_position, vehicle.vehicle_rotation);\n\t\t} else {\n\t\t\t// vehicle is mapped, update it\n\t\t\tm_vehicles[vehicle.vehicle_id]->Update(vehicle.vehicle_position, vehicle.vehicle_rotation);\n\t\t}\n\t\tcurrent_vehicle_ids.erase(vehicle.vehicle_id);\n\t}\n\n\t// remove vehicles that are not in the current frame\n\tfor (auto const &vehicle_id : current_vehicle_ids) {\n\t\tm_vehicles.erase(vehicle_id);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 48.9975176017919}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\t//std::cout << \"UpdateVehicles\" << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() << std::endl;\n\t//std::cout << \"Vehicles.size() = \" << vehicles.size() <<", "CodeBleu_score": 4.394423272867895}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tauto it = m_walkers.find(id);\n\tif (it!= m_walkers.end()) {\n\t\tcarla::geom::Location location = it->second->GetLocation();\n\t\tfloat sq_distance = carla::geom::DistanceSquared2D(location, direction);\n\t\tif (sq_distance < distance * distance) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 45.13164693130926}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// Get the actor from the map\n\tauto it = _walkers.find(id);\n\tif (it == _walkers.end()) {\n\t\treturn false;\n\t}\n\t// Enter the critical section\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\t// Compute the squared distance\n\tauto distance2 = distance * distance;\n\t// Check if the vehicle is nearby\n\treturn _crowd->GetAgentCount() > 0 && _crowd->GetAgentCount() <= _crowd->GetMaxAgents() && _crowd->GetAgentState(0).position.DistanceSquared(it->second.location) < distance2;\n}", "CodeBleu_score": 46.26090085107171}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// Search for the actor in the mapped walkers and vehicles.\n\tauto it = _walkers.find(id);\n\tif (it == _walkers.end()) {\n\t\tit = _vehicles.find(id);\n\t\tif (it == _vehicles.end()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Enter a critical section.\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Compute the squared distance.\n\tconst float squared_distance = distance * distance;\n\n\t// Check if there is a vehicle nearby.\n\treturn _crowd->HasVehicleNear(it->second, squared_distance, direction);\n}", "CodeBleu_score": 57.112493273065965}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current route point\n\tWalkerRoutePoint &current = info.route[info.current_point];\n\n\t// create a visitor to process the event\n\tWalkerEventVisitor visitor(id, info, delta);\n\n\t// process the event at the current route point\n\tboost::variant2::visit(visitor, current.event);\n\n\t// return the result of the event execution\n\treturn visitor.GetResult();\n}", "CodeBleu_score": 50.03400818576}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto &world = info.Walker->GetWorld();\n\tauto &walker = *info.Walker;\n\n\t// Retrieve current route point.\n\tauto &route_point = info.Route[info.CurrentRoutePoint];\n\n\t// Create a visitor to process the event at the current route point.\n\tWalkerEventVisitor visitor(info, world, walker, route_point, delta);\n\n\t// Execute the event at the current route point.\n\tauto result = boost::variant2::visit(visitor, route_point.Event);\n\n\t// Update current route point.\n\tinfo.CurrentRoutePoint = (info.CurrentRoutePoint + 1) % info.Route.size();\n\n\treturn result;\n}", "CodeBleu_score": 44.66450778829339}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\n#if 0\n  if (info.IsDone()) {\n    return EventResult::Done;\n  }\n\n  auto route_point = info.GetCurrentRoutePoint();\n\n  if (route_point == nullptr) {\n    return EventResult::Failed;\n  }\n\n  WalkerEventVisitor visitor(info, delta);\n\n  boost::variant2::visit(visitor, route_point->GetEvent());\n\n  return visitor.GetResult();\n#else\n  return EventResult::Done;\n#endif\n}", "CodeBleu_score": 39.99299243916277}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n#if defined(CARLA_DEBUG)\n  std::cout << \"Parsing lanes...\" << std::endl;\n#endif\n\n  // Iterate through each road node\n  for (auto road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    // Get the road ID\n    std::string road_id = road_node.attribute(\"id\").as_string();\n\n    // Iterate through each lane section\n    for (auto lane_section_node : road_node.children(\"laneSection\")) {\n      // Parse the lanes\n      ParseLanes(lane_section_node, map_builder);\n    }\n  }\n\n#if defined(CARLA_DEBUG)\n  std::cout << \"Parsing lanes... Done\" << std::endl;\n#endif\n}", "CodeBleu_score": 30.86205555577923}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n/*\n * Iterate through each road node and extract the road ID.\n */\n  for (auto road : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const auto id = road.attribute(\"id\").as_string();\n\n/*\n * Iterate through each lane section node and parse the left, center, and right lane nodes.\n */\n    for (auto lane_section : road.children(\"laneSection\")) {\n      for (auto lane : lane_section.children(\"lane\")) {\n        const auto left = lane.child(\"left\");\n        const auto center = lane.child(\"center\");\n        const auto right = lane.child(\"right\");\n        ParseLanes(left, center, right, map_builder, id);\n      }\n    }\n  }\n}", "CodeBleu_score": 39.47371739334587}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t#if defined(CARLA_DEBUG)\n  std::cout << \"LaneParser::Parse()\" << std::endl;\n#endif\n  for (auto &road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const auto road_id = road_node.attribute(\"id\").as_string();\n    for (auto &lane_section_node : road_node.children(\"lanes\")) {\n      ParseLanes(lane_section_node, road_id, map_builder);\n    }\n  }\n}", "CodeBleu_score": 27.426813294803164}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tm_matched_count = info.current_count;\n\t\tif (m_matched_count == 1) {\n\t\t\tm_first_connection = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tm_matched_count = info.current_count;\n\t} else {\n\t\tstd::cerr << \"ERROR: PublicationMatchedStatus: invalid current_count_change: \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 69.94567222409592}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tswitch (info.current_count_change) {\n\t\tcase efd::PublicationMatchedStatus::Added:\n\t\t\tm_matched_count++;\n\t\t\tif (m_matched_count == 1) {\n\t\t\t\tm_first_connection = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase efd::PublicationMatchedStatus::Removed:\n\t\t\tif (m_matched_count > 0) {\n\t\t\t\tm_matched_count--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cerr << \"Error: Unexpected PublicationMatchedStatus change: \" << info.current_count_change << std::endl;\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 40.64339719590539}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tswitch (info.current_count_change) {\n\tcase 1:\n\t\t// New match\n\t\tm_matched_count = info.current_count;\n\t\tm_first_connection = true;\n\t\tstd::cout << \"Publisher matched\" << std::endl;\n\t\tbreak;\n\tcase -1:\n\t\t// Match lost\n\t\tm_matched_count = info.current_count;\n\t\tstd::cout << \"Publisher lost match\" << std::endl;\n\t\tbreak;\n\tdefault:\n\t\tstd::cerr << \"Error: Unexpected publication matched status\" << std::endl;\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 45.73700681568765}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tif (info.current_count_change == 1) {\n\t\tif (info.current_count == 1) {\n\t\t\tm_first_connected = true;\n\t\t}\n\t\tm_matched_count = info.current_count;\n\t} else if (info.current_count_change == -1) {\n\t\tm_matched_count = info.current_count;\n\t\tif (m_matched_count == 0) {\n\t\t\tm_subscriber->destroy_datareader(reader);\n\t\t\tm_subscriber->delete_contained_entities();\n\t\t\tm_subscriber = nullptr;\n\t\t}\n\t} else {\n\t\tstd::cerr << \"Error: invalid subscription matched status: matched count \" << info.current_count << \" change \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 53.00422548937034}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tif (info.current_count == 1) {\n\t\t\tstd::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: New subscription matched.\" << std::endl;\n\t\t\tfirst_connected_ = true;\n\t\t} else if (info.current_count == 0) {\n\t\t\tstd::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: Subscription removed.\" << std::endl;\n\t\t} else {\n\t\t\tstd::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: Error: current_count change = \" << info.current_count_change << \" with invalid value \" << info.current_count << std::endl;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tif (info.current_count == 0) {\n\t\t\tstd::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: Subscription removed.\" << std::endl;\n\t\t} else if (info.current_count == 1) {\n\t\t\tstd::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: Error: current_count change = \" << info.current_count_change << \" with invalid value \" << info.current_count << std::endl;\n\t\t} else {\n\t\t\tstd::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: Error: current_count change = \" << info.current_count_change << \" with invalid value \" << info.current_count << std::endl;\n\t\t}\n\t} else {\n\t\tstd::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: Error: current_count change = \" << info.current_count_change << \" with invalid value \" << info.current_count << std::endl;\n\t}\n}", "CodeBleu_score": 54.09222665234563}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tif (info.current_count == 1) {\n\t\t\tfirst_connected_ = true;\n\t\t}\n\t\telse if (info.current_count == 0) {\n\t\t\tfirst_connected_ = false;\n\t\t}\n\t}\n\telse if (info.current_count_change == -1) {\n\t\tif (info.current_count == 0) {\n\t\t\tfirst_connected_ = false;\n\t\t}\n\t}\n\telse {\n\t\tstd::cout << \"Error: invalid subscription count change for CarlaEgoVehicleControlSubscriber\" << std::endl;\n\t}\n}", "CodeBleu_score": 60.80096015723653}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tCarlaCollisionEvent* m_data = (CarlaCollisionEvent*)data;\n\tif(force_md5 || CarlaCollisionEventPubSubType::getKey(m_data, handle)) {\n\t\t// serialize the key into the handle\n\t\tfastcdr::FastBuffer fastbuffer((char*) handle->value,\n\t\t\tCarlaCollisionEventPubSubType::getKeySize());\n\t\tfastcdr::Cdr ser(fastbuffer);\n\t\tser << *m_data;\n\t\treturn true;\n\t} else {\n\t\t// handle was not set\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 23.83297893840033}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tCarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n\tif (!force_md5 && CarlaCollisionEventPubSubType::getKeyHash(\n\t\t\tstatic_cast<void*>(p_type), handle) == RTI_TRUE) {\n\t\treturn true;\n\t}\n\telse if (force_md5 || CarlaCollisionEventPubSubType::getKeyHash(\n\t\t\tstatic_cast<void*>(p_type), handle) == RTI_FALSE) {\n\t\treturn CarlaCollisionEventPubSubType::serializeKey(\n\t\t\t\tstatic_cast<void*>(p_type), handle);\n\t}\n\treturn false;\n}", "CodeBleu_score": 22.41220448056494}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tCarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n\tif (!force_md5 && CarlaCollisionEventPubSubType::getKeyHash(data, handle))\n\t{\n\t\treturn true;\n\t}\n\t\n\treturn CarlaCollisionEventPubSubType::serializeKey(data, handle);\n}", "CodeBleu_score": 11.022178080767937}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\t// Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n\t\t\teprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\t// Serialize encapsulation\n\tser.serialize_encapsulation();\n\n\ttry\n\t{\n\t\tp_type->serialize(ser);\n\t}\n\tcatch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n\t{\n\t\treturn false;\n\t}\n\n\tpayload->length = (uint32_t)ser.getSerializedDataLength();\n\treturn true;\n}", "CodeBleu_score": 79.26737795031788}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n\t\t\teprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\t// Serialize encapsulation\n\tser.serialize_encapsulation();\n\n\ttry\n{\n\t\t// Serialize the object:\n\t\tp_type->serialize(ser);\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\n\t// Get the serialized length\n\tpayload->length = fastbuffer.getSerializedDataLength();\n\treturn true;\n}", "CodeBleu_score": 84.45993425408163}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n\t\t\teprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE; // Set the proper endianness.\n\t// Serialize encapsulation\n\tser.serialize_encapsulation();\n\n\ttry\n{\n\t\t// Serialize the object:\n\t\tp_type->serialize(ser);\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\n\t// Get the serialized length\n\tpayload->length = fastbuffer.getSerializedDataLength();\n\treturn true;\n}", "CodeBleu_score": 83.58717029188286}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_HEARTBEAT: {\n\t\tmavlink_heartbeat_t hb;\n\t\tmavlink_msg_heartbeat_decode(&msg, &hb);\n\t\tif (hb.type == MAV_TYPE_GCS) {\n\t\t\ttarget_sysid = hb.sysid;\n\t\t\ttarget_set = true;\n\t\t\tif (target_sysid!= sysid) {\n\t\t\t\tmavlink_request_data_stream(target_sysid, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\t\t\tmavlink_request_data_stream(target_sysid, MAV_DATA_STREAM_EXTRA1, 1, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT: {\n\t\tmavlink_global_position_int_t gps;\n\t\tmavlink_msg_global_position_int_decode(&msg, &gps);\n\t\tif (gps.target_system == target_sysid) {\n\t\t\ttarget_set = true;\n\t\t\ttarget_lat = gps.lat;\n\t\t\ttarget_lon = gps.lon;\n\t\t\ttarget_alt = gps.alt;\n\t\t\ttarget_heading = gps.hdg;\n\t\t\ttarget_air_pressure = gps.press_abs;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MAVLINK_MSG_ID_ATTITUDE: {\n\t\tmavlink_attitude_t att;\n\t\tmavlink_msg_attitude_decode(&msg, &att);\n\t\tif (att.target_system == target_sysid) {\n\t\t\ttarget_set = true;\n\t\t\ttarget_pitch = att.pitch;\n\t\t\ttarget_roll = att.roll;\n\t\t\ttarget_yaw = att.yaw;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 37.17868841299725}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) return; // already set\n\n\t// check if we have a message type that we want to track\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n\tcase MAVLINK_MSG_ID_LOCAL_POSITION_NED:\n\tcase MAVLINK_MSG_ID_ATTITUDE:\n\tcase MAVLINK_MSG_ID_VFR_HUD:\n\tcase MAVLINK_MSG_ID_HIGHRES_IMU:\n\tcase MAVLINK_MSG_ID_SCALED_PRESSURE:\n\tcase MAVLINK_MSG_ID_RAW_IMU:\n\tcase MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:\n\tcase MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_AHRS:\n\tcase MAVLINK_MSG_ID_RC_CHANNELS_RAW:\n\tcase MAVLINK_MSG_ID_RC_CHANNELS_SCALED:\n\tcase MAVLINK_MSG_ID_RC_CHANNELS_RAW_AHRS:\n\tcase MAVLINK_MSG_ID_ATTITUDE_QUATERNION:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_COV:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_COV:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_AHRS:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_AHRS:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_AHRS_COV:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_AHRS_COV:\n\tcase MAVLINK_MSG_ID_ATTITUDE_TARGET:\n\tcase MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED:\n\tcase MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL", "CodeBleu_score": 13.017167276160208}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\tif (msg.sysid == target_sysid) {\n\t\ttarget_set = true;\n\t\treturn;\n\t}\n\n\tif (msg.sysid!= target_sysid) {\n\t\ttarget_sysid = msg.sysid;\n\t}\n\n\t// Request position and air pressure data\n\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, 1, 0, 1);\n\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, 1, 1, 1);\n}", "CodeBleu_score": 32.42250080862596}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// Call the base class handler\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\n\t// If the result is accepted, set the flag\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_need_baro_calibration = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 52.66688298943312}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// call the base class handler\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\n\t// if the base class handler accepted the command, set the flag to indicate that altitude calibration is needed on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_calibration_flags |= (1 << BARO_CALIBRATION_NEEDED);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 47.68677197107273}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// Process the preflight calibration command for the barometer.\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration(msg);\n\n\t// If the result is MAV_RESULT_ACCEPTED, set a flag to indicate that altitude calibration is needed on the next barometer update.\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_tracker.set_altitude_calibration_needed();\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 49.90346548423651}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t//MAV_RESULT res = MAV_RESULT_UNSUPPORTED;\n\t//return res;\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 8.466246505442832}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0f) {\n\t\t// arm\n\t\t// TODO: arm\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0f) {\n\t\t// disarm\n\t\t// TODO: disarm\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\t// unsupported\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 42.85542361020984}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 42.634872392902246}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tif (sysid == 0 && compid == 0) {\n\t\tfor (uint8_t i = 0; i < GCS_CHANNELS; i++) {\n\t\t\tif (gcs_channels[i].available_payload_space() >= sizeof(gcs_msg_position_t)) {\n\t\t\t\tgcs_channels[i].send_message(MAVLINK_MSG_ID_GCS_POSITION, (uint8_t *) &gcs_msg_position, sizeof(gcs_msg_position_t));\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.20739430444634}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over available GCS channels\n\tfor (uint8_t i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\t// Check if channel is available\n\t\tif (gcs[i].available) {\n\t\t\t// Check if channel has enough space for the data\n\t\t\tif (gcs[i].payload_available > sizeof(mavlink_message_t)) {\n\t\t\t\t// Send request to start data stream\n\t\t\t\tmavlink_msg_request_data_stream_send(gcs[i].mavlink_fd, sysid, compid, MAV_DATA_STREAM_POSITION, 1, 10);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.86890956627807}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i = 0; i < _num_channels; i++) {\n\t\tif (_channels[i].available_payload_space() > 0) {\n\t\t\t_channels[i].request_datastream_position(sysid, compid);\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 30.917729319563847}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tTracker* tracker = Tracker::get_instance();\n\tif (tracker->get_ahrs()->get_pitch_cos() == 0) {\n\t\treturn false;\n\t} else {\n\t\tef_pitch = pitch - tracker->get_ahrs()->get_pitch();\n\t\tef_yaw = yaw - tracker->get_ahrs()->get_yaw();\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 42.38639872471049}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (cos(pitch) == 0.0) {\n\t\treturn false;\n\t}\n\telse {\n\t\tef_pitch = atan(sin(pitch) / cos(pitch));\n\t\tef_yaw = yaw + atan(sin(yaw) / cos(yaw));\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 31.748118800431023}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tTracker* tracker = Tracker::get_instance();\n\tif (pitch!= 0) {\n\t\tef_pitch = atan(tracker->get_pitch_cosine() / cos(pitch));\n\t\tef_yaw = yaw;\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 40.318269282631654}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// If the tracker is not tracking, then update the tracker\n\tif(!tracker->isTracking()) {\n\t\t// If the target is valid, then update the tracker\n\t\tif(tracker->target_valid) {\n\t\t\t// Update the tracker\n\t\t\ttracker->update(target_yaw, target_pitch, target_distance);\n\t\t}\n\t\t// If the target is not valid, then update the tracker with the current yaw and pitch\n\t\telse {\n\t\t\ttracker->update(yaw, pitch, target_distance);\n\t\t}\n\t}\n\t// If the tracker is tracking, then update the tracker\n\telse {\n\t\t// Update the tracker\n\t\ttracker->update();\n\t}\n\t// If the target distance is valid, then update the yaw and pitch servos\n\tif(target_distance > 0.0) {\n\t\t// If the target distance is greater than the minimum distance, then update the yaw and pitch servos\n\t\tif(target_distance > min_distance) {\n\t\t\t// Update the yaw and pitch servos\n\t\t\tyaw_servo->update(tracker->target_yaw);\n\t\t\tpitch_servo->update(tracker->target_pitch);\n\t\t}\n\t\t// If the target distance is less than or equal to the minimum distance, then set the yaw and pitch servos to the minimum distance\n\t\telse {\n\t\t\t// Update the yaw and pitch servos\n\t\t\tyaw_servo->update(tracker->target_yaw);\n\t\t\tpitch_servo->update(tracker->target_pitch);\n\t\t}\n\t}\n\t// If the target distance is not valid, then set the yaw and pitch servos to the current yaw and pitch\n\telse {\n\t\t// Update the yaw and pitch servos\n\t\tyaw_servo->update(yaw);\n\t\tpitch_servo->update(pitch);\n\t}\n}", "CodeBleu_score": 34.647024901320336}, {"code": "void Mode::update_auto(void){\n\t\t// Update the target yaw and pitch\n\tif (nav_status.valid_pos && (nav_status.distance_to_target > MIN_DISTANCE)) {\n\t\t// Compute the yaw and pitch error\n\t\tfloat yaw_error = (nav_status.target_yaw - nav_status.yaw) * 180.0f / M_PI;\n\t\tfloat pitch_error = (nav_status.target_pitch - nav_status.pitch) * 180.0f / M_PI;\n\n\t\t// Check if the direction is reversed\n\t\tif (yaw_error > 180.0f) yaw_error -= 360.0f;\n\t\tif (yaw_error < -180.0f) yaw_error += 360.0f;\n\t\tif (pitch_error > 180.0f) pitch_error -= 360.0f;\n\t\tif (pitch_error < -180.0f) pitch_error += 360.0f;\n\n\t\t// Convert the errors from earth frame to body frame\n\t\tfloat yaw_error_body = yaw_error * cosf(nav_status.pitch) + pitch_error * sinf(nav_status.pitch);\n\t\tfloat pitch_error_body = pitch_error * cosf(nav_status.pitch) - yaw_error * sinf(nav_status.pitch);\n\n\t\t// Update the pitch and yaw servos\n\t\tTracker::update_pitch_servo(pitch_error_body);\n\t\tTracker::update_yaw_servo(yaw_error_body);\n\t}\n\telse {\n\t\t// Update the pitch and yaw servos\n\t\tTracker::update_pitch_servo(0.0f);\n\t\tTracker::update_yaw_servo(0.0f);\n\t}\n}", "CodeBleu_score": 35.805186465962734}, {"code": "void Mode::update_auto(void){\n\t\t// Calculate the yaw and pitch in centidegrees\n\tfloat yaw = (float)Tracker::get_yaw();\n\tfloat pitch = (float)Tracker::get_pitch();\n\n\t// Check if the direction is reversed\n\tif (Tracker::get_reversed()) {\n\t\tyaw = -yaw;\n\t\tpitch = -pitch;\n\t}\n\n\t// Calculate the angle error\n\tfloat yaw_error = yaw - (float)Tracker::get_target_yaw();\n\tfloat pitch_error = pitch - (float)Tracker::get_target_pitch();\n\n\t// Convert the errors from earth frame to body frame\n\tfloat yaw_error_body = yaw_error * cos(pitch * 0.0174532925) + pitch_error * sin(pitch * 0.0174532925);\n\tfloat pitch_error_body = pitch_error * cos(pitch * 0.0174532925) - yaw_error * sin(pitch * 0.0174532925);\n\n\t// Check if the target distance is valid or no minimum distance is set\n\tif (Tracker::get_target_distance() > 0 || Tracker::get_min_distance() == 0) {\n\t\t// Update the pitch and yaw servos\n\t\tTracker::set_pitch_servo(pitch_error_body);\n\t\tTracker::set_yaw_servo(yaw_error_body);\n\t}\n}", "CodeBleu_score": 29.111728525644022}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tgps_data = GPS.read();\n\tif (gps_data.time!= last_gps_time) {\n\t\tlast_gps_time = gps_data.time;\n\t\tif (gps_data.fix) {\n\t\t\tif (gps_data.fixquality >= 3) {\n\t\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\t\thome_location = gps_data.location;\n\t\t\t\t\tground_start_countdown = 100;\n\t\t\t\t} else {\n\t\t\t\t\tground_start_countdown--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tground_start_countdown = 100;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.77336489963826}, {"code": "void Tracker::update_GPS(void){\n\t\t// Get the GPS data from the GPS module\n\tGPS_data = GPS.get_GPS_data();\n\n\t// Check if the GPS data is valid\n\tif (GPS_data.valid) {\n\t\t// Check if the GPS status is at least 3D fix\n\t\tif (GPS_data.status >= 3) {\n\t\t\t// Check if the last message time has changed\n\t\t\tif (GPS_data.last_message_time!= last_message_time) {\n\t\t\t\t// Reset the countdown\n\t\t\t\tground_start_countdown = 0;\n\t\t\t}\n\n\t\t\t// Update the last message time\n\t\t\tlast_message_time = GPS_data.last_message_time;\n\n\t\t\t// Check if the countdown is at zero\n\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\t// Set the home location\n\t\t\t\thome_location = GPS_data.location;\n\t\t\t}\n\t\t}\n\n\t\t// Increment the countdown\n\t\tground_start_countdown++;\n\t}\n}", "CodeBleu_score": 35.157515217190564}, {"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time!= last_message_time) {\n\t\tlast_message_time = gps.last_message_time;\n\t\tif (gps.status >= 3) {\n\t\t\tif (countdown_to_ground_start == 0) {\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\thome_location = gps.location;\n\t\t\t\t\tcountdown_to_ground_start = 10;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcountdown_to_ground_start--;\n\t\t\t}\n\t\t} else {\n\t\t\tcountdown_to_ground_start = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.10741700798288}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch >= 0) {\n\t\tpitch_servo.write(pitch);\n\t}\n}", "CodeBleu_score": 11.798941004522154}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 90) {\n\t\tpitch = 90;\n\t}\n\telse if (pitch < -90) {\n\t\tpitch = -90;\n\t}\n\n\tpitch = 100 * pitch / 90;\n\tpitch = 100 - pitch;\n\n\tif (pitch > 100) {\n\t\tpitch = 100;\n\t}\n\telse if (pitch < 0) {\n\t\tpitch = 0;\n\t}\n\n\tpitch = pitch / 100;\n\tpitch = pitch * 180;\n\tpitch = pitch / 1.8;\n\n\tpitch = pitch * 100;\n\n\tif (pitch > 100) {\n\t\tpitch = 100;\n\t}\n\telse if (pitch < 0) {\n\t\tpitch = 0;\n\t}\n\n\tpitch = pitch / 100;\n\tpitch = pitch * 1.8;\n\tpitch = pitch * 100;\n\n\tif (pitch > 180) {\n\t\tpitch = 180;\n\t}\n\telse if (pitch < 0) {\n\t\tpitch = 0;\n\t}\n\n\tpitch = pitch / 180;\n\tpitch = pitch * 100;\n\n\tif (pitch > 100) {\n\t\tpitch = 100;\n\t}\n\telse if (pitch < 0) {\n\t\tpitch = 0;\n\t}\n\n\tpitch = pitch / 100;\n\tpitch = pitch * 90;\n\n\tif (pitch > 90) {\n\t\tpitch = 90;\n\t}\n\telse if (pitch < -90) {\n\t\tpitch = -90;\n\t}\n\n\tpitch = pitch / 90;\n\tpitch = pitch * 100;\n\n\tif (pitch > 100) {\n\t\tpitch = 100;\n\t}\n\telse if (pitch < 0) {\n\t\tpitch = 0;\n\t}\n\n\tpitch = pitch / 100;\n\tpitch = pitch * 1.8;\n\tpitch = pitch * 10", "CodeBleu_score": 13.897439505896736}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0) {\n\t\tpitch_onoff_servo.write(0);\n\t}\n\telse {\n\t\tpitch_onoff_servo.write(180);\n\t}\n}", "CodeBleu_score": 13.23754285430444}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\tif (display_failure) {\n\t\tif (baro_alt_ref_cm > 0) {\n\t\t\tif (abs(baro_alt_ref_cm - inertial_nav_alt_cm) > ARMING_CHECK_BARO_ALT_DISPARITY_MAX_CM) {\n\t\t\t\t_failure_mode_flags.set_and_alert(FAIL_BARO_ALT_DISPARITY);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 29.724536170441873}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call the base class's barometer_checks function\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check barometer reference\n\tif (ARMING_CHECK_BARO &&!barometer.check_reference()) {\n\t\tif (display_failure) {\n\t\t\t_failure_reason = \"baro ref\";\n\t\t\t_failure_sub_reason = \"baro ref\";\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check barometer altitude\n\tif (ARMING_CHECK_BARO &&!barometer.check_altitude()) {\n\t\tif (display_failure) {\n\t\t\t_failure_reason = \"baro alt\";\n\t\t\t_failure_sub_reason = \"baro alt\";\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 39.86058110228032}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool result = AP_Arming::barometer_checks(display_failure);\n\tif (result && ARMING_CHECK_BARO) {\n\t\tfloat alt_diff = _nav_altitude - _baro_alt;\n\t\tif (alt_diff > ARMING_BARO_ALT_MAX) {\n\t\t\tif (display_failure) {\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t\t_failure_flags.set_and_clear(FAILFLAG_BARO_ALT_DIFF_TOO_HIGH);\n\t\t\t", "CodeBleu_score": 31.100127983041663}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 19.754462489470328}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\treturn false;\n}", "CodeBleu_score": 8.614048038226855}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\treturn ( _params.terrain_source == AP_Param::Param::TERRAIN_SOURCE_RANGEFINDER ) || ( _params.terrain_source == AP_Param::Param::TERRAIN_SOURCE_TERRAIN_DB && _params.rtl_altitude_type == AP_Param::Param::RTL_ALTITUDE_TYPE_TERRAIN );\n}", "CodeBleu_score": 25.430762796299337}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// Set the loop time for the rate controller\n\trate_controller.set_loop_time(scheduler.get_last_loop_time());\n\n\t// Run the rate controller\n\trate_controller.run();\n}", "CodeBleu_score": 22.431077098241065}, {"code": "void Copter::run_rate_controller(){\n\t\t// Set the loop time for the rate controllers\n\trate_controller_set_loop_time(last_loop_time);\n\n\t// Run the low-level rate controllers\n\trate_controller_run();\n}", "CodeBleu_score": 10.398259687399667}, {"code": "void Copter::run_rate_controller(){\n\t\t//Set the loop time for the rate controllers\n\trate_controller_set_loop_time(scheduler.get_last_loop_time());\n\n\t//Run the rate controller\n\trate_controller_run();\n}", "CodeBleu_score": 13.438661554965112}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.get_frame() == new_loc.get_frame() && old_loc.get_frame() == Location::FRAME_ALTITUDE) {\n\t\treturn false;\n\t}\n\ttarget_location = new_loc;\n\treturn true;\n}", "CodeBleu_score": 45.242960895796415}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// If the altitude frames are different, the target location cannot be updated\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// If the old location is the same as the new location, the target location cannot be updated\n\tif (old_loc.lat == new_loc.lat && old_loc.lon == new_loc.lon) {\n\t\treturn false;\n\t}\n\n\t// If the old location is the same as the new location, the target location cannot be updated\n\tif (old_loc.alt == new_loc.alt) {\n\t\treturn false;\n\t}\n\n\t// If the old location is the same as the new location, the target location cannot be updated\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// If the old location is the same as the new location, the target location cannot be updated\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// If the old location is the same as the new location, the target location cannot be updated\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// If the old location is the same as the new location, the target location cannot be updated\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// If the old location is the same as the new location, the target location cannot be updated\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// If the old location is the same as the new location, the target location cannot be updated\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// If the old location is the same as the new location, the target location cannot be updated\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// If the old location is the same as the new", "CodeBleu_score": 36.226256493171114}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// if the old location matches the current waypoint, and the altitude frames are the same, then we are at the next waypoint\n\tif (old_loc == new_loc && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set the new location as the target\n\tset_target_location(new_loc);\n\n\treturn true;\n}", "CodeBleu_score": 50.190269122110834}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode!= _copter->get_mode()) {\n\t\t\t_copter->set_mode(mode);\n\t\t}\n\t} else if (ch_flag == AuxSwitchPos::LOW && _copter->get_mode() == mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 56.08822332154888}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (_copter->get_mode()!= mode) {\n\t\t\t_copter->set_mode(mode);\n\t\t}\n\t} else if (_copter->get_mode() == mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 55.068273586474945}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (get_copter_ptr()->get_mode()!= mode) {\n\t\t\tget_copter_ptr()->set_mode(mode);\n\t\t}\n\t} else {\n\t\tif (get_copter_ptr()->get_mode() == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 55.26782355767508}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\tfloat roll_trim = 0;\n\tfloat pitch_trim = 0;\n\tfloat yaw_trim = 0;\n\tfloat roll_trim_rad = 0;\n\tfloat pitch_trim_rad = 0;\n\tfloat yaw_trim_rad = 0;\n\tfloat roll_trim_deg = 0;\n\tfloat pitch_trim_deg = 0;\n\tfloat yaw_trim_deg = 0;\n\tfloat roll_trim_deg_max = 0;\n\tfloat pitch_trim_deg_max = 0;\n\tfloat yaw_trim_deg_max = 0;\n\tfloat roll_trim_rad_max = 0;\n\tfloat pitch_trim_rad_max = 0;\n\tfloat yaw_trim_rad_max = 0;\n\tfloat roll_trim_rad_min = 0;\n\tfloat pitch_trim_rad_min = 0;\n\tfloat yaw_trim_rad_min = 0;\n\tfloat roll_trim_deg_min = 0;\n\tfloat pitch_trim_deg_min = 0;\n\tfloat yaw_trim_deg_min = 0;\n\tfloat roll_trim_rad_max_deg = 0;\n\tfloat pitch_trim_rad_max_deg = 0;\n\tfloat yaw_trim_rad_max_deg = 0;\n\tfloat roll_trim_rad_min_deg = 0;\n\tfloat pitch_trim_rad_min_deg = 0;\n\tfloat yaw_trim_rad_min_deg = 0;\n\tfloat roll_trim_rad_max_deg_min = 0;\n\tfloat pitch_trim_rad_max_deg_min = 0;\n\tfloat yaw_trim_rad_max_deg_min = 0;\n\tfloat roll_trim_rad_max_deg_max = 0;\n\tfloat pitch_trim_rad_max_deg_max = 0;\n\tfloat yaw_trim_rad_max_deg_max = 0;\n\tfloat roll_trim_rad_min_deg_min = 0;\n\tfloat pitch_trim_rad_min_deg_min = 0;\n\tfloat", "CodeBleu_score": 10.62577550173645}, {"code": "void Copter::save_trim(){\n\t\t// Get the trim values from the roll and pitch channels\n\tfloat roll_trim = _roll_trim_channel->get_control_in();\n\tfloat pitch_trim = _pitch_trim_channel->get_control_in();\n\n\t// Convert the trim values to radians\n\troll_trim *= M_PI_F / 180.0f;\n\tpitch_trim *= M_PI_F / 180.0f;\n\n\t// Add the trim values to the AHRS trim\n\t_ahrs.set_trim_roll_pitch(roll_trim, pitch_trim);\n\n\t// Log the event\n\tmavlink_log_event(\n\t\tMAV_SEVERITY_INFO,\n\t\tMAVLINK_MSG_ID_LOG_MESSAGE,\n\t\t\"Trim saved. Roll trim: %f, Pitch trim: %f\",\n\t\troll_trim,\n\t\tpitch_trim);\n\n\t// Send a confirmation message\n\tmavlink_message_t msg;\n\tmavlink_msg_log_message_send(\n\t\t&msg,\n\t\tMAVLINK_COMM_0,\n\t\tMAVLINK_MSG_ID_LOG_MESSAGE,\n\t\tMAV_SEVERITY_INFO,\n\t\t\"Trim saved. Roll trim: %f, Pitch trim: %f\",\n\t\troll_trim,\n\t\tpitch_trim);\n}", "CodeBleu_score": 48.82198181111583}, {"code": "void Copter::save_trim(){\n\t\t// TODO: implement\n}", "CodeBleu_score": 2.7694730809033348}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat yaw_look_ahead = 0;\n\tfloat speed_squared = 0;\n\tfloat speed_threshold = 0.1;\n\tif (copter.position_valid && (speed_squared = copter.velocity.length_squared()) > speed_threshold) {\n\t\tyaw_look_ahead = atan2(copter.velocity.y, copter.velocity.x);\n\t}\n\treturn yaw_look_ahead;\n}", "CodeBleu_score": 38.84149377035436}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat look_ahead_yaw;\n\tfloat speed_squared;\n\n\tif (copter->position_valid) {\n\t\tspeed_squared = copter->velocity[0] * copter->velocity[0] + copter->velocity[1] * copter->velocity[1];\n\n\t\tif (speed_squared > 0.001) {\n\t\t\tlook_ahead_yaw = atan2f(copter->velocity[1], copter->velocity[0]);\n\t\t}\n\t\telse {\n\t\t\tlook_ahead_yaw = 0;\n\t\t}\n\t}\n\telse {\n\t\tlook_ahead_yaw = 0;\n\t}\n\n\treturn look_ahead_yaw;\n}", "CodeBleu_score": 31.265700982546896}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat look_ahead_yaw = 0.0f;\n\tfloat speed_squared = 0.0f;\n\tfloat speed_squared_threshold = 1.0f;\n\tif (copter.position_valid && (speed_squared = copter.velocity.length_squared()) > speed_squared_threshold) {\n\t\tlook_ahead_yaw = atan2(copter.velocity.y, copter.velocity.x);\n\t}\n\treturn look_ahead_yaw;\n}", "CodeBleu_score": 41.597530504513735}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (rudder_arming_disabled || (throttle_zero &&!throttle_zero_disabled)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 29.259922040602937}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tbool result;\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (rudder_arming_disabled || (throttle > 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tresult = AP_Arming::arm_checks(method);\n\treturn result;\n}", "CodeBleu_score": 35.052162143815515}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// If arming checks are disabled, return true\n\tif (!AP_Arming::arm_checks_enabled) {\n\t\treturn true;\n\t}\n\n\t// If the watchdog was armed, return true\n\tif (AP_Arming::watchdog_armed) {\n\t\treturn true;\n\t}\n\n\t// If the rudder arming is disabled, return true\n\tif (!AP_Arming::rudder_arming_enabled) {\n\t\treturn true;\n\t}\n\n\t// If the throttle is not zero, return false\n\tif (Plane::get_throttle()!= 0) {\n\t\treturn false;\n\t}\n\n\t// If the rudder is not zero, return false\n\tif (Plane::get_rudder()!= 0) {\n\t\treturn false;\n\t}\n\n\t// If the throttle and rudder are zero, return true\n\treturn true;\n}", "CodeBleu_score": 18.225262536889808}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// If we are already armed, don't do anything\n\tif (is_armed()) {\n\t\treturn false;\n\t}\n\n\t// If we are not arming, don't do anything\n\tif (!is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If we are already armed and we are not arming, don't do anything\n\tif (is_armed() &&!is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If we are already armed and we are not arming, don't do anything\n\tif (is_armed() &&!is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If we are already armed and we are not arming, don't do anything\n\tif (is_armed() &&!is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If we are already armed and we are not arming, don't do anything\n\tif (is_armed() &&!is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If we are already armed and we are not arming, don't do anything\n\tif (is_armed() &&!is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If we are already armed and we are not arming, don't do anything\n\tif (is_armed() &&!is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If we are already armed and we are not arming, don't do anything\n\tif (is_armed() &&!is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If we are already armed and we are not arming, don't do anything\n\tif (is_armed() &&!is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If we are already armed and we are not arming, don't do anything\n\tif (is_armed() &&!is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If we are already armed and we are not arming, don't do anything\n\tif (is_armed() &&!is_arming()) {\n\t\treturn false;\n\t", "CodeBleu_score": 26.609035846290684}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// If the plane is already armed, return false\n\tif (is_armed()) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (!AP_Arming::valid_method(method)) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (AP_Arming::is_method_disabled(method)) {\n\t\treturn false;\n\t}\n\n\t// If the plane is not ready, return false\n\tif (!is_ready()) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (AP_Arming::is_method_disabled(method)) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (AP_Arming::is_method_disabled(method)) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (AP_Arming::is_method_disabled(method)) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (AP_Arming::is_method_disabled(method)) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (AP_Arming::is_method_disabled(method)) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (AP_Arming::is_method_disabled(method)) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (AP_Arming::is_method_disabled(method)) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (AP_Arming::is_method_disabled(method)) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n\tif (AP_Arming::is_method_disabled(method)) {\n\t\treturn false;\n\t}\n\n\t// If the arming method is not valid, return false\n", "CodeBleu_score": 27.412351200731568}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (do_arming_checks &&!check_arming_checks()) {\n\t\treturn false;\n\t}\n\n\t// set home location\n\t_ahrs.set_home_location(_ahrs.get_position());\n\n\t// set current location\n\t_ahrs.set_current_location(_ahrs.get_position());\n\n\t// arm\n\tif (method == AP_Arming::METHOD_BARO) {\n\t\t_ahrs.set_baro_mode(true);\n\t} else if (method == AP_Arming::METHOD_GPS) {\n\t\t_ahrs.set_gps_mode(true);\n\t} else if (method == AP_Arming::METHOD_AIRSPEED) {\n\t\t_ahrs.set_airspeed_mode(true);\n\t} else if (method == AP_Arming::METHOD_HIL) {\n\t\t_ahrs.set_hil_mode(true);\n\t} else if (method == AP_Arming::METHOD_LOITER) {\n\t\t_ahrs.set_loiter_mode(true);\n\t} else if (method == AP_Arming::METHOD_STABILIZE) {\n\t\t_ahrs.set_stabilize_mode(true);\n\t}\n\n\t// arm state\n\t_arm_state = ARMING_STATE_ARMED;\n\n\t// delay arm\n\t_delay_arm = true;\n\n\t// send status text\n\t_status_text.set_text(AP_MSG_ARMED);\n\n\t// return success\n\treturn true;\n}", "CodeBleu_score": 38.03326208546935}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 29.592044536541835}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (AP_Arming::pre_arm_checks(display_failure)) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 37.21109882562806}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (AP_Arming::pre_arm_checks(display_failure)) {\n\t\treturn true;\n\t}\n\n\tif (Sub::get_instance()->get_disarm_button_index() == 0) {\n\t\tif (display_failure) {\n\t\t\tSub::get_instance()->get_console()->printf_P(PSTR(\"Disarm button not configured.\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 56.2041532975651}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x*cos(yaw) + y*sin(yaw);\n\tfloat ne_y = -x*sin(yaw) + y*cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 53.08718821813907}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\t// Calculate the new coordinates in the North-East frame\n\tfloat ne_x = x * cos(yaw) + y * sin(yaw);\n\tfloat ne_y = -x * sin(yaw) + y * cos(yaw);\n\n\t// Update the coordinates in the body frame\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 53.15911508077199}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * cos(yaw) + y * sin(yaw);\n\tfloat ne_y = -x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 53.18204260260693}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// check if yaw angle and param4 values are within acceptable ranges\n\tif (fabsf(packet.param1) <= 180.0f && fabsf(packet.param4) <= 180.0f) {\n\t\t// set yaw heading using the provided parameters\n\t\t_yaw_heading = packet.param1;\n\t\t_yaw_heading_rate = packet.param4;\n\t\t// return MAV_RESULT_ACCEPTED\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\t// if not valid, return MAV_RESULT_DENIED\n\treturn MAV_RESULT_DENIED;\n}", "CodeBleu_score": 38.66313605980402}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if yaw angle and param4 values are within acceptable ranges\n\tif (AP_Math::within_limits(packet.param4, -180.0f, 180.0f) && AP_Math::within_limits(packet.param1, -180.0f, 180.0f)) {\n\t\t// If valid, set the yaw heading using the provided parameters\n\t\t_yaw_heading = packet.param1;\n\t\t_yaw_heading_set = true;\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\t// If not valid, return MAV_RESULT_DENIED\n\treturn MAV_RESULT_DENIED;\n}", "CodeBleu_score": 35.42399829057465}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if yaw angle is within acceptable range\n\tif (packet.param4 < -180 || packet.param4 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if yaw rate is within acceptable range\n\tif (packet.param5 < -100 || packet.param5 > 100) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set yaw heading using provided parameters\n\t_yaw_heading = packet.param4;\n\t_yaw_rate = packet.param5;\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 42.07581041634816}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (_control_mode == AP_MODE_AUTO || _control_mode == AP_MODE_GUIDED) {\n\t\treturn (uint8_t) ((_wp_bearing / 2) & 0xff);\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 34.68001714349723}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n\t\treturn (uint8_t)((int16_t)high_latency_tgt_bearing / 2);\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 34.87056570801242}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (_control_mode == AP_Mode::ControlMode::AUTO || _control_mode == AP_Mode::ControlMode::GUIDED) {\n\t\treturn (uint8_t) ((int32_t) _target_bearing / 2);\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 38.6462330891837}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (Logging_Enabled) {\n\t\tLogPacket packet;\n\t\tpacket.time = HAL_GetTick();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tpacket.type = LogPacketType::DATA;\n\t\tpacket.data_size = 4;\n\t\tpacket.data = (uint8_t*) &value;\n\t\tpacket.crc = packet.Get_CRC();\n\t\tpacket.crc_size = 2;\n\t\tpacket.crc_data = (uint8_t*) &packet.crc;\n\t\tpacket.crc_data_size = 2;\n\t\tpacket.data_size = 4;\n\t\tpacket.data_size_size = 1;\n\t\tpacket.data_size_data = (uint8_t*) &packet.data_size;\n\t\tpacket.data_size_data_size = 1;\n\t\tpacket.data_size_data_size_size = 1;\n\t\tpacket.data_size_data_size_data = (uint8_t*) &packet.data_size_data_size;\n\t\tpacket.data_size_data_size_data_size = 1;\n\t\tpacket.data_size_data_size_data_size_data = (uint8_t*) &packet.data_size_data_size_data_size;\n\t\tpacket.data_size_data_size_data_size_data_size = 1;\n\t\tpacket.data_size_data_size_data_size_data_size_data = (uint8_t*) &packet.data_size_data_size_data_size_data_size;\n\t\tpacket.data_size_data_size_data_size_data_size_data_size = 1;\n\t\tpacket.data_size_data_size_data_size_data_size_data_size_data = (uint8_t*) &packet.data_size_data_size_data_size_data_size_data_size;\n\t\tpacket.data_size_data_size_data_size_data_size_data_size_data_size = 1;\n\t\tpacket.data_size_data_size_data_size_data_size_data_size_data_size", "CodeBleu_score": 33.33314619337738}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (this->log_enabled) {\n\t\tthis->logger.Log_Write_Data(id, value);\n\t}\n}", "CodeBleu_score": 24.226120378119912}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (logging_enabled) {\n\t\tLog_Packet packet;\n\t\tpacket.time = HAL_GetTick();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tLog_Write_Packet(packet);\n\t}\n}", "CodeBleu_score": 36.598135216267345}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (_home_set) {\n\t\treturn;\n\t}\n\n\tif (_armed) {\n\t\t_home_set = true;\n\t\t_home_lat = _ekf_gps_data.lat;\n\t\t_home_lon = _ekf_gps_data.lon;\n\t\t_home_alt = _ekf_gps_data.alt;\n\t} else {\n\t\t_home_set = true;\n\t\t_home_lat = _ekf_gps_data.lat;\n\t\t_home_lon = _ekf_gps_data.lon;\n\t\t_home_alt = _ekf_gps_data.alt;\n\t}\n}", "CodeBleu_score": 16.44510680043546}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_set) {\n\t\treturn;\n\t}\n\tif (armed) {\n\t\thome_set = true;\n\t\thome_lat = EKF.lat;\n\t\thome_lon = EKF.lon;\n\t\thome_alt = EKF.alt;\n\t\thome_time = EKF.time_gps_usec;\n\t} else {\n\t\thome_set = EKF.home_set;\n\t\thome_lat = EKF.home_lat;\n\t\thome_lon = EKF.home_lon;\n\t\thome_alt = EKF.home_alt;\n\t\thome_time = EKF.home_time;\n\t}\n}", "CodeBleu_score": 16.472880635499845}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (_home_set) {\n\t\treturn;\n\t}\n\n\tif (_armed) {\n\t\t_home_set = true;\n\t\t_home_lat = _ekf_data.lat;\n\t\t_home_lon = _ekf_data.lon;\n\t\t_home_alt = _ekf_data.alt;\n\t} else {\n\t\t_home_set = _ekf_data.home_set;\n\t\t_home_lat = _ekf_data.home_lat;\n\t\t_home_lon = _ekf_data.home_lon;\n\t\t_home_alt = _ekf_data.home_alt;\n\t}\n}", "CodeBleu_score": 16.406558590556134}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\t//If the motors are not armed, set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit.\n\tif (motors.armed == false) {\n\t\tmotors.setThrottle(0);\n\t\tmotors.setSpoolState(SPOOL_UNLIMITED);\n\t\tattitude.relax();\n\t\treturn;\n\t}\n\n\t//If armed, set the spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run the attitude controller with these rates.\n\tmotors.setSpoolState(SPOOL_UNLIMITED);\n\tattitude.setDesiredRates(pilot.getRollRate(), pilot.getPitchRate(), pilot.getYawRate());\n\tattitude.run();\n\n\t//Output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls.\n\tmotors.setThrottle(pilot.getThrottle());\n\tmotors.setForward(pilot.getForward());\n\tmotors.setLateral(pilot.getLateral());\n}", "CodeBleu_score": 37.93094918045336}, {"code": "void ModeAcro::run(){\n\t\t// If the motors are not armed, set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit.\n\tif (!motorsArmed ) {\n\t\tthrottle = 0;\n\t\tspoolState = SpoolState::UnlimitedThrottle;\n\t\trelaxAttitudeControllers();\n\t\treturn;\n\t}\n\n\t// If armed, set the spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run the attitude controller with these rates.\n\tspoolState = SpoolState::UnlimitedThrottle;\n\tdesiredBodyRates.x = pilotInputs.x;\n\tdesiredBodyRates.y = pilotInputs.y;\n\tdesiredBodyRates.z = pilotInputs.z;\n\trunAttitudeController();\n\n\t// Output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls.\n\tthrottle = pilotInputs.throttle;\n\tmotorInputs.x = pilotInputs.x;\n\tmotorInputs.y = pilotInputs.y;\n}", "CodeBleu_score": 34.77002405189107}, {"code": "void ModeAcro::run(){\n\t\t// If not armed, set throttle to zero, adjust spool state, relax attitude controllers, and exit\n\tif (!armed) {\n\t\tthrottle = 0;\n\t\tsetSpoolState(SPOOL_STATE_UNLIMITED_THROTTLE);\n\t\trelaxAttitudeControllers();\n\t\treturn;\n\t}\n\t// If armed, set spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run attitude controller with these rates\n\tsetSpoolState(SPOOL_STATE_UNLIMITED_THROTTLE);\n\tfloat pilotThrottle = pilotInput.throttle;\n\tpilotThrottle = pilotThrottle - angleBoost;\n\tif (pilotThrottle < 0)\n\t\tpilotThrottle = 0;\n\tif (pilotThrottle > 1)\n\t\tpilotThrottle = 1;\n\tfloat pilotYaw = pilotInput.yaw;\n\tfloat pilotPitch = pilotInput.pitch;\n\tfloat pilotRoll = pilotInput.roll;\n\tfloat pilotForward = pilotInput.forward;\n\tfloat pilotLateral = pilotInput.lateral;\n\tfloat pilotVertical = pilotInput.vertical;\n\tfloat pilotYawRate = pilotYaw * 2 * M_PI / 1000;\n\tfloat pilotPitchRate = pilotPitch * 2 * M_PI / 1000;\n\tfloat pilotRollRate = pilotRoll * 2 * M_PI / 1000;\n\tfloat pilotForwardRate = pilotForward * 2 * M_PI / 1000;\n\tfloat pilotLateralRate = pilotLateral * 2 * M_PI / 1000;\n\tfloat pilotVerticalRate = pilotVertical * 2 * M_PI / 1000;\n\tfloat pilotYawRateDesired = pilotYawRate;\n\tfloat pilotPitchRateDesired = pilotPitchRate;\n\tfloat pilotRollRateDesired = pilotRollRate;\n\tfloat pilotForwardRateDesired = pilotForwardRate;\n\tfloat pilotLateralRateDesired = pilotLateralRate;\n\tfloat pilotVerticalRateDesired = pilotVerticalRate", "CodeBleu_score": 37.70365020139893}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set the mode to position control\n\tset_mode(Mode::PositionControl);\n\n\t// Initialize the waypoint controller\n\twaypoint_controller.init();\n\n\t// Get the stopping point\n\twaypoint_controller.get_stopping_point();\n\n\t// Set the stopping point as the waypoint destination\n\twaypoint_controller.set_waypoint_destination(waypoint_controller.get_stopping_point());\n\n\t// Initialize yaw using default auto yaw mode\n\tauto_yaw.init();\n}", "CodeBleu_score": 29.896981718856757}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set the mode to position control mode\n\t_mode = GUIDED_POS_CONTROL;\n\t// Set the waypoint destination to the stopping point\n\t_waypoint_controller.set_waypoint_destination(_stopping_point);\n\t// Initialize yaw using default auto yaw mode\n\t_yaw_controller.initialize_auto_yaw_mode();\n}", "CodeBleu_score": 13.590525738934458}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set mode to position control\n\tset_mode(Mode::PositionControl);\n\t// set waypoint destination\n\twaypoint_controller->set_destination(stopping_point);\n\t// set yaw mode to auto\n\tset_yaw_mode(YawMode::Auto);\n}", "CodeBleu_score": 11.132419384314291}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Initialize vertical maximum speeds and acceleration using pilot-defined parameters\n\t_vertical_max_speed_up = _parameters.get<float>(\"GUIDED_VERTICAL_MAX_SPEED_UP\");\n\t_vertical_max_speed_down = _parameters.get<float>(\"GUIDED_VERTICAL_MAX_SPEED_DOWN\");\n\t_vertical_acceleration = _parameters.get<float>(\"GUIDED_VERTICAL_ACCELERATION\");\n\t_vertical_max_speed_up = constrain_float(_vertical_max_speed_up, 0.0f, 10.0f);\n\t_vertical_max_speed_down = constrain_float(_vertical_max_speed_down, 0.0f, 10.0f);\n\t_vertical_acceleration = constrain_float(_vertical_acceleration, 0.0f, 10.0f);\n\n\t// Initialize the vertical velocity controller\n\t_vertical_velocity_controller.set_parameters(_vertical_max_speed_up, _vertical_max_speed_down, _vertical_acceleration);\n\n\t// Initialize the horizontal velocity controller\n\t_horizontal_velocity_controller.set_parameters(_parameters.get<float>(\"GUIDED_HORIZONTAL_MAX_SPEED\"), _parameters.get<float>(\"GUIDED_HORIZONTAL_ACCELERATION\"));\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\t_yaw_control_mode = YawControlMode::AUTO_YAW_HOLD;\n}", "CodeBleu_score": 39.80546642460985}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set the guided mode to velocity controller.\n\tguided_mode = GUIDED_MODE_VELOCITY;\n\n\t// Initialize vertical maximum speeds and acceleration using pilot-defined parameters.\n\tguided_max_vertical_speed = pilot_max_vertical_speed;\n\tguided_max_vertical_accel = pilot_max_vertical_accel;\n\n\t// Initialize the vertical and horizontal velocity controllers.\n\tguided_vertical_vel_control.init(guided_max_vertical_speed, guided_max_vertical_accel);\n\tguided_horizontal_vel_control.init(guided_max_horizontal_speed, guided_max_horizontal_accel);\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw.\n\tguided_yaw_control_mode = AUTO_YAW_HOLD;\n}", "CodeBleu_score": 27.53059383723192}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set guided mode to velocity controller\n\t_mode_guided = true;\n\n\t// Initialize vertical maximum speeds and acceleration using pilot-defined parameters\n\t_guided_vel_z_max = _params->get_guided_vel_z_max();\n\t_guided_vel_z_accel = _params->get_guided_vel_z_accel();\n\n\t// Initialize vertical and horizontal velocity controllers\n\t_guided_vel_z_controller.set_max_speed(_guided_vel_z_max);\n\t_guided_vel_z_controller.set_max_accel(_guided_vel_z_accel);\n\n\t_guided_vel_xy_controller.set_max_speed(_params->get_guided_vel_xy_max());\n\t_guided_vel_xy_controller.set_max_accel(_params->get_guided_vel_xy_accel());\n\n\t// Set yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\t_yaw_control_mode = YawControlMode::AUTO_YAW_HOLD;\n}", "CodeBleu_score": 41.90426673508913}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// TODO: implement guided_limit_check()\n\treturn false;\n}", "CodeBleu_score": 2.0176401258941974}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if timeout has been exceeded\n\tif (millis() - _startTime > _timeout) {\n\t\t// Timeout has been exceeded\n\t\treturn true;\n\t}\n\n\t// Check if altitude is within limits\n\tif (_altitude < _minAltitude || _altitude > _maxAltitude) {\n\t\t// Altitude is outside of limits\n\t\treturn true;\n\t}\n\n\t// Check if horizontal distance moved exceeds limit\n\tif (sqrt(pow(_x, 2) + pow(_y, 2)) > _maxDistance) {\n\t\t// Horizontal distance moved exceeds limit\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false\n\treturn false;\n}", "CodeBleu_score": 17.71886718248306}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tbool ret = false;\n\t// Check if the timeout has been exceeded\n\tif (millis() - _start_time > _timeout_ms) {\n\t\tret = true;\n\t\t_state = GUIDED_TIMEOUT;\n\t}\n\n\t// Check if the current altitude is below the minimum threshold\n\tif (_current_altitude < _min_altitude) {\n\t\tret = true;\n\t\t_state = GUIDED_MIN_ALTITUDE;\n\t}\n\n\t// Check if the current altitude is above the maximum threshold\n\tif (_current_altitude > _max_altitude) {\n\t\tret = true;\n\t\t_state = GUIDED_MAX_ALTITUDE;\n\t}\n\n\t// Check if the horizontal distance moved exceeds the specified limit\n\tif (_current_distance > _max_distance) {\n\t\tret = true;\n\t\t_state = GUIDED_MAX_DISTANCE;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 24.013585408265943}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\t// Check if the motor test has been enabled\n\tif (motor_test_enabled) {\n\t\t// Check if the motor test has been armed\n\t\tif (motor_test_armed) {\n\t\t\t// Check if the motor test has been started\n\t\t\tif (motor_test_started) {\n\t\t\t\t// Check if the motor test has been completed\n\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t// Check if the motor test has been failed\n\t\t\t\t\tif (motor_test_failed) {\n\t\t\t\t\t\t// Check if the motor test has been completed\n\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t// Check if the motor test has been passed\n\t\t\t\t\t\t\tif (motor_test_passed) {\n\t\t\t\t\t\t\t\t// Check if the motor test has been completed\n\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t// Check if the motor test has been failed\n\t\t\t\t\t\t\t\t\tif (motor_test_failed) {\n\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been completed\n\t\t\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been passed\n\t\t\t\t\t\t\t\t\t\t\tif (motor_test_passed) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been completed\n\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been failed\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_failed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been completed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been passed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_passed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been completed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been failed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_failed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been completed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been passed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_passed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been completed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been failed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_failed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been completed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the motor test has been passed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_", "CodeBleu_score": 31.147564504989845}, {"code": "bool Sub::verify_motor_test(){\n\t\t// If the motor test is not enabled, return true\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// If the motor test is enabled, check if the requests are received at least every 2 Hz\n\tif (motor_test_requests.size() < 2) {\n\t\t// If the requests are not received at least every 2 Hz, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false\n\t\tsend_timeout_message(motor_test_id);\n\t\tmotor_test_pass = false;\n\t\tmotor_test_enabled = false;\n\t\tdisarm();\n\t\trecord_failure_time(motor_test_id);\n\t\treturn false;\n\t}\n\n\t// If the requests are received at least every 2 Hz, return true\n\treturn true;\n}", "CodeBleu_score": 42.45474013696155}, {"code": "bool Sub::verify_motor_test(){\n\t\t//Check if the motor test has been enabled\n\tif (motor_test_enabled) {\n\t\t//Check if the motor test has been armed\n\t\tif (motor_test_armed) {\n\t\t\t//Check if the motor test has been disarmed\n\t\t\tif (motor_test_disarmed) {\n\t\t\t\t//Check if the motor test has been disabled\n\t\t\t\tif (motor_test_disabled) {\n\t\t\t\t\t//Check if the motor test has been started\n\t\t\t\t\tif (motor_test_started) {\n\t\t\t\t\t\t//Check if the motor test has been stopped\n\t\t\t\t\t\tif (motor_test_stopped) {\n\t\t\t\t\t\t\t//Check if the motor test has been completed\n\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t//Check if the motor test has been verified\n\t\t\t\t\t\t\t\tif (motor_test_verified) {\n\t\t\t\t\t\t\t\t\t//Check if the motor test has been failed\n\t\t\t\t\t\t\t\t\tif (motor_test_failed) {\n\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been timed out\n\t\t\t\t\t\t\t\t\t\tif (motor_test_timed_out) {\n\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been completed\n\t\t\t\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been verified\n\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_verified) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been failed\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_failed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been timed out\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_timed_out) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been completed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been verified\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_verified) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been failed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_failed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been timed out\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_timed_out) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been completed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_completed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been verified\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_verified) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been failed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_failed) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Check if the motor test has been timed out\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_timed_out) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Check", "CodeBleu_score": 31.315033231600363}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// TODO: implement translate_wpnav_rp\n}", "CodeBleu_score": 3.647387792519552}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll = wp_nav.roll;\n\tfloat pitch = wp_nav.pitch;\n\tif (roll > 180) {\n\t\troll -= 360;\n\t}\n\tif (pitch > 180) {\n\t\tpitch -= 360;\n\t}\n\troll = constrain(roll, -max_roll, max_roll);\n\tpitch = constrain(pitch, -max_pitch, max_pitch);\n\tlateral_out = roll / max_roll;\n\tforward_out = pitch / max_pitch;\n}", "CodeBleu_score": 36.76991965499094}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Get the roll and pitch targets from wp_nav\n\tfloat roll_target = wp_nav.roll_target;\n\tfloat pitch_target = wp_nav.pitch_target;\n\n\t// Constrain the roll and pitch targets within the specified maximum angle range\n\troll_target = constrain_angle(roll_target, max_roll_angle);\n\tpitch_target = constrain_angle(pitch_target, max_pitch_angle);\n\n\t// Normalize the roll and pitch targets\n\troll_target = normalize_angle(roll_target);\n\tpitch_target = normalize_angle(pitch_target);\n\n\t// Assign the normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 37.27531634329142}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// read the barometer data\n\tbarometer.read_barometer();\n\n\t// update the barometer calibration\n\tif (altitude_valid() && barometer.altitude_valid()) {\n\t\tbarometer.update_calibration();\n\t}\n\n\t// update the sensor health status\n\tif (depth_sensor_present()) {\n\t\tbarometer.update_sensor_health();\n\t}\n}", "CodeBleu_score": 45.99478166577307}, {"code": "void Sub::read_barometer(){\n\t\t// Read the barometer\n\tbarometer.read();\n\n\t// If the altitude is above zero, update the barometer calibration\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.calibrate(barometer.get_altitude());\n\t}\n\n\t// If a depth sensor is present, update the sensor health status based on the barometer's health\n\tif (depth_sensor!= NULL) {\n\t\tdepth_sensor->set_health(barometer.get_health());\n\t}\n}", "CodeBleu_score": 55.89406500810581}, {"code": "void Sub::read_barometer(){\n\t\t// TODO: Add code to read the barometer\n\tif (altitude > 0) {\n\t\tbarometer_calibration = altitude;\n\t}\n\tif (depth_sensor_present) {\n\t\tif (barometer_health == 0) {\n\t\t\tbarometer_health = 1;\n\t\t}\n\t}\n}", "CodeBleu_score": 27.50156857419167}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\treturn false;\n}", "CodeBleu_score": 5.492678133447096}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// TODO: implement\n\treturn false;\n}", "CodeBleu_score": 5.492677746086194}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (_ahrs == NULL) {\n\t\treturn false;\n\t}\n\n\tif (_ahrs->get_inertial_nav_state()!= INAV_STATE_NONE) {\n\t\treturn false;\n\t}\n\n\tif (!_motors->armed()) {\n\t\treturn true;\n\t}\n\n\tif (_ahrs->get_inertial_nav_state() == INAV_STATE_POS_HOLD) {\n\t\treturn false;\n\t}\n\n\tif (!_ahrs->get_inertial_nav_state() == INAV_STATE_POS_HOLD_YAW_HOLD) {\n\t\treturn false;\n\t}\n\n\tif (_ahrs->get_inertial_nav_state() == INAV_STATE_POS_HOLD_YAW_HOLD_ALT) {\n\t\treturn false;\n\t}\n\n\tif (_ahrs->get_inertial_nav_state() == INAV_STATE_POS_HOLD_YAW_HOLD_ALT_HOLD) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 47.89684468598728}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if the AHRS system is ready\n\tif (!ahrs.system_ready()) {\n\t\tif (display_failure) {\n\t\t\t_failure_reason = \"AHRS system not ready\";\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if the EKF failsafe is active\n\tif (ekf.get_fail_state()!= FAILSAFE_NONE) {\n\t\tif (display_failure) {\n\t\t\t_failure_reason = \"EKF failsafe active\";\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if the position estimate is valid\n\tif (!ahrs.position_ok()) {\n\t\tif (display_failure) {\n\t\t\t_failure_reason = \"Position estimate not valid\";\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 41.35255761832056}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// Check if the GPS is ready\n\tif (!AP_InertialSensor::gps->ready) {\n\t\tif (display_failure) {\n\t\t\t_display->printf_P(PSTR(\"GPS not ready\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Check if the EKF failsafe is active\n\tif (AP_InertialSensor::gps->ekf_fail_safe) {\n\t\tif (display_failure) {\n\t\t\t_display->printf_P(PSTR(\"EKF failsafe\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Check if the position estimate is valid\n\tif (!AP_InertialSensor::gps->position_ok) {\n\t\tif (display_failure) {\n\t\t\t_display->printf_P(PSTR(\"Position estimate invalid\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Call the parent class's GPS checks\n\tif (!AP_Arming_Acro::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// If we get here, all checks passed\n\treturn true;\n}", "CodeBleu_score": 42.09047256027307}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// Check the AHRS system is ready\n\tif (!ahrs.is_ready()) {\n\t\tif (display_failure) {\n\t\t\tdisplay_failure_message(AP_MSG_GPS_AHRS_FAIL);\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Check the EKF failsafe is not active\n\tif (ekf_failsafe_active) {\n\t\tif (display_failure) {\n\t\t\tdisplay_failure_message(AP_MSG_GPS_EKF_FAILSAFE);\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Check the EKF is healthy\n\tif (!ekf.healthy()) {\n\t\tif (display_failure) {\n\t\t\tdisplay_failure_message(AP_MSG_GPS_EKF_FAIL);\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Check the EKF position estimate is valid\n\tif (!ekf.valid_pos()) {\n\t\tif (display_failure) {\n\t\t\tdisplay_failure_message(AP_MSG_GPS_EKF_POS_FAIL);\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Check the EKF velocity estimate is valid\n\tif (!ekf.valid_vel()) {\n\t\tif (display_failure) {\n\t\t\tdisplay_failure_message(AP_MSG_GPS_EKF_VEL_FAIL);\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 34.965350348624725}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// If we are already armed, do nothing\n\tif (_armed) {\n\t\treturn true;\n\t}\n\n\t// If we are already disarmed, do nothing\n\tif (!_armed) {\n\t\treturn true;\n\t}\n\n\t// If we are already arming, do nothing\n\tif (_arming) {\n\t\treturn true;\n\t}\n\n\t// If we are already disarming, do nothing\n\tif (_disarming) {\n\t\treturn true;\n\t}\n\n\t// If we are already arming, do nothing\n\tif (_arming) {\n\t\treturn true;\n\t}\n\n\t// If we are already disarming, do nothing\n\tif (_disarming) {\n\t\treturn true;\n\t}\n\n\t// If we are already arming, do nothing\n\tif (_arming) {\n\t\treturn true;\n\t}\n\n\t// If we are already disarming, do nothing\n\tif (_disarming) {\n\t\treturn true;\n\t}\n\n\t// If we are already arming, do nothing\n\tif (_arming) {\n\t\treturn true;\n\t}\n\n\t// If we are already disarming, do nothing\n\tif (_disarming) {\n\t\treturn true;\n\t}\n\n\t// If we are already arming, do nothing\n\tif (_arming) {\n\t\treturn true;\n\t}\n\n\t// If we are already disarming, do nothing\n\tif (_disarming) {\n\t\treturn true;\n\t}\n\n\t// If we are already arming, do nothing\n\tif (_arming) {\n\t\treturn true;\n\t}\n\n\t// If we are already disarming, do nothing\n\tif (_disarming) {\n\t\treturn true;\n\t}\n\n\t// If we are already arming, do nothing\n\tif (_arming) {\n\t\treturn true;\n\t}\n\n\t// If we are already disarming, do nothing\n\tif (_disarming) {\n\t\treturn true;\n\t}\n\n\t// If we are already arming, do nothing\n\tif (_arming) {\n\t\treturn true;\n\t}\n\n\t// If we are already disarming, do nothing\n\tif (_disarming) {", "CodeBleu_score": 27.461062771802048}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool success = false;\n\n\t// Check if we are already armed\n\tif (is_armed()) {\n\t\t// If we are already armed, we should not be here\n\t\t// This is a programming error\n\t\t// Do not arm\n\t\treturn false;\n\t}\n\n\t// Check if we are already disarmed\n\tif (is_disarmed()) {\n\t\t// If we are already disarmed, we should not be here\n\t\t// This is a programming error\n\t\t// Do not arm\n\t\treturn false;\n\t}\n\n\t// Check if we are already arming\n\tif (is_arming()) {\n\t\t// If we are already arming, we should not be here\n\t\t// This is a programming error\n\t\t// Do not arm\n\t\treturn false;\n\t}\n\n\t// Check if we are already disarming\n\tif (is_disarming()) {\n\t\t// If we are already disarming, we should not be here\n\t\t// This is a programming error\n\t\t// Do not arm\n\t\treturn false;\n\t}\n\n\t// Check if we are already arming_failed\n\tif (is_arming_failed()) {\n\t\t// If we are already arming_failed, we should not be here\n\t\t// This is a programming error\n\t\t// Do not arm\n\t\treturn false;\n\t}\n\n\t// Check if we are already arming_failed\n\tif (is_disarming_failed()) {\n\t\t// If we are already disarming_failed, we should not be here\n\t\t// This is a programming error\n\t\t// Do not arm\n\t\treturn false;\n\t}\n\n\t// Check if we are already arming_failed\n\tif (is_armed_failed()) {\n\t\t// If we are already arming_failed, we should not be here\n\t\t// This is a programming error\n\t\t// Do not arm\n\t\treturn false;\n\t}\n\n\t// Check if we are already disarming_failed\n\tif (is_disarmed_failed()) {\n\t\t// If we are already disarming_failed, we should not be here\n\t\t// This is a programming error\n\t\t// Do not arm\n\t\treturn false;\n\t}\n\n\t// Check if we are already arming_failed\n\tif", "CodeBleu_score": 15.559465940360484}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// Check for valid arming method\n\tif (method < AP_Arming::NUM_METHODS) {\n\t\t// Check for valid arming method\n\t\tif (method == AP_Arming::METHOD_RTL) {\n\t\t\t// Check for valid arming method\n\t\t\tif (do_arming_checks) {\n\t\t\t\t// Check for valid arming method\n\t\t\t\tif (is_armed()) {\n\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (is_disarmed()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check for valid arming method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "CodeBleu_score": 26.71526308772771}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tstatic uint32_t last_retry = 0;\n\tstatic bool last_allowed = false;\n\tstatic bool last_enabled = false;\n\n\tif (charging_allowed) {\n\t\tif (!last_enabled) {\n\t\t\t// Enable charging\n\t\t\tdigitalWrite(PIN_CHARGING_ENABLE, HIGH);\n\t\t\tlast_enabled = true;\n\t\t\tlast_retry = 0;\n\t\t\tlast_allowed = true;\n\t\t\tSerial.println(\"Charging enabled\");\n\t\t}\n\t} else {\n\t\tif (last_enabled) {\n\t\t\t// Disable charging\n\t\t\tdigitalWrite(PIN_CHARGING_ENABLE, LOW);\n\t\t\tlast_enabled = false;\n\t\t\tlast_retry = 0;\n\t\t\tlast_allowed = false;\n\t\t\tSerial.println(\"Charging disabled\");\n\t\t}\n\t}\n\n\tif (last_allowed!= charging_allowed) {\n\t\t// If the allowed state changed, reset the retry timer\n\t\tlast_retry = millis();\n\t}\n\n\tif (charging_allowed &&!last_allowed) {\n\t\t// If the allowed state changed and the last state was not allowed, retry enabling charging\n\t\tif (millis() - last_retry > 5000) {\n\t\t\tdigitalWrite(PIN_CHARGING_ENABLE, HIGH);\n\t\t\tlast_retry = millis();\n\t\t\tSerial.println(\"Retrying charging enabled\");\n\t\t}\n\t}\n}", "CodeBleu_score": 55.49173007933143}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tif (!charging_allowed_at_start) {\n\t\t\t\tcharging_enabled_at_start = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (charging_allowed_at_start) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_allowed_at_start = false;\n\t\t\t\tcharging_enabled_at = millis();\n\t\t\t} else {\n\t\t\t\tif (millis() - charging_enabled_at > 10000) {\n\t\t\t\t\tcharging_enabled = true;\n\t\t\t\t\tcharging_allowed_at_start = false;\n\t\t\t\t\tcharging_enabled_at = millis();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_enabled_at_start = false;\n\t\t} else {\n\t\t\tif (charging_enabled_at_start) {\n\t\t\t\tcharging_enabled_at_start = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 48.00207175369648}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tif (!charging_allowed) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_disabled_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (charging_allowed && millis() - charging_disabled_time > charging_retry_delay) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.245010302417235}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros_running) {\n\t\tuint8_t *message_ptr = (uint8_t *) message;\n\t\tFastCRC16 crc;\n\t\tcrc.reset();\n\t\tcrc.update(message_ptr, size);\n\t\tuint16_t crc16 = crc.get();\n\t\tuint8_t crc_low = crc16 & 0x00FF;\n\t\tuint8_t crc_high = (crc16 & 0xFF00) >> 8;\n\t\tpacketSerial.write(message_ptr, size);\n\t\tpacketSerial.write(crc_low);\n\t\tpacketSerial.write(crc_high);\n\t}\n}", "CodeBleu_score": 42.53128156141385}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::running() && size >= 4) {\n\t\tFastCRC16 crc;\n\t\tuint16_t crc_value = crc.crc16((uint8_t *) message, size);\n\t\tmemcpy(((uint8_t *) message) + size, &crc_value, 2);\n\t\tpacketSerial.send((uint8_t *) message, size + 2);\n\t}\n}", "CodeBleu_score": 44.1792021943271}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros_running && size >= 4) {\n\t\tFastCRC16 crc16;\n\t\tuint8_t *msg = (uint8_t *) message;\n\t\tuint16_t crc = crc16.crc16(msg, size - 2);\n\t\tmsg[size - 2] = crc >> 8;\n\t\tmsg[size - 1] = crc & 0xFF;\n\t\tpacketSerial.send(msg, size);\n\t}\n}", "CodeBleu_score": 54.3002556064456}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\t// Initialize the serial communication for the sound module\n\tSerial1.begin(9600);\n\n\t// Clear any existing data in the buffer\n\twhile (Serial1.available()) {\n\t\tSerial1.read();\n\t}\n\n\t// Initialize the sound module and retrieve the number of sound files available on the SD card\n\tSerial1.print(\"init\n\");\n\tdelay(1000);\n\twhile (Serial1.available() == 0);\n\tnum_sounds = Serial1.parseInt();\n\n\t// Return true if there are one or more sound files available, indicating successful initialization\n\tif (num_sounds > 0) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 48.066638966880944}, {"code": "bool MP3Sound::begin(){\n\t\tSerial.begin(115200);\n\tdelay(100);\n\tSerial.println(\"begin\");\n\tdelay(100);\n\tif (!SD.begin(SD_CS_PIN)) {\n\t\tSerial.println(\"SD Card initialization failed!\");\n\t\treturn false;\n\t}\n\tdelay(100);\n\tSerial.println(\"SD Card initialized.\");\n\tdelay(100);\n\tif (!soundSystem.begin()) {\n\t\tSerial.println(\"Sound module initialization failed!\");\n\t\treturn false;\n\t}\n\tdelay(100);\n\tSerial.println(\"Sound module initialized.\");\n\tdelay(100);\n\tsoundSystem.clearBuffer();\n\tdelay(100);\n\tSerial.println(\"Buffer cleared.\");\n\tdelay(100);\n\treturn true;\n}", "CodeBleu_score": 44.72850614003148}, {"code": "bool MP3Sound::begin(){\n\t\tSerial.begin(9600);\n\tSerial.println(\"Initializing MP3 Sound Module\");\n\tSerial.println(\"Clearing buffer\");\n\tbuffer.clear();\n\tSerial.println(\"Initializing sound module\");\n\tif (init() == 0) {\n\t\tSerial.println(\"Sound module initialized\");\n\t\tSerial.print(\"Number of files: \");\n\t\tSerial.println(numFiles());\n\t\treturn true;\n\t}\n\telse {\n\t\tSerial.println(\"Sound module initialization failed\");\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 38.777084124967985}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tint numActiveSounds = activeSounds.size();\n\tif (numActiveSounds == 0) {\n\t\treturn numActiveSounds;\n\t}\n\tif (isPlaying) {\n\t\treturn numActiveSounds;\n\t}\n\tSound* sound = activeSounds.back();\n\tactiveSounds.pop_back();\n\tsound->play();\n\treturn numActiveSounds - 1;\n}", "CodeBleu_score": 47.26132996206535}, {"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (mp3IsPlaying) {\n\t\treturn activeSounds.size();\n\t}\n\t//if an MP3 is not playing, get the last sound in the list and play it\n\tSound* sound = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplaySound(sound);\n\treturn activeSounds.size();\n}", "CodeBleu_score": 39.907331621254826}, {"code": "int MP3Sound::processSounds(){\n\t\tint activeSounds = 0;\n\tif (mp3Player.isPlaying() == false) {\n\t\tif (activeSoundsList.size() > 0) {\n\t\t\tSound* sound = activeSoundsList.back();\n\t\t\tactiveSoundsList.pop_back();\n\t\t\tactiveSounds--;\n\t\t\tmp3Player.play(sound->getFilename());\n\t\t\tdelete sound;\n\t\t}\n\t}\n\treturn activeSounds;\n}", "CodeBleu_score": 42.17337260903099}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef __linux__\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    WbAbstractCamera *camera = (WbAbstractCamera *)d;\n    if (camera->file_mapped) {\n      wb_camera_unmap_file(camera->file_mapped);\n      camera->file_mapped = NULL;\n    }\n    camera->file_mapped = wb_camera_map_file(r);\n    if (camera->file_mapped) {\n      camera->command_handled = true;\n      return true;\n    }\n  }\n#endif\n  return false;\n}", "CodeBleu_score": 38.86724923910003}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef __linux__\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (r->length!= sizeof(WbMemoryMappedFileRequest))\n        return false;\n\n      WbMemoryMappedFileRequest *request = (WbMemoryMappedFileRequest *)r->data;\n\n      // If there is already a memory-mapped file, close it\n      if (d->private_data)\n        wb_memory_mapped_file_close((WbMemoryMappedFile *)d->private_data);\n\n      // Create a new memory-mapped file\n      d->private_data = wb_memory_mapped_file_open(request->filename, request->offset, request->size);\n\n      if (!d->private_data)\n        return false;\n\n      d->command_handled = true;\n      return true;\n    }\n    default:\n      return false;\n  }\n#else\n  return false;\n#endif\n}", "CodeBleu_score": 44.16340366822254}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef __linux__\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      WbMemoryMappedFile *file = wb_request_get_memory_mapped_file(r);\n      if (file) {\n        WbCamera *camera = (WbCamera *)d;\n        if (camera->memory_mapped_file)\n          wb_memory_mapped_file_delete(camera->memory_mapped_file);\n        camera->memory_mapped_file = file;\n        wb_request_set_int(r, 0);\n        wb_request_set_bool(r, true);\n        return true;\n      }\n      break;\n    }\n    default:\n      break;\n  }\n#endif\n  wb_request_set_bool(r, false);\n  return false;\n}", "CodeBleu_score": 48.62662761263203}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tAbstractCamera *camera = (AbstractCamera *) wb_robot_get_device_data(d);\n\tint height = -1;\n\tif (camera) {\n\t\twb_mutex_lock(camera->mutex);\n\t\tif (camera->data)\n\t\t\theight = camera->data->height;\n\t\twb_mutex_unlock(camera->mutex);\n\t}\n\treturn height;\n}", "CodeBleu_score": 41.978748915347275}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint height = -1;\n\tif (d!= NULL) {\n\t\tWbCamera *camera = (WbCamera *) d;\n\t\tif (camera->data!= NULL) {\n\t\t\tWbMutex *mutex = camera->data->mutex;\n\t\t\twb_mutex_lock(mutex);\n\t\t\theight = camera->data->height;\n\t\t\twb_mutex_unlock(mutex);\n\t\t}\n\t}\n\treturn height;\n}", "CodeBleu_score": 39.83509473727894}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint height = -1;\n\tif (d->node) {\n\t\tWbAbstractCamera *ac = d->node->data;\n\t\tif (ac) {\n\t\t\theight = ac->height;\n\t\t}\n\t}\n\treturn height;\n}", "CodeBleu_score": 45.67243875823739}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tWbDevice *device = robot_get_device_with_node_tag(tag, WB_NODE_ACCELEROMETER);\n\tif (device == NULL) {\n\t\tfprintf(stderr, \"Error: accelerometer tag '%d' is not a valid accelerometer tag.\n\", tag);\n\t\treturn -1;\n\t}\n\tsampling_period = device->accelerometer->sampling_period;\n\treturn sampling_period;\n}", "CodeBleu_score": 44.985151281289156}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t#ifdef _WIN32\n  if (wb_robot_get_mode() == WB_MODE_REMOTE_CONTROL) {\n    fprintf(stderr, \"Error: wb_accelerometer_get_sampling_period() is not available in remote control mode.\n\");\n    return -1;\n  }\n#endif\n  WbDevice *device = robot_get_device_with_node(tag);\n  if (device == NULL)\n    return -1;\n  if (device->node_type!= WB_NODE_ACCELEROMETER) {\n    fprintf(stderr, \"Error: wb_accelerometer_get_sampling_period() is only available for accelerometer devices.\n\");\n    return -1;\n  }\n  WbAccelerometer *accelerometer = (WbAccelerometer *)device->pdata;\n  int sampling_period;\n  if (accelerometer == NULL) {\n    fprintf(stderr, \"Error: wb_accelerometer_get_sampling_period() cannot get the sampling period of the accelerometer.\n\");\n    sampling_period = -1;\n  } else\n    sampling_period = accelerometer->sampling_period;\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 49.249565674616676}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period = -1;\n\tWbAccelerometer *accelerometer = robot_get_accelerometer(tag);\n\tif (accelerometer) {\n\t\tsampling_period = accelerometer->sampling_period;\n\t} else {\n\t\tfprintf(stderr, \"Error: accelerometer %d is invalid.\n\", tag);\n\t}\n\treturn sampling_period;\n}", "CodeBleu_score": 55.408727206775055}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsStringConverted(dmsString);\n\tfree(dmsString);\n\treturn dmsStringConverted;\n}", "CodeBleu_score": 42.15317537781575}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms = dmsString;\n\tfree(dmsString);\n\treturn dms;\n}", "CodeBleu_score": 43.95046110648649}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms = dmsString;\n\tfree(dmsString);\n\treturn dms;\n}", "CodeBleu_score": 43.95046110648649}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && dGeomGetClass (g) == dBoxClass, \"dGeomBoxGetTangentPlane: argument is not a box\");\n\tdGeomBoxData *data = (dGeomBoxData*) dGeomGetData (g);\n\tdReal *p = data->side_lengths;\n\tdReal *c = data->center;\n\tdReal *a = data->abs_side_lengths;\n\tdReal ax = fabs (x - c[0]);\n\tdReal ay = fabs (y - c[1]);\n\tdReal az = fabs (z - c[2]);\n\tdReal *n;\n\tdReal d;\n\tif (ax < ay) {\n\t\tif (ax < az) {\n\t\t\tn = data->normal1;\n\t\t\td = ax - a[0];\n\t\t} else {\n\t\t\tn = data->normal3;\n\t\t\td = az - a[2];\n\t\t}\n\t} else {\n\t\tif (ay < az) {\n\t\t\tn = data->normal2;\n\t\t\td = ay - a[1];\n\t\t} else {\n\t\t\tn = data->normal3;\n\t\t\td = az - a[2];\n\t\t}\n\t}\n\tplane[0] = n[0];\n\tplane[1] = n[1];\n\tplane[2] = n[2];\n\tplane[3] = d;\n}", "CodeBleu_score": 36.09636203504925}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdVector3 p;\n\tdGeomBoxGetLastPositionR (g, p);\n\tdReal dx = x - p[0];\n\tdReal dy = y - p[1];\n\tdReal dz = z - p[2];\n\tdReal ax = fabs (dx);\n\tdReal ay = fabs (dy);\n\tdReal az = fabs (dz);\n\tdReal max = ax;\n\tdVector3 normal;\n\tdReal dist;\n\tif (ay > max) {\n\t\tmax = ay;\n\t\tnormal[0] = 0;\n\t\tnormal[1] = (dy < 0)? -1 : 1;\n\t\tnormal[2] = 0;\n\t\tdist = p[1] + normal[1] * 0.5 * p[1];\n\t} else {\n\t\tnormal[0] = 0;\n\t\tnormal[1] = 0;\n\t\tnormal[2] = 0;\n\t\tdist = 0;\n\t}\n\tif (az > max) {\n\t\tmax = az;\n\t\tnormal[0] = 0;\n\t\tnormal[1] = 0;\n\t\tnormal[2] = (dz < 0)? -1 : 1;\n\t\tdist = p[2] + normal[2] * 0.5 * p[2];\n\t}\n\tdReal mag = dSqrt (normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);\n\tnormal[0] /= mag;\n\tnormal[1] /= mag;\n\tnormal[2] /= mag;\n\tplane[0] = normal[0];\n\tplane[1] = normal[1];\n\tplane[2] = normal[2];\n\tplane[3] = dist;\n}", "CodeBleu_score": 30.209081407739923}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdVector3 p, r;\n\tdVector3 normal;\n\tdReal distance;\n\tdReal d;\n\n\tdUASSERT (dGeomGetClass (g) == dBoxClass, \"dGeomBoxGetTangentPlane: argument is not a box\");\n\n\tdGeomBoxPointRel (g, x, y, z, r);\n\n\tdVectorSet (normal, 0, 0, 0);\n\tdistance = 0;\n\n\td = fabs (r[0]);\n\tif (d > distance) {\n\t\tdistance = d;\n\t\tdVectorSet (normal, 1, 0, 0);\n\t}\n\n\td = fabs (r[1]);\n\tif (d > distance) {\n\t\tdistance = d;\n\t\tdVectorSet (normal, -1, 0, 0);\n\t}\n\n\td = fabs (r[2]);\n\tif (d > distance) {\n\t\tdistance = d;\n\t\tdVectorSet (normal, 0, 1, 0);\n\t}\n\n\td = fabs (r[3]);\n\tif (d > distance) {\n\t\tdistance = d;\n\t\tdVectorSet (normal, 0, -1, 0);\n\t}\n\n\td = fabs (r[4]);\n\tif (d > distance) {\n\t\tdistance = d;\n\t\tdVectorSet (normal, 0, 0, 1);\n\t}\n\n\td = fabs (r[5]);\n\tif (d > distance) {\n\t\tdistance = d;\n\t\tdVectorSet (normal, 0, 0, -1);\n\t}\n\n\tdVectorScale (normal, 1.0 / distance);\n\tdistance *= 0.5;\n\n\tdVectorCopy (normal, plane);\n\tplane[3] = -distance;\n}", "CodeBleu_score": 25.505812610764455}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdIASSERT (box->body);\n\tdIASSERT (flags >= 0);\n\tdIASSERT (flags < 256);\n\tdIASSERT (immersion);\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\tdImmerseGeom (box, dGeomBoxGetSideLengths (box->geom), &data);\n\treturn immersion->immersion;\n}", "CodeBleu_score": 44.24157090508937}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdIASSERT (box->body);\n\tdIASSERT (box->flags & dBodyGetGeomFlags (box->body));\n\tdIASSERT (fluidPlane);\n\tdIASSERT (immersion);\n\tdIASSERT (flags & dBodyGetGeomFlags (box->body));\n\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.immersion = immersion;\n\tdata.flags = flags;\n\treturn dImmerseBox (&data);\n}", "CodeBleu_score": 43.62858999554031}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tif (!box ||!fluidPlane ||!immersion)\n\t\treturn -1;\n\n\tif (!box->body ||!box->geom)\n\t\treturn -1;\n\n\tif (flags < 0 || flags > 1)\n\t\treturn -1;\n\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\n\treturn dFluidImmersionBox (&data);\n}", "CodeBleu_score": 43.13635485511083}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (o1 && o2);\n\tdIASSERT (dxGeomGetClass (o1) == dBoxClass);\n\tdIASSERT (dxGeomGetClass (o2) == dCapsuleClass);\n\n\tdIASSERT (dxGeomGetBody (o1) == 0);\n\tdIASSERT (dxGeomGetBody (o2) == 0);\n\n\tdIASSERT (immersion);\n\n\tdIASSERT (immersion->fluid);\n\tdIASSERT (immersion->fluid->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics->fluid_dynamics);\n\n\tdIASSERT (immersion->fluid->fluid_dynamics->fluid_dynamics->fluid_dynamics->", "CodeBleu_score": 24.896391441067315}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdVector3 box_center, capsule_center;\n\tdVector3 box_half_size, capsule_half_size;\n\tdMatrix3 box_R, capsule_R;\n\tdMatrix3 box_abs_R, capsule_abs_R;\n\tdMatrix3 box_abs_R_T, capsule_abs_R_T;\n\tdVector3 box_abs_R_T_box_center, capsule_abs_R_T_capsule_center;\n\tdVector3 box_abs_R_T_capsule_center;\n\tdVector3 box_abs_R_T_capsule_half_size;\n\tdVector3 capsule_abs_R_T_capsule_half_size;\n\tdVector3 box_abs_R_T_capsule_half_size_abs;\n\tdVector3 box_abs_R_T_capsule_half_size_abs_abs;\n\tdVector3 box_abs_R_T_capsule_half_size_abs_abs_abs;\n\tdVector3 capsule_abs_R_T_capsule_half_size_abs;\n\tdVector3 capsule_abs_R_T_capsule_half_size_abs_abs;\n\tdVector3 capsule_abs_R_T_capsule_half_size_abs_abs_abs;\n\tdVector3 box_abs_R_T_capsule_half_size_abs_abs_abs_abs;\n\tdVector3 capsule_abs_R_T_capsule_half_size_abs_abs_abs_abs;\n\tdVector3 box_abs_R_T_capsule_half_size_abs_abs_abs_abs_abs;\n\tdVector3 capsule_abs_R_T_capsule_half_size_abs_abs_abs_abs_abs;\n\tdVector3 box_abs_R_T_capsule_half_size_abs_abs_abs_abs_abs_abs;\n\tdVector3 capsule_abs_R_T_capsule_half_size_abs_abs_abs_abs_abs_abs;\n\tdVector3 box_", "CodeBleu_score": 5.86788720184538}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (o1 && o2 && immersion);\n\n\t// Check if the object is a box\n\tdxBox *box = dGeomBox (o1);\n\tif (!box) return 0;\n\n\t// Check if the object is a capsule\n\tdxCapsule *capsule = dGeomCapsule (o2);\n\tif (!capsule) return 0;\n\n\t// Check if the box is attached to the world\n\tif (dGeomGetBody (o1) == 0) return 0;\n\n\t// Check if the capsule is attached to the world\n\tif (dGeomGetBody (o2) == 0) return 0;\n\n\t// Check if the box and the capsule are attached to the same body\n\tif (dGeomGetBody (o1)!= dGeomGetBody (o2)) return 0;\n\n\t// Check if the box and the capsule are attached to the same body\n\tif (dGeomGetBody (o1)!= dGeomGetBody (o2)) return 0;\n\n\t// Check if the box and the capsule are attached to the same body\n\tif (dGeomGetBody (o1)!= dGeomGetBody (o2)) return 0;\n\n\t// Check if the box and the capsule are attached to the same body\n\tif (dGeomGetBody (o1)!= dGeomGetBody (o2)) return 0;\n\n\t// Check if the box and the capsule are attached to the same body\n\tif (dGeomGetBody (o1)!= dGeomGetBody (o2)) return 0;\n\n\t// Check if the box and the capsule are attached to the same body\n\tif (dGeomGetBody (o1)!= dGeomGetBody (o2)) return 0;\n\n\t// Check if the box and the capsule are attached to the same body\n\tif (dGeomGetBody (o1)!= dGeomGetBody (o2)) return 0;\n\n\t// Check if the box and the capsule are attached to the same body\n\tif (dGeomGetBody (o1)!= dGeomGetBody (o2)) return 0;\n\n\t// Check if the box and the capsule are attached to the same body\n\tif (dGeomGet", "CodeBleu_score": 27.40498558691005}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal tanTheta1 = zIOverR * tanTheta0;\n\tdReal cosTheta0 = sqrt(1 - tanTheta0 * tanTheta0);\n\tdReal cosTheta1 = sqrt(1 - tanTheta1 * tanTheta1);\n\tdReal sinTheta0 = sqrt(1 - cosTheta0 * cosTheta0);\n\tdReal sinTheta1 = sqrt(1 - cosTheta1 * cosTheta1);\n\tdReal volume0 = 0.5 * (sinTheta0 + sinTheta1);\n\tdReal volume1 = 0.5 * (cosTheta0 - cosTheta1);\n\tdReal volume2 = 0.5 * (sinTheta0 + sinTheta1);\n\treturn 0.5 * (volume0 + volume1 + volume2);\n}", "CodeBleu_score": 40.48081930043254}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal z0OverR = zIOverR * z0OverR;\n\tdReal z1OverR = zIOverR * z1OverR;\n\tdReal z0OverR2 = z0OverR * z0OverR;\n\tdReal z1OverR2 = z1OverR * z1OverR;\n\n\tdReal sinTheta0 = sqrt(1.0 - z0OverR2);\n\tdReal sinTheta1 = sqrt(1.0 - z1OverR2);\n\n\tdReal sinTheta02 = sinTheta0 * sinTheta0;\n\tdReal sinTheta12 = sinTheta1 * sinTheta1;\n\n\tdReal tanTheta02 = tanTheta0 * tanTheta0;\n\tdReal tanTheta12 = tanTheta0 * tanTheta0;\n\n\tdReal sinTheta04 = sinTheta02 * sinTheta02;\n\tdReal sinTheta14 = sinTheta12 * sinTheta12;\n\n\tdReal tanTheta04 = tanTheta02 * tanTheta02;\n\tdReal tanTheta14 = tanTheta12 * tanTheta12;\n\n\tdReal tanTheta06 = tanTheta04 * tanTheta02;\n\tdReal tanTheta16 = tanTheta14 * tanTheta12;\n\n\tdReal sinTheta06 = sinTheta04 * sinTheta02;\n\tdReal sinTheta16 = sinTheta14 * sinTheta12;\n\n\tdReal tanTheta08 = tanTheta06 * tanTheta02;\n\tdReal tanTheta18 = tanTheta16 * tanTheta12;\n\n\tdReal sinTheta08 = sinTheta06 * sinTheta02;\n\tdReal sinTheta18 = sinTheta16 * sinTheta12;\n\n\tdReal tanTheta10 = tanTheta08 * tanTheta02;\n\tdReal tanTheta11 = tanTheta18 * tanTheta12;\n\n\tdReal sinTheta10 = sinTheta08 * sinTheta02;\n\tdReal sinTheta11 = sinTheta18 * sinTheta12;\n\n\tdReal tanTheta12 = tanTheta10 * tanTheta02;\n\tdReal", "CodeBleu_score": 34.39812709339598}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal zIOverR_2 = zIOverR * zIOverR;\n\tdReal zIOverR_3 = zIOverR_2 * zIOverR;\n\tdReal zIOverR_4 = zIOverR_3 * zIOverR;\n\tdReal zIOverR_5 = zIOverR_4 * zIOverR;\n\tdReal zIOverR_6 = zIOverR_5 * zIOverR;\n\tdReal zIOverR_7 = zIOverR_6 * zIOverR;\n\tdReal zIOverR_8 = zIOverR_7 * zIOverR;\n\tdReal zIOverR_9 = zIOverR_8 * zIOverR;\n\tdReal zIOverR_10 = zIOverR_9 * zIOverR;\n\tdReal zIOverR_11 = zIOverR_10 * zIOverR;\n\tdReal zIOverR_12 = zIOverR_11 * zIOverR;\n\tdReal zIOverR_13 = zIOverR_12 * zIOverR;\n\tdReal zIOverR_14 = zIOverR_13 * zIOverR;\n\tdReal zIOverR_15 = zIOverR_14 * zIOverR;\n\tdReal zIOverR_16 = zIOverR_15 * zIOverR;\n\tdReal zIOverR_17 = zIOverR_16 * zIOverR;\n\tdReal zIOverR_18 = zIOverR_17 * zIOverR;\n\tdReal zIOverR_19 = zIOverR_18 * zIOverR;\n\tdReal zIOverR_20 = zIOverR_19 * zIOverR;\n\tdReal zIOverR_21 = zIOverR_20 * zIOverR;\n\tdReal zIOverR_22 = zIOverR_21 * zIOverR;\n\tdReal zIOver", "CodeBleu_score": 29.46482005317638}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal xBuoyancyCenter = 0.0;\n\n\tdReal x0 = 0.0;\n\tdReal x1 = zIOverR;\n\tdReal x2 = 2.0 * zIOverR;\n\n\tdReal y0 = tanTheta0;\n\tdReal y1 = tanTheta0 * sinTheta1;\n\tdReal y2 = 0.0;\n\n\tdReal z0 = 0.0;\n\tdReal z1 = 0.0;\n\tdReal z2 = 0.0;\n\n\tdReal f0 = (y0 + 4.0 * y1 + y2) / 6.0;\n\tdReal f1 = (y0 + 4.0 * y2 + y1) / 6.0;\n\tdReal f2 = (y0 + 4.0 * y2 + y1) / 6.0;\n\n\txBuoyancyCenter = (x0 * f0 + x1 * f1 + x2 * f2) / volume;\n\n\treturn xBuoyancyCenter;\n}", "CodeBleu_score": 39.72450947465046}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal xBuoyancyCenter = 0.0;\n\tdReal deltaTheta = (dReal)M_PI / (dReal)32.0;\n\tdReal theta = 0.0;\n\tdReal deltaR = (dReal)0.01;\n\tdReal r = 0.0;\n\tdReal deltaZ = 0.0;\n\tdReal z = 0.0;\n\tdReal deltaR2 = 0.0;\n\tdReal r2 = 0.0;\n\tdReal deltaZ2 = 0.0;\n\tdReal z2 = 0.0;\n\tdReal deltaR3 = 0.0;\n\tdReal r3 = 0.0;\n\tdReal deltaZ3 = 0.0;\n\tdReal z3 = 0.0;\n\tdReal deltaR4 = 0.0;\n\tdReal r4 = 0.0;\n\tdReal deltaZ4 = 0.0;\n\tdReal z4 = 0.0;\n\tdReal deltaR5 = 0.0;\n\tdReal r5 = 0.0;\n\tdReal deltaZ5 = 0.0;\n\tdReal z5 = 0.0;\n\tdReal deltaR6 = 0.0;\n\tdReal r6 = 0.0;\n\tdReal deltaZ6 = 0.0;\n\tdReal z6 = 0.0;\n\tdReal deltaR7 = 0.0;\n\tdReal r7 = 0.0;\n\tdReal deltaZ7 = 0.0;\n\tdReal z7 = 0.0;\n\tdReal deltaR8 = 0.0;\n\tdReal r8 = 0.0;\n\tdReal deltaZ8 = 0.0;\n\tdReal z8 = 0.0;\n\tdReal deltaR9 = 0.0;\n\tdReal r9 = 0.0;\n\tdReal deltaZ9 = 0.0;\n\tdReal z9 = 0.0;\n\tdReal deltaR10 = 0.0", "CodeBleu_score": 11.02963481705347}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal xBuoyancyCenter = 0.0;\n\tdReal x = 0.0;\n\tdReal y = 0.0;\n\tdReal z = 0.0;\n\tdReal r = 0.0;\n\tdReal theta = 0.0;\n\tdReal sinTheta = 0.0;\n\tdReal cosTheta = 0.0;\n\tdReal sinTheta2 = 0.0;\n\tdReal cosTheta2 = 0.0;\n\tdReal sinTheta3 = 0.0;\n\tdReal cosTheta3 = 0.0;\n\tdReal sinTheta4 = 0.0;\n\tdReal cosTheta4 = 0.0;\n\tdReal sinTheta5 = 0.0;\n\tdReal cosTheta5 = 0.0;\n\tdReal sinTheta6 = 0.0;\n\tdReal cosTheta6 = 0.0;\n\tdReal sinTheta7 = 0.0;\n\tdReal cosTheta7 = 0.0;\n\tdReal sinTheta8 = 0.0;\n\tdReal cosTheta8 = 0.0;\n\tdReal sinTheta9 = 0.0;\n\tdReal cosTheta9 = 0.0;\n\tdReal sinTheta10 = 0.0;\n\tdReal cosTheta10 = 0.0;\n\tdReal sinTheta11 = 0.0;\n\tdReal cosTheta11 = 0.0;\n\tdReal sinTheta12 = 0.0;\n\tdReal cosTheta12 = 0.0;\n\tdReal sinTheta13 = 0.0;\n\tdReal cosTheta13 = 0.0;\n\tdReal sinTheta14 = 0.0;\n\tdReal cosTheta14 = 0.0;\n\tdReal sinTheta15 = 0.0;\n\tdReal cosTheta15 = 0.0;\n\tdReal sinTheta16 = 0.0;\n\tdReal cosTheta16 = 0.0;\n\tdReal sinTheta17 = 0.0;\n", "CodeBleu_score": 10.628055741864667}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmersionCapsuleData *capsuleData = (dImmersionCapsuleData *)immersion->data;\n\tdImmersionCapsuleTrimeshData *capsuleTrimeshData = (dImmersionCapsuleTrimeshData *)immersion->data;\n\n\tdTriMeshData *trimeshData = (dTriMeshData *)o2->data;\n\tdTriMeshData *capsuleTrimeshDataTrimeshData = (dTriMeshData *)capsuleTrimeshData->trimeshData;\n\n\tdImmersionOutline *outline = capsuleTrimeshData->outline;\n\tdImmersionOutline *capsuleOutline = capsuleData->outline;\n\n\tdVector3 x_axis, y_axis, z_axis;\n\tdVector3 capsuleCenter;\n\tdVector3 capsuleAxis;\n\n\tdVector3 x_axis_capsule, y_axis_capsule, z_axis_capsule;\n\tdVector3 capsuleCenter_capsule;\n\tdVector3 capsuleAxis_capsule;\n\n\tdVector3 capsuleCenter_capsule_capsule;\n\tdVector3 capsuleAxis_capsule_capsule;\n\n\tdVector3 capsuleCenter_capsule_capsule_capsule;\n\tdVector3 capsuleAxis_capsule_capsule_capsule;\n\n\tdVector3 capsuleCenter_capsule_capsule_capsule_capsule;\n\tdVector3 capsuleAxis_capsule_capsule_capsule_capsule;\n\n\tdVector3 capsuleCenter_capsule_capsule_capsule_capsule_capsule;\n\tdVector3 capsuleAxis_capsule_capsule_capsule_capsule_capsule;\n\n\tdVector3 capsuleCenter_capsule_capsule_capsule_capsule_capsule_capsule;\n\tdVector3 capsuleAxis_capsule_capsule_capsule_capsule_capsule_capsule;\n\n\tdVector3 capsuleCenter_capsule_capsule_capsule_capsule_capsule_capsule_capsule;\n\tdVector3 capsuleAxis_capsule_capsule_capsule_capsule_capsule_capsule_capsule;\n\n\tdVector3 capsuleCenter_capsule_", "CodeBleu_score": 24.559729082604157}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmersionCapsuleData *capsuleData = (dImmersionCapsuleData *)immersion->data;\n\tdImmersionCapsuleTrimeshData *capsuleTrimeshData = (dImmersionCapsuleTrimeshData *)immersion->data;\n\n\tif (capsuleData->capsule_type == dIMMERSE_CAPSULE_CYLINDER) {\n\t\treturn dImmerseCapsuleCylinderTrimesh (o1, o2, flags, immersion);\n\t}\n\n\tif (capsuleData->capsule_type == dIMMERSE_CAPSULE_SPHERE) {\n\t\treturn dImmerseCapsuleSphereTrimesh (o1, o2, flags, immersion);\n\t}\n\n\tif (capsuleData->capsule_type == dIMMERSE_CAPSULE_CONE) {\n\t\treturn dImmerseCapsuleConeTrimesh (o1, o2, flags, immersion);\n\t}\n\n\tif (capsuleData->capsule_type == dIMMERSE_CAPSULE_REVOLUTION) {\n\t\treturn dImmerseCapsuleRevolutionTrimesh (o1, o2, flags, immersion);\n\t}\n\n\tif (capsuleData->capsule_type == dIMMERSE_CAPSULE_IMMERSION) {\n\t\treturn dImmerseCapsuleImmersionTrimesh (o1, o2, flags, immersion);\n\t}\n\n\tif (capsuleData->capsule_type == dIMMERSE_CAPSULE_OUTLINE) {\n\t\treturn dImmerseCapsuleOutlineTrimesh (o1, o2, flags, immersion);\n\t}\n\n\tif (capsuleData->capsule_type == dIMMERSE_CAPSULE_TRIANGLE) {\n\t\treturn dImmerseCapsuleTriangleTrimesh (o1, o2, flags, immersion);\n\t}\n\n\tif (capsuleData->capsule_type == dIMMERSE_CAPSULE_CYLINDER_TRIANGLE) {\n\t\treturn dImmerseCapsuleCylinderTriangleTrimesh (o1, o2, flags, immersion);\n\t}\n\n\tif (capsuleData->capsule_type == dIMMERSE_CAPSULE_SPHERE_", "CodeBleu_score": 31.17465201329287}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmersionCapsuleData *capsuleData = (dImmersionCapsuleData *) immersion->data;\n\n\tdImmersionTrimeshData *trimeshData = (dImmersionTrimeshData *) immersion->data;\n\n\tdImmersionCapsuleTrimeshData *capsuleTrimeshData = (dImmersionCapsuleTrimeshData *) immersion->data;\n\n\tdImmersionRevolutionData *revolutionData = (dImmersionRevolutionData *) immersion->data;\n\n\tdImmersionCapsuleRevolutionData *capsuleRevolutionData = (dImmersionCapsuleRevolutionData *) immersion->data;\n\n\tdImmersionCapsuleCapsuleData *capsuleCapsuleData = (dImmersionCapsuleCapsuleData *) immersion->data;\n\n\tdImmersionCapsuleCapsuleTrimeshData *capsuleCapsuleTrimeshData = (dImmersionCapsuleCapsuleTrimeshData *) immersion->data;\n\n\tdImmersionCapsuleCapsuleRevolutionData *capsuleCapsuleRevolutionData = (dImmersionCapsuleCapsuleRevolutionData *) immersion->data;\n\n\tdImmersionCapsuleCapsuleCapsuleData *capsuleCapsuleCapsuleData = (dImmersionCapsuleCapsuleCapsuleData *) immersion->data;\n\n\tdImmersionCapsuleCapsuleCapsuleTrimeshData *capsuleCapsuleCapsuleTrimeshData = (dImmersionCapsuleCapsuleCapsuleTrimeshData *) immersion->data;\n\n\tdImmersionCapsuleCapsuleCapsuleRevolutionData *capsuleCapsuleCapsuleRevolutionData = (dImmersionCapsuleCapsuleCapsuleRevolutionData *) immersion->data;\n\n\tdImmersionCapsuleCapsuleCapsuleCapsuleData *capsuleCapsuleCapsuleCapsuleData = (dImmersionCapsuleCapsuleCapsuleCapsuleData *) immersion->data;\n\n\tdImmersionCapsuleCapsuleCapsuleCapsuleTrimeshData *capsuleCapsuleCapsuleCapsuleTrimeshData = (dImmersionCapsuleCapsuleCapsuleCapsuleTrimeshData *) immersion->data;\n\n\tdImmersionCapsuleCapsuleCapsuleCapsuleRevolutionData *capsuleCapsuleCapsuleCapsuleRevolutionData = (dImmersionCapsuleCapsuleCapsuleCapsuleRevolution", "CodeBleu_score": 14.16442362504016}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\tif (duration_ms_ <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\ttimer_waiting_ = true;\n\ttimer_ = std::make_unique<Timer>(duration_ms_, [this]() {\n\t\ttimer_waiting_ = false;\n\t\tthis->emitSignal(\"wake-up\");\n\t});\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 28.19775325146592}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (this->getDuration() <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\tthis->timer_waiting_ = true;\n\tthis->timer_ = this->getDuration();\n\tthis->wakeup_ = this->blackboard_->registerCallback(this->id_, [this](const Blackboard::Event& event) {\n\t\tif (event.event_id == Blackboard::Event::WAKEUP) {\n\t\t\tthis->timer_waiting_ = false;\n\t\t\tthis->onWakeUp();\n\t\t}\n\t});\n\n\tthis->setStatus(NodeStatus::RUNNING);\n\tthis->blackboard_->emitEvent(Blackboard::Event(Blackboard::Event::TIMER_START, this->id_));\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 34.11735831438199}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (!this->getDuration(sleep_duration_ms_)) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\tif (sleep_duration_ms_ <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\ttimer_waiting_ = true;\n\ttimer_id_ = this->getTree()->registerTimer(sleep_duration_ms_, [this] {\n\t\tthis->wakeUp();\n\t});\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 31.211255811799887}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tauto& blackboard = getBlackboard();\n\tstd::string key = getInput<std::string>(\"key\");\n\n\tif (blackboard.has(key)) {\n\t\tauto& entry = blackboard.get<Blackboard::Entry>(key);\n\t\tentry.lock();\n\t\tif (entry.sequence_id!= entry.previous_sequence_id) {\n\t\t\tentry.previous_sequence_id = entry.sequence_id;\n\t\t\tentry.unlock();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t\tentry.unlock();\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 37.66357277266926}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tBT_DEBUG(\"EntryUpdatedAction::tick\");\n\n\tstd::string key;\n\tif (!getInput<std::string>(\"key\", key)) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tauto entry = getBlackboard().getEntry(key);\n\tif (entry == nullptr) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tentry->lock();\n\tif (entry->getSequenceID() == entry->getPreviousSequenceID()) {\n\t\tentry->unlock();\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tentry->setPreviousSequenceID(entry->getSequenceID());\n\tentry->unlock();\n\n\treturn NodeStatus::SUCCESS;\n}", "CodeBleu_score": 38.93930121689403}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tBT_ASSERT(blackboard_);\n\tBT_ASSERT(blackboard_->is_locked());\n\n\tauto entry = blackboard_->get_entry(key_);\n\tif (entry == nullptr) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tif (entry->get_sequence_id() == sequence_id_) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tsequence_id_ = entry->get_sequence_id();\n\treturn NodeStatus::SUCCESS;\n}", "CodeBleu_score": 45.56553581777766}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (m_success_threshold < 0) {\n\t\treturn std::max(m_success_threshold + m_children.size(), 0);\n\t}\n\treturn m_success_threshold;\n}", "CodeBleu_score": 49.664885987884574}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (m_success_threshold < 0) {\n\t\treturn std::max(m_success_threshold + static_cast<int>(m_children.size()), 0);\n\t}\n\treturn m_success_threshold;\n}", "CodeBleu_score": 51.5847095189769}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (m_success_threshold < 0) {\n\t\treturn std::max(0, m_success_threshold + static_cast<int>(m_children.size()));\n\t}\n\treturn m_success_threshold;\n}", "CodeBleu_score": 51.5149230926788}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (heartbeat_active) {\n\t\t\tif (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now() - last_heartbeat).count() > 5) {\n\t\t\t\theartbeat_active = false;\n\t\t\t\tstd::cout << \"Heartbeat timed out. Disabling all breakpoints.\" << std::endl;\n\t\t\t\tfor (auto &breakpoint : breakpoints) {\n\t\t\t\t\tbreakpoint.second.enabled = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 30.841253499169817}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (lastHeartbeatTime!= 0) {\n\t\t\tif (lastHeartbeatTime + heartbeatTimeout < std::chrono::system_clock::now()) {\n\t\t\t\tif (heartbeatStatus) {\n\t\t\t\t\tfor (auto &breakpoint : breakpoints) {\n\t\t\t\t\t\tbreakpoint.second->setEnabled(false);\n\t\t\t\t\t}\n\t\t\t\t\theartbeatStatus = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!heartbeatStatus) {\n\t\t\t\t\tfor (auto &breakpoint : breakpoints) {\n\t\t\t\t\t\tbreakpoint.second->setEnabled(true);\n\t\t\t\t\t}\n\t\t\t\t\theartbeatStatus = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.82526870191457}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\tif (heartbeat_status_!= heartbeat_status) {\n\t\t\tif (heartbeat_status) {\n\t\t\t\t// Enable all breakpoints\n\t\t\t\tfor (auto& breakpoint : breakpoints_) {\n\t\t\t\t\tbreakpoint.second.enabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Disable all breakpoints\n\t\t\t\tfor (auto& breakpoint : breakpoints_) {\n\t\t\t\t\tbreakpoint.second.enabled = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theartbeat_status = heartbeat_status_;\n\t\t}\n\t}\n}", "CodeBleu_score": 41.2048424997914}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\ttry {\n\t\tauto root = m_blackboard_root;\n\t\tif (root == nullptr) {\n\t\t\treturn result;\n\t\t}\n\n\t\tauto json = nlohmann::json::object();\n\t\tstd::vector<std::string> blackboard_names = splitString(bb_list, ',');\n\t\tfor (auto& name : blackboard_names) {\n\t\t\tauto subtree = root->getBlackboardSubtree(name);\n\t\t\tif (subtree == nullptr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto subtree_lock = subtree->lock();\n\t\t\tauto json_subtree = subtree_lock->to_json();\n\t\t\tjson[name] = json_subtree;\n\t\t}\n\t\tresult = json.dump();\n\t}\n\tcatch (std::exception& e) {\n\t\tstd::cerr << \"Error in Groot2Publisher::generateBlackboardsDump: \" << e.what() << std::endl;\n\t}\n\treturn result;\n}", "CodeBleu_score": 44.197075205028554}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> bb_dump;\n\n\t// split the string of blackboard names\n\tstd::vector<std::string> bb_names;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\n\t// iterate through the blackboard names\n\tfor (const std::string& bb_name : bb_names) {\n\t\t// find the subtree\n\t\tstd::shared_ptr<BehaviorTree> subtree = tree_root_->findSubtree(bb_name);\n\n\t\t// if the subtree is valid\n\t\tif (subtree) {\n\t\t\t// lock the subtree\n\t\t\tsubtree->lock();\n\n\t\t\t// export the blackboard to JSON\n\t\t\trapidjson::Document bb_json;\n\t\t\trapidjson::Document::AllocatorType& allocator = bb_json.GetAllocator();\n\t\t\tsubtree->exportBlackboardToJson(bb_json, allocator);\n\n\t\t\t// add the JSON object to the JSON object\n\t\t\tbb_json.AddMember(\"blackboard\", bb_json[\"blackboard\"], allocator);\n\t\t\tbb_json.RemoveMember(\"blackboard\");\n\n\t\t\t// convert the JSON object to MessagePack format\n\t\t\trapidjson::StringBuffer buffer;\n\t\t\trapidjson::Writer<rapidjson::StringBuffer> writer(buffer);\n\t\t\tbb_json.Accept(writer);\n\t\t\tbb_dump.insert(bb_dump.end(), buffer.GetString(), buffer.GetString() + buffer.GetSize());\n\n\t\t\t// unlock the subtree\n\t\t\tsubtree->unlock();\n\t\t}\n\t}\n\n\treturn bb_dump;\n}", "CodeBleu_score": 39.64337023796123}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// Create a JSON object to store the blackboards.\n\tjson bb_dump;\n\n\t// Split the blackboard list into a vector of blackboard names.\n\tstd::vector<std::string> bb_names = split(bb_list, ',');\n\n\t// Iterate through the blackboard names.\n\tfor (const auto& bb_name : bb_names) {\n\t\t// Find the corresponding subtree.\n\t\tconst auto& subtree = blackboard_manager_->getTree(bb_name);\n\n\t\t// Check if the subtree is valid.\n\t\tif (subtree == nullptr) {\n\t\t\t// If the subtree is invalid, add an error message to the JSON object.\n\t\t\tbb_dump[\"error\"] = \"Blackboard \" + bb_name + \" not found\";\n\t\t} else {\n\t\t\t// If the subtree is valid, lock it.\n\t\t\tsubtree->lock();\n\n\t\t\t// Export the blackboard to JSON.\n\t\t\tjson bb_json = subtree->exportBlackboard();\n\n\t\t\t// Add the blackboard to the JSON object.\n\t\t\tbb_dump[bb_name] = bb_json;\n\n\t\t\t// Unlock the subtree.\n\t\t\tsubtree->unlock();\n\t\t}\n\t}\n\n\t// Convert the JSON object to MessagePack format.\n\tstd::vector<uint8_t> bb_dump_msgpack = msgpack::pack(bb_dump);\n\n\t// Return the MessagePack dump.\n\treturn bb_dump_msgpack;\n}", "CodeBleu_score": 47.190848148562615}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\n\t// check if the node exists\n\tauto it = breakpoints_.find(node_uid);\n\tif (it == breakpoints_.end()) {\n\t\treturn false;\n\t}\n\n\t// check if the node is valid\n\tif (!it->second.is_valid) {\n\t\treturn false;\n\t}\n\n\t// retrieve the hook\n\tauto &hook = it->second.hook;\n\n\t// lock the mutex\n\tstd::lock_guard<std::mutex> lock2(hook.mutex);\n\n\t// check if the node is in BREAKPOINT mode\n\tif (hook.mode!= Groot2Protocol::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\t// set the desired status\n\thook.status = result;\n\thook.remove = remove;\n\n\t// mark it as ready\n\thook.ready = true;\n\n\t// notify all waiting threads\n\thook.cv.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 44.68942166546375}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\t// Check if the node exists\n\tif (node_uid >= nodes.size()) {\n\t\treturn false;\n\t}\n\tif (nodes[node_uid].status!= NodeStatus::RUNNING) {\n\t\treturn false;\n\t}\n\n\t// Retrieve the hook\n\tstd::unique_lock<std::mutex> lock(nodes[node_uid].mutex);\n\n\tif (nodes[node_uid].hook.get() == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Check if the hook is in BREAKPOINT mode\n\tif (nodes[node_uid].hook->mode!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\t// Set the desired status and removal flag\n\tnodes[node_uid].hook->status = result;\n\tnodes[node_uid].hook->remove = remove;\n\n\t// Mark the node as ready\n\tnodes[node_uid].status = NodeStatus::READY;\n\n\t// Notify all waiting threads\n\tnodes[node_uid].condition.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 33.7564616032821}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tif (pos.empty()) {\n\t\treturn false;\n\t}\n\n\t// Search for the node\n\tauto it = nodes_.find(node_uid);\n\tif (it == nodes_.end()) {\n\t\treturn false;\n\t}\n\n\t// Check if the node is valid\n\tif (!it->second.valid) {\n\t\treturn false;\n\t}\n\n\t// Retrieve the hook\n\tauto hook = it->second.hook;\n\tif (!hook) {\n\t\treturn false;\n\t}\n\n\t// Lock the hook's mutex\n\tstd::unique_lock<std::mutex> lock(hook->mutex);\n\n\t// Check if the hook is in BREAKPOINT mode\n\tif (hook->mode!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\t// Set the desired status and removal flag\n\thook->status = result;\n\thook->remove = remove;\n\n\t// Mark it as ready\n\thook->ready = true;\n\n\t// Notify all waiting threads\n\thook->condition.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 53.38867948297323}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tNodeStatus status = NodeStatus::IDLE;\n\n\tif (is_running_) {\n\t\tstatus = NodeStatus::RUNNING;\n\t} else {\n\t\tis_running_ = true;\n\t\thalt_requested_ = false;\n\n\t\tauto tick_function = [this]() {\n\t\t\ttry {\n\t\t\t\tstatus = tick();\n\t\t\t} catch (const std::exception& e) {\n\t\t\t\tstd::cerr << \"Exception in \" << name_ << \": \" << e.what() << std::endl;\n\t\t\t\tstatus = NodeStatus::FAILURE;\n\t\t\t}\n\t\t};\n\n\t\tauto thread_id = minicoro::spawn(tick_function);\n\t\tif (thread_id.is_valid()) {\n\t\t\tis_running_ = true;\n\t\t} else {\n\t\t\tis_running_ = false;\n\t\t\tstatus = NodeStatus::FAILURE;\n\t\t}\n\t}\n\n\tif (halt_requested_) {\n\t\tstatus = NodeStatus::HALTED;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 41.46726436534626}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::thread t(&BT::ThreadedAction::runTick, this);\n\t\tt.detach();\n\t}\n\tif (halt_requested_) {\n\t\tstatus_ = NodeStatus::IDLE;\n\t}\n\treturn status_;\n}", "CodeBleu_score": 21.3370885465567}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::thread t(&BT::ThreadedAction::tick, this);\n\t\tt.detach();\n\t}\n\tif (halt_requested_) {\n\t\tstatus_ = NodeStatus::IDLE;\n\t}\n\tif (status_ == NodeStatus::RUNNING) {\n\t\tstatus_ = NodeStatus::SUCCESS;\n\t}\n\treturn status_;\n}", "CodeBleu_score": 25.242622374655387}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstream << \"--------------------------------------------------\" << std::endl;\n\tstream << \"Behavior Tree Structure\" << std::endl;\n\tstream << \"--------------------------------------------------\" << std::endl;\n\n\tauto print = [&](const TreeNode* node, int depth) {\n\t\tstd::string indent(depth * 2,'');\n\t\tstream << indent << node->getName() << std::endl;\n\t\tif (node->type == TreeNode::Type::CONTROL_NODE) {\n\t\t\tfor (const auto& child : node->children) {\n\t\t\t\tprint(child, depth + 1);\n\t\t\t}\n\t\t} else if (node->type == TreeNode::Type::DECORATOR_NODE) {\n\t\t\tprint(node->children[0], depth + 1);\n\t\t}\n\t};\n\n\tprint(root_node, 0);\n\n\tstream << \"--------------------------------------------------\" << std::endl;\n\tstream << \"End of Behavior Tree Structure\" << std::endl;\n\tstream << \"--------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 40.66808972480639}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstd::string indent;\n\tstd::string separator = \"----------------------------------------\n\";\n\tauto print = [&indent, &stream, &separator](const TreeNode* node) {\n\t\tstream << indent << node->getName() << std::endl;\n\t\tindent += \"  \";\n\t\tif (node->isControlNode()) {\n\t\t\tconst auto* control_node = static_cast<const ControlNode*>(node);\n\t\t\tprint(control_node->child());\n\t\t} else if (node->isDecoratorNode()) {\n\t\t\tconst auto* decorator_node = static_cast<const DecoratorNode*>(node);\n\t\t\tprint(decorator_node->child());\n\t\t}\n\t};\n\tstream << separator;\n\tprint(root_node);\n\tstream << separator;\n}", "CodeBleu_score": 38.32606665815239}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstream << \"----------------------------------------\" << std::endl;\n\tstream << \"Root Node: \" << root_node->getName() << std::endl;\n\tstream << \"----------------------------------------\" << std::endl;\n\tstream << std::endl;\n\n\tauto print_tree = [&](const TreeNode* node, int depth) {\n\t\tstd::string indent = std::string(depth * 4,'');\n\t\tstream << indent << node->getName() << std::endl;\n\n\t\tif (node->type() == TreeNodeType::ControlNode) {\n\t\t\tconst ControlNode* control_node = static_cast<const ControlNode*>(node);\n\t\t\tfor (auto child : control_node->children()) {\n\t\t\t\tprint_tree(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (node->type() == TreeNodeType::DecoratorNode) {\n\t\t\tconst DecoratorNode* decorator_node = static_cast<const DecoratorNode*>(node);\n\t\t\tprint_tree(decorator_node->child(), depth + 1);\n\t\t}\n\t};\n\n\tprint_tree(root_node, 0);\n\tstream << std::endl;\n\tstream << \"----------------------------------------\" << std::endl;\n\tstream << \"End of Tree\" << std::endl;\n\tstream << \"----------------------------------------\" << std::endl;\n}", "CodeBleu_score": 45.60856928424531}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow std::runtime_error(\"applyRecursiveVisitor: null node\");\n\t}\n\n\tvisitor(node);\n\n\tif (node->type() == TreeNode::Type::Control) {\n\t\tfor (const TreeNode* child : node->children()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->type() == TreeNode::Type::Decorator) {\n\t\tapplyRecursiveVisitor(node->child(), visitor);\n\t}\n}", "CodeBleu_score": 43.01373996023086}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"applyRecursiveVisitor: node is null\");\n\t}\n\n\tvisitor(node);\n\n\tif (node->type() == TreeNodeType::CONTROL_NODE) {\n\t\tconst ControlNode* cn = static_cast<const ControlNode*>(node);\n\t\tfor (const TreeNode* child : cn->children()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->type() == TreeNodeType::DECORATOR_NODE) {\n\t\tconst DecoratorNode* dn = static_cast<const DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(dn->child(), visitor);\n\t}\n}", "CodeBleu_score": 56.20678225804221}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (const ControlNode* control_node = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const TreeNode* child : control_node->children()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t}\n\telse if (const DecoratorNode* decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator_node->child(), visitor);\n\t}\n}", "CodeBleu_score": 58.95454829673522}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tstd::string id = manifest.id;\n\tif (builders_.count(id) > 0) {\n\t\tthrow BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder\",\n\t\t                            \"registration ID already exists: \" + id);\n\t}\n\tbuilders_[id] = builder;\n\tmanifests_[id] = manifest;\n}", "CodeBleu_score": 36.61263746045273}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.find(manifest.registration_id)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\"Builder for \" + manifest.registration_id + \" already registered\");\n\t}\n\tbuilders_[manifest.registration_id] = builder;\n\tmanifests_[manifest.registration_id] = manifest;\n}", "CodeBleu_score": 45.615473422497175}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.count(manifest.registration_id) > 0) {\n\t\tthrow BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder(): ID already registered: \" + manifest.registration_id);\n\t}\n\tbuilders_[manifest.registration_id] = builder;\n\tmanifests_[manifest.registration_id] = manifest;\n}", "CodeBleu_score": 43.47114711125223}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\tregisterBuilder(ID, [tick_functor, ports](TreeNodeManifest& manifest) {\n\t\tmanifest.type = \"SimpleAction\";\n\t\tmanifest.id = ID;\n\t\tmanifest.ports = ports;\n\t\treturn std::make_unique<SimpleActionNode>(tick_functor);\n\t});\n}", "CodeBleu_score": 38.86203306985717}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\n//  std::cout << \"registerSimpleAction\" << std::endl;\n\n  auto builder = [tick_functor, ports](TreeNodeManifest& manifest) {\n    manifest.type = \"SimpleAction\";\n    manifest.node_ptr = std::make_shared<SimpleActionNode>(tick_functor, ports);\n  };\n\n  registerBuilder(ID, builder);\n}", "CodeBleu_score": 44.00229635929524}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\t// Create a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\n\tNodeBuilder builder = [tick_functor, ports]() {\n\t\treturn std::make_unique<SimpleActionNode>(tick_functor, ports);\n\t};\n\n\t// Create a TreeNodeManifest with the action node type, ID, and ports list.\n\tTreeNodeManifest manifest(SimpleActionNode::type_name(), ID, ports);\n\n\t// Call registerBuilder to register the manifest and builder.\n\tregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 47.338901487437326}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> blackboard_backup;\n\tblackboard_backup.reserve(tree.size());\n\n\tfor (const auto& subtree : tree) {\n\t\tBlackboard::Ptr subtree_blackboard = std::make_shared<Blackboard>();\n\t\tsubtree_blackboard->clone(subtree->blackboard());\n\t\tblackboard_backup.push_back(subtree_blackboard);\n\t}\n\n\treturn blackboard_backup;\n}", "CodeBleu_score": 49.41833554996226}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> blackboard_backup;\n\tblackboard_backup.reserve(tree.getRootNode()->getSubtreeCount());\n\n\tfor (int i = 0; i < tree.getRootNode()->getSubtreeCount(); i++) {\n\t\tblackboard_backup.push_back(std::make_shared<Blackboard>(*tree.getRootNode()->getSubtree(i)->blackboard()));\n\t}\n\n\treturn blackboard_backup;\n}", "CodeBleu_score": 46.829908791932276}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tfor (const auto& subtree : tree.subtrees()) {\n\t\tauto backup = std::make_shared<Blackboard>(*subtree.blackboard());\n\t\tbackup->clone(subtree.blackboard());\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}", "CodeBleu_score": 47.83677588440013}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor.value()(env);\n}", "CodeBleu_score": 72.81208125672178}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tBT::ScriptParser parser;\n\n\tauto result = parser.parse(script);\n\tif (!result) {\n\t\treturn BT::make_unexpected(result.error());\n\t}\n\n\tBT::ScriptExecutor executor(env);\n\tauto result2 = executor.execute(result.value());\n\tif (!result2) {\n\t\treturn BT::make_unexpected(result2.error());\n\t}\n\n\treturn result2.value();\n}", "CodeBleu_score": 52.313483518226825}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto ast = ParseScript(script);\n\tif (!ast)\n\t\treturn BT::make_unexpected(ast.error());\n\n\tauto executor = ast->to_executor(env);\n\tif (!executor)\n\t\treturn BT::make_unexpected(executor.error());\n\n\treturn executor->execute();\n}", "CodeBleu_score": 58.63203335979752}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (loaded_) {\n\t\tthrow RuntimeError(\"SharedLibrary: cannot load a library twice\");\n\t}\n\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tstd::string error = dlerror();\n\t\tthrow RuntimeError(\"SharedLibrary: cannot load library: \" + error);\n\t}\n\n\tloaded_ = true;\n\tpath_ = path;\n\thandle_ = handle;\n}", "CodeBleu_score": 55.9852482051735}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\t// Acquire a unique lock on a mutex to ensure thread safety.\n\tstd::unique_lock<std::mutex> lock(mutex_);\n\n\t// If a library is already loaded, throw a RuntimeError.\n\tif (is_loaded_) {\n\t\tthrow RuntimeError(\"SharedLibrary::load: Library is already loaded\");\n\t}\n\n\t// Attempt to load the library using dlopen with RTLD_NOW and RTLD_GLOBAL flags.\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\t// If the load fails, retrieve the error message and throw a RuntimeError.\n\tif (handle == nullptr) {\n\t\tthrow RuntimeError(\"SharedLibrary::load: Unable to load library \" + path + \": \" + dlerror());\n\t}\n\n\t// If successful, store the path of the loaded library.\n\tpath_ = path;\n\thandle_ = handle;\n\tis_loaded_ = true;\n}", "CodeBleu_score": 54.39350921550973}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (loaded_) {\n\t\tthrow RuntimeError(\"SharedLibrary::load() called on a library that is already loaded\");\n\t}\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle_ == nullptr) {\n\t\tthrow RuntimeError(\"dlopen() failed: \" + std::string(dlerror()));\n\t}\n\tloaded_ = true;\n\tpath_ = path;\n}", "CodeBleu_score": 51.01094923018516}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str;\n\tstripped.strip();\n\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped.front()!= '{' || stripped.back()!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 25.704513689140462}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str;\n\tstripped.trim();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped.front()!= '{' || stripped.back()!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 25.67769115855092}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tstr.strip();\n\n\tif (str.front()!= '{' || str.back()!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 20.87343748494704}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0.0;\n\tLineIterator it(costmap_, x0, y0, x1, y1);\n\tfor (int i = 0; i < it.getSize(); ++i) {\n\t\tint x, y;\n\t\tit.compute(i, x, y);\n\t\tdouble point_cost = cellCost(x, y);\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\tcost += point_cost;\n\t}\n\treturn cost;\n}", "CodeBleu_score": 45.930507311054214}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble lineCost = 0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (int i = 0; i < line.getSize(); ++i) {\n\t\tdouble pointCost = getCost(line.getX(i), line.getY(i));\n\t\tif (pointCost < 0) {\n\t\t\treturn pointCost;\n\t\t}\n\t\telse {\n\t\t\tlineCost = std::max(lineCost, pointCost);\n\t\t}\n\t}\n\treturn lineCost;\n}", "CodeBleu_score": 50.77762512314631}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\t// Initialize the line cost\n\tdouble line_cost = 0;\n\n\t// Create a LineIterator object\n\tLineIterator it(costmap_, x0, y0, x1, y1);\n\n\t// Iterate through each point on the line\n\tfor (int i = 0; i < it.size(); i++) {\n\t\t// Calculate the point cost\n\t\tdouble point_cost = cost(it.getX(), it.getY());\n\n\t\t// If the point cost is negative, return the point cost immediately\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\n\t\t// Update the line cost if the point cost is higher\n\t\tif (point_cost > line_cost) {\n\t\t\tline_cost = point_cost;\n\t\t}\n\t}\n\n\t// Return the total line cost\n\treturn line_cost;\n}", "CodeBleu_score": 57.146228731057114}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\treturn;\n\t}\n\t// create a path message\n\tnav_msgs::Path path_msg;\n\t// set the header\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\t// copy the poses from the input path to the path message\n\tpath_msg.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tpath_msg.poses[i] = path[i];\n\t}\n\t// publish the path message\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 69.20593211001278}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\treturn;\n\t}\n\n\tnav_msgs::Path msg;\n\tmsg.header.frame_id = path[0].header.frame_id;\n\tmsg.header.stamp = path[0].header.stamp;\n\tmsg.poses.resize(path.size());\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tmsg.poses[i] = path[i];\n\t}\n\n\tpub.publish(msg);\n}", "CodeBleu_score": 68.07421704568218}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif(path.empty()) return;\n\n\tnav_msgs::Path msg;\n\tmsg.header.frame_id = path[0].header.frame_id;\n\tmsg.header.stamp = path[0].header.stamp;\n\n\tmsg.poses.resize(path.size());\n\tfor(unsigned int i = 0; i < path.size(); i++) {\n\t\tmsg.poses[i] = path[i];\n\t}\n\n\tpub.publish(msg);\n}", "CodeBleu_score": 71.89068999163226}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (base_odom.twist.twist.angular.z <= rot_stopped_velocity) && (base_odom.twist.twist.linear.x <= trans_stopped_velocity);\n}", "CodeBleu_score": 42.76351895282367}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// Get the angular and linear velocities from the odometry message\n\tdouble angular_velocity = base_odom.twist.twist.angular.z;\n\tdouble linear_velocity = base_odom.twist.twist.linear.x;\n\n\t// Check if the angular velocity is below or equal to the rotational stopped velocity threshold\n\tif (angular_velocity <= rot_stopped_velocity) {\n\t\t// Check if the linear velocity is below or equal to the translational stopped velocity threshold\n\t\tif (linear_velocity <= trans_stopped_velocity) {\n\t\t\t// If both angular and linear velocities are below or equal to their respective thresholds, return true\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// If either angular or linear velocity is above the respective threshold, return false\n\treturn false;\n}", "CodeBleu_score": 48.21356452316476}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// If the robot is stopped, it should have a linear and angular velocity of 0\n\tif (base_odom.twist.twist.linear.x <= trans_stopped_velocity && base_odom.twist.twist.angular.z <= rot_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 46.32182030501123}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// TODO Auto-generated constructor stub\n\n}", "CodeBleu_score": 4.780716794403336}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig.restoreDefaults();\n\t} else {\n\t\tif (!config.setup) {\n\t\t\tconfig.setup = true;\n\t\t\tconfig.restoreDefaults();\n\t\t}\n\t\tconfig.lock();\n\t\tconfig.updateLimits(config);\n\t\tconfig.unlock();\n\t}\n}", "CodeBleu_score": 28.71728557320593}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// If the setup flag is true and restore_defaults is requested, it resets the configuration to default limits.\n\tif (setup && restore_defaults) {\n\t\tconfig.restoreDefaults();\n\t}\n\t// If setup is not yet done, it initializes the default limits with the provided configuration and sets up the flag.\n\tif (!setup) {\n\t\tconfig.init(config);\n\t\tsetup = true;\n\t}\n\t// Finally, it locks the configuration mutex and updates the current limits with the new configuration.\n\tconfig_mutex.lock();\n\tconfig.updateLimits(config);\n\tconfig_mutex.unlock();\n}", "CodeBleu_score": 47.08706348117534}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t//if the cell is an obstacle, set the target distance to the maximum obstacle cost and return false\n\tif (costmap.getCost(check_cell->x, check_cell->y) >= costmap_2d::NO_INFORMATION) {\n\t\tcheck_cell->target_distance = costmap.getCost(current_cell->x, current_cell->y);\n\t\treturn false;\n\t}\n\t//calculate a new target distance\n\tdouble new_target_distance = current_cell->target_distance + 1;\n\t//if the new target distance is shorter, update the cell's target distance\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 47.973305053418734}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// get the cost of the cell\n\tunsigned char cell_cost = costmap.getCost(check_cell->x, check_cell->y);\n\t// if the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false\n\tif (cell_cost >= costmap_2d::LETHAL_OBSTACLE) {\n\t\tcheck_cell->target_dist = costmap.getCost(current_cell->x, current_cell->y);\n\t\treturn false;\n\t}\n\n\t// calculate the new target distance\n\tdouble new_target_dist = current_cell->target_dist + sqrt(pow(check_cell->x - current_cell->x, 2) + pow(check_cell->y - current_cell->y, 2));\n\n\t// if the new distance is shorter, update the cell's target distance\n\tif (new_target_dist < check_cell->target_dist) {\n\t\tcheck_cell->target_dist = new_target_dist;\n\t}\n\n\t// return true\n\treturn true;\n}", "CodeBleu_score": 66.28046142326274}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// Check the cost of the cell using the costmap.\n\tunsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\n\t// If the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false.\n\tif (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n\t\tcheck_cell->target_distance = costmap.getCostMax();\n\t\treturn false;\n\t}\n\n\t// If the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter.\n\tdouble new_target_distance = current_cell->target_distance + costmap.getCostToCostmap(check_cell->x, check_cell->y);\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 64.74031893592212}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\t// Initialize the cost and scaling factor based on the trajectory and speed parameters.\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 0.0;\n\tif (traj.cost_scaling_factor_ > 0.0) {\n\t\tscaling_factor = 1.0 / traj.cost_scaling_factor_;\n\t} else {\n\t\tscaling_factor = 1.0;\n\t}\n\t// If the footprint specification is empty, it logs an error and returns -9.\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"ObstacleCostFunction: Footprint specification is empty.\");\n\t\treturn -9.0;\n\t}\n\t// For each point in the trajectory, it calculates the footprint cost.\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\t// If the footprint cost is negative, it returns the cost immediately.\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i));\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\t\t// Otherwise, it either sums the scores or takes the maximum score based on the sum_scores_ flag.\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost * scaling_factor;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost * scaling_factor);\n\t\t}\n\t}\n\t// Finally, it returns the total cost.\n\treturn cost;\n}", "CodeBleu_score": 47.7155794451767}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\t// initialize the cost and scaling factor based on the trajectory and speed parameters\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\n\t// if the footprint specification is empty, log an error and return -9\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty.\");\n\t\treturn -9.0;\n\t}\n\n\t// for each point in the trajectory\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\t// calculate the footprint cost\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i));\n\n\t\t// if the footprint cost is negative, return the cost immediately\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\n\t\t// either sum the scores or take the maximum score based on the sum_scores_ flag\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\t// return the total cost\n\treturn cost * scaling_factor;\n}", "CodeBleu_score": 47.09020910995731}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tdouble cost = 0.0;\n\tdouble scaling_factor = 0.0;\n\n\tif (traj.getPointsSize() == 0) {\n\t\tROS_ERROR(\"Trajectory has no points, cannot score\");\n\t\treturn -9.0;\n\t}\n\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty, cannot score\");\n\t\treturn -9.0;\n\t}\n\n\t// initialize cost and scaling factor based on trajectory and speed\n\tscaling_factor = 1.0 / (traj.getPoints().back().vel.norm() * traj.getPoints().back().vel.norm());\n\tcost = traj.getPoints().back().cost;\n\n\t// calculate footprint cost for each point in trajectory\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); i++) {\n\t\tdouble footprint_cost = 0.0;\n\t\tfootprint_cost = footprintCost(traj.getPoints()[i].pose, footprint_spec_);\n\n\t\t// if footprint cost is negative, return the cost immediately\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\n\t\t// either sum the scores or take the maximum score\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost * scaling_factor;\n\t\t} else {\n\t\t\tif (footprint_cost * scaling_factor > cost) {\n\t\t\t\tcost = footprint_cost * scaling_factor;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cost;\n}", "CodeBleu_score": 47.747228860467125}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t//ROS_INFO(\"footprintCost\");\n\t//ROS_INFO(\"x: %f\", x);\n\t//ROS_INFO(\"y: %f\", y);\n\t//ROS_INFO(\"th: %f\", th);\n\t//ROS_INFO(\"scale: %f\", scale);\n\t//ROS_INFO(\"footprint_spec size: %d\", footprint_spec.size());\n\t//ROS_INFO(\"costmap size: %d\", costmap->getSizeInCellsX());\n\t//ROS_INFO(\"costmap size: %d\", costmap->getSizeInCellsY());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsX());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsY());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsX());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsY());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsX());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsY());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsX());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsY());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsX());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsY());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsX());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsY());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsX());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsY());\n\t//ROS_INFO(\"world_model size: %d\", world_model->getSizeInCellsX());\n\t//ROS_INFO(\"world_model size: %d\", world_model->", "CodeBleu_score": 8.440668035394966}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t//    ROS_INFO(\"footprintCost\");\n\n    // scale the footprint\n    std::vector<geometry_msgs::Point> scaled_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        geometry_msgs::Point point;\n        point.x = footprint_spec[i].x * scale;\n        point.y = footprint_spec[i].y * scale;\n        scaled_footprint.push_back(point);\n    }\n\n    // compute the footprint cost\n    double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint);\n    if (footprint_cost < 0) {\n        return -6.0;\n    }\n\n    // compute the cell cost\n    unsigned int mx, my;\n    if (!costmap->worldToMap(x, y, mx, my)) {\n        return -7.0;\n    }\n    unsigned char cell_cost = costmap->getCost(mx, my);\n    if (cell_cost == costmap_2d::NO_INFORMATION) {\n        return -7.0;\n    }\n    return std::max(footprint_cost, (double)cell_cost);\n}", "CodeBleu_score": 73.42119560039654}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//    ROS_INFO(\"footprintCost\");\n\n    // Compute the footprint\n    std::vector<geometry_msgs::Point> footprint = footprint_spec;\n    for (unsigned int i = 0; i < footprint.size(); i++) {\n        geometry_msgs::Point footprint_point = footprint[i];\n        footprint_point.x = scale * footprint_point.x;\n        footprint_point.y = scale * footprint_point.y;\n        footprint[i] = footprint_point;\n    }\n\n    // Compute the footprint cost\n    double footprint_cost = world_model->footprintCost(x, y, th, footprint);\n\n    // If the footprint cost is negative, return -6.0\n    if (footprint_cost < 0) {\n        return -6.0;\n    }\n\n    // If the position is off the map, return -7.0\n    if (!costmap->worldToMap(x, y, x, y)) {\n        return -7.0;\n    }\n\n    // Otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n    double cell_cost = costmap->getCost(x, y);\n    return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 65.79129767832828}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (odom_topic_.empty()) {\n\t\t\tif (odom_sub_.get()) {\n\t\t\t\todom_sub_.shutdown();\n\t\t\t\todom_sub_.reset();\n\t\t\t}\n\t\t} else {\n\t\t\tif (!odom_sub_) {\n\t\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t\t} else {\n\t\t\t\todom_sub_.shutdown();\n\t\t\t\todom_sub_.reset();\n\t\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.57963696434197}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (!odom_topic_.empty()) {\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}", "CodeBleu_score": 44.906430684719034}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\tif (odom_topic!= \"\") {\n\t\t\todom_topic_ = odom_topic;\n\t\t\todom_sub_.shutdown();\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_topic_ = \"\";\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}", "CodeBleu_score": 44.65697267759578}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// Get the squared distance between the current and previous positions\n\tfloat sq_dist = (pos - prev).squaredNorm();\n\n\t// Get the angle between the current and previous positions\n\tfloat angle = std::abs(atan2(pos.y() - prev.y(), pos.x() - prev.x()));\n\n\t// Reset the oscillation flags if the squared distance exceeds a threshold or the angular difference is greater than a set angle\n\tif (sq_dist > sq_dist_threshold_ || angle > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 33.891676294659256}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat dx = pos(0) - prev(0);\n\tfloat dy = pos(1) - prev(1);\n\tfloat d_sq = dx * dx + dy * dy;\n\tfloat d = std::sqrt(d_sq);\n\n\tfloat d_threshold = 0.01;\n\tif (d > d_threshold) {\n\t\t// Reset oscillation flags\n\t\toscillation_cost_ = 0.0;\n\t\toscillating_ = false;\n\t}\n\n\tfloat d_angle = std::atan2(dy, dx);\n\tfloat d_angle_threshold = 0.1;\n\tif (d_angle > d_angle_threshold) {\n\t\t// Reset oscillation flags\n\t\toscillation_cost_ = 0.0;\n\t\toscillating_ = false;\n\t}\n}", "CodeBleu_score": 38.591445255507814}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tdouble dist_sq = (pos - prev).squaredNorm();\n\tdouble angle = std::abs(tf2::getYaw(pos) - tf2::getYaw(prev));\n\n\tif (dist_sq > dist_sq_threshold_ || angle > angle_threshold_) {\n\t\toscillation_flags_.reset();\n\t}\n}", "CodeBleu_score": 29.767569286895945}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// Check if the point is within the grid bounds\n\tif (pt.x < min_x_ || pt.x > max_x_ || pt.y < min_y_ || pt.y > max_y_) {\n\t\treturn;\n\t}\n\n\t// Check if the point is too close to its nearest neighbor\n\tdouble dist = hypot(pt.x - min_x_, pt.y - min_y_);\n\tif (dist < min_dist_) {\n\t\treturn;\n\t}\n\n\t// Calculate the grid coordinates of the point\n\tint x_coord = (pt.x - min_x_) / cell_size_;\n\tint y_coord = (pt.y - min_y_) / cell_size_;\n\n\t// Calculate the grid index\n\tint index = y_coord * grid_width_ + x_coord;\n\n\t// Insert the point into the corresponding cell\n\tif (index < grid_size_) {\n\t\tgrid_[index].push_back(pt);\n\t}\n}", "CodeBleu_score": 42.5554331126924}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//ROS_DEBUG(\"PointGrid::insert\");\n\t//ROS_DEBUG(\"pt.x: %f\", pt.x);\n\t//ROS_DEBUG(\"pt.y: %f\", pt.y);\n\t//ROS_DEBUG(\"pt.z: %f\", pt.z);\n\n\tif (pt.x < min_x_ || pt.x > max_x_ || pt.y < min_y_ || pt.y > max_y_) {\n\t\t//ROS_DEBUG(\"PointGrid::insert: point is out of bounds\");\n\t\treturn;\n\t}\n\n\t//ROS_DEBUG(\"PointGrid::insert: point is in bounds\");\n\n\tint index_x, index_y;\n\n\tif (!worldToMap(pt.x, pt.y, index_x, index_y)) {\n\t\t//ROS_DEBUG(\"PointGrid::insert: point is too close to nearest neighbor\");\n\t\treturn;\n\t}\n\n\t//ROS_DEBUG(\"PointGrid::insert: point is far enough from nearest neighbor\");\n\n\tint index = index_x + (index_y * grid_size_x_);\n\n\t//ROS_DEBUG(\"PointGrid::insert: index: %d\", index);\n\n\tif (grid_[index] == NULL) {\n\t\t//ROS_DEBUG(\"PointGrid::insert: grid_[index] is NULL\");\n\t\tgrid_[index] = new std::vector<geometry_msgs::Point32>();\n\t}\n\n\t//ROS_DEBUG(\"PointGrid::insert: grid_[index] is not NULL\");\n\n\tgrid_[index]->push_back(pt);\n}", "CodeBleu_score": 42.81174201623082}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// TODO: check for NaNs\n\n\t// find the cell containing the point\n\tint cell_x, cell_y;\n\tif (!worldToMap(pt.x, pt.y, cell_x, cell_y)) {\n\t\treturn;\n\t}\n\n\t// check if the point is too close to a neighbor\n\tif (isTooClose(pt, cell_x, cell_y)) {\n\t\treturn;\n\t}\n\n\t// calculate the index of the cell in the grid\n\tint index = cell_x + cell_y * grid_size_x_;\n\n\t// insert the point into the cell\n\tcells_[index].push_back(pt);\n}", "CodeBleu_score": 47.67775787501637}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t//  Eigen::Vector3f new_vel;\n//  new_vel << 0.0, 0.0, 0.0;\n//  for (int i = 0; i < 3; i++) {\n//    if (sample_target_vel[i] > vel[i]) {\n//      new_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n//    } else {\n//      new_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n//    }\n//  }\n//  return new_vel;\n\tEigen::Vector3f new_vel;\n\tnew_vel << 0.0, 0.0, 0.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 45.997808032771495}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t}\n\n\treturn new_vel;\n}", "CodeBleu_score": 70.17302977382846}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tfor (unsigned int i = 0; i < 3; ++i) {\n\t\tdouble vel_diff = sample_target_vel[i] - vel[i];\n\t\tif (vel_diff > acclimits[i] * dt) {\n\t\t\tnew_vel[i] = vel[i] + acclimits[i] * dt;\n\t\t} else if (vel_diff < -acclimits[i] * dt) {\n\t\t\tnew_vel[i] = vel[i] - acclimits[i] * dt;\n\t\t} else {\n\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 67.36949500167356}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t//ROS_INFO(\"TrajectoryPlanner::headingDiff\");\n\tdouble goal_x = x;\n\tdouble goal_y = y;\n\n\t//ROS_INFO(\"goal_x: %f\", goal_x);\n\t//ROS_INFO(\"goal_y: %f\", goal_y);\n\n\t//ROS_INFO(\"cell_x: %d\", cell_x);\n\t//ROS_INFO(\"cell_y: %d\", cell_y);\n\n\t//ROS_INFO(\"x: %f\", x);\n\t//ROS_INFO(\"y: %f\", y);\n\n\t//ROS_INFO(\"heading: %f\", heading);\n\n\t//ROS_INFO(\"goal_x - x: %f\", goal_x - x);\n\t//ROS_INFO(\"goal_y - y: %f\", goal_y - y);\n\n\t//ROS_INFO(\"cos(heading): %f\", cos(heading));\n\t//ROS_INFO(\"sin(heading): %f\", sin(heading));\n\n\t//ROS_INFO(\"cos(heading) * (goal_x - x) + sin(heading) * (goal_y - y): %f\", cos(heading) * (goal_x - x) + sin(heading) * (goal_y - y));\n\n\t//ROS_INFO(\"cos(heading) * (goal_x - x) - sin(heading) * (goal_y - y): %f\", cos(heading) * (goal_x - x) - sin(heading) * (goal_y - y));\n\n\t//ROS_INFO(\"acos(cos(heading) * (goal_x - x) + sin(heading) * (goal_y - y)): %f\", acos(cos(heading) * (goal_x - x) + sin(heading) * (goal_y - y)));\n\n\t//ROS_INFO(\"acos(cos(heading) * (goal_x - x) - sin(heading) * (goal_y - y)): %f\", acos(cos(heading) * (goal_x - x) - sin(heading) * (goal_y - y)));\n\n\t//ROS_INFO(\"acos(cos(heading) * (goal_x - x) + sin(heading) * (goal_y - y)) - acos(", "CodeBleu_score": 7.330470755795888}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble dx = x - cell_x;\n\tdouble dy = y - cell_y;\n\tdouble diff = std::abs(tf2::getYaw(heading) - tf2::getYaw(atan2(dy, dx)));\n\tif (diff > M_PI) {\n\t\tdiff = 2.0 * M_PI - diff;\n\t}\n\treturn diff;\n}", "CodeBleu_score": 23.112668007907374}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t//ROS_INFO(\"headingDiff\");\n\t//ROS_INFO(\"cell_x: %d\", cell_x);\n\t//ROS_INFO(\"cell_y: %d\", cell_y);\n\t//ROS_INFO(\"x: %f\", x);\n\t//ROS_INFO(\"y: %f\", y);\n\t//ROS_INFO(\"heading: %f\", heading);\n\n\t//ROS_INFO(\"x_map: %f\", x_map);\n\t//ROS_INFO(\"y_map: %f\", y_map);\n\t//ROS_INFO(\"cell_x_map: %d\", cell_x_map);\n\t//ROS_INFO(\"cell_y_map: %d\", cell_y_map);\n\t//ROS_INFO(\"map_width: %d\", map_width);\n\t//ROS_INFO(\"map_height: %d\", map_height);\n\t//ROS_INFO(\"map_resolution: %f\", map_resolution);\n\t//ROS_INFO(\"map_origin_x: %f\", map_origin_x);\n\t//ROS_INFO(\"map_origin_y: %f\", map_origin_y);\n\n\t//ROS_INFO(\"x_map_origin: %f\", x_map_origin);\n\t//ROS_INFO(\"y_map_origin: %f\", y_map_origin);\n\t//ROS_INFO(\"x_map_origin_cell: %d\", x_map_origin_cell);\n\t//ROS_INFO(\"y_map_origin_cell: %d\", y_map_origin_cell);\n\n\t//ROS_INFO(\"x_map_origin_cell_map: %d\", x_map_origin_cell_map);\n\t//ROS_INFO(\"y_map_origin_cell_map: %d\", y_map_origin_cell_map);\n\n\t//ROS_INFO(\"cell_x_map_origin_cell_map: %d\", cell_x_map_origin_cell_map);\n\t//ROS_INFO(\"cell_y_map_origin_cell_map: %d\", cell_y_map_origin_cell_map);\n\n\t//ROS_INFO(\"cell_x_map_origin_cell_map_map: %d", "CodeBleu_score": 3.719603944995469}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t// TODO: Implement this function\n\t// The trajectory is valid if the score is non-negative\n\t// Otherwise, log a warning and return false\n\t// Use the sample velocities to compute the cost\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost < 0) {\n\t\tROS_WARN(\"Trajectory cost: %f\", cost);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 65.92041573901011}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t// Compute the trajectory\n\tstd::vector<geometry_msgs::PoseStamped> global_plan;\n\tif (!computeTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, global_plan)) {\n\t\tROS_WARN(\"The planner failed to find a valid plan for the given trajectory.\");\n\t\treturn false;\n\t}\n\t// Compute the cost\n\tdouble cost = scoreTrajectory(global_plan);\n\tif (cost >= 0) {\n\t\treturn true;\n\t}\n\tROS_WARN(\"The planner failed to find a valid plan for the given trajectory. Cost: %f\", cost);\n\treturn false;\n}", "CodeBleu_score": 59.09798128367405}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t// TODO: Implement this function.\n\t// You can use the scoreTrajectory function to compute the cost.\n\t// If the cost is non-negative, the trajectory is considered valid.\n\t// If the cost is negative, it logs a warning with the sample velocities and cost, then returns false.\n\t// If the cost is positive, it returns true.\n\t// The cost should be computed using the costmap, not the global plan.\n\t// You can use the getCost function of the costmap to get the cost of a cell.\n\t// You can use the getCostmap function of the costmap to get the costmap.\n\t// You can use the getRobotFootprint function of the costmap to get the footprint of the robot.\n\t// You can use the footprintToWorld function of the costmap to get the footprint of the robot in the world frame.\n\t// You can use the worldToFootprint function of the costmap to get the footprint of the robot in the costmap frame.\n\t// You can use the worldToMap function of the costmap to get the cell index of a point in the world frame.\n\t// You can use the mapToWorld function of the costmap to get the point of a cell in the world frame.\n\t// You can use the getRobotPose function of the costmap to get the pose of the robot in the world frame.\n\t// You can use the getRobotPose function of the costmap to get the pose of the robot in the costmap frame.\n\t// You can use the getRobotPose function of the costmap to get the pose of the robot in the costmap frame.\n\t// You can use the getRobotPose function of the costmap to get the pose of the robot in the costmap frame.\n\t// You can use the getRobotPose function of the costmap to get the pose of the robot in the costmap frame.\n\t// You can use the getRobotPose function of the costmap to get the pose of the robot in the costmap frame.\n\t// You can use the getRobotPose function of the costmap to get the pose of the robot in the costmap frame.\n\t// You can use the getRobotPose function of the costmap to get the pose of the robot in the costmap frame.\n\t// You can use the getRobotPose function of the cost", "CodeBleu_score": 10.11041935159191}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior() can be called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The global_costmap_ is not set, calling runBehavior on a default constructor does nothing\");\n\t\treturn;\n\t}\n\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local_costmap_ is not set, calling runBehavior on a default constructor does nothing\");\n\t\treturn;\n\t}\n\n\tros::Time start = ros::Time::now();\n\n\tif (affected_maps_ & CLEAR_GLOBAL_COSTMAP) {\n\t\tROS_INFO(\"Clearing global costmap\");\n\t\tglobal_costmap_->resetMap(force_update_);\n\t}\n\n\tif (affected_maps_ & CLEAR_LOCAL_COSTMAP) {\n\t\tROS_INFO(\"Clearing local costmap\");\n\t\tlocal_costmap_->resetMap(force_update_);\n\t}\n\n\tros::Time end = ros::Time::now();\n\tros::Duration duration = end - start;\n\tROS_INFO(\"Clearing costmaps took %.3f seconds\", duration.toSec());\n}", "CodeBleu_score": 40.565482554531336}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior() is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The cost map passed to the ClearCostmapRecovery object is NULL. Doing nothing.\");\n\t\treturn;\n\t}\n\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local cost map passed to the ClearCostmapRecovery object is NULL. Doing nothing.\");\n\t\treturn;\n\t}\n\n\tROS_INFO(\"Clearing costmaps\");\n\n\t// Clear the global costmap\n\tif (affected_maps_ & CLEAR_COSTMAP_GLOBAL) {\n\t\tROS_INFO(\"Clearing global costmap\");\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->updateMap();\n\t\t}\n\t\tglobal_costmap_->resetMap(invert_area_to_clear_);\n\t\tROS_INFO(\"Clearing global costmap took %.2f seconds\", (ros::WallTime::now() - start_time_).toSec());\n\t}\n\n\t// Clear the local costmap\n\tif (affected_maps_ & CLEAR_COSTMAP_LOCAL) {\n\t\tROS_INFO(\"Clearing local costmap\");\n\t\tif (force_update_) {\n\t\t\tlocal_costmap_->updateMap();\n\t\t}\n\t\tlocal_costmap_->resetMap(invert_area_to_clear_);\n\t\tROS_INFO(\"Clearing local costmap took %.2f seconds\", (ros::WallTime::now() - start_time_).toSec());\n\t}\n}", "CodeBleu_score": 47.70824045836887}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The planner's global costmap is not set.  Doing nothing.\");\n\t\treturn;\n\t}\n\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The planner's local costmap is not set.  Doing nothing.\");\n\t\treturn;\n\t}\n\n\tif (affected_maps_ == CLEAR_ALL) {\n\t\tROS_INFO(\"Clearing global and local costmaps.\");\n\t} else {\n\t\tif (affected_maps_ & CLEAR_GLOBAL) {\n\t\t\tROS_INFO(\"Clearing global costmap.\");\n\t\t}\n\n\t\tif (affected_maps_ & CLEAR_LOCAL) {\n\t\t\tROS_INFO(\"Clearing local costmap.\");\n\t\t}\n\t}\n\n\tif (affected_maps_ & CLEAR_GLOBAL) {\n\t\tROS_INFO(\"Clearing global costmap.\");\n\t\tif (force_update_) {\n\t\t\tROS_INFO(\"Forcing global costmap update.\");\n\t\t}\n\t\tROS_INFO(\"Clearing global costmap.\");\n\t\tglobal_costmap_->resetMap();\n\t}\n\n\tif (affected_maps_ & CLEAR_LOCAL) {\n\t\tROS_INFO(\"Clearing local costmap.\");\n\t\tif (force_update_) {\n\t\t\tROS_INFO(\"Forcing local costmap update.\");\n\t\t}\n\t\tlocal_costmap_->resetMap();\n\t}\n}", "CodeBleu_score": 42.21352709638641}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t// TODO: Implement me\n\t//polygon_cells.clear();\n\t//if (polygon.size() < 3) {\n\t//\treturn;\n\t//}\n\t//MapLocation last_point = polygon.back();\n\t//for (int i = 0; i < polygon.size() - 1; i++) {\n\t//\tMapLocation start_point = polygon[i];\n\t//\tMapLocation end_point = polygon[i + 1];\n\t//\traytraceLine(start_point, end_point, polygon_cells);\n\t//}\n\t//if (polygon_cells.size() > 0) {\n\t//\tMapLocation start_point = polygon.front();\n\t//\tMapLocation end_point = polygon.back();\n\t//\traytraceLine(start_point, end_point, polygon_cells);\n\t//}\n}", "CodeBleu_score": 5.1108987274786815}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\n\t// Initialize the object to gather the cells\n\tPolygonOutlineCells polygon_outline_cells(this);\n\n\t// Iterate through the polygon vertices\n\tfor (unsigned int i = 0; i < polygon.size() - 1; i++) {\n\t\t// Gather the cells between each consecutive pair of points\n\t\traytraceLine(polygon[i], polygon[i + 1], &polygon_outline_cells);\n\t}\n\n\t// If the polygon is not empty, close it by connecting the last point to the first\n\tif (!polygon.empty()) {\n\t\traytraceLine(polygon[polygon.size() - 1], polygon[0], &polygon_outline_cells);\n\t}\n\n\t// Add the cells to the output vector\n\tpolygon_cells = polygon_outline_cells.getPolygonOutlineCells();\n}", "CodeBleu_score": 56.81812974373045}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tMapLocation last = polygon.back();\n\tfor (unsigned int i = 0; i < polygon.size(); ++i) {\n\t\tMapLocation current = polygon[i];\n\t\traytraceLine(last, current, polygon_cells);\n\t\tlast = current;\n\t}\n\tif (!polygon_cells.empty()) {\n\t\tMapLocation first = polygon.front();\n\t\traytraceLine(last, first, polygon_cells);\n\t}\n}", "CodeBleu_score": 44.81771739670167}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t// Prepare the grid data\n\tprepareGrid();\n\n\t// Publish the prepared grid\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.90268748571795}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t// prepare the grid\n\tprepareGrid();\n\n\t// publish the prepared grid\n\tpub.publish(grid);\n}", "CodeBleu_score": 73.09148172409799}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t// prepare the grid data\n\tprepareGrid();\n\n\t// publish the grid data\n\tpub.publish(grid);\n}", "CodeBleu_score": 73.09148172409799}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tresolution_ = costmap_->getResolution();\n\tunsigned int width = costmap_->getSizeInCellsX();\n\tunsigned int height = costmap_->getSizeInCellsY();\n\tunsigned int size = width * height;\n\tgrid_.info.resolution = resolution_;\n\tgrid_.info.width = width;\n\tgrid_.info.height = height;\n\n\t// Convert map coordinates to world coordinates for the origin\n\tdouble origin_x, origin_y, origin_th;\n\tcostmap_->getOrigin(origin_x, origin_y, origin_th);\n\tgrid_.info.origin.position.x = origin_x;\n\tgrid_.info.origin.position.y = origin_y;\n\tgrid_.info.origin.position.z = 0.0;\n\ttf::Quaternion q;\n\tq.setRPY(0, 0, origin_th);\n\ttf::quaternionTFToMsg(q, grid_.info.origin.orientation);\n\n\t// Save origin coordinates\n\torigin_x_ = origin_x;\n\torigin_y_ = origin_y;\n\torigin_th_ = origin_th;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(size);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < width; ++i) {\n\t\tfor (unsigned int j = 0; j < height; ++j) {\n\t\t\tint index = i + (j * width);\n\t\t\tgrid_.data[index] = costmap_translation_[costmap_->getCharCost(i, j)];\n\t\t}\n\t}\n}", "CodeBleu_score": 53.370847230141585}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tresolution_ = costmap_->getResolution();\n\tunsigned int size_x = costmap_->getSizeInCellsX();\n\tunsigned int size_y = costmap_->getSizeInCellsY();\n\n\t// Prepare the header\n\theader_.stamp = ros::Time::now();\n\theader_.frame_id = costmap_->getGlobalFrameID();\n\n\t// Prepare the grid\n\tgrid_.info.resolution = resolution_;\n\tgrid_.info.width = size_x;\n\tgrid_.info.height = size_y;\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tdouble origin_x, origin_y, origin_yaw;\n\tcostmap_->getOrigin(origin_x, origin_y, origin_yaw);\n\tgrid_.info.origin.position.x = origin_x;\n\tgrid_.info.origin.position.y = origin_y;\n\ttf::Quaternion orientation;\n\torientation.setRPY(0, 0, origin_yaw);\n\tgrid_.info.origin.orientation.x = orientation.x();\n\tgrid_.info.origin.orientation.y = orientation.y();\n\tgrid_.info.origin.orientation.z = orientation.z();\n\tgrid_.info.origin.orientation.w = orientation.w();\n\n\t// Save the origin coordinates\n\torigin_x_ = origin_x;\n\torigin_y_ = origin_y;\n\torigin_yaw_ = origin_yaw;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(size_x * size_y);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < size_y; ++i) {\n\t\tfor (unsigned int j = 0; j < size_x; ++j) {\n\t\t\tunsigned int index = i * size_x + j;\n\t\t\tunsigned char cost = costmap_->getCost(j, i);\n\t\t\tgrid_.data[index] = costmap_2d::translateCostmapValue(cost);\n\t\t}\n\t}\n}", "CodeBleu_score": 51.10834242128244}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tcostmap_2d::Costmap2D* costmap = costmap_2d_ros_->getCostmap();\n\tif (!costmap) {\n\t\tROS_ERROR(\"Could not get costmap\");\n\t\treturn;\n\t}\n\tcostmap_2d::Costmap2D::CellCost cell;\n\tstd::vector<unsigned char> costmap_data;\n\tcostmap_2d::Costmap2D::CellCost min_cell;\n\tcostmap_2d::Costmap2D::CellCost max_cell;\n\tcostmap->getCostmapCopy(costmap_data, min_cell, max_cell);\n\tcostmap_2d::Costmap2D::CellCost min_cost = costmap->getCost(min_cell);\n\tcostmap_2d::Costmap2D::CellCost max_cost = costmap->getCost(max_cell);\n\n\t// Lock the costmap mutex\n\tcostmap->lock();\n\n\t// Get the resolution\n\tdouble resolution;\n\tcostmap->getResolution(resolution);\n\n\t// Set the header\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap->getGlobalFrameID();\n\n\t// Set the resolution\n\tgrid_.info.resolution = resolution;\n\n\t// Set the width and height\n\tgrid_.info.width = costmap->getSizeInCellsX();\n\tgrid_.info.height = costmap->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tcostmap_2d::MapLocation origin;\n\tcostmap->mapToWorld(costmap->getOriginX(), costmap->getOriginY(), origin.x, origin.y);\n\n\t// Set the origin\n\tgrid_.info.origin = origin;\n\n\t// Save the origin coordinates\n\torigin_x_ = origin.x;\n\torigin_y_ = origin.y;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < grid_.info.width * grid_.info.height; ++i) {\n\t\tgrid", "CodeBleu_score": 48.934321748995515}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint.size() == old_config.footprint.size() &&\n\t    new_config.robot_radius == old_config.robot_radius)\n\t\treturn;\n\tif (new_config.footprint.size() > 0) {\n\t\tif (!costmap_2d::readFootprint(new_config.footprint, robot_radius_, footprint_)) {\n\t\t\tROS_ERROR(\"The footprint string is not valid.\");\n\t\t}\n\t} else {\n\t\tfootprint_.clear();\n\t\tfootprint_.push_back(geometry_msgs::Point(robot_radius_, robot_radius_, 0.0));\n\t\tfootprint_.push_back(geometry_msgs::Point(-robot_radius_, robot_radius_, 0.0));\n\t\tfootprint_.push_back(geometry_msgs::Point(-robot_radius_, -robot_radius_, 0.0));\n\t\tfootprint_.push_back(geometry_msgs::Point(robot_radius_, -robot_radius_, 0.0));\n\t}\n}", "CodeBleu_score": 48.627927713497634}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint.size() == old_config.footprint.size() &&\n\t    new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\n\tif (new_config.footprint.size() > 0) {\n\t\tif (readFootprintFromParameterServer(new_config.footprint)) {\n\t\t\tROS_DEBUG(\"Updated footprint to %d points\", (int)footprint_.size());\n\t\t} else {\n\t\t\tROS_ERROR(\"The footprint provided to the costmap is not a valid polygon and will be ignored.\");\n\t\t}\n\t} else {\n\t\tROS_DEBUG(\"Using default footprint for radius: %.2f\", new_config.robot_radius);\n\t\tfootprint_ = createRobotFootprint(new_config.robot_radius);\n\t}\n}", "CodeBleu_score": 57.88029730414019}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint.size() == old_config.footprint.size() &&\n\t    new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\n\tif (new_config.footprint.empty()) {\n\t\tROS_WARN(\"No footprint provided. Using the robot radius instead.\");\n\t\tsetRobotFootprint(new_config.robot_radius);\n\t\treturn;\n\t}\n\n\tstd::vector<geometry_msgs::Point> footprint;\n\tif (!costmap_2d::readFootprintFromConfig(new_config.footprint, footprint)) {\n\t\tROS_ERROR(\"Invalid footprint string. Using the robot radius instead.\");\n\t\tsetRobotFootprint(new_config.robot_radius);\n\t\treturn;\n\t}\n\n\tsetRobotFootprint(footprint);\n}", "CodeBleu_score": 53.86121229851166}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!new_pose_available_) {\n\t\treturn;\n\t}\n\n\tgeometry_msgs::PoseStamped pose;\n\tif (!getRobotPose(pose)) {\n\t\tROS_WARN(\"Failed to get robot pose, cancelling reconfigure\");\n\t\treturn;\n\t}\n\n\t// If the robot has moved, we need to reconfigure the costmap\n\tif (pose.pose!= new_pose_) {\n\t\treconfigureCB(event);\n\t}\n}", "CodeBleu_score": 57.855569123963505}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// get the current pose of the robot\n\tif (!tf_->waitForTransform(global_frame_, base_frame_, ros::Time(), ros::Duration(0.1), ros::Duration(0.01), &tf_error_)) {\n\t\tROS_WARN(\"Failed to transform from %s to %s - costmap2d cannot make a plan\", base_frame_.c_str(), global_frame_.c_str());\n\t\treturn;\n\t}\n\ttf2::Stamped<tf2::Transform> tf_current;\n\ttry {\n\t\ttf_->lookupTransform(global_frame_, base_frame_, ros::Time(), tf_current);\n\t} catch (tf2::TransformException &ex) {\n\t\tROS_WARN(\"Failed to transform from %s to %s: %s\", global_frame_.c_str(), base_frame_.c_str(), ex.what());\n\t\treturn;\n\t}\n\ttf2::toMsg(tf_current, new_pose_);\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new_pose_;\n\t// update the global pose of the robot\n\tglobal_pose_ = new", "CodeBleu_score": 37.44212234405816}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// Get the current pose of the robot.\n\tgeometry_msgs::PoseStamped pose;\n\tif (!getRobotPose(pose)) {\n\t\tROS_WARN(\"Could not get robot pose, cancelling reconfiguration.\");\n\t\treturn;\n\t}\n\n\t// Get the current pose of the robot.\n\tgeometry_msgs::PoseStamped new_pose;\n\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN(\"Could not get robot pose, cancelling reconfiguration.\");\n\t\treturn;\n\t}\n\n\t// If the robot has moved, reconfigure the costmap.\n\tif (new_pose.pose.position.x!= pose.pose.position.x || new_pose.pose.position.y!= pose.pose.position.y || new_pose.pose.position.z!= pose.pose.position.z) {\n\t\treconfigureCB(event);\n\t}\n}", "CodeBleu_score": 60.89986244740847}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\t// Check if the costmap is already running\n\tif (running_) {\n\t\tROS_WARN(\"Costmap2DROS::start() called when costmap already running\");\n\t\treturn;\n\t}\n\n\t// Check if ROS is running\n\tif (!ros::isInitialized()) {\n\t\tROS_ERROR(\"Costmap2DROS::start() called before ros::init()\");\n\t\treturn;\n\t}\n\n\t// Check if the costmap is initialized\n\tif (!initialized_) {\n\t\tROS_ERROR(\"Costmap2DROS::start() called before costmap initialized\");\n\t\treturn;\n\t}\n\n\t// Check if the map update thread is active\n\tif (!map_update_thread_active_) {\n\t\tROS_ERROR(\"Costmap2DROS::start() called before map update thread active\");\n\t\treturn;\n\t}\n\n\t// Check if the costmap is stopped\n\tif (stopped_) {\n\t\t// Re-subscribe to topics\n\t\tfor (auto& plugin : plugins_) {\n\t\t\tplugin->activate();\n\t\t}\n\t\tstopped_ = false;\n\t}\n\n\t// Set stop_updates_ to false\n\tstop_updates_ = false;\n\n\t// Set running_ to true\n\trunning_ = true;\n}", "CodeBleu_score": 41.598172005196}, {"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\t// activate plugins\n\t\tfor (auto& plugin : plugins_) {\n\t\t\tplugin->activate();\n\t\t}\n\t\t// re-subscribe to topics\n\t\tros::NodeHandle nh;\n\t\tros::NodeHandle private_nh(\"~/\" + name_);\n\t\tfor (auto& plugin : plugins_) {\n\t\t\tplugin->initialize(nh, private_nh);\n\t\t}\n\t\t// set stopped to false\n\t\tstopped_ = false;\n\t\tstop_updates_ = false;\n\n\t\t// wait until ROS is running\n\t\twhile (!ros::isInitialized()) {\n\t\t\tif (!ros::ok()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tROS_WARN_THROTTLE(1.0, \"Costmap2DROS::start: waiting for ROS to initialize\");\n\t\t\tros::WallDuration(0.1).sleep();\n\t\t}\n\n\t\t// wait until the costmap is initialized\n\t\twhile (!is_initialized()) {\n\t\t\tif (!ros::ok()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tROS_WARN_THROTTLE(1.0, \"Costmap2DROS::start: waiting for costmap to be initialized\");\n\t\t\tros::WallDuration(0.1).sleep();\n\t\t}\n\n\t\t// wait until the map update thread is active\n\t\twhile (!is_updated()) {\n\t\t\tif (!ros::ok()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tROS_WARN_THROTTLE(1.0, \"Costmap2DROS::start: waiting for map update thread to start\");\n\t\t\tros::WallDuration(0.1).sleep();\n\t\t}\n\t}\n}", "CodeBleu_score": 38.24947931839515}, {"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\tROS_DEBUG(\"Costmap2DROS::start: Resuming costmap...\");\n\t\tstd::vector<std::string> plugins = layered_costmap_->getPlugins();\n\t\tfor (unsigned int i = 0; i < plugins.size(); i++) {\n\t\t\tif (layered_costmap_->isPlugin(plugins[i], \"inflation\")) {\n\t\t\t\tlayered_costmap_->activatePlugin(plugins[i], \"inflation\");\n\t\t\t} else {\n\t\t\t\tlayered_costmap_->activatePlugin(plugins[i], \"obstacle_layer\");\n\t\t\t}\n\t\t}\n\t\tstopped_ = false;\n\t\tstop_updates_ = false;\n\t\tif (map_update_thread_ == NULL) {\n\t\t\tmap_update_thread_ = new boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this));\n\t\t}\n\t}\n}", "CodeBleu_score": 45.32028926145119}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t//ROS_INFO(\"purgeStaleObservations\");\n\t//ROS_INFO(\"size: %d\", observations_.size());\n\tif (observations_.size() > 0) {\n\t\t//ROS_INFO(\"observations_.size() > 0\");\n\t\t//ROS_INFO(\"size: %d\", observations_.size());\n\t\t//ROS_INFO(\"observations_.begin()->first: %f\", observations_.begin()->first);\n\t\t//ROS_INFO(\"observations_.rbegin()->first: %f\", observations_.rbegin()->first);\n\t\t//ROS_INFO(\"observations_.rbegin()->first - observations_.begin()->first: %f\", observations_.rbegin()->first - observations_.begin()->first);\n\t\t//ROS_INFO(\"observation_keep_time_: %f\", observation_keep_time_);\n\t\tif (observation_keep_time_ > 0.0 && (observations_.rbegin()->first - observations_.begin()->first) > observation_keep_time_) {\n\t\t\t//ROS_INFO(\"observation_keep_time_ > 0.0 && (observations_.rbegin()->first - observations_.begin()->first) > observation_keep_time_\");\n\t\t\t//ROS_INFO(\"observations_.rbegin()->first - observations_.begin()->first: %f\", observations_.rbegin()->first - observations_.begin()->first);\n\t\t\t//ROS_INFO(\"observation_keep_time_: %f\", observation_keep_time_);\n\t\t\t//ROS_INFO(\"observations_.size(): %d\", observations_.size());\n\t\t\t//ROS_INFO(\"observations_.size() / 2: %d\", observations_.size() / 2);\n\t\t\t//ROS_INFO(\"observations_.rbegin()->first - observation_keep_time_: %f\", observations_.rbegin()->first - observation_keep_time_);\n\t\t\t//ROS_INFO(\"observations_.begin()->first: %f\", observations_.begin()->first);\n\t\t\t//ROS_INFO(\"observations_.begin()->first + observation_keep_time_: %f\", observations_.begin()->first + observation_keep_time_);\n\t\t\t//ROS_INFO(\"observations_.begin()->first + observation_keep_time_: %f\", observations_.begin()->first + observation_keep_time_);\n\t\t\t//ROS_INFO(\"observations_.begin()->first + observation_keep_time_: %f\", observations_.begin()->first + observation", "CodeBleu_score": 17.817754959364255}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t//If the observation_keep_time_ is zero, it keeps only the most recent observation.\n\tif(observation_keep_time_ == 0) {\n\t\t//If there is only one observation, it is the most recent observation.\n\t\tif(observations_.size() == 1) {\n\t\t\treturn;\n\t\t}\n\t\t//Otherwise, remove the oldest observation.\n\t\tobservations_.pop_front();\n\t\treturn;\n\t}\n\t//Otherwise, it iterates through the list and removes observations that are older than the specified keep time, stopping once it finds a valid observation.\n\tfor(std::list<Observation>::iterator it = observations_.begin(); it!= observations_.end(); ++it) {\n\t\tif(it->observation_time_ + observation_keep_time_ > ros::Time::now()) {\n\t\t\treturn;\n\t\t}\n\t}\n\t//If we get here, all observations are stale.\n\tobservations_.clear();\n}", "CodeBleu_score": 33.25845969375873}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (this->observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\t//ROS_INFO(\"purgeStaleObservations\");\n\t//ROS_INFO(\"this->observations_.size() = %d\", this->observations_.size());\n\t//ROS_INFO(\"this->observations_.begin()->first = %d\", this->observations_.begin()->first);\n\t//ROS_INFO(\"this->observations_.end()->first = %d\", this->observations_.end()->first);\n\t//ROS_INFO(\"this->observations_.end()->first - this->observations_.begin()->first = %d\", this->observations_.end()->first - this->observations_.begin()->first);\n\t//ROS_INFO(\"this->observation_keep_time_ = %d\", this->observation_keep_time_);\n\t//ROS_INFO(\"this->observations_.end()->first - this->observation_keep_time_ = %d\", this->observations_.end()->first - this->observation_keep_time_);\n\t//ROS_INFO(\"this->observations_.begin()->first + this->observation_keep_time_ = %d\", this->observations_.begin()->first + this->observation_keep_time_);\n\t//ROS_INFO(\"this->observations_.end()->first - this->observation_keep_time_ = %d\", this->observations_.end()->first - this->observation_keep_time_);\n\t//ROS_INFO(\"this->observations_.end()->first - this->observation_keep_time_ = %d\", this->observations_.end()->first - this->observation_keep_time_);\n\t//ROS_INFO(\"this->observations_.begin()->first + this->observation_keep_time_ = %d\", this->observations_.begin()->first + this->observation_keep_time_);\n\t//ROS_INFO(\"this->observations_.begin()->first + this->observation_keep_time_ = %d\", this->observations_.begin()->first + this->observation_keep_time_);\n\t//ROS_INFO(\"this->observations_.begin()->first + this->observation_keep_time_ = %d\", this->observations_.begin()->first + this->observation_keep_time_);\n\t//ROS_INFO(\"this->observations_.begin()->first + this->observation_keep_time_ = %d\", this->observations_.", "CodeBleu_score": 3.755308806515098}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\tdouble diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\tdouble inc = diff / (end_index - start_index);\n\tfor (int i = start_index; i < end_index; i++) {\n\t\tdouble yaw = tf2::getYaw(path[i].pose.orientation);\n\t\tyaw += inc;\n\t\tpath[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Matrix3x3(tf2::Vector3(0, 0, 1), tf2::Vector3(0, 1, 0), tf2::Vector3(1, 0, 0)).rotate(tf2::Vector3(0, 0, yaw))));\n\t}\n}", "CodeBleu_score": 62.18365905092048}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (start_index >= end_index) {\n\t\tROS_ERROR(\"start_index >= end_index\");\n\t\treturn;\n\t}\n\n\t// Get the yaw angles of the start and end poses\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Determine the shortest angular distance between the start and end yaw angles\n\tdouble angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose\n\tdouble angle_increment = angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tdouble new_yaw = start_yaw + (i - start_index) * angle_increment;\n\t\ttf2::Quaternion new_orientation;\n\t\tnew_orientation.setRPY(0, 0, new_yaw);\n\t\tpath[i].pose.orientation = tf2::toMsg(new_orientation);\n\t}\n}", "CodeBleu_score": 59.49596260626113}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\tdouble diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\tdouble inc = diff / (end_index - start_index);\n\n\tfor (int i = start_index; i < end_index; i++) {\n\t\tdouble yaw = start_yaw + inc * (i - start_index);\n\t\ttf2::Quaternion q = tf2::Quaternion(0, 0, sin(yaw / 2), cos(yaw / 2));\n\t\tpath[i].pose.orientation = tf2::toMsg(q);\n\t}\n}", "CodeBleu_score": 66.21107743571811}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tif(!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn false;\n\t}\n\t// make sure to set the frame_id of the start and goal to the map frame!\n\tstd::string global_frame = planner_util_.getGlobalFrame();\n\tif(req.start.header.frame_id!= global_frame) {\n\t\tROS_ERROR(\"The planner has been asked to make a plan to start in frame %s, but we only support %s\", req.start.header.frame_id.c_str(), global_frame.c_str());\n\t\treturn false;\n\t}\n\tif(req.goal.header.frame_id!= global_frame) {\n\t\tROS_ERROR(\"The planner has been asked to make a plan to goal in frame %s, but we only support %s\", req.goal.header.frame_id.c_str(), global_frame.c_str());\n\t\treturn false;\n\t}\n\n\t// first try to make a plan to the exact goal that was requested\n\t// we want the goal point to be on the local costmap because that is where the plan will be\n\tif(planner_util_.worldToMapEnforceBounds(req.goal.pose.position.x, req.goal.pose.position.y, goal_x_, goal_y_)) {\n\t\t// make sure that we're not planning in the goal point itself\n\t\tif(costmap_->getCost(goal_x_, goal_y_) == costmap_2d::LETHAL_OBSTACLE) {\n\t\t\tROS_WARN(\"The goal sent to the global planner is inside an obstacle! Planning around it may fail\");\n\t\t}\n\t\t// clear the existing path\n\t\tpath_maker_->clearRvizVisualization();\n\n\t\t// make the actual plan\n\t\tmakePlan(req.start, req.goal, resp.plan.poses);\n\t\t// if we didn't already return from makePlan() we'll\n\t\t// try to make a plan to the goal point\n\t\tif(!resp.plan.poses.empty()) {\n\t\t\t// we got a plan to the goal pose - tell the user\n\t\t\tROS_DEBUG_NAMED(\"planner_with_costmap\", \"Got a", "CodeBleu_score": 39.625141764522894}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tif(!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn false;\n\t}\n\t//make sure to set the frame_id of the start and goal to the map frame\n\tif(req.start.header.frame_id!= planner_util_->getGlobalFrameID()) {\n\t\tROS_ERROR(\"PlannerWithCostmap: The start point passed to makePlanService is in frame %s, which is not the global frame of the planner %s\", req.start.header.frame_id.c_str(), planner_util_->getGlobalFrameID().c_str());\n\t\treturn false;\n\t}\n\tif(req.goal.header.frame_id!= planner_util_->getGlobalFrameID()) {\n\t\tROS_ERROR(\"PlannerWithCostmap: The goal point passed to makePlanService is in frame %s, which is not the global frame of the planner %s\", req.goal.header.frame_id.c_str(), planner_util_->getGlobalFrameID().c_str());\n\t\treturn false;\n\t}\n\t//get the starting pose of the robot\n\tgeometry_msgs::PoseStamped start;\n\tif(!planner_util_->getRobotPose(start)) {\n\t\tROS_ERROR(\"PlannerWithCostmap: Could not get the robot pose\");\n\t\treturn false;\n\t}\n\t//get the goal pose of the robot\n\tgeometry_msgs::PoseStamped goal;\n\tif(!planner_util_->getGoalPose(goal)) {\n\t\tROS_ERROR(\"PlannerWithCostmap: Could not get the goal pose\");\n\t\treturn false;\n\t}\n\t//make sure that the start and goal are within the costmap\n\tif(!planner_util_->isPoseInBounds(start)) {\n\t\tROS_ERROR(\"PlannerWithCostmap: The start point passed to makePlanService is not within the costmap\");\n\t\treturn false;\n\t}\n\tif(!planner_util_->isPoseInBounds(goal)) {\n\t\tROS_ERROR(\"PlannerWithCostmap: The goal point passed to makePlanService is not within the costmap\");\n\t\treturn false;\n\t}\n\t//get the start and goal positions in the costmap\n\tunsigned int start_x_", "CodeBleu_score": 40.140980014275534}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn false;\n\t}\n\n\t// get the starting pose of the robot\n\tgeometry_msgs::PoseStamped start;\n\tstart.header.frame_id = req.start.header.frame_id;\n\tstart.header.stamp = ros::Time::now();\n\tstart.pose = req.start.pose;\n\n\t// get the goal pose of the robot\n\tgeometry_msgs::PoseStamped goal;\n\tgoal.header.frame_id = req.goal.header.frame_id;\n\tgoal.header.stamp = ros::Time::now();\n\tgoal.pose = req.goal.pose;\n\n\tstd::vector<geometry_msgs::PoseStamped> global_plan;\n\n\t// make sure to update the costmap to the latest version before planning\n\tcostmap_ros_->getCostmap()->updateMap();\n\n\t// run planner\n\tbool success = planner_->makePlan(start, goal, global_plan);\n\n\tif (success) {\n\t\t// create the response for the service\n\t\tresp.plan.poses.resize(global_plan.size());\n\t\tfor (unsigned int i = 0; i < global_plan.size(); i++) {\n\t\t\tresp.plan.poses[i] = global_plan[i];\n\t\t}\n\n\t\t// set the plan success flag\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t\tresp.plan.header.frame_id = req.start.header.frame_id;\n\t\tresp.plan.header.seq = req.start.header.seq;\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t\tresp.plan.header.frame_id = req.start.header.frame_id;\n\t\tresp.plan.header.seq = req.start.header.seq;\n\t\tresp.plan.poses = global_plan;\n\t\tresp.plan.poses.push_back(goal);\n\t\tresp.path_is_valid = true;\n\t} else {\n\t\tROS_WARN(\"Failed to find a plan to move the base to goal\");\n\t\tresp.path_is_valid = false;", "CodeBleu_score": 43.605645028291605}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\t// Initialize the ROS node handle\n\tros::NodeHandle private_nh(\"~/\" + name);\n\n\t// Advertise a service for planning the global path to the goal\n\tmake_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n\t// Subscribe to the goal topic\n\tgoal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 70.96115452255287}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\"~/\" + name);\n\n\tmake_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n\tgoal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 70.32446497855504}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\"~/\" + name);\n\tmake_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tgoal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 70.32446497855504}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < origin_x_ || wy < origin_y_) {\n\t\tROS_WARN(\"The world coordinates supplied to worldToMap are outside the bounds of the costmap. \"\n\t\t\t\"They were not mapped.\");\n\t\treturn false;\n\t}\n\n\tmx = (wx - origin_x_) / resolution_;\n\tmy = (wy - origin_y_) / resolution_;\n\n\tif (mx >= map_width_ || my >= map_height_) {\n\t\tROS_WARN(\"The world coordinates supplied to worldToMap are outside the bounds of the costmap. \"\n\t\t\t\"They were not mapped.\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 42.249723204571964}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < origin_x_ || wy < origin_y_)\n\t\treturn false;\n\n\tmx = (wx - origin_x_) / resolution_;\n\tmy = (wy - origin_y_) / resolution_;\n\n\tif (mx < 0 || my < 0 || mx >= width_ || my >= height_)\n\t\treturn false;\n\n\treturn true;\n}", "CodeBleu_score": 38.643527951493404}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < world_size_x_ / 2.0 && wx > -world_size_x_ / 2.0 && wy < world_size_y_ / 2.0 && wy > -world_size_y_ / 2.0) {\n\t\tmx = wx / resolution_x_ + origin_x_;\n\t\tmy = wy / resolution_y_ + origin_y_;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 25.831107803249083}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 92.89079784387178}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\t// Create a nav_msgs::Path with the input path\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Copy the poses from the input path\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\t// Publish the Path message\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.98158984520875}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 92.89079784387178}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\t// TODO: Implement this function\n\t//ROS_INFO(\"goalCB\");\n\tmove_base_msgs::MoveBaseActionGoal goal_msg;\n\tgoal_msg.header.stamp = ros::Time::now();\n\tgoal_msg.goal.target_pose = *goal;\n\taction_goal_pub_.publish(goal_msg);\n}", "CodeBleu_score": 53.076584170519816}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\t//ROS_DEBUG_NAMED(\"move_base\",\"Increasing goal id to %d\", ++goal_id_);\n\t//ROS_DEBUG_NAMED(\"move_base\",\"Received a goal of x: %f, y: %f, theta: %f\", goal->pose.position.x, goal->pose.position.y, tf2::getYaw(goal->pose.orientation));\n\n\t//wrap the goal in an action message\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\t//publish the action goal\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 63.349340798527784}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\t// TODO:\n\t// Wrap the goal in an action message and publish it to the action_goal_pub_ topic.\n\t// Use the current time as the timestamp for the goal.\n\t// The goal should be wrapped in a MoveBaseActionGoal message.\n\t// The goal should be assigned to the target_pose field of the message.\n\t// The message should be published to the action_goal_pub_ topic.\n\t// HINT: Use the current time as the timestamp for the goal.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field of the message to set the goal_id field of the message.\n\t// HINT: Use the goal_id field", "CodeBleu_score": 7.205063374180079}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (distance_limit_!= 0) {\n\t\tdouble distance_squared = (robot_pose_.x - last_pose_.x) * (robot_pose_.x - last_pose_.x) + (robot_pose_.y - last_pose_.y) * (robot_pose_.y - last_pose_.y);\n\t\tif (distance_squared > distance_limit_ * distance_limit_) {\n\t\t\tROS_INFO_STREAM(\"Robot has moved \" << distance_squared << \"m. Slowing down...\");\n\t\t\tif (remove_limit_thread_.joinable()) {\n\t\t\t\tremove_limit_thread_.join();\n\t\t\t}\n\t\t\tremove_limit_thread_ = std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\t\tdistance_check_timer_.stop();\n\t\t}\n\t}\n}", "CodeBleu_score": 46.70761483625745}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\t//ROS_INFO(\"distanceCheck\");\n\tif(sqrt(pow(limited_distance_ - current_distance_, 2)) > distance_threshold_) {\n\t\tROS_INFO(\"Distance moved: %f\", sqrt(pow(limited_distance_ - current_distance_, 2)));\n\t\tif(remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 55.84358086405853}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (pow(limited_distance - pow(robot_pose.pose.position.x,2) - pow(robot_pose.pose.position.y,2),2) > 0.001) {\n\t\tROS_INFO(\"Distance check triggered. Distance moved: %f\", sqrt(pow(limited_distance - pow(robot_pose.pose.position.x,2) - pow(robot_pose.pose.position.y,2),2)));\n\t\tif (remove_limit_thread.joinable()) {\n\t\t\tremove_limit_thread.join();\n\t\t}\n\t\tremove_limit_thread = std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tdistance_check_timer.stop();\n\t}\n}", "CodeBleu_score": 41.674834350282886}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t//get the current pose of the robot\n\tgeometry_msgs::PoseStamped global_pose = getRobotPose();\n\n\t//create a vector of PoseStamped objects to store the path\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\n\t//make a plan with the current global pose, goal pose, and empty path vector\n\tmakePlan(global_pose, *goal, path);\n\n\t//publish the path\n\tpublishPlan(path);\n}", "CodeBleu_score": 60.81472346881813}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t//ROS_INFO(\"poseCallback\");\n\t//ROS_INFO(\"poseCallback: goal->header.frame_id=%s\", goal->header.frame_id.c_str());\n\t//ROS_INFO(\"poseCallback: goal->pose.position.x=%f\", goal->pose.position.x);\n\t//ROS_INFO(\"poseCallback: goal->pose.position.y=%f\", goal->pose.position.y);\n\t//ROS_INFO(\"poseCallback: goal->pose.position.z=%f\", goal->pose.position.z);\n\t//ROS_INFO(\"poseCallback: goal->pose.orientation.x=%f\", goal->pose.orientation.x);\n\t//ROS_INFO(\"poseCallback: goal->pose.orientation.y=%f\", goal->pose.orientation.y);\n\t//ROS_INFO(\"poseCallback: goal->pose.orientation.z=%f\", goal->pose.orientation.z);\n\t//ROS_INFO(\"poseCallback: goal->pose.orientation.w=%f\", goal->pose.orientation.w);\n\t//ROS_INFO(\"poseCallback: goal->header.stamp.sec=%i\", goal->header.stamp.sec);\n\t//ROS_INFO(\"poseCallback: goal->header.stamp.nsec=%i\", goal->header.stamp.nsec);\n\t//ROS_INFO(\"poseCallback: goal->header.stamp.sec=%i\", goal->header.stamp.sec);\n\t//ROS_INFO(\"poseCallback: goal->header.stamp.nsec=%i\", goal->header.stamp.nsec);\n\t//ROS_INFO(\"poseCallback: goal->header.seq=%i\", goal->header.seq);\n\t//ROS_INFO(\"poseCallback: goal->header.frame_id=%s\", goal->header.frame_id.c_str());\n\t//ROS_INFO(\"poseCallback: goal->pose.position.x=%f\", goal->pose.position.x);\n\t//ROS_INFO(\"poseCallback: goal->pose.position.y=%f\", goal->pose.position.y);\n\t//ROS_INFO(\"poseCallback: goal->pose.position.z=%f\", goal->pose.position.z);\n\t//ROS_INFO(\"poseCallback: goal->pose.orientation.x=%f\", goal->pose", "CodeBleu_score": 9.303810271887548}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t//get the global pose of the robot\n\tgeometry_msgs::PoseStamped global_pose = getRobotPose();\n\n\t//create a vector of NavfnPathPoints\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\n\t//call makePlan with the global pose, goal pose, and an empty path vector\n\tmakePlan(global_pose, *goal, path);\n}", "CodeBleu_score": 64.62837929889304}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create a ParamSet service request\n\tmavros_msgs::ParamSet srv;\n\n\t// Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.value = param_set.value;\n\n\t// Call the param_set_client_ to send the request\n\tif (param_set_client_.call(srv)) {\n\t\tROS_INFO(\"Gimbal param set: %s = %s\", srv.request.param_id.c_str(), srv.request.value.c_str());\n\t} else {\n\t\tROS_ERROR(\"Failed to call service param_set\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 64.27185453437596}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create a param_set_client_ request\n\tmavros_msgs::ParamSet::Request req;\n\treq.param_id = param_set.param_id;\n\treq.value = param_set.value;\n\n\t// Call param_set_client_ to send the request\n\tparam_set_client_.call(req);\n}", "CodeBleu_score": 52.058433499348865}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet gimbal_param_set;\n\tgimbal_param_set.request.param_id = param_set.param_id;\n\tgimbal_param_set.request.value = param_set.value;\n\tparam_set_client_.call(gimbal_param_set);\n}", "CodeBleu_score": 56.5746562290989}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\t// create a socket\n\tboost::asio::io_service io_service;\n\tboost::asio::ip::tcp::acceptor acceptor(io_service, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port));\n\n\twhile (true) {\n\t\t// wait for a connection\n\t\tboost::asio::ip::tcp::socket socket(io_service);\n\t\tacceptor.accept(socket);\n\n\t\t// create a new thread to handle the connection\n\t\tboost::thread t(boost::bind(&CommunicationBridge::handleConnection, this, boost::ref(socket)));\n\t}\n}", "CodeBleu_score": 10.858404453879725}, {"code": "void CommunicationBridge::serverFun(){\n\t\t// Create a socket to listen on\n\tint listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listen_fd == -1) {\n\t\tROS_ERROR(\"Could not create socket\");\n\t\treturn;\n\t}\n\n\t// Bind the socket to a port\n\tstruct sockaddr_in serv_addr;\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tserv_addr.sin_port = htons(port);\n\tif (bind(listen_fd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) == -1) {\n\t\tROS_ERROR(\"Could not bind socket\");\n\t\treturn;\n\t}\n\n\t// Start listening on the socket\n\tif (listen(listen_fd, 1) == -1) {\n\t\tROS_ERROR(\"Could not listen on socket\");\n\t\treturn;\n\t}\n\n\t// Wait for a connection\n\tstruct sockaddr_in client_addr;\n\tsocklen_t client_addr_len = sizeof(client_addr);\n\tint client_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_addr_len);\n\tif (client_fd == -1) {\n\t\tROS_ERROR(\"Could not accept connection\");\n\t\treturn;\n\t}\n\n\t// Close the listening socket\n\tclose(listen_fd);\n\n\t// Loop to handle further connections\n\twhile (true) {\n\t\t// Receive data\n\t\tchar buffer[MAX_PACKET_SIZE];\n\t\tint bytes_received = recv(client_fd, buffer, MAX_PACKET_SIZE, 0);\n\t\tif (bytes_received == -1) {\n\t\t\tROS_ERROR(\"Could not receive data\");\n\t\t\tbreak;\n\t\t}\n\t\tif (bytes_received == 0) {\n\t\t\tROS_ERROR(\"Received zero-length data\");\n\t\t\tbreak;\n\t\t}\n\n\t\t// Decode the message\n\t\tchar *msg = buffer;\n\t\tuint8_t msg_type = msg[0];\n\t\tuint32_t msg_len = *(uint32_t *)(msg + 1);\n\t\tif (msg_len > MAX_PACKET_SIZE) {\n\t\t", "CodeBleu_score": 43.298337712661365}, {"code": "void CommunicationBridge::serverFun(){\n\t\t// Create a socket\n\tint server_socket = socket(AF_INET, SOCK_STREAM, 0);\n\tif (server_socket == -1) {\n\t\tROS_ERROR(\"CommunicationBridge::serverFun: Unable to create socket.\");\n\t\treturn;\n\t}\n\n\t// Set the socket options\n\tint opt = 1;\n\tif (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {\n\t\tROS_ERROR(\"CommunicationBridge::serverFun: Unable to set socket options.\");\n\t\treturn;\n\t}\n\n\t// Bind the socket to a port\n\tstruct sockaddr_in server_address;\n\tserver_address.sin_family = AF_INET;\n\tserver_address.sin_addr.s_addr = INADDR_ANY;\n\tserver_address.sin_port = htons(port);\n\tif (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {\n\t\tROS_ERROR(\"CommunicationBridge::serverFun: Unable to bind socket to port %d.\", port);\n\t\treturn;\n\t}\n\n\t// Listen for connections\n\tif (listen(server_socket, 1) == -1) {\n\t\tROS_ERROR(\"CommunicationBridge::serverFun: Unable to listen for connections.\");\n\t\treturn;\n\t}\n\n\t// Accept incoming connections\n\tint client_socket;\n\tstruct sockaddr_in client_address;\n\tsocklen_t client_address_length = sizeof(client_address);\n\twhile (ros::ok()) {\n\t\tclient_socket = accept(server_socket, (struct sockaddr *)&client_address, &client_address_length);\n\t\tif (client_socket == -1) {\n\t\t\tROS_ERROR(\"CommunicationBridge::serverFun: Unable to accept connection.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Receive and process data\n\t\tchar buffer[1024];\n\t\tint bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);\n\t\tif (bytes_received <= 0) {\n\t\t\tROS_ERROR(\"CommunicationBridge::serverFun: Unable to receive data.\");\n\t\t\tclose(client_socket);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Decode the message\n\t", "CodeBleu_score": 44.15684212984665}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (uav_cmd.id == -1) {\n\t\tROS_ERROR(\"UAV ID is not set\");\n\t\treturn;\n\t}\n\tif (uav_cmd.id == 0) {\n\t\tROS_ERROR(\"UAV ID is 0\");\n\t\treturn;\n\t}\n\tif (uav_cmd.id > swarm_control_simulation_.size()) {\n\t\tROS_ERROR(\"UAV ID is greater than the number of UAVs\");\n\t\treturn;\n\t}\n\tif (uav_cmd.id < 1) {\n\t\tROS_ERROR(\"UAV ID is less than 1\");\n\t\treturn;\n\t}\n\tif (uav_cmd.id == 1) {\n\t\tuav_basic_.publish(uav_cmd);\n\t} else {\n\t\tswarm_control_simulation_[uav_cmd.id - 1]->publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 39.078854608247184}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\t//ROS_INFO(\"Received command from the ground station\");\n\t//ROS_INFO(\"UAV ID: %d\", uav_cmd.uav_id);\n\t//ROS_INFO(\"Command ID: %d\", uav_cmd.command_id);\n\t//ROS_INFO(\"Command: %f\", uav_cmd.command);\n\t//ROS_INFO(\"Command: %f\", uav_cmd.command);\n\n\t// If the command is for a single UAV, publish it to the corresponding UAV\n\tif (uav_cmd.uav_id == -1) {\n\t\tuav_basic_.publish(uav_cmd);\n\t} else {\n\t\t// Otherwise, find the corresponding UAV and publish the command to it\n\t\tstd::map<int, UAV>::iterator it = swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= swarm_control_simulation_.end()) {\n\t\t\tit->second.publish(uav_cmd);\n\t\t} else {\n\t\t\tROS_WARN(\"UAV ID %d not found in simulation mode\", uav_cmd.uav_id);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.01264830235902}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (simulation_mode_) {\n\t\t// find the corresponding UAV from swarm_control_simulation_\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].id == uav_cmd.uav_id) {\n\t\t\t\tswarm_control_simulation_[i].cmd = uav_cmd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// publish the command to the single UAV using uav_basic_\n\t\tuav_basic_.publishCommand(uav_cmd);\n\t}\n}", "CodeBleu_score": 36.27738691367565}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exit\");\n\t} else if (mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETETABLE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 49.18285388035608}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tboost::mutex::scoped_lock lock(mode_mutex);\n\tif (mode_selection.use_mode == 0) {\n\t\tstd::cout << \"Mode Switch: REBOOTNX\" << std::endl;\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == 1) {\n\t\tstd::cout << \"Mode Switch: EXITNX\" << std::endl;\n\t\tsystem(\"exitnx\");\n\t} else if (mode_selection.use_mode == 2) {\n\t\tstd::cout << \"Mode Switch: CREATEMODE\" << std::endl;\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == 3) {\n\t\tstd::cout << \"Mode Switch: DELETEMODE\" << std::endl;\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 48.4859972342559}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tboost::mutex::scoped_lock lock(mode_switch_mutex);\n\tif (mode_selection.use_mode == \"REBOOTNX\") {\n\t\tstd::string command = \"rebootnx\";\n\t\tstd::string output;\n\t\tstd::string error;\n\t\tint return_value = executeCommand(command, output, error);\n\t\tif (return_value == 0) {\n\t\t\tstd::cout << \"Mode switched to REBOOTNX\" << std::endl;\n\t\t\tcreateMode(mode_selection);\n\t\t} else {\n\t\t\tstd::cout << \"Mode switch to REBOOTNX failed\" << std::endl;\n\t\t}\n\t} else if (mode_selection.use_mode == \"EXITNX\") {\n\t\tstd::string command = \"exitnx\";\n\t\tstd::string output;\n\t\tstd::string error;\n\t\tint return_value = executeCommand(command, output, error);\n\t\tif (return_value == 0) {\n\t\t\tstd::cout << \"Mode switched to EXITNX\" << std::endl;\n\t\t\tcreateMode(mode_selection);\n\t\t} else {\n\t\t\tstd::cout << \"Mode switch to EXITNX failed\" << std::endl;\n\t\t}\n\t} else {\n\t\tstd::cout << \"Mode switch failed\" << std::endl;\n\t}\n}", "CodeBleu_score": 43.903296949866046}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// Check if heartbeat is received\n\tif (heartbeat_received_flag) {\n\t\t// Reset heartbeat counter\n\t\theartbeat_counter = 0;\n\t} else {\n\t\t// Increment heartbeat counter\n\t\theartbeat_counter++;\n\t}\n\n\t// Check if heartbeat counter exceeds max allowed\n\tif (heartbeat_counter > heartbeat_max_allowed) {\n\t\t// Check if heartbeat is received\n\t\tif (heartbeat_received_flag) {\n\t\t\t// Check if vehicle is swarm\n\t\t\tif (vehicle_type == \"swarm\") {\n\t\t\t\t// Print error message\n\t\t\t\tROS_ERROR(\"Swarm heartbeat lost. Reconnecting...\");\n\t\t\t} else if (vehicle_type == \"uav\") {\n\t\t\t\t// Print error message\n\t\t\t\tROS_ERROR(\"UAV heartbeat lost. Reconnecting...\");\n\t\t\t} else if (vehicle_type == \"ugv\") {\n\t\t\t\t// Print error message\n\t\t\t\tROS_ERROR(\"UGV heartbeat lost. Reconnecting...\");\n\t\t\t}\n\n\t\t\t// Reset heartbeat counter\n\t\t\theartbeat_counter = 0;\n\n\t\t\t// Set disconnect flag\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 31.746280590381126}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// If the heartbeat has been lost, print an error message and set the disconnect flag\n\tif (heartbeat_lost_count >= 10) {\n\t\tROS_ERROR(\"Heartbeat lost. Disconnecting from vehicle.\");\n\t\tdisconnect_flag = true;\n\t}\n\n\t// If the heartbeat is still being received, reset the counter\n\tif (heartbeat_received_flag) {\n\t\theartbeat_lost_count = 0;\n\t}\n\n\t// Increment the heartbeat lost count\n\telse {\n\t\theartbeat_lost_count++;\n\t}\n\n\t// Reset the heartbeat received flag\n\theartbeat_received_flag = false;\n}", "CodeBleu_score": 21.306929299186876}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tboost::mutex::scoped_lock lock(heartbeat_mutex);\n\tif (heartbeat_count > 0) {\n\t\theartbeat_count--;\n\t} else {\n\t\tif (heartbeat_count == 0) {\n\t\t\tif (vehicle_type == \"swarm\") {\n\t\t\t\tROS_ERROR(\"Swarm %d has lost connection to the base station.\", swarm_id);\n\t\t\t} else if (vehicle_type == \"UAV\") {\n\t\t\t\tROS_ERROR(\"UAV %d has lost connection to the base station.\", uav_id);\n\t\t\t} else if (vehicle_type == \"UGV\") {\n\t\t\t\tROS_ERROR(\"UGV %d has lost connection to the base station.\", ugv_id);\n\t\t\t}\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t\theartbeat_count = -1;\n\t}\n}", "CodeBleu_score": 35.91761512790732}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t//std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n\t//std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb: \" << msg->drone_id << std::endl;\n\t//std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb: \" << msg->trajectory.size() << std::endl;\n\n\t// Get the drone ID\n\tstd::string drone_id = msg->drone_id;\n\n\t// Initialize the MultiBsplines message\n\tprometheus_msgs::MultiBsplines multi_bsplines_msg;\n\n\t// Initialize the MultiBsplines message header\n\tmulti_bsplines_msg.header.stamp = msg->header.stamp;\n\tmulti_bsplines_msg.header.frame_id = msg->header.frame_id;\n\n\t// Set the drone ID\n\tmulti_bsplines_msg.drone_id = drone_id;\n\n\t// Iterate through each trajectory\n\tfor (int i = 0; i < msg->trajectory.size(); i++) {\n\t\t// Initialize the Bspline struct\n\t\tBspline bspline;\n\n\t\t// Set the drone ID\n\t\tbspline.drone_id = drone_id;\n\n\t\t// Set the trajectory ID\n\t\tbspline.trajectory_id = i;\n\n\t\t// Set the number of control points\n\t\tbspline.num_control_points = msg->trajectory[i].num_control_points;\n\n\t\t// Set the number of knots\n\t\tbspline.num_knots = msg->trajectory[i].num_knots;\n\n\t\t// Set the number of position points\n\t\tbspline.num_position_points = msg->trajectory[i].num_position_points;\n\n\t\t// Set the number of yaw points\n\t\tbspline.num_yaw_points = msg->trajectory[i].num_yaw_points;\n\n\t\t// Set the number of derivatives\n\t\tbspline.num_derivatives = msg->trajectory[i].num_derivatives;\n\n\t\t// Set the number of derivatives\n\t\tbspline.num_derivatives = msg->trajectory[i].num_derivatives;\n\n\t\t// Set the number of derivatives\n\t\tbspline.num_derivatives", "CodeBleu_score": 41.546995310790535}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Get the drone ID from the message\n\tint drone_id = msg->drone_id;\n\n\t// Get the number of trajectories in the message\n\tint num_traj = msg->num_traj;\n\n\t// Initialize the MultiBsplines struct\n\tMultiBsplines mb;\n\n\t// Set the drone ID and number of trajectories\n\tmb.drone_id = drone_id;\n\tmb.num_traj = num_traj;\n\n\t// Initialize the trajectory structs\n\tfor (int i = 0; i < num_traj; i++) {\n\t\t// Get the trajectory data\n\t\tTrajectory traj = msg->traj[i];\n\n\t\t// Initialize the Bspline struct\n\t\tBspline bsp;\n\n\t\t// Set the attributes\n\t\tbsp.id = traj.id;\n\t\tbsp.num_knots = traj.num_knots;\n\t\tbsp.num_points = traj.num_points;\n\t\tbsp.num_yaw_points = traj.num_yaw_points;\n\t\tbsp.num_yaw_knots = traj.num_yaw_knots;\n\n\t\t// Set the knots\n\t\tbsp.knots = traj.knots;\n\n\t\t// Set the position points\n\t\tbsp.pos_points = traj.pos_points;\n\n\t\t// Set the yaw points\n\t\tbsp.yaw_points = traj.yaw_points;\n\n\t\t// Set the yaw knots\n\t\tbsp.yaw_knots = traj.yaw_knots;\n\n\t\t// Add the Bspline struct to the MultiBsplines struct\n\t\tmb.traj.push_back(bsp);\n\t}\n\n\t// Encode the MultiBsplines struct\n\tstd::string mb_str = prometheus_utils::encodeStruct(mb);\n\n\t// Send the encoded MultiBsplines struct via TCP\n\tcomm.sendTcp(mb_str);\n}", "CodeBleu_score": 29.871601631510135}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Extract the drone ID from the MultiBsplines message\n\tint drone_id = msg->drone_id;\n\n\t// Initialize a Bspline struct\n\tBspline bspline;\n\n\t// Set the drone ID and the number of waypoints for the Bspline struct\n\tbspline.drone_id = drone_id;\n\tbspline.num_waypoints = msg->waypoints.size();\n\n\t// Set the Bspline struct's attributes\n\tbspline.time_horizon = msg->time_horizon;\n\tbspline.time_step = msg->time_step;\n\tbspline.yaw_rate = msg->yaw_rate;\n\n\t// Set the Bspline struct's knots\n\tbspline.knots = msg->knots;\n\n\t// Set the Bspline struct's position points\n\tfor (int i = 0; i < bspline.num_waypoints; i++) {\n\t\tPoint point;\n\t\tpoint.x = msg->waypoints[i].x;\n\t\tpoint.y = msg->waypoints[i].y;\n\t\tpoint.z = msg->waypoints[i].z;\n\t\tbspline.position_points.push_back(point);\n\t}\n\n\t// Set the Bspline struct's yaw points\n\tfor (int i = 0; i < bspline.num_waypoints; i++) {\n\t\tbspline.yaw_points.push_back(msg->yaw_points[i]);\n\t}\n\n\t// Encode the MultiBsplines data and send it via TCP\n\tsendBsplineData(bspline);\n}", "CodeBleu_score": 42.68424763434879}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> pcl_cloud;\n\tpcl::fromROSMsg(msg, pcl_cloud);\n\n\t// Create an octree object\n\toctomap::OcTree octree(0.05);\n\n\t// Insert the points into the octree\n\tfor (size_t i = 0; i < pcl_cloud.points.size(); ++i) {\n\t\toctree.insertKey(pcl_cloud.points[i].x, pcl_cloud.points[i].y, pcl_cloud.points[i].z);\n\t}\n\n\t// Compress the octree\n\toctree.updateInnerOccupancy();\n\toctree.prune();\n\n\t// Create a new PointCloud2 message\n\tsensor_msgs::PointCloud2 new_msg;\n\n\t// Convert the compressed octree to a PointCloud2 message\n\toctomap_msgs::pointCloudToMsg(octree, new_msg);\n\n\t// Return the new PointCloud2 message\n\treturn new_msg;\n}", "CodeBleu_score": 25.663238222125905}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Create an octree compression object\n\toctomap::OcTree tree(0.05);\n\t// Compress the point cloud\n\toctomap::Pointcloud compression;\n\toctomap::pointCloud2Octree(cloud, compression);\n\ttree.insertPointCloud(compression, octomap::point3d(0, 0, 0));\n\n\t// Convert the compressed point cloud to a PointCloud2 message\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tpcl::toROSMsg(tree, compressed_msg);\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 22.934917423153657}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Create an octree compression object and compress the point cloud\n\toctree::OctreePointCloudCompression<pcl::PointXYZ> octree;\n\toctree.setInputCloud(cloud.makeShared());\n\toctree.setResolution(0.01);\n\toctree.filter();\n\n\t// Convert the compressed point cloud to a PointCloud2 message and return it\n\tpcl::PointCloud<pcl::PointXYZ> compressed_cloud;\n\toctree.getPointCloud(compressed_cloud);\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tpcl::toROSMsg(compressed_cloud, compressed_msg);\n\treturn compressed_msg;\n}", "CodeBleu_score": 26.747599083877205}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 54.82348116351547}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 58.95573600406434}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor(int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif(multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 53.28670083195048}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tUGVState ugv_state;\n\tint count = 0;\n\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state_size; i++) {\n\t\tugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\t\tmulti_ugv_state.ugv_state.push_back(ugv_state);\n\t\tcount++;\n\t}\n\n\tmulti_ugv_state.ugv_count = count;\n\n\tall_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 44.50012798249734}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state_msg;\n\tUGVState ugv_state_msg;\n\n\tmulti_ugv_state_msg.ugv_count = m_multi_ugv_state.ugv_count;\n\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tugv_state_msg.id = m_multi_ugv_state.ugv_states[i].id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_states[i].battery;\n\t\tugv_state_msg.position.x = m_multi_ugv_state.ugv_states[i].position.x;\n\t\tugv_state_msg.position.y = m_multi_ugv_state.ugv_states[i].position.y;\n\t\tugv_state_msg.position.z = m_multi_ugv_state.ugv_states[i].position.z;\n\t\tugv_state_msg.velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n\t\tugv_state_msg.velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n\t\tugv_state_msg.velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n\t\tugv_state_msg.attitude.roll = m_multi_ugv_state.ugv_states[i].attitude.roll;\n\t\tugv_state_msg.attitude.pitch = m_multi_ugv_state.ugv_states[i].attitude.pitch;\n\t\tugv_state_msg.attitude.yaw = m_multi_ugv_state.ugv_states[i].attitude.yaw;\n\n\t\tmulti_ugv_state_msg.ugv_states.push_back(ugv_state_msg);\n\t}\n\n\tm_all_ugv_state_pub.publish(multi_ugv_state_msg);\n}", "CodeBleu_score": 42.145210560854395}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState ugv_state_msg;\n\tint i;\n\tfor (i = 0; i < m_multi_ugv_state.ugv_state_size; i++) {\n\t\tUGVState ugv_state;\n\t\tugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\t\tugv_state_msg.ugv_state.push_back(ugv_state);\n\t}\n\tugv_state_msg.ugv_count = m_multi_ugv_state.ugv_count;\n\tm_all_ugv_state_pub.publish(ugv_state_msg);\n}", "CodeBleu_score": 41.22474345299303}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// TODO: Implement this function\n\t// TODO: Implement this function\n\t// TODO: Implement this function\n}", "CodeBleu_score": 3.845811572351676}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Get the B-spline coefficients\n\tEigen::MatrixXd coeff = getCoeff(q);\n\n\t// Calculate the cost and gradient of the B-spline trajectory\n\tdouble cost_bspline = 0;\n\tEigen::MatrixXd gradient_bspline;\n\tcalcCostGradient(q, cost_bspline, gradient_bspline);\n\n\t// Calculate the cost and gradient of the moving objects\n\tdouble cost_moving_obj = 0;\n\tEigen::MatrixXd gradient_moving_obj;\n\tcalcMovingObjCost(q, cost_moving_obj, gradient_moving_obj);\n\n\t// Calculate the total cost and gradient\n\tcost = cost_bspline + cost_moving_obj;\n\tgradient = gradient_bspline + gradient_moving_obj;\n}", "CodeBleu_score": 19.617313708339136}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// TODO: implement this function\n\t// You can use the function Bspline::calcPosition to calculate the position of a B-spline at a given time.\n\t// You can use the function Bspline::calcVelocity to calculate the velocity of a B-spline at a given time.\n\t// You can use the function Bspline::calcAcceleration to calculate the acceleration of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobian to calculate the Jacobian of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobianDot to calculate the time derivative of the Jacobian of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobianDotDot to calculate the second time derivative of the Jacobian of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobianDotDotDot to calculate the third time derivative of the Jacobian of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobianDotDotDotDot to calculate the fourth time derivative of the Jacobian of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobianDotDotDotDotDot to calculate the fifth time derivative of the Jacobian of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobianDotDotDotDotDotDot to calculate the sixth time derivative of the Jacobian of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobianDotDotDotDotDotDotDot to calculate the seventh time derivative of the Jacobian of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobianDotDotDotDotDotDotDotDot to calculate the eighth time derivative of the Jacobian of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobianDotDotDotDotDotDotDotDotDot to calculate the ninth time derivative of the Jacobian of a B-spline at a given time.\n\t// You can use the function Bspline::calcJacobianDotDotDotDotDotDotDotDotDotDot to calculate the tenth time derivative of the Jacobian of a B", "CodeBleu_score": 3.7372195246680375}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// initialize cost\n\tcost = 0.0;\n\t// initialize gradient\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// iterate through control points\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// compute positional error\n\t\tEigen::VectorXd error = q.col(i) - ref_q.col(i);\n\t\t// compute velocity vector\n\t\tEigen::VectorXd v = q.col(i + 1) - q.col(i);\n\t\t// compute cost and gradient\n\t\tcost += (a2 * error.dot(error) + b2 * v.dot(v)) / (a2 * b2);\n\t\tgradient.col(i) += (a2 * error + b2 * v) / (a2 * b2);\n\t\tgradient.col(i + 1) -= (a2 * error + b2 * v) / (a2 * b2);\n\t}\n}", "CodeBleu_score": 27.82825003126629}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0;\n\tgradient.resize(q.rows(), q.cols());\n\tgradient.setZero();\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\tEigen::VectorXd q_i = q.col(i);\n\t\tEigen::VectorXd q_i_ref = q_ref.col(i);\n\t\tEigen::VectorXd q_i_dot_ref = q_dot_ref.col(i);\n\t\tEigen::VectorXd q_i_ddot_ref = q_ddot_ref.col(i);\n\t\tEigen::VectorXd q_i_dddot_ref = q_dddot_ref.col(i);\n\n\t\tEigen::VectorXd q_i_error = q_i - q_i_ref;\n\t\tEigen::VectorXd q_i_dot_error = q_i_dot - q_i_dot_ref;\n\t\tEigen::VectorXd q_i_ddot_error = q_i_ddot - q_i_ddot_ref;\n\t\tEigen::VectorXd q_i_dddot_error = q_i_dddot - q_i_dddot_ref;\n\n\t\tEigen::VectorXd q_i_error_dot = q_i_error.dot(q_i_dot_ref) * q_i_dot_ref;\n\t\tEigen::VectorXd q_i_error_ddot = q_i_error.dot(q_i_ddot_ref) * q_i_ddot_ref;\n\t\tEigen::VectorXd q_i_error_dddot = q_i_error.dot(q_i_dddot_ref) * q_i_dddot_ref;\n\n\t\tcost += a2 * q_i_error.dot(q_i_error) + b2 * (q_i_error_dot.dot(q_i_error_dot) + q_i_error_ddot.dot(q_i_error_ddot) + q_i_error_dddot.dot(q_i_error_dddot));\n\n\t\tEigen::VectorXd q_i_error_dot_gradient = q_i_error.dot(q_i_dot_ref) *", "CodeBleu_score": 28.47442388390983}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0;\n\tgradient.setZero(q.rows(), q.cols());\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\tEigen::VectorXd q_i = q.col(i);\n\t\tEigen::VectorXd q_i_ref = q_ref.col(i);\n\t\tEigen::VectorXd q_i_dot = q_dot_ref.col(i);\n\t\tEigen::VectorXd q_i_ddot = q_ddot_ref.col(i);\n\n\t\t// Positional error\n\t\tEigen::VectorXd q_i_err = q_i - q_i_ref;\n\n\t\t// Velocity\n\t\tEigen::VectorXd q_i_dot_err = q_i_dot - q_i_ref;\n\n\t\t// Velocity error\n\t\tEigen::VectorXd q_i_ddot_err = q_i_ddot - q_i_dot_err;\n\n\t\t// Cost\n\t\tdouble cost_i = a2 * q_i_err.dot(q_i_err) + b2 * q_i_dot_err.dot(q_i_dot_err) + c2 * q_i_ddot_err.dot(q_i_ddot_err);\n\n\t\t// Gradient\n\t\tEigen::VectorXd q_i_err_grad = 2 * a2 * q_i_err;\n\t\tEigen::VectorXd q_i_dot_err_grad = 2 * b2 * q_i_dot_err;\n\t\tEigen::VectorXd q_i_ddot_err_grad = 2 * c2 * q_i_ddot_err;\n\n\t\tgradient.col(i) = q_i_err_grad + q_i_dot_err_grad + q_i_ddot_err_grad;\n\n\t\tcost += cost_i;\n\t}\n}", "CodeBleu_score": 33.733797364907254}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0;\n\tfor (int i = 0; i < this->n_dimensions; i++) {\n\t\tfor (int j = 0; j < this->n_control_points; j++) {\n\t\t\tjerk += pow(this->jerk_trajectory[i][j], 2) * (this->knot_times[i][j+3] - this->knot_times[i][j+2]);\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 26.456967492752863}, {"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0;\n\tstd::vector<double> knots = this->getKnots();\n\tstd::vector<std::vector<double>> controlPoints = this->getControlPoints();\n\tfor (int i = 0; i < controlPoints.size(); i++) {\n\t\tfor (int j = 0; j < controlPoints[i].size(); j++) {\n\t\t\tjerk += (controlPoints[i][j] * controlPoints[i][j]) * (knots[j + 3] - knots[j]);\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 40.82435320141277}, {"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0.0;\n\tstd::vector<double> jerk_knots;\n\tstd::vector<std::vector<double>> jerk_control_points;\n\tthis->getJerkTrajectory(jerk_knots, jerk_control_points);\n\n\tfor (int i = 0; i < jerk_control_points.size(); i++) {\n\t\tfor (int j = 0; j < jerk_control_points[i].size(); j++) {\n\t\t\tjerk += pow(jerk_control_points[i][j], 2) * (jerk_knots[i + 1] - jerk_knots[i]);\n\t\t}\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 42.23627402401468}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tfloat x = (u - cx_) * depth / fx_;\n\tfloat y = (v - cy_) * depth / fy_;\n\treturn Eigen::Vector4d(x, y, depth, 1);\n}", "CodeBleu_score": 48.717612566245805}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1.0;\n\treturn pos;\n}", "CodeBleu_score": 48.5261302368948}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\t// Transform pixel coordinates into camera coordinates\n\tfloat x = (u - cx_) * depth / fx_;\n\tfloat y = (v - cy_) * depth / fy_;\n\n\t// Return 4D position vector\n\treturn Eigen::Vector4d(x, y, depth, 1);\n}", "CodeBleu_score": 48.66302230671473}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, getDroneIDFromFrameID(odom.child_frame_id));\n\t} catch (const std::runtime_error& e) {\n\t\tROS_ERROR_STREAM(\"Failed to get drone ID from frame ID: \" << odom.child_frame_id << \". Exception: \" << e.what());\n\t}\n}", "CodeBleu_score": 37.464070016312036}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, odom.child_frame_id);\n\t} catch (std::exception& e) {\n\t\tstd::cout << \"DroneDetector::rcvDroneXOdomCallback: \" << e.what() << std::endl;\n\t}\n}", "CodeBleu_score": 41.67982877445902}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, getDroneIdFromChildFrameId(odom.child_frame_id));\n\t} catch (std::exception& e) {\n\t\tstd::cerr << \"DroneDetector::rcvDroneXOdomCallback: \" << e.what() << std::endl;\n\t}\n}", "CodeBleu_score": 38.94472462424297}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the drone's true pose\n\tEigen::Vector3d true_pose = drone_poses_[drone_id];\n\n\t// Check if the drone is visible\n\tif (true_pixel.x() == -1) {\n\t\t// Drone not visible\n\t\tdebug_result_.drone_visible = false;\n\t\tdebug_result_.pose_error = Eigen::Vector3d(0, 0, 0);\n\t\tdebug_result_.pose_error_norm = 0;\n\t\tdebug_result_.pose_error_norm_pixels = 0;\n\t} else {\n\t\t// Drone visible\n\t\tdebug_result_.drone_visible = true;\n\n\t\t// Get the drone's true position\n\t\tEigen::Vector3d true_position = true_pose.head(3);\n\n\t\t// Get the drone's true orientation\n\t\tEigen::Quaterniond true_orientation(true_pose(3), true_pose(4), true_pose(5), true_pose(6));\n\n\t\t// Get the drone's true pixel position\n\t\tEigen::Vector2d true_pixel_position(true_pixel.x(), true_pixel.y());\n\n\t\t// Get the drone's true pixel position in camera coordinates\n\t\tEigen::Vector3d true_camera_position = camera_model_.projectPixelTo3dRay(true_pixel_position);\n\n\t\t// Get the drone's true camera position\n\t\tEigen::Vector3d true_camera_position_3d(true_camera_position(0), true_camera_position(1), true_camera_position(2));\n\n\t\t// Get the drone's true camera pose\n\t\tEigen::Isometry3d true_camera_pose = Eigen::Isometry3d::Identity();\n\t\ttrue_camera_pose.translation() = true_camera_position_3d;\n\t\ttrue_camera_pose.rotate(true_orientation);\n\n\t\t// Get the drone's true world position\n\t\tEigen::Vector3d true_world_position = true_camera_pose * world_origin_;\n\n\t\t// Get the drone's true world pose\n\t\tEigen::Isometry3d true_world_pose = Eigen::Isometry3d::Identity();\n\t\ttrue_world_pose.translation() = true_world_position", "CodeBleu_score": 34.481063683667266}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Compute the true drone position in the camera frame\n\tEigen::Vector3d true_drone_position = Eigen::Vector3d(true_pixel(0), true_pixel(1), 0);\n\tEigen::Vector3d true_drone_position_camera = camera_matrix * true_drone_position;\n\n\t// Check if the drone is present\n\tbool drone_present = false;\n\tfor (const auto &drone : drone_list) {\n\t\tif (drone_id == drone.id) {\n\t\t\tdrone_present = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If the drone is present, compute the pose error and publish it\n\tif (drone_present) {\n\t\t// Compute the pose error\n\t\tEigen::Vector3d drone_position = Eigen::Vector3d(drone_list[drone_id].position(0), drone_list[drone_id].position(1), 0);\n\t\tEigen::Vector3d drone_position_camera = camera_matrix * drone_position;\n\t\tEigen::Vector3d pose_error = drone_position_camera - true_drone_position_camera;\n\n\t\t// Update the debug result\n\t\tdebug_result.pose_error_x = pose_error(0);\n\t\tdebug_result.pose_error_y = pose_error(1);\n\t\tdebug_result.pose_error_z = pose_error(2);\n\t\tdebug_result.pose_error_norm = pose_error.norm();\n\t\tdebug_result.success = true;\n\n\t\t// Publish the pose error\n\t\tpose_error_pub.publish(pose_error);\n\t}\n\t// If the drone is not present, update the debug result to indicate failure\n\telse {\n\t\tdebug_result.success = false;\n\t}\n\n\t// Publish the debug result\n\tdebug_result_pub.publish(debug_result);\n}", "CodeBleu_score": 39.65374282655103}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the drone from the drone list\n\tauto drone = drone_list.find(drone_id);\n\n\t// If the drone is not in the list, return\n\tif (drone == drone_list.end()) {\n\t\treturn;\n\t}\n\n\t// Calculate the drone's pose in the camera frame\n\tEigen::Vector3d drone_cam_pose = drone->second.cam_pose + drone->second.cam_offset;\n\n\t// Calculate the drone's pose in the world frame\n\tEigen::Vector3d drone_world_pose = drone->second.world_pose;\n\n\t// Calculate the drone's pose in the world frame\n\tEigen::Vector3d drone_world_pose_error = drone_world_pose - drone_cam_pose;\n\n\t// Calculate the drone's pose in the world frame\n\tEigen::Vector3d drone_cam_pose_error = drone_cam_pose - drone_world_pose;\n\n\t// Calculate the drone's pose in the world frame\n\tEigen::Vector3d drone_cam_pose_error_norm = drone_cam_pose_error.normalized();\n\n\t// Calculate the drone's pose in the world frame\n\tEigen::Vector3d drone_world_pose_error_norm = drone_world_pose_error.normalized();\n\n\t// Calculate the drone's pose in the world frame\n\tdouble drone_cam_pose_error_norm_mag = drone_cam_pose_error_norm.norm();\n\n\t// Calculate the drone's pose in the world frame\n\tdouble drone_world_pose_error_norm_mag = drone_world_pose_error_norm.norm();\n\n\t// Calculate the drone's pose in the world frame\n\tdouble drone_cam_pose_error_mag = drone_cam_pose_error.norm();\n\n\t// Calculate the drone's pose in the world frame\n\tdouble drone_world_pose_error_mag = drone_world_pose_error.norm();\n\n\t// Calculate the drone's pose in the world frame\n\tdouble drone_cam_pose_error_angle = acos(drone_cam_pose_error_", "CodeBleu_score": 28.613241610981632}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tGridNodePtr temp = current;\n\tpath.push_back(temp);\n\twhile (temp!= start) {\n\t\ttemp = cameFrom[temp];\n\t\tpath.push_back(temp);\n\t}\n\treturn path;\n}", "CodeBleu_score": 50.00360377892873}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current!= start) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 69.93685397526156}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 78.86875382773461}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert the start and end points to grid indices\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Adjust the start and end points if they are inside obstacles\n\tif (IsObstacle(start_idx)) {\n\t\tif (!AdjustPoint(start_pt, end_pt, start_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (IsObstacle(end_idx)) {\n\t\tif (!AdjustPoint(end_pt, start_pt, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 33.254531821442136}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert the coordinates to indices\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Adjust the start point if it is inside an obstacle\n\tif (IsInObstacle(start_idx)) {\n\t\tif (!AdjustPoint(start_idx, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Adjust the end point if it is inside an obstacle\n\tif (IsInObstacle(end_idx)) {\n\t\tif (!AdjustPoint(end_idx, start_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 31.417184752625538}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert the coordinates to indices\n\tstart_idx = ConvertToIndex(start_pt);\n\tend_idx = ConvertToIndex(end_pt);\n\n\t// Check if the start or end point is inside an obstacle\n\tif (IsObstacle(start_idx) || IsObstacle(end_idx)) {\n\t\t// Adjust the start point\n\t\twhile (IsObstacle(start_idx)) {\n\t\t\tstart_idx = MovePointAwayFromPoint(start_idx, end_idx);\n\t\t}\n\n\t\t// Adjust the end point\n\t\twhile (IsObstacle(end_idx)) {\n\t\t\tend_idx = MovePointAwayFromPoint(end_idx, start_idx);\n\t\t}\n\n\t\t// Convert the adjusted points to coordinates\n\t\tstart_pt = ConvertToCoordinates(start_idx);\n\t\tend_pt = ConvertToCoordinates(end_idx);\n\n\t\t// Check if the start or end point is inside an obstacle\n\t\tif (IsObstacle(start_idx) || IsObstacle(end_idx)) {\n\t\t\t// Failed to convert the coordinates to indices or adjust the points\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Convert the coordinates to indices and adjust the start and end points successfully\n\treturn true;\n}", "CodeBleu_score": 35.90317270800249}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t//std::cout << \"resetBuffer\" << std::endl;\n\t//std::cout << \"min_pos: \" << min_pos.transpose() << std::endl;\n\t//std::cout << \"max_pos: \" << max_pos.transpose() << std::endl;\n\t//std::cout << \"min_id: \" << min_id.transpose() << std::endl;\n\t//std::cout << \"max_id: \" << max_id.transpose() << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.rows(): \" << occupancy_buffer_inflate_.rows() << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.cols(): \" << occupancy_buffer_inflate_.cols() << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.size(): \" << occupancy_buffer_inflate_.size() << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.data(): \" << occupancy_buffer_inflate_.data() << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.data()[0]: \" << occupancy_buffer_inflate_.data()[0] << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.data()[1]: \" << occupancy_buffer_inflate_.data()[1] << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.data()[2]: \" << occupancy_buffer_inflate_.data()[2] << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.data()[3]: \" << occupancy_buffer_inflate_.data()[3] << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.data()[4]: \" << occupancy_buffer_inflate_.data()[4] << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.data()[5]: \" << occupancy_buffer_inflate_.data()[5] << std::endl;\n\t//std::cout << \"occupancy_buffer_inflate_.data()[6]: \" << occupancy_buffer_inflate_.data()[6] << std::endl;\n\t//std::cout", "CodeBleu_score": 4.296121439965667}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = this->world2Grid(min_pos);\n\tEigen::Vector3i max_id = this->world2Grid(max_pos);\n\n\tfor (int i = min_id(0); i <= max_id(0); ++i) {\n\t\tfor (int j = min_id(1); j <= max_id(1); ++j) {\n\t\t\tfor (int k = min_id(2); k <= max_id(2); ++k) {\n\t\t\t\tthis->occupancy_buffer_inflate_[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 54.02132389232326}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = this->worldToMap(min_pos);\n\tEigen::Vector3i max_id = this->worldToMap(max_pos);\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\tEigen::Vector3i id(x, y, z);\n\t\t\t\tthis->occupancy_buffer_inflate_(id) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.76295151330584}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_scale = 1;\n\tdouble min_scale = 1;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff(i) < 0) {\n\t\t\tmin_scale = std::min(min_scale, (-min_pt(i) - camera_pt(i)) / diff(i));\n\t\t}\n\t\telse if (diff(i) > 0) {\n\t\t\tmax_scale = std::min(max_scale, (max_pt(i) - camera_pt(i)) / diff(i));\n\t\t}\n\t}\n\n\tEigen::Vector3d result = camera_pt + diff * std::max(min_scale, max_scale);\n\treturn result;\n}", "CodeBleu_score": 38.98824735447811}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_x = (diff.x() > 0)? (width_ - 1) : 0;\n\tdouble max_y = (diff.y() > 0)? (height_ - 1) : 0;\n\tdouble max_z = (diff.z() > 0)? (depth_ - 1) : 0;\n\tdouble min_x = (diff.x() < 0)? (width_ - 1) : 0;\n\tdouble min_y = (diff.y() < 0)? (height_ - 1) : 0;\n\tdouble min_z = (diff.z() < 0)? (depth_ - 1) : 0;\n\tdouble scale_x = std::abs(diff.x() / (max_x - min_x));\n\tdouble scale_y = std::abs(diff.y() / (max_y - min_y));\n\tdouble scale_z = std::abs(diff.z() / (max_z - min_z));\n\tdouble scale = 1;\n\tif (scale_x < scale) {\n\t\tscale = scale_x;\n\t}\n\tif (scale_y < scale) {\n\t\tscale = scale_y;\n\t}\n\tif (scale_z < scale) {\n\t\tscale = scale_z;\n\t}\n\tEigen::Vector3d pt_new = pt - scale * diff;\n\treturn pt_new;\n}", "CodeBleu_score": 35.53465367373325}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tdouble min_x = 0;\n\tdouble max_x = map_width_;\n\tdouble min_y = 0;\n\tdouble max_y = map_height_;\n\tdouble min_z = 0;\n\tdouble max_z = map_depth_;\n\n\tdouble x_diff = pt.x() - camera_pt.x();\n\tdouble y_diff = pt.y() - camera_pt.y();\n\tdouble z_diff = pt.z() - camera_pt.z();\n\n\tdouble x_scale = 1;\n\tdouble y_scale = 1;\n\tdouble z_scale = 1;\n\n\tif (x_diff > 0) {\n\t\tx_scale = (max_x - pt.x()) / x_diff;\n\t}\n\telse if (x_diff < 0) {\n\t\tx_scale = (min_x - pt.x()) / x_diff;\n\t}\n\n\tif (y_diff > 0) {\n\t\ty_scale = (max_y - pt.y()) / y_diff;\n\t}\n\telse if (y_diff < 0) {\n\t\ty_scale = (min_y - pt.y()) / y_diff;\n\t}\n\n\tif (z_diff > 0) {\n\t\tz_scale = (max_z - pt.z()) / z_diff;\n\t}\n\telse if (z_diff < 0) {\n\t\tz_scale = (min_z - pt.z()) / z_diff;\n\t}\n\n\tdouble scale = std::min(std::min(x_scale, y_scale), z_scale);\n\n\tEigen::Vector3d result = pt + scale * Eigen::Vector3d(x_diff, y_diff, z_diff);\n\n\treturn result;\n}", "CodeBleu_score": 31.275800415884504}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last occupancy update time\n\tthis->last_occupancy_update_time_ = ros::Time::now();\n\n\t// Check if the local map has been updated\n\tif (this->local_map_updated_) {\n\t\t// Clear and inflate the local map\n\t\tthis->clearLocalMap();\n\t\tthis->inflateLocalMap();\n\n\t\t// Set the local map updated flag to false\n\t\tthis->local_map_updated_ = false;\n\t}\n\n\t// Check if the depth data is available\n\tif (this->depth_data_available_) {\n\t\t// Get the depth image\n\t\tconst sensor_msgs::ImageConstPtr & depth_image = this->depth_image_buffer_.front();\n\n\t\t// Project the depth image into points\n\t\tstd::vector<geometry_msgs::Point> points = this->projectDepthImage(depth_image);\n\n\t\t// Process the points with raycasting\n\t\tthis->raycast(points);\n\n\t\t// Set the depth data available flag to false\n\t\tthis->depth_data_available_ = false;\n\t}\n\n\t// Check if the odometry data is available\n\tif (this->odometry_data_available_) {\n\t\t// Get the odometry data\n\t\tconst nav_msgs::OdometryConstPtr & odometry_data = this->odometry_buffer_.front();\n\n\t\t// Update the odometry data\n\t\tthis->updateOdometry(odometry_data);\n\n\t\t// Set the odometry data available flag to false\n\t\tthis->odometry_data_available_ = false;\n\t}\n\n\t// Check if the depth timeout error has occurred\n\tif (this->depth_timeout_error_) {\n\t\t// Set the depth timeout error flag to false\n\t\tthis->depth_timeout_error_ = false;\n\n\t\t// Set the depth data available flag to false\n\t\tthis->depth_data_available_ = false;\n\t}\n\n\t// Check if the odometry timeout error has occurred\n\tif (this->odometry_timeout_error_) {\n\t\t// Set the odometry timeout error flag to false\n\t\tthis->odometry_timeout_error_ = false;\n\n\t\t// Set the odometry data available flag to false\n\t\tthis->odometry_data_available_ = false;\n\t}\n}", "CodeBleu_score": 27.267867541725405}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update last update time\n\tlast_update_time_ = ros::Time::now();\n\n\t// Check if a new depth image is available\n\tif (depth_image_received_ && depth_image_received_ && depth_image_received_ && depth_image_received_) {\n\t\t// If the local map has been updated, clear and inflate the local map\n\t\tif (local_map_updated_) {\n\t\t\t// Clear local map\n\t\t\tlocal_map_.clear();\n\n\t\t\t// Inflate local map\n\t\t\tlocal_map_.inflate(local_map_inflation_radius_, local_map_inflation_radius_);\n\n\t\t\t// Reset local map updated flag\n\t\t\tlocal_map_updated_ = false;\n\t\t}\n\n\t\t// Project depth image into points\n\t\tstd::vector<geometry_msgs::Point> points;\n\t\tprojectDepthImage(points);\n\n\t\t// Process points with raycasting\n\t\tprocessPoints(points);\n\t}\n\n\t// Check if odometry data is available\n\tif (odometry_received_) {\n\t\t// Check if the odometry data is valid\n\t\tif (odometry_.header.stamp.toSec() > last_update_time_.toSec()) {\n\t\t\t// Update last odometry update time\n\t\t\tlast_odometry_update_time_ = ros::Time::now();\n\n\t\t\t// Check if the odometry data is valid\n\t\t\tif (odometry_.header.stamp.toSec() > last_update_time_.toSec()) {\n\t\t\t\t// Get odometry data\n\t\t\t\ttf::StampedTransform transform;\n\t\t\t\ttry {\n\t\t\t\t\ttf_listener_.lookupTransform(odometry_.header.frame_id, odometry_.child_frame_id, odometry_.header.stamp, transform);\n\t\t\t\t}\n\t\t\t\tcatch (tf::TransformException &ex) {\n\t\t\t\t\tROS_ERROR(\"%s\", ex.what());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Transform odometry data into local frame\n\t\t\t\ttf::Transform local_transform;\n\t\t\t\tlocal_transform.setOrigin(transform.getOrigin());\n\t\t\t\tlocal_transform.setRotation(transform.getRotation());\n\n\t\t\t\t// Transform odometry data into local frame\n\t\t\t\ttf::Transform local_odometry_transform;\n\t\t\t\tlocal_odometry_transform.setOrigin(odometry_.pose.pose.position);\n\t\t\t", "CodeBleu_score": 32.778527590922074}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// update last occupancy update time\n\tlast_occupancy_update_time_ = ros::Time::now();\n\n\t// check if the local map needs to be updated\n\tif (local_map_update_needed_) {\n\t\t// clear and inflate local map\n\t\tlocal_map_.clear();\n\t\tlocal_map_.inflate(local_map_inflation_radius_);\n\n\t\t// set local map update needed to false\n\t\tlocal_map_update_needed_ = false;\n\t}\n\n\t// check if depth data is available\n\tif (depth_data_available_) {\n\t\t// project depth data into points\n\t\tpcl::PointCloud<pcl::PointXYZ> points;\n\t\tprojectDepthData(points);\n\n\t\t// process points with raycasting\n\t\tprocessPoints(points);\n\t}\n\n\t// check if odometry data is available\n\tif (odometry_data_available_) {\n\t\t// process odometry data\n\t\tprocessOdometryData();\n\t}\n\n\t// check if timeout error occured\n\tif (timeout_error_) {\n\t\t// clear and inflate local map\n\t\tlocal_map_.clear();\n\t\tlocal_map_.inflate(local_map_inflation_radius_);\n\n\t\t// set timeout error to false\n\t\ttimeout_error_ = false;\n\t}\n}", "CodeBleu_score": 34.10820836016219}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tint num_images = image_fns.size();\n\tfloat avg_f_measure = 0.0;\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load the image, ground truth, and detected ellipses\n\t\tMat image = imread(image_fns[i], IMREAD_GRAYSCALE);\n\t\tMat gt_ellipses = imread(gt_fns[i], IMREAD_GRAYSCALE);\n\t\tMat dt_ellipses = imread(dt_fns[i], IMREAD_GRAYSCALE);\n\n\t\t// Convert the ground truth ellipses to a vector of ellipse objects\n\t\tvector<Ellipse> gt_ellipses_vec = _ellipse_from_binary_image(gt_ellipses, gt_angle_radians);\n\n\t\t// Convert the detected ellipses to a vector of ellipse objects\n\t\tvector<Ellipse> dt_ellipses_vec = _ellipse_from_binary_image(dt_ellipses, gt_angle_radians);\n\n\t\t// Evaluate the detection performance\n\t\tfloat f_measure = _ellipse_evaluate_single_image(image, gt_ellipses_vec, dt_ellipses_vec);\n\n\t\t// Accumulate the F-measure\n\t\tavg_f_measure += f_measure;\n\t}\n\n\t// Return the average F-measure\n\treturn avg_f_measure / num_images;\n}", "CodeBleu_score": 50.3495012148631}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat f_measure_sum = 0;\n\tint num_images = image_fns.size();\n\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load the image and ground truth\n\t\tMat image = imread(image_fns[i], IMREAD_GRAYSCALE);\n\t\tMat gt = imread(gt_fns[i], IMREAD_GRAYSCALE);\n\n\t\t// Load the detected ellipses\n\t\tvector<vector<Point>> dt_ellipses;\n\t\tvector<vector<Point2f>> dt_ellipses_center;\n\t\tvector<vector<float>> dt_ellipses_angle;\n\t\tvector<vector<float>> dt_ellipses_axes;\n\t\tvector<vector<float>> dt_ellipses_angle_diff;\n\t\tvector<vector<float>> dt_ellipses_axes_diff;\n\t\tvector<vector<float>> dt_ellipses_area;\n\t\tvector<vector<float>> dt_ellipses_area_diff;\n\t\tvector<vector<float>> dt_ellipses_f_measure;\n\t\tvector<vector<float>> dt_ellipses_precision;\n\t\tvector<vector<float>> dt_ellipses_recall;\n\t\tvector<vector<float>> dt_ellipses_f_measure_diff;\n\n\t\tread_ellipses(dt_fns[i], dt_ellipses, dt_ellipses_center, dt_ellipses_angle, dt_ellipses_axes, dt_ellipses_angle_diff, dt_ellipses_axes_diff, dt_ellipses_area, dt_ellipses_area_diff, dt_ellipses_f_measure, dt_ellipses_precision, dt_ellipses_recall, dt_ellipses_f_measure_diff);\n\n\t\t// Evaluate the detection performance\n\t\tvector<vector<float>> f_measure_per_ellipse;\n\t\tvector<vector<float>> precision_per_ellipse;\n\t\tvector<vector<float>> recall_per_ellipse;\n\t\tvector<vector<float>> f_measure_diff_per_ellipse;\n\t\tvector<vector<float>> area_diff_per_ellipse;\n\t\t", "CodeBleu_score": 42.748393151706466}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\t// Load ground truth ellipses for each image\n\tvector<vector<Ellipse>> gt_ellipses;\n\tfor (string gt_fn : gt_fns) {\n\t\tgt_ellipses.push_back(load_ellipses(gt_fn, gt_angle_radians));\n\t}\n\n\t// Load detected ellipses for each image\n\tvector<vector<Ellipse>> dt_ellipses;\n\tfor (string dt_fn : dt_fns) {\n\t\tdt_ellipses.push_back(load_ellipses(dt_fn, gt_angle_radians));\n\t}\n\n\t// Calculate the F-measure for each image\n\tvector<float> f_measures;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tf_measures.push_back(ellipse_f_measure(gt_ellipses[i], dt_ellipses[i]));\n\t}\n\n\t// Return the average F-measure\n\treturn accumulate(f_measures.begin(), f_measures.end(), 0.0) / f_measures.size();\n}", "CodeBleu_score": 48.4446208452298}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = foci[0];\n\tfloat b = foci[1];\n\tfloat c = foci[2];\n\tfloat d = foci[3];\n\n\tfloat angle_1 = atan2(y - b, x - a);\n\tfloat angle_2 = atan2(y - d, x - c);\n\n\tfloat angle = angle_1 - angle_2;\n\n\tif (angle < -M_PI) {\n\t\tangle += 2 * M_PI;\n\t} else if (angle > M_PI) {\n\t\tangle -= 2 * M_PI;\n\t}\n\n\treturn angle;\n}", "CodeBleu_score": 35.93885158227646}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle1 = atan2f(foci[1] - y, foci[0] - x);\n\tfloat angle2 = atan2f(foci[3] - y, foci[2] - x);\n\tfloat angle = angle2 - angle1;\n\tif (angle > M_PI) {\n\t\tangle -= 2 * M_PI;\n\t} else if (angle < -M_PI) {\n\t\tangle += 2 * M_PI;\n\t}\n\treturn angle;\n}", "CodeBleu_score": 33.08334147266606}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_1 = atan2(y - foci[1], x - foci[0]);\n\tfloat angle_2 = atan2(y - foci[3], x - foci[2]);\n\tfloat angle_diff = angle_1 - angle_2;\n\tif (angle_diff > M_PI) {\n\t\tangle_diff -= 2 * M_PI;\n\t} else if (angle_diff < -M_PI) {\n\t\tangle_diff += 2 * M_PI;\n\t}\n\treturn angle_diff;\n}", "CodeBleu_score": 44.15980525476174}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\tdouble integral_above = 0.0;\n\tdouble integral_below = 0.0;\n\n\tfor (int i = start; i < end; i++) {\n\t\tdouble x1 = vp1[i].x;\n\t\tdouble y1 = vp1[i].y;\n\t\tdouble x2 = vp1[i + 1].x;\n\t\tdouble y2 = vp1[i + 1].y;\n\n\t\tdouble x_min = x1 < x2? x1 : x2;\n\t\tdouble x_max = x1 > x2? x1 : x2;\n\t\tdouble y_min = y1 < y2? y1 : y2;\n\t\tdouble y_max = y1 > y2? y1 : y2;\n\n\t\tdouble x_center = (x_min + x_max) / 2;\n\t\tdouble y_center = (y_min + y_max) / 2;\n\n\t\tdouble x_diff = x_max - x_min;\n\t\tdouble y_diff = y_max - y_min;\n\n\t\tdouble x_diff_squared = x_diff * x_diff;\n\t\tdouble y_diff_squared = y_diff * y_diff;\n\n\t\tdouble area_above = 0.5 * x_diff_squared * y_diff_squared;\n\t\tdouble area_below = ", "CodeBleu_score": 37.946224309761774}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].y < (min_y + max_y) / 2) {\n\t\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n\t\t}\n\t\telse {\n\t\t\tintegral_below += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n\t\t}\n\t}\n\n\tif (integral_above < integral_below) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 42.63520512342074}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\t// Compute the minimum and maximum x and y coordinates of the points in the section\n\tdouble min_x = std::numeric_limits<double>::max();\n\tdouble max_x = std::numeric_limits<double>::min();\n\tdouble min_y = std::numeric_limits<double>::max();\n\tdouble max_y = std::numeric_limits<double>::min();\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\n\t// Compute the integral above and below the polygon section\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (i == start) {\n\t\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i].y + vp1[end].y) / 2;\n\t\t\tintegral_below += (vp1[i].x - min_x) * (vp1[i].y + vp1[end].y) / 2;\n\t\t}\n\t\telse if (i == end) {\n\t\t\tintegral_above += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y + vp1[start].y) / 2;\n\t\t\tintegral_below += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y + vp1[start].y) / 2;\n\t\t}\n\t\telse {\n\t\t\tintegral_above += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y + vp1[i + 1].y) / 2;\n\t\t\tintegral_below += (vp1[i].x - vp1", "CodeBleu_score": 39.45704931904604}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tint i;\n\tbool is_detected = false;\n\tint num_regain = 0;\n\tint num_lost = 0;\n\tfor (i = 0; i < msg->detection_info.size(); i++) {\n\t\tif (msg->detection_info[i].object_name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\tif (is_detected) {\n\t\tellipse_det.sight_angle[0] = msg->detection_info[0].sight_angle[0];\n\t\tellipse_det.sight_angle[1] = msg->detection_info[0].sight_angle[1];\n\t}\n}", "CodeBleu_score": 65.53434589755011}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tellipse_det.is_detected = false;\n\tellipse_det.num_lost = 0;\n\tellipse_det.num_regain = 0;\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\tif (msg->detections[i].name == \"T\") {\n\t\t\tellipse_det.num_regain++;\n\t\t\tellipse_det.num_lost = 0;\n\t\t} else {\n\t\t\tellipse_det.num_lost++;\n\t\t\tellipse_det.num_regain = 0;\n\t\t}\n\t\tif (ellipse_det.num_lost > VISION_THRES) {\n\t\t\tellipse_det.is_detected = false;\n\t\t}\n\t\tif (ellipse_det.num_regain > VISION_THRES) {\n\t\t\tellipse_det.is_detected = true;\n\t\t}\n\t}\n\tellipse_det.sight_angle = msg->sight_angle;\n}", "CodeBleu_score": 35.34103433337423}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor(int i = 0; i < msg->detection_info.size(); i++) {\n\t\tif(msg->detection_info[i].object_name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t}\n\t\telse {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif(num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif(num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\tellipse_det.sight_angle[0] = msg->detection_info[0].sight_angle[1];\n\tellipse_det.sight_angle[1] = msg->detection_info[0].sight_angle[0];\n}", "CodeBleu_score": 64.47145870903253}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t//Get the current position in the map\n\tdouble x = cur_pos(0);\n\tdouble y = cur_pos(1);\n\tdouble z = cur_pos(2);\n\t//Get the current position in the map\n\tint x_map = (int) (x / map_resolution_);\n\tint y_map = (int) (y / map_resolution_);\n\tint z_map = (int) (z / map_resolution_);\n\t//Check if the position is occupied\n\tif (occupy_map_ptr_->get_occupancy_value(x_map, y_map, z_map) > safe_distance) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 38.74665825620083}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// check the safety of the position\n\tbool is_safe = Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n\treturn is_safe;\n}", "CodeBleu_score": 65.10518706499107}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// Start at the end node\n\tNodePtr current_node = end_node;\n\t// Follow the parent pointers to trace the path back to the start node\n\twhile (current_node->getParent()!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->getParent();\n\t}\n\t// Push the start node onto the path\n\tpath_nodes_.push_back(current_node);\n\t// Reverse the order of path_nodes_ to present the path from start to end\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 58.40231427428616}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// Start at the end node\n\tNodePtr curr_node = end_node;\n\n\t// While we haven't reached the start node\n\twhile (curr_node->parent!= nullptr) {\n\t\t// Add the current node to the path\n\t\tpath_nodes_.push_back(curr_node);\n\n\t\t// Move to the parent node\n\t\tcurr_node = curr_node->parent;\n\t}\n\n\t// Add the start node to the path\n\tpath_nodes_.push_back(curr_node);\n\n\t// Reverse the order of the path\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.92714992714266}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr curr_node = end_node;\n\twhile (curr_node->parent!= nullptr) {\n\t\tpath_nodes_.push_back(curr_node);\n\t\tcurr_node = curr_node->parent;\n\t}\n\tpath_nodes_.push_back(curr_node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.94227947145687}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"id: %d\", id);\n\t//ROS_INFO(\"odom.pose.pose.position.x: %f\", odom->pose.pose.position.x);\n\t//ROS_INFO(\"odom.pose.pose.position.y: %f\", odom->pose.pose.position.y);\n\t//ROS_INFO(\"odom.pose.pose.position.z: %f\", odom->pose.pose.position.z);\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\tif (sim_mode) {\n\t\tif (sqrt(pow(odom->pose.pose.position.x - start_pos.x, 2) + pow(odom->pose.pose.position.y - start_pos.y, 2)) > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 47.967863408276166}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"Received odometry data from UGV %d\", id);\n\t//ROS_INFO(\"UGV %d: x = %f, y = %f, z = %f\", id, odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].get_nei_state = true;\n\tif (sim_mode) {\n\t\tdouble dist = sqrt(pow(state_nei[id].x - start_x, 2) + pow(state_nei[id].y - start_y, 2));\n\t\tif (dist > 5) {\n\t\t\tstate_nei[id].get_nei_state = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 33.550494038512426}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\tif (sim_mode) {\n\t\tif (sqrt(pow(odom->pose.pose.position.x - start_pos.x, 2) + pow(odom->pose.pose.position.y - start_pos.y, 2)) > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n\tstate_nei[id].pos.x = odom->pose.pose.position.x;\n\tstate_nei[id].pos.y = odom->pose.pose.position.y;\n\tstate_nei[id].pos.z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].vel = odom->twist.twist.linear.x;\n\tstate_nei[id].height = odom->pose.pose.position.z;\n}", "CodeBleu_score": 53.59052560791005}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t// If odometry is not ready, return immediately\n\tif (!odom_ready) {\n\t\treturn;\n\t}\n\n\t// Set sensor_ready flag to true and increment update counter\n\tsensor_ready = true;\n\tupdate_count++;\n\n\t// If update counter is 5, update the Astar map with the new point cloud data\n\tif (update_count == 5) {\n\t\tupdate_count = 0;\n\t\tupdateAstarMap(msg);\n\t}\n}", "CodeBleu_score": 51.92463568813835}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"point cloud callback\");\n\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tupdate_counter++;\n\t\tif (update_counter % 5 == 0) {\n\t\t\tupdate_counter = 0;\n\t\t\t//ROS_INFO(\"update map\");\n\t\t\tupdate_map(msg);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.84756597862161}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//if (sensor_ready) {\n\t\t//std::cout << \"Received point cloud\" << std::endl;\n\t\t//pcl::PointCloud<pcl::PointXYZ> cloud;\n\t\t//pcl::fromROSMsg(*msg, cloud);\n\t\t//pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n\t\t//Astar_map.update(cloud_ptr);\n\t\t//update_counter++;\n\t\t//if (update_counter >= 5) {\n\t\t\t//Astar_map.update_map();\n\t\t\t//update_counter = 0;\n\t\t//}\n\t//}\n}", "CodeBleu_score": 5.524728674891709}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tpcl::PointCloud<pcl::PointXYZRGB>::Ptr gpcl_inflated (new pcl::PointCloud<pcl::PointXYZRGB>);\n\t\tpcl::inflation_radius = 0.5;\n\t\tpcl::inflation_radius = 0.05;\n\t\tpcl::inflation_radius = 0.02;\n\t\tpcl::inflation_radius = 0.01;\n\t\tpcl::inflation_radius = 0.005;\n\t\tpcl::inflation_radius = 0.002;\n\t\tpcl::inflation_radius = 0.001;\n\t\tpcl::inflation_radius = 0.0005;\n\t\tpcl::inflation_radius = 0.0002;\n\t\tpcl::inflation_radius = 0.0001;\n\t\tpcl::inflation_radius = 0.00005;\n\t\tpcl::inflation_radius = 0.00002;\n\t\tpcl::inflation_radius = 0.00001;\n\t\tpcl::inflation_radius = 0.000005;\n\t\tpcl::inflation_radius = 0.000002;\n\t\tpcl::inflation_radius = 0.000001;\n\t\tpcl::inflation_radius = 0.0000005;\n\t\tpcl::inflation_radius = 0.0000002;\n\t\tpcl::inflation_radius = 0.0000001;\n\t\tpcl::inflation_radius = 0.00000005;\n\t\tpcl::inflation_radius = 0.00000002;\n\t\tpcl::inflation_radius = 0.00000001;\n\t\tpcl::inflation_radius = 0.000000005;\n\t\tpcl::inflation_radius", "CodeBleu_score": 43.90714916620618}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\t// Check if the global map has been updated\n\tif (get_gpcl == false) {\n\t\t// Set the flag\n\t\tget_gpcl = true;\n\t\t// Convert the sensor message to a point cloud\n\t\tpcl::fromROSMsg(*global_point, global_map);\n\t\t// Inflation\n\t\tinflation(global_map, 0.3);\n\t\t// Publish the global map\n\t\tpublish_map();\n\t}\n}", "CodeBleu_score": 47.62385301483635}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(get_gpcl == false){\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, global_map);\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped_transformed;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped_transformed_filtered;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped_transformed_filtered_downsampled;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped_transformed_filtered_downsampled_flipped;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped_transformed_filtered_downsampled_flipped_transformed;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped_transformed_filtered_downsampled_flipped_transformed_filtered;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped_transformed_filtered_downsampled_flipped_transformed_filtered_downsampled;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped_transformed_filtered_downsampled_flipped_transformed_filtered_downsampled_flipped;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped_transformed_filtered_downsampled_flipped_transformed_filtered_downsampled_flipped_transformed;\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_inflated_filtered_downsampled_flipped_transformed_filtered_downsampled_f", "CodeBleu_score": 31.911948107119812}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// 1. Transform laser scan into PointCloud2 format\n\tpcl::PointCloud<pcl::PointXYZ> local_cloud;\n\tsensor_msgs::PointCloud2 local_cloud2;\n\tlaser_scan_to_point_cloud2(local_point, local_cloud2);\n\t// 2. Convert PointCloud2 to pcl::PointCloud\n\tpcl::fromROSMsg(local_cloud2, local_cloud);\n\t// 3. Merge local map with odometry data\n\tif (!simulated_mode) {\n\t\t// 3.1. Transform local map into PointCloud2 format\n\t\tpcl::PointCloud<pcl::PointXYZ> local_map_cloud;\n\t\tpcl::toROSMsg(*local_map, local_map_cloud);\n\t\t// 3.2. Transform local map into Eigen::Affine3d format\n\t\tEigen::Affine3d local_map_transform = Eigen::Affine3d::Identity();\n\t\tpcl::getTransformation(local_map_transform.matrix());\n\t\t// 3.3. Transform local map into Eigen::Affine3d format\n\t\tEigen::Affine3d local_odom_transform = Eigen::Affine3d::Identity();\n\t\tlocal_odom_transform.translation() = Eigen::Vector3d(odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z);\n\t\tlocal_odom_transform.rotate(Eigen::Quaterniond(odom.pose.pose.orientation.w, odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z));\n\t\t// 3.4. Transform local map into Eigen::Affine3d format\n\t\tEigen::Affine3d local_map_odom_transform = local_map_transform * local_odom_transform;\n\t\t// 3.5. Transform local map into PointCloud2 format\n\t\tpcl::PointCloud<pcl::PointXYZ> local_map_odom_cloud;\n\t\tpcl::transformPointCloud(local_map_cloud, local_map_odom_cloud, local_map_odom_transform);\n\t\t// 3.6. Merge local map with odometry data\n\t\t*local_map += local", "CodeBleu_score": 40.374930300982584}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert the laser scan into a PointCloud2 format\n\tpcl::PointCloud<pcl::PointXYZ> local_cloud;\n\tpcl::fromROSMsg(*local_point, local_cloud);\n\n\t// Merge the local map with the provided odometry data\n\tif (!simulation_mode) {\n\t\tmerge_local_map(local_cloud, odom);\n\t}\n}", "CodeBleu_score": 40.41590826661202}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr map_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_in(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr map_cloud_in(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_out(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr map_cloud_out(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr map_cloud_out_in(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr map_cloud_out_out(new pcl::PointCloud<pcl::PointXYZ>);\n\n\t// Convert the laser scan to a PointCloud2 format\n\tpcl::fromROSMsg(*local_point, *laser_cloud);\n\n\t// Convert the map to a PointCloud2 format\n\tpcl::fromROSMsg(*map_cloud_msg, *map_cloud);\n\n\t// Filter the laser scan data\n\tpcl::PassThrough<pcl::PointXYZ> pass;\n\tpass.setInputCloud(laser_cloud);\n\tpass.setFilterFieldName(\"z\");\n\tpass.setFilterLimits(0.0, 2.0);\n\tpass.filter(*laser_cloud_in);\n\n\t// Filter the map data\n\tpass.setInputCloud(map_cloud);\n\tpass.setFilterFieldName(\"z\");\n\tpass.setFilterLimits(0.0, 2.0);\n\tpass.filter(*map_cloud_in);\n\n\t// Transform the laser scan data to the map frame\n\tpcl_ros::transformPointCloud(odom.pose.pose, *laser_cloud_in, *laser_cloud_out, map_frame_);\n\n\t// Transform the map data to the map frame\n\tpcl_ros::transformPointCloud(odom.pose.pose, *map_cloud_in, *map_cloud_out", "CodeBleu_score": 39.72563415612058}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert global point cloud map to ROS message\n\tsensor_msgs::PointCloud2 global_pcl_msg;\n\tpcl::toROSMsg(*global_pcl_, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\n\t// Convert inflated point cloud map to ROS message\n\tsensor_msgs::PointCloud2 inflate_pcl_msg;\n\tpcl::toROSMsg(*inflate_pcl_, inflate_pcl_msg);\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\n\t// Publish global point cloud map\n\tglobal_pcl_pub_.publish(global_pcl_msg);\n\n\t// Publish inflated point cloud map\n\tinflate_pcl_pub_.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 57.74035870131928}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert global point cloud map to ROS message\n\tsensor_msgs::PointCloud2 global_pcl_msg;\n\tpcl::toROSMsg(*global_pcl_map_, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\n\t// Publish global point cloud map\n\tglobal_pcl_pub_.publish(global_pcl_msg);\n\n\t// Convert inflated point cloud map to ROS message\n\tsensor_msgs::PointCloud2 inflated_pcl_msg;\n\tpcl::toROSMsg(*inflated_pcl_map_, inflated_pcl_msg);\n\tinflated_pcl_msg.header.frame_id = \"world\";\n\tinflated_pcl_msg.header.stamp = ros::Time::now();\n\n\t// Publish inflated point cloud map\n\tinflate_pcl_pub_.publish(inflated_pcl_msg);\n}", "CodeBleu_score": 57.761812829581416}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::PointCloud<pcl::PointXYZ> global_pcl;\n\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl;\n\n\t// Convert the global point cloud map to a ROS message\n\tpcl::toROSMsg(*global_pcl_map_, global_pcl);\n\tglobal_pcl.header.frame_id = \"world\";\n\tglobal_pcl.header.stamp = ros::Time::now();\n\n\t// Convert the inflated point cloud map to a ROS message\n\tpcl::toROSMsg(*inflated_pcl_map_, inflated_pcl);\n\tinflated_pcl.header.frame_id = \"world\";\n\tinflated_pcl.header.stamp = ros::Time::now();\n\n\t// Publish the global point cloud map\n\tglobal_pcl_pub_.publish(global_pcl);\n\n\t// Publish the inflated point cloud map\n\tinflated_pcl_pub_.publish(inflated_pcl);\n}", "CodeBleu_score": 55.05559427813614}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.seq);\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.stamp.toNSec());\n\t//ROS_INFO(\"Lpointcloud", "CodeBleu_score": 8.129517961768457}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!sensor_ready) {\n\t\treturn;\n\t}\n\n\t// Set the sensor_ready flag to false, so that the A* algorithm is not updated until odometry is ready.\n\tsensor_ready = false;\n\n\t// Create a new point cloud message from the incoming point cloud message.\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr new_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*msg, *new_cloud);\n\n\t// Update the A* algorithm's map using the new point cloud data and current UAV odometry.\n\tastar_planner.update_map(new_cloud, uav_odometry);\n\n\t// Set the sensor_ready flag to true, so that the A* algorithm can be updated again.\n\tsensor_ready = true;\n}", "CodeBleu_score": 61.152364591130656}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n", "CodeBleu_score": 9.03593627644455}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get current time\n\tros::Time currentTime = ros::Time::now();\n\n\t// Calculate desired foot positions\n\tbodyController_->update(currentTime);\n\tbodyController_->getDesiredFootPositions(desiredFootPositions_);\n\n\t// Calculate velocity commands for legs\n\tlegController_->update(currentTime);\n\tlegController_->computeVelocityCommands(desiredFootPositions_, desiredJointVelocities_);\n\n\t// Calculate target joint positions\n\tlegController_->computeTargetJointPositions(desiredJointVelocities_, targetJointPositions_);\n\n\t// Publish foot contact information\n\tpublishFootContactInformation();\n\n\t// Publish joint positions\n\tpublishJointPositions();\n}", "CodeBleu_score": 43.97790487907223}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Calculate the target foot positions based on the desired pose using the body controller.\n\tEigen::Vector3d target_foot_position;\n\tEigen::Vector3d target_foot_velocity;\n\tEigen::Vector3d target_foot_acceleration;\n\tEigen::Vector3d target_foot_jerk;\n\tEigen::Vector3d target_foot_snap;\n\tEigen::Vector3d target_foot_cruise;\n\tEigen::Vector3d target_foot_jog;\n\tEigen::Vector3d target_foot_force;\n\tEigen::Vector3d target_foot_torque;\n\tEigen::Vector3d target_foot_jerk_force;\n\tEigen::Vector3d target_foot_jerk_torque;\n\tEigen::Vector3d target_foot_snap_force;\n\tEigen::Vector3d target_foot_snap_torque;\n\tEigen::Vector3d target_foot_cruise_force;\n\tEigen::Vector3d target_foot_cruise_torque;\n\tEigen::Vector3d target_foot_jog_force;\n\tEigen::Vector3d target_foot_jog_torque;\n\tEigen::Vector3d target_foot_acceleration_force;\n\tEigen::Vector3d target_foot_acceleration_torque;\n\tEigen::Vector3d target_foot_jerk_acceleration_force;\n\tEigen::Vector3d target_foot_jerk_acceleration_torque;\n\tEigen::Vector3d target_foot_snap_acceleration_force;\n\tEigen::Vector3d target_foot_snap_acceleration_torque;\n\tEigen::Vector3d target_foot_cruise_acceleration_force;\n\tEigen::Vector3d target_foot_cruise_acceleration_torque;\n\tEigen::Vector3d target_foot_jog_acceleration_force;\n\tEigen::Vector3d target_foot_jog_acceleration_torque;\n\tEigen::Vector3d target_foot_jerk_jog_force;\n\tEigen::Vector3d target_foot_jerk_jog_torque;\n\tEigen::Vector3d target_foot_snap_jog_force;\n\tEigen::Vector", "CodeBleu_score": 8.581275309378388}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get current time\n\tros::Time time = ros::Time::now();\n\n\t// Calculate the desired foot positions\n\tbodyController_->calculateFootPositions(time, desiredPose_);\n\n\t// Calculate the desired joint positions\n\tlegController_->calculateJointPositions(time, desiredPose_, footPositions_);\n\n\t// Publish the foot contact information\n\tlegController_->publishFootContactInformation(time);\n\n\t// Publish the joint positions\n\tlegController_->publishJointPositions(time);\n}", "CodeBleu_score": 40.48339726360854}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_!= NULL) {\n\t\t// Create the message\n\t\tif (foot_contacts_publisher_->trylock()) {\n\t\t\tfoot_contacts_publisher_->msg_.header.stamp = ros::Time::now();\n\t\t\tfoot_contacts_publisher_->msg_.header.frame_id = \"world\";\n\t\t\tfoot_contacts_publisher_->msg_.contact_states.resize(4);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tfoot_contacts_publisher_->msg_.contact_states[i] = foot_contacts[i]? 1 : 0;\n\t\t\t}\n\t\t\tfoot_contacts_publisher_->unlockAndPublish();\n\t\t}\n\t}\n}", "CodeBleu_score": 49.07866342822129}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_enabled_ &&!gazebo_) {\n\t\t// Create message\n\t\tstd_msgs::Header header;\n\t\theader.stamp = ros::Time::now();\n\t\theader.frame_id = \"world\";\n\t\tsensor_msgs::Contacts contacts;\n\t\tcontacts.header = header;\n\t\tcontacts.point_cloud_frame = \"world\";\n\t\tcontacts.points.resize(4);\n\n\t\t// Fill message\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tsensor_msgs::Point contact;\n\t\t\tcontact.x = 0.0;\n\t\t\tcontact.y = 0.0;\n\t\t\tcontact.z = 0.0;\n\t\t\tcontact.normal_x = 0.0;\n\t\t\tcontact.normal_y = 0.0;\n\t\t\tcontact.normal_z = 0.0;\n\t\t\tcontact.header = header;\n\t\t\tcontact.id = i;\n\t\t\tcontact.point_cloud_frame = \"world\";\n\t\t\tcontacts.points[i] = contact;\n\t\t}\n\n\t\t// Fill message\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts.points[i].contact_point.x = 0.0;\n\t\t\tcontacts.points[i].contact_point.y = 0.0;\n\t\t\tcontacts.points[i].contact_point.z = 0.0;\n\t\t\tcontacts.points[i].contact_point.normal_x = 0.0;\n\t\t\tcontacts.points[i].contact_point.normal_y = 0.0;\n\t\t\tcontacts.points[i].contact_point.normal_z = 0.0;\n\t\t\tcontacts.points[i].contact_point.header = header;\n\t\t\tcontacts.points[i].contact_point.id = i;\n\t\t\tcontacts.points[i].contact_point.point_cloud_frame = \"world\";\n\t\t}\n\n\t\t// Fill message\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts.points[i].position.x = 0.0;\n\t\t\tcontacts.points[i].position.y = 0.0;\n\t\t\tcontacts.points[i].position.z = 0.0;", "CodeBleu_score": 54.158700604118216}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_enabled_ &&!in_gazebo_) {\n\t\t// Create a ContactsStamped message\n\t\tstd_msgs::Header header;\n\t\theader.stamp = ros::Time::now();\n\t\theader.frame_id = \"world\";\n\t\tstd_msgs::String gait_phase;\n\t\tgait_phase.data = gait_phase_.data;\n\t\tstd_msgs::String gait_phase_prev;\n\t\tgait_phase_prev.data = gait_phase_prev_.data;\n\t\tstd_msgs::String gait_phase_next;\n\t\tgait_phase_next.data = gait_phase_next_.data;\n\t\tstd_msgs::String gait_phase_next_next;\n\t\tgait_phase_next_next.data = gait_phase_next_next_.data;\n\t\tstd_msgs::String gait_phase_next_next_next;\n\t\tgait_phase_next_next_next.data = gait_phase_next_next_next_.data;\n\t\tstd_msgs::String gait_phase_next_next_next_next;\n\t\tgait_phase_next_next_next_next.data = gait_phase_next_next_next_next_.data;\n\t\tstd_msgs::String gait_phase_next_next_next_next_next;\n\t\tgait_phase_next_next_next_next_next.data = gait_phase_next_next_next_next_next_.data;\n\t\tstd_msgs::String gait_phase_next_next_next_next_next_next;\n\t\tgait_phase_next_next_next_next_next_next.data = gait_phase_next_next_next_next_next_next_.data;\n\t\tstd_msgs::String gait_phase_next_next_next_next_next_next_next;\n\t\tgait_phase_next_next_next_next_next_next_next.data = gait_phase_next_next_next_next_next_next_next_.data;\n\t\tstd_msgs::String gait_phase_next_next_next_next_next_next_next_next", "CodeBleu_score": 25.550404304066543}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\t//Create a minimal joints message\n\tjoints_msg = Joints()\n\tjoints_msg.name = joints.name\n\tjoints_msg.position = joints.position[0:12]\n\tjoints_msg.velocity = joints.velocity[0:12]\n\tjoints_msg.effort = joints.effort[0:12]\n\tjoints_msg.time_from_start = joints.time_from_start\n\n\t//Publish the minimal joints message\n\tself.joints_pub.publish(joints_msg)\n\n\t//Create a joint trajectory message\n\ttraj_msg = JointTrajectory()\n\ttraj_msg.header.stamp = rospy.Time.now()\n\ttraj_msg.header.frame_id = \"base_link\"\n\ttraj_msg.joint_names = joints.name\n\ttraj_msg.points.append(JointTrajectoryPoint())\n\ttraj_msg.points[0].positions = joints.position\n\ttraj_msg.points[0].velocities = joints.velocity\n\ttraj_msg.points[0].accelerations = joints.effort\n\ttraj_msg.points[0].time_from_start = joints.time_from_start\n\n\t//Publish the joint trajectory message\n\tself.traj_pub.publish(traj_msg)\n}", "CodeBleu_score": 33.9809662153632}, {"code": "def joints_cmd_callback(self, joints){\n\t\t// Create a joints message with the first 12 joint positions\n\tjoints_msg = Joints()\n\tfor i in range(0, 12):\n\t\tjoints_msg.position.append(joints.position[i])\n\n\t// Publish the joints message\n\tself.joints_pub.publish(joints_msg)\n\n\t// Create a joint trajectory message with the same positions and a specified duration\n\ttraj_msg = JointTrajectory()\n\ttraj_msg.joint_names = joints_msg.joint_names\n\ttraj_msg.points.append(JointTrajectoryPoint())\n\ttraj_msg.points[0].positions = joints_msg.position\n\ttraj_msg.points[0].time_from_start = rospy.Duration.from_sec(0.5)\n\n\t// Publish the trajectory message\n\tself.traj_pub.publish(traj_msg)\n}", "CodeBleu_score": 43.03939578915425}, {"code": "def joints_cmd_callback(self, joints){\n\t\tmsg = Joints()\n\tmsg.name = joints.name\n\tmsg.position = joints.position\n\tmsg.velocity = joints.velocity\n\tmsg.effort = joints.effort\n\tmsg.position[12:] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\tmsg.velocity[12:] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\tmsg.effort[12:] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\tself.pub.publish(msg)\n\ttraj = JointTrajectory()\n\ttraj.joint_names = joints.name\n\ttraj.points.append(JointTrajectoryPoint())\n\ttraj.points[0].positions = joints.position\n\ttraj.points[0].velocities = joints.velocity\n\ttraj.points[0].accelerations = joints.effort\n\ttraj.points[0].time_from_start = rospy.Duration(0.5)\n\tself.traj_pub.publish(traj)\n}", "CodeBleu_score": 37.96523946973161}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize foot contact states to false\n\tbool foot_contact_states[2] = {false, false};\n\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); ++i) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::vector<std::string> split_collision_string;\n\t\tboost::split(split_collision_string, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n\n\t\t// If a contact matches one of the foot links\n\t\tif (split_collision_string.back() == \"foot_link\" || split_collision_string.back() == \"foot_link_left\" || split_collision_string.back() == \"foot_link_right\") {\n\t\t\t// Set the corresponding foot contact state to true\n\t\t\tif (split_collision_string.back() == \"foot_link\") {\n\t\t\t\tfoot_contact_states[0] = true;\n\t\t\t\tfoot_contact_states[1] = true;\n\t\t\t} else if (split_collision_string.back() == \"foot_link_left\") {\n\t\t\t\tfoot_contact_states[0] = true;\n\t\t\t} else if (split_collision_string.back() == \"foot_link_right\") {\n\t\t\t\tfoot_contact_states[1] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Create a champ_msgs::ContactsStamped message\n\tchamp_msgs::ContactsStamped msg;\n\tmsg.header.stamp = ros::Time::now();\n\tmsg.header.frame_id = \"world\";\n\tmsg.left_foot_contact = foot_contact_states[0];\n\tmsg.right_foot_contact = foot_contact_states[1];\n\n\t// Publish the message\n\tpub_.publish(msg);\n}", "CodeBleu_score": 40.19001384445004}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision_string = _msg->contact(i).collision1();\n\t\tstd::vector<std::string> collision_string_split;\n\t\tboost::split(collision_string_split, collision_string, boost::is_any_of(\"/\"));\n\t\tif (collision_string_split[0] == \"l_foot\" || collision_string_split[0] == \"r_foot\") {\n\t\t\tif (collision_string_split[0] == \"l_foot\") {\n\t\t\t\tl_foot_contact_ = true;\n\t\t\t} else {\n\t\t\t\tr_foot_contact_ = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.68516241102426}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize foot contact states to false\n\tfor (int i = 0; i < 4; i++) {\n\t\tfootContactStates[i] = false;\n\t}\n\n\t// For each contact in the message, split the collision string to identify the contact link\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::vector<std::string> tokens;\n\t\tboost::split(tokens, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n\t\tstd::string linkName = tokens[tokens.size() - 1];\n\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (linkName == footLinkNames[j]) {\n\t\t\t\tfootContactStates[j] = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 61.47034496145323}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Ensure the input is valid\n\tif (!rotor_velocities) {\n\t\tROS_ERROR_STREAM(\"rotor_velocities is NULL\");\n\t\treturn;\n\t}\n\n\t// Ensure the parameters are valid\n\tif (rotor_velocities_ == nullptr) {\n\t\tROS_ERROR_STREAM(\"rotor_velocities_ is NULL\");\n\t\treturn;\n\t}\n\n\t// Ensure the controller is active\n\tif (!is_active_) {\n\t\tfor (int i = 0; i < rotor_velocities_->size(); ++i) {\n\t\t\t(*rotor_velocities)[i] = 0.0;\n\t\t}\n\t\treturn;\n\t}\n\n\t// Calculate the desired acceleration and angular acceleration\n\tEigen::Vector3d acceleration_body = CalculateDesiredAcceleration();\n\tEigen::Vector3d angular_acceleration_body = CalculateDesiredAngularAcceleration();\n\n\t// Project thrust onto the body z-axis\n\tdouble thrust = acceleration_body.z();\n\tacceleration_body.z() = 0.0;\n\n\t// Combine angular acceleration and thrust into a single vector\n\tEigen::Vector3d acceleration_body_and_angular_acceleration_body = thrust * acceleration_body + angular_acceleration_body;\n\n\t// Compute the rotor velocities\n\tEigen::VectorXd rotor_velocities_unprojected = rotor_velocities_matrix_ * acceleration_body_and_angular_acceleration_body;\n\tfor (int i = 0; i < rotor_velocities_unprojected.size(); ++i) {\n\t\t(*rotor_velocities)[i] = std::sqrt(std::max(rotor_velocities_unprojected[i], 0.0));\n\t}\n}", "CodeBleu_score": 41.92718824578259}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tif (!is_active_) {\n\t\trotor_velocities->setZero(4);\n\t\treturn;\n\t}\n\n\t// Calculate desired acceleration and angular acceleration.\n\tEigen::Vector3d desired_acceleration = CalculateDesiredAcceleration();\n\tEigen::Vector3d desired_angular_acceleration = CalculateDesiredAngularAcceleration();\n\n\t// Calculate thrust.\n\tEigen::Vector3d thrust_vector = CalculateThrust();\n\n\t// Calculate combined acceleration.\n\tEigen::Vector3d combined_acceleration = desired_acceleration + desired_angular_acceleration + thrust_vector;\n\n\t// Calculate rotor velocities.\n\tEigen::VectorXd rotor_velocities_unconstrained = rotor_matrix_ * combined_acceleration;\n\trotor_velocities_unconstrained.array().max(0.0);\n\trotor_velocities->array() = rotor_velocities_unconstrained.array().sqrt();\n}", "CodeBleu_score": 30.11219936323467}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Ensure the input is valid\n\tif (!rotor_velocities) {\n\t\tthrow std::invalid_argument(\"rotor_velocities cannot be null\");\n\t}\n\tif (rotor_velocities->size()!= 4) {\n\t\tthrow std::invalid_argument(\"rotor_velocities must have 4 elements\");\n\t}\n\n\t// Ensure the controller is active\n\tif (!is_active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\t// Ensure the input parameters are valid\n\tif (!parameters_valid_) {\n\t\tthrow std::invalid_argument(\"Parameters are not valid\");\n\t}\n\n\t// Calculate the desired acceleration and angular acceleration\n\tEigen::Vector3d acceleration = Eigen::Vector3d::Zero();\n\tEigen::Vector3d angular_acceleration = Eigen::Vector3d::Zero();\n\n\t// If the controller is active, calculate the desired acceleration and angular acceleration\n\tif (is_active_) {\n\t\t// Calculate the desired acceleration and angular acceleration\n\t\tacceleration = CalculateDesiredAcceleration();\n\t\tangular_acceleration = CalculateDesiredAngularAcceleration();\n\t}\n\n\t// Project thrust onto the body z-axis\n\tEigen::Vector3d thrust_vector = Eigen::Vector3d::Zero();\n\tthrust_vector(2) = thrust_;\n\n\t// Combine angular acceleration and thrust into a single vector\n\tEigen::Vector3d combined_vector = angular_acceleration + thrust_vector;\n\n\t// Compute the rotor velocities\n\tEigen::Vector4d rotor_velocities_vector = rotor_velocities_matrix_ * combined_vector;\n\n\t// Ensure the rotor velocities are non-negative\n\tfor (int i = 0; i < 4; i++) {\n\t\trotor_velocities_vector(i) = std::max(0.0, rotor_velocities_vector(i));\n\t}\n\n\t// Take the square root of each component\n\tfor (int i = 0; i < 4; i++) {\n\t\trotor_velocities_vector(i) = std::sqrt(rotor_velocities_vector(i));\n\t}\n\n\t// Copy the rotor velocities into the output vector\n\trotor_velocities->setZero();\n\tfor", "CodeBleu_score": 41.72001548410203}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// get current position and velocity\n\tEigen::Vector3d position = this->odometry_data_.position;\n\tEigen::Vector3d velocity = this->odometry_data_.velocity;\n\n\t// transform velocity to world frame\n\tEigen::Vector3d world_velocity = this->odometry_data_.orientation.toRotationMatrix() * velocity;\n\n\t// compute velocity error\n\tEigen::Vector3d velocity_error = this->command_trajectory_.velocity - world_velocity;\n\n\t// compute acceleration error\n\tEigen::Vector3d acceleration_error = this->command_trajectory_.acceleration - this->odometry_data_.acceleration;\n\n\t// compute position error\n\tEigen::Vector3d position_error = this->command_trajectory_.position - position;\n\n\t// compute desired acceleration\n\t*acceleration = this->command_trajectory_.acceleration - this->mass_ * (this->gravity_ + velocity_error * this->velocity_gain_) - position_error * this->position_gain_ - acceleration_error * this->acceleration_gain_;\n}", "CodeBleu_score": 38.491848207600434}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d position_error = command_trajectory_.position() - odometry_.position();\n\tEigen::Vector3d velocity_error = command_trajectory_.velocity() - odometry_.velocity();\n\tEigen::Vector3d velocity_error_world = vehicle_state_.R_to_world.transpose() * velocity_error;\n\tEigen::Vector3d desired_acceleration = command_trajectory_.acceleration() - vehicle_state_.gravity - vehicle_state_.mass * (vehicle_state_.R_to_world.transpose() * vehicle_state_.R_to_world * velocity_error_world);\n\t*acceleration = position_error * position_gain_ + velocity_error * velocity_gain_ + desired_acceleration;\n}", "CodeBleu_score": 44.9470275214781}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute position and velocity errors\n\tEigen::Vector3d position_error = position_command_ - position_;\n\tEigen::Vector3d velocity_error = velocity_command_ - velocity_;\n\n\t// Transform vehicle velocity to world frame\n\tEigen::Vector3d velocity_world = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_dot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_ddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_dddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_ddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_dddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_ddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_ddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_ddddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_dddddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_dddddddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_ddddddddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_dddddddddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_dddddddddddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_ddddddddddddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_dddddddddddddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_ddddddddddddddddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_dddddddddddddddddddddddot = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_world_dddddddddddddddddddddddddot = Eigen::Vector3d::Zero();\n\t", "CodeBleu_score": 13.676004461794792}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// TODO: Calculate the rotor velocities.\n\t// You can use the provided function to calculate the desired thrust and the desired angular acceleration.\n\t// This function will also return the desired rotor velocities.\n\t// The desired rotor velocities must be between 1 and 250, inclusive.\n\n\t// This is the desired angular acceleration.\n\tEigen::VectorXd desired_angular_acceleration = CalculateDesiredAngularAcceleration();\n\n\t// This is the desired thrust.\n\tEigen::VectorXd desired_thrust = CalculateDesiredThrust();\n\n\t// This is the desired rotor velocities.\n\tEigen::VectorXd desired_rotor_velocities = CalculateDesiredRotorVelocities(desired_angular_acceleration, desired_thrust);\n\n\t// This is the desired rotor velocities.\n\trotor_velocities->resize(rotors_.size());\n\tfor (int i = 0; i < rotors_.size(); i++) {\n\t\t(*rotor_velocities)(i) = desired_rotor_velocities(i);\n\t}\n}", "CodeBleu_score": 33.03794761586083}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// TODO: Calculate the rotor velocities.\n\t// You can use the provided math functions and the rotations matrix.\n\t// You only need to use the first 4 elements of the rotations matrix (w11-w44).\n\t// For example, rotations_(0,0) gives you w11.\n\t// You can also use the provided math functions.\n\t// For example, you can calculate sin of the roll angle using math_utils::sin(roll_angle).\n\n\t// Ensure the input is valid.\n\tif (rotor_velocities == nullptr) {\n\t\tthrow std::invalid_argument(\"rotor_velocities cannot be null.\");\n\t}\n\tif (rotor_velocities->size()!= num_rotors_) {\n\t\tthrow std::invalid_argument(\"rotor_velocities must be the same size as the number of rotors.\");\n\t}\n\n\t// Calculate the desired angular acceleration.\n\t// Note: The desired angular acceleration is the sum of the desired acceleration and the acceleration due to gravity.\n\t// Note: The desired acceleration is the sum of the desired acceleration due to thrust and the acceleration due to gravity.\n\t// Note: The desired acceleration due to thrust is the thrust reference divided by the mass.\n\t// Note: The desired acceleration due to gravity is the sum of the acceleration due to gravity and the acceleration due to gravity in the body frame.\n\t// Note: The desired acceleration due to gravity in the body frame is the acceleration due to gravity in the world frame multiplied by the rotation matrix.\n\t// Note: The acceleration due to gravity in the world frame is the acceleration due to gravity in the earth frame multiplied by the rotation matrix.\n\t// Note: The acceleration due to gravity in the earth frame is the acceleration due to gravity in the earth frame multiplied by the rotation matrix.\n\t// Note: The rotation matrix is the transpose of the inverse of the rotation matrix.\n\t// Note: The inverse of the rotation matrix is the transpose of the rotation matrix.\n\t// Note: The rotation matrix is the transpose of the rotation matrix.\n\t// Note: The rotation matrix is the transpose of the rotation matrix.\n\tEigen::Vector3d desired_acceleration = (thrust_reference_ / mass_) + Eigen::Vector3d(0.0, 0.0, -9.", "CodeBleu_score": 20.68180024936534}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Ensure the input is valid.\n\tif (rotor_velocities == nullptr) {\n\t\tthrow std::invalid_argument(\"rotor_velocities cannot be null.\");\n\t}\n\n\t// Ensure the number of rotors is correct.\n\tif (rotor_velocities->size()!= rotor_count_) {\n\t\tthrow std::invalid_argument(\"rotor_velocities size is not equal to rotor_count.\");\n\t}\n\n\t// Calculate the desired angular acceleration.\n\tEigen::Vector3d angular_acceleration = CalculateDesiredAngularAcceleration();\n\n\t// Calculate the desired thrust.\n\tdouble desired_thrust = CalculateDesiredThrust();\n\n\t// Combine the desired angular acceleration and thrust into a single vector.\n\tEigen::VectorXd desired_acceleration = Eigen::VectorXd::Zero(rotor_count_);\n\tdesired_acceleration << angular_acceleration, desired_thrust;\n\n\t// Calculate the rotor velocities.\n\t*rotor_velocities = rotor_matrix_ * desired_acceleration;\n\n\t// Ensure the rotor velocities are at least one.\n\tfor (int i = 0; i < rotor_count_; i++) {\n\t\tif (rotor_velocities->coeff(i) < 1.0) {\n\t\t\trotor_velocities->coeffRef(i) = 1.0;\n\t\t}\n\t}\n\n\t// Take the square root of each rotor velocity.\n\tfor (int i = 0; i < rotor_count_; i++) {\n\t\trotor_velocities->coeffRef(i) = sqrt(rotor_velocities->coeff(i));\n\t}\n}", "CodeBleu_score": 45.55466429590346}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # Create a deep copy of the object\n    bag = copy.deepcopy(self)\n\n    # Find the start and end indices for the data\n    start_index = 0\n    end_index = 0\n    for i in range(len(self.times)):\n        if self.times[i] > start_time:\n            start_index = i\n            break\n    for i in range(len(self.times)):\n        if self.times[i] > end_time:\n            end_index = i\n            break\n\n    # Slice the data\n    bag.times = bag.times[start_index:end_index]\n    bag.topics = bag.topics[start_index:end_index]\n    bag.data = bag.data[start_index:end_index]\n\n    return bag\n\n", "CodeBleu_score": 32.8179244397106}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    sliced_bag = copy.deepcopy(self)\n    sliced_bag.topics = self.topics[start_index:end_index]\n    sliced_bag.times = self.times[start_index:end_index]\n    sliced_bag.msg_types = self.msg_types[start_index:end_index]\n    sliced_bag.msg_data = self.msg_data[start_index:end_index]\n    return sliced_bag\n\n", "CodeBleu_score": 22.336196870867052}, {"code": "def slice(self, start_time, end_time)\n\t\n    #create a copy of the object\n    sliced_bag = copy.deepcopy(self)\n    #find the indices for the start and end times\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    #slice the data\n    for key in sliced_bag.data.keys():\n        sliced_bag.data[key] = sliced_bag.data[key][start_index:end_index]\n    #return the sliced object\n    return sliced_bag\n\n", "CodeBleu_score": 36.90943770164939}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation\n    position = waypoint_msg.pose.position\n    orientation = waypoint_msg.pose.orientation\n\n    # Convert the rotation to Euler angles\n    rotation = tf.transformations.euler_from_quaternion((orientation.x, orientation.y, orientation.z, orientation.w))\n\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the current waypoint is different from the last one\n    if len(self.waypoints) > 0:\n        if (point.x == self.waypoints[-1].x) and (point.y == self.waypoints[-1].y) and (rotation[2] == self.yaw[-1]):\n            # If the current waypoint is the same as the last one, do not append it\n            return\n        else:\n            # If the current waypoint is different from the last one, append it\n            self.waypoints.append(point)\n            self.yaw.append(rotation[2])\n            self.times.append(msg_time)\n            self.bag_times.append(bag_time)\n            return\n    else:\n        # If there are no waypoints yet, append the first one\n        self.waypoints.append(point)\n        self.yaw.append(rotation[2])\n        self.times.append(msg_time)\n        self.bag_times.append(bag_time)\n        return\n\n", "CodeBleu_score": 31.07324782597952}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # append position\n    self.x.append(waypoint_msg.pose.position.x)\n    self.y.append(waypoint_msg.pose.position.y)\n    self.z.append(waypoint_msg.pose.position.z)\n    # append yaw\n    self.yaw.append(waypoint_msg.pose.orientation.z)\n    # append time\n    self.time.append(msg_time)\n    # append time since last waypoint\n    self.time_since_last_waypoint.append(msg_time - bag_time)\n    # append point\n    self.points.append(Point(waypoint_msg.pose.position.x,\n                             waypoint_msg.pose.position.y,\n                             waypoint_msg.pose.position.z))\n    # append yaw\n    self.yaw.append(tf.transformations.euler_from_quaternion([waypoint_msg.pose.orientation.x,\n                                                               waypoint_msg.pose.orientation.y,\n                                                               waypoint_msg.pose.orientation.z,\n                                                               waypoint_msg.pose.orientation.w])[2])\n    # append yaw_rate\n    self.yaw_rate.append(waypoint_msg.twist.angular.z)\n    # append yaw_rate_derivative\n    self.yaw_rate_derivative.append(waypoint_msg.twist.angular.z)\n    # append yaw_rate_derivative_derivative\n    self.yaw_rate_derivative_derivative.append(waypoint_msg.twist.angular.z)\n    # append yaw_rate_derivative_derivative_derivative\n    self.yaw_rate_derivative_derivative_derivative.append(waypoint_msg.twist.angular.z)\n    # append yaw_rate_derivative_derivative_derivative_derivative\n    self.yaw_rate_derivative_derivative_derivative_derivative.append(waypoint_msg.twist.angular.z)\n    # append yaw_rate_derivative_derivative_derivative_derivative_derivative\n    self.yaw_rate_derivative_derivative_derivative_derivative_derivative.append(waypoint_msg.twist.angular.z)\n    # append yaw_rate_derivative_derivative_derivative_derivative_derivative_derivative\n    self.yaw", "CodeBleu_score": 20.167587541169127}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Get the position and rotation of the waypoint\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert the rotation to Euler angles\n    roll, pitch, yaw = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object from the position\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the waypoint is different from the last one\n    if self.last_point is None or self.last_point.x!= point.x or self.last_point.y!= point.y or self.last_point.z!= point.z or self.last_yaw!= yaw:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.points.append(point)\n        self.yaws.append(yaw)\n        self.times.append(msg_time)\n\n        # Update the last point and yaw\n        self.last_point = copy.deepcopy(point)\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 26.927896450679228}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_accel_x.append(msg.linear_acceleration.x)\n        self.imu_accel_y.append(msg.linear_acceleration.y)\n        self.imu_accel_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs / 1000000000)\n        self.imu_bag_time.append(bag_time)\n\n", "CodeBleu_score": 31.86161667668639}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_ax.append(msg.linear_acceleration.x)\n        self.imu_ay.append(msg.linear_acceleration.y)\n        self.imu_az.append(msg.linear_acceleration.z)\n    return\n", "CodeBleu_score": 31.569746016637996}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_x.append(msg.linear_acceleration.x)\n        self.imu_y.append(msg.linear_acceleration.y)\n        self.imu_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.00115352694098}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create the figure with a title and a subplot for accelerations.\n    fig = pyplot.figure(figsize=(12, 6))\n    fig.suptitle('Accelerations')\n    ax = fig.add_subplot(111)\n    # For each acceleration dataset, plot the x, y, and z components over time with different colors and labels.\n    for i, dataset in enumerate(self.acceleration_datasets):\n        ax.plot(dataset.times, dataset.accelerations[:, 0], color=self.colors[i], label='x')\n        ax.plot(dataset.times, dataset.accelerations[:, 1], color=self.colors[i], label='y')\n        ax.plot(dataset.times, dataset.accelerations[:, 2], color=self.colors[i], label='z')\n    # Add labels for the x and y axes and include a legend.\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    ax.legend()\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file.\n    if self.save_plots:\n        if plot_suffix is not None:\n            filename = 'accelerations_' + plot_suffix + '.png'\n        else:\n            filename = 'accelerations.png'\n        fig.savefig(os.path.join(self.output_dir, filename))\n    # Close the figure.\n    pyplot.close(fig)\n\n", "CodeBleu_score": 45.16830682399119}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title and a subplot for accelerations\n    fig, ax = pyplot.subplots(figsize=(10, 7))\n    fig.suptitle(\"Acceleration Data\")\n\n    # For each acceleration dataset, plot the x, y, and z components over time with different colors and labels\n    for i, dataset in enumerate(self.accelerations):\n        ax.plot(dataset.time, dataset.linear_acceleration.x, label=\"x component\", color=\"blue\")\n        ax.plot(dataset.time, dataset.linear_acceleration.y, label=\"y component\", color=\"red\")\n        ax.plot(dataset.time, dataset.linear_acceleration.z, label=\"z component\", color=\"green\")\n\n    # Add labels for the x and y axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n    # Include a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = \"accelerations\"\n        if plot_suffix:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 39.01656417618208}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure(figsize=(10, 7))\n    fig.suptitle('Accelerations')\n    ax = fig.add_subplot(111)\n\n    # Plot the x, y, and z components of each acceleration dataset\n    for dataset in self.accelerations:\n        ax.plot(dataset.times, dataset.accelerations[:, 0], label='x')\n        ax.plot(dataset.times, dataset.accelerations[:, 1], label='y')\n        ax.plot(dataset.times, dataset.accelerations[:, 2], label='z')\n\n    # Add labels for the x and y axes\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Include a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = 'accelerations'\n        if plot_suffix:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        fig.savefig(filename)\n\n", "CodeBleu_score": 40.40502563297593}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 23.996715908025767}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 26.791720103491347}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: compare_positions requires at least two pose indices.\")\n        return\n    for i in range(len(pose_indeces)):\n        if i < len(pose_indeces) - 1:\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[i + 1])\n\n", "CodeBleu_score": 33.4551973168975}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for i in range(len(self.wrench)):\n        if start_time is None:\n            start_time = self.wrench[i].header.stamp.to_sec()\n        if end_time is None:\n            end_time = self.wrench[i].header.stamp.to_sec()\n        if start_time < self.wrench[i].header.stamp.to_sec() < end_time:\n            collision_times.append(self.wrench[i].header.stamp.to_sec())\n    return collision_times\n\n", "CodeBleu_score": 35.14260244808395}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is None:\n            start_time = collision.header.stamp.secs + collision.header.stamp.nsecs * 1e-9\n        if end_time is None:\n            end_time = self.wrench[-1].header.stamp.secs + self.wrench[-1].header.stamp.nsecs * 1e-9\n        if collision.header.stamp.secs + collision.header.stamp.nsecs * 1e-9 >= start_time and collision.header.stamp.secs + collision.header.stamp.nsecs * 1e-9 <= end_time:\n            collision_times.append(collision.header.stamp.secs + collision.header.stamp.nsecs * 1e-9)\n    return collision_times\n\n", "CodeBleu_score": 32.851214261445904}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for i in range(len(self.wrench)):\n        if start_time <= self.wrench[i].header.stamp <= end_time:\n            collision_times.append(self.wrench[i].header.stamp)\n    return collision_times\n\n", "CodeBleu_score": 35.56898693353516}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(analyze_bag, start_time, end_time,\n                                        settling_time, x_range, plot_suffix,\n                                        y_range=(-1.5, 1.5))\n\n", "CodeBleu_score": 38.69823702246617}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = settling_time + start_time\n    analyze_bag.plot_angular_velocities(analyze_bag, start_time, end_time,\n                                        settling_time, x_range, plot_suffix,\n                                        [-1.5, 1.5])\n\n", "CodeBleu_score": 42.068293549606615}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(analyze_bag, start_time, end_time,\n                                        settling_time, x_range, plot_suffix,\n                                        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 41.32841665995927}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\tif (data == NULL) {\n\t\treturn;\n\t}\n\n\t// Calculate the multiplier.\n\tfloat multiplier = (float) (width * height) / (float) (width * height);\n\n\t// Map the data to an Eigen vector.\n\tEigen::Map<Eigen::VectorXf> depth_vector(data, width * height);\n\n\t// Calculate the RMS noise.\n\tfloat rms_noise = sqrt(multiplier * noise_variance_);\n\n\t// Calculate the noise values.\n\tfloat noise_value = sqrt(multiplier * noise_variance_) * noise_std_dev_;\n\n\t// Apply the noise to the depth data.\n\tfor (int i = 0; i < width * height; i++) {\n\t\tif (depth_vector(i) < bad_point_threshold_) {\n\t\t\tdepth_vector(i) += (float) (rand() % 1000) / 1000 * noise_value;\n\t\t} else {\n\t\t\tdepth_vector(i) = bad_point_value_;\n\t\t}\n\t}\n}", "CodeBleu_score": 50.20961854724179}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\tif (!data) {\n\t\treturn;\n\t}\n\t// Calculate multiplier based on camera parameters\n\tfloat multiplier = 1.0f / (std::max(depth_noise_mean_, 0.0001f) * std::max(depth_noise_stddev_, 0.0001f));\n\t// Map the data to an Eigen vector\n\tEigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n\t// Compute the RMS noise\n\tfloat rms_noise = std::sqrt(depth_noise_variance_);\n\t// Compute the noise values\n\tEigen::VectorXf noise_values = Eigen::VectorXf::Random(width * height) * rms_noise;\n\t// Add noise if the pixel value is in range, otherwise set the pixel to a bad point value\n\tdepth_data += noise_values * multiplier;\n\tdepth_data = depth_data.cwiseMax(0.0f);\n\tdepth_data = depth_data.cwiseMin(1.0f);\n}", "CodeBleu_score": 36.99776850302212}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\tif (data == NULL) {\n\t\treturn;\n\t}\n\n\tconst float multiplier = 1.0 / (focal_length_ * baseline_);\n\n\tEigen::Map<Eigen::VectorXf> data_vector(data, width * height);\n\n\tconst float rms = std::sqrt(noise_variance_);\n\n\tconst float noise_value = static_cast<float>(std::sqrt(noise_variance_) * multiplier);\n\n\tconst float bad_point_value = std::numeric_limits<float>::quiet_NaN();\n\n\tfor (size_t i = 0; i < width * height; ++i) {\n\t\tif (data_vector[i] > min_range_ && data_vector[i] < max_range_) {\n\t\t\tdata_vector[i] += static_cast<float>(std::rand() * noise_value / RAND_MAX);\n\t\t} else {\n\t\t\tdata_vector[i] = bad_point_value;\n\t\t}\n\t}\n}", "CodeBleu_score": 48.5595422951032}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Convert Gazebo time to ROS time\n\tros::Time time = ros::Time(trajectory_msg->header.stamp.sec, trajectory_msg->header.stamp.nsec);\n\t// Write the message to the bag file\n\tbag_.write(trajectory_msg->header.frame_id + \"/trajectory\", time, trajectory_msg);\n}", "CodeBleu_score": 36.19073378424121}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time\n\tdouble current_time = world_->GetSimTime().Double();\n\t// Convert the current simulation time to ROS time\n\tros::Time ros_time = ros::Time::now();\n\n\t// Write the trajectory message to the bag file\n\tbag_.write(trajectory_msg->header.frame_id, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 39.39620762849711}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t//  ROS_INFO(\"Received trajectory message\");\n  // Get current simulation time\n  gazebo::common::Time current_time = world_->GetSimTime();\n  // Convert to ROS time\n  ros::Time ros_time = ros::Time(current_time.sec, current_time.nsec);\n  // Write to bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, trajectory_msg);\n}", "CodeBleu_score": 65.9215373640617}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time ros_time = common::Time::ToRos(now);\n\n\tmav_msgs::Actuators actuators;\n\tactuators.header.stamp = ros_time;\n\tactuators.header.frame_id = \"world\";\n\n\tfor (auto motor : this->motors) {\n\t\t// Calculate the slowed-down rotational velocity of the motor\n\t\tdouble rotational_velocity = motor->GetVelocity(0) / this->slowdown_factor;\n\n\t\t// Assign the slowed-down rotational velocity to the message\n\t\tactuators.angular_velocities.push_back(rotational_velocity);\n\t}\n\n\t// Write the message to the bag file\n\tthis->actuators_bag.write(this->motor_topic, ros_time, actuators);\n}", "CodeBleu_score": 32.57534065854557}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert simulation time to ROS time\n\tros::Time ros_time(now.sec, now.nsec);\n\t// Prepare message\n\tmav_msgs::Actuators msg;\n\tmsg.header.stamp = ros_time;\n\tmsg.header.frame_id = \"base_link\";\n\tmsg.angular_velocities.resize(motor_joints_.size());\n\t// Iterate through motor joints\n\tfor (unsigned int i = 0; i < motor_joints_.size(); i++) {\n\t\t// Get motor joint\n\t\tphysics::JointPtr motor_joint = motor_joints_[i];\n\t\t// Get motor joint name\n\t\tstd::string motor_joint_name = motor_joint->GetName();\n\t\t// Get motor joint rotational velocity\n\t\tdouble motor_joint_rotational_velocity = motor_joint->GetVelocity(0);\n\t\t// Get motor joint rotational velocity multiplier\n\t\tdouble motor_joint_rotational_velocity_multiplier = motor_joint_rotational_velocity_multipliers_[motor_joint_name];\n\t\t// Get motor joint rotational velocity slowdown factor\n\t\tdouble motor_joint_rotational_velocity_slowdown_factor = motor_joint_rotational_velocity_slowdown_factors_[motor_joint_name];\n\t\t// Calculate slowed-down rotational velocity\n\t\tdouble motor_joint_rotational_velocity_slowdown = motor_joint_rotational_velocity_multiplier * motor_joint_rotational_velocity_slowdown_factor;\n\t\t// Assign slowed-down rotational velocity to message\n\t\tmsg.angular_velocities[i] = motor_joint_rotational_velocity_slowdown;\n\t}\n\t// Write message to bag file\n\tbag_.write(motor_topic_, ros_time, msg);\n}", "CodeBleu_score": 48.02547492614948}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tif (now > last_log_time_ + log_period_) {\n\t\tlast_log_time_ = now;\n\t\tdouble time = now.Double();\n\t\tros::Time ros_time(time);\n\t\tros::Time ros_time_now(now.sec, now.nsec);\n\t\tros::Time ros_time_last(last_log_time_.sec, last_log_time_.nsec);\n\n\t\t//ROS_INFO(\"time: %f, ros_time: %f, ros_time_now: %f, ros_time_last: %f\", time, ros_time.toSec(), ros_time_now.toSec(), ros_time_last.toSec());\n\n\t\t// Prepare message\n\t\tmav_msgs::Actuators msg;\n\t\tmsg.header.stamp = ros_time;\n\t\tmsg.header.frame_id = \"rotors_gazebo_bag_plugin\";\n\n\t\t// Iterate through the motor joints\n\t\tfor (unsigned int i = 0; i < motor_joints_.size(); i++) {\n\t\t\t// Calculate slowed-down rotational velocity\n\t\t\tdouble rotational_velocity = motor_joints_[i]->GetVelocity(0);\n\t\t\tdouble slowed_down_rotational_velocity = rotational_velocity * slow_down_factor_;\n\n\t\t\t// Assign slowed-down rotational velocity to the message\n\t\t\tmsg.angular_velocities[i] = slowed_down_rotational_velocity;\n\t\t}\n\n\t\t// Write message to bag file\n\t\tbag_file_.write(motor_topic_name_, ros_time_now, msg);\n\t}\n}", "CodeBleu_score": 45.304723627687096}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t//  if (debug_printing_enabled_) {\n//    gzerr << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called.\n\";\n//  }\n\n  // Get the normalized roll, pitch, and yaw rate values from the roll_pitch_yawrate_thrust_msg.\n  double roll_normalized = roll_pitch_yawrate_thrust_msg->roll();\n  double pitch_normalized = roll_pitch_yawrate_thrust_msg->pitch();\n  double yaw_rate_normalized = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double thrust_normalized = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Convert the normalized roll, pitch, and yaw rate values to control surface angles for ailerons, elevator, and rudder respectively.\n  double aileron_angle = roll_normalized * aileron_max_angle_;\n  double elevator_angle = pitch_normalized * elevator_max_angle_;\n  double rudder_angle = yaw_rate_normalized * rudder_max_angle_;\n\n  // Set the throttle value from the thrust message.\n  double throttle = thrust_normalized * max_throttle_;\n\n  // Set the control surface angles for ailerons, elevator, and rudder.\n  SetControlSurfaceAngle(aileron_angle, elevator_angle, rudder_angle);\n\n  // Set the throttle.\n  SetThrottle(throttle);\n}", "CodeBleu_score": 41.5196294488909}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\t// If debug printing is enabled, log that the callback was called.\n\tif (debug_printing_enabled_) {\n\t\tROS_DEBUG_NAMED(\"gazebo_fw_dynamics_plugin\", \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called\");\n\t}\n\t// Convert roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder.\n\tdouble roll_angle = roll_pitch_yawrate_thrust_msg->roll() * roll_pitch_yawrate_thrust_msg->max_roll_angle();\n\tdouble pitch_angle = roll_pitch_yawrate_thrust_msg->pitch() * roll_pitch_yawrate_thrust_msg->max_pitch_angle();\n\tdouble yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate() * roll_pitch_yawrate_thrust_msg->max_yaw_rate();\n\tdouble throttle = roll_pitch_yawrate_thrust_msg->thrust() * roll_pitch_yawrate_thrust_msg->max_throttle();\n\t// Set the control surface angles.\n\tSetControlSurfaceAngle(aileron_left_, roll_angle);\n\tSetControlSurfaceAngle(aileron_right_, roll_angle);\n\tSetControlSurfaceAngle(elevator_, pitch_angle);\n\tSetControlSurfaceAngle(rudder_, yaw_rate);\n\t// Set the throttle.\n\tSetThrottle(throttle);\n}", "CodeBleu_score": 42.56654236114492}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\t// If debug printing is enabled, log that the callback was called.\n\tif (debug_printing_enabled_) {\n\t\tROS_INFO(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called\");\n\t}\n\n\t// Convert the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n\tdouble roll_angle = roll_pitch_yawrate_thrust_msg->roll() * control_surface_angle_max_;\n\tdouble pitch_angle = roll_pitch_yawrate_thrust_msg->pitch() * control_surface_angle_max_;\n\tdouble yaw_rate = roll_pitch_yawrate_thrust_msg->yawrate() * control_surface_angle_max_;\n\tdouble throttle = roll_pitch_yawrate_thrust_msg->thrust() * control_surface_angle_max_;\n\n\t// Set the throttle value from the thrust message.\n\tthrottle_ = throttle;\n\n\t// Set the control surface angles for ailerons, elevator, and rudder.\n\tailerons_angle_ = roll_angle;\n\televator_angle_ = pitch_angle;\n\trudder_angle_ = yaw_rate;\n}", "CodeBleu_score": 43.98397874925093}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t\n//    if (_dt > 0.0) {\n//        // Poll for new data\n//        fd_set fds;\n//        FD_ZERO(&fds);\n//        FD_SET(_serialFd, &fds);\n//        struct timeval timeout;\n//        timeout.tv_sec = _timeoutMs / 1000;\n//        timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n//        int rc = select(_serialFd + 1, &fds, NULL, NULL, &timeout);\n//        if (rc == -1) {\n//            gzerr << \"select failed: \" << strerror(errno) << \"\n\";\n//        } else if (rc > 0) {\n//            // Read the data\n//            unsigned char buffer[1024];\n//            int n = read(_serialFd, buffer, sizeof(buffer));\n//            if (n > 0) {\n//                // Parse the data\n//                mavlink_message_t msg;\n//                for (int i = 0; i < n; i++) {\n//                    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg,\n//                                           NULL)) {\n//                        handleMessage(msg);\n//                    }\n//                }\n//            }\n//        }\n//    }\n}", "CodeBleu_score": 1.4726803394282788}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t//  gazebo::common::Time _dt = gazebo::common::Time::GetWallTime() - this->lastPollTime;\n  this->lastPollTime = gazebo::common::Time::GetWallTime();\n\n  // Check if the timeout is not 0.\n  if (_timeoutMs == 0) {\n    return;\n  }\n\n  // Convert the timeout to a timeval structure.\n  timeval _timeout;\n  _timeout.tv_sec = _timeoutMs / 1000;\n  _timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Create a set of file descriptors to be polled.\n  fd_set _fds;\n  FD_ZERO(&_fds);\n  FD_SET(this->mavlinkInterface->getFd(), &_fds);\n  FD_SET(this->serialInterface->getFd(), &_fds);\n\n  // Perform the poll operation.\n  int _pollResult = select(std::max(this->mavlinkInterface->getFd(),\n                                    this->serialInterface->getFd()) + 1, &_fds,\n                           NULL, NULL, &_timeout);\n\n  // Check the result of the poll operation.\n  if (_pollResult == -1) {\n    gzerr << \"Error: poll failed\n\";\n    return;\n  } else if (_pollResult == 0) {\n    // No data available.\n    return;\n  }\n\n  // Handle incoming data.\n  if (FD_ISSET(this->mavlinkInterface->getFd(), &_fds)) {\n    // Receive MAVLink messages from the MAVLink interface.\n    this->mavlinkInterface->receiveMessages();\n  }\n\n  if (FD_ISSET(this->serialInterface->getFd(), &_fds)) {\n    // Receive MAVLink messages from the serial interface.\n    this->serialInterface->receiveMessages();\n  }\n\n  // Handle outgoing data.\n  if (this->mavlinkInterface->hasMessagesToTransmit()) {\n    // Send MAVLink messages to the MAVLink interface.\n    this->mavlinkInterface->sendMessages();\n  }\n\n  if (this->serialInterface->hasMessagesToTransmit()) {\n    // Send MAVLink messages to the serial interface.\n    this->serialInterface->sendMessages();\n  }\n}", "CodeBleu_score": 36.23616223427092}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#ifdef __linux__\n  // Convert timeout to timeval structure.\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for MAVLink messages.\n  int nfds = 1;\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(serialFd_, &readfds);\n  int ret = select(nfds, &readfds, NULL, NULL, &timeout);\n\n  // If data is available, read it and parse MAVLink messages.\n  if (ret > 0) {\n    if (FD_ISSET(serialFd_, &readfds)) {\n      char buf[1024];\n      int len = read(serialFd_, buf, 1024);\n      if (len > 0) {\n        for (int i = 0; i < len; i++) {\n          parseMAVLinkMessage(buf[i]);\n        }\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 50.30881710277115}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tif(this->isOpen) {\n\t\tthis->isOpen = false;\n\t\tthis->ioService.stop();\n\t\tthis->serial.close();\n\t\tif(this->ioThread.joinable()) {\n\t\t\tthis->ioThread.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 28.077813881909115}, {"code": "void GazeboMavlinkInterface::close() {\n\t\t// Lock mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(this->mutex);\n\n\t// Check if the interface is open\n\tif (this->isOpen) {\n\t\t// Stop the I/O service\n\t\tthis->ioService.stop();\n\n\t\t// Close the serial device\n\t\tthis->serialDevice->close();\n\n\t\t// Check if the I/O thread is joinable\n\t\tif (this->ioThread.joinable()) {\n\t\t\t// Join the I/O thread to clean up resources\n\t\t\tthis->ioThread.join();\n\t\t}\n\n\t\t// Set the interface as closed\n\t\tthis->isOpen = false;\n\t}\n}", "CodeBleu_score": 28.2599434073865}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (open) {\n\t\tio_service->stop();\n\t\tserial_port->close();\n\t\tif (io_service->joinable()) {\n\t\t\tio_service->join();\n\t\t}\n\t\topen = false;\n\t}\n}", "CodeBleu_score": 54.14765901878326}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tdouble x1, y1, z1, x2, y2, z2, x, y, z;\n\tx1 = x2 = y1 = y2 = z1 = z2 = x = y = z = 0;\n\tdouble x_inter, y_inter, z_inter;\n\tx_inter = y_inter = z_inter = 0;\n\tignition::math::Vector3d interpolated_vector;\n\tinterpolated_vector.Set(x_inter, y_inter, z_inter);\n\treturn interpolated_vector;\n}", "CodeBleu_score": 27.38330601410539}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d x1, x2, y1, y2, x, y;\n\tdouble x_value, y_value;\n\tx1 = ignition::math::Vector3d(0,0,0);\n\tx2 = ignition::math::Vector3d(0,0,0);\n\ty1 = ignition::math::Vector3d(0,0,0);\n\ty2 = ignition::math::Vector3d(0,0,0);\n\tx = ignition::math::Vector3d(0,0,0);\n\ty = ignition::math::Vector3d(0,0,0);\n\tx_value = 0;\n\ty_value = 0;\n\treturn x;\n}", "CodeBleu_score": 29.03507556996533}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d pos, pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8, pos9, pos10, pos11, pos12, pos13, pos14, pos15, pos16, pos17, pos18, pos19, pos20, pos21, pos22, pos23, pos24, pos25, pos26, pos27, pos28, pos29, pos30, pos31, pos32, pos33, pos34, pos35, pos36, pos37, pos38, pos39, pos40, pos41, pos42, pos43, pos44, pos45, pos46, pos47, pos48, pos49, pos50, pos51, pos52, pos53, pos54, pos55, pos56, pos57, pos58, pos59, pos60, pos61, pos62, pos63, pos64, pos65, pos66, pos67, pos68, pos69, pos70, pos71, pos72, pos73, pos74, pos75, pos76, pos77, pos78, pos79, pos80, pos81, pos82, pos83, pos84, pos85, pos86, pos87, pos88, pos89, pos90, pos91, pos92, pos93, pos94, pos95, pos96, pos97, pos98, pos99, pos100, pos101, pos102, pos103, pos104, pos105, pos106, pos107, pos108, pos109, pos110, pos111, pos112, pos113, pos114, pos115, pos116, pos117, pos118, pos119, pos120, pos121, pos122", "CodeBleu_score": 5.6624554375326195}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (this->looping) {\n\t\tif (_time > this->length) {\n\t\t\t_time = _time - this->length;\n\t\t} else if (_time < 0) {\n\t\t\t_time = _time + this->length;\n\t\t}\n\t} else {\n\t\t_time = std::min(this->length, std::max(0.0, _time));\n\t}\n\tif (this->time!= _time) {\n\t\tthis->time = _time;\n\t\tthis->Update();\n\t}\n}", "CodeBleu_score": 46.44398344010314}, {"code": "void Animation::SetTime(double _time){\n\t\tif (_time!= this->time) {\n\t\tthis->time = _time;\n\t\tthis->keyFrameIndex = 0;\n\t\tthis->keyFrameIndex = this->keyFrames.size() - 1;\n\t\tthis->Update();\n\t}\n}", "CodeBleu_score": 38.16827403264894}, {"code": "void Animation::SetTime(double _time){\n\t\tif (this->looping) {\n\t\t_time = fmod(_time, this->length);\n\t}\n\telse {\n\t\t_time = std::min(std::max(_time, 0.0), this->length);\n\t}\n\n\tif (_time!= this->time) {\n\t\tthis->time = _time;\n\t\tthis->Update();\n\t}\n}", "CodeBleu_score": 41.89074468769224}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n\n    self.local_pos_pub.publish(self.local_pos)\n    self.local_vel_pub.publish(self.local_vel)\n    self.local_att_pub.publish(self.local_att)\n    self.local_att_rate_pub.publish(self.local_att_rate)\n    self.local_pos_sp_pub.publish(self.local_pos_sp)\n    self.local_vel_sp_pub.publish(self.local_vel_sp)\n    self.local_att_sp_pub.publish(self.local_att_sp)\n    self.local_att_rate_sp_pub.publish(self.local_att_rate_sp)\n    self.local_pos_sp_pub.publish(self.local_pos_sp)\n    self.local_vel_sp_pub.publish(self.local_vel_sp)\n    self.local_att_sp_pub.publish(self.local_att_sp)\n    self.local_att_rate_sp_pub.publish(self.local_att_rate_sp)\n    self.local_pos_sp_pub.publish(self.local_pos_sp)\n    self.local_vel_sp_pub.publish(self.local_vel_sp)\n    self.local_att_sp_pub.publish(self.local_att_sp)\n    self.local_att_rate_sp_pub.publish(self.local_att_rate_sp)\n    self.local_pos_sp_pub.publish(self.local_pos_sp)\n    self.local_vel_sp_pub.publish(self.local_vel_sp)\n    self.local_att_sp_pub.publish(self.local_att_sp)\n    self.local_att_rate_sp_pub.publish(self.local_att_rate_sp)\n    self.local_pos_sp_pub.publish(self.local_pos_sp)\n    self.local_vel_sp_pub.publish(self.local_vel_sp)\n    self.local_att_sp_pub.publish(self.local_att_sp)\n    self.local_att_rate_sp_pub.publish(self.local_att_rate_sp)", "CodeBleu_score": 6.029421012996573}, {"code": "def hover(self)\n\t\n    self.local_setpoint.pose.position.x = 0\n    self.local_setpoint.pose.position.y = 0\n    self.local_setpoint.pose.position.z = 0\n    self.local_setpoint.pose.orientation.x = 0\n    self.local_setpoint.pose.orientation.y = 0\n    self.local_setpoint.pose.orientation.z = 0\n    self.local_setpoint.pose.orientation.w = 0\n    self.local_setpoint.type_mask = 0b0000111111000111\n    self.local_setpoint.coordinate_frame = 1\n    self.local_setpoint.velocity.x = 0\n    self.local_setpoint.velocity.y = 0\n    self.local_setpoint.velocity.z = 0\n    self.local_setpoint.acceleration_or_force.x = 0\n    self.local_setpoint.acceleration_or_force.y = 0\n    self.local_setpoint.acceleration_or_force.z = 0\n    self.local_setpoint.yaw = 0\n    self.local_setpoint.yaw_rate = 0\n    self.local_setpoint.thrust = 0\n    self.local_setpoint.type_mask = 0b0000111111000111\n    self.local_setpoint.coordinate_frame = 1\n    self.local_setpoint.velocity.x = 0\n    self.local_setpoint.velocity.y = 0\n    self.local_setpoint.velocity.z = 0\n    self.local_setpoint.acceleration_or_force.x = 0\n    self.local_setpoint.acceleration_or_force.y = 0\n    self.local_setpoint.acceleration_or_force.z = 0\n    self.local_setpoint.yaw = 0\n    self.local_setpoint.yaw_rate = 0\n    self.local_setpoint.thrust = 0\n    self.local_setpoint.type_mask = 0b0000111111000111\n    self.local_setpoint.coordinate", "CodeBleu_score": 17.529994721976884}, {"code": "def hover(self)\n\t\n    self.set_mode(0, 1)\n    self.set_mode(1, 0)\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 18.27234237702667}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    try:\n        if self.flight_mode == 'HOVER':\n            self.hover()\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            rospy.loginfo('Hover mode enabled.')\n            return True\n        else:\n            self.flight_mode_service(self.flight_mode)\n            rospy.loginfo('Mode switched to'+ self.flight_mode + '.')\n            return True\n    except rospy.ServiceException as e:\n        rospy.loginfo('Service call failed: %s' % e)\n        return False\n\n", "CodeBleu_score": 38.14365617264529}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            self.flight_mode = self.flightModeService.response.mode\n            rospy.loginfo('Mode changed to %s' % self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.loginfo('Service call failed: %s' % e)\n            return False\n\n", "CodeBleu_score": 55.13936958290371}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            rospy.loginfo('Switched to %s mode' % self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.logerr('Service call failed: %s' % e)\n            return False\n\n", "CodeBleu_score": 36.133095991046495}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if self.hover_flag == False and self.hold_flag == False:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if self.hover_flag == False and self.hold_flag == False and self.coordinate_frame == 0 and self.motion_type == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = PositionTarget()\n        self.target_motion.coordinate_frame = self.coordinate_frame\n        self.target_motion.header.stamp = rospy.Time.now()\n        self.target_motion.header.frame_id = 'enu'\n        self.target_motion.type_mask = 128\n        self.target_motion.velocity.x = msg.linear.x\n        self.target_motion.velocity.y = msg.linear.y\n        self.target_motion.velocity.z = msg.linear.z\n        self.target_motion.yaw = msg.angular.z\n\n", "CodeBleu_score": 35.77365722675019}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag == 0:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if self.hold_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion_construction(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n", "CodeBleu_score": 62.82367449496559}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if not self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z]\n\n", "CodeBleu_score": 63.304964607352}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    #if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02:\n        self.hover_flag = 0\n        self.set_mode('OFFBOARD')\n    elif self.hover_flag == 0 and self.current_state.mode!= 'HOVER':\n        self.hover_flag = 1\n        self.set_mode('HOVER')\n        self.hover(x, y, z)\n", "CodeBleu_score": 49.82811792779311}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode('OFFBOARD')\n    elif (self.hover_flag == 1 and self.flight_mode!= 'HOVER'):\n        self.hover_flag = 0\n        self.set_mode('HOVER')\n        self.hover_action()\n", "CodeBleu_score": 53.46757272096995}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n    elif self.hover_flag == 0 and self.mode!= \"HOVER\":\n        self.hover_flag = 1\n        self.set_mode(\"HOVER\")\n        self.hover()\n\n", "CodeBleu_score": 56.036658788473524}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        return q.yaw\n\n", "CodeBleu_score": 35.6773847240096}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[3], q[0], q[1], q[2]).yaw\n\n", "CodeBleu_score": 19.528210155997467}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    # Set the coordinate frame to body\n    self.set_frame(0)\n    # Set the motion type to hover\n    self.set_type_motion(0)\n    # Construct the target motion\n    self.set_target_motion(self.x, self.y, self.z, self.yaw)\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + self.vehicle_id)\n    print(\"Flight mode: HOVER\")\n", "CodeBleu_score": 21.127915116744763}, {"code": "def hover(self)\n\t\n    # Set the coordinate frame to the local frame\n    self.set_frame(self.local_frame)\n    # Set the motion type to position control\n    self.set_type_position()\n    # Construct a target motion\n    target_motion = self.construct_target_motion(self.current_pose.position.x, self.current_pose.position.y, self.current_pose.position.z, self.current_pose.orientation.z)\n    # Send the target motion to the vehicle\n    self.send_target_motion(target_motion)\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight mode: \" + self.flight_mode)\n", "CodeBleu_score": 25.512357378946525}, {"code": "def hover(self)\n\t\n    self.set_mode(\"OFFBOARD\")\n    self.set_frame(\"BODY_NED\")\n    self.set_type(\"POSITION_Z\")\n    self.set_position(self.x, self.y, self.z)\n    self.set_yaw(self.yaw)\n    self.set_velocity(0, 0, 0)\n    self.set_acceleration(0, 0, 0)\n    self.set_yaw_rate(0)\n    self.set_gains(self.roll_gains, self.pitch_gains, self.yaw_gains)\n    self.set_thrust(self.thrust)\n    self.set_heading(self.heading)\n    print(\"Vehicle type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight mode: \", self.flight_mode)\n", "CodeBleu_score": 19.833068236183408}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service(custom_mode=self.flight_mode)\n            rospy.loginfo('Switched flight mode to %s' % self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.logerr('Service call failed: %s' % e)\n            return False\n\n", "CodeBleu_score": 41.24891349494388}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            rospy.loginfo('Switched flight mode to'+ self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.logerr('Service call failed: %s' % e)\n            return False\n\n", "CodeBleu_score": 49.93466090584311}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            rospy.loginfo('Flight mode switched to'+ self.flight_mode)\n            return True\n        except rospy.ServiceException:\n            rospy.loginfo('Flight mode switch failed')\n            return False\n", "CodeBleu_score": 35.59293515396963}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n\n    self.get_total_reward()\n\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 51.633144163431034}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.id:\n        self.local_pose = msg\n    if self.gcs_command == 'takeoff':\n        self.takeoff_target_pose = msg\n    elif self.gcs_command == 'hover':\n        self.hover_target_pose = msg\n    self.global_pose.position.x = self.local_pose.pose.position.x + self.bias.x\n    self.global_pose.position.y = self.local_pose.pose.position.y + self.bias.y\n    self.global_pose.position.z = self.local_pose.pose.position.z + self.bias.z\n\n", "CodeBleu_score": 29.745103945217267}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == i:\n        self.local_pose = msg\n        if self.takeoff_target_pose is not None:\n            self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x + self.takeoff_target_pose.pose.position.x\n            self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y + self.takeoff_target_pose.pose.position.y\n            self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z + self.takeoff_target_pose.pose.position.z\n        if self.hover_target_pose is not None:\n            self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x + self.hover_target_pose.pose.position.x\n            self.hover_target_pose.pose.position.y = self.local_pose.pose.position.y + self.hover_target_pose.pose.position.y\n            self.hover_target_pose.pose.position.z = self.local_pose.pose.position.z + self.hover_target_pose.pose.position.z\n        self.global_pose.pose.position.x = self.local_pose.pose.position.x + self.global_pose.pose.position.x\n        self.global_pose.pose.position.y = self.local_pose.pose.position.y + self.global_pose.pose.position.y\n        self.global_pose.pose.position.z = self.local_pose.pose.position.z + self.global_pose.pose.position.z\n\n", "CodeBleu_score": 18.99302374447233}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.id:\n        self.local_pose = msg\n        if self.takeoff_target_pose is not None:\n            self.takeoff_target_pose.pose.position.x = msg.pose.position.x\n            self.takeoff_target_pose.pose.position.y = msg.pose.position.y\n            self.takeoff_target_pose.pose.position.z = msg.pose.position.z\n        if self.hover_target_pose is not None:\n            self.hover_target_pose.pose.position.x = msg.pose.position.x\n            self.hover_target_pose.pose.position.y = msg.pose.position.y\n            self.hover_target_pose.pose.position.z = msg.pose.position.z\n        self.global_pose.pose.position.x = msg.pose.position.x + self.bias.x\n        self.global_pose.pose.position.y = msg.pose.position.y + self.bias.y\n        self.global_pose.pose.position.z = msg.pose.position.z + self.bias.z\n\n", "CodeBleu_score": 20.86903151082421}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.862379601652705}, {"code": "def takeoff_detection(self)\n\t\n    if self.arm_state == 'active' and self.altitude > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 60.617887392028216}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_position.pose.position.z > 0.2 and self.arm_state == 'armed':\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 65.20089804104086}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the distance between UAVs in the original formation\n    orig_formation_dist = numpy.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            orig_formation_dist[i][j] = numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(orig_formation[j]))\n\n    # Calculate the distance between UAVs in the changed formation\n    change_formation_dist = numpy.zeros((len(change_formation), len(change_formation)))\n    for i in range(len(change_formation)):\n        for j in range(len(change_formation)):\n            change_formation_dist[i][j] = numpy.linalg.norm(numpy.array(change_formation[i]) - numpy.array(change_formation[j]))\n\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    orig_formation_dist = numpy.subtract(orig_formation_dist, 50)\n    orig_formation_dist = numpy.rint(orig_formation_dist)\n    change_formation_dist = numpy.subtract(change_formation_dist, 50)\n    change_formation_dist = numpy.rint(change_formation_dist)\n\n    # Return the distance matrix\n    return orig_formation_dist, change_formation_dist\n", "CodeBleu_score": 22.39581144473534}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the distances between all UAVs in the original formation\n    dist_matrix = numpy.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            dist_matrix[i, j] = numpy.linalg.norm(\n                numpy.array(orig_formation[i]) - numpy.array(orig_formation[j]))\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    dist_matrix = numpy.subtract(dist_matrix, 50)\n    dist_matrix = dist_matrix.astype(int)\n    return dist_matrix\n\n", "CodeBleu_score": 23.885004221759775}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # create a matrix to store the distances\n    dist_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    # calculate the distances between the UAVs in the original and changed formations\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = numpy.linalg.norm(\n                numpy.array(orig_formation[i]) - numpy.array(change_formation[j]))\n    # adjust the distances by subtracting them from 50 and converting to integers\n    dist_matrix = 50 - dist_matrix\n    dist_matrix = dist_matrix.astype(int)\n    return dist_matrix\n\n", "CodeBleu_score": 27.319583967864546}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    if i in self.left_visited:\n        return False\n    self.left_visited.add(i)\n    for j in self.graph[i]:\n        if j in self.right_visited:\n            continue\n        if self.match[j] == -1 or self.find_path(self.match[j]):\n            self.match[j] = i\n            self.match[i] = j\n            return True\n    self.right_visited.add(i)\n    return False\n", "CodeBleu_score": 29.65447014387848}, {"code": "def find_path(self, i)\n\t\n    global visited_left, visited_right, match, match_weight, slack, label, parent, left_vertices, right_vertices, left_edges, right_edges\n    visited_left[i] = True\n    for j in range(len(right_vertices)):\n        if visited_right[j] == False:\n            if match[j] == -1 or find_path(self, match[j]):\n                match[j] = i\n                return True\n    return False\n\n", "CodeBleu_score": 20.424421341839576}, {"code": "def find_path(self, i)\n\t\n    self.left_visited[i] = True\n    for j in range(self.num_right_nodes):\n        if self.right_visited[j]:\n            continue\n        if self.right_labels[j] == self.left_labels[i] + self.match_weights[i][j]:\n            self.right_visited[j] = True\n            if self.right_matches[j] == -1 or find_path(self, self.right_matches[j]):\n                self.right_matches[j] = i\n                self.left_matches[i] = j\n                return True\n    for j in range(self.num_right_nodes):\n        if self.right_visited[j]:\n            continue\n        if self.right_labels[j] > 0:\n            self.right_labels[j] -= 1\n        else:\n            self.right_labels[j] += self.slack[j]\n            self.slack[j] += 1\n    return False\n", "CodeBleu_score": 35.960225245382425}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    UAVs = self.UAVs\n    UAVs_num = self.UAVs_num\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAVs_num)\n    # print(\"UAVs\",UAVs)\n    # print(\"UAVs_num\",UAV", "CodeBleu_score": 0.31917129396030564}, {"code": "def KM(self)\n\t\n    #initialize slack variables\n    slack = numpy.zeros(self.UAVs)\n    slack_row = numpy.zeros(self.UAVs)\n    slack_col = numpy.zeros(self.UAVs)\n    #initialize visit arrays\n    visit_row = numpy.zeros(self.UAVs)\n    visit_col = numpy.zeros(self.UAVs)\n    #initialize path\n    path = numpy.zeros(self.UAVs)\n    #initialize match\n    match = numpy.zeros(self.UAVs)\n    #initialize unmatched\n    unmatched = numpy.ones(self.UAVs)\n    #initialize row_covered\n    row_covered = numpy.zeros(self.UAVs)\n    #initialize col_covered\n    col_covered = numpy.zeros(self.UAVs)\n    #initialize count\n    count = 0\n    #initialize match_count\n    match_count = 0\n    #initialize match_results\n    match_results = numpy.zeros(self.UAVs)\n    #initialize min_slack\n    min_slack = 0\n    #initialize min_slack_row\n    min_slack_row = 0\n    #initialize min_slack_col\n    min_slack_col = 0\n    #initialize row_min_slack\n    row_min_slack = 0\n    #initialize col_min_slack\n    col_min_slack = 0\n    #initialize row_min_slack_index\n    row_min_slack_index = 0\n    #initialize col_min_slack_index\n    col_min_slack_index = 0\n    #initialize row_min_slack_value\n    row_min_slack_value = 0\n    #initialize col_min_slack_value\n    col_min_slack_value = 0\n    #initialize row_index\n    row_index = 0\n    #initialize col_index\n    col_index = 0\n    #initialize row_value\n    row_value = 0\n    #initialize col_value\n    col_value = 0\n    #initialize row_index_value\n    row_index_value = 0\n    #initialize col_index_value\n    col_index_value = 0\n    #initialize row_min_slack_value_index\n    row_min_slack_value_index = 0\n    #initialize col_min_slack_value_index\n    col_", "CodeBleu_score": 10.64510988129988}, {"code": "def KM(self)\n\t\n    UAVs = self.UAVs\n    UAV_pos = self.UAV_pos\n    UAV_vel = self.UAV_vel\n    UAV_acc = self.UAV_acc\n    UAV_pos_est = self.UAV_pos_est\n    UAV_vel_est = self.UAV_vel_est\n    UAV_acc_est = self.UAV_acc_est\n    UAV_pos_est_prev = self.UAV_pos_est_prev\n    UAV_vel_est_prev = self.UAV_vel_est_prev\n    UAV_acc_est_prev = self.UAV_acc_est_prev\n    UAV_pos_est_prev_prev = self.UAV_pos_est_prev_prev\n    UAV_vel_est_prev_prev = self.UAV_vel_est_prev_prev\n    UAV_acc_est_prev_prev = self.UAV_acc_est_prev_prev\n    UAV_pos_est_prev_prev_prev = self.UAV_pos_est_prev_prev_prev\n    UAV_vel_est_prev_prev_prev = self.UAV_vel_est_prev_prev_prev\n    UAV_acc_est_prev_prev_prev = self.UAV_acc_est_prev_prev_prev\n    UAV_pos_est_prev_prev_prev_prev = self.UAV_pos_est_prev_prev_prev_prev\n    UAV_vel_est_prev_prev_prev_prev = self.UAV_vel_est_prev_prev_prev_prev\n    UAV_acc_est_prev_prev_prev_prev = self.UAV_acc_est_prev_prev_prev_prev\n    UAV_pos_est_prev_prev_prev_prev_prev = self.UAV_pos_est_prev_prev_prev_prev_prev\n    UAV_vel_est_prev_prev_prev_prev_prev = self.UAV_vel_est_prev_prev_prev_prev_prev\n    UAV_acc_est_prev_prev_prev_prev_prev = self.UAV_acc_est_prev_prev_prev_prev", "CodeBleu_score": 4.300239437120288}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t(TagDetector* tagDetector, int id, TagDescriptionContainer& descriptionContainer, bool printWarning) {\n\t\t// Check if the tag description is in the standalone tag descriptions map.\n\t\tauto it = tagDetector->standalone_tag_descriptions_.find(id);\n\t\tif (it!= tagDetector->standalone_tag_descriptions_.end()) {\n\t\t\t// Tag description found.\n\t\t\tdescriptionContainer = it->second;\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// Tag description not found.\n\t\t\tif (printWarning) {\n\t\t\t\t// Log warning message.\n\t\t\t\tROS_WARN_STREAM(\"Tag description not found for tag ID \" << id << \".\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}", "CodeBleu_score": 47.03730919263775}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t(const int& id, const bool& printWarning, TagDescriptionContainer& descriptionContainer)\n}", "CodeBleu_score": 0.8515126240404635}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t(const int id, const bool printWarning, TagDescriptionContainer &descriptionContainer)\n\t{\n\t\tif (standalone_tag_descriptions_.find(id)!= standalone_tag_descriptions_.end())\n\t\t{\n\t\t\tdescriptionContainer = standalone_tag_descriptions_.at(id);\n\t\t\treturn true;\n\t\t}\n\t\telse if (printWarning)\n\t\t{\n\t\t\tROS_WARN(\"TagDetector::findStandaloneTagDescription: Could not find standalone tag description for ID %d\", id);\n\t\t}\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 45.44767434161481}]}
