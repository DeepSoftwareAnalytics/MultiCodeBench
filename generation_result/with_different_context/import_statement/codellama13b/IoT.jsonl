{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\n\twhile (next_desc->bLength != 0) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc + next_desc->bLength);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 38.898758105734665}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *p = (uint8_t *) desc;\n\tuint8_t *p_end = (uint8_t *) desc + desc->wTotalLength;\n\n\twhile (p < p_end) {\n\t\tif (*p == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p;\n\t\t}\n\t\tp += *(p + 1);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.10245247171632}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc;\n\tuint8_t desc_length;\n\tuint8_t * desc_ptr;\n\n\tdesc_ptr = (uint8_t UDC_DESC_STORAGE *) desc;\n\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\n\twhile (next_desc->bDescriptorType != desc_id) {\n\t\tdesc_length = next_desc->bLength;\n\t\tdesc_ptr += desc_length;\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\n\t\tif (next_desc->bDescriptorType == USB_DESC_TYPE_CONFIGURATION) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn next_desc;\n}", "CodeBleu_score": 45.4631159532179}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (udc_config_desc == NULL) {\n\t\treturn false;\n\t}\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\tuint8_t *p = (uint8_t *) udc_config_desc;\n\tuint8_t *p_end = p + udc_config_desc->wTotalLength;\n\twhile (p < p_end) {\n\t\tif (*p == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *iface_desc = (struct usb_interface_descriptor *) p;\n\t\t\tif (iface_desc->bInterfaceNumber == iface_num) {\n\t\t\t\tif (iface_desc->bAlternateSetting == setting_num) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp += p[0];\n\t}\n\treturn false;\n}", "CodeBleu_score": 39.47074144418591}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (udc_config_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tuint8_t *p = (uint8_t *) udc_config_desc;\n\tuint8_t *end = p + udc_config_desc->wTotalLength;\n\n\twhile (p < end) {\n\t\tif (*p == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *iface_desc = (struct usb_interface_descriptor *) p;\n\t\t\tif (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tp += p[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 38.47743814493349}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t i;\n\tuint8_t iface_num_tmp;\n\tuint8_t setting_num_tmp;\n\tuint8_t iface_desc_len;\n\tuint8_t *iface_desc;\n\n\tif (udc_config_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num > udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tiface_desc = (uint8_t *) udc_config_desc;\n\tiface_desc += sizeof(struct usb_config_descriptor);\n\tfor (i = 0; i < udc_config_desc->bNumInterfaces; i++) {\n\t\tiface_num_tmp = iface_desc[2];\n\t\tsetting_num_tmp = iface_desc[3];\n\t\tiface_desc_len = iface_desc[0];\n\t\tif (iface_num_tmp == iface_num && setting_num_tmp == setting_num) {\n\t\t\treturn true;\n\t\t}\n\t\tiface_desc += iface_desc_len;\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.56599155047759}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t    uint8_t ep_num = udc_req_std_get_ep_num();\n    uint16_t ep_status = 0;\n    if (udc_req_std_get_length() != sizeof(ep_status)) {\n        return false;\n    }\n    if (udc_ep_is_halted(ep_num)) {\n        ep_status = 1;\n    }\n    udc_req_std_write(ep_status);\n    return true;\n}", "CodeBleu_score": 31.64442493008345}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t  if (udc_req_std_get_len() != sizeof(uint16_t)) {\n    return false;\n  }\n\n  uint16_t ep_status = 0;\n  uint8_t ep = udc_req_std_get_value();\n\n  if (udc_ep_is_halted(ep)) {\n    ep_status = 1;\n  }\n\n  udc_req_std_write(ep_status);\n  return true;\n}", "CodeBleu_score": 21.634844105743177}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    uint8_t ep_num = (uint8_t) (udc_req.wIndex & 0x0F);\n    uint8_t ep_dir = (uint8_t) (udc_req.wIndex & 0x80);\n    uint8_t ep_status = 0;\n\n    if (udc_req.wLength != 2) {\n        return false;\n    }\n\n    if (ep_dir == 0) {\n        ep_dir = 0;\n    } else {\n        ep_dir = 1;\n    }\n\n    if (USB_EP_GET_STATUS(ep_num, ep_dir) == USB_EP_HALTED) {\n        ep_status = 1;\n    }\n\n    udc_req.payload[0] = ep_status;\n    udc_req.payload[1] = 0;\n\n    return true;\n}", "CodeBleu_score": 45.02670709385904}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tbool success;\n\tuint8_t interface_number;\n\n\t// Check if the device is in a configured state\n\tif (!udc_is_configured()) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tinterface_number = udc_setup_get_interface_number();\n\tif (interface_number >= UDI_MAX_INTERFACE_COUNT) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_iface_set_default(interface_number)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_iface_set_altsetting(interface_number,\n\t\t\tudc_setup_get_interface_altsetting())) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\tsuccess = udi_setup_req_iface(interface_number);\n\n\treturn success;\n}", "CodeBleu_score": 39.79930423381903}, {"code": "static bool udc_req_iface(void){\n\t\tbool success = false;\n\n\t// Check if the device is configured\n\tif (udc_device_is_configured()) {\n\t\t// Check if the requested interface number is valid\n\t\tif (udc_req_iface_nb < udc_numb_interfaces) {\n\t\t\t// Update the interface descriptor to the default setting\n\t\t\tif (udc_iface_desc_tab[udc_req_iface_nb].bAlternateSetting == 0) {\n\t\t\t\t// Update the interface descriptor to the current alternate setting\n\t\t\t\tif (udc_iface_desc_tab[udc_req_iface_nb].bAlternateSetting == udc_iface_alt_nb[udc_req_iface_nb]) {\n\t\t\t\t\t// Forward the setup request to the corresponding USB Device Interface (UDI) handler\n\t\t\t\t\tif (udc_req_iface_nb < UDC_DESC_TAB_SIZE) {\n\t\t\t\t\t\tif (udc_g_req_vendor_handler[udc_req_iface_nb] != NULL) {\n\t\t\t\t\t\t\tsuccess = udc_g_req_vendor_handler[udc_req_iface_nb]();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn success;\n}", "CodeBleu_score": 36.99097209988437}, {"code": "static bool udc_req_iface(void){\n\t\tif (!udc_configured()) {\n\t\tudc_ack_setup();\n\t\treturn false;\n\t}\n\tuint8_t iface = udc_setup_get_wIndex0();\n\tif (iface >= UDI_MAX_INTERFACE) {\n\t\tudc_ack_setup();\n\t\treturn false;\n\t}\n\tiface_desc_t *iface_desc = &udc_interface_desc[iface];\n\tiface_desc->bInterfaceNumber = iface;\n\tiface_desc->bAlternateSetting = 0;\n\tif (!UDI_API_IFACE_SETUP(iface)) {\n\t\tudc_ack_setup();\n\t\treturn false;\n\t}\n\tiface_desc->bAlternateSetting = udc_setup_get_wValue1();\n\tif (!UDI_API_IFACE_SETUP(iface)) {\n\t\tudc_ack_setup();\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 46.28680879895478}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\tudi_msc_t *msc;\n\tuint8_t i;\n\tbool b_lun_available;\n\n\t// Check if the interface is supported\n\tif (!UDI_MSC_GLOBAL_ENABLE) {\n\t\treturn false;\n\t}\n\n\t// Initialize the state flags\n\tudi_msc_b_cbw_out = false;\n\tudi_msc_b_cbw_invalid = false;\n\tudi_msc_b_csw_invalid = false;\n\tudi_msc_b_csw_error = false;\n\tudi_msc_b_csw_error_phase = UDI_MSC_CSW_PHASE_ERROR_NONE;\n\tudi_msc_b_csw_error_phase_command = UDI_MSC_CSW_PHASE_ERROR_COMMAND_NONE;\n\tudi_msc_b_csw_error_phase_data = UDI_MSC_CSW_PHASE_ERROR_DATA_NONE;\n\tudi_msc_b_csw_error_phase_status = UDI_MSC_CSW_PHASE_ERROR_STATUS_NONE;\n\tudi_msc_b_csw_error_phase_status_condition = UDI_MSC_CSW_PHASE_ERROR_STATUS_CONDITION_NONE;\n\tudi_msc_b_csw_error_phase_status_condition_overrun = UDI_MSC_CSW_PHASE_ERROR_STATUS_CONDITION_OVERRUN_NONE;\n\tudi_msc_b_csw_error_phase_status_condition_underrun = UDI_MSC_CSW_PHASE_ERROR_STATUS_CONDITION_UNDERRUN_NONE;\n\n\t// Retrieve the number of LUNs\n\tudi_msc_nb_lun = udi_msc_get_nb_lun();\n\tif (!udi_msc_nb_lun) {\n\t\treturn false;\n\t}\n\n\t// Check if there are any LUNs available\n\tb_lun_available", "CodeBleu_score": 41.84537004721726}, {"code": "bool udi_msc_enable(void){\n\t\tbool b_lun_available = false;\n\tuint8_t i;\n\n\tudi_msc_b_lun_available = false;\n\tudi_msc_nb_lun = udi_msc_get_nb_lun();\n\tif (udi_msc_nb_lun == 0) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < udi_msc_nb_lun; i++) {\n\t\tif (udi_msc_unload_medium(i)) {\n\t\t\tb_lun_available = true;\n\t\t}\n\t}\n\tif (!b_lun_available) {\n\t\treturn false;\n\t}\n\tudi_msc_b_lun_available = true;\n\tudi_msc_b_cbw_wait = true;\n\treturn true;\n}", "CodeBleu_score": 51.12954512098927}, {"code": "bool udi_msc_enable(void){\n\t\tudi_msc_cbw_t cbw;\n\tuint8_t lun;\n\tuint8_t i;\n\tbool success = false;\n\n\t// Set initial state for flags\n\tudi_msc_b_cbw_invalid = false;\n\tudi_msc_b_csw_invalid = false;\n\tudi_msc_b_csw_error = false;\n\tudi_msc_b_csw_success = false;\n\tudi_msc_b_cbw_phase_error = false;\n\tudi_msc_b_cbw_error = false;\n\tudi_msc_b_cbw_aborted = false;\n\tudi_msc_b_cbw_valid = false;\n\tudi_msc_b_cbw_received = false;\n\tudi_msc_b_cbw_data_error = false;\n\tudi_msc_b_cbw_data_ok = false;\n\tudi_msc_b_cbw_data_aborted = false;\n\tudi_msc_b_cbw_data_invalid = false;\n\tudi_msc_b_cbw_data_overflow = false;\n\tudi_msc_b_cbw_data_underflow = false;\n\tudi_msc_b_cbw_data_padding = false;\n\tudi_msc_b_cbw_data_padding_error = false;\n\tudi_msc_b_cbw_data_padding_aborted = false;\n\tudi_msc_b_cbw_data_padding_ok = false;\n\tudi_msc_b_cbw_data_padding_underflow = false;\n\tudi_msc_b_cbw_data_padding_overflow = false;\n\tudi_msc_b_cbw_data_padding_valid = false;\n\tudi_msc_b_cbw_data_padding_received = false;\n\tudi_msc_b_cbw_data_padding_invalid = false;\n\tudi_msc_b_cbw_data_padding_aborted = false;\n\tudi_msc_", "CodeBleu_score": 17.46608229794908}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\t// Check if the transfer is successful\n\tif (UDD_EP_TRANSFER_OK != status) {\n\t\t// If not, wait for a MSC setup reset to restart CBW reception\n\t\tudi_msc_reset_process();\n\t\treturn;\n\t}\n\n\t// Decrease the data residue in the Command Status Wrapper (CSW)\n\tudi_msc_csw.dCSWDataResidue -= nb_sent;\n\n\t// If there is no data residue, send the CSW\n\tif (!udi_msc_csw.dCSWDataResidue) {\n\t\tudi_msc_csw_process();\n\t}\n}", "CodeBleu_score": 63.34518979814112}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status == UDD_EP_TRANSFER_OK) {\n    if (udi_msc_cbw_trans_block.csw.dCSWDataResidue == 0) {\n      udi_msc_cbw_trans_block.csw.bCSWStatus = UDI_MSC_CSW_STATUS_PASS;\n    } else {\n      udi_msc_cbw_trans_block.csw.bCSWStatus = UDI_MSC_CSW_STATUS_FAIL;\n    }\n    udi_msc_cbw_trans_block.csw.bCSWStatus |= UDI_MSC_CSW_STATUS_COMMAND_PASSED;\n    udi_msc_cbw_trans_block.csw.bCSWStatus |= UDI_MSC_CSW_STATUS_COMMAND_FAILED;\n    udi_msc_cbw_trans_block.csw.dCSWDataResidue -= nb_sent;\n    udi_msc_process_csw();\n  } else {\n    udi_msc_cbw_trans_block.csw.bCSWStatus = UDI_MSC_CSW_STATUS_FAIL;\n    udi_msc_cbw_trans_block.csw.bCSWStatus |= UDI_MSC_CSW_STATUS_COMMAND_FAILED;\n    udi_msc_cbw_trans_block.csw.dCSWDataResidue = 0;\n    udi_msc_process_csw();\n  }\n}", "CodeBleu_score": 44.58376911621967}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_TRANSFER_OK) {\n    // Transfer error\n    // Wait a MSC reset to restart CBW reception\n    udi_msc_cbw_wait_reset();\n    return;\n  }\n  // Data transfer success\n  // Update sense data\n  udi_msc_update_sense();\n  // Decrease the data residue in the CSW by the amount of data sent\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process the updated CSW\n  udi_msc_process_csw();\n}", "CodeBleu_score": 58.502066201720226}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tuint8_t udi_msc_csw_data[13];\n\n\tudi_msc_csw_data[0] = 0;\n\tudi_msc_csw_data[1] = 0;\n\tudi_msc_csw_data[2] = 0;\n\tudi_msc_csw_data[3] = 0;\n\tudi_msc_csw_data[4] = 0;\n\tudi_msc_csw_data[5] = 0;\n\tudi_msc_csw_data[6] = 0;\n\tudi_msc_csw_data[7] = 0;\n\tudi_msc_csw_data[8] = 0;\n\tudi_msc_csw_data[9] = 0;\n\tudi_msc_csw_data[10] = 0;\n\tudi_msc_csw_data[11] = 0;\n\tudi_msc_csw_data[12] = 0;\n\n\tudi_msc_csw_data[0] = udi_msc_cbw_data[0];\n\tudi_msc_csw_data[1] = udi_msc_cbw_data[1];\n\tudi_msc_csw_data[2] = udi_msc_cbw_data[2];\n\tudi_msc_csw_data[3] = udi_msc_cbw_data[3];\n\tudi_msc_csw_data[4] = udi_msc_cbw_data[4];\n\tudi_msc_csw_data[5] = udi_msc_cbw_data[5];\n\tudi_msc_csw_data[6] = udi_msc_cbw_data[6];\n\tudi_msc_csw_data[7] = udi_msc_cbw_data[7];\n\n\tif (udi_msc_cbw_data[0] == 0x00) {\n\t\tudi_", "CodeBleu_score": 31.623636995668857}, {"code": "static void udi_msc_csw_process(void){\n\t\tif (udi_msc_cbw.dCBWDataTransferLength) {\n\t\tif (udi_msc_cbw.bmCBWFlags & 0x80) {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n\tudi_msc_csw.dCSWDataResidue = le32_to_cpu(udi_msc_csw.dCSWDataResidue);\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.bCSWStatus = udi_msc_cbw.bCBWLUN;\n\tudd_ep_run(UDI_MSC_EP_IN,\n\t\t\tfalse,\n\t\t\t(uint8_t *) & udi_msc_csw,\n\t\t\tUDI_MSC_CSW_SIZE,\n\t\t\tNULL);\n}", "CodeBleu_score": 53.63776099559121}, {"code": "static void udi_msc_csw_process(void){\n\t\tirqflags_t flags;\n\tuint8_t *p_csw;\n\tuint32_t data_residue;\n\n\tflags = cpu_irq_save();\n\tif (udi_msc_b_cbw_invalid) {\n\t\tcpu_irq_restore(flags);\n\t\treturn;\n\t}\n\tudi_msc_b_cbw_invalid = true;\n\tcpu_irq_restore(flags);\n\n\tudi_msc_b_cbw_trans_status = UDI_MSC_CSW_STATUS_COMMAND_PASSED;\n\n\t/* Check if there is a non-zero data residue */\n\tif (udi_msc_b_cbw_data_trans_nb_trans > 0) {\n\t\tudi_msc_b_cbw_trans_status = UDI_MSC_CSW_STATUS_COMMAND_FAILED;\n\t\t/* Stall the appropriate endpoint */\n\t\tif (UDI_MSC_CBW_DIRECTION_OUT == udi_msc_b_cbw_direction) {\n\t\t\tudi_msc_b_cbw_trans_status = UDI_MSC_CSW_STATUS_PHASE_ERROR;\n\t\t\tudi_msc_b_cbw_trans_status = UDI_MSC_CSW_STATUS_COMMAND_FAILED;\n\t\t\tudi_msc_b_cbw_trans_status = UDI_MSC_CSW_STATUS_PHASE_ERROR;\n\t\t}\n\t}\n\n\t/* Prepare the CSW */\n\tp_csw = (uint8_t *) & udi_msc_b_cbw_csw;\n\tudi_msc_b_cbw_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\tudi_msc_b_cbw_csw.dCSWTag = udi_msc_b_cbw.dCBWTag;\n\tudi_msc_b_cbw_csw.bCSWStatus =", "CodeBleu_score": 39.78735596937405}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\tcancelReset();\n\t} else {\n\t\tif (usb_get_cdc_line_coding_baudrate(port) == 1200) {\n\t\t\t// We're in bootloader mode and the host has disabled DTR.\n\t\t\t// This means the host has disconnected and we should reset\n\t\t\t// the device.\n\t\t\tscheduleReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 27.477760950273005}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\tcancelReset();\n\t} else {\n\t\tif (usb_get_rate(port) == 1200) {\n\t\t\tscheduleReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 26.554248354320077}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\tusb_task_cdc_cancel_reset();\n\t} else {\n\t\tif (usb_task_cdc_get_baudrate(port) == 1200) {\n\t\t\tusb_task_cdc_schedule_reset();\n\t\t}\n\t}\n}", "CodeBleu_score": 27.191102725184024}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tif (usb_setup.Type == USB_SETUP_TYPE_VENDOR && usb_setup.Recipient == USB_SETUP_RECIPIENT_DEVICE) {\n\t\tif (usb_setup.bRequest == 0x04 && usb_setup.wIndex == 0x04) {\n\t\t\tusb_setup.wIndex = 0x00;\n\t\t\tusb_setup.wLength = 0x0008;\n\t\t\tusb_setup.wValue = 0x0000;\n\t\t\tusb_setup.bRequest = 0x06;\n\t\t\treturn true;\n\t\t}\n\t\tif (usb_setup.bRequest == 0x04 && usb_setup.wIndex == 0x05) {\n\t\t\tusb_setup.wIndex = 0x00;\n\t\t\tusb_setup.wLength = 0x000C;\n\t\t\tusb_setup.wValue = 0x0000;\n\t\t\tusb_setup.bRequest = 0x06;\n\t\t\treturn true;\n\t\t}\n\t\tif (usb_setup.bRequest == 0x04 && usb_setup.wIndex == 0x06) {\n\t\t\tusb_setup.wIndex = 0x00;\n\t\t\tusb_setup.wLength = 0x0004;\n\t\t\tusb_setup.wValue = 0x0000;\n\t\t\tusb_setup.bRequest = 0x06;\n\t\t\treturn true;\n\t\t}\n\t\tif (usb_setup.bRequest == 0x04 && usb_setup.wIndex == 0x07) {\n\t\t\tusb_setup.wIndex = 0x00;\n\t\t\tusb_setup.wLength = 0x0004;\n\t\t\tusb_setup.wValue = 0x0000;\n\t\t\tusb_setup.bRequest = 0x06;\n\t\t\treturn true;\n\t\t}\n\t\tif (", "CodeBleu_score": 19.07833262555245}, {"code": "bool usb_task_other_requests(void){\n\t    uint8_t request_index = (uint8_t)((usb_setup.wIndex & 0xFF00) >> 8);\n    uint8_t request_type = (uint8_t)(usb_setup.wIndex & 0x00FF);\n\n    if (request_type == 0x04) {\n        switch (request_index) {\n            case 0x01:\n                usb_setup.wIndex = 0x0401;\n                usb_setup.wLength = sizeof(usb_msos20_descriptor);\n                usb_setup.wValue = 0x0000;\n                return true;\n            case 0x02:\n                usb_setup.wIndex = 0x0402;\n                usb_setup.wLength = sizeof(usb_msos20_descriptor);\n                usb_setup.wValue = 0x0000;\n                return true;\n            case 0x03:\n                usb_setup.wIndex = 0x0403;\n                usb_setup.wLength = sizeof(usb_msos20_descriptor);\n                usb_setup.wValue = 0x0000;\n                return true;\n            case 0x04:\n                usb_setup.wIndex = 0x0404;\n                usb_setup.wLength = sizeof(usb_msos20_descriptor);\n                usb_setup.wValue = 0x0000;\n                return true;\n            default:\n                return false;\n        }\n    }\n    if (request_type == 0x05) {\n        switch (request_index) {\n            case 0x01:\n                usb_setup.wIndex = 0x0501;\n                usb_setup.wLength = sizeof(usb_msos20_descriptor);\n                usb_setup.wValue = 0x0000;\n                return true;\n            case 0x02:\n                usb_setup.wIndex = 0x05", "CodeBleu_score": 26.059139660375653}, {"code": "bool usb_task_other_requests(void){\n\t  /*\n   * If the request type is not a standard request, return \"false\" (0)\n   */\n  if (USB_BMREQUESTTYPE_TYPE(usb_request.bmRequestType) != USB_SETUP_TYPE_STANDARD) {\n    return false;\n  }\n  /*\n   * If the request type is a standard device request, return \"false\" (0)\n   */\n  if (USB_BMREQUESTTYPE_RECIPIENT(usb_request.bmRequestType) != USB_SETUP_RECIPIENT_DEVICE) {\n    return false;\n  }\n  /*\n   * If the request is a standard get descriptor request, return \"false\" (0)\n   */\n  if (usb_request.bRequest != USB_GET_DESCRIPTOR) {\n    return false;\n  }\n  /*\n   * If the request index is not 0x04 or 0x05, return \"false\" (0)\n   */\n  if (usb_request.wIndex != 0x04 && usb_request.wIndex != 0x05) {\n    return false;\n  }\n  /*\n   * If the request index is 0x04, set the payload pointer to the Microsoft-compatible ID descriptor\n   */\n  if (usb_request.wIndex == 0x04) {\n    usb_request.wLength = sizeof(usb_msc_compat_id_descriptor);\n    usb_request.pData = usb_msc_compat_id_descriptor;\n    return true;\n  }\n  /*\n   * If the request index is 0x05, set the payload pointer to the extended properties descriptor\n   */\n  if (usb_request.wIndex == 0x05) {\n    usb_request.wLength = sizeof(usb_msc_ext_properties_descriptor);\n    usb_request.pData = usb_msc_ext_properties_descriptor;\n    return true;\n  }\n  /*\n   * Return \"false\" (0) if the request index is not 0x04 or 0x05\n  ", "CodeBleu_score": 30.733286745043653}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint8_t dummy;\n\tuint16_t i;\n\n\tif (nbyte == 0) return;\n\n\tdummy = 0x00;\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPI_SendData(SPI1, dummy);\n\t\twhile (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);\n\t\tbuf[i] = SPI_I2S_ReceiveData(SPI1);\n\t}\n\n\tspiRec(&buf[i]);\n}", "CodeBleu_score": 40.69124050371813}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\tif (nbyte == 0) return;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiTxByte(0xff);\n\t\tbuf[i] = spiRxByte();\n\t}\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 42.98366099485895}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\n    uint16_t i;\n\n    // Check if the number of bytes to read is zero\n    if (nbyte == 0) {\n        return;\n    }\n\n    // For each byte to be read, send a dummy byte to the SPI transmit data register,\n    // wait for a byte to be received, and then store the received byte into the buffer.\n    for (i = 0; i < (nbyte - 1); i++) {\n        buf[i] = spiRec();\n        spiSend(0x00);\n    }\n\n    // Read the last byte using the \"spiRec\" function and store it in the buffer.\n    buf[i] = spiRec();\n\n    return;\n}", "CodeBleu_score": 50.2187391038621}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  pfnISR_Handler oldHandler;\n  uint32_t *vectors = (uint32_t*)SCB->VTOR;\n  uint32_t *irqTable = vectors + (irq + 16);\n\n  /* Disable global interrupts */\n  __disable_irq();\n\n  /* Get the old ISR handler */\n  oldHandler = (pfnISR_Handler) *irqTable;\n\n  /* Set the new ISR handler */\n  *irqTable = (uint32_t)newHandler;\n\n  /* Enable global interrupts */\n  __enable_irq();\n\n  return oldHandler;\n}", "CodeBleu_score": 49.487156569600245}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler = NULL;\n\n    // Disable global interrupts to ensure atomic operation\n    __disable_irq();\n\n    // Retrieve the current handler for the specified IRQ\n    oldHandler = g_pfnVectors[irq + 16];\n\n    // Replace the current handler with the new handler\n    g_pfnVectors[irq + 16] = newHandler;\n\n    // Re-enable global interrupts\n    __enable_irq();\n\n    return oldHandler;\n}", "CodeBleu_score": 63.109561590036556}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tuint32_t *pVTOR = (uint32_t *)SCB->VTOR;\n\tuint32_t *pIRQ = pVTOR + (irq + 16);\n\tpfnISR_Handler oldHandler = (pfnISR_Handler) *pIRQ;\n\t*pIRQ = (uint32_t)newHandler;\n\treturn oldHandler;\n}", "CodeBleu_score": 39.58709909628719}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (RX_BUFFER_EMPTY()) return -1;\n  return rx_buffer_ring[rx_buffer_head];\n}", "CodeBleu_score": 7.80831163116498}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!is_enabled) return -1;\n  if (!is_serial_available()) return -1;\n  return serial_peek();\n}", "CodeBleu_score": 13.452659692179648}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!_usb_cdc_initialized) return -1;\n  if (!usb_cdc_data_available()) return -1;\n  return usb_serial_peekchar();\n}", "CodeBleu_score": 14.667015343007625}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  if (pending_char >= 0) {\n    int c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n  if (!usb_serial_is_connected()) return -1;\n  if (usb_serial_available() > 0) {\n    int c = usb_serial_read();\n    if (c == '\\r') c = '\n';\n    if (parser.enabled) parser.update(c);\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 64.49905099693318}, {"code": "int MarlinSerialUSB::read(){\n\t  int c = -1;\n  if (usb_serial_available()) {\n    c = usb_serial_getchar();\n    if (c != -1) {\n      if (emergency_parser.enabled) emergency_parser.update(c);\n    }\n  }\n  return c;\n}", "CodeBleu_score": 32.21782527729683}, {"code": "int MarlinSerialUSB::read(){\n\t  int c = -1;\n  if (rx_buffer_index_read_serial > rx_buffer_index_write_serial) {\n    c = rx_buffer_serial[rx_buffer_index_read_serial];\n    rx_buffer_index_read_serial = (rx_buffer_index_read_serial + 1) % RX_BUFFER_SIZE;\n  }\n  else if (usb_serial_is_connected()) {\n    if (usb_serial_available()) {\n      c = usb_serial_read();\n      if (c != -1) {\n        rx_buffer_serial[rx_buffer_index_write_serial] = c;\n        rx_buffer_index_write_serial = (rx_buffer_index_write_serial + 1) % RX_BUFFER_SIZE;\n      }\n    }\n  }\n  return c;\n}", "CodeBleu_score": 40.00743006824684}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (usb_serial_available() > 0) return usb_serial_available();\n  return (usb_cdc_is_enabled() && usb_cdc_rx_ready()) ? 1 : 0;\n}", "CodeBleu_score": 43.72428309575388}, {"code": "int MarlinSerialUSB::available(){\n\t  return (int)((_rx_buffer_head - _rx_buffer_tail) & (RX_BUFFER_SIZE - 1));\n}", "CodeBleu_score": 10.434191644715856}, {"code": "int MarlinSerialUSB::available(){\n\t  if (rx_buffer_index_write == rx_buffer_index_read) return 0;\n  return rx_buffer_index_write - rx_buffer_index_read;\n}", "CodeBleu_score": 28.71453613727143}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\n  uint8_t c;\n\n  while (size--) {\n    if (!read_byte(pos, c)) return false;\n    if (writing) *value = c;\n    if (crc) *crc = crc16(c, *crc);\n    value++;\n  }\n\n  return true;\n}", "CodeBleu_score": 59.962133289630245}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\n  if (pos < 0) return false;\n\n  while (size--) {\n    const uint8_t b = persistentStore.read(pos);\n    if (writing && value) *value = b;\n    if (crc) *crc = crc16((uint8_t) *crc, b);\n    pos++;\n  }\n\n  return false;\n}", "CodeBleu_score": 55.24575648926344}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\n  uint8_t v;\n  while (size--) {\n    if (!read_byte(pos, v)) return false;\n    if (writing) *value = v;\n    if (crc) *crc = crc16((uint8_t)*crc, v);\n    value++;\n  }\n  return true;\n}", "CodeBleu_score": 58.20639882763492}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  uint8_t pwm_index = PWM_INDEX(pin);\n  if (pwm_index < PWM_COUNT) {\n    ledcWrite(pwm_index, value);\n    return;\n  }\n\n  // Try to find a software PWM slot\n  for (uint8_t i = 0; i < PWM_SOFT_COUNT; i++) {\n    if (pwm_soft_state[i].pin == pin) {\n      pwm_soft_state[i].value = value;\n      pwm_soft_state[i].freq = freq;\n      pwm_soft_state[i].res = res;\n      return;\n    }\n  }\n\n  // No slot found, allocate a new one\n  for (uint8_t i = 0; i < PWM_SOFT_COUNT; i++) {\n    if (pwm_soft_state[i].pin == 0) {\n      pwm_soft_state[i].pin = pin;\n      pwm_soft_state[i].value = value;\n      pwm_soft_state[i].freq = freq;\n      pwm_soft_state[i].res = res;\n\n      // Start the timer if this is the first PWM pin used\n      if (pwm_soft_count == 0) {\n        ledcSetup(PWM_SOFT_TIMER, PWM_SOFT_FREQUENCY, pwm_soft_res);\n        ledcAttachPin(pin, PWM_SOFT_TIMER);\n        ledcWrite(PWM_SOFT_TIMER, 0);\n      }\n\n      pwm_soft_count++;\n      return;\n    }\n  }\n}", "CodeBleu_score": 50.887566690275854}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (WITHIN(pin, 0, NUM_DIGITAL_PINS - 1)) {\n    if (pin < CORE_NUM_DIGITAL)\n      return HAL_analogWrite(pin, value, freq, res);\n    else\n      return HAL_analogWrite(pin - CORE_NUM_DIGITAL, value, freq, res);\n  }\n}", "CodeBleu_score": 20.596510645469763}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  uint8_t pwm_index = 0;\n  if (pin < NUM_DIGITAL_PINS) {\n    pwm_index = digitalPinToPwm(pin);\n    if (pwm_index > 0) {\n      ledcWrite(pwm_index, value);\n      return;\n    }\n  }\n  // No PWM hardware available for this pin.\n  // Use software PWM instead.\n  if (pwm_index >= MAX_PWM_COUNT) {\n    // Too many PWMs.\n    return;\n  }\n  if (pwm_count == 0) {\n    // No PWMs started. Start the first one.\n    ledcSetup(pwm_index, freq, res);\n    ledcAttachPin(pin, pwm_index);\n    pwm_count = 1;\n  }\n  else {\n    // Already started. See if this pin is in use.\n    for (uint8_t i = 0; i < pwm_count; i++) {\n      if (pwm_state[i].pin == pin) {\n        // Use existing PWM state.\n        pwm_index = i;\n        goto found;\n      }\n    }\n    // Not found. Add a new PWM state.\n    pwm_index = pwm_count;\n    pwm_state[pwm_count].pin = pin;\n    pwm_count++;\n  }\nfound:\n  ledcWrite(pwm_index, value);\n}", "CodeBleu_score": 55.20300815889343}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t    static_assert(sizeof(servoDelay) == sizeof(servoDelay[0]) * SERVO_CHANNELS, \"Servo delay array length must be equal to the number of servo channels.\");\n    if (servoAttach(value)) {\n        servoWrite(value);\n        delay(servoDelay[channel]);\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n            servoDetach();\n        }\n    }\n}", "CodeBleu_score": 51.73934370281877}, {"code": "void Servo::move(const int value){\n\t  static_assert(SERVO_DELAY_ARRAY_LENGTH == NUM_SERVOS, \"Servo delay array length must be equal to NUM_SERVOS\");\n  if (servoAttach(channel) == 0) {\n    servoWrite(channel, value);\n    delay(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      servoDetach(channel);\n    }\n  }\n}", "CodeBleu_score": 54.04749614253404}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == NUM_SERVOS, \"SERVO_DELAY_ARRAY_LENGTH must be equal to NUM_SERVOS\");\n\tif (attach()) {\n\t\twrite(value);\n\t\tdelay(SERVO_DELAY_ARRAY[channel]);\n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n\t\tdetach();\n#endif\n\t}\n}", "CodeBleu_score": 36.875708446863456}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t  uint8_t i;\n  uint8_t pwm_enabled = 0;\n  uint32_t sample_data;\n\n  // Check if any PWM pins are enabled for this sample\n  for (i = 0; i < NUM_PWM_PINS; i++) {\n    if (pwm_pin_duty_cycles[i] > 0) {\n      pwm_enabled = 1;\n      break;\n    }\n  }\n\n  // If no PWM pins are enabled, just write a 0 to the sample\n  if (!pwm_enabled) {\n    sample_data = 0;\n  }\n  else {\n    // PWM is enabled, so write the PWM data to the sample\n    sample_data = 0;\n    for (i = 0; i < NUM_PWM_PINS; i++) {\n      if (pwm_pin_duty_cycles[i] > 0) {\n        // If the pin's tick count is zero, toggle the pin state and set the tick count for the next transition\n        if (pwm_pin_tick_counts[i] == 0) {\n          if (pwm_pin_states[i] == 0) {\n            pwm_pin_states[i] = 1;\n          }\n          else {\n            pwm_pin_states[i] = 0;\n          }\n          pwm_pin_tick_counts[i] = pwm_pin_duty_cycles[i];\n        }\n        // Decrement the tick count and set the pin bit in the sample data\n        pwm_pin_tick_counts[i]--;\n        sample_data |= (pwm_pin_states[i] << i);\n      }\n    }\n  }\n\n  // Write the sample data to the DMA buffer\n  *(i2s_sample_buffer_position++) = sample_data;\n}", "CodeBleu_score": 42.115413732880235}, {"code": "void i2s_push_sample(){\n\t  uint8_t i;\n  uint8_t j;\n  uint8_t k;\n  uint8_t l;\n  uint8_t m;\n  uint8_t n;\n  uint8_t o;\n  uint8_t p;\n  uint8_t q;\n  uint8_t r;\n  uint8_t s;\n  uint8_t t;\n  uint8_t u;\n  uint8_t v;\n  uint8_t w;\n  uint8_t x;\n  uint8_t y;\n  uint8_t z;\n  uint8_t a;\n  uint8_t b;\n  uint8_t c;\n  uint8_t d;\n  uint8_t e;\n  uint8_t f;\n  uint8_t g;\n  uint8_t h;\n  uint8_t i2s_buffer_pos;\n  uint8_t pwm_pin_mask;\n  uint8_t pwm_pin_mask_temp;\n  uint8_t pwm_port_mask;\n  uint8_t pwm_port_mask_temp;\n  uint8_t pwm_port_mask_temp2;\n  uint8_t pwm_port_mask_temp3;\n  uint8_t pwm_port_mask_temp4;\n  uint8_t pwm_port_mask_temp5;\n  uint8_t pwm_port_mask_temp6;\n  uint8_t pwm_port_mask_temp7;\n  uint8_t pwm_port_mask_temp8;\n  uint8_t pwm_port_mask_temp9;\n  uint8_t pwm_port_mask_temp10;\n  uint8_t pwm_port_mask_temp11;\n  uint8_t pwm_port_mask_temp12;\n  uint8_t pwm_port_mask_temp13;\n  uint8_t pwm_port_mask_temp14;\n  uint8_", "CodeBleu_score": 4.971427914453896}, {"code": "void i2s_push_sample(){\n\t\tfor (int i = 0; i < NUM_PINS; i++) {\n\t\tif (pwm_ticks[i] == 0) {\n\t\t\tpwm_ticks[i] = pwm_periods[i];\n\t\t\tif (pwm_duty_cycles[i] > 0) {\n\t\t\t\tpwm_state[i] = !pwm_state[i];\n\t\t\t}\n\t\t}\n\t\tpwm_ticks[i]--;\n\t\tpwm_port_data[i] = pwm_state[i];\n\t}\n\tdma_buffer[dma_buffer_position] = pwm_port_data[0] | (pwm_port_data[1] << 1) | (pwm_port_data[2] << 2) | (pwm_port_data[3] << 3);\n\tdma_buffer_position++;\n\tif (dma_buffer_position == BUFFER_SIZE) {\n\t\tdma_buffer_position = 0;\n\t}\n}", "CodeBleu_score": 29.89334240187671}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn (hal_timer_t) 0;\n}", "CodeBleu_score": 6.845389585757376}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t count;\n\tif (timer_num == 0) {\n\t\tcount = TIMER0_COUNT;\n\t} else if (timer_num == 1) {\n\t\tcount = TIMER1_COUNT;\n\t} else if (timer_num == 2) {\n\t\tcount = TIMER2_COUNT;\n\t} else if (timer_num == 3) {\n\t\tcount = TIMER3_COUNT;\n\t} else if (timer_num == 4) {\n\t\tcount = TIMER4_COUNT;\n\t} else if (timer_num == 5) {\n\t\tcount = TIMER5_COUNT;\n\t} else {\n\t\tcount = 0;\n\t}\n\treturn count;\n}", "CodeBleu_score": 28.31636861268077}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\n\tif (timer_num >= NUM_TIMERS) {\n\t\treturn 0;\n\t}\n\n\treturn timer_config[timer_num].timer_count;\n}", "CodeBleu_score": 21.170022973284524}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\n  if (!is_initialized()) return true;\n\n  LOOP_L_N(i, size) {\n    uint8_t v = eeprom_read_byte((uint8_t*)pos);\n    if (writing) value[i] = v;\n    *crc = crc16((uint8_t*)value, size);\n    pos++;\n  }\n\n  return false;\n}", "CodeBleu_score": 46.2130674658959}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint8_t * const start = value;\n  uint8_t * const end = value + size;\n  while (value < end) {\n    uint8_t v = eeprom_read_byte((uint8_t*)pos);\n    if (writing) *value = v;\n    if (crc) *crc = crc16((uint8_t*)pos, 1, *crc);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 42.565154582214106}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\n  if (!WITHIN(pos, 0, persistentStore.capacity() - 1)) return true;\n\n  if (crc) *crc = persistentStore.read_byte(pos);\n  if (writing) STORE_BYTE(value, pos, persistentStore.read_byte(pos));\n\n  return persistentStore.read_data(pos, value, size - 1, crc, writing);\n}", "CodeBleu_score": 37.96224531560095}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    uint32_t count = 0;\n    uint32_t status;\n\n    if (!src || !sdioHandle) {\n        return false;\n    }\n\n    while (count < SD_WRITE_RETRY_COUNT) {\n        status = SD_WriteBlock(sdioHandle, block, src);\n\n        if (status == SD_OK) {\n            return true;\n        }\n\n        count++;\n    }\n\n    printf(\"Failed to write block %lu: %lu\\r\n\", block, status);\n    return false;\n}", "CodeBleu_score": 34.546199740184896}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\n  uint32_t status;\n  uint32_t count = 0;\n\n  if (src == NULL) {\n    printf(\"SDIO_WriteBlock: Error - source pointer is null\\r\n\");\n    return false;\n  }\n\n  if (hsd.Instance == NULL) {\n    printf(\"SDIO_WriteBlock: Error - SDIO handle is null\\r\n\");\n    return false;\n  }\n\n  /*\n   * The function \"HAL_SD_WriteBlocks\" attempts to write a block of data to an SD card using the SDIO interface.\nIt first asserts that the SDIO handle and source pointer are not null.\nIt then tries to write the block, retrying up to a defined number of times if the write operation fails.\nIf the write operation succeeds, it returns \"HAL_OK\".\nIf all retries fail, it prints an error message and returns \"HAL_ERROR\".\n   */\n  status = HAL_SD_WriteBlocks(&hsd, (uint8_t *)src, block, 1, 1000);\n\n  while ((status != HAL_OK) && (count < SD_WRITE_RETRY_COUNT)) {\n    count++;\n    printf(\"SDIO_WriteBlock: Error - write failed, retrying\\r\n\");\n    status = HAL_SD_WriteBlocks(&hsd, (uint8_t *)src, block, 1, 1000);\n  }\n\n  if (status != HAL_OK) {\n    printf(\"SDIO_WriteBlock: Error - write failed\\r\n\");\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 45.08825326245328}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    if (hsd.Instance == NULL) {\n        printf(\"Error: SDIO handle is null.\n\");\n        return false;\n    }\n    if (src == NULL) {\n        printf(\"Error: Source pointer is null.\n\");\n        return false;\n    }\n    // Try to write the block, retrying up to a defined number of times if the write operation fails.\n    for (uint8_t i = 0; i < SDIO_WRITE_RETRIES; i++) {\n        if (HAL_SD_WriteBlocks(&hsd, (uint8_t*)src, block, 1, 5000) == HAL_OK) {\n            return true;\n        }\n        else {\n            printf(\"Error: SDIO write block %u failed, retrying.\n\", block);\n        }\n    }\n    printf(\"Error: SDIO write block %u failed after %u retries.\n\", block, SDIO_WRITE_RETRIES);\n    return false;\n}", "CodeBleu_score": 42.67129488229942}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    uint32_t prescale = 0;\n    uint32_t timer_freq = 0;\n\n    if (timer_num == TEMP_TIMER_CHANNEL) {\n        prescale = (uint32_t)((float)F_CPU / (float)frequency / (float)TEMP_TIMER_PRESCALE);\n        timer_freq = (uint32_t)((float)F_CPU / (float)prescale);\n        TCCR1B |= (1 << CS10);\n        TCCR1B &= ~(1 << CS11);\n        TCCR1B &= ~(1 << CS12);\n        TCCR1B |= (1 << WGM12);\n        TIMSK1 |= (1 << OCIE1A);\n        OCR1A = (uint16_t)(timer_freq / TEMP_TIMER_PRESCALE);\n        sei();\n    } else if (timer_num == STEP_TIMER_CHANNEL) {\n        prescale = (uint32_t)((float)F_CPU / (float)frequency / (float)STEP_TIMER_PRESCALE);\n        timer_freq = (uint32_t)((float)F_CPU / (float)prescale);\n        TCCR2B |= (1 << CS20);\n        TCCR2B &= ~(1 << CS21);\n        TCCR2B &= ~(1 << CS22);\n        TCCR2B |= (1 << WGM22);\n        TIMSK2 |= (1 << OCIE2A);\n        OCR2A = (uint16_t)(timer_freq / STEP_TIMER_PRESCALE);\n        sei();\n    } else {\n        assert_param(0);\n    }\n}", "CodeBleu_score": 32.099250950690916}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  if (timer_num == TEMP_TIMER) {\n    TCCR1B = 0;\n    TCCR1A = 0;\n    TCNT1 = 0;\n    OCR1A = 0;\n    TCCR1B |= (1 << WGM12);\n    TCCR1B |= (1 << CS12) | (1 << CS10);\n    OCR1A = (uint16_t)((float)F_CPU / (float)frequency / (float)TEMP_TIMER_PRESCALE) - 1;\n    TIMSK1 |= (1 << OCIE1A);\n    sei();\n  }\n  else if (timer_num == STEP_TIMER) {\n    TCCR2B = 0;\n    TCCR2A = 0;\n    TCNT2 = 0;\n    OCR2A = 0;\n    TCCR2B |= (1 << WGM22);\n    TCCR2B |= (1 << CS22) | (1 << CS20);\n    OCR2A = (uint16_t)((float)F_CPU / (float)frequency / (float)STEP_TIMER_PRESCALE) - 1;\n    TIMSK2 |= (1 << OCIE2A);\n    sei();\n  }\n  else {\n    assert(false);\n  }\n}", "CodeBleu_score": 34.36641871031817}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    if (timer_num == TEMP_TIMER_CHANNEL) {\n        // Set the temperature timer prescale\n        TIMER_PrescaleSet(TEMP_TIMER_BASE, TIMER_A, TEMP_TIMER_PRESCALE);\n\n        // Set the temperature timer period\n        TIMER_LoadSet(TEMP_TIMER_BASE, TIMER_A, TEMP_TIMER_PERIOD);\n\n        // Set the temperature timer to start counting\n        TIMER_Enable(TEMP_TIMER_BASE, TIMER_A);\n\n        // Set the temperature timer priority\n        IntPrioritySet(INT_TEMP_TIMER, TEMP_TIMER_PRIORITY);\n\n        // Enable the temperature timer interrupt\n        TIMER_IntEnable(TEMP_TIMER_BASE, TIMER_TIMA_TIMEOUT);\n\n        // Enable the temperature timer interrupt in the NVIC\n        IntEnable(INT_TEMP_TIMER);\n\n    } else if (timer_num == STEP_TIMER_CHANNEL) {\n        // Set the stepper timer prescale\n        TIMER_PrescaleSet(STEP_TIMER_BASE, TIMER_A, STEP_TIMER_PRESCALE);\n\n        // Set the stepper timer period\n        TIMER_LoadSet(STEP_TIMER_BASE, TIMER_A, STEP_TIMER_PERIOD);\n\n        // Set the stepper timer to start counting\n        TIMER_Enable(STEP_TIMER_BASE, TIMER_A);\n\n        // Set the stepper timer priority\n        IntPrioritySet(INT_STEP_TIMER, STEP_TIMER_PRIORITY);\n\n        // Enable the stepper timer interrupt\n        TIMER_IntEnable(STEP_TIMER_BASE, TIMER_TIMA_TIMEOUT);\n\n        // Enable the stepper timer interrupt in the NVIC\n        IntEnable(INT_STEP_TIMER);", "CodeBleu_score": 35.03938453099097}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\n  if (eeprom_file) {\n    SERIAL_ECHOLNPGM(\"?EEPROM file already open\");\n    return false;\n  }\n\n  eeprom_file = fopen(eeprom_filename, \"rb\");\n  if (!eeprom_file) {\n    SERIAL_ECHOLNPGM(\"?EEPROM file open failed\");\n    return false;\n  }\n\n  fseek(eeprom_file, 0, SEEK_END);\n  size_t size = ftell(eeprom_file);\n  fseek(eeprom_file, 0, SEEK_SET);\n\n  if (size < E2END + 1) {\n    SERIAL_ECHOLNPGM(\"?EEPROM file too small\");\n    fclose(eeprom_file);\n    eeprom_file = NULL;\n    return false;\n  }\n\n  if (size > E2END + 1) {\n    SERIAL_ECHOLNPGM(\"?EEPROM file too big\");\n    fclose(eeprom_file);\n    eeprom_file = NULL;\n    return false;\n  }\n\n  if (fread(eeprom_buffer, sizeof(eeprom_buffer[0]), E2END + 1, eeprom_file) != E2END + 1) {\n    SERIAL_ECHOLNPGM(\"?EEPROM file read failed\");\n    fclose(eeprom_file);\n    eeprom_file = NULL;\n    return false;\n  }\n\n  fclose(eeprom_file);\n  eeprom_file = NULL;\n  return true;\n}", "CodeBleu_score": 43.07195607945226}, {"code": "bool PersistentStore::access_start(){\n\t  bool success = false;\n  if (file) {\n    // Close the file before opening it again\n    file.close();\n  }\n  file = SdFile::open(filename, O_READ);\n  if (file) {\n    // If the file is open, initialize the EEPROM emulation buffer\n    if (file.fileSize() >= (size_t)EEPROM_SIZE) {\n      // If the file is of sufficient size, read its contents into the buffer\n      file.read(eeprom_data, EEPROM_SIZE);\n    }\n    else {\n      // If the file is too small, fill the remainder of the buffer with the default erase value\n      memset(eeprom_data + file.fileSize(), EEPROM_DEFAULT_ERASE_VALUE, EEPROM_SIZE - file.fileSize());\n    }\n    file.close();\n    success = true;\n  }\n  return success;\n}", "CodeBleu_score": 30.280195824213372}, {"code": "bool PersistentStore::access_start(){\n\t  #if ENABLED(EEPROM_SETTINGS)\n    if (eeprom_status == EEPROM_STATUS_UNINITIALIZED) {\n      // Open the EEPROM file\n      eeprom_fd = HAL::eeprom_open(EEPROM_FILENAME);\n      if (eeprom_fd < 0) {\n        SERIAL_ECHO_START();\n        SERIAL_ECHOLNPAIR(\"EEPROM open failed: \", EEPROM_FILENAME);\n        return false;\n      }\n\n      // Get the EEPROM file size\n      int eeprom_size = HAL::eeprom_size(eeprom_fd);\n      if (eeprom_size <= 0) {\n        SERIAL_ECHO_START();\n        SERIAL_ECHOLNPAIR(\"EEPROM size failed: \", EEPROM_FILENAME);\n        return false;\n      }\n\n      // If the file is not large enough, zero-fill the remainder of the buffer\n      if (eeprom_size < EEPROM_SIZE) {\n        // Zero-fill the remainder of the buffer\n        memset(eeprom_data + eeprom_size, 0, EEPROM_SIZE - eeprom_size);\n        // Write the new data to the EEPROM file\n        if (!HAL::eeprom_write(eeprom_fd, eeprom_data, EEPROM_SIZE)) {\n          SERIAL_ECHO_START();\n          SERIAL_ECHOLNPAIR(\"EEPROM write failed: \", EEPROM_FILENAME);\n          return false;\n        }\n      }\n      // If the file is larger than the buffer, truncate the file\n      else if (eeprom_size > EEPROM_SIZE) {\n        if (!HAL::eeprom_write(eeprom_fd, eeprom_data, EEPROM_SIZE)) {\n          SERIAL_ECHO_START();\n          SERIAL_ECHOLNPAIR(\"EEPROM write failed: \", EEPROM_FILENAME);\n          return false;\n        }\n        if", "CodeBleu_score": 35.450428586072036}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    uint8_t i;\n\n    for (i = 0; i < 8; i++) {\n        HAL_GPIO_STM32_SetPin_Low(HAL_SPI_STM32_SPI_PORT_SCLK, HAL_SPI_STM32_PIN_SCLK);\n        if (b & 0x80) {\n            HAL_GPIO_STM32_SetPin_High(HAL_SPI_STM32_SPI_PORT_MOSI, HAL_SPI_STM32_PIN_MOSI);\n        } else {\n            HAL_GPIO_STM32_SetPin_Low(HAL_SPI_STM32_SPI_PORT_MOSI, HAL_SPI_STM32_PIN_MOSI);\n        }\n        HAL_GPIO_STM32_SetPin_High(HAL_SPI_STM32_SPI_PORT_SCLK, HAL_SPI_STM32_PIN_SCLK);\n        r = r << 1;\n        if (HAL_GPIO_STM32_GetPin(HAL_SPI_STM32_SPI_PORT_MISO, HAL_SPI_STM32_PIN_MISO)) {\n            r |= 1;\n        }\n        b = b << 1;\n    }\n\n    HAL_Delay_Milliseconds(1);\n\n    return r;\n}", "CodeBleu_score": 41.72030958185839}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    for (int i = 0; i < 8; i++) {\n        HAL_GPIO_STM32_WritePin(HAL_SPI_STM32_SCK_PORT, HAL_SPI_STM32_SCK_PIN, 0);\n        if (b & 0x80) {\n            HAL_GPIO_STM32_WritePin(HAL_SPI_STM32_MOSI_PORT, HAL_SPI_STM32_MOSI_PIN, 1);\n        } else {\n            HAL_GPIO_STM32_WritePin(HAL_SPI_STM32_MOSI_PORT, HAL_SPI_STM32_MOSI_PIN, 0);\n        }\n        b = b << 1;\n        HAL_GPIO_STM32_WritePin(HAL_SPI_STM32_SCK_PORT, HAL_SPI_STM32_SCK_PIN, 1);\n        r = r << 1;\n        if (HAL_GPIO_STM32_ReadPin(HAL_SPI_STM32_MISO_PORT, HAL_SPI_STM32_MISO_PIN)) {\n            r = r | 0x01;\n        }\n    }\n    return r;\n}", "CodeBleu_score": 38.469154551951945}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_STM32_WritePin(HAL_SPI_STM32_SPI_PORT, HAL_SPI_STM32_SCK_PIN, 0);\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_STM32_WritePin(HAL_SPI_STM32_SPI_PORT, HAL_SPI_STM32_MOSI_PIN, 1);\n\t\t} else {\n\t\t\tHAL_GPIO_STM32_WritePin(HAL_SPI_STM32_SPI_PORT, HAL_SPI_STM32_MOSI_PIN, 0);\n\t\t}\n\t\tHAL_GPIO_STM32_WritePin(HAL_SPI_STM32_SPI_PORT, HAL_SPI_STM32_SCK_PIN, 1);\n\t\tif (HAL_GPIO_STM32_ReadPin(HAL_SPI_STM32_SPI_PORT, HAL_SPI_STM32_MISO_PIN)) {\n\t\t\tr |= 0x01;\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(1);\n\treturn r;\n}", "CodeBleu_score": 38.363256441383385}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 84.07596204999733}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState == ENABLE)\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\telse\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 50.233957382233505}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 46.70610074575103}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c;\n  uint8_t *rx_head = &rx_buffer.head;\n  uint8_t *rx_tail = &rx_buffer.tail;\n  uint8_t *rx_buffer_data = rx_buffer.buffer;\n\n  if (obj->periph.uart.Instance == USART1) {\n    // Read one byte from the USART Data Register\n    c = (uint8_t)(USART1->DR & (uint16_t)0x01FF);\n  }\n  else {\n    // Read one byte from the USART Data Register\n    c = (uint8_t)(USART2->DR & (uint16_t)0x01FF);\n  }\n\n  if ((USART_GetFlagStatus(obj->periph.uart.Instance, USART_FLAG_PE) == RESET) || (obj->periph.uart.Init.Parity == USART_PARITY_NONE)) {\n    // No Parity error : normal operation\n    if (*rx_tail != *rx_head) {\n      // calculate the buffer index\n      uint8_t i = (*rx_tail + 1) & (uint8_t)(SERIAL_RX_BUFFER_SIZE - 1);\n\n      // store new data in buffer\n      rx_buffer_data[*rx_tail] = c;\n      *rx_tail = i;\n\n      // update number of received bytes\n      rx_buffer.count++;\n\n      // update the index of the first unread byte\n      rx_buffer.head = *rx_tail;\n\n      // update the emergency parser state\n      if (rx_buffer.count == 1) {\n        rx_buffer.state = c;\n      }\n      else {\n        rx_buffer.state = update_parser_state(rx_buffer.state, c);\n      }\n    }\n  }\n  else {\n    // Parity error : discard received byte\n    USART_ReceiveData(obj->periph.uart.Instance);\n  }\n}", "CodeBleu_score": 33.58126236137811}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\n  // Read the byte\n  uint8_t c = obj->regs->RBR;\n\n  // If no parity error occurred\n  if ((obj->regs->LSR & USART_LSR_PE) == 0) {\n\n    // If space is available in the RX FIFO, store the byte and move the head pointer\n    if (obj->rx_head != obj->rx_tail) {\n      obj->rx_buffer[obj->rx_head] = c;\n      obj->rx_head = (obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n    }\n\n    // If the emergency parser is enabled\n    if (obj->emergency_parser != NULL) {\n\n      // Call the parser function with the received byte\n      obj->emergency_parser(c);\n    }\n  }\n}", "CodeBleu_score": 46.01374308687224}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c = obj->regs->RBR;\n  if (!(obj->regs->LSR & LSR_ERR_MASK)) {\n    if (obj->rx_buff.pos < obj->rx_buff.length) {\n      obj->rx_buff.buffer[obj->rx_buff.pos++] = c;\n    }\n    if (obj->rx_buff.pos == obj->rx_buff.length) {\n      obj->rx_buff.pos = 0;\n      obj->rx_buff.overflow = true;\n    }\n  }\n  obj->regs->IER &= ~IER_RBR;\n  obj->regs->IER |= IER_RBRI;\n}", "CodeBleu_score": 31.930637117748763}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        if (HAL_timer_initialized(MF_TIMER_STEP) && !HAL_timer_interrupt_attached(MF_TIMER_STEP)) {\n            HAL_timer_attach_interrupt(MF_TIMER_STEP, Step_Handler);\n        }\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n        if (HAL_timer_initialized(MF_TIMER_TEMP) && !HAL_timer_interrupt_attached(MF_TIMER_TEMP)) {\n            HAL_timer_attach_interrupt(MF_TIMER_TEMP, Temp_Handler);\n        }\n    }\n}", "CodeBleu_score": 36.297487609870615}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    // Check if the timer is initialized\n    if (timer_num == MF_TIMER_STEP) {\n        if (step_timer_initialized && !step_timer_interrupt_attached) {\n            // Attach the interrupt handler\n            attachInterrupt(digitalPinToInterrupt(STEP_TIMER_PIN), Step_Handler, FALLING);\n            step_timer_interrupt_attached = true;\n        }\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n        if (temp_timer_initialized && !temp_timer_interrupt_attached) {\n            // Attach the interrupt handler\n            attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, FALLING);\n            temp_timer_interrupt_attached = true;\n        }\n    }\n}", "CodeBleu_score": 31.883531940988423}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        if (timer_step.initialized && !timer_step.interrupt_attached) {\n            timer_step.interrupt_attached = true;\n            attachInterrupt(digitalPinToInterrupt(STEP_TIMER_PIN), Step_Handler, FALLING);\n        }\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n        if (timer_temp.initialized && !timer_temp.interrupt_attached) {\n            timer_temp.interrupt_attached = true;\n            attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, FALLING);\n        }\n    }\n}", "CodeBleu_score": 34.45137688637637}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(s) == 0 {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\tn := len(s)\n\tm := len(sep)\n\tif m > n {\n\t\treturn -1\n\t}\n\tif m == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\tif m == n {\n\t\tif s == sep {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\t}\n\t// Rabin-Karp search\n\thashss := hashStr(s[len(s)-m:])\n\thashsep := hashStr(sep)\n\tif hashss == hashsep {\n\t\tif s[len(s)-m:] == sep {\n\t\t\treturn len(s) - m\n\t\t}\n\t}\n\tvar h uint32\n\tfor i := len(s) - m; i >= 0; i-- {\n\t\th = rollHashStr(h, s[i], s[i+m])\n\t\tif h == hashsep && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 44.48918907104634}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\thashsep, pow := HashStr(sep), uint64(1)\n\tfor i := 0; i < len(sep)-1; i++ {\n\t\tpow *= primeRK\n\t}\n\tvar h uint64\n\tfor i := len(sep) - 1; i < len(s); i++ {\n\t\th = h*primeRK + uint64(s[i])\n\t\tif i >= len(sep) {\n\t\t\th -= pow * uint64(s[i-len(sep)])\n\t\t}\n\t\tif h == hashsep && Equal(s[i-len(sep)+1:i+1], sep) {\n\t\t\treturn i - len(sep) + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 42.24397509109629}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\n\th := hash(sep)\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif hash(s[i:i+len(sep)]) == h && equal(s[i:i+len(sep)], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 30.11071169491015}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tmask := disableInterrupts()\n\tif usbcdc.txc.Head != usbcdc.txc.Tail {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\trestoreInterrupts(mask)\n}", "CodeBleu_score": 43.989228843939784}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txc != 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txc)\n\t\tusbcdc.txc = 0\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 44.9210684645142}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txc.Len() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 45.83857669199566}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag\n\ti2c.control.SetBits(avr.TWSR_START)\n\t// Put a start condition on the SDA line\n\ti2c.control.SetBits(avr.TWSR_START)\n\t// Enable the I2C module\n\ti2c.control.SetBits(avr.TWSR_ENABLE)\n\t// Wait for the start condition to be transmitted\n\tfor i2c.control.GetBits(avr.TWSR_START) == 0 {\n\t}\n\t// Write the 7-bit shifted peripheral address to the bus\n\tif write {\n\t\ti2c.data.Set(address << 1)\n\t} else {\n\t\ti2c.data.Set((address << 1) | 1)\n\t}\n\t// Send the address\n\ti2c.control.SetBits(avr.TWSR_START)\n\t// Wait for the address to be sent\n\tfor i2c.control.GetBits(avr.TWSR_START) == 0 {\n\t}\n}", "CodeBleu_score": 32.09471148016962}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear interrupt flag\n\ti2c.Control.SetBits(avr.I2C_TWINT)\n\t// Set start condition\n\ti2c.Control.SetBits(avr.I2C_TWSTA)\n\t// Enable I2C\n\ti2c.Control.SetBits(avr.I2C_TWEN)\n\t// Wait for start condition to be transmitted\n\tfor !i2c.Control.HasBits(avr.I2C_TWINT) {\n\t}\n\t// Write address\n\ti2c.Data = uint8(address << 1)\n\tif !write {\n\t\ti2c.Data |= 1\n\t}\n\t// Send address\n\ti2c.Control.SetBits(avr.I2C_TWINT)\n\t// Wait for address to be transmitted\n\tfor !i2c.Control.HasBits(avr.I2C_TWINT) {\n\t}\n}", "CodeBleu_score": 37.5208343778085}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag\n\ti2c.Control.SetBits(avr.I2C_WIF)\n\n\t// Set the start condition\n\ti2c.Control.SetBits(avr.I2C_WEN)\n\n\t// Wait for the start condition to be transmitted\n\tfor !i2c.Control.HasBits(avr.I2C_WIF) {\n\t}\n\n\t// Write the address to the bus\n\ti2c.Data.Set(uint8(address << 1))\n\n\t// Wait for the address to be transmitted\n\tfor !i2c.Control.HasBits(avr.I2C_WIF) {\n\t}\n\n\t// Clear the interrupt flag\n\ti2c.Control.SetBits(avr.I2C_WIF)\n\n\t// Set the read flag if needed\n\tif write {\n\t\ti2c.Control.ClearBits(avr.I2C_WEN)\n\t} else {\n\t\ti2c.Control.SetBits(avr.I2C_WEN)\n\t}\n}", "CodeBleu_score": 32.788737545814506}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Set the flash to erase mode.\n\tnrf.NVMC.CONFIG = nrf.NVMC_CONFIG_WEN_Een\n\tnrf.NVMC.ERASEALL = nrf.NVMC_ERASEALL_ERASEALL_Erase\n\n\t// Wait for the flash to be ready.\n\tfor nrf.NVMC.READY == nrf.NVMC_READY_READY_Busy {\n\t}\n\n\t// Erase the blocks.\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE = uint32(start + i)\n\n\t\t// Wait for the flash to be ready.\n\t\tfor nrf.NVMC.READY == nrf.NVMC_READY_READY_Busy {\n\t\t}\n\t}\n\n\t// Set the flash back to read mode.\n\tnrf.NVMC.CONFIG = nrf.NVMC_CONFIG_WEN_Ren\n\n\treturn nil\n}", "CodeBleu_score": 30.34717025496083}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address based on the block number and block size.\n\tstartAddress := f.baseAddress + start*f.blockSize\n\t// Wait for any ongoing flash operations to complete.\n\tfor nrf.FICR.FICR_INFO_PART.Get() == nrf.FICR_INFO_PART_PART_NONE {\n\t}\n\t// Configure the flash for erasing.\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Een)\n\t// Erase each block.\n\tfor i := int64(0); i < len; i++ {\n\t\t// Start erasing the block.\n\t\tnrf.NVMC.ERASEUICR.Set(uint32(startAddress))\n\t\t// Wait until the flash is no longer busy.\n\t\tfor nrf.NVMC.READY.Get() == nrf.NVMC_READY_READY_Busy {\n\t\t}\n\t\t// Update the start address for the next block.\n\t\tstartAddress += f.blockSize\n\t}\n\t// Set the flash back to read mode.\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\t// Return \"nil\" indicating successful completion.\n\treturn nil\n}", "CodeBleu_score": 40.582822665872285}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tvar (\n\t\tstartAddress uint32\n\t\tendAddress   uint32\n\t\tblockSize    uint32\n\t)\n\n\t// Get the start address of the first block to erase.\n\tstartAddress = f.getStartAddress(start)\n\t// Get the end address of the last block to erase.\n\tendAddress = f.getStartAddress(start + len - 1)\n\t// Get the block size.\n\tblockSize = f.getBlockSize()\n\n\t// Check if the address is aligned to a block boundary.\n\tif startAddress%blockSize != 0 {\n\t\treturn flashErr(\"start address not aligned to block boundary\")\n\t}\n\n\t// Check if the length is a multiple of the block size.\n\tif len%int64(blockSize) != 0 {\n\t\treturn flashErr(\"length not multiple of block size\")\n\t}\n\n\t// Check if the end address is aligned to a block boundary.\n\tif endAddress%blockSize != 0 {\n\t\treturn flashErr(\"end address not aligned to block boundary\")\n\t}\n\n\t// Check if the end address is within the flash memory.\n\tif endAddress > f.getEndAddress() {\n\t\treturn flashErr(\"end address out of range\")\n\t}\n\n\t// Check if the start address is within the flash memory.\n\tif startAddress < f.getStartAddress(0) {\n\t\treturn flashErr(\"start address out of range\")\n\t}\n\n\t// Disable interrupts.\n\tinterrupt.Disable()\n\t// Enter critical section.\n\tnrf.NVIC_INT_ENABLE.SetBits(nrf.PENDSV_IRQn)\n\n\t// Set the flash to erase mode.\n\tf.setMode(nrf.FICR_FMEM_ERASE)\n\n\t// Erase the blocks.\n\tfor address := startAddress; address <= endAddress; address += blockSize {\n\t\t// Start erasing the block.\n\t\tf.eraseBlock(address)\n\t\t// Wait until the flash is no longer busy.\n\t\tf.waitUntilNotBusy()\n\t}\n\n\t// Set the flash", "CodeBleu_score": 33.69349595455139}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > int64(f.size) || off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, nrf.Errorf(nrf.ErrorCodeOutOfBounds, \"WriteAt: invalid offset %d or length %d\", off, len(p))\n\t}\n\n\tstart := int(off)\n\tend := start + len(p)\n\n\t// Pad the data to fit the write block size.\n\tif end%int(f.writeBlockSize) != 0 {\n\t\tp = append(p, make([]byte, int(f.writeBlockSize)-(end%int(f.writeBlockSize)))...)\n\t}\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.Config.SetBits(nrf.NVMC_CONFIG_WEN)\n\n\t// Write the data in blocks.\n\tfor i := start; i < end; i += int(f.writeBlockSize) {\n\t\t// Wait for the flash memory to be ready.\n\t\tfor nrf.NVMC.Ready.HasBits(nrf.NVMC_READY_READY) == 0 {\n\t\t}\n\n\t\t// Write the block.\n\t\tnrf.NVMC.ErasePage.Set(uint32(i))\n\n\t\t// Wait for the flash memory to be ready.\n\t\tfor nrf.NVMC.Ready.HasBits(nrf.NVMC_READY_READY) == 0 {\n\t\t}\n\t}\n\n\t// Disable write mode on the flash memory controller.\n\tnrf.NVMC.Config.ClearBits(nrf.NVMC_CONFIG_WEN)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 32.84401723310674}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, nrf.Errorf(\"write %d bytes at offset %d exceeds device size %d\", len(p), off, f.Size())\n\t}\n\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// Calculate start address for writing.\n\tstart := int(off)\n\n\t// Pad the byte slice to fit the write block size.\n\tpad := f.WriteBlockSize() - (len(p) % f.WriteBlockSize())\n\tif pad != f.WriteBlockSize() {\n\t\tp = append(p, make([]byte, pad)...)\n\t}\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.CONFIG = nrf.NVMC_CONFIG_WEN_Een\n\tfor nrf.NVMC.READY == 0 {\n\t}\n\n\t// Write the data in blocks.\n\tfor len(p) > 0 {\n\t\t// Write the block.\n\t\tnrf.NVMC.ERASEPAGE = uint32(start)\n\t\tfor nrf.NVMC.READY == 0 {\n\t\t}\n\n\t\tnrf.NVMC.WRITE = uint32(start)\n\t\tfor nrf.NVMC.READY == 0 {\n\t\t}\n\n\t\t// Wait for the flash memory to be ready.\n\t\tfor nrf.NVMC.READY == 0 {\n\t\t}\n\n\t\t// Advance to the next block.\n\t\tstart += f.WriteBlockSize()\n\t\tp = p[f.WriteBlockSize():]\n\t}\n\n\t// Disable write mode on the flash memory controller.\n\tnrf.NVMC.CONFIG = nrf.NVMC_CONFIG_WEN_Ren\n\tfor nrf.NVMC.READY == 0 {\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 32.16869445517843}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds.\n\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, nrf.Errorf(nrf.ErrorCodeBadInput, \"WriteAt: write operation exceeds flash memory bounds\")\n\t}\n\n\t// Calculate the start address for writing.\n\tstartAddr := f.baseAddr + uint32(off)\n\n\t// Pad the byte slice to fit the write block size.\n\tif len(p)%int(f.writeBlockSize) != 0 {\n\t\tp = append(p, make([]byte, int(f.writeBlockSize)-len(p)%int(f.writeBlockSize))...)\n\t}\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.Config.SetBits(nrf.NVMC_CONFIG_WEN_Wen)\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(p); i += int(f.writeBlockSize) {\n\t\t// Wait for the flash memory to be ready.\n\t\tfor nrf.NVMC.Ready.Get() == 0 {\n\t\t}\n\n\t\t// Write the data.\n\t\tnrf.NVMC.Addr.Set(startAddr + uint32(i))\n\t\tnrf.NVMC.Write.Set(binary.LittleEndian.Uint32(p[i : i+int(f.writeBlockSize)]))\n\t}\n\n\t// Wait for the flash memory to be ready.\n\tfor nrf.NVMC.Ready.Get() == 0 {\n\t}\n\n\t// Disable write mode on the flash memory controller.\n\tnrf.NVMC.Config.SetBits(nrf.NVMC_CONFIG_WEN_Ren)\n\n\t// Return the number of bytes written.\n\treturn len(p), nil\n}", "CodeBleu_score": 36.822044030710984}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory.\n\tfor {\n\t\t// Attempt to open the directory.\n\t\tdir, err := syscall.Fdopendir(dup)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\n\t\t// If the error is anything other than \"syscall.EINTR\", close the duplicated file descriptor and return the error.\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(dup)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 59.08721656836321}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar dir *syscall.Dir\n\tvar err error\n\tvar dupfd syscallFd\n\n\t// Duplicate the file descriptor.\n\tif dupfd, err = syscall.Dup(int(fd)); err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory.\n\tfor {\n\t\tif dir, err = syscall.Fdopendir(int(dupfd)); err != nil {\n\t\t\t// If the error is not an interrupt, return the error.\n\t\t\tif err != syscall.EINTR {\n\t\t\t\tsyscall.Close(int(dupfd))\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\n\t\t\t// Otherwise, try again.\n\t\t\tcontinue\n\t\t}\n\n\t\t// Success.\n\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t}\n}", "CodeBleu_score": 51.47403724638515}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Open the directory using the duplicated file descriptor.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\t// If the error is \"syscall.EINTR\", retry the operation until it succeeds or fails with a different error.\n\t\tfor err == syscall.EINTR {\n\t\t\tdir, err = syscall.Fdopendir(dupFd)\n\t\t}\n\t\t// Close the duplicated file descriptor if an error occurs.\n\t\tif err != nil {\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\t// Return the directory pointer and no error.\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 62.28206075220872}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  uint32_t size = 0;\n  const esp_partition_t *partition = esp_ota_get_running_partition();\n  if (partition != NULL) {\n    if (response == FREE_SKETCH_SPACE) {\n      size = partition->size - partition->address;\n    } else {\n      size = partition->size;\n    }\n  }\n  return size;\n}", "CodeBleu_score": 38.239179597912695}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n\tuint32_t sketchSize = 0;\n\tuint32_t freeSketchSpace = 0;\n\n\tconst esp_partition_t* partition = esp_ota_get_running_partition();\n\n\tif (partition == NULL) {\n\t\treturn 0;\n\t}\n\n\tconst esp_partition_t* ota_data_partition = esp_ota_get_next_update_partition(NULL);\n\n\tif (ota_data_partition == NULL) {\n\t\treturn 0;\n\t}\n\n\tconst esp_partition_t* ota_data_partition_2 = esp_ota_get_next_update_partition(ota_data_partition);\n\n\tif (ota_data_partition_2 == NULL) {\n\t\treturn 0;\n\t}\n\n\tconst esp_partition_t* ota_data_partition_3 = esp_ota_get_next_update_partition(ota_data_partition_2);\n\n\tif (ota_data_partition_3 == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (response == FREE_SKETCH_SPACE) {\n\n\t\tuint32_t ota_data_partition_2_size = ota_data_partition_2->size;\n\t\tuint32_t ota_data_partition_3_size = ota_data_partition_3->size;\n\n\t\tfreeSketchSpace = ota_data_partition_2_size + ota_data_partition_3_size;\n\n\t\treturn freeSketchSpace;\n\n\t} else {\n\n\t\tuint32_t ota_data_partition_size = ota_data_partition->size;\n\n\t\tsketchSize = ota_data_partition_size;\n\n\t\treturn sketchSize;\n\n\t}\n\n}", "CodeBleu_score": 34.50698346840804}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    esp_partition_t *partition = esp_ota_get_running_partition();\n    if (partition == nullptr) {\n        return 0;\n    }\n\n    const esp_partition_t *running = esp_ota_get_running_partition();\n    esp_image_header_t *header = (esp_image_header_t *)running->address;\n    if (header->magic != ESP_IMAGE_HEADER_MAGIC) {\n        return 0;\n    }\n\n    if (response == SKETCH_SIZE_FREE) {\n        return partition->size - (header->image.data_len + sizeof(esp_image_header_t));\n    }\n\n    return header->image.data_len + sizeof(esp_image_header_t);\n}", "CodeBleu_score": 43.587442204930525}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t disk_sectors;\n    uint32_t disk_size;\n    uint32_t fat_sectors;\n    uint32_t fat_size;\n    uint32_t fat_offset;\n    uint32_t root_dir_sectors;\n    uint32_t root_dir_size;\n    uint32_t root_dir_offset;\n    uint32_t data_offset;\n    uint32_t data_size;\n    uint32_t disk_sector_size;\n    uint32_t disk_sector_count;\n    uint8_t *disk;\n\n    /*\n     * Calculate the number of sectors required for the disk.\n     */\n    disk_sectors = (uint32_t)(((uint64_t)FLASH_SECTOR_SIZE * (uint64_t)FLASH_SECTOR_COUNT) / (uint64_t)SECTOR_SIZE);\n\n    /*\n     * Calculate the number of sectors required for the FAT.\n     */\n    fat_sectors = (uint32_t)(((uint64_t)disk_sectors * (uint64_t)FAT_SECTOR_SIZE) / (uint64_t)SECTOR_SIZE);\n\n    /*\n     * Calculate the number of sectors required for the root directory.\n     */\n    root_dir_sectors = (uint32_t)(((uint64_t)disk_sectors * (uint64_t)ROOT_DIR_SECTOR_SIZE) / (uint64_t)SECTOR_SIZE);\n\n    /*\n     * Calculate the number of sectors required for the data area.\n     */\n    data_size = (uint32_t)(((uint64_t)disk_sectors * (uint64_t)SECTOR_SIZE) - ((uint64_t)fat_sectors * (uint64_t)SECTOR_SIZE) - ((uint64_t)root_dir_sectors * (uint64_t)", "CodeBleu_score": 19.467529496454645}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t disk_sectors;\n    uint32_t fat_sectors;\n    uint32_t fat_size;\n    uint32_t root_dir_sectors;\n    uint32_t root_dir_entries;\n    uint32_t root_dir_size;\n    uint32_t data_sectors;\n    uint32_t data_size;\n    uint32_t disk_size;\n    uint8_t *disk_ptr;\n    uint8_t *fat_ptr;\n    uint8_t *root_dir_ptr;\n    uint8_t *data_ptr;\n    uint32_t sector_number;\n    uint32_t cluster_number;\n    uint32_t cluster_size;\n    uint32_t cluster_count;\n    uint32_t cluster_offset;\n    uint32_t cluster_index;\n    uint32_t cluster_value;\n    uint32_t entry_index;\n    uint32_t entry_offset;\n    uint32_t entry_offset_next;\n    uint32_t entry_size;\n    uint32_t entry_size_next;\n    uint32_t entry_size_remaining;\n    uint32_t entry_size_remaining_next;\n    uint32_t entry_cluster_index;\n    uint32_t entry_cluster_index_next;\n    uint32_t entry_cluster_offset;\n    uint32_t entry_cluster_offset_next;\n    uint32_t entry_cluster_value;\n    uint32_t entry_cluster_value_next;\n    uint32_t entry_cluster_value_next_next;\n    uint32_t entry_cluster_value_last;\n    uint32_t entry_cluster_value_last_next;\n    uint32_t entry_cluster_value_last_next_next;\n    uint32_t entry_cluster_value_last_next_next_next;\n    uint32_t entry_cluster_value_last_next_next", "CodeBleu_score": 8.581296881067493}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t disk_sectors;\n    uint32_t disk_size;\n    uint32_t fat_sectors;\n    uint32_t fat_size;\n    uint32_t fat_entries;\n    uint32_t root_dir_sectors;\n    uint32_t root_dir_size;\n    uint32_t root_dir_entries;\n    uint32_t data_sectors;\n    uint32_t data_size;\n    uint32_t root_dir_cluster;\n    uint32_t root_dir_first_sector;\n    uint32_t root_dir_last_sector;\n    uint32_t data_first_sector;\n    uint32_t data_last_sector;\n    uint32_t fat_first_sector;\n    uint32_t fat_last_sector;\n    uint32_t i;\n    uint32_t j;\n    uint32_t k;\n    uint32_t l;\n    uint8_t *disk;\n    uint8_t *fat;\n    uint8_t *root_dir;\n    uint8_t *data;\n    uint32_t *fat_entry;\n    uint32_t *root_dir_entry;\n    uint32_t *fat_entry_ptr;\n    uint32_t *root_dir_entry_ptr;\n    uint32_t *data_entry_ptr;\n    uint32_t *fat_entry_ptr_next;\n    uint32_t *root_dir_entry_ptr_next;\n    uint32_t *data_entry_ptr_next;\n    uint32_t *fat_entry_ptr_prev;\n    uint32_t *root_dir_entry_ptr_prev;\n    uint32_t *data_entry_ptr_prev;\n    uint32_t *fat_entry_ptr_next_next;\n    uint32_t *root_dir_entry_ptr_next_next;\n    uint3", "CodeBleu_score": 8.178398157259743}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Erase failed at 0x%08x\", offset);\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Write failed at 0x%08x\", offset);\n        return err;\n    }\n    return err;\n}", "CodeBleu_score": 62.92845041190909}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    size_t aligned_size = (size + (partition->address % SPI_FLASH_SEC_SIZE) + SPI_FLASH_SEC_SIZE - 1) & ~(SPI_FLASH_SEC_SIZE - 1);\n    if (aligned_size != size) {\n        ESP_LOGE(TAG, \"write size is not aligned with flash sector size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n    err = esp_partition_erase_range(partition, offset, aligned_size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"erase failed (0x%x)\", err);\n        return err;\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"write failed (0x%x)\", err);\n        return err;\n    }\n    return err;\n}", "CodeBleu_score": 54.79173757766429}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\n    esp_err_t err;\n    size_t aligned_size;\n    uint32_t aligned_offset;\n    uint8_t *buf;\n\n    ESP_LOGD(TAG, \"msc_update_write: offset: %d, size: %d\", offset, size);\n\n    if ((offset % SPI_FLASH_SEC_SIZE) != 0) {\n        aligned_size = (offset + size + SPI_FLASH_SEC_SIZE - 1) & ~(SPI_FLASH_SEC_SIZE - 1);\n        aligned_offset = aligned_size - size;\n        ESP_LOGD(TAG, \"msc_update_write: aligned_size: %d, aligned_offset: %d\", aligned_size, aligned_offset);\n        buf = (uint8_t *)malloc(aligned_size);\n        if (buf == NULL) {\n            ESP_LOGE(TAG, \"msc_update_write: malloc failed\");\n            return ESP_FAIL;\n        }\n        memset(buf, 0xFF, aligned_size);\n        memcpy(&buf[aligned_offset], data, size);\n        err = esp_partition_erase_range(partition, 0, aligned_size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"msc_update_write: erase failed (%s)\", esp_err_to_name(err));\n            free(buf);\n            return err;\n        }\n        err = esp_partition_write(partition, 0, buf, aligned_size);\n        free(buf);\n        return err;\n    } else {\n        err = esp_partition_erase_range(partition, offset, size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"msc_update_write: erase failed (%s)\", esp_err_to_name(err));\n            return err;\n        }\n        err = esp_partition_write(partition, offset, data, size);\n        return err;\n    }\n}", "CodeBleu_score": 53.84999267710311}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t len = 0;\n\n  for (;;) {\n    int b;\n\n    if (*in == '\\0') {\n      break;\n    }\n\n    if ((b = hex2byte(in)) < 0) {\n      in++;\n      continue;\n    }\n\n    if (len >= maxlen) {\n      break;\n    }\n\n    out[len] = b;\n    len++;\n    in += 2;\n  }\n\n  return len;\n}", "CodeBleu_score": 43.312670151540864}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i;\n    size_t j;\n    size_t len;\n    unsigned char c;\n\n    len = 0;\n    j = 0;\n    for (i = 0; in[i] != '\\0'; i++) {\n        c = in[i];\n        if (c >= '0' && c <= '9') {\n            c -= '0';\n        } else if (c >= 'a' && c <= 'f') {\n            c = c - 'a' + 10;\n        } else if (c >= 'A' && c <= 'F') {\n            c = c - 'A' + 10;\n        } else {\n            continue;\n        }\n        if (j == 0) {\n            out[len] = c << 4;\n        } else {\n            out[len] |= c;\n            len++;\n        }\n        j = (j + 1) & 1;\n        if (len >= maxlen) {\n            return len;\n        }\n    }\n    return len;\n}", "CodeBleu_score": 44.97336004857557}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i, j;\n\tfor (i = 0, j = 0; in[i] && j < maxlen; i += 2, j++) {\n\t\tif (!isxdigit(in[i])) continue;\n\t\tif (!isxdigit(in[i + 1])) continue;\n\t\tout[j] = (hex2byte(in[i]) << 4) | hex2byte(in[i + 1]);\n\t}\n\treturn j;\n}", "CodeBleu_score": 38.55705662317271}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_buffer == NULL || tx_lock == NULL)\n\t\treturn 0;\n\tif (xSemaphoreTake(tx_lock, 10) == pdTRUE) {\n\t\tint size = ringBuffer.free(tx_buffer);\n\t\txSemaphoreGive(tx_lock);\n\t\treturn size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 58.564335502891886}, {"code": "int HWCDC::availableForWrite(void){\n\t\tint size;\n\n\tif (txRingBuffer == NULL)\n\t\treturn 0;\n\n\tif (txRingBuffer->lock == NULL)\n\t\treturn 0;\n\n\tif (xSemaphoreTake(txRingBuffer->lock, 1000 / portTICK_PERIOD_MS) != pdTRUE)\n\t\treturn 0;\n\n\tsize = txRingBuffer->size - xRingbufferGetCurFreeSize(txRingBuffer->buffer);\n\n\txSemaphoreGive(txRingBuffer->lock);\n\n\treturn size;\n}", "CodeBleu_score": 40.72590760029519}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (!_tx_buffer) return 0;\n\tif (!_tx_buffer_lock) return 0;\n\tif (xSemaphoreTake(_tx_buffer_lock, 100) == pdTRUE) {\n\t\tint ret = _tx_buffer->availableForStore();\n\t\txSemaphoreGive(_tx_buffer_lock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 46.38420555225366}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n\tif (function) {\n\n\t\t_onReceiveCB = function;\n\n\t\t_rxTimeout = onlyOnTimeout;\n\n\t\t_rx_buffer_head = 0;\n\n\t\t_rx_buffer_tail = 0;\n\n\t\t_rx_buffer_max_count = UART_FIFO_LEN;\n\n\t\t_rx_buffer_count = 0;\n\n\t\t_rx_buffer_overflow = false;\n\n\t\t_rx_buffer_full_count = 0;\n\n\t\t_rx_buffer_full_count_last = 0;\n\n\t\t_rx_buffer_full_count_max = 0;\n\n\t\t_rx_buffer_full_count_max_last = 0;\n\n\t\t_rx_buffer_full_count_max_last_time = 0;\n\n\t\t_rx_buffer_full_count_max_last_time_last = 0;\n\n\t\t_rx_buffer_full_count_max_last_time_last_last = 0;\n\n\t\t_rx_buffer_full_count_max_last_time_last_last_last = 0;\n\n\t\t_rx_buffer_full_count_max_last_time_last_last_last_last = 0;\n\n\t\t_rx_buffer_full_count_max_last_time_last_last_last_last_last = 0;\n\n\t\t_rx_buffer_full_count_max_last_time_last_last_last_last_last_last = 0;\n\n\t\t_rx_buffer_full_count_max_last_time_last_last_last_last_last_last_last = 0;\n\n\t\t_rx_buffer_full_count_max_last_time_last_last_last_last_last_last_last_last = 0;\n\n\t\t_rx_buffer_full_count_max_last_time_last_last_last_last_last_last_last_last_last = 0;\n\n\t\t_rx_buffer_full_count_max_last_time_last_last_", "CodeBleu_score": 17.28438683460159}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n    if (function) {\n\n        _onReceiveCB = function;\n\n        _rxTimeout = onlyOnTimeout;\n\n        _rx_buffer_size = 64;\n\n        _rx_buffer_head = _rx_buffer_tail = 0;\n\n        uart_set_rx_thr_len(_uart_num, _rx_buffer_size);\n\n        if (!_event_queue) {\n\n            _event_queue = xQueueCreate(1, sizeof(uint32_t));\n\n            xTaskCreate(HardwareSerial::_eventTask, \"uart_event_task\", 2048, this, 1, &_task_handle);\n\n        }\n\n    } else {\n\n        _onReceiveCB = NULL;\n\n        _rxTimeout = false;\n\n        _rx_buffer_size = 0;\n\n        _rx_buffer_head = _rx_buffer_tail = 0;\n\n        uart_set_rx_thr_len(_uart_num, 0);\n\n        if (_event_queue) {\n\n            vQueueDelete(_event_queue);\n\n            _event_queue = NULL;\n\n        }\n\n    }\n\n}", "CodeBleu_score": 42.44454798533136}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n    _mutex->lock();\n\n    _onReceiveCB = function;\n\n    _rxTimeout = onlyOnTimeout;\n\n    if (function) {\n\n        uart_set_rx_thr_len(uart_num, 1);\n\n        if (!_eventTaskHandle) {\n\n            xTaskCreatePinnedToCore(eventTask, \"uart_event_task\", 2048, (void *)this, 2, &_eventTaskHandle, 0);\n\n        }\n\n    }\n\n    _mutex->unlock();\n\n}", "CodeBleu_score": 38.834557465303305}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\twhile (1) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator || index == length - 1) {\n\t\t\tbuffer[index] = 0;\n\t\t\treturn index;\n\t\t}\n\t\tbuffer[index++] = (char)c;\n\t}\n}", "CodeBleu_score": 65.40043518859069}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) return 0;\n  size_t index = 0;\n  while (1) {\n    int c = timedRead();\n    if (c < 0 || c == terminator || index == length - 1) {\n      buffer[index] = (char)c;\n      buffer[index + 1] = '\\0';\n      return index + 1;\n    }\n    buffer[index] = (char)c;\n    index++;\n  }\n}", "CodeBleu_score": 71.58310356618604}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer = (char)c;\n\t\tindex++;\n\t\tbuffer++;\n\t}\n\t*buffer = 0;\n\treturn index;\n}", "CodeBleu_score": 80.60997043280199}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\n\tSerial.print(\"Tone: \");\n\tSerial.print(pin);\n\tSerial.print(\", \");\n\tSerial.print(frequency);\n\tSerial.print(\", \");\n\tSerial.println(duration);\n\n\tif (pin == 25) {\n\t\tSerial.println(\"Tone Error: Pin 25 is reserved for the speaker.\");\n\t\treturn;\n\t}\n\n\tif (tone_pins[pin] == 0) {\n\t\ttone_pins[pin] = 1;\n\t\ttone_queue.send(pin, frequency, duration);\n\t} else {\n\t\tSerial.println(\"Tone Error: Pin is already in use.\");\n\t}\n}", "CodeBleu_score": 36.83596057389577}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\n  Serial.println(\"tone\");\n\n  Serial.println(pin);\n\n  Serial.println(frequency);\n\n  Serial.println(duration);\n\n  if (pin == 0) {\n\n    Serial.println(\"tone: pin is 0\");\n\n    return;\n\n  }\n\n  if (pin == 1) {\n\n    Serial.println(\"tone: pin is 1\");\n\n    return;\n\n  }\n\n  if (pin == 3) {\n\n    Serial.println(\"tone: pin is 3\");\n\n    return;\n\n  }\n\n  if (pin == 4) {\n\n    Serial.println(\"tone: pin is 4\");\n\n    return;\n\n  }\n\n  if (pin == 5) {\n\n    Serial.println(\"tone: pin is 5\");\n\n    return;\n\n  }\n\n  if (pin == 6) {\n\n    Serial.println(\"tone: pin is 6\");\n\n    return;\n\n  }\n\n  if (pin == 7) {\n\n    Serial.println(\"tone: pin is 7\");\n\n    return;\n\n  }\n\n  if (pin == 8) {\n\n    Serial.println(\"tone: pin is 8\");\n\n    return;\n\n  }\n\n  if (pin == 9) {\n\n    Serial.println(\"tone: pin is 9\");\n\n    return;\n\n  }\n\n  if (pin == 10) {\n\n    Serial.println(\"tone: pin is 10\");\n\n    return;\n\n  }\n\n  if (pin == 11) {\n\n    Serial.println(\"tone: pin is 11\");\n\n    return;\n\n  }\n\n  if (pin == 12) {\n\n    Serial.println(\"tone: pin is 12\");\n\n    return;\n\n  }\n\n  if (pin == 13) {\n\n    Serial.println(\"tone: pin is 13\");\n\n    return;\n\n  }\n\n  if (pin == 14) {", "CodeBleu_score": 27.352138843929747}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    Serial.println(\"tone\");\n    Serial.println(pin);\n    Serial.println(frequency);\n    Serial.println(duration);\n    if (pin == 21 || pin == 22) {\n        Serial.println(\"Pin is available\");\n        ledcSetup(0, frequency, 8);\n        ledcAttachPin(pin, 0);\n        ledcWrite(0, 127);\n        delay(duration);\n        ledcWrite(0, 0);\n    }\n    else {\n        Serial.println(\"Pin is in use\");\n    }\n}", "CodeBleu_score": 33.98135685693596}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usbStarted) {\n\t\tif (enabled) {\n\t\t\tif (webUSBEnabled) return false;\n\t\t\twebUSBEnabled = true;\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\tusbVersion = 0x0210;\n\t\t\t}\n\t\t} else {\n\t\t\twebUSBEnabled = false;\n\t\t}\n\t\treturn false;\n\t}\n\twebUSBEnabled = enabled;\n\tif (enabled) {\n\t\tif (usbVersion < 0x0210) {\n\t\t\tusbVersion = 0x0210;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 50.934232990105954}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (usb.getVersion() < 0x0210) {\n    if (enabled) {\n      return true;\n    }\n  }\n  if (enabled) {\n    usb.webUSB();\n  }\n  else {\n    usb.disableWebUSB();\n  }\n  return false;\n}", "CodeBleu_score": 41.17224369783423}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (enabled) {\n\t\tif (!_usbStarted) {\n\t\t\t_webUSB = true;\n\t\t\treturn true;\n\t\t}\n\t\tif (_usbVersion < 0x0210) {\n\t\t\t_usbVersion = 0x0210;\n\t\t}\n\t\t_webUSB = true;\n\t\treturn false;\n\t}\n\t_webUSB = false;\n\treturn false;\n}", "CodeBleu_score": 45.609573311641775}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint32_t bytesRead = 0;\n\tuint32_t bytesDropped = 0;\n\tuint32_t bytesToRead = _rxBuffer.size();\n\tuint32_t bytesAvailable = 0;\n\tuint8_t byte = 0;\n\twhile (bytesRead < bytesToRead) {\n\t\tbytesAvailable = _rxBuffer.availableForStore();\n\t\tif (bytesAvailable == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!_rxBuffer.store_char(byte)) {\n\t\t\tbytesDropped++;\n\t\t} else {\n\t\t\tbytesRead++;\n\t\t}\n\t}\n\tif (bytesDropped > 0) {\n\t\t_eventHandler->postOverflowEvent(bytesDropped);\n\t\t_log.error(\"Overflow: %d bytes dropped\n\", bytesDropped);\n\t}\n\tif (bytesRead > 0) {\n\t\t_eventHandler->postRXEvent(bytesRead);\n\t}\n}", "CodeBleu_score": 26.883410029347267}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t buf[64];\n\tint len;\n\tint overflow = 0;\n\twhile (1) {\n\t\tlen = usb_serial_read(buf, 64);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tif (rx_queue.push_back(buf, len)) {\n\t\t\toverflow += len;\n\t\t} else {\n\t\t\t// Queue is full\n\t\t\toverflow += len;\n\t\t\tif (overflow > 0) {\n\t\t\t\tUSBCDC_EVENT_OVERFLOW(overflow);\n\t\t\t\toverflow = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (overflow > 0) {\n\t\tUSBCDC_EVENT_OVERFLOW(overflow);\n\t}\n\tif (len > 0) {\n\t\tUSBCDC_EVENT_RECEIVE(len);\n\t}\n}", "CodeBleu_score": 17.05866735644985}, {"code": "void USBCDC::_onRX(){\n\t    uint8_t buf[CDC_BUFFER_SIZE];\n    uint32_t bytesRead = 0;\n    uint32_t droppedBytes = 0;\n\n    while (bytesRead < CDC_BUFFER_SIZE) {\n        uint8_t c = CDC_ReceiveByte();\n\n        if (c == 0) {\n            break;\n        }\n\n        if (bytesRead < CDC_BUFFER_SIZE) {\n            buf[bytesRead] = c;\n            bytesRead++;\n        } else {\n            droppedBytes++;\n        }\n    }\n\n    if (bytesRead > 0) {\n        if (queue_write_length(_rxQueue) >= bytesRead) {\n            queue_write_array(_rxQueue, buf, bytesRead);\n            queue_commit_write(_rxQueue);\n            _postEvent(USBCDC_EVENT_RX, bytesRead);\n        } else {\n            queue_free(_rxQueue);\n            _rxQueue = NULL;\n            _postEvent(USBCDC_EVENT_OVERFLOW, droppedBytes);\n            error(\"USBCDC: RX overflow, dropped %d bytes\n\", droppedBytes);\n        }\n    }\n}", "CodeBleu_score": 30.34574546885203}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\n\tname := req.URL.Query().Get(\":name\")\n\n\tif a.robot(name) == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, `{\"error\": \"No robot found with the name %q\"}`, name)\n\t\treturn\n\t}\n\n\tvar devices []*robeaux.Device\n\tfor _, device := range a.robot(name).Devices() {\n\t\tdevices = append(devices, &robeaux.Device{\n\t\t\tName: device.Name(),\n\t\t\tCommands: device.Commands(),\n\t\t\tEvents: device.Events(),\n\t\t})\n\t}\n\n\tif err := json.NewEncoder(res).Encode(devices); err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, `{\"error\": \"Error encoding devices for robot %q\"}`, name)\n\t\treturn\n\t}\n}", "CodeBleu_score": 47.799518423328855}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\":name\")\n\tif name == \"\" {\n\t\thttp.Error(res, \"No robot name specified\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ta.robotLock.RLock()\n\tdefer a.robotLock.RUnlock()\n\n\tif _, ok := a.robots[name]; !ok {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot found with name %s\", name), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices := []*robeaux.Device{}\n\n\tfor _, device := range a.robots[name].Devices() {\n\t\tdevices = append(devices, &robeaux.Device{\n\t\t\tName: device.Name(),\n\t\t\tType: device.Driver().Name(),\n\t\t})\n\t}\n\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 46.759453534125825}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL\n\trobotName := req.URL.Query().Get(\":robot\")\n\n\t// Check if a robot with the given name exists\n\tif _, ok := a.robots[robotName]; !ok {\n\t\t// If no robot with the given name exists, return a JSON response with an error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"{\\\"error\\\": \\\"No robot found with name %s\\\"}\", robotName)))\n\t\treturn\n\t}\n\n\t// Gather the robot's devices into a JSON format\n\trobotDevices := make(map[string]interface{})\n\tfor _, device := range a.robots[robotName].Devices() {\n\t\trobotDevices[device.Name()] = device.Connection()\n\t}\n\n\t// Write the JSON response to the HTTP response writer\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(robotDevices)\n}", "CodeBleu_score": 43.340029084084435}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\trobot := a.findRobot(name)\n\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with the name '%s' was found\", name)\n\t\treturn\n\t}\n\n\tvar connections []robeaux.Connection\n\tfor _, c := range robot.Connections() {\n\t\tconnections = append(connections, robeaux.Connection{\n\t\t\tName: c.Name(),\n\t\t\tType: c.Type(),\n\t\t})\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 46.17223019743975}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Path[len(\"/robot/\"):]\n\n\tfor _, robot := range a.robots {\n\t\tif robot.Name() == robotName {\n\t\t\tdata, err := json.Marshal(robot.Connections())\n\t\t\tif err != nil {\n\t\t\t\ta.sendError(res, req, fmt.Sprintf(\"error: %v\", err))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tres.Write(data)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.sendError(res, req, fmt.Sprintf(\"error: no robot with name %q found\", robotName))\n}", "CodeBleu_score": 34.8278193015156}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\n\tif robot, ok := a.robots[name]; ok {\n\t\tvar connections []map[string]interface{}\n\t\tfor _, c := range robot.Connections() {\n\t\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\t\"name\": c.Name(),\n\t\t\t\t\"port\": c.Port(),\n\t\t\t\t\"url\":  c.URL(),\n\t\t\t})\n\t\t}\n\n\t\tif err := json.NewEncoder(res).Encode(connections); err != nil {\n\t\t\tlog.Println(err)\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t}\n\t} else {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with name %s found\n\", name)\n\t}\n}", "CodeBleu_score": 45.5490341482385}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the device exists\n\tif _, ok := a.robots[robotName].Devices()[deviceName]; !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Device %s does not exist\", deviceName)))\n\t\treturn\n\t}\n\n\t// Retrieve the command name from the URL query parameters\n\tcommandName := req.URL.Query().Get(\"command\")\n\n\t// Retrieve the command parameters from the URL query parameters\n\tparams := req.URL.Query()\n\tfor k, v := range params {\n\t\tif strings.HasPrefix(k, \"param\") {\n\t\t\tdelete(params, k)\n\t\t\tparams[k[5:]] = v\n\t\t}\n\t}\n\n\t// Execute the command on the device\n\tif err := a.robots[robotName].Devices()[deviceName].Command(commandName, params); err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(fmt.Sprintf(\"Error executing command: %s\", err.Error())))\n\t\treturn\n\t}\n\n\t// Write a JSON response indicating the command was executed successfully\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(\"Command executed successfully\"))\n}", "CodeBleu_score": 47.45661331914229}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tvar (\n\t\trobotName  = req.URL.Query().Get(\":robot\")\n\t\tdeviceName = req.URL.Query().Get(\":device\")\n\t\tcommand    = req.URL.Query().Get(\":command\")\n\t)\n\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"Robot %s not found\", robotName)\n\t\treturn\n\t}\n\n\tdevice, ok := robot.Device(deviceName)\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"Device %s not found\", deviceName)\n\t\treturn\n\t}\n\n\tif err := device.Command(command); err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"Error executing command %s on device %s: %v\", command, deviceName, err)\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(res, \"Executed command %s on device %s\", command, deviceName)\n}", "CodeBleu_score": 38.17008145274187}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\t// Check if the device exists\n\tif _, ok := a.robots[robotName]; !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Robot %s not found\", robotName)))\n\t\treturn\n\t}\n\tif _, ok := a.robots[robotName].Devices()[deviceName]; !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Device %s not found\", deviceName)))\n\t\treturn\n\t}\n\t// Retrieve the command name from the URL path\n\tcommandName := strings.TrimPrefix(req.URL.Path, \"/robot/\")\n\tcommandName = strings.TrimSuffix(commandName, \"/\")\n\t// Execute the command on the device using the Gobot framework\n\tcommand, err := a.robots[robotName].Devices()[deviceName].Command(commandName)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Command %s not found\", commandName)))\n\t\treturn\n\t}\n\tif err := command.Start(); err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(fmt.Sprintf(\"Error executing command: %s\", err)))\n\t\treturn\n\t}\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(\"Command executed\"))\n}", "CodeBleu_score": 46.58293563087719}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif !checkAuth(r, username, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.52400946158057}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := string(b)\n\t\ti := byte(0)\n\t\tfor j := 0; j < len(pair); j++ {\n\t\t\tif pair[j] == ':' {\n\t\t\t\ti = byte(j)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif i == 0 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tu, p := pair[:i], pair[i+1:]\n\t\tif subtle.ConstantTimeCompare([]byte(u), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(p), []byte(password)) != 1 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Call the next handler, which can be another middleware in the chain, or the final handler.\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 48.305937682000106}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tconst prefix = \"Basic \"\n\t\tif !strings.HasPrefix(auth, prefix) {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tc, err := base64.StdEncoding.DecodeString(auth[len(prefix):])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(c), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pair[1]), []byte(password)) != 1 {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Authorized\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 47.915378358490024}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\tif !a.connection.AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"Analog read not supported\")\n\t}\n\tvalue, err := a.connection.AnalogReadValue()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tscaledValue := float64(value) / float64(a.scale)\n\ta.lastRead = time.Now()\n\treturn value, scaledValue, nil\n}", "CodeBleu_score": 46.562239840549616}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"no connection\")\n\t}\n\tif !a.connection.AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog read failed: %v\", err)\n\t}\n\tscaled := a.scaleAnalogValue(raw)\n\ta.lastRawValue = raw\n\ta.lastScaledValue = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 45.55539597793846}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"Analog reading is not supported by this connection\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scale(raw)\n\n\ta.lastRead = time.Now()\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.68752975982326}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:  pin,\n\t\tconnection: &gobot.AnalogSensor{\n\t\t\tname:  gobot.DefaultName(\"AnalogSensor\"),\n\t\t\tpin:   pin,\n\t\t\tboard: a.(gobot.Adaptor),\n\t\t},\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase string:\n\t\t\td.name = option.(string)\n\t\tcase []int:\n\t\t\td.calibrate(option.([]int))\n\t\t}\n\t}\n\n\td.connection.Init()\n\n\treturn d\n}", "CodeBleu_score": 37.490776641918586}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:  pin,\n\t\tconn: a,\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase WithName:\n\t\t\td.name = option.(WithName).Name()\n\t\t}\n\t}\n\n\td.mutex = &sync.Mutex{}\n\n\treturn d\n}", "CodeBleu_score": 38.92330301092319}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tconnector: &gobot.DigitalReader{\n\t\t\tname:  \"GroveSoundSensor\",\n\t\t\tpin:   pin,\n\t\t\tboard: a.(gobot.Adaptor),\n\t\t},\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase string:\n\t\t\td.name = option.(string)\n\t\tcase []int:\n\t\t\td.voltageRange = option.([]int)\n\t\t}\n\t}\n\n\treturn d\n}", "CodeBleu_score": 36.78773684329785}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(CommandReg, SoftReset)\n\ttime.Sleep(time.Millisecond * 10)\n\tvalue := d.readRegister(CommandReg)\n\tif value&0x80 != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 25.211029154888802}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Send the soft reset command to the MFRC522 chip.\n\td.writeRegister(CommandReg, SoftReset)\n\n\t// Wait for the MFRC522 to complete its soft reset.\n\ttime.Sleep(SoftResetDelay)\n\n\t// Read the command register to verify that the MFRC522 has completed its soft reset.\n\tvalue, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"softReset: readRegister(CommandReg): %w\", err)\n\t}\n\n\t// Return an error if the MFRC522 hasn't completed its soft reset.\n\tif value&0x80 == 0x80 {\n\t\treturn fmt.Errorf(\"softReset: soft reset not completed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 48.94886561041082}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(CommandReg, SoftResetCommand)\n\ttime.Sleep(100 * time.Millisecond)\n\tvalue, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif value&0x80 != 0x0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.491990064547544}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Read the number of bytes currently in the FIFO\n\tvar n, err = d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// The FIFO buffer size is 64 bytes.\n\tif n > 64 {\n\t\treturn 0, fmt.Errorf(\"FIFO overflow\")\n\t}\n\n\t// Check if the requested number of bytes is available\n\tif n < len(backData) {\n\t\treturn 0, fmt.Errorf(\"Not enough data available in FIFO buffer. Requested %d, available %d\", len(backData), n)\n\t}\n\n\t// Read the received data from the FIFO buffer\n\tfor i := 0; i < len(backData); i++ {\n\t\tvar b, err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = b\n\t}\n\n\t// Read the last bits received\n\treturn d.readRegister(ControlReg) & 0x07, nil\n}", "CodeBleu_score": 45.981158860707694}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Get the number of bytes currently in the FIFO\n\tvar length uint8\n\tvar err error\n\tif length, err = d.readRegister(FIFOLevelReg); err != nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: error reading FIFO length: %v\", err)\n\t}\n\n\t// Check if the requested number of bytes is available in the FIFO\n\tif length > len(backData) {\n\t\treturn 0, fmt.Errorf(\"readFifo: FIFO length %d is greater than the number of bytes requested %d\", length, len(backData))\n\t}\n\n\t// Read the FIFO into the byte slice\n\tfor i := 0; i < int(length); i++ {\n\t\tvar b byte\n\t\tif b, err = d.readRegister(FIFODataReg); err != nil {\n\t\t\treturn 0, fmt.Errorf(\"readFifo: error reading FIFO data: %v\", err)\n\t\t}\n\t\tbackData[i] = b\n\t}\n\n\t// Read the control register to get the last bits received\n\tvar value uint8\n\tif value, err = d.readRegister(ControlReg); err != nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: error reading control register: %v\", err)\n\t}\n\treturn value, nil\n}", "CodeBleu_score": 44.91066840113381}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tvar err error\n\tvar length int\n\tvar value uint8\n\n\t// Read the number of bytes currently in the FIFO\n\tlength, err = d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: readRegister: %w\", err)\n\t}\n\n\t// Check if the requested number of bytes are available in the FIFO\n\tif length > len(backData) {\n\t\treturn 0, fmt.Errorf(\"readFifo: FIFO length %d exceeds provided buffer length %d\", length, len(backData))\n\t}\n\n\t// Read the bytes from the FIFO\n\tfor i := 0; i < length; i++ {\n\t\tvalue, err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"readFifo: readRegister: %w\", err)\n\t\t}\n\t\tbackData[i] = value\n\t}\n\n\t// Read the last bits received\n\tvalue, err = d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: readRegister: %w\", err)\n\t}\n\n\treturn value, nil\n}", "CodeBleu_score": 46.58251498404018}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.debugPrint(\"Halt\")\n\n\t// Create and send the command\n\tcmd := []byte{CMD_HLTA}\n\td.write(cmd)\n\n\t// Read the response\n\t_, err := d.read(1)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error in communication: %s\", err)\n\t}\n\n\t// Wait 1ms\n\td.delay(1)\n\n\treturn nil\n}", "CodeBleu_score": 21.1135467716045}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.debug(\"piccHalt\")\n\n\t// Build and send the command.\n\tcmd := []byte{d.Command.PICC_HLTA, 0}\n\tif err := d.sendCommand(d.Command.PCD_TRANSCEIVE, cmd, 0); err != nil {\n\t\treturn fmt.Errorf(\"piccHalt: %s\", err)\n\t}\n\n\t// Wait for a response.\n\tif err := d.waitFor(d.Command.PICC_HLTA, 0); err != nil {\n\t\treturn fmt.Errorf(\"piccHalt: %s\", err)\n\t}\n\n\t// Check response length.\n\tif d.lastBits != 0 {\n\t\treturn fmt.Errorf(\"piccHalt: invalid response length\")\n\t}\n\n\t// Check response value.\n\tif d.response[0] != d.Command.PICC_OK {\n\t\treturn fmt.Errorf(\"piccHalt: invalid response value\")\n\t}\n\n\t// Return OK.\n\treturn nil\n}", "CodeBleu_score": 38.80122729212839}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.debug(\"PICC Halt\")\n\tvar err error\n\td.Write([]byte{0x50, 0x02})\n\t_, err = d.Read([]byte{0x00})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"PICC Halt failed: %s\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 26.313431039120637}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build read command.\n\t// Read command = [0x30] + 2-byte block address + CRC_A\n\tcmd := []byte{0x30, 0x00, 0x00, 0x00, 0x00, 0x00}\n\tcmd[1] = block\n\n\t// Calculate CRC_A and append it to the read command.\n\tcrc := d.calcCRC(cmd[:5])\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Transmit the read command and receive 16 bytes of data in the response.\n\tdata, err := d.transmit(cmd, 16)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Verify that the response is a valid read response.\n\t// Response = [0x0A] + 16-byte data + 2-byte CRC_A\n\tif len(data) != 18 {\n\t\treturn nil, fmt.Errorf(\"Invalid read response: %v bytes\", len(data))\n\t}\n\tif data[0] != 0x0A {\n\t\treturn nil, fmt.Errorf(\"Invalid read response: %02x\", data[0])\n\t}\n\n\t// Verify the CRC_A in the response.\n\tcrc = d.calcCRC(data[:17])\n\tif data[17] != crc[0] || data[18] != crc[1] {\n\t\treturn nil, fmt.Errorf(\"Invalid read response: invalid CRC_A\")\n\t}\n\n\t// Return the data.\n\treturn data[1:17], nil\n}", "CodeBleu_score": 37.98151449981486}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build the read command\n\tcmd := []byte{\n\t\tbyte(PICC_CMD_READ),\n\t\tblock,\n\t}\n\n\t// Calculate CRC\n\tcrc := d.calcCRC(cmd)\n\n\t// Add CRC to the command\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Transmit the command and receive the response\n\tresponse, err := d.piccTransmit(cmd)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"piccRead: piccTransmit failed: %v\", err)\n\t}\n\n\t// Check response length\n\tif len(response) != 16 {\n\t\treturn nil, fmt.Errorf(\"piccRead: response length is not 16 bytes\")\n\t}\n\n\t// Return the response\n\treturn response, nil\n}", "CodeBleu_score": 35.80249217550955}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare the command to be sent.\n\t// Address 0x02 is used for reading.\n\t// The command contains the address of the block to be read.\n\t// The command option bits are set to 0b0000 for a read operation.\n\tcmd := []byte{0x02, block}\n\n\t// Calculate CRC_A.\n\tcrc := d.calculateCRC(cmd)\n\n\t// We need to append the CRC_A to the command block.\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Transmit the command and get the response.\n\tresp, err := d.transmit(cmd, 25)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The first byte of the response is the status byte.\n\t// We check this byte to see if the read was successful.\n\tif resp[0] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"Error reading block %d: %s\", block, d.getErrorMessage(resp[0]))\n\t}\n\n\t// Copy the first 16 bytes of the response block to the data buffer.\n\t// Note that we skip the first byte of the response since that is the status byte.\n\tdata := make([]byte, 16)\n\tcopy(data, resp[1:])\n\n\treturn data, nil\n}", "CodeBleu_score": 40.04760349786617}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Check if the answer buffer is large enough to hold the response.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"Answer buffer too small\")\n\t}\n\n\t// Build command buffer\n\tvar cmd []byte\n\tcmd = append(cmd, PICC_CMD_REQA)\n\tif reqMode == PICC_CMD_REQA || reqMode == PICC_CMD_WUPA {\n\t\tcmd = append(cmd, 0x26)\n\t} else {\n\t\tcmd = append(cmd, 0x00)\n\t}\n\n\t// Clear the bit in the Status1 register that indicates a collision.\n\td.WriteRegister(MFRC522_REG_COLL, 0x80)\n\n\t// Transceive the data, store the answer in the answer buffer.\n\t_, err := d.transceive(cmd, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if a collision was detected.\n\tif d.ReadRegister(MFRC522_REG_COLL) & 0x80 == 0 {\n\t\treturn fmt.Errorf(\"Collision detected\")\n\t}\n\n\t// Check the response buffer for a valid response.\n\tif answer[0] != 0x00 || answer[1]&0x0F != 0x0A {\n\t\treturn fmt.Errorf(\"PiccRequest failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 49.05798044875541}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tvar err error\n\tvar length int\n\n\t// Check if the answer buffer is large enough to hold the response.\n\tif len(answer) < 16 {\n\t\treturn fmt.Errorf(\"Answer buffer too small\")\n\t}\n\n\t// Set the command bits.\n\td.writeRegister(CommandReg, PCD_Transceive)\n\n\t// Clear the internal buffer by writing 25 bytes of 0x00.\n\td.writeRegister(WriteDataReg, 0x00)\n\td.writeRegister(FIFOLevelReg, 0x80)\n\n\t// Set the FIFO access bits.\n\td.writeRegister(FIFOLevelReg, 0x70)\n\n\t// Write the request data to the FIFO.\n\td.writeRegister(WriteDataReg, reqMode)\n\td.writeRegister(FIFOLevelReg, 0x81)\n\n\t// Start the transmission.\n\td.writeRegister(CommandReg, PCD_Transceive)\n\n\t// Wait for the FIFO to become empty.\n\tfor {\n\t\tvalue, err := d.readRegister(FIFOLevelReg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif (value & 0x01) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Read the response data from the FIFO.\n\tlength = 0\n\tfor {\n\t\tvalue, err := d.readRegister(FIFOLevelReg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif (value & 0x01) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tvalue, err = d.readRegister(ReadDataReg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tanswer[length] = byte(value & 0x00FF)\n\t\tlength += 1\n\t}\n\n\t// Check if there are any errors.\n\tvalue, err := d.readRegister(Status2Reg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif (value & ", "CodeBleu_score": 50.77710526554002}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Prepare values for BitFramingReg\n\t// The datasheet says:\n\t//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "CodeBleu_score": 3.7344286996483045}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a step\n\terr := d.connection.DigitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\terr = d.connection.DigitalWrite(d.stepPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 67.64262320726742}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.StepPin.DigitalWrite(0)\n\ttime.Sleep(d.StepDelay)\n\td.StepPin.DigitalWrite(1)\n\tif d.Direction == 1 {\n\t\td.StepNumber++\n\t} else {\n\t\td.StepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 33.747625309580556}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.connection.DigitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\terr = d.connection.DigitalWrite(d.stepPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 67.64262320726742}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.stopChannel != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.stopChannel = make(chan bool)\n\td.waitGroup = &sync.WaitGroup{}\n\td.waitGroup.Add(1)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChannel:\n\t\t\t\td.waitGroup.Done()\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.Distance()\n\t\t\t\tif err != nil {\n\t\t\t\t\td.Logger.Error(fmt.Sprintf(\"error while measuring distance: %v\", err))\n\t\t\t\t} else {\n\t\t\t\t\td.Logger.Info(fmt.Sprintf(\"distance: %v\", distance))\n\t\t\t\t}\n\t\t\t\ttime.Sleep(d.interval)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 45.70194255808301}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor is already running\")\n\t}\n\td.distanceMonitorRunning = true\n\td.stopCh = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\tgo d.measureDistance()\n\treturn nil\n}", "CodeBleu_score": 31.90961616926138}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStop = make(chan struct{})\n\td.distanceMonitorWg = &sync.WaitGroup{}\n\td.distanceMonitorWg.Add(1)\n\td.distanceMonitorRunning = true\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStop:\n\t\t\t\td.distanceMonitorWg.Done()\n\t\t\t\treturn\n\t\t\tcase <-time.After(d.distanceMonitorInterval):\n\t\t\t\td.MeasureDistance()\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 44.21116617848213}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := time.Since(start)\n\t\t\td.durationChannel <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 37.99598537015058}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTime time.Time\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := time.Since(startTime)\n\t\t\td.durationChannel <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 38.84768349289519}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstart := time.Now()\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else {\n\t\t\td.pulseDuration <- time.Since(start)\n\t\t}\n\t}\n}", "CodeBleu_score": 35.10091707376959}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif err := d.trig.Write(true); err != nil {\n\t\treturn err\n\t}\n\tif err := d.trig.Write(false); err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-d.done:\n\t\t\treturn fmt.Errorf(\"Measurement interrupted\")\n\t\tcase <-time.After(d.timeout):\n\t\t\treturn fmt.Errorf(\"Measurement timeout\")\n\t\tcase <-d.echo.WaitForEdge(d.timeout):\n\t\t\td.echo.Read()\n\t\t\td.echo.WaitForEdge(d.timeout)\n\t\t\tif err := d.echo.Read(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\td.distance = d.echo.Time().Microseconds()\n\t\t\treturn nil\n\t\t}\n\t}\n}", "CodeBleu_score": 55.81935316124987}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\terr := d.connection.DigitalWrite(d.triggerPin, gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Microsecond)\n\n\terr = d.connection.DigitalWrite(d.triggerPin, gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the sensor to send back the echo\n\terr = d.connection.DigitalRead(d.echoPin)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the echo to start\n\tfor {\n\t\techo, err := d.connection.DigitalRead(d.echoPin)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif echo == gpio.Low {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Wait for the echo to end and measure the time\n\tstart := time.Now()\n\tfor {\n\t\techo, err := d.connection.DigitalRead(d.echoPin)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif echo == gpio.High {\n\t\t\tbreak\n\t\t}\n\t}\n\tend := time.Now()\n\n\td.distance = end.Sub(start).Microseconds()\n\n\treturn nil\n}", "CodeBleu_score": 52.21123677336629}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\terr := d.connection.DigitalWrite(d.trigPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(10 * time.Microsecond)\n\terr = d.connection.DigitalWrite(d.trigPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the echo to go high\n\terr = d.connection.WaitForEdge(d.echoPin, gpio.RisingEdge)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the echo to go low\n\terr = d.connection.WaitForEdge(d.echoPin, gpio.FallingEdge)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Measure the time between the edges\n\td.distanceMicros, err = d.connection.PulseDuration(d.echoPin, time.Microsecond)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 50.87843573388423}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get(\"PLATFORMIO_ACCESS_TOKEN\")\n    if token:\n        return token\n    if self.state and self.state.get(\"access_token\"):\n        return self.state.get(\"access_token\")\n    if self.state and self.state.get(\"refresh_token\"):\n        try:\n            result = self.http_client.post(\n                \"/oauth/token\",\n                data={\n                    \"grant_type\": \"refresh_token\",\n                    \"refresh_token\": self.state.get(\"refresh_token\"),\n                },\n            )\n            self.state[\"access_token\"] = result.get(\"access_token\")\n            self.state[\"expires_at\"] = int(time.time()) + result.get(\"expires_in\")\n            self.state[\"refresh_token\"] = result.get(\"refresh_token\")\n            self.state[\"token_type\"] = result.get(\"token_type\")\n            self.save_state()\n            return self.state.get(\"access_token\")\n        except HTTPClientError as e:\n            if e.code == 400 and e.response.get(\"error\") == \"invalid_grant\":\n                raise UserSideException(\n                    \"Invalid refresh token. Please run 'platformio account unlink' command to remove the local state.\"\n                )\n            raise\n    raise PlatformioException(\n        \"Please login to PlatformIO Account. Run 'platformio account login' command.\"\n    )\n\n", "CodeBleu_score": 40.80521476649193}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get(\"PLATFORMIO_ACCESS_TOKEN\")\n    if token:\n        return token\n\n    if self.state.get(\"access_token\") and self.state.get(\"expires_at\"):\n        expires_at = self.state.get(\"expires_at\")\n        if expires_at > time.time():\n            return self.state.get(\"access_token\")\n\n        refresh_token = self.state.get(\"refresh_token\")\n        if refresh_token:\n            try:\n                self.refresh_authentication_token(refresh_token)\n                return self.state.get(\"access_token\")\n            except HTTPClientError as e:\n                if e.code == 401:\n                    raise UserSideException(\n                        \"Refresh token has expired. Please re-authorize.\"\n                    )\n                raise e\n\n    raise PlatformioException(\n        \"You are not authorized to perform this action. \"\n        \"Please use 'pio account login' to authorize.\"\n    )\n\n", "CodeBleu_score": 37.033989921828905}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get(\"PLATFORMIO_ACCOUNT_TOKEN\")\n    if token:\n        return token\n    try:\n        token, expires = self.get_authentication_data()\n        if token and expires > time.time():\n            return token\n    except (PlatformioException, ValueError):\n        pass\n    try:\n        token = self.refresh_authentication_token()\n    except HTTPClientError as e:\n        if e.response.status_code == 401:\n            raise UserSideException(\n                \"Account is not authorized. Please run `pio account login`\"\n            )\n        raise\n    if token:\n        self.set_authentication_data(token)\n        return token\n    raise UserSideException(\"Account is not authorized. Please run `pio account login`\")\n\n", "CodeBleu_score": 31.425081346907902}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_session_data(\"refresh_token\")\n    if refresh_token:\n        try:\n            HTTPClient().post(\n                \"%s/v1/logout\" % __accounts_api__,\n                data={\"refresh_token\": refresh_token},\n                headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n            )\n        except HTTPClientError:\n            pass\n        self.delete_session_data()\n    return True\n\n", "CodeBleu_score": 49.30236381618638}, {"code": "def logout(self)\n\t\n    if not self.is_logged_in():\n        return True\n\n    try:\n        refresh_token = self.get_session_item(\"refresh_token\")\n        self.delete_session()\n        self.http_client.post(\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n            timeout=5,\n        )\n    except HTTPClientError as e:\n        if e.code != 401:\n            raise\n\n    return True\n\n", "CodeBleu_score": 43.95146908398317}, {"code": "def logout(self)\n\t\n    if not self.is_logged_in():\n        return True\n    refresh_token = self.get_refresh_token()\n    self.clear_session()\n    try:\n        HTTPClient(self).post(\"/v1/logout\", data={\"refresh_token\": refresh_token})\n    except HTTPClientError:\n        pass\n    return True\n\n", "CodeBleu_score": 54.12723917301096}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        result.append(PackageSpec(\n            name=package.name,\n            version=package.version,\n            external=package.external,\n            source_url=package.source_url\n        ))\n    return result\n\n", "CodeBleu_score": 23.803938226814793}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg_spec in self.get_used_packages():\n        if pkg_spec.is_optional():\n            continue\n        pkg_meta = self.get_package_metadata(pkg_spec)\n        pkg_meta.update({\n            \"name\": pkg_spec.name,\n            \"version\": pkg_spec.version,\n            \"external\": pkg_meta.get(\"external\", False)\n        })\n        if pkg_meta.get(\"external\"):\n            pkg_meta[\"source\"] = pkg_spec.source\n        result.append(pkg_meta)\n    return result\n\n", "CodeBleu_score": 33.81620609928252}, {"code": "def dump_used_packages(self)\n\t\n    used_packages = []\n    for pkg in self.packages:\n        if pkg.optional:\n            continue\n        if pkg.external:\n            used_packages.append(\n                PackageSpec(\n                    name=pkg.name,\n                    version=pkg.version,\n                    source=pkg.source,\n                    external=True,\n                    external_url=pkg.external_url,\n                )\n            )\n        else:\n            used_packages.append(\n                PackageSpec(\n                    name=pkg.name,\n                    version=pkg.version,\n                    source=pkg.source,\n                    external=False,\n                )\n            )\n    return used_packages\n\n", "CodeBleu_score": 19.99446884146467}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    config = ProjectConfig.get_instance(env.project_config.path)\n    if not config.validate_platform(env.name, targets):\n        raise UndefinedEnvPlatformError(env.name)\n    platform = cls(config.get_optional_dir(\"platforms\"), autoinstall=autoinstall)\n    platform.set_project_config(config)\n    platform.set_environment(env)\n    platform.configure_project_packages(env.name, targets)\n    return platform\n\n", "CodeBleu_score": 35.293753020709325}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_name = env.get(\"platform\")\n    if not platform_name:\n        raise UndefinedEnvPlatformError(env)\n    return cls(\n        platform_name,\n        env,\n        targets=targets,\n        autoinstall=autoinstall,\n    )\n\n", "CodeBleu_score": 24.127355416567486}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not env:\n        raise ValueError(\"Missed environment name\")\n    config = ProjectConfig.get_instance(env)\n    if not config.validate([\"platform\"]):\n        raise UnknownPlatform(\n            \"Unknown platform for environment '%s'\" % env\n            if not config.default_envs\n            else \"Unknown platform for default environment\"\n        )\n    platform = cls(config.get(\"platform\"), autoinstall=autoinstall)\n    platform.core_packages = config.get_optional_dir(\"core_packages\")\n    platform.env_packages = config.get_optional_dir(\"env_packages\")\n    platform.env_data = config.items\n    platform.env = env\n    platform.config = config\n    platform.targets = targets or config.default_envs[env].get(\"targets\") or []\n    platform.packages = []\n    platform.packages_deps = []\n    platform.packages_manifests = []\n    platform.packages_extra_manifests = []\n    platform.packages_optional_manifests = []\n    platform.packages_ignored_manifests = []\n    platform.packages_required = []\n    platform.packages_deps_cache = {}\n    platform.packages_ignored = []\n    platform.packages_deps_cache = {}\n    platform.packages_manifests_cache = {}\n    platform.packages_extra_manifests_cache = {}\n    platform.packages_optional_manifests_cache = {}\n    platform.packages_ignored_manifests_cache = {}\n    platform.packages_required_cache = {}\n    platform.packages_deps_cache = {}\n    platform.packages_ignored_cache = {}\n    platform.packages_deps_cache = {}\n    platform.packages_manifests_cache = {}\n    platform.packages_extra_manifests_cache = {}\n    platform.packages_optional_manifests_cache = {}\n    platform.packages_ignored_manifests_cache = {}\n    platform.packages_required_cache = {}\n    platform.packages_deps_cache = {}\n    platform.packages_ignored_cache = {}\n    platform.packages_deps_cache = {}\n    platform.packages_manifests", "CodeBleu_score": 29.288763545708097}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\n\tWire.beginTransmission(AXP192_ADDR);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\n\tWire.requestFrom(AXP192_ADDR, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 62.99479123919027}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\n  // Start I2C transmission\n  Wire.beginTransmission(0x34);\n  // Send address to read from\n  Wire.write(Addr);\n  // End transmission\n  Wire.endTransmission();\n  // Request data from the device\n  Wire.requestFrom(0x34, Size);\n  // Store data in buffer\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n\n}", "CodeBleu_score": 69.45114768660069}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission(false);\n\tWire.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 68.27808120560853}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        SetWakeupTimer(time_in_us);\n        Wire.beginTransmission(AXP192_SLAVE_ADDRESS);\n        Wire.write(AXP192_REG_POWER_CTL);\n        Wire.write(0x80);\n        Wire.endTransmission();\n    } else {\n        Wire.beginTransmission(AXP192_SLAVE_ADDRESS);\n        Wire.write(AXP192_REG_POWER_CTL);\n        Wire.write(0xC0);\n        Wire.endTransmission();\n    }\n    delay(100);\n    ESP.deepSleep(0);\n}", "CodeBleu_score": 48.3652315056956}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us != 0) {\n        SetWakeupTimer(time_in_us);\n    }\n    else {\n        ClearWakeupTimer();\n    }\n    EnterSleep();\n}", "CodeBleu_score": 47.8141022612316}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us > 0) {\n    EnableWakeupPin(true);\n    EnableTimerWakeup(time_in_us);\n  } else {\n    EnableWakeupPin(false);\n  }\n  EnterSleep();\n}", "CodeBleu_score": 50.30409051939606}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = y_scroll;\n\tif (tteBar) {\n\t\ty = y_scroll_alt;\n\t}\n\ty_scroll = (y + TEXT_HEIGHT) % (HEIGHT - TEXT_HEIGHT - TEXT_HEIGHT_ALT);\n\tif (tteBar) {\n\t\ty_scroll_alt = (y_scroll_alt + TEXT_HEIGHT_ALT) % (HEIGHT - TEXT_HEIGHT_ALT);\n\t}\n\tlcd.fillRect(0, y, WIDTH, TEXT_HEIGHT, color);\n\treturn y;\n}", "CodeBleu_score": 25.15096262040869}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = _scroll_y;\n\tif (_scroll_y >= _height - _scroll_bottom_area_height) {\n\t\t_scroll_y = _scroll_top_area_height;\n\t} else {\n\t\t_scroll_y += _text_line_height;\n\t}\n\tif (_scroll_y == _scroll_top_area_height && _scroll_y == _scroll_bottom_area_height) {\n\t\t_scroll_y = _text_line_height;\n\t}\n\t_display->fillRect(0, y, _width, _text_line_height, color);\n\t_display->setScrollAddress(y);\n\treturn y;\n}", "CodeBleu_score": 25.454601178060283}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tuint16_t y = tte_y;\n\tuint16_t x = tte_x;\n\tuint16_t h = tte_height;\n\tuint16_t w = tte_width;\n\n\tif (tte_bar) {\n\t\ttte_y = tte_bar_y;\n\t\ttte_height = tte_bar_height;\n\t\ttte_width = tte_bar_width;\n\t}\n\n\tif (tte_y + h > DISPLAY_HEIGHT - 16) {\n\t\ttte_y = tte_y_start;\n\t} else {\n\t\ttte_y += h;\n\t}\n\n\tgfx_SetColor(color);\n\tgfx_FillRectangle_NoClip(tte_x, tte_y, w, h);\n\n\ttte_x = x;\n\ttte_y = y;\n\ttte_height = h;\n\ttte_width = w;\n\n\treturn y;\n}", "CodeBleu_score": 27.71934359001339}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif(ssids == NULL || access_points == NULL) {\n\t\tSerial.println(\"ERROR: No SSIDs or Access Points provided.\");\n\t\treturn false;\n\t}\n\tif(ssids->size() == 0 || access_points->size() == 0) {\n\t\tSerial.println(\"ERROR: No SSIDs or Access Points provided.\");\n\t\treturn false;\n\t}\n\n\t// Setup the access points\n\tif(!setupAccessPoints(access_points)) {\n\t\tSerial.println(\"ERROR: Setting up access points failed.\");\n\t\treturn false;\n\t}\n\n\t// Setup the HTML content\n\tif(!setupHTML(ssids)) {\n\t\tSerial.println(\"ERROR: Setting up HTML content failed.\");\n\t\treturn false;\n\t}\n\n\t// Start the portal\n\tstartPortal();\n\n\treturn true;\n}", "CodeBleu_score": 50.00574226780867}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  // Set up access points\n  if(!setupAccessPoints(access_points)) {\n    return false;\n  }\n  // Set up HTML content\n  if(!setupHTML(ssids)) {\n    return false;\n  }\n  // Start the portal\n  return start();\n}", "CodeBleu_score": 54.819305679068265}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t    // Setup access points\n    if (!setupAccessPoints(access_points)) {\n        return false;\n    }\n\n    // Setup HTML content\n    if (!setupHTMLContent()) {\n        return false;\n    }\n\n    // Start portal\n    portal.begin();\n\n    return true;\n}", "CodeBleu_score": 56.886559025966264}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (text.empty()) {\n\t\t\ttext.push_back(std::string());\n\t\t\ttext_in.push_back(std::string());\n\t\t}\n\t}\n\telse {\n\t\ttext.clear();\n\t\ttext_in.clear();\n\t\ttext.push_back(std::string());\n\t\ttext_in.push_back(std::string());\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 12.183261012252574}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (queue.empty()) {\n\t\t\tqueue_enabled_flag = false;\n\t\t}\n\t\telse {\n\t\t\tqueue_enabled_flag = true;\n\t\t\ttext = queue.front();\n\t\t\tqueue.pop();\n\t\t\ttext_in = text.begin();\n\t\t}\n\t}\n\telse {\n\t\tqueue_enabled_flag = true;\n\t\tqueue.clear();\n\t}\n}", "CodeBleu_score": 11.74006077825151}, {"code": "void GpsInterface::enable_queue(){\n\t\n\tif (queue_enabled_flag) {\n\n\t\tif (queue.empty()) {\n\t\t\tqueue_enabled_flag = true;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tqueue.clear();\n\t\t\tqueue_enabled_flag = true;\n\t\t\treturn;\n\t\t}\n\t}\n\telse {\n\t\tqueue_enabled_flag = true;\n\t\tqueue.clear();\n\t\treturn;\n\t}\n}", "CodeBleu_score": 10.753150584806772}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (nmea_queue != NULL) {\n\t\tdelete nmea_queue;\n\t\tnmea_queue = new Queue<NmeaSentence*>();\n\t}\n\telse {\n\t\tnmea_queue = new Queue<NmeaSentence*>();\n\t}\n}", "CodeBleu_score": 38.716028642466284}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (queue_nmea) {\n        delete queue_nmea;\n        queue_nmea = new std::queue<std::string>();\n    } else {\n        queue_nmea = new std::queue<std::string>();\n    }\n}", "CodeBleu_score": 42.76203812314592}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea != NULL) {\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new std::queue<std::string>();\n}", "CodeBleu_score": 34.68038810338282}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n    /*The most top left point of the area*/\n    int32_t tl_x = area->x1;\n    int32_t tl_y = area->y1;\n\n    /*The most bottom right point of the area*/\n    int32_t br_x = area->x2;\n    int32_t br_y = area->y2;\n\n    /*Calculate the number of pixels*/\n    uint32_t w = (br_x - tl_x + 1);\n    uint32_t h = (br_y - tl_y + 1);\n    uint32_t len = w * h;\n\n    /*Fill the buffer with the colors*/\n    uint8_t buf[len * 2];\n    uint32_t i;\n    for(i = 0; i < len; i++) {\n      buf[2 * i] = color_p->ch.blue;\n      buf[2 * i + 1] = color_p->ch.green;\n      color_p++;\n    }\n\n    /*Set the area*/\n    ili9341_set_area(tl_x, tl_y, br_x, br_y);\n\n    /*Write the buffer*/\n    ili9341_write_data(buf, len * 2);\n\n    /*Tell lvgl that flushing is done*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 42.89903932038435}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    // Start a write transaction\n    ili9341_start_write();\n\n    // Set the address window to the provided area\n    ili9341_set_addr_window(area->x1, area->y1, area->x2, area->y2);\n\n    // Iterate through each pixel in the area\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        // Write the corresponding color from the color buffer\n        ili9341_write_data(color_p->full);\n        color_p++;\n      }\n    }\n\n    // End the write transaction\n    ili9341_end_write();\n\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 55.85915551668862}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t x1 = area->x1;\n    uint32_t x2 = area->x2;\n    uint32_t y1 = area->y1;\n    uint32_t y2 = area->y2;\n    uint32_t w = (x2 - x1 + 1);\n    uint32_t h = (y2 - y1 + 1);\n\n    // Write a transaction to the display\n    disp_spi_send_cmd(CMD_WR_MEM_START);\n\n    // Set the display window to the area to be updated\n    disp_spi_send_cmd(CMD_SET_COL_ADDR);\n    disp_spi_send_data((x1 >> 8) & 0xFF);\n    disp_spi_send_data(x1 & 0xFF);\n    disp_spi_send_data((x2 >> 8) & 0xFF);\n    disp_spi_send_data(x2 & 0xFF);\n\n    disp_spi_send_cmd(CMD_SET_PAGE_ADDR);\n    disp_spi_send_data((y1 >> 8) & 0xFF);\n    disp_spi_send_data(y1 & 0xFF);\n    disp_spi_send_data((y2 >> 8) & 0xFF);\n    disp_spi_send_data(y2 & 0xFF);\n\n    // Iterate through each pixel in the area and write the color data to the display\n    for(int32_t y = y1; y <= y2; y++) {\n        for(int32_t x = x1; x <= x2; x++) {\n            disp_spi_send_data(color_p->ch.red);\n            disp_spi_send_data(color_p->ch.green);\n            disp_spi_send_data(color_p->ch.blue);\n            color_p++;\n        }\n    }\n\n    // End the write transaction\n    disp_spi_send_cmd(CMD_WR_ME", "CodeBleu_score": 41.3405689841708}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == nullptr) {\n\t\treturn;\n\t}\n\tfor (auto it = menu->begin(); it != menu->end(); it++) {\n\t\tstd::cout << std::string(layer, '\\t') << it->getName() << std::endl;\n\t\tshowMenuList(it->getSubMenu(), layer + 1);\n\t}\n\tstd::cout << std::endl;\n}", "CodeBleu_score": 34.0637329593043}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->getMenuNodes().size(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tstd::cout << \"    \";\n\t\t}\n\t\tstd::cout << menu->getMenuNodes()[i]->getName() << std::endl;\n\t\tif (menu->getMenuNodes()[i]->getMenu() != nullptr) {\n\t\t\tshowMenuList(menu->getMenuNodes()[i]->getMenu(), layer + 1);\n\t\t}\n\t}\n\tstd::cout << std::endl;\n}", "CodeBleu_score": 44.22740154734537}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->getMenuNodeCount(); i++) {\n\t\tMenuNode * menuNode = menu->getMenuNode(i);\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tstd::cout << \"  \";\n\t\t}\n\t\tstd::cout << menuNode->getName() << std::endl;\n\t\tif (menuNode->getMenu() != NULL) {\n\t\t\tshowMenuList(menuNode->getMenu(), layer + 1);\n\t\t}\n\t}\n\tstd::cout << std::endl;\n}", "CodeBleu_score": 45.714410824115035}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  int i;\n  for (i = 0; i < count; i++) {\n    char ssid[7];\n    int channel;\n    char mac[18];\n\n    sprintf(ssid, \"%02X%02X%02X\", random(0, 255), random(0, 255), random(0, 255));\n    channel = random(1, 14);\n    sprintf(mac, \"%02X:%02X:%02X:%02X:%02X:%02X\", random(0, 255), random(0, 255), random(0, 255), random(0, 255), random(0, 255), random(0, 255));\n\n    Serial.print(F(\"SSID: \"));\n    Serial.print(ssid);\n    Serial.print(F(\" | Channel: \"));\n    Serial.print(channel);\n    Serial.print(F(\" | MAC: \"));\n    Serial.println(mac);\n\n    SSIDs.add(ssid);\n  }\n  return i;\n}", "CodeBleu_score": 36.57373877648452}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int ssidsGenerated = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = generateRandomSSID();\n    int channel = random(1, 14);\n    String mac = generateRandomMac();\n    ssids.push_back(ssid);\n    ssidChannels.push_back(channel);\n    ssidMacs.push_back(mac);\n    ssidsGenerated++;\n    Serial.println(F(\"SSID: \") + ssid + F(\" | Channel: \") + String(channel) + F(\" | MAC: \") + mac);\n  }\n  return ssidsGenerated;\n}", "CodeBleu_score": 39.649664087075145}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  for (int i = 0; i < count; i++) {\n    String ssid = generateRandomSSID();\n    int channel = random(1, 14);\n    String bssid = generateRandomBSSID();\n    String mac = generateRandomMAC();\n    String security = generateRandomSecurity();\n    String rssi = random(-100, -1);\n    String timestamp = random(1, 1000000);\n    String line = ssid + \",\" + channel + \",\" + bssid + \",\" + mac + \",\" + security + \",\" + rssi + \",\" + timestamp;\n    Serial.println(line);\n    ssids.push_back(ssid);\n  }\n  return ssids.size();\n}", "CodeBleu_score": 38.37703078925971}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    try:\n        publisher = pubsub_v1.PublisherClient()\n        topic_path = publisher.topic_path(project_id, topic_name)\n        topic = publisher.create_topic(topic_path)\n        print(f\"Topic {topic.name} created.\")\n    except Exception as e:\n        print(f\"Error creating topic {topic_name}: {e}\")\n\n", "CodeBleu_score": 67.0991200206349}, {"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(\n        \"Created topic: {}\".format(topic.name)\n    )\n\n", "CodeBleu_score": 68.96229705044202}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(\"Topic created: {}\".format(topic.name))\n\n", "CodeBleu_score": 52.81628364945629}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 56.64796094364441}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    # Set the issuer (iss) to the GCP project ID\n    iss = project_id\n\n    # Set the audience (aud) to the GCP project ID\n    aud = project_id\n\n    # Set the current UTC time in seconds as the issued time (iat)\n    iat = int(time.time())\n\n    # Set the expiration time (exp) to one hour later\n    exp = iat + 3600\n\n    # Create a JWT payload\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': aud,\n        'iss': iss\n    }\n\n    # Read the private key file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create a JWT using the private key\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 45.12421161828697}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 56.64796094364441}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message:\")\n    print(\"Topic: {}\".format(message.topic))\n    print(\"Payload: {}\".format(message.payload))\n    print(\"QoS: {}\".format(message.qos))\n\n    if message.payload == b'on':\n        print('Received \"on\" message')\n        print('Capturing image...')\n        # Capture image\n        # os.system('raspistill -o image.jpg')\n        os.system('raspistill -o image.jpg -t 1')\n        print('Image captured')\n        print('Uploading image to GCS...')\n        # Upload image to GCS\n        # os.system('gsutil cp image.jpg gs://{}/{}'.format(BUCKET_NAME, FILE_NAME))\n        os.system('gsutil cp image.jpg gs://{}/{}'.format(BUCKET_NAME, FILE_NAME))\n        print('Image uploaded')\n        print('Publishing image URL to MQTT event topic...')\n        # Publish image URL to MQTT event topic\n        # client.publish(EVENT_TOPIC, 'gs://{}/{}'.format(BUCKET_NAME, FILE_NAME), qos=0)\n        client.publish(EVENT_TOPIC, 'gs://{}/{}'.format(BUCKET_NAME, FILE_NAME), qos=1)\n        print('Image URL published')\n\n    elif message.payload == b'off':\n        print('Received \"off\" message')\n\n    else:\n        print('Received unknown message')\n\n", "CodeBleu_score": 29.300115499186962}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n\n    print(\"Received message '{}' on topic '{}' with QoS {}\".format(\n        message.payload.decode(\"utf-8\"), message.topic, message.qos))\n    if message.payload.decode(\"utf-8\") == \"on\":\n        print(\"Taking a picture\")\n        # Capture a picture\n        os.system(\"raspistill -o test.jpg\")\n        # Upload the file to a bucket\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket(BUCKET_NAME)\n        blob = bucket.blob(\n            \"test.jpg\")\n        blob.upload_from_filename(\"test.jpg\")\n        # Get the URL of the file\n        url = \"https://storage.googleapis.com/\" + bucket.name + \"/test.jpg\"\n        # Publish the URL to an MQTT event topic\n        mqtt_client.publish(\n            \"events\",\n            url,\n            qos=1)\n        print(\"Published URL to topic: \" + url)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 39.54840816092705}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(message.payload.decode('utf-8'), message.topic, message.qos))\n    if message.payload.decode('utf-8') == \"on\":\n        print(\"Taking photo\")\n        # Capture a preview image and save it to a temporary file\n        os.system('fswebcam -r 1280x720 --no-banner /tmp/image.jpg')\n        print(\"Saving image to bucket\")\n        # Upload the image to a bucket\n        upload_blob('/tmp/image.jpg', 'iot-camera-images')\n        print(\"Getting signed URL\")\n        # Get a signed URL for the image\n        signed_url = get_signed_url('iot-camera-images', 'image.jpg')\n        print(\"Publishing to topic\")\n        # Publish the signed URL to an MQTT event topic\n        publish_message(signed_url, 'iot-camera-event')\n    else:\n        print(\"off\")\n", "CodeBleu_score": 36.063000618218275}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n\n    parser = argparse.ArgumentParser(description='Subscribe to a Google Cloud IoT MQTT device connection.')\n    parser.add_argument('--project_id',\n                        help='GCP cloud project name',\n                        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument('--subscription',\n                        help='GCP IoT subscription name',\n                        default='')\n    args = parser.parse_args()\n\n    if args.project_id is None:\n        raise ValueError('The Google Cloud project ID must be set.')\n    if args.subscription is None:\n        raise ValueError('The Google Cloud IoT subscription name must be set.')\n\n    return args\n\n", "CodeBleu_score": 42.1178695361619}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Identifier for the Google Cloud project containing the subscription.')\n    parser.add_argument(\n        '--subscription_name',\n        help='Name of the subscription to pull messages from.')\n    parser.add_argument(\n        '--message_count',\n        type=int,\n        help='Number of messages to pull.',\n        default=10)\n    parser.add_argument(\n        '--message_type',\n        help='Type of message to pull.',\n        default='event')\n    parser.add_argument(\n        '--device_id',\n        help='Device ID of the device publishing messages.')\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region',\n        help='GCP cloud region.',\n        default='us-central1')\n    parser.add_argument(\n        '--ca_certs',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--minttl',\n        type=int,\n        help='Minimum token lifetime in seconds.')\n    parser.add_argument(\n        '--maxttl',\n        type=int,\n        help='Maximum token lifetime in seconds.')\n    parser.add_argument(\n        '--message_data',\n        help='Message data to send to Google Cloud IoT Core.')\n    parser.add_argument(\n        '--message_attributes',\n        help='Message attributes to send to Google Cloud IoT Core.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        help='MQTT bridge hostname.')\n    parser", "CodeBleu_score": 31.641300080868227}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='Google Cloud project ID to use.')\n    parser.add_argument(\n        '--subscription_name',\n        default=os.environ.get('GOOGLE_CLOUD_SUBSCRIPTION'),\n        help='Google Cloud Pub/Sub subscription name to use.')\n    return parser.parse_args()\n\n", "CodeBleu_score": 44.14192532074927}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # Define the necessary API scopes, version, and discovery URL\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials, scoped appropriately\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes)\n\n    # Build and return the client for the Cloud IoT Core service\n    return discovery.build(\n        'cloudiot',\n        version,\n        credentials=credentials,\n        discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 22.443832680463373}, {"code": "def get_client(service_account_json)\n\t\n    # The device that should publish data to the topic.\n    device_path = 'projects/{}/locations/{}/registries/{}/devices/{}'.format(\n        os.environ['GOOGLE_CLOUD_PROJECT'],\n        os.environ['REGION'],\n        os.environ['IOT_REGISTRY'],\n        os.environ['IOT_DEVICE'])\n\n    # Create the service account credentials using the created key file.\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n\n    # Scopes the credentials to only allow access to the specified API.\n    scoped_credentials = credentials.with_scopes(\n        ['https://www.googleapis.com/auth/cloud-platform'])\n\n    # Creates an API client for the service.\n    return discovery.build(\n        'cloudiot',\n        'v1',\n        credentials=scoped_credentials,\n        cache_discovery=False)\n\n", "CodeBleu_score": 41.03856705035784}, {"code": "def get_client(service_account_json)\n\t\n    # Construct the service account credentials using the service account JSON file\n    # and necessary scopes.\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(\n        ['https://www.googleapis.com/auth/cloud-platform'])\n\n    # Use the credentials and project ID to create a Cloud IoT Core V1 service object.\n    cloudiot = discovery.build(\n        'cloudiot', 'v1', credentials=scoped_credentials, cache_discovery=False)\n    return cloudiot\n\n", "CodeBleu_score": 21.861175377898746}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    # Retrieve the ASN1 code for the hash method and raise an error if the hash method is invalid.\n    hash_method_asn1 = common.get_hash_asn1(hash_method)\n    if hash_method_asn1 is None:\n        raise ValueError(\"Invalid hash method.\")\n\n    # Concatenate the ASN1 code with the hash value, pad the result for signing, and encrypt the padded hash using the private key.\n    padded_hash = transform.pad_for_signing(hash_method, hash_value)\n    encrypted_hash = core.encrypt_pkcs1_v1_5(padded_hash, priv_key)\n\n    return encrypted_hash\n\n", "CodeBleu_score": 27.3348185900245}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == \"MD5\":\n        asn1_code = b\"\\x30\\x20\\x30\\x0c\\x06\\x08\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x02\\x05\\x05\\x00\\x04\\x10\"\n    elif hash_method == \"SHA1\":\n        asn1_code = b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\"\n    elif hash_method == \"SHA256\":\n        asn1_code = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    elif hash_method == \"SHA384\":\n        asn1_code = b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30\"\n    elif hash_method == \"SHA512\":\n        asn1_code = b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\"\n    else:\n        raise ValueError(\"Invalid hash method\")\n    padded_hash = asn1_code + hash_value\n    padded_hash = common.pad_block", "CodeBleu_score": 16.53877921491497}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = common.get_hash_asn1(hash_method)\n    if hash_method_asn1 is None:\n        raise ValueError(\"Invalid hash method.\")\n    hash_value_block = common.hash_to_block(hash_value, hash_method)\n    hash_block = common.concat_blocks([hash_method_asn1, hash_value_block])\n    padded_hash_block = common.pad_block(hash_block, priv_key.block_size)\n    signature_block = core.encrypt_block(padded_hash_block, priv_key)\n    return signature_block\n\n", "CodeBleu_score": 34.208036352833155}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError(\"message must be of type bytes\")\n    if not isinstance(signature, bytes):\n        raise TypeError(\"signature must be of type bytes\")\n    if not isinstance(pub_key, core.PublicKey):\n        raise TypeError(\"pub_key must be of type PublicKey\")\n    if len(signature) != pub_key.size_in_bytes():\n        raise ValueError(\"signature length must equal public key size in bytes\")\n    if pub_key.has_private():\n        raise ValueError(\"public key has private part\")\n    if not pub_key.is_valid():\n        raise ValueError(\"public key is invalid\")\n    if pub_key.has_precomputed():\n        raise ValueError(\"public key has precomputed values\")\n    if pub_key.has_custom_parameters():\n        raise ValueError(\"public key has custom parameters\")\n    if pub_key.has_precomputed_public():\n        raise ValueError(\"public key has precomputed public values\")\n    if pub_key.has_precomputed_private():\n        raise ValueError(\"public key has precomputed private values\")\n    if not pub_key.is_valid():\n        raise ValueError(\"public key is invalid\")\n    if pub_key.has_precomputed():\n        raise ValueError(\"public key has precomputed values\")\n    if pub_key.has_custom_parameters():\n        raise ValueError(\"public key has custom parameters\")\n    if pub_key.has_precomputed_public():\n        raise ValueError(\"public key has precomputed public values\")\n    if pub_key.has_precomputed_private():\n        raise ValueError(\"public key has precomputed private values\")\n    if not pub_key.is_valid():\n        raise ValueError(\"public key is invalid\")\n    if pub_key.has_precomputed():\n        raise ValueError(\"public key has precomputed values\")\n    if pub_key.has_custom_parameters():\n        raise ValueError(\"public key has custom parameters\")\n    if pub_key.has_precomputed_public():\n        raise ValueError(\"public key has precomputed public values", "CodeBleu_score": 19.13960293878932}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(signature, bytes):\n        raise TypeError(\"Signature must be a byte string\")\n    if not isinstance(pub_key, core.PublicKey):\n        raise TypeError(\"Public key must be a PublicKey object\")\n    if not isinstance(message, bytes):\n        raise TypeError(\"Message must be a byte string\")\n    if len(signature) != pub_key.size_in_bytes():\n        raise ValueError(\"Signature length must match public key size\")\n    # Convert signature to an integer\n    signature = int.from_bytes(signature, byteorder=\"big\")\n    # Decrypt signature\n    clear_signature = pub_key.decrypt(signature)\n    # Determine hash method used\n    hash_method = common.get_hash_method(clear_signature)\n    # Compute hash of message\n    hash_obj = hash_method()\n    hash_obj.update(message)\n    hash = hash_obj.digest()\n    # Reconstruct expected padded hash\n    expected_padded_hash = transform.bytes2int(hash)\n    expected_padded_hash = transform.int2bytes(expected_padded_hash, pub_key.n_size_in_bytes())\n    # Compare expected padded hash with clear signature\n    if clear_signature != expected_padded_hash:\n        raise ValueError(\"Signature does not match message\")\n    return hash_method.name\n\n", "CodeBleu_score": 38.52894543460642}, {"code": "def verify(message, signature, pub_key)\n\t\n    signature = common.asbytes(signature)\n    message = common.asbytes(message)\n    pub_key = common.asbytes(pub_key)\n    signature = core.decode_signature(signature)\n    h = core.decrypt_signature(signature, pub_key)\n    h = core.hash_to_long(h)\n    m = core.hash_message(message)\n    if h != m:\n        raise core.VerificationError(\"Signature verification failed\")\n    return core.get_hash_name(h)\n\n", "CodeBleu_score": 21.560833731390595}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\n\ttime_t currentTime;\n\n\tif (time(&currentTime) != -1) {\n\t\tupdateJWT(currentTime);\n\t}\n\n\tif (connectMQTTClient() == 0) {\n\t\tsendMQTTSubscribe = 1;\n\t}\n\n\tdebug_printInfo(\"MQTT connection attempt\");\n}", "CodeBleu_score": 20.159006432247967}, {"code": "static void connectMQTT(){\n\t\t\n\t// Get the current time\n\ttime_t currentTime;\n\tstruct tm *currentTime_tm;\n\t\n\t// Get the current time\n\ttime(&currentTime);\n\tcurrentTime_tm = gmtime(&currentTime);\n\t\n\t// If the current time is valid, update the JWT\n\tif (currentTime_tm->tm_year > (2016 - 1900)) {\n\t\t\n\t\t// Update the JWT\n\t\tupdateJWT(currentTime);\n\t\t\n\t}\n\t\n\t// Connect to the MQTT client\n\tconnectToMQTTClient();\n\t\n\t// Set the flag to send an MQTT SUBSCRIBE packet\n\tsendMQTTSubscribe = 1;\n\t\n\t// Print a debug message indicating the MQTT connection attempt\n\tDEBUG_PRINT(\"Attempting to connect to MQTT client\n\");\n\t\n}", "CodeBleu_score": 43.12665332919992}, {"code": "static void connectMQTT(){\n\t\n\ttime_t currentTime;\n\n\ttime(&currentTime);\n\n\tif (currentTime > 0) {\n\n\t\tupdateJWT(currentTime);\n\n\t} else {\n\n\t\tdebug_printError(\"ERROR: Could not retrieve the current time\");\n\n\t}\n\n\tif (connectToMQTTClient()) {\n\n\t\tsendMQTTSubscribe = 1;\n\n\t}\n\n\tdebug_printInfo(\"INFO: Attempting to connect to the MQTT client\");\n\n}", "CodeBleu_score": 24.564736013046385}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    const uint8_t* str_end = str + width;\n    uint32_t result = 0;\n\n    if (str == NULL || width <= 0 || num == NULL)\n        return str;\n\n    while (str < str_end) {\n        uint8_t digit = *str - '0';\n        if (digit > 9)\n            return str;\n        result = result * 10 + digit;\n        str++;\n    }\n\n    *num = result;\n    return str;\n}", "CodeBleu_score": 29.753299353740104}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    int i;\n    uint32_t temp = 0;\n\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n\n        temp = temp * 10 + (str[i] - '0');\n    }\n\n    *num = temp;\n\n    return str + width;\n}", "CodeBleu_score": 27.025908866132276}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    int i;\n    uint32_t temp = 0;\n\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n\n        temp = (temp * 10) + (str[i] - '0');\n    }\n\n    *num = temp;\n    return &str[i];\n}", "CodeBleu_score": 26.49728116480269}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = ATCACERT_E_SUCCESS;\n    uint8_t cert_template[ATCACERT_MAX_SIZE];\n    size_t cert_template_size = 0;\n    uint8_t cert_der_enc[ATCACERT_MAX_SIZE];\n    size_t cert_der_enc_size = 0;\n    uint8_t cert_der_sig[ATCACERT_MAX_SIZE];\n    size_t cert_der_sig_size = 0;\n    uint8_t cert_der_sig_enc[ATCACERT_MAX_SIZE];\n    size_t cert_der_sig_enc_size = 0;\n    uint8_t cert_der_sig_enc_pad[ATCACERT_MAX_SIZE];\n    size_t cert_der_sig_enc_pad_size = 0;\n    uint8_t cert_der_sig_enc_pad_size_asn1[2];\n    uint8_t cert_der_sig_enc_pad_size_asn1_size = 0;\n    uint8_t cert_der_sig_enc_pad_size_asn1_size_asn1[2];\n    uint8_t cert_der_sig_enc_pad_size_asn1_size_asn1_size = 0;\n    uint8_t cert_der_sig_enc_pad_size_asn1_size_asn1_size_asn1[2];\n    uint8_t cert_der_sig_enc_pad_size_asn1_size_asn1_size_asn1_size = 0;\n    uint8_t cert_der_sig_enc_pad_size_asn1_size_asn1_size_asn1_size_asn1[2];\n    uint8_t cert_der_sig_enc_pad_size_asn1_size_asn1_size_asn1_size_asn1_size = 0;\n    uint8_t cert_der_sig_enc_pad_size_asn1_size_asn1_size", "CodeBleu_score": 10.356986313052966}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = 0;\n    uint8_t* tmp_buf = NULL;\n    uint8_t* tmp_buf_pos = NULL;\n    uint8_t* tmp_buf_end = NULL;\n    uint8_t* cert_buf = NULL;\n    uint8_t* cert_buf_pos = NULL;\n    uint8_t* cert_buf_end = NULL;\n    uint8_t* cert_buf_size_pos = NULL;\n    uint8_t* cert_buf_size_end = NULL;\n    uint8_t* cert_buf_size_size_pos = NULL;\n    uint8_t* cert_buf_size_size_end = NULL;\n    uint8_t* cert_buf_size_size_size_pos = NULL;\n    uint8_t* cert_buf_size_size_size_end = NULL;\n    uint8_t* cert_buf_size_size_size_size_pos = NULL;\n    uint8_t* cert_buf_size_size_size_size_end = NULL;\n    uint8_t* cert_buf_size_size_size_size_size_pos = NULL;\n    uint8_t* cert_buf_size_size_size_size_size_end = NULL;\n    uint8_t* cert_buf_size_size_size_size_size_size_pos = NULL;\n    uint8_t* cert_buf_size_size_size_size_size_size_end = NULL;\n    uint8_t* cert_buf_size_size_size_size_size_size_size_pos = NULL;\n    uint8_t* cert_buf_size_size_size_size_size_size_size_end = NULL;\n    uint8_t* cert_buf_size_size_size_size_size_size_size_size_pos = NULL;\n    uint8_t* cert_buf_size_size_size_size_size_size_size_size_end = NULL;\n    uint8_t* cert_buf_size_size_size_size_size_size_size_size_size_pos = NULL;\n   ", "CodeBleu_score": 11.944248423062415}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = ATCACERT_E_SUCCESS;\n    uint8_t* cert_buf = build_state->cert_def->cert_template_offset;\n    uint32_t cert_size = build_state->cert_def->cert_template_size;\n    uint8_t* cert_end = cert_buf + cert_size;\n    uint8_t* pos = cert_buf;\n    uint8_t* pos_end = cert_end;\n    size_t cert_size_max = cert_size;\n    uint32_t cert_size_actual = 0;\n    uint8_t* cert_size_pos = NULL;\n    uint8_t* cert_size_pos_end = NULL;\n    uint8_t* cert_size_pos_start = NULL;\n    uint8_t* cert_size_pos_end_start = NULL;\n    uint8_t* cert_size_pos_end_end = NULL;\n    uint8_t* cert_size_pos_end_start_start = NULL;\n    uint8_t* cert_size_pos_end_end_start = NULL;\n    uint8_t* cert_size_pos_end_end_end = NULL;\n    uint8_t* cert_size_pos_end_end_start_start = NULL;\n    uint8_t* cert_size_pos_end_end_end_start = NULL;\n    uint8_t* cert_size_pos_end_end_end_end = NULL;\n    uint8_t* cert_size_pos_end_end_end_start_start = NULL;\n    uint8_t* cert_size_pos_end_end_end_end_start = NULL;\n    uint8_t* cert_size_pos_end_end_end_end_end = NULL;\n    uint8_t* cert_size_pos_end_end_end_end_start_start = NULL;\n    uint8_t* cert_size_pos_end_end_end_end_end_start = NULL;\n    uint8_t* cert_size_pos_end_end_end_end_end", "CodeBleu_score": 16.481957033266013}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t cert_signature[64];\n    uint8_t ca_public_key_buf[64];\n    uint8_t ca_public_key_comp[64];\n    uint8_t ca_comp_key_id[20];\n    uint8_t ca_comp_key_id_buf[20];\n    uint8_t ca_comp_key_id_temp[20];\n    uint8_t ca_comp_key_id_temp2[20];\n    uint8_t ca_comp_key_id_temp3[20];\n    uint8_t ca_comp_key_id_temp4[20];\n    uint8_t ca_comp_key_id_temp5[20];\n    uint8_t ca_comp_key_id_temp6[20];\n    uint8_t ca_comp_key_id_temp7[20];\n    uint8_t ca_comp_key_id_temp8[20];\n    uint8_t ca_comp_key_id_temp9[20];\n    uint8_t ca_comp_key_id_temp10[20];\n    uint8_t ca_comp_key_id_temp11[20];\n    uint8_t ca_comp_key_id_temp12[20];\n    uint8_t ca_comp_key_id_temp13[20];\n    uint8_t ca_comp_key_id_temp14[20];\n    uint8_t ca_comp_key_id_temp15[20];\n    uint8_t ca_comp_key_id_temp16[20];\n    uint8_t ca_comp_key_id_temp17[20];\n    uint8_t ca_comp_key_id_temp18[20];\n    uint8_t ca_comp_key_id_temp19[20];\n    uint8_t ca_comp_key_id_temp2", "CodeBleu_score": 18.062446426719593}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n    int ret = ATCACERT_E_SUCCESS;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    uint8_t ca_public_key_tmp[72];\n    uint8_t ca_public_key_comp[72];\n    uint8_t ca_public_key_comp_enc[72];\n    uint8_t ca_public_key_comp_enc_tmp[72];\n    uint8_t ca_public_key_comp_enc_tmp_sw[72];\n    uint8_t ca_public_key_comp_enc_sw[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp_sw[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp_sw_tmp[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp_sw_tmp_sw[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp_sw_tmp_sw_tmp[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp_sw_tmp_sw_tmp_sw[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp_sw_tmp_sw_tmp_sw_tmp[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp_sw_tmp_sw_tmp_sw_tmp_sw[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp_sw_tmp_sw_tmp_sw_tmp_sw_tmp[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp_sw_tmp_sw_tmp_sw_tmp_sw_tmp_sw[72];\n    uint8_t ca_public_key_comp_enc_sw_tmp_sw_tmp_sw_tmp_sw_tmp_sw", "CodeBleu_score": 16.19324327334206}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    uint8_t ca_public_key_internal[72];\n\n    if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the TBS digest\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the signature\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Convert the public key to the internal format used by the CryptoAuthLib\n    ret = atcacert_public_key_to_ref(cert_def->ca_public_key_type, ca_public_key, ca_public_key_internal);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the signature\n    if (atcac_sw_sha2_256_verify(tbs_digest, sizeof(tbs_digest), signature, ca_public_key_internal) == ATCA_SUCCESS) {\n        ret = ATCACERT_E_SUCCESS;\n    } else {\n        ret = ATCACERT_E_VERIFY_FAILED;\n    }\n\n    return ret;\n}", "CodeBleu_score": 80.62587457570034}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t *tmp = *list;\n    timerStruct_t *prev = NULL;\n    while (tmp != NULL)\n    {\n        if (tmp == timer)\n        {\n            if (prev == NULL)\n                *list = tmp->next;\n            else\n                prev->next = tmp->next;\n            return true;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n    return false;\n}", "CodeBleu_score": 35.83229722566009}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\t\ttimerStruct_t * volatile *prev = &list;\n\t\twhile (*prev != NULL)\n\t\t{\n\t\t\tif (*prev == timer)\n\t\t\t{\n\t\t\t\t*prev = timer->next;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = &((*prev)->next);\n\t\t}\n\t\treturn false;\n\t}", "CodeBleu_score": 19.987895054494057}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t *current = *list;\n\ttimerStruct_t *prev = NULL;\n\twhile (current != NULL)\n\t{\n\t\tif (current == timer)\n\t\t{\n\t\t\tif (prev != NULL)\n\t\t\t{\n\t\t\t\tprev->next = current->next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*list = current->next;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tprev = current;\n\t\tcurrent = current->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.32538784914295}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\n\tint ret = BSD_ERROR;\n\n\tif (socket >= 0 && socket < MAX_SOCKET) {\n\n\t\tif (sockets[socket].state != NOT_A_SOCKET) {\n\n\t\t\tsockets[socket].state = NOT_A_SOCKET;\n\n\t\t\tif (close(sockets[socket].socket_id) == 0) {\n\n\t\t\t\tret = BSD_SUCCESS;\n\n\t\t\t} else {\n\n\t\t\t\tswitch (errno) {\n\n\t\t\t\tcase EBADF:\n\n\t\t\t\t\tsockets[socket].errno = EBADF;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tsockets[socket].errno = EIO;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsockets[socket].errno = EBADF;\n\n\t\t}\n\n\t} else {\n\n\t\tsockets[socket].errno = EBADF;\n\n\t}\n\n\treturn ret;\n\n}", "CodeBleu_score": 38.43156430712597}, {"code": "int BSD_close(int socket){\n\t\n\tint ret;\n\n\tstruct BSD_socket_info *socket_info;\n\n\tif (socket < 0 || socket >= MAX_SOCKET) {\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\tsocket_info = &BSD_socket_info_list[socket];\n\n\tif (socket_info->state == NOT_A_SOCKET) {\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\tsocket_info->state = NOT_A_SOCKET;\n\n\tret = close(socket);\n\n\tif (ret < 0) {\n\n\t\tswitch (errno) {\n\n\t\tcase EBADF:\n\n\t\t\tsocket_info->error_number = EBADF;\n\n\t\t\tbreak;\n\n\t\tcase EINTR:\n\n\t\t\tsocket_info->error_number = EINTR;\n\n\t\t\tbreak;\n\n\t\tcase EIO:\n\n\t\t\tsocket_info->error_number = EIO;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tsocket_info->error_number = EINVAL;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\treturn BSD_SUCCESS;\n\n}", "CodeBleu_score": 48.04743353004011}, {"code": "int BSD_close(int socket){\n\t\n\tint return_value;\n\n\tstruct socket_info *socket_ptr;\n\n\tsocket_ptr = retrieve_socket(socket);\n\n\tif (socket_ptr == NULL) {\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\tsocket_ptr->state = NOT_A_SOCKET;\n\n\treturn_value = close(socket);\n\n\tif (return_value < 0) {\n\n\t\tswitch (errno) {\n\n\t\tcase EBADF:\n\n\t\t\terrno = BSD_EBADF;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\terrno = BSD_EINVAL;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\treturn BSD_SUCCESS;\n\n}", "CodeBleu_score": 47.0817380304741}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\n\tint response;\n\n\tresponse = listen(socket, backlog);\n\n\tif (response == -1) {\n\n\t\tswitch (errno) {\n\n\t\tcase EBADF:\n\n\t\t\tsocket_errno = EBADF_errno;\n\n\t\t\tbreak;\n\n\t\tcase ENOTSOCK:\n\n\t\t\tsocket_errno = ENOTSOCK_errno;\n\n\t\t\tbreak;\n\n\t\tcase EOPNOTSUPP:\n\n\t\t\tsocket_errno = EOPNOTSUPP_errno;\n\n\t\t\tbreak;\n\n\t\tcase EADDRINUSE:\n\n\t\t\tsocket_errno = EADDRINUSE_errno;\n\n\t\t\tbreak;\n\n\t\tcase EINVAL:\n\n\t\t\tsocket_errno = EINVAL_errno;\n\n\t\t\tbreak;\n\n\t\tcase ENOBUFS:\n\n\t\t\tsocket_errno = ENOBUFS_errno;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tsocket_errno = ESOCKET_errno;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\treturn BSD_SUCCESS;\n\n}", "CodeBleu_score": 41.607847456624256}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret = BSD_ERROR;\n\n\tif (listen(socket, backlog) == 0) {\n\t\tret = BSD_SUCCESS;\n\t} else {\n\t\tswitch (SOCK_ERRNO) {\n\t\tcase SOCK_EACCES:\n\t\t\tret = BSD_EACCES;\n\t\t\tbreak;\n\t\tcase SOCK_EADDRINUSE:\n\t\t\tret = BSD_EADDRINUSE;\n\t\t\tbreak;\n\t\tcase SOCK_EINVAL:\n\t\t\tret = BSD_EINVAL;\n\t\t\tbreak;\n\t\tcase SOCK_ENOTSOCK:\n\t\t\tret = BSD_ENOTSOCK;\n\t\t\tbreak;\n\t\tcase SOCK_EOPNOTSUPP:\n\t\t\tret = BSD_EOPNOTSUPP;\n\t\t\tbreak;\n\t\tcase SOCK_ENOBUFS:\n\t\t\tret = BSD_ENOBUFS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = BSD_ERROR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 38.375775467656666}, {"code": "int BSD_listen(int socket, int backlog){\n\t\n\tint return_value;\n\n\treturn_value = listen(socket, backlog);\n\n\tif (return_value < 0) {\n\n\t\tswitch (errno) {\n\n\t\tcase EBADF:\n\n\t\t\terrno = EBADF;\n\n\t\t\tbreak;\n\n\t\tcase ENOTSOCK:\n\n\t\t\terrno = ENOTSOCK;\n\n\t\t\tbreak;\n\n\t\tcase EADDRINUSE:\n\n\t\t\terrno = EADDRINUSE;\n\n\t\t\tbreak;\n\n\t\tcase EINVAL:\n\n\t\t\terrno = EINVAL;\n\n\t\t\tbreak;\n\n\t\tcase EOPNOTSUPP:\n\n\t\t\terrno = EOPNOTSUPP;\n\n\t\t\tbreak;\n\n\t\tcase ENOBUFS:\n\n\t\t\terrno = ENOBUFS;\n\n\t\t\tbreak;\n\n\t\tcase ENOMEM:\n\n\t\t\terrno = ENOMEM;\n\n\t\t\tbreak;\n\n\t\tcase EACCES:\n\n\t\t\terrno = EACCES;\n\n\t\t\tbreak;\n\n\t\tcase EINVAL:\n\n\t\t\terrno = EINVAL;\n\n\t\t\tbreak;\n\n\t\tcase EFAULT:\n\n\t\t\terrno = EFAULT;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn BSD_ERROR;\n\n\t}\n\n\treturn BSD_SUCCESS;\n\n}", "CodeBleu_score": 42.10469136992493}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\n\tint ret;\n\n\tstruct sockaddr_in addr_in;\n\n\tstruct sockaddr_in6 addr_in6;\n\n\tstruct sockaddr_in6 * addr_in6_ptr = NULL;\n\n\tstruct sockaddr_in * addr_in_ptr = NULL;\n\n\tstruct sockaddr * addr_ptr = NULL;\n\n\tsocklen_t addr_len;\n\n\tuint16_t addr_family;\n\n\tuint32_t addr_family_len = sizeof(addr_family);\n\n\tif (socket < 0) {\n\n\t\tret = BSD_EINVAL;\n\n\t\tgoto done;\n\n\t}\n\n\tif (addr == NULL) {\n\n\t\tret = BSD_EINVAL;\n\n\t\tgoto done;\n\n\t}\n\n\tif (addrlen == NULL) {\n\n\t\tret = BSD_EINVAL;\n\n\t\tgoto done;\n\n\t}\n\n\tif (getsockopt(socket, SOL_SOCKET, SO_TYPE, (char *) &addr_family, &addr_family_len) < 0) {\n\n\t\tret = BSD_EINVAL;\n\n\t\tgoto done;\n\n\t}\n\n\tif (addr_family == SOCK_STREAM) {\n\n\t\tif (getsockname(socket, (struct sockaddr *) &addr_in, (socklen_t *) &addr_len) < 0) {\n\n\t\t\tret = BSD_EINVAL;\n\n\t\t\tgoto done;\n\n\t\t}\n\n\t\taddr_in_ptr = &addr_in;\n\n\t\taddr_ptr = (struct sockaddr *) addr_in_ptr;\n\n\t} else if (addr_family == SOCK_DGRAM) {\n\n\t\tif (getsockname(socket, (struct sockaddr *) &addr_in6, (socklen_t *) &addr_len) < 0) {\n\n\t\t\tret = BSD_EINVAL;\n\n\t\t\tgoto done;\n\n\t\t}\n\n\t\taddr_in6_", "CodeBleu_score": 39.611790068849665}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret;\n\tuint32_t len;\n\n\tif (socket < 0 || socket >= MAX_SOCKET) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (sockets[socket].state != SOCKET_STATE_CONNECTED) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (addr == NULL) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (addrlen == NULL) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (sockets[socket].address_family != BSD_AF_INET) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tlen = sizeof(struct bsd_sockaddr_in);\n\n\tif (len < *addrlen) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tret = accept(socket, (struct sockaddr *) addr, &len);\n\n\tif (ret < 0) {\n\t\treturn BSD_ERROR;\n\t}\n\n\t*addrlen = len;\n\n\treturn ret;\n}", "CodeBleu_score": 39.54834988125254}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\n\tint ret;\n\n\tstruct sockaddr_in * addr_in;\n\n\tstruct sockaddr_in6 * addr_in6;\n\n\tstruct sockaddr_in6_old * addr_in6_old;\n\n\tstruct sockaddr_in_old * addr_in_old;\n\n\tif (addr == NULL) {\n\n\t\tret = accept(socket, NULL, NULL);\n\n\t} else {\n\n\t\tswitch (addr->sa_family) {\n\n\t\tcase AF_INET:\n\n\t\t\taddr_in = (struct sockaddr_in *) addr;\n\n\t\t\tret = accept(socket, (struct sockaddr *) addr_in, (socklen_t *) addrlen);\n\n\t\t\tbreak;\n\n\t\tcase AF_INET6:\n\n\t\t\taddr_in6 = (struct sockaddr_in6 *) addr;\n\n\t\t\tret = accept(socket, (struct sockaddr *) addr_in6, (socklen_t *) addrlen);\n\n\t\t\tbreak;\n\n\t\tcase AF_INET6_OLD:\n\n\t\t\taddr_in6_old = (struct sockaddr_in6_old *) addr;\n\n\t\t\tret = accept(socket, (struct sockaddr *) addr_in6_old, (socklen_t *) addrlen);\n\n\t\t\tbreak;\n\n\t\tcase AF_INET_OLD:\n\n\t\t\taddr_in_old = (struct sockaddr_in_old *) addr;\n\n\t\t\tret = accept(socket, (struct sockaddr *) addr_in_old, (socklen_t *) addrlen);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tret = BSD_EAFNOSUPPORT;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn ret;\n\n}", "CodeBleu_score": 39.68595459163693}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\n    uint32_t time_unix;\n\n    // Get the current time\n    time_unix = getCurrentUnixTime();\n\n    // Check if the time is valid\n    if (time_unix != 0) {\n\n        // Update the JWT with the current time offset\n        updateJWT(time_unix);\n\n        // Initiate the MQTT connection\n        MQTT_Connect();\n\n        // Print a debug message to indicate the connection attempt\n        debug_printInfo(\"Connecting to MQTT broker...\");\n\n        // Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n        g_flags.send_subscribe_packet = true;\n\n    } else {\n\n        // Print a debug message to indicate the connection attempt\n        debug_printError(\"Invalid time\");\n\n    }\n\n}", "CodeBleu_score": 23.914900710947713}, {"code": "static void connectMQTT(){\n\t\n\tif(isTimeValid()){\n\n\t\tupdateJWT();\n\n\t\tdebug_printInfo(\"Attempting to connect to MQTT broker...\");\n\n\t\tmqtt_connect(&mqttClient);\n\n\t\tsetFlag(MQTT_SUBSCRIBE_FLAG);\n\n\t} else {\n\n\t\tdebug_printError(\"Time is invalid. Unable to connect to MQTT broker.\");\n\n\t}\n\n}", "CodeBleu_score": 16.214288363561693}, {"code": "static void connectMQTT(){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "CodeBleu_score": 2.7552018946369774}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tif (CLOUD_isConnected()) {\n\t\tdebug_printInfo(\"CLOUD: Disconnecting...\");\n\t\tMQTT_disconnect(&MQTT_client);\n\t\tMQTT_client.connState = MQTT_DISCONNECTED;\n\t}\n\tdebug_printInfo(\"CLOUD: Disconnected\");\n}", "CodeBleu_score": 50.38056197406263}, {"code": "void CLOUD_disconnect(void){\n\t\tdebug_printInfo(\"CLOUD: Disconnecting from cloud service...\");\n\n\tif (mqtt_client.connection_state == CONNECTED) {\n\t\tdebug_printInfo(\"CLOUD: Disconnecting MQTT client...\");\n\t\tmqtt_disconnect(&mqtt_client);\n\t}\n}", "CodeBleu_score": 47.04578558736245}, {"code": "void CLOUD_disconnect(void){\n\t\tdebug_printInfo(\"CLOUD_disconnect: Disconnecting from cloud service\");\n\tif (mqtt_client.connState == MQTT_CONNECTED) {\n\t\tdebug_printInfo(\"CLOUD_disconnect: Disconnecting MQTT client\");\n\t\tmqtt_disconnect(&mqtt_client);\n\t}\n}", "CodeBleu_score": 44.56720439684294}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n\ttstrWifiInitParam param;\n\ttstrWifiInitEnumType init_param;\n\ttstrM2mWifiConnect connect_param;\n\ttstrM2MWifiWepParams wep_param;\n\ttstrM2mWifiWepParams *wep_param_ptr;\n\tuint8_t dhcp_mode;\n\tuint8_t sec_type;\n\tuint8_t auth_type;\n\tuint8_t *ssid;\n\tuint8_t *password;\n\tuint8_t *ip_address;\n\tuint8_t *gw_address;\n\tuint8_t *netmask;\n\tuint8_t *mac_address;\n\tuint8_t *dhcp_server_address;\n\tuint8_t *dns_address;\n\tuint8_t *dns_address2;\n\tuint8_t *current_ssid;\n\tuint8_t *current_bssid;\n\tuint8_t *current_ip_address;\n\tuint8_t *current_netmask;\n\tuint8_t *current_gateway;\n\tuint8_t *current_dns;\n\tuint8_t *current_dns2;\n\tuint8_t *current_mac_address;\n\tuint8_t *current_dhcp_server_address;\n\tuint8_t *current_proxy_address;\n\tuint8_t *current_proxy_port;\n\tuint8_t *current_proxy_user;\n\tuint8_t *current_proxy_password;\n\tuint8_t *current_proxy_auth_type;\n\tuint8_t *current_proxy_auth_user;\n\tuint8_t *current_proxy_auth_password;\n\tuint8_t *current_proxy_auth_domain;\n\tuint8_t *current_proxy_auth_method;\n\tuint8_t *current_proxy_auth_cert;\n\tuint8_t *current_proxy_auth_cert_key;\n\tuint8_t *current_proxy_auth_cert_key_password;\n\tuint8_t *current_proxy_", "CodeBleu_score": 3.323404535945671}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n\ttstrWifiInitParam param;\n\n\tmemset((uint8_t *)&param, 0, sizeof(param));\n\n\tparam.pfAppWifiCb = wifi_cb;\n\n\tif (M2M_SUCCESS != m2m_wifi_init(&param)) {\n\n\t\tDBG_PRINT(\"Error initializing WINC1500 Wi-Fi driver.\n\");\n\n\t\treturn false;\n\n\t}\n\n\tif (passed_wifi_creds == 0) {\n\n\t\tif (wifi_connectToDefaultAp() == false) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t} else {\n\n\t\tif (wifi_connectToSpecifiedAp() == false) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}", "CodeBleu_score": 30.094699959454736}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\t\n\t// Local variables\n\t\n\tuint8_t ret;\n\t\n\tchar *ssid;\n\t\n\tchar *auth_type;\n\t\n\tchar *password;\n\t\n\t\n\t\n\t// Local variables initialization\n\t\n\tret = M2M_ERR_FAIL;\n\t\n\tssid = NULL;\n\t\n\tauth_type = NULL;\n\t\n\tpassword = NULL;\n\t\n\t\n\t\n\t// If new credentials were passed\n\t\n\tif (passed_wifi_creds) {\n\t\t\n\t\t// Get the SSID, authentication type, and password\n\t\t\n\t\tssid = getSsid();\n\t\t\n\t\tauth_type = getAuthType();\n\t\t\n\t\tpassword = getPassword();\n\t\t\n\t\t\n\t\t\n\t\t// If the SSID, authentication type, and password were all successfully retrieved\n\t\t\n\t\tif (ssid && auth_type && password) {\n\t\t\t\n\t\t\t// Connect to the access point\n\t\t\t\n\t\t\tret = m2m_wifi_connect((char *) ssid, strlen(ssid), (uint8_t *) auth_type, (void *) password, M2M_WIFI_CH_ALL);\n\t\t\t\n\t\t}\n\t\t\n\t\telse {\n\t\t\t\n\t\t\t// Log the error\n\t\t\t\n\t\t\tdebug_printError(WIFI_ERROR_CREDENTIALS_RETRIEVE);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t// Update the networking error status\n\t\t\t\n\t\t\tupdateNetworkingErrorStatus(WIFI_ERROR_CREDENTIALS_RETRIEVE);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t// Return false\n\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\t// Otherwise, if default credentials were passed\n\t\n\telse {\n\t\t\n\t\t// Connect to the access point\n\t\t\n\t\tret = m2m_wifi_connect((char *) DEFAULT_SSID, str", "CodeBleu_score": 46.84568744614441}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t  const client = new AWSAppSyncClient({\n    url: awsconfig.aws_appsync_graphqlEndpoint,\n    region: awsconfig.aws_appsync_region,\n    auth: {\n      type: awsconfig.aws_appsync_authenticationType,\n      apiKey: awsconfig.aws_appsync_apiKey,\n    },\n    disableOffline: true,\n  });\n\n  const query = gql`\n    query GetSensors {\n      sensors {\n        id\n        name\n        latitude\n        longitude\n        sensorType\n        value\n      }\n    }\n  `;\n\n  const { data } = await client.query({ query });\n\n  if (data.sensors.length > 0) {\n    console.log(\"Sensors retrieved:\", data.sensors);\n\n    for (let sensor of data.sensors) {\n      // Create a marker for each sensor\n      var el = document.createElement(\"div\");\n      el.className = \"marker\";\n      el.style.backgroundImage =\n        \"url('https://docs.mapbox.com/help/demos/custom-markers-gl-js/mapbox-icon.png')\";\n      el.style.backgroundSize = \"cover\";\n      el.style.width = \"50px\";\n      el.style.height = \"50px\";\n      el.style.borderRadius = \"50%\";\n      el.title = sensor.name;\n      el.addEventListener(\"click\", function () {\n        console.log(\"clicked \" + sensor.name);\n      });\n\n      // Add the marker to the map\n      new maplibregl.Marker({\n        element: el,\n      })\n        .setLngLat([sensor.longitude, sensor.latitude])\n        .addTo(map);\n    }\n  } else {\n    console.log(\"No sensors found.\");\n  }\n}", "CodeBleu_score": 36.332596493250215}, {"code": "async function DisplaySensors(map){\n\t    try {\n        const client = new AWSAppSyncClient({\n            url: \"https://xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.appsync-api.us-west-2.amazonaws.com/graphql\",\n            region: \"us-west-2\",\n            auth: {\n                type: \"API_KEY\",\n                apiKey: \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n            }\n        });\n        const query = gql`\n            query getSensors {\n                getSensors {\n                    sensorId\n                    sensorType\n                    sensorLocation {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        `;\n        const { data } = await client.query({ query });\n        if (data.getSensors.length > 0) {\n            console.log(\"Retrieved sensors\");\n            data.getSensors.forEach(sensor => {\n                const marker = new maplibregl.Marker({ color: \"red\" }).setLngLat([sensor.sensorLocation.longitude, sensor.sensorLocation.latitude]).addTo(map);\n            });\n        }\n    } catch (err) {\n        console.log(\"Error retrieving sensors: \", err);\n    }\n}", "CodeBleu_score": 36.96727943343902}, {"code": "async function DisplaySensors(map){\n\t    try {\n        const client = new AWSAppSyncClient({\n            url: GRAPHQL_ENDPOINT,\n            region: AWS_REGION,\n            auth: {\n                type: AUTH_TYPE,\n                apiKey: API_KEY\n            },\n            disableOffline: true\n        });\n\n        const sensorQuery = gql`\n            query GetSensors {\n                getSensors {\n                    sensorId\n                    sensorName\n                    sensorLat\n                    sensorLong\n                    sensorElevation\n                    sensorValue\n                    sensorType\n                    sensorUnits\n                }\n            }\n        `;\n\n        const { data } = await client.query({\n            query: sensorQuery\n        });\n\n        if (data.getSensors.length > 0) {\n            console.log(\"Sensors retrieved\");\n\n            for (let i = 0; i < data.getSensors.length; i++) {\n                let sensor = data.getSensors[i];\n\n                let el = document.createElement('div');\n                el.className = 'marker';\n                el.style.backgroundImage =\n                    'url(https://docs.mapbox.com/help/demos/custom-markers-gl-js/mapbox-icon.png)';\n                el.style.backgroundSize = 'cover';\n                el.style.width = '50px';\n                el.style.height = '50px';\n                el.style.borderRadius = '50%';\n                el.title = sensor.sensorName;\n\n                let popup = new maplibregl.Popup({ offset: 25 })\n                    .setHTML(\n                        `<h3>${sensor.sensorName}</h3><p>${sensor.sensorType} (${sensor.sensorUnits})</p><p>${sensor.sensorValue}</p>`\n                    )\n                    .addTo(map);\n\n                new maplibregl.Marker({\n                    element: el,\n                    anchor: 'bottom'\n                })\n                    .setLngLat([sensor.sensorLong, sensor.s", "CodeBleu_score": 33.17890755358398}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = 'rgba(255, 165, 0, 0.5)';\n  marker.style.border = '2px solid rgb(255, 165, 0)';\n  return marker;\n}", "CodeBleu_score": 44.00476995343869}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor-marker\";\n    marker.style.borderColor = \"#555\";\n    marker.style.backgroundColor = \"#555\";\n    return marker;\n}", "CodeBleu_score": 44.594825834945986}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.backgroundColor = sensor.color;\n    marker.style.border = '2px solid black';\n    return marker;\n}", "CodeBleu_score": 47.83060810106311}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    if module_name in hass.data:\n        return hass.data[module_name]\n\n    path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n\n    try:\n        module = await async_import_module(path)\n    except ImportError as err:\n        logging.getLogger(__name__).error(\n            \"Unable to import mfa module %s: %s\", module_name, err\n        )\n        raise\n\n    if module.REQUIREMENTS:\n        await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, module.DEPENDENCIES\n        )\n\n    hass.data[module_name] = module\n    return module\n\n", "CodeBleu_score": 41.09994512319278}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module = await async_import_module(f\"homeassistant.auth.mfa_modules.{module_name}\")\n    if module is None:\n        logging.getLogger(__name__).error(f\"Error loading multi-factor auth module {module_name}\")\n        raise HomeAssistantError(f\"Error loading multi-factor auth module {module_name}\")\n    if not module.REQUIREMENTS and not module.DEPENDENCIES:\n        return module\n    if not hass.data.get(HassKey(\"mfa_modules_setup\")):\n        hass.data[HassKey(\"mfa_modules_setup\")] = set()\n    if module_name in hass.data[HassKey(\"mfa_modules_setup\")]:\n        return module\n    if not await requirements.async_process_requirements(\n        hass, module_name, module.REQUIREMENTS, module.DEPENDENCIES\n    ):\n        return None\n    hass.data[HassKey(\"mfa_modules_setup\")].add(module_name)\n    return module\n\n", "CodeBleu_score": 36.71687478625273}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    # Construct the module path\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n\n    # Attempt to import the module\n    module = await async_import_module(hass, module_path)\n\n    if module is None:\n        logging.getLogger(__name__).error(f\"Failed to import {module_path}\")\n        raise HomeAssistantError(f\"Failed to import {module_path}\")\n\n    # Check if the module has requirements\n    if hasattr(module, \"REQUIREMENTS\"):\n        # Check if the module's requirements have already been processed\n        if not hass.data.get(HassKey(\"auth/mfa_module_requirements_processed\")):\n            # Process the module's requirements\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n            # Mark the module's requirements as processed\n            hass.data[HassKey(\"auth/mfa_module_requirements_processed\")] = True\n\n    return module\n\n", "CodeBleu_score": 36.611613916976474}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if not self.data.get(user_id):\n        self.data[user_id] = setup_data.get(\"pin\")\n    else:\n        self.data[user_id] = setup_data.get(\"pin\")\n    return True\n\n", "CodeBleu_score": 33.20736219121351}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n    return True\n\n", "CodeBleu_score": 35.27506592053247}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Get the PIN from the setup data\n    pin = setup_data.get(\"pin\")\n\n    # Get the data list\n    data = await self.async_get_user_data(user_id)\n\n    # Check if the user already has an entry in the internal data list\n    if user_id in data:\n        # Update the PIN\n        data[user_id][\"pin\"] = pin\n    else:\n        # Add a new entry with the user ID and PIN to the data list\n        data[user_id] = {\n            \"pin\": pin\n        }\n\n    # Save the data list\n    await self.async_set_user_data(user_id, data)\n\n", "CodeBleu_score": 36.10770924807068}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        data = await self._store.async_load()\n        self._user_settings = OrderedDict()\n\n        if data is not None:\n            for user_id, user_data in data.items():\n                self._user_settings[user_id] = NotifySetting(\n                    user_id,\n                    user_data[\"name\"],\n                    user_data[\"language\"],\n                    user_data[\"mode\"],\n                    user_data[\"sensor_ids\"],\n                    user_data[\"sensor_types\"],\n                    user_data[\"sensor_names\"],\n                    user_data[\"sensor_icons\"],\n                    user_data[\"sensor_units\"],\n                    user_data[\"sensor_decimals\"],\n                    user_data[\"sensor_round_digits\"],\n                    user_data[\"sensor_max_length\"],\n                    user_data[\"sensor_min_length\"],\n                    user_data[\"sensor_icons\"],\n                    user_data[\"sensor_icons_color\"],\n                    user_data[\"sensor_icons_size\"],\n                    user_data[\"sensor_icons_show\"],\n                    user_data[\"sensor_icons_only\"],\n                    user_data[\"sensor_icons_only_color\"],\n                    user_data[\"sensor_icons_only_size\"],\n                    user_data[\"sensor_icons_only_show\"],\n                    user_data[\"sensor_icons_only_show_unavailable\"],\n                    user_data[\"sensor_icons_only_show_unavailable_color\"],\n                    user_data[\"sensor_icons_only_show_unavailable_size\"],\n                    user_data[\"sensor_icons_only_show_unavailable_show\"],\n                    user_data[\"sensor_icons_only_show_unavailable_show_unavailable\"],\n                    user_data[\"sensor_icons_only_show_unavailable_show_unavailable_color\"],\n                    user_data[\"sensor_icons_only_show_unavailable_show", "CodeBleu_score": 26.480269136134098}, {"code": "async def _async_load(self) -> None\n\t\n    if self._user_settings is not None:\n        return\n\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        data = await self._store.async_load()\n        self._user_settings = {}\n        if data is not None:\n            for user_id, user_data in data.items():\n                self._user_settings[user_id] = NotifySetting(\n                    user_id,\n                    user_data.get(ATTR_INCLUDE, []),\n                    user_data.get(ATTR_EXCLUDE, []),\n                )\n\n", "CodeBleu_score": 42.154549442436796}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is None:\n            data = await self._store.async_load()\n            if data is None:\n                data = {}\n            self._user_settings = OrderedDict()\n            for user_id, user_settings in data.items():\n                self._user_settings[user_id] = NotifySetting(\n                    user_id,\n                    user_settings[\"name\"],\n                    user_settings[\"targets\"],\n                    user_settings[\"include\"],\n                    user_settings[\"exclude\"],\n                )\n\n", "CodeBleu_score": 35.530930237593466}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load_user_settings()\n    settings = self._user_settings.get(user_id)\n    if settings is None:\n        return False\n    return await self._async_validate_user_input(user_id, settings, user_input)\n\n", "CodeBleu_score": 43.505703419854434}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    settings = await self.async_get_settings(user_id)\n    if settings is None:\n        return False\n    return await self.hass.async_add_executor_job(settings.validate, user_input)\n\n", "CodeBleu_score": 38.5879819155738}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_user_settings(user_id)\n    user_settings = self.user_settings.get(user_id)\n    if not user_settings:\n        return False\n    return await self._async_validate_user_input(user_id, user_input, user_settings)\n\n", "CodeBleu_score": 42.94249829567563}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entities.get(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.devices.get(entity.device_id)\n    if device is None:\n        return None\n    if device.area_id is None:\n        return None\n    return area_dict.get(device.area_id)\n\n", "CodeBleu_score": 57.581645236447265}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    try:\n        entity_entry = perm_lookup.entities[entity_id]\n    except KeyError:\n        return None\n\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if not device_entry:\n        return None\n\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 57.03233275230104}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n\n    entity_entry = perm_lookup.entities.get(entity_id)\n\n    if entity_entry is None:\n        return None\n\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 64.42890356638978}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, rules in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = rules\n            else:\n                merged_policy[category].update(rules)\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 42.56460575230319}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, category_policy in policy.items():\n            if category not in seen_categories:\n                merged_policy[category] = category_policy\n                seen_categories.add(category)\n            else:\n                merged_policy[category] = {\n                    **merged_policy[category],\n                    **category_policy,\n                }\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 40.822178912976284}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, rules in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = rules\n            else:\n                merged_policy[category] = merge_rules(merged_policy[category], rules)\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 44.067790351299415}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(\n            f\"homeassistant.auth.providers.{provider}\"\n        )\n    except ImportError as err:\n        logging.getLogger(__name__).error(\n            \"Unable to import auth provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider}: {err}\"\n        ) from err\n\n    if not getattr(module, \"REQUIREMENTS\", None):\n        return module\n\n    if not hass.config.skip_pip:\n        reqs = await requirements.async_get_integration_with_requirements(\n            hass, domain=\"auth\", name=provider\n        )\n        if reqs.requirements:\n            await requirements.async_process_requirements(\n                hass, reqs.requirements, provider\n            )\n\n    return module\n\n", "CodeBleu_score": 54.03829855764517}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    module = await async_import_module(\n        \"homeassistant.auth.providers.\" + provider\n    )\n    if not module:\n        raise HomeAssistantError(\n            f\"Unable to import provider {provider} from homeassistant.auth.providers\"\n        )\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not isinstance(module.REQUIREMENTS, Mapping):\n        raise HomeAssistantError(\n            f\"Provider {provider} has an invalid REQUIREMENTS mapping\"\n        )\n    if not hasattr(module, \"CONDITION\"):\n        raise HomeAssistantError(\n            f\"Provider {provider} has no CONDITION defined\"\n        )\n    if not callable(module.CONDITION):\n        raise HomeAssistantError(\n            f\"Provider {provider} has an invalid CONDITION defined\"\n        )\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        raise HomeAssistantError(\n            f\"Provider {provider} has no CONFIG_SCHEMA defined\"\n        )\n    if not hasattr(module, \"async_setup\"):\n        raise HomeAssistantError(\n            f\"Provider {provider} has no async_setup defined\"\n        )\n    if not hasattr(module, \"async_setup_flow\"):\n        raise HomeAssistantError(\n            f\"Provider {provider} has no async_setup_flow defined\"\n        )\n    if not hasattr(module, \"async_setup_flow_handler\"):\n        raise HomeAssistantError(\n            f\"Provider {provider} has no async_setup_flow_handler defined\"\n        )\n    if not hasattr(module, \"async_validate_config\"):\n        raise HomeAssistantError(\n            f\"Provider {provider} has no async_validate_config defined\"\n        )\n    if not hasattr(module, \"async_validate_mfa_modules\"):\n        raise HomeAssistantError(\n            f\"Provider {provider} has no async_validate_mfa_modules defined\"\n        )\n    if not hasattr(module, \"async_create_mfa", "CodeBleu_score": 29.32730867997084}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    module = await async_import_module(\n        \"homeassistant.auth.providers.{}\".format(provider)\n    )\n\n    if not module:\n        raise HomeAssistantError(\"Unable to find provider {}\".format(provider))\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    reqs = requirements.Requirements(module.REQUIREMENTS)\n\n    if not reqs.is_satisfied(hass):\n        if not reqs.has_requirements:\n            logging.getLogger(__name__).error(\n                \"Provider %s has no requirements, please check the configuration\",\n                provider,\n            )\n            raise HomeAssistantError(\n                \"Provider {} has no requirements, please check the configuration\".format(\n                    provider\n                )\n            )\n\n        logging.getLogger(__name__).error(\n            \"Provider %s has unmet dependencies: %s\",\n            provider,\n            \", \".join(reqs.missing_requirements),\n        )\n        raise HomeAssistantError(\n            \"Provider {} has unmet dependencies: {}\".format(\n                provider, \", \".join(reqs.missing_requirements)\n            )\n        )\n\n    return module\n\n", "CodeBleu_score": 40.09410863456382}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    store = Store(self.hass, 1, \"auth_users\")\n    raw_users = await store.async_load()\n    if raw_users is None:\n        raw_users = []\n    users = []\n    for user in raw_users:\n        if CONF_ID not in user:\n            user[CONF_ID] = user[\"username\"]\n        users.append(user)\n    self._users = users\n\n", "CodeBleu_score": 23.56780435052201}, {"code": "async def async_load(self) -> None\n\t\n    store = Store(self.hass, self.store_name)\n    data = await store.async_load()\n    if data is None:\n        data = {\"users\": []}\n    if not isinstance(data[\"users\"], list):\n        raise HomeAssistantError(\n            f\"The data in {self.store_name} is not valid: 'users' is not a list\"\n        )\n    self.users = data[\"users\"]\n    # check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"] != user[\"username\"].lower():\n            user[\"username\"] = user[\"username\"].lower()\n    # check for non-normalized identifiers\n    for user in self.users:\n        if user[\"identifier\"] != user[\"identifier\"].lower():\n            user[\"identifier\"] = user[\"identifier\"].lower()\n\n", "CodeBleu_score": 27.725551044586954}, {"code": "async def async_load(self) -> None\n\t\n    store = self._store\n    data = await store.async_load()\n\n    if data is None:\n        data = {\"users\": []}\n\n    # Normalize usernames to lowercase\n    for user in data[\"users\"]:\n        if \"username\" in user and user[\"username\"] is not None:\n            user[\"username\"] = user[\"username\"].lower()\n\n    self._data = data\n\n", "CodeBleu_score": 36.97765423690046}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt(12))\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise ir.InvalidAuth\n    raise ir.InvalidAuth\n\n", "CodeBleu_score": 41.549842996107486}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            hashed_password = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(\"utf-8\"), hashed_password):\n                return\n            else:\n                raise ir.InvalidAuth\n    raise ir.InvalidAuth\n\n", "CodeBleu_score": 40.67833832503824}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = base64.b64decode(user.password_hash)\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            raise ir.InvalidAuth\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise ir.InvalidAuth\n    raise ir.InvalidAuth\n\n", "CodeBleu_score": 40.76473679366095}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(self.hass.data[DOMAIN][CONF_ID], \"user_not_found\")\n\n", "CodeBleu_score": 31.28710723593396}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    for user in self.users:\n        if user.name == normalized_username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 29.131773325642214}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    for user in self.users:\n        if user[CONF_ID] == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(f\"user_not_found: {username}\")\n\n", "CodeBleu_score": 25.351130171786206}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    await self.async_load()\n    try:\n        del self.data[credentials.id]\n    except KeyError:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 33.623882411851405}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        await self.async_load()\n    if credentials.data[CONF_ID] in self.data:\n        del self.data[credentials.data[CONF_ID]]\n        await self.async_save()\n\n", "CodeBleu_score": 47.70261585740172}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        self.data = await self.async_load()\n    if credentials.data[CONF_ID] in self.data:\n        del self.data[credentials.data[CONF_ID]]\n        await self.async_save()\n\n", "CodeBleu_score": 43.310202459604774}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    # Calculate the timeout for each thread\n    thread_timeout = timeout / len(threads)\n    # Join threads\n    joined_threads = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread_id = thread.ident\n            if thread_id is not None:\n                # Attempt to join the thread\n                thread.join(timeout=thread_timeout)\n                # If the thread is still alive, log it\n                if thread.is_alive():\n                    if log:\n                        logging.debug(\n                            f\"Thread with id {thread_id} did not join within {thread_timeout} seconds.\"\n                        )\n                # If the thread is no longer alive, add it to the joined set\n                else:\n                    joined_threads.add(thread)\n            # If the thread has no identifier, add it to the joined set\n            else:\n                joined_threads.add(thread)\n    # Attempt to raise a SystemExit exception in any remaining threads\n    for thread in threads - joined_threads:\n        if thread.is_alive():\n            thread.raise_exception(SystemExit)\n    # Return the set of successfully joined threads\n    return joined_threads\n\n", "CodeBleu_score": 40.66413639454407}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads = set()\n    for thread in threads:\n        if thread.is_alive() and hasattr(thread, \"ident\"):\n            try:\n                thread.join(timeout)\n            except Exception as e:\n                if log:\n                    logging.error(\n                        f\"Error while joining thread {thread.ident}: {e.__class__.__name__}: {e}\"\n                    )\n                raise\n            if not thread.is_alive():\n                joined_threads.add(thread)\n        else:\n            joined_threads.add(thread)\n    if log:\n        for thread in threads - joined_threads:\n            logging.warning(f\"Thread {thread.ident} is still running!\")\n    for thread in joined_threads:\n        if thread.is_alive():\n            try:\n                thread._tstate_lock.release()\n            except Exception as e:\n                if log:\n                    logging.error(\n                        f\"Error while interrupting thread {thread.ident}: {e.__class__.__name__}: {e}\"\n                    )\n                raise\n    return joined_threads\n\n", "CodeBleu_score": 35.83780027743079}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not hasattr(thread, \"ident\"):\n            joined.add(thread)\n            continue\n        if log:\n            logging.warning(f\"Thread {thread.ident} still running, interrupting...\")\n        thread.join(timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n        else:\n            logging.warning(f\"Thread {thread.ident} still running, raising SystemExit...\")\n            thread.raise_exc(SystemExit)\n    return joined\n\n", "CodeBleu_score": 45.29098930705261}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get the total timeout\n    total_timeout = threading.TIMEOUT_MAX\n\n    # Get all non-main, non-daemon, alive threads\n    all_threads = [thread for thread in threading.enumerate() if thread.is_alive() and not thread.isDaemon() and not thread == threading.current_thread()]\n\n    # Calculate the timeout for each thread\n    timeout = total_timeout / len(all_threads)\n\n    # Join each thread\n    for thread in all_threads:\n        try:\n            thread.join(timeout=timeout)\n        except RuntimeError:\n            logging.warning(f\"Failed to join thread {thread.name}\")\n\n", "CodeBleu_score": 30.01155785272813}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get the current thread\n    current_thread = threading.current_thread()\n\n    # Get the main thread\n    main_thread = threading.main_thread()\n\n    # Get all non-main, non-daemon, alive threads\n    non_main_non_daemon_alive_threads = [\n        thread for thread in threading.enumerate()\n        if thread is not main_thread and not thread.daemon and thread.is_alive()\n    ]\n\n    # Get the total shutdown timeout\n    total_shutdown_timeout = current_thread.get_ident()\n\n    # Get the number of non-main, non-daemon, alive threads\n    num_non_main_non_daemon_alive_threads = len(non_main_non_daemon_alive_threads)\n\n    # Get the timeout for each thread\n    timeout_for_each_thread = total_shutdown_timeout / num_non_main_non_daemon_alive_threads\n\n    # Join each thread\n    for thread in non_main_non_daemon_alive_threads:\n        # Join the thread\n        thread.join(timeout_for_each_thread)\n\n        # If the thread is still alive\n        if thread.is_alive():\n            # Log a warning\n            logging.warning(\n                f'Failed to join thread \"{thread.name}\" in \"{timeout_for_each_thread}\" seconds.')\n\n", "CodeBleu_score": 35.25489097216473}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get the total shutdown timeout\n    total_timeout = threading.active_count() * 5\n\n    # Get all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if thread is not threading.current_thread() and thread.is_alive() and not thread.daemon]\n\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = total_timeout / len(threads)\n\n    # Attempt to join each thread within the calculated timeout\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            logging.warning(f\"Failed to join thread {thread.name}.\")\n\n", "CodeBleu_score": 33.03421714389907}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_state:\n        self.dispatcher_signal.emit(remaining_with_setup_started)\n        self._previous_state = remaining_with_setup_started\n", "CodeBleu_score": 49.27842985965313}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_remaining_with_setup_started:\n        self._previous_remaining_with_setup_started = remaining_with_setup_started\n        self._dispatcher.send(\n            self._dispatcher_signal, remaining_with_setup_started=remaining_with_setup_started\n        )\n\n", "CodeBleu_score": 41.3231497088236}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_setups:\n        remaining_setups = remaining_with_setup_started or self._remaining_setups\n        self._remaining_setups = remaining_setups\n        self._dispatcher_signal.send(self, remaining_setups=remaining_setups)\n\n", "CodeBleu_score": 48.99186962788647}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.cache_dir.is_dir():\n        config.cache_dir.mkdir()\n\n    bluetooth_file = config.cache_dir / \"bluetooth.py\"\n\n    if not bluetooth_file.exists():\n        bluetooth_file.touch()\n\n    bluetooth_content = bluetooth_file.read_text()\n    generated_content = generate_bluetooth_content(integrations, config)\n\n    if generated_content != bluetooth_content:\n        config.add_error(\n            \"bluetooth.py\",\n            \"bluetooth.py is not up to date\",\n            f\"Run the following command to fix it:\n", "CodeBleu_score": 42.53882416949713}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.get_option(\"validate_bluetooth\"):\n        return\n    if not os.path.isfile(config.bluetooth_path):\n        config.add_error(\"bluetooth.py file is missing\", \"bluetooth.py file is missing. Please create it.\", \"bluetooth.py file is missing. Please create it.\")\n        return\n    if not os.access(config.bluetooth_path, os.W_OK):\n        config.add_error(\"bluetooth.py file is not writable\", \"bluetooth.py file is not writable. Please make it writable.\", \"bluetooth.py file is not writable. Please make it writable.\")\n        return\n    current_content = read_file(config.bluetooth_path)\n    generated_content = generate_content(integrations)\n    if current_content == generated_content:\n        return\n    config.add_error(\"bluetooth.py file is outdated\", \"bluetooth.py file is outdated. Please update it.\", \"bluetooth.py file is outdated. Please update it.\")\n    config.add_suggestion(\"bluetooth.py file is outdated\", \"bluetooth.py file is outdated. Please update it.\", \"bluetooth.py file is outdated. Please update it.\", \"Update bluetooth.py\", \"Update bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\", \"bluetooth.py\",", "CodeBleu_score": 27.989072059409402}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    # Generate Bluetooth content based on provided integrations\n    bluetooth_content = generate_bluetooth_content(integrations)\n\n    # Read current content of bluetooth.py\n    bluetooth_file_path = config.path / \"bluetooth.py\"\n    bluetooth_file_content = bluetooth_file_path.read_text()\n\n    # Validate Bluetooth content\n    if validate_bluetooth_content(bluetooth_content, bluetooth_file_content):\n        # If the contents are the same, write the generated content to the configuration cache\n        config.cache[\"bluetooth.py\"] = bluetooth_content\n    else:\n        # If the contents differ, add an error to the configuration\n        config.add_error(\n            \"bluetooth.py\",\n            \"bluetooth.py is not up to date.\",\n            \"Run 'python3 -m homeassistant --script bluetooth_fix' to fix this.\",\n        )\n\n", "CodeBleu_score": 39.04200599997048}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp, err := resty.New().R().\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"client_id\":     d.ClientID,\n\t\t\t\"client_secret\": d.ClientSecret,\n\t\t}).\n\t\tPost(\"https://api.dropboxapi.com/oauth2/token\")\n\tif err != nil {\n\t\tlogger.Error(\"[Dropbox] refreshToken: \", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"[Dropbox] refreshToken: \", zap.String(\"status\", resp.Status()), zap.String(\"body\", resp.String()))\n\t\treturn fmt.Errorf(\"[Dropbox] refreshToken: status %d: %s\", resp.StatusCode(), resp.String())\n\t}\n\n\tvar res struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tUID         string `json:\"uid\"`\n\t}\n\tif err = resp.JSON(&res); err != nil {\n\t\tlogger.Error(\"[Dropbox] refreshToken: \", zap.Error(err))\n\t\treturn err\n\t}\n\n\td.AccessToken = res.AccessToken\n\treturn nil\n}", "CodeBleu_score": 49.74814684558672}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tlogger.Log.Info(\"refreshToken\")\n\tclient := resty.New()\n\tresp, err := client.R().\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t}).\n\t\tSetAuthToken(fmt.Sprintf(\"%s:%s\", d.AppKey, d.AppSecret)).\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tPost(fmt.Sprintf(\"%s/oauth2/token\", d.Endpoint))\n\n\tif err != nil {\n\t\tlogger.Log.Error(\"refreshToken\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Log.Error(\"refreshToken\", zap.String(\"status\", resp.Status()), zap.String(\"body\", resp.String()))\n\t\treturn fmt.Errorf(\"status code: %d, body: %s\", resp.StatusCode(), resp.String())\n\t}\n\n\tvar tokenResponse TokenResponse\n\terr = resp.JSON(&tokenResponse)\n\tif err != nil {\n\t\tlogger.Log.Error(\"refreshToken\", zap.Error(err))\n\t\treturn err\n\t}\n\n\td.AccessToken = tokenResponse.AccessToken\n\treturn nil\n}", "CodeBleu_score": 51.202557960064}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tlogger.Log.Info(\"refreshToken\")\n\tclient := resty.New()\n\tresp, err := client.R().\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"client_id\":     d.AppKey,\n\t\t\t\"client_secret\": d.AppSecret,\n\t\t}).\n\t\tPost(\"https://api.dropboxapi.com/oauth2/token\")\n\n\tif err != nil {\n\t\tlogger.Log.Error(\"refreshToken error\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Log.Error(\"refreshToken error\", zap.Error(fmt.Errorf(\"status code: %d\", resp.StatusCode())))\n\t\treturn fmt.Errorf(\"status code: %d\", resp.StatusCode())\n\t}\n\n\tvar tokenResponse struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tUID         string `json:\"uid\"`\n\t}\n\n\tif err := resp.JSON(&tokenResponse); err != nil {\n\t\tlogger.Log.Error(\"refreshToken error\", zap.Error(err))\n\t\treturn err\n\t}\n\n\td.AccessToken = tokenResponse.AccessToken\n\n\treturn nil\n}", "CodeBleu_score": 49.612237016683736}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tif d.token == nil {\n\t\treturn nil, fmt.Errorf(\"Google Drive: Access token is missing\")\n\t}\n\tvar request *http.Request\n\tvar err error\n\tif callback != nil {\n\t\trequest, err = callback(d.token, url, method)\n\t} else {\n\t\trequest, err = d.buildRequest(url, method)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresponse, err := d.client.Do(request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode == 401 {\n\t\tif err := d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trequest, err = d.buildRequest(url, method)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse, err = d.client.Do(request)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn nil, fmt.Errorf(\"Google Drive: HTTP error %d: %s\", response.StatusCode, response.Status)\n\t}\n\tif resp != nil {\n\t\tif err := d.parseResponse(response, resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn d.readResponseBody(response)\n}", "CodeBleu_score": 52.348036850392845}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq, err := http.NewRequestWithContext(context.Background(), method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.accessToken)\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\trespBody, err := d.client.Do(req, resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn respBody, nil\n\t}\n\trespBody, err := d.client.Do(req, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn respBody, nil\n}", "CodeBleu_score": 49.919109305437544}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar respBody []byte\n\tvar err error\n\n\t// Retry request up to 3 times if it fails\n\tfor i := 0; i < 3; i++ {\n\t\tif respBody, err = d.requestOnce(url, method, callback, resp); err == nil {\n\t\t\treturn respBody, nil\n\t\t}\n\t}\n\n\treturn nil, err\n}", "CodeBleu_score": 24.085551954673285}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Check if the context has been cancelled\n\tif err := ctx.Err(); err != nil {\n\t\treturn err\n\t}\n\n\t// Create a new request\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, stream)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the appropriate headers\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"Content-Length\", strconv.FormatInt(stream.Size(), 10))\n\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", stream.Size()-1, stream.Size()))\n\n\t// Send the request\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the request was successful\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"failed to upload chunk: %d\", resp.StatusCode)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 34.14806477693641}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Set the chunk size to 50MB.\n\tchunkSize := int64(52428800)\n\n\t// Create a new request.\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the content type to \"application/octet-stream\".\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\n\t// Set the range to the size of the file.\n\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", stream.Size, stream.Size))\n\n\t// Create a new HTTP client.\n\tclient := http.Client{}\n\n\t// Create a new buffer to store the file chunk.\n\tbuf := make([]byte, chunkSize)\n\n\t// Loop through the file chunk by chunk.\n\tfor {\n\t\t// Check for context cancellation.\n\t\tif err := ctx.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Read the chunk into the buffer.\n\t\tn, err := stream.Read(buf)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the chunk size is 0, then the file has been uploaded completely.\n\t\tif n == 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Create a new request body.\n\t\treq.Body = io.NopCloser(bytes.NewReader(buf[:n]))\n\n\t\t// Send the request to the server.\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Close the request body.\n\t\tif err := resp.Body.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check the response status code.\n\t\tif resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {\n\t\t\treturn fmt.Errorf(\"unexpected status code: %d", "CodeBleu_score": 40.298095798204216}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Get the file size\n\tfileSize := stream.Size()\n\n\t// Create a buffer to store the chunk\n\tchunk := make([]byte, utils.ChunkSize)\n\n\t// Create a Resty Client\n\tclient := resty.New()\n\n\t// Create a request object\n\treq := client.R()\n\n\t// Create a context for the request\n\treq = req.SetContext(ctx)\n\n\t// Create a header object for the request\n\theader := req.Header\n\n\t// Set the content type to \"application/octet-stream\"\n\theader.Set(\"Content-Type\", \"application/octet-stream\")\n\n\t// Set the range header to \"bytes 0-<chunk_size>\"\n\theader.Set(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", utils.ChunkSize, fileSize))\n\n\t// Create a buffer to store the data\n\tdata := make([]byte, utils.ChunkSize)\n\n\t// Read the first chunk\n\t_, err := stream.Read(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the request body to the chunk\n\treq.SetBody(data)\n\n\t// Make the request\n\tresp, err := req.Put(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the request was successful\n\tif resp.StatusCode() != http.StatusOK && resp.StatusCode() != http.StatusCreated {\n\t\treturn fmt.Errorf(\"error uploading file: %s\", resp.Status())\n\t}\n\n\t// Loop until the file is completely uploaded\n\tfor {\n\t\t// Read the next chunk\n\t\t_, err = stream.Read(chunk)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// Create a new request\n\t\treq = client.R()\n\n\t\t// Set the request context\n\t\treq = req.SetContext(ctx)\n\n\t\t// Set the header\n\t\theader = req.Header\n\n\t\t//", "CodeBleu_score": 44.05020703197252}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req model.UmountStorage\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.ErrCodeParameter, common_err.ErrMsgParameter)\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.ErrCodeParameter, common_err.ErrMsgParameter)\n\t}\n\tif err := service.MyService.UmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.ErrCodeUmountStorage, err.Error())\n\t}\n\tif err := service.MyService.DeleteStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.ErrCodeDeleteStorage, err.Error())\n\t}\n\treturn ctx.JSON(common_err.SuccessCode, common_err.SuccessMsg)\n}", "CodeBleu_score": 37.76201615184295}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tlogger.Log.Info(\"UmountStorage\")\n\tvar mount_point string\n\tif err := ctx.Bind(&mount_point); err != nil {\n\t\tlogger.Log.Error(\"Bind\", zap.Error(err))\n\t\treturn ctx.JSON(common_err.ErrBind, err.Error())\n\t}\n\tif mount_point == \"\" {\n\t\tlogger.Log.Error(\"mount_point is empty\")\n\t\treturn ctx.JSON(common_err.ErrParams, \"mount_point is empty\")\n\t}\n\tif err := service.MyService.UmountStorage(mount_point); err != nil {\n\t\tlogger.Log.Error(\"UmountStorage\", zap.Error(err))\n\t\treturn ctx.JSON(common_err.ErrUmountStorage, err.Error())\n\t}\n\treturn ctx.JSON(200, \"success\")\n}", "CodeBleu_score": 35.896847331815195}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tlogger.Log.Info(\"UmountStorage\")\n\tvar req model.UmountStorageReq\n\terr := ctx.Bind(&req)\n\tif err != nil {\n\t\tlogger.Log.Error(\"Bind\", zap.Error(err))\n\t\treturn ctx.JSON(common_err.ErrCodeParameter, common_err.ErrMsgParameter)\n\t}\n\tif req.MountPoint == \"\" {\n\t\tlogger.Log.Error(\"MountPoint\", zap.Error(err))\n\t\treturn ctx.JSON(common_err.ErrCodeParameter, common_err.ErrMsgParameter)\n\t}\n\t// \u5378\u8f7d\n\terr = service.MyService.UmountStorage(req.MountPoint)\n\tif err != nil {\n\t\tlogger.Log.Error(\"UmountStorage\", zap.Error(err))\n\t\treturn ctx.JSON(common_err.ErrCodeService, common_err.ErrMsgService)\n\t}\n\t// \u5220\u9664\u914d\u7f6e\n\terr = service.MyService.DeleteStorageConfig(req.MountPoint)\n\tif err != nil {\n\t\tlogger.Log.Error(\"DeleteStorageConfig\", zap.Error(err))\n\t\treturn ctx.JSON(common_err.ErrCodeService, common_err.ErrMsgService)\n\t}\n\treturn ctx.JSON(common_err.ErrCodeSuccess, common_err.ErrMsgSuccess)\n}", "CodeBleu_score": 44.12743775964473}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"filePath\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, &model.Error{\n\t\t\tCode:    http.StatusBadRequest,\n\t\t\tMessage: \"filePath is missing\",\n\t\t})\n\t}\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, &model.Error{\n\t\t\tCode:    http.StatusNotFound,\n\t\t\tMessage: \"file not found\",\n\t\t})\n\t}\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 46.86328660879595}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tpath := ctx.QueryParam(\"path\")\n\t// Check if the file path is provided\n\tif path == \"\" {\n\t\t// Return a JSON error message if the path is missing\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"Missing file path\",\n\t\t})\n\t}\n\t// Check if the file exists\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\t// Return a JSON error message if the file does not exist\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"File not found\",\n\t\t})\n\t}\n\t// Return the file to the client\n\treturn ctx.File(path)\n}", "CodeBleu_score": 41.74141994108109}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"path parameter is missing\")\n\t}\n\n\tif !file.Exists(path) {\n\t\treturn ctx.JSON(http.StatusNotFound, \"file does not exist\")\n\t}\n\n\treturn ctx.File(path)\n}", "CodeBleu_score": 36.89039898092117}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]string\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrorText(common_err.ErrBind))\n\t}\n\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrorText(common_err.ErrBadParam))\n\t}\n\tservice.MyService.Notify().Send(name, message)\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: true, Message: \"success\"})\n}", "CodeBleu_score": 58.75082999238982}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message model.Message\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrBadRequest.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, service.NotifyMessage(message.Name, message.Message))\n}", "CodeBleu_score": 35.92105888201709}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrorText(common_err.ErrBind))\n\t}\n\tname := ctx.Param(\"name\")\n\tservice.Notify.Send(name, message)\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: true, Message: \"success\"})\n}", "CodeBleu_score": 49.3413994663539}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\n\tc, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn err\n\t}\n\tdefer c.Close()\n\tservice.NotifyService.Add(c)\n\tservice.NotifyService.Run()\n\tfor {\n\t\t_, message, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"recv: %s\n\", message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 42.75396038339727}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\n\t// Upgrade HTTP request to WebSocket\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tservice.NotifyWS.Add(ws)\n\n\t// Start the message sending service\n\tgo service.NotifyWS.SendMessage()\n\n\t// Continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, p, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(\"Message type:\", ws.MessageType())\n\t\tfmt.Println(\"Message:\", string(p))\n\t}\n\n\t// Remove the WebSocket connection from the list of connections\n\tservice.NotifyWS.Remove(ws)\n\n\treturn nil\n}", "CodeBleu_score": 44.6322863646808}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tfmt.Println(\"NotifyWS: \", err)\n\t\treturn ctx.JSON(http.StatusInternalServerError, types.Result{\n\t\t\tCode: http.StatusInternalServerError,\n\t\t\tMsg:  err.Error(),\n\t\t})\n\t}\n\tservice.NotifyWS.Add(conn)\n\tservice.NotifyWS.Start()\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"NotifyWS: \", err)\n\t\t\treturn ctx.JSON(http.StatusInternalServerError, types.Result{\n\t\t\t\tCode: http.StatusInternalServerError,\n\t\t\t\tMsg:  err.Error(),\n\t\t\t})\n\t\t}\n\t\tfmt.Println(\"NotifyWS: \", message)\n\t}\n}", "CodeBleu_score": 39.003493774036954}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar info = make(map[string]interface{})\n\tinfo[\"architecture\"] = runtime.GOARCH\n\tinfo[\"drive_model\"] = runtime.GOOS\n\tinfo[\"cpu_info\"] = nil\n\tcpuinfo, err := service.MyService.System().GetCPUInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err.SUCCESS, Message: oasis_err.GetMsg(oasis_err.SUCCESS), Data: info})\n\t}\n\tinfo[\"cpu_info\"] = cpuinfo\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err.SUCCESS, Message: oasis_err.GetMsg(oasis_err.SUCCESS), Data: info})\n}", "CodeBleu_score": 44.45411345196704}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar hardwareInfo model2.HardwareInfo\n\thardwareInfo.Architecture = runtime.GOARCH\n\thardwareInfo.DriveModel = runtime.GOOS\n\thardwareInfo.CPU = runtime.NumCPU()\n\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n}", "CodeBleu_score": 13.927213053053894}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar hardwareInfo model2.HardwareInfo\n\thardwareInfo.Cpu = runtime.NumCPU()\n\thardwareInfo.Arch = runtime.GOARCH\n\thardwareInfo.Disk = service.MyService.System().GetDiskInfo()\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err.SUCCESS, Message: oasis_err.GetMsg(oasis_err.SUCCESS), Data: hardwareInfo})\n}", "CodeBleu_score": 36.186184641492204}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\t// Get all services that match \"casaos*\"\n\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a map of running and not running services\n\tservicesMap := make(map[bool]*[]string)\n\tservicesMap[true] = &[]string{}\n\tservicesMap[false] = &[]string{}\n\n\t// Iterate through the services and categorize them based on their running status\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\t*servicesMap[true] = append(*servicesMap[true], service.Name)\n\t\t} else {\n\t\t\t*servicesMap[false] = append(*servicesMap[false], service.Name)\n\t\t}\n\t}\n\n\treturn servicesMap, nil\n}", "CodeBleu_score": 53.36281456614037}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 73.62934850117406}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar running []string\n\tvar notRunning []string\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 75.41248309365682}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tif i.eventBus == nil {\n\t\treturn\n\t}\n\tdata, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"failed to marshal message\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\terr = i.eventBus.Publish(name, data)\n\tif err != nil {\n\t\tlogger.Error(\"failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t}\n}", "CodeBleu_score": 41.11142194199432}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tif i.bus != nil {\n\t\tif err := i.bus.Publish(name, message); err != nil {\n\t\t\tlogger.Error(\"Failed to publish event\", zap.Error(err))\n\t\t}\n\t}\n}", "CodeBleu_score": 15.888263679084824}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\ti.publisher.Publish(name, message)\n}", "CodeBleu_score": 6.259326044255826}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tvar err error\n\tvar server string\n\tvar client *message_bus.ClientWithResponses\n\tvar cacheKey string\n\n\tcacheKey = \"message_bus\"\n\tif c.cache.Get(cacheKey) != nil {\n\t\tserver = c.cache.Get(cacheKey).(string)\n\t} else {\n\t\tserver, err = external.GetMessageBusAddress()\n\t\tif err != nil {\n\t\t\tserver = \"error\"\n\t\t}\n\t\tc.cache.Set(cacheKey, server, cache.DefaultExpiration)\n\t}\n\n\tclient = message_bus.NewClientWithResponses(server, websocket.Dialer{})\n\treturn client\n}", "CodeBleu_score": 33.121897379707974}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tvar server string\n\tif config.ServerInfo.MessageBus.Server != \"\" {\n\t\tserver = config.ServerInfo.MessageBus.Server\n\t} else {\n\t\tserver = \"http://127.0.0.1:50051\"\n\t}\n\treturn message_bus.NewClientWithResponses(server, &websocket.Dialer{})\n}", "CodeBleu_score": 28.35777341069745}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tvar mb = message_bus.NewClientWithResponses(c.getMessageBusAddress())\n\treturn mb\n}", "CodeBleu_score": 18.5058679852502}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\t// Check for a forwarded address\n\tip := request.Header.Get(\"X-Forwarded-For\")\n\n\t// If nothing found, fallback to the request IP\n\tif ip == \"\" {\n\t\tip = strings.Split(request.RemoteAddr, \":\")[0]\n\t}\n\n\t// Return the IP address\n\treturn ip\n}", "CodeBleu_score": 36.51303633589828}, {"code": "func GetIP(request *http.Request) string{\n\t\tvar ip string\n\tif ip = request.Header.Get(\"x-forwarded-for\"); ip != \"\" {\n\t\tip = strings.Split(ip, \",\")[0]\n\t}\n\tif ip == \"\" {\n\t\tip = strings.Split(request.RemoteAddr, \":\")[0]\n\t}\n\tip = strings.TrimSpace(ip)\n\tif ip != \"::1\" && ip != \"::ffff:127.0.0.1\" {\n\t\treturn ip\n\t}\n\treturn \"127.0.0.1\"\n}", "CodeBleu_score": 55.6844531854492}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = strings.Split(request.RemoteAddr, \":\")[0]\n\t}\n\tip = strings.TrimSpace(ip)\n\tip = strings.Replace(ip, \"::ffff:\", \"\", -1)\n\tip = strings.Replace(ip, \"::1\", \"127.0.0.1\", -1)\n\tip = strings.Replace(ip, \"localhost\", \"127.0.0.1\", -1)\n\treturn ip\n}", "CodeBleu_score": 48.00202430595384}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Define paths for the modules directory and the entry file, ensuring the entry file exists.\n\tmodulesDir := filepath.Join(config.AppInfo.WorkPath, \"modules\")\n\tentryFile := filepath.Join(config.AppInfo.WorkPath, \"system\", \"entry.json\")\n\tif !file.CheckNotExist(entryFile) {\n\t\tfile.CheckNotExist(entryFile)\n\t}\n\n\t// Read each module directory for entry.json files, concatenate their content into a single JSON array, and write this array to the entry file path.\n\tvar entryJSON []byte\n\terr := filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tlogger.Log.Error(\"GenreateSystemEntry\", zap.Any(\"err\", err))\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif filepath.Base(path) != \"entry.json\" {\n\t\t\treturn nil\n\t\t}\n\t\tentry, err := os.ReadFile(path)\n\t\tif err != nil {\n\t\t\tlogger.Log.Error(\"GenreateSystemEntry\", zap.Any(\"err\", err))\n\t\t\treturn err\n\t\t}\n\t\tentryJSON = append(entryJSON, entry...)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlogger.Log.Error(\"GenreateSystemEntry\", zap.Any(\"err\", err))\n\t}\n\terr = os.WriteFile(entryFile, entryJSON, 0644)\n\tif err != nil {\n\t\tlogger.Log.Error(\"GenreateSystemEntry\", zap.Any(\"err\", err))\n\t}\n}", "CodeBleu_score": 43.86502121482055}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// \u5b9a\u4e49\u6a21\u5757\u76ee\u5f55\u8def\u5f84\u548c\u5165\u53e3\u6587\u4ef6\u8def\u5f84\uff0c\u786e\u4fdd\u5165\u53e3\u6587\u4ef6\u5b58\u5728\n\tmodulesPath := filepath.Join(common.CasaOSDiskPath, \"modules\")\n\tentryFilePath := filepath.Join(modulesPath, \"entry.json\")\n\n\t// \u8bfb\u53d6\u6bcf\u4e2a\u6a21\u5757\u76ee\u5f55\u4e2d\u7684entry.json\u6587\u4ef6\uff0c\u5c06\u5b83\u4eec\u7684\u5185\u5bb9\u8fde\u63a5\u5230\u5355\u4e2aJSON\u6570\u7ec4\u4e2d\uff0c\u5e76\u5c06\u6b64\u6570\u7ec4\u5199\u5165\u5165\u53e3\u6587\u4ef6\u8def\u5f84\n\tif _, err := os.Stat(modulesPath); !os.IsNotExist(err) {\n\t\t// \u8bfb\u53d6\u6a21\u5757\u76ee\u5f55\n\t\tdirs, err := os.ReadDir(modulesPath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"read dir error\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\n\t\t// \u8bfb\u53d6\u6bcf\u4e2a\u6a21\u5757\u76ee\u5f55\u4e2d\u7684entry.json\u6587\u4ef6\n\t\tvar entryJSONArray []byte\n\t\tfor _, dir := range dirs {\n\t\t\tif dir.IsDir() {\n\t\t\t\tentryFilePath := filepath.Join(modulesPath, dir.Name(), \"entry.json\")\n\t\t\t\tif _, err := os.Stat(entryFilePath); !os.IsNotExist(err) {\n\t\t\t\t\tentryJSON, err := os.ReadFile(entryFilePath)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogger.Error(\"read entry.json error\", zap.Error(err))\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tentryJSONArray = append(entryJSONArray, entryJSON...)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// \u5199\u5165\u5165\u53e3\u6587\u4ef6\n\t\tif err := os.WriteFile(entryFilePath, entryJSONArray, 0644); err != nil {\n\t\t\tlogger.Error(\"write entry.json error\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.775509134272156}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tvar (\n\t\terr                  error\n\t\tentryFilePath        string\n\t\tmodulesDirectoryPath string\n\t\tentryFileContent     []byte\n\t\tmodulesDirectoryInfo []os.FileInfo\n\t\tmoduleDirectoryPath  string\n\t\tmoduleEntryFilePath  string\n\t\tmoduleEntryFile      *os.File\n\t\tmoduleEntryFileBytes []byte\n\t)\n\n\t// Define the path to the entry file.\n\tentryFilePath = filepath.Join(common.CasaOSRootPath, \"entry.json\")\n\n\t// Define the path to the modules directory.\n\tmodulesDirectoryPath = filepath.Join(common.CasaOSRootPath, \"modules\")\n\n\t// Ensure the entry file exists.\n\tif _, err = os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\t// If the entry file does not exist, create it.\n\t\tif _, err = os.Create(entryFilePath); err != nil {\n\t\t\tlogger.Error(\"error creating entry file: \" + err.Error())\n\t\t}\n\t}\n\n\t// Read the modules directory.\n\tif modulesDirectoryInfo, err = ioutil.ReadDir(modulesDirectoryPath); err != nil {\n\t\tlogger.Error(\"error reading modules directory: \" + err.Error())\n\t}\n\n\t// Loop through each module directory.\n\tfor _, moduleDirectoryInfo := range modulesDirectoryInfo {\n\t\t// Ensure the module directory is a directory.\n\t\tif moduleDirectoryInfo.IsDir() {\n\t\t\t// Define the path to the module directory.\n\t\t\tmoduleDirectoryPath = filepath.Join(modulesDirectoryPath, moduleDirectoryInfo.Name())\n\n\t\t\t// Define the path to the module entry file.\n\t\t\tmoduleEntryFilePath = filepath.Join(moduleDirectoryPath, \"entry.json\")\n\n\t\t\t// Ensure the module entry file exists.\n\t\t\tif _, err = os.Stat(moduleEntryFilePath); os.IsNotExist(err) {\n\t\t\t\t// If the module entry file does not exist, create it.\n\t\t\t\tif _, err = os.Create(moduleEntryFilePath); err != nil {\n\t\t\t\t", "CodeBleu_score": 41.407378291791666}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range ifaces {\n\t\tif strings.Contains(i.Name, \"lo\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"docker\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"veth\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"br-\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"tun\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"virbr\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"kube\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"flannel\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"cni\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"br-\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"br-\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"br-\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"br-\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"br-\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"br-\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"br-\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"br-\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i.Name, \"br-\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(i", "CodeBleu_score": 47.775566109409795}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tvar macAddress string\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range ifaces {\n\t\tif i.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif i.Flags&net.FlagLoopback != 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\taddrs, err := i.Addrs()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmacAddress = i.HardwareAddr.String()\n\t\t\treturn macAddress, nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"are you connected to the network?\")\n}", "CodeBleu_score": 56.84842066319514}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// handle err\n\tvar macAddress string\n\tfor _, i := range ifaces {\n\t\tif i.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif i.Flags&net.FlagLoopback != 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\taddrs, err := i.Addrs()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue // not an ipv4 address\n\t\t\t}\n\t\t\tmacAddress = i.HardwareAddr.String()\n\t\t\treturn macAddress, nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"are you connected to the network?\")\n}", "CodeBleu_score": 56.242501892409315}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t ret = 0;\n    if (pRequest == NULL || pTscObj == NULL) {\n        return -1;\n    }\n    pthread_mutex_lock(&pTscObj->lock);\n    if (pTscObj->pRequestObj != NULL) {\n        pTscObj->pRequestObj->pNext = pRequest;\n    } else {\n        pTscObj->pRequestObj = pRequest;\n    }\n    pTscObj->requestCount++;\n    if (pTscObj->pAppObj != NULL) {\n        pTscObj->pAppObj->requestCount++;\n        pTscObj->pAppObj->currentRequestCount++;\n    }\n    pthread_mutex_unlock(&pTscObj->lock);\n    ret = addRef(pRequest);\n    if (ret != 0) {\n        return ret;\n    }\n    logDebug(\"debug: register request %s\", pRequest->id);\n    return 0;\n}", "CodeBleu_score": 36.92393527449292}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t ret = 0;\n\tchar *pLogStr = NULL;\n\n\tif (pRequest == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (pTscObj == NULL) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Increment the request count for the TSC object\n\t */\n\tpTscObj->iRequestCount++;\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary, including total and current request counts\n\t */\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpTscObj->pAppInfo->iRequestCount++;\n\t\tpTscObj->pAppInfo->iCurrentRequestCount++;\n\t}\n\n\t/*\n\t * Log debug information about the new request\n\t */\n\tif (pRequest->iRequestType == TREQ_TYPE_HTTP) {\n\t\tpLogStr = (char *) malloc(sizeof(char) * 1024);\n\t\tif (pLogStr == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(pLogStr, 0, sizeof(char) * 1024);\n\t\tsnprintf(pLogStr, 1024, \"Registered HTTP request %d for TSC %s\", pRequest->iRequestId, pTscObj->szTscName);\n\t\tlogDebug(\"main\", pLogStr);\n\t\tfree(pLogStr);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 38.36153088147263}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\n\tif (pRequest == NULL) {\n\t\treturn (S_ERROR);\n\t}\n\n\tif (pTscObj == NULL) {\n\t\treturn (S_ERROR);\n\t}\n\n\t/*\n\t * Add a reference to the request object\n\t */\n\tpRequest->refCount++;\n\n\t/*\n\t * Increment the request count for the associated TSC object\n\t */\n\tpTscObj->requestCount++;\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary, including total and current request counts\n\t */\n\tif (pTscObj->pAppInfo != NULL) {\n\n\t\tpTscObj->pAppInfo->requestCount++;\n\n\t\tpTscObj->pAppInfo->currentRequestCount++;\n\t}\n\n\t/*\n\t * Log debug information about the new request\n\t */\n\tlogDebug(\"registerRequest: new request registered with TSC object %s\", pTscObj->name);\n\n\treturn (S_OK);\n}", "CodeBleu_score": 23.781782209383802}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->pDatabase) {\n\t\tif (strcmp(pRequest->pDatabase, exceptDb) != 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (pRequest->pDatabaseList) {\n\t\tchar* p = pRequest->pDatabaseList;\n\t\tchar* pEnd = p + strlen(p);\n\t\twhile (p < pEnd) {\n\t\t\tchar* pDb = p;\n\t\t\twhile (*p && *p != ',') {\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (p != pDb) {\n\t\t\t\tif (strcmp(pDb, exceptDb) != 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*p) {\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 46.44624983370777}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->pDatabase == NULL) {\n    return false;\n  }\n\n  if (strcmp(pRequest->pDatabase, exceptDb) == 0) {\n    return false;\n  }\n\n  if (pRequest->pDatabaseList == NULL) {\n    return true;\n  }\n\n  char *pDatabase = pRequest->pDatabaseList;\n  while (pDatabase != NULL) {\n    char *pSchema = strchr(pDatabase, ':');\n    if (pSchema != NULL) {\n      pSchema++;\n    } else {\n      pSchema = pDatabase;\n    }\n\n    if (strcmp(pSchema, exceptDb) == 0) {\n      return false;\n    }\n\n    pDatabase = strchr(pDatabase, ',');\n    if (pDatabase != NULL) {\n      pDatabase++;\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 54.17507039371679}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  char* db = pRequest->db;\n  if (db == NULL) {\n    return false;\n  }\n  if (strcmp(db, exceptDb) == 0) {\n    return false;\n  }\n  if (pRequest->dbs != NULL) {\n    int i;\n    for (i = 0; i < pRequest->dbs->length; i++) {\n      char* db = (char*)pRequest->dbs->array[i];\n      if (db != NULL) {\n        char* schema = strchr(db, '.');\n        if (schema != NULL) {\n          *schema = '\\0';\n        }\n        if (strcmp(db, exceptDb) == 0) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "CodeBleu_score": 57.466393338434266}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\n    bool rfp = false;\n\n    if (code == 4000) {\n        if (msgType != MSG_TYPE_RPC_REQ) {\n            rfp = true;\n        }\n    }\n\n    return rfp;\n}", "CodeBleu_score": 25.989461298328802}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    bool rfp = false;\n\n    if (code == 0) {\n        return rfp;\n    }\n\n    switch (msgType) {\n        case MSG_TYPE_RPC_REQ:\n        case MSG_TYPE_RPC_REQ_WITH_RETURN:\n        case MSG_TYPE_RPC_REQ_WITH_RETURN_AND_WAIT:\n        case MSG_TYPE_RPC_REQ_WITH_RETURN_AND_WAIT_AND_CALLBACK:\n        case MSG_TYPE_RPC_REQ_WITH_RETURN_AND_WAIT_AND_CALLBACK_AND_CALLBACK:\n        case MSG_TYPE_RPC_REQ_WITH_RETURN_AND_WAIT_AND_CALLBACK_AND_CALLBACK_AND_CALLBACK:\n        case MSG_TYPE_RPC_REQ_WITH_RETURN_AND_WAIT_AND_CALLBACK_AND_CALLBACK_AND_CALLBACK_AND_CALLBACK:\n            rfp = true;\n            break;\n        default:\n            rfp = false;\n            break;\n    }\n\n    return rfp;\n}", "CodeBleu_score": 30.05283448657119}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  bool rfp = false;\n\n  switch (code) {\n    case CATALOG_ERR_NO_CATALOG:\n    case CATALOG_ERR_NO_CATALOG_SERVER:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_TIMEOUT:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_TYPE:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_VERSION:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_REPLY:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_REPLY_TYPE:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_REPLY_VERSION:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_REPLY_REPLY:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_REPLY_REPLY_TYPE:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_REPLY_REPLY_VERSION:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_REPLY_REPLY_REPLY:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_REPLY_REPLY_REPLY_TYPE:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY_BAD_REPLY_REPLY_REPLY_VERSION:\n    case CATALOG_ERR_NO_CATALOG_SERVER_REPLY", "CodeBleu_score": 22.695396671449426}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\n\tSHashObj *pObj = NULL;\n\tRequest *pRequest = NULL;\n\tQuery *pQuery = NULL;\n\n\t/* Iterate through the hash table of requests. */\n\tfor (pObj = pRequests->pFirst; pObj != NULL; pObj = pObj->pNext) {\n\n\t\t/* Acquire the request by its request ID. */\n\t\tpRequest = (Request *)getObjByID(pRequests, pObj->iObjID);\n\n\t\tif (pRequest == NULL) {\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Stop the query associated with the request. */\n\t\tpQuery = pRequest->pQuery;\n\n\t\tif (pQuery != NULL) {\n\n\t\t\tstopQuery(pQuery);\n\t\t}\n\n\t\t/* Release the request. */\n\t\treleaseObj(pRequests, pRequest);\n\t}\n}", "CodeBleu_score": 40.75632301935794}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t    SHashIter *pIter = createHashIter(pRequests);\n    SHashObj *pObj = NULL;\n    while ((pObj = getNextObj(pIter)) != NULL) {\n        TRequest *pRequest = (TRequest *) pObj->pContent;\n        if (pRequest->pQuery != NULL) {\n            stopQuery(pRequest->pQuery);\n        }\n        releaseRequest(pRequest);\n    }\n    releaseHashIter(pIter);\n}", "CodeBleu_score": 39.37546642603288}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i;\n\tint iNum;\n\tint iRequestId;\n\tSHashObj *pRequest;\n\tSHashObj *pQuery;\n\tSHashObj *pQueryNext;\n\tSHashObj *pQueryPrev;\n\tSHashObj *pRequestNext;\n\tSHashObj *pRequestPrev;\n\tSHashObj *pRequestsNext;\n\tSHashObj *pRequestsPrev;\n\tSHashObj *pRequestsTmp;\n\tTQuery *pTQuery;\n\tTQuery *pTQueryNext;\n\tTQuery *pTQueryPrev;\n\tTQuery *pTQueryTmp;\n\tTQuery *pTQueryTmp2;\n\tTQuery *pTQueryTmp3;\n\tTQuery *pTQueryTmp4;\n\tTQuery *pTQueryTmp5;\n\tTQuery *pTQueryTmp6;\n\tTQuery *pTQueryTmp7;\n\tTQuery *pTQueryTmp8;\n\tTQuery *pTQueryTmp9;\n\tTQuery *pTQueryTmp10;\n\tTQuery *pTQueryTmp11;\n\tTQuery *pTQueryTmp12;\n\tTQuery *pTQueryTmp13;\n\tTQuery *pTQueryTmp14;\n\tTQuery *pTQueryTmp15;\n\tTQuery *pTQueryTmp16;\n\tTQuery *pTQueryTmp17;\n\tTQuery *pTQueryTmp18;\n\tTQuery *pTQueryTmp19;\n\tTQuery *pTQueryTmp20;\n\tTQuery *pTQueryTmp21;\n\tTQuery *pTQueryTmp22;\n\tTQuery *pTQueryTmp23;\n\tTQuery *pTQueryTmp24;\n\tTQuery *pTQueryTmp25;\n\tTQuery *pTQueryTmp26;\n\tTQuery *pTQueryTmp27;\n\tTQuery *pTQueryTmp28;\n\tTQuery *pTQueryTmp29;\n\tT", "CodeBleu_score": 6.511378174738887}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t  if (!gp_crashReport) {\n    return;\n  }\n  if (!ttas_int(&gp_crashReport->clientStop, 1)) {\n    tlog(\"crash report thread already stopped\");\n    return;\n  }\n  while (gp_crashReport->clientStop) {\n    tsleep(100);\n  }\n}", "CodeBleu_score": 57.194096808476736}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportEnabled()) {\n\t\treturn;\n\t}\n\n\tif (__sync_bool_compare_and_swap(&clientStop, 0, 1)) {\n\t\twhile (clientStop) {\n\t\t\tosSleep(1000);\n\t\t}\n\t} else {\n\t\tclientLog(L_DEBUG, \"Crash report thread already stopped\");\n\t}\n}", "CodeBleu_score": 49.35344457239893}, {"code": "void tscStopCrashReport(){\n\t  if (!tcs_crashReportingEnabled) {\n    return;\n  }\n\n  if (!tcs_atomicCompareAndExchange(&tcs_clientStop, 1, 0)) {\n    tcs_log(\n        \"tscStopCrashReport: Crash report thread already stopped\",\n        TCS_LOG_ERROR);\n    return;\n  }\n\n  while (tcs_clientStop) {\n    tcs_osSleep(1000);\n  }\n}", "CodeBleu_score": 59.866196985865}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t rc = 0;\n    int32_t numViews = 0;\n    int32_t numCols = 0;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t k = 0;\n    char *viewName = NULL;\n    char *colName = NULL;\n    char *colType = NULL;\n    char *colTypeMod = NULL;\n    int32_t colTypeLen = 0;\n    int32_t colTypeModLen = 0;\n    int32_t viewId = 0;\n    int32_t colId = 0;\n    int32_t colLen = 0;\n    int32_t colPrecision = 0;\n    int32_t colScale = 0;\n    int32_t colNullable = 0;\n    int32_t colUpdatable = 0;\n    int32_t colCaseSensitive = 0;\n    int32_t colSearchable = 0;\n    int32_t colSigned = 0;\n    int32_t colMoney = 0;\n    int32_t colAutoIncrement = 0;\n    int32_t colUnique = 0;\n    int32_t colPartition = 0;\n    int32_t colUnused = 0;\n    int32_t colCollation = 0;\n    int32_t colOrder = 0;\n    int32_t colOrderNulls = 0;\n    int32_t colTableId = 0;\n    int32_t colTableOid = 0;\n    int32_t colCollationOid = 0;\n    int32_t colOrderOid = 0;\n    int32_t colOrderNullsOid = 0;\n    int32_t colTypeOid = 0;\n    int32_t colTypeModOid = 0;\n    int32_t colTypeLen", "CodeBleu_score": 10.918730262400636}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t rc = 0;\n    int32_t i;\n    int32_t numViews;\n    int32_t numColumns;\n    int32_t numCols;\n    int32_t numCols2;\n    int32_t numCols3;\n    int32_t numCols4;\n    int32_t numCols5;\n    int32_t numCols6;\n    int32_t numCols7;\n    int32_t numCols8;\n    int32_t numCols9;\n    int32_t numCols10;\n    int32_t numCols11;\n    int32_t numCols12;\n    int32_t numCols13;\n    int32_t numCols14;\n    int32_t numCols15;\n    int32_t numCols16;\n    int32_t numCols17;\n    int32_t numCols18;\n    int32_t numCols19;\n    int32_t numCols20;\n    int32_t numCols21;\n    int32_t numCols22;\n    int32_t numCols23;\n    int32_t numCols24;\n    int32_t numCols25;\n    int32_t numCols26;\n    int32_t numCols27;\n    int32_t numCols28;\n    int32_t numCols29;\n    int32_t numCols30;\n    int32_t numCols31;\n    int32_t numCols32;\n    int32_t numCols33;\n    int32_t numCols34;\n    int32_t numCols35;\n    int32_t numCols36;\n    int32_t numCols37;", "CodeBleu_score": 9.941237606208034}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t rc = 0;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t k = 0;\n    int32_t viewId = 0;\n    int32_t numCols = 0;\n    int32_t numViews = 0;\n    int32_t numUpdates = 0;\n    int32_t numDeletes = 0;\n    int32_t numViewsWithErrors = 0;\n    int32_t numColsWithErrors = 0;\n    int32_t numErrors = 0;\n    int32_t numViewsWithoutErrors = 0;\n    int32_t numColsWithoutErrors = 0;\n    int32_t numViewsWithoutErrorsBeforeError = 0;\n    int32_t numColsWithoutErrorsBeforeError = 0;\n    int32_t numViewsWithoutErrorsAfterError = 0;\n    int32_t numColsWithoutErrorsAfterError = 0;\n    int32_t numViewsWithoutErrorsBeforeLastError = 0;\n    int32_t numColsWithoutErrorsBeforeLastError = 0;\n    int32_t numViewsWithoutErrorsAfterLastError = 0;\n    int32_t numColsWithoutErrorsAfterLastError = 0;\n    int32_t numViewsWithoutErrorsBeforeLastLastError = 0;\n    int32_t numColsWithoutErrorsBeforeLastLastError = 0;\n    int32_t numViewsWithoutErrorsAfterLastLastError = 0;\n    int32_t numColsWithoutErrorsAfterLastLastError = 0;\n    int32_t numViewsWithoutErrorsBeforeLastLastLastError = 0;\n    int32_t numColsWithoutErrorsBeforeLastLastLastError = 0;\n    int32_t numViewsWithoutErrorsAfterLastLastLastError = 0;\n    int32_t numColsWithoutErrorsAfterLastLastLastError = ", "CodeBleu_score": 10.362898991276898}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    cos_pool_t *p = (cos_pool_t *) callbackData;\n    cos_list_t *list;\n    cos_object_content_length_t *content_length;\n\n    list = cos_list_get_next(&properties->response_properties);\n    while (list) {\n        content_length = cos_list_entry(list, cos_object_content_length_t, node);\n        if (content_length->length > 0) {\n            cos_list_init(&p->body);\n            cos_list_add_tail(&content_length->node, &p->body);\n            break;\n        }\n        list = cos_list_get_next(list);\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 50.250698403242076}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    cos_pool_t *p = (cos_pool_t *) callbackData;\n    cos_status_t *s = NULL;\n\n    if (properties->contentLength > 0) {\n        s = cos_status_create(p);\n        s->content_length = properties->contentLength;\n    } else {\n        s = cos_status_create(p);\n        s->content_length = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 69.24090424979264}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tCosStatus *cos_status = (CosStatus *) callbackData;\n\tcos_status->content_length = properties->contentLength;\n\tif (properties->contentLength > 0) {\n\t\tcos_status->status = S3StatusOK;\n\t} else {\n\t\tcos_status->status = S3StatusAborted;\n\t}\n\treturn cos_status->status;\n}", "CodeBleu_score": 59.047046738271106}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t    // Attempt to create checkpoint backup directory\n    if (mkdir(CHECKPOINT_BACKUP_DIR, 0777) == -1) {\n        fprintf(stderr, \"Error: Failed to create checkpoint backup directory.", "CodeBleu_score": 1.1311608053117745}, {"code": "void startRsync(){\n\t\t// Create the checkpoint backup directory\n\tif (mkdir(CHECKPOINT_BACKUP_DIR, 0777) == -1) {\n\t\tlogError(\"Failed to create checkpoint backup directory\");\n\t\treturn;\n\t}\n\t\n\t// Remove empty directories\n\tremoveEmptyDirs(CHECKPOINT_BACKUP_DIR);\n\t\n\t// Generate the Rsync configuration file\n\tif (!generateRsyncConfigFile(CHECKPOINT_BACKUP_DIR, CHECKPOINT_BACKUP_PORT)) {\n\t\tlogError(\"Failed to generate Rsync configuration file\");\n\t\treturn;\n\t}\n\t\n\t// Start the Rsync server\n\tchar command[MAX_COMMAND_LENGTH];\n\tsprintf(command, \"rsync --daemon --no-detach --config=%s\", RSYNC_CONFIG_FILE);\n\tif (system(command) != 0) {\n\t\tlogError(\"Failed to start Rsync server\");\n\t} else {\n\t\tlogInfo(\"Rsync server started\");\n\t}\n}", "CodeBleu_score": 24.12610229244879}, {"code": "void startRsync(){\n\t\n    // Create the checkpoint backup directory if it does not exist\n    if (mkdir(CHECKPOINT_BACKUP_DIR, 0777) == -1) {\n        fprintf(stderr, \"Error creating checkpoint backup directory", "CodeBleu_score": 1.0798335428915262}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID [\" + dispatcherId + \"] is not registered!\");\n    }\n    dispatcher.shutdownNow();\n}", "CodeBleu_score": 71.24062506891}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Lock lock = dispatchersLock.writeLock();\n    lock.lock();\n    try {\n        Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n        if (dispatcher == null) {\n            throw new IllegalArgumentException(\"Dispatcher with ID [\" + dispatcherId + \"] is not registered!\");\n        }\n        dispatcher.shutdownNow();\n    } finally {\n        lock.unlock();\n    }\n}", "CodeBleu_score": 64.62089032825307}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new IllegalArgumentException(\"Dispatcher with id \" + dispatcherId + \" is not registered!\");\n    }\n    dispatcher.shutdownNow();\n}", "CodeBleu_score": 65.43256492175917}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t     Set<TbActorId> children = parentToChildren.get(parent);\n     if (children != null) {\n         children.stream().filter(childFilter).forEach(child -> {\n             try {\n                 if (highPriority) {\n                     context().forward(msg, child);\n                 } else {\n                     context().tell(msg, child);\n                 }\n             } catch (Exception e) {\n                 log.warn(\"[{}] Failed to broadcast msg: {}\", child, msg, e);\n             }\n         });\n     }\n }", "CodeBleu_score": 61.08673083100984}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t     Set<TbActorId> children = getChildren(parent);\n     if (children != null) {\n         children.stream().filter(childFilter).forEach(child -> {\n             try {\n                 if (highPriority) {\n                     getOrCreateActor(child).tellWithHighPriority(msg);\n                 } else {\n                     getOrCreateActor(child).tell(msg);\n                 }\n             } catch (Exception e) {\n                 log.warn(\"[{}] Failed to send msg: {}\", child, msg, e);\n             }\n         });\n     }\n }", "CodeBleu_score": 53.85276358845456}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t     Set<TbActorId> children = actorChildren.get(parent);\n     if (children != null) {\n         children.stream().filter(childFilter).forEach(child -> {\n             try {\n                 if (highPriority) {\n                     getOrCreateActor(child).tellWithHighPriority(msg);\n                 } else {\n                     getOrCreateActor(child).tell(msg);\n                 }\n             } catch (Exception e) {\n                 log.warn(\"[{}] Failed to send msg to child: {}\", parent, child, e);\n             }\n         });\n     }\n }", "CodeBleu_score": 57.67963138577016}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destroyed.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    } else {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (failed.get()) {\n                failed.set(false);\n                init(context);\n            } else {\n                log.trace(\"[{}] Message {} is ignored because the actor is in the process of destruction.\", entityId, msg);\n            }\n        } else {\n            log.trace(\"[{}] Message {} is ignored because the actor is in the process of destruction.\", entityId, msg);\n        }\n    }\n}", "CodeBleu_score": 59.39368474281104}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (isDestroyInProgress()) {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            try {\n                if (!init(getActorCtx())) {\n                    log.warn(\"[{}] Failed to reinitialize the actor. Destroying it.\", getActorId());\n                    getActorCtx().stop(getSelf());\n                }\n            } catch (Exception e) {\n                log.warn(\"[{}] Failed to reinitialize the actor. Destroying it.\", getActorId(), e);\n                getActorCtx().stop(getSelf());\n            }\n        } else {\n            msg.getCallback().onFailure(new TbActorStopedException(getActorId()));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        process(getActorCtx());\n    }\n}", "CodeBleu_score": 58.2723790697218}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (destroying.get()) {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (failed.get()) {\n                if (reinit()) {\n                    return;\n                }\n            } else {\n                return;\n            }\n        }\n        msg.getCallback().onFailure(new TbActorStopReason(TbActorStopReason.STOPPED_ACTOR_REASON));\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    }\n}", "CodeBleu_score": 58.68669048413205}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    if (log.isTraceEnabled()) {\n        log.trace(\"[{}] Processing mailbox.\", entityId);\n    }\n    if (throughputLimit > 0) {\n        long start = System.nanoTime();\n        long processed = 0;\n        while (processed < throughputLimit) {\n            TbActorMsg msg = highPriorityMsgQueue.poll();\n            if (msg != null) {\n                try {\n                    process(msg);\n                } catch (Throwable th) {\n                    processFailure(msg, th);\n                }\n                processed++;\n            } else {\n                msg = msgQueue.poll();\n                if (msg != null) {\n                    try {\n                        process(msg);\n                    } catch (Throwable th) {\n                        processFailure(msg, th);\n                    }\n                    processed++;\n                } else {\n                    break;\n                }\n            }\n        }\n        long duration = System.nanoTime() - start;\n        long throughput = TimeUnit.NANOSECONDS.toMillis(duration) > 0 ? processed * 1000L / TimeUnit.NANOSECONDS.toMillis(duration) : 0;\n        if (log.isTraceEnabled()) {\n            log.trace(\"[{}] Processed {} messages in {} ms ({} msg/s).\", entityId, processed, TimeUnit.NANOSECONDS.toMillis(duration), throughput);\n        }\n    } else {\n        TbActorMsg msg;\n        while ((msg = highPriorityMsgQueue.poll()) != null) {\n            try {\n                process(msg);\n            } catch (Throwable th) {\n                processFailure(msg, th);\n            }\n        }\n        while ((msg = msgQueue.poll()) != null) {\n            try {\n                process(msg);\n            } catch (Throwable th) {\n                processFailure(msg, th);\n            }\n        }\n    }\n    if (highPriorityMsgQueue.isEmpty() && msgQueue.isEmpty()) {\n        status = MAILBOX_FREE;\n        if (log.isTrace", "CodeBleu_score": 37.46405124931057}, {"code": "private void processMailbox(){\n\t    try {\n        if (mailbox.isHighPriority()) {\n            processHighPriorityMailbox();\n        } else {\n            processNormalPriorityMailbox();\n        }\n    } catch (Throwable th) {\n        log.error(\"[{}] Failed to process actor mailbox\", getActorId(), th);\n        destroy(new TbActorStopReason(th));\n    }\n}", "CodeBleu_score": 9.420498509124752}, {"code": "private void processMailbox(){\n\t    if (isAlive()) {\n        if (throughputLimit > 0) {\n            int messagesProcessed = 0;\n            long startTime = System.nanoTime();\n            while (messagesProcessed < throughputLimit) {\n                if (processMessage()) {\n                    messagesProcessed++;\n                } else {\n                    break;\n                }\n            }\n            long elapsedTime = System.nanoTime() - startTime;\n            if (elapsedTime > 0) {\n                throughput = TimeUnit.SECONDS.toNanos(1) * messagesProcessed / elapsedTime;\n            }\n        } else {\n            processMessage();\n        }\n    }\n}", "CodeBleu_score": 18.227397847700157}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (destroyInProgress.compareAndSet(false, true)) {\n        stopReason = stopReason != null ? stopReason : TbActorStopReason.DESTROYED;\n        log.debug(\"[{}] Destroying actor.\", getActorId());\n        try {\n            if (getActorExecutor() != null) {\n                getActorExecutor().submit(() -> {\n                    try {\n                        setReady(false);\n                        onActorDestroy();\n                        if (cause != null) {\n                            log.debug(\"[{}] Destroyed actor due to:\", getActorId(), cause);\n                        } else {\n                            log.debug(\"[{}] Destroyed actor.\", getActorId());\n                        }\n                    } catch (Throwable e) {\n                        log.warn(\"[{}] Failed to destroy actor due to:\", getActorId(), e);\n                    } finally {\n                        notifyQueuedMessages();\n                    }\n                });\n            } else {\n                setReady(false);\n                onActorDestroy();\n                if (cause != null) {\n                    log.debug(\"[{}] Destroyed actor due to:\", getActorId(), cause);\n                } else {\n                    log.debug(\"[{}] Destroyed actor.\", getActorId());\n                }\n                notifyQueuedMessages();\n            }\n        } catch (Throwable e) {\n            log.warn(\"[{}] Failed to destroy actor due to:\", getActorId(), e);\n        }\n    }\n}", "CodeBleu_score": 35.83860072902615}, {"code": "public void destroy(Throwable cause){\n\t    if (destroyed.compareAndSet(false, true)) {\n        if (stopReason == null) {\n            stopReason = TbActorStopReason.DESTROYED;\n        }\n        if (cause != null) {\n            log.warn(\"Destroying actor: [{}] due to [{}]\", getActorId(), cause.getMessage(), cause);\n        } else {\n            log.warn(\"Destroying actor: [{}]\", getActorId());\n        }\n        if (cause != null) {\n            stopReason.setCause(cause);\n        }\n        if (actorExecutor != null) {\n            actorExecutor.submit(() -> {\n                try {\n                    setReady(false);\n                    onActorDestroy();\n                    if (cause != null) {\n                        onActorDestroyed(cause);\n                    } else {\n                        onActorDestroyed();\n                    }\n                } catch (Exception e) {\n                    log.warn(\"[{}] Failed to destroy actor\", getActorId(), e);\n                } finally {\n                    actorExecutor.shutdownNow();\n                }\n            });\n        }\n    }\n}", "CodeBleu_score": 50.944430584253695}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.DESTROYED;\n    }\n    if (destroyInProgress.compareAndSet(false, true)) {\n        dispatcher.getExecutor().schedule(() -> {\n            try {\n                setReady(false);\n                onDestroy(stopReason, cause);\n                notifyListeners();\n            } catch (Throwable th) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", getActorId(), th.getMessage(), th);\n            }\n        }, 0, TimeUnit.MILLISECONDS);\n    }\n}", "CodeBleu_score": 44.27736293514838}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.isNullUid()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimits().get(api);\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits();\n    if (rateLimits == null) {\n        return true;\n    }\n    if (rateLimits.getRateLimitType() == TbRateLimits.RateLimitType.MONGO) {\n        return checkMongoRateLimit(tenantId, api, level);\n    } else {\n        return checkCacheRateLimit(tenantId, api, level);\n    }\n}", "CodeBleu_score": 55.020198103095076}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null && !ignoreTenantNotFound) {\n        throw new TenantProfileNotFoundException(tenantId);\n    }\n    if (tenantProfile == null) {\n        return true;\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimits().get(api);\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits();\n    if (rateLimits == null) {\n        return true;\n    }\n    String key = rateLimitsTrigger.getKey();\n    if (key == null) {\n        return true;\n    }\n    if (rateLimits.getTotal() > 0) {\n        String levelKey = StringUtils.isEmpty(level) ? \"default\" : level.toString();\n        String apiKey = api.name();\n        String tenantRateLimitKey = tenantId.getId().toString() + \":\" + apiKey + \":\" + levelKey;\n        Cache<String, TbRateLimits> tenantRateLimitCache = tenantRateLimitCaches.get(tenantId);\n        if (tenantRateLimitCache == null) {\n            tenantRateLimitCache = Caffeine.newBuilder()\n                    .expireAfterWrite(rateLimits.getTimeLimit(), TimeUnit.MILLISECONDS)\n                    .initialCapacity(1)\n                    .maximumSize(1)\n                    .build();\n            tenantRateLimitCaches.put(tenantId, tenantRateLimitCache);\n        }\n        TbRateLimits tbRateLimits = tenantRateLimitCache.getIfPresent(tenantRateLimitKey);\n        if (tbRateLimits == null) {\n            tbRateLimits = new TbRateLimits(rateL", "CodeBleu_score": 47.2653472461401}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (systemTenantId.equals(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimits().get(api);\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits();\n    if (rateLimits == null) {\n        return true;\n    }\n    TbRateLimits.RateLimit rateLimit = rateLimits.get(level);\n    if (rateLimit == null) {\n        return true;\n    }\n    String apiKey = rateLimitsTrigger.getApiKey();\n    if (StringUtils.isEmpty(apiKey)) {\n        return true;\n    }\n    String key = apiKey + \":\" + tenantId.getId().toString() + \":\" + level;\n    return checkRateLimit(key, rateLimit);\n}", "CodeBleu_score": 56.67094630586011}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (InetSocketAddress address : dtlsSessions.keySet()) {\n        DtlsSession session = dtlsSessions.get(address);\n        if (session.getLastActivityTime() < expirationTime) {\n            log.debug(\"Removing DTLS session for {} due to inactivity\", address);\n            dtlsSessions.remove(address);\n        }\n    }\n}", "CodeBleu_score": 46.583348241716706}, {"code": "public void evictTimeoutSessions(){\n\t    final long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (final ConcurrentMap.Entry<InetSocketAddress, DtlsSession> entry : sessions.entrySet()) {\n        final DtlsSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            log.info(\"Removing session for {}\", entry.getKey());\n            sessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 48.560289518988434}, {"code": "public void evictTimeoutSessions(){\n\t    final long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    final int removedCount = sessions.entrySet().stream().filter(entry -> entry.getValue().getLastActivityTime() < expirationTime).map(entry -> entry.getKey()).map(sessions::remove).mapToInt(session -> 1).sum();\n    if (removedCount > 0) {\n        log.info(\"Removed {} expired DTLS sessions\", removedCount);\n    }\n}", "CodeBleu_score": 46.60296918170876}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!CollectionUtils.isEmpty(timeseries)) {\n        return timeseries.entrySet().stream().map(e -> {\n            List<KvEntry> entries = new ArrayList<>();\n            for (JsonNode node : e.getValue()) {\n                if (node.has(\"ts\")) {\n                    if (node.has(\"boolV\")) {\n                        entries.add(new BasicTsKvEntry(node.get(\"ts\").asLong(), new BooleanDataEntry(e.getKey(), node.get(\"boolV\").asBoolean())));\n                    } else if (node.has(\"strV\")) {\n                        entries.add(new BasicTsKvEntry(node.get(\"ts\").asLong(), new StringDataEntry(e.getKey(), node.get(\"strV\").asText())));\n                    } else if (node.has(\"longV\")) {\n                        entries.add(new BasicTsKvEntry(node.get(\"ts\").asLong(), new LongDataEntry(e.getKey(), node.get(\"longV\").asLong())));\n                    } else if (node.has(\"dblV\")) {\n                        entries.add(new BasicTsKvEntry(node.get(\"ts\").asLong(), new DoubleDataEntry(e.getKey(), node.get(\"dblV\").asDouble())));\n                    } else if (node.has(\"jsonV\")) {\n                        entries.add(new BasicTsKvEntry(node.get(\"ts\").asLong(), new JsonDataEntry(e.getKey(), node.get(\"jsonV\"))));\n                    }\n                }\n            }\n            return entries;\n        }).flatMap(List::stream).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 38.29644072016332}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!CollectionUtils.isEmpty(timeseries)) {\n        return timeseries.entrySet().stream().flatMap(entry -> {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            if (values.size() == 1) {\n                JsonNode value = values.get(0);\n                if (value.isNull()) {\n                    return Collections.emptyList();\n                } else if (value.isObject()) {\n                    return value.fields().entrySet().stream().map(field -> {\n                        String fieldKey = field.getKey();\n                        JsonNode fieldValue = field.getValue();\n                        if (fieldValue.isNull()) {\n                            return Collections.emptyList();\n                        } else if (fieldValue.isNumber()) {\n                            return Collections.singletonList(new BasicTsKvEntry(fieldKey, new LongDataEntry(fieldValue.asLong())));\n                        } else if (fieldValue.isBoolean()) {\n                            return Collections.singletonList(new BasicTsKvEntry(fieldKey, new BooleanDataEntry(fieldValue.asBoolean())));\n                        } else if (fieldValue.isTextual()) {\n                            return Collections.singletonList(new BasicTsKvEntry(fieldKey, new StringDataEntry(fieldValue.asText())));\n                        } else if (fieldValue.isDouble()) {\n                            return Collections.singletonList(new BasicTsKvEntry(fieldKey, new DoubleDataEntry(fieldValue.asDouble())));\n                        } else {\n                            return Collections.singletonList(new BasicTsKvEntry(fieldKey, new JsonDataEntry(fieldValue)));\n                        }\n                    }).flatMap(List::stream);\n                } else if (value.isNumber()) {\n                    return Collections.singletonList(new BasicTsKvEntry(key, new LongDataEntry(value.asLong())));\n                } else if (value.isBoolean()) {\n                    return Collections.singletonList(new BasicTsKvEntry(key, new BooleanDataEntry(value.asBoolean())));\n                } else if (value", "CodeBleu_score": 40.1298737883289}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (CollectionUtils.isEmpty(timeseries)) {\n        return Collections.emptyList();\n    }\n    return timeseries.entrySet().stream().flatMap(entry -> {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (JsonNode jsonNode : entry.getValue()) {\n            if (jsonNode.isObject()) {\n                result.add(parseObject(entry.getKey(), jsonNode));\n            } else if (jsonNode.isArray()) {\n                result.addAll(parseArray(entry.getKey(), jsonNode));\n            } else {\n                result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(entry.getKey(), jsonNode.asText())));\n            }\n        }\n        return result.stream();\n    }).collect(Collectors.toList());\n}", "CodeBleu_score": 47.175185108537136}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t    Map<String, String> refreshTokenRequestMap = new HashMap<>();\n    refreshTokenRequestMap.put(\"refreshToken\", \"eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJUZXN0IiwiaWF0IjoxNTI5ODQ0MzE1fQ.XbPfbIHMI9lf5JQUZ516oL_3c9uERd2t3ii7pR9HRFw\");\n    Map<String, String> headerMap = new HashMap<>();\n    headerMap.put(\"Content-Type\", \"application/json\");\n    HttpEntity<Map<String, String>> refreshTokenRequestEntity = new HttpEntity<>(refreshTokenRequestMap, headerMap);\n    ResponseEntity<JwtPair> refreshTokenResponseEntity = restTemplate.postForEntity(\n            \"http://localhost:8080/api/auth/token\", refreshTokenRequestEntity, JwtPair.class);\n    JwtPair refreshTokenResponse = refreshTokenResponseEntity.getBody();\n    System.out.println(refreshTokenResponse.getAccessToken());\n    System.out.println(refreshTokenResponse.getRefreshToken());\n}", "CodeBleu_score": 44.02875784449221}, {"code": "public void refreshToken(){\n\t    // Construct request body\n    Map<String, Object> requestMap = new HashMap<>();\n    requestMap.put(\"refreshToken\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJXZWJDbGllbnQiLCJpc3MiOiJXZWJDbGllbnQiLCJleHAiOjE1OTU4NjAwMDAwMDAsImlhdCI6MTU2ODg0MDAwMDAwMCwicm9sZXMiOlsiZGF0YWJhc2UiXX0.c5Ki31FwuC4-NyxTGqUiaP2zWBJk7BW85_RG7eYxrko\");\n\n    // Prepare request\n    HttpRequest request = HttpRequest.newBuilder()\n        .uri(URI.create(\"http://localhost:8080/api/auth/token\"))\n        .header(\"Content-Type\", \"application/json\")\n        .POST(HttpRequest.BodyPublishers.ofString(requestMap.toString()))\n        .build();\n\n    // Send request\n    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n    // Read response\n    System.out.println(\"Status code: \" + response.statusCode());\n    System.out.println(\"Response body: \" + response.body());\n}", "CodeBleu_score": 42.251027362328855}, {"code": "public void refreshToken(){\n\t    // TODO: Implement refreshToken\n    // BEGIN:refreshToken\n    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refresh_token\", \"YOUR_REFRESH_TOKEN\");\n    ResponseEntity<JwtPair> responseEntity = restTemplate.postForEntity(\n            \"/api/auth/token\", requestMap, JwtPair.class);\n    JwtPair jwtPair = responseEntity.getBody();\n    // END:refreshToken\n}", "CodeBleu_score": 48.55095956573467}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t  // Create a map for the login request\n  Map<String, Object> loginRequestMap = new HashMap<>();\n  loginRequestMap.put(\"username\", username);\n  loginRequestMap.put(\"password\", password);\n  // Create a request entity with the login request map\n  HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(loginRequestMap);\n  // Send the POST request to the \"/api/auth/login\" URL\n  ResponseEntity<JwtPair> loginResponse = restTemplate.postForEntity(loginUrl, requestEntity, JwtPair.class);\n  // Get the response body\n  JwtPair jwtPair = loginResponse.getBody();\n  // Get the refresh token\n  String refreshToken = jwtPair.getRefreshToken();\n  // Get the access token\n  String accessToken = jwtPair.getAccessToken();\n  // Get the current timestamp\n  long currentTime = System.currentTimeMillis();\n  // Update the token information\n  tokenInfo = new TokenInfo(currentTime, accessToken, refreshToken);\n}", "CodeBleu_score": 47.556034443299}, {"code": " private void doLogin(){\n\t \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", "CodeBleu_score": 1.312489352683406}, {"code": " private void doLogin(){\n\t  // Create a Map of request parameters.\n  Map<String, String> loginRequestParams = new HashMap<>();\n  loginRequestParams.put(\"username\", \"admin\");\n  loginRequestParams.put(\"password\", \"admin\");\n  // Create a request based on the loginRequestParams\n  HttpRequest loginRequest = createRequest(loginRequestParams, \"/api/auth/login\");\n  // Send a request and get response\n  HttpResponse loginResponse = sendRequest(loginRequest);\n  // Parse the response and get the token\n  Map<String, String> loginResponseData = parseResponse(loginResponse);\n  // Get the token from the response\n  String token = loginResponseData.get(\"token\");\n  // Set the token in the request header\n  setHeader(loginRequest, \"X-Authorization\", \"Bearer \" + token);\n}", "CodeBleu_score": 37.586049226560704}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    return Optional.ofNullable(restTemplate.getForObject(\"/api/device/{deviceId}\", Device.class, deviceId.toString()));\n}", "CodeBleu_score": 12.441642495111985}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    return Optional.empty();\n}", "CodeBleu_score": 11.911951025259437}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        return Optional.of(restTemplate.getForObject(\"/api/device/{deviceId}\", Device.class, deviceId.toString()));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 48.08807913858962}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t  // Create a request object containing the device and its credentials.\n  SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest(device, credentials);\n  // Attempt to send the request.\n  try {\n    return Optional.of(this.deviceService.saveDeviceWithCredentials(request));\n  } catch (HttpClientErrorException e) {\n    // If a 404 error occurs, return an empty Optional.\n    if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n      return Optional.empty();\n    }\n    // Otherwise, rethrow the exception.\n    throw e;\n  }\n}", "CodeBleu_score": 46.95944802266781}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest();\n    request.setDevice(device);\n    request.setCredentials(credentials);\n    try {\n        return Optional.of(doExecuteWithFallback(\n                () -> restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class).getBody(),\n                () -> null));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 52.313112583125154}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    // Create a request object containing the device and its credentials\n    SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest();\n    request.setDevice(device);\n    request.setCredentials(credentials);\n\n    // Attempt to send this request\n    try {\n        return Optional.of(doExecuteWithFallback(() -> {\n            ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class);\n            return response.getBody();\n        }));\n    } catch (HttpClientErrorException e) {\n        // If a 404 error occurs, return an empty Optional\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        // Otherwise, rethrow the exception\n        throw e;\n    }\n}", "CodeBleu_score": 54.45752706976423}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\tthis._brightness = Math.round(val * 15 / 100);\n\t} else {\n\t\tthis._devices[addr].brightness = Math.round(val * 15 / 100);\n\t}\n\treturn this;\n}", "CodeBleu_score": 38.292262240806316}, {"code": "brightness(addr, val){\n\t    if (arguments.length == 1) {\n        this.brightness = val;\n    } else if (arguments.length == 2) {\n        this.brightness[addr] = val;\n    } else {\n        throw new Error(\"Invalid number of arguments\");\n    }\n    return this;\n}", "CodeBleu_score": 42.83599842272042}, {"code": "brightness(addr, val){\n\t    if (arguments.length == 1) {\n        this.brightness = Math.round(val * 15 / 100);\n    } else {\n        this.devices[addr].brightness = Math.round(val * 15 / 100);\n    }\n    return this;\n}", "CodeBleu_score": 42.03418823632122}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    var dev = {};\n    var proto = Object.getPrototypeOf(this);\n    var own = Object.keys(this);\n    var keys = Object.keys(proto).concat(own);\n    for (var i = 0; i < keys.length; i++) {\n        var k = keys[i];\n        if (typeof this[k] == \"function\") {\n            dev[k] = this[k].bind(this, addr);\n        }\n    }\n    return dev;\n}", "CodeBleu_score": 42.27558946491611}, {"code": "device(addr){\n\t  var self = this;\n  var obj = {};\n  for (var key in self) {\n    if (self.hasOwnProperty(key)) {\n      obj[key] = self[key].bind(self, addr);\n    }\n  }\n  return obj;\n}", "CodeBleu_score": 23.037339709646094}, {"code": "device(addr){\n\t  var device = {};\n  for (var key in this) {\n    if (this.hasOwnProperty(key)) {\n      device[key] = this[key].bind(this, addr);\n    }\n  }\n  return device;\n}", "CodeBleu_score": 30.44038256160682}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[`${method}WithCallback`] = function(collection, duration, callback) {\n      if (!duration) duration = 1000;\n      if (!callback) callback = () => {};\n      if (typeof callback !== 'function') callback = () => {};\n      let promises = [];\n      collection.forEach(element => {\n        promises.push(this[method](element, duration));\n      });\n      Promise.all(promises).then(() => {\n        callback();\n      });\n    };\n  });\n}", "CodeBleu_score": 35.372095279400185}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach((method) => {\n    const originalMethod = target[method];\n\n    target[method] = (collection, duration, callback) => {\n      if (!callback || typeof callback !== 'function') {\n        callback = duration;\n        duration = 1000;\n      }\n\n      const promises = [];\n      collection.forEach((element) => {\n        promises.push(originalMethod(element, duration));\n      });\n\n      Promise.all(promises).then(() => {\n        callback();\n      });\n    };\n  });\n}", "CodeBleu_score": 38.87229342971247}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[`${method}Callback`] = (collection, duration, callback) => {\n            if (!(collection instanceof Collection)) {\n                throw new Error(`${method}Callback: the first argument must be a Collection`);\n            }\n            if (typeof duration !== 'number') {\n                duration = 1000;\n            }\n            if (typeof callback !== 'function') {\n                throw new Error(`${method}Callback: the third argument must be a function`);\n            }\n            const promises = collection.map(element => {\n                return new Promise(resolve => {\n                    setTimeout(() => {\n                        resolve(element[method]());\n                    }, duration);\n                });\n            });\n            Promise.all(promises).then(results => {\n                callback(results);\n            });\n        };\n    });\n}", "CodeBleu_score": 39.13211505863163}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t  if (this.serialPort) {\n    this.serialPort.on('data', (data) => {\n      this.inputString += data.toString();\n      const sentences = this.inputString.split('\\r\n');\n      this.inputString = sentences.pop();\n      sentences.forEach(sentence => {\n        this.parseNmeaSentence(sentence);\n      });\n    });\n  }\n}", "CodeBleu_score": 28.183350302734212}, {"code": "listen(){\n\t  // Create a new input string\n  inputString = \"\";\n  // Initialize the serial port\n  Serial.begin(9600);\n  // Wait for the serial port to open\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n  // Start reading from the serial port\n  while (Serial.available()) {\n    // Read the next byte\n    char inChar = (char)Serial.read();\n    // Add the byte to the inputString\n    inputString += inChar;\n    // If the incoming character is a newline, set a flag so the main loop can\n    // do something about it:\n    if (inChar == '\n') {\n      stringComplete = true;\n    }\n  }\n  // If a newline is received, split the string into sentences and process them\n  if (stringComplete) {\n    // Split the string on the \"\\r\n\" delimiter\n    String sentences[MAX_SENTENCES];\n    sentences[0] = inputString;\n    int sentenceCount = 1;\n    for (int i = 0; i < inputString.length(); i++) {\n      if (inputString.substring(i, i + 2) == \"\\r\n\") {\n        sentences[sentenceCount] = inputString.substring(i + 2);\n        sentenceCount++;\n        if (sentenceCount >= MAX_SENTENCES) {\n          break;\n        }\n      }\n    }\n    // Process each sentence\n    for (int i = 0; i < sentenceCount; i++) {\n      parseNmeaSentence(sentences[i]);\n    }\n    // Clear the input string\n    inputString = \"\";\n    // Reset the flag\n    stringComplete = false;\n  }\n}", "CodeBleu_score": 21.19980174330124}, {"code": "listen(){\n\t  if (DEBUG) {\n    Serial.println(\"Starting listen\");\n  }\n\n  // Initialize the input string\n  inputString = \"\";\n  incompleteSentence = \"\";\n\n  // Start listening on the serial port\n  while (Serial.available()) {\n    // Get the new byte:\n    char inChar = (char)Serial.read();\n    // Add it to the inputString:\n    inputString += inChar;\n    // If the incoming character is a newline, set a flag so the main loop can\n    // do something about it:\n    if (inChar == '\n') {\n      stringComplete = true;\n    }\n  }\n\n  // Now that all the data has been read, it's time to split it into sentences\n  // and process them\n  if (stringComplete) {\n    // Split the input string into an array of sentences\n    String sentences[] = splitString(inputString, '\\r');\n    // Process each sentence\n    for (int i = 0; i < sizeof(sentences); i++) {\n      if (DEBUG) {\n        Serial.print(\"Sentence: \");\n        Serial.println(sentences[i]);\n      }\n      parseNmeaSentence(sentences[i]);\n    }\n    // Clear the input string\n    inputString = \"\";\n    // Reset the flag\n    stringComplete = false;\n  }\n\n  // If we have an incomplete sentence, keep it around for the next read\n  if (incompleteSentence != \"\") {\n    inputString = incompleteSentence;\n    incompleteSentence = \"\";\n  }\n}", "CodeBleu_score": 25.417729463918874}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tuint8_t num_channels = 0;\n\tuint8_t num_active_channels = 0;\n\tuint8_t num_data_bytes = 0;\n\n\tfor (uint8_t i = 0; i < config->num_channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tnum_channels++;\n\t\t\tif (config->channels[i].enabled) {\n\t\t\t\tnum_active_channels++;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (sequence->resolution) {\n\tcase 8:\n\t\tnum_data_bytes = 1;\n\t\tbreak;\n\tcase 12:\n\t\tnum_data_bytes = 2;\n\t\tbreak;\n\tcase 16:\n\t\tnum_data_bytes = 3;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < num_data_bytes * num_active_channels) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 36.431222401744}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tint channels = 0;\n\tint i;\n\tint size;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i].channel_id != ADC_CHANNEL_OFFSET) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tsize = channels * config->resolution / 8U;\n\n\tif (sequence->options) {\n\t\tsize *= (1 + sequence->calibrate);\n\t}\n\n\tif (size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size (%d)\", size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.30562334499545}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_cfg *config = dev->config;\n\tuint8_t active_channels = 0;\n\tuint8_t active_channels_mask = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tuint8_t channel = sequence->channels_id[i];\n\n\t\tif (channel >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel %d\", channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tactive_channels_mask |= BIT(channel);\n\t}\n\n\tfor (i = 0; i < config->num_channels; i++) {\n\t\tif (active_channels_mask & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < active_channels * sizeof(uint16_t)) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.236943931052544}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tconst struct adc_channel_cfg *channels = sequence->channels;\n\tuint8_t num_channels = sequence->channels_length;\n\tint32_t *buffer = sequence->buffer;\n\tsize_t buffer_size = sequence->buffer_size;\n\tint i;\n\n\tif (data->resolution != AD559x_RESOLUTION_12BIT) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tif (channels[i].channel_id != i) {\n\t\t\tLOG_ERR(\"Invalid channel id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (buffer_size < num_channels * sizeof(int32_t)) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer = buffer;\n\tadc_context_start_read(&data->ctx, sequence);\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}", "CodeBleu_score": 50.24919746004607}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tstruct adc_context *ctx = &data->ctx;\n\tuint8_t chan_count, chan_id;\n\tuint8_t *buffer;\n\tuint8_t *buf_end;\n\tuint8_t *buf;\n\tuint8_t *chan_buf;\n\tuint8_t *chan_buf_end;\n\tuint8_t *chan_buf_start;\n\tuint8_t *chan_buf_end_prev;\n\tuint8_t resolution;\n\tuint8_t sample_size;\n\tint err;\n\tint i;\n\tint j;\n\tint ret;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchan_count = sequence->channels;\n\tbuffer = sequence->buffer;\n\tbuf_end = buffer + sequence->buffer_size;\n\n\tresolution = config->resolution;\n\tsample_size = resolution / 8U;\n\n\tfor (i = 0; i < chan_count; i++) {\n\t\tchan_id = sequence->channels[i];\n\n\t\tif (chan_id >= config->channel_count) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchan_buf_start = buffer + chan_id * sample_size;\n\t\tchan_buf_end_prev = chan_buf_start;\n\n\t\tfor (j = 0; j < sequence->oversampling; j++) {\n\t\t\tchan_buf = chan_buf_end_prev;\n\t\t\tchan_buf_end = chan_buf + sample_size;\n\n\t\t\tif (chan_buf_end > buf_end) {\n\t\t\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t", "CodeBleu_score": 51.29452252425932}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_cfg *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint16_t *buffer = sequence->buffer;\n\tuint8_t resolution = sequence->resolution;\n\tuint8_t channels = sequence->channels;\n\tuint8_t channel_count = sequence->channels;\n\tuint8_t channel_id = 0;\n\tuint8_t channel_mask = 0;\n\tint i;\n\n\tif (resolution != ADC_RESOLUTION_12BIT) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tchannel_id = i;\n\t\t\tchannel_mask |= BIT(channel_id);\n\t\t}\n\t}\n\n\tif (channel_count != 1) {\n\t\tLOG_ERR(\"Invalid channel count\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (channel_id > config->channel_count) {\n\t\tLOG_ERR(\"Invalid channel id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data->buffer_size < (channel_count * sizeof(uint16_t))) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer = buffer;\n\tdata->channel_mask = channel_mask;\n\tdata->channel_count = channel_count;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tad559x_read_async(dev, channel_id);\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}", "CodeBleu_score": 48.20976991829582}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_stm32_data *data = ctx->data;\n\tconst struct device *dev = data->dev;\n\tconst struct adc_stm32_cfg *config = dev->config;\n\tADC_TypeDef *adc = config->base;\n\tuint32_t cfgr1 = adc->CFGR1;\n\tuint32_t cfgr2 = adc->CFGR2;\n\tuint32_t smpr = adc->SMPR;\n\tuint32_t chan_mask = 0;\n\tuint8_t i;\n\n\tadc_context_lock(ctx, false, NULL);\n\n\t/*\n\t * The following assumes that the scan sequence is the same as the channel sequence.\n\t * This is a valid assumption for the STM32H7 ADC driver.\n\t */\n\tfor (i = 0U; i < ctx->channels; i++) {\n\t\tuint32_t channel = ctx->sequence.entries[i].channel_id;\n\t\tuint32_t mask = BIT(channel);\n\n\t\tif ((mask & BIT_MASK(ADC_STM32_MAX_CHANNELS)) == 0) {\n\t\t\tLOG_ERR(\"Invalid channel %d\", channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfgr2 & mask) != mask) {\n\t\t\tLOG_ERR(\"Invalid channel %d\", channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((smpr & mask) == 0) {\n\t\t\tLOG_ERR(\"Invalid sample rate %d\", channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchan_mask |= mask;\n\t}\n\n\tif (chan_mask == 0) {\n\t\tLOG_ERR(\"No channel configured\");\n\t\tadc_context_release(ctx, 0);\n\t\treturn;\n\t}\n\n\tif (cfgr1 & ADC_CFGR1_CONT) {\n\t\tLOG_ERR(\"Continuous mode not supported\");\n\t\tadc_context_release(ctx, 0", "CodeBleu_score": 40.44911860862446}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct ad559x_data *data = CONTAINER_OF(ctx, struct ad559x_data, ctx);\n\tstruct ad559x_chip_config *config = &data->config;\n\tstruct ad559x_chip_config_sequence *seq = &config->seq;\n\tint ret;\n\n\t/*\n\t * The function \"ad559x_channel_setup\" sets up the AD559x to sample the specified channels.\n\t */\n\tret = ad559x_channel_setup(data->dev, config);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not setup channel\");\n\t\treturn;\n\t}\n\n\t/*\n\t * The function \"ad559x_start_channels\" starts the AD559x to sample the specified channels.\n\t */\n\tret = ad559x_start_channels(data->dev, seq->channels, seq->num_channels);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not start channels\");\n\t\treturn;\n\t}\n\n\t/*\n\t * The function \"ad559x_start_channels\" starts the AD559x to sample the specified channels.\n\t */\n\tret = ad559x_start_channels(data->dev, seq->channels, seq->num_channels);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not start channels\");\n\t\treturn;\n\t}\n\n\t/*\n\t * The function \"ad559x_read_channels\" reads the AD559x channel data.\n\t */\n\tret = ad559x_read_channels(data->dev, seq->channels, seq->num_channels, data->buffer);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not read channels\");\n\t\treturn;\n\t}\n\n\t/*\n\t * The function \"ad559x_start_channels\" starts the AD559x to sample the specified channels.\n\t */\n\tret = ad559x_start_", "CodeBleu_score": 50.34589434967983}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct ad559x_data *drv_data = ctx->drv_data;\n\tstruct ad559x_dev_config *config = drv_data->config;\n\tstruct ad559x_channel_cfg *channels = drv_data->channels;\n\n\tLOG_DBG(\"Start sampling\");\n\n\tif (drv_data->state != AD559X_NOT_POWERED) {\n\t\tLOG_DBG(\"ADC already started\");\n\t\treturn;\n\t}\n\n\tdrv_data->state = AD559X_STARTED;\n\n\t/*\n\t * Set the channels to be sampled.\n\t */\n\tfor (int i = 0; i < config->num_channels; i++) {\n\t\tLOG_DBG(\"Set channel %d\", i);\n\t\tad559x_channel_setup(drv_data->dev, channels[i].channel,\n\t\t\t\t     channels[i].gain, channels[i].ref);\n\t}\n\n\t/*\n\t * Set the repeat buffer to the data buffer.\n\t */\n\tad559x_repeat_buffer_setup(drv_data->dev, drv_data->buffer,\n\t\t\t\t   config->num_channels);\n\n\t/*\n\t * Start the ADC.\n\t */\n\tad559x_start(drv_data->dev);\n\n\t/*\n\t * Release the lock so the interrupt handler can do its work.\n\t */\n\tk_sem_give(&drv_data->sem);\n}", "CodeBleu_score": 45.29603398358023}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_sync_device *dev = ctx->dev;\n\n\tif (repeat_sampling) {\n\t\tctx->buffer = dev->repeat_buffer;\n\t}\n}", "CodeBleu_score": 39.678788876031405}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = ctx->buffer;\n\t}\n}", "CodeBleu_score": 47.04822149301768}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\n\tstruct adc_data *data = ctx->data;\n\n\tif (data->repeat_sampling) {\n\t\tdata->buffer_pointer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 53.606574574634024}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct adc_ad559x_cfg *config = data->adc_ad559x_cfg;\n\tstruct adc_context *ctx = &data->ctx;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tadc_context_lock(ctx, false, K_FOREVER);\n\n\t\t/* Sample each active channel */\n\t\tfor (u8_t i = 0; i < config->num_channels; ++i) {\n\t\t\tstruct adc_channel_cfg *channel_cfg = &config->channel_cfg[i];\n\t\t\tu16_t adc_value;\n\n\t\t\t/* Skip inactive channels */\n\t\t\tif (!channel_cfg->channel_id) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Read the ADC value */\n\t\t\tif (ad559x_get_adc_value(config->parent, channel_cfg->channel_id, &adc_value) != 0) {\n\t\t\t\tLOG_ERR(\"Failed to read ADC value for channel %d\", channel_cfg->channel_id);\n\t\t\t\tadc_context_release(ctx, ADC_ACQUISITION_TIMEOUT);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Convert ADC value to a 16-bit unsigned value */\n\t\t\tu16_t adc_value_converted = sys_cpu_to_be16(adc_value);\n\n\t\t\t/* Store the ADC value in the buffer */\n\t\t\tmemcpy(&ctx->buffer[i], &adc_value_converted, sizeof(adc_value_converted));\n\t\t}\n\n\t\tadc_context_release(ctx, K_NO_WAIT);\n\t}\n}", "CodeBleu_score": 36.444453054984606}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    struct adc_context *ctx = &data->ctx;\n    struct adc_ad559x_channel_cfg *channels = data->active_channels;\n    struct adc_ad559x_channel_cfg *channel;\n    uint16_t sample;\n    int err;\n\n    while (1) {\n        k_sem_take(&data->sem, K_FOREVER);\n\n        if (data->state == ADC_AD559X_STATE_ERROR) {\n            LOG_ERR(\"ADC error\");\n            ctx->error = -EIO;\n            adc_context_on_sampling_done(&data->ctx, ctx->error);\n            continue;\n        }\n\n        for (int i = 0; i < ctx->active_channels; i++) {\n            channel = &channels[i];\n            err = ad559x_read_sample(data->ad559x, channel->channel_id, &sample);\n            if (err < 0) {\n                LOG_ERR(\"Failed to read ADC sample\");\n                ctx->error = -EIO;\n                adc_context_on_sampling_done(&data->ctx, ctx->error);\n                return;\n            }\n\n            adc_context_on_channel_sampling_done(&data->ctx, channel->id, sample);\n        }\n\n        adc_context_on_sampling_done(&data->ctx, 0);\n    }\n}", "CodeBleu_score": 42.40420632589761}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_context *ctx = &data->ctx;\n\tstruct adc_channel_cfg *active = ctx->active_channels;\n\tint i, ret;\n\tuint16_t val;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (i = 0; i < ctx->sequence.channels; i++) {\n\t\t\tif (!active[i].enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = ad559x_read_channel_value(data->ad559x,\n\t\t\t\t\t\t\tactive[i].channel_id,\n\t\t\t\t\t\t\t&val);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"Could not read channel %d\",\n\t\t\t\t\tactive[i].channel_id);\n\t\t\t\tadc_context_complete(&data->ctx, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tadc_context_on_sampling_done(&data->ctx,\n\t\t\t\t\t\t     &active[i],\n\t\t\t\t\t\t     val);\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, NULL, 0);\n\t}\n}", "CodeBleu_score": 47.749066195983225}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint ret;\n\tuint16_t config;\n\n\tk_msleep(ADS1112_READY_TIME_MS);\n\n\tret = i2c_reg_read_word_be16(dev, ADS1112_REG_CONFIG, &config);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Error reading config register\");\n\t\treturn ret;\n\t}\n\n\tif (config & ADS1112_CONFIG_OS) {\n\t\treturn 0;\n\t}\n\n\tLOG_WRN(\"ADS1112 not ready\");\n\n\twhile (1) {\n\t\tk_usleep(100);\n\t\tret = i2c_reg_read_word_be16(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Error reading config register\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (config & ADS1112_CONFIG_OS) {\n\t\t\treturn 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 46.78694145567683}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    struct ads1112_data *data = dev->data;\n    uint8_t config;\n    int rc;\n    int i;\n    const struct ads1112_config *config_dev = dev->config;\n\n    /* Wait for the device to be ready for data reading. */\n    k_sleep(K_USEC(config_dev->ready_time));\n\n    /* Read the configuration register to check the status. */\n    rc = i2c_reg_read_byte(data->i2c_master, config_dev->i2c_address, ADS1112_REG_CONFIG, &config);\n    if (rc != 0) {\n        LOG_ERR(\"Error reading configuration register: %d\", rc);\n        return rc;\n    }\n\n    /* If the device is not ready, repeatedly sleep for 100 microseconds and check the status again. */\n    for (i = 0; i < 100; i++) {\n        if (config & ADS1112_CONFIG_OS_MASK) {\n            return 0;\n        }\n        k_sleep(K_USEC(100));\n        rc = i2c_reg_read_byte(data->i2c_master, config_dev->i2c_address, ADS1112_REG_CONFIG, &config);\n        if (rc != 0) {\n            LOG_ERR(\"Error reading configuration register: %d\", rc);\n            return rc;\n        }\n    }\n\n    /* If the device is not ready after 1000 microseconds, return an error. */\n    if (!(config & ADS1112_CONFIG_OS_MASK)) {\n        LOG_ERR(\"Device is not ready\");\n        return -EIO;\n    }\n\n    return 0;\n}", "CodeBleu_score": 54.192005759242925}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *cfg = dev->config;\n\tint ret;\n\tuint16_t status;\n\n\tk_sleep(K_USEC(cfg->data_ready_ms));\n\n\tret = i2c_reg_read_word_be16(cfg->bus, cfg->i2c_addr, ADS1112_REG_CONFIG, &status);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tif (status & ADS1112_CONFIG_OS_MASK) {\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tk_sleep(K_USEC(100));\n\n\t\tret = i2c_reg_read_word_be16(cfg->bus, cfg->i2c_addr, ADS1112_REG_CONFIG, &status);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (status & ADS1112_CONFIG_OS_MASK) {\n\t\t\treturn 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 48.089518125338884}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Sequence options are not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels > 1) {\n\t\tLOG_ERR(\"Only one channel supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < 2) {\n\t\tLOG_ERR(\"Buffer size must be at least 2\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.5272119998897}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    int num_samplings = sequence->options;\n    int num_extra_samplings = 0;\n    int num_samplings_with_conversions = 0;\n    int num_samplings_with_conversions_and_repeats = 0;\n    int num_samplings_with_repeats = 0;\n    int num_samplings_with_repeats_and_conversions = 0;\n    int num_samplings_with_repeats_and_conversions_and_repeats = 0;\n    int num_samplings_with_conversions_and_repeats_and_repeats = 0;\n    int num_samplings_with_repeats_and_conversions_and_repeats_and_conversions = 0;\n    int num_samplings_with_repeats_and_conversions_and_repeats_and_conversions_and_repeats = 0;\n    int num_samplings_with_repeats_and_conversions_and_repeats_and_conversions_and_repeats_and_conversions = 0;\n    int num_samplings_with_repeats_and_conversions_and_repeats_and_conversions_and_repeats_and_conversions_and_repeats = 0;\n    int num_samplings_with_repeats_and_conversions_and_repeats_and_conversions_and_repeats_and_conversions_and_repeats_and_conversions = 0;\n    int num_samplings_with_repeats_and_conversions_and_repeats_and_conversions_and_repeats_and_conversions_and_repeats_and_conversions_and_repeats = 0;\n    int num_samplings_with_repeats_and_conversions_and_repeats_and_conversions_and_repeats_and_conversions_and_repeats_and_conversions_and_repeats_", "CodeBleu_score": 9.019849576629714}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_buffer_size;\n\n\trequired_buffer_size = (sequence->options) ? sequence->options->extra_samplings : 0;\n\trequired_buffer_size += sequence->channels;\n\trequired_buffer_size *= sizeof(struct adc_sample);\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.11647840264974}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tstruct ads1112_dev_config *config = dev->config;\n\tuint16_t adc_val;\n\tuint8_t adc_val_byte;\n\tint i;\n\tint ret;\n\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"Only single channel supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Only 12-bit resolution supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & ~BIT(0)) {\n\t\tLOG_ERR(\"Only channel 0 supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(1)) {\n\t\tLOG_ERR(\"Only channel 0 supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(2)) {\n\t\tLOG_ERR(\"Only channel 0 supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(3)) {\n\t\tLOG_ERR(\"Only channel 0 supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(4)) {\n\t\tLOG_ERR(\"Only channel 0 supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(5)) {\n\t\tLOG_ERR(\"Only channel 0 supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(6)) {\n\t\tLOG_ERR(\"", "CodeBleu_score": 39.149888317370866}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tstruct ads1112_dev_config *config = dev->config;\n\tint rc;\n\n\t/* Verify the sequence makes sense before executing it */\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"Invalid channel selection\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Invalid oversampling\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Invalid calibration\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"Invalid channel selection\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Set the data pointer */\n\tdata->sequence = sequence;\n\n\t/* Start the ADC read context */\n\trc = adc_context_start_read(&data->ctx, sequence);\n\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* Wait for the read to complete */\n\tif (wait) {\n\t\trc = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 65.35374212589775}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tstruct ads1112_config *config = dev->config;\n\tint ret;\n\tuint8_t i;\n\n\t/* Check for NULL sequence */\n\tif (sequence == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check for channels outside sequence range */\n\tfor (i = 0U; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i] < ADS1112_CHANNEL_0 ||\n\t\t    sequence->channels[i] > ADS1112_CHANNEL_3) {\n\t\t\tLOG_ERR(\"Channel %d is outside the sequence range\",\n\t\t\t\tsequence->channels[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check for channels outside channel range */\n\tfor (i = 0U; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i] < config->channel_ids[0] ||\n\t\t    sequence->channels[i] > config->channel_ids[3]) {\n\t\t\tLOG_ERR(\"Channel %d is outside the channel range\",\n\t\t\t\tsequence->channels[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check for valid gain setting */\n\tif (sequence->oversampling != ADS1112_GAIN_1 &&\n\t    sequence->oversampling != ADS1112_GAIN_2 &&\n\t    sequence->oversampling != ADS1112_GAIN_4 &&\n\t    sequence->oversampling != ADS1112_GAIN_8) {\n\t\tLOG_ERR(\"Invalid gain setting %d\", sequence->oversampling);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check for valid resolution setting */\n\tif (sequence->resolution != ADS1112_RES_9 &&\n\t    sequence->resolution != ADS1112_RES_10 &&\n", "CodeBleu_score": 35.22779049295275}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret = 0;\n\tconst struct device *dev = NULL;\n\tstruct codec_prop prop;\n\tchar *endptr;\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tprop.prop = strtol(argv[2], &endptr, 10);\n\tif (*endptr != '\\0') {\n\t\tshell_error(sh, \"Invalid property\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (argc > 3) {\n\t\tprop.value = strtol(argv[3], &endptr, 10);\n\t\tif (*endptr != '\\0') {\n\t\t\tshell_error(sh, \"Invalid value\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = codec_apply_prop(dev, &prop);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply property\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.80100498125549}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\tstruct codec_prop prop;\n\tint ret;\n\n\tif (argc < 4) {\n\t\tshell_help(sh);\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tprop.prop = strtoul(argv[2], NULL, 16);\n\tprop.val = strtoul(argv[3], NULL, 16);\n\n\tret = codec_apply_prop(dev, &prop);\n\n\tif (ret) {\n\t\tshell_error(sh, \"Error applying property\");\n\t\treturn -ENOEXEC;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 61.70624690581206}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    const struct device *dev;\n    struct audio_codec_prop_node *prop_node;\n    struct audio_codec_prop_node *prop_node_temp;\n    struct codec_prop_node_data *prop_data;\n    struct codec_prop_node_data *prop_data_temp;\n    int ret;\n    int i;\n\n    if (argc < 2) {\n        shell_error(sh, \"Too few arguments.\");\n        return -EINVAL;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Device not found.\");\n        return -ENODEV;\n    }\n\n    prop_node = audio_codec_get_properties(dev);\n    if (!prop_node) {\n        shell_error(sh, \"Device has no properties.\");\n        return -ENODEV;\n    }\n\n    for (i = 0; i < argc - 2; i++) {\n        prop_data = prop_node->data;\n        prop_data_temp = prop_data;\n\n        while (prop_data_temp) {\n            if (!strcmp(argv[i + 2], prop_data_temp->name)) {\n                ret = audio_codec_apply_prop(dev, prop_data_temp->prop);\n                if (ret) {\n                    shell_error(sh, \"Failed to apply property.\");\n                    return ret;\n                }\n\n                break;\n            }\n\n            prop_data_temp = prop_data_temp->next;\n        }\n\n        if (!prop_data_temp) {\n            shell_error(sh, \"Property not found.\");\n            return -ENODEV;\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 56.739134593555086}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    struct mpxxdtyy_dev_data *dev_data = dev->data;\n    struct mpxxdtyy_dev_cfg *dev_cfg = dev->config;\n    int ret;\n\n    LOG_DBG(\"dev_data: %p, dev_cfg: %p, cmd: %d\", dev_data, dev_cfg, cmd);\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (dev_data->state == DMIC_STATE_READY) {\n                dev_data->state = DMIC_STATE_ACTIVE;\n                ret = i2s_trigger(dev_cfg->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n                if (ret) {\n                    LOG_ERR(\"Failed to start I2S RX (%d)\", ret);\n                    dev_data->state = DMIC_STATE_ERROR;\n                    return ret;\n                }\n            } else {\n                LOG_ERR(\"Invalid state %d\", dev_data->state);\n                return -EIO;\n            }\n            break;\n        case DMIC_TRIGGER_STOP:\n            if (dev_data->state == DMIC_STATE_ACTIVE) {\n                dev_data->state = DMIC_STATE_READY;\n                ret = i2s_trigger(dev_cfg->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n                if (ret) {\n                    LOG_ERR(\"Failed to stop I2S RX (%d)\", ret);\n                    dev_data->state = DMIC_STATE_ERROR;\n                    return ret;\n                }\n            } else {\n                LOG_ERR(\"Invalid state %d\", dev_data->state);\n                return -EIO;\n            }\n            break;\n        default:\n            LOG_ERR(\"Invalid command %d\", cmd);\n            return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 54.59721391123673}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_dev_data *dev_data = dev->data;\n\tconst struct mpxxdtyy_dev_cfg *dev_cfg = dev->config;\n\tstruct i2s_config i2s_cfg;\n\tint ret;\n\n\tif (dev_data->state == MPXXDTYY_DEVICE_STATE_ERROR) {\n\t\tLOG_ERR(\"Device is in error state\");\n\t\treturn -EIO;\n\t}\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (dev_data->state == MPXXDTYY_DEVICE_STATE_ACTIVE) {\n\t\t\tLOG_WRN(\"Device already started\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (dev_data->state != MPXXDTYY_DEVICE_STATE_CONFIGURED) {\n\t\t\tLOG_WRN(\"Device not configured\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\ti2s_cfg.channel_direction = I2S_DIR_RX;\n\t\ti2s_cfg.word_size = I2S_WORD_SIZE_32BIT;\n\t\ti2s_cfg.channels = MPXXDTYY_NUM_CHANNELS;\n\t\ti2s_cfg.format = I2S_FMT_DATA_FORMAT_I2S;\n\t\ti2s_cfg.options = I2S_OPT_FRAME_CLK_SLAVE | I2S_OPT_BIT_CLK_SLAVE;\n\t\ti2s_cfg.frame_clk_freq = MPXXDTYY_FRAME_CLK_FREQ;\n\t\ti2s_cfg.block_size = MPXXDTYY_BLOCK_SIZE;\n\t\ti2s_cfg.mem_slab = &dev_data->rx_mem_slab;\n\t\ti2s_cfg.timeout = 1000;\n\t\ti2s_cfg.options |= I2S_OPT_LOOPBACK;\n\n\t\tret = i2s_trigger(dev_", "CodeBleu_score": 48.32548585383291}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret = 0;\n\tstruct mpxxdtyy_dev_data *dev_data = dev->data;\n\tconst struct mpxxdtyy_dev_cfg *dev_cfg = dev->config;\n\tconst struct i2s_config *i2s_cfg = &dev_cfg->i2s_cfg;\n\n\tif (dev_data->state == MPXXDTYY_STATE_DISABLED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tLOG_INF(\"Starting device %s\", dev->name);\n\t\t\tret = i2s_trigger(dev_data->i2s_dev, I2S_DIR_TX, I2S_TRIGGER_START);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"Failed to start device %s\", dev->name);\n\t\t\t} else {\n\t\t\t\tdev_data->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t}\n\t\t}\n\t} else if (dev_data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tLOG_INF(\"Stopping device %s\", dev->name);\n\t\t\tret = i2s_trigger(dev_data->i2s_dev, I2S_DIR_TX, I2S_TRIGGER_STOP);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"Failed to stop device %s\", dev->name);\n\t\t\t} else {\n\t\t\t\tdev_data->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 41.60669954656457}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0x00;\n\n\tif (enabled) {\n\t\tcommand = config->display_mode;\n\t\tif (data->cursor_enabled) {\n\t\t\tcommand |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t\t}\n\t\tif (data->cursor_blink) {\n\t\t\tcommand |= AUXDISPLAY_HD44780_CURSOR_BLINK;\n\t\t}\n\t\tif (data->display_enabled) {\n\t\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t\t}\n\t}\n\n\tdata->display_enabled = enabled;\n\n\tif (data->display_enabled) {\n\t\tgpio_pin_set_raw(data->rs_gpio, config->rs_pin, 1);\n\t\tgpio_pin_set_raw(data->rw_gpio, config->rw_pin, 0);\n\t\tgpio_pin_set_raw(data->e_gpio, config->e_pin, 0);\n\t}\n\n\tgpio_pin_set_raw(data->rs_gpio, config->rs_pin, 0);\n\tgpio_pin_set_raw(data->rw_gpio, config->rw_pin, 0);\n\tgpio_pin_set_raw(data->e_gpio, config->e_pin, 0);\n\n\tgpio_pin_set_raw(data->data_gpio, config->data_pins[0], (command & 0x01) != 0);\n\tgpio_pin_set_raw(data->data_gpio, config->data_pins[1], (command & 0x02) != 0);\n\tgpio_pin_set_raw(data->data_gpio, config->data_pins[2], (command", "CodeBleu_score": 61.07354229399866}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tstruct auxdisplay_hd44780_config *config = dev->config;\n\n\tuint8_t command = 0;\n\n\tif (enabled) {\n\t\tcommand = AUXDISPLAY_HD44780_DISPLAY_MODE_CMD;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (data->cursor_blink_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK_ON;\n\t}\n\n\tif (data->display_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (data->display_blink_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_BLINK_ON;\n\t}\n\n\tif (data->display_shift_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_SHIFT_ON;\n\t}\n\n\tif (data->display_shift_direction == AUXDISPLAY_HD44780_DISPLAY_SHIFT_DIRECTION_LEFT) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_SHIFT_LEFT;\n\t}\n\n\tif (enabled) {\n\t\tdata->display_enabled = true;\n\t}\n\n\tconfig->write_command(dev, command);\n\n}", "CodeBleu_score": 61.63358292272264}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\n\tstruct auxdisplay_hd44780_config *config = dev->config;\n\n\tuint8_t command = 0;\n\n\tif (enabled) {\n\t\tcommand |= config->display_mode;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_CURSOR_BLINK_ON;\n\t}\n\n\tif (config->display_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tLOG_DBG(\"Set display mode: 0x%02x\", command);\n\n\tif (config->display_enabled) {\n\t\tconfig->display_enabled = false;\n\t}\n\n\tif (config->i2c_api->write(config->i2c_dev, &command, 1, config->i2c_addr) < 0) {\n\t\tLOG_ERR(\"Unable to set display mode\");\n\t}\n\n\tconfig->display_enabled = enabled;\n}", "CodeBleu_score": 57.606981321451045}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *dev_config = dev->config;\n    struct auxdisplay_itron_data *dev_data = dev->data;\n    int ret;\n    int busy;\n\n    if (dev_config->busy_port == NULL) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get(dev_config->busy_port, dev_config->busy_pin);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to get busy pin status (err %d)\", ret);\n        return ret;\n    }\n\n    busy = ret;\n\n    if (dev_data->busy_cb != NULL) {\n        dev_data->busy_cb(dev, busy);\n    }\n\n    return busy;\n}", "CodeBleu_score": 58.186183955865346}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n    if (config->busy_gpio_port == NULL) {\n        return -ENOTSUP;\n    }\n    return gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 70.57781098653221}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tconst struct gpio_dt_spec *busy_gpio;\n\tint rc;\n\n\tif (!device_is_ready(config->busy_gpio.port)) {\n\t\tLOG_ERR(\"Busy GPIO device not ready\");\n\t\treturn -ENODEV;\n\t}\n\n\tbusy_gpio = &config->busy_gpio;\n\trc = gpio_pin_get(busy_gpio->port, busy_gpio->pin);\n\tif (rc < 0) {\n\t\tLOG_ERR(\"Failed to get busy pin (err %d)\", rc);\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 60.901973119184014}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\tstruct auxdisplay_serlcd_config *const config = dev->config;\n\tstruct auxdisplay_serlcd_data *const data = dev->data;\n\n\tuint8_t buffer[2];\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tint result = i2c_write(data->i2c, buffer, 2, config->i2c_address);\n\tif (result) {\n\t\tLOG_ERR(\"Failed to send special command\");\n\t}\n\n\tk_sleep(config->special_command_delay);\n\n\treturn result;\n}", "CodeBleu_score": 51.323133899518005}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\tint ret = i2c_write(config->i2c_dev, buffer, sizeof(buffer), config->i2c_address);\n\tk_sleep(config->special_command_delay);\n\treturn ret;\n}", "CodeBleu_score": 64.52193855829485}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\n\tconst uint8_t command_buffer[] = {\n\t\tAUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX,\n\t\tcommand\n\t};\n\n\tconst struct i2c_msg message = {\n\t\t.buf = (uint8_t *)command_buffer,\n\t\t.len = sizeof(command_buffer),\n\t\t.flags = I2C_MSG_WRITE\n\t};\n\n\tint result = i2c_write(config->i2c_dev, &message, 1, config->i2c_address);\n\n\tif (result != 0) {\n\t\tLOG_ERR(\"I2C write error: %d\", result);\n\t}\n\n\tk_sleep(config->special_command_delay);\n\n\treturn result;\n}", "CodeBleu_score": 49.29916834212056}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *emul_data = dev->data;\n\tconst struct bbram_emul_cfg *emul_cfg = dev->config;\n\n\tif (offset + size > emul_cfg->size) {\n\t\tLOG_ERR(\"Reading out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &emul_data->data[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 52.80738385102695}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_api *api = dev->api;\n\n\tif (offset + size > api->size) {\n\t\tLOG_ERR(\"Read exceeds BBRAM size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data) {\n\t\tLOG_ERR(\"Invalid data pointer\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, api->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 60.60488638470487}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_cfg *cfg = dev->config;\n\n\tif (offset + size > cfg->size) {\n\t\tLOG_ERR(\"Read operation exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data) {\n\t\tLOG_ERR(\"Read operation with invalid buffer\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, cfg->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 61.452210871464686}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tuint8_t *bbram_ptr = data_ptr->bbram_ptr;\n\n\tif (size == 0) {\n\t\tLOG_ERR(\"Write size is 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\tLOG_ERR(\"Write size is too large\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_ptr->state != BBR_VALID) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(bbram_ptr + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 57.78222501899746}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_api *api = (const struct bbram_emul_api *)dev->api;\n\n\tif (size == 0) {\n\t\tLOG_ERR(\"Write size is 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > api->size) {\n\t\tLOG_ERR(\"Write size is too big\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (api->is_invalid) {\n\t\tLOG_ERR(\"BBRAM is invalid\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(api->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 59.10546330438}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tuint8_t *bbram_ptr = data_ptr->bbram;\n\tsize_t bbram_size = data_ptr->size;\n\n\tif (size > bbram_size) {\n\t\tLOG_ERR(\"Invalid size %d\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset > bbram_size) {\n\t\tLOG_ERR(\"Invalid offset %d\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram_size) {\n\t\tLOG_ERR(\"Invalid size %d with offset %d\", size, offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_ptr->invalid) {\n\t\tLOG_ERR(\"BBRAM is invalid\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(bbram_ptr + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 54.16822413117918}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Device not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.3396180458071}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (bbram_is_supported(dev) != 0) {\n\t\tshell_error(sh, \"BBRAM not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 68.96568466443765}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Device not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.3396180458071}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t    struct net_buf *buf;\n    uint8_t hdr_len;\n    uint8_t hdr_buf[4];\n    int read;\n\n    buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);\n\n    hdr_len = 1;\n\n    if (buf->len == 0) {\n        buf->data[0] = bt_uart_poll_in(dev);\n\n        if (buf->data[0] != 0x01) {\n            LOG_ERR(\"Invalid HCI packet type: 0x%02x\", buf->data[0]);\n            bt_buf_put(buf);\n            return;\n        }\n\n        hdr_len = 4;\n    }\n\n    read = bt_uart_read_bytes(dev, hdr_buf, hdr_len - buf->len);\n\n    if (read < 0) {\n        LOG_ERR(\"Failed to read HCI packet header (err %d)\", read);\n        bt_buf_put(buf);\n        return;\n    }\n\n    net_buf_add_mem(buf, hdr_buf, read);\n\n    if (buf->len == 1) {\n        buf->len = bt_buf_get_h4_len(buf->data) + 1;\n    } else {\n        buf->len = sys_get_le16(buf->data) + 1;\n    }\n\n    if (buf->len < 1) {\n        LOG_ERR(\"Invalid HCI packet length: %u bytes\", buf->len);\n        bt_buf_put(buf);\n        return;\n    }\n\n    if (buf->len > CONFIG_BT_RX_BUF_LEN) {\n        LOG_ERR(\"Invalid HCI packet length: %u bytes\", buf->len);\n        bt_buf_put(buf);\n        return;\n    }\n\n    if (buf->len > bt_buf_tailroom(buf)) {\n        LOG_ERR(\"Not enough space in buffer: %u\", buf->len);\n", "CodeBleu_score": 41.13119699664063}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    uint8_t hdr_buf[4];\n    int rx_len;\n    int hdr_len = 4;\n    int hdr_remain = 4;\n    int rx_remain = 0;\n    int err;\n    int i;\n    while (hdr_remain > 0) {\n        rx_len = uart_fifo_read(dev, hdr_buf + 4 - hdr_remain, hdr_remain);\n        if (rx_len < 0) {\n            LOG_ERR(\"UART read error: %d\", err);\n            return;\n        }\n        hdr_remain -= rx_len;\n        rx_remain += rx_len;\n    }\n    for (i = 0; i < 4; i++) {\n        LOG_INF(\"hdr_buf[%d] = %x\", i, hdr_buf[i]);\n    }\n    uint8_t pkt_type = hdr_buf[0] & 0x03;\n    uint16_t pkt_len = (hdr_buf[1] << 8) | hdr_buf[2];\n    uint8_t hdr_checksum = hdr_buf[3];\n    uint8_t calc_checksum = 0;\n    for (i = 0; i < 3; i++) {\n        calc_checksum += hdr_buf[i];\n    }\n    if (calc_checksum != hdr_checksum) {\n        LOG_ERR(\"Invalid checksum\");\n        return;\n    }\n    if (pkt_type == 0) {\n        LOG_INF(\"ACL packet\");\n    } else if (pkt_type == 1) {\n        LOG_INF(\"SCO packet\");\n    } else if (pkt_type == 2) {\n        LOG_INF(\"EVENT packet\");\n    } else if (pkt_type == 3) {\n        LOG_INF(\"VENDOR packet\");\n    } else {\n        LOG_ERR(\"Invalid packet type\");\n        return;\n    }\n    uint8_t *", "CodeBleu_score": 26.49113915313756}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct bt_dev *bt = &bt_dev;\n\tuint8_t buf[sizeof(bt->hdr_buf)];\n\tsize_t bytes_read = 0;\n\tint err;\n\n\terr = uart_fifo_read(dev, buf, sizeof(buf));\n\tif (err < 0) {\n\t\tLOG_ERR(\"Error reading from UART (err %d)\", err);\n\t\treturn;\n\t}\n\n\tbytes_read += err;\n\n\tif (bytes_read > bt->hdr_len) {\n\t\tLOG_ERR(\"Invalid header length (%u)\", bt->hdr_len);\n\t\treturn;\n\t}\n\n\tmemcpy(bt->hdr_buf + bytes_read, buf, bytes_read);\n\tbt->hdr_len -= bytes_read;\n}", "CodeBleu_score": 45.36670182329478}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t read_len;\n\n    read_len = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n    if (read_len < len) {\n        LOG_ERR(\"Failed to discard (err %d)\", -errno);\n        return 0;\n    }\n\n    return read_len;\n}", "CodeBleu_score": 63.7850616960529}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tint err;\n\n\tif (len > 33) {\n\t\tlen = 33;\n\t}\n\n\terr = uart_read(uart, buf, len);\n\tif (err < 0) {\n\t\tLOG_ERR(\"UART read failed: %d\", err);\n\t\treturn 0;\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 62.81863872917709}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read_len;\n\n\tread_len = uart_fifo_read(uart, buf, sizeof(buf));\n\tif (read_len != len) {\n\t\tLOG_ERR(\"Failed to discard %d bytes\", len);\n\t\treturn 0;\n\t}\n\n\treturn read_len;\n}", "CodeBleu_score": 56.91749380543183}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint32_t max_prio = 0;\n\tint32_t prio;\n\tstruct zbus_observer *obs;\n\n\tzbus_channel_lock(chan);\n\n\tobs = zbus_channel_observer_iter(chan, NULL);\n\twhile (obs != NULL) {\n\t\tprio = zbus_observer_priority(obs);\n\t\tif (zbus_observer_is_enabled(obs) && prio < max_prio) {\n\t\t\tmax_prio = prio;\n\t\t}\n\n\t\tobs = zbus_channel_observer_iter(chan, obs);\n\t}\n\n\tchan->highest_observer_prio = max_prio;\n\n\tzbus_channel_unlock(chan);\n}", "CodeBleu_score": 29.688695157817325}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tuint8_t highest = 0xFF;\n\n\tfor (obs = zbus_observer_iterate_start(chan); obs != NULL; obs = zbus_observer_iterate_next(obs)) {\n\t\tif (obs->priority < highest && obs->enabled) {\n\t\t\thighest = obs->priority;\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = highest;\n}", "CodeBleu_score": 22.74884259581065}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t hop = 0xFF;\n\n\tfor (const struct zbus_observer *obs = chan->observers; obs < chan->observers + chan->observer_count; obs++) {\n\t\tif (obs->priority < hop && obs->enabled) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = hop;\n}", "CodeBleu_score": 19.54781226733686}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel *channel;\n\n    ZBUS_FOREACH_CHANNEL(channel) {\n        if (channel->observer == obs) {\n            zbus_channel_update_hop(channel);\n        }\n    }\n}", "CodeBleu_score": 22.186118107039338}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel_observation *obs_ch;\n    sys_snode_t *node;\n\n    ZBUS_CHANNEL_OBSERVATION_FOREACH(node, obs_ch) {\n        if (obs_ch->observer == obs) {\n            obs_ch->update_channel(obs_ch->channel, obs_ch->data);\n        }\n    }\n}", "CodeBleu_score": 24.511900517004566}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel_observation *obs_ch;\n    struct zbus_channel_observation *tmp_obs_ch;\n    SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&zbus_observations, obs_ch, tmp_obs_ch, node) {\n        if (obs_ch->observer == obs) {\n            obs_ch->hop_function(obs_ch->channel);\n        }\n    }\n}", "CodeBleu_score": 21.532039092359618}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    LOG_DBG(\"zbus_obs_attach_to_thread\");\n    return 0;\n}", "CodeBleu_score": 8.259510368176915}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (obs == NULL) {\n\t\tLOG_ERR(\"zbus_obs_attach_to_thread: observer is NULL\");\n\t\treturn -1;\n\t}\n\tif (k_is_in_isr()) {\n\t\tLOG_ERR(\"zbus_obs_attach_to_thread: cannot be called from an ISR\");\n\t\treturn -1;\n\t}\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\tif (obs->prio != K_IDLE_PRIO) {\n\t\tLOG_ERR(\"zbus_obs_attach_to_thread: observer is already attached to a thread\");\n\t\tk_spin_unlock(&obs->lock, key);\n\t\treturn -1;\n\t}\n\tobs->prio = k_thread_priority_get(k_current_get());\n\tfor (int i = 0; i < obs->num_channels; i++) {\n\t\tstruct zbus_channel *ch = obs->channels[i];\n\t\tif (ch == NULL) {\n\t\t\tLOG_ERR(\"zbus_obs_attach_to_thread: channel %d is NULL\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tk_spinlock_key_t key = k_spin_lock(&ch->lock);\n\t\tif (ch->observer == NULL) {\n\t\t\tLOG_ERR(\"zbus_obs_attach_to_thread: channel %d has no observer\", i);\n\t\t\tk_spin_unlock(&ch->lock, key);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch->observer != obs) {\n\t\t\tLOG_ERR(\"zbus_obs_attach_to_thread: channel %d is attached to another observer\", i);\n\t\t\tk_spin_unlock(&ch->lock, key);\n\t\t\tcontinue;\n\t\t}\n\t\tk_thread_priority_set(ch->thread, obs->prio);\n\t\tk_spin_unlock(&ch->lock, key);\n\t}\n\tk_spin_unlock(&obs->", "CodeBleu_score": 38.96899379033937}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    return 0;\n}", "CodeBleu_score": 6.203992247536536}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tif (!chan) {\n\t\treturn -EINVAL;\n\t}\n\tif (k_is_in_isr()) {\n\t\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_TICKS_FOREVER)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_FOREVER - 1)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_TICKS_FOREVER - 1)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_TICKS_FOREVER - 2)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_TICKS_FOREVER - 3)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_TICKS_FOREVER - 4)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_TICKS_FOREVER - 5)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_TICKS_FOREVER - 6)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_TICKS_FOREVER - 7)) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (", "CodeBleu_score": 26.268412997876673}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t__ASSERT_NO_MSG(chan != NULL);\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tconst k_ticks_t end = k_uptime_get() + timeout.ticks;\n\n\tk_prio_t prio = k_thread_priority_get(k_current_get());\n\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\n\tint err = 0;\n\n\tk_spin_unlock(&chan->lock, key);\n\n\treturn err;\n}", "CodeBleu_score": 30.54470470015998}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    struct k_poll_signal *signal;\n    k_timeout_t end;\n    int ret;\n    uint32_t key;\n\n    if (!chan) {\n        return -EINVAL;\n    }\n\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    end = k_timeout_init(timeout);\n\n    key = irq_lock();\n    signal = chan->signal;\n    if (signal) {\n        irq_unlock(key);\n        ret = k_poll_signal_raise(signal, 0);\n        if (ret < 0) {\n            return ret;\n        }\n    } else {\n        irq_unlock(key);\n    }\n\n    return 0;\n}", "CodeBleu_score": 31.652738751886712}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    uint32_t temp;\n\n    /* Check the parameters */\n    assert_param(IS_ETH_INT(Int));\n    assert_param(IS_BOOL(enable));\n\n    if (enable) {\n        /* Enable the selected interrupts */\n        temp = ETH->INT_EN;\n        if (Int & ETH_INT_RX_OVERFLOW) {\n            temp |= ETH_INT_RX_OVERFLOW;\n        }\n        if (Int & ETH_INT_RX_ERR) {\n            temp |= ETH_INT_RX_ERR;\n        }\n        if (Int & ETH_INT_RX_FIN) {\n            temp |= ETH_INT_RX_FIN;\n        }\n        if (Int & ETH_INT_RX_DONE) {\n            temp |= ETH_INT_RX_DONE;\n        }\n        if (Int & ETH_INT_TX_UNDERFLOW) {\n            temp |= ETH_INT_TX_UNDERFLOW;\n        }\n        if (Int & ETH_INT_TX_ERR) {\n            temp |= ETH_INT_TX_ERR;\n        }\n        if (Int & ETH_INT_TX_FIN) {\n            temp |= ETH_INT_TX_FIN;\n        }\n        if (Int & ETH_INT_TX_DONE) {\n            temp |= ETH_INT_TX_DONE;\n        }\n        ETH->INT_EN = temp;\n    } else {\n        /* Disable the selected interrupts */\n        temp = ETH->INT_EN;\n        if (Int & ETH_INT_RX_OVERFLOW) {\n            temp &= ~ETH_INT_RX_OVERFLOW;\n        }\n        if (Int & ETH_INT_RX_ERR) {\n            temp &= ~ETH_INT_RX_ERR;\n        }\n        if (Int & ETH_INT_RX_FIN) {\n            temp &= ~ETH_INT_RX_FIN;\n", "CodeBleu_score": 35.962697083267855}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    uint32_t temp = 0;\n\n    if (Int & ETH_INT_RX_FIN) {\n        temp |= ETH_INT_RX_FIN;\n    }\n\n    if (Int & ETH_INT_RX_DMA_DONE) {\n        temp |= ETH_INT_RX_DMA_DONE;\n    }\n\n    if (Int & ETH_INT_TX_DMA_DONE) {\n        temp |= ETH_INT_TX_DMA_DONE;\n    }\n\n    if (Int & ETH_INT_TX_FIN) {\n        temp |= ETH_INT_TX_FIN;\n    }\n\n    if (Int & ETH_INT_TX_ABT) {\n        temp |= ETH_INT_TX_ABT;\n    }\n\n    if (Int & ETH_INT_RX_ABT) {\n        temp |= ETH_INT_RX_ABT;\n    }\n\n    if (Int & ETH_INT_RX_OVR) {\n        temp |= ETH_INT_RX_OVR;\n    }\n\n    if (Int & ETH_INT_RX_BUF_UNAVAIL) {\n        temp |= ETH_INT_RX_BUF_UNAVAIL;\n    }\n\n    if (Int & ETH_INT_TX_BUF_UNAVAIL) {\n        temp |= ETH_INT_TX_BUF_UNAVAIL;\n    }\n\n    if (Int & ETH_INT_RX_STOP) {\n        temp |= ETH_INT_RX_STOP;\n    }\n\n    if (Int & ETH_INT_TX_STOP) {\n        temp |= ETH_INT_TX_STOP;\n    }\n\n    if (Int & ETH_INT_RX_START) {\n        temp |= ETH_INT_RX_START;\n    }\n\n    if (Int & ETH_INT_TX_START) {\n        temp |= E", "CodeBleu_score": 32.16682624776854}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    if (Int & 0x80000000) {\n        if (enable) {\n            ETH->INTEN |= Int & 0x7FFFFFFF;\n        } else {\n            ETH->INTEN &= ~Int;\n        }\n    } else {\n        if (enable) {\n            ETH->INTEN |= Int;\n        } else {\n            ETH->INTEN &= ~Int;\n        }\n    }\n}", "CodeBleu_score": 29.92619088246751}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\tpTxDesc = (ETH_TX_DESC *)(ETH_BASE + ETH_TDTAR_OFFSET);\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\tif ((pTxDesc->tdes0 & ETH_TDES0_OWN) == 0) {\n\t\t\treturn pTxDesc;\n\t\t}\n\t\tpTxDesc++;\n\t\tif (pTxDesc == (ETH_TX_DESC *)(ETH_BASE + ETH_TDTAR_OFFSET)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.6129501641545}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc = NULL;\n\tuint32_t i = 0;\n\tuint32_t TxStatus = 0;\n\n\t/* Check for unlocked TxDescriptors */\n\tfor (i = 0; i < ETH_TXBUFNB; i++) {\n\t\tpTxDesc = (ETH_TX_DESC *) (ETH_BASE + 0x1000 + i * 0x10);\n\t\tTxStatus = pTxDesc->status;\n\n\t\tif ((TxStatus & ETH_TDES0_OWN) == 0) {\n\t\t\t/* Return pointer to the free Tx descriptor */\n\t\t\treturn pTxDesc;\n\t\t}\n\t}\n\n\t/* There are no free Tx descriptors */\n\treturn 0;\n}", "CodeBleu_score": 31.848167850600028}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *ptxdesc;\n    uint32_t firsttxdesc;\n    uint32_t descidx;\n\n    firsttxdesc = ETH->DMA_TXDESC;\n    descidx = 0;\n    ptxdesc = (ETH_TX_DESC *)firsttxdesc;\n    while (1) {\n        if ((ptxdesc->status & ETH_TX_DESC_OWN) == 0) {\n            return ptxdesc;\n        }\n        descidx++;\n        if (descidx == ETH_TX_DESC_CNT) {\n            return 0;\n        }\n        ptxdesc++;\n        if ((uint32_t)ptxdesc == firsttxdesc) {\n            return 0;\n        }\n    }\n}", "CodeBleu_score": 38.191401950645854}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_err_t result = RT_EOK;\n    cy_rslt_t status;\n    CSD_Type *dac_base;\n    CSD_IDAC_Type *dac_channel;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    dac_base = (CSD_Type *)device->parent.user_data;\n    dac_channel = (CSD_IDAC_Type *)(dac_base + 1UL + (channel * CSD_IDAC_Type_SIZE));\n\n    status = Cy_CSDIDAC_OutputEnable(dac_channel, *value);\n    if (CY_CSD_SUCCESS != status) {\n        result = RT_ERROR;\n        LOG_E(\"Failed to enable DAC output for channel %d. Error code: %d\", channel, status);\n    }\n\n    return result;\n}", "CodeBleu_score": 51.56413331037668}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\n    struct rt_dac_device *dac = device;\n    struct cyp_dac_device *dev = (struct cyp_dac_device *)dac->parent.user_data;\n    cy_rslt_t result = CY_RSLT_SUCCESS;\n\n    RT_ASSERT(dev != RT_NULL);\n\n    if (channel >= dev->channel_num) {\n        return -RT_EIO;\n    }\n\n    result = Cy_CSDIDAC_SetValue(dev->base, channel, *value);\n    if (result != CY_RSLT_SUCCESS) {\n        return -RT_EIO;\n    }\n\n    result = Cy_CSDIDAC_OutputEnable(dev->base, channel);\n    if (result != CY_RSLT_SUCCESS) {\n        return -RT_EIO;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 53.7287108864708}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_err_t result = RT_EOK;\n    cy_rslt_t status = CY_RSLT_SUCCESS;\n    cy_stc_csd_dac_config_t config;\n    cy_stc_csd_dac_context_t context;\n\n    CY_ASSERT_L1(NULL != device);\n    CY_ASSERT_L1(NULL != value);\n\n    /* Get the CSD DAC configuration structure */\n    config = *(cy_stc_csd_dac_config_t *)device->config;\n\n    /* Get the CSD DAC context structure */\n    context = *(cy_stc_csd_dac_context_t *)device->data;\n\n    /* Get the CSD DAC channel */\n    cy_stc_csd_dac_channel_config_t *dac_channel = &config.dacChannelConfig[channel];\n\n    /* Enable the CSD DAC channel */\n    status = Cy_CSD_DAC_Init(dac_channel, &context);\n\n    if (CY_RSLT_SUCCESS != status) {\n        LOG_E(\"Failed to initialize the CSD DAC channel, error code: %d\", status);\n        result = -RT_ERROR;\n    } else {\n        /* Set the CSD DAC channel output value */\n        status = Cy_CSD_DAC_WriteValue(dac_channel, &context, *value);\n\n        if (CY_RSLT_SUCCESS != status) {\n            LOG_E(\"Failed to set the CSD DAC channel output value, error code: %d\", status);\n            result = -RT_ERROR;\n        } else {\n            /* Enable the CSD DAC channel output */\n            status = Cy_CSD_DAC_OutputEnable(dac_channel, &context);\n\n            if (CY_RSLT_SUCCESS != status) {\n                LOG_E(\"Failed to enable the CSD DAC channel output, error code: %d\", status);\n                result = -RT_ERROR;\n            }\n        }\n    }\n\n    return result;\n", "CodeBleu_score": 45.87867230983386}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    rt_uint32_t *p = (rt_uint32_t *)addr;\n\n    if (addr + size > IFX_FLASH_END_ADDRESS) {\n        return -RT_EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        *buf++ = *p++;\n    }\n\n    return size;\n}", "CodeBleu_score": 45.43633251461591}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t *flash_ptr;\n\trt_uint32_t *buf_ptr;\n\n\tif (addr + size > IFX_FLASH_END_ADDRESS) {\n\t\treturn -1;\n\t}\n\n\tflash_ptr = (rt_uint32_t *)(IFX_FLASH_START_ADDRESS + addr);\n\tbuf_ptr = (rt_uint32_t *)buf;\n\n\tfor (i = 0; i < size; i += 4) {\n\t\t*buf_ptr = *flash_ptr;\n\t\tflash_ptr++;\n\t\tbuf_ptr++;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 41.09178860401214}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    rt_uint32_t end_addr = addr + size;\n\n    if (end_addr > 0x00080000) {\n        return -RT_ERROR;\n    }\n\n    for (i = addr; i < end_addr; i++) {\n        *buf = *((rt_uint8_t *)i);\n        buf++;\n    }\n\n    return size;\n}", "CodeBleu_score": 43.872292223594044}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    uint32_t count;\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    cy_rslt_t rslt = cyhal_timer_read(obj, &count);\n    if (rslt != CY_RSLT_SUCCESS)\n    {\n        rt_kprintf(\"cyhal_timer_read error\n\");\n    }\n    return count;\n}", "CodeBleu_score": 54.60169707650042}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    uint32_t count;\n    cyhal_timer_read((cyhal_timer_t *)timer->parent.user_data, &count);\n    return count;\n}", "CodeBleu_score": 47.43278620011428}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    rt_uint32_t count = 0;\n    cy_rslt_t result;\n    cyhal_timer_t *obj;\n\n    RT_ASSERT(timer != RT_NULL);\n    RT_ASSERT(timer->parent.user_data != RT_NULL);\n\n    obj = (cyhal_timer_t *)timer->parent.user_data;\n    result = cyhal_timer_read(obj, &count);\n    if (result != CY_RSLT_SUCCESS) {\n        rt_kprintf(\"Get timer count error: %d\n\", result);\n        return 0;\n    }\n\n    return count;\n}", "CodeBleu_score": 57.33345645035664}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    os_mutex_lock(&dfs_lock, OS_IPC_WAITING_FOREVER);\n}", "CodeBleu_score": 7.181925779554381}, {"code": "void dfs_lock(void){\n\t    /* take the lock */\n    if (rt_mutex_take(&dfs_lock_mutex, RT_WAITING_FOREVER) != RT_EOK) {\n        /* take the lock failed */\n        RT_ASSERT(0);\n    }\n}", "CodeBleu_score": 27.731996556298828}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(&dfs_lock_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.59057861658449}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n    struct dfs_fdtable_entry *entry;\n\n    /* search for an empty slot starting from the specified index */\n    for (i = startfd; i < fdt->maxfd; i++) {\n        entry = fdt->fdt_entry + i;\n        if (entry->status == DFS_FD_STATUS_UNUSED) {\n            return i;\n        }\n    }\n\n    /* no empty slot is found, try to expand the fd table */\n    if (fdt->maxfd >= DFS_FD_MAX) {\n        return -1;\n    }\n\n    entry = fdt->fdt_entry + fdt->maxfd;\n    entry->status = DFS_FD_STATUS_UNUSED;\n    entry->type = DFS_FD_TYPE_UNKNOWN;\n    entry->flags = 0;\n    entry->offset = 0;\n    entry->fops = NULL;\n    entry->data = NULL;\n\n    fdt->maxfd++;\n\n    return fdt->maxfd - 1;\n}", "CodeBleu_score": 38.968380425745764}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n\n    for (fd = startfd; fd < DFS_FD_MAX; fd++) {\n        if (fdt->fd_array[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    if (fdt->max_fds == DFS_FD_MAX) {\n        return -1;\n    }\n\n    fd = fdt->max_fds;\n    fdt->max_fds++;\n\n    return fd;\n}", "CodeBleu_score": 40.66707961467062}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    if (startfd < 0) {\n        startfd = 0;\n    }\n\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fds[i].flags == 0) {\n            return i;\n        }\n    }\n\n    if (fdt->maxfd >= DFS_FD_MAX) {\n        return -1;\n    }\n\n    fdt->fds = RT_KERNEL_REALLOC(fdt->fds, (fdt->maxfd + 1) * sizeof(struct dfs_fd));\n    if (fdt->fds == RT_NULL) {\n        return -1;\n    }\n\n    fdt->maxfd++;\n\n    return i;\n}", "CodeBleu_score": 43.521974190890276}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    static const char * const err_tab[] = {\n        \"EOK\",\n        \"EERROR\",\n        \"EINVALID\",\n        \"EINVALID_PARAM\",\n        \"EINVALID_ADDR\",\n        \"EINVALID_OPERATION\",\n        \"EINVALID_SIZE\",\n        \"EINVALID_ARG\",\n        \"EINVALID_MAGIC\",\n        \"EINVALID_HANDLE\",\n        \"EINVALID_VERSION\",\n        \"EINVALID_SYS\",\n        \"EINVALID_VER\",\n        \"EINVALID_ALIGN\",\n        \"EINVALID_SEQ\",\n        \"EINVALID_ID\",\n        \"EINVALID_ID_HANDLE\",\n        \"EINVALID_ID_DATA\",\n        \"EINVALID_ID_NAME\",\n        \"EINVALID_ID_SIZE\",\n        \"EINVALID_ID_MAGIC\",\n        \"EINVALID_ID_CHECKSUM\",\n        \"EINVALID_ID_VERSION\",\n        \"EINVALID_ID_COUNT\",\n        \"EINVALID_ID_NOMEM\",\n        \"EINVALID_ID_FULL\",\n        \"EINVALID_ID_EMPTY\",\n        \"EINVALID_ID_FMT\",\n        \"EINVALID_ID_DATA_SIZE\",\n        \"EINVALID_ID_DATA_CHECKSUM\",\n        \"EINVALID_ID_DATA_FULL\",\n        \"EINVALID_ID_DATA_EMPTY\",\n        \"EINVALID_ID_NAME_DUPLICATE\",\n        \"EINVALID_ID_NAME_TOOLONG\",\n        \"EINVALID_ID_NAME_FMT\",\n        \"EINVALID_ID_DELETED\",\n        \"EINVALID_ID_NOT_FOUND\",\n        \"EINVALID_ID_NOT_CREATED\",\n        \"EINVALID_ID_IN_USE\",\n        \"EINVALID_ID_INVALID\",\n        \"EINVALID_ID_CHECKSUM\",\n        \"EINVALID_ID_NO_MEM\",\n        \"EINVALID_ID_LENGTH\",\n", "CodeBleu_score": 5.515512881711966}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tstatic const char *rt_strerror_tab[] = {\n\t\t\"EOK\",\n\t\t\"EUNKNOW\",\n\t\t\"EINVAL\",\n\t\t\"EINTR\",\n\t\t\"EIO\",\n\t\t\"ENOMEM\",\n\t\t\"EAGAIN\",\n\t\t\"EINPROGRESS\",\n\t\t\"EALREADY\",\n\t\t\"EPROTONOSUPPORT\",\n\t\t\"EPROTO\",\n\t\t\"EPROTOTYPE\",\n\t\t\"ENOPROTOOPT\",\n\t\t\"EPROTONOTSUPPORT\",\n\t\t\"ESOCKTNOSUPPORT\",\n\t\t\"EOPNOTSUPP\",\n\t\t\"EPFNOSUPPORT\",\n\t\t\"EAFNOSUPPORT\",\n\t\t\"EADDRINUSE\",\n\t\t\"EADDRNOTAVAIL\",\n\t\t\"ENETDOWN\",\n\t\t\"ENETUNREACH\",\n\t\t\"ENETRESET\",\n\t\t\"ECONNABORTED\",\n\t\t\"ECONNRESET\",\n\t\t\"ENOBUFS\",\n\t\t\"EISCONN\",\n\t\t\"ENOTCONN\",\n\t\t\"ETIMEDOUT\",\n\t\t\"ECONNREFUSED\",\n\t\t\"EHOSTDOWN\",\n\t\t\"EHOSTUNREACH\",\n\t\t\"EINPROGRESS\",\n\t\t\"EALREADY\",\n\t\t\"EDESTADDRREQ\",\n\t\t\"EMSGSIZE\",\n\t\t\"EPROTONOSUPPORT\",\n\t\t\"ESOCKTNOSUPPORT\",\n\t\t\"EOPNOTSUPP\",\n\t\t\"EPFNOSUPPORT\",\n\t\t\"EAFNOSUPPORT\",\n\t\t\"EADDRINUSE\",\n\t\t\"EADDRNOTAVAIL\",\n\t\t\"ENETDOWN\",\n\t\t\"ENETUNREACH\",\n\t\t\"ENETRESET\",\n\t\t\"ECONNABORTED\",\n\t\t\"ECONNRESET\",\n\t\t\"ENOBUFS\",\n\t\t\"EIS", "CodeBleu_score": 4.8480768665905165}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\n\tstatic const char *rt_error_strings[] = {\n\n\t\t\"EOK\",\n\n\t\t\"EFAIL\",\n\n\t\t\"EINVL\",\n\n\t\t\"EINVL_PARAM\",\n\n\t\t\"EINVL_PARAM_VAL\",\n\n\t\t\"EINVL_PARAM_TYPE\",\n\n\t\t\"EINVL_PARAM_RANGE\",\n\n\t\t\"EINVL_PARAM_SIZE\",\n\n\t\t\"EINVL_PARAM_ALIGN\",\n\n\t\t\"EINVL_PARAM_CONF\",\n\n\t\t\"EINVL_PARAM_NULL\",\n\n\t\t\"EINVL_PARAM_STATE\",\n\n\t\t\"EINVL_PARAM_CALL\",\n\n\t\t\"EINVL_PARAM_TIME\",\n\n\t\t\"EINVL_PARAM_ARCH\",\n\n\t\t\"EINVL_PARAM_OS\",\n\n\t\t\"EINVL_PARAM_FEAT\",\n\n\t\t\"EINVL_PARAM_SZ\",\n\n\t\t\"EINVL_PARAM_VAL_RANGE\",\n\n\t\t\"EINVL_PARAM_VAL_ALIGN\",\n\n\t\t\"EINVL_PARAM_VAL_OS\",\n\n\t\t\"EINVL_PARAM_VAL_ARCH\",\n\n\t\t\"EINVL_PARAM_VAL_FEAT\",\n\n\t\t\"EINVL_PARAM_VAL_CONF\",\n\n\t\t\"EINVL_PARAM_VAL_SIZE\",\n\n\t\t\"EINVL_PARAM_VAL_ALIGN_ARCH\",\n\n\t\t\"EINVL_PARAM_VAL_ALIGN_FEAT\",\n\n\t\t\"EINVL_PARAM_VAL_ALIGN_OS\",\n\n\t\t\"EINVL_PARAM_VAL_ALIGN_CONF\",\n\n\t\t\"EINVL_PARAM_VAL_ALIGN_SZ\",\n\n\t\t\"EINVL_OBJ\",", "CodeBleu_score": 4.773394846413904}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result = RT_EOK;\n    rt_base_t level;\n    rt_uint32_t i;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_thread_idle_hook_list[i] == RT_NULL) {\n            rt_thread_idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 69.76092985075171}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t lock;\n    rt_err_t result = RT_EFULL;\n    rt_thread_t tid;\n    rt_uint32_t i;\n\n    tid = rt_thread_self();\n    RT_ASSERT(tid != RT_NULL);\n\n    lock = rt_hw_interrupt_disable();\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_LIST_SIZE; i++) {\n        if (tid->idle_hook_list[i] == RT_NULL) {\n            tid->idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n    rt_hw_interrupt_enable(lock);\n\n    return result;\n}", "CodeBleu_score": 52.15354411211251}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_err_t result = RT_EOK;\n\n    if (hook == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    level = rt_hw_interrupt_disable();\n    if (idle_thread->idle_hook_list_num < RT_IDLE_HOOK_LIST_SIZE) {\n        idle_thread->idle_hook[idle_thread->idle_hook_list_num] = hook;\n        idle_thread->idle_hook_list_num ++;\n    } else {\n        result = -RT_EFULL;\n    }\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 31.917754655587576}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_err_t ret = RT_EOK;\n    rt_thread_idle_hook_t *hook_item;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n    hook_item = &rt_thread_idle_hook_list[0];\n    while (*hook_item != RT_NULL) {\n        if (*hook_item == hook) {\n            *hook_item = RT_NULL;\n            break;\n        }\n        hook_item++;\n    }\n    if (*hook_item == RT_NULL) {\n        ret = -RT_ERROR;\n    }\n    rt_hw_interrupt_enable(level);\n\n    return ret;\n}", "CodeBleu_score": 35.64233687826329}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_thread_idle_hook_t *idle_hook;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n\n    idle_hook = _k_idle_hook_list;\n    while (idle_hook != RT_NULL) {\n        if (idle_hook->idle_hook == hook) {\n            idle_hook->idle_hook = RT_NULL;\n            break;\n        }\n\n        idle_hook = idle_hook->next;\n    }\n\n    if (idle_hook == RT_NULL) {\n        rt_hw_interrupt_enable(level);\n        return -RT_ERROR;\n    }\n\n    rt_hw_interrupt_enable(level);\n    return RT_EOK;\n}", "CodeBleu_score": 42.819273878726946}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_base_t   level;\n    rt_err_t    result = RT_EOK;\n    rt_uint32_t i;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_thread_idle_hook_list[i] == hook) {\n            rt_thread_idle_hook_list[i] = RT_NULL;\n            break;\n        }\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    if (i == RT_THREAD_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 57.394854792772264}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    struct rt_thread *thread;\n    struct rt_list_node *node;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* wakeup all suspended thread */\n    for (node = susp_list->next; node != susp_list; node = node->next) {\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n        /* remove thread from suspend list */\n        rt_list_remove(&thread->tlist);\n\n        /* resume thread */\n        thread->error = thread_error;\n        rt_thread_resume(thread);\n    }\n\n    /* enable interrupt */\n    rt_exit_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 37.2852858633805}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    struct rt_thread *thread;\n    struct rt_list_node *node;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* resume all suspended thread */\n    for (node = susp_list->next; node != susp_list; node = node->next) {\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n\n        /* resume thread */\n        rt_thread_resume(thread);\n\n        /* set error code */\n        thread->error = thread_error;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 41.78245347280808}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_list_t *list;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    rt_enter_critical();\n\n    /* check suspension list */\n    if (susp_list->next == susp_list)\n        goto __exit;\n\n    /* resume all suspended threads */\n    list = susp_list->next;\n    while (list != susp_list) {\n        thread = rt_list_entry(list, struct rt_thread, tlist);\n\n        /* remove thread from suspension list */\n        rt_list_remove(list);\n\n        /* resume thread */\n        rt_thread_resume(thread);\n\n        /* set error code */\n        thread->error = thread_error;\n\n        /* check if thread is ready */\n        if (thread->stat == RT_THREAD_READY)\n            /* then insert thread to scheduler ready list */\n            rt_schedule_insert_thread(thread);\n\n        /* switch to next thread */\n        list = list->next;\n    }\n\n__exit:\n    rt_exit_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 35.88223979907876}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t new_device, old_device = RT_NULL;\n    rt_err_t result;\n\n    /* find the new device */\n    new_device = rt_device_find(name);\n    if (new_device == RT_NULL) {\n        rt_kprintf(\"can't find device: %s\n\", name);\n        return old_device;\n    }\n\n    /* check if the new device is the same as the old device */\n    if (rt_console_get_device() == new_device) {\n        rt_kprintf(\"the new device is the same as the old device\n\");\n        return old_device;\n    }\n\n    /* close the old device */\n    old_device = rt_console_get_device();\n    if (old_device != RT_NULL) {\n        rt_device_close(old_device);\n    }\n\n    /* open the new device */\n    result = rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_OFLAG_STREAM);\n    if (result != RT_EOK) {\n        rt_kprintf(\"open device failed: %s\n\", name);\n        return old_device;\n    }\n\n    /* set the new device as the console device */\n    rt_console_set_device(new_device);\n\n    return old_device;\n}", "CodeBleu_score": 63.120216651119755}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = RT_NULL;\n    rt_device_t new_console = RT_NULL;\n\n    if (name == RT_NULL) {\n        return RT_NULL;\n    }\n\n    if (rt_console_get_device() == RT_NULL) {\n        old_console = RT_NULL;\n    } else {\n        old_console = rt_console_get_device();\n    }\n\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        return old_console;\n    }\n\n    if (new_console == old_console) {\n        return old_console;\n    }\n\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return old_console;\n    }\n\n    rt_console_set_device(new_console);\n\n    return old_console;\n}", "CodeBleu_score": 59.257737502471855}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t new_device, old_device = RT_NULL;\n\n    /* find device */\n    new_device = rt_device_find(name);\n    if (new_device == RT_NULL) {\n        rt_kprintf(\"Can't find device: %s\n\", name);\n        return RT_NULL;\n    }\n\n    /* check device type */\n    if (new_device->type != RT_Device_Class_Char) {\n        rt_kprintf(\"Device: %s is not a character device\n\", name);\n        return RT_NULL;\n    }\n\n    /* close old device */\n    old_device = rt_console_get_device();\n    if (old_device != RT_NULL) {\n        rt_device_close(old_device);\n    }\n\n    /* set new device */\n    rt_console_set_device(new_device);\n\n    /* open new device */\n    if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        rt_kprintf(\"Can't open device: %s\n\", name);\n        return RT_NULL;\n    }\n\n    return old_device;\n}", "CodeBleu_score": 61.40820944027294}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tstruct rt_object *object;\n\n\tRT_ASSERT(type < RT_Object_Class_Unknown);\n\n\tfor (object = object_list[type]; object != RT_NULL; object = object->next) {\n\t\tcount++;\n\t}\n\n\treturn count;\n}", "CodeBleu_score": 26.579026527129162}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object *object;\n    struct rt_list_node *node;\n    int count = 0;\n\n    RT_ASSERT(type < RT_Object_Class_Unknown);\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* try to get the first object */\n    object = rt_object_get_object(type);\n    if (object != RT_NULL)\n    {\n        /* lock object */\n        rt_object_take(object);\n\n        /* get object list */\n        node = &(object->list);\n\n        /* release object */\n        rt_object_put(object);\n\n        /* iterate list */\n        while (1)\n        {\n            /* get next object */\n            object = rt_list_entry(node, struct rt_object, list);\n\n            /* lock object */\n            rt_object_take(object);\n\n            /* increase count */\n            count ++;\n\n            /* get next node */\n            node = node->next;\n\n            /* release object */\n            rt_object_put(object);\n\n            /* break if end of object list */\n            if (node == &(object->list))\n                break;\n        }\n    }\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    return count;\n}", "CodeBleu_score": 47.79403336828397}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int length = 0;\n    struct rt_object *object;\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* try to get the first object */\n    object = rt_object_get_first(type);\n    if (object != RT_NULL)\n    {\n        /* get the first object */\n        while (object != RT_NULL)\n        {\n            /* increase the length */\n            length ++;\n\n            /* get next object */\n            object = rt_object_get_next(object);\n        }\n    }\n\n    /* leave critical */\n    rt_exit_critical();\n\n    return length;\n}", "CodeBleu_score": 39.40852109699652}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_list_t *list;\n\n    RT_ASSERT(object != RT_NULL);\n\n    /* invoke object detach hook */\n    if (object->type == RT_Object_Class_Thread) {\n        rt_thread_t thread = (rt_thread_t)object;\n\n        if (thread->cleanup != RT_NULL)\n        {\n            /* call cleanup function */\n            thread->cleanup(thread);\n        }\n    }\n\n    /* remove object from object list */\n    list = &(rt_object_container[object->type]);\n    rt_enter_critical();\n    rt_list_remove(&(object->list));\n    rt_exit_critical();\n\n    /* set object type to unknown */\n    object->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 52.306933046827496}, {"code": "void rt_object_detach(rt_object_t object){\n\t\n    /* object check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* call object detach hook */\n    if (object->type != RT_Object_Class_Unknown)\n    {\n        rt_object_detach_hook(object);\n    }\n\n    /* get object information */\n    rt_object_information_t information;\n    rt_object_get_information(object, &information);\n\n    /* lock object spinlock */\n    rt_base_t lock;\n    lock = rt_hw_interrupt_disable();\n\n    /* remove object from object list */\n    rt_list_remove(&(information.object_list));\n\n    /* unlock object spinlock */\n    rt_hw_interrupt_enable(lock);\n\n    /* set object type to unknown */\n    object->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 45.67260677445729}, {"code": "void rt_object_detach(rt_object_t object){\n\t    struct rt_object_information *information;\n\n    /* object check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* get object information */\n    information = (struct rt_object_information *)(object->type);\n    RT_ASSERT(information != RT_NULL);\n\n    /* lock object */\n    rt_base_t lock = rt_hw_interrupt_disable();\n\n    /* remove object from list */\n    rt_list_remove(&(object->list));\n\n    /* unlock object */\n    rt_hw_interrupt_enable(lock);\n\n    /* set object type to RT_Object_Class_Unknown */\n    object->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 55.814454546568996}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n\n    RT_ASSERT(obj != RT_NULL);\n\n    if (obj->type == RT_Object_Class_Custom) {\n        struct rt_object_information *information = (struct rt_object_information *)(obj->type_info);\n\n        if (information->object_destroy != RT_NULL) {\n            result = information->object_destroy(obj);\n        }\n\n        rt_free(obj);\n    } else {\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 52.884499729307464}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\n    rt_err_t result = RT_EOK;\n\n    /* check object */\n    RT_ASSERT(obj != RT_NULL);\n\n    /* check object type */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* check object */\n    RT_ASSERT(obj->type == RT_Object_Class", "CodeBleu_score": 29.00482819196575}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n    rt_custom_object_t object = (rt_custom_object_t)obj;\n\n    RT_ASSERT(object != RT_NULL);\n\n    /* check object type */\n    RT_ASSERT(object->type == RT_Object_Class_Custom);\n\n    /* check object type */\n    if (object->type != RT_Object_Class_Custom)\n        return -RT_ERROR;\n\n    /* destroy object */\n    if (object->ops != RT_NULL && object->ops->destroy != RT_NULL)\n        result = object->ops->destroy(object);\n\n    /* delete object */\n    rt_object_delete(object);\n\n    return result;\n}", "CodeBleu_score": 46.84889959825908}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t tid = rt_thread_self();\n    rt_base_t   level;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* remove from schedule */\n    rt_schedule_remove_thread(tid);\n\n    /* change thread stat */\n    tid->stat = RT_THREAD_CLOSE;\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* do auto cleanup */\n    if (tid->cleanup != RT_NULL)\n        tid->cleanup(tid);\n\n    /* remove it from timer list */\n    rt_timer_detach(&(tid->thread_timer));\n\n    /* remove it from timer list */\n    rt_timer_detach(&(tid->thread_timer));\n\n    /* insert to defunct thread list */\n    rt_list_insert_after(&rt_thread_defunct, &(tid->tlist));\n\n    /* do context switch */\n    rt_schedule();\n\n    /* never reach here */\n    RT_ASSERT(0);\n}", "CodeBleu_score": 56.09666587473943}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread = rt_thread_self();\n\n    RT_ASSERT(thread != RT_NULL);\n\n    rt_enter_critical();\n\n    /* change the stat of thread */\n    thread->stat = RT_THREAD_CLOSE;\n\n    /* remove from schedule */\n    rt_schedule_remove_thread(thread);\n\n    /* insert to defunct thread list */\n    rt_list_insert_before(&rt_thread_defunct, &(thread->tlist));\n\n    /* trigger a context switch */\n    rt_schedule();\n\n    /* never reach here */\n}", "CodeBleu_score": 58.64474387797588}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* change thread stat */\n    thread->stat = RT_THREAD_CLOSE;\n\n    /* add to defunct thread list */\n    rt_list_insert_before(&rt_thread_defunct, &(thread->tlist));\n\n    /* leave critical */\n    rt_exit_critical();\n\n    /* do schedule */\n    rt_schedule();\n\n    /* never reach here */\n}", "CodeBleu_score": 55.27134547495434}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t)parameter;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n    rt_enter_critical();\n    thread->stat = RT_THREAD_READY;\n    /* remove thread from suspend list */\n    rt_list_remove(&(thread->tlist));\n    /* insert thread to ready list */\n    rt_list_insert_before(&(thread->rlist), &(rt_thread_priority_table[thread->current_priority]));\n    /* thread timeout */\n    thread->error = -RT_ETIMEOUT;\n    rt_exit_critical();\n\n    /* do schedule */\n    rt_schedule();\n}", "CodeBleu_score": 44.47500640074883}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n    rt_tick_t tick;\n\n    RT_ASSERT(parameter != RT_NULL);\n\n    thread = (struct rt_thread *)parameter;\n\n    rt_scheduler_lock();\n\n    /* thread check */\n    RT_ASSERT(thread->stat != RT_THREAD_CLOSE);\n    RT_ASSERT(thread->stat != RT_THREAD_READY);\n    RT_ASSERT(thread->stat != RT_THREAD_RUNNING);\n\n    /* thread is suspend */\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_scheduler_unlock();\n\n        return;\n    }\n\n    /* remove thread from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* insert to schedule ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* do schedule */\n    need_schedule();\n\n    /* get tick */\n    tick = rt_tick_get();\n\n    /* thread timeout check */\n    if (thread->timeout > tick) {\n        thread->timeout -= tick;\n    }\n    else {\n        thread->timeout = 0;\n    }\n\n    rt_scheduler_unlock();\n}", "CodeBleu_score": 59.94945488620458}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n\n    thread = (struct rt_thread *)parameter;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to schedule ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* enable interrupt */\n    rt_exit_critical();\n\n    /* do schedule */\n    rt_schedule();\n}", "CodeBleu_score": 56.22391001850653}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t lock;\n    rt_mutex_t mutex;\n\n    RT_ASSERT(thread != RT_NULL);\n\n    lock = rt_hw_interrupt_disable();\n    /* is it waiting on a mutex? */\n    if (thread->stat & RT_THREAD_STAT_MUTEX) {\n        /* detach it from mutex */\n        mutex = thread->mutex_pending;\n        RT_ASSERT(mutex != RT_NULL);\n\n        /* remove thread from mutex's waiting list */\n        rt_list_remove(&(thread->tlist));\n        thread->stat &= ~RT_THREAD_STAT_MUTEX;\n        thread->mutex_pending = RT_NULL;\n\n        /* if mutex is not in the priority queue, remove it */\n        if (!(mutex->stat & RT_MUTEX_STAT_IN_QUEUE)) {\n            /* remove it from mutex priority queue */\n            rt_list_remove(&(mutex->mlist));\n        }\n\n        /* if mutex is not in the priority queue, remove it */\n        if (!(mutex->stat & RT_MUTEX_STAT_IN_QUEUE)) {\n            /* remove it from mutex priority queue */\n            rt_list_remove(&(mutex->mlist));\n        }\n\n        /* if there is no waiting thread, release mutex */\n        if (rt_list_isempty(&(mutex->list))) {\n            mutex->owner = RT_NULL;\n            mutex->stat &= ~RT_MUTEX_STAT_IN_QUEUE;\n            mutex->stat &= ~RT_MUTEX_STAT_PRIORITY;\n            mutex->stat &= ~RT_MUTEX_STAT_ROBIN;\n        }\n        else {\n            /* there are still threads waiting on the mutex */\n            rt_thread_t next_thread;\n            rt_list_t *queue_list;\n\n            /* get next thread to be scheduled */\n            next_thread = rt_list_entry(mutex->list.next,", "CodeBleu_score": 41.336958629984295}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    struct rt_mutex *mutex;\n\n    RT_ASSERT(thread != RT_NULL);\n\n    if (thread->mutex_list == RT_NULL)\n        return;\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* remove from mutex's waiting list */\n    mutex = thread->mutex_list;\n    if (mutex->owner_thread == thread) {\n        /* remove self from mutex's owner list */\n        mutex->owner_thread = mutex->prev;\n        if (mutex->prev != RT_NULL)\n            mutex->prev->next = RT_NULL;\n    } else {\n        /* remove self from mutex's waiting list */\n        while (mutex->prev != thread)\n            mutex = mutex->prev;\n        mutex->prev = thread->prev;\n        if (mutex->prev != RT_NULL)\n            mutex->prev->next = RT_NULL;\n    }\n\n    /* clear thread pending object */\n    thread->pending_object = RT_NULL;\n\n    /* release all mutexes */\n    while (thread->mutex_list != RT_NULL) {\n        mutex = thread->mutex_list;\n\n        /* remove self from mutex's owner list */\n        mutex->owner_thread = mutex->prev;\n        if (mutex->prev != RT_NULL)\n            mutex->prev->next = RT_NULL;\n\n        /* clear thread pending object */\n        thread->pending_object = RT_NULL;\n\n        /* release mutex */\n        mutex->lock_nest--;\n        if (mutex->lock_nest == 0) {\n            mutex->owner_thread = RT_NULL;\n\n            /* release mutex */\n            rt_mutex_release(mutex);\n        }\n    }\n\n    /* enable interrupt */\n    rt_exit_critical();\n}", "CodeBleu_score": 45.30978919426432}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_list_t *node;\n    struct rt_mutex *mutex;\n\n    /* take the thread lock */\n    rt_enter_critical();\n\n    /* check if the thread is waiting for a mutex */\n    if (thread->pending_object != RT_NULL) {\n        /* check if the thread is waiting for a mutex */\n        if (thread->pending_object->type == RT_Object_Class_Mutex) {\n            /* remove from the mutex waiting list */\n            mutex = (struct rt_mutex *)thread->pending_object;\n            rt_list_remove(&(thread->tlist));\n\n            /* clear the pending object */\n            thread->pending_object = RT_NULL;\n\n            /* release the mutex */\n            rt_mutex_release(mutex);\n        }\n    }\n\n    /* release the thread lock */\n    rt_exit_critical();\n}", "CodeBleu_score": 39.42888837389236}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n    rt_base_t lock;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type(&thread->parent) == RT_Object_Class_Thread);\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* set to ready status */\n    thread->stat = RT_THREAD_READY;\n\n    /* insert to schedule ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    rt_schedule();\n\n    return RT_EOK;\n}", "CodeBleu_score": 41.37269627021135}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->type == RT_THREAD_TYPE_MAIN);\n\n    /* set thread state */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* reset cleanup function */\n    thread->cleanup = RT_NULL;\n\n    /* reset thread timer */\n    thread->remaining_time = 0;\n\n    /* reset thread error number */\n    thread->error = RT_EOK;\n\n    /* thread ready to run */\n    rt_schedule_insert_thread(thread);\n\n    /* do a schedule */\n    rt_schedule();\n\n    return RT_EOK;\n}", "CodeBleu_score": 52.8100481870896}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result = RT_EOK;\n\n    if (thread == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    if (thread->stat != RT_THREAD_INIT) {\n        return -RT_ERROR;\n    }\n\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"startup thread: %s\n\", thread->name));\n\n    /* set to suspend state */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* calculate priority attribute */\n    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(thread->parent)));\n\n    /* reset thread error number */\n    thread->error = RT_EOK;\n\n    /* insert to schedule ready queue */\n    rt_schedule_insert_thread(thread);\n\n    /* start it */\n    rt_schedule();\n\n    return result;\n}", "CodeBleu_score": 43.44673849395885}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *timer_node;\n    rt_timer_t timer;\n\n    RT_ASSERT(timer_list != RT_NULL);\n    RT_ASSERT(timeout_tick != RT_NULL);\n\n    timer_node = timer_list[0].next;\n    if (timer_node != &(timer_list[0])) {\n        timer = rt_list_entry(timer_node, struct rt_timer, row[0]);\n        *timeout_tick = timer->timeout_tick;\n\n        return RT_EOK;\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 57.100097649226086}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_base_t level;\n    rt_list_t *timer_node;\n    rt_timer_t timer;\n\n    RT_ASSERT(timer_list != RT_NULL);\n    RT_ASSERT(timeout_tick != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n\n    timer_node = timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next;\n    if (timer_node != &(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        timer = (rt_timer_t)rt_list_entry(timer_node, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1].list);\n        *timeout_tick = timer->timeout_tick;\n        rt_hw_interrupt_enable(level);\n\n        return RT_EOK;\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 58.32746359925222}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *l;\n    rt_timer_t timer;\n\n    /* check if the highest level of the timer skip list is not empty */\n    l = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n    if (l->next != l) {\n        /* get the first timer entry */\n        timer = rt_list_entry(l->next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n        /* set timeout tick */\n        *timeout_tick = timer->timeout_tick;\n\n        return RT_EOK;\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 68.02126688088947}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(time > 0);\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* initialize timer object */\n    rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);\n    timer->timeout_func = timeout;\n    timer->parameter    = parameter;\n    timer->time_init    = time;\n    timer->time_counter = time;\n    timer->flag         = flag;\n\n    return timer;\n}", "CodeBleu_score": 58.686911573697095}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\n    rt_timer_t timer;\n    rt_object_t object;\n\n    /* allocate object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* set object flag */\n    if (flag & RT_TIMER_FLAG_ONE_SHOT) {\n        rt_object_set_flag(timer, RT_TIMER_FLAG_ONE_SHOT);\n    }\n    if (flag & RT_TIMER_FLAG_SOFT_TIMER) {\n        rt_object_set_flag(timer, RT_TIMER_FLAG_SOFT_TIMER);\n    }\n\n    /* set user data */\n    timer->parameter = parameter;\n\n    /* set timeout function */\n    timer->timeout_func = timeout;\n\n    /* set time */\n    timer->init_tick = time;\n    timer->timeout_tick = time;\n\n    /* insert timer to timer list */\n    rt_timer_insert(timer);\n\n    /* startup timer */\n    rt_timer_start(timer);\n\n    return timer;\n}", "CodeBleu_score": 53.037638570832854}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\n    rt_timer_t timer;\n\n    /* allocate a new timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* initialize timer object */\n    rt_timer_init(timer,\n                  name,\n                  timeout,\n                  parameter,\n                  time,\n                  flag);\n\n    return timer;\n}", "CodeBleu_score": 64.1270957033187}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tfor _, handler := range a.handlers {\n\t\trecorder := httptest.NewRecorder()\n\t\thandler.ServeHTTP(recorder, req)\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 71.10939085471256}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tfor _, handler := range a.handlers {\n\t\trecorder := httptest.NewRecorder()\n\t\thandler(recorder, req)\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\ta.sendError(res, req, http.StatusUnauthorized, \"Not Authorized\")\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 78.07520453268768}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Capture the response using a recorder\n\trecorder := httptest.NewRecorder()\n\n\t// Pass the request through the handlers\n\tfor _, handler := range a.handlers {\n\t\thandler(recorder, req)\n\n\t\t// If any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\ta.sendError(res, recorder.Code, \"Not Authorized\")\n\t\t\treturn\n\t\t}\n\t}\n\n\t// If all handlers pass without unauthorized status, it forwards the request to the router for further handling.\n\ta.router.ServeHTTP(res, req)\n\n\t// Copy the recorder's headers to the original response\n\tfor k, v := range recorder.Header() {\n\t\tres.Header()[k] = v\n\t}\n}", "CodeBleu_score": 63.729911179590026}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := Asset(path)\n\tif err != nil {\n\t\thttp.Error(res, \"Not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\text := strings.ToLower(path[strings.LastIndex(path, \".\")+1:])\n\tswitch ext {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 56.40416092157867}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// If the request is for the API, serve the API\n\tif strings.HasPrefix(req.URL.Path, \"/api\") {\n\t\ta.router.ServeHTTP(res, req)\n\t\treturn\n\t}\n\n\t// Otherwise, serve the static assets\n\tasset, err := Asset(req.URL.Path)\n\tif err != nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\n\t// Set the Content-Type header based on the file extension\n\text := strings.TrimPrefix(req.URL.Path, \"/\")\n\text = strings.TrimSuffix(ext, \"/\")\n\text = strings.TrimSuffix(ext, \"/index.html\")\n\text = strings.TrimSuffix(ext, \".html\")\n\text = strings.TrimSuffix(ext, \".js\")\n\text = strings.TrimSuffix(ext, \".css\")\n\tif ext == \"\" {\n\t\text = \"html\"\n\t}\n\tcontentType := \"text/html\"\n\tswitch ext {\n\tcase \"js\":\n\t\tcontentType = \"application/javascript\"\n\tcase \"css\":\n\t\tcontentType = \"text/css\"\n\t}\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Write the asset content to the response\n\tres.Write(asset)\n}", "CodeBleu_score": 49.4433707366285}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tvar (\n\t\terr error\n\t\tbuf []byte\n\t)\n\n\tif strings.HasPrefix(req.URL.Path, \"/api/\") {\n\t\ta.router.ServeHTTP(res, req)\n\t\treturn\n\t}\n\n\tif strings.HasPrefix(req.URL.Path, \"/favicon.ico\") {\n\t\tres.Header().Set(\"Content-Type\", \"image/x-icon\")\n\t\tres.Write([]byte{})\n\t\treturn\n\t}\n\n\tif strings.HasPrefix(req.URL.Path, \"/robots.txt\") {\n\t\tres.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tres.Write([]byte(\"User-agent: *", "CodeBleu_score": 32.232316023659365}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robot/\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, `{\"error\": \"No robot found with name %s\"}`, robotName)\n\t\treturn\n\t}\n\n\tconnections := make([]map[string]interface{}, 0)\n\tfor _, connection := range robot.Connections() {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\":    connection.Name(),\n\t\t\t\"adaptor\": connection.AdaptorName(),\n\t\t\t\"port\":    connection.Port(),\n\t\t})\n\t}\n\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 46.87481611130679}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\tname = strings.TrimSuffix(name, \"/connections\")\n\n\t// Find the robot with the specified name\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\t// If the robot was not found, write a JSON error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, `{\"error\": \"No robot named %s\"}`, name)\n\t\treturn\n\t}\n\n\t// Gather the robot's connections\n\tconnections := []robeaux.Connection{}\n\tfor _, connection := range robot.Connections() {\n\t\tconnections = append(connections, robeaux.Connection{\n\t\t\tName:     connection.Name(),\n\t\t\tPort:     connection.Port(),\n\t\t\tProtocol: connection.Protocol(),\n\t\t})\n\t}\n\n\t// Convert the connections to JSON format\n\tjson, err := json.Marshal(connections)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, `{\"error\": \"Failed to marshal connections to JSON\"}`)\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(res, string(json))\n}", "CodeBleu_score": 39.02261512269506}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Path[len(\"/api/robots/\"):]\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, `{\"error\":\"no robot found with name %s\"}`, robotName)\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\tjsonConnections, err := json.Marshal(connections)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, `{\"error\":\"%s\"}`, err)\n\t\treturn\n\t}\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(res, string(jsonConnections))\n}", "CodeBleu_score": 36.40926095126268}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tb, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tpair := string(b)\n\t\ti := byte(0)\n\t\tfor j := 0; j < len(pair); j++ {\n\t\t\tif pair[j] == ':' {\n\t\t\t\ti = byte(j)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(username), []byte(pair[:i])) == 0 {\n\t\t\tif subtle.ConstantTimeCompare([]byte(password), []byte(pair[i+1:])) == 0 {\n\t\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 50.361470807335685}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tb, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := string(b)\n\t\ti := byte(0)\n\t\tfor j := 0; j < len(pair); j++ {\n\t\t\tif pair[j] == ':' {\n\t\t\t\ti = byte(j)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tu, p := pair[:i], pair[i+1:]\n\t\tif subtle.ConstantTimeCompare([]byte(u), []byte(username)) != 1 ||\n\t\t\tsubtle.ConstantTimeCompare([]byte(p), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If everything is okay, call the next handler\n\t\t// in the chain.\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(`{\"message\": \"Success!\"}`))\n\t}\n}", "CodeBleu_score": 48.61212920039549}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Authorization header from the request\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\t// If the header is empty, return a 401 status\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Decode the header\n\t\tb, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\t// Split the decoded string into username and password\n\t\tpair := string(b)\n\t\tsep := byte(':')\n\t\tif i := byteIndex(b, sep); i >= 0 {\n\t\t\tpair = string(b[:i]) + string(b[i+1:])\n\t\t}\n\t\t// Check the username and password\n\t\tif subtle.ConstantTimeCompare([]byte(username), []byte(pair)) != 1 || subtle.ConstantTimeCompare([]byte(password), []byte(pair)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If everything is OK, call the next handler\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tw.Write([]byte(\"Welcome, \" + username + \"!\"))\n\t}\n}", "CodeBleu_score": 49.353057002572434}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t} else if value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 58.528397378693384}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept for the scaling transformation\n\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\t// Perform the scaling\n\t\tvalue = int(slope*input + intercept)\n\n\t\t// Ensure the output is clamped within the target range\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn value\n\t}\n}", "CodeBleu_score": 59.0829482527633}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - (slope * fromMin)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 59.1569310781805}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"Analog read not supported\")\n\t}\n\n\tvalue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = value\n\ta.lastScaledValue = a.scale(value)\n\n\treturn value, a.lastScaledValue, nil\n}", "CodeBleu_score": 52.16809991469963}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"Analog read not supported\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scale(raw)\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 48.04509392206203}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"Connection does not support analog read\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.voltageRange / 1024.0\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 47.44850050429864}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(x int) float64 {\n\t\tif x < fromMin {\n\t\t\treturn toMin\n\t\t} else if x > fromMax {\n\t\t\treturn toMax\n\t\t} else {\n\t\t\treturn m*float64(x) + n\n\t\t}\n\t}\n}", "CodeBleu_score": 74.66687608975423}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 51.082230834924324}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\n\treturn func(value int) float64 {\n\t\treturn m*float64(value) + n\n\t}\n}", "CodeBleu_score": 51.50501711351385}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tv:    NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\td.AddEvent(VibrationEvent)\n\n\td.v.On(d.v.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tgobot.Publish(d.Event(VibrationEvent), data)\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 50.10821691453744}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tvibeE: gobot.NewEvent(VibrationEvent),\n\t\tconn:  NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\td.AddEvent(d.vibeE)\n\n\td.conn.AddEvent(d.Event(DataEvent))\n\n\td.AddCommand(\"On\", func(params map[string]interface{}) interface{} {\n\t\td.Start()\n\t\treturn nil\n\t})\n\n\td.AddCommand(\"Off\", func(params map[string]interface{}) interface{} {\n\t\td.Halt()\n\t\treturn nil\n\t})\n\n\treturn d\n}", "CodeBleu_score": 40.36070756741555}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tvibe: gobot.NewEvent(),\n\t\tpin:  pin,\n\t\ta:    NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\td.AddEvent(d.Event(\"Vibration\"))\n\n\td.a.Once(d.a.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(\"Vibration\"), data)\n\t\t}\n\t})\n\n\tif err := d.a.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 57.360083781497885}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz < 0 {\n\t\treturn fmt.Errorf(\"invalid frequency: %f\", hz)\n\t}\n\tif duration < 0 {\n\t\treturn fmt.Errorf(\"invalid duration: %f\", duration)\n\t}\n\tif d.bpm < 0 {\n\t\treturn fmt.Errorf(\"invalid bpm: %f\", d.bpm)\n\t}\n\tif d.pin == \"\" {\n\t\treturn fmt.Errorf(\"invalid pin: %s\", d.pin)\n\t}\n\tif d.connection == nil {\n\t\treturn fmt.Errorf(\"invalid connection\")\n\t}\n\n\t// Calculate the tone period and tempo\n\tperiod := 60.0 / (hz * d.bpm)\n\ttempo := period * duration\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period\n\tfor i := 0.0; i < tempo; i += period {\n\t\terr := d.connection.DigitalWrite(d.pin, d.activeLow)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period*1000) * time.Millisecond)\n\t\terr = d.connection.DigitalWrite(d.pin, !d.activeLow)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period*1000) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.350340224312944}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.connection == nil {\n\t\treturn fmt.Errorf(\"BuzzerDriver requires connection to be set\")\n\t}\n\tvar err error\n\tvar tempo float64\n\tvar period float64\n\tvar on bool\n\tvar ticker *time.Ticker\n\n\tif hz <= 0 || duration <= 0 {\n\t\treturn fmt.Errorf(\"Invalid frequency or duration\")\n\t}\n\n\tif d.bpm <= 0 {\n\t\treturn fmt.Errorf(\"Invalid BPM\")\n\t}\n\n\ttempo = 60 / d.bpm\n\tperiod = 1 / hz\n\n\tticker = time.NewTicker(time.Duration(tempo * period * 1000000000))\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tif on {\n\t\t\t\tif err = d.Off(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err = d.On(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\ton = !on\n\t\tcase <-time.After(time.Duration(duration * 1000000000)):\n\t\t\tif err = d.Off(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n}", "CodeBleu_score": 35.85922633848712}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tvar (\n\t\terr     error\n\t\ttone    = time.Duration(1000000 / hz)\n\t\ttempo   = time.Duration(60000000 / d.bpm)\n\t\ttoneDur = time.Duration(duration * float64(tone))\n\t)\n\n\tif err = d.Start(); err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < int(toneDur/tempo); i++ {\n\t\tif err = d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(tone)\n\t\tif err = d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(tempo - tone)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 42.730657046150164}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.SleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\td.Stop()\n\td.SleepPin.DigitalWrite(0)\n\td.Sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.12380146441558}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.SleepPin == \"\" {\n\t\treturn fmt.Errorf(\"Sleep pin is not set\")\n\t}\n\n\tif err := d.Stop(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := d.SetPin(d.SleepPin, gobot.Gpio.Low); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 50.10341764386702}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"cannot sleep, no sleep pin set\")\n\t}\n\tif d.isSleeping {\n\t\treturn fmt.Errorf(\"already sleeping\")\n\t}\n\tif d.isMoving {\n\t\treturn fmt.Errorf(\"cannot sleep while moving\")\n\t}\n\td.Stop()\n\td.sleepPin.Write(false)\n\td.isSleeping = true\n\treturn nil\n}", "CodeBleu_score": 36.199682224175646}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Pins not initialized\")\n\t}\n\n\tif a.pins[id] == nil {\n\t\tpath, params, err := a.translateID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin, err := a.NewAnalogPin(path, params)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.pins[id] = pin\n\t}\n\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 53.630544146883985}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Pins map is not initialized\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, params, err := a.translatePinID(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp, err := gobot.NewAnalogPin(path, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = p\n\n\treturn p, nil\n}", "CodeBleu_score": 49.66780077169522}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpin, err := a.newAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 48.349246619911455}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\tpin, err := a.getPin(id, gpioDigital)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := pin.Write(val); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 60.3665979410114}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id, \"DigitalWrite\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif pin.Mode != gpio.OUT {\n\t\treturn fmt.Errorf(\"Pin %s is not an output\", id)\n\t}\n\n\treturn pin.DigitalWrite(val)\n}", "CodeBleu_score": 67.13200184943705}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\n\tpin, err := a.getPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := pin.DigitalWrite(val); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 59.788455590763846}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.Connected() {\n\t\treturn nil, fmt.Errorf(\"not connected\")\n\t}\n\n\ta.digitalPinsMutex.Lock()\n\tdefer a.digitalPinsMutex.Unlock()\n\n\tif a.digitalPins == nil {\n\t\ta.digitalPins = make(map[string]gobot.DigitalPinner)\n\t}\n\n\tif _, ok := a.digitalPins[id]; !ok {\n\t\tpin, err := a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin.Configure(opts...)\n\t\ta.digitalPins[id] = pin\n\t} else {\n\t\ta.digitalPins[id].Configure(opts...)\n\t}\n\n\treturn a.digitalPins[id], nil\n}", "CodeBleu_score": 43.825188891122316}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins configured\")\n\t}\n\n\tfor _, pin := range a.pins {\n\t\tif pin.ID() == id {\n\t\t\tfor _, option := range opts {\n\t\t\t\toption(pin)\n\t\t\t}\n\t\t\treturn pin, nil\n\t\t}\n\t}\n\n\tpin, err := a.translatePin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgobotPin := newDigitalPin(a, pin.Chip, pin.Line, pin.Name)\n\tfor _, option := range opts {\n\t\toption(gobotPin)\n\t}\n\ta.pins = append(a.pins, gobotPin)\n\n\treturn gobotPin, nil\n}", "CodeBleu_score": 45.58715756752629}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.Connected() {\n\t\treturn nil, fmt.Errorf(\"adaptor not connected\")\n\t}\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins found\")\n\t}\n\tvar pin gobot.DigitalPinner\n\tvar err error\n\tvar found bool\n\tfor _, p := range a.pins {\n\t\tif p.ID() == id {\n\t\t\tfound = true\n\t\t\tpin = p\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tchip, line, err := a.translateID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = &DigitalPin{\n\t\t\tchip: chip,\n\t\t\tline: line,\n\t\t\tadaptor: a,\n\t\t\toptions: opts,\n\t\t}\n\t\ta.pins = append(a.pins, pin)\n\t} else {\n\t\tpin.SetOptions(opts...)\n\t}\n\treturn pin, err\n}", "CodeBleu_score": 48.001148538420644}]}
