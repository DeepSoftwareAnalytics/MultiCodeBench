{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> required_files;\n  std::vector<std::string> missing_files;\n  std::vector<std::string> files;\n  std::vector<std::string> missing_files_with_path;\n\n  try {\n    files = _client.GetFilesInDirectory(folder);\n  } catch (const std::exception &e) {\n    log_error(e.what());\n    throw;\n  }\n\n  for (const auto &file : files) {\n    if (file.find(\".egg\") != std::string::npos) {\n      required_files.push_back(file);\n    }\n  }\n\n  for (const auto &file : required_files) {\n    if (download) {\n      if (!FileExists(file)) {\n        log_info(\"Downloading\", file);\n        _client.DownloadFile(folder, file);\n      } else {\n        log_info(\"Found in cache\", file);\n      }\n    }\n  }\n\n  return required_files;\n}", "CodeBleu_score": 53.44858449882287}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> result;\n  auto files = _client.GetRequiredFiles(folder);\n  for (auto &file : files) {\n    if (download) {\n      auto path = _client.GetFile(folder, file);\n      if (path.empty()) {\n        _client.RequestFile(folder, file);\n        LOG_INFO(\"Downloading \" + folder + \"/\" + file);\n      } else {\n        LOG_INFO(\"Found \" + folder + \"/\" + file + \" in cache\");\n      }\n    }\n    result.emplace_back(file);\n  }\n  return result;\n}", "CodeBleu_score": 47.581390639012945}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> files;\n    auto response = _client.call(\"get_required_files\", folder, download);\n    if (response.has_error()) {\n        throw_exception(std::move(response).error());\n    }\n    files = std::move(response).get<std::vector<std::string>>();\n    return files;\n}", "CodeBleu_score": 44.811095022257796}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        const auto &translation = transform.location;\n        const auto &rotation = transform.rotation;\n        if (translation.x == 0.0 && translation.y == 0.0 &&\n            rotation.pitch == 0.0 && rotation.yaw == 0.0 && rotation.roll == 0.0) {\n            log_warning(\n                \"The transformation provided for the actor with ID\",\n                description.id,\n                \"is ill-formed. This may cause the actor to be spawned with an invalid transformation.\");\n        }\n    }\n    return SpawnActorWithParentImpl(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 50.88435369565294}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0f &&\n        transform.location.y == 0.0f &&\n        transform.location.z != 0.0f) {\n      log_warning(\n          \"The provided transform has only a translation in the z axis. \"\n          \"This is not a valid attachment transform for a SpringArm or \"\n          \"SpringArmGhost attachment type. The attachment transform will be \"\n          \"ignored.\");\n    }\n  }\n  return SpawnActorWithParentImpl(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 44.15287325418594}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n  // This function, Client::SpawnActorWithParent, spawns an actor with a specified parent using the provided description, transform, parent ID, attachment type, and socket name.\nIf the attachment type is SpringArm or SpringArmGhost, it checks the validity of the transformation to avoid ill-formed transformations when the translation is only in the 'z' axis and issues a warning if necessary.\nFinally, it calls an internal function to complete the actor spawning process and returns the spawned actor.\n\n  // Check if the attachment type is SpringArm or SpringArmGhost\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the transformation is ill-formed\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f && transform.location.z == 0.0f &&\n        transform.rotation.pitch == 0.0f && transform.rotation.yaw == 0.0f && transform.rotation.roll == 0.0f) {\n      // If the transformation is ill-formed, issue a warning\n      log_warning(\n          \"The actor transformation is ill-formed. The translation is only in the 'z' axis. \"\n          \"This may cause the actor to be spawned in an unexpected location.\");\n    }\n  }\n\n  // Call an internal function to complete the actor spawning process and return the spawned actor\n  return _client->SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 49.10287006525736}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t    auto token = GetGBufferToken(ActorId, GBufferId);\n    const auto &token_data = token.GetTokenData();\n    auto stream = _streaming_client->Subscribe(token_data.token);\n    callback(stream.PopBuffer());\n    stream.RegisterCallback(std::move(callback));\n}", "CodeBleu_score": 49.28023243696933}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n  // Retrieve the token for the G-buffer.\n  auto token = GetToken(ActorId, GBufferId);\n\n  // Copy the token data.\n  std::vector<uint8_t> token_data(token.begin(), token.end());\n\n  // Subscribe to the streaming client using the provided callback function.\n  _streaming_client->Subscribe(token_data, callback);\n}", "CodeBleu_score": 39.34375048078581}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token = _client.SubscribeToGBuffer(ActorId, GBufferId);\n  auto token_data = token.GetToken();\n  std::copy(token_data.begin(), token_data.end(), std::back_inserter(_streaming_tokens));\n  _streaming_client.Subscribe(token, callback);\n}", "CodeBleu_score": 48.82061146163807}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::lock_guard<std::mutex> guard(episode_mutex);\n  if (navigation == nullptr) {\n    try {\n      navigation = std::make_shared<WalkerNavigation>(GetWorld(), GetClient().GetTrafficManager());\n    } catch (const std::exception &e) {\n      log_error(e.what());\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 41.394971032253935}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\n  if (navigation == nullptr) {\n    auto result = client.CreateWalkerNavigation();\n    if (!result.has_value()) {\n      log_error(\n          \"Failed to create a WalkerNavigation object, check your server's log for more details\");\n      return nullptr;\n    }\n    navigation = result.value();\n  }\n  return navigation;\n}", "CodeBleu_score": 42.06233107659541}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (!_navigation) {\n    try {\n      _navigation = std::make_shared<WalkerNavigation>(_client, _id);\n    } catch (const std::exception &e) {\n      log_error(e.what());\n    }\n  }\n  return _navigation;\n}", "CodeBleu_score": 35.297485545593524}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto start_time = std::chrono::steady_clock::now();\n  while (episode.GetCurrentFrame() < frame) {\n    const auto current_time = std::chrono::steady_clock::now();\n    if (current_time - start_time > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.Lock()->GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 43.68555797824698}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::high_resolution_clock::now();\n  while (episode.GetCurrentFrame() < frame) {\n    using namespace std::chrono;\n    auto now = high_resolution_clock::now();\n    auto duration = duration_cast<time_duration>(now - start);\n    if (duration > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.Lock()->GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 47.445688038411504}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\n  auto start = std::chrono::system_clock::now();\n\n  while (episode.GetCurrentFrame() < frame) {\n\n    std::this_thread::yield();\n\n    auto end = std::chrono::system_clock::now();\n\n    if (std::chrono::duration_cast<time_duration>(end - start) > timeout) {\n\n      return false;\n\n    }\n\n  }\n\n  episode.Lock()->GetTrafficManager()->Tick();\n\n  return true;\n\n}", "CodeBleu_score": 52.50051640531896}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  EpisodeProxy episode;\n  std::size_t attempts = 0u;\n  while (attempts++ < 1000000000u) {\n    episode = EpisodeProxy(\n        client.AsyncLoadEpisode(map_name, reset_settings, map_layers));\n    if (episode.GetId() != 0) {\n      break;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n  }\n  if (attempts >= 1000000000u) {\n    throw_exception(std::runtime_error(\"timeout when trying to connect to the episode\"));\n  }\n  return episode;\n}", "CodeBleu_score": 36.606061505528174}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // Check if the simulator is already running.\n  if (EpisodeProxy::IsValid()) {\n    throw_exception(std::runtime_error(\"episode already running\"));\n  }\n\n  // Load the new episode.\n  const auto episode_id = _client.LoadNewEpisode(map_name, reset_settings, map_layers);\n\n  // Wait until the episode is ready to connect.\n  for (auto i = 0u; i != 100u; ++i) {\n    if (EpisodeProxy::IsValid()) {\n      return EpisodeProxy{*this};\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(100u));\n  }\n\n  throw_exception(std::runtime_error(\"timeout when trying to connect to episode\"));\n}", "CodeBleu_score": 44.30589785587205}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  log_debug(\"Simulator::LoadEpisode\");\n  log_debug(\"map_name: \" + map_name);\n  log_debug(\"reset_settings: \" + std::to_string(reset_settings));\n  log_debug(\"map_layers: \" + std::to_string(map_layers));\n\n  // 1. Load the episode.\n  auto episode_id = client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // 2. Wait until the episode is ready to be used.\n  int attempts = 0;\n  while (client.GetEpisode().GetId() != episode_id) {\n    if (attempts > 1000) {\n      throw_exception(std::runtime_error(\"timeout while waiting for episode to be ready\"));\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    ++attempts;\n  }\n\n  // 3. Return the episode.\n  return EpisodeProxy(client.GetEpisode());\n}", "CodeBleu_score": 49.0553796126353}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = GetActorById(controller.GetWalker()->GetId());\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"cannot register AI controller: walker not found\"));\n  }\n  assert(_episode != nullptr);\n  if (_episode->GetNavigation() == nullptr) {\n    _episode->SetNavigation(std::make_shared<carla::client::detail::WalkerNavigation>(*this));\n  }\n  _episode->GetNavigation()->RegisterWalker(controller.GetWalker(), controller.GetId());\n}", "CodeBleu_score": 54.97935262323136}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = controller.GetWalker();\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"WalkerAIController: walker is not valid\"));\n  }\n  if (episode == nullptr) {\n    throw_exception(std::runtime_error(\"WalkerAIController: episode is null\"));\n  }\n  if (navigation == nullptr) {\n    navigation = std::make_unique<WalkerNavigation>(*this);\n  }\n  navigation->RegisterController(controller.GetId(), walker);\n}", "CodeBleu_score": 58.490882081358144}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = controller.GetWalker();\n  if (!walker) {\n    throw_exception(std::runtime_error(\"WalkerAIController not associated with a walker\"));\n  }\n  if (episode == nullptr) {\n    throw_exception(std::runtime_error(\"cannot register AI controller, episode is null\"));\n  }\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(*this);\n  }\n  navigation->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 56.45974374153558}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    if (blueprint.GetId() == 0u) {\n        log_error(\"Trying to spawn an actor from an empty blueprint.\");\n        return nullptr;\n    }\n    ActorId parent_id = 0u;\n    if (parent != nullptr) {\n        parent_id = parent->GetId();\n    }\n    rpc::Actor actor = GetCurrentEpisode().Lock()->SpawnActor(\n        blueprint.GetId(),\n        transform,\n        parent_id,\n        attachment_type,\n        socket_name);\n    auto result = _actor_factory->MakeActor(actor);\n    if (gc != GarbageCollectionPolicy::DoNotApply) {\n        _garbage_collection_policy.ApplyPolicy(result, gc);\n    }\n    return result;\n}", "CodeBleu_score": 51.53374500802887}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n    // Create the actor.\n    Actor actor = GetCurrentEpisode().SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n\n    // Register the actor in the current episode.\n    _episode->RegisterActor(actor);\n\n    // Apply the garbage collection policy.\n    if (gc == GarbageCollectionPolicy::Inherit) {\n        gc = _garbage_collection_policy;\n    }\n    if (gc == GarbageCollectionPolicy::Enabled) {\n        _garbage_collection_candidates.insert(actor.GetId());\n    }\n\n    // Log the creation.\n    log_debug(\n        \"actor\", actor.GetId(),\n        \"spawned\", blueprint.GetId(),\n        \"at\", transform,\n        \"with\", parent ? parent->GetId() : -1,\n        \"with attachment type\", static_cast<int>(attachment_type),\n        \"with socket name\", socket_name);\n\n    // Return the actor.\n    return actor;\n}", "CodeBleu_score": 48.384006622730006}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  return GetCurrentEpisode().SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n}", "CodeBleu_score": 19.940427278541005}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n  // Ensure the episode is valid.\n  if (!Episode::IsValid()) {\n    throw_exception(std::runtime_error(\"invalid episode\"));\n  }\n\n  // Subscribe to the sensor's data stream.\n  auto stream = Client.SubscribeToStream(sensor.GetStreamToken());\n\n  // Set up the callback to handle the incoming data.\n  stream.RegisterCallback(\n      [this, callback](SharedPtr<carla::rpc::SensorData> sensor_data) {\n        // Deserialize the sensor data.\n        auto deserialized = sensor::Deserializer::Deserialize(sensor_data);\n\n        // Associate the deserialized data with the current episode.\n        deserialized->SetEpisode(Episode);\n\n        // Invoke the callback with the deserialized sensor data.\n        callback(deserialized);\n      });\n}", "CodeBleu_score": 43.11582410275185}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (sensor.IsValid()) {\n    client.SubscribeToStream(\n        sensor.GetStreamingPort(),\n        [this, callback](SharedPtr<Buffer> buffer) {\n          auto data = sensor::Deserializer::Deserialize(buffer);\n          data->SetEpisode(GetCurrentEpisode());\n          callback(data);\n        });\n  } else {\n    log_error(\n        \"Simulator::SubscribeToSensor\",\n        \"invalid sensor\");\n  }\n}", "CodeBleu_score": 45.49475232799692}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(_episode != nullptr);\n  DEBUG_ASSERT(_client != nullptr);\n  auto stream = _client->SubscribeToStream(sensor.GetStreamToken());\n  stream.RegisterCallback(\n      [this, callback](SharedPtr<sensor::SensorData> data) {\n        data->Listen(this->_episode);\n        callback(data);\n      });\n}", "CodeBleu_score": 49.49942269342042}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  std::vector<rpc::WalkerControl> walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  std::vector<uint64_t> walker_ids;\n  walker_ids.reserve(walkers.size());\n  for (const auto &walker : walkers) {\n    walker_ids.push_back(walker.id);\n  }\n\n  auto state = episode->GetState();\n  state.RemoveWalkers(walker_ids);\n\n  nav.UpdateVehicles(walkers);\n  nav.UpdateCrowd();\n\n  std::vector<rpc::Transform> transforms;\n  std::vector<float> speeds;\n  transforms.reserve(walkers.size());\n  speeds.reserve(walkers.size());\n  for (const auto &walker : walkers) {\n    transforms.emplace_back(walker.transform);\n    speeds.push_back(walker.speed);\n  }\n\n  episode->ApplyControlToWalkers(transforms, speeds);\n\n  auto dead_walkers = nav.GetDeadWalkers();\n  for (uint64_t id : dead_walkers) {\n    nav.RemoveWalker(id);\n    episode->DestroyWalkerController(id);\n  }\n}", "CodeBleu_score": 45.0964316641322}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  std::vector<uint64_t> walker_ids = episode->GetWalkerIds();\n  if (walker_ids.empty()) {\n    return;\n  }\n  auto state = episode->GetState();\n  auto walkers = state.GetWalkers();\n  walker_ids.erase(\n      std::remove_if(\n          walker_ids.begin(),\n          walker_ids.end(),\n          [&walkers](auto id) { return walkers.find(id) == walkers.end(); }),\n      walker_ids.end());\n  _navigation.UpdateVehicles(walker_ids);\n  _navigation.UpdateCrowd();\n  std::vector<carla::rpc::Command> commands;\n  commands.reserve(walker_ids.size());\n  for (auto walker_id : walker_ids) {\n    auto walker = walkers.at(walker_id);\n    auto transform = walker.GetTransform();\n    auto velocity = walker.GetVelocity();\n    commands.emplace_back(\n        carla::rpc::Command::ApplyWalkerState,\n        carla::rpc::WalkerControl{transform, velocity});\n  }\n  episode->ApplyBatch(commands);\n  for (auto walker_id : walker_ids) {\n    auto walker = walkers.at(walker_id);\n    auto transform = walker.GetTransform();\n    auto velocity = walker.GetVelocity();\n    _navigation.SetVehicleState(walker_id, transform, velocity);\n  }\n  std::vector<uint64_t> dead_walkers;\n  for (auto walker_id : walker_ids) {\n    if (!walkers.at(walker_id).IsAlive()) {\n      dead_walkers.push_back(walker_id);\n    }\n  }\n  for (auto walker_id : dead_walkers) {\n    _navigation.RemoveVehicle(walker_id);\n    _controllers.erase(walker_id);\n  }\n}", "CodeBleu_score": 46.06038187269231}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  auto state = episode->GetState();\n  for (auto it = _controllers.begin(); it != _controllers.end();) {\n    if (state.find(it->first) == state.end()) {\n      it = _controllers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  nav::CrowdHandle crowd_handle = _navigation->GetCrowd();\n  nav::Crowd::Agent const *agents = _navigation->GetAgents();\n  nav::Crowd::Agent *agent_positions = _navigation->GetAgentPositions();\n  nav::Crowd::AgentState *agent_states = _navigation->GetAgentStates();\n  nav::Crowd::AgentAnimation *agent_animations = _navigation->GetAgentAnimations();\n  nav::Crowd::Obstacle *obstacles = _navigation->GetObstacles();\n  nav::Crowd::AgentAvoidanceParams *agent_avoidance_params = _navigation->GetAgentAvoidanceParams();\n\n  _navigation->UpdateCrowd(crowd_handle, agents, agent_positions, agent_states, agent_animations, obstacles, agent_avoidance_params);\n\n  for (auto &walker : walkers) {\n    auto &controller = _controllers[walker.first];\n    auto transform = walker.second.GetTransform();\n    auto speed = walker.second.GetVelocity();\n    controller.ApplyToWorld(transform, speed);\n  }\n\n  _navigation->SetAgentPositions(crowd_handle, agent_positions);\n  _navigation->SetAgentStates(crowd_handle, agent_states);\n  _navigation->SetAgentAnimations(crowd_handle, agent_animations);\n  _navigation->SetAgentAvoidanceParams(crowd_handle, agent_avoidance_params);\n\n  for (auto &walker : walkers) {\n    auto &controller = _controllers[walker.first", "CodeBleu_score": 47.39404630848031}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.set_uid(uid);\n  description.set_id(id);\n  description.mutable_attributes()->Reserve(attributes.size());\n  for (auto &attribute : attributes) {\n    rpc::Attribute *attribute_description = description.add_attributes();\n    attribute_description->set_key(attribute.first);\n    attribute_description->set_value(attribute.second);\n  }\n  return description;\n}", "CodeBleu_score": 56.9201248842777}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.set_uid(uid);\n  description.set_id(id);\n  description.mutable_attributes()->Reserve(attributes.size());\n  for (const auto &attribute : attributes) {\n    description.add_attributes()->CopyFrom(attribute);\n  }\n  return description;\n}", "CodeBleu_score": 66.92064834060776}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.set_id(GetId());\n  description.set_uid(GetUId());\n  for (auto &attribute : GetAttributes()) {\n    description.mutable_attributes()->insert({attribute.first, attribute.second});\n  }\n  return description;\n}", "CodeBleu_score": 56.85198187169704}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n  for (auto &blueprint : blueprints) {\n    if (blueprint->HasAttribute(name)) {\n      auto attribute = blueprint->GetAttribute(name);\n      if (attribute->HasValue(value)) {\n        result->Add(blueprint);\n      } else if (attribute->HasRecommendedValue(value)) {\n        result->Add(blueprint);\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 42.09273830415724}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n  SharedPtr<BlueprintLibrary> filtered_library = MakeShared<BlueprintLibrary>();\n\n  for (const auto& blueprint : blueprints) {\n    auto attribute = blueprint->GetAttribute(name);\n    if (attribute.has_value()) {\n      if (attribute.value().value == value ||\n          std::any_of(attribute.value().recommended_values.begin(),\n                      attribute.value().recommended_values.end(),\n                      [&value](const std::string& v) { return v == value; })) {\n        filtered_library->Add(blueprint);\n      }\n    }\n  }\n  return filtered_library;\n}", "CodeBleu_score": 45.16224243612439}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto &blueprint : blueprints) {\n    if (blueprint.second->HasAttribute(name)) {\n      if (blueprint.second->GetAttributeAsString(name) == value) {\n        result->Add(blueprint.second);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 32.566411032832676}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// construct the full file path\n\tstd::string full_path = path + \"/\" + carla::version::to_string() + \".bin\";\n\n\t// validate the file path\n\tif (full_path.empty() || full_path.find(\"..\") != std::string::npos) {\n\t\treturn false;\n\t}\n\n\t// open the file in binary mode to truncate its contents\n\tstd::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\t// write the content and close the file\n\t\tfile.write(reinterpret_cast<char *>(content.data()), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 44.74474235041414}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string filePath = FileTransfer::GetFilePath(path);\n\tif (FileTransfer::ValidateFilePath(filePath)) {\n\t\tstd::ofstream file(filePath, std::ios::binary | std::ios::trunc);\n\t\tif (file.is_open()) {\n\t\t\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\t\t\tfile.close();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.803925079252195}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\n\tstd::string full_path = path;\n\tfull_path.append(FILE_SEPARATOR);\n\tfull_path.append(FILE_NAME);\n\n\t// validate the file path\n\tif (!FileTransfer::ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\n\t// open the file in binary mode to truncate its contents\n\tstd::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\t// write the content to the file\n\tfile.write(reinterpret_cast<const char*>(content.data()), content.size());\n\n\t// close the file\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 47.301025956190486}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n  const auto location = transform.location + parent->GetBoundingBox().location;\n  const float yaw = transform.rotation.yaw;\n  const float cos_yaw = std::cos(yaw);\n  const float sin_yaw = std::sin(yaw);\n  const auto extent = parent->GetBoundingBox().extent;\n  const geom::Vector3D front_left(-extent.x * sin_yaw - extent.y * cos_yaw,\n                                  extent.x * cos_yaw - extent.y * sin_yaw,\n                                  extent.z);\n  const geom::Vector3D front_right(extent.x * cos_yaw - extent.y * sin_yaw,\n                                   extent.x * sin_yaw + extent.y * cos_yaw,\n                                   extent.z);\n  const geom::Vector3D rear_left(-extent.x * sin_yaw + extent.y * cos_yaw,\n                                 -extent.x * cos_yaw - extent.y * sin_yaw,\n                                 extent.z);\n  const geom::Vector3D rear_right(extent.x * cos_yaw + extent.y * sin_yaw,\n                                  -extent.x * sin_yaw + extent.y * cos_yaw,\n                                  extent.z);\n  return std::make_shared<const Bounds>(\n      frame,\n      geom::Location{location.x + front_left.x, location.y + front_left.y, location.z + front_left.z},\n      geom::Location{location.x + front_right.x, location.y + front_right.y, location.z + front_right.z},\n      geom::Location{location.x + rear_left.x, location.y + rear_left.y, location.z + rear_left.z},\n      geom::Location{location.x + rear_right.x, location.y + rear_right.y, location.z + rear_right.z});\n}", "CodeBleu_score": 43.97585102022696}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n  auto bounds = std::make_shared<const Bounds>();\n\n  bounds->frame = frame;\n\n  // Calculate location.\n  bounds->location = transform.location;\n\n  // Calculate corners.\n  const auto &extent = GetExtent();\n\n  // Calculate the four corners of the bounding box.\n  auto right_front = transform.rotation.Rotate(extent);\n  auto left_front = transform.rotation.Rotate(geom::Vector3D(-extent.x, extent.y, extent.z));\n  auto left_rear = transform.rotation.Rotate(geom::Vector3D(-extent.x, -extent.y, extent.z));\n  auto right_rear = transform.rotation.Rotate(geom::Vector3D(extent.x, -extent.y, extent.z));\n\n  // Calculate the corners in world space.\n  bounds->corners.reserve(4u);\n  bounds->corners.push_back(bounds->location + right_front);\n  bounds->corners.push_back(bounds->location + left_front);\n  bounds->corners.push_back(bounds->location + left_rear);\n  bounds->corners.push_back(bounds->location + right_rear);\n\n  return bounds;\n}", "CodeBleu_score": 43.541010515957254}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto location = transform.location + _parent->GetBoundingBox().location;\n  const auto yaw = transform.rotation.yaw * 0.01745329251994329576923690768489;\n  const auto half_width = _parent->GetBoundingBox().extent.x * 0.5f;\n  const auto half_length = _parent->GetBoundingBox().extent.y * 0.5f;\n  const auto half_height = _parent->GetBoundingBox().extent.z * 0.5f;\n  const auto right = geom::Location(\n      half_width * std::cos(yaw) - half_length * std::sin(yaw),\n      half_width * std::sin(yaw) + half_length * std::cos(yaw),\n      half_height);\n  const auto left = geom::Location(\n      -half_width * std::cos(yaw) - half_length * std::sin(yaw),\n      -half_width * std::sin(yaw) + half_length * std::cos(yaw),\n      half_height);\n  const auto front_left = geom::Location(\n      -half_width * std::cos(yaw) + half_length * std::sin(yaw),\n      -half_width * std::sin(yaw) - half_length * std::cos(yaw),\n      half_height);\n  const auto front_right = geom::Location(\n      half_width * std::cos(yaw) + half_length * std::sin(yaw),\n      half_width * std::sin(yaw) - half_length * std::cos(yaw),\n      half_height);\n  const auto rear_left = geom::Location(\n      -half_width * std::cos(yaw) - half_length * std::sin(yaw),\n      -half_width * std::sin(yaw) + half_length * std::cos(yaw),\n      -half_height);\n  const auto rear_right = geom::Location(\n      half_width *", "CodeBleu_score": 44.186957347983665}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> guard(_mutex);\n  auto lights_states = _simulator->QueryLightsState();\n  for (auto &light_state : lights_states) {\n    auto it = _lights.find(light_state.id);\n    if (it == _lights.end()) {\n      _lights[light_state.id] = std::make_unique<Light>(light_state);\n    } else {\n      it->second->SetLightState(light_state);\n    }\n  }\n}", "CodeBleu_score": 35.118751372198965}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    _lights = _simulator->QueryLightsState();\n}", "CodeBleu_score": 13.037380777973567}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\n  std::lock_guard<std::mutex> guard(_mutex);\n\n  auto lights_state = _pimpl->GetEpisode().Lock()->GetLightsState();\n\n  for (auto &light_state : lights_state) {\n\n    auto id = light_state.id;\n    auto state = light_state.state;\n\n    auto it = _lights.find(id);\n    if (it == _lights.end()) {\n      _lights.insert(std::make_pair(id, std::make_unique<Light>(id)));\n    }\n\n    _lights.at(id)->SetLightState(state);\n  }\n}", "CodeBleu_score": 38.45836494839454}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> guard(mutex);\n  if (dirty) {\n    if (discard_client) {\n      changes.clear();\n    }\n    auto lights = std::make_shared<rpc::LightsState>(changes);\n    client.AsyncCall(\"simulator.update_lights_state\", lights);\n    changes.clear();\n    dirty = false;\n  }\n}", "CodeBleu_score": 27.417703785613945}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> guard(mutex);\n  if (dirty) {\n    auto lights_message = std::make_shared<carla::rpc::LightStateList>();\n    for (auto &light : lights) {\n      lights_message->light_states.emplace_back(light.GetLightState());\n    }\n    detail::Simulator::GetCurrent().GetCurrentEpisode().Lock()->SetLightState(lights_message);\n    if (discard_client) {\n      for (auto &light : lights) {\n        light.SetLightState(light.GetLightState());\n      }\n    }\n    dirty = false;\n  }\n}", "CodeBleu_score": 38.19474309950884}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(mutex);\n  if (dirty) {\n    if (discard_client) {\n      // If the client has been disconnected, we need to discard the changes\n      // made by the client, and send the server the current state of the\n      // lights.\n      for (auto &light : lights) {\n        light.second.current_state = light.second.requested_state;\n      }\n    }\n    carla::rpc::LightStateList msg;\n    msg.light_states.reserve(lights.size());\n    for (auto &light : lights) {\n      msg.light_states.emplace_back(light.second.current_state);\n    }\n    detail::Simulator::GetCurrent().SetLightStates(msg);\n    dirty = false;\n  }\n}", "CodeBleu_score": 39.49051925304996}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  DEBUG_ASSERT(GetId() == \"sensor.other.v2x_custom\");\n  LOG_WARN(\"Sending message to episode\");\n  _episode.SendSensorData(GetId(), message);\n}", "CodeBleu_score": 42.05724847232135}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  log_debug(\"ServerSideSensor::Send\");\n  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"ServerSideSensor::Send: sensor ID does not match.\");\n    return;\n  }\n  auto episode = GetEpisode();\n  if (episode == nullptr) {\n    log_warning(\"ServerSideSensor::Send: episode is null.\");\n    return;\n  }\n  episode->SendMessage(GetId(), std::move(message));\n}", "CodeBleu_score": 51.56186474418754}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  log_debug(\"ServerSideSensor::Send()\");\n  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"ServerSideSensor::Send() - Sensor ID does not match\");\n    return;\n  }\n  auto episode = GetEpisode();\n  if (episode != nullptr) {\n    episode->SendSensorData(GetId(), message);\n  }\n}", "CodeBleu_score": 53.99162716340585}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  GetActor()->SetAutopilot(enabled, tm_port);\n}", "CodeBleu_score": 29.65205604126176}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  GetActor()->SetAutopilot(enabled, tm_port);\n}", "CodeBleu_score": 29.65205604126176}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  auto traffic_manager = GetWorld().GetTrafficManager();\n  if (enabled) {\n    traffic_manager.RegisterVehicle(GetActor(), tm_port);\n  } else {\n    traffic_manager.DeregisterVehicle(GetActor());\n  }\n}", "CodeBleu_score": 46.25866955392749}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t  _actor = GetEpisode().Lock()->FindActor(GetControlledId());\n  if (_actor == nullptr) {\n    UE_LOG(LogCarla, Error, TEXT(\"WalkerAIController: Actor not found\"));\n    return;\n  }\n\n  _navigation = GetEpisode().Lock()->GetNavigationSystem();\n  if (_navigation == nullptr) {\n    UE_LOG(LogCarla, Error, TEXT(\"WalkerAIController: Navigation system not found\"));\n    return;\n  }\n\n  _navigation->RegisterWalker(_actor, _actor->GetActorTransform());\n  _actor->SetSimulatePhysics(false);\n  _actor->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\n  _navigation->SetWalkerSpeed(_actor, _actor->GetVelocity().Size());\n}", "CodeBleu_score": 41.826357241291305}, {"code": "void WalkerAIController::Start(){\n\t  auto episode = GetEpisode();\n  auto actor = GetActor();\n  auto navigation = episode->GetNavigationSystem();\n  auto location = actor->GetLocation();\n  navigation->RegisterWalker(actor, location);\n  navigation->SetUpWalker(actor);\n  actor->DisableSimulation();\n  actor->SetCollisionEnabled(false);\n}", "CodeBleu_score": 41.92635304378564}, {"code": "void WalkerAIController::Start(){\n\t  auto episode = GetEpisode();\n  _actor = episode.FindActor(GetParentId());\n  if (_actor == nullptr) {\n    throw_exception(std::runtime_error(\"WalkerAIController: parent actor not found\"));\n  }\n\n  auto walker = _actor->GetWalker();\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"WalkerAIController: parent actor is not a walker\"));\n  }\n\n  _navigation = episode.Lock()->GetNavigationSystem();\n  _navigation->RegisterWalker(walker, walker->GetLocation());\n  _navigation->SetWalkerSpeed(walker, _speed);\n  _navigation->SetWalkerMaxAngle(walker, _max_angle);\n\n  _actor->SetSimulatePhysics(false);\n  _actor->SetCollisionEnabled(false);\n}", "CodeBleu_score": 44.237539494448974}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto *navigation = GetEpisode().Lock()->GetNavigation();\n  if (navigation != nullptr) {\n    auto walker = GetWalker();\n    if (walker != nullptr) {\n      if (!navigation->SetWalkerSpeed(*walker, max_speed)) {\n        log_warning(\"failed to set walker speed\");\n      }\n    } else {\n      log_warning(\"walker not found\");\n    }\n  } else {\n    log_warning(\"navigation not available\");\n  }\n}", "CodeBleu_score": 70.2719615064707}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto navigation = _episode->GetNavigation();\n  if (navigation != nullptr) {\n    auto walker = _episode->FindWalker(_actor->GetId());\n    if (walker != nullptr) {\n      if (!navigation->SetWalkerMaxSpeed(walker, max_speed)) {\n        UE_LOG(LogCarla, Warning, TEXT(\"Failed to set walker %d max speed\"), _actor->GetId());\n      }\n    } else {\n      UE_LOG(LogCarla, Warning, TEXT(\"Walker %d not found\"), _actor->GetId());\n    }\n  } else {\n    UE_LOG(LogCarla, Warning, TEXT(\"Navigation not found\"));\n  }\n}", "CodeBleu_score": 56.622991780347796}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto *navigation = GetEpisode().Lock()->GetNavigation();\n  if (navigation != nullptr) {\n    auto *walker = navigation->GetWalker(GetWalkerId());\n    if (walker != nullptr) {\n      if (!navigation->SetWalkerMaxSpeed(GetWalkerId(), max_speed)) {\n        log_warning(\n            \"failed to set the maximum speed of walker\",\n            GetWalkerId(),\n            \"to\",\n            max_speed);\n      }\n    } else {\n      log_warning(\"walker\", GetWalkerId(), \"not found\");\n    }\n  } else {\n    log_warning(\"navigation not available\");\n  }\n}", "CodeBleu_score": 63.330127498139866}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  std::vector<carla::road::element::Waypoint> waypoints = _map->GetPrevious(*this, distance);\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(std::make_shared<Waypoint>(waypoint));\n  }\n  return result;\n}", "CodeBleu_score": 59.21468002102115}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\n  std::vector<SharedPtr<Waypoint>> result;\n\n  std::vector<SharedPtr<Waypoint>> waypoints = GetMap().GetPreviousWaypoint(*this, distance);\n\n  for (auto waypoint : waypoints) {\n\n    result.push_back(MakeShared<Waypoint>(*waypoint));\n\n  }\n\n  return result;\n\n}", "CodeBleu_score": 50.113536389067406}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  std::vector<SharedPtr<Waypoint>> waypoints = _map->GetPrevious(this, distance);\n  for (SharedPtr<Waypoint> waypoint : waypoints) {\n    result.push_back(MakeShared<Waypoint>(*waypoint));\n  }\n  return result;\n}", "CodeBleu_score": 52.47342612975546}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::unordered_set<uint64_t> landmark_ids;\n\n  for (auto signal : GetSignalsInDistance(distance, stop_at_junction)) {\n    if (landmark_ids.find(signal.GetLandmarkId()) == landmark_ids.end()) {\n      landmark_ids.insert(signal.GetLandmarkId());\n      result.emplace_back(MakeShared<Landmark>(signal.GetLandmarkId(), signal.GetLocation(), signal.GetType()));\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 37.104845939397514}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\n    std::vector<SharedPtr<Landmark>> result;\n\n    // Get the signals within the distance\n    std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\n    // Avoid repeated signals\n    std::unordered_set<SharedPtr<Signal>> unique_signals;\n    for (auto signal : signals) {\n        unique_signals.insert(signal);\n    }\n\n    // Create a new waypoint for each signal\n    for (auto signal : unique_signals) {\n        result.push_back(MakeShared<Landmark>(signal->GetWaypoint(), signal));\n    }\n\n    return result;\n}", "CodeBleu_score": 42.35590038629153}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\n  std::vector<SharedPtr<Landmark>> result;\n\n  std::unordered_set<SharedPtr<Signal>> signals;\n  std::unordered_set<SharedPtr<Landmark>> landmarks;\n\n  // Get all the signals within the distance\n  auto signals_in_distance = GetSignalsInDistance(distance, stop_at_junction);\n\n  // Add all the signals to the signals set\n  for (auto signal : signals_in_distance) {\n    signals.insert(signal);\n  }\n\n  // Create a new waypoint and landmark for each signal\n  for (auto signal : signals) {\n    auto waypoint = MakeWaypoint(signal->GetTransform());\n    auto landmark = MakeLandmark(signal->GetId(), signal->GetType(), signal->GetLocation(), signal->GetOrientation(), signal->GetColor(), signal->GetState());\n    landmarks.insert(landmark);\n  }\n\n  // Add all the landmarks to the result\n  for (auto landmark : landmarks) {\n    result.push_back(landmark);\n  }\n\n  return result;\n}", "CodeBleu_score": 53.32492931464259}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  if (settings.synchronous_mode) {\n    log_warning(\n        \"Setting 'synchronous_mode' is not supported. Ignoring setting.\");\n  }\n  if (settings.no_rendering_mode) {\n    log_warning(\n        \"Setting 'no_rendering_mode' is not supported. Ignoring setting.\");\n  }\n  if (settings.substepping) {\n    log_warning(\n        \"Setting 'substepping' is not supported. Ignoring setting.\");\n  }\n  if (settings.max_substep_delta_time != 0.01) {\n    log_warning(\n        \"Setting 'max_substep_delta_time' is not supported. Ignoring setting.\");\n  }\n  if (settings.max_substeps != 10) {\n    log_warning(\n        \"Setting 'max_substeps' is not supported. Ignoring setting.\");\n  }\n  if (settings.max_culling_distance != 0) {\n    log_warning(\n        \"Setting 'max_culling_distance' is not supported. Ignoring setting.\");\n  }\n  if (settings.enable_tessellation) {\n    log_warning(\n        \"Setting 'enable_tessellation' is not supported. Ignoring setting.\");\n  }\n  if (settings.enable_dynamic_weather) {\n    log_warning(\n        \"Setting 'enable_dynamic_weather' is not supported. Ignoring setting.\");\n  }\n  if (settings.post_physics_tick_enabled) {\n    log_warning(\n        \"Setting 'post_physics_tick_enabled' is not supported. Ignoring setting.\");\n  }\n  if (settings.collision_damage_multiplier != 0) {\n    log_warning(\n        \"Setting 'collision_damage_multiplier' is not supported. Ignoring setting.\");\n  }\n  if (settings.max_agents_num != 0) {\n    log_warning(\n        \"Setting 'max_agents_num' is not supported. Ignoring setting.\");\n  }\n  if (settings.max_control_physics_fps != 0) {\n    log_", "CodeBleu_score": 17.232254168260244}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  return _pimpl->ApplySettings(settings, timeout);\n}", "CodeBleu_score": 9.855984628610415}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  DEBUG_ASSERT(_episode != nullptr);\n  return _episode->ApplySettings(settings, timeout);\n}", "CodeBleu_score": 11.581757667104045}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  (const geom::Location &point, const geom::Location &segment_start, const geom::Location &segment_end) {\n    const geom::Location segment_vector = segment_end - segment_start;\n    const float segment_length_squared = segment_vector.SquaredLength();\n    if (segment_length_squared == 0.0f) {\n      return {0.0f, (point - segment_start).Length()};\n    }\n    const float t = geom::Math::Clamp(\n        (point - segment_start).Dot(segment_vector) / segment_length_squared,\n        0.0f,\n        1.0f);\n    const geom::Location projection = segment_start + t * segment_vector;\n    return {(point - projection).Length(), (point - segment_start).Length()};\n  }\n}", "CodeBleu_score": 42.352523512016084}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  (const geom::Location &point, const geom::Location &segment_start, const geom::Location &segment_end) {\n    const geom::Location segment = segment_end - segment_start;\n    const float squared_length = segment.SquaredLength();\n    if (squared_length == 0.0f) {\n      return {0.0f, point.Distance(segment_start)};\n    }\n    const float t = geom::Math::Clamp(\n        (point - segment_start).Dot(segment) / squared_length,\n        0.0f,\n        1.0f);\n    const geom::Location projection = segment_start + segment * t;\n    return {projection.Distance(point), point.Distance(projection)};\n  }\n}", "CodeBleu_score": 43.828473829758686}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  (const geom::Location &point,\n   const geom::Location &segment_start,\n   const geom::Location &segment_end) {\n\n    geom::Location segment = segment_end - segment_start;\n    float squared_length = segment.x * segment.x + segment.y * segment.y;\n    float length = std::sqrt(squared_length);\n\n    if (length < 0.0000001f) {\n      return {0.0f, (point - segment_start).Length()};\n    }\n\n    float dot = (point.x - segment_start.x) * segment.x + (point.y - segment_start.y) * segment.y;\n    float t = dot / squared_length;\n    t = std::max(0.0f, std::min(1.0f, t));\n    geom::Location projection = segment_start + segment * t;\n    float distance_along = (point - projection).Length();\n    float distance_from = (point - projection).Length();\n\n    return {distance_along, distance_from};\n  }\n}", "CodeBleu_score": 40.127080166709554}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  if (vertices.size() < 3u) {\n    throw_exception(std::invalid_argument(\"at least three vertices required\"));\n  }\n  const auto index = _vertices.size();\n  for (auto i = 0u; i < vertices.size(); ++i) {\n    _vertices.push_back(vertices[i]);\n    _indices.push_back(index + 0u);\n    _indices.push_back(index + i + 1u);\n    _indices.push_back(index + i + 2u);\n  }\n}", "CodeBleu_score": 44.14020967944229}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  assert(vertices.size() >= 3u);\n  const auto initial_index = _vertices.size();\n  for (const auto &vertex : vertices) {\n    _vertices.push_back(vertex);\n  }\n  for (size_t i = 0u; i < vertices.size() - 2u; ++i) {\n    _indices.push_back(initial_index);\n    _indices.push_back(initial_index + i + 1u);\n    _indices.push_back(initial_index + i + 2u);\n  }\n}", "CodeBleu_score": 43.01887911093284}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  assert(vertices.size() >= 3u);\n  const std::size_t initial_index = vertices.front().index;\n  for (std::size_t i = 0u, count = vertices.size() - 2u; i < count; ++i) {\n    _indices.push_back(initial_index);\n    _indices.push_back(vertices[i + 1u].index);\n    _indices.push_back(vertices[i + 2u].index);\n  }\n}", "CodeBleu_score": 46.21522123132794}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\n  if (message->is_valid()) {\n\n    boost::asio::post(\n\n        _strand,\n\n        [this, message]() {\n\n          if (_socket.is_open()) {\n\n            _socket.async_write_some(\n\n                boost::asio::buffer(message->data(), message->size()),\n\n                boost::asio::bind_executor(\n\n                    _strand,\n\n                    [this, message](boost::system::error_code ec, std::size_t size) {\n\n                      if (ec) {\n\n                        LOG_ERROR(\"Primary::Write failed: \", ec.message());\n\n                        Close();\n\n                      } else {\n\n                        if (size != message->size()) {\n\n                          LOG_ERROR(\"Primary::Write failed: incomplete message\");\n\n                          Close();\n\n                        }\n\n                      }\n\n                    }));\n\n          }\n\n        });\n\n  } else {\n\n    LOG_ERROR(\"Primary::Write failed: invalid message\");\n\n  }\n\n}", "CodeBleu_score": 38.13126031946168}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message->GetType() != carla::streaming::detail::tcp::Message::Type::DATA) {\n    throw std::runtime_error(\"Primary::Write: invalid message type\");\n  }\n\n  boost::asio::post(strand_, [this, self = shared_from_this(), message]() {\n    if (!socket_.is_open()) {\n      return;\n    }\n\n    auto timeout = std::chrono::steady_clock::now() + 10s;\n\n    boost::asio::async_write(\n        socket_,\n        boost::asio::buffer(message->GetData(), message->GetSize()),\n        boost::asio::bind_executor(strand_, [this, self, message, timeout](auto &&ec, auto &&) {\n          if (ec) {\n            if (ec == boost::asio::error::operation_aborted) {\n              return;\n            }\n            if (ec == boost::asio::error::timed_out) {\n              LOG_ERROR(\"Primary::Write: timed out\");\n              return;\n            }\n            LOG_ERROR(\"Primary::Write: \" << ec.message());\n            return;\n          }\n\n          auto now = std::chrono::steady_clock::now();\n          if (now > timeout) {\n            LOG_ERROR(\"Primary::Write: timeout\");\n            return;\n          }\n\n          // LOG_INFO(\"Primary::Write: \" << message->GetSize() << \" bytes\");\n\n          // if (message->GetSize() == 0) {\n          //   return;\n          // }\n\n          // auto *data = message->GetData();\n          // auto size = message->GetSize();\n\n          // if (data[0] == 0x01) {\n          //   if (data[1] == 0x01) {\n          //     std::cout << \"Primary::Write: 0x0101\" << std::endl;\n          //   }\n          // }\n        }));\n  });\n}", "CodeBleu_score": 42.358322933472834}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message->size() > carla::streaming::detail::tcp::MAX_MESSAGE_SIZE) {\n    log_error(\"Primary\", \"message too large (\", message->size(), \" > \", carla::streaming::detail::tcp::MAX_MESSAGE_SIZE, \")\");\n    return;\n  }\n  if (message->size() < carla::streaming::detail::tcp::MIN_MESSAGE_SIZE) {\n    log_error(\"Primary\", \"message too small (\", message->size(), \" < \", carla::streaming::detail::tcp::MIN_MESSAGE_SIZE, \")\");\n    return;\n  }\n  boost::asio::post(strand, [this, message]() {\n    if (socket.is_open()) {\n      boost::asio::async_write(\n          socket,\n          boost::asio::buffer(message->data(), message->size()),\n          boost::asio::bind_executor(\n              strand,\n              [this, message](boost::system::error_code ec, std::size_t) {\n                if (ec) {\n                  log_error(\"Primary\", \"error sending message: \", ec.message());\n                  Close();\n                }\n              }));\n    }\n  });\n}", "CodeBleu_score": 40.0639055441232}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\n  // Cancel the deadline timer.\n  _deadline.cancel();\n\n  // If the socket is open and we didn't get an error code, attempt to\n  // perform a shutdown and close the socket.\n  if (!ec && _socket.is_open()) {\n    _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    _socket.close(ec);\n  }\n\n  // Trigger the on_closed callback.\n  if (_on_closed) {\n    _on_closed();\n  }\n\n  // Log the session closed.\n  if (ec) {\n    log_warning(\"session closed: \", ec.message());\n  } else {\n    log_info(\"session closed\");\n  }\n}", "CodeBleu_score": 59.52183202622459}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if (ec) {\n    return;\n  }\n\n  if (socket_.is_open()) {\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    socket_.close(ec);\n  }\n\n  on_closed(ec);\n\n  if (ec) {\n    log_warning(\n        \"Primary::CloseNow\",\n        \"error closing session: \",\n        ec.message());\n  } else {\n    log_debug(\"Primary::CloseNow\", \"session closed\");\n  }\n}", "CodeBleu_score": 45.89115651284506}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\n  if (!ec) {\n\n    // Cancel the deadline timer.\n\n    deadline_.cancel();\n\n    // If the socket is open, shut it down.\n\n    if (socket_.is_open()) {\n\n      boost::system::error_code ignored_ec;\n\n      socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\n    }\n\n    // Trigger the on_closed callback.\n\n    on_closed_();\n\n    // Log that the session has been closed.\n\n    CARLA_LOG_INFO(\"session closed\");\n\n  }\n\n}", "CodeBleu_score": 56.90050596065248}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t    carla::streaming::detail::tcp::Message msg;\n    msg.type = carla::streaming::detail::tcp::Message::Type::YOU_ALIVE;\n    msg.length = 0;\n    std::vector<char> buffer(carla::streaming::detail::tcp::Message::HEADER_SIZE + msg.length);\n    carla::streaming::detail::tcp::Message::WriteHeader(buffer.data(), msg);\n    std::cout << \"Sending a message to the next router: Are you alive?\" << std::endl;\n    router.write(buffer.data(), buffer.size());\n    std::cout << \"Waiting for a response from the next router...\" << std::endl;\n    std::vector<char> response(carla::streaming::detail::tcp::Message::HEADER_SIZE);\n    router.read(response.data(), response.size());\n    carla::streaming::detail::tcp::Message msg2;\n    carla::streaming::detail::tcp::Message::ReadHeader(response.data(), msg2);\n    std::cout << \"Received a response from the next router: \" << msg2.type << std::endl;\n}", "CodeBleu_score": 41.03566359725237}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  std::vector<char> buffer;\n  carla::streaming::detail::tcp::Message::Serialize(\n      buffer,\n      carla::streaming::detail::tcp::Message::Type::YOU_ALIVE,\n      carla::streaming::detail::tcp::Message::Type::YOU_ALIVE,\n      carla::streaming::detail::tcp::Message::Type::YOU_ALIVE);\n  LOG_INFO(\"Sending Is Alive Message\");\n  Router::Write(buffer);\n  LOG_INFO(\"Waiting for Is Alive Response\");\n  Router::WaitForMessage(carla::streaming::detail::tcp::Message::Type::YOU_ALIVE);\n}", "CodeBleu_score": 29.005397708035797}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::vector<char> buffer(sizeof(carla::streaming::detail::tcp::Message));\n\tcarla::streaming::detail::tcp::Message *message = reinterpret_cast<carla::streaming::detail::tcp::Message*>(buffer.data());\n\tmessage->type = carla::streaming::detail::tcp::Message::Type::YOU_ALIVE;\n\tmessage->size = sizeof(carla::streaming::detail::tcp::Message);\n\tmessage->id = 0;\n\tmessage->token = carla::streaming::detail::Token{};\n\tmessage->timestamp = 0;\n\tmessage->payload_size = 0;\n\tmessage->payload_offset = 0;\n\tstd::cout << \"Sending message: Are you alive?\n\";\n\tPrimary::SendToNext(buffer, carla::multigpu::Command::YOU_ALIVE);\n\tstd::vector<char> response = Primary::ReceiveFromNext();\n\tcarla::streaming::detail::tcp::Message *response_message = reinterpret_cast<carla::streaming::detail::tcp::Message*>(response.data());\n\tif (response_message->type == carla::streaming::detail::tcp::Message::Type::I_AM_ALIVE) {\n\t\tstd::cout << \"Received message: I am alive!\n\";\n\t} else {\n\t\tstd::cout << \"Received message: I am dead!\n\";\n\t}\n}", "CodeBleu_score": 40.57837913441211}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\n  // Check if the sensor is active on any secondary server\n  bool found = false;\n  for (auto& secondary : _secondaries) {\n    if (secondary.IsActive(sensor_id)) {\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n    LOG_ERROR(\"PrimaryCommands::SendEnableForROS: Sensor ID not found on any secondary server\");\n    return;\n  }\n\n  // Create a buffer with the sensor ID\n  std::vector<uint8_t> buffer;\n  buffer.resize(sizeof(stream_id));\n  memcpy(buffer.data(), &sensor_id, sizeof(stream_id));\n\n  // Send an ENABLE_ROS command to the router\n  _router.Send(Primary::Command::ENABLE_ROS, buffer);\n\n  // Wait for and process the server's response\n  auto response = _router.Receive();\n  if (response.command == Primary::Command::ENABLE_ROS) {\n    LOG_INFO(\"PrimaryCommands::SendEnableForROS: Sensor ID found on a secondary server\");\n  } else {\n    LOG_ERROR(\"PrimaryCommands::SendEnableForROS: Unexpected response from the router\");\n  }\n}", "CodeBleu_score": 47.4478535759893}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\n  bool found = false;\n\n  for (auto& secondary : Secondary::instances) {\n\n    if (secondary.IsSensorEnabled(sensor_id)) {\n\n      found = true;\n\n      std::vector<uint8_t> buffer;\n\n      buffer.push_back(static_cast<uint8_t>(Command::ENABLE_ROS));\n\n      buffer.push_back(static_cast<uint8_t>(sensor_id >> 8));\n      buffer.push_back(static_cast<uint8_t>(sensor_id & 0xFF));\n\n      Router::instance.Send(secondary.GetId(), buffer);\n\n      auto response = Router::instance.Receive(secondary.GetId());\n\n      if (response.size() != 1) {\n\n        std::cerr << \"Invalid response size for ENABLE_ROS command\" << std::endl;\n\n      } else {\n\n        if (response[0] != static_cast<uint8_t>(Response::SUCCESS)) {\n\n          std::cerr << \"ENABLE_ROS command failed\" << std::endl;\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (!found) {\n\n    std::cerr << \"Sensor \" << sensor_id << \" not found\" << std::endl;\n\n  }\n\n}", "CodeBleu_score": 43.44152616282963}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  // Check if the sensor is already enabled.\n  if (enabled_sensors.find(sensor_id) != enabled_sensors.end()) {\n    return;\n  }\n\n  // Check if the sensor is on any secondary server.\n  auto it = std::find_if(\n      secondary_servers.begin(), secondary_servers.end(),\n      [sensor_id](const auto &server) {\n        return server.second.sensors.find(sensor_id) != server.second.sensors.end();\n      });\n\n  if (it == secondary_servers.end()) {\n    LOG_ERROR(\"PrimaryCommands::SendEnableForROS: sensor not found\");\n    return;\n  }\n\n  // Create a buffer with the sensor ID.\n  std::vector<uint8_t> buffer(sizeof(stream_id));\n  std::memcpy(buffer.data(), &sensor_id, sizeof(stream_id));\n\n  // Send an ENABLE_ROS command to the server using the router.\n  auto response = router.SendCommand(it->first, Command::ENABLE_ROS, buffer);\n\n  // Wait for and process the server's response.\n  if (response.has_value()) {\n    auto &response_buffer = response.value();\n    if (response_buffer.size() == 0) {\n      enabled_sensors.insert(sensor_id);\n    } else {\n      LOG_ERROR(\"PrimaryCommands::SendEnableForROS: unexpected response\");\n    }\n  } else {\n    LOG_ERROR(\"PrimaryCommands::SendEnableForROS: timeout\");\n  }\n}", "CodeBleu_score": 46.74014096500645}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  std::lock_guard<std::mutex> lock(mutex);\n  if (sensor_id == 0) {\n    return 0;\n  }\n  if (sensor_id > max_sensor_id) {\n    std::cerr << \"PrimaryCommands::GetToken: sensor_id \" << sensor_id << \" is out of range.\" << std::endl;\n    return 0;\n  }\n  if (sensor_id == max_sensor_id) {\n    return 0;\n  }\n  if (sensor_id == 1) {\n    return 0;\n  }\n  if (sensor_id == 2) {\n    return 0;\n  }\n  if (sensor_id == 3) {\n    return 0;\n  }\n  if (sensor_id == 4) {\n    return 0;\n  }\n  if (sensor_id == 5) {\n    return 0;\n  }\n  if (sensor_id == 6) {\n    return 0;\n  }\n  if (sensor_id == 7) {\n    return 0;\n  }\n  if (sensor_id == 8) {\n    return 0;\n  }\n  if (sensor_id == 9) {\n    return 0;\n  }\n  if (sensor_id == 10) {\n    return 0;\n  }\n  if (sensor_id == 11) {\n    return 0;\n  }\n  if (sensor_id == 12) {\n    return 0;\n  }\n  if (sensor_id == 13) {\n    return 0;\n  }\n  if (sensor_id == 14) {\n    return 0;\n  }\n  if (sensor_id == 15) {\n    return 0;\n  }\n  if (sensor_id == 16) {\n    return 0;\n  }\n  if (sensor_id == 17) {\n    return 0;\n  }\n  if (", "CodeBleu_score": 15.549129715746346}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\n  // Check if the sensor is already activated\n  auto it = active_sensors_.find(sensor_id);\n  if (it != active_sensors_.end()) {\n    // Sensor is already activated\n    LOG_DEBUG(\"Sensor \" << sensor_id << \" is already activated\");\n    return it->second;\n  }\n\n  // Sensor is not activated\n  LOG_DEBUG(\"Sensor \" << sensor_id << \" is not activated\");\n\n  // Enable sensor on secondary server\n  auto secondary_id = router_.GetSecondaryId(sensor_id);\n  LOG_DEBUG(\"Enabling sensor \" << sensor_id << \" on secondary \" << secondary_id);\n  auto token = router_.EnableSensor(secondary_id, sensor_id);\n\n  // Update maps\n  active_sensors_[sensor_id] = token;\n  active_secondaries_[secondary_id].insert(sensor_id);\n\n  // Log action\n  LOG_DEBUG(\"Sensor \" << sensor_id << \" activated\");\n\n  // Return token\n  return token;\n}", "CodeBleu_score": 50.92368154532259}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t    // Check if sensor is already activated\n    if (is_activated(sensor_id)) {\n        // If it is, return the existing token\n        std::cout << \"Sensor \" << sensor_id << \" is already activated, returning existing token\" << std::endl;\n        return token_map[sensor_id];\n    }\n    // If it is not, enable the sensor on a secondary server\n    std::cout << \"Sensor \" << sensor_id << \" is not activated, activating it\" << std::endl;\n    // Create a new token\n    auto token = Token::Create();\n    // Create a new stream_id\n    auto stream_id = StreamID::Create();\n    // Send the token and stream_id to the secondary server\n    auto command = std::make_shared<Primary::Command>(Primary::Command::Type::Activate, sensor_id, token, stream_id);\n    // Send the command to the router\n    router->Send(command);\n    // Wait for the response\n    auto response = router->Receive();\n    // Check if the response is valid\n    if (response->type != Primary::Response::Type::Activated) {\n        // If it is not, throw an exception\n        throw std::runtime_error(\"Invalid response\");\n    }\n    // If it is, retrieve the token and stream_id\n    auto token_response = std::static_pointer_cast<Primary::Response::Activated>(response);\n    // Update the maps\n    token_map[sensor_id] = token_response->token;\n    stream_map[sensor_id] = token_response->stream_id;\n    // Log the action\n    std::cout << \"Sensor \" << sensor_id << \" activated with token \" << token_response->token << \" and stream_id \" << token_response->stream_id << std::endl;\n    // Return the token\n    return token_response->token;\n}", "CodeBleu_score": 42.32262592990848}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\n  std::ifstream file(filename, std::ios::binary);\n\n  if (!file) {\n    return false;\n  }\n\n  std::vector<char> data;\n  file.seekg(0, std::ios::end);\n  data.resize(file.tellg());\n  file.seekg(0, std::ios::beg);\n  file.read(data.data(), data.size());\n\n  file.close();\n\n  return Load(data);\n}", "CodeBleu_score": 53.71930756216183}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  file.seekg(0, std::ios::end);\n  std::streampos length = file.tellg();\n  file.seekg(0, std::ios::beg);\n  std::vector<char> data(length);\n  file.read(data.data(), length);\n  file.close();\n  return Load(data);\n}", "CodeBleu_score": 55.96477424290165}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream input(filename, std::ios::binary);\n  if (!input.is_open()) {\n    return false;\n  }\n  std::vector<char> data((std::istreambuf_iterator<char>(input)), std::istreambuf_iterator<char>());\n  input.close();\n  return Load(data);\n}", "CodeBleu_score": 57.91810298587683}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (!IsReady()) {\n    return false;\n  }\n  assert(_crowd != nullptr);\n  std::lock_guard<std::mutex> lock(_mutex);\n  auto it = _walker_map.find(id);\n  if (it != _walker_map.end()) {\n    _walker_manager->RemoveWalker(it->second);\n    _crowd->removeAgent(it->second);\n    _walker_map.erase(it);\n    return true;\n  }\n  it = _vehicle_map.find(id);\n  if (it != _vehicle_map.end()) {\n    _vehicle_manager->RemoveVehicle(it->second);\n    _crowd->removeAgent(it->second);\n    _vehicle_map.erase(it);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 65.90078204770433}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (!IsReady()) {\n    return false;\n  }\n\n  if (id == 0) {\n    return false;\n  }\n\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  auto walker_it = _walker_mapping.find(id);\n  auto vehicle_it = _vehicle_mapping.find(id);\n\n  if (walker_it == _walker_mapping.end() && vehicle_it == _vehicle_mapping.end()) {\n    return false;\n  }\n\n  if (walker_it != _walker_mapping.end()) {\n    _crowd->removeAgent(_walker_mapping[id]);\n    _walker_manager->RemoveWalker(walker_it->second);\n    _walker_mapping.erase(walker_it);\n  }\n  else if (vehicle_it != _vehicle_mapping.end()) {\n    _crowd->removeAgent(_vehicle_mapping[id]);\n    _vehicle_manager->RemoveVehicle(vehicle_it->second);\n    _vehicle_mapping.erase(vehicle_it);\n  }\n\n  return true;\n}", "CodeBleu_score": 56.503218759771954}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (!IsReady()) {\n    return false;\n  }\n  assert(_crowd != nullptr);\n  auto walker_it = _walker_to_agent.find(id);\n  auto vehicle_it = _vehicle_to_agent.find(id);\n  if (walker_it == _walker_to_agent.end() && vehicle_it == _vehicle_to_agent.end()) {\n    return false;\n  }\n  auto id_to_remove = (walker_it != _walker_to_agent.end()) ? walker_it->first : vehicle_it->first;\n  {\n    std::lock_guard<std::mutex> lock(_crowd_mutex);\n    if (walker_it != _walker_to_agent.end()) {\n      _walker_manager->RemoveWalker(id_to_remove);\n    } else {\n      _vehicle_manager->RemoveVehicle(id_to_remove);\n    }\n    dtCrowdAgent *agent = _crowd->getEditableAgent(id_to_remove);\n    if (agent != nullptr) {\n      _crowd->removeAgent(id_to_remove);\n    }\n  }\n  if (walker_it != _walker_to_agent.end()) {\n    _walker_to_agent.erase(walker_it);\n  } else {\n    _vehicle_to_agent.erase(vehicle_it);\n  }\n  return true;\n}", "CodeBleu_score": 55.74516074617517}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n\tstd::lock_guard<std::mutex> lock(vehicle_mutex_);\n\n\tstd::unordered_set<uint32_t> current_vehicle_ids;\n\n\tfor (const auto &vehicle : vehicle_map_) {\n\t\tcurrent_vehicle_ids.insert(vehicle.first);\n\t}\n\n\tfor (const auto &vehicle : vehicles) {\n\t\tcurrent_vehicle_ids.erase(vehicle.id);\n\n\t\tif (vehicle_map_.count(vehicle.id) == 0) {\n\t\t\tvehicle_map_.insert(std::make_pair(vehicle.id, VehicleState(vehicle)));\n\t\t} else {\n\t\t\tvehicle_map_[vehicle.id].Update(vehicle);\n\t\t}\n\t}\n\n\tfor (const auto &id : current_vehicle_ids) {\n\t\tvehicle_map_.erase(id);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 52.12546248899367}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    std::lock_guard<std::mutex> lock(vehicle_mutex);\n    std::set<uint64_t> current_vehicles;\n    for (auto& vehicle : vehicle_collision_infos) {\n        current_vehicles.insert(vehicle.first);\n    }\n    for (auto& vehicle : vehicles) {\n        auto it = vehicle_collision_infos.find(vehicle.id);\n        if (it != vehicle_collision_infos.end()) {\n            it->second = vehicle;\n            it->second.updated = true;\n        } else {\n            vehicle_collision_infos.insert(std::make_pair(vehicle.id, vehicle));\n        }\n        current_vehicles.erase(vehicle.id);\n    }\n    for (auto& id : current_vehicles) {\n        auto it = vehicle_collision_infos.find(id);\n        if (it != vehicle_collision_infos.end()) {\n            it->second.updated = false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 50.67528985963581}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n\tstd::set<int> vehicle_ids;\n\n\tfor (auto &v : vehicles) {\n\t\tvehicle_ids.insert(v.id);\n\t}\n\n\tstd::set<int> updated_vehicles;\n\n\tfor (auto &v : vehicles) {\n\t\tif (vehicle_map.count(v.id) == 0) {\n\t\t\tvehicle_map[v.id] = v;\n\t\t} else {\n\t\t\tvehicle_map[v.id] = v;\n\t\t\tupdated_vehicles.insert(v.id);\n\t\t}\n\t}\n\n\tfor (auto &v : vehicle_map) {\n\t\tif (updated_vehicles.count(v.first) == 0) {\n\t\t\tvehicle_map.erase(v.first);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 48.90635539707839}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  auto walker = _walker_manager.GetWalker(id);\n  if (walker == nullptr) {\n    return false;\n  }\n\n  // Compute the squared distance\n  const float squared_distance = carla::geom::Math::DistanceSquared(walker->GetLocation(), direction);\n  if (squared_distance > distance * distance) {\n    return false;\n  }\n\n  std::lock_guard<std::mutex> lock(_crowd_mutex);\n\n  const auto &crowd = _crowd_manager.GetCrowd();\n  if (crowd == nullptr) {\n    return false;\n  }\n\n  const auto &vehicle_crowd = _crowd_manager.GetVehicleCrowd();\n  if (vehicle_crowd == nullptr) {\n    return false;\n  }\n\n  // Check if there is a vehicle near the actor\n  const auto &vehicle = vehicle_crowd->getAgent(walker->GetAgentId());\n  if (vehicle == nullptr) {\n    return false;\n  }\n\n  return crowd->isAgentInCylinder(vehicle->id, walker->GetLocation().x, walker->GetLocation().y, distance);\n}", "CodeBleu_score": 50.1094742072978}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  auto it = walkers_.find(id);\n  if (it == walkers_.end()) {\n    it = vehicles_.find(id);\n    if (it == vehicles_.end()) {\n      return false;\n    }\n  }\n\n  const auto &location = it->second.GetLocation();\n  const auto squared_distance = carla::geom::Math::DistanceSquared(location, direction);\n\n  if (squared_distance < distance * distance) {\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 62.58971339389131}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  if (!_walker_manager->IsWalker(id)) {\n    return false;\n  }\n  WalkerId walker_id = _walker_manager->GetWalkerId(id);\n  if (walker_id == 0) {\n    return false;\n  }\n  const Walker &walker = _walker_manager->GetWalker(walker_id);\n  if (walker.is_walking) {\n    return false;\n  }\n  std::lock_guard<std::mutex> lock(_mutex);\n  float squared_distance = carla::geom::Math::SquaredDistance(walker.location, direction);\n  if (squared_distance > distance * distance) {\n    return false;\n  }\n  return _crowd_manager->HasVehicleNear(walker.location, distance);\n}", "CodeBleu_score": 47.24966353953928}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\n    WalkerEventVisitor visitor(*this, info, delta);\n\n    return boost::variant2::visit(visitor, info.route.front());\n}", "CodeBleu_score": 43.556962259275465}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\n  auto event = info.events.front();\n  info.events.pop_front();\n\n  WalkerEventVisitor visitor(info, delta);\n  return boost::variant2::visit(visitor, event);\n}", "CodeBleu_score": 45.07308906589938}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  auto route_point = info.GetCurrentRoutePoint();\n  WalkerEventVisitor visitor{*this, info, delta};\n  return boost::variant2::visit(visitor, route_point->event);\n}", "CodeBleu_score": 52.756800140288696}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"road\")) {\n    auto road_id = road_node.attribute(\"id\").as_int();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\")) {\n      auto lane_section_id = lane_section_node.attribute(\"s\").as_double();\n      for (pugi::xml_node lane_node : lane_section_node.children()) {\n        auto lane_id = lane_node.attribute(\"id\").as_int();\n        auto lane_type = lane_node.attribute(\"type\").as_string();\n        auto lane_width = lane_node.attribute(\"width\").as_double();\n        auto lane_speed = lane_node.attribute(\"speed\").as_double();\n        auto lane_access = lane_node.attribute(\"access\").as_string();\n        auto lane_height = lane_node.attribute(\"height\").as_double();\n        auto lane_rule = lane_node.attribute(\"rule\").as_string();\n        auto lane_link = lane_node.attribute(\"link\").as_string();\n\n        ParseLanes(lane_node, road_id, lane_section_id, lane_id, lane_type, lane_width, lane_speed, lane_access, lane_height, lane_rule, lane_link, map_builder);\n      }\n    }\n  }\n}", "CodeBleu_score": 51.91351394380027}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  for (pugi::xml_node road = xml.child(\"openDRIVE\").child(\"road\"); road; road = road.next_sibling(\"road\")) {\n    std::string road_id = road.attribute(\"id\").value();\n\n    for (pugi::xml_node lane_section = road.child(\"lanes\").child(\"laneSection\"); lane_section; lane_section = lane_section.next_sibling(\"laneSection\")) {\n      double s = lane_section.attribute(\"s\").as_double();\n\n      ParseLanes(lane_section, map_builder, road_id, s);\n    }\n  }\n}", "CodeBleu_score": 36.34892062932258}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  // Retrieve the road node\n  pugi::xml_node road = xml.child(\"openDRIVE\").child(\"road\");\n\n  // Retrieve the lanes node\n  pugi::xml_node lanes = road.child(\"lanes\");\n\n  // Retrieve the lane section node\n  pugi::xml_node lane_section = lanes.child(\"laneSection\");\n\n  // Retrieve the road ID\n  std::string road_id = road.attribute(\"id\").as_string();\n\n  // Iterate through each lane section\n  for (; lane_section; lane_section = lane_section.next_sibling(\"laneSection\")) {\n\n    // Retrieve the lane section s attribute\n    double s = lane_section.attribute(\"s\").as_double();\n\n    // Retrieve the left lane node\n    pugi::xml_node left_lane = lane_section.child(\"left\");\n\n    // Retrieve the center lane node\n    pugi::xml_node center_lane = lane_section.child(\"center\");\n\n    // Retrieve the right lane node\n    pugi::xml_node right_lane = lane_section.child(\"right\");\n\n    // Parse the left, center, and right lanes\n    ParseLanes(road_id, s, left_lane, center_lane, right_lane, map_builder);\n  }\n}", "CodeBleu_score": 47.82899233829607}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\n    if (info.current_count_change == 1) {\n        std::cout << \"CarlaListenerImpl::on_publication_matched(): a new publisher matched\" << std::endl;\n        this->matched = info.total_count;\n        this->firstConnection = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"CarlaListenerImpl::on_publication_matched(): a publisher stopped matching\" << std::endl;\n        this->matched = info.total_count;\n    } else {\n        std::cout << \"CarlaListenerImpl::on_publication_matched(): invalid count change\" << std::endl;\n    }\n}", "CodeBleu_score": 60.0184554977911}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    std::cout << \"New publication matched\" << std::endl;\n  } else if (info.current_count_change == -1) {\n    std::cout << \"Publication match lost\" << std::endl;\n  } else {\n    std::cout << \"Invalid publication matched count change: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 56.260011871235115}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        std::cout << \"CarlaListenerImpl::on_publication_matched() - \" << info.current_count << \" \" << info.total_count << std::endl;\n        matched_ = info.current_count;\n        first_connected_ = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"CarlaListenerImpl::on_publication_matched() - \" << info.current_count << \" \" << info.total_count << std::endl;\n        matched_ = info.current_count;\n    } else {\n        std::cout << \"CarlaListenerImpl::on_publication_matched() - \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 64.2855636502549}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if(info.current_count_change == 1) {\n        std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: New subscription matched\" << std::endl;\n        matched_count++;\n        first_connected = true;\n    } else if(info.current_count_change == -1) {\n        std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: Subscription unmatched\" << std::endl;\n        matched_count--;\n        if(matched_count == 0) {\n            std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: No subscribers, destroying subscriber\" << std::endl;\n            subscriber->destroy_datareader(reader);\n        }\n    } else {\n        std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: Invalid count change\" << std::endl;\n    }\n}", "CodeBleu_score": 43.69423302575931}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    std::cout << \"on_subscription_matched\" << std::endl;\n    if (info.current_count_change == 1) {\n        std::cout << \"on_subscription_matched: new match\" << std::endl;\n        matched_count++;\n        first_connected = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"on_subscription_matched: unmatch\" << std::endl;\n        matched_count--;\n        if (matched_count == 0) {\n            std::cout << \"on_subscription_matched: destroying subscriber\" << std::endl;\n            delete this;\n        }\n    } else {\n        std::cout << \"on_subscription_matched: invalid count change\" << std::endl;\n    }\n}", "CodeBleu_score": 49.68793076517841}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched\" << std::endl;\n        first_connected = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched\" << std::endl;\n        if (info.total_count == 0) {\n            delete this;\n        }\n    } else {\n        std::cout << \"Subscriber matched error\" << std::endl;\n    }\n}", "CodeBleu_score": 57.86167080927479}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\n    if ( !isKeyDefined() ) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n\n    if ( force_md5 || !isKeyComputable() ) {\n        // Compute MD5 hash of serialized data\n        eprosima::fastcdr::FastBuffer buffer;\n        eprosima::fastcdr::Cdr ser(buffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n        p_type->serializeKey(ser);\n        ser.finalize();\n        handle->value[0] = buffer.buffer()[0];\n        handle->value[1] = buffer.buffer()[1];\n        handle->value[2] = buffer.buffer()[2];\n        handle->value[3] = buffer.buffer()[3];\n        handle->value[4] = buffer.buffer()[4];\n        handle->value[5] = buffer.buffer()[5];\n        handle->value[6] = buffer.buffer()[6];\n        handle->value[7] = buffer.buffer()[7];\n        handle->value[8] = buffer.buffer()[8];\n        handle->value[9] = buffer.buffer()[9];\n        handle->value[10] = buffer.buffer()[10];\n        handle->value[11] = buffer.buffer()[11];\n        return true;\n    }\n    else {\n        // Directly copy key\n        memcpy(handle->value, p_type->getKey().value, 12);\n        return true;\n    }\n}", "CodeBleu_score": 41.15098804668402}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer), CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n\n    // If the force_md5 flag is set, compute the MD5 hash, otherwise copy the key directly.\n    if (force_md5) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 79.51913666242062}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*) data;\n\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer), CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < CarlaCollisionEvent::getKeyMaxCdrSerializedSize(); ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 91.69449804119873}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\n    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\n    // Serialize encapsulation.\n    ser.serialize_encapsulation();\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 82.78544320143973}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 98.7824316315562}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    std::size_t payloadSize = static_cast<std::size_t>(payload->max_size);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payloadSize);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    try {\n        ser.serialize_encapsulation();\n        ser.serialize(p_type->control);\n    } catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 81.15710548066129}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\n\t// Check if the target has been set\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// Decode the MAVLink message\n\tmavlink_msg_command_long_decode(&msg, &command_long);\n\n\t// Check if the message type is one that should be tracked\n\tif (command_long.command != MAV_CMD_DO_SET_ROI_LOCATION && command_long.command != MAV_CMD_DO_SET_ROI_WPNEXT_OFFSET && command_long.command != MAV_CMD_DO_SET_ROI_NONE) {\n\t\treturn;\n\t}\n\n\t// Check if the target system ID is set\n\tif (command_long.target_system == 0) {\n\t\t// Set the target system ID\n\t\ttarget_sysid = command_long.target_system;\n\n\t\t// Request position and air pressure data streams from the target\n\t\tmavlink_msg_request_data_stream_pack(GCS_MAVLINK_Tracker::sysid, GCS_MAVLINK_Tracker::compid, &msg, target_sysid, target_compid, MAV_DATA_STREAM_POSITION, 1);\n\t\tmavlink_msg_request_data_stream_pack(GCS_MAVLINK_Tracker::sysid, GCS_MAVLINK_Tracker::compid, &msg, target_sysid, target_compid, MAV_DATA_STREAM_PRESSURE, 1);\n\n\t\t// Flag that the target has been set\n\t\ttarget_set = true;\n\t}\n}", "CodeBleu_score": 39.74588604173008}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\n\t// If the target has already been set, exit immediately.\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// Decode the message.\n\tmavlink_msg_to_gcs_tracker_t(msg, &mavlink_message);\n\n\t// If the message type is not one that should be tracked, exit.\n\tif (mavlink_message.type != MAV_TYPE_FIXED_WING) {\n\t\treturn;\n\t}\n\n\t// If the target system ID is not set, set it and request position and air pressure data streams from the target.\n\tif (mavlink_message.target_sysid == 0) {\n\t\tmavlink_message.target_sysid = msg.sysid;\n\t\tmavlink_send_message(MAVLINK_MSG_ID_GLOBAL_POSITION_INT, msg.sysid, msg.compid, &mavlink_message);\n\t\tmavlink_send_message(MAVLINK_MSG_ID_AIR_PRESSURE, msg.sysid, msg.compid, &mavlink_message);\n\t}\n\n\t// Flag that the target has been set.\n\ttarget_set = true;\n}", "CodeBleu_score": 41.71958912041068}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tmavlink_message_t mavlink_msg;\n\tmavlink_msg_command_long_pack(GCS_MAVLINK::sysid, GCS_MAVLINK::compid, &mavlink_msg, msg.sysid, msg.compid, msg.sysid, msg.compid, MAV_CMD_REQUEST_DATA_STREAM, 1, 1, 0, 0, 0, 0, 0);\n\tGCS_MAVLINK::send_message(mavlink_msg);\n\tmavlink_msg_command_long_pack(GCS_MAVLINK::sysid, GCS_MAVLINK::compid, &mavlink_msg, msg.sysid, msg.compid, msg.sysid, msg.compid, MAV_CMD_REQUEST_DATA_STREAM, 1, 2, 0, 0, 0, 0, 0);\n\tGCS_MAVLINK::send_message(mavlink_msg);\n\n\tif (target_sysid == 0) {\n\t\ttarget_sysid = msg.sysid;\n\t\ttarget_compid = msg.compid;\n\t\ttarget_set = true;\n\t}\n}", "CodeBleu_score": 34.88575921642354}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _baro_cal_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 67.28307896212618}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _calibrate_baro = true;\n    }\n    return result;\n}", "CodeBleu_score": 67.50436756641716}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_need_baro_calibration = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 64.80753675822791}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result;\n\n    if (packet.param1 == 1.0) {\n        result = MAV_RESULT_ACCEPTED;\n        Tracker::instance().set_armed(true);\n    } else if (packet.param1 == 0) {\n        result = MAV_RESULT_ACCEPTED;\n        Tracker::instance().set_armed(false);\n    } else {\n        result = MAV_RESULT_UNSUPPORTED;\n    }\n\n    return result;\n}", "CodeBleu_score": 51.99813507252038}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    // Check if the command is to arm or disarm the servos\n    if (packet.param1 == 1.0f) {\n        // Arm the servos\n        Tracker::getInstance().arm();\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0f) {\n        // Disarm the servos\n        Tracker::getInstance().disarm();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        // Unsupported parameter\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 58.642706658392996}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\telse if (packet.param1 == 0) {\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\telse {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 42.638134216377374}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    // Check if the channel is available\n    for (uint8_t i = 0; i < GCS_CHANNELS; i++) {\n        if (gcs_channels[i].sysid == 0 && gcs_channels[i].compid == 0) {\n            // Check if there is enough space to send the request\n            if (gcs_channels[i].payload_size < MAVLINK_MSG_ID_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n                // There is not enough space to send the request, so we will skip this channel\n                continue;\n            }\n\n            // Send the request\n            mavlink_message_t msg;\n            mavlink_msg_data_stream_pack(GCS_MAVLINK_SYSID, GCS_MAVLINK_COMPID, &msg, i, sysid, compid, 1000, MAV_DATA_STREAM_POSITION);\n            gcs_channels[i].send_message(&msg);\n\n            // Mark the channel as used\n            gcs_channels[i].sysid = sysid;\n            gcs_channels[i].compid = compid;\n\n            // We found a channel, so we can stop looking\n            return;\n        }\n    }\n\n    // If we get here, we could not find a channel\n    // TODO: Log an error\n}", "CodeBleu_score": 47.414832630783444}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\n\t// Iterate over the available GCS channels\n\tfor (uint8_t i = 0; i < GCS_CHANNEL_COUNT; i++) {\n\n\t\t// Check if there is space available in the payload\n\t\tif (gcs_channels[i].get_payload_space() >= GCS_DATASTREAM_POSITION_PAYLOAD_SIZE) {\n\n\t\t\t// Send a request to start the data stream\n\t\t\tgcs_channels[i].request_datastream_position(sysid, compid, GCS_DATASTREAM_POSITION_RATE);\n\t\t}\n\t}\n}", "CodeBleu_score": 33.450536754376714}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over all GCS channels\n\tfor (int i = 0; i < GCS_CHANNEL_COUNT; i++) {\n\t\t// Check if the channel is available\n\t\tif (this->gcs_channels[i].is_available()) {\n\t\t\t// Check if there is enough space in the channel for a new datastream request\n\t\t\tif (this->gcs_channels[i].get_payload_space() >= sizeof(mavlink_request_data_stream_t)) {\n\t\t\t\t// Send the request\n\t\t\t\tmavlink_request_data_stream_t request;\n\t\t\t\trequest.req_message_rate = 10;\n\t\t\t\trequest.req_stream_id = 0;\n\t\t\t\trequest.req_stream_rate = 1;\n\t\t\t\trequest.req_start_stop = 1;\n\t\t\t\trequest.target_system = sysid;\n\t\t\t\trequest.target_component = compid;\n\t\t\t\tthis->gcs_channels[i].send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, &request);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.584984294974205}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    AHRS* ahrs = Tracker::get_instance().get_ahrs();\n    if (ahrs->getPitchCos() == 0) {\n        return false;\n    }\n    ef_pitch = atan2f(ahrs->getPitchSin() * ahrs->getRollSin() * yaw + ahrs->getPitchCos() * ahrs->getRollCos() * pitch, ahrs->getPitchCos() * ahrs->getRollSin() * yaw - ahrs->getPitchSin() * ahrs->getRollCos() * pitch);\n    ef_yaw = atan2f(ahrs->getPitchSin() * ahrs->getRollCos() * yaw - ahrs->getPitchCos() * ahrs->getRollSin() * pitch, ahrs->getPitchCos() * ahrs->getRollCos() * yaw + ahrs->getPitchSin() * ahrs->getRollSin() * pitch);\n    return true;\n}", "CodeBleu_score": 54.24906766000819}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Retrieve the AHRS instance\n\tAHRS* ahrs = Tracker::getAHRS();\n\n\t// Check for a zero pitch cosine to avoid division by zero\n\tif (ahrs->getPitchCos() != 0) {\n\t\t// Calculate the earth frame pitch and yaw using trigonometric conversions\n\t\tef_pitch = atan2f(ahrs->getPitchSin(), ahrs->getPitchCos()) + pitch;\n\t\tef_yaw = yaw - ahrs->getYaw();\n\n\t\t// Return true to indicate a successful conversion\n\t\treturn true;\n\t}\n\n\t// Return false to indicate a failed conversion\n\treturn false;\n}", "CodeBleu_score": 41.633385594730065}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = Tracker::get_ahrs();\n\tfloat pitch_cosine = ahrs->getPitch();\n\tif (pitch_cosine != 0) {\n\t\tfloat pitch_sine = ahrs->getRoll();\n\t\tfloat yaw_sine = ahrs->getYaw();\n\t\tef_pitch = atan2(pitch_sine, pitch_cosine) + pitch;\n\t\tef_yaw = atan2(yaw_sine, pitch_cosine) + yaw;\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 44.700002966969706}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t    // Calculate the target yaw and pitch in centidegrees\n    int16_t target_yaw = (int16_t)((float)nav_status.yaw_target * 100);\n    int16_t target_pitch = (int16_t)((float)nav_status.pitch_target * 100);\n\n    // Check if the direction is reversed\n    if (nav_status.yaw_reversed) {\n        target_yaw = -target_yaw;\n    }\n    if (nav_status.pitch_reversed) {\n        target_pitch = -target_pitch;\n    }\n\n    // Calculate the angle error\n    int16_t yaw_error = target_yaw - (int16_t)((float)nav_status.yaw_actual * 100);\n    int16_t pitch_error = target_pitch - (int16_t)((float)nav_status.pitch_actual * 100);\n\n    // Convert the errors from earth frame to body frame\n    int16_t yaw_error_body = yaw_error;\n    int16_t pitch_error_body = pitch_error;\n\n    // If the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly\n    if (nav_status.distance_valid || nav_status.distance_min == 0) {\n        // Update the yaw servo\n        if (nav_status.yaw_reversed) {\n            yaw_error_body = -yaw_error_body;\n        }\n        if (abs(yaw_error_body) > 1000) {\n            yaw_error_body = 1000 * (yaw_error_body / abs(yaw_error_body));\n        }\n        if (abs(yaw_error_body) < 50) {\n            yaw_error_body = 0;\n        }\n        yaw_error_body = (int16_t)((float)yaw_error_body *", "CodeBleu_score": 34.65099007049209}, {"code": "void Mode::update_auto(void){\n\t  // Calculate the target yaw and pitch in centidegrees\n  int16_t target_yaw = (int16_t)((nav_status.target_bearing * 100.0) / 360.0);\n  int16_t target_pitch = (int16_t)((nav_status.target_elevation * 100.0) / 90.0);\n\n  // Check if the direction is reversed\n  bool direction_reversed = (target_yaw < 0);\n  if (direction_reversed) {\n    target_yaw = -target_yaw;\n  }\n\n  // Calculate the angle error\n  int16_t angle_error_yaw = (int16_t)((nav_status.yaw * 100.0) / 360.0) - target_yaw;\n  int16_t angle_error_pitch = (int16_t)((nav_status.pitch * 100.0) / 90.0) - target_pitch;\n\n  // Convert the errors from earth frame to body frame\n  if (direction_reversed) {\n    angle_error_yaw = -angle_error_yaw;\n  }\n  angle_error_pitch = -angle_error_pitch;\n\n  // Update the pitch and yaw servos if the target distance is valid or no minimum distance is set\n  if ((nav_status.distance > MIN_DISTANCE) || (MIN_DISTANCE == 0)) {\n    // Update the yaw servo\n    if (abs(angle_error_yaw) < 100) {\n      yaw_servo.write(yaw_servo.read() + angle_error_yaw);\n    }\n\n    // Update the pitch servo\n    if (abs(angle_error_pitch) < 100) {\n      pitch_servo.write(pitch_servo.read() + angle_error_pitch);\n    }\n  }\n}", "CodeBleu_score": 38.37636339610447}, {"code": "void Mode::update_auto(void){\n\t    // Get navigation status\n    NavigationStatus nav_status = Tracker::nav_status;\n\n    // Calculate target yaw and pitch in centidegrees\n    int16_t target_yaw = (int16_t) (nav_status.yaw * 100);\n    int16_t target_pitch = (int16_t) (nav_status.pitch * 100);\n\n    // Check if the direction is reversed\n    bool reversed = Tracker::reversed;\n\n    // Calculate the angle error\n    int16_t error_yaw = target_yaw - Tracker::yaw;\n    int16_t error_pitch = target_pitch - Tracker::pitch;\n\n    // Convert the errors from earth frame to body frame\n    if (reversed) {\n        error_yaw = -error_yaw;\n        error_pitch = -error_pitch;\n    }\n\n    // Update the pitch and yaw servos if the target distance is valid or no minimum distance is set\n    if (nav_status.distance_valid || Tracker::min_distance == 0) {\n        Tracker::yaw_servo.write(Tracker::yaw + error_yaw);\n        Tracker::pitch_servo.write(Tracker::pitch + error_pitch);\n    }\n}", "CodeBleu_score": 37.01810467745542}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\t// Update the GPS\n\tGPS.update();\n\n\t// If the last message time has changed, check if the GPS status is at least 3D fix\n\tif (GPS.last_message_time != last_message_time) {\n\t\tlast_message_time = GPS.last_message_time;\n\t\tif (GPS.status >= 3) {\n\t\t\t// If the location is valid, check if the countdown is at one\n\t\t\tif (countdown == 1) {\n\t\t\t\t// If the countdown is at one, set the home location if it has not been set\n\t\t\t\tif (!home_set) {\n\t\t\t\t\thome_lat = GPS.latitude;\n\t\t\t\t\thome_lon = GPS.longitude;\n\t\t\t\t\thome_alt = GPS.altitude;\n\t\t\t\t\thome_set = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Reset the countdown if the location is invalid\n\t\t\telse if (!GPS.valid) {\n\t\t\t\tcountdown = 10;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.98639551242125}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update the GPS data\n\tGPS.read();\n\n\t// Check if the last message time has changed\n\tif (GPS.time.isUpdated()) {\n\t\t// Check if the GPS status is at least 3D fix\n\t\tif (GPS.status.status >= 3) {\n\t\t\t// Check if the countdown is running\n\t\t\tif (countdown_running) {\n\t\t\t\t// Check if the countdown has reached one\n\t\t\t\tif (countdown == 1) {\n\t\t\t\t\t// Check if the current location is valid\n\t\t\t\t\tif (GPS.location.isValid()) {\n\t\t\t\t\t\t// Set the home location\n\t\t\t\t\t\thome_location = GPS.location;\n\n\t\t\t\t\t\t// Stop the countdown\n\t\t\t\t\t\tcountdown_running = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Decrement the countdown\n\t\t\t\tcountdown--;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 27.44220465415609}, {"code": "void Tracker::update_GPS(void){\n\t\tstatic int countdown = 0;\n\n\tif (GPS.newNMEAreceived()) {\n\t\tGPS.parse(GPS.lastNMEA());\n\t\tif (GPS.lastNMEA()[0] == 'G') {\n\t\t\tif (GPS.fix > 3) {\n\t\t\t\tif (countdown > 0) {\n\t\t\t\t\tcountdown--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcountdown = 10;\n\t\t\t}\n\t\t\tif (countdown == 1) {\n\t\t\t\tif (GPS.fix > 3) {\n\t\t\t\t\thome_lat = GPS.latitude;\n\t\t\t\t\thome_lon = GPS.longitude;\n\t\t\t\t\thome_alt = GPS.altitude;\n\t\t\t\t} else {\n\t\t\t\t\tcountdown = 10;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.9200927859137}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch >= 0) {\n\t\tpitch_onoff_servo.write(pitch);\n\t}\n\telse {\n\t\tpitch_onoff_servo.write(0);\n\t}\n}", "CodeBleu_score": 14.394501837577833}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    float servo_position = 0.0;\n    if (pitch < 0.0) {\n        servo_position = 180.0 + pitch;\n    }\n    else {\n        servo_position = pitch;\n    }\n    servo_pitch.write(servo_position);\n}", "CodeBleu_score": 16.001668966289163}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // Check if the pitch is within the range of the servo\n    if (pitch > 0 && pitch < 180) {\n        // Set the servo to the pitch\n        pitch_onoff_servo.write(pitch);\n    }\n    else {\n        // If the pitch is outside of the range, set the servo to 0\n        pitch_onoff_servo.write(0);\n    }\n}", "CodeBleu_score": 14.995126183389672}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (AP_Arming_Base::barometer_checks(display_failure) == false) {\n        return false;\n    }\n\n    if (AP_Arming_Copter::_check_baro_alt_diff) {\n        float baro_alt = barometer.get_altitude();\n        float inertial_alt = gps.altitude();\n        if (abs(baro_alt - inertial_alt) > AP_Arming_Copter::_baro_alt_diff_limit) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Baro alt diff: %f\n\"), (double)(baro_alt - inertial_alt));\n            }\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 39.937298559815495}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    bool result = AP_Arming_Base::barometer_checks(display_failure);\n\n    if (result && _arming_checks_enabled[ARMING_CHECK_BARO]) {\n        float baro_alt = _ahrs->get_altitude();\n        float inertial_nav_alt = _ahrs->get_inertial_nav_alt();\n        float baro_alt_error = fabsf(baro_alt - inertial_nav_alt);\n        if (baro_alt_error > _baro_alt_error_limit) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Baro alt error: %.1f > %.1f\n\"), (double)baro_alt_error, (double)_baro_alt_error_limit);\n            }\n            result = false;\n        }\n    }\n    return result;\n}", "CodeBleu_score": 48.57830321737822}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call the base class barometer_checks\n    if (!AP_Arming_Base::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro altitude against inertial nav altitude\n    if (g.arming_check_baro) {\n        float baro_alt = barometer.get_altitude();\n        float inertial_nav_alt = inertial_nav.get_altitude();\n        float alt_diff = fabsf(inertial_nav_alt - baro_alt);\n        if (alt_diff > g.arming_check_baro_diff) {\n            if (display_failure) {\n                gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Baro alt %f m differs from inertial nav alt %f m by more than %d m\", (double)baro_alt, (double)inertial_nav_alt, (int)g.arming_check_baro_diff);\n            }\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 48.192716094084474}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    return (\n        AP_Arming_Plane::terrain_database_required() ||\n        (\n            _terrain.get_source() == TERRAIN_SOURCE_DATABASE &&\n            _rtl_alt_type == RTL_ALT_TYPE_TERRAIN\n        )\n    );\n}", "CodeBleu_score": 28.017686505400686}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (terrain.get_source() == TERRAIN_RANGEFINDER) {\n        return false;\n    } else if (terrain.get_source() == TERRAIN_DATABASE && rtl.get_alt_type() == RTL_ALT_TYPE_TERRAIN) {\n        return true;\n    } else {\n        return AP_Arming_Base::terrain_database_required();\n    }\n}", "CodeBleu_score": 53.37123254233883}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (AP_Notify::flags.armed &&\n        _terrain_source == TERRAIN_SOURCE_DATABASE &&\n        _rtl_alt_type == RTL_ALT_TYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming_Base::terrain_database_required();\n}", "CodeBleu_score": 33.47613573572683}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// Set the loop time for attitude, position, and motor controllers\n\t// using the last loop time from the scheduler\n\tconst float loop_time = constrain_float(scheduler.micros() - last_loop_time, 100, 10000);\n\tlast_loop_time = scheduler.micros();\n\t\n\t// Run the low-level rate controllers that require only IMU data\n\trate_controller_run(loop_time);\n}", "CodeBleu_score": 41.233291024927524}, {"code": "void Copter::run_rate_controller(){\n\t\n    // get the time since the last loop\n    uint32_t now = micros();\n    uint32_t dt = now - last_loop_time;\n    last_loop_time = now;\n\n    // set the loop time for the attitude controller\n    attitude_control.set_dt(dt);\n\n    // set the loop time for the position controller\n    position_control.set_dt(dt);\n\n    // set the loop time for the motor controller\n    motor_control.set_dt(dt);\n\n    // run the rate controllers that only require IMU data\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 53.78637355730254}, {"code": "void Copter::run_rate_controller(){\n\t\t// get the time in microseconds since the last loop\n\tuint32_t now = micros();\n\tuint32_t dt = now - last_run;\n\tlast_run = now;\n\n\t// set the loop time for the attitude controller\n\trate_controller.set_dt(dt);\n\n\t// run the rate controller\n\trate_controller.rate_controller_run();\n\n\t// set the loop time for the position controller\n\tpos_control.set_dt(dt);\n\n\t// run the position controller\n\tpos_control.position_controller_run();\n\n\t// set the loop time for the motor controller\n\tmotor_controller.set_dt(dt);\n\n\t// run the motor controller\n\tmotor_controller.motor_control_run();\n}", "CodeBleu_score": 48.02409347245463}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // get the next waypoint location\n    Location next_waypoint_loc;\n    if (!get_next_waypoint_location(next_waypoint_loc)) {\n        return false;\n    }\n\n    // check if the old location matches this waypoint\n    if (old_loc.distance(next_waypoint_loc) > 1.0f) {\n        return false;\n    }\n\n    // check if the altitude frames of the old and new locations are the same\n    if (old_loc.alt != new_loc.alt) {\n        return false;\n    }\n\n    // set the new location as the target\n    target_location = new_loc;\n\n    return true;\n}", "CodeBleu_score": 58.72845707631738}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n    // check if the old location matches the current waypoint\n    if (old_loc.equals(current_waypoint_location)) {\n\n        // check if the altitude frames of the old and new locations are the same\n        if (old_loc.alt_frame == new_loc.alt_frame) {\n\n            // set the new location as the target\n            target_location = new_loc;\n\n            // return true\n            return true;\n        }\n    }\n\n    // return false\n    return false;\n}", "CodeBleu_score": 46.39899846020921}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // check if the old location matches the next waypoint\n    if (old_loc != next_WP_location) {\n        return false;\n    }\n\n    // check if the altitude frames of the old and new locations are the same\n    if (old_loc.alt != new_loc.alt) {\n        return false;\n    }\n\n    // set the new location as the target\n    target_location = new_loc;\n\n    return true;\n}", "CodeBleu_score": 45.17703571558766}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    // if the aux switch is in the HIGH position, set the mode\n    if (aux_switch_pos(ch_flag) == AuxSwitchPos::HIGH) {\n        // set the mode\n        copter().set_mode(mode);\n    }\n    // if the aux switch is not in the HIGH position and the current flight mode matches the given mode, reset the mode switch\n    else if (aux_switch_pos(ch_flag) == AuxSwitchPos::LOW && copter().flight_mode() == mode) {\n        // reset the mode switch\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 58.41519907505241}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    // if the switch is in the HIGH position, attempt to set the mode\n    if (aux_switch_pos(ch_flag) == AuxSwitchPos::HIGH) {\n        if (copter().set_mode(mode)) {\n            // if the mode was successfully set, reset the mode switch\n            rc().reset_mode_switch();\n        }\n    }\n    // if the switch is not in the HIGH position and the current flight mode matches the given mode, reset the mode switch\n    else if (copter().mode() == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 60.9987099948209}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (aux_switch_pos(ch_flag) == AuxSwitchPos::HIGH) {\n        copter().set_mode(mode);\n    } else {\n        if (copter().mode() == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 60.45903876136825}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // Calculate the roll and pitch trim values\n    float roll_trim = RC_Channel::rc_channels[RC_Channel::k_roll]->control_in;\n    float pitch_trim = RC_Channel::rc_channels[RC_Channel::k_pitch]->control_in;\n\n    // Convert to radians\n    roll_trim = (roll_trim - 0.5f) * 2.0f * M_PI_F;\n    pitch_trim = (pitch_trim - 0.5f) * 2.0f * M_PI_F;\n\n    // Add to the AHRS trim\n    ahrs.set_trim(roll_trim, pitch_trim);\n\n    // Log the event\n    Log_Write_Event(DATA_TRIM_SAVED);\n\n    // Send a confirmation message with MAV_SEVERITY_INFO\n    mavlink_log_info(&mavlink_log_pub, \"Trim Saved\");\n}", "CodeBleu_score": 48.94739157436124}, {"code": "void Copter::save_trim(){\n\t    // TODO: implement me\n}", "CodeBleu_score": 2.7694730809033348}, {"code": "void Copter::save_trim(){\n\t    // calculate trim values from the control inputs of the roll and pitch channels\n    float roll_trim = 0.0;\n    float pitch_trim = 0.0;\n    if (g.rc_3.control_in > 0) {\n        roll_trim = g.rc_3.control_in;\n    } else if (g.rc_3.control_in < 0) {\n        roll_trim = g.rc_3.control_in;\n    }\n    if (g.rc_4.control_in > 0) {\n        pitch_trim = g.rc_4.control_in;\n    } else if (g.rc_4.control_in < 0) {\n        pitch_trim = g.rc_4.control_in;\n    }\n    // convert to radians\n    roll_trim *= DEGTORAD;\n    pitch_trim *= DEGTORAD;\n    // add to AHRS trim\n    g.ahrs.add_trim(roll_trim, pitch_trim);\n    // log event\n    Log_Write_Event(DATA_TRIM_SAVE);\n    // send confirmation message with MAV_SEVERITY_INFO\n    mavlink_log_info(&mavlink_log_pub, \"Trim values saved\");\n}", "CodeBleu_score": 44.60293175069151}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\n\t// Check if the copter's position is valid\n\tif (Copter.altitude_ok()) {\n\n\t\t// Get the copter's velocity\n\t\tfloat vx = Copter.get_velocity_x();\n\t\tfloat vy = Copter.get_velocity_y();\n\n\t\t// Calculate the speed squared\n\t\tfloat speed_squared = vx * vx + vy * vy;\n\n\t\t// If the speed exceeds a minimum threshold\n\t\tif (speed_squared > 0.01f) {\n\n\t\t\t// Calculate the look-ahead yaw angle\n\t\t\tfloat look_ahead_yaw = atan2(vy, vx);\n\n\t\t\t// Return the computed look-ahead yaw angle\n\t\t\treturn look_ahead_yaw;\n\t\t}\n\t}\n\n\t// Return the look-ahead yaw angle\n\treturn look_ahead_yaw;\n}", "CodeBleu_score": 45.01354239237196}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t  float look_ahead_yaw = 0;\n  if (copter.get_position_valid() && copter.get_velocity_valid()) {\n    float velocity_squared = copter.get_velocity_x() * copter.get_velocity_x() + copter.get_velocity_y() * copter.get_velocity_y();\n    if (velocity_squared > 0.01) {\n      look_ahead_yaw = atan2(copter.get_velocity_y(), copter.get_velocity_x());\n    }\n  }\n  return look_ahead_yaw;\n}", "CodeBleu_score": 37.04240660146733}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\n  // If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle.\n  if (Copter.state.position_valid && Copter.state.speed_sq > 100) {\n    look_ahead_yaw_angle = atan2(Copter.state.velocity.x, Copter.state.velocity.y);\n  }\n\n  // Return the computed look-ahead yaw angle.\n  return look_ahead_yaw_angle;\n}", "CodeBleu_score": 26.373256959181468}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // rudder arming check\n    if (method == AP_Arming::RUDDER) {\n        // rudder arming check\n        if (!_plane->rudder_arming_enabled()) {\n            return false;\n        }\n        // rudder arming check\n        if (_plane->throttle_zero_not_idle()) {\n            return false;\n        }\n    }\n    // if arming checks are disabled or the watchdog was armed, bypass checks\n    if (!_plane->arming_checks_enabled() || _plane->watchdog_armed()) {\n        return true;\n    }\n    // call parent class\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 52.181884457935304}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // rudder arming checks\n    if (method == AP_Arming::RUDDER) {\n        // rudder arming disabled\n        if (plane.rudder_arming.get() == 0) {\n            return false;\n        }\n        // rudder arming enabled, but throttle is not zero\n        if (plane.throttle_cruise.get() != 0) {\n            return false;\n        }\n    }\n\n    // watchdog armed\n    if (plane.watchdog.armed()) {\n        return true;\n    }\n\n    // arming checks disabled\n    if (plane.arming_checks_disable.get() != 0) {\n        return true;\n    }\n\n    // call parent class's arm_checks\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 57.20605911504077}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == RUDDER) {\n        if (!_plane->rudder_arming_enabled() || _plane->throttle_zero_not_idle()) {\n            return false;\n        }\n    }\n    if (_plane->arming_checks_override()) {\n        return true;\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 46.50276996475925}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\n    // check if we are already armed\n    if (armed()) {\n        return false;\n    }\n\n    // check if we have a valid location\n    if (do_arming_checks && !_plane.initialised()) {\n        return false;\n    }\n\n    // check if we have a valid home\n    if (do_arming_checks && !_plane.home_is_set()) {\n        return false;\n    }\n\n    // check if we have a valid GPS lock\n    if (do_arming_checks && !_plane.gps.healthy()) {\n        return false;\n    }\n\n    // check if we have a valid attitude\n    if (do_arming_checks && !_plane.ahrs.healthy()) {\n        return false;\n    }\n\n    // check if we have a valid airspeed\n    if (do_arming_checks && !_plane.airspeed.healthy()) {\n        return false;\n    }\n\n    // check if we have a valid barometer\n    if (do_arming_checks && !_plane.barometer.healthy()) {\n        return false;\n    }\n\n    // check if we have a valid sonar\n    if (do_arming_checks && !_plane.sonar.healthy()) {\n        return false;\n    }\n\n    // check if we have a valid compass\n    if (do_arming_checks && !_plane.compass.healthy()) {\n        return false;\n    }\n\n    // check if we have a valid GPS\n    if (do_arming_checks && !_plane.gps.healthy()) {\n        return false;\n    }\n\n    // check if we have a valid rangefinder\n    if (do_arming_checks && !_plane.rangefinder.healthy()) {\n        return false;\n    }\n\n    // check if we have a valid INS\n    if (do_arming_checks && !_plane.ins.healthy()) {\n        return false;\n    }\n\n    // check if we have a", "CodeBleu_score": 32.18178186332329}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // check for a valid method\n    if (method == AP_Arming::Method::none) {\n        return false;\n    }\n\n    // check for a valid arming method\n    if (method != AP_Arming::Method::manual && method != AP_Arming::Method::autopilot) {\n        return false;\n    }\n\n    // check for a valid arming state\n    if (plane.get_arming_state() != AP_Arming::State::disarmed) {\n        return false;\n    }\n\n    // check for a valid arming method\n    if (method == AP_Arming::Method::manual && plane.get_manual_armed_state() != AP_Arming::Manual_Arming::armed) {\n        return false;\n    }\n\n    // check for a valid arming method\n    if (method == AP_Arming::Method::autopilot && plane.get_autopilot_armed_state() != AP_Arming::Autopilot_Arming::armed) {\n        return false;\n    }\n\n    // check for a valid arming method\n    if (method == AP_Arming::Method::autopilot && plane.get_manual_armed_state() != AP_Arming::Manual_Arming::disarmed) {\n        return false;\n    }\n\n    // check for a valid arming method\n    if (method == AP_Arming::Method::autopilot && plane.get_manual_armed_state() != AP_Arming::Manual_Arming::disarmed) {\n        return false;\n    }\n\n    // check for a valid arming method\n    if (method == AP_Arming::Method::autopilot && plane.get_manual_armed_state() != AP_Arming::Manual_Arming::disarmed) {\n        return false;\n    }\n\n    // check for a valid arming method\n    if (method == AP_Arming::Method::autopilot && plane.get_manual_armed_state() != AP_Arming::Manual_Arming::disarmed) {\n        return false;", "CodeBleu_score": 45.40252792070969}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // check if we are already armed\n    if (plane.armed()) {\n        return false;\n    }\n\n    // check if we are in a state where we can arm\n    if (plane.control_mode != AP_Vehicle::FixedWing && plane.control_mode != AP_Vehicle::MultiRotor && plane.control_mode != AP_Vehicle::AC_ROVER) {\n        return false;\n    }\n\n    // check if we have a GPS fix\n    if (plane.gps.status() < AP_GPS::GPS_OK_FIX_3D) {\n        return false;\n    }\n\n    // check if we have a barometer\n    if (plane.barometer == NULL) {\n        return false;\n    }\n\n    // check if we have an airspeed sensor\n    if (plane.airspeed == NULL) {\n        return false;\n    }\n\n    // check if we have a compass\n    if (plane.compass == NULL) {\n        return false;\n    }\n\n    // check if we have an altimeter\n    if (plane.altimeter == NULL) {\n        return false;\n    }\n\n    // check if we have an RPM sensor\n    if (plane.rpm_sensor == NULL) {\n        return false;\n    }\n\n    // check if we have a battery\n    if (plane.battery == NULL) {\n        return false;\n    }\n\n    // check if we have a motor\n    if (plane.motors == NULL) {\n        return false;\n    }\n\n    // check if we have a GPS\n    if (plane.gps == NULL) {\n        return false;\n    }\n\n    // check if we have an AHRS\n    if (plane.ahrs == NULL) {\n        return false;\n    }\n\n    // check if we have an INS\n    if (plane.ins == NULL) {\n        return false;\n    }\n\n    // check if we have an INS\n    if (plane.ins == NULL) {\n        return false;\n    }\n\n    // check if we have an INS\n    if (plane.", "CodeBleu_score": 26.80034393655703}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (arming.is_armed()) {\n        return true;\n    }\n\n    if (arming.disarm_button == 0) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Arming failed: No disarm button configured\n\"));\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.43720900766455}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // check if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // check if disarm button is configured\n    if (disarm_button == 0) {\n        // no disarm button configured\n        if (display_failure) {\n            // display failure message\n            hal.console->printf_P(PSTR(\"Arming failed: no disarm button configured.\n\"));\n        }\n        return false;\n    }\n\n    // disarm button configured, perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 65.9316337920304}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (AP_Arming::pre_arm_checks(display_failure)) {\n        return true;\n    }\n    if (display_failure) {\n        hal.console->printf_P(PSTR(\"Pre-arm checks failed.\"));\n    }\n    return false;\n}", "CodeBleu_score": 57.74625568085791}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\n    // Rotation matrix for the body frame to the North-East frame\n    float rotation_matrix[2][2] = {\n        {cos(ahrs.yaw), -sin(ahrs.yaw)},\n        {sin(ahrs.yaw), cos(ahrs.yaw)}\n    };\n\n    // Rotate the coordinates x and y from the body frame to the North-East frame\n    float ne_x = x * rotation_matrix[0][0] + y * rotation_matrix[0][1];\n    float ne_y = x * rotation_matrix[1][0] + y * rotation_matrix[1][1];\n\n    // Update x and y with the new coordinates\n    x = ne_x;\n    y = ne_y;\n\n}", "CodeBleu_score": 51.9796838903442}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\n\t// Rotation matrix\n\tfloat R[2][2] = {\n\t\t{cos(yaw), -sin(yaw)},\n\t\t{sin(yaw), cos(yaw)}\n\t};\n\n\t// New coordinates\n\tfloat ne_x = x * R[0][0] + y * R[0][1];\n\tfloat ne_y = x * R[1][0] + y * R[1][1];\n\n\t// Update coordinates\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 49.868479394090286}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x;\n\tfloat ne_y;\n\tfloat temp_x;\n\tfloat temp_y;\n\tfloat temp_z;\n\n\t// Calculate the new coordinates ne_x and ne_y\n\tne_x = cos(yaw) * x - sin(yaw) * y;\n\tne_y = sin(yaw) * x + cos(yaw) * y;\n\n\t// Update x and y with these new values\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 50.388498854371655}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    if (packet.param1 < 0 || packet.param1 > 360) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param4 < 0 || packet.param4 > 1) {\n        return MAV_RESULT_DENIED;\n    }\n    // set yaw heading\n    _vehicle->set_yaw_heading(packet.param1, packet.param4);\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 46.118020033004036}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\n    // check if yaw angle is valid\n    if (packet.param1 < -3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679 || packet.param1 > 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // check if param4 is valid\n    if (packet.param4 < 0 || packet.param4 > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set the yaw heading\n    _yaw_heading = packet.param1;\n    _yaw_heading_type = packet.param2;\n    _yaw_heading_angle = packet.param4;\n\n    // return MAV_RESULT_ACCEPTED\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 45.986765548296745}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // check if yaw angle is within range\n    if (packet.param1 < 0 || packet.param1 > 360) {\n        return MAV_RESULT_DENIED;\n    }\n    // check if param4 is within range\n    if (packet.param4 < 0 || packet.param4 > 1) {\n        return MAV_RESULT_DENIED;\n    }\n    // set yaw heading\n    _vehicle->set_yaw_heading(packet.param1, packet.param4);\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 46.101588109337534}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    uint8_t ret = 0;\n    if (gcs_cmd.control_mode == GCS_MAVLINK::MAV_MODE_AUTO_ARMED || gcs_cmd.control_mode == GCS_MAVLINK::MAV_MODE_GUIDED_ARMED) {\n        if (gcs_cmd.waypoint_bearing < 0) {\n            ret = (uint8_t)((gcs_cmd.waypoint_bearing + 36000) / 2);\n        } else {\n            ret = (uint8_t)(gcs_cmd.waypoint_bearing / 2);\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 41.69938188861968}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    uint8_t ret = 0;\n    switch (vehicle_control_mode.flag_control_mode) {\n        case MAV_MODE_FLAG_CUSTOM_MODE_ENABLED:\n            switch (vehicle_control_mode.custom_mode) {\n                case PX4_CUSTOM_MAIN_MODE_AUTO:\n                case PX4_CUSTOM_MAIN_MODE_GUIDED:\n                    ret = (uint8_t)(((((int16_t)vehicle_waypoint.param1 + 18000) % 36000) / 2) % 256);\n                    break;\n            }\n            break;\n    }\n    return ret;\n}", "CodeBleu_score": 38.95510484148753}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return (waypoint_bearing + 18000) / 2;\n    } else {\n        return 0;\n    }\n}", "CodeBleu_score": 37.6736044098811}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\n\tif (log_enable) {\n\t\tLogData data;\n\t\tdata.id = id;\n\t\tdata.value = value;\n\t\tdata.time = (uint32_t)millis();\n\t\tlog_queue.criticalBlockWrite(&data, sizeof(LogData));\n\t}\n}", "CodeBleu_score": 40.847781257973914}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\n    if (log_enabled) {\n\n        // Create a log packet with the current time, log data ID, and value\n        LogPacket packet = LogPacket(id, value);\n\n        // Write the packet to the logger as a critical block\n        logger.Write_Critical_Block(packet);\n    }\n}", "CodeBleu_score": 29.4128661045794}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (!LoggingEnabled) {\n\t\treturn;\n\t}\n\n\t// Create the log packet\n\tLogPacket packet;\n\tpacket.Time = Get_Time();\n\tpacket.ID = id;\n\tpacket.Data = value;\n\n\t// Write the log packet as a critical block\n\tWrite_Log_Packet_Critical(&packet);\n}", "CodeBleu_score": 31.36454703689107}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\tif (armed) {\n\t\tset_home_to_current_location();\n\t} else {\n\t\tset_home_to_current_EKF_location();\n\t}\n}", "CodeBleu_score": 25.202321925774747}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set()) {\n\t\treturn;\n\t}\n\n\tif (motors_armed()) {\n\t\t// Set home to current location\n\t\thome_is_set(true);\n\t\thome_lat = ekf_loc.lat;\n\t\thome_lon = ekf_loc.lon;\n\t\thome_alt = ekf_loc.alt;\n\t\thome_yaw = ekf_loc.yaw;\n\t} else {\n\t\t// Set home to current EKF location\n\t\tset_home_to_EKF_location();\n\t}\n}", "CodeBleu_score": 26.46293065417651}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (home_is_set()) {\n        return;\n    }\n\n    if (armed()) {\n        set_home_to_current_location();\n    } else {\n        set_home_to_current_EKF_location();\n    }\n}", "CodeBleu_score": 33.141322519046696}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t    // if motors are not armed, set throttle to zero, adjust spool state, relax attitude controllers, and exit\n    if (!motorsArmed()) {\n        setThrottle(0);\n        setSpoolState(SPOOL_STATE_UNLIMITED_THROTTLE);\n        relaxAttitudeController();\n        return;\n    }\n\n    // set spool state to unlimited throttle\n    setSpoolState(SPOOL_STATE_UNLIMITED_THROTTLE);\n\n    // convert pilot inputs to desired body frame rates\n    float rollRate = pilotRoll();\n    float pitchRate = pilotPitch();\n    float yawRate = pilotYaw();\n\n    // run attitude controller with these rates\n    attitudeController.run(rollRate, pitchRate, yawRate);\n\n    // output pilot's throttle input without angle boost and set forward and lateral motor inputs based on pilot controls\n    setThrottle(pilotThrottle());\n    setForward(pilotForward());\n    setLateral(pilotLateral());\n}", "CodeBleu_score": 33.64905681616085}, {"code": "void ModeAcro::run(){\n\t    // if motors are not armed, set throttle to zero, adjust spool state, relax attitude controllers, and exit\n    if (!motorsArmed) {\n        // set throttle to zero\n        setThrottle(0);\n\n        // adjust spool state\n        if (spoolState == SpoolState::SPOOLING) {\n            setSpoolState(SpoolState::SPOOLING_TO_UNLIMITED_THROTTLE);\n        } else if (spoolState == SpoolState::UNLIMITED_THROTTLE) {\n            setSpoolState(SpoolState::UNLIMITED_THROTTLE_TO_SPOOLING);\n        }\n\n        // relax attitude controllers\n        attitudeController.relax();\n\n        // exit\n        return;\n    }\n\n    // set spool state to unlimited throttle\n    setSpoolState(SpoolState::UNLIMITED_THROTTLE);\n\n    // convert pilot inputs to desired body frame rates\n    attitudeController.setDesiredBodyRates(getDesiredRollRate(), getDesiredPitchRate(), getDesiredYawRate());\n\n    // run attitude controller with these rates\n    attitudeController.run();\n\n    // set pilot's throttle input without angle boost\n    setThrottle(getThrottle() - getAngleBoost());\n\n    // set forward and lateral motor inputs based on pilot controls\n    setForward(getDesiredForward());\n    setLateral(getDesiredLateral());\n}", "CodeBleu_score": 39.917433519105444}, {"code": "void ModeAcro::run(){\n\t\n}", "CodeBleu_score": 1.8702286680134719}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set position control mode\n\t_control_mode.flag_control_position_enabled = true;\n\t_control_mode.flag_control_velocity_enabled = false;\n\t_control_mode.flag_control_altitude_enabled = false;\n\t_control_mode.flag_control_climb_rate_enabled = false;\n\t_control_mode.flag_control_attitude_enabled = false;\n\t_control_mode.flag_control_rates_enabled = false;\n\t_control_mode.flag_control_acceleration_enabled = false;\n\t_control_mode.flag_control_force_enabled = false;\n\t_control_mode.flag_control_torque_enabled = false;\n\t_control_mode.flag_control_velocity_enabled = false;\n\t_control_mode.flag_control_termination_enabled = false;\n\n\t// set waypoint destination\n\t_waypoint_prev = _position;\n\t_waypoint_next = _position;\n\t_waypoint_next.x = _pos_sp_triplet.current.x;\n\t_waypoint_next.y = _pos_sp_triplet.current.y;\n\t_waypoint_next.z = _pos_sp_triplet.current.z;\n\n\t// set yaw angle\n\t_att_sp.yaw_body = _pos_sp_triplet.current.yaw;\n\n\t// initialize waypoint controller\n\t_waypoint_controller.init();\n\n\t// set yaw angle\n\t_att_sp.yaw_body = _pos_sp_triplet.current.yaw;\n\n\t// initialize waypoint controller\n\t_waypoint_controller.init();\n}", "CodeBleu_score": 33.38865474886102}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set position control mode\n\t_control_mode.flag_control_position_enabled = true;\n\t_control_mode.flag_control_velocity_enabled = false;\n\t_control_mode.flag_control_acceleration_enabled = false;\n\t_control_mode.flag_control_attitude_enabled = false;\n\t_control_mode.flag_control_rates_enabled = false;\n\t_control_mode.flag_control_altitude_enabled = false;\n\t_control_mode.flag_control_climb_rate_enabled = false;\n\t_control_mode.flag_control_force_enabled = false;\n\t_control_mode.flag_control_torque_enabled = false;\n\t_control_mode.flag_control_velocity_enabled = false;\n\t_control_mode.flag_control_surface_enabled = false;\n\n\t// set waypoint controller to position control mode\n\t_waypoint_controller.set_mode(WAYPOINT_MODE_POSITION);\n\n\t// set the waypoint destination to the stopping point\n\t_waypoint_controller.set_destination(_destination);\n\n\t// initialize yaw\n\t_yaw_mode = YawMode(YawMode::Mode::Auto, _destination.yaw);\n\n\t// set the current position as the waypoint destination\n\t_waypoint_controller.set_destination(_destination);\n}", "CodeBleu_score": 35.09524318544043}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t  // TODO: implement\n}", "CodeBleu_score": 3.006399650678141}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialize vertical maximum speeds and acceleration\n\t_vel_max_up = _param_mpc_z_vel_max_up.get();\n\t_vel_max_down = _param_mpc_z_vel_max_dn.get();\n\t_acc_max_up = _param_mpc_acc_up_max.get();\n\t_acc_max_down = _param_mpc_acc_down_max.get();\n\n\t// initialize vertical and horizontal velocity controllers\n\t_vel_x_controller.set_gains(_param_mpc_xy_p.get(), _param_mpc_xy_vel_p.get(), _param_mpc_xy_vel_i.get(),\n\t\t\t\t    _param_mpc_xy_vel_d.get());\n\t_vel_y_controller.set_gains(_param_mpc_xy_p.get(), _param_mpc_xy_vel_p.get(), _param_mpc_xy_vel_i.get(),\n\t\t\t\t    _param_mpc_xy_vel_d.get());\n\t_vel_z_controller.set_gains(_param_mpc_z_p.get(), _param_mpc_z_vel_p.get(), _param_mpc_z_vel_i.get(),\n\t\t\t\t    _param_mpc_z_vel_d.get());\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\t_yaw_control_mode = AUTO_YAW_HOLD;\n}", "CodeBleu_score": 33.02085339288322}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// TODO: implement\n}", "CodeBleu_score": 2.2996549372656574}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// TODO: implement\n}", "CodeBleu_score": 2.2996549372656574}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if the time since the last waypoint has exceeded the timeout\n\tif (hrt_elapsed_time(&_wp_last_update) > _param_com_rcl_wp_timeout.get() * 1000) {\n\t\t// If the timeout has been exceeded, return true\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is below the minimum altitude\n\tif (_param_com_rcl_alt_min.get() > 0.0f && _global_pos.alt < _param_com_rcl_alt_min.get()) {\n\t\t// If the current altitude is below the minimum altitude, return true\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is above the maximum altitude\n\tif (_param_com_rcl_alt_max.get() > 0.0f && _global_pos.alt > _param_com_rcl_alt_max.get()) {\n\t\t// If the current altitude is above the maximum altitude, return true\n\t\treturn true;\n\t}\n\n\t// Check if the horizontal distance moved since the last waypoint exceeds the limit\n\tif (_param_com_rcl_dist_max.get() > 0.0f && _wp_distance > _param_com_rcl_dist_max.get()) {\n\t\t// If the horizontal distance moved since the last waypoint exceeds the limit, return true\n\t\treturn true;\n\t}\n\n\t// If none of the conditions were met, return false\n\treturn false;\n}", "CodeBleu_score": 34.17053782934636}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // Check if the timeout has been exceeded\n    if (hrt_elapsed_time(&_guided_start_time) > _param_com_rcl_nav_timeout.get() * 1000) {\n        return true;\n    }\n\n    // Check if the current altitude is below a minimum or above a maximum threshold\n    if (_param_com_rcl_nav_alt.get() > 0 && _param_com_rcl_nav_alt.get() < _current_altitude) {\n        return true;\n    }\n\n    if (_param_com_rcl_nav_alt.get() < 0 && _param_com_rcl_nav_alt.get() > _current_altitude) {\n        return true;\n    }\n\n    // Check if the horizontal distance moved exceeds a specified limit\n    if (_param_com_rcl_nav_hor_dist.get() > 0 && _horizontal_distance > _param_com_rcl_nav_hor_dist.get()) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 37.87398879589654}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // Check timeout\n    if (g.rtl_at_time != 0 && g.rtl_at_time < g.nav_pvt.time_utc_usec) {\n        return true;\n    }\n\n    // Check altitude\n    if (g.rtl_alt_min != 0 && g.nav_pvt.alt_m < g.rtl_alt_min) {\n        return true;\n    }\n\n    if (g.rtl_alt_max != 0 && g.nav_pvt.alt_m > g.rtl_alt_max) {\n        return true;\n    }\n\n    // Check distance\n    if (g.rtl_dist != 0 && g.nav_pvt.distance_to_home < g.rtl_dist) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 37.48211912265296}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\t// Verify that motor test requests are received at least every 2 Hz\n\tif (millis() - last_motor_test_request_time > 500) {\n\t\t// Send a timeout message\n\t\tsend_message(MESSAGE_TYPE_ERROR, ERROR_MOTOR_TEST_TIMEOUT);\n\t\t// Set the pass flag to false\n\t\tpass = false;\n\t\t// Disable the motor test\n\t\tmotor_test = false;\n\t\t// Disarm the system\n\t\tarmed = false;\n\t\t// Record the failure time\n\t\tfailure_time = millis();\n\t\t// Return false\n\t\treturn false;\n\t}\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 30.71645006902103}, {"code": "bool Sub::verify_motor_test(){\n\t    if (motor_test_time_out_flag) {\n        motor_test_time_out_flag = false;\n        pass = false;\n        motor_test_pass_flag = false;\n        motor_test_fail_flag = true;\n        motor_test_fail_time = ros::Time::now();\n        motor_test_pass_time = ros::Time::now();\n        motor_test_pass_time.sec = 0;\n        motor_test_pass_time.nsec = 0;\n        motor_test_fail_time.sec = 0;\n        motor_test_fail_time.nsec = 0;\n        motor_test_pass_time.sec = 0;\n        motor_test_pass_time.nsec = 0;\n        motor_test_pass_time.sec = 0;\n        motor_test_pass_time.nsec = 0;\n        motor_test_fail_time.sec = 0;\n        motor_test_fail_time.nsec = 0;\n        motor_test_pass_time.sec = 0;\n        motor_test_pass_time.nsec = 0;\n        motor_test_fail_time.sec = 0;\n        motor_test_fail_time.nsec = 0;\n        motor_test_pass_time.sec = 0;\n        motor_test_pass_time.nsec = 0;\n        motor_test_fail_time.sec = 0;\n        motor_test_fail_time.nsec = 0;\n        motor_test_pass_time.sec = 0;\n        motor_test_pass_time.nsec = 0;\n        motor_test_fail_time.sec = 0;\n        motor_test_fail_time.nsec = 0;\n        motor_test_pass_time.sec = 0;\n        motor_test_pass_time.nsec = 0;\n        motor_test_fail_time.sec = 0;\n        motor_test_fail_time.nsec = 0;\n        motor_test_pass_time.sec = 0;\n        motor", "CodeBleu_score": 32.45792448122719}, {"code": "bool Sub::verify_motor_test(){\n\t  if (motor_test_request_time_out()) {\n    pass = false;\n    motor_test_pass = false;\n    motor_test_fail_time = micros();\n    motor_test_pass_time = 0;\n    motor_test_request_time = 0;\n    motor_test_pass_time_out = false;\n    motor_test_request_time_out = false;\n    motor_test_pass_time_out = false;\n    motor_test_pass_time_out = false;\n    motor_test_pass = false;\n    motor_test_fail = false;\n    motor_test_fail_time = 0;\n    motor_test_pass_time = 0;\n    motor_test_pass_time_out = false;\n    motor_test_request_time_out = false;\n    motor_test_pass_time_out = false;\n    motor_test_pass_time_out = false;\n    motor_test_pass = false;\n    motor_test_fail = false;\n    motor_test_fail_time = 0;\n    motor_test_pass_time = 0;\n    motor_test_pass_time_out = false;\n    motor_test_request_time_out = false;\n    motor_test_pass_time_out = false;\n    motor_test_pass_time_out = false;\n    motor_test_pass = false;\n    motor_test_fail = false;\n    motor_test_fail_time = 0;\n    motor_test_pass_time = 0;\n    motor_test_pass_time_out = false;\n    motor_test_request_time_out = false;\n    motor_test_pass_time_out = false;\n    motor_test_pass_time_out = false;\n    motor_test_pass = false;\n    motor_test_fail = false;\n    motor_test_fail_time = 0;\n    motor_test_pass_time = 0;\n    motor_test_pass_time_out = false;\n    motor_test_request_time_out = false;\n    motor_test_", "CodeBleu_score": 36.65553042193312}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.get_roll_target();\n\tfloat pitch_target = wp_nav.get_pitch_target();\n\n\tfloat roll_target_norm = 0.0;\n\tfloat pitch_target_norm = 0.0;\n\n\t// roll\n\tif (roll_target > 0) {\n\t\tif (roll_target > roll_max) {\n\t\t\troll_target_norm = roll_max;\n\t\t} else {\n\t\t\troll_target_norm = roll_target;\n\t\t}\n\t} else if (roll_target < 0) {\n\t\tif (roll_target < -roll_max) {\n\t\t\troll_target_norm = -roll_max;\n\t\t} else {\n\t\t\troll_target_norm = roll_target;\n\t\t}\n\t}\n\n\t// pitch\n\tif (pitch_target > 0) {\n\t\tif (pitch_target > pitch_max) {\n\t\t\tpitch_target_norm = pitch_max;\n\t\t} else {\n\t\t\tpitch_target_norm = pitch_target;\n\t\t}\n\t} else if (pitch_target < 0) {\n\t\tif (pitch_target < -pitch_max) {\n\t\t\tpitch_target_norm = -pitch_max;\n\t\t} else {\n\t\t\tpitch_target_norm = pitch_target;\n\t\t}\n\t}\n\n\t// normalize\n\tfloat roll_target_norm_norm = roll_target_norm / roll_max;\n\tfloat pitch_target_norm_norm = pitch_target_norm / pitch_max;\n\n\t// assign\n\tlateral_out = roll_target_norm_norm;\n\tforward_out = pitch_target_norm_norm;\n}", "CodeBleu_score": 39.55069162461476}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\n\tfloat roll_target = wp_nav.roll_cd;\n\tfloat pitch_target = wp_nav.pitch_cd;\n\n\t// Roll and pitch targets are constrained to a maximum angle range\n\troll_target = constrain_float(roll_target, -1800, 1800);\n\tpitch_target = constrain_float(pitch_target, -1800, 1800);\n\n\t// Roll and pitch targets are normalized to the range [-1, 1]\n\tlateral_out = roll_target / 1800.0;\n\tforward_out = pitch_target / 1800.0;\n\n}", "CodeBleu_score": 33.196794969769094}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.get_roll_target();\n\tfloat pitch_target = wp_nav.get_pitch_target();\n\t\n\t// Constrain roll and pitch targets to the maximum angle range\n\tif (roll_target > max_angle_cd) {\n\t\troll_target = max_angle_cd;\n\t} else if (roll_target < -max_angle_cd) {\n\t\troll_target = -max_angle_cd;\n\t}\n\tif (pitch_target > max_angle_cd) {\n\t\tpitch_target = max_angle_cd;\n\t} else if (pitch_target < -max_angle_cd) {\n\t\tpitch_target = -max_angle_cd;\n\t}\n\t\n\t// Normalize roll and pitch targets\n\tfloat roll_norm = roll_target / max_angle_cd;\n\tfloat pitch_norm = pitch_target / max_angle_cd;\n\t\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 38.17470909973427}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t    /*\n     * If the barometer is not calibrated, it is calibrated.\n     */\n    if (!barometer_calibrated) {\n        barometer.calibrate();\n        barometer_calibrated = true;\n    }\n\n    /*\n     * If the barometer is calibrated, it reads the barometer data.\n     */\n    barometer.read();\n\n    /*\n     * If the altitude is above zero, it updates the barometer calibration.\n     */\n    if (barometer.altitude > 0) {\n        barometer.calibrate(barometer.altitude);\n    }\n\n    /*\n     * If a depth sensor is present, it updates the sensor health status based on the barometer's health.\n     */\n    if (depth_sensor_present) {\n        if (barometer.health == 0) {\n            depth_sensor_healthy = true;\n        } else {\n            depth_sensor_healthy = false;\n        }\n    }\n}", "CodeBleu_score": 39.984251075847816}, {"code": "void Sub::read_barometer(){\n\t\t// Update the barometer data\n\tbarometer.read();\n\n\t// If the altitude is above zero, update the barometer calibration\n\tif (barometer.getAltitude() > 0) {\n\t\tbarometer.calibrate();\n\t}\n\n\t// If a depth sensor is present, update the sensor health status based on the barometer's health\n\tif (depth_sensor_present) {\n\t\tif (barometer.getHealth() == 0) {\n\t\t\tdepth_sensor_health = 0;\n\t\t}\n\t\telse if (barometer.getHealth() == 1) {\n\t\t\tdepth_sensor_health = 1;\n\t\t}\n\t\telse {\n\t\t\tdepth_sensor_health = 2;\n\t\t}\n\t}\n}", "CodeBleu_score": 56.022051510643486}, {"code": "void Sub::read_barometer(){\n\t    if (barometer.read_altitude()) {\n        if (barometer.get_altitude() > 0) {\n            if (barometer.is_calibrated()) {\n                barometer.calibrate();\n            }\n        }\n        if (depth_sensor.is_present()) {\n            if (barometer.is_healthy()) {\n                depth_sensor.set_health(true);\n            } else {\n                depth_sensor.set_health(false);\n            }\n        }\n    }\n}", "CodeBleu_score": 54.17380812147675}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    if (!inertial_nav.get_position(ekf_position)) {\n        return false;\n    }\n\n    if (!motors.armed()) {\n        return true;\n    }\n\n    if (ekf_position.flags.relative_position) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 42.01811594138357}, {"code": "bool Sub::ekf_position_ok(){\n\t    if (!inertial_nav.get_position_ok()) {\n        return false;\n    }\n    if (!motors.armed()) {\n        return true;\n    }\n    if (inertial_nav.get_ekf_origin_ok()) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 39.766692804008265}, {"code": "bool Sub::ekf_position_ok(){\n\t    return _ekf.position_ok();\n}", "CodeBleu_score": 10.01728104734774}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (control_mode_requires_position_velocity()) {\n        if (!AP_Arming_Base::gps_checks(display_failure)) {\n            return false;\n        }\n        if (!ahrs.healthy()) {\n            if (display_failure) {\n                gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"AHRS not ready\");\n            }\n            return false;\n        }\n        if (ahrs.get_ekf_status().flags.ekf_failsafe) {\n            if (display_failure) {\n                gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"EKF failsafe active\");\n            }\n            return false;\n        }\n        if (!ahrs.get_ekf_status().flags.position_valid) {\n            if (display_failure) {\n                gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Position estimate invalid\");\n            }\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 50.780996304472325}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (!_parent->control_mode_requires_gps()) {\n        return true;\n    }\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n    if (!_parent->ahrs.healthy()) {\n        if (display_failure) {\n            _parent->compass.set_healthy(false);\n        }\n        return false;\n    }\n    if (_parent->ekf.failsafe.ekf_failsafe) {\n        if (display_failure) {\n            _parent->compass.set_healthy(false);\n        }\n        return false;\n    }\n    if (!_parent->ekf.position_is_valid()) {\n        if (display_failure) {\n            _parent->compass.set_healthy(false);\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 49.49813970335042}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\n    if (control_mode == Rover::MODE_MANUAL) {\n        return true;\n    }\n\n    if (!AP_Arming_Plane::gps_checks(display_failure)) {\n        return false;\n    }\n\n    if (!_ahrs->initialised()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"AHRS not ready\n\"));\n        }\n        return false;\n    }\n\n    if (_ahrs->ekf_failsafe()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"EKF failsafe active\n\"));\n        }\n        return false;\n    }\n\n    if (!_ahrs->position_ok()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Position estimate invalid\n\"));\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 54.29508731827802}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\n    // record the arming method\n    _arming_method = method;\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are already armed\n    if (ap.land_complete) {\n        // we are", "CodeBleu_score": 24.342580334609607}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\n    // check if we are already armed\n    if (armed()) {\n        return true;\n    }\n\n    // check if we are already disarmed\n    if (disarmed()) {\n        return false;\n    }\n\n    // check if we are already in simple mode\n    if (simple()) {\n        return false;\n    }\n\n    // check if we are already in smart mode\n    if (smart()) {\n        return false;\n    }\n\n    // check if we are already in rtl mode\n    if (rtl()) {\n        return false;\n    }\n\n    // check if we are already in loiter mode\n    if (loiter()) {\n        return false;\n    }\n\n    // check if we are already in guided mode\n    if (guided()) {\n        return false;\n    }\n\n    // check if we are already in auto mode\n    if (auto_armed()) {\n        return false;\n    }\n\n    // check if we are already in manual mode\n    if (manual()) {\n        return false;\n    }\n\n    // check if we are already in failsafe mode\n    if (failsafe()) {\n        return false;\n    }\n\n    // check if we are already in takeoff mode\n    if (takeoff()) {\n        return false;\n    }\n\n    // check if we are already in land mode\n    if (land()) {\n        return false;\n    }\n\n    // check if we are already in hold mode\n    if (hold()) {\n        return false;\n    }\n\n    // check if we are already in auto-takeoff mode\n    if (auto_takeoff()) {\n        return false;\n    }\n\n    // check if we are already in auto-land mode\n    if (auto_land()) {\n        return false;\n    }\n\n    // check if we are already in auto-rtl mode\n    if (auto_rtl()) {\n        return false;\n    }\n\n    // check if we are already in auto-loiter mode\n    if (auto_loiter()) {\n        return false;\n    }\n\n    // check if we are already in auto-rtl", "CodeBleu_score": 14.857459266555034}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // if we are already armed, fail\n    if (armed()) {\n        return false;\n    }\n\n    // attempt to arm\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // set SmartRTL home location\n    if (smart_rtl.enabled()) {\n        smart_rtl.set_home();\n    }\n\n    // set simple mode heading\n    if (simple_mode.enabled()) {\n        simple_mode.set_heading();\n    }\n\n    // record home heading for sail vehicles\n    if (sail_mode.enabled()) {\n        sail_mode.set_home_heading();\n    }\n\n    // update soft armed status\n    if (soft_armed()) {\n        // we are soft armed\n        soft_armed_status = soft_armed_status_soft;\n    } else {\n        // we are not soft armed\n        soft_armed_status = soft_armed_status_none;\n    }\n\n    // send arm/disarm status text\n    if (soft_armed()) {\n        // we are soft armed\n        send_arm_disarm_status_text(arm_status_soft);\n    } else {\n        // we are not soft armed\n        send_arm_disarm_status_text(arm_status_normal);\n    }\n\n    // arming was successful\n    return true;\n}", "CodeBleu_score": 49.826119240494336}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (charging_enabled) {\n      // Do nothing\n    } else {\n      // Enable charging\n      charging_enabled = true;\n      charging_start_time = millis();\n    }\n  } else {\n    if (charging_enabled) {\n      // Disable charging\n      charging_enabled = false;\n      charging_stop_time = millis();\n    } else {\n      // Retry enabling charging\n      if (millis() - charging_stop_time > 10000) {\n        // Enable charging\n        charging_enabled = true;\n        charging_start_time = millis();\n      }\n    }\n  }\n}", "CodeBleu_score": 46.11784516457283}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (!charging_enabled) {\n      charging_enabled = true;\n      charging_start_time = millis();\n      charging_start_time_ms = millis();\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      charging_stop_time = millis();\n      charging_stop_time_ms = millis();\n    }\n    if (millis() - charging_stop_time_ms > 1000) {\n      charging_stop_time_ms = millis();\n      if (charging_enabled) {\n        charging_enabled = false;\n        charging_stop_time = millis();\n      }\n    }\n  }\n}", "CodeBleu_score": 46.35419526100179}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed && !charging_enabled) {\n    charging_enabled = true;\n    charging_start_time = millis();\n  } else if (!charging_allowed && charging_enabled) {\n    charging_enabled = false;\n    charging_stop_time = millis();\n    // TODO: add charging_stop_time to log\n  }\n}", "CodeBleu_score": 24.824950077904884}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t  if (size >= 4) {\n    uint32_t crc = FastCRC::CRC32().crc32(message, size);\n    memcpy((uint8_t *)message + size, &crc, sizeof(crc));\n    size += 4;\n  }\n  packetSerial.send(message, size);\n}", "CodeBleu_score": 39.97274613025564}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (size < 4) {\n        return;\n    }\n    uint8_t *data = (uint8_t *)message;\n    uint32_t crc = FastCRC32().crc(data, size);\n    data[size] = (crc >> 24) & 0xFF;\n    data[size + 1] = (crc >> 16) & 0xFF;\n    data[size + 2] = (crc >> 8) & 0xFF;\n    data[size + 3] = crc & 0xFF;\n    size += 4;\n    packetSerial.send(data, size);\n}", "CodeBleu_score": 66.20132809610044}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (size < 4) {\n        return;\n    }\n    uint8_t crc = 0;\n    uint8_t *data = (uint8_t *)message;\n    for (size_t i = 0; i < size; i++) {\n        crc = _crc_ibutton_update(crc, data[i]);\n    }\n    data[size] = crc;\n    packetSerial.send(data, size + 1);\n}", "CodeBleu_score": 52.888718098936195}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\tSerial.begin(9600);\n\twhile (!Serial);\n\tSerial.flush();\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tdelay(", "CodeBleu_score": 39.61798627374651}, {"code": "bool MP3Sound::begin(){\n\t  if (mp3_module.begin(9600)) {\n    mp3_module.flush();\n    mp3_module.write(0x7E);\n    mp3_module.write(0xFF);\n    mp3_module.write(0x06);\n    mp3_module.write(0x01);\n    mp3_module.write(0x01);\n    mp3_module.write(0xEF);\n    mp3_module.write(0x0A);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00);\n    mp3_module.write(0x00", "CodeBleu_score": 34.90187713450905}, {"code": "bool MP3Sound::begin(){\n\t  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB\n  }\n  delay(1000);\n  Serial.write(0x7E);\n  Serial.write(0xFF);\n  Serial.write(0x06);\n  Serial.write(0x01);\n  Serial.write(0x56);\n  Serial.write(0xAE);\n  Serial.write(0xC9);\n  Serial.write(0xBA);\n  Serial.write(0xBE);\n  Serial.write(0xD5);\n  Serial.write(0x2B);\n  Serial.write(0xDB);\n  Serial.write(0xAE);\n  Serial.write(0x8C);\n  Serial.write(0x82);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);", "CodeBleu_score": 28.648001663719857}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0 || isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\telse {\n\t\tint sound = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\tplaySound(sound);\n\t\treturn activeSounds.size();\n\t}\n}", "CodeBleu_score": 42.01009204595481}, {"code": "int MP3Sound::processSounds(){\n\t    int numSounds = 0;\n    if (activeSounds.size() > 0) {\n        if (isPlaying) {\n            numSounds = activeSounds.size();\n        } else {\n            MP3Sound *sound = activeSounds.back();\n            activeSounds.pop_back();\n            sound->play();\n            numSounds = activeSounds.size();\n        }\n    }\n    return numSounds;\n}", "CodeBleu_score": 45.164629176368955}, {"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\tstring sound = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplay(sound);\n\treturn activeSounds.size();\n}", "CodeBleu_score": 41.56776378791649}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *abstract_camera = d->pdata;\n  bool command_handled = false;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      int width, height, format;\n      int size = wb_request_read_uchar(r);\n      if (size == 0) {\n        wb_abstract_camera_cleanup_memory_mapped_file(abstract_camera);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar(r);\n        wb_request_read_uchar", "CodeBleu_score": 42.21065032689529}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      int size;\n      int width;\n      int height;\n      int refresh_rate;\n      int quality;\n      int channels;\n      int has_alpha;\n      int has_depth;\n      int has_recognition;\n      int has_segmentation;\n      int has_object_mask;\n      int has_object_id;\n      int has_object_label;\n      int has_object_model;\n      int has_object_scale;\n      int has_object_orientation;\n      int has_object_velocity;\n      int has_object_bbox_center;\n      int has_object_bbox_size;\n      int has_object_bbox_rotation;\n      int has_object_bbox_translation;\n      int has_object_bbox_local_rotation;\n      int has_object_bbox_local_translation;\n      int has_object_bbox_ref_node;\n      int has_object_bbox_center_local;\n      int has_object_bbox_size_local;\n      int has_object_bbox_rotation_local;\n      int has_object_bbox_translation_local;\n      int has_object_bbox_ref_node_local;\n      int has_object_bbox_local_translation_local;\n      int has_object_bbox_local_rotation_local;\n      int has_object_bbox_ref_node_local_translation;\n      int has_object_bbox_ref_node_local_rotation;\n      int has_object_bbox_ref_node_local_translation_local;\n      int has_object_bbox_ref_node_local_rotation_local;\n      int has_object_bbox_ref_node_local_translation_local_rotation;\n      int has_object_bbox_ref_node_local_translation_local_rotation_translation;\n      int has_object_bbox_ref_node_local_translation_local_rotation_translation", "CodeBleu_score": 24.474830080753744}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *camera = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      unsigned char request_type;\n      const char *request;\n      if (wb_robot_get_mode() == WB_MODE_REMOTE_CONTROL) {\n        request_type = wb_request_read_uchar(r);\n        request = wb_request_read_string(r);\n      } else {\n        request_type = wb_robot_get_request_data(r);\n        request = wb_robot_get_request_data(r);\n      }\n      if (request_type == CAMERA_MEMORY_MAPPED_FILE_REQUEST_SET) {\n        if (camera->memory_mapped_file)\n          munmap(camera->memory_mapped_file, camera->memory_mapped_file_size);\n        camera->memory_mapped_file = NULL;\n        camera->memory_mapped_file_size = 0;\n        if (request) {\n          camera->memory_mapped_file = mmap(NULL, camera->width * camera->height * 3, PROT_READ | PROT_WRITE, MAP_SHARED,\n                                            camera->file_descriptor, 0);\n          if (camera->memory_mapped_file == MAP_FAILED) {\n            fprintf(stderr, \"Error: %s\n\", strerror(errno));\n            return false;\n          }\n          camera->memory_mapped_file_size = camera->width * camera->height * 3;\n        }\n      } else if (request_type == CAMERA_MEMORY_MAPPED_FILE_REQUEST_GET) {\n        wb_request_write_uchar(r, camera->memory_mapped_file ? 1 : 0);\n      } else\n        fprintf(stderr, \"Error: %s\n\", \"Invalid request type for memory mapped file.\");\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 43.20950662839806}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  AbstractCamera *abstract_camera = d->pdata;\n  int height;\n  wb_robot_mutex_lock(abstract_camera->robot);\n  height = abstract_camera->height;\n  wb_robot_mutex_unlock(abstract_camera->robot);\n  return height;\n}", "CodeBleu_score": 45.62004977608894}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  AbstractCamera *abstract_camera = d->pdata;\n  int height;\n  wb_robot_mutex_lock(abstract_camera->robot);\n  if (abstract_camera->height == -1) {\n    wb_robot_mutex_unlock(abstract_camera->robot);\n    return -1;\n  }\n  height = abstract_camera->height;\n  wb_robot_mutex_unlock(abstract_camera->robot);\n  return height;\n}", "CodeBleu_score": 42.8895715608382}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  WbAbstractCamera *camera = d->pdata;\n  if (camera->height == -1) {\n    robot_mutex_lock_step();\n    camera->height = camera->height_get_from_device;\n    robot_mutex_unlock_step();\n  }\n  return camera->height;\n}", "CodeBleu_score": 49.97509618947052}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else {\n    sampling_period = 0;\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  }\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 53.57889278238173}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  WbDevice *d = wb_device_get_struct(tag);\n  if (d) {\n    if (d->node->type == WB_NODE_ACCELEROMETER) {\n      sampling_period = d->pdata->sampling_period;\n      return sampling_period;\n    } else {\n      fprintf(stderr, \"Error: %s() called for a non-ACCELEROMETER device.\n\", __FUNCTION__);\n      return 0;\n    }\n  } else {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    return 0;\n  }\n}", "CodeBleu_score": 50.87255202961445}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    sampling_period = 0;\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 47.942910714606626}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 39.37179132599584}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  int degrees;\n  int minutes;\n  double seconds;\n\n  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree, &degrees, &minutes, &seconds);\n  string result(dms);\n  free(dms);\n\n  return result;\n}", "CodeBleu_score": 41.76027868882052}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dmsString(dms);\n  free(dms);\n  return dmsString;\n}", "CodeBleu_score": 40.526162192779694}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  dAASSERT (g && g->type == dBoxClass);\n  dUASSERT (plane, \"argument is NULL\");\n  dVector3 center;\n  dGeomBoxGetCenter (g, center);\n  dVector3 relpos;\n  relpos[0] = x - center[0];\n  relpos[1] = y - center[1];\n  relpos[2] = z - center[2];\n  dReal dist = dFabs (relpos[0]) + dFabs (relpos[1]) + dFabs (relpos[2]);\n  dReal maxdist = ((dGeomBox*) g)->side[0] + ((dGeomBox*) g)->side[1] + ((dGeomBox*) g)->side[2];\n  dVector3 normal;\n  if (dist > maxdist) {\n    dVector3 vec;\n    vec[0] = dRecip (dFabs (relpos[0]));\n    vec[1] = dRecip (dFabs (relpos[1]));\n    vec[2] = dRecip (dFabs (relpos[2]));\n    dVector3Copy (relpos, normal);\n    dVector3Scale (normal, vec);\n  } else {\n    dVector3Copy (relpos, normal);\n  }\n  dVector3Copy (normal, plane);\n  plane[3] = -dDOT (normal, center);\n}", "CodeBleu_score": 37.215775766041084}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdAASSERT (g && g->type == dBoxClass);\n\tdUASSERT (plane, \"argument plane is NULL\");\n\n\tconst dReal *pos = dGeomGetPosition (g);\n\tconst dReal *R = dGeomGetRotation (g);\n\tconst dReal *side = dGeomBoxGetLengths (g);\n\n\tdVector3 p;\n\tp[0] = x - pos[0];\n\tp[1] = y - pos[1];\n\tp[2] = z - pos[2];\n\n\tdVector3 n;\n\tn[0] = R[0] * p[0] + R[1] * p[1] + R[2] * p[2];\n\tn[1] = R[4] * p[0] + R[5] * p[1] + R[6] * p[2];\n\tn[2] = R[8] * p[0] + R[9] * p[1] + R[10] * p[2];\n\n\tdReal d = 0;\n\tdReal min = REAL(1.0e30);\n\tint min_axis = -1;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tif (n[i] < -side[i]) {\n\t\t\td = -side[i] - n[i];\n\t\t\tif (d < min) {\n\t\t\t\tmin = d;\n\t\t\t\tmin_axis = i;\n\t\t\t}\n\t\t}\n\t\tif (n[i] > side[i]) {\n\t\t\td = side[i] - n[i];\n\t\t\tif (d < min) {\n\t\t\t\tmin = d;\n\t\t\t\tmin_axis = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (min_axis == 0) {\n\t\tplane[0] = -R[0];\n\t\tplane[1] = -R[1];\n\t\tplane[2] = -R[2];\n\t}\n\telse if (min_axis == ", "CodeBleu_score": 43.87527062933159}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dAASSERT (g && g->type == dBoxClass);\n    dUASSERT (plane, \"argument plane is NULL\");\n    dReal *pos = g->pos;\n    dReal *R = g->R;\n    dReal *side = g->box.side;\n    dReal px = x - pos[0];\n    dReal py = y - pos[1];\n    dReal pz = z - pos[2];\n    dReal nx = R[0] * px + R[1] * py + R[2] * pz;\n    dReal ny = R[4] * px + R[5] * py + R[6] * pz;\n    dReal nz = R[8] * px + R[9] * py + R[10] * pz;\n    dReal d = - (R[0] * pos[0] + R[1] * pos[1] + R[2] * pos[2]);\n    dReal dist = nx * side[0] + ny * side[1] + nz * side[2];\n    if (dist > 0) {\n        plane[0] = nx;\n        plane[1] = ny;\n        plane[2] = nz;\n        plane[3] = -(nx * pos[0] + ny * pos[1] + nz * pos[2]) + d;\n    } else if (dFabs (nx) > side[0]) {\n        plane[0] = 0;\n        plane[1] = ny;\n        plane[2] = nz;\n        plane[3] = -(ny * pos[1] + nz * pos[2]) + d;\n    } else if (dFabs (ny) > side[1]) {\n        plane[0] = nx;\n        plane[1] = 0;\n        plane[2] = nz;\n        plane[3] = -(nx * pos[0] + nz * pos[2]) + d;\n    } else {\n        plane[0] = nx;\n        plane[1] = ny;\n        plane[2] = 0;\n        plane", "CodeBleu_score": 41.972558443038025}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n   // check the box\n   dUASSERT (box && box->body && (box->flags & ROTATIONAL_FLAGS) == 0,\n         \"invalid box\");\n\n   // initialize the immersion data\n   sBoxImmersionData data;\n   data.box = box;\n   data.fluidPlane = fluidPlane;\n   data.flags = flags;\n   data.immersion = immersion;\n\n   // perform the immersion checking\n   return dImmerseBox (&data);\n}", "CodeBleu_score": 47.32013351346397}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n   dAASSERT (box);\n   dAASSERT (box->body);\n   dAASSERT ((flags & (~(dIMMERSE_BOX_IMPENETRABLE | dIMMERSE_BOX_STABILIZE))) == 0);\n\n   sBoxImmersionData data;\n   data.box = box;\n   data.fluidPlane = fluidPlane;\n   data.flags = flags;\n   data.immersion = immersion;\n\n   return dImmerseBox (&data);\n}", "CodeBleu_score": 46.925773006324185}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n  dAASSERT (box);\n  dAASSERT (box->body);\n  dAASSERT ((flags & (dIMMERSE_BOX_BODY|dIMMERSE_BOX_FLUID_PLANE)) == (dIMMERSE_BOX_BODY|dIMMERSE_BOX_FLUID_PLANE));\n\n  sBoxImmersionData data;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.immersion = immersion;\n  data.flags = flags;\n\n  return dImmerseBox_r (&data);\n}", "CodeBleu_score": 45.99014405947368}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n    dIASSERT (immersion != nullptr);\n    dIASSERT (immersion->m_iFlags == 0);\n    dIASSERT ((flags & NUMI_MASK) >= 1);\n\n    if (o1->type != dBoxClass) {\n        dUASSERT (o1->type == dBoxClass, \"argument 1 must be a box\");\n        return 0;\n    }\n\n    if (o2->type != dCapsuleClass) {\n        dUASSERT (o2->type == dCapsuleClass, \"argument 2 must be a capsule\");\n        return 0;\n    }\n\n    dxBox *box = (dxBox *) o1;\n    dxCapsule *capsule = (dxCapsule *) o2;\n\n    const dReal *box_pos = dGeomGetPosition (o1);\n    const dReal *box_R = dGeomGetRotation (o1);\n\n    const dReal *capsule_pos = dGeomGetPosition (o2);\n    const dReal *capsule_R = dGeomGetRotation (o2);\n\n    const dReal *capsule_axis = capsule->final_posr->R + 2;\n\n    dVector3 box_pos_local;\n    dVector3 capsule_pos_local;\n\n    dMultiply0_331 (box_pos_local, box_R, box_pos);\n    dMultiply0_331 (capsule_pos_local, capsule_R, capsule_pos);\n\n    dVector3 box_pos_local_offset;\n    dVector3 capsule_pos_local_offset;\n\n    dVector3 box_pos_local_offset_2;\n    dVector3 capsule_pos_local_offset_2;\n\n    dVector3 box_pos_local_offset_3;\n    dVector3 capsule_pos_local_offset_3;\n\n    dVector3 box_pos_local_offset_4;\n    dVector3 capsule_pos_local_offset_4;\n\n    dVector3 box_pos", "CodeBleu_score": 45.615375613885625}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (immersion != 0);\n\tdIASSERT (immersion->box != 0);\n\tdIASSERT (immersion->capsule != 0);\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdIASSERT ((flags & NUMI_MASK) <= 2);\n\tdIASSERT (flags & (IMMERSION_BOX | IMMERSION_CAPSULE));\n\tdIASSERT (flags & (IMMERSION_OUTLINE_BOX | IMMERSION_OUTLINE_CAPSULE));\n\n\t// Validate the input arguments\n\tif (dGeomGetClass (o1) != dBoxClass) {\n\t\tdDebug (d_ERR_IMMERSION_INVALID_GEOM, \"dImmerseBoxCapsule: first argument is not a box\");\n\t\treturn 0;\n\t}\n\tif (dGeomGetClass (o2) != dCapsuleClass) {\n\t\tdDebug (d_ERR_IMMERSION_INVALID_GEOM, \"dImmerseBoxCapsule: second argument is not a capsule\");\n\t\treturn 0;\n\t}\n\n\t// Retrieve the box and capsule data\n\tdxBox *b = (dxBox *) o1;\n\tdxCapsule *c = (dxCapsule *) o2;\n\tdReal radius = c->radius;\n\tdReal length = c->lz;\n\tdVector3 sides = {b->side[0], b->side[1], b->side[2]};\n\tdVector3 center = {b->final_posr->pos[0], b->final_posr->pos[1], b->final_posr->pos[2]};\n\tdMatrix3 R = {b->final_posr->R[0], b->final_posr->R[1], b->final_posr->R[2], b->final_posr->R[3], b->final_posr->R[4], b->final_posr->R[5], b->final_posr->R[6], b->", "CodeBleu_score": 43.15475254125977}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (immersion);\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdIASSERT ((flags & NUMJ_MASK) >= 1);\n\n\tdxBox *b = (dxBox *) o1;\n\tdxCapsule *c = (dxCapsule *) o2;\n\n\tdVector3 sides = {b->side[0], b->side[1], b->side[2]};\n\tdVector3 r = {c->radius, c->radius, c->radius};\n\tdVector3 p1 = {c->final_posr->pos[0] + c->final_posr->R[2] * c->lz, c->final_posr->pos[1] + c->final_posr->R[6] * c->lz, c->final_posr->pos[2] + c->final_posr->R[10] * c->lz};\n\tdVector3 p2 = {c->final_posr->pos[0] - c->final_posr->R[2] * c->lz, c->final_posr->pos[1] - c->final_posr->R[6] * c->lz, c->final_posr->pos[2] - c->final_posr->R[10] * c->lz};\n\n\tdVector3 center, normal;\n\tdReal depth;\n\n\tif (dCollideBoxCapsule (b->final_posr->pos, b->final_posr->R, sides, r, p1, p2, &center, &normal, &depth, 1)) {\n\t\tdVector3 offset = {center[0] - b->final_posr->pos[0], center[1] - b->final_posr->pos[1], center[2] - b->final_posr->pos[2]};\n\n\t\timmersion->depth = depth;\n\t\timmersion->normal[0] = normal[0];\n\t\timmersion->normal[1] = normal[1];\n\t\timmersion->normal[2] = normal[2];\n\t\timmersion->", "CodeBleu_score": 39.97216656782908}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\n\tdReal volume = 0.0;\n\n\tdReal theta0 = atan(tanTheta0);\n\tdReal theta1 = atan(sinTheta1);\n\n\tdReal zI = zIOverR * m_radius;\n\n\tdReal z0 = zI * cos(theta0);\n\tdReal z1 = zI * cos(theta1);\n\n\tdReal sinTheta0 = sin(theta0);\n\tdReal sinTheta1 = sin(theta1);\n\n\tdReal sinTheta0Sqr = sinTheta0 * sinTheta0;\n\tdReal sinTheta1Sqr = sinTheta1 * sinTheta1;\n\n\tdReal sinTheta0SqrSqr = sinTheta0Sqr * sinTheta0Sqr;\n\tdReal sinTheta1SqrSqr = sinTheta1Sqr * sinTheta1Sqr;\n\n\tdReal cosTheta0Sqr = 1.0 - sinTheta0Sqr;\n\tdReal cosTheta1Sqr = 1.0 - sinTheta1Sqr;\n\n\tdReal cosTheta0SqrSqr = cosTheta0Sqr * cosTheta0Sqr;\n\tdReal cosTheta1SqrSqr = cosTheta1Sqr * cosTheta1Sqr;\n\n\tdReal cosTheta0 = sqrt(cosTheta0Sqr);\n\tdReal cosTheta1 = sqrt(cosTheta1Sqr);\n\n\tdReal cosTheta0SqrSqrCubed = cosTheta0SqrSqr * cosTheta0Sqr;\n\tdReal cosTheta1SqrSqrCubed = cosTheta1SqrSqr * cosTheta1Sqr;\n\n\tdReal sinTheta0SqrCubed = sinTheta0Sqr * sinTheta0Sqr;\n\tdReal sinTheta1SqrCubed = sinTheta1Sqr * sinTheta1Sqr;\n\n\tdReal cosTheta0SqrCubed = cosTheta0Sqr * cosTheta0Sqr;\n\td", "CodeBleu_score": 37.95545453482521}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tconst dReal zI = zIOverR * m_radius;\n\n\tconst dReal tanTheta02 = tanTheta0 * tanTheta0;\n\tconst dReal tanTheta03 = tanTheta02 * tanTheta0;\n\tconst dReal tanTheta04 = tanTheta03 * tanTheta0;\n\n\tconst dReal sinTheta12 = sinTheta1 * sinTheta1;\n\tconst dReal sinTheta13 = sinTheta12 * sinTheta1;\n\tconst dReal sinTheta14 = sinTheta13 * sinTheta1;\n\n\tconst dReal cosTheta0 = dSqrt(dFabs(1.0 - tanTheta02));\n\tconst dReal cosTheta1 = dSqrt(dFabs(1.0 - sinTheta12));\n\n\tconst dReal cosTheta02 = cosTheta0 * cosTheta0;\n\tconst dReal cosTheta03 = cosTheta02 * cosTheta0;\n\tconst dReal cosTheta04 = cosTheta03 * cosTheta0;\n\n\tconst dReal cosTheta12 = cosTheta1 * cosTheta1;\n\tconst dReal cosTheta13 = cosTheta12 * cosTheta1;\n\tconst dReal cosTheta14 = cosTheta13 * cosTheta1;\n\n\tconst dReal sinTheta0 = dSqrt(dFabs(1.0 - cosTheta02));\n\tconst dReal sinTheta1 = dSqrt(dFabs(1.0 - cosTheta12));\n\n\tconst dReal sinTheta02 = sinTheta0 * sinTheta0;\n\tconst dReal sinTheta03 = sinTheta02 * sinTheta0;\n\tconst dReal sinTheta04 = sinTheta03 * sinTheta0;\n\n\tconst dReal sinTheta12 = sinTheta1 * sinTheta1;\n\tconst dReal sinTheta13 = sinTheta12 * sinTheta1;\n\tconst dReal sinTheta14 = sinTheta13 * sinTheta1;\n\n\tconst dReal sinTheta0cosTheta0 = sinTheta0 * cosTheta0;\n\tconst dReal sinTheta0cosTheta02 = sinTheta0cosTheta0 * sinTheta0", "CodeBleu_score": 37.00293577530269}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\n    dReal sinTheta0 = dSqrt(1.0 - zIOverR * zIOverR);\n\n    dReal cosTheta0 = zIOverR;\n\n    dReal cosTheta1 = sinTheta1 / zIOverR;\n\n    dReal tanTheta1 = tanTheta0 * cosTheta1;\n\n    dReal sinTheta2 = sinTheta1 * cosTheta1;\n\n    dReal cosTheta2 = dSqrt(1.0 - sinTheta2 * sinTheta2);\n\n    dReal tanTheta2 = tanTheta0 * cosTheta2;\n\n    dReal sinTheta3 = sinTheta2 * cosTheta2;\n\n    dReal cosTheta3 = dSqrt(1.0 - sinTheta3 * sinTheta3);\n\n    dReal tanTheta3 = tanTheta0 * cosTheta3;\n\n    dReal sinTheta4 = sinTheta3 * cosTheta3;\n\n    dReal cosTheta4 = dSqrt(1.0 - sinTheta4 * sinTheta4);\n\n    dReal tanTheta4 = tanTheta0 * cosTheta4;\n\n    dReal sinTheta5 = sinTheta4 * cosTheta4;\n\n    dReal cosTheta5 = dSqrt(1.0 - sinTheta5 * sinTheta5);\n\n    dReal tanTheta5 = tanTheta0 * cosTheta5;\n\n    dReal sinTheta6 = sinTheta5 * cosTheta5;\n\n    dReal cosTheta6 = dSqrt(1.0 - sinTheta6 * sinTheta6);\n\n    dReal tanTheta6 = tanTheta0 * cosTheta6;\n\n    dReal sinTheta7 = sinTheta6 * cosTheta6;\n\n    dReal cosTheta7 = dSqrt(1.0 - sinTheta7 * sinTheta7);\n\n    dReal tanTheta7 = tanTheta0 * cosTheta7;\n\n    dReal sinTheta8 = sinTheta7 * cosTheta7;\n\n    dReal cosTheta8 = dSqrt(1.0 - sinTheta8 * sinTheta8);\n\n    dReal tanTheta8 = tanTheta0 * cosTheta8;\n\n    dReal sinTheta9 = sinTheta8 * cosTheta8", "CodeBleu_score": 36.116541154230276}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    const dReal oneThird = 1.0 / 3.0;\n    const dReal twoThirds = 2.0 / 3.0;\n    const dReal oneSixth = 1.0 / 6.0;\n    const dReal oneTwelfth = 1.0 / 12.0;\n    const dReal twoTwelfths = 2.0 / 12.0;\n    const dReal oneFourth = 1.0 / 4.0;\n    const dReal oneEighth = 1.0 / 8.0;\n    const dReal oneSixteenth = 1.0 / 16.0;\n    const dReal twoSixteenths = 2.0 / 16.0;\n    const dReal oneThirtysecond = 1.0 / 32.0;\n    const dReal twoThirtyseconds = 2.0 / 32.0;\n    const dReal oneSixtyfourth = 1.0 / 64.0;\n    const dReal twoSixtyfourths = 2.0 / 64.0;\n    const dReal oneOnehundredtwentyeighth = 1.0 / 128.0;\n    const dReal twoOnehundredtwentyeighths = 2.0 / 128.0;\n    const dReal oneTwohundredfiftysixth = 1.0 / 256.0;\n    const dReal twoTwohundredfiftysixths = 2.0 / 256.0;\n    const dReal oneFivehundredtwentyeighth = 1.0 / 512.0;\n    const dReal twoFivehundredtwentyeighths = 2.0 / 512.0;\n    const dReal oneThousandtwentyfourth = 1.0 / 1024.0;\n    const dReal twoThousandtwentyfourths = 2.0 / 1024.0;\n    const dReal oneTwohundredfiftysixthOverSixteenth = oneTwohundredf", "CodeBleu_score": 11.480511749857364}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  dReal xBuoyancyCenter;\n  dReal x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63, x64, x65, x66, x67, x68, x69, x70, x71, x72, x73, x74, x75, x76, x77, x78, x79, x80, x81, x82, x83, x84, x85, x86, x87, x88, x89, x90, x91, x92, x93, x94, x95, x96, x97, x98, x99, x100, x101, x102, x103, x104, x105, x106, x107, x108, x109, x110, x111, x112, x113, x114, x115, x116, x117, x118, x119, x120, x121", "CodeBleu_score": 9.389044261182217}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    dReal x;\n\n    // If the hemisphere is entirely immersed, the buoyancy center is the center of the hemisphere.\n    if (zIOverR >= 1.0) {\n        x = 0.0;\n    }\n    else {\n        // Calculate the x-coordinate of the buoyancy center for the immersed hemisphere using Simpson's rule.\n        dReal x0 = 0.0;\n        dReal x1 = 0.0;\n        dReal x2 = 0.0;\n        dReal x3 = 0.0;\n        dReal x4 = 0.0;\n        dReal x5 = 0.0;\n        dReal x6 = 0.0;\n        dReal x7 = 0.0;\n        dReal x8 = 0.0;\n        dReal x9 = 0.0;\n        dReal x10 = 0.0;\n        dReal x11 = 0.0;\n        dReal x12 = 0.0;\n        dReal x13 = 0.0;\n        dReal x14 = 0.0;\n        dReal x15 = 0.0;\n        dReal x16 = 0.0;\n        dReal x17 = 0.0;\n        dReal x18 = 0.0;\n        dReal x19 = 0.0;\n        dReal x20 = 0.0;\n        dReal x21 = 0.0;\n        dReal x22 = 0.0;\n        dReal x23 = 0.0;\n        dReal x24 = 0.0;\n        dReal x25 = 0.0;\n        dReal x26 = 0.0;\n        dReal x27 = 0.0;\n        dReal x28 = 0.0;\n        dReal x29 = 0.0;\n        dReal x30 = 0.0;\n        dReal x31 = 0.0;\n        dReal x32 = 0.", "CodeBleu_score": 17.580151850243407}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n\tdIASSERT (immersion);\n\tdIASSERT (immersion->immersionType == dImmersionCapsuleTrimesh);\n\n\tdReal radius = REAL(0.5) * ((dxCapsule *) o1)->radius;\n\tdReal depth = ((dxCapsule *) o1)->lz - radius;\n\n\tdReal r2 = radius * radius;\n\tdReal r3 = r2 * radius;\n\tdReal r5 = r3 * r2;\n\tdReal r7 = r5 * r2;\n\n\tdReal *vertex = (dReal *) ((dxTriMesh *) o2)->Points;\n\tdReal *normal = (dReal *) ((dxTriMesh *) o2)->Normals;\n\tint *index = ((dxTriMesh *) o2)->Triangles;\n\n\tdReal *vertex1 = (dReal *) ((dxCapsule *) o1)->final_posr->pos;\n\tdReal *normal1 = (dReal *) ((dxCapsule *) o1)->final_posr->R;\n\n\tdReal x1 = vertex1[0];\n\tdReal y1 = vertex1[1];\n\tdReal z1 = vertex1[2];\n\n\tdReal x2 = vertex1[0] + radius * normal1[0];\n\tdReal y2 = vertex1[1] + radius * normal1[4];\n\tdReal z2 = vertex1[2] + radius * normal1[8];\n\n\tdReal x3 = vertex1[0] + radius * normal1[1];\n\tdReal y3 = vertex1[1] + radius * normal1[5];\n\tdReal z3 = vertex1[2] + radius * normal1[9];\n\n\tdReal x4 = vertex1[0] + radius * normal1[2];\n\tdReal y4 = vertex1[1] + radius * normal1[6];\n\tdReal z4 = vertex1[2] + radius * normal1[10];\n\n\tdReal x5 = vertex1[0] + radius * normal1[3];\n\tdReal y5 = vertex1[1] + radius *", "CodeBleu_score": 32.567129708405844}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n\n\n  dIASSERT (o1->type == dCapsuleClass);\n  dIASSERT (o2->type == dTriMeshClass);\n\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n\n  dIASSERT ((flags & IMMERSION_BOUNDARY_EDGE) || (flags & IMMERSION_BOUNDARY_VERTEX));\n\n  dIASSERT (immersion);\n\n\n\n  dxCapsule *capsule = (dxCapsule *) o1;\n\n  dxTriMesh *trimesh = (dxTriMesh *) o2;\n\n\n\n  dVector3 *vertices = (dVector3 *) trimesh->Points;\n\n  dVector3 *normals = (dVector3 *) trimesh->Normals;\n\n\n\n  dReal radius = capsule->radius;\n\n  dReal length = capsule->lz;\n\n\n\n  dReal *d = immersion->depths;\n\n  dReal *x = immersion->x;\n\n\n\n  dReal *A = immersion->A;\n\n  dReal *B = immersion->B;\n\n\n\n  dReal *u = immersion->u;\n\n  dReal *v = immersion->v;\n\n  dReal *w = immersion->w;\n\n\n\n  dReal *N = immersion->N;\n\n  dReal *n = immersion->n;\n\n\n\n  dReal *buoyancy_center = immersion->buoyancy_center;\n\n\n\n  dReal *volume = immersion->volume;\n\n\n\n  dReal *radius_sum = immersion->radius_sum;\n\n  dReal *radius_sum_squared = immersion->radius_sum_squared;\n\n\n\n  dReal *radius_sum_cubed = immersion->radius_sum_cubed;\n\n\n\n  dReal *radius_sum_fourth = immersion->radius_sum_fourth;\n\n\n\n  dReal *radius_sum_sixth = immersion->radius_sum_sixth;\n\n\n\n", "CodeBleu_score": 38.78340612220732}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n\n\tdIASSERT (immersion);\n\n\n\tdIASSERT (immersion->immersionData);\n\n\n\tdIASSERT (immersion->immersionData->immersionType == dImmersionCapsule);\n\n\n\tdIASSERT (immersion->immersionData->immersionType == dImmersionCapsule);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData->revolutionData);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData->revolutionData->type == dRevolutionCylinder);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData->revolutionData->cylinderRevolutionData);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData->revolutionData->cylinderRevolutionData->cylinder);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData->revolutionData->cylinderRevolutionData->cylinder->type == dCylinderClass);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData->revolutionData->cylinderRevolutionData->cylinder->c);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData->revolutionData->cylinderRevolutionData->cylinder->c->geom.g);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData->revolutionData->cylinderRevolutionData->cylinder->c->geom.g->type == dCylinderClass);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData->revolutionData->cylinderRevolutionData->cylinder->c->geom.g->c);\n\n\n\tdIASSERT (immersion->immersionData->capsuleImmersionData->revolutionData->cyl", "CodeBleu_score": 23.32471136315065}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t    std::chrono::milliseconds duration = getInput<std::chrono::milliseconds>(\"duration\");\n    if( duration <= std::chrono::milliseconds(0) )\n    {\n        return NodeStatus::SUCCESS;\n    }\n    else\n    {\n        timer_.start(duration);\n        timer_waiting_ = true;\n        return NodeStatus::RUNNING;\n    }\n}", "CodeBleu_score": 28.64451337643571}, {"code": "NodeStatus SleepNode::onStart(){\n\t    if (getInput(\"milliseconds\", milliseconds_)) {\n        if (milliseconds_ <= 0) {\n            return NodeStatus::SUCCESS;\n        }\n\n        setStatus(NodeStatus::RUNNING);\n        timer_waiting_ = true;\n        timer_ = std::make_shared<ros::WallTimer>(\n            getNodeHandle().createWallTimer(\n                ros::WallDuration(milliseconds_ / 1000.0),\n                &SleepNode::timerCallback, this, true, false));\n\n        return NodeStatus::RUNNING;\n    }\n\n    return NodeStatus::SUCCESS;\n}", "CodeBleu_score": 45.79182824325046}, {"code": "NodeStatus SleepNode::onStart(){\n\t    // The node status is set to RUNNING,\n    // a timer is started and a callback is set to wake up the node\n    // when the timer expires\n    if( getInput<int>(\"milliseconds\", milliseconds_) <= 0 )\n    {\n        // the duration is missing or non-positive, return SUCCESS\n        return NodeStatus::SUCCESS;\n    }\n    else\n    {\n        // the duration is valid, set the node status to RUNNING\n        // and start the timer\n        setStatus( NodeStatus::RUNNING );\n        timer_.start( milliseconds_, std::bind( &SleepNode::onTimerExpire, this ) );\n        return NodeStatus::RUNNING;\n    }\n}", "CodeBleu_score": 26.712704264220893}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    auto entry = getInput<Blackboard::Entry>(getInputTick(), \"entry\");\n    if(entry) {\n        if(entry->sequence_id != sequence_id) {\n            entry->lock();\n            sequence_id = entry->sequence_id;\n            entry->unlock();\n            return NodeStatus::SUCCESS;\n        }\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 35.18974198477199}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    std::string entry_name = getInput<std::string>(\"entry_name\", \"\");\n\n    if (entry_name.empty())\n    {\n        throw RuntimeError(\"EntryUpdatedAction: entry_name must be set\");\n    }\n\n    auto entry = getInput<Blackboard::Ptr>(\"blackboard\")->getEntry(entry_name);\n\n    if (!entry)\n    {\n        return NodeStatus::FAILURE;\n    }\n\n    std::unique_lock<std::recursive_mutex> lock(entry->mutex);\n\n    if (entry->sequence_id != last_sequence_id)\n    {\n        last_sequence_id = entry->sequence_id;\n        return NodeStatus::SUCCESS;\n    }\n\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 47.265642172108926}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    std::string entry_name = getInput<std::string>(\"entry\");\n    int sequence_id = getInput<int>(\"sequence_id\");\n\n    // retrieve the entry and lock its mutex\n    auto entry = getInput<Blackboard::Ptr>(\"blackboard\")->getEntry(entry_name);\n    if(entry == nullptr)\n    {\n        return NodeStatus::FAILURE;\n    }\n\n    std::unique_lock<std::mutex> lock(entry->mutex);\n    if(entry->sequence_id == sequence_id)\n    {\n        return NodeStatus::FAILURE;\n    }\n    else\n    {\n        entry->sequence_id = sequence_id;\n        return NodeStatus::SUCCESS;\n    }\n}", "CodeBleu_score": 49.66542940000812}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return std::max(0, static_cast<int>(children_nodes_.size()) + success_threshold_);\n    } else {\n        return success_threshold_;\n    }\n}", "CodeBleu_score": 61.32676461698223}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return (size_t) (-success_threshold_ + children_nodes_.size());\n    } else {\n        return (size_t) success_threshold_;\n    }\n}", "CodeBleu_score": 59.98015094831668}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    size_t threshold = static_cast<size_t>(-success_threshold_);\n    if (threshold < children_nodes_.size()) {\n        threshold = children_nodes_.size();\n    }\n    return threshold;\n}", "CodeBleu_score": 46.44792843836606}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (!heartbeat_thread_stop_requested) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        auto now = std::chrono::system_clock::now();\n        auto now_ms = std::chrono::time_point_cast<std::chrono::milliseconds>(now);\n        auto now_ms_time_t = std::chrono::system_clock::to_time_t(now_ms);\n\n        std::lock_guard<std::mutex> lock(heartbeat_mutex);\n        for (auto& it : heartbeat_map) {\n            auto& heartbeat_time = it.second;\n            if (heartbeat_time == 0) {\n                continue;\n            }\n            auto heartbeat_time_ms = std::chrono::system_clock::from_time_t(heartbeat_time);\n            auto heartbeat_time_ms_time_t = std::chrono::system_clock::to_time_t(heartbeat_time_ms);\n            if (now_ms_time_t > heartbeat_time_ms_time_t) {\n                heartbeat_time = 0;\n                if (it.first == 0) {\n                    // heartbeat for the server\n                    enable_breakpoints = false;\n                }\n                else {\n                    // heartbeat for a breakpoint\n                    auto& bp_info = breakpoint_map[it.first];\n                    bp_info.enabled = false;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 43.12926130517133}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while(true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n        // If the heartbeat is still active, do nothing.\n        if (isHeartbeatActive()) {\n            continue;\n        }\n\n        // If the heartbeat is not active, disable all breakpoints.\n        for (auto& breakpoint : breakpoints_) {\n            breakpoint.second.enabled = false;\n        }\n\n        // If the heartbeat is not active, enable all breakpoints.\n        for (auto& breakpoint : breakpoints_) {\n            breakpoint.second.enabled = true;\n        }\n    }\n}", "CodeBleu_score": 34.154405423321975}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while(true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n        std::lock_guard<std::mutex> lock(heartbeat_mutex);\n\n        if(heartbeat_active) {\n            if(std::chrono::steady_clock::now() - heartbeat_timestamp > std::chrono::seconds(1)) {\n                heartbeat_active = false;\n                disableBreakpoints();\n            }\n        }\n        else {\n            if(std::chrono::steady_clock::now() - heartbeat_timestamp < std::chrono::seconds(1)) {\n                heartbeat_active = true;\n                enableBreakpoints();\n            }\n        }\n    }\n}", "CodeBleu_score": 38.11314798723759}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> result;\n    std::vector<std::string> bb_names;\n    split(bb_list, bb_names, \",\");\n\n    for (const auto& bb_name : bb_names) {\n        auto bb_it = blackboards_.find(bb_name);\n        if (bb_it != blackboards_.end()) {\n            auto subtree_ptr = bb_it->second.getSubtree();\n            if (subtree_ptr != nullptr) {\n                std::string json_dump;\n                subtree_ptr->blackboard()->toJson(json_dump);\n                result.insert(result.end(), json_dump.begin(), json_dump.end());\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 49.39068264975832}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\n    std::vector<uint8_t> msgpack_data;\n\n    std::vector<std::string> blackboard_list;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    while (std::getline(ss, bb_name, ',')) {\n        blackboard_list.push_back(bb_name);\n    }\n\n    for (const auto& bb_name : blackboard_list) {\n        auto subtree = tree_ptr_->getSubtree(bb_name);\n        if (subtree != nullptr) {\n            std::lock_guard<std::mutex> lock(subtree->blackboard_mutex_);\n            auto blackboard_data = subtree->blackboard_.toJson();\n            msgpack_data.insert(msgpack_data.end(), blackboard_data.begin(), blackboard_data.end());\n        }\n    }\n\n    return msgpack_data;\n}", "CodeBleu_score": 44.2558903487657}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> msgpack_buffer;\n    std::stringstream ss;\n    ss << \"[\" << bb_list << \"]\";\n    std::vector<std::string> bb_names;\n    try {\n        bb_names = XMLParser::splitString(ss.str(), ',');\n    }\n    catch (const std::exception& ex) {\n        std::cerr << \"Error: \" << ex.what() << std::endl;\n        return msgpack_buffer;\n    }\n    for (const std::string& bb_name : bb_names) {\n        std::string bb_content;\n        TreeNode* bb_node = root_node_->getBlackboard()->findSubtree(bb_name);\n        if (bb_node != nullptr) {\n            bb_node->lock();\n            bb_content = bb_node->getBlackboard()->toJSON();\n            bb_node->unlock();\n            if (bb_content.size() > 0) {\n                msgpack_buffer.insert(msgpack_buffer.end(), bb_content.begin(), bb_content.end());\n            }\n        }\n    }\n    return msgpack_buffer;\n}", "CodeBleu_score": 43.73708008766053}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::lock_guard<std::mutex> lock(this->mutex_);\n\n  auto it = this->nodes_.find(node_uid);\n  if (it == this->nodes_.end()) {\n    return false;\n  }\n\n  auto& node = it->second;\n  if (node.pos != pos) {\n    return false;\n  }\n\n  auto& hook = node.hook;\n  if (hook == nullptr) {\n    return false;\n  }\n\n  std::lock_guard<std::mutex> hook_lock(hook->mutex_);\n  if (hook->mode != Groot2Hook::BREAKPOINT) {\n    return false;\n  }\n\n  hook->mode = Groot2Hook::NONE;\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->cond_.notify_all();\n\n  return true;\n}", "CodeBleu_score": 53.17417319989646}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t    auto it = hooks_.find(node_uid);\n    if (it == hooks_.end()) {\n        return false;\n    }\n    auto& hook = it->second;\n    std::lock_guard<std::mutex> lock(hook.mutex);\n    if (hook.status != BREAKPOINT) {\n        return false;\n    }\n    hook.status = result;\n    hook.remove = remove;\n    hook.ready = true;\n    hook.cv.notify_all();\n    return true;\n}", "CodeBleu_score": 44.58389747403801}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto it = hooks.find(node_uid);\n  if (it == hooks.end()) {\n    return false;\n  }\n  auto& hook = it->second;\n  std::lock_guard<std::mutex> lock(hook.mutex);\n  if (hook.mode != Mode::BREAKPOINT) {\n    return false;\n  }\n  hook.status = result;\n  hook.remove = remove;\n  hook.ready = true;\n  hook.cond.notify_all();\n  return true;\n}", "CodeBleu_score": 43.20120736553121}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    if (status() != NodeStatus::IDLE) {\n        throw RuntimeError(\"A ThreadedAction node must be IDLE before executing a new tick\");\n    }\n\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_ = false;\n\n    std::thread([this] {\n        try {\n            tickHandler();\n            if (halt_requested_) {\n                setStatus(NodeStatus::HALTED);\n            } else {\n                setStatus(NodeStatus::SUCCESS);\n            }\n        } catch (const std::exception &ex) {\n            setStatus(NodeStatus::FAILURE);\n            throw ex;\n        }\n    }).detach();\n\n    return status();\n}", "CodeBleu_score": 34.027224858146624}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    // Check if the node has already been running\n    if (status() != NodeStatus::IDLE) {\n        throw std::runtime_error(\"A ThreadedAction node must be in IDLE state before ticking\");\n    }\n\n    // Set the status to RUNNING and start the thread\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_ = false;\n    std::thread t(&BT::ThreadedAction::tick, this);\n    t.detach();\n\n    // Return the current status\n    return status();\n}", "CodeBleu_score": 18.361858624895174}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  // Check if the thread is still running.\n  if (thread_ && thread_->joinable()) {\n    // Check if the thread has finished.\n    if (thread_->try_join_for(std::chrono::milliseconds(0))) {\n      // Thread has finished.\n      // Check if an exception was thrown.\n      if (exception_ptr_) {\n        // Throw the exception.\n        std::rethrow_exception(exception_ptr_);\n      }\n\n      // Reset the thread pointer.\n      thread_.reset();\n\n      // Check if the tick function completed successfully.\n      if (status_ == NodeStatus::RUNNING) {\n        // The tick function completed successfully.\n        // Set the status to SUCCESS.\n        setStatus(NodeStatus::SUCCESS);\n      } else {\n        // The tick function did not complete successfully.\n        // Set the status to FAILURE.\n        setStatus(NodeStatus::FAILURE);\n      }\n    }\n  } else {\n    // Thread is not running.\n    // Check if the status is IDLE.\n    if (getStatus() == NodeStatus::IDLE) {\n      // Status is IDLE.\n      // Set the status to RUNNING.\n      setStatus(NodeStatus::RUNNING);\n\n      // Reset the halt request flag.\n      halt_requested_ = false;\n\n      // Start a new thread.\n      thread_ = std::make_unique<std::thread>(&ThreadedAction::tickHandler, this);\n    }\n  }\n\n  return getStatus();\n}", "CodeBleu_score": 39.603995621152926}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    const std::string indent_str = \"  \";\n\n    const auto print_tree_recursively = [&](const TreeNode* node, int depth) {\n        for( int i = 0; i < depth; ++i ) {\n            stream << indent_str;\n        }\n        stream << node->name() << std::endl;\n\n        if( node->type() == NodeType::CONTROL ) {\n            for( const auto& child : node->children() ) {\n                print_tree_recursively( child.get(), depth+1 );\n            }\n        }\n        else if( node->type() == NodeType::DECORATOR ) {\n            print_tree_recursively( node->child().get(), depth+1 );\n        }\n    };\n\n    stream << \"----------------------------------------\" << std::endl;\n    print_tree_recursively( root_node, 0 );\n    stream << \"----------------------------------------\" << std::endl;\n}", "CodeBleu_score": 48.43362373481238}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    stream << \"----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "CodeBleu_score": 5.419648359256731}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\n    std::function<void(const TreeNode*, int)> print_tree_recursively = [&print_tree_recursively](const TreeNode* node, int depth) {\n        if( node == nullptr ) {\n            return;\n        }\n        stream << std::string(depth, '\\t') << node->name() << std::endl;\n\n        if( node->type() == NodeType::CONTROL ) {\n            for( const auto& child : node->children() ) {\n                print_tree_recursively(child.get(), depth + 1);\n            }\n        }\n        else if( node->type() == NodeType::DECORATOR ) {\n            print_tree_recursively(node->child().get(), depth + 1);\n        }\n    };\n\n    stream << \"------------------------------------------------\" << std::endl;\n    print_tree_recursively(root_node, 0);\n    stream << \"------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 45.41357278846824}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\n    if (node == nullptr) {\n        throw LogicError(\"applyRecursiveVisitor: nullptr\");\n    }\n\n    visitor(node);\n\n    if (node->getNodeType() == NodeType::CONTROL) {\n        const ControlNode* control_node = static_cast<const ControlNode*>(node);\n        for (size_t i = 0; i < control_node->child_nodes.size(); ++i) {\n            applyRecursiveVisitor(control_node->child_nodes[i], visitor);\n        }\n    }\n    else if (node->getNodeType() == NodeType::DECORATOR) {\n        const DecoratorNode* decorator_node = static_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decorator_node->child_node, visitor);\n    }\n}", "CodeBleu_score": 56.09270049738277}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (node == nullptr) {\n        throw LogicError(\"applyRecursiveVisitor: The given node is null.\");\n    }\n    visitor(node);\n    if (node->type == NodeType::CONTROL) {\n        const auto control_node = static_cast<const ControlNode*>(node);\n        for (const auto& child : control_node->children) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (node->type == NodeType::DECORATOR) {\n        const auto decorator_node = static_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decorator_node->child, visitor);\n    }\n}", "CodeBleu_score": 57.78425688801466}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (node == nullptr) {\n        throw BehaviorTreeException(\"applyRecursiveVisitor: nullptr\");\n    }\n    visitor(node);\n    if (node->getNodeType() == NodeType::CONTROL) {\n        for (const auto& child : node->children()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    }\n    else if (node->getNodeType() == NodeType::DECORATOR) {\n        applyRecursiveVisitor(node->child(), visitor);\n    }\n}", "CodeBleu_score": 48.29297020744965}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\n    if (builders.find(manifest.registration_ID) != builders.end()) {\n        throw BehaviorTreeException(\"The registration ID '\" + manifest.registration_ID + \"' is already registered\");\n    }\n\n    builders[manifest.registration_ID] = builder;\n    manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 48.35789653650113}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (builders_.find(manifest.registration_ID) != builders_.end()) {\n        throw BehaviorTreeException(\"registration_ID already exists\");\n    }\n    builders_[manifest.registration_ID] = builder;\n    manifests_[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 43.245136520378345}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    const std::string& registration_ID = manifest.registration_ID;\n    if (builders.find(registration_ID) != builders.end()) {\n        throw BehaviorTreeException(\"registration ID already registered: \" + registration_ID);\n    }\n    builders[registration_ID] = builder;\n    manifests[registration_ID] = manifest;\n}", "CodeBleu_score": 45.15567588435005}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\n    auto builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n    };\n\n    TreeNodeManifest action_node(ID, builder);\n\n    action_node.ports = ports;\n\n    registerBuilder(action_node);\n}", "CodeBleu_score": 61.086065356263184}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\n    auto builder = [=](const std::string& name, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n    };\n\n    TreeNodeManifest action_manifest(\n        ID,\n        std::bind(builder, std::placeholders::_1, std::placeholders::_2),\n        ports);\n\n    registerBuilder(action_manifest);\n}", "CodeBleu_score": 56.13066796767043}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\n    auto builder = [=](const std::string& name, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n    };\n\n    auto manifest = TreeNodeManifest{ ActionNodeType, ID, ports };\n\n    registerBuilder(manifest, builder);\n}", "CodeBleu_score": 66.93792420848686}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\n    std::vector<Blackboard::Ptr> blackboard_backups;\n    blackboard_backups.reserve(tree.root_node->num_children);\n\n    for (const auto& child : tree.root_node->children) {\n        Blackboard::Ptr backup_blackboard = std::make_shared<Blackboard>();\n        backup_blackboard->cloneFrom(child->blackboard);\n        blackboard_backups.push_back(backup_blackboard);\n    }\n\n    return blackboard_backups;\n}", "CodeBleu_score": 48.317864770515506}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.rootNode->children.size());\n    for (const auto& subtree : tree.rootNode->children) {\n        auto backup = std::make_shared<Blackboard>();\n        backup->clone(subtree->blackboard);\n        backups.push_back(backup);\n    }\n    return backups;\n}", "CodeBleu_score": 51.77513137158458}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.root_node->num_children());\n\n    for (const auto& subtree : tree.root_node->children()) {\n        backups.push_back(subtree->blackboard->clone());\n    }\n    return backups;\n}", "CodeBleu_score": 56.42503289295716}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n\n    return executor->execute(env);\n}", "CodeBleu_score": 73.29052456777674}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if(executor) {\n        return executor->execute(env);\n    } else {\n        return executor.error();\n    }\n}", "CodeBleu_score": 75.42381094973956}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (executor) {\n        return executor->Execute(env);\n    }\n    else {\n        return nonstd::make_unexpected(executor.error());\n    }\n}", "CodeBleu_score": 83.5122690363175}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n\n    if (isLoaded()) {\n        throw RuntimeError(\"A library is already loaded\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle_ == nullptr) {\n        throw RuntimeError(std::string(\"Unable to load library: \") + dlerror());\n    }\n\n    path_ = path;\n}", "CodeBleu_score": 48.80009559587716}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> guard(mutex_);\n\n    if (is_loaded_) {\n        throw RuntimeError(\"A library is already loaded\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle_) {\n        throw RuntimeError(std::string(\"Could not load library: \") + dlerror());\n    }\n\n    is_loaded_ = true;\n    path_ = path;\n}", "CodeBleu_score": 54.95101823751671}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n    if (loaded_) {\n        throw RuntimeError(\"A library is already loaded\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    if (!handle_) {\n        throw RuntimeError(\"Failed to load the library: \" + std::string(dlerror()));\n    }\n\n    loaded_ = true;\n    path_ = path;\n}", "CodeBleu_score": 54.60935196336393}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3)\n    {\n        return false;\n    }\n\n    StringView stripped = str.strip();\n\n    if (stripped.size() < 3)\n    {\n        return false;\n    }\n\n    if (stripped.front() != '{' || stripped.back() != '}')\n    {\n        return false;\n    }\n\n    if (stripped_pointer)\n    {\n        *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    }\n\n    return true;\n}", "CodeBleu_score": 28.40929079697771}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.length() < 3) {\n        return false;\n    }\n\n    std::string::size_type first_pos = str.find_first_not_of(' ');\n    std::string::size_type last_pos = str.find_last_not_of(' ');\n\n    if (first_pos == std::string::npos || last_pos == std::string::npos) {\n        return false;\n    }\n\n    if (str[first_pos] != '{' || str[last_pos] != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = str.substr(first_pos + 1, last_pos - first_pos - 1);\n    }\n\n    return true;\n}", "CodeBleu_score": 42.31223045499634}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n    std::size_t start = 0;\n    std::size_t end = str.size() - 1;\n\n    // skip leading spaces\n    while (str[start] == ' ') {\n        start++;\n        if (start >= str.size()) {\n            return false;\n        }\n    }\n\n    // skip trailing spaces\n    while (str[end] == ' ') {\n        end--;\n        if (end <= start) {\n            return false;\n        }\n    }\n\n    // check if the string is a valid blackboard pointer\n    if (str[start] != '{' || str[end] != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = str.substr(start + 1, end - start - 1);\n    }\n\n    return true;\n}", "CodeBleu_score": 49.622455597791316}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  // Initialize the line cost\n  double line_cost = 0.0;\n\n  // Initialize the line iterator\n  LineIterator line_iterator(x0, y0, x1, y1, costmap_);\n\n  // Iterate through each point on the line\n  for (line_iterator.getNext(); !line_iterator.isDone(); line_iterator.getNext()) {\n    // Calculate the point cost\n    double point_cost = pointCost(line_iterator.getX(), line_iterator.getY());\n\n    // If the point cost is negative, return the point cost immediately\n    if (point_cost < 0.0) {\n      return point_cost;\n    }\n\n    // Otherwise, update the line cost if the point cost is higher\n    if (point_cost > line_cost) {\n      line_cost = point_cost;\n    }\n  }\n\n  // Return the total line cost\n  return line_cost;\n}", "CodeBleu_score": 67.47159300335758}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\n  // Initialize the line cost to 0.\n  double line_cost = 0.0;\n\n  // Initialize the LineIterator.\n  LineIterator line_iterator(x0, y0, x1, y1, *costmap_);\n\n  // Iterate through each point on the line.\n  while (!line_iterator.isDone()) {\n\n    // Calculate the point cost.\n    double point_cost = pointCost(line_iterator.getX(), line_iterator.getY());\n\n    // If the point cost is negative, return it immediately.\n    if (point_cost < 0.0) {\n      return point_cost;\n    }\n\n    // If the point cost is higher than the line cost, update the line cost.\n    if (point_cost > line_cost) {\n      line_cost = point_cost;\n    }\n\n    // Move the LineIterator to the next point.\n    line_iterator.next();\n  }\n\n  // Return the line cost.\n  return line_cost;\n}", "CodeBleu_score": 51.19771955288852}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  // initialize the line cost to 0\n  double line_cost = 0.0;\n\n  // create a line iterator\n  LineIterator line_iterator(x0, y0, x1, y1);\n\n  // iterate through each point on the line\n  while (!line_iterator.isDone()) {\n    // get the current point\n    const unsigned int mx = line_iterator.getX();\n    const unsigned int my = line_iterator.getY();\n\n    // calculate the cost of the current point\n    double point_cost = pointCost(mx, my);\n\n    // if the point cost is negative, return it immediately\n    if (point_cost < 0.0) {\n      return point_cost;\n    }\n\n    // otherwise, update the line cost if the point cost is higher\n    if (point_cost > line_cost) {\n      line_cost = point_cost;\n    }\n\n    // increment the line iterator\n    line_iterator.advance();\n  }\n\n  // return the total line cost\n  return line_cost;\n}", "CodeBleu_score": 60.491988180254474}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    if (path.empty()) {\n        return;\n    }\n\n    nav_msgs::Path plan_msg;\n    plan_msg.poses.resize(path.size());\n    plan_msg.header = path[0].header;\n\n    for (unsigned int i = 0; i < path.size(); ++i) {\n        plan_msg.poses[i] = path[i];\n    }\n\n    pub.publish(plan_msg);\n}", "CodeBleu_score": 60.94226160583216}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path plan_msg;\n  plan_msg.poses.resize(path.size());\n  plan_msg.header.frame_id = path[0].header.frame_id;\n  plan_msg.header.stamp = path[0].header.stamp;\n\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    plan_msg.poses[i] = path[i].pose;\n  }\n\n  pub.publish(plan_msg);\n}", "CodeBleu_score": 67.52180426442374}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty())\n    return;\n\n  nav_msgs::Path plan_msg;\n  plan_msg.header = path[0].header;\n  plan_msg.poses = path;\n  pub.publish(plan_msg);\n}", "CodeBleu_score": 34.105171225543}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t    if (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n            fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && \n            fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity) {\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 81.99827276521569}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  // check if the robot has stopped translating\n  if (fabs(base_odom.twist.twist.linear.x) > trans_stopped_velocity ||\n      fabs(base_odom.twist.twist.linear.y) > trans_stopped_velocity) {\n    return false;\n  }\n\n  // check if the robot has stopped rotating\n  if (fabs(base_odom.twist.twist.angular.z) > rot_stopped_velocity) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 64.80903275316928}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n  // if the robot has not moved, it is considered stopped\n  if (base_odom.twist.twist.linear.x == 0.0 && base_odom.twist.twist.linear.y == 0.0 &&\n      base_odom.twist.twist.angular.z == 0.0) {\n    return true;\n  }\n\n  // check if the robot has stopped translating\n  if (base_odom.twist.twist.linear.x <= trans_stopped_velocity &&\n      base_odom.twist.twist.linear.y <= trans_stopped_velocity) {\n    // check if the robot has stopped rotating\n    if (base_odom.twist.twist.angular.z <= rot_stopped_velocity) {\n      return true;\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 48.317430696007094}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_ && restore_defaults) {\n    config.max_vel_x = default_config_.max_vel_x;\n    config.max_vel_x_backwards = default_config_.max_vel_x_backwards;\n    config.max_vel_x_rot = default_config_.max_vel_x_rot;\n    config.min_in_place_vel_x = default_config_.min_in_place_vel_x;\n    config.max_vel_y = default_config_.max_vel_y;\n    config.max_vel_theta = default_config_.max_vel_theta;\n    config.max_vel_x_yaw = default_config_.max_vel_x_yaw;\n    config.max_vel_x_yaw_backwards = default_config_.max_vel_x_yaw_backwards;\n    config.max_trans_acc = default_config_.max_trans_acc;\n    config.max_rot_acc = default_config_.max_rot_acc;\n    config.max_trans_jerk = default_config_.max_trans_jerk;\n    config.max_rot_jerk = default_config_.max_rot_jerk;\n    config.costmap_inscribed_radius = default_config_.costmap_inscribed_radius;\n    config.costmap_circumscribed_radius = default_config_.costmap_circumscribed_radius;\n    config.costmap_cost_scaling_factor = default_config_.costmap_cost_scaling_factor;\n    config.costmap_2d_inscribed_radius = default_config_.costmap_2d_inscribed_radius;\n    config.costmap_2d_circumscribed_radius = default_config_.costmap_2d_circumscribed_radius;\n    config.costmap_2d_cost_scaling_factor = default_config_.costmap_2d_cost_scaling_factor;\n    config.costmap_3d_inscribed_radius = default_config_.costmap_3d_inscribed_radius;\n    config.costmap_3d_circumscribed_radius =", "CodeBleu_score": 29.92155608111922}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  // if the setup flag is not set and restore_defaults is requested, set the configuration to default limits\n  if (!setup_ && restore_defaults) {\n    config.max_vel_x = LocalPlannerLimits().max_vel_x;\n    config.max_vel_x_backwards = LocalPlannerLimits().max_vel_x_backwards;\n    config.max_vel_x_trans = LocalPlannerLimits().max_vel_x_trans;\n    config.max_vel_x_rot = LocalPlannerLimits().max_vel_x_rot;\n    config.max_vel_y = LocalPlannerLimits().max_vel_y;\n    config.max_vel_theta = LocalPlannerLimits().max_vel_theta;\n    config.max_vel_x_goal = LocalPlannerLimits().max_vel_x_goal;\n    config.max_vel_x_goal_backwards = LocalPlannerLimits().max_vel_x_goal_backwards;\n    config.max_vel_x_goal_trans = LocalPlannerLimits().max_vel_x_goal_trans;\n    config.max_vel_x_goal_rot = LocalPlannerLimits().max_vel_x_goal_rot;\n    config.max_vel_y_goal = LocalPlannerLimits().max_vel_y_goal;\n    config.max_vel_theta_goal = LocalPlannerLimits().max_vel_theta_goal;\n    config.min_in_place_vel_x = LocalPlannerLimits().min_in_place_vel_x;\n    config.min_in_place_vel_theta = LocalPlannerLimits().min_in_place_vel_theta;\n    config.min_vel_x = LocalPlannerLimits().min_vel_x;\n    config.min_vel_x_backwards = LocalPlannerLimits().min_vel_x_backwards;\n    config.min_vel_x_trans = LocalPlannerLimits().min_vel_x_trans;\n    config.min_vel", "CodeBleu_score": 29.69985921368429}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_ && restore_defaults) {\n    config.max_trans_vel = default_max_trans_vel_;\n    config.max_trans_acc = default_max_trans_acc_;\n    config.min_trans_vel = default_min_trans_vel_;\n    config.max_rot_vel = default_max_rot_vel_;\n    config.max_rot_acc = default_max_rot_acc_;\n    config.min_rot_vel = default_min_rot_vel_;\n  } else if (!setup_) {\n    default_max_trans_vel_ = config.max_trans_vel;\n    default_max_trans_acc_ = config.max_trans_acc;\n    default_min_trans_vel_ = config.min_trans_vel;\n    default_max_rot_vel_ = config.max_rot_vel;\n    default_max_rot_acc_ = config.max_rot_acc;\n    default_min_rot_vel_ = config.min_rot_vel;\n    setup_ = true;\n  }\n\n  boost::mutex::scoped_lock lock(config_mutex_);\n  max_trans_vel_ = config.max_trans_vel;\n  max_trans_acc_ = config.max_trans_acc;\n  min_trans_vel_ = config.min_trans_vel;\n  max_rot_vel_ = config.max_rot_vel;\n  max_rot_acc_ = config.max_rot_acc;\n  min_rot_vel_ = config.min_rot_vel;\n}", "CodeBleu_score": 49.14004510810401}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  // Check the cost of the cell\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (cost == costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_distance = max_obstacle_cost_;\n    return false;\n  }\n  if (cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = max_obstacle_cost_;\n    return false;\n  }\n\n  // Calculate a new target distance for the cell\n  double new_target_distance =\n      current_cell->target_distance + sqrt(pow(check_cell->x - current_cell->x, 2) + pow(check_cell->y - current_cell->y, 2));\n\n  // Update the cell's target distance if the new distance is shorter\n  if (new_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_target_distance;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 59.48683387161305}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int mx, my;\n  costmap.worldToMap(check_cell->x_coord, check_cell->y_coord, mx, my);\n  unsigned char cost = costmap.getCost(mx, my);\n  if (cost == costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_distance = obstacle_cost_;\n    return false;\n  }\n  if (cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = obstacle_cost_;\n    return false;\n  }\n\n  double dx = check_cell->x_coord - current_cell->x_coord;\n  double dy = check_cell->y_coord - current_cell->y_coord;\n  double distance = sqrt(dx*dx + dy*dy);\n  if (distance < check_cell->target_distance) {\n    check_cell->target_distance = distance;\n  }\n  return true;\n}", "CodeBleu_score": 58.362239671709204}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  // If the cell is an obstacle or has no information, it sets the cell's target distance to the maximum obstacle cost and returns false.\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = std::numeric_limits<double>::max();\n    return false;\n  }\n\n  // If the cell is not an obstacle, it calculates a new target distance and updates the cell's target distance if the new distance is shorter.\n  double new_distance = current_cell->target_distance +\n      sqrt(pow(check_cell->x - current_cell->x, 2) + pow(check_cell->y - current_cell->y, 2));\n  if (new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 65.53009045693895}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scale = 0;\n  double max_scale = 0;\n\n  // if footprint is empty, log error and return -9\n  if (traj.footprint.empty()) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory() error: footprint is empty\");\n    return -9;\n  }\n\n  // initialize cost and scaling factor\n  if (traj.velocity > 0) {\n    scale = 1.0 / traj.velocity;\n  } else {\n    scale = 1.0;\n  }\n  cost = traj.cost;\n\n  // for each point in the trajectory\n  for (std::vector<geometry_msgs::Point>::iterator it = traj.points.begin(); it != traj.points.end(); it++) {\n    // calculate footprint cost\n    double footprint_cost = footprintCost(*it, traj.footprint, traj.orientation);\n\n    // if footprint cost is negative, return cost immediately\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    // either sum the scores or take the maximum score\n    if (sum_scores_) {\n      cost += footprint_cost * scale;\n    } else {\n      max_scale = std::max(max_scale, scale);\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  // return the total cost\n  return cost * max_scale;\n}", "CodeBleu_score": 49.22296557063097}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scaling_factor = 0.0;\n\n  if (traj.footprint.empty()) {\n    ROS_ERROR(\"The footprint of the robot is empty. The cost of a trajectory cannot be calculated.\");\n    return -9.0;\n  }\n\n  for (unsigned int i = 0; i < traj.points.size(); ++i) {\n    double footprint_cost = scoreFootprint(traj.points[i], traj.footprint);\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n\n    scaling_factor += traj.points[i].speed;\n  }\n\n  return cost / scaling_factor;\n}", "CodeBleu_score": 49.757419545651906}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  // initialize the cost\n  double cost = 0;\n  // initialize the scaling factor\n  double scaling_factor = 1.0;\n  // if the footprint specification is empty\n  if (traj.footprint_spec.empty()) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory(): The footprint specification is empty.\");\n    return -9;\n  }\n  // for each point in the trajectory\n  for (unsigned int i = 0; i < traj.points.size(); ++i) {\n    // calculate the footprint cost\n    double footprint_cost = footprintCost(traj, i);\n    // if the footprint cost is negative\n    if (footprint_cost < 0) {\n      // return the cost immediately\n      return footprint_cost;\n    }\n    // otherwise, either sum the scores or take the maximum score\n    if (sum_scores_) {\n      // sum the scores\n      cost += footprint_cost;\n    } else {\n      // take the maximum score\n      cost = std::max(cost, footprint_cost);\n    }\n    // scale the cost\n    cost *= scaling_factor;\n    // update the scaling factor\n    scaling_factor *= scaling_factor_decay_;\n  }\n  // return the total cost\n  return cost;\n}", "CodeBleu_score": 52.523394032407765}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  // Scale the footprint points by the given scale factor\n  std::vector<geometry_msgs::Point> scaled_footprint_spec;\n  for (int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point scaled_point;\n    scaled_point.x = scale * footprint_spec[i].x;\n    scaled_point.y = scale * footprint_spec[i].y;\n    scaled_point.z = scale * footprint_spec[i].z;\n    scaled_footprint_spec.push_back(scaled_point);\n  }\n\n  // Compute the footprint cost using a world model\n  double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint_spec, costmap);\n\n  // Return the maximum cost between the footprint cost and the cell cost at the given position\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n  else {\n    unsigned int mx, my;\n    costmap->worldToMap(x, y, mx, my);\n    if (!costmap->isInside(mx, my)) {\n      return -7.0;\n    }\n    else {\n      return std::max(footprint_cost, costmap->getCost(mx, my));\n    }\n  }\n}", "CodeBleu_score": 71.05214171810734}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t  // Scale the footprint points by the given scale factor\n  std::vector<geometry_msgs::Point> scaled_footprint_spec;\n  for (auto point : footprint_spec) {\n    geometry_msgs::Point scaled_point;\n    scaled_point.x = point.x * scale;\n    scaled_point.y = point.y * scale;\n    scaled_footprint_spec.push_back(scaled_point);\n  }\n\n  // Compute the footprint cost using a world model\n  double footprint_cost = world_model->footprintCost(\n      x, y, th, scaled_footprint_spec, costmap);\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  // Get the cost at the given position\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n  unsigned char cost = costmap->getCost(mx, my);\n\n  // Return the maximum cost between the footprint cost and the cell cost\n  return std::max(cost, footprint_cost);\n}", "CodeBleu_score": 63.37459876810689}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  // scale footprint points\n  std::vector<geometry_msgs::Point> scaled_footprint_spec;\n  for (std::vector<geometry_msgs::Point>::iterator it = footprint_spec.begin(); it != footprint_spec.end(); ++it) {\n    scaled_footprint_spec.push_back(scalePoint(scale, *it));\n  }\n\n  // get cost of footprint\n  double footprint_cost = world_model->footprintCost(scaled_footprint_spec, x, y, th, costmap);\n\n  // return cost\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n  else {\n    unsigned int mx, my;\n    if (!costmap->worldToMap(x, y, mx, my)) {\n      return -7.0;\n    }\n    else {\n      unsigned int cost = costmap->getCost(mx, my);\n      if (cost > footprint_cost) {\n        return cost;\n      }\n      else {\n        return footprint_cost;\n      }\n    }\n  }\n}", "CodeBleu_score": 59.157049638393346}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.90579232493761}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic == odom_topic_) {\n    return;\n  }\n  odom_topic_ = odom_topic;\n\n  if (odom_topic.empty()) {\n    odom_sub_.shutdown();\n  } else {\n    odom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n  }\n}", "CodeBleu_score": 38.47127021614133}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    if (odom_topic_ != odom_topic) {\n        odom_topic_ = odom_topic;\n        if (!odom_topic_.empty()) {\n            odom_sub_ = nh_.subscribe(odom_topic_, 10, &OdometryHelperRos::odomCallback, this);\n        } else {\n            odom_sub_.shutdown();\n        }\n    }\n}", "CodeBleu_score": 50.21253104184156}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  float distance_squared = (pos - prev).squaredNorm();\n  float angle_difference = std::abs(std::atan2(pos[1] - prev[1], pos[0] - prev[0]) - std::atan2(pos[1] - prev[1], pos[0] - prev[0]));\n  if (distance_squared > oscillation_distance_squared_threshold_ || angle_difference > oscillation_angle_threshold_) {\n    oscillation_flags_ = 0;\n  }\n}", "CodeBleu_score": 44.1854185129566}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  const float dist_squared = (pos - prev).squaredNorm();\n  const float angle_diff = fabs(atan2(pos[1] - prev[1], pos[0] - prev[0]) - atan2(pos[1] - prev[1], pos[0] - prev[0]));\n  if (dist_squared > oscillation_distance_threshold_ * oscillation_distance_threshold_ || angle_diff > oscillation_angle_threshold_) {\n    oscillation_flags_.reset();\n  }\n}", "CodeBleu_score": 47.84228106240079}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\n\t//calculate the distance between the current and previous positions\n\tEigen::Vector3f diff = pos - prev;\n\tfloat distance = diff.norm();\n\n\t//calculate the angular difference\n\tfloat angle = std::atan2(diff[1], diff[0]);\n\n\t//if the distance is greater than the threshold or the angle is greater than the set angle, reset the oscillation flags\n\tif (distance > oscillation_distance_threshold_ || std::abs(angle) > oscillation_angle_threshold_) {\n\t\toscillation_distance_threshold_ = 0;\n\t\toscillation_angle_threshold_ = 0;\n\t}\n\n}", "CodeBleu_score": 42.34301472690603}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // calculate the grid coordinates of the point\n  double x_grid = (pt.x - origin_x) / resolution;\n  double y_grid = (pt.y - origin_y) / resolution;\n\n  // check if the point is outside the grid bounds\n  if (x_grid < 0 || x_grid >= width || y_grid < 0 || y_grid >= height)\n    return;\n\n  // calculate the grid index\n  unsigned int index = (unsigned int) (x_grid + y_grid * width);\n\n  // check if the point is too close to its nearest neighbor\n  if (index >= points.size() || distance(pt, points[index]) < min_distance)\n    return;\n\n  // insert the point into the grid\n  points[index] = pt;\n}", "CodeBleu_score": 42.08600203981244}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    int x, y;\n    if (!getGridCoordinates(pt, x, y)) {\n        return;\n    }\n    if (x < 0 || x >= grid_size_x_ || y < 0 || y >= grid_size_y_) {\n        return;\n    }\n    int index = x + y * grid_size_x_;\n    if (index >= (int)cells_.size()) {\n        return;\n    }\n    PointGridCell& cell = cells_[index];\n    if (cell.points_.size() > 0) {\n        const geometry_msgs::Point32& first_pt = cell.points_[0];\n        double dx = first_pt.x - pt.x;\n        double dy = first_pt.y - pt.y;\n        double dist = sqrt(dx * dx + dy * dy);\n        if (dist < cell_size_ / 2.0) {\n            return;\n        }\n    }\n    cell.points_.push_back(pt);\n}", "CodeBleu_score": 42.34531015063437}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    // get the grid coordinates of the point\n    int x_coord = getGridCoord(pt.x, min_x_, inv_cell_size_x_);\n    int y_coord = getGridCoord(pt.y, min_y_, inv_cell_size_y_);\n\n    // check if the point is within the grid bounds\n    if (x_coord < 0 || x_coord >= num_cells_x_ || y_coord < 0 || y_coord >= num_cells_y_)\n        return;\n\n    // check if the point is too close to its nearest neighbor\n    if (getMinDist(x_coord, y_coord) < min_dist_to_neighbor_)\n        return;\n\n    // calculate the grid index\n    unsigned int grid_index = x_coord + y_coord * num_cells_x_;\n\n    // insert the point into the corresponding cell\n    grid_[grid_index].insert(pt);\n}", "CodeBleu_score": 44.20580415804596}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel(i) > vel(i) + acclimits(i) * dt)\n      new_vel(i) = vel(i) + acclimits(i) * dt;\n    else if (sample_target_vel(i) < vel(i) - acclimits(i) * dt)\n      new_vel(i) = vel(i) - acclimits(i) * dt;\n    else\n      new_vel(i) = sample_target_vel(i);\n  }\n  return new_vel;\n}", "CodeBleu_score": 60.68406715872907}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n  // for each of the three velocity components\n  for (unsigned int i = 0; i < 3; ++i) {\n    // if the target velocity is lower than the current velocity\n    if (sample_target_vel(i) < vel(i)) {\n      // decrease the current velocity towards the target velocity within the acceleration limits\n      new_vel(i) = std::max(vel(i) - dt * acclimits(i), sample_target_vel(i));\n    }\n    // if the target velocity is higher than the current velocity\n    else if (sample_target_vel(i) > vel(i)) {\n      // increase the current velocity towards the target velocity within the acceleration limits\n      new_vel(i) = std::min(vel(i) + dt * acclimits(i), sample_target_vel(i));\n    }\n  }\n\n  // return the new velocity vector\n  return new_vel;\n}", "CodeBleu_score": 62.65095858506899}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel(0, 0, 0);\n  for (unsigned int i = 0; i < 3; i++) {\n    // if the target velocity is higher than the current velocity, increase the current velocity\n    if (sample_target_vel[i] > vel[i]) {\n      // if the acceleration limit is higher than the difference between the target and current velocity, increase the current velocity\n      if (acclimits[i] > sample_target_vel[i] - vel[i]) {\n        new_vel[i] = vel[i] + (sample_target_vel[i] - vel[i]) * dt;\n      }\n      // otherwise, increase the current velocity to the acceleration limit\n      else {\n        new_vel[i] = vel[i] + acclimits[i] * dt;\n      }\n    }\n    // if the target velocity is lower than the current velocity, decrease the current velocity\n    else if (sample_target_vel[i] < vel[i]) {\n      // if the acceleration limit is higher than the difference between the current and target velocity, decrease the current velocity\n      if (acclimits[i] > vel[i] - sample_target_vel[i]) {\n        new_vel[i] = vel[i] - (vel[i] - sample_target_vel[i]) * dt;\n      }\n      // otherwise, decrease the current velocity to the acceleration limit\n      else {\n        new_vel[i] = vel[i] - acclimits[i] * dt;\n      }\n    }\n    // if the target velocity is equal to the current velocity, keep the current velocity\n    else {\n      new_vel[i] = vel[i];\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 63.26102203073541}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double diff = DBL_MAX;\n  double goal_x, goal_y;\n  costmap_->mapToWorld(cell_x, cell_y, goal_x, goal_y);\n  double goal_angle = atan2(goal_y - y, goal_x - x);\n  double goal_diff = angles::shortest_angular_distance(heading, goal_angle);\n  if (goal_diff < 0)\n    goal_diff *= -1;\n  if (goal_diff > M_PI)\n    goal_diff = 2 * M_PI - goal_diff;\n  if (goal_diff < diff)\n    diff = goal_diff;\n  return diff;\n}", "CodeBleu_score": 39.197553295515654}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double diff = 0.0;\n  unsigned int i = 0;\n  double dx, dy;\n  double goal_angle = 0.0;\n  double angle_diff = 0.0;\n  unsigned int n_cells = global_plan_.size();\n  unsigned int n_goal_cells = 0;\n  unsigned int n_goal_cells_max = 20;\n  double goal_x, goal_y;\n  double goal_x_prev, goal_y_prev;\n  double goal_x_prev2, goal_y_prev2;\n  double goal_x_prev3, goal_y_prev3;\n  double goal_x_prev4, goal_y_prev4;\n  double goal_x_prev5, goal_y_prev5;\n  double goal_x_prev6, goal_y_prev6;\n  double goal_x_prev7, goal_y_prev7;\n  double goal_x_prev8, goal_y_prev8;\n  double goal_x_prev9, goal_y_prev9;\n  double goal_x_prev10, goal_y_prev10;\n  double goal_x_prev11, goal_y_prev11;\n  double goal_x_prev12, goal_y_prev12;\n  double goal_x_prev13, goal_y_prev13;\n  double goal_x_prev14, goal_y_prev14;\n  double goal_x_prev15, goal_y_prev15;\n  double goal_x_prev16, goal_y_prev16;\n  double goal_x_prev17, goal_y_prev17;\n  double goal_x_prev18, goal_y_prev18;\n  double goal_x_prev19, goal_y_prev19;\n  double goal_x_prev20, goal_y_prev20;\n  bool goal_reached = false;\n  bool goal_reached_prev = false;\n  bool goal_reached_prev2 = false;\n  bool goal_reached_prev3 =", "CodeBleu_score": 11.156716965524053}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // Find the farthest point with a clear line of sight to the goal\n  int index = 0;\n  for (int i = (int)global_plan_.size() - 1; i >= 0; i--) {\n    // Check if the goal cell is clear of obstacles\n    if (costmap_->isClear(cell_x, cell_y, global_plan_[i].pose.position.x, global_plan_[i].pose.position.y)) {\n      // Convert the goal cell coordinates to world coordinates\n      double goal_x = global_plan_[i].pose.position.x;\n      double goal_y = global_plan_[i].pose.position.y;\n      // Calculate the shortest angular distance between the current heading and the direction to the goal point\n      double diff = angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x));\n      // Return the absolute value of the difference\n      return fabs(diff);\n    }\n  }\n  // Return DBL_MAX if no valid point is found\n  return DBL_MAX;\n}", "CodeBleu_score": 52.646778873108424}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  // check if the trajectory is valid\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost < 0) {\n    ROS_WARN_STREAM(\"Trajectory with sampled velocities (\" << vx_samp << \",\" << vy_samp << \",\" << vtheta_samp << \") has cost \" << cost);\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 71.55521389940303}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  //compute the cost of the trajectory\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  //if the cost is negative, log a warning\n  if(cost < 0.0) {\n    ROS_WARN(\"Trajectory rejected with cost %f: x=%f, y=%f, theta=%f, vx=%f, vy=%f, vtheta=%f, vx_samp=%f, vy_samp=%f, vtheta_samp=%f\",\n             cost, x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  }\n\n  //return true if the cost is non-negative\n  return cost >= 0.0;\n}", "CodeBleu_score": 65.1908744491191}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost < 0.0) {\n    ROS_WARN_STREAM(\"Rejected trajectory with cost \" << cost << \" for sampled velocities (\" << vx_samp << \", \" << vy_samp << \", \" << vtheta_samp << \")\");\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 69.4457800017065}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"The behavior has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"The global costmap is NULL\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"The local costmap is NULL\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing the area outside of the specified area\");\n  } else {\n    ROS_WARN(\"Clearing the area inside of the specified area\");\n  }\n\n  ros::WallTime start = ros::WallTime::now();\n\n  if (affected_maps_ & GLOBAL_COSTMAP) {\n    global_costmap_->setCostmapToDefaultValue(invert_area_to_clear_);\n    if (force_clearing_) {\n      global_costmap_->updateMap();\n    }\n  }\n\n  if (affected_maps_ & LOCAL_COSTMAP) {\n    local_costmap_->setCostmapToDefaultValue(invert_area_to_clear_);\n    if (force_clearing_) {\n      local_costmap_->updateMap();\n    }\n  }\n\n  ros::WallTime end = ros::WallTime::now();\n\n  ROS_INFO(\"Clearing the costmap took %.2f seconds\", (end - start).toSec());\n}", "CodeBleu_score": 46.217680494066435}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t    if (!initialized()) {\n        ROS_ERROR(\"The behavior has not been initialized, please call initialize() before using this behavior\");\n        return;\n    }\n\n    if (global_costmap_ == NULL) {\n        ROS_ERROR(\"The global costmap is NULL, please provide a valid costmap to use this behavior\");\n        return;\n    }\n\n    if (local_costmap_ == NULL) {\n        ROS_ERROR(\"The local costmap is NULL, please provide a valid costmap to use this behavior\");\n        return;\n    }\n\n    if (invert_area_to_clear_) {\n        ROS_WARN(\"Clearing inside the specified area\");\n    } else {\n        ROS_WARN(\"Clearing outside the specified area\");\n    }\n\n    // clear the global costmap\n    if (affected_maps_ & GLOBAL_COSTMAP) {\n        ROS_INFO(\"Clearing the global costmap\");\n        global_costmap_->setConvexRegionCost(area_to_clear_, costmap_2d::FREE_SPACE, invert_area_to_clear_);\n        if (force_clearing_) {\n            global_costmap_->updateMap();\n        }\n        ROS_INFO(\"Global costmap cleared in %f seconds\", global_costmap_->getLastUpdateTime());\n    }\n\n    // clear the local costmap\n    if (affected_maps_ & LOCAL_COSTMAP) {\n        ROS_INFO(\"Clearing the local costmap\");\n        local_costmap_->setConvexRegionCost(area_to_clear_, costmap_2d::FREE_SPACE, invert_area_to_clear_);\n        if (force_clearing_) {\n            local_costmap_->updateMap();\n        }\n        ROS_INFO(\"Local costmap cleared in %f seconds\", local_costmap_->getLastUpdateTime());\n    }\n}", "CodeBleu_score": 43.04062271457565}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"The plugin must be initialized before runBehavior is called.\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmap pointers are not set.\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside the area to clear.\");\n  } else {\n    ROS_WARN(\"Clearing inside the area to clear.\");\n  }\n\n  ros::WallTime start_time = ros::WallTime::now();\n  if (affected_maps_ & GLOBAL_COSTMAP) {\n    global_costmap_->setCostmapToDefaultValue(invert_area_to_clear_);\n    if (force_full_update_) {\n      global_costmap_->updateMap();\n    }\n  }\n  ros::WallDuration global_time = ros::WallTime::now() - start_time;\n\n  start_time = ros::WallTime::now();\n  if (affected_maps_ & LOCAL_COSTMAP) {\n    local_costmap_->setCostmapToDefaultValue(invert_area_to_clear_);\n    if (force_full_update_) {\n      local_costmap_->updateMap();\n    }\n  }\n  ros::WallDuration local_time = ros::WallTime::now() - start_time;\n\n  ROS_INFO(\"Clearing the costmap took %f seconds for the global costmap and %f seconds for the local costmap.\",\n           global_time.toSec(), local_time.toSec());\n}", "CodeBleu_score": 52.01977254787037}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  polygon_cells.clear();\n  if (polygon.empty()) {\n    return;\n  }\n\n  // Iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points.\n  for (unsigned int i = 0; i < polygon.size(); i++) {\n    if (i + 1 < polygon.size()) {\n      raytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n    }\n  }\n\n  // If the polygon is not empty, it also closes the polygon by connecting the last point to the first.\n  if (!polygon.empty()) {\n    raytraceLine(polygon.back(), polygon.front(), polygon_cells);\n  }\n}", "CodeBleu_score": 47.63843202427373}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells outline;\n\tif (polygon.empty())\n\t\treturn;\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tif (i + 1 == polygon.size()) {\n\t\t\toutline.raytraceLine(polygon[i], polygon[0]);\n\t\t} else {\n\t\t\toutline.raytraceLine(polygon[i], polygon[i + 1]);\n\t\t}\n\t}\n\toutline.getCells(polygon_cells);\n}", "CodeBleu_score": 48.52675137661462}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells outline_cells(polygon, *this);\n\toutline_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 12.136977763495679}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t    if (pub.getSubscriberName() != last_subscriber_ && !prepareGrid()) {\n        ROS_ERROR(\"Failed to publish costmap to new subscriber\");\n    }\n    last_subscriber_ = pub.getSubscriberName();\n}", "CodeBleu_score": 45.823515765579685}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  if (pub.getSubscriber().getTopic() == \"costmap\") {\n    prepareGrid();\n    pub.publish(grid_);\n  }\n}", "CodeBleu_score": 80.37727158434113}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  if (pub.getSubscriberName() != last_subscriber_) {\n    last_subscriber_ = pub.getSubscriberName();\n    prepareGrid();\n  }\n  pub.publish(grid_);\n}", "CodeBleu_score": 57.17706027366949}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  if (publish_costmap_ || publish_costmap_ros_) {\n    // lock the mutex and retrieve the resolution\n    unsigned int mx, my;\n    double res;\n    {\n      boost::mutex::scoped_lock lock(costmap_->getMutex());\n      mx = costmap_->getSizeInCellsX();\n      my = costmap_->getSizeInCellsY();\n      res = costmap_->getResolution();\n    }\n\n    // set the header, resolution, width, and height\n    grid_.header.frame_id = global_frame_;\n    grid_.header.stamp = ros::Time::now();\n    grid_.info.resolution = res;\n    grid_.info.width = mx;\n    grid_.info.height = my;\n\n    // convert the map coordinates to world coordinates for the origin\n    tf::Point origin(0, 0, 0);\n    tf::Point transformed_origin;\n    tf_.transformPoint(global_frame_, origin, transformed_origin);\n\n    // set the origin's position and orientation\n    grid_.info.origin.position.x = transformed_origin.x();\n    grid_.info.origin.position.y = transformed_origin.y();\n    grid_.info.origin.position.z = transformed_origin.z();\n    grid_.info.origin.orientation.x = 0;\n    grid_.info.origin.orientation.y = 0;\n    grid_.info.origin.orientation.z = 0;\n    grid_.info.origin.orientation.w = 1;\n\n    // save the origin coordinates and resize the grid data vector\n    grid_origin_x_ = transformed_origin.x();\n    grid_origin_y_ = transformed_origin.y();\n    grid_.data.resize(mx * my);\n\n    // populate the grid data from the costmap's character map\n    // using a translation table\n    unsigned int i = 0;\n    for (unsigned int y = 0; y < my; y++) {\n      for (unsigned int x = 0; x < mx; x++) {\n        unsigned int cost = costmap_->getCost(x, y);\n        grid", "CodeBleu_score": 50.09127848718795}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // Lock the costmap mutex and retrieve the resolution\n  boost::mutex::scoped_lock lock(costmap_->getMutex());\n  double resolution = costmap_->getResolution();\n  // Set the grid's header, resolution, width, and height\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  // Convert the map coordinates to world coordinates for the origin and set the origin's position and orientation\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  // Save the origin coordinates and resize the grid data vector\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n  grid_.data.resize(grid_.info.width * grid_.info.height, 0);\n  // Populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < costmap_->getSizeInCellsX(); ++i) {\n    for (unsigned int j = 0; j < costmap_->getSizeInCellsY(); ++j) {\n      unsigned int index = i + j * costmap_->getSizeInCellsX();\n      unsigned int value = costmap_->getCost(i, j);\n      if (value == costmap_2d::LETHAL_OBSTACLE) {\n        grid_.data[index] = -1;\n      } else if (value == costmap_2d::NO_INFORMATION) {\n        grid_.", "CodeBleu_score": 62.90506393752412}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*costmap_);\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.info.resolution = costmap_->getResolution();\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0;\n  grid_.info.origin.orientation.x = 0;\n  grid_.info.origin.orientation.y = 0;\n  grid_.info.origin.orientation.z = 0;\n  grid_.info.origin.orientation.w = 1;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  for(unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = costmap_->getCharMap()[i];\n  }\n}", "CodeBleu_score": 51.61557468979417}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.robot_radius == old_config.robot_radius && new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  if (new_config.footprint == old_config.footprint) {\n    ROS_DEBUG_STREAM(\"Footprint string is the same as the old configuration, no need to update\");\n    return;\n  }\n\n  // If we have a valid footprint string, then use it\n  if (new_config.footprint != \"\") {\n    std::vector<geometry_msgs::Point> points;\n    if (costmap_2d::toShapeMsg(new_config.footprint, points)) {\n      ROS_DEBUG_STREAM(\"Setting footprint from config\");\n      setFootprint(points);\n      return;\n    }\n  }\n\n  // Otherwise, we'll just use the radius to create a circle\n  ROS_DEBUG_STREAM(\"Setting footprint from radius\");\n  setFootprintRadius(new_config.robot_radius);\n}", "CodeBleu_score": 64.14568412695154}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (new_config.footprint.empty()) {\n    ROS_WARN(\"No footprint string provided.  Using a circular footprint\");\n    footprint_spec_.clear();\n    footprint_spec_.addCircle(new_config.robot_radius);\n  } else {\n    try {\n      footprint_spec_.fromString(new_config.footprint);\n    } catch (tf2::TransformException &ex) {\n      ROS_ERROR(\"Error reading footprint string: %s\", ex.what());\n      return;\n    }\n  }\n}", "CodeBleu_score": 60.989772215481565}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> points;\n    std::vector<std::string> footprint_strings = tf2::split(new_config.footprint, ',');\n    for (const std::string &footprint_string : footprint_strings) {\n      geometry_msgs::Point point;\n      std::vector<std::string> point_strings = tf2::split(footprint_string, ' ');\n      if (point_strings.size() != 2) {\n        ROS_ERROR(\"Invalid footprint string specified.  Must be of the form (x, y)\");\n        continue;\n      }\n      point.x = std::stod(point_strings[0]);\n      point.y = std::stod(point_strings[1]);\n      points.push_back(point);\n    }\n    if (!points.empty()) {\n      footprint_ = points;\n      return;\n    }\n  }\n\n  // if we get here, we need to generate a footprint from the radius\n  geometry_msgs::Point point;\n  point.x = new_config.robot_radius;\n  point.y = 0.0;\n  footprint_.clear();\n  footprint_.push_back(point);\n  point.x = 0.0;\n  point.y = new_config.robot_radius;\n  footprint_.push_back(point);\n  point.x = -new_config.robot_radius;\n  point.y = 0.0;\n  footprint_.push_back(point);\n  point.x = 0.0;\n  point.y = -new_config.robot_radius;\n  footprint_.push_back(point);\n}", "CodeBleu_score": 58.76412771807596}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  if (!tf_listener_) {\n    ROS_WARN(\"Costmap2DROS::movementCB(): tf_listener_ is not set\");\n    return;\n  }\n  if (!tf_buffer_) {\n    ROS_WARN(\"Costmap2DROS::movementCB(): tf_buffer_ is not set\");\n    return;\n  }\n  if (!costmap_) {\n    ROS_WARN(\"Costmap2DROS::movementCB(): costmap_ is not set\");\n    return;\n  }\n  if (!costmap_ros_) {\n    ROS_WARN(\"Costmap2DROS::movementCB(): costmap_ros_ is not set\");\n    return;\n  }\n  if (!global_frame_.empty()) {\n    if (!tf_buffer_->canTransform(global_frame_, robot_base_frame_, ros::Time(0))) {\n      ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB(): Cannot transform from %s to %s\", global_frame_.c_str(), robot_base_frame_.c_str());\n      return;\n    }\n  }\n  geometry_msgs::TransformStamped transform;\n  try {\n    transform = tf_buffer_->lookupTransform(global_frame_, robot_base_frame_, ros::Time(0));\n  }\n  catch (tf2::TransformException &ex) {\n    ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB(): %s\", ex.what());\n    return;\n  }\n  tf2::doTransform(transform, new_pose_);\n  if (new_pose_.position.x != current_pose_.position.x || new_pose_.position.y != current_pose_.position.y) {\n    current_pose_ = new_pose_;\n    costmap_->updateMapLocation(current_pose_.position.x, current_pose_.position.y, tf2::getYaw(current_pose_.orientation));\n    if (publish_costmap_ros_) {\n      costmap_ros_->publishCostmap();\n    }\n ", "CodeBleu_score": 39.71008042681628}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t    geometry_msgs::PoseStamped new_pose;\n    try {\n        tf2::fromMsg(tf_buffer_.lookupTransform(global_frame_, robot_base_frame_, ros::Time(0)), transform_);\n        new_pose.header.frame_id = global_frame_;\n        new_pose.header.stamp = ros::Time::now();\n        new_pose.pose = transform_ * robot_pose_;\n    }\n    catch (tf2::TransformException &ex) {\n        ROS_WARN(\"The tf from '%s' to '%s' is not yet available.  Will try again later.\", global_frame_.c_str(), robot_base_frame_.c_str());\n        return;\n    }\n    if (new_pose.pose.position.x != current_pose_.pose.position.x || new_pose.pose.position.y != current_pose_.pose.position.y || new_pose.pose.position.z != current_pose_.pose.position.z ||\n        new_pose.pose.orientation.x != current_pose_.pose.orientation.x || new_pose.pose.orientation.y != current_pose_.pose.orientation.y || new_pose.pose.orientation.z != current_pose_.pose.orientation.z ||\n        new_pose.pose.orientation.w != current_pose_.pose.orientation.w) {\n        current_pose_ = new_pose;\n        if (publish_voxel_map_) {\n            publishVoxelMap();\n        }\n        publishMap();\n    }\n}", "CodeBleu_score": 41.23927761224496}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  if (tf_) {\n    tf2::Stamped<tf2::Transform> new_pose;\n    try {\n      tf_->transform(robot_base_frame_, ros::Time(0), new_pose, world_frame_);\n    } catch (tf2::TransformException &ex) {\n      ROS_WARN(\"Failed to get robot pose: %s\", ex.what());\n      return;\n    }\n    new_pose.stamp_ = ros::Time::now();\n    if (new_pose.stamp_ != last_robot_motion_stamp_) {\n      if (last_robot_motion_stamp_ != ros::Time(0)) {\n        // calculate the change in position of the robot\n        double dx = new_pose.getOrigin().x() - last_robot_motion_pose_.getOrigin().x();\n        double dy = new_pose.getOrigin().y() - last_robot_motion_pose_.getOrigin().y();\n        double dt = (new_pose.stamp_ - last_robot_motion_stamp_).toSec();\n        double vx = dx / dt;\n        double vy = dy / dt;\n        double v = sqrt(vx * vx + vy * vy);\n        // update the robot velocity\n        robot_velocity_x_ = vx;\n        robot_velocity_y_ = vy;\n        robot_velocity_ = v;\n        // update the robot's position in the costmap\n        double wx = new_pose.getOrigin().x();\n        double wy = new_pose.getOrigin().y();\n        double wth = tf2::getYaw(new_pose.getRotation());\n        double gx = costmap_->getOriginX();\n        double gy = costmap_->getOriginY();\n        double gth = costmap_->getOriginYaw();\n        double dx = (gx - wx) * cos(wth) + (gy - wy) * sin(wth);\n        double dy = (gy - wy) * cos(wth) - (gx - wx) * sin(wth);\n        double dt = (new_pose", "CodeBleu_score": 40.31159810870727}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  if (stopped_) {\n    for (auto it = plugins_.begin(); it != plugins_.end(); ++it) {\n      (*it)->activate();\n    }\n    stopped_ = false;\n  }\n  stop_updates_ = false;\n  while (!ros::ok() || !is_initialized_) {\n    ros::Duration(0.01).sleep();\n  }\n  map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this));\n}", "CodeBleu_score": 46.77736060187578}, {"code": "void Costmap2DROS::start(){\n\t  if (stop_updates_) {\n    ROS_INFO_NAMED(\"costmap\", \"Reactivating plugins\");\n    for (auto it = plugins_.begin(); it != plugins_.end(); ++it) {\n      (*it)->activate();\n    }\n    stop_updates_ = false;\n  }\n\n  // wait until ROS is running\n  while (!ros::ok()) {\n    ros::Duration(0.01).sleep();\n  }\n\n  // wait until the costmap is initialized\n  while (!initialized_) {\n    ros::Duration(0.01).sleep();\n  }\n\n  // wait until the map update thread is active\n  while (!map_update_thread_active_) {\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 47.307296801796575}, {"code": "void Costmap2DROS::start(){\n\t  if (!is_running_) {\n    if (stopped_) {\n      for (auto& plugin : plugins_) {\n        plugin.second->activate();\n      }\n      stopped_ = false;\n    }\n\n    if (!is_running_) {\n      is_running_ = true;\n      if (!initialized_) {\n        initialize();\n      }\n      if (initialized_) {\n        if (!map_update_thread_) {\n          map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateThread, this));\n        }\n        while (!ros::ok() || !initialized_ || !map_update_thread_) {\n          ros::Duration(0.01).sleep();\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 43.655553996350775}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t    if (observation_keep_time_ == ros::Duration(0.0)) {\n        while (!observation_list_.empty()) {\n            if (observation_list_.front().getTime() < ros::Time::now()) {\n                observation_list_.pop_front();\n            } else {\n                break;\n            }\n        }\n    } else {\n        while (!observation_list_.empty()) {\n            if (observation_list_.front().getTime() < ros::Time::now() - observation_keep_time_) {\n                observation_list_.pop_front();\n            } else {\n                break;\n            }\n        }\n    }\n}", "CodeBleu_score": 43.05749550053864}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    if (!observations_.empty()) {\n      observations_.pop_front();\n    }\n  } else {\n    while (!observations_.empty()) {\n      if (observations_.front().header.stamp + observation_keep_time_ > ros::Time::now()) {\n        break;\n      }\n      observations_.pop_front();\n    }\n  }\n}", "CodeBleu_score": 33.01721666497014}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0)) {\n    if (!observations_.empty()) {\n      observations_.pop_front();\n    }\n  } else {\n    while (!observations_.empty()) {\n      if (observations_.front().header.stamp + observation_keep_time_ > ros::Time::now()) {\n        break;\n      }\n      observations_.pop_front();\n    }\n  }\n}", "CodeBleu_score": 30.608546531224306}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  if (start_index >= end_index) {\n    return;\n  }\n\n  // Get the start and end yaw angles\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end angles\n  double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Compute the incremental change in angle for each pose\n  double delta_yaw_inc = delta_yaw / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index; i <= end_index; i++) {\n    double yaw = angles::normalize_angle(start_yaw + i * delta_yaw_inc);\n    tf2::Quaternion q;\n    q.setRPY(0, 0, yaw);\n    path[i].pose.orientation = tf2::toMsg(q);\n  }\n}", "CodeBleu_score": 63.35242894238245}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    // if there are no poses in the path, do nothing\n    if (path.size() == 0) {\n        return;\n    }\n\n    // if the start index is outside the range of the path, do nothing\n    if (start_index < 0 || start_index >= (int)path.size()) {\n        return;\n    }\n\n    // if the end index is outside the range of the path, do nothing\n    if (end_index < 0 || end_index >= (int)path.size()) {\n        return;\n    }\n\n    // if the start index is the same as the end index, do nothing\n    if (start_index == end_index) {\n        return;\n    }\n\n    // if the start index is greater than the end index, swap them\n    if (start_index > end_index) {\n        int temp = start_index;\n        start_index = end_index;\n        end_index = temp;\n    }\n\n    // get the start and end yaw angles\n    tf2::Quaternion start_orientation;\n    tf2::fromMsg(path[start_index].pose.orientation, start_orientation);\n    double start_yaw = tf2::getYaw(start_orientation);\n\n    tf2::Quaternion end_orientation;\n    tf2::fromMsg(path[end_index].pose.orientation, end_orientation);\n    double end_yaw = tf2::getYaw(end_orientation);\n\n    // determine the shortest angular distance between the start and end yaw angles\n    double shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // if the angular distance is less than the threshold, do nothing\n    if (fabs(shortest_angular_distance) < yaw_threshold_) {\n        return;\n    }\n\n    // compute the incremental change in yaw angle for each pose\n    double incremental_yaw_change = shortest_angular_distance / (end_index - start_index);\n\n    // update the orientation of each pose in the specified range\n    for (int i = start_index; i <= end_index", "CodeBleu_score": 48.672594679952894}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n    if (start_index < 0 || end_index >= path.size()) {\n        return;\n    }\n\n    if (start_index >= end_index) {\n        return;\n    }\n\n    // Get the yaw angle at the start and end indices\n    tf2::Quaternion start_quat, end_quat;\n    tf2::fromMsg(path[start_index].pose.orientation, start_quat);\n    tf2::fromMsg(path[end_index].pose.orientation, end_quat);\n\n    double start_angle = tf2::getYaw(start_quat);\n    double end_angle = tf2::getYaw(end_quat);\n\n    // Calculate the shortest angular distance between the two yaw angles\n    double angular_distance = angles::shortest_angular_distance(start_angle, end_angle);\n\n    // Determine the incremental change in angle for each pose\n    double incremental_angle = angular_distance / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index; i < end_index; i++) {\n        tf2::Quaternion quat;\n        quat.setRPY(0, 0, start_angle);\n        path[i].pose.orientation = tf2::toMsg(quat);\n        start_angle += incremental_angle;\n    }\n}", "CodeBleu_score": 50.63305958526608}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the start and goal frames to \"map\"\n    req.start.header.frame_id = req.goal.header.frame_id = \"map\";\n    // Call the makePlan function to generate a path\n    std::vector<geometry_msgs::PoseStamped> path;\n    bool success = makePlan(req.start, req.goal, path);\n    // Update the response with the success status and the generated path\n    resp.success = success;\n    if (success) {\n        resp.plan = path;\n    }\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 78.88313594453918}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\n    //set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    //call makePlan to generate a path\n    bool success = makePlan(req.start, req.goal, resp.plan);\n\n    //update the response with the success status and the generated path if a plan is found\n    resp.success = success;\n\n    return true;\n}", "CodeBleu_score": 62.314760403495825}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// set the start and goal frames to be the same as the map\n\tgeometry_msgs::PoseStamped start, goal;\n\tstart.header.frame_id = goal.header.frame_id = \"map\";\n\tstart.header.stamp = goal.header.stamp = ros::Time::now();\n\tstart.pose = req.start;\n\tgoal.pose = req.goal;\n\t// make the plan\n\tbool success = makePlan(start, goal, resp.plan);\n\t// set the success status and return\n\tresp.success = success;\n\treturn true;\n}", "CodeBleu_score": 51.19239670966176}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle nh(\"~/\" + name);\n    costmap_ = cmap;\n    costmap_ros_ = cmap;\n    make_plan_srv_ = nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 63.273223089340355}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle nh(\"~/\" + name);\n    costmap_ros_ = cmap;\n    costmap_ = costmap_ros_->getCostmap();\n    make_plan_srv_ = nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 62.425998495317955}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~/\" + name);\n    ros::NodeHandle nh;\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = nh.subscribe(\"move_base_simple/goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 61.3043925535257}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n      wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    return false;\n  }\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  return true;\n}", "CodeBleu_score": 42.896701384277755}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n      wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    return false;\n  }\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n  return true;\n}", "CodeBleu_score": 42.896701384277755}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\n    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n        wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n        wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY())\n        return false;\n\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n    return true;\n}", "CodeBleu_score": 44.94892980760168}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_)  {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++)  {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 91.76350942948643}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\n    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    // create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n    gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n\n}", "CodeBleu_score": 93.3682171045552}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n  gui_path.poses.resize(path.size());\n\n  // copy each pose\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  // publish the plan\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 88.27078703211053}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    ROS_DEBUG(\"Wrapping goal in an action message\");\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 71.55042166845284}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG(\"Wrapping goal in an action message\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 71.22884794651873}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    ROS_DEBUG(\"Wrapping goal in an action message\");\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 71.55042166845284}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  // check if we have moved far enough\n  if (sqrt(limited_distance_) < sqrt(current_distance_)) {\n    ROS_INFO(\"MoveSlowAndClear: Robot has moved far enough to clear obstacles.\");\n    // join and delete the remove limit thread if it exists\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    // start a new thread to remove the speed limit\n    remove_limit_thread_ = new boost::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n    // stop the distance check timer\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 66.20364649061364}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  // If the robot has moved far enough, it logs a message, joins and deletes any existing remove limit thread, starts a new thread to remove the speed limit, and stops the distance check timer.\n  if (sqrt(limited_distance_) < sqrt(distance_)) {\n    ROS_INFO(\"The robot has moved far enough. Removing the speed limit.\");\n    if (remove_limit_thread_ != nullptr) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = nullptr;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 70.5727150014355}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (distance_squared_limited_ >= distance_squared_current_) {\n    ROS_INFO_STREAM(\"MoveSlowAndClear: Robot has moved far enough to remove speed limit.\");\n    if (remove_limit_thread_.joinable()) {\n      remove_limit_thread_.join();\n    }\n    remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeLimit, this);\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 43.37870282696913}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  tf2::Transform transform;\n  tf2::fromMsg(goal->pose, transform);\n\n  // get the robot pose\n  tf2::Transform robot_pose;\n  try {\n    robot_pose = tf_buffer_.lookupTransform(goal->header.frame_id,\n                                            robot_base_frame_,\n                                            goal->header.stamp,\n                                            ros::Duration(0.5));\n  } catch (tf2::TransformException& ex) {\n    ROS_WARN(\"%s\", ex.what());\n    return;\n  }\n\n  // convert the robot pose to a navfn pose\n  navfn::PoseStamped navfn_pose;\n  navfn_pose.header = goal->header;\n  navfn_pose.pose.x = robot_pose.getOrigin().x();\n  navfn_pose.pose.y = robot_pose.getOrigin().y();\n  navfn_pose.pose.theta = tf2::getYaw(robot_pose.getRotation());\n\n  // make the plan\n  std::vector<navfn::PoseStamped> path;\n  if (makePlan(navfn_pose, transform, path)) {\n    // publish the plan\n    path_pub_.publish(path);\n  }\n}", "CodeBleu_score": 42.703242027195586}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    if (!initialized_) {\n        ROS_ERROR(\"NavfnWithCostmap has not been initialized yet\");\n        return;\n    }\n\n    if (!goal->header.frame_id.empty() && goal->header.frame_id != costmap_ros_->getGlobalFrameID()) {\n        ROS_ERROR(\"The goal pose has a different frame ID than the costmap. Please transform the goal pose to the costmap frame\");\n        return;\n    }\n\n    if (goal->header.frame_id.empty()) {\n        ROS_WARN(\"The goal pose has an empty frame ID. The goal pose will be assumed to be in the costmap frame\");\n    }\n\n    geometry_msgs::PoseStamped global_pose;\n    global_pose.header.frame_id = costmap_ros_->getGlobalFrameID();\n    global_pose.header.stamp = ros::Time::now();\n    global_pose.pose = getRobotPose();\n\n    if (global_pose.pose.position.x == 0 && global_pose.pose.position.y == 0) {\n        ROS_ERROR(\"Could not get robot pose. Aborting.\");\n        return;\n    }\n\n    std::vector<geometry_msgs::PoseStamped> path;\n    if (!makePlan(global_pose, *goal, path)) {\n        ROS_ERROR(\"Could not find a plan. Aborting.\");\n        return;\n    }\n\n    // publish the path\n    path_pub_.publish(path);\n}", "CodeBleu_score": 46.57373332951414}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the global pose of the robot\n  tf::Stamped<tf::Pose> robot_pose;\n  try {\n    tf_listener_.waitForTransform(global_frame_, base_frame_, ros::Time(0),\n                                  ros::Duration(10.0));\n    tf_listener_.transformPose(global_frame_, *goal, robot_pose);\n  } catch (tf::TransformException ex) {\n    ROS_ERROR(\"Received an exception trying to transform a pose from \\\"%s\\\" \"\n              \"to \\\"%s\\\": %s\",\n              goal->header.frame_id.c_str(), global_frame_.c_str(),\n              ex.what());\n    return;\n  }\n\n  // Create a path to the goal\n  std::vector<geometry_msgs::PoseStamped> path;\n  if (!makePlan(robot_pose, goal->pose, path)) {\n    ROS_ERROR(\"Could not find a path to the goal\");\n    return;\n  }\n\n  // Publish the path\n  nav_msgs::Path plan;\n  plan.poses.resize(path.size());\n  for (unsigned int i = 0; i < path.size(); i++) {\n    plan.poses[i] = path[i];\n  }\n  plan.header.stamp = ros::Time::now();\n  plan.header.frame_id = global_frame_;\n  plan_pub_.publish(plan);\n}", "CodeBleu_score": 45.08607013516212}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\n    // Create a new parameter set service request\n    rclcpp::Client<mavros_msgs::srv::ParamSet>::SharedPtr param_set_client_ =\n        this->create_client<mavros_msgs::srv::ParamSet>(\"mavros/param/set\");\n\n    // Wait for the service to be ready\n    while (!param_set_client_->wait_for_service(1s)) {\n        if (!rclcpp::ok()) {\n            RCLCPP_ERROR(this->get_logger(), \"AutonomousLanding::gimbalParamSetServer was interrupted while waiting for the service. Exiting.\");\n            return;\n        }\n        RCLCPP_INFO(this->get_logger(), \"AutonomousLanding::gimbalParamSetServer waiting for the service to be available.\");\n    }\n\n    // Create a new parameter set service request\n    auto request = std::make_shared<mavros_msgs::srv::ParamSet::Request>();\n\n    // Assign the parameter ID and value to the service request\n    request->param_id = param_set.param_id;\n    request->param_value = param_set.param_value;\n\n    // Send the service request\n    auto result = param_set_client_->async_send_request(request);\n\n    // Wait for the result\n    if (rclcpp::spin_until_future_complete(this->get_node_base_interface(), result) !=\n        rclcpp::FutureReturnCode::SUCCESS) {\n        RCLCPP_ERROR(this->get_logger(), \"AutonomousLanding::gimbalParamSetServer failed. Exiting.\");\n        return;\n    }\n\n    // Check the result\n    if (result.get()->success) {\n        RCLCPP_INFO(this->get_logger(), \"AutonomousLanding::gimbalParamSetServer succeeded.\");\n    } else {\n        RCLCPP_ERROR(this->get_logger(), \"AutonomousLanding::gimbalParamSetServer failed.\");\n    }\n}", "CodeBleu_score": 36.76244381703005}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    // Create a service request\n    mavros_msgs::ParamSetRequest request;\n    // Assign parameter ID and value to the request\n    request.param_id = param_set.param_id;\n    request.param_value = param_set.param_value;\n    // Send the request\n    param_set_client_.call(request);\n}", "CodeBleu_score": 55.94973486328696}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\n    // Create a service request for the ParamSet service\n    std_srvs::SetBool::Request req;\n\n    // Assign the parameter ID and value to the service request\n    req.data = param_set.value;\n    param_set_client_.call(req, param_set.id);\n\n}", "CodeBleu_score": 42.788517226689756}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\t// Create a socket to listen for incoming connections\n\tint sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n\t// If the socket is invalid, throw an error\n\tif (sockfd < 0) {\n\t\tthrow std::runtime_error(\"ERROR opening socket\");\n\t}\n\n\t// Bind the socket to the specified port\n\tsockaddr_in serv_addr;\n\tmemset(&serv_addr, 0, sizeof(serv_addr));\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(port);\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tthrow std::runtime_error(\"ERROR on binding\");\n\t}\n\n\t// Listen for incoming connections\n\tlisten(sockfd, 1);\n\n\t// Enter an infinite loop to accept incoming connections\n\twhile (true) {\n\t\t// Wait for an incoming connection\n\t\tsockaddr_in cli_addr;\n\t\tsocklen_t clilen = sizeof(cli_addr);\n\t\tint newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\n\t\t// If the connection is invalid, throw an error\n\t\tif (newsockfd < 0) {\n\t\t\tthrow std::runtime_error(\"ERROR on accept\");\n\t\t}\n\n\t\t// Receive data\n\t\tchar buffer[256];\n\t\tint n = read(newsockfd, buffer, 255);\n\n\t\t// If the message length is zero or less, log an error and close the socket\n\t\tif (n <= 0) {\n\t\t\tROS_ERROR(\"ERROR reading from socket\");\n\t\t\tclose(newsockfd);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Decode the message\n\t\tstd::string message(buffer, n);\n\t\tdecodeMessage(message);\n\n\t\t// Close the socket\n\t\tclose(newsockfd);\n\t", "CodeBleu_score": 45.45594267356964}, {"code": "void CommunicationBridge::serverFun(){\n\t\n\t// Set up the socket\n\tboost::asio::ip::tcp::acceptor acceptor(io_service, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port));\n\n\t// Wait for a connection\n\tboost::asio::ip::tcp::socket socket(io_service);\n\tacceptor.accept(socket);\n\n\t// Enter the loop to handle multiple connections\n\twhile (true) {\n\t\t// Wait for a connection\n\t\tacceptor.accept(socket);\n\n\t\t// Enter the loop to handle the connection\n\t\twhile (true) {\n\t\t\t// Receive data\n\t\t\tboost::array<char, 1024> buf;\n\t\t\tsize_t len = socket.read_some(boost::asio::buffer(buf));\n\n\t\t\t// If data is received successfully, process it\n\t\t\tif (len > 0) {\n\t\t\t\t// Decode the message and publish it\n\t\t\t\tdecodeAndPublish(buf, len);\n\t\t\t}\n\t\t\t// If the received message length is zero or less, log an error and close the socket\n\t\t\telse {\n\t\t\t\tROS_ERROR(\"CommunicationBridge::serverFun: Received message length is zero or less\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 24.466140695682085}, {"code": "void CommunicationBridge::serverFun(){\n\t\n    // Wait for a connection from the ground station\n    if (listen(sockfd, 1) < 0) {\n        std::cout << \"Error: Listen failed\" << std::endl;\n        exit(1);\n    }\n\n    // Accept a connection\n    int new_fd;\n    struct sockaddr_in their_addr;\n    socklen_t sin_size = sizeof(their_addr);\n    new_fd = accept(sockfd, (struct sockaddr *)&their_addr, &sin_size);\n    if (new_fd == -1) {\n        std::cout << \"Error: Accept failed\" << std::endl;\n        exit(1);\n    }\n\n    // Receive data\n    char buf[1024];\n    int numbytes = 0;\n    while (1) {\n        numbytes = recv(new_fd, buf, 1024, 0);\n        if (numbytes <= 0) {\n            std::cout << \"Error: Receive failed\" << std::endl;\n            exit(1);\n        }\n\n        // Decode message\n        std::string message = decodeMessage(buf, numbytes);\n\n        // Publish message\n        if (message.length() > 0) {\n            publishMessage(message);\n        }\n    }\n\n    // Close socket\n    close(new_fd);\n    close(sockfd);\n}", "CodeBleu_score": 46.39774858250008}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\n    if (uav_cmd.id == -1) {\n        ROS_ERROR(\"CommunicationBridge::recvData: UAV ID is -1. Cannot process command.\");\n        return;\n    }\n\n    if (uav_cmd.id == 0) {\n        ROS_ERROR(\"CommunicationBridge::recvData: UAV ID is 0. Cannot process command.\");\n        return;\n    }\n\n    if (uav_cmd.id > swarm_control_simulation_.size()) {\n        ROS_ERROR(\"CommunicationBridge::recvData: UAV ID is %d, but the swarm size is %d. Cannot process command.\", uav_cmd.id, swarm_control_simulation_.size());\n        return;\n    }\n\n    if (simulation_mode_) {\n        swarm_control_simulation_[uav_cmd.id-1].publishCommand(uav_cmd);\n    } else {\n        uav_basic_.publishCommand(uav_cmd);\n    }\n\n}", "CodeBleu_score": 41.866231536291615}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (!simulation_mode_) {\n        uav_basic_.publish(uav_cmd);\n    } else {\n        std::shared_lock<boost::shared_mutex> lock(swarm_control_simulation_mutex_);\n        for (auto &uav_sim : swarm_control_simulation_) {\n            if (uav_sim.getUAVID() == uav_cmd.uav_id) {\n                uav_sim.publish(uav_cmd);\n                break;\n            }\n        }\n    }\n}", "CodeBleu_score": 43.110575700443455}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\n    if (uav_cmd.ID == 0) {\n        ROS_ERROR(\"Received command with ID 0, ignoring...\");\n        return;\n    }\n\n    // If in simulation mode, find the UAV by ID and publish to it\n    if (simulation_mode_) {\n        // Find the UAV by ID\n        boost::shared_lock<boost::shared_mutex> lock(swarm_control_simulation_mutex_);\n        std::vector<UAV*>::iterator it = std::find_if(swarm_control_simulation_.begin(), swarm_control_simulation_.end(),\n                                                      [&](UAV* uav) { return uav->get_ID() == uav_cmd.ID; });\n        if (it == swarm_control_simulation_.end()) {\n            ROS_ERROR(\"Received command for unknown UAV with ID %d, ignoring...\", uav_cmd.ID);\n            return;\n        }\n\n        // Publish to the UAV\n        (*it)->recvData(uav_cmd);\n\n    } else {\n        // Publish to the UAV\n        uav_basic_.recvData(uav_cmd);\n    }\n\n}", "CodeBleu_score": 45.57903560476202}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if(mode_selection.use_mode == 0) {\n        if(mode_selection.mode == \"REBOOTNX\") {\n            std::cout << \"Rebooting NX\" << std::endl;\n            system(\"reboot\");\n        } else if(mode_selection.mode == \"EXITNX\") {\n            std::cout << \"Exiting NX\" << std::endl;\n            system(\"exit\");\n        }\n    } else {\n        if(mode_selection.mode == \"REBOOTNX\") {\n            std::cout << \"Rebooting NX\" << std::endl;\n            system(\"reboot\");\n        } else if(mode_selection.mode == \"EXITNX\") {\n            std::cout << \"Exiting NX\" << std::endl;\n            system(\"exit\");\n        }\n    }\n}", "CodeBleu_score": 40.8767101806983}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    std::cout << \"modeSwitch: \" << mode_selection.use_mode << std::endl;\n    if (mode_selection.use_mode == \"REBOOTNX\") {\n        std::cout << \"modeSwitch: rebooting\" << std::endl;\n        system(\"reboot\");\n    } else if (mode_selection.use_mode == \"EXITNX\") {\n        std::cout << \"modeSwitch: exiting\" << std::endl;\n        system(\"exit\");\n    } else {\n        if (mode_selection.create_mode) {\n            createMode(mode_selection.use_mode);\n        } else {\n            deleteMode(mode_selection.use_mode);\n        }\n    }\n}", "CodeBleu_score": 51.02169378135901}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    switch (mode_selection.mode) {\n        case REBOOTNX:\n            system(\"reboot\");\n            break;\n        case EXITNX:\n            system(\"exit\");\n            break;\n        case CREATEMODE:\n            createMode(mode_selection.mode_name);\n            break;\n        case DELETEMODE:\n            deleteMode(mode_selection.mode_name);\n            break;\n        case USEMODE:\n            useMode(mode_selection.mode_name);\n            break;\n        case LISTMODES:\n            listModes();\n            break;\n        case SETMODE:\n            setMode(mode_selection.mode_name);\n            break;\n        case UNSETMODE:\n            unsetMode(mode_selection.mode_name);\n            break;\n        case LISTSETMODES:\n            listSetModes();\n            break;\n        case LISTUNSETMODES:\n            listUnsetModes();\n            break;\n        case LISTALLMODES:\n            listAllModes();\n            break;\n        case LISTSETANDUNSETMODES:\n            listSetAndUnsetModes();\n            break;\n        case LISTSETANDUNSETMODESANDDEFAULT:\n            listSetAndUnsetModesAndDefault();\n            break;\n        case LISTSETANDUNSETMODESANDDEFAULTANDCURRENT:\n            listSetAndUnsetModesAndDefaultAndCurrent();\n            break;\n        case LISTSETANDUNSETMODESANDDEFAULTANDCURRENTANDALL:\n            listSetAndUnsetModesAndDefaultAndCurrentAndAll();\n            break;\n        case LISTSETANDUNSETMODESANDDEFAULTANDCURRENTANDALLANDALL:\n            listSetAndUnsetModesAndDefaultAndCurrentAndAllAndAll();\n            break;\n        case LISTSETANDUNSETMODESANDDEFAULTANDCURRENTANDALLANDALLANDALL:\n            listSetAndUnsetModesAndDefaultAndCurrentAndAllAndAllAndAll();\n            break;\n        case LISTSETANDUNSETMODESANDDEFAULTANDCURRENTANDALLANDALLANDALLANDALL:\n            listSetAndUnsetModesAndDefaultAndCurrentAndAllAndAllAndAllAnd", "CodeBleu_score": 35.47366196388916}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  if (heartbeat_count == 0) {\n    ROS_INFO_STREAM(\"Communication Bridge: Heartbeat received.\");\n    heartbeat_count = 1;\n  } else if (heartbeat_count > 0) {\n    heartbeat_count++;\n  }\n\n  if (heartbeat_count == 10) {\n    ROS_ERROR_STREAM(\"Communication Bridge: Heartbeat count exceeded.\");\n    if (vehicle_type == \"swarm\") {\n      ROS_ERROR_STREAM(\"Communication Bridge: Swarm disconnected.\");\n      disconnect_flag = true;\n    } else if (vehicle_type == \"uav\") {\n      ROS_ERROR_STREAM(\"Communication Bridge: UAV disconnected.\");\n      disconnect_flag = true;\n    } else if (vehicle_type == \"ugv\") {\n      ROS_ERROR_STREAM(\"Communication Bridge: UGV disconnected.\");\n      disconnect_flag = true;\n    }\n  }\n}", "CodeBleu_score": 39.46814529830357}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    boost::mutex::scoped_lock lock(heartbeat_mutex);\n    if (heartbeat_count == 0) {\n        ROS_ERROR(\"Lost connection to the drone.\");\n        if (vehicle_type == \"swarm\") {\n            ROS_ERROR(\"Please check if the drone is in the air.\");\n        }\n        else if (vehicle_type == \"uav\") {\n            ROS_ERROR(\"Please check if the drone is in the air.\");\n        }\n        else if (vehicle_type == \"ugv\") {\n            ROS_ERROR(\"Please check if the drone is in the air.\");\n        }\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count > 0) {\n        heartbeat_count--;\n    }\n}", "CodeBleu_score": 34.764285785878144}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  // Check if the heartbeat has been received\n  if (heartbeat_received == true) {\n    // Reset the heartbeat counter\n    heartbeat_counter = 0;\n    // Set the heartbeat flag to true\n    heartbeat_received = false;\n  } else {\n    // Increment the heartbeat counter\n    heartbeat_counter++;\n  }\n  // Check if the heartbeat counter is greater than the max heartbeat counter\n  if (heartbeat_counter > max_heartbeat_counter) {\n    // Print an error message\n    ROS_ERROR(\"[Communication Bridge] - Heartbeat lost!\");\n    // Set the disconnect flag to true\n    disconnect_flag = true;\n    // Check if the vehicle is a swarm\n    if (vehicle_type == \"swarm\") {\n      // Trigger the swarm disconnect function\n      swarmDisconnect();\n    } else if (vehicle_type == \"UAV\") {\n      // Trigger the UAV disconnect function\n      UAVDisconnect();\n    } else if (vehicle_type == \"UGV\") {\n      // Trigger the UGV disconnect function\n      UGVDisconnect();\n    }\n  }\n}", "CodeBleu_score": 33.52290272696396}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract the drone ID and trajectory data from the message\n    int drone_id = msg->id;\n    prometheus_msgs::Bspline bspline = msg->trajectory;\n\n    // Initialize a Bspline struct\n    Bspline bspline_struct;\n\n    // Set the attributes of the Bspline struct\n    bspline_struct.drone_id = drone_id;\n    bspline_struct.order = bspline.order;\n    bspline_struct.n_points = bspline.n_points;\n    bspline_struct.n_segments = bspline.n_segments;\n    bspline_struct.duration = bspline.duration;\n    bspline_struct.start_time = bspline.start_time;\n    bspline_struct.dim = bspline.dim;\n    bspline_struct.max_time = bspline.max_time;\n    bspline_struct.max_position = bspline.max_position;\n    bspline_struct.max_velocity = bspline.max_velocity;\n    bspline_struct.max_acceleration = bspline.max_acceleration;\n    bspline_struct.max_jerk = bspline.max_jerk;\n    bspline_struct.max_yaw = bspline.max_yaw;\n    bspline_struct.max_dyaw = bspline.max_dyaw;\n\n    // Populate the knots, position points, and yaw points of the Bspline struct\n    bspline_struct.knots = bspline.knots;\n    bspline_struct.points = bspline.points;\n    bspline_struct.yaw = bspline.yaw;\n\n    // Encode the Bspline struct data into a string\n    string bspline_str = encodeBspline(bspline_struct);\n\n    // Send the Bspline struct data via TCP using the communication module\n    comm_module->sendTcp(bspline_str);\n}", "CodeBleu_score": 28.295392920239}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\n    // Create a MultiBsplines message to be sent via TCP\n    prometheus_msgs::MultiBsplines multiBsplinesTcpMsg;\n\n    // Get the drone ID from the incoming message\n    multiBsplinesTcpMsg.id = msg->id;\n\n    // Get the number of trajectories in the incoming message\n    int numTraj = msg->traj.size();\n\n    // Loop through the trajectories in the incoming message\n    for (int i = 0; i < numTraj; i++) {\n\n        // Create a Bspline struct to hold the trajectory data\n        Bspline bspline;\n\n        // Get the number of knots in the incoming trajectory\n        int numKnots = msg->traj[i].knots.size();\n\n        // Loop through the knots in the incoming trajectory\n        for (int j = 0; j < numKnots; j++) {\n\n            // Create a Knot struct to hold the knot data\n            Knot knot;\n\n            // Get the knot data from the incoming message\n            knot.x = msg->traj[i].knots[j].x;\n            knot.y = msg->traj[i].knots[j].y;\n            knot.z = msg->traj[i].knots[j].z;\n            knot.yaw = msg->traj[i].knots[j].yaw;\n\n            // Add the knot data to the Bspline struct\n            bspline.knots.push_back(knot);\n        }\n\n        // Get the number of position points in the incoming trajectory\n        int numPos = msg->traj[i].pos.size();\n\n        // Loop through the position points in the incoming trajectory\n        for (int j = 0; j < numPos; j++) {\n\n            // Create a PositionPoint struct to hold the position point data\n            PositionPoint posPoint;\n\n            // Get the position point data from the incoming message\n            posPoint.x = msg->traj[i].pos[j].x;\n            posPoint.y = msg->traj[i", "CodeBleu_score": 46.5914933228887}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Get drone ID\n    int id = msg->id;\n\n    // Get number of trajectories\n    int num_traj = msg->trajs.size();\n\n    // Create a MultiBspline struct\n    prometheus_msgs::MultiBspline multi_bspline;\n\n    // Set MultiBspline attributes\n    multi_bspline.id = id;\n    multi_bspline.header = msg->header;\n\n    // Initialize a Bspline struct for each trajectory\n    prometheus_msgs::Bspline bspline;\n\n    // Iterate through trajectories\n    for (int i = 0; i < num_traj; i++) {\n        // Get trajectory data\n        prometheus_msgs::Bspline traj = msg->trajs[i];\n\n        // Set Bspline attributes\n        bspline.id = traj.id;\n        bspline.header = traj.header;\n        bspline.knots = traj.knots;\n        bspline.points = traj.points;\n        bspline.yaw_points = traj.yaw_points;\n\n        // Set Bspline knots\n        bspline.knots.x = traj.knots.x;\n        bspline.knots.y = traj.knots.y;\n        bspline.knots.z = traj.knots.z;\n\n        // Set Bspline position points\n        bspline.points.x = traj.points.x;\n        bspline.points.y = traj.points.y;\n        bspline.points.z = traj.points.z;\n\n        // Set Bspline yaw points\n        bspline.yaw_points = traj.yaw_points;\n\n        // Add Bspline to MultiBspline\n        multi_bspline.trajs.push_back(bspline);\n    }\n\n    // Encode MultiBspline data\n    std::string data = encodeMultiBspline(multi_bspline);\n\n    // Send Multi", "CodeBleu_score": 40.35496660457227}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Create a new point cloud\n    pcl::PointCloud<pcl::PointXYZRGB> cloud;\n    // Convert the message to a point cloud\n    pcl::fromROSMsg(msg, cloud);\n\n    // Create a new octree\n    pcl::octree::OctreePointCloudSearch<pcl::PointXYZRGB> octree(0.01);\n    // Set the octree resolution\n    octree.setResolution(0.01);\n    // Add the point cloud to the octree\n    octree.setInputCloud(cloud.makeShared());\n    // Build the octree\n    octree.addPointsFromInputCloud();\n    // Create a new point cloud\n    pcl::PointCloud<pcl::PointXYZRGB> cloud_compressed;\n    // Compress the point cloud\n    octree.voxelTraversalAndCompression(cloud_compressed);\n\n    // Create a new point cloud message\n    sensor_msgs::PointCloud2 msg_compressed;\n    // Convert the point cloud to a point cloud message\n    pcl::toROSMsg(cloud_compressed, msg_compressed);\n    // Set the point cloud message header\n    msg_compressed.header = msg.header;\n\n    // Return the point cloud message\n    return msg_compressed;\n}", "CodeBleu_score": 30.681640653953966}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n    // Declare a new pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZRGB> cloud;\n\n    // Convert the ROS message to a pcl::PointCloud\n    pcl::fromROSMsg(msg, cloud);\n\n    // Declare a new pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZRGB> cloud_compressed;\n\n    // Declare a new pcl::octree::OctreePointCloudSearch object\n    pcl::octree::OctreePointCloudSearch<pcl::PointXYZRGB> octree(resolution_);\n\n    // Set the octree resolution\n    octree.setResolution(resolution_);\n\n    // Build the octree\n    octree.setInputCloud(cloud.makeShared());\n    octree.addPointsFromInputCloud();\n\n    // Compress the point cloud\n    octree.getVoxelCentroids(cloud_compressed);\n\n    // Convert the pcl::PointCloud to a ROS message\n    sensor_msgs::PointCloud2 msg_compressed;\n    pcl::toROSMsg(cloud_compressed, msg_compressed);\n\n    // Set the header of the ROS message\n    msg_compressed.header = msg.header;\n\n    // Release dynamically allocated memory\n    cloud.clear();\n    cloud_compressed.clear();\n\n    // Return the compressed ROS message\n    return msg_compressed;\n}", "CodeBleu_score": 32.44074102519506}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n    // Create a pcl::PointCloud object from the input message\n    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZRGB>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Create an octree object and set the resolution\n    pcl::octree::OctreePointCloudSearch<pcl::PointXYZRGB> octree(resolution_);\n    octree.setInputCloud(cloud);\n\n    // Compress the point cloud\n    octree.addPointsFromInputCloud();\n    octree.deleteTree();\n\n    // Create a new PointCloud2 message and set its header\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n\n    // Set the fields of the PointCloud2 message\n    compressed_msg.fields = msg.fields;\n    compressed_msg.height = 1;\n    compressed_msg.width = 1;\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = sizeof(uint32_t);\n    compressed_msg.row_step = compressed_msg.point_step;\n    compressed_msg.is_dense = true;\n\n    // Set the data of the PointCloud2 message\n    compressed_msg.data.resize(sizeof(uint32_t));\n    memcpy(&compressed_msg.data[0], &octree.getRoot().getData(), sizeof(uint32_t));\n\n    // Return the compressed message\n    return compressed_msg;\n\n}", "CodeBleu_score": 37.349773986305365}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < multi_uav_state_.uav_state_size(); i++) {\n        if (multi_uav_state_.uav_state(i).uav_id() == uav_state.uav_id()) {\n            multi_uav_state_.mutable_uav_state(i)->CopyFrom(uav_state);\n        }\n    }\n}", "CodeBleu_score": 58.38621666966506}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    // Iterate through the list of UAV states and replace the matching UAV state with the new uav_state data based on the UAV ID.\n    for(int i = 0; i < multi_uav_state_.size(); i++) {\n        if(multi_uav_state_[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 52.47493356862532}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tstd::vector<struct UAVState>::iterator it;\n\tfor (it = multi_uav_state_.begin(); it != multi_uav_state_.end(); ++it) {\n\t\tif (it->uav_id == uav_state.uav_id) {\n\t\t\t*it = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 47.16936302469647}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  // Initialize the MultiUGVState message\n  m_multi_ugv_state_msg.header.frame_id = \"world\";\n  m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n  m_multi_ugv_state_msg.count = 0;\n\n  // Iterate through each UGV state\n  for (int i = 0; i < m_multi_ugv_state.count; i++) {\n    // Initialize the UGVState message\n    m_ugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n    m_ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n    m_ugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position[0];\n    m_ugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position[1];\n    m_ugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position[2];\n    m_ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity[0];\n    m_ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity[1];\n    m_ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity[2];\n    m_ugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude[0];\n    m_ugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude[1];\n    m_ugv_state_msg.attitude.z = m_multi_ugv_state.ugv_state[i].attitude[2];", "CodeBleu_score": 43.24410331311963}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    // Initialize a MultiUGVState message\n    m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n    m_multi_ugv_state_msg.header.frame_id = \"map\";\n    m_multi_ugv_state_msg.num_ugv = 0;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.num_ugv; i++) {\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        m_ugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n        m_ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n        m_ugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        m_ugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        m_ugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        m_ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        m_ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n        m_ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n        m_ugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n        m_ugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n        m_ugv_state_msg", "CodeBleu_score": 44.43278887432209}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\n    // Initialize the MultiUGVState message\n    m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n    m_multi_ugv_state_msg.header.frame_id = \"map\";\n    m_multi_ugv_state_msg.UGV_count = 0;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.UGV_count; i++) {\n\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        m_ugv_state_msg.ID = m_multi_ugv_state.UGV_state[i].ID;\n        m_ugv_state_msg.battery = m_multi_ugv_state.UGV_state[i].battery;\n        m_ugv_state_msg.pos.x = m_multi_ugv_state.UGV_state[i].pos.x;\n        m_ugv_state_msg.pos.y = m_multi_ugv_state.UGV_state[i].pos.y;\n        m_ugv_state_msg.pos.z = m_multi_ugv_state.UGV_state[i].pos.z;\n        m_ugv_state_msg.vel.x = m_multi_ugv_state.UGV_state[i].vel.x;\n        m_ugv_state_msg.vel.y = m_multi_ugv_state.UGV_state[i].vel.y;\n        m_ugv_state_msg.vel.z = m_multi_ugv_state.UGV_state[i].vel.z;\n        m_ugv_state_msg.att.x = m_multi_ugv_state.UGV_state[i].att.x;\n        m_ugv_state_msg.att.y = m_multi_ugv_state.UGV_state[i].att.y;\n        m_ugv_state_msg.att.z = m_multi", "CodeBleu_score": 43.752830296188904}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    // initialize the cost and gradient\n    cost = 0;\n    gradient.setZero(q.rows(), q.cols());\n\n    // iterate through control points\n    for (int i = 0; i < q.rows(); i++) {\n        // compute the predicted positions of moving objects\n        std::vector<Eigen::Vector3d> predicted_positions;\n        for (auto &moving_object : moving_objects_) {\n            predicted_positions.push_back(moving_object.getPredictedPosition(q.row(i)));\n        }\n\n        // iterate through moving objects\n        for (int j = 0; j < moving_objects_.size(); j++) {\n            // compute the distance between the control point and the moving object\n            double distance = moving_objects_[j].computeDistance(q.row(i), predicted_positions[j]);\n\n            // if the distance is less than the clearance\n            if (distance < moving_objects_[j].clearance_) {\n                // update the cost and gradient\n                cost += distance;\n                gradient.row(i) += moving_objects_[j].computeGradient(q.row(i), predicted_positions[j]);\n            }\n        }\n    }\n}", "CodeBleu_score": 37.121451842604735}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    int n_cp = q.cols();\n    int n_obj = moving_objects_.size();\n\n    double dist, dist_cost;\n    Eigen::Vector3d diff;\n\n    cost = 0.0;\n    gradient.setZero();\n\n    for (int i = 0; i < n_cp; i++) {\n        for (int j = 0; j < n_obj; j++) {\n            // Compute the predicted position of moving objects\n            moving_objects_[j]->predictPos(q.col(i));\n\n            // Compute the distance between the current control point and the predicted position of the object\n            diff = moving_objects_[j]->pos_pred_ - q.col(i);\n            dist = diff.norm();\n\n            // If the distance is less than a specified clearance, update the cost and gradient\n            if (dist < moving_objects_[j]->clearance_) {\n                dist_cost = dist - moving_objects_[j]->clearance_;\n                cost += dist_cost * dist_cost;\n\n                // Update the gradient\n                gradient.col(i) += 2.0 * dist_cost * diff;\n            }\n        }\n    }\n}", "CodeBleu_score": 41.16458587048524}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // get the number of control points\n  int num_cp = q.cols();\n\n  // initialize the cost and gradient\n  cost = 0;\n  gradient.setZero(3, num_cp);\n\n  // iterate through control points\n  for (int i = 0; i < num_cp; i++) {\n    // get the position of the i-th control point\n    Eigen::Vector3d cp = q.col(i);\n\n    // get the predicted positions of moving objects\n    Eigen::MatrixXd pred_pos = getPredictedPos(cp, i);\n\n    // evaluate the distance between the control point and predicted positions of moving objects\n    Eigen::VectorXd dist = (pred_pos - cp).colwise().norm();\n\n    // if the distance is less than the clearance, update the cost and gradient\n    for (int j = 0; j < dist.rows(); j++) {\n      if (dist(j) < clearance_) {\n        cost += dist(j);\n        gradient.col(i) += (pred_pos.col(j) - cp).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 33.3868527234168}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n    // Initialize cost and gradient\n    cost = 0.0;\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    // Iterate through all control points\n    for (int i = 0; i < q.rows(); i++) {\n\n        // Compute the positional error\n        Eigen::Vector3d err = q.row(i) - q_ref.row(i);\n\n        // Compute the velocity vector\n        Eigen::Vector3d v = (q.row(i + 1) - q.row(i - 1)) / 2.0;\n\n        // Compute the cost and gradient\n        double cost_i = a2 * err.dot(err) + b2 * v.dot(err);\n        gradient.row(i) = 2.0 * a2 * err + b2 * v;\n\n        // Update the cost\n        cost += cost_i;\n    }\n}", "CodeBleu_score": 28.238732914825665}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0;\n  gradient.setZero();\n  double a2 = 1000;\n  double b2 = 1000;\n  Eigen::VectorXd err;\n  Eigen::VectorXd vel;\n  Eigen::VectorXd grad;\n  Eigen::VectorXd pos;\n  Eigen::VectorXd dpos;\n  Eigen::VectorXd dvel;\n  Eigen::VectorXd dgrad;\n  for (int i = 0; i < q.cols(); i++) {\n    // Compute the positional error\n    err = q.col(i) - ref_traj_.col(i);\n    // Compute the velocity vector\n    vel = (q.col(i + 1) - q.col(i)) / dt_;\n    // Compute the cost\n    cost += a2 * err.dot(err) + b2 * vel.dot(vel);\n    // Compute the gradient\n    grad = 2 * a2 * err - 2 * b2 * vel;\n    // Compute the positional error derivative\n    dpos = 2 * a2 * err.transpose() * q.col(i) - 2 * b2 * vel.transpose() * q.col(i);\n    // Compute the velocity derivative\n    dvel = 2 * a2 * err.transpose() * q.col(i + 1) - 2 * b2 * vel.transpose() * q.col(i + 1);\n    // Compute the gradient derivative\n    dgrad = 2 * a2 * err.transpose() * grad - 2 * b2 * vel.transpose() * grad;\n    // Update the gradient\n    gradient.col(i) += dpos;\n    gradient.col(i + 1) += dvel;\n    gradient.col(i + 2) += dgrad;\n  }\n}", "CodeBleu_score": 39.49317492868044}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n    // Initialize the cost to zero.\n    cost = 0;\n\n    // Initialize the gradient to zero.\n    gradient.setZero(q.rows(), q.cols());\n\n    // Iterate through the control points.\n    for (int i = 0; i < q.rows(); i++) {\n\n        // Compute the positional error.\n        Eigen::Vector3d error = q.block<3, 1>(i * 3, 0) - refPoints[i];\n\n        // Compute the velocity vector.\n        Eigen::Vector3d vel = q.block<3, 1>(i * 3 + 1, 0) - q.block<3, 1>(i * 3, 0);\n\n        // Compute the cost.\n        cost += a2 * error.dot(error) + b2 * vel.dot(vel);\n\n        // Compute the gradient.\n        gradient.block<3, 1>(i * 3, 0) = -2 * a2 * error;\n        gradient.block<3, 1>(i * 3 + 1, 0) = -2 * b2 * vel;\n    }\n}", "CodeBleu_score": 26.3861209654772}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t  // Compute the third derivative of the spline to obtain the jerk trajectory\n  Bspline jerk_traj = Bspline::derivative(3);\n\n  // Retrieve the knot times and control points of the jerk trajectory\n  double* jerk_knots = jerk_traj.getKnots();\n  double** jerk_control_points = jerk_traj.getControlPoints();\n\n  // Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n  double total_jerk = 0.0;\n  for (int i = 0; i < jerk_traj.getDegree(); i++) {\n    for (int j = 0; j < jerk_traj.getDimension(); j++) {\n      total_jerk += pow(jerk_control_points[i][j], 2) * (jerk_knots[i+1] - jerk_knots[i]);\n    }\n  }\n\n  // Return the total jerk value\n  return total_jerk;\n}", "CodeBleu_score": 46.06529082141543}, {"code": "double UniformBspline::getJerk(){\n\t\n    double jerk = 0;\n\n    // Calculate the third derivative of the spline\n    Bspline third_derivative = getThirdDerivative();\n\n    // Get the knot times and control points of the jerk trajectory\n    std::vector<double> jerk_knot_times = third_derivative.getKnotTimes();\n    std::vector<std::vector<double> > jerk_control_points = third_derivative.getControlPoints();\n\n    // Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n    for (int i = 0; i < jerk_control_points.size(); i++) {\n        for (int j = 0; j < jerk_control_points[i].size(); j++) {\n            jerk += jerk_control_points[i][j] * jerk_control_points[i][j] * (jerk_knot_times[i+1] - jerk_knot_times[i]);\n        }\n    }\n\n    return jerk;\n\n}", "CodeBleu_score": 48.676776458622825}, {"code": "double UniformBspline::getJerk(){\n\t\n    double jerk = 0.0;\n\n    // Calculate the third derivative of the spline\n    calcThirdDerivative();\n\n    // Retrieve the knot times and control points of the jerk trajectory\n    double* jerk_knot_times = jerk_spline.getKnotTimes();\n    double** jerk_control_points = jerk_spline.getControlPoints();\n\n    // Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n    for(int i = 0; i < num_control_points; i++) {\n        for(int j = 0; j < num_dimensions; j++) {\n            jerk += pow(jerk_control_points[i][j], 2) * (jerk_knot_times[i+1] - jerk_knot_times[i]);\n        }\n    }\n\n    return jerk;\n\n}", "CodeBleu_score": 43.048965449715325}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n    return pos;\n}", "CodeBleu_score": 49.315525916455506}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d point;\n    point(0) = (u - cx_) * depth / fx_;\n    point(1) = (v - cy_) * depth / fy_;\n    point(2) = depth;\n    point(3) = 1.0;\n    return point;\n}", "CodeBleu_score": 78.43314230533451}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1;\n    return pos;\n}", "CodeBleu_score": 63.352792714373265}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        std::string drone_id = extractDroneID(odom.child_frame_id);\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (const std::exception& e) {\n        ROS_ERROR_STREAM(e.what());\n    }\n}", "CodeBleu_score": 51.24632747435933}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\n    try {\n        rcvDroneOdomCallbackBase(odom, extractDroneID(odom.child_frame_id));\n    }\n    catch(const std::exception& e) {\n        ROS_ERROR_STREAM(\"Exception thrown while processing drone odometry message: \" << e.what());\n    }\n\n}", "CodeBleu_score": 44.912242911182645}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    std::string drone_id = getDroneID(odom.child_frame_id);\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  } catch (const std::exception& e) {\n    ROS_ERROR_STREAM(\"Could not extract drone ID from odometry message: \" << e.what());\n  }\n}", "CodeBleu_score": 51.11188937723149}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Get the drone pose in the camera frame\n    Eigen::Vector3d drone_pose_camera = drone_poses_camera_.at(drone_id);\n    // Get the drone pose in the world frame\n    Eigen::Vector3d drone_pose_world = drone_poses_world_.at(drone_id);\n    // Get the drone pose in the camera frame\n    Eigen::Vector3d drone_pose_camera_true = drone_poses_camera_true_.at(drone_id);\n    // Get the drone pose in the world frame\n    Eigen::Vector3d drone_pose_world_true = drone_poses_world_true_.at(drone_id);\n    // Get the drone pose in the camera frame\n    Eigen::Vector3d drone_pose_camera_true_2 = drone_poses_camera_true_2_.at(drone_id);\n    // Get the drone pose in the world frame\n    Eigen::Vector3d drone_pose_world_true_2 = drone_poses_world_true_2_.at(drone_id);\n    // Get the drone pose in the camera frame\n    Eigen::Vector3d drone_pose_camera_true_3 = drone_poses_camera_true_3_.at(drone_id);\n    // Get the drone pose in the world frame\n    Eigen::Vector3d drone_pose_world_true_3 = drone_poses_world_true_3_.at(drone_id);\n    // Get the drone pose in the camera frame\n    Eigen::Vector3d drone_pose_camera_true_4 = drone_poses_camera_true_4_.at(drone_id);\n    // Get the drone pose in the world frame\n    Eigen::Vector3d drone_pose_world_true_4 = drone_poses_world_true_4_.at(drone_id);\n    // Get the drone pose in the camera frame\n    Eigen::Vector3d drone_pose_camera_true_5 = drone_poses_camera_true_5_.at(drone_", "CodeBleu_score": 18.25439693785775}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // Initialize the debug result\n  drone_debug_result.id = drone_id;\n  drone_debug_result.found = false;\n\n  // Check if the drone is detected in the camera frame\n  Eigen::Vector2i pixel = drone_id_to_pixel_map[drone_id];\n  if (pixel[0] < 0 || pixel[1] < 0) {\n    drone_debug_result.found = false;\n    drone_debug_result.pose_error = 0.0;\n    drone_debug_result_pub.publish(drone_debug_result);\n    return;\n  }\n\n  // Compute the true pose of the drone in the camera frame\n  Eigen::Vector3d true_camera_pose = Eigen::Vector3d(true_pixel[0], true_pixel[1], 0.0);\n  Eigen::Vector3d true_world_pose = camera_to_world_transform * true_camera_pose;\n\n  // Compute the pose error between the camera and world coordinates\n  Eigen::Vector3d detected_camera_pose = Eigen::Vector3d(pixel[0], pixel[1], 0.0);\n  Eigen::Vector3d detected_world_pose = camera_to_world_transform * detected_camera_pose;\n  drone_debug_result.pose_error = (detected_world_pose - true_world_pose).norm();\n\n  // Check if the drone is detected\n  if (drone_debug_result.pose_error < pose_error_threshold) {\n    drone_debug_result.found = true;\n  }\n\n  // Publish the debug result\n  drone_debug_result_pub.publish(drone_debug_result);\n}", "CodeBleu_score": 38.69424542409611}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n    // Get the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose_camera_frame = getTruePoseCameraFrame(drone_id);\n\n    // Check if the drone is present\n    bool drone_present = isDronePresent(true_pose_camera_frame);\n\n    // Update the debug result\n    debug_result_.drone_id = drone_id;\n    debug_result_.drone_present = drone_present;\n\n    // If drone is present, compute the pose error between the camera and world coordinates\n    if (drone_present) {\n\n        // Get the pose error between the camera and world coordinates\n        double pose_error = getPoseError(true_pose_camera_frame);\n\n        // Update the debug result\n        debug_result_.pose_error = pose_error;\n\n        // Publish the pose error\n        pose_error_pub_.publish(pose_error);\n\n    }\n\n    // Publish the debug result\n    debug_result_pub_.publish(debug_result_);\n\n}", "CodeBleu_score": 31.220730294025422}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getCameFrom() != nullptr) {\n        path.push_back(current->getCameFrom());\n        current = current->getCameFrom();\n    }\n    return path;\n}", "CodeBleu_score": 73.17947383064246}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getCameFrom() != NULL) {\n        path.push_back(current->getCameFrom());\n        current = current->getCameFrom();\n    }\n    return path;\n}", "CodeBleu_score": 75.2383804899265}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getCameFrom() != nullptr) {\n        current = current->getCameFrom();\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 77.40374327276972}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  // Convert the start and end points to grid indices\n  start_idx = ConvertToIndex(start_pt);\n  end_idx = ConvertToIndex(end_pt);\n\n  // If the start or end point is inside an obstacle, adjust it by moving it away from the other point until it is no longer in an obstacle\n  if (IsInObstacle(start_idx)) {\n    for (int i = 0; i < 1000; i++) {\n      start_idx = AdjustPoint(start_idx, end_idx);\n      if (!IsInObstacle(start_idx)) {\n        break;\n      }\n    }\n    if (IsInObstacle(start_idx)) {\n      return false;\n    }\n  }\n  if (IsInObstacle(end_idx)) {\n    for (int i = 0; i < 1000; i++) {\n      end_idx = AdjustPoint(end_idx, start_idx);\n      if (!IsInObstacle(end_idx)) {\n        break;\n      }\n    }\n    if (IsInObstacle(end_idx)) {\n      return false;\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 40.48238827898455}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// convert start and end point to grid indices\n\tstart_idx = Vector3i(start_pt.x() / m_cell_size.x(), start_pt.y() / m_cell_size.y(), start_pt.z() / m_cell_size.z());\n\tend_idx = Vector3i(end_pt.x() / m_cell_size.x(), end_pt.y() / m_cell_size.y(), end_pt.z() / m_cell_size.z());\n\n\t// if start or end point is inside an obstacle, adjust the point until it is no longer inside an obstacle\n\tif (m_map->IsObstacle(start_idx.x(), start_idx.y(), start_idx.z())) {\n\t\tVector3d adjusted_pt = start_pt;\n\t\tbool success = false;\n\t\twhile (!success) {\n\t\t\tsuccess = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tif (m_map->IsObstacle(adjusted_pt[i] / m_cell_size[i])) {\n\t\t\t\t\tsuccess = false;\n\t\t\t\t\tadjusted_pt[i] += m_cell_size[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstart_pt = adjusted_pt;\n\t\tstart_idx = Vector3i(start_pt.x() / m_cell_size.x(), start_pt.y() / m_cell_size.y(), start_pt.z() / m_cell_size.z());\n\t}\n\tif (m_map->IsObstacle(end_idx.x(), end_idx.y(), end_idx.z())) {\n\t\tVector3d adjusted_pt = end_pt;\n\t\tbool success = false;\n\t\twhile (!success) {\n\t\t\tsuccess = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tif (m_map->IsObstacle(adjusted_pt[i] / m_cell_size", "CodeBleu_score": 33.54416213512467}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\n    //Convert start and end points to grid indices\n    start_idx = ConvertToGridIndex(start_pt);\n    end_idx = ConvertToGridIndex(end_pt);\n\n    //Check if the start and end points are inside obstacles\n    if (IsInObstacle(start_idx) || IsInObstacle(end_idx)) {\n\n        //If either point is inside an obstacle, attempt to adjust it\n        //Iterate through each dimension\n        for (int i = 0; i < 3; i++) {\n\n            //If the start or end point is inside an obstacle, attempt to adjust it\n            if (IsInObstacle(start_idx) || IsInObstacle(end_idx)) {\n\n                //Iterate through each dimension\n                for (int j = 0; j < 3; j++) {\n\n                    //If the start or end point is inside an obstacle, attempt to adjust it\n                    if (IsInObstacle(start_idx) || IsInObstacle(end_idx)) {\n\n                        //If the start or end point is inside an obstacle, attempt to adjust it\n                        if (IsInObstacle(start_idx) || IsInObstacle(end_idx)) {\n\n                            //If the start or end point is inside an obstacle, attempt to adjust it\n                            if (IsInObstacle(start_idx) || IsInObstacle(end_idx)) {\n\n                                //If the start or end point is inside an obstacle, attempt to adjust it\n                                if (IsInObstacle(start_idx) || IsInObstacle(end_idx)) {\n\n                                    //If the start or end point is inside an obstacle, attempt to adjust it\n                                    if (IsInObstacle(start_idx) || IsInObstacle(end_idx)) {\n\n                                        //If the start or end point is inside an obstacle, attempt to adjust it\n                                        if (IsInObstacle(start_idx) || IsInObstacle(end_idx)) {\n\n                                            //If the start or end point is inside an obstacle, attempt to adjust it", "CodeBleu_score": 33.19173387612992}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    Eigen::Vector3i min_id, max_id;\n    Eigen::Vector3d grid_size_inv = 1.0 / grid_size_;\n    Eigen::Vector3d min_pos_grid = (min_pos - origin_) * grid_size_inv;\n    Eigen::Vector3d max_pos_grid = (max_pos - origin_) * grid_size_inv;\n    min_id = min_pos_grid.array().floor().cast<int>();\n    max_id = max_pos_grid.array().floor().cast<int>();\n\n    for (int x = min_id[0]; x <= max_id[0]; x++) {\n        for (int y = min_id[1]; y <= max_id[1]; y++) {\n            for (int z = min_id[2]; z <= max_id[2]; z++) {\n                int index = x * dim_[1] * dim_[2] + y * dim_[2] + z;\n                occupancy_buffer_inflate_[index] = 0;\n                distance_buffer_inflate_[index] = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 41.4263830593064}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id = posToIndex(min_pos);\n  Eigen::Vector3i max_id = posToIndex(max_pos);\n  for (int i = min_id(0); i <= max_id(0); i++) {\n    for (int j = min_id(1); j <= max_id(1); j++) {\n      for (int k = min_id(2); k <= max_id(2); k++) {\n        occupancy_buffer_inflate_(i, j, k) = 0;\n        distance_buffer_inflate_(i, j, k) = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 52.165827418206035}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    // Check if the specified region is within the grid map\n    if (min_pos.x() < min_x_ || min_pos.y() < min_y_ || min_pos.z() < min_z_ ||\n        max_pos.x() > max_x_ || max_pos.y() > max_y_ || max_pos.z() > max_z_) {\n        std::cout << \"The specified region is not within the grid map.\" << std::endl;\n        return;\n    }\n\n    // Convert the min_pos and max_pos to grid coordinates\n    int min_id_x = (min_pos.x() - min_x_) * inv_resolution_;\n    int min_id_y = (min_pos.y() - min_y_) * inv_resolution_;\n    int min_id_z = (min_pos.z() - min_z_) * inv_resolution_;\n    int max_id_x = (max_pos.x() - min_x_) * inv_resolution_;\n    int max_id_y = (max_pos.y() - min_y_) * inv_resolution_;\n    int max_id_z = (max_pos.z() - min_z_) * inv_resolution_;\n\n    // Iterate over the grid coordinates and reset the occupancy and distance buffer\n    for (int i = min_id_z; i <= max_id_z; ++i) {\n        for (int j = min_id_y; j <= max_id_y; ++j) {\n            for (int k = min_id_x; k <= max_id_x; ++k) {\n                // Set the occupancy and distance buffer to zero\n                occupancy_buffer_inflate_[i][j][k] = 0;\n                distance_buffer_inflate_[i][j][k] = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 35.1430589367015}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  double max_trans_x = diff.x() / diff.x();\n  double max_trans_y = diff.y() / diff.y();\n  double max_trans_z = diff.z() / diff.z();\n  double min_trans_x = diff.x() / diff.x();\n  double min_trans_y = diff.y() / diff.y();\n  double min_trans_z = diff.z() / diff.z();\n\n  double scale_x = 1;\n  double scale_y = 1;\n  double scale_z = 1;\n\n  if (diff.x() > 0) {\n    scale_x = max_trans_x;\n  } else if (diff.x() < 0) {\n    scale_x = min_trans_x;\n  }\n  if (diff.y() > 0) {\n    scale_y = max_trans_y;\n  } else if (diff.y() < 0) {\n    scale_y = min_trans_y;\n  }\n  if (diff.z() > 0) {\n    scale_z = max_trans_z;\n  } else if (diff.z() < 0) {\n    scale_z = min_trans_z;\n  }\n\n  Eigen::Vector3d new_pt = camera_pt + diff * scale_x * scale_y * scale_z;\n\n  return new_pt;\n}", "CodeBleu_score": 37.967800253755826}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n\tEigen::Vector3d pt_in_map;\n\tpt_in_map = pt;\n\n\tEigen::Vector3d diff_vec = pt - camera_pt;\n\n\tdouble max_translation_coef = diff_vec.maxCoeff();\n\tdouble min_translation_coef = diff_vec.minCoeff();\n\n\tfor (int i = 0; i < 3; i++) {\n\n\t\tif (diff_vec(i) > 0) {\n\t\t\tif (pt_in_map(i) - camera_pt(i) > max_translation_coef) {\n\t\t\t\tpt_in_map(i) = camera_pt(i) + max_translation_coef;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (pt_in_map(i) - camera_pt(i) < min_translation_coef) {\n\t\t\t\tpt_in_map(i) = camera_pt(i) + min_translation_coef;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn pt_in_map;\n}", "CodeBleu_score": 40.984862028995}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d adjusted_pt = pt;\n    double max_scaling_factor = 1.0;\n    double min_scaling_factor = 0.0;\n    double scaling_factor = 0.0;\n\n    for (int i = 0; i < 3; i++) {\n        if (diff(i) > 0) {\n            scaling_factor = (map_max_boundary_[i] - camera_pt(i)) / diff(i);\n            if (scaling_factor < min_scaling_factor) {\n                min_scaling_factor = scaling_factor;\n            }\n        } else if (diff(i) < 0) {\n            scaling_factor = (map_min_boundary_[i] - camera_pt(i)) / diff(i);\n            if (scaling_factor > max_scaling_factor) {\n                max_scaling_factor = scaling_factor;\n            }\n        }\n    }\n\n    for (int i = 0; i < 3; i++) {\n        if (diff(i) > 0) {\n            adjusted_pt(i) = camera_pt(i) + min_scaling_factor * diff(i);\n        } else if (diff(i) < 0) {\n            adjusted_pt(i) = camera_pt(i) + max_scaling_factor * diff(i);\n        }\n    }\n\n    return adjusted_pt;\n}", "CodeBleu_score": 48.87722508448357}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t    // Update last occupancy update time\n    last_occupancy_update_ = ros::Time::now();\n\n    // If an update is needed\n    if (update_needed_) {\n        // Project the depth image into points\n        projectDepthImage();\n\n        // Process the points with raycasting\n        raycast();\n\n        // Clear and inflate the local map\n        clearInflateLocalMap();\n\n        // Set the update needed flag to false\n        update_needed_ = false;\n    }\n\n    // Handle timeout errors for odometry or depth data\n    if (ros::Time::now() - last_odom_update_ > ros::Duration(0.5)) {\n        ROS_WARN_STREAM_THROTTLE(1, \"Odometry data not received for more than 0.5 seconds. Setting odometry_timeout_ to true.\");\n        odometry_timeout_ = true;\n    } else {\n        odometry_timeout_ = false;\n    }\n    if (ros::Time::now() - last_depth_update_ > ros::Duration(0.5)) {\n        ROS_WARN_STREAM_THROTTLE(1, \"Depth data not received for more than 0.5 seconds. Setting depth_timeout_ to true.\");\n        depth_timeout_ = true;\n    } else {\n        depth_timeout_ = false;\n    }\n}", "CodeBleu_score": 37.82287972175279}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update last occupancy update time.\n  last_occupancy_update_ = ros::Time::now();\n\n  // Check if an update is needed.\n  if (last_occupancy_update_ - last_sensor_update_ < occupancy_update_rate_) {\n    return;\n  }\n\n  // Project depth image into points.\n  std::vector<Eigen::Vector3d> points;\n  if (!projectDepthImage(points)) {\n    ROS_ERROR(\"Could not project depth image into points.\");\n    return;\n  }\n\n  // Process points with raycasting.\n  if (!processPointsWithRaycasting(points)) {\n    ROS_ERROR(\"Could not process points with raycasting.\");\n    return;\n  }\n\n  // Clear and inflate local map.\n  clearInflateLocalMap();\n\n  // Handle timeout errors for odometry or depth data and set relevant flags.\n  handleTimeoutErrors();\n}", "CodeBleu_score": 30.438130119612598}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\n    // Update the last occupancy update time\n    last_occupancy_update_ = ros::Time::now();\n\n    // If an update is needed, project the depth image into points and process them with raycasting\n    if (update_needed_) {\n\n        // Project the depth image into points\n        projectDepth();\n\n        // Process the points with raycasting\n        raycast();\n\n        // Clear and inflate the local map\n        clearInflateLocalMap();\n\n        // Set the update needed flag to false\n        update_needed_ = false;\n    }\n\n    // Handle timeout errors for odometry or depth data\n    if (ros::Time::now() - last_odom_update_ > odom_timeout_) {\n\n        // Set the odometry timeout flag to true\n        odom_timeout_ = true;\n\n        // Set the update needed flag to true\n        update_needed_ = true;\n    }\n\n    if (ros::Time::now() - last_depth_update_ > depth_timeout_) {\n\n        // Set the depth timeout flag to true\n        depth_timeout_ = true;\n\n        // Set the update needed flag to true\n        update_needed_ = true;\n    }\n}", "CodeBleu_score": 36.92211775008667}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\t\n\t// Accumulate the F-measure for all images\n\tfloat f_measure = 0.0f;\n\t\n\t// Iterate through the image filenames\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\t\n\t\t// Load the image\n\t\tMat image = imread(image_fns[i]);\n\t\t\n\t\t// Load the ground truth\n\t\tMat gt = imread(gt_fns[i]);\n\t\t\n\t\t// Load the detected ellipses\n\t\tMat dt = imread(dt_fns[i]);\n\t\t\n\t\t// Evaluate the detection performance\n\t\tfloat fm = ellipse_evaluate(image, gt, dt, gt_angle_radians);\n\t\t\n\t\t// Accumulate the F-measure\n\t\tf_measure += fm;\n\t\t\n\t}\n\t\n\t// Return the average F-measure\n\treturn f_measure / image_fns.size();\n\t\n}", "CodeBleu_score": 57.91665474423726}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float f_measure = 0;\n    int num_images = image_fns.size();\n\n    for (int i = 0; i < num_images; i++) {\n        Mat image = imread(image_fns[i]);\n        Mat gt = imread(gt_fns[i]);\n        Mat dt = imread(dt_fns[i]);\n\n        // convert to grayscale\n        cvtColor(image, image, COLOR_BGR2GRAY);\n        cvtColor(gt, gt, COLOR_BGR2GRAY);\n        cvtColor(dt, dt, COLOR_BGR2GRAY);\n\n        // threshold image\n        threshold(image, image, 128, 255, THRESH_BINARY);\n        threshold(gt, gt, 128, 255, THRESH_BINARY);\n        threshold(dt, dt, 128, 255, THRESH_BINARY);\n\n        // calculate F-measure\n        float fm = ellipse_fmeasure(image, gt, dt, gt_angle_radians);\n        f_measure += fm;\n    }\n\n    return f_measure / num_images;\n}", "CodeBleu_score": 53.888124410530345}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n    // Initialize the accumulator\n    float f_accum = 0;\n\n    // Iterate through the images\n    for (size_t i = 0; i < image_fns.size(); i++) {\n\n        // Load the image\n        Mat image = imread(image_fns[i]);\n\n        // Load the ground truth\n        Mat gt = imread(gt_fns[i], IMREAD_GRAYSCALE);\n\n        // Load the detected ellipses\n        Mat dt = imread(dt_fns[i], IMREAD_GRAYSCALE);\n\n        // Calculate the F-measure\n        float f_measure = ellipse_evaluate(image, gt, dt, gt_angle_radians);\n\n        // Accumulate the F-measure\n        f_accum += f_measure;\n\n    }\n\n    // Return the average F-measure\n    return f_accum / image_fns.size();\n\n}", "CodeBleu_score": 61.826813701221226}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle = 0;\n    if (foci != NULL) {\n        float angle_to_focus1 = atan2(y - foci[0], x - foci[1]);\n        float angle_to_focus2 = atan2(y - foci[2], x - foci[3]);\n        angle = angle_to_focus2 - angle_to_focus1;\n    }\n    return fmod(angle + 3 * M_PI, 2 * M_PI) - M_PI;\n}", "CodeBleu_score": 39.26599680577914}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle = 0.0f;\n\tif (foci != nullptr) {\n\t\tfloat angle_to_focus_1 = atan2(y - foci[1], x - foci[0]);\n\t\tfloat angle_to_focus_2 = atan2(y - foci[3], x - foci[2]);\n\t\tangle = angle_to_focus_2 - angle_to_focus_1;\n\t}\n\treturn (angle + M_PI) - (2 * M_PI * floor((angle + M_PI) / (2 * M_PI)));\n}", "CodeBleu_score": 42.6987976749421}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle = 0.0f;\n    if (foci != NULL) {\n        float angle1 = atan2(y - foci[0], x - foci[1]);\n        float angle2 = atan2(y - foci[2], x - foci[3]);\n        angle = angle2 - angle1;\n    }\n    if (angle > M_PI) {\n        angle -= 2.0f * M_PI;\n    } else if (angle < -M_PI) {\n        angle += 2.0f * M_PI;\n    }\n    return angle;\n}", "CodeBleu_score": 43.73477636661172}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble x_min = vp1[start].x;\n\tdouble x_max = vp1[start].x;\n\tdouble y_min = vp1[start].y;\n\tdouble y_max = vp1[start].y;\n\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < x_min) {\n\t\t\tx_min = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > x_max) {\n\t\t\tx_max = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < y_min) {\n\t\t\ty_min = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > y_max) {\n\t\t\ty_max = vp1[i].y;\n\t\t}\n\t}\n\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].y < y_min) {\n\t\t\tintegral_above += (x_max - x_min) * (y_min - vp1[i].y);\n\t\t}\n\t\telse if (vp1[i].y > y_max) {\n\t\t\tintegral_below += (x_max - x_min) * (vp1[i].y - y_min);\n\t\t}\n\t}\n\n\tif (integral_above < integral_below) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 38.229514203940596}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_x = vp1[start].x;\n\tdouble max_y = vp1[start].y;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n\t\tintegral_below += (vp1[i].x - min_x) * (max_y - vp1[i].y);\n\t}\n\tif (integral_above < integral_below) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 36.44807554131189}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\telse if (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\telse if (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n\t\tintegral_below += (vp1[i].x - min_x) * (max_y - vp1[i].y);\n\t}\n\n\tif (integral_above < integral_below) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 36.56861312134656}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\n    bool is_detected = false;\n\n    int num_regain = 0;\n\n    int num_lost = 0;\n\n    for (int i = 0; i < msg->det_num; i++) {\n\n        if (msg->det_info[i].det_name == \"T\") {\n\n            num_regain++;\n\n            num_lost = 0;\n\n        } else {\n\n            num_lost++;\n\n            num_regain = 0;\n\n        }\n\n    }\n\n    if (num_lost > VISION_THRES) {\n\n        is_detected = false;\n\n    } else if (num_regain > VISION_THRES) {\n\n        is_detected = true;\n\n    }\n\n    if (is_detected != ellipse_det.is_detected) {\n\n        ellipse_det.is_detected = is_detected;\n\n        if (is_detected) {\n\n            ellipse_det.sight_angle_1 = ellipse_det.sight_angle_2;\n\n        } else {\n\n            ellipse_det.sight_angle_2 = ellipse_det.sight_angle_1;\n\n        }\n\n    }\n\n}", "CodeBleu_score": 64.48825569820077}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\n    // Iterate through each detection info\n    for (int i = 0; i < msg->info.size(); i++) {\n\n        // Update ellipse_det\n        ellipse_det = msg->info[i];\n\n        // If an object named \"T\" is detected\n        if (ellipse_det.name == \"T\") {\n\n            // Increment num_regain and reset num_lost\n            num_regain++;\n            num_lost = 0;\n\n        }\n\n        // Otherwise\n        else {\n\n            // Reset num_regain and increment num_lost\n            num_regain = 0;\n            num_lost++;\n\n        }\n\n    }\n\n    // If num_lost exceeds VISION_THRES\n    if (num_lost > VISION_THRES) {\n\n        // Set is_detected to false\n        is_detected = false;\n\n    }\n\n    // If num_regain exceeds VISION_THRES\n    if (num_regain > VISION_THRES) {\n\n        // Set is_detected to true\n        is_detected = true;\n\n    }\n\n    // Swap the sight_angle values of ellipse_det\n    float temp = ellipse_det.sight_angle[0];\n    ellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n    ellipse_det.sight_angle[1] = temp;\n\n}", "CodeBleu_score": 76.09495350015243}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\n    for (int i = 0; i < msg->det_num; i++) {\n\n        if (msg->detection_info[i].name == \"T\") {\n\n            ellipse_det.is_detected = true;\n\n            ellipse_det.num_regain++;\n\n            ellipse_det.num_lost = 0;\n\n        } else {\n\n            ellipse_det.num_regain = 0;\n\n            ellipse_det.num_lost++;\n\n        }\n\n    }\n\n    if (ellipse_det.num_lost > VISION_THRES) {\n\n        ellipse_det.is_detected = false;\n\n    }\n\n    if (ellipse_det.num_regain > VISION_THRES) {\n\n        ellipse_det.is_detected = true;\n\n    }\n\n    ellipse_det.sight_angle_1 = ellipse_det.sight_angle_2;\n\n    ellipse_det.sight_angle_2 = ellipse_det.sight_angle_3;\n\n    ellipse_det.sight_angle_3 = ellipse_det.sight_angle_4;\n\n}", "CodeBleu_score": 41.56100624959401}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    bool is_safe = true;\n    double cur_x = cur_pos(0);\n    double cur_y = cur_pos(1);\n    double cur_z = cur_pos(2);\n    double cur_yaw = cur_pos(3);\n    double cur_pitch = cur_pos(4);\n    double cur_roll = cur_pos(5);\n\n    Eigen::Vector3d cur_pos_3d(cur_x, cur_y, cur_z);\n    Eigen::Vector3d cur_pos_3d_safe(cur_x, cur_y, cur_z + safe_distance);\n\n    // check whether the position is safe\n    if (Occupy_map_ptr->getOccupancyMap().at(cur_pos_3d.x(), cur_pos_3d.y(), cur_pos_3d.z()) == 1) {\n        is_safe = false;\n    }\n\n    // check whether the position is safe\n    if (Occupy_map_ptr->getOccupancyMap().at(cur_pos_3d_safe.x(), cur_pos_3d_safe.y(), cur_pos_3d_safe.z()) == 1) {\n        is_safe = false;\n    }\n\n    // check whether the position is safe\n    if (Occupy_map_ptr->getOccupancyMap().at(cur_pos_3d_safe.x() + 0.5 * cos(cur_yaw), cur_pos_3d_safe.y() + 0.5 * sin(cur_yaw), cur_pos_3d_safe.z()) == 1) {\n        is_safe = false;\n    }\n\n    // check whether the position is safe\n    if (Occupy_map_ptr->getOccupancyMap().at(cur_pos_3d_safe.x() - 0.5 * cos(cur_yaw), cur_pos_3d_safe.y() - 0.5 * sin(cur_yaw), cur_pos_3d_safe.z()) == 1) {\n        is_safe = false;\n    }\n", "CodeBleu_score": 37.393724334931456}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\n\tbool is_safe = false;\n\tEigen::Vector3d cur_pos_vec = Eigen::Vector3d(cur_pos(0), cur_pos(1), cur_pos(2));\n\tis_safe = Occupy_map_ptr->check_safety_astar(cur_pos_vec, safe_distance);\n\treturn is_safe;\n}", "CodeBleu_score": 53.87017570958466}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\n    if (Occupy_map_ptr->getOccupancyMap().data.at(cur_pos(0), cur_pos(1), cur_pos(2)) == 0)\n        return true;\n    else\n        return false;\n}", "CodeBleu_score": 25.669397919264846}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr curr_node = end_node;\n\tpath_nodes_.push_back(curr_node);\n\twhile (curr_node->getParent() != nullptr) {\n\t\tcurr_node = curr_node->getParent();\n\t\tpath_nodes_.push_back(curr_node);\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 58.78859262217966}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    path_nodes_.clear();\n    NodePtr current = end_node;\n    while (current != nullptr) {\n        path_nodes_.push_back(current);\n        current = current->parent;\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.03953651111987}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.push_back(end_node);\n\twhile (end_node->getParent() != nullptr) {\n\t\tend_node = end_node->getParent();\n\t\tpath_nodes_.push_back(end_node);\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 40.8960117543565}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n    // Assign the state of the neighboring UGV to the state_nei array\n    state_nei[id].x = odom->pose.pose.position.x;\n    state_nei[id].y = odom->pose.pose.position.y;\n    state_nei[id].z = odom->pose.pose.position.z;\n\n    // Check the distance from the start position in simulation mode\n    if(simulation_mode) {\n        // Calculate the distance from the start position\n        double dist = sqrt(pow(state_nei[id].x - state_start.x, 2) + pow(state_nei[id].y - state_start.y, 2));\n\n        // If the distance exceeds 5 meters, set the get_nei_state flag to false\n        if(dist > 5) {\n            get_nei_state[id] = false;\n        }\n        // Otherwise, set the get_nei_state flag to true\n        else {\n            get_nei_state[id] = true;\n        }\n    }\n    // Otherwise, set the get_nei_state flag to true\n    else {\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 55.73658894790543}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n    // get the current state of the neighboring UGV\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n\n    // check if the neighboring UGV is too far from the start position\n    if (sim_mode) {\n        if (sqrt(pow(state_nei[id][0] - start_pos[0], 2) + pow(state_nei[id][1] - start_pos[1], 2) + pow(state_nei[id][2] - start_pos[2], 2)) > 5) {\n            get_nei_state[id] = false;\n        }\n        else {\n            get_nei_state[id] = true;\n        }\n    }\n    else {\n        get_nei_state[id] = true;\n    }\n\n}", "CodeBleu_score": 60.220693695605654}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n    // Get the position and height of the neighboring UGV\n    state_nei[0] = odom->pose.pose.position.x;\n    state_nei[1] = odom->pose.pose.position.y;\n    state_nei[2] = odom->pose.pose.position.z;\n\n    // Check if the neighboring UGV is within 5 meters of the start position\n    if (sim_mode) {\n        if (sqrt(pow(state_nei[0] - start_pos[0], 2) + pow(state_nei[1] - start_pos[1], 2)) > 5) {\n            get_nei_state[id] = false;\n        }\n        else {\n            get_nei_state[id] = true;\n        }\n    }\n    else {\n        get_nei_state[id] = true;\n    }\n\n}", "CodeBleu_score": 56.09213229938296}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n  if (odom_ready == false) {\n    return;\n  }\n\n  sensor_ready = true;\n\n  update_counter++;\n\n  if (update_counter < 5) {\n    return;\n  }\n\n  // Update Astar map\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  pcl::fromROSMsg(*msg, cloud);\n  pcl::PointCloud<pcl::PointXYZ> cloud_filtered;\n  pcl::VoxelGrid<pcl::PointXYZ> sor;\n  sor.setInputCloud(cloud.makeShared());\n  sor.setLeafSize(0.2, 0.2, 0.2);\n  sor.filter(cloud_filtered);\n\n  // Transform point cloud to map frame\n  tf::TransformListener listener;\n  tf::StampedTransform transform;\n  try {\n    listener.waitForTransform(\"/map\", \"/base_link\", ros::Time(0), ros::Duration(10.0) );\n    listener.lookupTransform(\"/map\", \"/base_link\", ros::Time(0), transform);\n  }\n  catch (tf::TransformException ex) {\n    ROS_ERROR(\"%s\",ex.what());\n    ros::Duration(1.0).sleep();\n  }\n\n  Eigen::Affine3d trans;\n  tf::transformTFToEigen(transform, trans);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::transformPointCloud(cloud_filtered, *cloud_transformed, trans);\n\n  // Create a point cloud map\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_map(new pcl::PointCloud<pcl::PointXYZ>);\n  *cloud_map = *cloud_transformed;\n\n  // Create a KD-Tree\n  pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ>);\n  tree->setInputCloud (cloud_map);\n\n", "CodeBleu_score": 39.088383502091816}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    // Check if odometry is ready\n    if (!odom_ready) {\n        return;\n    }\n\n    // If odometry is ready, set sensor_ready flag and increment update counter\n    sensor_ready = true;\n    update_counter++;\n\n    // Every fifth update, update the Astar map with the new point cloud data and reset the update counter\n    if (update_counter % 5 == 0) {\n        // Convert point cloud to a vector of points\n        pcl::PointCloud<pcl::PointXYZ> cloud;\n        pcl::fromROSMsg(*msg, cloud);\n        std::vector<geometry_msgs::Point> points;\n        for (int i = 0; i < cloud.points.size(); i++) {\n            geometry_msgs::Point point;\n            point.x = cloud.points[i].x;\n            point.y = cloud.points[i].y;\n            point.z = cloud.points[i].z;\n            points.push_back(point);\n        }\n\n        // Update the Astar map with the new point cloud data\n        astar_map.update_map(points);\n\n        // Reset the update counter\n        update_counter = 0;\n    }\n}", "CodeBleu_score": 60.153351043519685}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    // If odometry is not ready, return immediately\n    if (!odom_ready) {\n        return;\n    }\n\n    // Set sensor_ready flag to true\n    sensor_ready = true;\n\n    // Increment update counter\n    update_counter++;\n\n    // If update counter is less than 5, return immediately\n    if (update_counter < 5) {\n        return;\n    }\n\n    // Reset update counter\n    update_counter = 0;\n\n    // Update the A* map with the new point cloud data\n    Astar_map.update_map(msg);\n\n    // Reset the A* map update flag\n    Astar_map.update_flag = false;\n\n    return;\n}", "CodeBleu_score": 59.688040991718694}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n  if (get_gpcl == true) {\n    return;\n  }\n\n  get_gpcl = true;\n\n  pcl::PointCloud<pcl::PointXYZ> global_map;\n  pcl::fromROSMsg(*global_point, global_map);\n\n  pcl::PointCloud<pcl::PointXYZ>::Ptr global_map_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(*global_point, *global_map_ptr);\n\n  // Inflate the point cloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr global_map_inflated_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::PointCloud<pcl::PointXYZ> global_map_inflated;\n  pcl::InflatePointCloud(*global_map_ptr, *global_map_inflated_ptr, inflation_radius);\n  pcl::toROSMsg(*global_map_inflated_ptr, global_map_inflated);\n  global_map_inflated.header = global_point->header;\n  global_map_inflated.header.frame_id = global_point->header.frame_id;\n  global_map_inflated.header.stamp = global_point->header.stamp;\n  pub_global_map_inflated.publish(global_map_inflated);\n\n  // Store the inflated point cloud\n  global_map_inflated_ptr->header = global_point->header;\n  global_map_inflated_ptr->header.frame_id = global_point->header.frame_id;\n  global_map_inflated_ptr->header.stamp = global_point->header.stamp;\n  global_map_inflated_ptr->width = global_map_inflated_ptr->points.size();\n  global_map_inflated_ptr->height = 1;\n  global_map_inflated_ptr->is_dense = true;\n  global_map_inflated_ptr->sensor_origin_.setZero();\n  global_map_inflated_ptr", "CodeBleu_score": 54.094811570287064}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n    if(!get_gpcl) {\n        get_gpcl = true;\n\n        // Convert the sensor message to a point cloud\n        pcl::fromROSMsg(*global_point, *global_point_cloud);\n\n        // Store the point cloud\n        global_point_cloud_ptr = global_point_cloud;\n\n        // Inflate the point cloud\n        inflate_point_cloud(global_point_cloud, inflated_global_point_cloud);\n\n        // Set the flag to false\n        get_gpcl = false;\n    }\n}", "CodeBleu_score": 61.598381467046515}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (!get_gpcl) {\n        get_gpcl = true;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr global_point_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*global_point, *global_point_ptr);\n        global_point_vector.push_back(global_point_ptr);\n        inflate_point_cloud(global_point_ptr);\n    }\n}", "CodeBleu_score": 55.726236677836994}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // convert laser scan into a PointCloud2 format and convert it to a pcl::PointCloud\n    sensor_msgs::PointCloud2 laserCloud;\n    projector_.transformLaserScanToPointCloud(base_frame_, *local_point, laserCloud, listener_);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr laserCloudIn(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(laserCloud, *laserCloudIn);\n\n    // if not in simulation mode, merge the local map with the provided odometry data\n    if (simulation_mode_) {\n        map_.insertPointCloud(laserCloudIn, Eigen::Affine3f::Identity());\n    } else {\n        Eigen::Affine3f laserCloudInAffine(Eigen::Translation3f(odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z));\n        laserCloudInAffine = laserCloudInAffine * Eigen::AngleAxisf(odom.pose.pose.orientation.w, odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z);\n        map_.insertPointCloud(laserCloudIn, laserCloudInAffine);\n    }\n\n}", "CodeBleu_score": 46.025821436776646}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t  // Convert laser scan to point cloud\n  pcl::PointCloud<pcl::PointXYZ> laserCloud;\n  sensor_msgs::PointCloud2 laserCloud2;\n  projector_.transformLaserScanToPointCloud(base_frame_, *local_point, laserCloud2, listener_);\n  pcl::fromROSMsg(laserCloud2, laserCloud);\n\n  // Update occupancy map with laser scan\n  occupancy_map_->updateOccupancyMap(laserCloud, odom);\n\n  // Merge local map with global map\n  if (!simulation_mode_) {\n    occupancy_map_->mergeOccupancyMap();\n  }\n}", "CodeBleu_score": 44.83459386339281}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // Converts the laser scan into a PointCloud2 format and converts it to a pcl::PointCloud\n    sensor_msgs::PointCloud2 laser_cloud;\n    laserCloud.header = local_point->header;\n    laserCloud.header.frame_id = \"map\";\n    projector_.transformLaserScanToPointCloud(\"base_link\", *local_point, laserCloud, listener_);\n    pcl::fromROSMsg(laserCloud, laserCloudIn);\n\n    // If not in simulation mode, merges the local map with the provided odometry data\n    if (!simulation_mode_) {\n        laserCloudIn = laserCloudIn + odom;\n    }\n\n    // Publishes the updated occupancy map\n    publish_occupancy_map();\n}", "CodeBleu_score": 45.96181559686763}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n    // 1. publish global point cloud map\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(global_pcl, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // 2. publish inflated point cloud\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(inflate_pcl, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n\n}", "CodeBleu_score": 59.25875744216425}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Create a ROS message\n    sensor_msgs::PointCloud2 pcl_msg;\n\n    // Convert the global point cloud map to a ROS message\n    pcl::toROSMsg(global_pcl_map, pcl_msg);\n\n    // Set the frame ID to \"world\"\n    pcl_msg.header.frame_id = \"world\";\n\n    // Publish the ROS message to the global_pcl_pub topic\n    global_pcl_pub.publish(pcl_msg);\n\n    // Convert the inflated point cloud to a ROS message\n    pcl::toROSMsg(inflate_pcl_map, pcl_msg);\n\n    // Set the frame ID to \"world\"\n    pcl_msg.header.frame_id = \"world\";\n\n    // Publish the ROS message to the inflate_pcl_pub topic\n    inflate_pcl_pub.publish(pcl_msg);\n}", "CodeBleu_score": 44.230000063498665}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n  // Publish the global point cloud map\n  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(*global_pcl_ptr, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // Publish the inflated point cloud\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(*inflate_pcl_ptr, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 65.04287261418962}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n\t// set sensor ready flag to true\n\tsensor_ready = true;\n\n\t// convert the point cloud to a vector of points\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(*msg, cloud);\n\tstd::vector<Point3D> points;\n\tfor (int i = 0; i < cloud.size(); i++) {\n\t\tPoint3D point;\n\t\tpoint.x = cloud.points[i].x;\n\t\tpoint.y = cloud.points[i].y;\n\t\tpoint.z = cloud.points[i].z;\n\t\tpoints.push_back(point);\n\t}\n\n\t// update the A* algorithm's map\n\tif (sensor_ready && odometry_ready) {\n\t\ta_star.update_map(points, odom.pose.pose.position, odom.pose.pose.orientation);\n\t}\n}", "CodeBleu_score": 43.76438069568328}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (odometry_ready) {\n    sensor_ready = true;\n    // Get the point cloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg, *cloud);\n    // Get the current odometry\n    tf::StampedTransform transform;\n    try {\n      tf_listener.lookupTransform(world_frame, uav_frame, ros::Time(0), transform);\n    }\n    catch (tf::TransformException ex) {\n      ROS_ERROR(\"%s\", ex.what());\n      ros::Duration(1.0).sleep();\n      return;\n    }\n    // Get the current odometry\n    tf::Quaternion q(transform.getRotation().getX(), transform.getRotation().getY(), transform.getRotation().getZ(), transform.getRotation().getW());\n    double roll, pitch, yaw;\n    tf::Matrix3x3(q).getRPY(roll, pitch, yaw);\n    // Update the map\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::transformPointCloud(*cloud, *cloud_transformed, transform);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PassThrough<pcl::PointXYZ> pass;\n    pass.setInputCloud(cloud_transformed);\n    pass.setFilterFieldName(\"z\");\n    pass.setFilterLimits(0.0, 1.0);\n    pass.filter(*cloud_filtered);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_voxelized(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::VoxelGrid<pcl::PointXYZ> sor;\n    sor.setInputCloud(cloud_filtered);\n    sor.setLeafSize(0.05, 0.05, ", "CodeBleu_score": 43.52209459953708}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (odometry_ready) {\n        sensor_ready = true;\n    }\n    if (sensor_ready) {\n        // Update the map\n        map_mutex.lock();\n        // Get the current odometry\n        geometry_msgs::PoseStamped pose;\n        pose.pose.position.x = odometry.pose.pose.position.x;\n        pose.pose.position.y = odometry.pose.pose.position.y;\n        pose.pose.position.z = odometry.pose.pose.position.z;\n        pose.pose.orientation.x = odometry.pose.pose.orientation.x;\n        pose.pose.orientation.y = odometry.pose.pose.orientation.y;\n        pose.pose.orientation.z = odometry.pose.pose.orientation.z;\n        pose.pose.orientation.w = odometry.pose.pose.orientation.w;\n        // Get the current point cloud\n        sensor_msgs::PointCloud2 cloud_msg;\n        sensor_msgs::convertPointCloud2ToPointCloud(*msg, cloud);\n        // Update the map\n        map_update(pose, cloud);\n        map_mutex.unlock();\n    }\n}", "CodeBleu_score": 46.478980775932534}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Get the time\n  ros::Time now = ros::Time::now();\n  // Get the time step\n  double dt = (now - last_time_).toSec();\n  last_time_ = now;\n\n  // Check if the robot is in the air\n  if (is_flying_) {\n    // If the robot is in the air, we don't need to control the legs\n    return;\n  }\n\n  // Check if the robot is in the stance\n  if (is_in_stance_) {\n    // If the robot is in the stance, we don't need to control the legs\n    return;\n  }\n\n  // Check if the robot is in the initial pose\n  if (is_in_initial_pose_) {\n    // If the robot is in the initial pose, we don't need to control the legs\n    return;\n  }\n\n  // Check if the robot is in the balance\n  if (is_in_balance_) {\n    // If the robot is in the balance, we don't need to control the legs\n    return;\n  }\n\n  // Check if the robot is in the standing\n  if (is_in_standing_) {\n    // If the robot is in the standing, we don't need to control the legs\n    return;\n  }\n\n  // Check if the robot is in the walking\n  if (is_in_walking_) {\n    // If the robot is in the walking, we don't need to control the legs\n    return;\n  }\n\n  // Check if the robot is in the trotting\n  if (is_in_trotting_) {\n    // If the robot is in the trotting, we don't need to control the legs\n    return;\n  }\n\n  // Check if the robot is in the galloping\n  if (is_in_galloping_) {\n    // If the robot is in the galloping, we don't need to control the legs\n    return;\n  }\n\n  // Check if the robot is in the trotting\n  if (is_in_pacing_) {\n    // If the robot is in the trotting, we don'", "CodeBleu_score": 27.2265533604098}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Get the current time\n    ros::Time now = ros::Time::now();\n\n    // Update the robot state\n    updateRobotState_(now);\n\n    // Update the target foot positions\n    updateTargetFootPositions_();\n\n    // Update the target joint positions\n    updateTargetJointPositions_();\n\n    // Update the target joint velocities\n    updateTargetJointVelocities_();\n\n    // Publish the foot contact information\n    publishFootContactInformation_();\n\n    // Publish the joint positions\n    publishJointPositions_();\n\n    // Publish the joint velocities\n    publishJointVelocities_();\n}", "CodeBleu_score": 26.91226526185017}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n  // Get current time\n  ros::Time time_now = ros::Time::now();\n\n  // Get current state of the robot\n  quadruped_state_ = robot_->getCurrentState();\n\n  // Get the current robot pose\n  Eigen::VectorXd current_robot_pose = robot_->getCurrentPose();\n\n  // Get the current robot velocity\n  Eigen::VectorXd current_robot_velocity = robot_->getCurrentVelocity();\n\n  // Get the current robot acceleration\n  Eigen::VectorXd current_robot_acceleration = robot_->getCurrentAcceleration();\n\n  // Get the current robot effort\n  Eigen::VectorXd current_robot_effort = robot_->getCurrentEffort();\n\n  // Get the current robot joint positions\n  Eigen::VectorXd current_robot_joint_positions = robot_->getCurrentJointPositions();\n\n  // Get the current robot joint velocities\n  Eigen::VectorXd current_robot_joint_velocities = robot_->getCurrentJointVelocities();\n\n  // Get the current robot joint accelerations\n  Eigen::VectorXd current_robot_joint_accelerations = robot_->getCurrentJointAccelerations();\n\n  // Get the current robot joint efforts\n  Eigen::VectorXd current_robot_joint_efforts = robot_->getCurrentJointEfforts();\n\n  // Get the current robot joint positions\n  Eigen::VectorXd current_robot_joint_torques = robot_->getCurrentJointTorques();\n\n  // Get the current robot joint positions\n  Eigen::VectorXd current_robot_joint_position_errors = robot_->getCurrentJointPositionErrors();\n\n  // Get the current robot joint velocities\n  Eigen::VectorXd current_robot_joint_velocity_errors = robot_->getCurrentJointVelocityErrors();\n\n  // Get the current robot joint accelerations\n  Eigen::VectorXd current_robot_joint_acceleration_errors = robot_->getCurrentJointAccelerationErrors();", "CodeBleu_score": 21.914306119677317}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_ != nullptr && !in_gazebo_) {\n    quadruped_msgs::ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.header.frame_id = \"base_link\";\n    contacts_msg.contacts.resize(4);\n\n    for (int i = 0; i < 4; ++i) {\n      contacts_msg.contacts[i].name = \"foot_\" + std::to_string(i + 1);\n      contacts_msg.contacts[i].contact = foot_contacts[i];\n      contacts_msg.contacts[i].gait_phase = gait_phase_[i];\n    }\n\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 54.23820017002701}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_ && !gazebo_) {\n    quadruped_msgs::ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    for (int leg = 0; leg < 4; leg++) {\n      contacts_msg.contacts[leg].phase = current_gait_[leg];\n      contacts_msg.contacts[leg].contact = foot_contacts[leg];\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 51.84534819800074}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_->trylock()) {\n    auto contacts = foot_contacts_publisher_->msg();\n    contacts->header.stamp = time_keeper_->get_stamp();\n    contacts->header.frame_id = \"base_link\";\n    contacts->contact_states.clear();\n\n    for (int i = 0; i < 4; ++i) {\n      if (foot_contacts[i]) {\n        contacts->contact_states.push_back(\n            quadruped_model_->getGaitPhase(i));\n      }\n    }\n\n    foot_contacts_publisher_->unlockAndPublish();\n  }\n}", "CodeBleu_score": 43.31931238163298}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message with the first 12 joint positions\n    self.joints_msg = Joints()\n    self.joints_msg.header.stamp = rospy.Time.now()\n    self.joints_msg.header.frame_id = \"base\"\n    self.joints_msg.name = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    self.joints_msg.position = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]]\n    self.joints_pub.publish(self.joints_msg)\n\n    # Create a joint trajectory message with the same positions and a specified duration\n    self.trajectory_msg = JointTrajectory()\n    self.trajectory_msg.header.stamp = rospy.Time.now()\n    self.trajectory_msg.header.frame_id = \"base\"\n    self.trajectory_msg.joint_names = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    self.trajectory_msg.points = [JointTrajectoryPoint(positions=[joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10", "CodeBleu_score": 30.320891540301602}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message with the first 12 joint positions\n    joints_msg = Joints()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.name = self.joint_names[0:12]\n    joints_msg.position = joints.position[0:12]\n    self.pub_joints.publish(joints_msg)\n\n    # Create a joint trajectory message with the same positions and a specified duration\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.header.stamp = rospy.Time.now()\n    joint_trajectory.joint_names = self.joint_names[0:12]\n    joint_trajectory.points = [JointTrajectoryPoint(positions=joints.position[0:12], velocities=[0.0] * 12, time_from_start=rospy.Duration(0.5))]\n    self.pub_trajectory.publish(joint_trajectory)\n}", "CodeBleu_score": 44.58679940603062}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create joints message\n    joints_msg = Joints()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.name = joints.name[0:12]\n    joints_msg.position = joints.position[0:12]\n    joints_msg.velocity = joints.velocity[0:12]\n    joints_msg.effort = joints.effort[0:12]\n    self.joints_pub.publish(joints_msg)\n\n    # Create joint trajectory message\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.header.stamp = rospy.Time.now()\n    joint_trajectory.joint_names = joints.name[0:12]\n    joint_trajectory_point = JointTrajectoryPoint()\n    joint_trajectory_point.positions = joints.position[0:12]\n    joint_trajectory_point.velocities = joints.velocity[0:12]\n    joint_trajectory_point.effort = joints.effort[0:12]\n    joint_trajectory_point.time_from_start = rospy.Duration(self.duration)\n    joint_trajectory.points.append(joint_trajectory_point)\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 49.44703495779116}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\n    // Initialize foot contact states to false\n    bool left_foot_contact = false;\n    bool right_foot_contact = false;\n\n    // Loop through all contacts in the message\n    for (int i = 0; i < _msg->contact_size(); i++) {\n\n        // Split the collision string to identify the contact link\n        std::vector<std::string> collision_string_split;\n        boost::split(collision_string_split, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n        std::string contact_link = collision_string_split.back();\n\n        // If a contact matches one of the foot links, set the corresponding foot contact state to true\n        if (contact_link == \"l_sole\") {\n            left_foot_contact = true;\n        } else if (contact_link == \"r_sole\") {\n            right_foot_contact = true;\n        }\n\n    }\n\n    // Publish the foot contact states\n    champ_msgs::ContactsStamped foot_contacts;\n    foot_contacts.header.stamp = ros::Time::now();\n    foot_contacts.left_foot_contact = left_foot_contact;\n    foot_contacts.right_foot_contact = right_foot_contact;\n    foot_contacts_pub.publish(foot_contacts);\n\n}", "CodeBleu_score": 44.853476313852745}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\n    // Initialize contact states to false\n    bool left_contact = false;\n    bool right_contact = false;\n\n    // Loop through all contacts\n    for (int i = 0; i < _msg->contact_size(); i++) {\n\n        // Split collision string to identify contact link\n        std::vector<std::string> collision_split;\n        boost::split(collision_split, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n\n        // If the contact link matches the left foot link, set the left foot contact state to true\n        if (collision_split[collision_split.size() - 1] == \"left_foot_collision\") {\n            left_contact = true;\n        }\n\n        // If the contact link matches the right foot link, set the right foot contact state to true\n        if (collision_split[collision_split.size() - 1] == \"right_foot_collision\") {\n            right_contact = true;\n        }\n    }\n\n    // Publish contact states\n    champ_msgs::ContactsStamped msg;\n    msg.header.stamp = ros::Time::now();\n    msg.left_contact = left_contact;\n    msg.right_contact = right_contact;\n    contact_pub.publish(msg);\n}", "CodeBleu_score": 40.21680601304145}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\n    // Initialize foot contact states to false\n    std::vector<bool> footContacts(4, false);\n\n    // For each contact in the message\n    for (unsigned int i = 0; i < _msg->contact_size(); i++) {\n\n        // Split the collision string to identify the contact link\n        std::vector<std::string> collisionStrings;\n        boost::split(collisionStrings, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n        std::string collisionLink = collisionStrings.back();\n\n        // If a contact matches one of the foot links, set the corresponding foot contact state to true\n        if (collisionLink == \"left_foot_contact\") {\n            footContacts[0] = true;\n        }\n        if (collisionLink == \"right_foot_contact\") {\n            footContacts[1] = true;\n        }\n        if (collisionLink == \"left_foot_contact_2\") {\n            footContacts[2] = true;\n        }\n        if (collisionLink == \"right_foot_contact_2\") {\n            footContacts[3] = true;\n        }\n    }\n\n    // Publish the foot contact states\n    champ_msgs::ContactsStamped footContactsMsg;\n    footContactsMsg.header.stamp = ros::Time::now();\n    footContactsMsg.left_contact = footContacts[0];\n    footContactsMsg.right_contact = footContacts[1];\n    footContactsMsg.left_contact_2 = footContacts[2];\n    footContactsMsg.right_contact_2 = footContacts[3];\n    footContactsPub_.publish(footContactsMsg);\n}", "CodeBleu_score": 40.1317227959041}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  // Check if the controller is active.\n  if (!IsActive()) {\n    // If not active, set all rotor velocities to zero.\n    *rotor_velocities = Eigen::VectorXd::Zero(kNumMotors);\n    return;\n  }\n\n  // Check that the input is valid.\n  CHECK_NOTNULL(rotor_velocities);\n  CHECK_EQ(rotor_velocities->size(), kNumMotors);\n\n  // Calculate the desired acceleration.\n  Eigen::Vector3d desired_acceleration =\n      desired_state_.thrust -\n      Eigen::Vector3d(0.0, 0.0, 9.81) -\n      desired_state_.angular_acceleration.cross(desired_state_.position);\n\n  // Project thrust onto the body z-axis.\n  double thrust_body_z = desired_acceleration.z();\n\n  // Combine thrust and angular acceleration.\n  Eigen::Vector3d desired_acceleration_projected =\n      Eigen::Vector3d(0.0, 0.0, thrust_body_z) +\n      desired_state_.angular_acceleration;\n\n  // Compute rotor velocities.\n  *rotor_velocities =\n      Eigen::VectorXd::Map(kRotorVelocityCoefficients.data(), kNumMotors) *\n      desired_acceleration_projected.cwiseAbs();\n\n  // Ensure non-negative values.\n  *rotor_velocities = rotor_velocities->cwiseMax(0.0);\n\n  // Take square root.\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 44.72718210186778}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  // Check if controller is active\n  if (!IsActive()) {\n    // Set all rotor velocities to zero and exit\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  // Check if inputs are valid\n  if (!InputsValid()) {\n    // Set all rotor velocities to zero and exit\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  // Compute the desired acceleration\n  Eigen::Vector3d desired_acceleration =\n      desired_rotor_thrusts_ * kRotorVelocityCoefficient;\n\n  // Compute the desired angular acceleration\n  Eigen::Vector3d desired_angular_acceleration =\n      desired_rotor_thrusts_ * kAngularAccelerationCoefficient;\n\n  // Project the desired acceleration onto the body z-axis\n  Eigen::Vector3d desired_acceleration_projected =\n      desired_acceleration.dot(body_z_axis_) * body_z_axis_;\n\n  // Compute the desired rotor thrusts\n  Eigen::VectorXd desired_rotor_thrusts_projected =\n      desired_acceleration_projected + desired_angular_acceleration;\n\n  // Compute the rotor velocities\n  *rotor_velocities = desired_rotor_thrusts_projected.cwiseProduct(\n                          rotor_velocity_direction_);\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_count_));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 46.74963438400439}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  // Ensure that the input is valid.\n  if (rotor_velocities == NULL) {\n    return;\n  }\n\n  // If the controller is not active, set all rotor velocities to zero.\n  if (!IsActive()) {\n    *rotor_velocities = Eigen::VectorXd::Zero(kNumMotors);\n    return;\n  }\n\n  // Calculate the desired acceleration and angular acceleration.\n  Eigen::Vector3d desired_acceleration =\n      desired_state_.thrust_force_b - desired_state_.drag_force_b;\n  Eigen::Vector3d desired_angular_acceleration =\n      desired_state_.moment_b - desired_state_.torque_b;\n\n  // Project thrust onto the body z-axis and combine with angular acceleration.\n  Eigen::Vector3d desired_acceleration_projected =\n      desired_acceleration.dot(kRotorDirection) * kRotorDirection;\n  Eigen::Vector3d desired_acceleration_vector =\n      desired_acceleration - desired_acceleration_projected;\n  Eigen::Vector3d desired_acceleration_total =\n      desired_acceleration_projected + desired_angular_acceleration;\n\n  // Compute the rotor velocities.\n  *rotor_velocities =\n      kRotorVelocityCoefficients * desired_acceleration_total;\n\n  // Ensure that the rotor velocities are non-negative.\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(kNumMotors));\n\n  // Take the square root of each rotor velocity.\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 46.5592250606293}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\n  // Get the current odometry data\n  Eigen::Vector3d position_error, velocity_error;\n  ComputePositionAndVelocityErrors(position_error, velocity_error);\n\n  // Transform the vehicle's velocity to the world frame\n  Eigen::Vector3d velocity_world = Eigen::Vector3d::Zero();\n  Eigen::Vector3d orientation_world = Eigen::Vector3d::Zero();\n  Eigen::Vector3d angular_velocity_world = Eigen::Vector3d::Zero();\n  Eigen::Vector3d angular_acceleration_world = Eigen::Vector3d::Zero();\n  ComputeVehicleDataInWorldFrame(velocity_world, orientation_world, angular_velocity_world, angular_acceleration_world);\n\n  // Compute the desired acceleration\n  *acceleration = position_error * position_gain_ + velocity_error * velocity_gain_ +\n                  (command_trajectory_->GetVelocity() - velocity_world) * mass_ * gravity_ +\n                  command_trajectory_->GetAcceleration();\n}", "CodeBleu_score": 45.66658877033466}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  Eigen::Vector3d position_error = command_trajectory_.at(command_trajectory_index_).position - odometry_.position;\n  Eigen::Vector3d velocity_error = command_trajectory_.at(command_trajectory_index_).velocity - odometry_.velocity;\n  Eigen::Vector3d acceleration_error = command_trajectory_.at(command_trajectory_index_).acceleration - odometry_.acceleration;\n\n  Eigen::Vector3d desired_acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error + acceleration_gain_ * acceleration_error;\n\n  desired_acceleration.z() -= 9.81;\n\n  desired_acceleration.x() /= vehicle_mass_;\n  desired_acceleration.y() /= vehicle_mass_;\n  desired_acceleration.z() /= vehicle_mass_;\n\n  desired_acceleration = desired_acceleration + command_trajectory_.at(command_trajectory_index_).acceleration;\n\n  *acceleration = desired_acceleration;\n}", "CodeBleu_score": 44.8184355583525}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t    // Position error\n    Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n    // Velocity error\n    Eigen::Vector3d velocity_error = command_trajectory_.velocity - odometry_.velocity;\n\n    // Transform the velocity error to the world frame\n    Eigen::Vector3d velocity_error_world = odometry_.orientation.inverse() * velocity_error;\n\n    // Desired acceleration\n    Eigen::Vector3d acceleration_commanded = position_gain_ * position_error + velocity_gain_ * velocity_error_world;\n\n    // Adjust for gravity\n    acceleration_commanded += Eigen::Vector3d(0, 0, -9.81);\n\n    // Adjust for mass\n    acceleration_commanded /= mass_;\n\n    // Adjust for commanded acceleration\n    acceleration_commanded += command_trajectory_.acceleration;\n\n    *acceleration = acceleration_commanded;\n}", "CodeBleu_score": 45.55716670945655}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  // Check that the number of rotors is valid.\n  if (rotor_parameters_.size() != kNumMotors) {\n    std::cout << \"Invalid number of rotors.\" << std::endl;\n    return;\n  }\n\n  // Check that the number of rotor thrusts is valid.\n  if (rotor_velocities->size() != kNumMotors) {\n    std::cout << \"Invalid number of rotor thrusts.\" << std::endl;\n    return;\n  }\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(kNumMotors);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration =\n      attitude_gains_.thrust_to_angular_acceleration * desired_thrust_ +\n      attitude_gains_.error_to_angular_acceleration * attitude_error_;\n\n  // Combine the desired angular acceleration with the thrust reference.\n  Eigen::VectorXd angular_acceleration_with_thrust =\n      Eigen::VectorXd::Zero(kNumMotors);\n  angular_acceleration_with_thrust << angular_acceleration, desired_thrust_;\n\n  // Multiply the combined vector with the transformation matrix.\n  *rotor_velocities =\n      attitude_gains_.angular_acceleration_to_rotor_velocities *\n      angular_acceleration_with_thrust;\n\n  // Ensure the rotor velocities are at least one.\n  for (int i = 0; i < kNumMotors; ++i) {\n    (*rotor_velocities)(i) = std::max((*rotor_velocities)(i), 1.0);\n  }\n\n  // Take the square root of each component.\n  *rotor_velocities = (*rotor_velocities).cwiseSqrt();\n}", "CodeBleu_score": 44.40690260295366}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n    // Check that the input is valid.\n    if (rotor_velocities == nullptr) {\n        std::cout << \"The rotor_velocities pointer is nullptr in AttitudeControllerSamy::CalculateRotorVelocities.\" << std::endl;\n        return;\n    }\n\n    // Check that the number of rotors is valid.\n    if (rotor_velocities->size() != kNumMotors) {\n        std::cout << \"The rotor_velocities vector is the wrong size in AttitudeControllerSamy::CalculateRotorVelocities.\" << std::endl;\n        return;\n    }\n\n    // Resize the rotor velocities vector.\n    rotor_velocities->resize(kNumMotors);\n\n    // Calculate the desired angular acceleration.\n    Eigen::Vector3d desired_angular_acceleration = GetDesiredAngularAcceleration();\n\n    // Calculate the thrust reference.\n    Eigen::Vector3d thrust_reference = GetThrustReference();\n\n    // Calculate the desired angular acceleration and thrust reference combined.\n    Eigen::Vector3d desired_angular_acceleration_and_thrust_reference = desired_angular_acceleration + thrust_reference;\n\n    // Multiply the desired angular acceleration and thrust reference combined with the matrix.\n    Eigen::VectorXd desired_angular_acceleration_and_thrust_reference_multiplied_by_matrix =\n        kRotorVelocityMatrix * desired_angular_acceleration_and_thrust_reference;\n\n    // Take the square root of each component.\n    for (int i = 0; i < kNumMotors; i++) {\n        rotor_velocities->operator()(i) = sqrt(desired_angular_acceleration_and_thrust_reference_multiplied_by_matrix(i));\n    }\n\n    // Ensure the rotor velocities are at least one.\n    for (int i = 0; i < kNumMotors; i++) {\n        if (rotor_velocities->operator()(i) < 1", "CodeBleu_score": 40.1212177171514}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  // Ensure the input is valid.\n  assert(rotor_velocities != nullptr);\n\n  // Ensure the parameters are valid.\n  assert(params_.size() == kNumParameters);\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(kNumMotors);\n\n  // Calculate the desired angular acceleration.\n  Eigen::VectorXd desired_angular_acceleration =\n      (params_[kPMatrix] * (params_[kDesiredAngularAcceleration] - state_.attitude_error)) +\n      (params_[kDMatrix] * state_.attitude_error_dot);\n\n  // Combine the desired angular acceleration with the thrust reference.\n  Eigen::VectorXd desired_angular_acceleration_with_thrust =\n      Eigen::VectorXd::Zero(kNumMotors);\n  desired_angular_acceleration_with_thrust.head(kNumMotors - 1) =\n      desired_angular_acceleration;\n  desired_angular_acceleration_with_thrust.tail(1) =\n      params_[kThrustReference];\n\n  // Calculate the rotor velocities.\n  *rotor_velocities =\n      desired_angular_acceleration_with_thrust.cwiseMax(Eigen::VectorXd::Ones(kNumMotors))\n          .cwiseProduct(\n              params_[kRotorVelocityToThrustCoefficientMatrix] *\n              desired_angular_acceleration_with_thrust.cwiseMax(\n                  Eigen::VectorXd::Ones(kNumMotors))).cwiseSqrt();\n}", "CodeBleu_score": 41.92152506041872}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices of the start and end times\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n\n    # Create a copy of the object\n    sliced_bag = copy.deepcopy(self)\n\n    # Update the attributes of the sliced object\n    for attr in self.__dict__:\n        if attr == 'bag':\n            sliced_bag.bag = self.bag.slice(start_time, end_time)\n        elif attr == 'time':\n            sliced_bag.time = self.time[start_index:end_index + 1]\n        elif attr == 'time_index':\n            sliced_bag.time_index = self.time_index[start_index:end_index + 1]\n        elif attr == 'time_delta':\n            sliced_bag.time_delta = self.time_delta[start_index:end_index]\n        else:\n            sliced_bag.__dict__[attr] = self.__dict__[attr][start_index:end_index + 1]\n\n    return sliced_bag\n\n", "CodeBleu_score": 29.270272122111095}, {"code": "def slice(self, start_time, end_time)\n\t\n    # find the indices of the start and end times\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n\n    # make a deep copy of the object\n    new_bag = copy.deepcopy(self)\n\n    # update each attribute to contain only the sliced data\n    new_bag.header = self.header[start_index:end_index]\n    new_bag.pose = self.pose[start_index:end_index]\n    new_bag.twist = self.twist[start_index:end_index]\n    new_bag.accel = self.accel[start_index:end_index]\n    new_bag.imu = self.imu[start_index:end_index]\n    new_bag.mag = self.mag[start_index:end_index]\n    new_bag.baro = self.baro[start_index:end_index]\n    new_bag.gps = self.gps[start_index:end_index]\n    new_bag.sonar = self.sonar[start_index:end_index]\n    new_bag.battery = self.battery[start_index:end_index]\n    new_bag.motor = self.motor[start_index:end_index]\n    new_bag.rc = self.rc[start_index:end_index]\n    new_bag.servo = self.servo[start_index:end_index]\n    new_bag.range = self.range[start_index:end_index]\n    new_bag.sonar_range = self.sonar_range[start_index:end_index]\n    new_bag.sonar_range_filtered = self.sonar_range_filtered[start_index:end_index]\n    new_bag.sonar_range_raw = self.sonar_range_raw[start_index:end_index]\n    new_bag.sonar_range_raw_filtered = self.sonar_range_raw_filtered[start_index:end_index]\n    new_bag", "CodeBleu_score": 14.096907501054556}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n    new_bag = copy.deepcopy(self)\n    for attribute in self.__dict__:\n        if type(getattr(self, attribute)) is list:\n            setattr(new_bag, attribute, getattr(self, attribute)[start_index:end_index])\n    return new_bag\n\n", "CodeBleu_score": 28.234185745178152}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n\n    # Get position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    euler_angles = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object\n    waypoint_point = Point()\n    waypoint_point.x = position.x\n    waypoint_point.y = position.y\n    waypoint_point.z = position.z\n\n    # Check if the current waypoint is different from the last one\n    if self.waypoint_array[-1] != waypoint_point or self.yaw_array[-1] != euler_angles[2]:\n        # Append the new waypoint, yaw, and corresponding times to their respective arrays\n        self.waypoint_array.append(waypoint_point)\n        self.yaw_array.append(euler_angles[2])\n        self.time_array.append(bag_time)\n\n", "CodeBleu_score": 26.632010490777574}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion((rotation.x, rotation.y, rotation.z, rotation.w))\n\n    # Create Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the current waypoint is different from the last one\n    if self.waypoints_list[-1][0] != point or self.waypoints_list[-1][2] != euler[2]:\n        # Append new waypoint, yaw, and corresponding times to their respective arrays\n        self.waypoints_list.append([point, msg_time, euler[2], bag_time])\n\n", "CodeBleu_score": 21.013475774186627}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert the rotation to Euler angles\n    quat = [rotation.x, rotation.y, rotation.z, rotation.w]\n    euler = tf.transformations.euler_from_quaternion(quat)\n    yaw = euler[2]\n\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the current waypoint is different from the last one\n    # If it is, append the new point, yaw, and corresponding times to their respective arrays\n    if self.last_point is None or not self.last_point.position.x == point.x or not self.last_point.position.y == point.y or not self.last_point.position.z == point.z or not self.last_yaw == yaw:\n        self.points.append(point)\n        self.yaws.append(yaw)\n        self.times.append(msg_time)\n        self.bag_times.append(bag_time)\n        self.last_point = point\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 28.014551292614804}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic_name:\n        self.imu_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_acceleration_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(bag_time.to_sec())\n        self.bag_time.append(bag_time)\n\n", "CodeBleu_score": 30.77447721611733}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.time_acceleration.append(bag_time)\n        self.time_acceleration_bag.append(msg.header.stamp.secs)\n\n", "CodeBleu_score": 30.687026312158256}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic:\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.time_accel.append(msg.header.stamp.to_sec())\n        self.time_bag.append(bag_time)\n\n", "CodeBleu_score": 31.701275778666133}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n\n    # Create a figure with a title\n    fig = pyplot.figure(figsize=(10, 10))\n    pyplot.suptitle('Acceleration Data')\n\n    # Create a subplot for accelerations\n    ax1 = fig.add_subplot(111)\n\n    # Plot the x, y, and z components of acceleration over time\n    ax1.plot(self.acceleration_data[:, 0], self.acceleration_data[:, 1], color='b', label='x')\n    ax1.plot(self.acceleration_data[:, 0], self.acceleration_data[:, 2], color='r', label='y')\n    ax1.plot(self.acceleration_data[:, 0], self.acceleration_data[:, 3], color='g', label='z')\n\n    # Add labels for the x and y axes\n    pyplot.xlabel('Time (s)')\n    pyplot.ylabel('Acceleration (m/s^2)')\n\n    # Add a legend\n    pyplot.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        if plot_suffix is None:\n            pyplot.savefig(self.plot_dir + self.plot_prefix + '_accelerations.png', format='png')\n        else:\n            pyplot.savefig(self.plot_dir + self.plot_prefix + '_' + plot_suffix + '_accelerations.png', format='png')\n\n    # Return the figure and subplot\n    return fig, ax1\n\n", "CodeBleu_score": 35.8643744987378}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.acceleration_data:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        else:\n            plot_suffix = \"_\" + plot_suffix\n        # Create a figure with a title and a subplot for accelerations\n        fig = pyplot.figure()\n        fig.suptitle(\"Acceleration Data\" + plot_suffix, fontsize=14, fontweight='bold')\n        ax = fig.add_subplot(1, 1, 1)\n        # For each acceleration dataset, plot the x, y, and z components over time with different colors and labels\n        for i, accel_data in enumerate(self.acceleration_data):\n            ax.plot(accel_data.time_stamps, accel_data.x_data, label=\"Accel X\" + str(i + 1), color=\"r\")\n            ax.plot(accel_data.time_stamps, accel_data.y_data, label=\"Accel Y\" + str(i + 1), color=\"g\")\n            ax.plot(accel_data.time_stamps, accel_data.z_data, label=\"Accel Z\" + str(i + 1), color=\"b\")\n        # Add labels for the x and y axes and include a legend\n        ax.set_xlabel(\"Time (s)\")\n        ax.set_ylabel(\"Acceleration (m/s^2)\")\n        ax.legend()\n        # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n        if self.save_plots:\n            filename = self.plot_filename_prefix + \"accelerations\" + plot_suffix + \".png\"\n            pyplot.savefig(filename)\n\n", "CodeBleu_score": 40.07447508591255}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.accel_data is None:\n        return\n\n    # Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure(figsize=(12, 8))\n    pyplot.title(\"Accelerations\")\n    ax = fig.add_subplot(1, 1, 1)\n\n    # Plot the x, y, and z components over time with different colors and labels\n    for i in range(3):\n        ax.plot(self.accel_data.times, self.accel_data.data[:, i], label=self.accel_data.labels[i], color=self.accel_data.colors[i])\n\n    # Add labels for the x and y axes and include a legend\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    pyplot.legend(loc=\"upper right\")\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = self.plots_dir + \"accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n        pyplot.savefig(filename)\n\n    # Show the plot\n    pyplot.show()\n\n", "CodeBleu_score": 42.45638688509305}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces)-1):\n        self.compare_two_xyz(pose_indeces[i], pose_indeces[i+1])\n", "CodeBleu_score": 7.611206243871485}, {"code": "def compare_positions(self, pose_indeces)\n\t\n\n    for i in range(len(pose_indeces)-1):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 25.839059751769888}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) > 1:\n        for i in range(0, len(pose_indeces) - 1):\n            compare_two_xyz(self, pose_indeces[i], pose_indeces[i + 1])\n    else:\n        print(\"You must provide at least two pose indices to compare positions.\")\n\n", "CodeBleu_score": 32.669205574681314}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    if start_time is None:\n        start_time = self.wrench[0].header.stamp.to_sec()\n    if end_time is None:\n        end_time = self.wrench[-1].header.stamp.to_sec()\n    collision_times = []\n    for i in range(len(self.wrench)):\n        if start_time <= self.wrench[i].header.stamp.to_sec() <= end_time:\n            collision_times.append(self.wrench[i].header.stamp.to_sec())\n    return collision_times\n\n", "CodeBleu_score": 36.07841536570855}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if (start_time is None or collision.header.stamp.to_sec() >= start_time) and (end_time is None or collision.header.stamp.to_sec() <= end_time):\n            collision_times.append(collision.header.stamp.to_sec())\n    return collision_times\n\n", "CodeBleu_score": 45.49771926825068}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    # Initialize an empty list for collision times\n    collision_times = []\n    # Iterate through each collision's time in self.wrench\n    for collision in self.wrench:\n        # If the time is within the start_time and end_time range, append the time to the collision_times list\n        if start_time <= collision.header.stamp.to_sec() <= end_time:\n            collision_times.append(collision.header.stamp.to_sec())\n    # Return the list of collision times\n    return collision_times\n\n", "CodeBleu_score": 40.455341762668716}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 30.087936187511037}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 30.087936187511037}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time,\n                                        absolute_settling_time, x_range,\n                                        plot_suffix, y_range=(-1.5, 1.5))\n\n", "CodeBleu_score": 35.99230538159559}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate the multiplier\n  double multiplier = 1.0;\n  if (this->noise_type_ == \"gaussian\") {\n    multiplier = 1.0 / (this->mean_ * this->mean_);\n  }\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Compute the RMS noise\n  double rms_noise = this->mean_ * sqrt(multiplier);\n\n  // Create a vector of noise values\n  Eigen::VectorXf noise_vec(width * height);\n  for (uint32_t i = 0; i < width * height; ++i) {\n    // Add noise if the pixel value is in range, otherwise set the pixel to a\n    // bad point value\n    if (data_vec(i) > 0.0 && data_vec(i) < 10.0) {\n      noise_vec(i) = rms_noise * this->noise_dist_(this->gen_);\n    } else {\n      noise_vec(i) = 0.0;\n    }\n  }\n\n  // Add noise to the data\n  data_vec += noise_vec;\n}", "CodeBleu_score": 49.5009309968392}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  // Check if data pointer is null\n  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate multiplier based on camera parameters\n  double multiplier = 1.0;\n  if (this->camera_ == \"D435\") {\n    multiplier = 1000.0 / 500.0;\n  }\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Compute RMS noise\n  double rms_noise = this->rng_->Gaussian(this->mean_, this->stddev_);\n\n  // Compute noise values\n  Eigen::VectorXf noise_vec =\n      Eigen::VectorXf::NullaryExpr(width * height, [&rms_noise]() {\n        return rms_noise * std::sqrt(2.0 * std::log(1.0 / 0.05));\n      });\n\n  // Add noise to data\n  for (int i = 0; i < width * height; i++) {\n    if (data_vec(i) > 0 && data_vec(i) < 10000) {\n      data_vec(i) = data_vec(i) + noise_vec(i) * multiplier;\n    } else {\n      data_vec(i) = 0;\n    }\n  }\n}", "CodeBleu_score": 50.64371997071731}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (!data) {\n    return;\n  }\n\n  const float multiplier = 1.0f / (2.0f * this->range_);\n  Eigen::Map<Eigen::VectorXf> data_vector(data, width * height);\n\n  // Calculate RMS noise\n  float rms_noise = this->rms_noise_ *\n                    sqrt(multiplier * this->range_ / this->noise_density_);\n\n  // Calculate noise values\n  Eigen::VectorXf noise_vector = Eigen::VectorXf::Random(width * height) *\n                                 rms_noise;\n\n  // Add noise to data\n  for (unsigned int i = 0; i < width * height; ++i) {\n    if (data_vector(i) > 0.0f && data_vector(i) < this->range_) {\n      data_vector(i) += noise_vector(i);\n    } else {\n      data_vector(i) = this->bad_point_value_;\n    }\n  }\n}", "CodeBleu_score": 48.11542188235284}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n    ros::Time sim_time = ros::Time(world_->SimTime().Double());\n    ros::Time ros_time = ros::Time(sim_time.toSec() + time_offset_);\n    std::stringstream ss;\n    ss << \"Writing waypoint message to \" << bag_file_name_ << \" at \" << ros_time << std::endl;\n    ROS_INFO_STREAM(ss.str());\n    bag_.write(waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 44.853138320832336}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time current_ros_time = ros::Time::now();\n  ros::Time trajectory_ros_time = ros::Time(trajectory_msg->header.stamp.sec,\n                                            trajectory_msg->header.stamp.nsec);\n  ros::Duration elapsed_time = current_ros_time - trajectory_ros_time;\n  trajectory_msg->header.stamp = current_ros_time;\n  trajectory_msg->header.stamp -= elapsed_time;\n  trajectory_msg->header.frame_id = world_frame_id_;\n  trajectory_msg->header.seq++;\n  trajectory_msg->header.stamp.fromNSec(trajectory_msg->header.stamp.toNSec());\n  trajectory_msg->header.stamp.fromSec(trajectory_msg->header.stamp.toSec());\n\n  trajectory_bag_.write(waypoint_topic_, current_ros_time,\n                        *trajectory_msg);\n}", "CodeBleu_score": 40.83052664479227}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  common::Time sim_time = world_->GetSimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = ros::Time(sim_time.sec, sim_time.nsec);\n\n  // Write the trajectory message to the bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 67.45274634002404}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\n  // Convert the simulation time to ROS time\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for motor velocities\n  mav_msgs::Actuators motor_velocities;\n  motor_velocities.header.stamp = ros_now;\n\n  // Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message\n  for (int i = 0; i < motor_joint_names_.size(); i++) {\n    motor_velocities.angular_velocities.push_back(motor_velocities_[i]);\n  }\n\n  // Write the data to a bag file using the specified namespace and motor topic\n  motor_velocities_pub_.publish(motor_velocities);\n\n  // Write the data to a bag file using the specified namespace and motor topic\n  motor_velocities_pub_.publish(motor_velocities);\n\n}", "CodeBleu_score": 44.036993653637495}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\n  // Convert simulation time to ROS time\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare message for motor velocities\n  mav_msgs::Actuators motor_velocities;\n  motor_velocities.header.stamp = ros_now;\n  motor_velocities.header.frame_id = \"base_link\";\n\n  // Iterate through the motor joints\n  for (int i = 0; i < motor_joint_names_.size(); i++) {\n    // Calculate slowed-down rotational velocities\n    double rotational_velocity = motor_joints_[i]->GetVelocity(0) * motor_joint_rotational_velocities_slowdown_factors_[i];\n\n    // Assign rotational velocities to message\n    motor_velocities.angular_velocities.push_back(rotational_velocity);\n  }\n\n  // Write message to bag file\n  motor_velocities_bag_.write(motor_velocities_topic_, ros_now, motor_velocities);\n}", "CodeBleu_score": 50.69055357347371}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  // Prepare message for motor velocities\n  mav_msgs::Actuators actuators_msg;\n  actuators_msg.header.stamp = ros_now;\n  // Iterate through motor joints\n  for (int i = 0; i < this->motor_joint_names_.size(); i++) {\n    // Calculate slowed-down rotational velocities\n    double rot_vel = this->motor_joint_velocities_[i] * this->motor_rotor_velocity_slowdown_factor_;\n    // Assign velocities to message\n    actuators_msg.angular_velocities.push_back(rot_vel);\n  }\n  // Write message to bag file\n  this->motor_velocity_bag_.write(this->motor_velocity_topic_, ros_now, actuators_msg);\n}", "CodeBleu_score": 44.40122916118061}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // Convert normalized roll, pitch, and yaw rate to control surface angles\n  roll_ = roll_pitch_yawrate_thrust_msg->roll() * M_PI;\n  pitch_ = roll_pitch_yawrate_thrust_msg->pitch() * M_PI;\n  yaw_rate_ = roll_pitch_yawrate_thrust_msg->yaw_rate() * M_PI;\n\n  // Set throttle\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 35.3933730362607}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called\n\";\n  }\n  // Convert roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll() * M_PI / 2.0;\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch() * M_PI / 2.0;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n\n  double aileron_angle = roll_angle * aileron_ratio_;\n  double elevator_angle = pitch_angle * elevator_ratio_;\n  double rudder_angle = yaw_rate * rudder_ratio_;\n\n  // Set the throttle value from the thrust message\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Set the control surface angles for the ailerons, elevator, and rudder\n  aileron_joint_->SetAngle(0, aileron_angle);\n  elevator_joint_->SetAngle(0, elevator_angle);\n  rudder_joint_->SetAngle(0, rudder_angle);\n\n  // Set the throttle value\n  throttle_joint_->SetForce(0, thrust);\n}", "CodeBleu_score": 42.91934301441992}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_print_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called.\n\";\n  }\n\n  // Convert normalized roll, pitch, and yaw rate to control surface angles\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll() * M_PI * 0.5;\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch() * M_PI * 0.5;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n\n  // Set control surface angles\n  aileron_->SetAngle(roll_angle);\n  elevator_->SetAngle(pitch_angle);\n  rudder_->SetAngle(yaw_rate);\n\n  // Set throttle\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 40.96676042446563}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Convert timeout to timeval\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs - (tv.tv_sec * 1000)) * 1000;\n\n  // Poll for MAVLink messages\n  int ret = poll(fds, nfds, tv.tv_sec * 1000 + tv.tv_usec / 1000);\n  if (ret < 0) {\n    gzerr << \"Error while polling for MAVLink messages.\" << std::endl;\n    return;\n  } else if (ret == 0) {\n    // Timeout\n    return;\n  }\n\n  // Receive data from file descriptor\n  if (fds[0].revents & POLLIN) {\n    int len = read(fds[0].fd, buf, BUFLEN);\n    if (len <= 0) {\n      gzerr << \"Error while reading from file descriptor.\" << std::endl;\n      return;\n    }\n\n    // Parse MAVLink messages\n    for (unsigned i = 0; i < len; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status)) {\n        // Handle MAVLink message\n        handleMAVLinkMessage(&msg, _dt);\n      }\n    }\n  }\n}", "CodeBleu_score": 59.90234718725669}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Check if we have a serial connection\n  if (!this->serialConn) {\n    return;\n  }\n\n  // Check if we have any subscribers\n  if (this->mavlinkSubscribers.empty()) {\n    return;\n  }\n\n  // Convert timeout to timeval\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for data\n  int fds = this->serialConn->GetFD();\n  if (fds < 0) {\n    gzerr << \"Serial connection has no file descriptor", "CodeBleu_score": 21.808738528433558}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t\n  // Get the current time\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n\n  // Convert the timeout to a timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Add the timeout to the current time\n  timeout.tv_sec += tv.tv_sec;\n  timeout.tv_usec += tv.tv_usec;\n  timeout.tv_sec += timeout.tv_usec / 1000000;\n  timeout.tv_usec = timeout.tv_usec % 1000000;\n\n  // Poll for data\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(this->fd, &fds);\n  int res = select(this->fd + 1, &fds, NULL, NULL, &timeout);\n\n  // If data is available, receive it and parse MAVLink messages\n  if (res > 0) {\n\n    // Receive data\n    char buf[MAVLINK_MAX_PACKET_LEN];\n    int len = read(this->fd, buf, MAVLINK_MAX_PACKET_LEN);\n\n    // Parse MAVLink messages\n    for (int i = 0; i < len; i++) {\n      mavlink_status_t status;\n      mavlink_message_t msg;\n      mavlink_msg_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status);\n\n      // Handle MAVLink message\n      handleMAVLinkMessage(&msg);\n    }\n  }\n}", "CodeBleu_score": 51.48248583752982}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t    std::lock_guard<std::mutex> lock(this->mutex);\n    if (this->is_open) {\n        this->io_service.stop();\n        this->serial_port.close();\n        if (this->io_thread.joinable()) {\n            this->io_thread.join();\n        }\n        this->is_open = false;\n    }\n}", "CodeBleu_score": 29.90245853118529}, {"code": "void GazeboMavlinkInterface::close() {\n\t    boost::mutex::scoped_lock lock(this->mutex);\n    if (!this->is_open_) {\n        return;\n    }\n    this->is_open_ = false;\n    this->io_service_.stop();\n    this->serial_.close();\n    if (this->io_thread_.joinable()) {\n        this->io_thread_.join();\n    }\n}", "CodeBleu_score": 32.06148082810869}, {"code": "void GazeboMavlinkInterface::close() {\n\t    boost::mutex::scoped_lock lock(mutex_);\n    if (open_) {\n        io_service_.stop();\n        serial_port_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n        open_ = false;\n    }\n}", "CodeBleu_score": 57.98696151649615}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d x1, y1, x2, y2, x;\n  double y;\n  x1 = ignition::math::Vector3d(0, 0, 0);\n  y1 = ignition::math::Vector3d(0, 0, 0);\n  x2 = ignition::math::Vector3d(0, 0, 0);\n  y2 = ignition::math::Vector3d(0, 0, 0);\n  x = ignition::math::Vector3d(0, 0, 0);\n  y = 0;\n  x1.X() = 0;\n  x1.Y() = 0;\n  x1.Z() = 0;\n  y1.X() = 0;\n  y1.Y() = 0;\n  y1.Z() = 0;\n  x2.X() = 0;\n  x2.Y() = 0;\n  x2.Z() = 0;\n  y2.X() = 0;\n  y2.Y() = 0;\n  y2.Z() = 0;\n  x.X() = 0;\n  x.Y() = 0;\n  x.Z() = 0;\n  y = 0;\n\n  x1.X() = 0;\n  x1.Y() = 0;\n  x1.Z() = 0;\n  y1.X() = 0;\n  y1.Y() = 0;\n  y1.Z() = 0;\n  x2.X() = 0;\n  x2.Y() = 0;\n  x2.Z() = 0;\n  y2.X() = 0;\n  y2.Y() = 0;\n  y2.Z() = 0;\n  x.X() = 0;\n  x.Y() = 0;\n  x.Z() = 0;\n  y = 0;\n\n  x1.X() = 0;\n  x1.Y() = 0;\n  x1.Z", "CodeBleu_score": 32.73797208579473}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    double x, double y, double z,\n    const std::vector<double> &x_coordinates,\n    const std::vector<double> &y_coordinates,\n    const std::vector<double> &z_coordinates\n}", "CodeBleu_score": 26.069954177846967}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    (const ignition::math::Vector3d &pos,\n    const ignition::math::Vector3d &pos1,\n    const ignition::math::Vector3d &pos2,\n    const ignition::math::Vector3d &value1,\n    const ignition::math::Vector3d &value2) {\n\n    double x = pos.X();\n    double y = pos.Y();\n    double z = pos.Z();\n\n    double x1 = pos1.X();\n    double y1 = pos1.Y();\n    double z1 = pos1.Z();\n\n    double x2 = pos2.X();\n    double y2 = pos2.Y();\n    double z2 = pos2.Z();\n\n    double x_diff = x2 - x1;\n    double y_diff = y2 - y1;\n    double z_diff = z2 - z1;\n\n    double value_x = value1.X() + (value2.X() - value1.X()) * (x - x1) / x_diff;\n    double value_y = value1.Y() + (value2.Y() - value1.Y()) * (y - y1) / y_diff;\n    double value_z = value1.Z() + (value2.Z() - value1.Z()) * (z - z1) / z_diff;\n\n    return ignition::math::Vector3d(value_x, value_y, value_z);\n}\n", "CodeBleu_score": 35.14132945647588}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t  if (_time < 0) {\n    gzerr << \"Animation::SetTime: time < 0.0\n\";\n    return;\n  }\n\n  if (this->loop) {\n    this->time = fmod(_time, this->length);\n  }\n  else {\n    this->time = std::max(0.0, std::min(_time, this->length));\n  }\n\n  this->Update();\n}", "CodeBleu_score": 44.58530101498582}, {"code": "void Animation::SetTime(double _time){\n\t  if (this->loop) {\n    this->time = _time;\n    if (this->time > this->length) {\n      this->time = this->time - this->length;\n    }\n    if (this->time < 0) {\n      this->time = this->time + this->length;\n    }\n  }\n  else {\n    this->time = std::max(0.0, std::min(this->time, this->length));\n  }\n}", "CodeBleu_score": 46.60225900524948}, {"code": "void Animation::SetTime(double _time){\n\t  if (this->loop) {\n    this->time = _time;\n    if (this->time > this->length) {\n      this->time -= this->length;\n    }\n  } else {\n    this->time = std::min(this->length, _time);\n    this->time = std::max(0.0, this->time);\n  }\n}", "CodeBleu_score": 49.11642201525551}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.target_pose.header.frame_id = \"1\"\n    self.target_pose.header.stamp = rospy.Time.now()\n    self.target_pose.pose.position.x = self.current_pose.pose.position.x\n    self.target_pose.pose.position.y = self.current_pose.pose.position.y\n    self.target_pose.pose.position.z = self.current_pose.pose.position.z\n    self.target_pose.pose.orientation = self.current_pose.pose.orientation\n    self.target_pose.pose.position.z = 2\n    self.target_pose.pose.orientation = Quaternion(\n        x=0, y=0, z=0, w=1)\n    self.target_pose.pose.position.z = 2\n    self.target_pose.pose.orientation = Quaternion(\n        x=0, y=0, z=0, w=1)\n    self.target_pose.pose.position.z = 2\n    self.target_pose.pose.orientation = Quaternion(\n        x=0, y=0, z=0, w=1)\n    self.target_pose.pose.position.z = 2\n    self.target_pose.pose.orientation = Quaternion(\n        x=0, y=0, z=0, w=1)\n    self.target_pose.pose.position.z = 2\n    self.target_pose.pose.orientation = Quaternion(\n        x=0, y=0, z=0, w=1)\n    self.target_pose.pose.position.z = 2\n    self.target_pose.pose.orientation = Quaternion(\n        x=0, y=0, z=0, w=1)\n    self.target_pose.pose.position.z = 2\n    self.target_pose.pose.orientation = Quaternion(\n        x=0, y=0, z=0, w=1)\n    self.target_pose.pose.position.z = 2\n    self.target_pose.pose.orientation =", "CodeBleu_score": 9.213759339383214}, {"code": "def hover(self)\n\t\n    # Set coordinate frame\n    self.coordinate_frame = 1\n    # Set motion type\n    self.motion_type = 0\n    # Construct target motion\n    self.target_motion = PoseStamped()\n    self.target_motion.header.stamp = rospy.Time.now()\n    self.target_motion.header.frame_id = 'map'\n    self.target_motion.pose.position.x = self.current_position.pose.position.x\n    self.target_motion.pose.position.y = self.current_position.pose.position.y\n    self.target_motion.pose.position.z = self.current_position.pose.position.z\n    self.target_motion.pose.orientation = self.current_position.pose.orientation\n    # Print vehicle type, vehicle ID, and flight mode\n    print('Vehicle type: %s' % self.vehicle_type)\n    print('Vehicle ID: %s' % self.vehicle_ID)\n    print('Flight mode: %s' % self.flight_mode)\n\n", "CodeBleu_score": 51.286801068348794}, {"code": "def hover(self)\n\t\n    self.target_pose.header.frame_id = \"1\"\n    self.target_pose.header.stamp = rospy.Time.now()\n    self.target_pose.pose.position.x = self.current_pose.pose.position.x\n    self.target_pose.pose.position.y = self.current_pose.pose.position.y\n    self.target_pose.pose.position.z = self.current_pose.pose.position.z\n    self.target_pose.pose.orientation.x = self.current_pose.pose.orientation.x\n    self.target_pose.pose.orientation.y = self.current_pose.pose.orientation.y\n    self.target_pose.pose.orientation.z = self.current_pose.pose.orientation.z\n    self.target_pose.pose.orientation.w = self.current_pose.pose.orientation.w\n    self.target_pose.type_mask = 0\n    self.target_pose.coordinate_frame = 1\n    self.target_pose.velocity.x = 0\n    self.target_pose.velocity.y = 0\n    self.target_pose.velocity.z = 0\n    self.target_pose.acceleration_or_force.x = 0\n    self.target_pose.acceleration_or_force.y = 0\n    self.target_pose.acceleration_or_force.z = 0\n    self.target_pose.yaw = 0\n    self.target_pose.yaw_rate = 0\n\n    rospy.loginfo(\"Vehicle type: %s\", self.vehicle_type)\n    rospy.loginfo(\"Vehicle ID: %s\", self.vehicle_id)\n    rospy.loginfo(\"Flight mode: %s\", self.flight_mode)\n\n", "CodeBleu_score": 22.9712482551324}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n\n    rospy.loginfo(\"Setting mode to: %s\" % self.flight_mode)\n    flight_mode_service = rospy.ServiceProxy(\n        '/mavros/set_mode', SetMode)\n    flight_mode_service(custom_mode=self.flight_mode)\n\n    rospy.loginfo(\"Waiting for mode to be set...\")\n    while self.flight_mode != self.flight_mode_current:\n        rospy.sleep(0.1)\n\n    if self.flight_mode == self.flight_mode_current:\n        rospy.loginfo(\"Mode change successful\")\n        return True\n    else:\n        rospy.loginfo(\"Mode change failed\")\n        return False\n\n", "CodeBleu_score": 39.33669906446394}, {"code": "def flight_mode_switch(self)\n\t\n    # Switch to OFFBOARD mode\n    print(\"Setting to OFFBOARD flight mode\")\n    self.flightModeService(custom_mode='OFFBOARD')\n    # Wait for the mode to switch to OFFBOARD\n    while not self.flightModeReq.mode == 'OFFBOARD':\n        self.rate.sleep()\n    print(\"OFFBOARD mode activated\")\n    return True\n\n", "CodeBleu_score": 27.630090194835745}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hoverFlag = 1\n        self.hover()\n        return True\n    else:\n        rospy.wait_for_service('mavros/cmd/set_mode')\n        flightModeService = rospy.ServiceProxy('mavros/cmd/set_mode', SetMode)\n        flightModeService(custom_mode=self.flightMode)\n        if self.flightMode == 'OFFBOARD':\n            self.offboardFlag = 1\n        if self.flightMode == 'AUTO.RTL':\n            self.rtlFlag = 1\n        if self.flightMode == 'AUTO.LAND':\n            self.landFlag = 1\n        if self.flightMode == 'AUTO.MISSION':\n            self.missionFlag = 1\n        if self.flightMode == 'AUTO.RTGS':\n            self.rtgsFlag = 1\n        if self.flightMode == 'AUTO.RTL':\n            self.rtlFlag = 1\n        if self.flightMode == 'AUTO.LAND':\n            self.landFlag = 1\n        if self.flightMode == 'AUTO.MISSION':\n            self.missionFlag = 1\n        if self.flightMode == 'AUTO.RTGS':\n            self.rtgsFlag = 1\n        if self.flightMode == 'AUTO.RTL':\n            self.rtlFlag = 1\n        if self.flightMode == 'AUTO.LAND':\n            self.landFlag = 1\n        if self.flightMode == 'AUTO.MISSION':\n            self.missionFlag = 1\n        if self.flightMode == 'AUTO.RTGS':\n            self.rtgsFlag = 1\n        if self.flightMode == 'AUTO.RTL':\n            self.rtlFlag = 1\n        if self.flightMode == 'AUTO.LAND':\n            self.landFlag = 1\n        if self.flightMode == 'AUTO.MISSION':\n            self.missionFlag = 1\n        if self.fl", "CodeBleu_score": 26.103780892791058}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    # TODO: Add a state machine to transition between hover and hold\n    # TODO: Add a state machine to transition between enu and body\n    # TODO: Add a state machine to transition between hold and waypoint\n    # TODO: Add a state machine to transition between waypoint and enu\n\n    # TODO: Add a state machine to transition between hover and hold\n    # TODO: Add a state machine to transition between enu and body\n    # TODO: Add a state machine to transition between hold and waypoint\n    # TODO: Add a state machine to transition between waypoint and enu\n\n    # TODO: Add a state machine to transition between hover and hold\n    # TODO: Add a state machine to transition between enu and body\n    # TODO: Add a state machine to transition between hold and waypoint\n    # TODO: Add a state machine to transition between waypoint and enu\n\n    # TODO: Add a state machine to transition between hover and hold\n    # TODO: Add a state machine to transition between enu and body\n    # TODO: Add a state machine to transition between hold and waypoint\n    # TODO: Add a state machine to transition between waypoint and enu\n\n    # TODO: Add a state machine to transition between hover and hold\n    # TODO: Add a state machine to transition between enu and body\n    # TODO: Add a state machine to transition between hold and waypoint\n    # TODO: Add a state machine to transition between waypoint and enu\n\n    # TODO: Add a state machine to transition between hover and hold\n    # TODO: Add a state machine to transition between enu and body\n    # TODO: Add a state machine to transition between hold and waypoint\n    # TODO: Add a state machine to transition between waypoint and enu\n\n    # TODO: Add a state machine to transition between hover and hold\n    # TODO: Add a state machine to transition between enu and body\n    # TODO: Add a state machine to transition between hold and waypoint\n    # TODO: Add a state machine to transition between waypoint and enu\n\n    # TODO: Add a state machine to transition between hover and hold\n    # TODO: Add a state machine to transition between enu and body\n    # TODO: Add a state machine to transition between hold and waypoint\n    # TODO: Add a state machine to", "CodeBleu_score": 1.031650641025641}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    # TODO: implement\n    self.hover_flag = 0\n    self.hold_flag = 0\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    self.target_motion = PoseStamped()\n    self.target_motion.header.stamp = rospy.Time.now()\n    self.target_motion.header.frame_id = \"enu\"\n    self.target_motion.pose.position.x = msg.linear.x\n    self.target_motion.pose.position.y = msg.linear.y\n    self.target_motion.pose.position.z = msg.linear.z\n    self.target_motion.pose.orientation = Quaternion(axis=[0,0,1], angle=msg.angular.z)\n    self.target_motion.pose.orientation = self.target_motion.pose.orientation.normalized()\n\n", "CodeBleu_score": 39.04840475691642}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.target_motion = self.construct_target_motion(msg.linear, msg.angular)\n    elif self.hover_flag == 1:\n        self.target_motion = self.construct_target_motion(msg.linear, msg.angular)\n        self.hover_state_transition(msg.linear.x, msg.angular.z)\n    elif self.hold_flag == 1:\n        self.target_motion = self.construct_target_motion(msg.linear, msg.angular)\n        self.hold_state_transition(msg.linear.x, msg.angular.z)\n\n", "CodeBleu_score": 50.19624600685517}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    # Check if the drone is in the HOVER flight mode\n    if self.flight_mode != \"HOVER\":\n        # Check if the drone is within the positional thresholds\n        if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02):\n            # Set hover_flag to 0 and change the flight mode to 'OFFBOARD'\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        # Check if the drone is within the rotational thresholds\n        elif (abs(w) > 0.005):\n            # Set hover_flag to 0 and change the flight mode to 'OFFBOARD'\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        # Check if the drone is within the positional and rotational thresholds\n        elif (abs(x) <= 0.02) and (abs(y) <= 0.02) and (abs(z) <= 0.02) and (abs(w) <= 0.005):\n            # Set hover_flag to 1, change the flight mode to 'HOVER', and initiate the hover action\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover_action()\n    # Check if the drone is in the HOVER flight mode\n    elif self.flight_mode == \"HOVER\":\n        # Check if the drone is within the positional thresholds\n        if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02):\n            # Set hover_flag to 0 and change the flight mode to 'OFFBOARD'\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        # Check if the drone is within the rotational thresholds\n        elif (abs(w) > 0.005):\n            # Set hover_flag to 0", "CodeBleu_score": 50.11233975565457}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 0:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.set_flight_mode()\n            self.hover_action()\n    elif self.hover_flag == 1:\n        if x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.set_flight_mode()\n\n", "CodeBleu_score": 51.73468292640459}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    # Check if the drone is in the hover state\n    if self.hover_flag == 1:\n        # Check if the drone is within the positional threshold\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02:\n            # If the drone is not within the positional threshold, set the flag to 0\n            self.hover_flag = 0\n            # Set the flight mode to \"OFFBOARD\"\n            self.set_flight_mode(\"OFFBOARD\")\n            # Set the hover flag to 0\n            self.hover_flag = 0\n        # Check if the drone is within the rotational threshold\n        if abs(w) > 0.005:\n            # If the drone is not within the rotational threshold, set the flag to 0\n            self.hover_flag = 0\n            # Set the flight mode to \"OFFBOARD\"\n            self.set_flight_mode(\"OFFBOARD\")\n            # Set the hover flag to 0\n            self.hover_flag = 0\n    # Check if the drone is not in the hover state\n    elif self.hover_flag == 0:\n        # Check if the drone is within the positional threshold\n        if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02:\n            # If the drone is within the positional threshold, set the flag to 1\n            self.hover_flag = 1\n            # Set the flight mode to \"HOVER\"\n            self.set_flight_mode(\"HOVER\")\n            # Set the hover flag to 1\n            self.hover_flag = 1\n        # Check if the drone is within the rotational threshold\n        if abs(w) < 0.005:\n            # If the drone is within the rotational threshold, set the flag to 1\n            self.hover_flag = 1\n            # Set the flight mode to \"HOVER\"\n            self.set_flight_mode(\"HOVER\")\n            # Set the hover flag to 1\n            self", "CodeBleu_score": 51.59340740358651}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q.w, q.x, q.y, q.z)\n        yaw = q.yaw_pitch_roll[0]\n    return yaw\n\n", "CodeBleu_score": 60.94785503739226}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q.w, q.x, q.y, q.z)\n        yaw = q.yaw_pitch_roll[0]\n    return yaw\n\n", "CodeBleu_score": 60.94785503739226}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw_pitch_roll[0]\n    else:\n        yaw = Quaternion(q.w, q.x, q.y, q.z).yaw_pitch_roll[0]\n    return yaw\n\n", "CodeBleu_score": 56.971707924421786}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_pose = PoseStamped()\n    self.target_pose.pose.position.x = self.current_pose.pose.position.x\n    self.target_pose.pose.position.y = self.current_pose.pose.position.y\n    self.target_pose.pose.position.z = self.current_pose.pose.position.z\n    self.target_pose.pose.orientation = self.current_pose.pose.orientation\n    self.vehicle_type = \"quadrotor\"\n    self.vehicle_id = 1\n    self.flight_mode = \"HOVER\"\n\n", "CodeBleu_score": 48.194972506001456}, {"code": "def hover(self)\n\t\n    # Set the coordinate frame to be body-fixed\n    self.coordinate_frame = 8\n    # Set the motion type to be body-fixed\n    self.motion_type = 8\n    # Construct a target motion using the current position and yaw values\n    self.target_pose.pose.position.x = self.local_pose.pose.position.x\n    self.target_pose.pose.position.y = self.local_pose.pose.position.y\n    self.target_pose.pose.position.z = self.local_pose.pose.position.z\n    self.target_pose.pose.orientation = self.local_pose.pose.orientation\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight mode:\", self.flight_mode)\n\n", "CodeBleu_score": 35.96333947525104}, {"code": "def hover(self)\n\t\n\n    # Set coordinate frame to global\n    self.set_frame(frame_id='map', child_frame_id='base_link')\n\n    # Set motion type to hover\n    self.set_motion_type(motion_type='HOVER')\n\n    # Construct target motion\n    target_motion = PoseStamped()\n    target_motion.header.stamp = rospy.Time.now()\n    target_motion.header.frame_id = 'map'\n    target_motion.pose.position.x = self.current_position[0]\n    target_motion.pose.position.y = self.current_position[1]\n    target_motion.pose.position.z = self.current_position[2]\n    target_motion.pose.orientation = self.current_orientation\n\n    # Set target motion\n    self.set_target_motion(target_motion)\n\n    # Print vehicle type, vehicle ID, and flight mode\n    rospy.loginfo(\"Vehicle Type: %s\", self.vehicle_type)\n    rospy.loginfo(\"Vehicle ID: %s\", self.vehicle_id)\n    rospy.loginfo(\"Flight Mode: %s\", self.flight_mode)\n\n", "CodeBleu_score": 23.158815716632677}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    # Switch to HOVER mode\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n\n    # Switch to a different mode\n    else:\n        rospy.wait_for_service('mavros/cmd/set_mode')\n        try:\n            flightModeService = rospy.ServiceProxy('mavros/cmd/set_mode', SetMode)\n            flightModeService(custom_mode=self.flight_mode)\n            rospy.loginfo(\"Flight mode switched to %s\" % self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.logerr(\"Flight mode switch service failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 41.11600646957842}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        rospy.loginfo(\"Setting flight mode to %s\", self.flightMode)\n        flightModeService = rospy.ServiceProxy('/mavros/set_mode', SetMode)\n        flightModeService(custom_mode=self.flightMode)\n        return True\n\n", "CodeBleu_score": 34.026418705832654}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hoverFlag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flightMode)\n            rospy.loginfo(\"Flight mode switched to \" + self.flightMode)\n            return True\n        except:\n            rospy.loginfo(\"Flight mode switch failed\")\n            return False\n\n", "CodeBleu_score": 48.116551802019266}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 51.10360294045804}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 51.10360294045804}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.local_pose_time = time.time()\n\n        if self.takeoff_target_pose is None:\n            self.takeoff_target_pose = msg\n            self.takeoff_target_pose_time = time.time()\n\n        if self.hover_target_pose is None:\n            self.hover_target_pose = msg\n            self.hover_target_pose_time = time.time()\n\n        if self.local_pose.pose.position.z > self.takeoff_target_pose.pose.position.z:\n            self.takeoff_target_pose = msg\n            self.takeoff_target_pose_time = time.time()\n\n        if self.local_pose.pose.position.z > self.hover_target_pose.pose.position.z:\n            self.hover_target_pose = msg\n            self.hover_target_pose_time = time.time()\n\n        self.global_pose.pose.position.x = msg.pose.position.x + self.global_pose_bias[0]\n        self.global_pose.pose.position.y = msg.pose.position.y + self.global_pose_bias[1]\n        self.global_pose.pose.position.z = msg.pose.position.z + self.global_pose_bias[2]\n        self.global_pose.pose.orientation = msg.pose.orientation\n\n", "CodeBleu_score": 22.904551713368527}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == self.uav_id[i]:\n        self.local_pose[i] = msg\n\n        if self.gcs_cmd[i] == \"TAKEOFF\":\n            self.takeoff_target_pose[i] = copy.deepcopy(self.local_pose[i])\n            self.takeoff_target_pose[i].pose.position.z += 1\n            self.global_pose[i].pose.position.z += 1\n        elif self.gcs_cmd[i] == \"HOVER\":\n            self.hover_target_pose[i] = copy.deepcopy(self.local_pose[i])\n            self.global_pose[i].pose.position.z += 1\n\n        self.global_pose[i].pose.position.x = self.local_pose[i].pose.position.x + self.local_pose[i].pose.position.x * self.bias[i]\n        self.global_pose[i].pose.position.y = self.local_pose[i].pose.position.y + self.local_pose[i].pose.position.y * self.bias[i]\n        self.global_pose[i].pose.position.z = self.local_pose[i].pose.position.z + self.local_pose[i].pose.position.z * self.bias[i]\n        self.global_pose[i].pose.orientation = self.local_pose[i].pose.orientation\n\n", "CodeBleu_score": 28.61989188025216}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == i:\n        self.local_pose = msg\n        self.local_pose.pose.position.x += self.local_pose_bias.x\n        self.local_pose.pose.position.y += self.local_pose_bias.y\n        self.local_pose.pose.position.z += self.local_pose_bias.z\n        self.global_pose.pose.position.x = self.local_pose.pose.position.x\n        self.global_pose.pose.position.y = self.local_pose.pose.position.y\n        self.global_pose.pose.position.z = self.local_pose.pose.position.z\n        self.global_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n        self.global_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n        self.global_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n        self.global_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n        self.global_pose.header.stamp = rospy.Time.now()\n        self.global_pose.header.seq = i\n        self.global_pose.header.frame_id = \"map\"\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.gcs_command == \"hover\":\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n\n", "CodeBleu_score": 28.78984561859128}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.current_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 74.38794348022033}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == True:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.88263518862473}, {"code": "def takeoff_detection(self)\n\t\n    if self.current_state.pose.position.z > 0.2 and self.arm_state == True:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 64.58084106451916}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Create a distance matrix\n    distance_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i][j] = numpy.linalg.norm(orig_formation[i] - change_formation[j])\n            # Adjust the distances by subtracting them from 50 and converting to integers\n            distance_matrix[i][j] = int(50 - distance_matrix[i][j])\n    return distance_matrix\n", "CodeBleu_score": 32.62736516739534}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the pairwise distances between UAVs in the original and changed formations using the Euclidean norm\n    dist_orig = numpy.sqrt(numpy.sum(numpy.square(numpy.subtract(orig_formation, orig_formation[:, numpy.newaxis])), axis=2))\n    dist_change = numpy.sqrt(numpy.sum(numpy.square(numpy.subtract(change_formation, change_formation[:, numpy.newaxis])), axis=2))\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    dist_orig = numpy.floor(dist_orig - 50)\n    dist_change = numpy.floor(dist_change - 50)\n    # Return the distance matrix\n    return [dist_orig, dist_change]\n\n", "CodeBleu_score": 16.657692087111624}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\n    orig_dist = numpy.linalg.norm(orig_formation[:, :2] - orig_formation[:, :2].T, axis=2)\n    change_dist = numpy.linalg.norm(change_formation[:, :2] - change_formation[:, :2].T, axis=2)\n\n    # Adjust the distances by subtracting them from 50 and converting to integers.\n    orig_dist = numpy.rint(50 - orig_dist).astype(int)\n    change_dist = numpy.rint(50 - change_dist).astype(int)\n\n    # Create a distance matrix from the distances calculated above.\n    graph = numpy.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            graph[i, j] = orig_dist[i, j] + change_dist[i, j]\n\n    return graph\n\n", "CodeBleu_score": 19.519026406434925}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    # Mark the left vertex as visited\n    self.left_visited[i] = True\n    # Iterate through adjacent right vertices\n    for j in self.left_adj[i]:\n        # If the right vertex is already visited, continue\n        if self.right_visited[j]:\n            continue\n        # Calculate the gap between labels and match weight\n        gap = self.left_label[i] - self.right_label[j]\n        # If the gap is zero, mark the right vertex as visited and check if it can either find a path or update the match\n        if gap == 0:\n            self.right_visited[j] = True\n            # Check if it can either find a path or update the match\n            if self.find_path(j):\n                # Update the match\n                self.match[i] = j\n                self.match[j] = i\n                return True\n        # If the gap is not zero, update the slack value for the right vertex\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    # If a path is not found, return False\n    return False\n\n", "CodeBleu_score": 38.60543601488039}, {"code": "def find_path(self, i)\n\t\n    #print(\"finding path\")\n    #print(i)\n    #print(self.match_weight)\n    #print(self.slack)\n    #print(self.visited)\n    #print(self.left_vertex)\n    #print(self.right_vertex)\n    #print(self.left_vertex[i])\n    #print(self.right_vertex[self.match_weight[i]])\n    #print(self.slack[self.match_weight[i]])\n    #print(self.visited[self.match_weight[i]])\n    #print(self.left_vertex[i] == self.right_vertex[self.match_weight[i]])\n    #print(self.slack[self.match_weight[i]] == 0)\n    #print(self.visited[self.match_weight[i]])\n    #print(self.left_vertex[i] == self.right_vertex[self.match_weight[i]])\n    #print(self.slack[self.match_weight[i]] == 0)\n    #print(self.visited[self.match_weight[i]])\n    #print(self.left_vertex[i] == self.right_vertex[self.match_weight[i]])\n    #print(self.slack[self.match_weight[i]] == 0)\n    #print(self.visited[self.match_weight[i]])\n    #print(self.left_vertex[i] == self.right_vertex[self.match_weight[i]])\n    #print(self.slack[self.match_weight[i]] == 0)\n    #print(self.visited[self.match_weight[i]])\n    #print(self.left_vertex[i] == self.right_vertex[self.match_weight[i]])\n    #print(self.slack[self.match_weight[i]] == 0)\n    #print(self.visited[self.match_weight[i]])\n    #print(self.left_vertex[i] == self.right_vertex", "CodeBleu_score": 0.6813226744186046}, {"code": "def find_path(self, i)\n\t\n    # Mark the left vertex as visited\n    self.left_visited[i] = True\n    # Iterate through adjacent right vertices\n    for j in self.right_adj[i]:\n        # If a right vertex is already visited, continue\n        if self.right_visited[j]:\n            continue\n        # Calculate the gap between labels and match weight\n        gap = self.left_label[i] - self.right_label[j]\n        # If the gap is zero, mark the right vertex as visited and check if it can either find a path or update the match\n        if gap == 0:\n            self.right_visited[j] = True\n            # If the right vertex is unmatched, it can find a path\n            if self.right_match[j] == -1:\n                return True\n            # Otherwise, it can update the match\n            else:\n                # Mark the right vertex as visited\n                self.right_visited[self.right_match[j]] = False\n                # Update the match\n                self.right_match[j] = i\n                self.left_match[i] = j\n                # Return True\n                return True\n        # Otherwise, update the slack value for the right vertex\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    # Return False\n    return False\n\n", "CodeBleu_score": 34.16551445188292}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    # Initialize slack variables\n    slack = numpy.zeros(len(self.right))\n    # Initialize array to track which right nodes have been visited\n    visited = numpy.zeros(len(self.right))\n    # Initialize array to track which left nodes have been visited\n    visited_left = numpy.zeros(len(self.left))\n    # Initialize array to track which left nodes have been matched\n    match_left = numpy.zeros(len(self.left))\n    # Initialize array to track which right nodes have been matched\n    match_right = numpy.zeros(len(self.right))\n    # Initialize array to track the current labeling of left nodes\n    label = numpy.zeros(len(self.left))\n    # Initialize array to track the current labeling of right nodes\n    label_right = numpy.zeros(len(self.right))\n    # Initialize array to track the current labeling of right nodes\n    label_right_prev = numpy.zeros(len(self.right))\n    # Initialize array to track the current labeling of right nodes\n    label_right_prev2 = numpy.zeros(len(self.right))\n    # Initialize array to track the current labeling of right nodes\n    label_right_prev3 = numpy.zeros(len(self.right))\n    # Initialize array to track the current labeling of right nodes\n    label_right_prev4 = numpy.zeros(len(self.right))\n    # Initialize array to track the current labeling of right nodes\n    label_right_prev5 = numpy.zeros(len(self.right))\n    # Initialize array to track the current labeling of right nodes\n    label_right_prev6 = numpy.zeros(len(self.right))\n    # Initialize array to track the current labeling of right nodes\n    label_right_prev7 = numpy.zeros(len(self.right))\n    # Initialize array to track the current labeling of right nodes\n    label_right_prev8 = numpy.zeros(len(self.right))\n    # Initialize array to track the current labeling of right nodes\n    label_right_prev9 = numpy.zeros(len(self.right))\n    # Initialize array to", "CodeBleu_score": 16.396478874682405}, {"code": "def KM(self)\n\t\n    n = len(self.uav_labels)\n    m = len(self.target_labels)\n    # Initialize slack variables\n    slack = numpy.zeros(n)\n    slack_label = numpy.zeros(n)\n    # Initialize visit arrays\n    uav_visit = numpy.zeros(n)\n    target_visit = numpy.zeros(m)\n    # Initialize match arrays\n    match_uav = numpy.zeros(n)\n    match_target = numpy.zeros(m)\n    # Initialize augmenting path arrays\n    path_uav = numpy.zeros(n)\n    path_target = numpy.zeros(m)\n    # Initialize label arrays\n    label = numpy.zeros(n)\n    label_star = numpy.zeros(n)\n    # Initialize modified arrays\n    delta = numpy.zeros(n)\n    delta_label = numpy.zeros(n)\n    # Initialize maximum value arrays\n    z0_row = numpy.zeros(n)\n    z0_col = numpy.zeros(m)\n    # Initialize minimum slack value arrays\n    minv = numpy.zeros(n)\n    minv_label = numpy.zeros(n)\n    # Initialize zero arrays\n    zero_row = numpy.zeros(n)\n    zero_col = numpy.zeros(m)\n    # Initialize one arrays\n    one_row = numpy.zeros(n)\n    one_col = numpy.zeros(m)\n    # Initialize infinity arrays\n    inf_row = numpy.zeros(n)\n    inf_col = numpy.zeros(m)\n    # Initialize done arrays\n    done_row = numpy.zeros(n)\n    done_col = numpy.zeros(m)\n    # Initialize unmatched arrays\n    unmatched_row = numpy.zeros(n)\n    unmatched_col = numpy.zeros(m)\n    # Initialize unmatched_row_count and unmatched_col_count\n    unmatched_row_count = 0\n    unmatched_col_count = 0\n    # Initialize match_count\n    match_count", "CodeBleu_score": 9.710579597770996}, {"code": "def KM(self)\n\t\n    n = self.n\n    m = self.m\n    match_r = numpy.zeros(m, dtype=int)\n    match_r[:] = -1\n    match_l = numpy.zeros(n, dtype=int)\n    match_l[:] = -1\n    for u in range(n):\n        slack = numpy.zeros(m, dtype=float)\n        slack[:] = numpy.inf\n        slack_visited = numpy.zeros(m, dtype=bool)\n        slack_visited[:] = False\n        slack_visited[self.label_l[u]] = True\n        slack[self.label_l[u]] = 0\n        while True:\n            slack_min = numpy.inf\n            for u in range(n):\n                if not slack_visited[self.label_l[u]]:\n                    slack_min = min(slack_min, slack[self.label_l[u]])\n            if slack_min == numpy.inf:\n                break\n            for u in range(n):\n                if not slack_visited[self.label_l[u]]:\n                    slack[self.label_l[u]] -= slack_min\n                    if slack[self.label_l[u]] == 0:\n                        slack_visited[self.label_l[u]] = True\n                        slack_min = 0\n            for u in range(n):\n                if slack_visited[self.label_l[u]]:\n                    for v in range(m):\n                        if not slack_visited[v]:\n                            slack[v] = min(slack[v], self.cost[u, v] - slack[self.label_l[u]])\n            for v in range(m):\n                if slack_visited[v]:\n                    slack_min = min(slack_min, slack[v])\n                    slack[v] -= slack_min\n            for v in range(m):\n                if slack_visited[v] and slack[v] ==", "CodeBleu_score": 23.384204599874835}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([40, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.440086488580548}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Define the HSV range for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Apply the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t    (\n        const std::string& id,\n        TagDescriptionContainer& descriptionContainer,\n        bool printWarning\n    )\n    {\n        auto it = standalone_tag_descriptions_.find(id);\n        if (it != standalone_tag_descriptions_.end())\n        {\n            descriptionContainer = it->second;\n            return true;\n        }\n        else if (printWarning)\n        {\n            ROS_WARN_STREAM(\"TagDetector: Could not find standalone tag description for ID \" << id << \".\");\n        }\n        return false;\n    }\n\n\n", "CodeBleu_score": 54.39342655795313}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n    // Check if the description is in the standalone_tag_descriptions_ map\n    auto it = standalone_tag_descriptions_.find(id);\n\n    // If the description is not found and printWarning is true, log a warning message\n    if (it == standalone_tag_descriptions_.end() && printWarning) {\n        ROS_WARN_STREAM(\"Tag ID \" << id << \" not found in standalone_tag_descriptions_ map.\");\n        return false;\n    }\n\n    // If found, set the descriptionContainer to the tag's description and return true; otherwise, return false\n    if (it != standalone_tag_descriptions_.end()) {\n        descriptionContainer = it->second;\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 39.33777980060824}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  (\n    const int &id,\n    TagDescriptionContainer &descriptionContainer,\n    const bool &printWarning\n  )\n  {\n    auto it = standalone_tag_descriptions_.find(id);\n\n    if (it != standalone_tag_descriptions_.end()) {\n      descriptionContainer = it->second;\n      return true;\n    }\n\n    if (printWarning) {\n      ROS_WARN_STREAM(\"Tag ID \" << id << \" not found in standalone_tag_descriptions_\");\n    }\n\n    return false;\n  }\n\n\n", "CodeBleu_score": 52.65545747105481}]}
