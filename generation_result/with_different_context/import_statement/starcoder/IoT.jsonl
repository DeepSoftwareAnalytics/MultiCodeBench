{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_iface_desc_t UDC_DESC_STORAGE *iface_desc;\n\tuint8_t i;\n\n\tiface_desc = (usb_iface_desc_t UDC_DESC_STORAGE *)desc;\n\tfor (i = 0; i < iface_desc->bNumEndpoints; i++) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)desc + iface_desc->bLength);\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 42.36356457377286}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t iface_desc_len;\n\tuint8_t iface_desc_num;\n\tuint8_t iface_desc_count;\n\tuint8_t iface_desc_num_alt;\n\tuint8_t iface_desc_count_alt;\n\tuint8_t iface_desc_num_end;\n\tuint8_t iface_desc_count_end;\n\tuint8_t iface_desc_num_end_alt;\n\tuint8_t iface_desc_count_end_alt;\n\tuint8_t iface_desc_num_end_end;\n\tuint8_t iface_desc_count_end_end;\n\tuint8_t iface_desc_num_end_end_alt;\n\tuint8_t iface_desc_count_end_end_alt;\n\tuint8_t iface_desc_num_end_end_end;\n\tuint8_t iface_desc_count_end_end_end;\n\tuint8_t iface_desc_num_end_end_end_alt;\n\tuint8_t iface_desc_count_end_end_end_alt;\n\tuint8_t iface_desc_num_end_end_end_end;\n\tuint8_t iface_desc_count_end_end_end_end;\n\tuint8_t iface_desc_num_end_end_end_end_alt;\n\tuint8_t iface_desc_count_end_end_end_end_alt;\n\tuint8_t iface_desc_num_end_end_end_end_end;\n\tuint8_t iface_desc_count_end_end_end_end_end;\n\tuint8_t iface_desc_num_end_end_end_end_end_alt;\n\tuint8_t iface_desc_count_end_end_end_end_end_alt;\n\tuint8_t iface_desc_num_end_end_end_end_end_end;\n\tuint8_t iface_desc_count_end_end_end_end_end_end;\n\tuint8_t iface_desc_num_end_end_end_end_end", "CodeBleu_score": 10.54158777421755}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *desc_ptr = (uint8_t *)desc;\n\tuint8_t desc_len = desc->bLength;\n\n\twhile (desc_len) {\n\t\tdesc_ptr += desc_len;\n\t\tdesc_len = desc_ptr[0];\n\t\tif (desc_ptr[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *)desc_ptr;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 32.60184912048342}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *ptr = udc_cfg_desc;\n\tuint8_t *end = ptr + udc_cfg_desc[4];\n\tuint8_t *iface_desc = NULL;\n\n\tif (ptr == NULL) {\n\t\treturn false;\n\t}\n\n\tif (ptr[0] != 9 || ptr[1] != 2) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= ptr[5] || setting_num >= ptr[6]) {\n\t\treturn false;\n\t}\n\n\tptr += 9;\n\n\twhile (ptr < end) {\n\t\tif (ptr[0] == 9 && ptr[1] == 4) {\n\t\t\tiface_desc = ptr;\n\t\t}\n\n\t\tptr += ptr[2];\n\t}\n\n\tif (iface_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tptr = iface_desc + 5;\n\tend = ptr + iface_desc[4];\n\n\twhile (ptr < end) {\n\t\tif (ptr[0] == 9 && ptr[1] == 5 && ptr[4] == setting_num) {\n\t\t\treturn true;\n\t\t}\n\n\t\tptr += ptr[2];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 33.876676568264465}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t i;\n\tuint8_t iface_desc_count;\n\tuint8_t iface_desc_index;\n\tuint8_t iface_desc_length;\n\tuint8_t iface_desc_type;\n\tuint8_t iface_desc_num;\n\tuint8_t iface_desc_alt_setting;\n\tuint8_t iface_desc_class;\n\tuint8_t iface_desc_subclass;\n\tuint8_t iface_desc_protocol;\n\tuint8_t iface_desc_index_end;\n\n\t/*\n\t * Check if there is a valid configuration.\n\t */\n\tif (g_usb_dev.config_desc_valid == false) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Check if the interface number is within bounds.\n\t */\n\tiface_desc_count = g_usb_dev.config_desc.bNumInterfaces;\n\tif (iface_num >= iface_desc_count) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Iterate through the interface descriptors, starting from the beginning of the configuration descriptor, and check each one to see if it matches the specified interface number and setting number.\n\t */\n\tiface_desc_index = g_usb_dev.config_desc.bLength;\n\tfor (i = 0; i < iface_desc_count; i++) {\n\t\t/*\n\t\t * Get the length of the current interface descriptor.\n\t\t */\n\t\tiface_desc_length = g_usb_dev.config_desc.interface[i].bLength;\n\n\t\t/*\n\t\t * Get the type of the current interface descriptor.\n\t\t */\n\t\tiface_desc_type = g_usb_dev.config_desc.interface[i].bDescriptorType;\n\n\t\t/*\n\t\t * Get the interface number of the current interface descriptor.\n\t\t */\n\t\tiface_desc_num = g_usb_dev.config_desc.interface[i].bInterfaceNumber;\n\n\t\t/*\n\t\t * Get the alternate setting number of the current interface descriptor.\n\t\t */\n\t\tiface_desc_alt_setting = g_usb_dev.config_desc.interface[i].bAlternateSetting;\n\n\t\t/*\n\t\t * Get the class of the current interface descriptor.\n\t\t */\n\t\tiface_desc_class = g_", "CodeBleu_score": 24.760914442721166}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t i;\n\tuint8_t num_iface_descs;\n\tuint8_t num_iface_settings;\n\tuint8_t iface_desc_type;\n\tuint8_t iface_desc_num;\n\tuint8_t iface_desc_setting;\n\tuint8_t *iface_desc_ptr;\n\n\t/* Verify that there is a valid configuration */\n\tif (g_usb_cfg_desc.bNumInterfaces == 0) {\n\t\treturn false;\n\t}\n\n\t/* Verify that the interface number is within bounds */\n\tif (iface_num >= g_usb_cfg_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t/* Get a pointer to the first interface descriptor */\n\tiface_desc_ptr = g_usb_cfg_desc_ptr + sizeof(USB_Config_Descriptor);\n\n\t/* Iterate through the interface descriptors */\n\tfor (i = 0; i < g_usb_cfg_desc.bNumInterfaces; i++) {\n\t\t/* Get the interface descriptor type and number */\n\t\tiface_desc_type = iface_desc_ptr[1];\n\t\tiface_desc_num = iface_desc_ptr[2];\n\t\tiface_desc_setting = iface_desc_ptr[3];\n\n\t\t/* Check if the interface descriptor matches the specified interface number and setting number */\n\t\tif ((iface_desc_type == USB_DT_INTERFACE) && (iface_desc_num == iface_num) && (iface_desc_setting == setting_num)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t/* Get a pointer to the next interface descriptor */\n\t\tiface_desc_ptr += iface_desc_ptr[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 39.40656659194587}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = udc_req_get_wIndex();\n\tuint8_t ep_status = 0;\n\tif (udc_endpoint_get_status(ep_num, &ep_status)) {\n\t\tudc_req_set_payload(ep_status);\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 15.788715890705316}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (g_ep_status_len == 1) {\n\t\tif (g_ep_status == 0) {\n\t\t\tg_ep_status = 1;\n\t\t\tg_ep_status_buf[0] = 0;\n\t\t}\n\t\telse {\n\t\t\tg_ep_status = 0;\n\t\t\tg_ep_status_buf[0] = 1;\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 15.31919546711123}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = udc_req_get_wValue() & 0x7F;\n\tuint8_t ep_status = 0;\n\tuint8_t ep_size = udc_req_get_wLength();\n\n\tif (ep_size != 1) {\n\t\treturn false;\n\t}\n\n\tif (ep_num == 0) {\n\t\tep_status = udc_ep_halted(0);\n\t} else if (ep_num == 1) {\n\t\tep_status = udc_ep_halted(1);\n\t} else if (ep_num == 2) {\n\t\tep_status = udc_ep_halted(2);\n\t} else if (ep_num == 3) {\n\t\tep_status = udc_ep_halted(3);\n\t} else if (ep_num == 4) {\n\t\tep_status = udc_ep_halted(4);\n\t} else if (ep_num == 5) {\n\t\tep_status = udc_ep_halted(5);\n\t} else if (ep_num == 6) {\n\t\tep_status = udc_ep_halted(6);\n\t} else if (ep_num == 7) {\n\t\tep_status = udc_ep_halted(7);\n\t} else {\n\t\treturn false;\n\t}\n\n\tudc_req_set_payload(&ep_status, 1);\n\treturn true;\n}", "CodeBleu_score": 15.397629551412017}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t alt_setting;\n\tuint8_t iface_num;\n\tuint8_t ep_num;\n\tuint8_t ep_type;\n\tuint8_t ep_dir;\n\tuint8_t ep_size;\n\tuint8_t iface_class;\n\tuint8_t iface_subclass;\n\tuint8_t iface_protocol;\n\tuint8_t iface_string;\n\tuint8_t iface_num_alt_settings;\n\tuint8_t iface_num_endpoints;\n\tuint8_t *iface_desc_ptr;\n\tuint8_t *ep_desc_ptr;\n\tuint8_t *ep_desc_ptr_alt;\n\tuint8_t *iface_desc_ptr_alt;\n\tuint8_t *iface_string_ptr;\n\tuint8_t *iface_string_ptr_alt;\n\tuint8_t *ep_string_ptr;\n\tuint8_t *ep_string_ptr_alt;\n\tbool ret;\n\tuint8_t iface_index;\n\tuint8_t ep_index;\n\tuint8_t ep_index_alt;\n\tuint8_t iface_num_alt_settings_alt;\n\tuint8_t iface_num_endpoints_alt;\n\tuint8_t iface_num_alt_settings_alt;\n\tuint8_t iface_num_endpoints_alt;\n\tuint8_t iface_num_alt_settings_alt;\n\tuint8_t iface_num_endpoints_alt;\n\tuint8_t iface_num_alt_settings_alt;\n\tuint8_t iface_num_endpoints_alt;\n\tuint8_t iface_num_alt_settings_alt;\n\tuint8_t iface_num_endpoints_alt;\n\tuint8_t iface_num_alt_settings_alt;\n\tuint8_t iface_num_endpoints_alt;\n\tuint8_t iface_num_alt_settings_alt;\n\tuint8_t iface_num_endpoints_alt;\n\tuint8_t iface_num_alt_settings_alt;\n\tuint8_t iface_num_endpoints_", "CodeBleu_score": 5.899113579524844}, {"code": "static bool udc_req_iface(void){\n\t\tbool ret = false;\n\tuint8_t if_num = udc_setup.wIndex;\n\tuint8_t alt_num = udc_setup.wValue;\n\tuint8_t ep_num = udc_setup.wLength;\n\tuint8_t if_desc_len = 0;\n\tuint8_t alt_desc_len = 0;\n\tuint8_t ep_desc_len = 0;\n\tuint8_t *if_desc_ptr = NULL;\n\tuint8_t *alt_desc_ptr = NULL;\n\tuint8_t *ep_desc_ptr = NULL;\n\tuint8_t *udi_ptr = NULL;\n\tuint8_t *udi_desc_ptr = NULL;\n\tuint8_t udi_num = 0;\n\tuint8_t udi_alt_num = 0;\n\tuint8_t udi_ep_num = 0;\n\tuint8_t udi_if_num = 0;\n\tuint8_t udi_if_desc_len = 0;\n\tuint8_t udi_alt_desc_len = 0;\n\tuint8_t udi_ep_desc_len = 0;\n\tuint8_t udi_ep_dir = 0;\n\tuint8_t udi_ep_type = 0;\n\tuint8_t udi_ep_attr = 0;\n\tuint8_t udi_ep_size = 0;\n\tuint8_t udi_ep_interval = 0;\n\tuint8_t udi_ep_comp = 0;\n\tuint8_t udi_ep_name_len = 0;\n\tuint8_t udi_ep_name_ptr = 0;\n\tuint8_t udi_ep_name[16];\n\tuint8_t udi_if_name_len = 0;\n\tuint8_t udi_if_name_ptr = 0;\n\tuint8_t udi_if_name[16];\n\tuint8_t udi_alt_name_len = 0;", "CodeBleu_score": 8.487404928174701}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface = udc_setup.index;\n\tuint8_t alt = udc_setup.value & 0xff;\n\n\t/* Check if the device is configured */\n\tif (!(udc_dev.state & UDC_CONFIGURED)) {\n\t\treturn false;\n\t}\n\n\t/* Check if the interface number is valid */\n\tif (iface >= udc_dev.num_interfaces) {\n\t\treturn false;\n\t}\n\n\t/* Get the interface descriptor */\n\tconst usb_iface_desc_t *iface_desc = udc_dev.iface_desc[iface];\n\n\t/* Check if the interface is valid */\n\tif (!iface_desc) {\n\t\treturn false;\n\t}\n\n\t/* Check if the alternate setting is valid */\n\tif (alt >= iface_desc->bNumEndpoints) {\n\t\treturn false;\n\t}\n\n\t/* Update the interface descriptor */\n\tudc_dev.iface_desc[iface] = &iface_desc[alt];\n\n\t/* Update the endpoint descriptors */\n\tfor (uint8_t i = 0; i < iface_desc->bNumEndpoints; i++) {\n\t\tudc_dev.ep_desc[iface][i] = &iface_desc[alt].ep_desc[i];\n\t}\n\n\t/* Forward the SETUP request to the UDI */\n\treturn udi_req_setup(&udc_dev, iface);\n}", "CodeBleu_score": 51.19003755327347}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\tbool ret = false;\n\tuint8_t lun;\n\n\t// Initialize the MSC interface\n\tif (msc_init() == false) {\n\t\treturn false;\n\t}\n\n\t// Check if the device is ready\n\tif (msc_test_unit_ready() == false) {\n\t\treturn false;\n\t}\n\n\t// Get the number of LUNs\n\tif (msc_get_max_lun() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check if the device has any LUN\n\tfor (lun = 0; lun < msc_get_max_lun(); lun++) {\n\t\t// Unload the medium on the LUN\n\t\tif (msc_test_unit_ready(lun) == false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Enable the MSC interface\n\tmsc_enable();\n\n\t// Wait for a CBW reception\n\tret = msc_wait_cbw();\n\n\treturn ret;\n}", "CodeBleu_score": 44.32803870157094}, {"code": "bool udi_msc_enable(void){\n\t\tuint8_t i;\n\tuint8_t lun;\n\tuint8_t lun_nb;\n\tuint8_t sense_key;\n\tuint8_t sense_asc;\n\tuint8_t sense_ascq;\n\tuint8_t inquiry_data[36];\n\tuint8_t inquiry_length;\n\tbool sense_valid;\n\tbool inquiry_valid;\n\tbool inquiry_done;\n\tbool inquiry_error;\n\tbool inquiry_not_supported;\n\tbool inquiry_invalid_lun;\n\tbool inquiry_lun_not_supported;\n\tbool inquiry_lun_busy;\n\tbool inquiry_lun_invalid;\n\tbool inquiry_invalid_page;\n\tbool inquiry_page_not_supported;\n\tbool inquiry_parameter_not_supported;\n\tbool inquiry_invalid_parameter;\n\tbool inquiry_invalid_field;\n\tbool inquiry_invalid_opcode;\n\tbool inquiry_invalid_request;\n\tbool inquiry_invalid_length;\n\tbool inquiry_invalid_allocation_length;\n\tbool inquiry_invalid_bdt;\n\tbool inquiry_invalid_transfer_length;\n\tbool inquiry_invalid_field_parameter;\n\tbool inquiry_invalid_field_parameter_page;\n\tbool inquiry_invalid_field_parameter_allocation_length;\n\tbool inquiry_invalid_field_parameter_transfer_length;\n\tbool inquiry_invalid_field_parameter_block_size;\n\tbool inquiry_invalid_field_parameter_page_code;\n\tbool inquiry_invalid_field_parameter_page_parameter;\n\tbool inquiry_invalid_field_parameter_page_parameter_subpage;\n\tbool inquiry_invalid_field_parameter_page_parameter_subpage_invalid;\n\tbool inquiry_invalid_field_parameter_page_parameter_subpage_invalid_parameter;\n\tbool inquiry_invalid_field_parameter_page_parameter_subpage_invalid_page;\n\tbool inquiry_invalid_field_parameter_page_parameter_subpage_invalid_parameter_page;\n\tbool inquiry_invalid_field_", "CodeBleu_score": 3.962531426322498}, {"code": "bool udi_msc_enable(void){\n\t\tuint8_t lun;\n\tuint8_t lun_nb;\n\tuint8_t i;\n\tuint8_t result;\n\n\t/* Initialize the LUN list */\n\tfor (i = 0; i < UDI_MSC_MAX_LUN; i++) {\n\t\tudi_msc_lun[i].state = UDI_MSC_LUN_STATE_DISABLED;\n\t\tudi_msc_lun[i].sense = 0;\n\t\tudi_msc_lun[i].sense_valid = false;\n\t\tudi_msc_lun[i].sense_key = 0;\n\t\tudi_msc_lun[i].sense_asc = 0;\n\t\tudi_msc_lun[i].sense_ascq = 0;\n\t}\n\n\t/* Retrieve the number of LUNs */\n\tlun_nb = msc_get_lun_nb();\n\tif (lun_nb == 0) {\n\t\treturn false;\n\t}\n\n\t/* Check if there are any LUNs available */\n\tfor (lun = 0; lun < lun_nb; lun++) {\n\t\t/* Unload the medium on the LUN */\n\t\tresult = msc_lun_unload(lun);\n\t\tif (result != 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t/* Check if the LUN is available */\n\t\tresult = msc_lun_is_available(lun);\n\t\tif (result != 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Enable the MSC interface */\n\tudi_msc_state = UDI_MSC_STATE_ENABLED;\n\n\treturn true;\n}", "CodeBleu_score": 43.19571011551181}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tuint8_t *ptr;\n\tuint16_t len;\n\tuint16_t i;\n\tuint8_t  sense_key;\n\tuint8_t  sense_asc;\n\tuint8_t  sense_ascq;\n\n\tif (status == UDD_EP_TRANSFER_OK) {\n\t\t/* Decrease the data residue in the CSW */\n\t\tudi_msc_cbw_t *cbw = (udi_msc_cbw_t *)udd_ep_get_trans_data_addr(ep);\n\t\tcbw->bCBWDataResidue -= nb_sent;\n\t\tif (cbw->bCBWDataResidue > 0) {\n\t\t\t/* Update the data pointer and the data length */\n\t\t\tptr = (uint8_t *)cbw + sizeof(udi_msc_cbw_t);\n\t\t\tlen = cbw->bCBWDataResidue;\n\t\t} else {\n\t\t\t/* Update the data pointer and the data length */\n\t\t\tptr = (uint8_t *)cbw + sizeof(udi_msc_cbw_t);\n\t\t\tlen = 0;\n\t\t}\n\t\t/* Process the updated CBW */\n\t\tudi_msc_process_cbw(ptr, len);\n\t} else if (status == UDD_EP_TRANSFER_ABORTED) {\n\t\t/* The transfer has been aborted */\n\t\tif (udi_msc_cbw_state == UDI_MSC_CBW_STATE_IDLE) {\n\t\t\t/* No CBW to process */\n\t\t\treturn;\n\t\t}\n\t\t/* Wait for a MSC setup reset */\n\t\tudi_msc_cbw_state = UDI_MSC_CBW_STATE_IDLE;\n\t\treturn;\n\t} else {\n\t\t/* Update the sense data */\n\t\tsense_key = UDI_MSC_SENSE_KEY_MEDIUM_ERROR;\n\t\tsense_asc = UDI_MSC_SENSE_ASC_NO_ADDITIONAL_SENSE_INFORMATION;\n\t\tsense_ascq = 0;\n\t\tudi_msc_update_sense_data(sense_key, sense_asc, sense_ascq);\n\t\t/* Send the CSW */\n\t\tudi_msc_send_csw(UDI", "CodeBleu_score": 45.96634451577284}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tuint8_t csw[13];\n\tuint8_t sense_key = UDD_EP_STATUS_GET_SENSE_KEY(status);\n\tuint8_t add_sense_code = UDD_EP_STATUS_GET_SENSE_CODE(status);\n\tuint8_t add_sense_qualifier = UDD_EP_STATUS_GET_SENSE_QUALIFIER(status);\n\tuint8_t valid_b_cnt = 0;\n\tuint8_t valid_d_cnt = 0;\n\tuint8_t data_residue = 0;\n\tuint8_t *ptr_csw;\n\tuint8_t *ptr_sense;\n\tuint8_t *ptr_sense_data;\n\tuint8_t *ptr_sense_data_ptr;\n\tuint8_t *ptr_sense_data_len;\n\tuint8_t *ptr_sense_key;\n\tuint8_t *ptr_add_sense_code;\n\tuint8_t *ptr_add_sense_qualifier;\n\tuint8_t *ptr_valid_b_cnt;\n\tuint8_t *ptr_valid_d_cnt;\n\tuint8_t *ptr_data_residue;\n\tuint8_t *ptr_data_residue_len;\n\n\tif (status == UDD_EP_TRANSFER_OK) {\n\t\t/* Update the number of bytes sent */\n\t\tudi_msc_cbw.dCBWDataTransferLength -= nb_sent;\n\n\t\t/* Check if the data transfer is complete */\n\t\tif (udi_msc_cbw.dCBWDataTransferLength == 0) {\n\t\t\t/* Update the CSW */\n\t\t\tudi_msc_cbw.bCSWStatus = CSW_STATUS_PASSED;\n\t\t\tudi_msc_cbw.dCSWDataResidue = 0;\n\n\t\t\t/* Send the CSW */\n\t\t\tudd_ep_write(ep, (uint8_t*)&udi_msc_cbw, 13);\n\n\t\t\t/* Process the CSW */\n\t\t\tudi_msc_process_csw();\n\t\t} else {\n\t\t\t/* Update the CSW */\n\t\t\tudi_msc_cbw", "CodeBleu_score": 47.12737689192365}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status == UDD_EP_TRANSFER_OK) {\n\t\t/* Update the CSW with the number of data sent */\n\t\tudi_msc_cbw_t *cbw = (udi_msc_cbw_t*)udd_ep_get_trans_data_addr(ep);\n\t\tcbw->dcs += nb_sent;\n\t\tif (cbw->dcs > cbw->dtl) {\n\t\t\tcbw->dcs = cbw->dtl;\n\t\t}\n\t\t/* Process the updated CSW */\n\t\tudi_msc_process_csw();\n\t} else if (status == UDD_EP_SETUP) {\n\t\t/*\n\t\t * The transfer has failed, the MSC layer has requested a reset of the CBW reception.\n\t\t * We just need to wait for the new CBW.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * The transfer has failed, the MSC layer has requested a reset of the CBW reception.\n\t\t * We just need to wait for the new CBW.\n\t\t */\n\t}\n}", "CodeBleu_score": 52.02932375180309}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tuint8_t residue;\n\tuint8_t i;\n\tuint8_t * ptr;\n\tuint8_t * ptr_csw;\n\tuint8_t * ptr_data_in;\n\tuint8_t * ptr_data_out;\n\tuint8_t * ptr_data;\n\tuint8_t * ptr_data_end;\n\tuint16_t data_length;\n\tuint8_t direction;\n\tuint8_t status;\n\tuint8_t * ptr_csw_be;\n\tuint16_t csw_be_length;\n\tuint16_t csw_be_signature;\n\tuint32_t csw_be_tag;\n\tuint32_t csw_be_data_residue;\n\n\t/* Get the direction of the CBW */\n\tdirection = udi_msc_cbw_direction();\n\n\t/* Get the data length of the CBW */\n\tdata_length = udi_msc_cbw_data_length();\n\n\t/* Get the data residue of the CBW */\n\tresidue = udi_msc_cbw_data_residue();\n\n\t/* Get the CBW tag */\n\tudi_msc_cbw_tag_get(&csw_be_tag);\n\n\t/* Get the CSW signature */\n\tudi_msc_csw_signature_get(&csw_be_signature);\n\n\t/* Get the CSW data residue */\n\tudi_msc_csw_data_residue_get(&csw_be_data_residue);\n\n\t/* Check the direction of the CBW */\n\tif (direction == UDI_MSC_CBW_DIRECTION_IN) {\n\t\t/* Get the data pointer of the CBW */\n\t\tptr_data_in = udi_msc_cbw_data_pointer();\n\n\t\t/* Get the data pointer of the CSW */\n\t\tptr_csw = udi_msc_csw_data_pointer();\n\n\t\t/* Get the data pointer of the CSW in big endian format */\n\t\tptr_csw_be = udi_msc_csw_data_pointer_be();\n\n\t\t/* Set the CSW signature */\n\t\tudi", "CodeBleu_score": 19.520568063631163}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint16_t wLength = udi_msc_cbw_get_wLength();\n\tuint8_t bStatus = UDI_MSC_CSW_STATUS_PASSED;\n\n\t/*\n\t * If there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n\t */\n\tif (wLength != 0) {\n\t\tif (udi_msc_cbw_get_direction() == UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\tudc_endpoint_halt(UDI_MSC_IN_EP);\n\t\t} else {\n\t\t\tudc_endpoint_halt(UDI_MSC_OUT_EP);\n\t\t}\n\t}\n\n\t/*\n\t * Prepare the Command Status Wrapper (CSW) by setting its tag and converting the data residue to little-endian format.\n\t */\n\tudi_msc_csw_set_tag(udi_msc_cbw_get_tag());\n\tudi_msc_csw_set_dataResidue(wLength);\n\n\t/*\n\t * Send the Command Status Wrapper (CSW).\n\t */\n\tudc_ack_in();\n\tudi_msc_send_csw();\n}", "CodeBleu_score": 30.513668856894547}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint16_t data_residue;\n\tuint8_t direction;\n\n\t/* Get the data residue */\n\tdata_residue = udi_msc_cbw_get_data_residue();\n\n\t/* Get the direction of the transfer */\n\tdirection = udi_msc_cbw_get_direction();\n\n\t/* Stall the next request on the data endpoint if there is a non-zero data residue */\n\tif (data_residue) {\n\t\tif (direction) {\n\t\t\tudd_ep_stall(UDI_MSC_EP_DATA_OUT);\n\t\t} else {\n\t\t\tudd_ep_stall(UDI_MSC_EP_DATA_IN);\n\t\t}\n\t}\n\n\t/* Prepare the CSW */\n\tudi_msc_csw_prepare(data_residue);\n\n\t/* Send the CSW */\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 31.137241036516905}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_CDC_PORT_COUNT) {\n\t\treturn;\n\t}\n\tif (b_enable) {\n\t\tusb_cdc_ports[port].b_dtr = true;\n\t\tif (usb_cdc_ports[port].dtr_rate == 1200) {\n\t\t\tif (!usb_cdc_ports[port].b_dtr_enabled) {\n\t\t\t\tusb_cdc_ports[port].b_dtr_enabled = true;\n\t\t\t\tinitiateReset();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tusb_cdc_ports[port].b_dtr = false;\n\t\tif (usb_cdc_ports[port].dtr_rate == 1200) {\n\t\t\tif (usb_cdc_ports[port].b_dtr_enabled) {\n\t\t\t\tusb_cdc_ports[port].b_dtr_enabled = false;\n\t\t\t\tcancelReset();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.567557697154115}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_CDC_PORT_COUNT) {\n\t\treturn;\n\t}\n\n\tif (b_enable) {\n\t\t// Enable DTR\n\t\tusb_cdc_ports[port].b_dtr = true;\n\n\t\t// Check if DTR rate is 1200\n\t\tif (usb_cdc_ports[port].dtr_rate == 1200) {\n\t\t\t// Cancel any scheduled reset\n\t\t\tcancelReset(port);\n\t\t}\n\t} else {\n\t\t// Disable DTR\n\t\tusb_cdc_ports[port].b_dtr = false;\n\n\t\t// Check if DTR rate is 1200\n\t\tif (usb_cdc_ports[port].dtr_rate == 1200) {\n\t\t\t// Schedule a delayed system reset\n\t\t\tusb_cdc_ports[port].reset_timer = reset_timer_start(RESET_DELAY_MS);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.34358403098328}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_CDC_PORT_COUNT) return;\n\tif (port == 0) {\n\t\tif (b_enable) {\n\t\t\tusb_cdc_line_coding_t *line_coding = &usb_cdc_line_coding[0];\n\t\t\tif (line_coding->dwDTERate == 1200) {\n\t\t\t\tif (!usb_cdc_dtr[0]) {\n\t\t\t\t\tusb_cdc_dtr[0] = true;\n\t\t\t\t\tcancelReset();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (usb_cdc_dtr[0]) {\n\t\t\t\t\tusb_cdc_dtr[0] = false;\n\t\t\t\t\tif (line_coding->dwDTERate != 0) {\n\t\t\t\t\t\tusb_cdc_line_coding[0].dwDTERate = 1200;\n\t\t\t\t\t\tusb_cdc_line_coding[0].bCharFormat = 0;\n\t\t\t\t\t\tusb_cdc_line_coding[0].bParityType = 0;\n\t\t\t\t\t\tusb_cdc_line_coding[0].bDataBits = 8;\n\t\t\t\t\t\tusb_cdc_line_coding[0].bStopBits = 0;\n\t\t\t\t\t\tusb_cdc_line_coding[0].wChecksum = 0;\n\t\t\t\t\t\tusb_cdc_line_coding[0].wResidual = 0;\n\t\t\t\t\t\tusb_cdc_line_coding_changed[0] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (usb_cdc_dtr[0]) {\n\t\t\t\tusb_cdc_dtr[0] = false;\n\t\t\t\tif (usb_cdc_line_coding[0].dwDTERate != 0) {\n\t\t\t\t\tusb_cdc_line_coding[0].dwDTERate = 1200;\n\t\t\t\t\tusb_cdc_line_coding[0].bCharFormat = 0;\n\t\t\t\t\tusb_cdc_line_coding[0].bParityType = 0;\n\t\t\t\t\tusb_cdc_line_coding[0].bDataBits = 8;\n\t\t\t\t\tusb_cdc_line_coding[0].bStopBits = 0;\n\t\t\t\t\tusb_cdc_line_coding[0].wChecksum = 0;\n\t\t\t\t\tusb_cdc_line_", "CodeBleu_score": 33.74051602204587}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tif (USB_SetupPacket.wValue == 0x04 && USB_SetupPacket.wIndex == 0x00) {\n\t\t// Microsoft-compatible ID descriptor\n\t\tUSB_ControlRequest.wLength = 0x14;\n\t\tmemcpy(USB_ControlRequest.Payload, &msft_compatible_id_descriptor, 0x14);\n\t\treturn true;\n\t} else if (USB_SetupPacket.wValue == 0x05 && USB_SetupPacket.wIndex == 0x00) {\n\t\t// Extended properties descriptor\n\t\tUSB_ControlRequest.wLength = 0x0E;\n\t\tmemcpy(USB_ControlRequest.Payload, &extended_properties_descriptor, 0x0E);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 12.06751577016017}, {"code": "bool usb_task_other_requests(void){\n\t\tuint8_t request_type;\n\tuint8_t request_index;\n\tuint8_t request_value;\n\tuint8_t request_length;\n\tuint8_t *request_data;\n\tuint8_t *request_data_ptr;\n\tuint8_t *request_data_end;\n\tuint8_t *descriptor_ptr;\n\tuint8_t *descriptor_end;\n\tuint8_t *string_ptr;\n\tuint8_t *string_end;\n\tuint8_t *string_index_ptr;\n\tuint8_t *string_index_end;\n\tuint8_t *string_language_ptr;\n\tuint8_t *string_language_end;\n\tuint8_t *string_language_index_ptr;\n\tuint8_t *string_language_index_end;\n\tuint8_t *string_language_index_length_ptr;\n\tuint8_t *string_language_index_length_end;\n\tuint8_t *string_language_index_length_value_ptr;\n\tuint8_t *string_language_index_length_value_end;\n\tuint8_t *string_language_index_length_value_ptr2;\n\tuint8_t *string_language_index_length_value_end2;\n\tuint8_t *string_language_index_length_value_ptr3;\n\tuint8_t *string_language_index_length_value_end3;\n\tuint8_t *string_language_index_length_value_ptr4;\n\tuint8_t *string_language_index_length_value_end4;\n\tuint8_t *string_language_index_length_value_ptr5;\n\tuint8_t *string_language_index_length_value_end5;\n\tuint8_t *string_language_index_length_value_ptr6;\n\tuint8_t *string_language_index_length_value_end6;\n\tuint8_t *string_language_index_length_value_ptr7;\n\tuint8_t *string_language_index_length_value_end", "CodeBleu_score": 4.200042607939729}, {"code": "bool usb_task_other_requests(void){\n\t\tif (usb_control_request.bmRequestType.Type == USB_SETUP_TYPE_VENDOR) {\n\t\tswitch (usb_control_request.bRequest) {\n\t\t\tcase USB_SETUP_VALUE_MS_EXT_PROPERTIES:\n\t\t\t\t// Microsoft-compatible extended properties descriptor\n\t\t\t\tusb_control_request.wLength = sizeof(usb_ms_ext_properties_descriptor);\n\t\t\t\tusb_control_request.payload = (uint8_t *) &usb_ms_ext_properties_descriptor;\n\t\t\t\treturn true;\n\n\t\t\tcase USB_SETUP_VALUE_MS_EXT_PROPERTY_STRING_INDEX:\n\t\t\t\t// Microsoft-compatible extended properties descriptor string index\n\t\t\t\tusb_control_request.wLength = 2;\n\t\t\t\tusb_control_request.payload = (uint8_t *) &usb_ms_ext_property_string_index;\n\t\t\t\treturn true;\n\n\t\t\tcase USB_SETUP_VALUE_MS_EXT_PROPERTY_STRING_COUNT:\n\t\t\t\t// Microsoft-compatible extended properties descriptor string count\n\t\t\t\tusb_control_request.wLength = 2;\n\t\t\t\tusb_control_request.payload = (uint8_t *) &usb_ms_ext_property_string_count;\n\t\t\t\treturn true;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 29.845430174592558}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\tuint8_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiRec();\n\t\tbuf[i] = spiRec();\n\t}\n\tspiRec();\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 44.58027567936803}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\n\tuint8_t i;\n\tuint8_t dummy = 0;\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiRec(buf + i);\n\t}\n\n\tspiRec(buf + nbyte - 1);\n\tspiRec(&dummy);\n}", "CodeBleu_score": 41.73024764085906}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\tuint8_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(0);\n\t\tbuf[i] = spiRec();\n\t}\n\tspiSend(0);\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 46.81080811951958}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *relocated_isr_table;\n\tuint32_t old_interrupt_state;\n\n\t// Get the address of the relocated interrupt vector table\n\trelocated_isr_table = (uint32_t *) *(&__isr_vector - 2);\n\n\t// Disable global interrupts\n\told_interrupt_state = __get_interrupt_state();\n\t__disable_interrupt();\n\n\t// Get the old handler\n\toldHandler = (pfnISR_Handler) relocated_isr_table[irq];\n\n\t// Install the new handler\n\trelocated_isr_table[irq] = (uint32_t) newHandler;\n\n\t// Re-enable global interrupts\n\t__set_interrupt_state(old_interrupt_state);\n\n\t// Return the old handler\n\treturn oldHandler;\n}", "CodeBleu_score": 46.13415540214799}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *vectorTable;\n\n\t// Retrieve the address of the vector table\n\tvectorTable = (uint32_t *)SCB->VTOR;\n\n\t// Disable global interrupts\n\t__disable_irq();\n\n\t// Save the original handler\n\toldHandler = (pfnISR_Handler)vectorTable[irq];\n\n\t// Replace the handler with the new handler\n\tvectorTable[irq] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original handler\n\treturn oldHandler;\n}", "CodeBleu_score": 49.203284873429986}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tuint32_t *oldHandler;\n\tuint32_t *newVectorTable;\n\tuint32_t oldVector;\n\tuint32_t newVector;\n\n\t// Get the address of the relocated interrupt vector table\n\tnewVectorTable = (uint32_t *)SCB->VTOR;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Get the current handler for the specified IRQ\n\toldVector = newVectorTable[irq];\n\n\t// Replace the current handler with the new handler\n\tnewVectorTable[irq] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original handler\n\treturn (pfnISR_Handler)oldVector;\n}", "CodeBleu_score": 43.297255868380084}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\tif (MarlinSerial::peek() >= 0) return MarlinSerial::peek();\n\treturn -1;\n}", "CodeBleu_score": 21.77485834019903}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (ENABLED(EMERGENCY_PARSER)) {\n\t\tif (parser.available()) return parser.peek();\n\t}\n\treturn usb_serial_peek(USB_SERIAL_MARLIN);\n}", "CodeBleu_score": 17.51233130795693}, {"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(USE_USB_SERIAL)\n  if (serial_ && serial_->peek()) {\n    return serial_->peek();\n  }\n#endif\n  return -1;\n}", "CodeBleu_score": 23.019932671064275}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\t// If there is a pending character, return it\n\tif (m_rx_buffer_head != m_rx_buffer_tail) {\n\t\tuint8_t c = m_rx_buffer[m_rx_buffer_tail];\n\t\tm_rx_buffer_tail = (m_rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n\t\treturn c;\n\t}\n\n\t// If the USB CDC is not enabled, return -1\n\tif (!m_usb_cdc_enabled) return -1;\n\n\t// If the USB CDC is not configured, return -1\n\tif (!m_usb_cdc_configured) return -1;\n\n\t// If there are no bytes available to read from the PC, return -1\n\tif (!m_usb_cdc_serial.available()) return -1;\n\n\t// Read a byte from the PC\n\tuint8_t c = m_usb_cdc_serial.read();\n\n\t// Update the emergency parser if enabled\n\tif (m_emergency_parser_enabled) {\n\t\tif (m_emergency_parser_state == 0) {\n\t\t\tif (c == 0x1B) m_emergency_parser_state = 1;\n\t\t}\n\t\telse if (m_emergency_parser_state == 1) {\n\t\t\tif (c == 0x5B) m_emergency_parser_state = 2;\n\t\t\telse m_emergency_parser_state = 0;\n\t\t}\n\t\telse if (m_emergency_parser_state == 2) {\n\t\t\tif (c == 0x41) m_emergency_parser_state = 3;\n\t\t\telse m_emergency_parser_state = 0;\n\t\t}\n\t\telse if (m_emergency_parser_state == 3) {\n\t\t\tif (c == 0x31) m_emergency_parser_state = 4;\n\t\t\telse m_emergency_parser_state = 0;\n\t\t}\n\t\telse if (m_emergency_parser_state == 4) {\n\t\t\tif (c == 0x3B) m_emergency_parser_state = 5;\n\t\t\telse m_em", "CodeBleu_score": 35.85027958646955}, {"code": "int MarlinSerialUSB::read(){\n\t\t// If there is a pending character, return it\n\tif (Serial.available()) return Serial.read();\n\n\t// If the CDC is not enabled, return -1\n\tif (!cdc_enabled) return -1;\n\n\t// If there are no bytes available, return -1\n\tif (!SerialUSB.available()) return -1;\n\n\t// Read a byte\n\tint c = SerialUSB.read();\n\n\t// If the emergency parser is enabled, update it\n\tif (emergency_parser) emergency_parser->update(c);\n\n\t// Return the read character\n\treturn c;\n}", "CodeBleu_score": 40.04851487960245}, {"code": "int MarlinSerialUSB::read(){\n\t\t// Return if the USB serial is not enabled\n\tif (!enabled) return -1;\n\n\t// Return if there is a pending character\n\tif (pending_char) {\n\t\tpending_char = false;\n\t\treturn read_char;\n\t}\n\n\t// Return if the USB serial is not configured\n\tif (!usb_cdc_configured) return -1;\n\n\t// Return if there are no bytes available to read\n\tif (usb_cdc_rx_size == 0) return -1;\n\n\t// Read the byte from the USB serial\n\tread_char = usb_cdc_rx_buffer[usb_cdc_rx_index];\n\tusb_cdc_rx_index++;\n\tusb_cdc_rx_size--;\n\n\t// Update the emergency parser if enabled\n\tif (parser.enabled) parser.update(read_char);\n\n\t// Return the read character\n\treturn read_char;\n}", "CodeBleu_score": 39.53581811713671}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t#if ENABLED(USE_USB_SERIAL)\n  if (usb_cdc_enabled) return usb_serial.available();\n  return 0;\n#else\n  return 0;\n#endif\n}", "CodeBleu_score": 32.342324973635925}, {"code": "int MarlinSerialUSB::available(){\n\t#if ENABLED(SERIAL_STATS_DROPPED_BYTES)\n  static uint32_t last_dropped_bytes = 0;\n  static uint32_t last_dropped_millis = 0;\n#endif\n\n  // If there are characters in the buffer, return the count\n  if (count_ > 0) return count_;\n\n  // If the USB port is enabled and ready to receive data, return the count\n  if (ENABLED(USB_CDC_ENABLED) && usb_cdc_enabled && usb_cdc_connected) {\n    count_ = usb_cdc_rx_available();\n    return count_;\n  }\n\n#if ENABLED(SERIAL_STATS_DROPPED_BYTES)\n  // If the USB port is enabled but not ready to receive data, check the time\n  if (ENABLED(USB_CDC_ENABLED) && usb_cdc_enabled && !usb_cdc_connected) {\n    const uint32_t now = millis();\n    if (now > last_dropped_millis + 1000) {\n      const uint32_t dropped = usb_cdc_rx_dropped();\n      if (dropped > last_dropped_bytes) {\n        SERIAL_ECHO_START();\n        SERIAL_ECHOLNPGM(\"Dropped \", dropped - last_dropped_bytes, \" bytes\");\n      }\n      last_dropped_bytes = dropped;\n      last_dropped_millis = now;\n    }\n  }\n#endif\n\n  // No data available\n  return 0;\n}", "CodeBleu_score": 45.188368620289964}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (count_available) {\n\t\tcount_available = 0;\n\t\treturn count;\n\t}\n\tif (cdc_enabled && usb_cdc.ready())\n\t\treturn usb_cdc.available();\n\treturn 0;\n}", "CodeBleu_score": 33.460998489390136}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (writing) {\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, value, size);\n\t\t}\n\t\tif (pos + size > _size) {\n\t\t\treturn false;\n\t\t}\n\t\tmemcpy(_data + pos, value, size);\n\t\tpos += size;\n\t} else {\n\t\tif (pos + size > _size) {\n\t\t\treturn false;\n\t\t}\n\t\tmemcpy(value, _data + pos, size);\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, value, size);\n\t\t}\n\t\tpos += size;\n\t}\n\treturn true;\n}", "CodeBleu_score": 39.703177891461024}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (pos < 0 || pos >= _size) return false;\n\tif (value == NULL) return false;\n\tif (size == 0) return false;\n\tif (crc == NULL) return false;\n\n\tuint8_t byte;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (writing) {\n\t\t\tif (read_byte(pos, &byte)) {\n\t\t\t\tif (value != NULL) value[i] = byte;\n\t\t\t\tif (crc != NULL) crc[0] = crc16_update(crc[0], byte);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (value != NULL) value[i] = 0;\n\t\t}\n\t\tpos++;\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.04003005032391}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (pos < 0 || pos >= this->size) {\n\t\treturn false;\n\t}\n\tif (pos + size > this->size) {\n\t\tsize = this->size - pos;\n\t}\n\tif (value) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tvalue[i] = this->read_byte(pos + i);\n\t\t}\n\t}\n\tif (crc) {\n\t\t*crc = this->update_crc(*crc, value, size, writing);\n\t}\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 43.22606786041369}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin < 0) return;\n\tif (value > 0) {\n\t\tif (freq > 0) {\n\t\t\tif (ledcWrite(pin, value, freq, res)) return;\n\t\t}\n\t\tif (pin < NUM_DIGITAL_PINS) {\n\t\t\tif (digitalPinToTimer(pin) == NOT_ON_TIMER) {\n\t\t\t\tif (pin < NUM_PWM_PINS) {\n\t\t\t\t\tif (pwm_state[pin].used == 0) {\n\t\t\t\t\t\tif (pin < NUM_PWM_CHANNELS) {\n\t\t\t\t\t\t\tpwm_state[pin].timer = timerBegin(pin, PWM_RESOLUTION, true);\n\t\t\t\t\t\t\tif (pwm_state[pin].timer != NULL) {\n\t\t\t\t\t\t\t\tpwm_state[pin].used = 1;\n\t\t\t\t\t\t\t\ttimerAttachInterrupt(pwm_state[pin].timer, &pwm_timer_isr, true);\n\t\t\t\t\t\t\t\ttimerAlarmWrite(pwm_state[pin].timer, PWM_MAX_VALUE, PWM_RESOLUTION);\n\t\t\t\t\t\t\t\ttimerAlarmEnable(pwm_state[pin].timer);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pwm_state[pin].used > 0) {\n\t\t\t\t\t\tpwm_state[pin].value = value;\n\t\t\t\t\t\tpwm_state[pin].freq = freq;\n\t\t\t\t\t\tpwm_state[pin].res = res;\n\t\t\t\t\t\tanalogWrite(pin, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tledcWrite(pin, value, freq, res);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tanalogWrite(pin, 0);\n\t}\n}", "CodeBleu_score": 35.60269849117596}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (value == 0) {\n\t\tdigitalWrite(pin, LOW);\n\t\treturn;\n\t}\n\tif (value == 255) {\n\t\tdigitalWrite(pin, HIGH);\n\t\treturn;\n\t}\n\tif (freq > 0) {\n\t\tledcWrite(pin, value, freq, res);\n\t\treturn;\n\t}\n\tif (pin < 0 || pin >= NUM_DIGITAL_PINS) {\n\t\treturn;\n\t}\n\tif (digitalPinToTimer(pin) != NOT_ON_TIMER) {\n\t\tledcWrite(pin, value, PWM_FREQUENCY, res);\n\t\treturn;\n\t}\n\tuint8_t pinIndex = digitalPinToPinIndex(pin);\n\tif (pinIndex >= NUM_PWM_PINS) {\n\t\treturn;\n\t}\n\tif (digitalPinToTimer(pin) == NOT_ON_TIMER) {\n\t\tpinIndex = pwmPinToTimerIndex(pin);\n\t\tif (pinIndex >= NUM_PWM_TIMERS) {\n\t\t\treturn;\n\t\t}\n\t\tif (pwmState[pinIndex].timer == NULL) {\n\t\t\tpwmState[pinIndex].timer = timerBegin(pinIndex, PWM_RESOLUTION, true);\n\t\t\ttimerAttachInterrupt(pwmState[pinIndex].timer, &pwmState[pinIndex], &pwmTimerCallback);\n\t\t\ttimerAlarmWrite(pwmState[pinIndex].timer, PWM_MAX_DUTY_CYCLE, PWM_RESOLUTION);\n\t\t\ttimerAlarmEnable(pwmState[pinIndex].timer);\n\t\t}\n\t\tpwmState[pinIndex].pin = pin;\n\t\tpwmState[pinIndex].dutyCycle = value;\n\t\tpwmState[pinIndex].frequency = PWM_FREQUENCY;\n\t\tpwmState[pinIndex].resolution = res;\n\t\tpwmState[pinIndex].enabled = true;\n\t}\n\telse {\n\t\tpwmState[pinIndex].dutyCycle = value;\n\t}\n\tuint32_t dutyCycle = pwmState[pinIndex].dutyCycle;\n\tuint32_t dutyCyclePercent = dutyCycle * 100 / PWM_MAX_DUTY_CYCLE;\n\tuint32_t period = (PWM_FREQUENCY * res)", "CodeBleu_score": 36.556282380683015}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin >= NUM_DIGITAL_PINS) return;\n\tif (value == 0) {\n\t\tdigitalWrite(pin, LOW);\n\t\treturn;\n\t}\n\tif (value == 255) {\n\t\tdigitalWrite(pin, HIGH);\n\t\treturn;\n\t}\n\tif (value > 255) {\n\t\tanalogWrite(pin, 255);\n\t\treturn;\n\t}\n\tif (freq > 0) {\n\t\tif (ledcWrite(pin, value, freq, res) == 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pin < NUM_ANALOG_PINS) {\n\t\tuint32_t val = value * 1024 / 255;\n\t\tif (val > 4095) val = 4095;\n\t\tanalogWriteState(pin, val);\n\t}\n}", "CodeBleu_score": 30.7172216199114}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH >= SERVO_CHANNEL_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must be greater than or equal to SERVO_CHANNEL_COUNT\");\n\tif (attach()) {\n\t\twrite(value);\n\t\tdelay(SERVO_DELAY_ARRAY[channel]);\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tdetach();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.63558199441602}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH > 0, \"SERVO_DELAY_ARRAY_LENGTH must be greater than 0\");\n\tif (attach()) {\n\t\twrite(value);\n\t\tdelay(SERVO_DELAY_ARRAY[channel]);\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tdetach();\n\t\t}\n\t}\n}", "CodeBleu_score": 35.293373675078044}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_LENGTH == SERVO_COUNT, \"SERVO_DELAY_LENGTH must equal SERVO_COUNT\");\n\tif (servo_attached) {\n\t\tservo_position = value;\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tdetach();\n\t\t}\n\t\twrite(value);\n\t\tdelay(SERVO_DELAY[channel]);\n\t}\n}", "CodeBleu_score": 36.518227162811435}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tuint32_t i;\n\tuint32_t pin;\n\tuint32_t port;\n\tuint32_t pin_mask;\n\tuint32_t port_mask;\n\tuint32_t duty_cycle;\n\tuint32_t tick_count;\n\tuint32_t pin_state;\n\tuint32_t pin_state_next;\n\tuint32_t port_data;\n\tuint32_t port_data_next;\n\n\t// Update the PWM states for each pin\n\tfor (i = 0; i < I2S_PIN_COUNT; i++) {\n\t\tpin = i2s_pin_list[i];\n\t\tport = pin / 32;\n\t\tpin_mask = 1 << (pin % 32);\n\t\tport_mask = 0xFFFFFFFF << (pin % 32);\n\t\tduty_cycle = i2s_pin_duty_cycle[i];\n\t\ttick_count = i2s_pin_tick_count[i];\n\t\tpin_state = i2s_pin_state[i];\n\t\tpin_state_next = pin_state;\n\t\tport_data = i2s_pin_port_data[port];\n\t\tport_data_next = port_data;\n\n\t\t// If the pin has active PWM, update its state\n\t\tif (duty_cycle > 0) {\n\t\t\t// If the tick count reaches zero, toggle the pin state\n\t\t\tif (tick_count == 0) {\n\t\t\t\tpin_state_next = pin_state ^ pin_mask;\n\t\t\t}\n\n\t\t\t// Update the tick count\n\t\t\ttick_count--;\n\t\t\tif (tick_count < 0) {\n\t\t\t\ttick_count = 0;\n\t\t\t}\n\n\t\t\t// Update the port data\n\t\t\tport_data_next = (port_data & port_mask) | (pin_state_next << (pin % 32));\n\t\t}\n\n\t\t// Store the updated pin state and port data\n\t\ti2s_pin_state[i] = pin_state_next;\n\t\ti2s_pin_port_data[port] = port_data_next;\n\t}\n\n\t// Store the updated port", "CodeBleu_score": 32.180917997011896}, {"code": "void i2s_push_sample(){\n\t\tuint32_t i;\n\tuint32_t j;\n\tuint32_t mask;\n\tuint32_t port_state;\n\tuint32_t port_state_next;\n\tuint32_t port_state_mask;\n\tuint32_t port_state_mask_next;\n\tuint32_t port_state_mask_next_high;\n\tuint32_t port_state_mask_next_low;\n\tuint32_t port_state_mask_next_high_mask;\n\tuint32_t port_state_mask_next_low_mask;\n\tuint32_t port_state_mask_next_high_mask_mask;\n\tuint32_t port_state_mask_next_low_mask_mask;\n\tuint32_t port_state_mask_next_high_mask_mask_mask;\n\tuint32_t port_state_mask_next_low_mask_mask_mask;\n\tuint32_t port_state_mask_next_high_mask_mask_mask_mask;\n\tuint32_t port_state_mask_next_low_mask_mask_mask_mask;\n\tuint32_t port_state_mask_next_high_mask_mask_mask_mask_mask;\n\tuint32_t port_state_mask_next_low_mask_mask_mask_mask_mask;\n\tuint32_t port_state_mask_next_high_mask_mask_mask_mask_mask_mask;\n\tuint32_t port_state_mask_next_low_mask_mask_mask_mask_mask_mask;\n\tuint32_t port_state_mask_next_high_mask_mask_mask_mask_mask_mask_mask;\n\tuint32_t port_state_mask_next_low_mask_mask_mask_mask_mask_mask_mask;\n\tuint32_t port_state_mask_next_high_mask_mask_mask_mask_mask_mask_mask_mask;\n\tuint32_t port_state_mask_next_low_", "CodeBleu_score": 1.7653719045535314}, {"code": "void i2s_push_sample(){\n\t\tfor (int i = 0; i < NUM_PWM_PINS; i++) {\n\t\tif (pwm_pins[i].duty_cycle > 0) {\n\t\t\tif (pwm_pins[i].tick_count == 0) {\n\t\t\t\tpwm_pins[i].tick_count = pwm_pins[i].duty_cycle;\n\t\t\t\tif (pwm_pins[i].state == 0) {\n\t\t\t\t\tpwm_pins[i].state = 1;\n\t\t\t\t\tport_set_output_level(pwm_pins[i].pin, 1);\n\t\t\t\t} else {\n\t\t\t\t\tpwm_pins[i].state = 0;\n\t\t\t\t\tport_set_output_level(pwm_pins[i].pin, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpwm_pins[i].tick_count--;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Write data to DMA buffer\n\tint dma_pos = (int) (i2s_out_pos / 4);\n\tint dma_pos_byte = i2s_out_pos % 4;\n\tuint32_t *dma_buf = (uint32_t *) (i2s_out_buffer);\n\tuint32_t val = 0;\n\tfor (int i = 0; i < NUM_PWM_PINS; i++) {\n\t\tval |= (pwm_pins[i].state << i);\n\t}\n\tdma_buf[dma_pos] = (val << (2 * dma_pos_byte)) | (val >> (2 * (3 - dma_pos_byte)));\n\n\t// Increment buffer position\n\ti2s_out_pos += 4;\n\tif (i2s_out_pos >= i2s_out_len) {\n\t\ti2s_out_pos = 0;\n\t}\n}", "CodeBleu_score": 34.61871541705867}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tif (timer_num >= HAL_TIMER_NUM) {\n\t\treturn HAL_TIMER_INVALID_TIMER;\n\t}\n\n\treturn hal_timer_get_count_internal(timer_num);\n}", "CodeBleu_score": 20.25180566146716}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn HAL_TIMER_COUNT;\n}", "CodeBleu_score": 8.064186689141248}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tuint32_t timer_count = 0;\n\n\t/* Check the parameter */\n\tif (timer_num > HAL_TIMER_MAX_NUM) {\n\t\treturn HAL_TIMER_INVALID_TIMER_NUM;\n\t}\n\n\t/* Get the timer count */\n\ttimer_count = TIM_GetCounter(timer_num);\n\n\t/* Return the timer count */\n\treturn timer_count;\n}", "CodeBleu_score": 32.770900353508345}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tif (pos < 0) {\n\t\treturn false;\n\t}\n\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tif (crc == NULL) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos);\n\t\t*crc = crc16_update(*crc, value[i]);\n\t\tif (writing) {\n\t\t\tEEPROM.write(pos, value[i]);\n\t\t}\n\t\tpos++;\n\t}\n\treturn true;\n}", "CodeBleu_score": 56.09975572105081}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tuint8_t read_value;\n\tuint16_t read_crc = 0;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tread_value = EEPROM.read(pos);\n\t\tif (writing) {\n\t\t\tvalue[i] = read_value;\n\t\t}\n\t\tread_crc = _crc16_update(read_crc, read_value);\n\t\tpos++;\n\t}\n\tif (crc != NULL) {\n\t\t*crc = read_crc;\n\t}\n\treturn false;\n}", "CodeBleu_score": 53.40528695069775}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tif (pos < 0 || pos > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tif (value == NULL) {\n\t\treturn false;\n\t}\n\tif (size == 0) {\n\t\treturn false;\n\t}\n\tif (crc == NULL) {\n\t\treturn false;\n\t}\n\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\n\tuint8_t *ptr = (uint8_t *)EEPROM_ADDR;\n\tptr += pos;\n\tfor (int i = 0; i < size; i++) {\n\t\t*value = *ptr;\n\t\tif (writing) {\n\t\t\tvalue[i] = *ptr;\n\t\t}\n\t\t*crc = update_crc(*crc, *value);\n\t\tptr++;\n\t}\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 53.39450434540489}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tuint32_t retry = 0;\n\tif (SDIO_Handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\twhile (HAL_SD_WriteBlocks(SDIO_Handle, (uint8_t *) src, block, 1) != SD_OK) {\n\t\tretry++;\n\t\tif (retry > SD_MAX_RETRIES) {\n\t\t\tprintf(\"SD write failed\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 32.78843841234017}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\t// Check that the handle and source pointer are valid\n\tif (sdio_handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\t// Try to write the block, retrying up to 5 times if the write operation fails\n\tuint32_t retry_count = 0;\n\twhile (retry_count < 5) {\n\t\t// Write the block\n\t\tsdio_status = SDIO_WriteBlocks(sdio_handle, (uint8_t *)src, block, 1);\n\n\t\t// Check if the write operation succeeded\n\t\tif (sdio_status == SDIO_TRANSFER_OK) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Wait 100 ms before retrying\n\t\tdelay_ms(100);\n\n\t\t// Increment the retry count\n\t\tretry_count++;\n\t}\n\n\t// Display an error message if all retries fail\n\tprintf(\"Failed to write block %d\\r\n\", block);\n\n\t// Return failure\n\treturn false;\n}", "CodeBleu_score": 37.85707436568106}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (handle == NULL) {\n\t\treturn false;\n\t}\n\tif (src == NULL) {\n\t\treturn false;\n\t}\n\tuint32_t timeout = 0;\n\tuint8_t *dst = (uint8_t *) (0x08000000 + (block * 512));\n\twhile (timeout < 1000) {\n\t\tif (HAL_SD_WriteBlocks(handle, dst, src, 1, 1000) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t\ttimeout++;\n\t}\n\tprintf(\"SD write error\n\");\n\treturn false;\n}", "CodeBleu_score": 36.102774741151954}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tassert(timer_num < NUM_TIMERS);\n\tassert(frequency > 0);\n\tassert(timer_num != TEMP_TIMER_NUM);\n\tassert(timer_num != STEP_TIMER_NUM);\n\n\t// TODO: Initialize timer with given frequency\n\tTIM_TypeDef *timer = NULL;\n\tswitch (timer_num) {\n\t\tcase 0:\n\t\t\ttimer = TIM1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttimer = TIM2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttimer = TIM3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttimer = TIM4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttimer = TIM5;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\ttimer = TIM6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\ttimer = TIM7;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\ttimer = TIM8;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\ttimer = TIM9;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\ttimer = TIM10;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\ttimer = TIM11;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\ttimer = TIM12;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\ttimer = TIM13;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\ttimer = TIM14;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tassert(timer != NULL);\n\n\tuint32_t prescaler = 0;\n\tuint32_t period = 0;\n\tuint32_t clock = HAL_get_clock_frequency(timer_num);\n\tuint32_t timer_frequency = clock / 2;\n\twhile (timer_frequency > frequency) {\n\t\ttimer_frequency /= 2;\n\t\tprescaler++;\n\t}\n\tperiod = (clock / 2) / timer_frequency;\n\tassert(period > 0);\n\tassert(prescaler < 0x10000);\n\n\ttimer->PSC = prescaler;\n\ttimer->ARR = period;\n\ttimer->EGR |= TIM_EGR_UG;\n\ttimer->CR1 |=", "CodeBleu_score": 34.58048120316756}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tswitch (timer_num) {\n\t\tcase TIMER_CHANNEL_TEMP:\n\t\t\t// Set the timer prescale to 1:1\n\t\t\tHAL_TIM_PrescalerConfig(TIM_TEMP, 0, TIM_PSC_1);\n\t\t\t// Set the timer period to the given frequency\n\t\t\tHAL_TIM_Base_Start_IT(TIM_TEMP);\n\t\t\t// Set the timer callback priority to 1\n\t\t\tHAL_NVIC_SetPriority(TIM_TEMP_IRQn, 1, 0);\n\t\t\tbreak;\n\t\tcase TIMER_CHANNEL_STEP:\n\t\t\t// Set the timer prescale to 1:1\n\t\t\tHAL_TIM_PrescalerConfig(TIM_STEP, 0, TIM_PSC_1);\n\t\t\t// Set the timer period to the given frequency\n\t\t\tHAL_TIM_Base_Start_IT(TIM_STEP);\n\t\t\t// Set the timer callback priority to 1\n\t\t\tHAL_NVIC_SetPriority(TIM_STEP_IRQn, 1, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Invalid timer channel\n\t\t\tassert(0);\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 23.4170695754302}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tassert(timer_num < TIMER_NUM_CHANNELS);\n\tassert(frequency > 0);\n\n\tif (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\tHAL_timer_start_temperature(frequency);\n\t} else if (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\tHAL_timer_start_stepper(frequency);\n\t} else {\n\t\tassert(0);\n\t}\n}", "CodeBleu_score": 33.59593347989968}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tFile file = SD.open(EEPROM_FILE_NAME, FILE_READ);\n\tif (!file) {\n\t\treturn false;\n\t}\n\tfile.seek(0, SeekMode::end);\n\tint fileSize = file.position();\n\tif (fileSize < EEPROM_SIZE) {\n\t\tfile.close();\n\t\tfile = SD.open(EEPROM_FILE_NAME, FILE_WRITE);\n\t\tif (!file) {\n\t\t\treturn false;\n\t\t}\n\t\tfile.seek(fileSize);\n\t\tint bytesToWrite = EEPROM_SIZE - fileSize;\n\t\twhile (bytesToWrite > 0) {\n\t\t\tint bytesWritten = file.write(EEPROM_ERASE_VALUE);\n\t\t\tif (bytesWritten == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbytesToWrite -= bytesWritten;\n\t\t}\n\t\tfile.close();\n\t\tfile = SD.open(EEPROM_FILE_NAME, FILE_READ);\n\t\tif (!file) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfile.read(buffer, EEPROM_SIZE);\n\tfile.close();\n\treturn true;\n}", "CodeBleu_score": 31.777529894282612}, {"code": "bool PersistentStore::access_start(){\n\t\tif (this->file) {\n\t\treturn false;\n\t}\n\tthis->file = fopen(this->filename.c_str(), \"r+b\");\n\tif (!this->file) {\n\t\treturn false;\n\t}\n\tfseek(this->file, 0, SEEK_END);\n\tthis->file_size = ftell(this->file);\n\tif (this->file_size < this->eeprom_size) {\n\t\tfseek(this->file, 0, SEEK_SET);\n\t\tfor (uint32_t i = this->file_size; i < this->eeprom_size; i++) {\n\t\t\tfwrite(&this->erase_value, sizeof(this->erase_value), 1, this->file);\n\t\t}\n\t\tthis->file_size = this->eeprom_size;\n\t}\n\telse {\n\t\tfseek(this->file, 0, SEEK_SET);\n\t}\n\treturn true;\n}", "CodeBleu_score": 23.137797183864855}, {"code": "bool PersistentStore::access_start(){\n\t\tif (access_file.open(access_file_name, FILE_WRITE)) {\n\t\tif (access_file.size() < EEPROM_SIZE) {\n\t\t\taccess_buffer = (uint8_t *) malloc(EEPROM_SIZE);\n\t\t\tmemset(access_buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n\t\t\taccess_file.write(access_buffer, EEPROM_SIZE);\n\t\t} else {\n\t\t\taccess_buffer = (uint8_t *) malloc(EEPROM_SIZE);\n\t\t\taccess_file.read(access_buffer, EEPROM_SIZE);\n\t\t}\n\t\taccess_file.close();\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 28.849805268010986}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t mosi;\n\tuint8_t miso;\n\tuint8_t byte = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tmosi = (b & 0x80) >> 7;\n\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, mosi);\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, 0);\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, 1);\n\t\tmiso = HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin);\n\t\tbyte = (byte << 1) | miso;\n\t\tb = b << 1;\n\t}\n\n\tHAL_Delay(1);\n\n\treturn byte;\n}", "CodeBleu_score": 38.777709582005066}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t mosi = 0;\n\tuint8_t miso = 0;\n\tuint8_t byte = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tmosi = (b & 0x80) >> 7;\n\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, mosi);\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, 0);\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, 1);\n\t\tmiso = HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin);\n\t\tbyte = (byte << 1) | miso;\n\t\tb = b << 1;\n\t}\n\n\tHAL_Delay(1);\n\n\treturn byte;\n}", "CodeBleu_score": 38.41935249248094}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i, j, tmp;\n\n\tfor (i = 0; i < 8; i++) {\n\t\ttmp = 0x80 >> i;\n\t\tif (b & tmp) {\n\t\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, GPIO_PIN_SET);\n\t\t}\n\t\telse {\n\t\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_SET);\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_RESET);\n\t\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_SET);\n\t\t}\n\t\tif (HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin)) {\n\t\t\tb |= tmp;\n\t\t}\n\t}\n\tHAL_Delay(1);\n\treturn b;\n}", "CodeBleu_score": 36.871910828564936}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_CLK(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 79.29483299122909}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\t/* The clock is disabled */\n\tif (NewState == DISABLE) {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n\t/* The clock is enabled */\n\telse {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 79.68413482331852}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_CLK(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState != DISABLE) {\n\t\t/* Enable the AHB clock */\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\t/* Disable the AHB clock */\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 79.2943279299047}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// If no error occurs, read the byte and store it in the receive buffer if there is space available.\n\tif (obj->status.rx_error == 0) {\n\t\t// Read the byte from the serial interface\n\t\tuint8_t data = obj->uart->read();\n\n\t\t// If there is space available in the receive buffer, store the byte\n\t\tif (obj->rx_head != obj->rx_tail) {\n\t\t\tobj->rx_buffer[obj->rx_head] = data;\n\t\t\tobj->rx_head = (obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t\t}\n\n\t\t// If enabled, update the emergency parser with the received byte\n\t\tif (obj->emergency_parser.enabled) {\n\t\t\tobj->emergency_parser.update(data);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.704934303465016}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c = obj->getc();\n\tif (c == 0) {\n\t\treturn;\n\t}\n\n\tif (obj->rx_buffer.head != obj->rx_buffer.tail) {\n\t\tobj->rx_buffer.buffer[obj->rx_buffer.head] = c;\n\t\tobj->rx_buffer.head = (obj->rx_buffer.head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t}\n\n\tif (obj->rx_buffer.head == obj->rx_buffer.tail) {\n\t\tobj->rx_buffer.overflow = true;\n\t}\n\n\tif (obj->emergency_parser) {\n\t\tobj->emergency_parser->process_byte(c);\n\t}\n}", "CodeBleu_score": 39.30357920107746}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t data;\n\tint next_head;\n\n\t// Check for a parity error\n\tif (obj->rx_pin->get() == 0) {\n\t\t// Parity error\n\t\tobj->rx_buffer[obj->rx_head] = 0;\n\t\tobj->rx_head = (obj->rx_head + 1) & obj->rx_buffer_mask;\n\t\tobj->rx_count = 0;\n\t\treturn;\n\t}\n\n\t// Read the data\n\tdata = obj->rx_pin->get();\n\n\t// Store the data in the buffer\n\tnext_head = (obj->rx_head + 1) & obj->rx_buffer_mask;\n\tif (next_head != obj->rx_tail) {\n\t\tobj->rx_buffer[obj->rx_head] = data;\n\t\tobj->rx_head = next_head;\n\t\tobj->rx_count++;\n\t}\n}", "CodeBleu_score": 42.98314160860086}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (HAL_timer_is_initialized(MF_TIMER_STEP) && !HAL_timer_has_interrupt(MF_TIMER_STEP)) {\n\t\t\tHAL_timer_attach_interrupt(MF_TIMER_STEP, Step_Handler);\n\t\t}\n\t}\n\telse if (timer_num == MF_TIMER_TEMP) {\n\t\tif (HAL_timer_is_initialized(MF_TIMER_TEMP) && !HAL_timer_has_interrupt(MF_TIMER_TEMP)) {\n\t\t\tHAL_timer_attach_interrupt(MF_TIMER_TEMP, Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.59496856902932}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (timer_step.timer_initialized == 1 && timer_step.timer_interrupt_enabled == 0) {\n\t\t\ttimer_step.timer_interrupt_enabled = 1;\n\t\t\tHAL_TIM_Base_Start_IT(&timer_step);\n\t\t}\n\t}\n\tif (timer_num == MF_TIMER_TEMP) {\n\t\tif (timer_temp.timer_initialized == 1 && timer_temp.timer_interrupt_enabled == 0) {\n\t\t\ttimer_temp.timer_interrupt_enabled = 1;\n\t\t\tHAL_TIM_Base_Start_IT(&timer_temp);\n\t\t}\n\t}\n}", "CodeBleu_score": 29.853337236941506}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num < MF_TIMER_NUM) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\tif (HAL_timer_is_initialized(timer_num) && !HAL_timer_has_interrupt(timer_num)) {\n\t\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t\t}\n\t\t}\n\t\telse if (timer_num == MF_TIMER_TEMP) {\n\t\t\tif (HAL_timer_is_initialized(timer_num) && !HAL_timer_has_interrupt(timer_num)) {\n\t\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.67840859222925}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\th := hash(sep)\n\ti := len(s) - len(sep)\n\tfor i >= 0 {\n\t\tif hash(s[i:i+len(sep)]) == h && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t\ti--\n\t}\n\treturn -1\n}", "CodeBleu_score": 27.9747608875761}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// If the main string is empty, the substring cannot be found.\n\tif len(s) == 0 {\n\t\treturn -1\n\t}\n\n\t// If the substring is empty, the substring is found at the end of the main string.\n\tif len(sep) == 0 {\n\t\treturn len(s) - 1\n\t}\n\n\t// Calculate the hash of the substring.\n\th := HashRabinKarp(sep)\n\n\t// Calculate the hash of the last substring in the main string.\n\ti := len(s) - len(sep)\n\thLast := HashRabinKarp(s[i:])\n\n\t// If the hashes match, compare the substrings.\n\tif h == hLast && s[i:] == sep {\n\t\treturn i\n\t}\n\n\t// If the hashes don't match, search for the substring in the rest of the main string.\n\tfor i > 0 {\n\t\t// Calculate the hash of the current substring.\n\t\th = HashRabinKarp(s[i-1:i+len(sep)-1])\n\n\t\t// If the hashes match, compare the substrings.\n\t\tif h == hLast && s[i-1:i+len(sep)-1] == sep {\n\t\t\treturn i - 1\n\t\t}\n\n\t\t// Move to the previous substring.\n\t\ti--\n\t}\n\n\t// The substring was not found.\n\treturn -1\n}", "CodeBleu_score": 38.03743117399858}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Calculate the hash of the substring\n\th := HashRabinKarp(sep)\n\n\t// Calculate the hash of the main string\n\thMain := HashRabinKarp(s)\n\n\t// Calculate the hash of the substring in the main string\n\thSub := hMain - h\n\n\t// Calculate the length of the substring\n\tl := len(sep)\n\n\t// Calculate the length of the main string\n\tlMain := len(s)\n\n\t// Calculate the length of the main string minus the length of the substring\n\tlMainSub := lMain - l\n\n\t// Iterate through the main string from the end towards the beginning\n\tfor i := lMainSub; i >= 0; i-- {\n\t\t// Check if the hash of the substring matches the hash of the main string\n\t\tif hSub == hMain {\n\t\t\t// Check if the substring matches\n\t\t\tif s[i:i+l] == sep {\n\t\t\t\t// Return the starting index of the last occurrence\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\n\t\t// Update the hash of the main string\n\t\thMain = (hMain * 31) + int(s[i])\n\n\t\t// Update the hash of the substring\n\t\thSub = (hSub * 31) + int(s[i+l])\n\t}\n\n\t// Return -1 if the substring was not found\n\treturn -1\n}", "CodeBleu_score": 37.60875113324419}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif len(usbcdc.txBuffer) > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 40.14934796811316}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tinterrupt.Disable()\n\t// Check if there is data in the transmit buffer\n\tif len(usbcdc.txBuffer) > 0 {\n\t\t// Send data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\t// If no data is available, set \"waitTxc\" to false\n\tif len(usbcdc.txBuffer) == 0 {\n\t\tusbcdc.waitTxc = false\n\t}\n\t// Restore interrupt mask\n\tinterrupt.Enable()\n}", "CodeBleu_score": 54.60968126672165}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif len(usbcdc.txBuf) > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 39.66013206758989}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Set the control register to clear the interrupt flag, put a start condition on the SDA line, and enable the I2C module.\n\ti2c.control.set(0)\n\ti2c.control.set(1)\n\ti2c.control.set(2)\n\ti2c.control.set(3)\n\t// Wait for the start condition to be transmitted by checking the interrupt flag.\n\tfor i2c.status.get()&0x08 == 0 {\n\t\t// Do nothing.\n\t}\n\t// Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed, and send it.\n\tif write {\n\t\ti2c.data.set(address<<1)\n\t} else {\n\t\ti2c.data.set((address<<1)|0x01)\n\t}\n}", "CodeBleu_score": 27.224342392157986}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Set the control register to clear the interrupt flag, put a start condition on the SDA line, and enable the I2C module.\n\ti2c.control.set(0)\n\ti2c.control.set(1 << avr.I2C_CTRL_START)\n\ti2c.control.set(1 << avr.I2C_CTRL_ENABLE)\n\t// Wait for the start condition to be transmitted by checking the interrupt flag.\n\tfor {\n\t\tif i2c.status.get()&(1<<avr.I2C_STATUS_START_COND) != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\t// Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed, and send it.\n\tif write {\n\t\ti2c.data.set(address<<1)\n\t} else {\n\t\ti2c.data.set((address<<1)|1)\n\t}\n}", "CodeBleu_score": 27.32327285219307}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.cr1.set(0)\n\ti2c.cr2.set(0)\n\ti2c.sr1.set(0)\n\ti2c.sr2.set(0)\n\ti2c.dr.set(address<<1 | uint8(i2c.read)<<0)\n\ti2c.cr1.set(1<<10 | 1<<8 | 1<<7 | 1<<6 | 1<<0)\n\tfor {\n\t\tif i2c.sr1.get()&1<<0 != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\ti2c.cr2.set(1<<14 | uint16(address)<<11 | uint16(write)<<10 | 1<<9 | 1<<8 | 1<<7 | 1<<6 | 1<<0)\n}", "CodeBleu_score": 30.971024246761857}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\taddr := int(f.base) + int(start*f.blockSize)\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE(addr)\n\t\tfor nrf.NVMC.READY() == 0 {\n\t\t}\n\t\taddr += int(f.blockSize)\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.62608003747367}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn ErrOutOfBounds\n\t}\n\tif start+len > int64(f.numBlocks) {\n\t\treturn ErrOutOfBounds\n\t}\n\n\t// Calculate the start address based on the block number and block size.\n\tstartAddr := start * int64(f.blockSize)\n\n\t// Wait for any ongoing flash operations to complete.\n\tf.wait()\n\n\t// Configure the flash for erasing.\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN)\n\n\t// Erase each block.\n\tfor i := 0; i < int(len); i++ {\n\t\t// Calculate the address of the block to erase.\n\t\taddr := startAddr + int64(i)*int64(f.blockSize)\n\n\t\t// Erase the block.\n\t\tnrf.NVMC.ERASEPAGE.Set(addr)\n\n\t\t// Wait until the flash is no longer busy.\n\t\tfor nrf.NVMC.READY.Get() == 0 {\n\t\t}\n\t}\n\n\t// Set the flash back to read mode.\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_REN)\n\n\treturn nil\n}", "CodeBleu_score": 41.47623468802173}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 1 {\n\t\treturn EINVAL\n\t}\n\t// Make sure the flash is ready for erasing\n\tif f.readMode() != 0 {\n\t\tf.writeMode()\n\t}\n\t// Calculate the start address of the first block to erase\n\taddr := f.blockSize * start\n\t// Set the flash to erase mode\n\tf.writeCommand(flashEraseAllUnsecure)\n\t// Wait for any ongoing flash operation to complete\n\tf.waitBusy()\n\t// Erase each block\n\tfor i := int64(0); i < len; i++ {\n\t\t// Send the command to erase the current block\n\t\tf.writeCommand(flashErasePage)\n\t\t// Send the address to erase\n\t\tf.writeAddress(addr)\n\t\t// Wait for any ongoing flash operation to complete\n\t\tf.waitBusy()\n\t\t// Move to the next block\n\t\taddr += f.blockSize\n\t}\n\t// Set the flash back to read mode\n\tf.readMode()\n\treturn nil\n}", "CodeBleu_score": 40.02607133409396}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, &os.PathError{Op: \"write\", Path: f.name, Err: os.ErrInvalid}\n\t}\n\tif uint64(off) >= f.size {\n\t\treturn 0, &os.PathError{Op: \"write\", Path: f.name, Err: os.ErrInvalid}\n\t}\n\tif uint64(len(p)) > f.writeBlockSize {\n\t\treturn 0, &os.PathError{Op: \"write\", Path: f.name, Err: os.ErrInvalid}\n\t}\n\tif uint64(len(p)) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tstartAddr := uint32(off)\n\tendAddr := uint32(off + uint64(len(p)))\n\tif endAddr > f.size {\n\t\tendAddr = uint32(f.size)\n\t}\n\n\t// Calculate the number of write operations that need to be performed\n\tnumOfBlocks := (endAddr - startAddr) / uint32(f.writeBlockSize)\n\tif (endAddr - startAddr) % uint32(f.writeBlockSize) != 0 {\n\t\tnumOfBlocks += 1\n\t}\n\n\t// Enable write mode\n\tf.flash.ErasePage(startAddr)\n\tf.flash.ErasePage(endAddr)\n\tf.flash.WriteEnable()\n\n\t// Write data in blocks\n\tfor i := uint32(0); i < numOfBlocks; i++ {\n\t\tf.flash.ErasePage(startAddr + i*uint32(f.writeBlockSize))\n\t\tf.flash.Program(startAddr+i*uint32(f.writeBlockSize), p[i*uint32(f.writeBlockSize):(i+1)*uint32(f.writeBlockSize)])\n\t}\n\n\t// Wait for flash memory to be ready\n\tfor i := uint32(0); i < numOfBlocks; i++ {\n\t\tf.flash.WaitForReady()\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 30.792232255132628}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off > f.Size {\n\t\treturn 0, EINVAL\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, 0\n\t}\n\tif off+int64(len(p)) > f.Size {\n\t\treturn 0, EINVAL\n\t}\n\tif off%int64(f.BlockSize) != 0 {\n\t\tp = append(make([]byte, f.BlockSize-off%int64(f.BlockSize)), p...)\n\t}\n\tstartAddr := off\n\tendAddr := off + int64(len(p))\n\t// Enable write mode\n\tnrf.NVMC.CONFIG.SetBits(nrf.NVMC_CONFIG_WEN)\n\t// Write data in blocks\n\tfor startAddr < endAddr {\n\t\t// Calculate start and end addresses for the current block\n\t\tblockStartAddr := startAddr - startAddr%int64(f.BlockSize)\n\t\tblockEndAddr := blockStartAddr + int64(f.BlockSize)\n\t\t// Check if the current block is partially or completely outside the flash memory\n\t\tif blockStartAddr < 0 {\n\t\t\tblockStartAddr = 0\n\t\t}\n\t\tif blockEndAddr > f.Size {\n\t\t\tblockEndAddr = f.Size\n\t\t}\n\t\t// Calculate the offset for the current block\n\t\tblockOffset := startAddr - blockStartAddr\n\t\t// Calculate the number of bytes to write in the current block\n\t\tblockLen := blockEndAddr - blockStartAddr\n\t\t// Write the data in the current block\n\t\tf.writeBlock(p[blockOffset:blockOffset+blockLen], blockStartAddr)\n\t\t// Wait for the flash memory to be ready\n\t\tf.waitReady()\n\t\t// Update the start address\n\t\tstartAddr += int64(blockLen)\n\t}\n\t// Disable write mode\n\tnrf.NVMC.CONFIG.ClearBits(nrf.NVMC_CONFIG_WEN)\n\treturn len(p), nil\n}", "CodeBleu_score": 33.348758301950426}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, ErrNegativeOffset\n\t}\n\tif off >= int64(f.Size()) {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\tif int64(len(p)) > f.BlockSize() {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\n\t// Calculate start address for writing\n\tstartAddr := uint32(off / f.BlockSize())\n\taddr := uint32(off % f.BlockSize())\n\n\t// Pad the byte slice to fit the write block size\n\tpad := f.BlockSize() - len(p)\n\tp = append(p, make([]byte, pad)...)\n\n\t// Enable write mode\n\tnrf.NVMC.CONFIG.SetBits(nrf.NVMC_CONFIG_WEN)\n\n\t// Write data in blocks\n\tfor i := 0; i < len(p); i += 4 {\n\t\t// Set the address for the write operation\n\t\tnrf.NVMC.ADDR.Set(startAddr)\n\n\t\t// Set the data for the write operation\n\t\tdata := uint32(p[i]) | (uint32(p[i+1]) << 8) | (uint32(p[i+2]) << 16) | (uint32(p[i+3]) << 24)\n\t\tnrf.NVMC.DATA.Set(data)\n\n\t\t// Start the write operation\n\t\tnrf.NVMC.CONFIG.SetBits(nrf.NVMC_CONFIG_WRITE)\n\n\t\t// Wait for the flash memory to be ready\n\t\tfor nrf.NVMC.READY.Get() == 0 {\n\t\t}\n\n\t\t// Increment the start address\n\t\tstartAddr++\n\n\t\t// Increment the address\n\t\taddr += 4\n\t}\n\n\t// Disable write mode\n\tnrf.NVMC.CONFIG.ClearBits(nrf.NVMC_CONFIG_WEN)\n\n\t// Return the number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 37.48678919985443}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor to avoid closing it.\n\tdupFd, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to duplicate file descriptor: %s\", err)\n\t}\n\n\t// Close the duplicated file descriptor if an error occurs.\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tsyscall.Close(dupFd)\n\t\t}\n\t}()\n\n\t// Check for errors.\n\tvar errno syscall.Errno\n\tif _, _, errno = syscall.Syscall(syscall.SYS_FCNTL, uintptr(dupFd), syscall.F_GETFD, 0); errno != 0 {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to get file descriptor flags: %s\", errno)\n\t}\n\n\t// Attempt to open the directory.\n\tdirPtr, errno := syscall.Fdopendir(dupFd)\n\tif errno != 0 {\n\t\tif errno != syscall.EINTR {\n\t\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %s\", errno)\n\t\t}\n\n\t\t// If an \"EINTR\" error occurs, attempt to open the directory again.\n\t\truntime.Gosched()\n\t\tdirPtr, errno = syscall.Fdopendir(dupFd)\n\t\tif errno != 0 {\n\t\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %s\", errno)\n\t\t}\n\t}\n\n\t// No error occurred; return the directory pointer.\n\treturn dirPtr, \"\", nil\n}", "CodeBleu_score": 49.5074690185543}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor to avoid closing it.\n\tdupFd, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory.\n\tdirPtr, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\tsyscall.Close(dupFd)\n\t\treturn 0, \"\", err\n\t}\n\n\t// If successful, return the directory pointer.\n\treturn dirPtr, \"\", nil\n}", "CodeBleu_score": 55.19481720308431}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Attempt to duplicate the provided file descriptor.\n\tfdDup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Close the duplicated file descriptor if it is not the same as the original.\n\tif fdDup != int(fd) {\n\t\tdefer syscall.Close(fdDup)\n\t}\n\t// Attempt to open the directory using \"syscall.Fdopendir\".\n\tdirPtr, err := syscall.Fdopendir(fdDup)\n\tif err == nil {\n\t\treturn dirPtr, \"\", nil\n\t}\n\t// If the error is \"syscall.EINTR\", return the error message.\n\tif err == syscall.EINTR {\n\t\treturn 0, \"\", err\n\t}\n\t// If the error is not \"syscall.EINTR\", attempt to open the directory repeatedly until it either succeeds or encounters an error other than \"syscall.EINTR\".\n\tfor i := 0; i < 10; i++ {\n\t\truntime.Gosched()\n\t\tdirPtr, err = syscall.Fdopendir(fdDup)\n\t\tif err == nil {\n\t\t\treturn dirPtr, \"\", nil\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\t// Close the duplicated file descriptor if it is not the same as the original.\n\tif fdDup != int(fd) {\n\t\tsyscall.Close(fdDup)\n\t}\n\treturn 0, \"\", err\n}", "CodeBleu_score": 60.60052982367638}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *partition = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_FACTORY, NULL);\n\tuint32_t size = 0;\n\tif (partition != NULL) {\n\t\tsize = esp_partition_get_size(partition);\n\t}\n\tif (response) {\n\t\treturn esp_partition_get_free_space_for_partition(partition);\n\t}\n\treturn size;\n}", "CodeBleu_score": 26.506982579849105}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tconst esp_partition_t *running = esp_ota_get_running_partition();\n\tconst esp_partition_t *boot = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, \"boot\");\n\n\tif (running == NULL || boot == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (running->subtype == ESP_PARTITION_SUBTYPE_DATA_FAT) {\n\t\treturn response ? boot->size - running->address : running->size;\n\t} else {\n\t\treturn response ? boot->size - running->address : running->size;\n\t}\n}", "CodeBleu_score": 50.729561248275786}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t partition;\n\tesp_partition_get_running(&partition);\n\tesp_partition_t *part = &partition;\n\tuint32_t size = 0;\n\tif (part->subtype == ESP_PARTITION_SUBTYPE_APP_FACTORY) {\n\t\tif (response) {\n\t\t\tsize = part->size - part->app_flash_off - part->app_flash_size;\n\t\t} else {\n\t\t\tsize = part->app_flash_size;\n\t\t}\n\t} else {\n\t\tif (response) {\n\t\t\tsize = part->size - part->app_flash_off - part->app_flash_size;\n\t\t} else {\n\t\t\tsize = part->app_flash_size;\n\t\t}\n\t}\n\treturn size;\n}", "CodeBleu_score": 39.4265593389589}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t i;\n\tuint32_t sector_count;\n\tuint32_t fat_sector_count;\n\tuint32_t root_dir_sector_count;\n\tuint32_t root_dir_entry_count;\n\tuint32_t root_dir_sector_index;\n\tuint32_t root_dir_entry_index;\n\tuint32_t root_dir_entry_size;\n\tuint32_t file_sector_count;\n\tuint32_t file_sector_index;\n\tuint32_t file_sector_index_in_fat;\n\tuint32_t file_sector_offset;\n\tuint32_t file_sector_size;\n\tuint32_t file_sector_size_in_fat;\n\tuint32_t file_sector_count_in_fat;\n\tuint32_t file_sector_count_in_fat_bytes;\n\tuint32_t file_sector_count_in_fat_bytes_high;\n\tuint32_t file_sector_count_in_fat_bytes_low;\n\tuint32_t file_sector_index_in_fat_bytes;\n\tuint32_t file_sector_index_in_fat_bytes_high;\n\tuint32_t file_sector_index_in_fat_bytes_low;\n\tuint32_t file_sector_offset_bytes;\n\tuint32_t file_sector_offset_bytes_high;\n\tuint32_t file_sector_offset_bytes_low;\n\tuint32_t file_sector_size_bytes;\n\tuint32_t file_sector_size_bytes_high;\n\tuint32_t file_sector_size_bytes_low;\n\tuint32_t file_sector_count_in_fat_bytes_in_root_dir_entry;\n\tuint32_t file_sector_count_in_fat_bytes_in_root_dir_entry_high;\n\tuint32_t file_sector_count_in_fat_bytes_in_root_dir_entry", "CodeBleu_score": 9.117634503411379}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t i;\n\tuint32_t num_sectors;\n\tuint32_t num_reserved_sectors;\n\tuint32_t num_fat_sectors;\n\tuint32_t num_root_dir_sectors;\n\tuint32_t num_data_sectors;\n\tuint32_t num_sectors_per_cluster;\n\tuint32_t num_clusters;\n\tuint32_t root_dir_sectors_offset;\n\tuint32_t fat_sectors_offset;\n\tuint32_t data_sectors_offset;\n\tuint32_t cluster_offset;\n\tuint32_t cluster_num;\n\tuint32_t cluster_num_offset;\n\tuint8_t *p;\n\tuint8_t *p_sector;\n\tuint8_t *p_fat;\n\tuint8_t *p_root_dir;\n\tuint8_t *p_data;\n\tuint8_t *p_cluster;\n\tuint8_t *p_cluster_num;\n\tuint8_t *p_cluster_num_sector;\n\tuint8_t *p_fat_sector;\n\tuint8_t *p_data_sector;\n\tuint8_t *p_sector_buffer;\n\tuint8_t *p_sector_buffer_copy;\n\tuint8_t *p_sector_buffer_copy_copy;\n\tuint8_t *p_sector_buffer_copy_copy_copy;\n\tuint8_t *p_sector_buffer_copy_copy_copy_copy;\n\tuint8_t *p_sector_buffer_copy_copy_copy_copy_copy;\n\tuint8_t *p_sector_buffer_copy_copy_copy_copy_copy_copy;\n\tuint8_t *p_sector_buffer_copy_copy_copy_copy_copy_copy_copy;\n\tuint8_t *p_sector_buffer_copy_copy_copy_copy_copy_copy_copy_copy;\n\tuint8_t *p_sector_buffer_copy_copy_copy_", "CodeBleu_score": 7.692956811390769}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t i;\n\tuint32_t fat_size;\n\tuint32_t root_dir_sectors;\n\tuint32_t root_dir_size;\n\tuint32_t data_sectors;\n\tuint32_t data_size;\n\tuint32_t total_sectors;\n\tuint32_t total_size;\n\tuint32_t data_start_sector;\n\tuint32_t fat_start_sector;\n\tuint32_t root_dir_start_sector;\n\tuint32_t root_dir_start_cluster;\n\tuint32_t data_start_cluster;\n\tuint32_t data_start_sector_in_cluster;\n\tuint32_t data_sectors_in_cluster;\n\tuint32_t data_sectors_in_fat;\n\tuint32_t fat_sectors_in_cluster;\n\tuint32_t fat_sectors_in_fat;\n\tuint32_t fat_start_sector_in_fat;\n\tuint32_t fat_start_cluster_in_fat;\n\tuint32_t root_dir_entry_size;\n\tuint32_t root_dir_entry_start_sector;\n\tuint32_t root_dir_entry_start_cluster;\n\tuint32_t root_dir_entry_start_sector_in_cluster;\n\tuint32_t root_dir_entry_sectors_in_cluster;\n\tuint32_t root_dir_entry_sectors_in_fat;\n\tuint32_t root_dir_entry_start_sector_in_fat;\n\tuint32_t root_dir_entry_start_cluster_in_fat;\n\tuint32_t *fat;\n\tuint32_t *root_dir_entry;\n\tuint32_t *root_dir_entry_name;\n\tuint32_t *root_dir_entry_extension;\n\tuint32_t *root_dir_entry_attributes;\n\tuint32_t *root_dir_", "CodeBleu_score": 8.465443044001464}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tif (offset % partition->sector_size != 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x is not aligned with the sector size 0x%x of the partition\", offset, partition->sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size % partition->sector_size != 0) {\n\t\tESP_LOGE(TAG, \"Size 0x%x is not aligned with the sector size 0x%x of the partition\", size, partition->sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (esp_partition_erase_range(partition, offset, size) != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Erase failed at offset 0x%x with size 0x%x\", offset, size);\n\t\treturn ESP_FAIL;\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Write failed at offset 0x%x with size 0x%x\", offset, size);\n\t}\n\treturn err;\n}", "CodeBleu_score": 52.48856879397238}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % SPI_FLASH_SEC_SIZE != 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x is not aligned with flash sector size 0x%x\", offset, SPI_FLASH_SEC_SIZE);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tif (esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE) != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Erase failed at offset 0x%x\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\n\tif (esp_partition_write(partition, offset, data, size) != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Write failed at offset 0x%x\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\n\treturn ESP_OK;\n}", "CodeBleu_score": 46.55351346409905}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % partition->sector_size) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x is not aligned with the sector size 0x%x\", offset, partition->sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (esp_partition_erase_range(partition, offset, size) == ESP_OK) {\n\t\treturn esp_partition_write(partition, offset, data, size);\n\t}\n\treturn ESP_FAIL;\n}", "CodeBleu_score": 41.46861843455037}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\tsize_t j = 0;\n\n\twhile (in[i] != '\\0' && j < maxlen) {\n\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\tout[j] = in[i] - '0';\n\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\tout[j] = in[i] - 'A' + 10;\n\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\tout[j] = in[i] - 'a' + 10;\n\t\t} else {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tj++;\n\t\ti++;\n\t}\n\n\treturn j;\n}", "CodeBleu_score": 37.995114892189676}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t outlen = 0;\n\tunsigned char c;\n\twhile (outlen < maxlen && (c = *in) != 0) {\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tc = c - '0';\n\t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\tc = c - 'A' + 10;\n\t\t} else if (c >= 'a' && c <= 'f') {\n\t\t\tc = c - 'a' + 10;\n\t\t} else {\n\t\t\tin++;\n\t\t\tcontinue;\n\t\t}\n\t\tin++;\n\t\tif (outlen & 1) {\n\t\t\tout[outlen >> 1] |= c;\n\t\t} else {\n\t\t\tout[outlen >> 1] = c << 4;\n\t\t}\n\t\toutlen++;\n\t}\n\treturn outlen;\n}", "CodeBleu_score": 50.446420280046}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\tsize_t j = 0;\n\tunsigned char c = 0;\n\tunsigned char n = 0;\n\n\twhile (i < maxlen && in[i] != '\\0') {\n\t\tc = in[i];\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tn = c - '0';\n\t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\tn = c - 'A' + 10;\n\t\t} else if (c >= 'a' && c <= 'f') {\n\t\t\tn = c - 'a' + 10;\n\t\t} else {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (j % 2 == 0) {\n\t\t\tout[j / 2] = n << 4;\n\t\t} else {\n\t\t\tout[j / 2] |= n;\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn j / 2;\n}", "CodeBleu_score": 43.236581363961065}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tint freeSize = 0;\n\n\tif (this->transmitBuffer != NULL) {\n\t\tif (this->transmitBuffer->lock != NULL) {\n\t\t\tif (xSemaphoreTake(this->transmitBuffer->lock, 1000 / portTICK_RATE_MS) == pdTRUE) {\n\t\t\t\tfreeSize = this->transmitBuffer->freeSize;\n\t\t\t\txSemaphoreGive(this->transmitBuffer->lock);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn freeSize;\n}", "CodeBleu_score": 22.66045283477466}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (txRingBuf == NULL || txLock == NULL) {\n\t\treturn 0;\n\t}\n\tif (txLock->take(TX_LOCK_TIMEOUT)) {\n\t\tint freeSpace = txRingBuf->getFree();\n\t\ttxLock->give();\n\t\treturn freeSpace;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 55.21746570656285}, {"code": "int HWCDC::availableForWrite(void){\n\t\tint freeSize;\n\n\tif (txRingBuffer == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (txRingBuffer->lock == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (txRingBuffer->lock->take(txRingBuffer->lock, txRingBuffer->timeout) == 0) {\n\t\treturn 0;\n\t}\n\n\tfreeSize = txRingBuffer->size - txRingBuffer->count;\n\ttxRingBuffer->lock->give(txRingBuffer->lock);\n\n\treturn freeSize;\n}", "CodeBleu_score": 44.07285934122292}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\n#if CONFIG_IDF_TARGET_ESP32\n\n\tif (_uart_num == UART_NUM_0) {\n\n\t\tif (function != NULL) {\n\n\t\t\tif (_onReceiveCB == NULL) {\n\n\t\t\t\txSemaphoreTake(_mutex, portMAX_DELAY);\n\n\t\t\t\t_onReceiveCB = function;\n\n\t\t\t\t_rx_buffer_size = 0;\n\n\t\t\t\t_rx_buffer = (uint8_t *) malloc(_rx_buffer_size);\n\n\t\t\t\t_rx_buffer_head = 0;\n\n\t\t\t\t_rx_buffer_tail = 0;\n\n\t\t\t\t_rx_buffer_full = false;\n\n\t\t\t\t_rx_buffer_overflow = false;\n\n\t\t\t\t_rx_buffer_overflow_count = 0;\n\n\t\t\t\t_rx_buffer_overflow_limit = 100;\n\n\t\t\t\t_rx_buffer_overflow_event = xEventGroupCreate();\n\n\t\t\t\t_rx_buffer_overflow_event_handle = xTaskCreate(onReceiveBufferOverflowTask, \"onReceiveBufferOverflowTask\", 2048, this, 2, NULL);\n\n\t\t\t\txSemaphoreGive(_mutex);\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (onlyOnTimeout) {\n\n\t\t\tuart_set_rx_timeout(_uart_num, _rxTimeout);\n\n\t\t} else {\n\n\t\t\tuart_set_rx_timeout(_uart_num, 0);\n\n\t\t}\n\n\t}\n", "CodeBleu_score": 45.15827905245163}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t// Lock the serial mutex\n\txSemaphoreTake(_mutex, portMAX_DELAY);\n\n\t// Assign the callback function\n\t_onReceiveCB = function;\n\n\t// Configure the receive timeout behavior\n\t_rxTimeout = onlyOnTimeout;\n\t_rxTimeoutTicks = 0;\n\n\t// If the callback is not NULL, set the FIFO full threshold and create an event task if it does not already exist\n\tif (_onReceiveCB != NULL) {\n\t\t_rxThreshold = 1;\n\t\tif (_eventTask == NULL) {\n\t\t\txTaskCreate(_eventTaskFunction, \"EventTask\", 2048, this, tskIDLE_PRIORITY + 1, &_eventTask);\n\t\t}\n\t}\n\n\t// Unlock the serial mutex\n\txSemaphoreGive(_mutex);\n}", "CodeBleu_score": 45.26023746272488}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t//Serial.println(\"HardwareSerial::onReceive\");\n\n\tif (function == NULL) {\n\t\t//Serial.println(\"HardwareSerial::onReceive: function is NULL\");\n\t\treturn;\n\t}\n\n\t//Serial.println(\"HardwareSerial::onReceive: locking mutex\");\n\n\t_mutex.lock();\n\n\t//Serial.println(\"HardwareSerial::onReceive: mutex locked\");\n\n\t_onReceiveCB = function;\n\n\tif (onlyOnTimeout) {\n\t\t//Serial.println(\"HardwareSerial::onReceive: only on timeout\");\n\t\t_rxTimeout = true;\n\t\t_rxTimeoutTicks = 0;\n\t\t_rxTimeoutTicks = (uint32_t) std::clock() + _rxTimeoutTicks;\n\t} else {\n\t\t//Serial.println(\"HardwareSerial::onReceive: not only on timeout\");\n\t\t_rxTimeout = false;\n\t\t_rxTimeoutTicks = 0;\n\t}\n\n\tif (_rxFifo.size() > 0) {\n\t\t//Serial.println(\"HardwareSerial::onReceive: fifo size > 0\");\n\t\t_rxFifo.clear();\n\t}\n\n\tif (_onReceiveTask == NULL) {\n\t\t//Serial.println(\"HardwareSerial::onReceive: creating task\");\n\t\t_onReceiveTask = new OnReceiveTask(this);\n\t\txTaskCreate(_onReceiveTask, \"onReceiveTask\", 2048, this, 1, &_onReceiveTaskHandle);\n\t} else {\n\t\t//Serial.println(\"HardwareSerial::onReceive: task already exists\");\n\t\tBaseType_t xResult = xEventGroupSetBits(_onReceiveEventGroup, ON_RECEIVE_EVENT);\n\n\t\tif (xResult == pdPASS) {\n\t\t\t//Serial.println(\"HardwareSerial::onReceive: event set\");\n\t\t} else {\n\t\t\t//Serial.println(\"HardwareSerial::onReceive: event set failed\");\n\t\t}\n\t}\n\n\t_mutex.unlock();\n\n\t//Serial.println(\"HardwareSerial::onReceive: mutex unlocked\");\n}", "CodeBleu_score": 46.03032602989364}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tchar c;\n\tsize_t i = 0;\n\n\twhile (i < length) {\n\t\tc = timedRead();\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[i] = c;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}", "CodeBleu_score": 51.43586307393434}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index++] = (char)c;\n\t}\n\treturn index;\n}", "CodeBleu_score": 63.16410061373592}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t count = 0;\n\tint c = timedRead();\n\twhile (c >= 0 && count < length - 1) {\n\t\tbuffer[count++] = (char)c;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tc = timedRead();\n\t}\n\tbuffer[count] = 0;\n\treturn count;\n}", "CodeBleu_score": 52.51445549268998}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\t// Check if the pin is available or already in use\n\tif (digitalPinToPort(pin) == NOT_A_PIN) {\n\t\t// Log the pin, frequency, and duration\n\t\tSerial.print(\"Tone on pin \");\n\t\tSerial.print(pin);\n\t\tSerial.print(\" with frequency \");\n\t\tSerial.print(frequency);\n\t\tSerial.print(\" for \");\n\t\tSerial.print(duration);\n\t\tSerial.print(\" milliseconds.\n\");\n\n\t\t// Initialize the tone\n\t\tledcSetupTone(pin, frequency);\n\n\t\t// Send a start command with the pin, frequency, and duration to a queue\n\t\txQueueSend(toneQueue, &pin, portMAX_DELAY);\n\t\txQueueSend(toneQueue, &frequency, portMAX_DELAY);\n\t\txQueueSend(toneQueue, &duration, portMAX_DELAY);\n\t\txQueueSend(toneQueue, &true, portMAX_DELAY);\n\t}\n\telse {\n\t\t// Log an error message instructing to stop the current tone on the pin first\n\t\tSerial.print(\"ERROR: Tone on pin \");\n\t\tSerial.print(pin);\n\t\tSerial.print(\" with frequency \");\n\t\tSerial.print(frequency);\n\t\tSerial.print(\" for \");\n\t\tSerial.print(duration);\n\t\tSerial.print(\" milliseconds.\n\");\n\t\tSerial.print(\"ERROR: Tone on pin \");\n\t\tSerial.print(pin);\n\t\tSerial.print(\" is already in use.\n\");\n\t}\n}", "CodeBleu_score": 38.47618001753362}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\t// Check if the pin is available\n\tif (digitalPinToBitMask(pin) & (1ULL << digitalPinToBitPosition(pin))) {\n\t\t// Log the pin, frequency, and duration\n\t\tSerial.printf(\"Pin %d is already in use.\n\", pin);\n\t\treturn;\n\t}\n\t// Initialize the tone\n\tledcSetup(pin, frequency, 8);\n\tledcAttachPin(pin, LEDC_CHANNEL_0);\n\t// Send a start command with the pin, frequency, and duration to a queue\n\txQueueSend(startQueue, &pin, portMAX_DELAY);\n\txQueueSend(startQueue, &frequency, portMAX_DELAY);\n\txQueueSend(startQueue, &duration, portMAX_DELAY);\n}", "CodeBleu_score": 34.44418281321346}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (pin < 0 || pin > 39) {\n\t\tSerial.print(\"Invalid pin: \");\n\t\tSerial.println(pin);\n\t\treturn;\n\t}\n\tif (frequency < 1 || frequency > 10000) {\n\t\tSerial.print(\"Invalid frequency: \");\n\t\tSerial.println(frequency);\n\t\treturn;\n\t}\n\tif (duration < 1 || duration > 1000000) {\n\t\tSerial.print(\"Invalid duration: \");\n\t\tSerial.println(duration);\n\t\treturn;\n\t}\n\tif (g_pin_status[pin] == 1) {\n\t\tSerial.print(\"Pin \");\n\t\tSerial.print(pin);\n\t\tSerial.print(\" is already in use. Please stop the tone on this pin first.\");\n\t\treturn;\n\t}\n\tg_pin_status[pin] = 1;\n\tSerial.print(\"Pin \");\n\tSerial.print(pin);\n\tSerial.print(\" is available. Starting tone...\");\n\tSerial.print(\"Frequency: \");\n\tSerial.print(frequency);\n\tSerial.print(\" Duration: \");\n\tSerial.println(duration);\n\tledc_timer_config_t ledc_timer = {\n\t\t.speed_mode = LEDC_HIGH_SPEED_MODE,\n\t\t.timer_num = LEDC_TIMER_0,\n\t\t.duty_resolution = LEDC_TIMER_13_BIT,\n\t\t.freq_hz = frequency,\n\t\t.clk_cfg = LEDC_AUTO_CLK\n\t};\n\tledc_timer_config(&ledc_timer);\n\tledc_channel_config_t ledc_channel = {\n\t\t.timer_sel = LEDC_TIMER_0,\n\t\t.speed_mode = LEDC_HIGH_SPEED_MODE,\n\t\t.channel = LEDC_CHANNEL_0,\n\t\t.intr_type = LEDC_INTR_DISABLE,\n\t\t.duty = 0,\n\t\t.hpoint = 0,\n\t\t.timer_sel = LEDC_TIMER_0,\n\t\t.duty_resolution = LEDC_TIMER_13_BIT,\n\t\t.freq_hz = frequency,\n\t\t.clk_cfg = LEDC_AUTO_CLK\n\t", "CodeBleu_score": 40.39994866940302}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!USB.hasStarted()) {\n\t\t_webUSBEnabled = enabled;\n\t\tif (enabled) {\n\t\t\tUSB.setVersion(0x0210);\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\t_webUSBEnabled = enabled;\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 43.510819882858186}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (USB.hasStarted()) {\n\t\tUSB.setWebUSBEnabled(enabled);\n\t\treturn false;\n\t} else {\n\t\twebUSBEnabled = enabled;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 33.36642348405213}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!USB.hasStarted()) {\n\t\t_webUSBEnabled = enabled;\n\t\tif (enabled && USB.getVersion() < 0x0210) {\n\t\t\tUSB.setVersion(0x0210);\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\tUSB.setWebUSBEnabled(enabled);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 41.49923163759013}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t byte;\n\tuint16_t i = 0;\n\tuint16_t len = 0;\n\tuint16_t dropped = 0;\n\twhile (USBCDC::available()) {\n\t\tbyte = USBCDC::read();\n\t\tif (i >= USBCDC_RX_BUFFER_SIZE) {\n\t\t\tdropped++;\n\t\t} else {\n\t\t\trxBuffer[i] = byte;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (dropped) {\n\t\t_log(ERROR, \"USB CDC RX buffer overflow, dropped %d bytes\", dropped);\n\t\t_postEvent(CDC_EVENT_RX_OVERFLOW, dropped);\n\t} else {\n\t\tlen = i;\n\t\t_postEvent(CDC_EVENT_RX, len);\n\t}\n}", "CodeBleu_score": 22.878000333215557}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t buffer[64];\n\tuint8_t length = USB.read(buffer, sizeof(buffer));\n\tif (length > 0) {\n\t\tif (length > sizeof(buffer)) {\n\t\t\tlength = sizeof(buffer);\n\t\t}\n\t\tuint8_t dropped = 0;\n\t\tfor (uint8_t i = 0; i < length; i++) {\n\t\t\tif (!this->rxQueue.post(buffer[i])) {\n\t\t\t\tdropped++;\n\t\t\t}\n\t\t}\n\t\tif (dropped > 0) {\n\t\t\tthis->logf(LOG_ERROR, \"RX overflow: %d bytes dropped\", dropped);\n\t\t\tthis->post(CDCEvent(CDCEvent::OVERFLOW, dropped));\n\t\t}\n\t\tthis->post(CDCEvent(CDCEvent::RECEIVE, length));\n\t}\n}", "CodeBleu_score": 29.04242961511073}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t data;\n\tuint16_t length;\n\n\tlength = USB.getRXCount();\n\tif (length > 0) {\n\t\tif (length > USBCDC_BUFFER_SIZE) {\n\t\t\tlength = USBCDC_BUFFER_SIZE;\n\t\t}\n\t\tUSB.read(data, length);\n\t\tif (!rxQueue.push(data, length)) {\n\t\t\trxOverflowEvent.post(length);\n\t\t\tlogf(\"RX overflow: dropped %u bytes\n\", length);\n\t\t} else {\n\t\t\trxEvent.post(length);\n\t\t}\n\t}\n}", "CodeBleu_score": 16.107320348794545}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\tname = strings.TrimSuffix(name, \"/devices\")\n\tif name == \"\" {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\tif _, ok := a.robots[name]; !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\tvar devices []robeaux.Device\n\tfor _, device := range a.robots[name].Devices() {\n\t\tdevices = append(devices, robeaux.Device{\n\t\t\tName:    device.Name(),\n\t\t\tAdaptor: device.Adaptor().Name(),\n\t\t\tCommands: []string{},\n\t\t})\n\t\tfor _, command := range device.Commands() {\n\t\t\tdevices[len(devices)-1].Commands = append(devices[len(devices)-1].Commands, command.Name)\n\t\t}\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 36.00052230258234}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL path\n\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\tname = strings.TrimSuffix(name, \"/devices\")\n\n\t// Check if a robot with the given name exists\n\trobot, ok := a.robots.Load(name)\n\tif !ok {\n\t\t// If the robot does not exist, return an error message\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"robot %s not found\", name),\n\t\t})\n\t\treturn\n\t}\n\n\t// Get the robot's devices\n\tdevices := robot.Devices()\n\n\t// Create a JSON response with the robot's devices\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 37.70793140821404}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimSpace(req.URL.Query().Get(\":name\"))\n\trobot := a.Robot(name)\n\tif robot == nil {\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"No robot named '%s' found\", name)))\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tdevices := []map[string]interface{}{}\n\tfor _, device := range robot.Devices() {\n\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\"Name\":        device.Name(),\n\t\t\t\"Type\":        device.Type(),\n\t\t\t\"Connections\": device.Connection().Name(),\n\t\t\t\"Commands\":    device.Commands(),\n\t\t})\n\t}\n\tres.Write([]byte(json.Marshal(devices)))\n}", "CodeBleu_score": 45.77801609452609}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\tname = strings.TrimSuffix(name, \"/connections\")\n\tif name == \"\" {\n\t\thttp.Error(res, \"no robot name specified\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif _, ok := a.robots[name]; !ok {\n\t\thttp.Error(res, \"robot '\"+name+\"' not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections := []map[string]interface{}{}\n\tfor _, conn := range a.robots[name].Connections() {\n\t\tconnections = append(connections, conn.Connection().(map[string]interface{}))\n\t}\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 40.963040570151655}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\tif _, ok := a.robots[name]; !ok {\n\t\thttp.Error(res, fmt.Sprintf(\"no robot with name '%s' found\", name), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tvar connections []map[string]interface{}\n\tfor _, conn := range a.robots[name].Connections() {\n\t\tconnections = append(connections, conn.Connection().(map[string]interface{}))\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 46.73267408764317}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tpath := strings.Split(req.URL.Path, \"/\")\n\tif len(path) != 4 {\n\t\tres.Write([]byte(\"404 - Not Found\n\"))\n\t\treturn\n\t}\n\n\trobot := a.robots.ByName(path[3])\n\tif robot == nil {\n\t\tres.Write([]byte(\"404 - Not Found\n\"))\n\t\treturn\n\t}\n\n\tconnections := []map[string]interface{}{}\n\tfor _, connection := range robot.Connections() {\n\t\tconnections = append(connections, connection.ToJSON())\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(json.Marshal(connections))\n}", "CodeBleu_score": 31.494780141127666}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot and device name from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\t// Check if the robot exists\n\tif _, ok := a.robots[robotName]; !ok {\n\t\t// If the robot does not exist, write an error message as a JSON response\n\t\ta.writeJSONError(res, fmt.Sprintf(\"Robot '%s' does not exist\", robotName))\n\t\treturn\n\t}\n\t// Check if the device exists\n\tif _, ok := a.robots[robotName].Devices[deviceName]; !ok {\n\t\t// If the device does not exist, write an error message as a JSON response\n\t\ta.writeJSONError(res, fmt.Sprintf(\"Device '%s' does not exist on robot '%s'\", deviceName, robotName))\n\t\treturn\n\t}\n\t// Get the command name from the URL query parameters\n\tcommandName := req.URL.Query().Get(\"command\")\n\t// Check if the command exists\n\tif _, ok := a.robots[robotName].Devices[deviceName].Commands[commandName]; !ok {\n\t\t// If the command does not exist, write an error message as a JSON response\n\t\ta.writeJSONError(res, fmt.Sprintf(\"Command '%s' does not exist on device '%s' on robot '%s'\", commandName, deviceName, robotName))\n\t\treturn\n\t}\n\t// Get the command arguments from the URL query parameters\n\tcommandArgs := req.URL.Query().Get(\"args\")\n\t// Check if the command arguments are valid JSON\n\tif commandArgs != \"\" {\n\t\tvar commandArgsMap map[string]interface{}\n\t\terr := json.Unmarshal([]byte(commandArgs), &commandArgsMap)\n\t\tif err != nil {\n\t\t\t// If the command arguments are not valid JSON, write an error message as a JSON response\n\t\t\ta.writeJSONError(res, fmt.Sprintf(\"Command arguments '%s' are not valid JSON\", commandArgs))\n\t\t\treturn\n\t\t}\n\t}\n\t// Execute the command on the device\n\terr := a.robots[robotName].Devices[deviceName].Commands[commandName].Run(commandArgsMap)\n\tif err != nil {\n\t\t// If", "CodeBleu_score": 49.36477861207262}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve the robot and device names from the URL query parameters\n\tparams := req.URL.Query()\n\trobotName := params.Get(\"robot\")\n\tdeviceName := params.Get(\"device\")\n\n\t// Check if the robot exists\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\t// The robot does not exist\n\t\t// Write the error message as a JSON response\n\t\ta.writeJSONResponse(res, http.StatusNotFound, fmt.Sprintf(\"robot '%s' does not exist\", robotName))\n\t\treturn\n\t}\n\n\t// Check if the device exists\n\tdevice, ok := robot.Devices[deviceName]\n\tif !ok {\n\t\t// The device does not exist\n\t\t// Write the error message as a JSON response\n\t\ta.writeJSONResponse(res, http.StatusNotFound, fmt.Sprintf(\"device '%s' does not exist\", deviceName))\n\t\treturn\n\t}\n\n\t// Retrieve the command name from the URL query parameters\n\tcommandName := params.Get(\"command\")\n\tif commandName == \"\" {\n\t\t// The command name is empty\n\t\t// Write the error message as a JSON response\n\t\ta.writeJSONResponse(res, http.StatusBadRequest, \"command name is empty\")\n\t\treturn\n\t}\n\n\t// Check if the command exists\n\tcommand, ok := device.Commands[commandName]\n\tif !ok {\n\t\t// The command does not exist\n\t\t// Write the error message as a JSON response\n\t\ta.writeJSONResponse(res, http.StatusNotFound, fmt.Sprintf(\"command '%s' does not exist\", commandName))\n\t\treturn\n\t}\n\n\t// Retrieve the command arguments from the URL query parameters\n\tvar commandArgs []interface{}\n\tfor _, commandArg := range params[\"arg\"] {\n\t\t// Convert the command argument to a float64\n\t\tcommandArgFloat64, err := command.NewArgument(commandArg)\n\t\tif err != nil {\n\t\t\t// The command argument is not a float64\n\t\t\t// Write the error message as a JSON response\n\t\t\ta.writeJSONResponse(res, http.StatusBadRequest, fmt.Sprintf(\"command argument '%s' is not a float64\", commandArg))\n\t\t\treturn\n\t\t}\n\n\t\t// Add the command argument to the list\n\t\tcommand", "CodeBleu_score": 44.55972976621927}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\t// Check if the robot exists.\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\t// If the robot does not exist, write the error message as a JSON response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": fmt.Sprintf(\"robot '%s' not found\", robotName)})\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tdevice, ok := robot.Devices[deviceName]\n\tif !ok {\n\t\t// If the device does not exist, write the error message as a JSON response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": fmt.Sprintf(\"device '%s' not found\", deviceName)})\n\t\treturn\n\t}\n\n\t// Execute the specified command on the device using the Gobot framework.\n\terr := device.Command(command)\n\tif err != nil {\n\t\t// If an error occurs while executing the command, write the error message as a JSON response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": fmt.Sprintf(\"error executing command '%s' on device '%s': %s\", command, deviceName, err)})\n\t\treturn\n\t}\n\n\t// Write a JSON response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(map[string]string{\"message\": fmt.Sprintf(\"executed command '%s' on device '%s'\", command, deviceName)})\n}", "CodeBleu_score": 46.30411086577554}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\t// If the header is empty, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the \"Authorization\" header into two parts: the type and the credentials.\n\t\t// If the header is not formatted correctly, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\tsplit := strings.SplitN(auth, \" \", 2)\n\t\tif len(split) != 2 || split[0] != \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the credentials from base64.\n\t\tdecoded, err := base64.StdEncoding.DecodeString(split[1])\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the decoded credentials into two parts: the username and the password.\n\t\t// If the decoded credentials are not formatted correctly, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\tsplit = strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(split) != 2 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password from the decoded credentials with the username and password specified in the function arguments.\n\t\t// If the usernames and passwords do not match, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\tif subtle", "CodeBleu_score": 47.12536524333091}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\t// If it doesn't exist, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the \"Authorization\" header value into two parts: the \"Basic\" prefix and the encoded credentials.\n\t\t// If the \"Basic\" prefix is not found, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\tconst prefix = \"Basic \"\n\t\tif !strings.HasPrefix(auth, prefix) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the encoded credentials.\n\t\t// If the decoding fails, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\tc, err := base64.StdEncoding.DecodeString(auth[len(prefix):])\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the decoded credentials into two parts: the username and the password.\n\t\t// If the username or password is empty, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\tcs := string(c)\n\t\ts := strings.IndexByte(cs, ':')\n\t\tif s < 0 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tu, p := cs[:s], cs[s+1:]\n\t\tif u == \"\" || p == \"\"", "CodeBleu_score": 46.81386410221317}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+r.URL.Path+`\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized\"))\n\t\t\treturn\n\t\t}\n\t\tif !strings.HasPrefix(auth, \"Basic \") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+r.URL.Path+`\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized\"))\n\t\t\treturn\n\t\t}\n\t\tauth = auth[6:]\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+r.URL.Path+`\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized\"))\n\t\t\treturn\n\t\t}\n\t\tauth = string(payload)\n\t\tif subtle.ConstantTimeCompare([]byte(auth), []byte(username+\":\"+password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+r.URL.Path+`\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized\"))\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 46.680763710199216}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the sensor supports analog reading\n\tif !a.AnalogSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"Analog reading is not supported by this sensor\")\n\t}\n\n\t// Read the raw sensor value\n\traw := a.AnalogRead()\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaled := a.scaleRawValue(raw)\n\n\t// Update the last read values\n\ta.lastRawValue = raw\n\ta.lastScaledValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 35.65921063915885}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tif !a.connection.AnalogReading() {\n\t\treturn 0, 0, fmt.Errorf(\"Analog reading not supported by this connection\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaledValue := float64(rawValue) * a.scaleFactor\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\ta.lastReadTime = time.Now()\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 55.35828739990467}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.Analog() {\n\t\treturn 0, 0, fmt.Errorf(\"Analog reading not supported\")\n\t}\n\n\traw := a.connection.Read()\n\tscaled := a.scale(raw)\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 31.975056673505986}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tgsd := &GroveSoundSensorDriver{\n\t\tname:         gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tanalogReader: a,\n\t\tpin:          pin,\n\t}\n\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase Option:\n\t\t\to(gsd)\n\t\t}\n\t}\n\n\treturn gsd\n}", "CodeBleu_score": 35.27371182267875}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tgsd := &GroveSoundSensorDriver{\n\t\tname:       gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tanalogPort: a,\n\t\tpin:        pin,\n\t}\n\n\tfor _, opt := range opts {\n\t\topt.(func(*GroveSoundSensorDriver))(gsd)\n\t}\n\n\tgsd.analogReader = NewAnalogSensorDriver(a)\n\tgsd.Add(gsd.analogReader)\n\n\treturn gsd\n}", "CodeBleu_score": 39.0995853729557}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tgsd := &GroveSoundSensorDriver{\n\t\tname:       gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tanalogPort: a,\n\t\tpin:        pin,\n\t}\n\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase string:\n\t\t\tgsd.name = o\n\t\tcase bool:\n\t\t\tgsd.active = o\n\t\t}\n\t}\n\n\tgsd.analogPort.AddListener(gsd)\n\treturn gsd\n}", "CodeBleu_score": 36.07091130409113}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write soft reset command\n\tif err := d.WriteRegister(CommandReg, SoftResetCommand); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the reset to complete\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Check the reset has completed\n\tstatus, err := d.ReadRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status&0x0800 != 0 {\n\t\treturn fmt.Errorf(\"Soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 68.42478468671735}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeCommand(PCD_SOFT_RESET)\n\ttime.Sleep(100 * time.Millisecond)\n\tif d.readRegister(PCD_COMMAND) != 0x00 {\n\t\treturn fmt.Errorf(\"failed to reset MFRC522\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 24.480941776494742}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tvar err error\n\n\t// Send the soft reset command\n\tif err = d.WriteRegister(CommandReg, PCD_SOFT_RESET); err != nil {\n\t\treturn err\n\t}\n\n\t// To be sure that the reset has been executed, we check the status\n\t// after the specified time.\n\ttime.Sleep(10 * time.Millisecond)\n\tstatus, err := d.ReadRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status&0x08 != 0 {\n\t\treturn fmt.Errorf(\"timeout waiting for PCD to initialize\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 57.93684623281305}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) != d.fifoDataLen {\n\t\treturn 0, fmt.Errorf(\"len(backData) != d.fifoDataLen\")\n\t}\n\n\t// Wait for the FIFO buffer to fill up\n\tfor {\n\t\tstatus, err := d.readRegister(mfrc522FifoLevelReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif status&0x7F > 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Now read the FIFO buffer\n\tvar i uint8\n\tfor i = 0; i < d.fifoDataLen; i++ {\n\t\tbyte, err := d.readRegister(mfrc522FifoDataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = byte\n\t}\n\n\t// Get the last bits received and return them\n\tlastBits, err := d.readRegister(mfrc522ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn lastBits, nil\n}", "CodeBleu_score": 49.769830185290445}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) != d.getFIFOLevel() {\n\t\treturn 0, fmt.Errorf(\"data length does not match number of bytes available in FIFO\")\n\t}\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], _ = d.readRegister(FIFODataReg)\n\t}\n\treturn d.readRegister(ControlReg)\n}", "CodeBleu_score": 24.459894070707165}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) != d.GetFIFOByteCount() {\n\t\treturn 0, fmt.Errorf(\"Incorrect byte length. Expecting %d, got %d\", d.GetFIFOByteCount(), len(backData))\n\t}\n\n\t// Check how many bytes are left in the FIFO buffer\n\tbyteCount, err := d.ReadRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// If byteCount is zero, don't do anything\n\tif byteCount == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// If byteCount is not zero, but backData is, return an error\n\tif len(backData) == 0 {\n\t\treturn 0, fmt.Errorf(\"Byte count is %d but backData is empty\", byteCount)\n\t}\n\n\t// Read the FIFO buffer into the provided byte slice\n\tfor i := range backData {\n\t\tbackData[i], err = d.ReadRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the last bits received\n\tbitsReceived, err := d.ReadRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn bitsReceived, nil\n}", "CodeBleu_score": 48.57236083782455}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"Halting PICC\")\n\t}\n\tcmd := []byte{PICC_CMD_HALT}\n\tcrc := d.calculateCRC(cmd[:])\n\tcmd = append(cmd, crc[0])\n\tcmd = append(cmd, crc[1])\n\tif d.transceive(cmd) != nil {\n\t\treturn ErrPICCHalt\n\t}\n\treturn nil\n}", "CodeBleu_score": 30.47022330173825}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Printf(\"halting PICC\n\")\n\t}\n\tif d.crc == nil {\n\t\treturn ErrNoCRC\n\t}\n\tcmd := []byte{PICC_HALT}\n\tcrc := d.crc.Calc(cmd[:])\n\tcmd = append(cmd, crc[:2]...)\n\t_, err := d.PCD_Transceive(cmd, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 30.316001226820788}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Printf(\"halting PICC\n\")\n\t}\n\tcommand := []byte{PICC_HALT}\n\tcrc := d.calculateCRC(command[:])\n\tcommand = append(command, crc[:])\n\tif d.debug {\n\t\tfmt.Printf(\"created PICC halt command % x\n\", command)\n\t}\n\terr := d.PCD_Communicate(command, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 25.5604792299795}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif d.debug {\n\t\tfmt.Printf(\"PICC_Read: 0x%02X\n\", block)\n\t}\n\n\tcommand := []byte{PICC_READ, byte(block)}\n\tcrc := d.calculateCRC(command[:2])\n\tcommand = append(command, crc)\n\n\tif d.debug {\n\t\tfmt.Printf(\"PCD_Transceive: % X\n\", command)\n\t}\n\n\tresponse, err := d.PCD_Transceive(command, 16)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif response[0] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"PCD_Transceive returned error code: %d\", response[0])\n\t}\n\n\tif d.debug {\n\t\tfmt.Printf(\"PCD_Transceive: % X\n\", response)\n\t}\n\n\treturn response[1:], nil\n}", "CodeBleu_score": 34.93880370020515}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar data = []byte{PICC_READ, byte(block)}\n\tcrc := d.crc(data[:2])\n\tdata = append(data, crc)\n\terr := d.PCD_Transceive(data, data[:17])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif data[0] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"piccRead: %s\", ErrToStr(data[0]))\n\t}\n\treturn data[1:17], nil\n}", "CodeBleu_score": 33.38883108821602}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif d.debug {\n\t\tfmt.Println(\"piccRead()\")\n\t}\n\n\t// Build a read command for the block.\n\tcommand := []byte{PICC_CMD_READ, byte(block)}\n\n\t// Calculate CRC for the command.\n\tcrc := d.calculateCRC(command[:2])\n\n\t// Add CRC to the command.\n\tcommand = append(command, crc)\n\n\t// Transmit the command.\n\tif d.debug {\n\t\tfmt.Printf(\"Sending: % X\n\", command)\n\t}\n\td.transceive(command)\n\n\t// Read the response.\n\tdata := make([]byte, 18)\n\tif d.debug {\n\t\tfmt.Printf(\"Reading: % X\n\", data)\n\t}\n\terr := d.read(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check that the response is 16 bytes long.\n\tif len(data) != 18 {\n\t\treturn nil, fmt.Errorf(\"piccRead() failed: Wrong number of bytes received.\")\n\t}\n\n\t// Check the CRC.\n\tif data[len(data)-2] != d.calculateCRC(data[:len(data)-2]) {\n\t\treturn nil, fmt.Errorf(\"piccRead() failed: Wrong CRC.\")\n\t}\n\n\t// Return the data.\n\treturn data[0:len(data)-2], nil\n}", "CodeBleu_score": 44.18045546300626}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn ErrBufferTooSmall\n\t}\n\t// Clear the bit mask for the request command.\n\td.ClearBitMask(BitMaskClearColl, 0x04)\n\t// Set the bit mask for the request command.\n\td.SetBitMask(reqMode, 0x04)\n\t// Anti collision\n\tif reqMode == TransmissionTypeAnticollision {\n\t\t// Set the bits for the CRC calculation.\n\t\td.SetBitMask(CRC_A, 0x08)\n\t}\n\t// Transmission of 7 bits in the last byte\n\tif reqMode == TransmissionTypeTransmissionLastBits {\n\t\t// Set the bits for the CRC calculation.\n\t\td.SetBitMask(CRC_A, 0x08)\n\t\t// Set the transmission mode to only 7 bits in the last byte.\n\t\td.SetBitMask(0x07, 0x10)\n\t}\n\t// Transmission of 4 bits in the last byte\n\tif reqMode == TransmissionTypeTransmissionLast4Bits {\n\t\t// Set the bits for the CRC calculation.\n\t\td.SetBitMask(CRC_A, 0x08)\n\t\t// Set the transmission mode to only 4 bits in the last byte.\n\t\td.SetBitMask(0x0F, 0x10)\n\t}\n\t// Send the request.\n\terr := d.PCD_TransceiveData(0x0C, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Check that the request was properly received.\n\tif (answer[0] & 0x0F) != reqMode+1 {\n\t\treturn ErrRequestNotReceived\n\t}\n\tif (answer[0] & 0x10) == 0x10 {\n\t\treturn ErrCollision\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.16633406660687}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn ErrBufferTooSmall\n\t}\n\n\td.ClearBitMask(CollReg, 0x80)\n\td.SetBitMask(TxControlReg, 0x03, 0x00)\n\n\tif reqMode != Transceive:\n\t\td.SetBitMask(TxControlReg, 0x03, 0x03)\n\n\terr := d.PCD_TransceiveData(reqMode, []byte{PICC_REQIDL}, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif (answer[0] & 0x10) != 0 {\n\t\td.SetBitMask(CollReg, 0x80)\n\t}\n\n\tif (answer[0] & 0x03) == 0x00 {\n\t\treturn ErrNoTag\n\t}\n\n\tif (answer[0] & 0x03) == 0x01 {\n\t\treturn ErrCollision\n\t}\n\n\tif (answer[0] & 0x03) == 0x02 {\n\t\treturn ErrProtocol\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.077908401963676}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn ErrBufferTooSmall\n\t}\n\n\terr := d.ClearBitMask(mfrc522CrcIRq, 0x3F)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.SetBitMask(mfrc522CommandReg, reqMode)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.AntennaOn()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.SetBitMask(mfrc522BitFramingReg, 0x80)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < 9; i++ {\n\t\t_, err = d.Request(0x00)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = d.AntennaOff()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.SetBitMask(mfrc522BitFramingReg, 0x00)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.SelectTag(0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.Request(0x26)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.AntennaOn()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.SetBitMask(mfrc522BitFramingReg, 0x80)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\t_, err = d.Request(0x00)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = d.AntennaOff()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.SetBitMask(mfrc522BitFramingReg, 0x00)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.SelectTag(0)", "CodeBleu_score": 46.535469117037074}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.Write(d.stepPinHigh)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\terr = d.stepPin.Write(d.stepPinLow)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.stepDirection {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 63.80098882875696}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.direction == CW {\n\t\td.stepNum += 1\n\t} else {\n\t\td.stepNum -= 1\n\t}\n\n\tif d.stepNum > d.numSteps {\n\t\td.stepNum = 1\n\t} else if d.stepNum < 1 {\n\t\td.stepNum = d.numSteps\n\t}\n\n\tif err := d.stepPin.Write(d.stepPinHigh); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\tif err := d.stepPin.Write(d.stepPinLow); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 55.97090296438284}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.Write(gobot.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.delay)\n\terr = d.stepPin.Write(gobot.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == gobot.Forward {\n\t\td.stepNum++\n\t} else {\n\t\td.stepNum--\n\t}\n\treturn nil\n}", "CodeBleu_score": 67.25075594621632}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorRunning = true\n\n\td.distanceMonitorStopChan = make(chan bool)\n\td.distanceMonitorWaitGroup = new(sync.WaitGroup)\n\n\tgo func() {\n\t\td.distanceMonitorWaitGroup.Add(1)\n\t\tdefer d.distanceMonitorWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tstart := time.Now()\n\t\t\t\terr := d.readDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tgobot.Error(err)\n\t\t\t\t}\n\t\t\t\telapsed := time.Since(start)\n\t\t\t\ttime.Sleep(d.distanceMonitorInterval - elapsed)\n\t\t}\n\t}()\n\n\treturn nil\n}\n\n", "CodeBleu_score": 53.83563750052587}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorRunning = true\n\td.stopDistanceMonitor = make(chan bool)\n\td.distanceMonitorWaitGroup = new(sync.WaitGroup)\n\td.distanceMonitorWaitGroup.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}", "CodeBleu_score": 34.950640203252036}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"Distance monitor already running\")\n\t}\n\n\td.distanceMonitorRunning = true\n\td.distanceMonitorStop = make(chan bool)\n\td.distanceMonitorWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorWaitGroup.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}", "CodeBleu_score": 35.320051780565834}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, val time.Duration, name string, eventID uint32, eventVal uint32) {\n\t\tif name == \"gpio_rising_edge\" {\n\t\t\td.start = time.Now()\n\t\t} else if name == \"gpio_falling_edge\" {\n\t\t\tduration := time.Now().Sub(d.start)\n\t\t\td.distance = duration * d.speedOfSound\n\t\t\td.start = time.Now()\n\t\t\td.distanceChan <- d.distance\n\t\t}\n\t}\n}", "CodeBleu_score": 36.38646417936428}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(gpio int, level time.Duration, _ string, _ uint32, _ uint32) {\n\t\tif gpio == d.pin {\n\t\t\tif level == gobot.RisingEdge {\n\t\t\t\td.start = time.Now()\n\t\t\t} else if level == gobot.FallingEdge {\n\t\t\t\td.duration = time.Since(d.start)\n\t\t\t\td.start = time.Time{}\n\t\t\t\td.mutex.Lock()\n\t\t\t\td.events <- d.duration\n\t\t\t\td.mutex.Unlock()\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.45142222926112}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(gpio int, value time.Duration, name string, pin uint32, eventID uint32) {\n\t\tif value == 1 {\n\t\t\td.startTimestamp = time.Now()\n\t\t} else {\n\t\t\td.duration = time.Since(d.startTimestamp)\n\t\t\td.startTimestamp = time.Time{}\n\t\t\td.durationChan <- d.duration\n\t\t}\n\t}\n}", "CodeBleu_score": 35.95782562354851}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\td.sensor.Trigger()\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.sensor.Echo():\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout while waiting for echo\")\n\t}\n\n\t// Get the time of flight in microseconds\n\td.timeOfFlight = d.sensor.Microseconds()\n\n\treturn nil\n}", "CodeBleu_score": 37.18974549976658}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor\n\tif _, err := d.sensor.Write([]byte{0x5}); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measurementComplete:\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timed out while waiting for measurement to complete\")\n\t}\n}", "CodeBleu_score": 49.464503029576896}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access\n\td.mutex.Lock()\n\t// Trigger the sensor\n\td.sensor.Trigger()\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.sensor.Echo():\n\t\t// The measurement is successful, store the measured time in microseconds\n\t\td.time = time.Now()\n\tcase <-time.After(d.timeout):\n\t\t// A timeout occurred, return an error\n\t\td.mutex.Unlock()\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n\t// Unlock the measurement mutex\n\td.mutex.Unlock()\n\treturn nil\n}", "CodeBleu_score": 34.86322775548045}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if self.is_token_expired():\n        self.refresh_access_token()\n    elif self.get_access_token():\n        return self.get_access_token()\n    raise PlatformioException(\n        \"You are not logged in. Please log in to PIO Account using PlatformIO CLI `pio account login` command.\"\n    )\n\n", "CodeBleu_score": 16.480588724105452}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.token:\n        return self.token\n    if self.state.get(\"access_token\") and self.state.get(\"expires_at\"):\n        if self.state[\"expires_at\"] > int(time.time()):\n            self.token = self.state[\"access_token\"]\n            return self.token\n    if self.state.get(\"refresh_token\"):\n        try:\n            data = __accounts_api__.refresh_token(self.state[\"refresh_token\"])\n            self.state.update(\n                {\n                    \"access_token\": data[\"access_token\"],\n                    \"expires_at\": int(time.time()) + data[\"expires_in\"],\n                }\n            )\n            self.token = data[\"access_token\"]\n            return self.token\n        except HTTPClientError as e:\n            if e.status == 401:\n                self.state.pop(\"access_token\")\n                self.state.pop(\"expires_at\")\n                self.state.pop(\"refresh_token\")\n    raise PlatformioException(\n        \"You are not logged in. Please log in to PIO Account using PlatformIO Account \"\n        \"page: https://account.platformio.org.", "CodeBleu_score": 39.15697150457756}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.token:\n        return self.token\n    if self.refresh_token:\n        if self.refresh_token_expire > time.time():\n            try:\n                self.token = __accounts_api__.fetch_authentication_token(\n                    self.refresh_token\n                )\n                self.save_state()\n                return self.token\n            except (PlatformioException, HTTPClientError) as e:\n                app.log.error(e)\n        self.refresh_token = None\n        self.save_state()\n\n    raise UserSideException(\n        \"You are not authorized. Please log in to PIO Account via PlatformIO IDE Menu: PlatformIO > Account or via PIO Home > Account.\"\n    )\n\n", "CodeBleu_score": 29.406162756185378}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_session_var(\"refresh_token\")\n        if not refresh_token:\n            raise UserSideException(\n                \"You are not logged in. Please log in to PIO Account using `pio account login` command\"\n            )\n        self.delete_session_var(\"refresh_token\")\n        self.delete_session_var(\"access_token\")\n        self.delete_session_var(\"access_token_expire\")\n        self.delete_session_var(\"account_username\")\n        self.delete_session_var(\"account_email\")\n        self.delete_session_var(\"account_profile_picture\")\n        self.delete_session_var(\"account_profile_url\")\n        self.delete_session_var(\"account_profile_id\")\n        self.delete_session_var(\"account_profile_username\")\n        self.delete_session_var(\"account_profile_display_name\")\n        self.delete_session_var(\"account_profile_description\")\n        self.delete_session_var(\"account_profile_company\")\n        self.delete_session_var(\"account_profile_location\")\n        self.delete_session_var(\"account_profile_public_repos\")\n        self.delete_session_var(\"account_profile_followers\")\n        self.delete_session_var(\"account_profile_following\")\n        self.delete_session_var(\"account_profile_created_at\")\n        self.delete_session_var(\"account_profile_updated_at\")\n        self.delete_session_var(\"account_profile_website_url\")\n        self.delete_session_var(\"account_profile_blog_url\")\n        self.delete_session_var(\"account_profile_twitter_username\")\n        self.delete_session_var(\"account_profile_is_hireable\")\n        self.delete_session_var(\"account_profile_is_verified\")\n        self.delete_session_var(\"account_profile_total_private_repos\")\n        self.delete_session_var(\"account_profile_owned_private_repos\")\n        self.delete_session_var(\"account_profile_private_gists\")\n        self.delete_session_var(\"account_profile_disk_usage\")\n        self.delete_session_var(\"account_profile_collaborators\")\n        self.delete_session_var", "CodeBleu_score": 26.791991801448468}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.session.get(\"refresh_token\")\n        if not refresh_token:\n            return False\n        self.session.delete()\n        with HTTPClient() as client:\n            try:\n                client.fetch(\n                    \"%s/v1/logout\" % __accounts_api__,\n                    method=\"POST\",\n                    data={\"refresh_token\": refresh_token},\n                )\n            except HTTPClientError:\n                pass\n        return True\n    except Exception as e:\n        raise UserSideException(e)\n\n", "CodeBleu_score": 51.18907818829079}, {"code": "def logout(self)\n\t\n    try:\n        self._refresh_token = self.get_state_item(\"refresh_token\")\n        if not self._refresh_token:\n            raise UserSideException(\n                \"You are not logged in. Please log in to perform this action.\"\n            )\n        self.delete_state_item(\"refresh_token\")\n        self.delete_state_item(\"access_token\")\n        self.delete_state_item(\"expires_in\")\n        self.delete_state_item(\"account_id\")\n        self.delete_state_item(\"account_username\")\n        self.delete_state_item(\"account_email\")\n        self.delete_state_item(\"account_name\")\n        self.delete_state_item(\"account_org_name\")\n        self.delete_state_item(\"account_org_id\")\n        self.delete_state_item(\"account_org_role\")\n        self.delete_state_item(\"account_profile_name\")\n        self.delete_state_item(\"account_profile_id\")\n        self.delete_state_item(\"account_profile_role\")\n        self.delete_state_item(\"account_profile_org_id\")\n        self.delete_state_item(\"account_profile_org_name\")\n        self.delete_state_item(\"account_profile_org_role\")\n        self.delete_state_item(\"account_profile_org_username\")\n        self.delete_state_item(\"account_profile_org_email\")\n        self.delete_state_item(\"account_profile_org_member_type\")\n        self.delete_state_item(\"account_profile_org_member_id\")\n        self.delete_state_item(\"account_profile_org_member_email\")\n        self.delete_state_item(\"account_profile_org_member_username\")\n        self.delete_state_item(\"account_profile_org_member_name\")\n        self.delete_state_item(\"account_profile_org_member_org_id\")\n        self.delete_state_item(\"account_profile_org_member_org_name\")\n        self.delete_state_item(\"account_profile_org_member_org_role\")\n        self.delete_state_item(\"account_profile_org_member_profile_id\")\n        self.delete_state_item(\"account_profile", "CodeBleu_score": 26.497688369125516}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for p in self.packages:\n        if p.metadata.spec.external:\n            packages.append(\n                {\n                    \"name\": p.metadata.name,\n                    \"version\": p.metadata.version,\n                    \"url\": p.metadata.spec.url,\n                }\n            )\n        elif not p.metadata.spec.optional:\n            packages.append(\n                {\"name\": p.metadata.name, \"version\": p.metadata.version}\n            )\n    return packages\n\n", "CodeBleu_score": 27.24941166810534}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for p in self.get_packages():\n        if p.metadata.spec.optional:\n            continue\n        if p.metadata.spec.external:\n            packages.append(\n                {\n                    \"name\": p.metadata.name,\n                    \"version\": p.metadata.version,\n                    \"external\": p.metadata.spec.external_url,\n                }\n            )\n        else:\n            packages.append(\n                {\"name\": p.metadata.name, \"version\": p.metadata.version}\n            )\n    return packages\n\n", "CodeBleu_score": 29.05352310706244}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, pkg in self.get_installed().items():\n        if not pkg.metadata.spec.optional:\n            result.append(\n                {\n                    \"name\": name,\n                    \"version\": pkg.metadata.version,\n                    \"spec\": str(pkg.metadata.spec),\n                }\n            )\n            if pkg.metadata.spec.external:\n                result[-1][\"url\"] = pkg.metadata.spec.url\n    return result\n\n", "CodeBleu_score": 37.874935250626194}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    assert isinstance(env, str)\n    assert isinstance(targets, list) or targets is None\n    assert isinstance(autoinstall, bool)\n\n    project_config = ProjectConfig.get_instance()\n    if env not in project_config.envs():\n        raise UndefinedEnvPlatformError(env)\n\n    try:\n        platform_name = project_config.get(env, \"platform\")\n    except KeyError:\n        raise UndefinedEnvPlatformError(env)\n\n    try:\n        platform_manifest = base.get_platform_manifest(platform_name)\n    except UnknownPlatform as e:\n        raise UndefinedEnvPlatformError(env) from e\n\n    cls = load_python_module(\"platformio.platform.%s\" % platform_name,\n                             os.path.join(platform_manifest['package_dir'],\n                                          \"platform.py\"))\n    obj = cls(platform_manifest['title'], platform_manifest['version'])\n\n    obj.set_project_config(project_config)\n    obj.set_env_name(env)\n    obj.set_auto_install(autoinstall)\n    obj.configure_project_packages(env, targets)\n    return obj\n\n", "CodeBleu_score": 35.610577701063086}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    config = ProjectConfig.get_instance()\n    env_options = config.items(env=env, as_dict=True)\n    if \"platform\" not in env_options:\n        raise UndefinedEnvPlatformError(env)\n    platform = env_options[\"platform\"]\n    if not cls.get_platformnames(platform):\n        raise UnknownPlatform(platform)\n    cls.configure_project_packages(env, targets)\n    return cls(env_options, autoinstall=autoinstall)\n\n", "CodeBleu_score": 37.337911174825145}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not env:\n        raise ValueError(\"Environment name is not specified\")\n    config = ProjectConfig.get_instance()\n    try:\n        env_options = config.items(env, as_dict=True)\n    except KeyError:\n        raise UndefinedEnvPlatformError(env)\n    platform = env_options.get(\"platform\")\n    if not platform:\n        raise UndefinedEnvPlatformError(env)\n    try:\n        platform_manifest = load_python_module(\n            \"platformio.platforms.%s\" % platform, \"platform.json\"\n        )\n    except ImportError:\n        raise UnknownPlatform(platform)\n    if not targets:\n        targets = env_options.get(\"targets\")\n    if not targets:\n        targets = platform_manifest.default_targets\n    if not isinstance(targets, list):\n        targets = [targets]\n    if not all([re.match(\"^[a-zA-Z0-9_-]+$\", t) for t in targets]):\n        raise ValueError(\"Invalid target(s): %s\" % \", \".join(targets))\n    cls.validate_targets(targets)\n    platform_cls = base.get_platform_class(platform)\n    return cls(\n        platform_manifest,\n        env,\n        targets,\n        autoinstall=autoinstall,\n        project_config=config,\n    )\n\n", "CodeBleu_score": 37.55611795499184}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tuint8_t i = 0;\n\twhile (Wire.available()) {\n\t\tBuff[i] = Wire.read();\n\t\ti++;\n\t}\n}", "CodeBleu_score": 53.035362025565135}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tuint8_t i;\n\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tfor (i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 64.15324056446788}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tuint8_t i = 0;\n\twhile (Wire.available()) {\n\t\tBuff[i] = Wire.read();\n\t\ti++;\n\t}\n}", "CodeBleu_score": 53.035362025565135}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tWrite(REG_TIMER_CTL, Read(REG_TIMER_CTL) | BIT_TIMER_CTL_ENABLE | BIT_TIMER_CTL_SLEEP_MODE | BIT_TIMER_CTL_POWER_OFF_ENABLE);\n\t\tWrite(REG_TIMER_TARGET, time_in_us);\n\t} else {\n\t\tWrite(REG_TIMER_CTL, Read(REG_TIMER_CTL) & ~(BIT_TIMER_CTL_ENABLE | BIT_TIMER_CTL_SLEEP_MODE | BIT_TIMER_CTL_POWER_OFF_ENABLE));\n\t}\n\tWrite(REG_POWER_CTL, Read(REG_POWER_CTL) | BIT_POWER_CTL_SLEEP);\n\tif (time_in_us > 0) {\n\t\tdelay(time_in_us / 1000 + 1);\n\t} else {\n\t\tdelay(10);\n\t}\n\tWrite(REG_POWER_CTL, Read(REG_POWER_CTL) & ~(BIT_POWER_CTL_SLEEP));\n}", "CodeBleu_score": 54.13222311666548}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep(true);\n\tif (time_in_us > 0) {\n\t\tSetTimer(true, time_in_us);\n\t} else {\n\t\tSetTimer(false, 0);\n\t}\n\taxp192_deep_sleep();\n}", "CodeBleu_score": 37.00509270537775}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\taxp192_set_timer(time_in_us);\n\t} else {\n\t\taxp192_disable_timer();\n\t}\n\taxp192_enable_exten(true);\n\taxp192_enable_adc(false);\n\taxp192_enable_power(false);\n\taxp192_enable_exten(false);\n\taxp192_enable_ldo2(false);\n\taxp192_enable_ldo3(false);\n\taxp192_enable_ldo4(false);\n\taxp192_enable_ldo3(false);\n\taxp192_enable_ldo4(false);\n\taxp192_enable_gpio0(false);\n\taxp192_enable_gpio1(false);\n\taxp192_enable_gpio2(false);\n\taxp192_enable_gpio3(false);\n\taxp192_enable_gpio4(false);\n\taxp192_enable_gpio5(false);\n\taxp192_enable_gpio6(false);\n\taxp192_enable_gpio7(false);\n\taxp192_enable_gpio8(false);\n\taxp192_enable_gpio9(false);\n\taxp192_enable_gpio10(false);\n\taxp192_enable_gpio11(false);\n\taxp192_enable_gpio12(false);\n\taxp192_enable_gpio13(false);\n\taxp192_enable_gpio14(false);\n\taxp192_enable_gpio15(false);\n\taxp192_enable_gpio16(false);\n\taxp192_enable_gpio17(false);\n\taxp192_enable_gpio18(false);\n\taxp192_enable_gpio19(false);\n\taxp192_", "CodeBleu_score": 44.9506505300586}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tuint16_t y_start = tft.get_scroll_y();\n\ttft.fill_rect(0, y_start, tft.width(), tft.height() - y_start, color);\n\tif (y_start == tft.height() - tft.height() / 8) {\n\t\ty_start = tft.height() - tft.height() / 8;\n\t\ttft.fill_rect(0, y_start, tft.width(), tft.height() - y_start, color);\n\t}\n\telse {\n\t\ty_start += tft.height() / 8;\n\t}\n\ttft.set_scroll_y(y_start);\n\treturn y_start;\n}", "CodeBleu_score": 19.44389443199049}, {"code": "int Display::scroll_line(uint32_t color){\n\t\t// Store current scroll address\n\tuint32_t scroll_address = tte_get_scroll_address();\n\n\t// Scroll one line\n\ttte_set_scroll(scroll_address, scroll_address + 160, 0);\n\n\t// Fill new line\n\tfor (int i = 0; i < 160; i++) {\n\t\ttte_write_cmd(TTE_COLOR_RGB | color);\n\t\ttte_write_cmd(TTE_VERTEX2F(i, 159));\n\t}\n\n\t// Update scroll address and return previous value\n\treturn tte_set_scroll(scroll_address, scroll_address + 160, 1);\n}", "CodeBleu_score": 12.044564482084184}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y_start = scroll_address.y;\n\tscroll_address.y += text_line_height;\n\tif (scroll_address.y > (display_height - bottom_fixed_area_height)) {\n\t\tscroll_address.y = y_start;\n\t\tif (tteBar) {\n\t\t\tscroll_address.y = display_height - bottom_fixed_area_height;\n\t\t}\n\t}\n\ttft.fillRect(0, y_start, display_width, text_line_height, color);\n\tupdate_scroll_address();\n\treturn y_start;\n}", "CodeBleu_score": 19.33578439900334}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!setAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\tif (!setSSIDs(ssids)) {\n\t\treturn false;\n\t}\n\n\treturn startPortal();\n}", "CodeBleu_score": 53.38135717166534}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// Set up access points\n\tif (!set_access_points(access_points)) {\n\t\treturn false;\n\t}\n\n\t// Set up HTML content\n\tif (!set_html_content(ssids)) {\n\t\treturn false;\n\t}\n\n\t// Start the portal\n\tportal.begin();\n\n\treturn true;\n}", "CodeBleu_score": 54.49606718561508}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// Initialize the WiFi module\n\tWiFi.mode(WIFI_AP_STA);\n\tWiFi.softAP(\"EvilPortal\", WIFI_PASSWORD);\n\n\t// Set up access points\n\tif (!setAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\t// Set up HTML content\n\tif (!setHTML(ssids)) {\n\t\treturn false;\n\t}\n\n\t// Start the portal\n\tportal.begin();\n\tportal.onNotFound(handleNotFound);\n\tportal.onWifi(handleWifi);\n\tportal.onAp(handleAp);\n\tportal.onRequest(handleRequest);\n\tportal.onWebsocket(handleWebsocket);\n\tportal.onClient(handleClient);\n\tportal.onUpload(handleUpload);\n\tportal.onBody(handleBody);\n\tportal.onSave(handleSave);\n\tportal.onLoad(handleLoad);\n\tportal.onDisconnect(handleDisconnect);\n\n\treturn true;\n}", "CodeBleu_score": 44.96923181625843}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (!queue_enabled_flag) {\n\t\tqueue_enabled_flag = true;\n\t\tqueue.flush();\n\t\ttext.clear();\n\t\ttext_in.clear();\n\t}\n}", "CodeBleu_score": 6.440150170101027}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag == false) {\n\t\t//if the queue is not enabled, initialize the queue\n\t\tqueue_enabled_flag = true;\n\t\tgps_queue = xQueueCreate(QUEUE_SIZE, sizeof(gps_data_t));\n\t\ttext = (char *)malloc(sizeof(char) * TEXT_SIZE);\n\t\ttext_in = (char *)malloc(sizeof(char) * TEXT_SIZE);\n\t}\n\telse {\n\t\t//if the queue is enabled, flush the queue\n\t\tflush_queue();\n\t}\n}", "CodeBleu_score": 12.169006513994747}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag == false) {\n\t\tgps_queue.flush();\n\t\tgps_text = \"\";\n\t\tgps_text_in = \"\";\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 7.009522537335523}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea != NULL) {\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new QueueNmea();\n}", "CodeBleu_score": 33.95008815128904}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (nmea_queue) {\n\t\tdelete nmea_queue;\n\t}\n\tnmea_queue = new Queue<String>(10);\n}", "CodeBleu_score": 34.300528534737126}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea != NULL) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = NULL;\n\t}\n\tqueue_nmea = new QueueNmea();\n}", "CodeBleu_score": 35.05353451618662}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint32_t w = (area->x2 - area->x1 + 1);\n\tuint32_t h = (area->y2 - area->y1 + 1);\n\tuint32_t x = area->x1;\n\tuint32_t y = area->y1;\n\tuint32_t size = w * h;\n\tuint32_t size_in_bytes = size * sizeof(lv_color_t);\n\tuint32_t i = 0;\n\tuint32_t j = 0;\n\n\t/* In the flush function we need to convert the coordinates of the area to the display coordinates */\n\t/* The coordinates of the area are relative to the display */\n\t/* The coordinates of the display are relative to the driver */\n\t/* So we need to convert the area coordinates to the display coordinates */\n\tx += disp->hor_res;\n\ty += disp->ver_res;\n\n\t/* In the flush function we need to convert the color buffer to the display color format */\n\t/* The color format of the display is different from the color format of the color buffer */\n\t/* So we need to convert the color buffer color format to the display color format */\n\n\t/* Iterate through each pixel in the area */\n\tfor (i = 0; i < size; i++) {\n\t\t/* Convert the coordinates of the pixel to the display coordinates */\n\t\tx--;\n\t\ty--;\n\n\t\t/* Set the address window to the current pixel */\n\t\tili9341_set_window(x, y, x, y);\n\n\t\t/* Write the color of the pixel to the display */\n\t\tili9341_write_pixels(1, &color_p[i]);\n\t}\n\n\t/* After updating the area, we need to inform the graphics library that the flush is complete */\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 46.90726354556811}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\t///*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n\t///*It is quite slow and should be only used for debugging*/\n\t//int32_t x;\n\t//int32_t y;\n\t//for(y = area->y1; y <= area->y2; y++) {\n\t//\tfor(x = area->x1; x <= area->x2; x++) {\n\t//\t\tdisp_drv.draw_px(x, y, *color_p);\n\t//\t\tcolor_p++;\n\t//\t}\n\t//}\n\n\t/*In this example `disp_drv.draw_px` is just a very small function which only writes one pixel to the screen*/\n\t/*It should be replaced by your own function which writes the pixel to the display*/\n\tint32_t x;\n\tint32_t y;\n\tfor(y = area->y1; y <= area->y2; y++) {\n\t\tfor(x = area->x1; x <= area->x2; x++) {\n\t\t\tdisp_drv.draw_px(x, y, *color_p);\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\n\t/* IMPORTANT!!!\n\t * Inform the graphics library that you are ready with the flushing*/\n\tdisp_drv.flush_cb(disp, area, color_p);\n}", "CodeBleu_score": 40.17695127419621}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n#if LV_USE_GPU\n    /*The GPU interface is not used in this example.\n     *But it is required to use the GPU.\n     *It can be enabled in lv_conf.h\n     */\n    lv_disp_flush_ready(disp);\n#else\n\n    /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n    for(int32_t y = area->y1; y <= area->y2 && y < MY_DISP_HOR_RES; y++) {\n        for(int32_t x = area->x1; x <= area->x2 && x < MY_DISP_VER_RES; x++) {\n            /* Put a pixel to the screen. The parameters are\n             * 1. (x, y) coordinates\n             * 2. a color\n             * 3. a mask: only pixels with this mask will be drawn\n             *    (if the mask is 0 the pixel will be fully drawn)\n             */\n            lv_disp_draw_px(disp, x, y, *color_p, LV_OPA_COVER);\n\n            /* Go to the next pixel */\n            color_p++;\n        }\n    }\n\n    /* IMPORTANT!\n     * Inform the system that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n#endif\n}", "CodeBleu_score": 43.53510544847662}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->size; i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tprintf(\"  \");\n\t\t}\n\t\tprintf(\"%s\n\", menu->menuItems[i].name);\n\t}\n\tprintf(\"\n\");\n}", "CodeBleu_score": 48.78617848143369}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < menu->size(); i++) {\n\t\tif (menu->at(i) == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tprintf(\"    \");\n\t\t}\n\n\t\tprintf(\"%s\n\", menu->at(i)->getName().c_str());\n\n\t\tshowMenuList(menu->at(i), layer + 1);\n\t}\n\n\tprintf(\"\n\");\n}", "CodeBleu_score": 47.6874638676419}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu != nullptr) {\n\t\tfor (int i = 0; i < menu->get_menu_size(); i++) {\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tstd::cout << \"    \";\n\t\t\t}\n\t\t\tstd::cout << menu->get_menu_node(i).get_name() << std::endl;\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n}", "CodeBleu_score": 49.32590796579698}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint num = 0;\n\tfor(i = 0; i < count; i++) {\n\t\tchar ssid[7];\n\t\tchar mac[18];\n\t\tchar channel[3];\n\t\tint j;\n\t\tfor(j = 0; j < 6; j++) {\n\t\t\tssid[j] = random(97, 122);\n\t\t}\n\t\tssid[6] = '\\0';\n\t\tfor(j = 0; j < 6; j++) {\n\t\t\tmac[j*2] = random(48, 57);\n\t\t\tmac[j*2+1] = random(97, 102);\n\t\t}\n\t\tmac[12] = ':';\n\t\tmac[13] = random(48, 57);\n\t\tmac[14] = random(48, 57);\n\t\tmac[15] = random(48, 57);\n\t\tmac[16] = random(48, 57);\n\t\tmac[17] = '\\0';\n\t\tfor(j = 0; j < 2; j++) {\n\t\t\tchannel[j] = random(48, 57);\n\t\t}\n\t\tchannel[2] = '\\0';\n\t\tWiFi.softAP(ssid, mac, channel, 0, 0);\n\t\tSerial.println(ssid);\n\t\tnum++;\n\t}\n\treturn num;\n}", "CodeBleu_score": 39.09361979878365}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint l = 0;\n\tint m = 0;\n\tint n = 0;\n\tint o = 0;\n\tint p = 0;\n\tint q = 0;\n\tint r = 0;\n\tint s = 0;\n\tint t = 0;\n\tint u = 0;\n\tint v = 0;\n\tint w = 0;\n\tint x = 0;\n\tint y = 0;\n\tint z = 0;\n\tint a = 0;\n\tint b = 0;\n\tint c = 0;\n\tint d = 0;\n\tint e = 0;\n\tint f = 0;\n\tint g = 0;\n\tint h = 0;\n\tint i1 = 0;\n\tint j1 = 0;\n\tint k1 = 0;\n\tint l1 = 0;\n\tint m1 = 0;\n\tint n1 = 0;\n\tint o1 = 0;\n\tint p1 = 0;\n\tint q1 = 0;\n\tint r1 = 0;\n\tint s1 = 0;\n\tint t1 = 0;\n\tint u1 = 0;\n\tint v1 = 0;\n\tint w1 = 0;\n\tint x1 = 0;\n\tint y1 = 0;\n\tint z1 = 0;\n\tint a1 = 0;\n\tint b1 = 0;\n\tint c1 = 0;\n\tint d1 = 0;\n\tint e1 = 0;\n\tint f1 = 0;\n\tint g1 = 0;\n\tint h1 = 0;\n\tint i2 = 0;\n\tint j2 = 0;\n\tint k2 = 0;\n\tint l2 = 0;\n\tint m2 = 0;\n\tint n2 = 0;\n\tint o2 = 0;\n\tint p2 = 0", "CodeBleu_score": 5.4068798354365155}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint j;\n\tint k;\n\tint channel;\n\tint mac[6];\n\tchar ssid[7];\n\tint ssidCount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tmac[j] = rand() % 256;\n\t\t}\n\t\tchannel = rand() % 15;\n\t\tfor (k = 0; k < 6; k++) {\n\t\t\tssid[k] = rand() % 256;\n\t\t}\n\t\tssid[6] = 0;\n\t\tssidCount++;\n\t\tSerial.print(F(\"SSID \"));\n\t\tSerial.print(ssidCount);\n\t\tSerial.print(F(\": \"));\n\t\tSerial.print(ssid);\n\t\tSerial.print(F(\" (\"));\n\t\tSerial.print(channel);\n\t\tSerial.print(F(\") \"));\n\t\tSerial.print(mac[0], HEX);\n\t\tSerial.print(mac[1], HEX);\n\t\tSerial.print(mac[2], HEX);\n\t\tSerial.print(mac[3], HEX);\n\t\tSerial.print(mac[4], HEX);\n\t\tSerial.print(mac[5], HEX);\n\t\tSerial.println();\n\t\taddSSID(ssid, mac, channel);\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 40.82170549494357}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    # Initialize a Publisher client.\n    publisher = pubsub_v1.PublisherClient()\n    # The `topic_path` method creates a fully qualified identifier\n    # in the form `projects/{project_id}/topics/{topic_name}`\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic.\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 47.407721850208304}, {"code": "def create_topic(project_id, topic_name)\n\t\n    # Imports the Google Cloud client library\n    from google.cloud import pubsub_v1\n\n    # Initializes a Publisher client\n    publisher = pubsub_v1.PublisherClient()\n\n    # The `topic_path` method creates a fully qualified identifier\n    # in the form `projects/{project_id}/topics/{topic_name}`\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Creates the topic\n    topic = publisher.create_topic(topic_path)\n\n    # The `topic` object is a Topic; if not canceled, the topic\n    # is already exists and its information is displayed\n    print(f\"Created topic: {topic.name}\")\n    return topic\n\n", "CodeBleu_score": 76.0250511046093}, {"code": "def create_topic(project_id, topic_name)\n\t\n    # Imports the Google Cloud client library\n    from google.cloud import pubsub_v1\n\n    # Initializes a Publisher client\n    publisher = pubsub_v1.PublisherClient()\n\n    # The `topic_path` method creates a fully qualified identifier\n    # in the form `projects/{project_id}/topics/{topic_name}`\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Creates the topic\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Created topic: {topic}\")\n\n", "CodeBleu_score": 77.71720929359269}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 72.75104479961406}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        'iat': datetime.datetime.utcnow(),\n        # The time the token expires.\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        # The audience field should always be set to the GCP project id.\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 76.4527720693834}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        'iat': datetime.datetime.utcnow(),\n        # The time the token expires.\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        # The audience field should always be set to the GCP project id.\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 76.4527720693834}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload)\n    topic = message.topic\n    qos = str(message.qos)\n    if payload == \"on\":\n        print(\"Received message '\" + str(payload) + \"' on topic '\" + str(topic) + \"' with QoS \" + str(qos))\n        capture_image()\n        upload_image()\n        publish_image()\n    else:\n        print(\"Received message '\" + str(payload) + \"' on topic '\" + str(topic) + \"' with QoS \" + str(qos))\n\n", "CodeBleu_score": 21.281262367099906}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\"utf-8\"))\n    topic = message.topic\n    qos = message.qos\n    print(\"Received message '\" + str(payload) + \"' on topic '\" + str(topic) + \"' with QoS \" + str(qos))\n    if payload == \"on\":\n        # Capture a preview image\n        os.system(\"fswebcam -d /dev/video0 -r 1280x720 -S 30 /home/pi/Desktop/image.jpg\")\n        # Upload the file to the specified bucket\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket(\"bucket_name\")\n        blob = bucket.blob(\"image.jpg\")\n        blob.upload_from_filename(\"/home/pi/Desktop/image.jpg\")\n        # Publish the file's URL to an MQTT event topic\n        client.publish(\"events/image\", \"https://storage.cloud.google.com/bucket_name/image.jpg\")\n    else:\n        print(\"off\")\n", "CodeBleu_score": 33.90636406535072}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload)\n    topic = message.topic\n    qos = message.qos\n    if payload == \"on\":\n        # Capture and upload a preview image\n        os.system(\n            \"raspistill -o preview.jpg -w 1280 -h 720 -t 1000 -tl 500 -bm -ex antishake -ss 1000000 -awb off -mm average -q 100\")\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket(\"iot-camera-bucket\")\n        blob = bucket.blob(\"preview.jpg\")\n        blob.upload_from_filename(\"preview.jpg\")\n        # Publish the URL of the uploaded image to an MQTT event topic\n        mqtt_client.publish(\"iot-camera-events\",\n                            \"https://storage.googleapis.com/iot-camera-bucket/preview.jpg\")\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 31.96422930508154}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter\n    )\n    parser.add_argument(\"project_id\", help=\"GCP cloud project name\")\n    parser.add_argument(\"subscription_name\", help=\"Pub/Sub subscription name\")\n    parser.add_argument(\n        \"--cloud_region\",\n        default=\"us-central1\",\n        help=\"GCP cloud region (default: us-central1)\",\n    )\n    parser.add_argument(\n        \"--registry_id\", default=\"example-registry\", help=\"Cloud IoT registry id\"\n    )\n    parser.add_argument(\n        \"--device_id\", default=\"example-device-id\", help=\"Cloud IoT device id\"\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        default=\"rsa_private.pem\",\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        default=\"RS256\",\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\"\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Type of message to publish. Either 'event' or 'state'.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\", default=8883, help=\"MQTT bridge port.\", type=int\n    )\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        default=20,\n        type=int,\n        help=\"Expiration time, in minutes, for JWT tokens.\",\n    )\n    parser.add_argument(\n        \"--mqtt_topic\",\n        default=\"devices/{}/{}\".format(\"my-device-id\", \"events\"),\n        help=\"MQTT topic to publish device events.\",\n    )", "CodeBleu_score": 30.353195588474218}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument('project_id', help='GCP cloud project name.')\n    parser.add_argument('subscription_name', help='Pub/Sub subscription name.')\n    parser.add_argument('--message_type', default='event', choices=['event', 'state'], help='Indicates whether the message is an event or a state message.')\n    parser.add_argument('--device_id', default='my-device-id', help='Cloud IoT Core device id.')\n    parser.add_argument('--registry_id', default='my-registry-id', help='Cloud IoT Core registry id.')\n    parser.add_argument('--ca_certs', default='roots.pem', help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--private_key', default='rsa_private.pem', help='Path to private key file.')\n    parser.add_argument('--algorithm', default='RS256', help='Encryption algorithm to generate the JWT.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--num_messages', default=100, type=int, help='Number of messages to publish.')\n    parser.add_argument('--mqtt_topic', default='events', help='MQTT topic name to subscribe to.')\n    parser.add_argument('--service_account_json', default=None, help='Path to service account json file.')\n    args = parser.parse_args()\n\n    return args\n\n", "CodeBleu_score": 37.32375900682725}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument('project_id', help='GCP cloud project name.')\n    parser.add_argument('subscription_name', help='Pub/Sub subscription name.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--registry_id', default='my-registry', help='Cloud IoT Core registry id')\n    parser.add_argument('--device_id', default='my-device-id', help='Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', default='rsa_private.pem', help='Path to private key file.')\n    parser.add_argument('--algorithm', default='RS256', help='Encryption algorithm to generate the JWT.')\n    parser.add_argument('--ca_certs', default='roots.pem', help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--num_messages', default=100, type=int, help='Number of messages to publish.')\n    parser.add_argument('--message_type', default='event', choices=('event', 'state'), help='Type of message to publish. Either \"event\" or \"state\".')\n    parser.add_argument('--base_topic', default='projects/my-project/topics/my-topic', help='Base topic to publish to.')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, type=int, help='MQTT bridge port.')\n    return parser.parse_args()\n\n", "CodeBleu_score": 38.86014863763514}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest?version={v}\".format(\n        v=version\n    )\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json\n    )\n    scoped_credentials = credentials.with_scopes(scopes)\n    return discovery.build(\n        \"cloudiot\",\n        version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n\n", "CodeBleu_score": 41.88355835179468}, {"code": "def get_client(service_account_json)\n\t\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version={}'.format(version)\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(scopes)\n    return discovery.build('cloudiot', version, discoveryServiceUrl=discovery_url, credentials=scoped_credentials)\n\n", "CodeBleu_score": 38.67287396392502}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest?version={}\".format(version)\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(scopes)\n    return discovery.build(\"cloudiot\", version, discoveryServiceUrl=discovery_url, credentials=scoped_credentials)\n\n", "CodeBleu_score": 38.15088365463185}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method not in common.HASH_METHODS:\n        raise ValueError('Invalid hash method specified')\n    asn1_hash_method = common.HASH_METHODS[hash_method]\n    hash_value = transform.bytes2int(hash_value)\n    asn1_hash_value = transform.int2bytes(hash_value, asn1_hash_method['digest_size'])\n    padded_hash_value = transform.add_pkcs1_padding(asn1_hash_value, asn1_hash_method['digest_size'], 'sign')\n    signature = core.encrypt_int(padded_hash_value, priv_key.e, priv_key.n)\n    return signature\n\n", "CodeBleu_score": 42.45880323241914}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    # Retrieve the ASN1 code for the hash method\n    hash_asn1 = _get_hash_asn1(hash_method)\n    # Concatenate the ASN1 code with the hash value\n    hash_asn1_hash = hash_asn1 + hash_value\n    # Pad the hash for signing\n    padded_hash = _pad_for_signing(hash_asn1_hash, priv_key.n)\n    # Sign the padded hash\n    signature = core.encrypt_int(padded_hash, priv_key.e, priv_key.n)\n    # Return the signature\n    return signature\n\n", "CodeBleu_score": 12.207041457889577}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == 'MD5':\n        asn1_code = b'\\x30\\x20\\x30\\x0c\\x06\\x08\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x02\\x05\\x05\\x00\\x04\\x10'\n    elif hash_method == 'SHA1':\n        asn1_code = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == 'SHA224':\n        asn1_code = b'\\x30\\x2d\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x04\\x05\\x00\\x04\\x1c'\n    elif hash_method == 'SHA256':\n        asn1_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'SHA384':\n        asn1_code = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'SHA512':\n        asn1_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x", "CodeBleu_score": 10.213713643744619}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError(\"message must be a bytes object\")\n    if not isinstance(signature, bytes):\n        raise TypeError(\"signature must be a bytes object\")\n    if not isinstance(pub_key, common.PublicKey):\n        raise TypeError(\"pub_key must be a rsa.PublicKey object\")\n\n    # Convert signature to integer\n    signature_int = transform.bytes2int(signature)\n\n    # Decrypt signature\n    clear_signature = core.decrypt_int(signature_int, pub_key.e, pub_key.n)\n\n    # Determine hash method\n    hash_method = common.get_hash_method(clear_signature)\n\n    # Compute hash of message\n    message_hash = common.compute_hash(message, hash_method)\n\n    # Reconstruct expected padded hash\n    expected_padded_hash = common.reconstruct_padded_hash(message_hash, pub_key.n, hash_method)\n\n    # Compare clear signature and expected padded hash\n    if clear_signature == expected_padded_hash:\n        return hash_method\n    else:\n        raise common.VerificationError(\"Signature verification failed\")\n\n", "CodeBleu_score": 41.28758047002837}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError(\"message must be bytes\")\n    if not isinstance(signature, bytes):\n        raise TypeError(\"signature must be bytes\")\n    if not isinstance(pub_key, common.PublicKey):\n        raise TypeError(\"pub_key must be rsa.PublicKey\")\n\n    # Convert the signature to an integer\n    clear_signature = transform.bytes2int(signature)\n\n    # Decrypt the signature\n    clear_signature = core.decrypt_int(clear_signature, pub_key.e, pub_key.n)\n\n    # Determine the hash method\n    if pub_key.method == common.METHOD_MD5:\n        hash_method = hashlib.md5\n    elif pub_key.method == common.METHOD_SHA1:\n        hash_method = hashlib.sha1\n    elif pub_key.method == common.METHOD_SHA256:\n        hash_method = hashlib.sha256\n    elif pub_key.method == common.METHOD_SHA384:\n        hash_method = hashlib.sha384\n    elif pub_key.method == common.METHOD_SHA512:\n        hash_method = hashlib.sha512\n    else:\n        raise ValueError(\"Unknown method\")\n\n    # Compute the hash of the message\n    hash_object = hash_method(message)\n    hash_digest = hash_object.digest()\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = transform.bytes2int(hash_digest)\n    for i in range(pub_key.k - len(hash_digest) * 8):\n        expected_padded_hash = expected_padded_hash << 8\n\n    # Compare the clear signature with the expected padded hash\n    if clear_signature == expected_padded_hash:\n        return pub_key.method\n    else:\n        raise common.VerificationError(\"Signature verification failed\")\n\n", "CodeBleu_score": 38.888195252137564}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError(\"message must be bytes\")\n    if not isinstance(signature, bytes):\n        raise TypeError(\"signature must be bytes\")\n    if not isinstance(pub_key, common.PublicKey):\n        raise TypeError(\"pub_key must be a PublicKey instance\")\n\n    # Convert the signature to an integer\n    signature = transform.bytes2int(signature)\n\n    # Decrypt the signature to obtain the clear signature\n    clear_signature = core.decrypt_int(signature, pub_key.e, pub_key.n)\n\n    # Determine the hash method used\n    hash_method = pub_key.hash_method\n    if hash_method == \"SHA-1\":\n        hash_method = \"SHA1\"\n\n    # Compute the hash of the message\n    if hash_method == \"SHA1\":\n        hash_object = hashlib.sha1()\n    elif hash_method == \"SHA256\":\n        hash_object = hashlib.sha256()\n    elif hash_method == \"SHA512\":\n        hash_object = hashlib.sha512()\n    else:\n        raise ValueError(\"unknown hash method\")\n    hash_object.update(message)\n    message_hash = hash_object.digest()\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = transform.bytes2int(transform.bytes_to_long(message_hash))\n\n    # Compare the expected padded hash with the clear signature\n    if clear_signature != expected_padded_hash:\n        raise common.VerificationError(\"signature does not match message\")\n\n    # Return the hash method name\n    return hash_method\n\n", "CodeBleu_score": 40.01532269421203}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\ttime_t current_time;\n\n\t/*\n\t * The function \"get_current_time\" retrieves the current time and stores it in the variable \"current_time\".\n\t */\n\tcurrent_time = get_current_time();\n\n\t/*\n\t * If the time is valid, the function \"update_jwt\" is called to update the JWT.\n\t */\n\tif (current_time != 0) {\n\t\tupdate_jwt(current_time);\n\t}\n\n\t/*\n\t * The function \"connectToMQTT\" is called to connect to the MQTT client.\n\t */\n\tconnectToMQTT();\n\n\t/*\n\t * The flag \"subscribe_flag\" is set to \"true\" to send an MQTT SUBSCRIBE packet after the connection is established.\n\t */\n\tsubscribe_flag = true;\n\n\t/*\n\t * A debug message is printed indicating the MQTT connection attempt.\n\t */\n\tprintf(\"Attempting MQTT connection...\n\");\n}", "CodeBleu_score": 23.387315823039533}, {"code": "static void connectMQTT(){\n\t\t// Retrieve the current time\n\ttime_t current_time = get_current_time();\n\n\t// Check if the current time is valid\n\tif (current_time != (time_t)(-1)) {\n\t\t// Update the JWT using the current time\n\t\tupdate_jwt(current_time);\n\t}\n\n\t// Connect to the MQTT client\n\tmqtt_connect();\n\n\t// Set the flag to send an MQTT SUBSCRIBE packet after the connection is established\n\tsend_subscribe = true;\n\n\t// Print a debug message indicating the MQTT connection attempt\n\tprintf(\"MQTT connection attempt\n\");\n}", "CodeBleu_score": 21.476195892644718}, {"code": "static void connectMQTT(){\n\t\ttime_t now;\n\tchar jwt[JWT_TOKEN_SIZE];\n\tint32_t unixTime;\n\tint32_t unixTimeExpiry;\n\tint32_t unixTimeCurrent;\n\tint32_t timeNow;\n\tint32_t timeNowExpiry;\n\tint32_t timeNowCurrent;\n\tint32_t timeNowCurrentExpiry;\n\tint32_t timeNowCurrentExpiryCurrent;\n\tint32_t timeNowCurrentExpiryCurrentExpiry;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrent;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiry;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrent;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiry;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrent;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiry;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrent;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiry;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrent;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiry;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrent;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiry;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrent;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiry;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrent;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiry;\n\tint32_t timeNowCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrentExpiryCurrent;\n", "CodeBleu_score": 3.4379813733216364}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tint i;\n\tuint32_t val = 0;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tval = (val * 10) + (*str - '0');\n\t\tstr++;\n\t}\n\n\t*num = val;\n\treturn str;\n}", "CodeBleu_score": 29.878773459139207}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tint i;\n\tuint32_t n = 0;\n\tfor (i = 0; i < width; i++) {\n\t\tif (!isdigit(str[i])) {\n\t\t\treturn str;\n\t\t}\n\t\tn *= 10;\n\t\tn += str[i] - '0';\n\t}\n\t*num = n;\n\treturn &str[width];\n}", "CodeBleu_score": 24.570707048530636}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tuint8_t c = *str++;\n\t\tif (c < '0' || c > '9') {\n\t\t\treturn str - 1;\n\t\t}\n\t\tresult = result * 10 + c - '0';\n\t}\n\n\t*num = result;\n\treturn str;\n}", "CodeBleu_score": 23.34316067209557}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tuint8_t* cert_loc = NULL;\n\tuint8_t* cert_loc_end = NULL;\n\tuint8_t* cert_loc_start = NULL;\n\tuint8_t* cert_loc_end_start = NULL;\n\tuint8_t* cert_loc_end_end = NULL;\n\tuint8_t* cert_loc_end_end_start = NULL;\n\tuint8_t* cert_loc_end_end_end = NULL;\n\tuint8_t* cert_loc_end_end_end_start = NULL;\n\tuint8_t* cert_loc_end_end_end_end = NULL;\n\tuint8_t* cert_loc_end_end_end_end_start = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end_start = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end_end = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end_end_start = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end_end_end = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end_end_end_start = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end_end_end_end = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end_end_end_end_start = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end_end_end_end_end = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end_end_end_end_end_start = NULL;\n\tuint8_t* cert_loc_end_end_end_end_end_end_end_end_end_end = NULL;\n\tuint8_t* cert_loc_end", "CodeBleu_score": 10.870588267753584}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tuint8_t* cert = NULL;\n\tuint8_t* cert_end = NULL;\n\tuint8_t* cert_start = NULL;\n\tuint8_t* cert_temp = NULL;\n\tuint8_t* cert_temp_end = NULL;\n\tuint8_t* cert_temp_start = NULL;\n\tuint8_t* cert_temp_temp = NULL;\n\tuint8_t* cert_temp_temp_end = NULL;\n\tuint8_t* cert_temp_temp_start = NULL;\n\tuint8_t* cert_temp_temp_temp = NULL;\n\tuint8_t* cert_temp_temp_temp_end = NULL;\n\tuint8_t* cert_temp_temp_temp_start = NULL;\n\tuint8_t* cert_temp_temp_temp_temp = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_end = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_start = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_temp = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_temp_end = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_temp_start = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_temp_temp = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_temp_temp_end = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_temp_temp_start = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_temp_temp_temp = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_temp_temp_temp_end = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_temp_temp_temp_start = NULL;\n\tuint8_t* cert_temp_temp_temp_temp_temp_temp_temp_temp = NULL;\n\tuint8_t* cert_temp_temp_temp", "CodeBleu_score": 10.565262677034132}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tuint8_t* cert = NULL;\n\tuint8_t* cert_end = NULL;\n\tuint8_t* cert_start = NULL;\n\tuint8_t* tbs_start = NULL;\n\tuint8_t* tbs_end = NULL;\n\tuint8_t* tbs_cert_start = NULL;\n\tuint8_t* tbs_cert_end = NULL;\n\tuint8_t* tbs_ext_start = NULL;\n\tuint8_t* tbs_ext_end = NULL;\n\tuint8_t* tbs_ext_data_start = NULL;\n\tuint8_t* tbs_ext_data_end = NULL;\n\tuint8_t* ext_start = NULL;\n\tuint8_t* ext_end = NULL;\n\tuint8_t* ext_data_start = NULL;\n\tuint8_t* ext_data_end = NULL;\n\tuint8_t* ext_data_oid = NULL;\n\tuint8_t* ext_data_oid_start = NULL;\n\tuint8_t* ext_data_oid_end = NULL;\n\tuint8_t* ext_data_oid_data = NULL;\n\tuint8_t* ext_data_oid_data_start = NULL;\n\tuint8_t* ext_data_oid_data_end = NULL;\n\tuint8_t* ext_data_value = NULL;\n\tuint8_t* ext_data_value_start = NULL;\n\tuint8_t* ext_data_value_end = NULL;\n\tuint8_t* ext_data_value_data = NULL;\n\tuint8_t* ext_data_value_data_start = NULL;\n\tuint8_t* ext_data_value_data_end = NULL;\n\tuint8_t* ext_data_value_data_2 = NULL;\n\tuint8_t* ext_data_value_data_2_start = NULL;\n\tuint8_t* ext_data_value_data_2_end = NULL;\n\tuint8_t* ext_data_value_data_", "CodeBleu_score": 10.956815410116079}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint status = 0;\n\tuint8_t digest[32];\n\tuint8_t signature[64];\n\tuint8_t public_key[64];\n\tuint8_t ca_public_key_compressed[33];\n\tuint8_t ca_public_key_uncompressed[65];\n\tuint8_t ca_public_key_y[32];\n\tuint8_t ca_public_key_p[64];\n\tuint8_t ca_public_key_q[32];\n\tuint8_t ca_public_key_g[32];\n\tuint8_t ca_public_key_x[32];\n\tuint8_t ca_public_key_y_bit[32];\n\tuint8_t ca_public_key_y_bit_comp[32];\n\tuint8_t ca_public_key_p_bit[64];\n\tuint8_t ca_public_key_p_bit_comp[64];\n\tuint8_t ca_public_key_q_bit[32];\n\tuint8_t ca_public_key_q_bit_comp[32];\n\tuint8_t ca_public_key_g_bit[32];\n\tuint8_t ca_public_key_g_bit_comp[32];\n\tuint8_t ca_public_key_x_bit[32];\n\tuint8_t ca_public_key_x_bit_comp[32];\n\tuint8_t ca_public_key_y_bit_comp_2[32];\n\tuint8_t ca_public_key_p_bit_comp_2[64];\n\tuint8_t ca_public_key_q_bit_comp_2[32];\n\tuint8_t ca_public_key_g_bit_comp_2[32];\n\tuint8_t ca_public_key_x_bit_comp_2[32];\n\tuint8_t ca_public_key_y_bit_comp_3[32];\n\tuint8_t ca_public_key_", "CodeBleu_score": 13.580596131884825}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint status = 0;\n\tuint8_t digest[32];\n\tuint8_t signature[64];\n\tuint8_t public_key[64];\n\tuint8_t public_key_id[20];\n\tuint8_t ca_public_key_id[20];\n\tuint8_t ca_public_key_sig[64];\n\tuint8_t ca_public_key_sig_comp[64];\n\tuint8_t ca_public_key_sig_verified[64];\n\tuint8_t ca_public_key_sig_verified_comp[64];\n\tuint8_t ca_public_key_digest[32];\n\tuint8_t ca_public_key_digest_comp[32];\n\tuint8_t ca_public_key_digest_verified[32];\n\tuint8_t ca_public_key_digest_verified_comp[32];\n\tuint8_t ca_public_key_digest_verified_sw[32];\n\tuint8_t ca_public_key_digest_verified_sw_comp[32];\n\tuint8_t ca_public_key_verified[64];\n\tuint8_t ca_public_key_verified_comp[64];\n\tuint8_t ca_public_key_verified_sw[64];\n\tuint8_t ca_public_key_verified_sw_comp[64];\n\tuint8_t ca_public_key_verified_sw_comp_temp[64];\n\tuint8_t ca_public_key_verified_sw_comp_temp2[64];\n\tuint8_t ca_public_key_verified_sw_comp_temp3[64];\n\tuint8_t ca_public_key_verified_sw_comp_temp4[64];\n\tuint8_t ca_public_key_verified_sw_comp_temp5[64];\n\tuint8_t ca_public_key_verified_sw_comp_temp6[64];\n\tuint8_t ca_public_key_verified_sw_comp_temp7[64", "CodeBleu_score": 14.490524934630452}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint status = 0;\n\tuint8_t digest[32];\n\tuint8_t signature[64];\n\tuint8_t public_key[64];\n\tuint8_t public_key_id = 0;\n\tuint8_t ca_public_key_id = 0;\n\tuint8_t ca_public_key_size = 0;\n\tuint8_t ca_public_key_type = 0;\n\n\t// Check the parameters\n\tif ((cert_def == NULL) || (cert == NULL) || (ca_public_key == NULL)) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\t// Get the digest of the certificate's to-be-signed (TBS) portion\n\tstatus = atcacert_get_tbs(cert_def, cert, cert_size, digest);\n\tif (status != ATCACERT_E_SUCCESS) {\n\t\treturn status;\n\t}\n\n\t// Get the certificate's signature\n\tstatus = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\tif (status != ATCACERT_E_SUCCESS) {\n\t\treturn status;\n\t}\n\n\t// Get the certificate's public key\n\tstatus = atcacert_get_pubkey(cert_def, cert, cert_size, public_key);\n\tif (status != ATCACERT_E_SUCCESS) {\n\t\treturn status;\n\t}\n\n\t// Get the certificate's public key id\n\tstatus = atcacert_get_subj_public_key_id(cert_def, cert, cert_size, &public_key_id);\n\tif (status != ATCACERT_E_SUCCESS) {\n\t\treturn status;\n\t}\n\n\t// Get the certificate's CA public key id\n\tstatus = atcacert_get_subj_key_id(cert_def, cert, cert_size, &ca_public_key_id);\n\tif (status != ATCACERT_E_SUCCESS) {\n\t\treturn status;\n\t}\n\n\t// Get the certificate's CA public key size\n\tstatus = atcacert_get_ca_public_key(cert_def,", "CodeBleu_score": 57.53123345896981}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t *prev = NULL;\n\ttimerStruct_t *curr = *list;\n\n\tif (timer == NULL) {\n\t\treturn false;\n\t}\n\n\twhile (curr != NULL) {\n\t\tif (curr == timer) {\n\t\t\tif (prev == NULL) {\n\t\t\t\t*list = curr->next;\n\t\t\t} else {\n\t\t\t\tprev->next = curr->next;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tprev = curr;\n\t\tcurr = curr->next;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 32.775088426845514}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tbool ret_val;\n\ttimerStruct_t * volatile *cur;\n\ttimerStruct_t * volatile *prev;\n\ttimerStruct_t * volatile *next;\n\ttimerStruct_t * volatile *last;\n\ttimerStruct_t * volatile *tmp;\n\ttimerStruct_t * volatile *tmp2;\n\ttimerStruct_t * volatile *tmp3;\n\ttimerStruct_t * volatile *tmp4;\n\ttimerStruct_t * volatile *tmp5;\n\ttimerStruct_t * volatile *tmp6;\n\ttimerStruct_t * volatile *tmp7;\n\ttimerStruct_t * volatile *tmp8;\n\ttimerStruct_t * volatile *tmp9;\n\ttimerStruct_t * volatile *tmp10;\n\ttimerStruct_t * volatile *tmp11;\n\ttimerStruct_t * volatile *tmp12;\n\ttimerStruct_t * volatile *tmp13;\n\ttimerStruct_t * volatile *tmp14;\n\ttimerStruct_t * volatile *tmp15;\n\ttimerStruct_t * volatile *tmp16;\n\ttimerStruct_t * volatile *tmp17;\n\ttimerStruct_t * volatile *tmp18;\n\ttimerStruct_t * volatile *tmp19;\n\ttimerStruct_t * volatile *tmp20;\n\ttimerStruct_t * volatile *tmp21;\n\ttimerStruct_t * volatile *tmp22;\n\ttimerStruct_t * volatile *tmp23;\n\ttimerStruct_t * volatile *tmp24;\n\ttimerStruct_t * volatile *tmp25;\n\ttimerStruct_t * volatile *tmp26;\n\ttimerStruct_t * volatile *tmp27;\n\ttimerStruct_t * volatile *tmp28;\n\ttimerStruct_t * volatile *tmp29;\n\ttimerStruct_t * volatile *tmp30;\n\ttimerStruct_t * volatile *tmp31;\n\ttimerStruct_t * volatile *tmp32;\n\ttimerStruct_t * volatile *tmp33;\n\ttimerStruct_t * volatile *tmp34;\n\ttimerStruct_t * volatile *tmp35;\n\ttimerStruct_t * volatile *tmp36;\n\ttimerStruct", "CodeBleu_score": 6.7560528057140035}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tbool found = false;\n\ttimerStruct_t * volatile *current = list;\n\ttimerStruct_t * volatile *next = list;\n\twhile (*current != NULL) {\n\t\tnext = &(*current)->next;\n\t\tif (*current == timer) {\n\t\t\t*current = (*current)->next;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = next;\n\t}\n\treturn found;\n}", "CodeBleu_score": 28.464193240744496}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tint32_t ret_val = BSD_ERROR;\n\tBSD_SOCKET_INFO *socket_info;\n\n\tif (socket < 0) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tsocket_info = BSD_get_socket_info(socket);\n\n\tif (socket_info != NULL) {\n\t\tsocket_info->state = NOT_A_SOCKET;\n\t}\n\n\tret_val = close(socket);\n\n\tif (ret_val < 0) {\n\t\tif (socket_info != NULL) {\n\t\t\tif (errno == EBADF) {\n\t\t\t\tsocket_info->error_number = EBADF;\n\t\t\t\tret_val = BSD_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret_val;\n}", "CodeBleu_score": 44.00090969615616}, {"code": "int BSD_close(int socket){\n\t\tint32_t socket_info;\n\n\tif (socket == -1) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tsocket_info = socket_get_socket_info(socket);\n\n\tif (socket_info == -1) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tsocket_set_socket_state(socket, NOT_A_SOCKET);\n\n\tif (socket_close(socket) == -1) {\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 23.87592423303646}, {"code": "int BSD_close(int socket){\n\t\tint8_t returnValue;\n\n\tsocket_t* sock;\n\n\tsock = getSocket(socket);\n\n\tif (sock == NULL) {\n\t\treturn BSD_ERROR_SOCKET_NOT_FOUND;\n\t}\n\n\tsock->state = NOT_A_SOCKET;\n\n\treturnValue = close(socket);\n\n\tif (returnValue < 0) {\n\t\tswitch (returnValue) {\n\t\t\tcase SOCKET_ERROR_AGAIN:\n\t\t\t\treturn BSD_ERROR_AGAIN;\n\t\t\tcase SOCKET_ERROR_BAD_ADDRESS:\n\t\t\t\treturn BSD_ERROR_BAD_ADDRESS;\n\t\t\tcase SOCKET_ERROR_CONN_ABORTED:\n\t\t\t\treturn BSD_ERROR_CONN_ABORTED;\n\t\t\tcase SOCKET_ERROR_CONN_RESET:\n\t\t\t\treturn BSD_ERROR_CONN_RESET;\n\t\t\tcase SOCKET_ERROR_FAIL:\n\t\t\t\treturn BSD_ERROR_FAIL;\n\t\t\tcase SOCKET_ERROR_IN_PROGRESS:\n\t\t\t\treturn BSD_ERROR_IN_PROGRESS;\n\t\t\tcase SOCKET_ERROR_INVALID_VALUE:\n\t\t\t\treturn BSD_ERROR_INVALID_VALUE;\n\t\t\tcase SOCKET_ERROR_MEM:\n\t\t\t\treturn BSD_ERROR_MEM;\n\t\t\tcase SOCKET_ERROR_NO_BUFS:\n\t\t\t\treturn BSD_ERROR_NO_BUFS;\n\t\t\tcase SOCKET_ERROR_NO_CONNECTION:\n\t\t\t\treturn BSD_ERROR_NO_CONNECTION;\n\t\t\tcase SOCKET_ERROR_NO_SOCKET:\n\t\t\t\treturn BSD_ERROR_NO_SOCKET;\n\t\t\tcase SOCKET_ERROR_NOT_CONNECTED:\n\t\t\t\treturn BSD_ERROR_NOT_CONNECTED;\n\t\t\tcase SOCKET_ERROR_NOT_INITIALIZED:\n\t\t\t\treturn BSD_ERROR_NOT_INITIALIZED;\n\t\t\tcase SOCKET_ERROR_NOT_SOCKET:\n\t\t\t\treturn BSD_ERROR_NOT_SOCKET;\n\t\t\tcase SOCKET_ERROR_NOT_SUPPORTED:\n\t\t\t\treturn BSD_ERROR_NOT_SUPPORTED;\n\t\t\tcase SOCKET_ERROR_TIMED_OUT:\n\t\t\t\treturn BSD_ERROR_TIMED_OUT;\n\t\t\tcase SOCKET_ERROR_UNKNOWN:\n\t\t\t\treturn BSD_ERROR_UNKNOWN;\n\t\t\tdefault:\n\t\t\t\treturn BSD_ERROR_UNKNOWN;\n\t\t}\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 40.15104512716615}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret = -1;\n\tint err = 0;\n\tint32_t resp = 0;\n\tuint8_t sock_num = 0;\n\n\tif (socket < 0) {\n\t\terr = BSD_EINVAL;\n\t\tgoto error;\n\t}\n\n\tsock_num = (uint8_t) socket;\n\n\tresp = listen(sock_num, backlog);\n\n\tif (resp < 0) {\n\t\terr = BSD_EINVAL;\n\t\tgoto error;\n\t}\n\n\tret = BSD_SUCCESS;\n\nerror:\n\treturn ret;\n}", "CodeBleu_score": 32.04311176606688}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret;\n\tint32_t status;\n\tuint8_t response;\n\n\tif (socket < 0) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tret = listen(socket, backlog);\n\n\tif (ret < 0) {\n\t\tstatus = winc_socket_get_error(socket);\n\n\t\tif (status == SOCKET_ERROR_INVALID_SOCKET) {\n\t\t\treturn BSD_ERROR_INVALID_SOCKET;\n\t\t} else if (status == SOCKET_ERROR_INVALID_STATE) {\n\t\t\treturn BSD_ERROR_INVALID_STATE;\n\t\t} else if (status == SOCKET_ERROR_NOT_SUPPORTED) {\n\t\t\treturn BSD_ERROR_NOT_SUPPORTED;\n\t\t} else if (status == SOCKET_ERROR_NOT_INITIALIZED) {\n\t\t\treturn BSD_ERROR_NOT_INITIALIZED;\n\t\t} else if (status == SOCKET_ERROR_PARAMETER) {\n\t\t\treturn BSD_ERROR_PARAMETER;\n\t\t} else if (status == SOCKET_ERROR_NO_MEMORY) {\n\t\t\treturn BSD_ERROR_NO_MEMORY;\n\t\t} else if (status == SOCKET_ERROR_NOT_FOUND) {\n\t\t\treturn BSD_ERROR_NOT_FOUND;\n\t\t} else if (status == SOCKET_ERROR_CONNECTION) {\n\t\t\treturn BSD_ERROR_CONNECTION;\n\t\t} else if (status == SOCKET_ERROR_TIMEOUT) {\n\t\t\treturn BSD_ERROR_TIMEOUT;\n\t\t} else if (status == SOCKET_ERROR_BUFFER_FULL) {\n\t\t\treturn BSD_ERROR_BUFFER_FULL;\n\t\t} else if (status == SOCKET_ERROR_REJECTED) {\n\t\t\treturn BSD_ERROR_REJECTED;\n\t\t} else if (status == SOCKET_ERROR_ABORTED) {\n\t\t\treturn BSD_ERROR_ABORTED;\n\t\t} else if (status == SOCKET_ERROR_BUSY) {\n\t\t\treturn BSD_ERROR_BUSY;\n\t\t} else if (status == SOCKET_ERROR_ALREADY) {\n\t\t\treturn BSD_ERROR_ALREADY;\n\t\t} else if (status == SOCKET_ERROR_INVALID) {\n\t\t\treturn BSD_ERROR_INVALID;\n\t\t} else if (status == SOCKET_ERROR_UNSUPPORTED) {\n\t\t\treturn BSD_ERROR_UNSUPPORTED;\n\t\t} else if (status == SOCKET_ERROR_INIT_FAILED", "CodeBleu_score": 39.62324412851844}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret_code;\n\tuint8_t err_code;\n\n\tret_code = listen(socket, backlog);\n\n\terr_code = BSD_get_error_code(ret_code);\n\n\tif (err_code != 0) {\n\t\tBSD_set_error_number(err_code);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 25.852381739690127}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret_val;\n\tint32_t ret_val_32;\n\tint8_t ret_val_8;\n\tuint8_t addr_family;\n\tuint8_t addr_length;\n\tuint8_t addr_port;\n\tuint8_t addr_ip[4];\n\tuint8_t addr_ip_len;\n\tuint8_t addr_ip_port_len;\n\tuint8_t addr_ip_port_family_len;\n\tuint8_t addr_ip_port_family_len_len;\n\tuint8_t addr_ip_port_family_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len_len_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len_len_len_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len_len_len_len_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len_len_len_len_len_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len_len_len_len_len_len_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len_len_len_len_len_len_len_len_len_len;\n\tuint8_t addr_ip_port_family_len_len_len_len_len_len_len_len_len_len_len_len_len_len;\n\tuint8_t", "CodeBleu_score": 9.1856780214719}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret_val = -1;\n\n\tif (socket < BSD_SOCKET_MIN || socket > BSD_SOCKET_MAX) {\n\t\tdebug_printError(\"BSD_accept: Invalid socket number\");\n\t\treturn BSD_EINVAL;\n\t}\n\n\tif (addr == NULL) {\n\t\tdebug_printError(\"BSD_accept: addr is NULL\");\n\t\treturn BSD_EINVAL;\n\t}\n\n\tif (addrlen == NULL) {\n\t\tdebug_printError(\"BSD_accept: addrlen is NULL\");\n\t\treturn BSD_EINVAL;\n\t}\n\n\tif (addr->sa_family == AF_INET) {\n\t\tstruct sockaddr_in addr_in;\n\t\tmemset(&addr_in, 0, sizeof(struct sockaddr_in));\n\t\taddr_in.sin_family = AF_INET;\n\t\taddr_in.sin_port = addr->sa_data.sin_port;\n\t\taddr_in.sin_addr.s_addr = addr->sa_data.sin_addr.s_addr;\n\t\tret_val = accept(socket, (struct sockaddr *) &addr_in, addrlen);\n\t\tif (ret_val < 0) {\n\t\t\tdebug_printError(\"BSD_accept: accept failed\");\n\t\t\tif (socket == BSD_SOCKET_WINC) {\n\t\t\t\twinc_setErrno(errno);\n\t\t\t}\n\t\t}\n\t} else if (addr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 addr_in6;\n\t\tmemset(&addr_in6, 0, sizeof(struct sockaddr_in6));\n\t\taddr_in6.sin6_family = AF_INET6;\n\t\taddr_in6.sin6_port = addr->sa_data.sin6_port;\n\t\taddr_in6.sin6_flowinfo = addr->sa_data.sin6_flowinfo;\n\t\tmemcpy(addr_in6.sin6_addr.s6_addr, addr->sa_data.sin6_addr.s6_addr, sizeof(addr_in6.sin6_addr.s6_addr));\n\t\taddr_in6.sin6_scope_id = addr->sa_data.sin6_scope_id;\n\t\tret_val = accept(socket,", "CodeBleu_score": 44.84281480984579}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret_code;\n\tint32_t ret_code_int32;\n\tint32_t sock_addr_len;\n\tint32_t sock_addr_len_int32;\n\tint32_t sock_addr_len_int32_temp;\n\tint32_t sock_addr_len_int32_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp_temp_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\tint32_t sock_addr_len_int32_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\tint32_t sock_addr_len_", "CodeBleu_score": 8.849563045688441}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tint32_t time_now;\n\n\t// Retrieve current time in UNIX format\n\ttime_now = get_current_time();\n\n\t// Check if the time is valid\n\tif (time_now < 0) {\n\t\t// If the time is not valid, print a debug message and return\n\t\tprintd(\"Time is not valid\n\");\n\t\treturn;\n\t}\n\n\t// Update the JWT with the current time offset\n\tupdate_jwt_time(time_now);\n\n\t// Initiate the MQTT connection\n\tmqtt_connect();\n\n\t// Set a flag to send an MQTT SUBSCRIBE packet once the connection is established\n\tmqtt_subscribe_flag = true;\n\n\t// Print a debug message to indicate the connection attempt\n\tprintd(\"MQTT connection attempt\n\");\n}", "CodeBleu_score": 46.951842683422164}, {"code": "static void connectMQTT(){\n\t\ttime_t currentTime;\n\n\ttime(&currentTime);\n\n\tif (isTimeValid(currentTime)) {\n\t\tupdateJWT(currentTime);\n\n\t\tif (connectToMQTTBroker()) {\n\t\t\tprintLog(LOG_LEVEL_INFO, \"MQTT connection established\");\n\n\t\t\tsubscribeToMQTTTopics();\n\n\t\t\tsendMQTTSubscribedPacket();\n\n\t\t\tsetMQTTConnectionStatus(true);\n\t\t} else {\n\t\t\tprintLog(LOG_LEVEL_ERROR, \"MQTT connection failed\");\n\t\t}\n\t} else {\n\t\tprintLog(LOG_LEVEL_ERROR, \"Invalid time\");\n\t}\n}", "CodeBleu_score": 37.749113545225136}, {"code": "static void connectMQTT(){\n\t\tuint32_t currentTime = 0;\n\tuint32_t timeOffset = 0;\n\tint32_t ret = 0;\n\n\t// Get current time in UNIX format\n\tcurrentTime = (uint32_t)time(NULL);\n\n\t// Check if time is valid\n\tif (currentTime > 0) {\n\t\t// Update JWT with current time offset\n\t\ttimeOffset = currentTime - (uint32_t)get_unix_time();\n\t\tjwt_update_time_offset(timeOffset);\n\n\t\t// Initiate MQTT connection\n\t\tret = mqtt_connect();\n\n\t\t// Print debug message\n\t\tdebug_printError(\"MQTT connection attempt: %d\", ret);\n\n\t\t// Set flag to send MQTT SUBSCRIBE packet once the connection is established\n\t\tmqtt_setSubscribeFlag();\n\t}\n}", "CodeBleu_score": 51.86217572636489}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tif (CLOUD_CONNECTION_STATE == CLOUD_STATE_CONNECTED) {\n\t\tif (CLOUD_MQTT_STATE == CLOUD_MQTT_STATE_CONNECTED) {\n\t\t\tm2m_wifi_disconnect();\n\t\t\tCLOUD_MQTT_STATE = CLOUD_MQTT_STATE_DISCONNECTED;\n\t\t}\n\t\tCLOUD_CONNECTION_STATE = CLOUD_STATE_DISCONNECTED;\n\t\tdebug_printError(\"Disconnected from the cloud service\");\n\t}\n}", "CodeBleu_score": 45.41332236551104}, {"code": "void CLOUD_disconnect(void){\n\t\tif (cloud_service_state == CLOUD_SERVICE_STATE_CONNECTED) {\n\t\tcloud_service_state = CLOUD_SERVICE_STATE_DISCONNECTING;\n\t\tCLOUD_debug_print(\"CLOUD_disconnect: Disconnecting from the cloud service.\n\");\n\t\tif (mqtt_client_state == MQTT_CLIENT_STATE_CONNECTED) {\n\t\t\tCLOUD_debug_print(\"CLOUD_disconnect: Disconnecting from the MQTT broker.\n\");\n\t\t\tMQTT_disconnect(mqtt_client_info.client_id, mqtt_client_info.username, mqtt_client_info.password, mqtt_client_info.keep_alive_interval);\n\t\t} else {\n\t\t\tCLOUD_debug_print(\"CLOUD_disconnect: MQTT client not connected.\n\");\n\t\t}\n\t} else {\n\t\tCLOUD_debug_print(\"CLOUD_disconnect: Cloud service not connected.\n\");\n\t}\n}", "CodeBleu_score": 38.253750125798305}, {"code": "void CLOUD_disconnect(void){\n\t\tif (CLOUD_CONNECTION_STATE == CLOUD_CONNECTION_STATE_CONNECTED) {\n\t\tif (CLOUD_CONNECTION_MQTT_STATE == CLOUD_CONNECTION_MQTT_STATE_CONNECTED) {\n\t\t\tCLOUD_CONNECTION_MQTT_STATE = CLOUD_CONNECTION_MQTT_STATE_DISCONNECTING;\n\t\t\tCLOUD_CONNECTION_STATE = CLOUD_CONNECTION_STATE_DISCONNECTING;\n\t\t\tMQTT_disconnect(&CLOUD_CONNECTION_MQTT_CLIENT);\n\t\t} else {\n\t\t\tCLOUD_CONNECTION_STATE = CLOUD_CONNECTION_STATE_DISCONNECTED;\n\t\t\tCLOUD_CONNECTION_MQTT_STATE = CLOUD_CONNECTION_MQTT_STATE_DISCONNECTED;\n\t\t}\n\t} else {\n\t\tCLOUD_CONNECTION_STATE = CLOUD_CONNECTION_STATE_DISCONNECTED;\n\t\tCLOUD_CONNECTION_MQTT_STATE = CLOUD_CONNECTION_MQTT_STATE_DISCONNECTED;\n\t}\n}", "CodeBleu_score": 31.758013634144184}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrM2MWifiConnect strM2MWifiConnect;\n\tsint8 ret;\n\tif (passed_wifi_creds == 1) {\n\t\t/*\n\t\t * Connect to the Wi-Fi access point using the specified SSID, authentication type, and password.\n\t\t */\n\t\tstrM2MWifiConnect.pu8Ssid = (uint8 *) WIFI_SSID;\n\t\tstrM2MWifiConnect.u8SsidLen = strlen(WIFI_SSID);\n\t\tstrM2MWifiConnect.u8SecType = WIFI_AUTH_WPA_PSK;\n\t\tstrM2MWifiConnect.pu8Password = (uint8 *) WIFI_PASSWORD;\n\t\tstrM2MWifiConnect.u8PasswordLen = strlen(WIFI_PASSWORD);\n\t\tret = m2m_wifi_connect(&strM2MWifiConnect);\n\t} else {\n\t\t/*\n\t\t * Connect to the Wi-Fi access point using the default Wi-Fi settings.\n\t\t */\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret == M2M_SUCCESS) {\n\t\tdebug_printError(\"wifi_connectToAp(): Connection successful\");\n\t\treturn true;\n\t} else if (ret == M2M_ERR_FAIL) {\n\t\tdebug_printError(\"wifi_connectToAp(): Connection failed\");\n\t\treturn false;\n\t} else {\n\t\tdebug_printError(\"wifi_connectToAp(): Connection failed with error code %d\", ret);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 44.89117081177698}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiInitParam param;\n\tsint8 ret;\n\tuint8_t retry = 0;\n\tuint8_t authType = 0;\n\tuint8_t wifi_cred_index = 0;\n\tbool wifi_connected = false;\n\ttstrM2mWifiAuthCredentials wifi_cred;\n\ttstrSystemTime wifi_start_time;\n\ttstrSystemTime wifi_end_time;\n\tuint32_t wifi_elapsed_time;\n\tuint8_t wifi_status;\n\tuint8_t wifi_connect_attempts = 0;\n\tchar *wifi_ssid = NULL;\n\tchar *wifi_password = NULL;\n\tuint8_t wifi_cred_count = 0;\n\tuint8_t wifi_cred_index = 0;\n\tuint8_t wifi_cred_index_max = 0;\n\tuint8_t wifi_cred_index_current = 0;\n\tuint8_t wifi_cred_index_next = 0;\n\tuint8_t wifi_cred_index_next_max = 0;\n\tuint8_t wifi_cred_index_next_current = 0;\n\tuint8_t wifi_cred_index_next_next = 0;\n\tuint8_t wifi_cred_index_next_next_max = 0;\n\tuint8_t wifi_cred_index_next_next_current = 0;\n\tuint8_t wifi_cred_index_next_next_next = 0;\n\tuint8_t wifi_cred_index_next_next_next_max = 0;\n\tuint8_t wifi_cred_index_next_next_next_current = 0;\n\tuint8_t wifi_cred_index_next_next_next_next = 0;\n\tuint8_t wifi_cred_index_next_next_next_next_max = 0;\n\tuint8_t wifi_cred_index_next_next_next_next_current = 0;\n\tuint8_t wifi_cred_index_next_next_next_next_next = 0;\n\tuint8_t wifi_cred_", "CodeBleu_score": 5.460076022893664}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrM2mWifiStateChanged *wifi_state_changed;\n\tsint8_t ret;\n\tuint8_t i;\n\tuint8_t wifi_creds_loaded;\n\ttstrSystemInfo sys_info;\n\ttstrWifiInitParam param;\n\ttstrM2mIpV4Addr ip_config;\n\tuint8_t ip_config_set;\n\tuint8_t wifi_connected;\n\tuint8_t wifi_default_creds_set;\n\tuint8_t wifi_default_creds_loaded;\n\tuint8_t wifi_default_creds_loaded_and_set;\n\tuint8_t wifi_default_creds_set_and_loaded;\n\tuint8_t wifi_default_creds_set_and_loaded_and_connected;\n\tuint8_t wifi_default_creds_set_and_loaded_and_connected_and_ip_set;\n\tuint8_t wifi_default_creds_set_and_loaded_and_connected_and_ip_set_and_mqtt_connected;\n\tuint8_t wifi_default_creds_set_and_loaded_and_connected_and_ip_set_and_mqtt_connected_and_app_started;\n\tuint8_t wifi_default_creds_set_and_loaded_and_connected_and_ip_set_and_mqtt_connected_and_app_started_and_led_off;\n\tuint8_t wifi_default_creds_set_and_loaded_and_connected_and_ip_set_and_mqtt_connected_and_app_started_and_led_on;\n\tuint8_t wifi_default_creds_set_and_loaded_and_connected_and_ip_set_and_mqtt_connected_and_app_started_and_led_on_and_mqtt_subscribed;\n\tuint8_t wifi_default_creds_set_and_loaded_and_connected_and_ip_set_and_mqtt_connected_and_app_started_and_led_on_and_mqtt_subscribed_and_led_off;\n\tuint8_t wifi_default_creds_set_and_loaded_and_connected_and", "CodeBleu_score": 3.40010937187233}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t// Create a client using the AWS AppSync endpoint\nconst client = new AWSAppSyncClient({\nurl: GRAPHQL_ENDPOINT,\nregion: AWS_REGION,\nauth: {\ntype: AUTH_TYPE.API_KEY,\napiKey: API_KEY\n}\n});\n// Create a GraphQL query to retrieve sensor data\nconst query = gql`\nquery ListSensors {\nlistSensors {\nitems {\nid\nname\nlocation {\nlatitude\nlongitude\n}\n}\nnextToken\n}\n}\n`;\n// Execute the GraphQL query\nconst response = await client.query({ query });\nconsole.log(\"ListSensors query:\", response);\n// If the response contains data, display the sensors on the map\nif (response.data.listSensors.items) {\n// Iterate through the sensors to create markers\nresponse.data.listSensors.items.forEach(sensor => {\n// Create a marker for each sensor\nconst marker = new maplibregl.Marker()\n.setLngLat([sensor.location.longitude, sensor.location.latitude])\n.setPopup(new maplibregl.Popup({ offset: 25 })\n.setHTML(`<b>Sensor Name:</b> ${sensor.name}<br />\n<b>Sensor ID:</b> ${sensor.id}`))\n.addTo(map);\n});\n}\n}", "CodeBleu_score": 39.36378159403887}, {"code": "async function DisplaySensors(map){\n\t// Create a client to interact with the GraphQL API\nconst client = new AWSAppSyncClient({\nurl: awsconfig.aws_appsync_graphqlEndpoint,\nregion: awsconfig.aws_appsync_region,\nauth: {\ntype: AUTH_TYPE.API_KEY,\napiKey: awsconfig.aws_appsync_apiKey\n}\n});\n\n// Create a GraphQL query to retrieve sensor data\nconst query = gql`\nquery listSensors {\nlistSensors {\nitems {\nid\nname\ndescription\nlocation {\nlatitude\nlongitude\n}\n}\nnextToken\n}\n}\n`;\n\n// Execute the query\nclient.query({\nquery: query\n}).then(function (response) {\n// Log the response\nconsole.log(response);\n// If the response contains data, iterate through each sensor to create a marker\nif (response.data.listSensors.items) {\nresponse.data.listSensors.items.forEach(function (sensor) {\n// Create a marker for the sensor\nconst marker = new maplibregl.Marker()\n.setLngLat([sensor.location.longitude, sensor.location.latitude])\n.addTo(map);\n// Add a popup to the marker\nmarker.setPopup(new maplibregl.Popup({ offset: 25 })\n.setHTML(\"<b>Sensor Name:</b> \" + sensor.name + \"<br/><b>Sensor Description:</b> \" + sensor.description));\n});\n}\n}).catch(function (error) {\n// Log the error\nconsole.log(error);\n});\n}", "CodeBleu_score": 38.911938930745315}, {"code": "async function DisplaySensors(map){\n\t\n// Create a client to interact with the GraphQL API\nconst client = new ApolloClient({\nuri: 'https://q434264v2j.execute-api.us-east-1.amazonaws.com/dev/graphql'\n});\n\n// Create a GraphQL query to retrieve sensor data\nconst query = gql`\n{\nsensors {\nid\nname\ngeolocation {\nlat\nlng\n}\n}\n}\n`;\n\n// Use the Apollo client to send the query and retrieve sensor data\nclient\n.query({\nquery: query\n})\n.then((response) => {\nconsole.log('Retrieved sensors');\nconsole.log(response);\n\n// If the response contains data, iterate through each sensor to create a marker\nif (response.data.sensors) {\nresponse.data.sensors.forEach((sensor) => {\n\n// Create a marker for each sensor\nconst marker = new maplibre_gl_js.Marker()\n.setLngLat([sensor.geolocation.lng, sensor.geolocation.lat])\n.addTo(map);\n\n// Add the marker to the map\nmarker.addTo(map);\n});\n}\n})\n.catch((error) => {\nconsole.log(error);\n});\n}", "CodeBleu_score": 44.61515065721081}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\t// Create a marker element with the given sensor's id.\n\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\n\t// Set the marker's class name to 'sensor-marker'.\n\tmarker.className = \"sensor-marker\";\n\n\t// Set the marker's background color to the sensor's color.\n\tmarker.style.backgroundColor = sensor.color;\n\n\t// Set the marker's border to a 2px solid black color.\n\tmarker.style.border = \"2px solid black\";\n\n\t// Return the created marker element.\n\treturn marker;\n}", "CodeBleu_score": 44.39298298430829}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\t// Create a marker element.\n\tconst marker = document.createElement('div');\n\t// Set the marker's id using the sensor's unique ID.\n\tmarker.id = `marker-${sensor.id}`;\n\t// Assign the marker a specific class name.\n\tmarker.className = 'sensor-marker';\n\t// Set the marker's background color to a default value.\n\tmarker.style.backgroundColor = '#3F51B5';\n\t// Set the marker's border to a default value.\n\tmarker.style.border = '2px solid #3F51B5';\n\t// Set the marker's width and height.\n\tmarker.style.width = '50px';\n\tmarker.style.height = '50px';\n\t// Set the marker's font color to white.\n\tmarker.style.color = 'white';\n\t// Set the marker's font size to 15 pixels.\n\tmarker.style.fontSize = '15px';\n\t// Set the marker's text content to the sensor's name.\n\tmarker.textContent = sensor.name;\n\t// Return the created marker element.\n\treturn marker;\n}", "CodeBleu_score": 44.648273906404604}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensorMarker\";\n\tmarker.style.backgroundColor = \"#000000\";\n\tmarker.style.border = \"2px solid #000000\";\n\treturn marker;\n}", "CodeBleu_score": 42.37119402490597}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth_providers.{module_name}\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError:\n        _LOGGER.exception(\n            \"Unable to load auth provider %s. If you have issues with other \"\n            \"auth providers, please report them to the custom component \"\n            \"author.\",\n            module_path,\n        )\n        raise\n\n    if not hasattr(module, \"async_setup_flow\"):\n        _LOGGER.error(\n            \"Auth provider %s does not support multi-factor authentication\",\n            module_path,\n        )\n        raise HomeAssistantError(\n            f\"Auth provider {module_path} does not support multi-factor authentication\"\n        )\n\n    if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n        _LOGGER.error(\n            \"Auth provider %s does not have a AUTH_PROVIDER_SCHEMA\", module_path\n        )\n        raise HomeAssistantError(\n            f\"Auth provider {module_path} does not have a AUTH_PROVIDER_SCHEMA\"\n        )\n\n    if not hasattr(module, \"MFA_SETUP_SCHEMA\"):\n        _LOGGER.error(\n            \"Auth provider %s does not have a MFA_SETUP_SCHEMA\", module_path\n        )\n        raise HomeAssistantError(\n            f\"Auth provider {module_path} does not have a MFA_SETUP_SCHEMA\"\n        )\n\n    if not hasattr(module, \"AUTH_CALLBACK_PATH\"):\n        _LOGGER.error(\n            \"Auth provider %s does not have a AUTH_CALLBACK_PATH\", module_path\n        )\n        raise HomeAssistantError(\n            f\"Auth provider {module_path} does not have a AUTH_CALLBACK_PATH\"\n        )\n\n    if not hasattr(module, \"AUTH_CALLBACK_CLASS\"):\n        _LOGGER.error(\n            \"Auth provider %s does not have a AUTH_CALLBACK_CLASS\", module_path\n        )\n        raise HomeAssistantError(\n            f\"Auth provider {module_path} does not have a AUTH_CALLBACK_CLASS\"\n        )\n\n    if not hasattr(module, \"AUTH_CALLBACK_ROUTE\"):\n        _LOGGER.error(\n            \"Auth provider %s does not have a AUTH_CALLBACK_ROUTE\", module_path\n        )\n        raise HomeAssistantError(\n            f\"Auth provider {module_path} does not have a AUTH_CALLBACK_ROUTE\"\n        )\n\n    if not hasattr(module, \"AUTH_", "CodeBleu_score": 26.853921109769363}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    # Construct the module path\n    module_path = f\"homeassistant.auth_providers.{module_name}\"\n    # Attempt to import the module\n    module = await async_import_module(hass, module_path)\n    # Log the module being loaded\n    logging.getLogger(__name__).debug(\n        \"Loaded module %s from %s\", module_name, module_path\n    )\n    # If the module has requirements, process these requirements\n    if hasattr(module, \"REQUIREMENTS\"):\n        # Check if the module's requirements have already been processed\n        if module_path in requirements.PROVIDERS:\n            # Log that the module's requirements have already been processed\n            logging.getLogger(__name__).debug(\n                \"Module %s requirements have already been processed\", module_name\n            )\n        else:\n            # Log the module's requirements being processed\n            logging.getLogger(__name__).debug(\n                \"Processing module %s requirements\", module_name\n            )\n            # Process the module's requirements\n            await requirements.async_process_requirements(hass, module_path)\n    # Return the loaded module\n    return module\n\n", "CodeBleu_score": 34.933609730921695}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth_providers.{module_name}\"\n    module = await async_import_module(hass, module_path)\n    if not hasattr(module, \"DOMAIN\"):\n        raise HomeAssistantError(f\"Module {module_name} does not define a DOMAIN\")\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not await requirements.async_process_requirements(hass, module.REQUIREMENTS):\n            raise HomeAssistantError(\n                f\"Error processing requirements of {module_name}\"\n            )\n    return module\n\n", "CodeBleu_score": 28.68382484453142}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        raise InvalidCode(\n            \"Invalid code provided. Please make sure you have copied the entire code from your authenticator app.\"\n        )\n    user_data = self.data.get(user_id)\n    if user_data:\n        user_data[\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n    return True\n\n", "CodeBleu_score": 39.541019366074615}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Extract the PIN from the setup data\n    pin = setup_data.get(\"pin\")\n    # Check if the user already has an entry in the internal data list\n    for user in self.data:\n        if user[\"user_id\"] == user_id:\n            # Update the PIN\n            user[\"pin\"] = pin\n            return\n    # If an entry does not exist, add a new entry with the user ID and PIN to the data list\n    self.data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 56.05638611996439}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n\n", "CodeBleu_score": 35.20745562491782}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t os each user.", "CodeBleu_score": 1.470588235752007}, {"code": "async def _async_load(self) -> None\n\t argparse.Namespace.\"\"\"\n    async with self._lock:\n        if self._data is not None:\n            return\n\n        try:\n            data = await self._store.async_load()\n        except HomeAssistantError:\n            data = {}\n\n        if data is None:\n            data = {}\n\n        self._data = OrderedDict()\n\n        for user_id, user_data in data.items():\n            self._data[user_id] = NotifySetting(\n                user_id,\n                user_data.get(CONF_INCLUDE, []),\n                user_data.get(CONF_EXCLUDE, []),\n            )\n\n", "CodeBleu_score": 36.18075405817409}, {"code": "async def _async_load(self) -> None\n\t django.core.cache.Cache.get.", "CodeBleu_score": 3.4314188037380053}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._store.async_is_loading():\n        await self._store.async_load()\n\n    if user_id in self._store.data:\n        if user_input.get(CONF_EXCLUDE) is not None:\n            user_input[CONF_EXCLUDE] = cv.ensure_list(user_input[CONF_EXCLUDE])\n        if user_input.get(CONF_INCLUDE) is not None:\n            user_input[CONF_INCLUDE] = cv.ensure_list(user_input[CONF_INCLUDE])\n        return await self._hass.async_add_executor_job(self._validate, user_id, user_input)\n    else:\n        return False\n\n", "CodeBleu_score": 48.015958226740665}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self.settings is None:\n        await self.async_load_settings()\n    if user_id not in self.settings:\n        return False\n    settings = self.settings[user_id]\n    if settings.get(\"otp_secret\") is None:\n        return False\n    secret = settings[\"otp_secret\"]\n    if settings.get(\"otp_type\") == \"totp\":\n        return await self.hass.async_add_executor_job(validate_totp, user_input[\"code\"], secret)\n    if settings.get(\"otp_type\") == \"hotp\":\n        return await self.hass.async_add_executor_job(validate_hotp, user_input[\"code\"], secret, settings[\"otp_counter\"])\n    return False\n\n", "CodeBleu_score": 47.08772684618779}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_user_settings(user_id)\n    settings = self.async_get_user_settings(user_id)\n    if settings is None:\n        return False\n    if user_input[\"otp\"] == settings.get(\"otp\"):\n        return True\n    return False\n\n", "CodeBleu_score": 38.577605859556655}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict[area_id]\n\n", "CodeBleu_score": 53.00175136925983}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    if entity_id is None:\n        return None\n    entity_entry = perm_lookup.entity_lookup.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.device_lookup.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 73.25632051162735}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 47.22039460883292}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, permissions in policy.items():\n            if category not in seen_categories:\n                merged_policy[category] = permissions\n                seen_categories.add(category)\n            else:\n                merged_policy[category] = merged_policy[category] | permissions\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 43.18417331854649}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                if category in merged_policy:\n                    merged_policy[category].update(policy[category])\n                else:\n                    merged_policy[category] = policy[category]\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 56.37170789023177}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy_dict: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                policy_dict[category] = policy[category]\n            else:\n                policy_dict[category] = merge_categories(\n                    policy_dict[category], policy[category]\n                )\n    return cast(PolicyType, policy_dict)\n\n", "CodeBleu_score": 58.22551877501216}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth_providers.{provider}\")\n    except ImportError:\n        _LOGGER.error(\n            \"The module '%s' could not be loaded. The following exception \"\n            \"was thrown: ", "CodeBleu_score": 17.753723006322165}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth_providers.{provider}\")\n    except ImportError:\n        _LOGGER.error(\n            \"Unable to load auth provider %s: module not found\", provider\n        )\n        raise HomeAssistantError(\n            f\"Unable to find auth provider {provider}.\"\n        ) from None\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        for req in module.REQUIREMENTS:\n            if req not in requirements.ALL_REQS:\n                _LOGGER.error(\n                    \"Unable to load auth provider %s: requirement '%s' not found\",\n                    provider,\n                    req,\n                )\n                raise HomeAssistantError(\n                    f\"Unable to find auth provider {provider} requirement {req}.\"\n                ) from None\n\n        await requirements.async_process_requirements(hass, provider, module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 39.24901987896883}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth_providers.{provider}\")\n    except ImportError:\n        raise HomeAssistantError(f\"Unable to load auth provider {provider}\")\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed = await requirements.async_process_requirements(\n        hass, provider, module.REQUIREMENTS\n    )\n    if not processed:\n        return module\n\n    return module\n\n", "CodeBleu_score": 33.42484754568474}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self._store.async_load()\n    except HomeAssistantError:\n        data = None\n\n    if data is None:\n        data = {\"users\": []}\n    if \"users\" not in data:\n        data[\"users\"] = []\n\n    self._data = data\n    self._data_lock = asyncio.Lock()\n\n    # Check for non-normalized usernames\n    self._data[\"users\"] = self._normalize_usernames(self._data[\"users\"])\n\n", "CodeBleu_score": 41.077214418967124}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self._store.async_load()\n    except HomeAssistantError:\n        data = None\n\n    if data is None:\n        data = {\"users\": []}\n\n    if not isinstance(data, Mapping):\n        raise HomeAssistantError(\"Data must be a dictionary\")\n\n    self._users = data[\"users\"]\n\n    # Check for non-normalized usernames\n    for user in self._users:\n        if user[\"username\"] != user[\"username\"].lower():\n            _LOGGER.warning(\n                \"Found non-normalized username %s in store. \"\n                \"This will be migrated to %s\",\n                user[\"username\"],\n                user[\"username\"].lower(),\n            )\n            user[\"username\"] = user[\"username\"].lower()\n\n", "CodeBleu_score": 36.464624591092566}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self._store.async_load()\n    except HomeAssistantError:\n        data = {}\n\n    if not isinstance(data, Mapping):\n        data = {}\n\n    if CONF_USERS not in data:\n        data[CONF_USERS] = []\n\n    # Normalize usernames\n    for user in data[CONF_USERS]:\n        if CONF_USERNAME not in user:\n            user[CONF_USERNAME] = user[CONF_ID]\n\n    self._data = data\n\n", "CodeBleu_score": 29.81983228908073}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy_password\", bcrypt.gensalt())\n    for user in self._users:\n        if user.username == username:\n            if bcrypt.hashpw(password.encode(\"utf-8\"), user.password_hash) == user.password_hash:\n                return\n            raise InvalidAuth()\n    if bcrypt.hashpw(password.encode(\"utf-8\"), dummy_hash) == dummy_hash:\n        raise InvalidAuth()\n    raise InvalidAuth()\n\n", "CodeBleu_score": 33.358877030870474}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    password = password.encode(\"<PASSWORD>\")\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password, stored_hash):\n                return\n            raise InvalidAuth()\n    if bcrypt.checkpw(password, dummy_hash):\n        raise InvalidAuth()\n    raise InvalidAuth()\n\n", "CodeBleu_score": 42.75213554931688}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user[CONF_ID] == username:\n            stored_hash = user[\"password\"]\n            if bcrypt.hashpw(password.encode(\"utf-8\"), stored_hash) == stored_hash:\n                return\n            raise InvalidAuth()\n    if bcrypt.hashpw(password.encode(\"utf-8\"), dummy_hash) == dummy_hash:\n        raise InvalidAuth()\n    raise InvalidAuth()\n\n", "CodeBleu_score": 39.273956825534675}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for index, user in enumerate(self.users):\n        if user[CONF_ID] == username:\n            del self.users[index]\n            return\n    raise ir.InvalidUser(username)\n\n", "CodeBleu_score": 33.26920984426816}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    for user in self.users:\n        if user[CONF_ID] == username:\n            self.users.remove(user)\n            return\n    raise ir.InvalidUser(username)\n\n", "CodeBleu_score": 24.395113583405504}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self._normalize_username(username)\n    if username not in self._users:\n        raise ir.InvalidUser(f\"User {username} not found\")\n    self._users.pop(username)\n\n", "CodeBleu_score": 23.676551223128904}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        await self.async_load()\n    if credentials.data:\n        try:\n            self.data.pop(credentials.data[CONF_ID])\n            await self.async_save()\n        except KeyError:\n            pass\n\n", "CodeBleu_score": 50.197045713986974}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._store.async_is_loaded():\n        await self._store.async_load()\n    if self._store.data.get(\"data\") is None:\n        self._store.data = {\"data\": {}}\n    if self._store.data[\"data\"].get(credentials.username) is None:\n        self._store.data[\"data\"][credentials.username] = {}\n    try:\n        del self._store.data[\"data\"][credentials.username][credentials.auth_provider_type]\n        self._store.async_delay_save(self._data_to_save, 1)\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 47.99440784824593}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        await self.async_load()\n    if credentials.data[CONF_USERNAME] in self.data:\n        del self.data[credentials.data[CONF_USERNAME]]\n        await self.async_save()\n\n", "CodeBleu_score": 47.96560025000659}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        thread_timeout = timeout\n        if thread.ident is not None:\n            thread_timeout = timeout - (time.time() - thread.start_time)\n        if thread_timeout > 0:\n            try:\n                thread.join(thread_timeout)\n            except RuntimeError:\n                pass\n            if thread.is_alive():\n                if log:\n                    logging.error(\n                        f\"Thread {thread.name} ({thread.ident}) did not join within {timeout} seconds\"\n                    )\n                joined.add(thread)\n        else:\n            joined.add(thread)\n    for thread in joined:\n        if thread.ident is not None:\n            thread.join()\n    for thread in threads:\n        if thread.ident is not None:\n            thread.raise_exc(SystemExit)\n    return joined\n\n", "CodeBleu_score": 41.86799033523047}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    start = time.time()\n    with ThreadPoolExecutor(max_workers=len(threads)) as executor:\n        while True:\n            if timeout is not None:\n                remaining = start + timeout - time.time()\n                if remaining <= 0:\n                    break\n            else:\n                remaining = None\n            for thread in threads.copy():\n                if thread.is_alive():\n                    executor.submit(thread.join, timeout=remaining)\n                else:\n                    if thread.ident is not None:\n                        threads.remove(thread)\n                        joined.add(thread)\n                    else:\n                        threads.remove(thread)\n                        if log:\n                            logging.error(\n                                f\"Thread {thread} has no identifier and could not be joined.\"\n                            )\n    for thread in threads:\n        if thread.is_alive():\n            if log:\n                logging.error(\n                    f\"Thread {thread} did not terminate within {timeout} seconds and will be terminated.\"\n                )\n            thread.join(timeout=0)\n            if thread.is_alive():\n                if log:\n                    logging.error(\n                        f\"Thread {thread} did not terminate and will be terminated.\"\n                    )\n                thread.terminate()\n        else:\n            threads.remove(thread)\n            joined.add(thread)\n    if threads:\n        if log:\n            logging.error(\n                f\"The following threads did not terminate within {timeout} seconds and will be terminated: {threads}.\"\n            )\n        for thread in threads:\n            thread.join(timeout=0)\n            if thread.is_alive():\n                if log:\n                    logging.error(\n                        f\"Thread {thread} did not terminate and will be terminated.\"\n                    )\n                thread.terminate()\n    return joined\n\n", "CodeBleu_score": 40.415037061772594}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    if timeout > 0:\n        for thread in threads:\n            if thread.is_alive():\n                thread.join(timeout=timeout)\n            if thread.is_alive():\n                if log:\n                    logging.warning(\n                        \"Thread %s did not stop within the specified timeout of %s seconds\",\n                        thread.name,\n                        timeout,\n                    )\n                joined.add(thread)\n    else:\n        for thread in threads:\n            if thread.is_alive():\n                thread.join()\n            if thread.is_alive():\n                if log:\n                    logging.warning(\n                        \"Thread %s did not stop within the specified timeout of %s seconds\",\n                        thread.name,\n                        timeout,\n                    )\n                joined.add(thread)\n    for thread in threads:\n        if thread.is_alive():\n            if log:\n                logging.warning(\"Thread %s did not stop\", thread.name)\n            try:\n                thread.raise_exception()\n            except Exception:\n                pass\n            joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 37.049640888598326}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    if threading.current_thread() is threading.main_thread():\n        logging.warning(\"deadlock_safe_shutdown called from main thread. This will deadlock.\")\n        return\n    current_thread = threading.current_thread()\n    current_thread_name = current_thread.name\n    current_thread_ident = current_thread.ident\n    current_thread_is_daemon = current_thread.daemon\n    current_thread_is_alive = current_thread.is_alive()\n    current_thread_is_main = current_thread_name == \"MainThread\"\n    if current_thread_is_main:\n        logging.warning(\"deadlock_safe_shutdown called from main thread. This will deadlock.\")\n        return\n    if current_thread_is_daemon:\n        logging.warning(\"deadlock_safe_shutdown called from daemon thread. This will deadlock.\")\n        return\n    if not current_thread_is_alive:\n        logging.warning(\"deadlock_safe_shutdown called from dead thread. This will deadlock.\")\n        return\n    if current_thread_ident == 1:\n        logging.warning(\"deadlock_safe_shutdown called from main thread. This will deadlock.\")\n        return\n    current_thread_frame = inspect.currentframe()\n    if current_thread_frame is None:\n        logging.warning(\"deadlock_safe_shutdown called from unknown thread. This will deadlock.\")\n        return\n    current_thread_frame = current_thread_frame.f_back\n    if current_thread_frame is None:\n        logging.warning(\"deadlock_safe_shutdown called from unknown thread. This will deadlock.\")\n        return\n    current_thread_frame_name = current_thread_frame.f_code.co_name\n    if current_thread_frame_name != \"run\":\n        logging.warning(\"deadlock_safe_shutdown called from unknown thread. This will deadlock.\")\n        return\n    main_thread = threading.main_thread()\n    main_thread_ident = main_thread.ident\n    main_thread_is_alive = main_thread.is_alive()\n    if not main_thread_is_alive:\n        logging.warning(\"deadlock_safe_shutdown called from main thread that is dead. This will deadlock.\")\n        return\n    main_thread_frame = inspect.getouterframes(main_thread_ident)[1][0]\n    main_thread", "CodeBleu_score": 27.207028714610882}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get all threads except main and daemon threads\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread != threading.main_thread() and not thread.daemon\n    ]\n\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = int(\n        (\n            int(\n                os.environ.get(\n                    \"SHUTDOWN_TIMEOUT\",\n                    str(\n                        int(\n                            (\n                                int(os.environ.get(\"SHUTDOWN_GRACE_PERIOD\", \"5\"))\n                                + int(os.environ.get(\"SHUTDOWN_WAIT_PERIOD\", \"5\"))\n                            )\n                            * 1.5\n                        )\n                    ),\n                )\n            )\n            / len(threads)\n        )\n        + 1\n    )\n\n    # Join each thread within the calculated timeout\n    for thread in threads:\n        thread.join(timeout=timeout)\n\n        # Log a warning if joining a thread fails\n        if thread.is_alive():\n            logging.warning(\n                f\"Failed to join thread {thread.name} within {timeout} seconds.\"\n            )\n\n", "CodeBleu_score": 30.448149615114282}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get the current stack frame\n    current_frame = inspect.currentframe()\n    # Get the current thread\n    current_thread = threading.current_thread()\n    # Get the stack frames for all threads\n    frames = sys._current_frames()\n    # Get the total shutdown timeout\n    total_shutdown_timeout = 10\n    # Get the number of remaining threads\n    remaining_threads = 0\n    # Get the list of non-main, non-daemon, alive threads\n    non_main_non_daemon_alive_threads = []\n    for thread_id, stack_frame in frames.items():\n        # Get the thread object\n        thread = threading._active.get(thread_id)\n        # Check if the thread is not the main thread\n        if thread is not current_thread:\n            # Check if the thread is not a daemon\n            if not thread.daemon:\n                # Check if the thread is alive\n                if thread.is_alive():\n                    # Add the thread to the list of non-main, non-daemon, alive threads\n                    non_main_non_daemon_alive_threads.append(thread)\n                    # Increment the number of remaining threads\n                    remaining_threads += 1\n    # Calculate the timeout for each thread\n    timeout = total_shutdown_timeout / remaining_threads\n    # Iterate over all non-main, non-daemon, alive threads\n    for thread in non_main_non_daemon_alive_threads:\n        # Attempt to join the thread within the calculated timeout\n        thread.join(timeout=timeout)\n        # Check if joining the thread failed\n        if thread.is_alive():\n            # Log a warning\n            logging.warning(\n                \"Deadlock detected while shutting down. \"\n                f\"The thread {thread.name} is still alive.\"\n            )\n\n", "CodeBleu_score": 27.354965132589736}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_remaining_with_setup_started:\n        self._dispatcher.dispatch(remaining_with_setup_started)\n        self._previous_remaining_with_setup_started = remaining_with_setup_started\n    self._remaining_with_setup_started = bool(remaining_with_setup_started)\n\n def _async_wait_for_dispatcher(self) -> None:\n    \"\"\"The function \"_async_wait_for_dispatcher\" waits for an internal dispatcher signal and then dispatches it.\"\"\"\n    await self._dispatcher.wait_for()\n    self._async_dispatch(self._dispatcher.signal)\n\n def _async_wait_for_setup(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_wait_for_setup\" waits for a setup to finish and then dispatches a signal with the remaining setups.\"\"\"\n    await self._setup_locks[setup_name].acquire()\n    self._setup_locks[setup_name].release()\n    self._async_dispatch(self._setup_locks)\n\n def _async_wait_for_setups(self, setup_names: list[str]) -> None:\n    \"\"\"The function \"_async_wait_for_setups\" waits for all setups to finish and then dispatches a signal with the remaining setups.\"\"\"\n    await asyncio.gather(*[self._setup_locks[setup_name].acquire() for setup_name in setup_names])\n    for setup_name in setup_names:\n        self._setup_locks[setup_name].release()\n    self._async_dispatch(self._setup_locks)\n\n def _async_wait_for_setups_and_dispatch(self, setup_names: list[str]) -> None:\n    \"\"\"The function \"_async_wait_for_setups_and_dispatch\" waits for all setups to finish and then dispatches a signal with the remaining setups.\"\"\"\n    await asyncio.gather(*[self._setup_locks[setup_name].acquire() for setup_name in setup_names])\n    for setup_name in setup_names:\n        self._setup_locks[setup_name].release()\n    self._async_dispatch(self._setup_locks)\n\n def _async_wait_for_setups_and_dispatch_if_remaining(self, setup_names", "CodeBleu_score": 46.40562538477141}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_remaining_with_setup_started:\n        self._dispatch_signal.send(remaining_with_setup_started)\n    self._previous_remaining_with_setup_started = remaining_with_setup_started\n    self._remaining_with_setup_started = bool(remaining_with_setup_started)\n\n def _async_wait(self, timeout: float = None) -> None:\n    \"\"\"The function \"_async_wait\" waits for the internal dispatcher signal to be sent.", "CodeBleu_score": 51.00680518747181}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._dispatch_remaining_with_setup_started = remaining_with_setup_started\n        self._dispatch_remaining_with_setup_started_event.set()\n    elif self._dispatch_remaining_with_setup_started:\n        self._dispatch_remaining_with_setup_started_event.clear()\n        self._dispatch_remaining_with_setup_started = {}\n    else:\n        self._dispatch_remaining_with_setup_started_event.clear()\n\n def _async_dispatch_remaining_with_setup_started(self) -> None:\n    \"\"\"The function \"_async_dispatch_remaining_with_setup_started\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 30.785299826011258}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    # If the user has not specified any integrations to validate, we will validate all integrations.\n    if not config.integrations:\n        config.integrations = integrations.keys()\n\n    # If the user has specified integrations to validate, we will validate only those integrations.\n    else:\n        # Check that all specified integrations are valid.\n        for integration in config.integrations:\n            if integration not in integrations:\n                raise InvalidConfiguration(\n                    f\"Integration '{integration}' does not exist.\"\n                )\n\n    # If the user has not specified any integrations to ignore, we will not ignore any integrations.\n    if not config.ignore:\n        config.ignore = []\n\n    # If the user has specified integrations to ignore, we will ignore those integrations.\n    else:\n        # Check that all specified integrations are valid.\n        for integration in config.ignore:\n            if integration not in integrations:\n                raise InvalidConfiguration(\n                    f\"Integration '{integration}' does not exist.\"\n                )\n\n    # Generate the content of bluetooth.py.\n    content = generate(integrations, config)\n\n    # If the user has not specified a configuration file, we will validate the content against the default configuration file.\n    if not config.config:\n        config_file = DEFAULT_CONFIG_FILE\n    else:\n        config_file = config.config\n\n    # If the user has specified a configuration file, we will validate the content against the specified configuration file.\n    if config.config:\n        config_file = config.config\n\n    # Read the current content of bluetooth.py.\n    with open(config_file, \"r\") as file:\n        current_content = file.read()\n\n    # If the current content of bluetooth.py is different from the generated content, we will add an error to the configuration indicating that bluetooth.py is not up to date and providing a fixable suggestion.\n    if content != current_content:\n        error = (\n            \"The content of 'bluetooth.py' is not up to date. \"\n            \"Run 'python3 -m homeassistant --script check_config' to check for errors.\"\n        )\n        suggestion = f\"This can be fixed by running 'python3 -m homeassistant --script generate_config --config {config_file}'\"\n\n        config.add_error(error, suggestion)\n", "CodeBleu_score": 32.46044708092929}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    if config.core.disabled_integrations:\n        return\n\n    if \"bluetooth\" not in config.components:\n        return\n\n    if not config.integrations:\n        return\n\n    if \"bluetooth\" not in config.integrations:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"devices\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"whitelist\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"allowlist\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"allowlist_external_dirs\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"scan_interval\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"passive\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"hci_interface\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"btle_interface\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"btle_whitelist\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"btle_blacklist\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"btle_passive_scan\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"btle_active_scan\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"btle_discover_by_filter\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"btle_scan_timeout\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"btle_scan_passive_timeout\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"btle_scan_active_timeout\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].config_entries[0].options[\"btle_scan_dup_cache_size\"]:\n        return\n\n    if not config.integrations[\"bluetooth\"].", "CodeBleu_score": 21.61551987823002}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    # Generate the content of bluetooth.py\n    content = generate(integrations, config)\n\n    # Check if bluetooth.py is up to date\n    if config.cache.bluetooth_content != content:\n        config.cache.bluetooth_content = content\n        config.cache.bluetooth_error = True\n        config.cache.bluetooth_error_fix = f\"The content of {config.root}/bluetooth.py is not up to date. Run 'python3 -m script.hassfest' to update it.\"\n\n    # Check if bluetooth.py is empty\n    if not content:\n        config.cache.bluetooth_error = True\n        config.cache.bluetooth_error_fix = f\"The content of {config.root}/bluetooth.py is empty. Run 'python3 -m script.hassfest' to update it.\"\n", "CodeBleu_score": 31.063290981516285}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\t// The refresh token is required to be set before calling this function.\n\tif d.RefreshToken == \"\" {\n\t\treturn fmt.Errorf(\"refresh token is not set\")\n\t}\n\n\t// Create a new resty client.\n\tclient := resty.New()\n\n\t// Set the content type to URL encoded form.\n\tclient.SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Set the base URL for the request.\n\tclient.SetBaseURL(\"https://api.dropboxapi.com/oauth2/token\")\n\n\t// Create the request body.\n\tbody := fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s&client_id=%s&client_secret=%s\", d.RefreshToken, d.AppKey, d.AppSecret)\n\n\t// Send the request.\n\tresp, err := client.R().\n\t\tSetBody(body).\n\t\tPost(\"\")\n\n\t// Check for errors.\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check the status code.\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"Error refreshing access token\",\n\t\t\tzap.String(\"status\", resp.Status()),\n\t\t\tzap.Int(\"status_code\", resp.StatusCode()),\n\t\t\tzap.String(\"response\", resp.String()),\n\t\t)\n\t\treturn fmt.Errorf(\"error refreshing access token: %s\", resp.String())\n\t}\n\n\t// Decode the response body into a map.\n\tvar data map[string]interface{}\n\terr = base.DecodeJSONBody(resp, &data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Update the access token.\n\td.AccessToken = data[\"access_token\"].(string)\n\n\t// Return no error.\n\treturn nil\n}", "CodeBleu_score": 49.280355657743804}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Get the refresh token from the driver\n\trefreshToken := d.RefreshToken\n\t// Get the app key from the driver\n\tappKey := d.AppKey\n\t// Get the app secret from the driver\n\tappSecret := d.AppSecret\n\n\t// Create a new request\n\treq := resty.R()\n\n\t// Set the request method to POST\n\treq.SetMethod(http.MethodPost)\n\n\t// Set the request URL to the Dropbox OAuth2 token endpoint\n\treq.SetURL(\"https://api.dropboxapi.com/oauth2/token\")\n\n\t// Set the request body to the refresh token, app key, and app secret\n\treq.SetBody(fmt.Sprintf(\"refresh_token=%s&grant_type=refresh_token&client_id=%s&client_secret=%s\", refreshToken, appKey, appSecret))\n\n\t// Set the request header content type to \"application/x-www-form-urlencoded\"\n\treq.SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the request\n\tresp, err := req.Send()\n\n\t// Check if there was an error\n\tif err != nil {\n\t\t// Log the error\n\t\tlogger.Log.Error(\"Error refreshing Dropbox access token\",\n\t\t\tzap.String(\"error\", err.Error()),\n\t\t\tzap.String(\"refreshToken\", refreshToken),\n\t\t\tzap.String(\"appKey\", appKey),\n\t\t\tzap.String(\"appSecret\", appSecret))\n\n\t\t// Return the error\n\t\treturn err\n\t}\n\n\t// Check if the response status code was 200 OK\n\tif resp.StatusCode() != http.StatusOK {\n\t\t// Log the response status code\n\t\tlogger.Log.Error(\"Error refreshing Dropbox access token\",\n\t\t\tzap.Int(\"statusCode\", resp.StatusCode()),\n\t\t\tzap.String(\"refreshToken\", refreshToken),\n\t\t\tzap.String(\"appKey\", appKey),\n\t\t\tzap.String(\"appSecret\", appSecret))\n\n\t\t// Return an error\n\t\treturn base.ErrUnexpectedStatusCode\n\t}\n\n\t// Get the response body\n\tbody := resp.Body()\n\n\t// Get the access token from the response body\n\taccessToken := body[\"access_token\"]\n\n\t// Update the driver access token\n\t", "CodeBleu_score": 43.217761157322165}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create a resty client\n\tclient := resty.New()\n\t// Set the base URL for the Dropbox OAuth2 token endpoint\n\tclient.SetBaseURL(\"https://api.dropboxapi.com/oauth2/token\")\n\t// Set the Content-Type header for the request to \"application/x-www-form-urlencoded\"\n\tclient.SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t// Create the request body\n\tdata := fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s&client_id=%s&client_secret=%s\", d.RefreshToken, d.AppKey, d.AppSecret)\n\t// Send the POST request to the Dropbox OAuth2 token endpoint\n\tresp, err := client.R().\n\t\tSetBody(data).\n\t\tPost(\"\")\n\t// If an error occurs, log it and return it\n\tif err != nil {\n\t\tlogger.Log.Error(\"Error refreshing access token\", zap.Error(err))\n\t\treturn err\n\t}\n\t// If the status code is not 200, log the response and return an error\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Log.Error(\"Error refreshing access token\", zap.Error(base.ErrBadAPIResponse))\n\t\treturn base.ErrBadAPIResponse\n\t}\n\t// Decode the response body into the access token\n\terr = resp.JSON(d)\n\t// If an error occurs, log it and return it\n\tif err != nil {\n\t\tlogger.Log.Error(\"Error refreshing access token\", zap.Error(err))\n\t\treturn err\n\t}\n\t// Return nil if no errors occur\n\treturn nil\n}", "CodeBleu_score": 47.530547795361734}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// Create a request with the given method and URL.\n\treq := d.client.R().SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken).SetHeader(\"Accept\", \"application/json\").SetHeader(\"Content-Type\", \"application/json\").SetHeader(\"User-Agent\", \"CasaOS\").SetHeader(\"x-goog-api-client\", \"gdcl/1.11.0 gl-go/1.11.0 gdcl/1.11.0\").SetBody(callback)\n\tif method == \"POST\" {\n\t\treq = d.client.R().SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken).SetHeader(\"Accept\", \"application/json\").SetHeader(\"Content-Type\", \"application/json\").SetHeader(\"User-Agent\", \"CasaOS\").SetHeader(\"x-goog-api-client\", \"gdcl/1.11.0 gl-go/1.11.0 gdcl/1.11.0\").SetBody(callback).SetResult(resp)\n\t} else if method == \"GET\" {\n\t\treq = d.client.R().SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken).SetHeader(\"Accept\", \"application/json\").SetHeader(\"Content-Type\", \"application/json\").SetHeader(\"User-Agent\", \"CasaOS\").SetHeader(\"x-goog-api-client\", \"gdcl/1.11.0 gl-go/1.11.0 gdcl/1.11.0\").SetResult(resp)\n\t} else if method == \"PUT\" {\n\t\treq = d.client.R().SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken).SetHeader(\"Accept\", \"application/json\").SetHeader(\"Content-Type\", \"application/json\").SetHeader(\"User-Agent\", \"CasaOS\").SetHeader(\"x-goog-api-client\", \"gdcl/1.11.0 gl-go/1.11.0 gdcl/1.11.0\").SetBody(callback).SetResult(resp)\n\t} else if method == \"DELETE\" {\n\t\treq = d.client.R().SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken).SetHeader(\"Accept\", \"application/json\").SetHeader(\"Content-Type\", \"", "CodeBleu_score": 32.21415092347255}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar err error\n\tvar response *resty.Response\n\tvar req *resty.Request\n\treq = d.client.R().SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tresponse, err = req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif response.IsError() {\n\t\tif response.StatusCode() == http.StatusUnauthorized {\n\t\t\terr = d.RefreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"Error: %s\", response.String())\n\t}\n\tif resp != nil {\n\t\terr = response.JSON(resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn response.Body(), nil\n}", "CodeBleu_score": 57.74520851463082}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\treq.SetHeader(\"Content-Type\", \"application/json\")\n\treq.SetHeader(\"Accept\", \"application/json\")\n\treq.SetHeader(\"User-Agent\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36\")\n\treq.SetHeader(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"X-Upload-Content-Length\", \"0\")\n\treq.SetHeader(\"X-Upload-Content-MD5\", \"\")\n\treq.SetHeader(\"X-Drive-First-Party\", \"DriveWebUi\")\n\treq.SetHeader(\"X-Origin\", \"https://drive.google.com\")\n\treq.SetHeader(\"X-Referer\", \"https://drive.google.com/\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\treq.SetHeader(\"X-Goog-Upload-Header-Content-Length\", \"0\")\n\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"resumable\")\n\treq.SetHeader(\"X-Goog-Upload-Raw-Size\", \"0\")\n\treq.SetHeader(\"X-Goog-Upload-URL\", url)\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\treq.SetHeader(\"X-Goog-Upload-Offset\", \"0\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"", "CodeBleu_score": 18.429558212171298}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size\n\tchunkSize, err := utils.CalculateChunkSize(stream.Size(), d.ChunkSize)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Initialize the HTTP client\n\tclient := resty.New()\n\tclient.SetRedirectPolicy(resty.FlexibleRedirectPolicy(3))\n\n\t// Upload each chunk sequentially\n\tfor i := 0; i < stream.ChunkCount(); i++ {\n\t\t// Create a new HTTP request\n\t\treq := client.R()\n\t\treq.SetContext(ctx)\n\t\treq.SetHeader(\"Content-Length\", fmt.Sprintf(\"%d\", chunkSize))\n\t\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", i*chunkSize, (i+1)*chunkSize-1, stream.Size()))\n\t\treq.SetHeader(\"Content-Type\", \"application/octet-stream\")\n\t\treq.SetBody(stream.Chunk(i))\n\n\t\t// Execute the request and handle errors\n\t\tresp, err := req.Post(url)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif resp.IsError() {\n\t\t\treturn fmt.Errorf(\"upload failed: %s\", resp.Status())\n\t\t}\n\t}\n\n\t// Upload the file\n\treq := client.R()\n\treq.SetContext(ctx)\n\treq.SetBody(stream)\n\tresp, err := req.Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif resp.IsError() {\n\t\treturn fmt.Errorf(\"upload failed: %s\", resp.Status())\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 40.9188066174863}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Get the file size.\n\tfileSize, err := stream.Size()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the chunk size.\n\t// The chunk size must be a multiple of 256 KB per the API specification.\n\tchunkSize := base.ChunkSize\n\tif chunkSize%base.ChunkSizeBoundary != 0 {\n\t\tchunkSize += base.ChunkSizeBoundary - chunkSize%base.ChunkSizeBoundary\n\t}\n\n\t// Upload the file in chunks.\n\tvar uploaded int64\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\t// Read a chunk.\n\t\t\tchunk := make([]byte, chunkSize)\n\t\t\tn, err := stream.Read(chunk)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\t// The entire file has been uploaded.\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Upload the chunk.\n\t\t\tif err := d.uploadChunk(ctx, url, chunk[:n]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Update the number of bytes uploaded.\n\t\t\tuploaded += int64(n)\n\n\t\t\t// Check if the entire file has been uploaded.\n\t\t\tif uploaded == fileSize {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.936201694496496}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tvar err error\n\tvar chunkSize int64 = 1024 * 1024 * 1024 // 1GB\n\tvar uploaded int64\n\tvar totalSize int64 = stream.Size()\n\tvar chunkCount int64 = totalSize / chunkSize\n\tif totalSize%chunkSize > 0 {\n\t\tchunkCount += 1\n\t}\n\tfor i := int64(0); i < chunkCount; i++ {\n\t\tvar r io.Reader\n\t\tvar buf []byte\n\t\tif i == chunkCount-1 {\n\t\t\tbuf = make([]byte, totalSize-uploaded)\n\t\t\tr = stream\n\t\t} else {\n\t\t\tbuf = make([]byte, chunkSize)\n\t\t\t_, err = stream.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tr = bytes.NewReader(buf)\n\t\t}\n\t\terr = d.uploadChunk(ctx, r, url, i, chunkCount)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuploaded += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 40.46919192595298}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tmount_point := ctx.FormValue(\"mount_point\")\n\tif mount_point == \"\" {\n\t\treturn ctx.JSON(common_err.StorageMountPointEmpty.Code, common_err.StorageMountPointEmpty.Error())\n\t}\n\tmount_point = strings.TrimSpace(mount_point)\n\tif strings.HasSuffix(mount_point, \"/\") {\n\t\tmount_point = mount_point[:len(mount_point)-1]\n\t}\n\t// Get the storage configuration\n\tstorage := model.StorageConf{}\n\tif err := storage.GetByMountPoint(mount_point); err != nil {\n\t\treturn ctx.JSON(common_err.StorageConfigNotExist.Code, common_err.StorageConfigNotExist.Error())\n\t}\n\t// Unmount the storage\n\tif err := service.UmountStorage(storage); err != nil {\n\t\treturn ctx.JSON(common_err.StorageUnmountFail.Code, common_err.StorageUnmountFail.Error())\n\t}\n\t// Delete the configuration\n\tif err := storage.Delete(); err != nil {\n\t\treturn ctx.JSON(common_err.StorageConfigDeleteFail.Code, common_err.StorageConfigDeleteFail.Error())\n\t}\n\treturn ctx.JSON(common_err.Success.Code, common_err.Success.Error())\n}", "CodeBleu_score": 38.24415266400917}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar (\n\t\terr      error\n\t\tmount_id string\n\t\tconfig   model.StorageConfig\n\t\tuser     model.User\n\t)\n\tmount_id = ctx.Param(\"mount_id\")\n\tif mount_id == \"\" {\n\t\treturn ctx.JSON(common_err.ErrInvalidParam.GetCode(), common_err.ErrInvalidParam.GetMsg())\n\t}\n\tuser = ctx.Get(\"user\").(model.User)\n\tconfig, err = service.GetStorageConfig(mount_id)\n\tif err != nil {\n\t\tlogger.Error(\"GetStorageConfig\", zap.String(\"err\", err.Error()))\n\t\treturn ctx.JSON(common_err.ErrGetStorageConfig.GetCode(), common_err.ErrGetStorageConfig.GetMsg())\n\t}\n\tif config.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.ErrMountPointNotFound.GetCode(), common_err.ErrMountPointNotFound.GetMsg())\n\t}\n\tif strings.Contains(config.MountPoint, \"OneDrive\") {\n\t\terr = onedrive.Unmount(config.MountPoint)\n\t} else if strings.Contains(config.MountPoint, \"GoogleDrive\") {\n\t\terr = google_drive.Unmount(config.MountPoint)\n\t} else if strings.Contains(config.MountPoint, \"Dropbox\") {\n\t\terr = dropbox.Unmount(config.MountPoint)\n\t}\n\tif err != nil {\n\t\tlogger.Error(\"Unmount\", zap.String(\"err\", err.Error()))\n\t\treturn ctx.JSON(common_err.ErrUnmount.GetCode(), common_err.ErrUnmount.GetMsg())\n\t}\n\terr = service.DelStorageConfig(mount_id)\n\tif err != nil {\n\t\tlogger.Error(\"DelStorageConfig\", zap.String(\"err\", err.Error()))\n\t\treturn ctx.JSON(common_err.ErrDelStorageConfig.GetCode(), common_err.ErrDelStorageConfig.GetMsg())\n\t}\n\t//\u6e05\u9664\u7f13\u5b58\n\terr = httper.DelFileCache(user.ID)\n\tif err != nil {\n\t\tlogger.Error(\"DelFileCache\", zap.String(\"err\", err.Error()))\n\t}\n\treturn ctx.JSON", "CodeBleu_score": 31.251431438315226}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tmountPoint := ctx.FormValue(\"mount_point\")\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.ErrInvalidParam.GetCode(), common_err.ErrInvalidParam.GetMsg())\n\t}\n\tif strings.Contains(mountPoint, \"google_drive\") {\n\t\tif !google_drive.CheckMounted(mountPoint) {\n\t\t\treturn ctx.JSON(common_err.ErrStorageNotMounted.GetCode(), common_err.ErrStorageNotMounted.GetMsg())\n\t\t}\n\t\tif err := google_drive.Umount(mountPoint); err != nil {\n\t\t\treturn ctx.JSON(common_err.ErrStorageUmountFail.GetCode(), common_err.ErrStorageUmountFail.GetMsg())\n\t\t}\n\t\t//\u5220\u9664\u914d\u7f6e\n\t\tmodel.DB.Where(\"mount_point = ?\", mountPoint).Delete(&model.Storage)\n\t\treturn ctx.JSON(httper.StatusOK, \"success\")\n\t} else if strings.Contains(mountPoint, \"dropbox\") {\n\t\tif !dropbox.CheckMounted(mountPoint) {\n\t\t\treturn ctx.JSON(common_err.ErrStorageNotMounted.GetCode(), common_err.ErrStorageNotMounted.GetMsg())\n\t\t}\n\t\tif err := dropbox.Umount(mountPoint); err != nil {\n\t\t\treturn ctx.JSON(common_err.ErrStorageUmountFail.GetCode(), common_err.ErrStorageUmountFail.GetMsg())\n\t\t}\n\t\t//\u5220\u9664\u914d\u7f6e\n\t\tmodel.DB.Where(\"mount_point = ?\", mountPoint).Delete(&model.Storage)\n\t\treturn ctx.JSON(httper.StatusOK, \"success\")\n\t} else if strings.Contains(mountPoint, \"onedrive\") {\n\t\tif !onedrive.CheckMounted(mountPoint) {\n\t\t\treturn ctx.JSON(common_err.ErrStorageNotMounted.GetCode(), common_err.ErrStorageNotMounted.GetMsg())\n\t\t}\n\t\tif err := onedrive.Umount(mountPoint); err != nil {\n\t\t\treturn ctx.JSON(common_err.ErrStorageUmountFail.GetCode(), common_err.ErrStorageUmountFail.GetMsg())\n\t\t}\n\t\t//\u5220\u9664\u914d\u7f6e\n\t\t", "CodeBleu_score": 40.94856632410399}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tlogger.ServerLogger.Info(\"GetLocalFile\")\n\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Code: common_err.LocalFileGet_PATH_ERR.GetCode(), Message: common_err.LocalFileGet_PATH_ERR.GetMsg()})\n\t}\n\tif !file.IsExist(path) {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Code: common_err.LocalFileGet_FILE_NOT_EXIST.GetCode(), Message: common_err.LocalFileGet_FILE_NOT_EXIST.GetMsg()})\n\t}\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Code: common_err.LocalFileGet_FILE_OPEN_ERR.GetCode(), Message: common_err.LocalFileGet_FILE_OPEN_ERR.GetMsg()})\n\t}\n\tdefer file.Close()\n\tdata, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Code: common_err.LocalFileGet_FILE_READ_ERR.GetCode(), Message: common_err.LocalFileGet_FILE_READ_ERR.GetMsg()})\n\t}\n\tctx.Response().Header().Set(\"Content-Disposition\", \"attachment; filename=\"+filepath.Base(path))\n\tctx.Response().Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tctx.Response().Header().Set(\"Content-Length\", strconv.FormatInt(file.Size(), 10))\n\t_, err = ctx.Response().Write(data)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, model.Result{Code: common_err.LocalFileGet_FILE_WRITE_ERR.GetCode(), Message: common_err.LocalFileGet_FILE_WRITE_ERR.GetMsg()})\n\t}\n\treturn nil\n}", "CodeBleu_score": 45.514860700846015}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tlog.Println(\"GetLocalFile\")\n\tfilePath := ctx.QueryParam(\"path\")\n\tlog.Println(filePath)\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusOK, common_err.ErrInvalidParams)\n\t}\n\tif !file.IsExist(filePath) {\n\t\treturn ctx.JSON(http.StatusOK, common_err.ErrFileNotFound)\n\t}\n\tf, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.ErrOpenFile)\n\t}\n\tdefer f.Close()\n\tfi, _ := f.Stat()\n\thttp.ServeContent(ctx.Response(), ctx.Request(), fi.Name(), fi.ModTime(), f)\n\treturn nil\n}", "CodeBleu_score": 41.251357975092404}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tvar err error\n\tvar file_path string\n\tvar file_name string\n\tvar file_type string\n\tvar file_size int\n\tvar file_content []byte\n\tvar file_info os.FileInfo\n\tvar is_download bool\n\tvar is_share bool\n\tvar is_edit bool\n\tvar is_view bool\n\tvar is_view_only bool\n\tvar is_view_only_edit bool\n\tvar is_view_only_share bool\n\tvar is_view_only_download bool\n\tvar is_share_only bool\n\tvar is_download_only bool\n\tvar is_edit_only bool\n\tvar is_view_only_share_download bool\n\tvar is_view_only_share_edit bool\n\tvar is_view_only_share_download_edit bool\n\tvar is_share_download bool\n\tvar is_share_edit bool\n\tvar is_share_download_edit bool\n\tvar is_download_edit bool\n\tvar is_share_download_edit_view bool\n\tvar is_share_download_edit_view_only bool\n\tvar is_share_download_edit_view_only_download bool\n\tvar is_share_download_edit_view_only_edit bool\n\tvar is_share_download_edit_view_only_share bool\n\tvar is_share_download_edit_view_only_share_download bool\n\tvar is_share_download_edit_view_only_share_edit bool\n\tvar is_share_download_edit_view_only_share_download_edit bool\n\tvar is_share_download_edit_view_only_share_download_edit_view bool\n\tvar is_share_download_edit_view_only_share_download_edit_view_only bool\n\tvar is_share_download_edit_view_only_share_download_edit_view_only_download bool\n\tvar is_share_download_edit_view_only_share_download_edit_view_only_edit bool\n\tvar is_share_download_edit_view_only_share_download_edit_view_only_share bool\n\tvar is_share_download_edit_view_only_share_download_edit", "CodeBleu_score": 4.549240306061671}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := new(model.Message)\n\tif err := ctx.Bind(message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequest(err))\n\t}\n\tservice.GetNotify().SendMessage(name, message)\n\treturn ctx.JSON(http.StatusOK, common_err.Success())\n}", "CodeBleu_score": 45.9232685161412}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message model.NotifyMessage\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequest(err.Error()))\n\t}\n\tservice.NotifyService().Send(name, message)\n\treturn ctx.JSON(http.StatusOK, common_err.Success())\n}", "CodeBleu_score": 49.282090187924055}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message model.Message\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequest(err))\n\t}\n\tif err := service.NotifyService().Send(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequest(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.Success())\n}", "CodeBleu_score": 55.30028331049941}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\tservice.NotifyService.Add(conn)\n\tfor {\n\t\tmt, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(mt, message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 45.76955165559953}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection.\n\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\t// Add the new WebSocket connection to the list of connections.\n\tservice.NotifyWSList = append(service.NotifyWSList, conn)\n\t// Start the message sending service.\n\tgo service.Notify()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t// Read a message from the WebSocket connection.\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Println(messageType, string(message), err)\n\t}\n\t// Remove the WebSocket connection from the list of connections.\n\tservice.NotifyWSList = remove(service.NotifyWSList, conn)\n\treturn nil\n}", "CodeBleu_score": 48.48247736731033}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\tfmt.Println(\"Client connected\")\n\tservice.NotifyService.AddConn(ws)\n\tdefer service.NotifyService.RemoveConn(ws)\n\tfor {\n\t\t// Read message from WebSocket connection\n\t\tmessage := types.NotifyMessage{}\n\t\terr = ws.ReadJSON(&message)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tservice.NotifyService.RemoveConn(ws)\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type and message\n\t\tfmt.Printf(\"recv: %s\n\", message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 44.64956955538448}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tif !config.SystemInit {\n\t\treturn ctx.JSON(http.StatusOK, common.ResponseFailed(common_err.SystemNotInit))\n\t}\n\tcpuInfo := utils.GetCPUInfo()\n\tif cpuInfo == nil {\n\t\treturn ctx.JSON(http.StatusOK, common.ResponseSuccess(nil))\n\t}\n\treturn ctx.JSON(http.StatusOK, common.ResponseSuccess(cpuInfo))\n}", "CodeBleu_score": 18.421544563256294}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\tresult model2.SystemHardwareInfo\n\t)\n\tresult.CPU = GetCPUInfo()\n\tresult.Disk = GetDiskInfo()\n\tresult.Mem = GetMemInfo()\n\tresult.OS = GetOSInfo()\n\tresult.Net = GetNetInfo()\n\tresult.Time = GetTimeInfo()\n\tresult.Host = GetHostInfo()\n\tresult.Docker = GetDockerInfo()\n\tresult.DockerInfo = GetDockerInfo()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerInfo = GetDockerInfo()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion()\n\tresult.DockerVersion = GetDockerVersion", "CodeBleu_score": 15.092434869997106}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar res model.Response\n\tres.Code = 0\n\tres.Msg = \"Success\"\n\tres.Data = model.SystemHardwareInfo{\n\t\tCPUInfo: model.CPUInfo{\n\t\t\tNum:    runtime.NumCPU(),\n\t\t\tArch:   runtime.GOARCH,\n\t\t\tModel:  runtime.GOOS,\n\t\t\tVendor: runtime.GOOS,\n\t\t},\n\t\tDriveInfo: model.DriveInfo{\n\t\t\tName:    \"C:\",\n\t\t\tModel:   \"C:\",\n\t\t\tArch:    \"C:\",\n\t\t\tVendor:  \"C:\",\n\t\t\tTotal:   \"C:\",\n\t\t\tUsed:    \"C:\",\n\t\t\tFree:    \"C:\",\n\t\t\tPercent: \"C:\",\n\t\t},\n\t}\n\treturn ctx.JSON(http.StatusOK, res)\n}", "CodeBleu_score": 26.421652046421567}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar running, notRunning []string\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif systemctl.IsRunning(service) {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 67.37460870088174}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar runningServices []string\n\tvar notRunningServices []string\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tif port.IsPortOpen(service) {\n\t\t\t\trunningServices = append(runningServices, service)\n\t\t\t} else {\n\t\t\t\tnotRunningServices = append(notRunningServices, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 55.508176489310515}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar runningServices, notRunningServices []string\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif port.IsPortOpen(\"127.0.0.1\", 9000) {\n\t\t\t\trunningServices = append(runningServices, service)\n\t\t\t} else {\n\t\t\t\tnotRunningServices = append(notRunningServices, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 58.79023832137721}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tif len(name) == 0 {\n\t\treturn\n\t}\n\t// Create a new event\n\te := model.Event{\n\t\tName: name,\n\t}\n\t// Add the message values to the event\n\tfor k, v := range message {\n\t\te.Data[k] = v\n\t}\n\t// Publish the event\n\tif err := i.broker.Publish(e); err != nil {\n\t\tlogger.Error(\"Error publishing event\", zap.String(\"event\", e.Name), zap.Error(err))\n\t}\n}", "CodeBleu_score": 31.515897665174975}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tlogger.Info(\"Send Notify\",\n\t\tzap.String(\"name\", name),\n\t\tzap.Any(\"message\", message))\n\tmsg, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Send Notify\",\n\t\t\tzap.String(\"name\", name),\n\t\t\tzap.Any(\"message\", message),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\terr = i.notify.Publish(context.Background(), &notify.Event{\n\t\tName:   name,\n\t\tFields: msg,\n\t})\n\tif err != nil {\n\t\tlogger.Error(\"Send Notify\",\n\t\t\tzap.String(\"name\", name),\n\t\t\tzap.Any(\"message\", message),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 42.98572227163925}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tvar err error\n\tvar data []byte\n\tif data, err = json.Marshal(message); err != nil {\n\t\tlogger.Error(\"notify server send notify error\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\t//logger.Info(\"notify server send notify\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.ByteString(\"data\", data))\n\t//if err = i.bus.Publish(name, data); err != nil {\n\t//\tlogger.Error(\"notify server send notify error\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t//\treturn\n\t//}\n\t//logger.Info(\"notify server send notify\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.ByteString(\"data\", data))\n\t//i.sendNotify(name, data)\n\ti.sendNotify(name, data)\n}", "CodeBleu_score": 22.93389615418483}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tvar client = message_bus.NewClientWithResponses(c.MessageBusAddress())\n\treturn client\n}", "CodeBleu_score": 19.434370388210382}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.MessageBusAddress())\n\treturn client\n}", "CodeBleu_score": 10.463237290231348}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.Server)\n\tif c.Server == \"http://localhost:8080\" {\n\t\tc.Server = \"ws://\" + config.LocalIP + \":8080\"\n\t}\n\treturn client\n}", "CodeBleu_score": 21.479045955177856}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \",\") {\n\t\tip = strings.Split(ip, \",\")[0]\n\t}\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 63.9706509309723}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \",\")[0]\n\tip = strings.TrimSpace(ip)\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 65.33301117834864}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \",\") {\n\t\tip = strings.Split(ip, \",\")[0]\n\t}\n\tif strings.Contains(ip, \":\") {\n\t\tip = strings.Split(ip, \":\")[0]\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 64.01373045950372}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tlogger.Info(\"Generating system entry\")\n\t// 1.Get the path of the modules directory\n\tmodulesDir := config.Config.System.ModuleDir\n\t// 2.Get the path of the entry file\n\tentryFile := config.Config.System.SystemEntry\n\t// 3.Get the list of module directories\n\tmoduleDirs, err := file.GetDirList(modulesDir)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to get the list of module directories\",\n\t\t\tzap.String(\"module_dir\", modulesDir),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\t// 4.Initialize the entry array\n\tentry := make([]model.SystemModule, 0)\n\t// 5.Iterate through the module directory list\n\tfor _, moduleDir := range moduleDirs {\n\t\t// 5.1Get the path of the entry.json file in the module directory\n\t\tentryFileInModuleDir := filepath.Join(modulesDir, moduleDir, \"entry.json\")\n\t\t// 5.2Read the entry.json file\n\t\tentryFileInModuleDirContent, err := file.Read(entryFileInModuleDir)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to read the entry.json file in the module directory\",\n\t\t\t\tzap.String(\"module_dir\", modulesDir),\n\t\t\t\tzap.String(\"entry_file_in_module_dir\", entryFileInModuleDir),\n\t\t\t\tzap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\t// 5.3Convert the entry.json file content to a model.SystemModule object\n\t\tmodule := model.SystemModule{}\n\t\terr = json.Unmarshal(entryFileInModuleDirContent, &module)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to convert the entry.json file content to a model.SystemModule object\",\n\t\t\t\tzap.String(\"module_dir\", modulesDir),\n\t\t\t\tzap.String(\"entry_file_in_module_dir\", entryFileInModuleDir),\n\t\t\t\tzap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\t// 5.4Append the model.SystemModule object to the entry array\n\t\tentry = append(entry, module)\n\t}\n\t// 6.Convert the entry array to JSON format\n\tentryJSON", "CodeBleu_score": 42.123190863659076}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tlogger.Info(\"Generate System Entry\")\n\tentry := []model.SystemEntry{}\n\tmodulePath := config.SystemConf.SystemModulePath\n\t//modulePath := \"/usr/local/CasaOS/modules\"\n\terr := filepath.Walk(modulePath, func(path string, info os.FileInfo, err error) error {\n\t\tif info.IsDir() {\n\t\t\tif !strings.HasSuffix(path, \"/system\") {\n\t\t\t\tentryFile := path + \"/entry.json\"\n\t\t\t\tif file.IsExist(entryFile) {\n\t\t\t\t\t//logger.Info(entryFile)\n\t\t\t\t\tentry = append(entry, model.SystemEntry{})\n\t\t\t\t\tentry[len(entry)-1].Path = path\n\t\t\t\t\tentry[len(entry)-1].Name = info.Name()\n\t\t\t\t\tentry[len(entry)-1].EntryFile = entryFile\n\t\t\t\t\tentry[len(entry)-1].Entry = file.ReadJson(entryFile)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t}\n\tfile.WriteByte(config.SystemConf.SystemEntryPath, []byte(json.Marshal(entry)))\n\tlogger.Info(\"Generate System Entry Success\")\n}", "CodeBleu_score": 36.44746653613263}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tvar modules []string\n\tvar moduleList []string\n\tvar entryList []string\n\tvar entryList2 []string\n\tvar entryList3 []string\n\tvar entryList4 []string\n\tvar entryList5 []string\n\tvar entryList6 []string\n\tvar entryList7 []string\n\tvar entryList8 []string\n\tvar entryList9 []string\n\tvar entryList10 []string\n\tvar entryList11 []string\n\tvar entryList12 []string\n\tvar entryList13 []string\n\tvar entryList14 []string\n\tvar entryList15 []string\n\tvar entryList16 []string\n\tvar entryList17 []string\n\tvar entryList18 []string\n\tvar entryList19 []string\n\tvar entryList20 []string\n\tvar entryList21 []string\n\tvar entryList22 []string\n\tvar entryList23 []string\n\tvar entryList24 []string\n\tvar entryList25 []string\n\tvar entryList26 []string\n\tvar entryList27 []string\n\tvar entryList28 []string\n\tvar entryList29 []string\n\tvar entryList30 []string\n\tvar entryList31 []string\n\tvar entryList32 []string\n\tvar entryList33 []string\n\tvar entryList34 []string\n\tvar entryList35 []string\n\tvar entryList36 []string\n\tvar entryList37 []string\n\tvar entryList38 []string\n\tvar entryList39 []string\n\tvar entryList40 []string\n\tvar entryList41 []string\n\tvar entryList42 []string\n\tvar entryList43 []string\n\tvar entryList44 []string\n\tvar entryList45 []string\n\tvar entryList46 []string\n\tvar entryList47 []string\n\tvar entryList48 []string\n\tvar entryList49 []string\n\tvar entryList50 []string\n\tvar entryList51 []string\n\tvar entryList52 []string\n\tvar entryList53 []string\n\tvar entryList54 []string\n\tvar entryList55 []string\n\tvar entryList56 []string\n\tvar entryList5", "CodeBleu_score": 3.558854907603446}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range interfaces {\n\t\tif i.Name == \"eth0\" {\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 56.67603738972029}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range ifaces {\n\t\tif iface.Name == \"eth0\" {\n\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no interface found\")\n}", "CodeBleu_score": 53.9865482496755}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range interfaces {\n\t\tif i.Name == \"eth0\" {\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No interface named eth0\")\n}", "CodeBleu_score": 56.71018260530496}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t retCode;\n\tint32_t requestCount;\n\tint32_t totalRequestCount;\n\n\t/*\n\t * Increment the request count for the associated TSC object.\n\t */\n\trequestCount = pTscObj->requestCount.value;\n\ttotalRequestCount = pTscObj->totalRequestCount.value;\n\trequestCount++;\n\tpTscObj->requestCount.value = requestCount;\n\ttotalRequestCount++;\n\tpTscObj->totalRequestCount.value = totalRequestCount;\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary, including total and current request counts.\n\t */\n\tif (pTscObj->appInfo.value != NULL) {\n\t\tretCode = catalogUpdateRequestSummary(pTscObj->appInfo.value, requestCount, totalRequestCount);\n\t\tif (retCode != 0) {\n\t\t\treturn retCode;\n\t\t}\n\t}\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tlogRequest(pRequest, pTscObj, \"New request registered\");\n\n\treturn 0;\n}", "CodeBleu_score": 42.59339589564638}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t ret = 0;\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (pRequest->refCount == 0) {\n\t\tpRequest->refCount = 1;\n\t\tif (pTscObj->appInfo != NULL) {\n\t\t\tpTscObj->appInfo->reqCount++;\n\t\t\tpTscObj->appInfo->totalReqCount++;\n\t\t}\n\t}\n\telse {\n\t\tpRequest->refCount++;\n\t}\n\tif (pRequest->refCount == 1) {\n\t\tpRequest->tscObj = pTscObj;\n\t\tpRequest->tscObj->reqCount++;\n\t\tpRequest->tscObj->totalReqCount++;\n\t}\n\tif (pRequest->refCount == 1) {\n\t\tif (pRequest->debug) {\n\t\t\tlogMsg(pRequest->debug, LOG_DEBUG, \"Registering request %p for TSC %p\", pRequest, pTscObj);\n\t\t}\n\t}\nout:\n\treturn ret;\n}", "CodeBleu_score": 42.95109978631507}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tif (pRequest == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (pRequest->refCnt == 0) {\n\t\tpRequest->refCnt = 1;\n\t} else {\n\t\tpRequest->refCnt++;\n\t}\n\n\tif (pTscObj != NULL) {\n\t\tpTscObj->requestCount++;\n\n\t\tif (pTscObj->appInfo != NULL) {\n\t\t\tpTscObj->appInfo->requestCount++;\n\t\t}\n\t}\n\n\tlogRequest(pRequest, \"New request registered\", 1);\n\n\treturn 0;\n}", "CodeBleu_score": 22.819644370138615}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb = pRequest->pDb;\n\tchar *pDbName = pDb;\n\tchar *pDbNameEnd;\n\tchar *pDbNameStart;\n\tchar *pExceptDbName = exceptDb;\n\tchar *pExceptDbNameEnd;\n\tchar *pExceptDbNameStart;\n\tbool found = false;\n\tif(pDbName) {\n\t\tpDbNameStart = pDbName;\n\t\tpDbNameEnd = pDbName;\n\t\twhile(*pDbNameEnd) {\n\t\t\tif(*pDbNameEnd == '.') {\n\t\t\t\tpDbNameEnd++;\n\t\t\t\tpDbName = pDbNameEnd;\n\t\t\t} else {\n\t\t\t\tpDbNameEnd++;\n\t\t\t}\n\t\t}\n\t\tpExceptDbNameStart = pExceptDbName;\n\t\tpExceptDbNameEnd = pExceptDbName;\n\t\twhile(*pExceptDbNameEnd) {\n\t\t\tif(*pExceptDbNameEnd == '.') {\n\t\t\t\tpExceptDbNameEnd++;\n\t\t\t\tpExceptDbName = pExceptDbNameEnd;\n\t\t\t} else {\n\t\t\t\tpExceptDbNameEnd++;\n\t\t\t}\n\t\t}\n\t\tif((pDbNameStart == pExceptDbNameStart) && (pDbNameEnd == pExceptDbNameEnd)) {\n\t\t\tfound = true;\n\t\t} else {\n\t\t\tchar *pDbNameStartNoSchema = pDbNameStart;\n\t\t\tif(pDbNameStartNoSchema[0] == '`' && pDbNameStartNoSchema[pDbNameEnd - pDbNameStart - 1] == '`') {\n\t\t\t\tpDbNameStartNoSchema++;\n\t\t\t\tpDbNameEnd--;\n\t\t\t}\n\t\t\tchar *pExceptDbNameStartNoSchema = pExceptDbNameStart;\n\t\t\tif(pExceptDbNameStartNoSchema[0] == '`' && pExceptDbNameStartNoSchema[pExceptDbNameEnd - pExceptDbNameStart - 1] == '`') {\n\t\t\t\tpExceptDbNameStartNoSchema++;\n\t\t\t\tpExceptDbNameEnd--;\n\t\t\t}\n\t\t\tif((pDbNameStartNoSchema == pExceptDbNameStartNoSchema) && (pDbNameEnd == pExceptDbNameEnd)) {\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}", "CodeBleu_score": 27.382828824773203}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *p = NULL;\n\tchar *p2 = NULL;\n\tchar *p3 = NULL;\n\tchar *p4 = NULL;\n\tchar *p5 = NULL;\n\tchar *p6 = NULL;\n\tchar *p7 = NULL;\n\tchar *p8 = NULL;\n\tchar *p9 = NULL;\n\tchar *p10 = NULL;\n\tchar *p11 = NULL;\n\tchar *p12 = NULL;\n\tchar *p13 = NULL;\n\tchar *p14 = NULL;\n\tchar *p15 = NULL;\n\tchar *p16 = NULL;\n\tchar *p17 = NULL;\n\tchar *p18 = NULL;\n\tchar *p19 = NULL;\n\tchar *p20 = NULL;\n\tchar *p21 = NULL;\n\tchar *p22 = NULL;\n\tchar *p23 = NULL;\n\tchar *p24 = NULL;\n\tchar *p25 = NULL;\n\tchar *p26 = NULL;\n\tchar *p27 = NULL;\n\tchar *p28 = NULL;\n\tchar *p29 = NULL;\n\tchar *p30 = NULL;\n\tchar *p31 = NULL;\n\tchar *p32 = NULL;\n\tchar *p33 = NULL;\n\tchar *p34 = NULL;\n\tchar *p35 = NULL;\n\tchar *p36 = NULL;\n\tchar *p37 = NULL;\n\tchar *p38 = NULL;\n\tchar *p39 = NULL;\n\tchar *p40 = NULL;\n\tchar *p41 = NULL;\n\tchar *p42 = NULL;\n\tchar *p43 = NULL;\n\tchar *p44 = NULL;\n\tchar *p45 = NULL;\n\tchar *p46 = NULL;\n\tchar *p47 = NULL;\n\tchar *p48 = NULL;\n\tchar *p49 = NULL;\n\tchar *p50 = NULL;\n\tchar *p51 = NULL;\n\tchar *p52 = NULL;\n\tchar", "CodeBleu_score": 5.930997343522877}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb = NULL;\n\tchar *pDb2 = NULL;\n\tchar *pDb3 = NULL;\n\tchar *pDb4 = NULL;\n\tchar *pDb5 = NULL;\n\tchar *pDb6 = NULL;\n\tchar *pDb7 = NULL;\n\tchar *pDb8 = NULL;\n\tchar *pDb9 = NULL;\n\tchar *pDb10 = NULL;\n\tchar *pDb11 = NULL;\n\tchar *pDb12 = NULL;\n\tchar *pDb13 = NULL;\n\tchar *pDb14 = NULL;\n\tchar *pDb15 = NULL;\n\tchar *pDb16 = NULL;\n\tchar *pDb17 = NULL;\n\tchar *pDb18 = NULL;\n\tchar *pDb19 = NULL;\n\tchar *pDb20 = NULL;\n\tchar *pDb21 = NULL;\n\tchar *pDb22 = NULL;\n\tchar *pDb23 = NULL;\n\tchar *pDb24 = NULL;\n\tchar *pDb25 = NULL;\n\tchar *pDb26 = NULL;\n\tchar *pDb27 = NULL;\n\tchar *pDb28 = NULL;\n\tchar *pDb29 = NULL;\n\tchar *pDb30 = NULL;\n\tchar *pDb31 = NULL;\n\tchar *pDb32 = NULL;\n\tchar *pDb33 = NULL;\n\tchar *pDb34 = NULL;\n\tchar *pDb35 = NULL;\n\tchar *pDb36 = NULL;\n\tchar *pDb37 = NULL;\n\tchar *pDb38 = NULL;\n\tchar *pDb39 = NULL;\n\tchar *pDb40 = NULL;\n\tchar *pDb41 = NULL;\n\tchar *pDb42 = NULL;\n\tchar *pDb43 = NULL;\n\tchar *pDb44 = NULL;\n\tchar *pDb45 = NULL;\n\tchar *pDb46 = NULL;\n\tchar *pDb47 = NULL;\n\tchar *pDb", "CodeBleu_score": 6.068744873776036}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tswitch (code) {\n\t\tcase ERR_NOT_AUTHORIZED:\n\t\t\treturn msgType != TMSG_QUERY_GET_CATALOG && msgType != TMSG_QUERY_GET_SCHEMA && msgType != TMSG_QUERY_GET_TABLES && msgType != TMSG_QUERY_GET_COLUMNS && msgType != TMSG_QUERY_GET_INDEXES && msgType != TMSG_QUERY_GET_TRIGGERS && msgType != TMSG_QUERY_GET_VIEWS && msgType != TMSG_QUERY_GET_PROCEDURES && msgType != TMSG_QUERY_GET_PROCEDURE_COLUMNS && msgType != TMSG_QUERY_GET_SQL;\n\t\tcase ERR_CLUSTER_NOT_FOUND:\n\t\t\treturn msgType != TMSG_QUERY_GET_CATALOG && msgType != TMSG_QUERY_GET_SCHEMA && msgType != TMSG_QUERY_GET_TABLES && msgType != TMSG_QUERY_GET_COLUMNS && msgType != TMSG_QUERY_GET_INDEXES && msgType != TMSG_QUERY_GET_TRIGGERS && msgType != TMSG_QUERY_GET_VIEWS && msgType != TMSG_QUERY_GET_PROCEDURES && msgType != TMSG_QUERY_GET_PROCEDURE_COLUMNS && msgType != TMSG_QUERY_GET_SQL;\n\t\tcase ERR_CLUSTER_NOT_RUNNING:\n\t\t\treturn msgType != TMSG_QUERY_GET_CATALOG && msgType != TMSG_QUERY_GET_SCHEMA && msgType != TMSG_QUERY_GET_TABLES && msgType != TMSG_QUERY_GET_COLUMNS && msgType != TMSG_QUERY_GET_INDEXES && msgType != TMSG_QUERY_GET_TRIGGERS && msgType != TMSG_QUERY_GET_VIEWS && msgType != TMSG_QUERY_GET_PROCEDURES && msgType != TMSG_QUERY_GET_PROCEDURE_COLUMNS && msgType != TMSG_QUERY_GET_SQL;\n\t\tcase ERR_CLUSTER_NOT_SUPPORTED:\n\t\t\treturn msgType != TMSG_QUERY_GET_CATALOG && msgType != TMSG_QUERY_GET_SCHEMA && msgType != TMSG_QUERY_GET_TABLES && msgType != TMSG_QUERY_GET_COLUMNS && msgType != TMSG_QUERY_", "CodeBleu_score": 40.94967493100366}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TDBRPCREDIRECT) {\n\t\tif (msgType == TMSG_REPLY || msgType == TMSG_EXCEPTION || msgType == TMSG_REPLY_ACK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 37.285700384398936}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool rfp = false;\n\n\tif (code == ERR_CLIENT_REDIRECT) {\n\t\tif (msgType != TMSG_OPEN && msgType != TMSG_CLOSE && msgType != TMSG_EXECUTE && msgType != TMSG_FETCH && msgType != TMSG_COMMIT && msgType != TMSG_ROLLBACK && msgType != TMSG_FETCH_RESPONSE && msgType != TMSG_CANCEL_RESPONSE && msgType != TMSG_CLOSE_RESPONSE && msgType != TMSG_ERROR_RESPONSE && msgType != TMSG_FLUSH_RESPONSE && msgType != TMSG_ERROR_STACK_TRACE) {\n\t\t\trfp = true;\n\t\t}\n\t}\n\n\treturn rfp;\n}", "CodeBleu_score": 46.966441480209994}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i;\n\tSHashIter iter;\n\tRequest *pRequest;\n\tQuery *pQuery;\n\n\tfor (i = 0, pRequest = (Request *) SHashNext(pRequests, &iter); pRequest; i++, pRequest = (Request *) SHashNext(pRequests, &iter)) {\n\t\tpQuery = pRequest->pQuery;\n\t\tif (pQuery) {\n\t\t\tpQuery->pRequest = NULL;\n\t\t\tpQuery->stopFlag = true;\n\t\t\tpQuery->state = Q_STOPPING;\n\t\t\tpQuery->error = QE_USER_STOP;\n\t\t\tpQuery->errorMsg = xstrdup(\"Query stopped by the user.\");\n\t\t\tpQuery->errorMsgLen = strlen(pQuery->errorMsg);\n\t\t\tpQuery->nRows = 0;\n\t\t\tpQuery->nFields = 0;\n\t\t\tpQuery->nProcessed = 0;\n\t\t\tpQuery->nFiltered = 0;\n\t\t\tpQuery->nReturned = 0;\n\t\t\tpQuery->nUpserted = 0;\n\t\t\tpQuery->nDeleted = 0;\n\t\t\tpQuery->nInserted = 0;\n\t\t\tpQuery->nMatched = 0;\n\t\t\tpQuery->nModified = 0;\n\t\t\tpQuery->nRecs = 0;\n\t\t\tpQuery->nRecsFiltered = 0;\n\t\t\tpQuery->nRecsReturned = 0;\n\t\t\tpQuery->nRecsMatched = 0;\n\t\t\tpQuery->nRecsModified = 0;\n\t\t\tpQuery->nRecsUpserted = 0;\n\t\t\tpQuery->nRecsDeleted = 0;\n\t\t\tpQuery->nRecsInserted = 0;\n\t\t\tpQuery->nErrors = 0;\n\t\t\tpQuery->nWarnings = 0;\n\t\t\tpQuery->nFields = 0;\n\t\t\tpQuery->nParams = 0;\n\t\t\tpQuery->nBindVars = 0;\n\t\t\tpQuery->nBatchRows = 0;\n\t\t\tpQuery->nBatchBindRows = 0;\n\t\t\tpQuery->nBatchRecs = 0;\n\t\t\tpQuery->nBatchRecsMatched = 0;\n\t\t\tpQuery->nBatchRecsModified = 0;\n\t\t\t", "CodeBleu_score": 28.576439515803187}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i = 0;\n\tint n = 0;\n\tTSRMLS_FETCH();\n\tfor (i = 0, n = zend_hash_num_elements(pRequests); i < n; i++) {\n\t\tzval **pData = NULL;\n\t\tulong idx = 0;\n\t\tHashPosition pos;\n\t\tzval *pRequest = NULL;\n\t\tzval *pQuery = NULL;\n\t\tzval *pWorker = NULL;\n\t\tzval *pRequestID = NULL;\n\t\tzval *pStatus = NULL;\n\t\tzval *pError = NULL;\n\t\tzval *pResult = NULL;\n\t\tzval *pResultData = NULL;\n\t\tzval *pResultInfo = NULL;\n\t\tzval *pResultID = NULL;\n\t\tzval *pResultIndex = NULL;\n\t\tzval *pResultCount = NULL;\n\t\tzval *pResultSchema = NULL;\n\t\tzval *pResultRowCount = NULL;\n\t\tzval *pResultTime = NULL;\n\t\tzval *pResultTimeUsec = NULL;\n\t\tzval *pResultTimeStr = NULL;\n\t\tzval *pResultTimeZone = NULL;\n\t\tzval *pResultTimeZoneStr = NULL;\n\t\tzval *pResultTimeZoneOffset = NULL;\n\t\tzval *pResultTimeZoneOffsetStr = NULL;\n\t\tzval *pResultTimeZoneAbbrev = NULL;\n\t\tzval *pResultTimeZoneAbbrevStr = NULL;\n\t\tzval *pResultRowCount = NULL;\n\t\tzval *pResultRowCountStr = NULL;\n\t\tzval *pResultStatus = NULL;\n\t\tzval *pResultStatusStr = NULL;\n\t\tzval *pResultError = NULL;\n\t\tzval *pResultErrorCode = NULL;\n\t\tzval *pResultErrorMessage = NULL;\n\t\tzval *pResultErrorInfo = NULL;\n\t\tzval *pResultErrorInfoMessage = NULL;\n\t\tzval *pResultErrorInfoCode = NULL;\n\t\tzval *pResultErrorInfoTrace = NULL;\n\t\tzval *pResultErrorInfoQuery = NULL;\n\t\tzval *pResultErrorInfoQueryID = NULL;\n\t\tzval *pResultErrorInfoParams = NULL;\n\t\tzval *pResultError", "CodeBleu_score": 10.930142622594218}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\t// Iterate through the hash table of requests.\n\tfor (int i = 0; i < pRequests->size; ++i) {\n\t\t// Get the request.\n\t\tRequest *pRequest = (Request *)SHashObj_getValue(pRequests, i);\n\n\t\t// If the request is valid, stop the query associated with the request.\n\t\tif (pRequest != NULL) {\n\t\t\tstopRequest(pRequest);\n\t\t}\n\t}\n}", "CodeBleu_score": 33.59548609695718}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (gbl_crash_report_enable) {\n\t\tif (atomic_cas_bool(&gbl_client_stop, 1, 0)) {\n\t\t\twhile (gbl_client_stop) {\n\t\t\t\tos_usleep(100000);\n\t\t\t}\n\t\t} else {\n\t\t\tclientLog(CL_WARN, \"Crash report thread already stopped\");\n\t\t}\n\t}\n}", "CodeBleu_score": 41.46309124691684}, {"code": "void tscStopCrashReport(){\n\t\tif (tsCrashReportEnabled) {\n\t\tif (tscAtomicCompareAndExchange(&clientStop, 0, 1)) {\n\t\t\twhile (clientStop) {\n\t\t\t\tosSleep(100000);\n\t\t\t}\n\t\t} else {\n\t\t\tclientLog(CL_ERROR, \"Crash report thread is already stopped\");\n\t\t}\n\t}\n}", "CodeBleu_score": 41.23454382115991}, {"code": "void tscStopCrashReport(){\n\t\tint32_t status;\n\tint32_t stopFlag;\n\n\tif (tscCrashReportEnabled()) {\n\t\tstopFlag = 1;\n\t\tstatus = tscAtomicCompareAndSwapInt32(&clientStop, 0, stopFlag);\n\t\tif (status == 0) {\n\t\t\tclientLog(CL_ERROR, \"Crash report thread already stopped\");\n\t\t} else {\n\t\t\twhile (clientStop != 0) {\n\t\t\t\tosSleep(1000);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.570365073507}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = HEARTBEAT_OK;\n\tstruct HeartbeatViewInfoResponse *pResponse = NULL;\n\tstruct HeartbeatViewInfo *pViewInfo = NULL;\n\tstruct SCatalogEntry *pEntry = NULL;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\n\tpResponse = deserializeHeartbeatViewInfoResponse(value, valueLen);\n\tif (pResponse == NULL) {\n\t\trc = HEARTBEAT_ERROR_DESERIALIZE_VIEW_INFO;\n\t\tgoto cleanup;\n\t}\n\n\tif (pResponse->status != 0) {\n\t\trc = HEARTBEAT_ERROR_VIEW_INFO_STATUS;\n\t\tgoto cleanup;\n\t}\n\n\tfor (i = 0; i < pResponse->viewCount; i++) {\n\t\tpViewInfo = &pResponse->views[i];\n\t\tpEntry = scatalog_findEntryByNamespace(pCatalog, pViewInfo->namespace);\n\t\tif (pEntry == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pEntry->type != SCATALOG_ENTRY_TYPE_VIEW) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pEntry->view.columnCount != pViewInfo->columnCount) {\n\t\t\tscatalog_removeEntry(pCatalog, pEntry);\n\t\t}\n\t}\n\ncleanup:\n\tif (pResponse != NULL) {\n\t\tdestroyHeartbeatViewInfoResponse(pResponse);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 35.77133309319832}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = 0;\n\tstruct ViewInfo *pViewInfo = NULL;\n\tstruct ViewInfo *pViewInfoTmp = NULL;\n\tstruct ViewInfo *pViewInfoTmp2 = NULL;\n\tstruct ViewInfo *pViewInfoTmp3 = NULL;\n\tstruct ViewInfo *pViewInfoTmp4 = NULL;\n\tstruct ViewInfo *pViewInfoTmp5 = NULL;\n\tstruct ViewInfo *pViewInfoTmp6 = NULL;\n\tstruct ViewInfo *pViewInfoTmp7 = NULL;\n\tstruct ViewInfo *pViewInfoTmp8 = NULL;\n\tstruct ViewInfo *pViewInfoTmp9 = NULL;\n\tstruct ViewInfo *pViewInfoTmp10 = NULL;\n\tstruct ViewInfo *pViewInfoTmp11 = NULL;\n\tstruct ViewInfo *pViewInfoTmp12 = NULL;\n\tstruct ViewInfo *pViewInfoTmp13 = NULL;\n\tstruct ViewInfo *pViewInfoTmp14 = NULL;\n\tstruct ViewInfo *pViewInfoTmp15 = NULL;\n\tstruct ViewInfo *pViewInfoTmp16 = NULL;\n\tstruct ViewInfo *pViewInfoTmp17 = NULL;\n\tstruct ViewInfo *pViewInfoTmp18 = NULL;\n\tstruct ViewInfo *pViewInfoTmp19 = NULL;\n\tstruct ViewInfo *pViewInfoTmp20 = NULL;\n\tstruct ViewInfo *pViewInfoTmp21 = NULL;\n\tstruct ViewInfo *pViewInfoTmp22 = NULL;\n\tstruct ViewInfo *pViewInfoTmp23 = NULL;\n\tstruct ViewInfo *pViewInfoTmp24 = NULL;\n\tstruct ViewInfo *pViewInfoTmp25 = NULL;\n\tstruct ViewInfo *pViewInfoTmp26 = NULL;\n\tstruct ViewInfo *pViewInfoTmp27 = NULL;\n\tstruct ViewInfo *pViewInfoTmp28 = NULL;\n\tstruct ViewInfo *pViewInfoTmp29 = NULL;\n\tstruct ViewInfo *pViewInfoTmp30 = NULL;\n\tstruct ViewInfo *pViewInfoTmp31 = NULL;\n\tstruct ViewInfo *pViewInfoTmp32 = NULL;\n\tstruct ViewInfo *pViewInfoTmp33 = NULL;\n\tstruct View", "CodeBleu_score": 7.321572821070174}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc;\n\tstruct ViewInfo *pViewInfo;\n\tstruct ViewInfo *pViewInfoTmp;\n\tint32_t i;\n\tint32_t numViews;\n\tint32_t numViewsTmp;\n\tint32_t numViewsTmp2;\n\tint32_t numColumns;\n\tint32_t numColumnsTmp;\n\tint32_t numColumnsTmp2;\n\tstruct ViewInfo tmpViewInfo;\n\tstruct ViewInfo tmpViewInfoTmp;\n\n\t/* Deserialize the response. */\n\trc = deserializeViewInfoArray(value, valueLen, &pViewInfo, &numViews);\n\tif (rc != TDB_OK) {\n\t\treturn rc;\n\t}\n\n\t/* Check for errors. */\n\tif (numViews < 0) {\n\t\tlogError(\"Unexpected negative number of views: %d\", numViews);\n\t\treturn TDB_ERROR;\n\t}\n\n\t/* Iterate through the deserialized view metadata. */\n\tpViewInfoTmp = pViewInfo;\n\tfor (i = 0; i < numViews; i++) {\n\t\t/* Check for errors. */\n\t\tif (pViewInfoTmp->viewName == NULL || pViewInfoTmp->viewNameLen <= 0 || pViewInfoTmp->viewNameLen >= TDB_MAX_NAME_LEN) {\n\t\t\tlogError(\"Invalid view name: %s\", pViewInfoTmp->viewName);\n\t\t\treturn TDB_ERROR;\n\t\t}\n\n\t\tif (pViewInfoTmp->viewDefinition == NULL || pViewInfoTmp->viewDefinitionLen <= 0) {\n\t\t\tlogError(\"Invalid view definition: %s\", pViewInfoTmp->viewDefinition);\n\t\t\treturn TDB_ERROR;\n\t\t}\n\n\t\tif (pViewInfoTmp->viewMetadata == NULL || pViewInfoTmp->viewMetadataLen <= 0) {\n\t\t\tlogError(\"Invalid view metadata: %s\", pViewInfoTmp->viewMetadata);\n\t\t\treturn TDB_ERROR;\n\t\t}\n\n\t\tif (pViewInfoTmp->viewMetadataLen != pViewInfoTmp->numColumns * sizeof(struct ColumnInfo)) {\n\t\t\tlogError(\"Invalid view metadata length: %d\", pViewInfoTmp->viewMetadataLen);\n\t\t\t", "CodeBleu_score": 33.99878480211089}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tstruct callbackData *data = (struct callbackData *) callbackData;\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 76.32571732613623}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status;\n\tS3ContentLengthCallbackData *contentLengthCallbackData = (S3ContentLengthCallbackData *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tcontentLengthCallbackData->contentLength = properties->contentLength;\n\t} else {\n\t\tcontentLengthCallbackData->contentLength = 0;\n\t}\n\n\tstatus = S3StatusOK;\n\n\treturn status;\n}", "CodeBleu_score": 67.52320404826926}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status;\n\tS3CallbackData *cbData = (S3CallbackData *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tcbData->contentLength = properties->contentLength;\n\t} else {\n\t\tcbData->contentLength = 0;\n\t}\n\n\tstatus = S3StatusOK;\n\n\treturn(status);\n}", "CodeBleu_score": 69.60557666734357}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tif (mkdir(CHECKPOINT_DIR, 0700) == -1) {\n\t\ttlog(\"Error: could not create checkpoint backup directory.\");\n\t\treturn;\n\t}\n\n\tif (removeEmptyDirs(CHECKPOINT_DIR) == -1) {\n\t\ttlog(\"Error: could not remove empty directories.\");\n\t\treturn;\n\t}\n\n\tif (generateRsyncConfig(CHECKPOINT_DIR, RSYNC_CONFIG_FILE) == -1) {\n\t\ttlog(\"Error: could not generate Rsync configuration file.\");\n\t\treturn;\n\t}\n\n\tchar *command = malloc(sizeof(char) * (strlen(RSYNC_COMMAND) + strlen(RSYNC_CONFIG_FILE) + strlen(RSYNC_PORT) + 1));\n\tsprintf(command, \"%s %s %s\", RSYNC_COMMAND, RSYNC_CONFIG_FILE, RSYNC_PORT);\n\tsystem(command);\n\tfree(command);\n}", "CodeBleu_score": 29.150669086436732}, {"code": "void startRsync(){\n\t\tchar *backupDir = getBackupDir();\n\tif (mkdir(backupDir, 0700) != 0 && errno != EEXIST) {\n\t\tlogError(\"Failed to create checkpoint backup directory\");\n\t\treturn;\n\t}\n\n\tremoveEmptyDirs(backupDir);\n\n\tchar *configFile = getRsyncConfig();\n\tif (!generateRsyncConfig(configFile)) {\n\t\tlogError(\"Failed to generate Rsync configuration file\");\n\t\treturn;\n\t}\n\n\tchar *command = getRsyncCommand(configFile);\n\tif (system(command) != 0) {\n\t\tlogError(\"Failed to start Rsync server\");\n\t}\n}", "CodeBleu_score": 22.589817450945745}, {"code": "void startRsync(){\n\t\tchar *rsyncDir = \"rsync\";\n\tchar *rsyncConfig = \"rsync.conf\";\n\tchar *rsyncCommand = \"rsync --daemon --config=rsync.conf\";\n\tchar *rsyncPort = \"873\";\n\tchar *rsyncUser = \"root\";\n\tchar *rsyncPassword = \"<PASSWORD>\";\n\tchar *rsyncHost = \"127.0.0.1\";\n\tchar *rsyncBackupDir = \"backup\";\n\tchar *rsyncLogDir = \"logs\";\n\tchar *rsyncLog = \"rsync.log\";\n\tchar *rsyncLogFile = \"logs/rsync.log\";\n\tchar *rsyncCmd = NULL;\n\tchar *rsyncCmd2 = NULL;\n\tchar *rsyncCmd3 = NULL;\n\tchar *rsyncCmd4 = NULL;\n\tchar *rsyncCmd5 = NULL;\n\tchar *rsyncCmd6 = NULL;\n\tchar *rsyncCmd7 = NULL;\n\tchar *rsyncCmd8 = NULL;\n\tchar *rsyncCmd9 = NULL;\n\tchar *rsyncCmd10 = NULL;\n\tchar *rsyncCmd11 = NULL;\n\tchar *rsyncCmd12 = NULL;\n\tchar *rsyncCmd13 = NULL;\n\tchar *rsyncCmd14 = NULL;\n\tchar *rsyncCmd15 = NULL;\n\tchar *rsyncCmd16 = NULL;\n\tchar *rsyncCmd17 = NULL;\n\tchar *rsyncCmd18 = NULL;\n\tchar *rsyncCmd19 = NULL;\n\tchar *rsyncCmd20 = NULL;\n\tchar *rsyncCmd21 = NULL;\n\tchar *rsyncCmd22 = NULL;\n\tchar *rsyncCmd23 = NULL;\n\tchar *rsyncCmd24 = NULL;\n\tchar *rsyncCmd25 = NULL;\n\tchar *rsyncCmd26 = NULL;\n\tchar *rsyncCmd27 = NULL;\n\tchar *rsyncCmd28 = NULL;\n\tchar *rsyncCmd29 = NULL;\n\tchar *rsyncCmd30 = NULL;\n\tchar *rsyncCmd3", "CodeBleu_score": 5.807649511226701}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tExecutorHolder executorHolder = dispatchers.get(dispatcherId);\n\t\texecutorHolder.executor.shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered!\");\n\t}\n}", "CodeBleu_score": 62.88862084167112}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"No dispatcher with id: \" + dispatcherId + \" is registered!\");\n\t}\n\tdispatcher.getExecutor().shutdownNow();\n}", "CodeBleu_score": 64.16488131179264}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tdispatcher = dispatchers.remove(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"No dispatcher registered with ID [\" + dispatcherId + \"]!\");\n\t}\n\tdispatcher.getExecutor().shutdownNow();\n}", "CodeBleu_score": 59.467845919226235}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t Set<TbActorId> children = childrenMap.get(parent);\n if (children != null) {\n List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n if (filteredChildren.isEmpty()) {\n log.warn(\"[{}] No children found for parent [{}] and filter [{}]\", actorId, parent, childFilter);\n } else {\n for (TbActorId child : filteredChildren) {\n try {\n if (highPriority) {\n actorSystem.tellWithHighPriority(child, msg);\n } else {\n actorSystem.tell(child, msg);\n }\n } catch (ActorNotRegisteredException e) {\n log.warn(\"[{}] Child [{}] is not registered\", actorId, child);\n }\n }\n }\n } else {\n log.warn(\"[{}] No children found for parent [{}] and filter [{}]\", actorId, parent, childFilter);\n }\n }", "CodeBleu_score": 48.39310724681877}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t if (children.containsKey(parent)) {\n List<TbActorId> filteredChildren = children.get(parent).stream().filter(childFilter).collect(Collectors.toList());\n if (filteredChildren.isEmpty()) {\n log.warn(\"[{}] No children found for parent [{}] and filter [{}]\", self.getActorId(), parent, childFilter);\n } else {\n for (TbActorId child : filteredChildren) {\n if (actors.containsKey(child)) {\n if (highPriority) {\n actors.get(child).tell(new TbActorMsgWrapper(msg, self.getActorId()), ActorRef.noSender());\n } else {\n actors.get(child).tell(msg, ActorRef.noSender());\n }\n } else {\n log.warn(\"[{}] Child [{}] is not registered\", self.getActorId(), child);\n }\n }\n }\n } else {\n log.warn(\"[{}] No children found for parent [{}]\", self.getActorId(), parent);\n }\n }", "CodeBleu_score": 37.53552917687141}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t List<TbActorId> children = getChildren(parent);\n children.stream()\n .filter(childFilter)\n .forEach(child -> {\n try {\n if (highPriority) {\n actorSystem.tell(child, msg, ActorRef.noSender(), ActorSystem.HighPriority);\n } else {\n actorSystem.tell(child, msg, ActorRef.noSender());\n }\n } catch (ActorInitializationException e) {\n log.warn(\"[{}] Failed to send message to child [{}]\", parent, child, e);\n }\n });\n }", "CodeBleu_score": 45.306500810293976}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (isStopped.get()) {\n\t\tif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && highPriority) {\n\t\t\tif (initFailed.get()) {\n\t\t\t\tinitFailed.set(false);\n\t\t\t\tinit();\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.onTbActorStopped(TbActorStopReason.STOPPED, null);\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\tif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\t\tif (initFailed.get()) {\n\t\t\t\t\tinitFailed.set(false);\n\t\t\t\t\tinit();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thighPriorityMsgs.add(msg);\n\t\t\t}\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t}\n}", "CodeBleu_score": 50.46893245507225}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (destroyed.get()) {\n\t\tif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\tif (initFailed.get()) {\n\t\t\t\tinitFailed.set(false);\n\t\t\t\tinit(ctx);\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.onTbActorStopped(TbActorStopReason.DESTROYED, null);\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\tif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\t\tif (initFailed.get()) {\n\t\t\t\t\tinitFailed.set(false);\n\t\t\t\t\tinit(ctx);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thighPriorityMsgs.add(msg);\n\t\t\t}\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t}\n}", "CodeBleu_score": 47.23012942852517}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (isStopped.get()) {\n\t\tif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && highPriority) {\n\t\t\tif (initFailed.get()) {\n\t\t\t\tlog.info(\"[{}] Actor reinitialization has started due to failure\", ctx.getActorName());\n\t\t\t\tinitFailed.set(false);\n\t\t\t\tinit(ctx);\n\t\t\t\tlog.info(\"[{}] Actor reinitialization has finished\", ctx.getActorName());\n\t\t\t}\n\t\t} else {\n\t\t\tlog.info(\"[{}] Actor stopped, msg: {}\", ctx.getActorName(), msg);\n\t\t\tmsg.onTbActorStopped(TbActorStopReason.STOPPED, null);\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\tif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\t\tif (initFailed.get()) {\n\t\t\t\t\tlog.info(\"[{}] Actor reinitialization has started due to failure\", ctx.getActorName());\n\t\t\t\t\tinitFailed.set(false);\n\t\t\t\t\tinit(ctx);\n\t\t\t\t\tlog.info(\"[{}] Actor reinitialization has finished\", ctx.getActorName());\n\t\t\t\t}\n\t\t\t}\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t}\n}", "CodeBleu_score": 51.87307010730231}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t\tif (isStopped.get()) {\n\t\treturn;\n\t}\n\ttry {\n\t\tif (initFailed.get()) {\n\t\t\tthrow new RuntimeException(\"Initialization failed\");\n\t\t}\n\t\tlong start = System.nanoTime();\n\t\tfor (int i = 0; i < maxMailboxSize; i++) {\n\t\t\tTbActorMsg msg = null;\n\t\t\tif (highPriorityQueue.peek() != null) {\n\t\t\t\tmsg = highPriorityQueue.poll();\n\t\t\t} else if (normalPriorityQueue.peek() != null) {\n\t\t\t\tmsg = normalPriorityQueue.poll();\n\t\t\t}\n\t\t\tif (msg != null) {\n\t\t\t\ttry {\n\t\t\t\t\tprocess(msg);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tif (processFailureStrategy.process(msg, e)) {\n\t\t\t\t\t\tstop(TbActorStopReason.FAILURE);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (System.nanoTime() - start > TimeUnit.MILLISECONDS.toNanos(maxMailboxSize)) {\n\t\t\tlog.warn(\"[{}] Mailbox processing took more than {} ms\", actorName, maxMailboxSize);\n\t\t}\n\t\tif (highPriorityQueue.peek() == null && normalPriorityQueue.peek() == null) {\n\t\t\tif (isStopped.get()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (actorStatus.compareAndSet(ActorStatus.ACTIVE, ActorStatus.FREE)) {\n\t\t\t\tscheduleQueueProcessing();\n\t\t\t}\n\t\t}\n\t} catch (Exception e) {\n\t\tlog.error(\"[{}] Failed to process mailbox\", actorName, e);\n\t\tif (actorStatus.compareAndSet(ActorStatus.ACTIVE, ActorStatus.FREE)) {\n\t\t\tscheduleQueueProcessing();\n\t\t}\n\t}\n}", "CodeBleu_score": 39.25216902037897}, {"code": "private void processMailbox(){\n\t\ttry {\n\t\tif (initFailed.get()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isStopped()) {\n\t\t\treturn;\n\t\t}\n\t\tif (log.isTraceEnabled()) {\n\t\t\tlog.trace(\"[{}] Processing mailbox\", getActorName());\n\t\t}\n\t\tlong start = System.nanoTime();\n\t\tlong lastProcessTime = start;\n\t\tlong lastProcessSize = 0;\n\t\tint lastProcessCount = 0;\n\t\tint maxProcessCount = getMaxProcessCount();\n\t\tint maxProcessTime = getMaxProcessTime();\n\t\tlong processCount = 0;\n\t\tlong processSize = 0;\n\t\tlong processTime = 0;\n\t\tlong maxProcessSize = getMaxProcessSize();\n\t\tlong maxProcessTimeNs = TimeUnit.MILLISECONDS.toNanos(maxProcessTime);\n\t\tlong maxProcessSizeBytes = maxProcessSize * 1024 * 1024;\n\t\tlong totalProcessTime = 0;\n\t\tlong totalProcessSize = 0;\n\t\tlong totalProcessCount = 0;\n\t\tboolean stop = false;\n\t\twhile (!stop) {\n\t\t\tboolean processed = false;\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tif (isStopped()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (log.isTraceEnabled()) {\n\t\t\t\t\tlog.trace(\"[{}] Processing {} priority queue\", getActorName(), i == 0 ? \"high\" : \"normal\");\n\t\t\t\t}\n\t\t\t\tList<TbActorMsg> messages = null;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tmessages = highPriorityQueue.drainTo(new ArrayList<>());\n\t\t\t\t} else {\n\t\t\t\t\tmessages = normalPriorityQueue.drainTo(new ArrayList<>());\n\t\t\t\t}\n\t\t\t\tif (messages.isEmpty()) {\n\t\t\t\t\tif (log.isTraceEnabled()) {\n\t\t\t\t\t\tlog.trace(\"[{}] No more messages in {} priority queue\", getActorName(), i == 0 ? \"high\" : \"normal\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (log.isTraceEnabled()) {\n\t\t\t\t\tlog.trace(\"[{}] Processing {} messages in {} priority queue\", getActorName(), messages.size(), i == 0 ? \"high\" : \"normal\");\n\t\t\t\t}\n\t\t\t\tfor (TbActorMsg msg : messages", "CodeBleu_score": 22.630254771318395}, {"code": "private void processMailbox(){\n\t\tif (initFailed.get()) {\n\t\treturn;\n\t}\n\ttry {\n\t\tif (log.isTraceEnabled()) {\n\t\t\tlog.trace(\"[{}] Processing mailbox...\", actorName);\n\t\t}\n\t\tlong currTime = System.nanoTime();\n\t\tlong currQueueSize = 0;\n\t\tlong currProcessedMessages = 0;\n\t\tlong currFailedMessages = 0;\n\t\tlong currFailedRetries = 0;\n\t\tlong currMaxQueueSize = 0;\n\t\tlong currMaxProcessedMessages = 0;\n\t\tlong currMaxFailedMessages = 0;\n\t\tlong currMaxFailedRetries = 0;\n\t\tlong currMinQueueSize = Integer.MAX_VALUE;\n\t\tlong currMinProcessedMessages = Integer.MAX_VALUE;\n\t\tlong currMinFailedMessages = Integer.MAX_VALUE;\n\t\tlong currMinFailedRetries = Integer.MAX_VALUE;\n\t\tlong currTotalQueueSize = 0;\n\t\tlong currTotalProcessedMessages = 0;\n\t\tlong currTotalFailedMessages = 0;\n\t\tlong currTotalFailedRetries = 0;\n\t\tlong currTotalProcessTime = 0;\n\t\tlong currTotalProcessTimeThreshold = 0;\n\t\tlong currTotalProcessTimeThresholdExceeded = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCount = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThreshold = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThresholdExceeded = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThresholdExceededCount = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThresholdExceededCountThreshold = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThresholdExceededCountThresholdExceeded = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThresholdExceededCountThresholdExceededCount = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThresholdExceededCountThresholdExceededCountThreshold = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThresholdExceededCountThresholdExceededCountThresholdExceeded = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThresholdExceededCountThresholdExceededCountThresholdExceededCount = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThresholdExceededCountThresholdExceededCountThresholdExceededCountThreshold = 0;\n\t\tlong currTotalProcessTimeThresholdExceededCountThresholdExceededCountThresholdExceededCountThresholdExceededCountThresholdExceeded = 0;", "CodeBleu_score": 11.435312887327417}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (!destroyed.get()) {\n\t\tif (stopReason == null) {\n\t\t\tstopReason = TbActorStopReason.TB_STOPPED;\n\t\t}\n\t\tdestroyed.set(true);\n\t\texecutor.schedule(() -> {\n\t\t\ttry {\n\t\t\t\tactor.destroy(stopReason, cause);\n\t\t\t\tfor (TbActorMsg msg : queue) {\n\t\t\t\t\tif (msg.getMsgType() == MsgType.STOP) {\n\t\t\t\t\t\tmsg.getCallback().onSuccess();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmsg.getCallback().onFailure(new TbActorError(actor.getActorId(), \"Actor is destroyed\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tqueue.clear();\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.warn(\"[{}] Failed to destroy actor\", actor.getActorId(), e);\n\t\t\t}\n\t\t}, 0, TimeUnit.MILLISECONDS);\n\t}\n}", "CodeBleu_score": 44.994955252573234}, {"code": "public void destroy(Throwable cause){\n\t\tif (!destroyed.getAndSet(true)) {\n\t\tstopReason = stopReason == null ? TbActorStopReason.CLOSED : stopReason;\n\t\tlog.warn(\"[{}] Destroying actor due to [{}]\", entityId, stopReason);\n\t\ttry {\n\t\t\tdispatcher.schedule(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (actor != null) {\n\t\t\t\t\t\t\tactor.destroy(stopReason, cause);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tlog.warn(\"[{}] Failed to destroy actor due to [{}]\", entityId, stopReason, e);\n\t\t\t\t\t}\n\t\t\t\t\tfor (TbActorMsg msg : queue) {\n\t\t\t\t\t\tmsg.tell(new TbActorError(entityId, stopReason, cause));\n\t\t\t\t\t}\n\t\t\t\t\tqueue.clear();\n\t\t\t\t}\n\t\t\t}, 1, TimeUnit.SECONDS);\n\t\t} catch (Exception e) {\n\t\t\tlog.warn(\"[{}] Failed to schedule actor destruction due to [{}]\", entityId, stopReason, e);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.6883115467318}, {"code": "public void destroy(Throwable cause){\n\t\tif (this.stopReason == null) {\n\t\tthis.stopReason = TbActorStopReason.DESTROY;\n\t}\n\n\tif (this.destroyed.compareAndSet(false, true)) {\n\t\tthis.log.warn(\"[{}] Going to destroy actor due to: {}\", this.ctx.getSelf(), cause.getMessage());\n\t\tthis.ctx.getDispatcher().schedule(new DestroyActorTask(cause), 1, TimeUnit.SECONDS);\n\t} else {\n\t\tthis.log.warn(\"[{}] Already destroyed actor due to: {}\", this.ctx.getSelf(), cause.getMessage());\n\t}\n}", "CodeBleu_score": 19.509230339309404}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isNullUid()) {\n\t\treturn true;\n\t}\n\tTenantProfile profile = tenantProfileCache.getIfPresent(tenantId);\n\tif (profile == null) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tRateLimitsTrigger rateLimits = profile.getRateLimit(api);\n\tif (rateLimits == null) {\n\t\treturn true;\n\t}\n\tTbRateLimits tbRateLimits = TbRateLimits.fromRateLimitTrigger(rateLimits);\n\tif (tbRateLimits.isRateLimited(api, level)) {\n\t\tlog.warn(\"[{}] Rate limit exceeded: {}\", tenantId, api);\n\t\tnotificationRuleProcessor.processRateLimitNotification(tenantId, api, level, rateLimits);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 43.02726536206015}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isNullUid()) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = tenantProfileCache.getIfPresent(tenantId);\n\tif (tenantProfile == null) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t\t}\n\t}\n\tRateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimit();\n\tif (rateLimitsTrigger == null) {\n\t\treturn true;\n\t}\n\tTbRateLimits rateLimits = rateLimitsTrigger.getRateLimits();\n\tif (rateLimits == null) {\n\t\treturn true;\n\t}\n\tlong maxCallsPerPeriod = rateLimits.getMaxCallsPerPeriod();\n\tlong periodInSeconds = rateLimits.getPeriodInSeconds();\n\tif (maxCallsPerPeriod == 0 || periodInSeconds == 0) {\n\t\treturn true;\n\t}\n\tlong currentPeriodStart = System.currentTimeMillis() / periodInSeconds * periodInSeconds;\n\tlong currentPeriodEnd = currentPeriodStart + periodInSeconds;\n\tlong currentPeriodCount = rateLimitCache.get(tenantId, () -> new TbRateLimits(maxCallsPerPeriod, periodInSeconds));\n\tif (currentPeriodCount.incrementAndGet() > maxCallsPerPeriod) {\n\t\tif (rateLimitsTrigger.isNotifyIfExceeded()) {\n\t\t\tRateLimitsNotification notification = new RateLimitsNotification(tenantId, api, level, currentPeriodStart, currentPeriodEnd, maxCallsPerPeriod);\n\t\t\tnotificationService.process(notification);\n\t\t}\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 49.16441409767626}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isNullUid()) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = tenantProfileCache.getIfPresent(tenantId);\n\tif (tenantProfile == null) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tRateLimitConfig rateLimitConfig = getRateLimitConfig(tenantProfile);\n\tif (rateLimitConfig == null) {\n\t\treturn true;\n\t}\n\tif (rateLimitConfig.getApiLimit().get(api) == null) {\n\t\treturn true;\n\t}\n\tRateLimitLevel rateLimitLevel = rateLimitConfig.getApiLimit().get(api).get(level);\n\tif (rateLimitLevel == null) {\n\t\treturn true;\n\t}\n\tlong currentTimeMillis = System.currentTimeMillis();\n\tif (rateLimitLevel.getRemainingTokens() > 0) {\n\t\trateLimitLevel.setLastCheckTime(currentTimeMillis);\n\t\trateLimitLevel.setRemainingTokens(rateLimitLevel.getRemainingTokens() - 1);\n\t\treturn true;\n\t}\n\tif (rateLimitLevel.getRemainingTokens() == 0 && currentTimeMillis - rateLimitLevel.getLastCheckTime() < rateLimitLevel.getCheckPeriodInMillis()) {\n\t\treturn false;\n\t}\n\trateLimitLevel.setLastCheckTime(currentTimeMillis);\n\trateLimitLevel.setRemainingTokens(rateLimitLevel.getTokensPerPeriod());\n\trateLimitConfig.getNotification().process(api, tenantId, level, rateLimitLevel.getCheckPeriodInMillis() / 1000, rateLimitLevel.getTokensPerPeriod());\n\treturn true;\n}", "CodeBleu_score": 48.12017766866026}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - this.dtlsSessionTimeout;\n\tfor (String sessionId : this.dtlsSessions.keySet()) {\n\t\tif (this.dtlsSessions.get(sessionId).getLastActivityTime() < expirationTime) {\n\t\t\tDtlsSession dtlsSession = this.dtlsSessions.get(sessionId);\n\t\t\tlog.info(\"Removing expired DTLS session with session ID: \" + sessionId);\n\t\t\tthis.dtlsSessions.remove(sessionId);\n\t\t\tdtlsSession.close();\n\t\t}\n\t}\n}", "CodeBleu_score": 33.71184889790679}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tConcurrentMap<InetSocketAddress, DtlsSession> sessions = getDtlsSessions();\n\tfor (InetSocketAddress remoteAddress : sessions.keySet()) {\n\t\tDtlsSession session = sessions.get(remoteAddress);\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\tsessions.remove(remoteAddress);\n\t\t\tlog.debug(\"Removed DTLS session from cache for {} due to inactivity timeout\", remoteAddress);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.590870997519247}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tsynchronized (dtlsSessions) {\n\t\tfor (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n\t\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\t\tlog.debug(\"Removing DTLS session with peer address {} and fingerprint {} from sessions map\", entry.getValue().getPeerAddress(), entry.getValue().getFingerprint());\n\t\t\t\tdtlsSessions.remove(entry.getKey());\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.42441146809476}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries == null) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> result = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tif (CollectionUtils.isEmpty(values)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (JsonNode value : values) {\n\t\t\tTsKvEntry kvEntry = parseValue(key, value);\n\t\t\tif (kvEntry != null) {\n\t\t\t\tresult.add(kvEntry);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 41.97121998225663}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (CollectionUtils.isEmpty(timeseries)) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> tsKvEntries = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tList<KvEntry> kvEntries = new ArrayList<>();\n\t\tfor (JsonNode node : entry.getValue()) {\n\t\t\tkvEntries.add(parseValue(node));\n\t\t}\n\t\ttsKvEntries.add(new BasicTsKvEntry(parseLong(entry.getKey()), kvEntries));\n\t}\n\treturn tsKvEntries;\n}", "CodeBleu_score": 37.98148760580857}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (CollectionUtils.isEmpty(timeseries)) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> tsKvEntries = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tfor (JsonNode value : values) {\n\t\t\tTsKvEntry tsKvEntry = parseTsKvEntry(key, value);\n\t\t\tif (tsKvEntry != null) {\n\t\t\t\ttsKvEntries.add(tsKvEntry);\n\t\t\t}\n\t\t}\n\t}\n\treturn tsKvEntries;\n}", "CodeBleu_score": 38.36335916830896}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tif (refreshToken == null) {\n\t\tthrow new IllegalArgumentException(\"Refresh token is not set!\");\n\t}\n\tif (refreshToken.getAccessToken() == null) {\n\t\tthrow new IllegalArgumentException(\"Refresh token is not set!\");\n\t}\n\tif (refreshToken.getRefreshToken() == null) {\n\t\tthrow new IllegalArgumentException(\"Refresh token is not set!\");\n\t}\n\tif (refreshToken.getExpireTime() == null) {\n\t\tthrow new IllegalArgumentException(\"Refresh token is not set!\");\n\t}\n\tif (refreshToken.getExpireTime().getTime() < System.currentTimeMillis()) {\n\t\tthrow new IllegalArgumentException(\"Refresh token is expired!\");\n\t}\n\tif (refreshToken.getExpireTime().getTime() - System.currentTimeMillis() < 10000) {\n\t\tthrow new IllegalArgumentException(\"Refresh token is about to expire!\");\n\t}\n\tif (refreshToken.getExpireTime().getTime() - System.currentTimeMillis() > 120000) {\n\t\tthrow new IllegalArgumentException(\"Refresh token is about to expire!\");\n\t}\n\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", refreshToken.getRefreshToken());\n\trequestMap.put(\"refreshTokenSignature\", refreshToken.getRefreshTokenSignature());\n\tHttpHeaders headers = new HttpHeaders();\n\theaders.setContentType(MediaType.APPLICATION_JSON);\n\theaders.set(\"X-Authorization\", refreshToken.getAccessToken());\n\tHttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(requestMap, headers);\n\tResponseEntity<String> responseEntity = restTemplate.postForEntity(authServerUrl + \"/api/auth/refreshToken\", requestEntity, String.class);\n\tif (responseEntity.getStatusCode() != HttpStatus.OK) {\n\t\tthrow new HttpClientErrorException(responseEntity.getStatusCode(), \"Refresh token failed!\");\n\t}\n\tJsonNode responseNode = JacksonUtil.valueToTree(responseEntity.getBody());\n\trefreshToken.setExpireTime(new Date(System.currentTimeMillis() + responseNode.get(\"expires_in\").asLong() * 1000));\n\trefreshToken.setAccessToken(responseNode.get(\"access_token\").asText());\n\trefreshToken.setRefreshToken(responseNode.get(\"refresh_token\").asText());\n\trefreshToken.", "CodeBleu_score": 38.79920536514134}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", getRestClient().getRefresh_token());\n\tString refreshToken = getRestClient().post(getRestClient().getBaseUrl() + \"/api/auth/token\", requestMap, String.class);\n\tgetRestClient().setToken(refreshToken);\n\tgetRestClient().setRefresh_token(refreshToken);\n}", "CodeBleu_score": 46.25627803715358}, {"code": "public void refreshToken(){\n\t\tString refreshToken = getConfiguration(\"refreshToken\");\n\tif (isEmpty(refreshToken)) {\n\t\tlog.error(\"Refresh token is empty!\");\n\t\treturn;\n\t}\n\tString accessToken = getConfiguration(\"accessToken\");\n\tif (isEmpty(accessToken)) {\n\t\tlog.error(\"Access token is empty!\");\n\t\treturn;\n\t}\n\tString tokenEndpoint = getConfiguration(\"tokenEndpoint\");\n\tif (isEmpty(tokenEndpoint)) {\n\t\tlog.error(\"Token endpoint is empty!\");\n\t\treturn;\n\t}\n\tString clientId = getConfiguration(\"clientId\");\n\tif (isEmpty(clientId)) {\n\t\tlog.error(\"Client Id is empty!\");\n\t\treturn;\n\t}\n\tString clientSecret = getConfiguration(\"clientSecret\");\n\tif (isEmpty(clientSecret)) {\n\t\tlog.error(\"Client secret is empty!\");\n\t\treturn;\n\t}\n\tString refreshTokenKey = getConfiguration(\"refreshTokenKey\");\n\tif (isEmpty(refreshTokenKey)) {\n\t\tlog.error(\"Refresh token key is empty!\");\n\t\treturn;\n\t}\n\tString accessTokenKey = getConfiguration(\"accessTokenKey\");\n\tif (isEmpty(accessTokenKey)) {\n\t\tlog.error(\"Access token key is empty!\");\n\t\treturn;\n\t}\n\tString tokenTypeKey = getConfiguration(\"tokenTypeKey\");\n\tif (isEmpty(tokenTypeKey)) {\n\t\tlog.error(\"Token type key is empty!\");\n\t\treturn;\n\t}\n\tString expiresInKey = getConfiguration(\"expiresInKey\");\n\tif (isEmpty(expiresInKey)) {\n\t\tlog.error(\"Expires in key is empty!\");\n\t\treturn;\n\t}\n\tString refreshTokenExpiresInKey = getConfiguration(\"refreshTokenExpiresInKey\");\n\tif (isEmpty(refreshTokenExpiresInKey)) {\n\t\tlog.error(\"Refresh token expires in key is empty!\");\n\t\treturn;\n\t}\n\tString accessTokenExpiresInKey = getConfiguration(\"accessTokenExpiresInKey\");\n\tif (isEmpty(accessTokenExpiresInKey)) {\n\t\tlog.error(\"Access token expires in key is empty!\");\n\t\treturn;\n\t}\n\tString refreshTokenExpireTimeKey = getConfiguration(\"refreshTokenExpireTimeKey\");\n\tif (isEmpty(refreshTokenExpireTimeKey)) {\n\t\tlog.error(\"Refresh token expire time key is empty!\");", "CodeBleu_score": 19.42330129906476}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\tif (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {\n\t\tthrow new IllegalArgumentException(\"Username or password cannot be empty!\");\n\t}\n\ttry {\n\t\t// Create the login request map\n\t\tMap<String, String> loginRequest = new HashMap<>();\n\t\tloginRequest.put(\"username\", username);\n\t\tloginRequest.put(\"password\", password);\n\t\t// Send the login request\n\t\tResponseEntity<JsonNode> response = restTemplate.postForEntity(authUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n\t\tif (response.getStatusCode() == HttpStatus.OK) {\n\t\t\t// Update the token information\n\t\t\tJsonNode body = response.getBody();\n\t\t\tif (body != null) {\n\t\t\t\ttoken = body.get(\"token\").asText();\n\t\t\t\trefreshToken = body.get(\"refreshToken\").asText();\n\t\t\t\trefreshTokenExpirationTime = System.currentTimeMillis() + (body.get(\"refreshTokenExpTime\").asLong() * 1000);\n\t\t\t\tif (body.has(\"jti\")) {\n\t\t\t\t\tjti = body.get(\"jti\").asText();\n\t\t\t\t}\n\t\t\t\tif (body.has(\"refreshTokenExpTime\")) {\n\t\t\t\t\trefreshTokenExpirationTime = System.currentTimeMillis() + (body.get(\"refreshTokenExpTime\").asLong() * 1000);\n\t\t\t\t}\n\t\t\t\tif (body.has(\"accessTokenExpTime\")) {\n\t\t\t\t\taccessTokenExpirationTime = System.currentTimeMillis() + (body.get(\"accessTokenExpTime\").asLong() * 1000);\n\t\t\t\t}\n\t\t\t\tif (body.has(\"customerId\")) {\n\t\t\t\t\tcustomerId = CustomerId.fromString(body.get(\"customerId\").asText());\n\t\t\t\t}\n\t\t\t\tif (body.has(\"tenantId\")) {\n\t\t\t\t\ttenantId = TenantId.fromString(body.get(\"tenantId\").asText());\n\t\t\t\t}\n\t\t\t\tif (body.has(\"userId\")) {\n\t\t\t\t\tuserId = UserId.fromString(body.get(\"userId\").asText());\n\t\t\t\t}\n\t\t\t\tif (body.has(\"userName\")) {\n\t\t\t\t\tusername = body.get(\"userName\").asText();\n\t\t\t\t}\n\t\t\t\tif (body.has(\"userTenantId\")) {\n\t\t\t\t\tuserTenantId = TenantId.fromString(body.get(\"userTenantId\").asText());\n\t\t\t\t}\n\t\t\t\tif (body.has", "CodeBleu_score": 53.61301724862747}, {"code": " private void doLogin(){\n\t\ttry {\n\t\tString username = \"admin\";\n\t\tString password = \"<PASSWORD>\";\n\t\tString url = \"http://localhost:8080/api/auth/login\";\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\theaders.setContentType(MediaType.APPLICATION_JSON);\n\t\tMap<String, String> params = new HashMap<String, String>();\n\t\tparams.put(\"username\", username);\n\t\tparams.put(\"password\", password);\n\t\tHttpEntity<Map<String, String>> entity = new HttpEntity<Map<String, String>>(params, headers);\n\t\tResponseEntity<JsonNode> response = restTemplate.postForEntity(url, entity, JsonNode.class);\n\t\tSystem.out.println(\"Response Body: \" + response.getBody());\n\t\tSystem.out.println(\"Response Status: \" + response.getStatusCode());\n\t\tSystem.out.println(\"Response Headers: \" + response.getHeaders());\n\t\tif (response.getStatusCode().value() != 200) {\n\t\t\tSystem.out.println(\"Login failed!\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Login succeeded!\");\n\t\t\tJsonNode node = response.getBody();\n\t\t\tString accessToken = node.get(\"token\").asText();\n\t\t\tString refreshToken = node.get(\"refreshToken\").asText();\n\t\t\tString tokenType = node.get(\"tokenType\").asText();\n\t\t\tint expiresInSeconds = node.get(\"expiresInSeconds\").asInt();\n\t\t\tString jti = node.get(\"jti\").asText();\n\t\t\tSystem.out.println(\"Access Token: \" + accessToken);\n\t\t\tSystem.out.println(\"Refresh Token: \" + refreshToken);\n\t\t\tSystem.out.println(\"Token Type: \" + tokenType);\n\t\t\tSystem.out.println(\"Expires in: \" + expiresInSeconds);\n\t\t\tSystem.out.println(\"JWT ID: \" + jti);\n\t\t\tSystem.out.println(\"JWT Expiration Time: \" + Instant.now().plusSeconds(expiresInSeconds));\n\t\t\tSystem.out.println(\"JWT Issued At Time: \" + Instant.now());\n\t\t\tSystem.out.println(\"JWT Issuer: \" + node.get(\"iss\").asText());\n\t\t\tSystem.out.println(\"JWT Subject: \" + node.get(\"sub\").asText());\n\t\t\tSystem.out.println(\"JWT", "CodeBleu_score": 35.25902818318575}, {"code": " private void doLogin(){\n\t\ttry {\n\t\t// Set the login request data.\n\t\tMap<String, Object> loginRequest = new HashMap<>();\n\t\tloginRequest.put(\"username\", username);\n\t\tloginRequest.put(\"password\", password);\n\n\t\t// Create the login request entity.\n\t\tHttpEntity<Map<String, Object>> loginRequestEntity = new HttpEntity<>(loginRequest);\n\n\t\t// Send the login request.\n\t\tResponseEntity<Map<String, Object>> loginResponse = restTemplate.postForEntity(authServerUrl + \"/api/auth/login\", loginRequestEntity, Map.class);\n\n\t\t// Check if the login was successful.\n\t\tif (loginResponse.getStatusCode().equals(HttpStatus.OK)) {\n\t\t\t// Get the token information from the response.\n\t\t\tMap<String, String> tokenInfo = (Map<String, String>) loginResponse.getBody().get(\"token\");\n\n\t\t\t// Update the token information.\n\t\t\ttoken.setAccessToken(tokenInfo.get(\"access_token\"));\n\t\t\ttoken.setRefreshToken(tokenInfo.get(\"refresh_token\"));\n\t\t\ttoken.setExpireTime(tokenInfo.get(\"expire_time\"));\n\n\t\t\t// Get the JWT token from the response.\n\t\t\tString jwtToken = (String) loginResponse.getBody().get(\"jwtToken\");\n\n\t\t\t// Check if the JWT token is not empty.\n\t\t\tif (!Strings.isNullOrEmpty(jwtToken)) {\n\t\t\t\t// Set the JWT token.\n\t\t\t\ttoken.setJwtToken(jwtToken);\n\n\t\t\t\t// Get the JWT token expiration time from the response.\n\t\t\t\tString jwtTokenExpireTime = (String) loginResponse.getBody().get(\"expireTime\");\n\n\t\t\t\t// Check if the JWT token expiration time is not empty.\n\t\t\t\tif (!Strings.isNullOrEmpty(jwtTokenExpireTime)) {\n\t\t\t\t\t// Update the JWT token expiration time.\n\t\t\t\t\ttoken.setJwtTokenExpireTime(jwtTokenExpireTime);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get the refresh token expiration time from the response.\n\t\t\tString refreshTokenExpireTime = (String) loginResponse.getBody().get(\"refreshTokenExpireTime\");\n\n\t\t\t// Check if the refresh token expiration time is not empty.\n\t\t\tif (!Strings.isNullOrEmpty(refreshTokenExpireTime)) {\n\t\t\t\t// Update the refresh token expiration time.\n\t\t\t\ttoken.setRefreshTokenExpireTime(refreshTokenExpireTime);\n\t\t\t}\n\n\t\t\t// Get", "CodeBleu_score": 47.46363279487798}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tlog.debug(\"[{}] Retrieving device by id [{}]\", tenantId, deviceId);\n\t\treturn Optional.ofNullable(restTemplate.getForEntity(\n\t\t\t\t\"/api/device/{deviceId}\", Device.class, tenantId, deviceId.getId()).getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\tlog.debug(\"[{}] Device [{}] was not found\", tenantId, deviceId);\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 39.21372102230124}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tDevice device = restTemplate.getForObject(getUrl() + \"/api/device/{deviceId}\", Device.class, deviceId);\n\t\treturn Optional.of(device);\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 51.2868897270943}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\tString url = baseUrl + \"/api/device/\" + deviceId.getId().toString();\n\ttry {\n\t\tResponseEntity<Device> response = restTemplate.exchange(url, HttpMethod.GET, getRequestEntity(), Device.class);\n\t\tif (response.getStatusCode().is2xxSuccessful()) {\n\t\t\treturn Optional.of(response.getBody());\n\t\t} else if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new HttpClientErrorException(response.getStatusCode());\n\t\t}\n\t} catch (HttpClientErrorException e) {\n\t\tthrow new HttpClientErrorException(e.getStatusCode(), \"Failed to get device by id [\" + deviceId.getId().toString() + \"]\", e.getResponseHeaders(), e.getResponseBodyAsString());\n\t}\n}", "CodeBleu_score": 55.170479332203904}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tif (device == null) {\n\t\tthrow new IllegalArgumentException(\"Device object is null\");\n\t}\n\tif (credentials == null) {\n\t\tthrow new IllegalArgumentException(\"Credentials object is null\");\n\t}\n\tif (device.getId() != null) {\n\t\tthrow new IllegalArgumentException(\"Device object must not have an id\");\n\t}\n\tif (credentials.getId() != null) {\n\t\tthrow new IllegalArgumentException(\"Credentials object must not have an id\");\n\t}\n\tif (device.getTenantId() == null) {\n\t\tthrow new IllegalArgumentException(\"Device object must have a tenant id\");\n\t}\n\tif (credentials.getCredentialsType() == null) {\n\t\tthrow new IllegalArgumentException(\"Credentials object must have a credentials type\");\n\t}\n\tif (credentials.getCredentialsId() == null) {\n\t\tthrow new IllegalArgumentException(\"Credentials object must have a credentials id\");\n\t}\n\tif (credentials.getCredentialsType() == DeviceCredentialsType.ACCESS_TOKEN) {\n\t\tthrow new IllegalArgumentException(\"Credentials object must not be of type ACCESS_TOKEN\");\n\t}\n\tif (credentials.getCredentialsType() == DeviceCredentialsType.X509_CERTIFICATE) {\n\t\tthrow new IllegalArgumentException(\"Credentials object must not be of type X509_CERTIFICATE\");\n\t}\n\tif (credentials.getCredentialsType() == DeviceCredentialsType.JWT_TOKEN) {\n\t\tthrow new IllegalArgumentException(\"Credentials object must not be of type JWT_TOKEN\");\n\t}\n\tif (credentials.getCredentialsType() == DeviceCredentialsType.MQTT_BASIC) {\n\t\tthrow new IllegalArgumentException(\"Credentials object must not be of type MQTT_BASIC\");\n\t}\n\tif (credentials.getCredentialsType() == DeviceCredentialsType.MQTT_CERT) {\n\t\tthrow new IllegalArgumentException(\"Credentials object must not be of type MQTT_CERT\");\n\t}\n\tif (credentials.getCredentialsType() == DeviceCredentialsType.LWM2M_ACCESS_TOKEN) {\n\t\tthrow new IllegalArgumentException(\"Credentials object must not be of type LWM2M_ACCESS_TOKEN\");\n\t}\n\tif (credentials.getCredentialsType() == DeviceCredentialsType.LWM2M_X509) {\n\t\tthrow new IllegalArgumentException(\"Credentials object must not be of type LWM2M_X509\");\n\t}\n\tif (credentials.get", "CodeBleu_score": 20.235817269597646}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tlog.info(\"Creating request object to save device with credentials\");\n\t\tSaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest();\n\t\trequest.setDevice(device);\n\t\trequest.setCredentials(credentials);\n\t\tlog.info(\"Sending POST request to save device with credentials\");\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(uri + \"/api/device-with-credentials\", request, Device.class);\n\t\tlog.info(\"Successfully saved device with credentials\");\n\t\treturn Optional.ofNullable(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\tlog.warn(\"Failed to save device with credentials; device not found\");\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tlog.error(\"Failed to save device with credentials; error: {}\", e.getMessage());\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 55.50812656708566}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tif (device == null) {\n\t\t\tthrow new IllegalArgumentException(\"device is null\");\n\t\t}\n\t\tif (credentials == null) {\n\t\t\tthrow new IllegalArgumentException(\"credentials is null\");\n\t\t}\n\t\tif (device.getId() == null) {\n\t\t\tthrow new IllegalArgumentException(\"device.id is null\");\n\t\t}\n\t\tif (credentials.getId() == null) {\n\t\t\tthrow new IllegalArgumentException(\"credentials.id is null\");\n\t\t}\n\t\tif (!device.getId().equals(credentials.getDeviceId())) {\n\t\t\tthrow new IllegalArgumentException(\"device.id does not match credentials.deviceId\");\n\t\t}\n\t\tif (credentials.getCredentialsType() == null) {\n\t\t\tthrow new IllegalArgumentException(\"credentials.credentialsType is null\");\n\t\t}\n\t\tif (credentials.getCredentialsType().equals(DeviceCredentialsType.ACCESS_TOKEN)) {\n\t\t\tthrow new IllegalArgumentException(\"credentials.credentialsType is \" + DeviceCredentialsType.ACCESS_TOKEN + \", but must be \" + DeviceCredentialsType.X509_CERTIFICATE);\n\t\t}\n\t\tif (credentials.getCredentialsType().equals(DeviceCredentialsType.X509_CERTIFICATE)) {\n\t\t\tif (credentials.getCredentialsId() == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"credentials.credentialsId is null\");\n\t\t\t}\n\t\t\tif (credentials.getCredentialsValue() == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"credentials.credentialsValue is null\");\n\t\t\t}\n\t\t}\n\t\tif (credentials.getCredentialsType().equals(DeviceCredentialsType.JWT_TOKEN)) {\n\t\t\tif (credentials.getCredentialsValue() == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"credentials.credentialsValue is null\");\n\t\t\t}\n\t\t}\n\t\tif (credentials.getCredentialsType().equals(DeviceCredentialsType.MQTT_SECRET)) {\n\t\t\tif (credentials.getCredentialsValue() == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"credentials.credentialsValue is null\");\n\t\t\t}\n\t\t}\n\t\tif (credentials.getCredentialsType().equals(DeviceCredentialsType.LWM2M_ACCESS_TOKEN)) {\n\t\t\tif (credentials.getCredentialsValue() == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"credentials.credentialsValue is null\");\n\t\t\t}\n\t\t}\n\t\tif (credentials.getCredentialsType().equals(DeviceCredentialsType.LWM2M_CREDENTIALS)) {\n\t\t\t", "CodeBleu_score": 22.1069004935099}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (typeof addr === 'number') {\n\t\tif (typeof val === 'number') {\n\t\t\tthis.leds[addr].brightness(val);\n\t\t} else {\n\t\t\tthis.leds[addr].brightness();\n\t\t}\n\t} else {\n\t\tfor (let i = 0; i < this.leds.length; i++) {\n\t\t\tthis.leds[i].brightness(addr);\n\t\t}\n\t}\n\treturn this;\n}", "CodeBleu_score": 35.82690342961018}, {"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\tthis.brightness = val;\n\t\tfor (var i = 0; i < this.devices.length; i++) {\n\t\t\tthis.devices[i].brightness(val);\n\t\t}\n\t} else if (arguments.length == 2) {\n\t\tthis.devices[addr].brightness(val);\n\t}\n\treturn this;\n}", "CodeBleu_score": 45.16638516180161}, {"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\tthis._brightness = val;\n\t} else if (arguments.length == 2) {\n\t\tthis._brightness[addr] = val;\n\t}\n\treturn this;\n}", "CodeBleu_score": 36.208465477689}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tvar device = {};\n\n\tfor (var key in LedControl.prototype) {\n\t\tif (typeof LedControl.prototype[key] === \"function\") {\n\t\t\tdevice[key] = this.bind(key, addr);\n\t\t}\n\t}\n\n\tfor (var key in this) {\n\t\tif (typeof this[key] === \"function\") {\n\t\t\tdevice[key] = this.bind(key, addr);\n\t\t}\n\t}\n\n\treturn device;\n}", "CodeBleu_score": 43.712688971731254}, {"code": "device(addr){\n\t\tvar self = this;\n\tvar proto = LedControl.prototype;\n\tfor (var key in proto) {\n\t\tif (typeof proto[key] === \"function\") {\n\t\t\tthis[key] = proto[key].bind(this, addr);\n\t\t}\n\t}\n\tfor (var key in this) {\n\t\tif (typeof this[key] === \"function\") {\n\t\t\tthis[key] = this[key].bind(this, addr);\n\t\t}\n\t}\n\treturn this;\n}", "CodeBleu_score": 40.38414740332667}, {"code": "device(addr){\n\t\tconst prototype = LedControl.prototype;\n\tconst device = {};\n\n\tfor (const key in prototype) {\n\t\tif (prototype.hasOwnProperty(key) && typeof prototype[key] === 'function') {\n\t\t\tdevice[key] = prototype[key].bind(this, addr);\n\t\t}\n\t}\n\n\tfor (const key in this) {\n\t\tif (this.hasOwnProperty(key) && typeof this[key] === 'function') {\n\t\t\tdevice[key] = this[key].bind(this, addr);\n\t\t}\n\t}\n\n\treturn device;\n}", "CodeBleu_score": 42.539698300535846}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\tconst callbackMethod = `${method}WithCallback`;\n\t\ttarget[callbackMethod] = (duration, callback) => {\n\t\t\tif (!callback) {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\tthis.forEach(element => {\n\t\t\t\tconst promise = element[method](duration);\n\t\t\t\tpromises.push(promise);\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 35.340785368631856}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\tif (typeof target[method] === 'function') {\n\t\t\tconst originalMethod = target[method];\n\t\t\ttarget[method] = (collection, callback, duration) => {\n\t\t\t\tconst promises = [];\n\t\t\t\tcollection.forEach(item => {\n\t\t\t\t\tconst promise = originalMethod.call(target, item);\n\t\t\t\t\tif (promise && typeof promise.then === 'function') {\n\t\t\t\t\t\tpromises.push(promise);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn Promise.all(promises).then(() => {\n\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t});\n}", "CodeBleu_score": 35.13314817408475}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = (collection, duration, callback) => {\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tcallback = () => {};\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\tcollection.forEach(element => {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(element[method]());\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 31.257043075360436}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\tvar inputString = \"\";\n\tvar nmeaSentence = \"\";\n\tvar nmeaArray = [];\n\n\twhile (true) {\n\t\tinputString += serialReadLine();\n\n\t\tif (inputString.endsWith(\"\\r\n\")) {\n\t\t\tnmeaArray = inputString.split(\"\\r\n\");\n\t\t\tinputString = nmeaArray.pop();\n\n\t\t\tfor (var i = 0; i < nmeaArray.length; i++) {\n\t\t\t\tnmeaSentence = nmeaArray[i];\n\t\t\t\tparseNmeaSentence(nmeaSentence);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 23.064585217417534}, {"code": "listen(){\n\t\tvar inputString = \"\";\n\tvar nmeaSentence = \"\";\n\tvar data = \"\";\n\tvar port = new SerialPort(portName, {\n\t\tbaudRate: 9600,\n\t\tdataBits: 8,\n\t\tparity: 'none',\n\t\tstopBits: 1,\n\t\tflowControl: false,\n\t\tautoOpen: false\n\t});\n\tport.open(function (err) {\n\t\tif (err) {\n\t\t\treturn console.log('Error opening port: ', err.message);\n\t\t}\n\t\tconsole.log('Port ' + portName + ' opened');\n\t\tport.on('data', function (data) {\n\t\t\tinputString += data.toString('utf8');\n\t\t\tinputString = inputString.replace(\"\\r\n\", \"\n\");\n\t\t\tvar inputArray = inputString.split(\"\n\");\n\t\t\tinputString = inputArray.pop();\n\t\t\tfor (var i = 0; i < inputArray.length; i++) {\n\t\t\t\tnmeaSentence = inputArray[i];\n\t\t\t\tif (nmeaSentence.charAt(nmeaSentence.length - 1) == \"\\r\") {\n\t\t\t\t\tnmeaSentence = nmeaSentence.slice(0, -1);\n\t\t\t\t}\n\t\t\t\tif (nmeaSentence.length > 0) {\n\t\t\t\t\tparseNmeaSentence(nmeaSentence);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}", "CodeBleu_score": 31.525756223390793}, {"code": "listen(){\n\t\tvar input = \"\";\n\tvar serialPort = new SerialPort(serialPortName, {\n\t\tbaudRate: 9600\n\t});\n\tserialPort.on(\"open\", function() {\n\t\tconsole.log(\"Serial port \" + serialPortName + \" opened.\");\n\t\tserialPort.on(\"data\", function(data) {\n\t\t\tinput += data.toString(\"utf8\");\n\t\t\tvar sentences = input.split(\"\\r\n\");\n\t\t\tinput = sentences.pop();\n\t\t\tfor (var i = 0; i < sentences.length; i++) {\n\t\t\t\tparseNmeaSentence(sentences[i]);\n\t\t\t}\n\t\t});\n\t});\n}", "CodeBleu_score": 36.85339534038986}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tu32_t active_channels = 0U;\n\tu32_t buffer_size = 0U;\n\n\tif (sequence->channels & BIT(config->input_pin)) {\n\t\tactive_channels++;\n\t}\n\n\tif (sequence->channels & BIT(config->ref_pin)) {\n\t\tactive_channels++;\n\t}\n\n\tif (sequence->channels & BIT(config->gnd_pin)) {\n\t\tactive_channels++;\n\t}\n\n\tbuffer_size = active_channels * sizeof(u16_t);\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 53.259953118980995}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tuint32_t channel_count = 0U;\n\tuint32_t sample_size = 0U;\n\tuint32_t needed_size = 0U;\n\n\t/*\n\t * Check if the device is in the correct state.\n\t */\n\tif (dev->driver_api->adc_read == NULL) {\n\t\tLOG_ERR(\"adc_read() API is NULL\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * Check if the sequence is NULL.\n\t */\n\tif (sequence == NULL) {\n\t\tLOG_ERR(\"adc_sequence is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the buffer is NULL.\n\t */\n\tif (sequence->buffer == NULL) {\n\t\tLOG_ERR(\"adc_sequence->buffer is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the channel count is zero.\n\t */\n\tchannel_count = sequence->channels;\n\tif (channel_count == 0U) {\n\t\tLOG_ERR(\"adc_sequence->channels is zero\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the channel count is greater than the maximum.\n\t */\n\tif (channel_count > config->info->max_channel_count) {\n\t\tLOG_ERR(\"adc_sequence->channels (%d) is greater than the maximum (%d)\",\n\t\t\tchannel_count, config->info->max_channel_count);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the buffer size is zero.\n\t */\n\tif (sequence->buffer_size == 0U) {\n\t\tLOG_ERR(\"adc_sequence->buffer_size is zero\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the buffer size is greater than the maximum.\n\t */\n\tif (sequence->buffer_size > config->info->max_buffer_size) {\n\t\tLOG_ERR(\"adc_sequence->buffer_size (%d) is greater than the maximum (%d)\",\n\t\t\tsequence->buffer_size, config->info->max_buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the buffer", "CodeBleu_score": 39.5303573365433}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tuint16_t channels = 0;\n\tuint16_t data_size = 0;\n\tuint16_t i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tconst struct adc_channel_cfg *channel = &sequence->channels[i];\n\n\t\tif (channel->channel_id >= config->channels) {\n\t\t\tLOG_ERR(\"Channel %d is not valid (valid channels: 0-%d)\",\n\t\t\t\tchannel->channel_id, config->channels - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channel->channel_id == 0) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 1) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 2) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 3) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 4) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 5) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 6) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 7) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 8) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 9) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 10) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 11) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 12) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 13) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 14) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 15) {\n\t\t\tchannels++;\n\t\t}\n\n\t\tif (channel->channel_id == 16) {\n\t\t\tchannels++;\n\t\t", "CodeBleu_score": 40.133185277504055}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tstruct ad559x_data *data = dev->data;\n\tuint8_t channel_count = 0U;\n\tuint8_t resolution = 0U;\n\tint error_code = 0;\n\tuint8_t channel_buffer[AD559X_CHANNEL_COUNT];\n\tuint8_t channel_buffer_index = 0U;\n\tuint8_t channel_buffer_size = 0U;\n\tuint8_t channel_buffer_value = 0U;\n\tuint8_t channel_buffer_mask = 0U;\n\tuint8_t channel_buffer_bit_index = 0U;\n\tuint8_t channel_buffer_bit_mask = 0U;\n\tuint8_t channel_buffer_bit_value = 0U;\n\tuint8_t channel_buffer_bit_count = 0U;\n\tuint8_t channel_buffer_bit_value_index = 0U;\n\tuint8_t channel_buffer_bit_value_mask = 0U;\n\tuint8_t channel_buffer_bit_value_bit_index = 0U;\n\tuint8_t channel_buffer_bit_value_bit_mask = 0U;\n\tuint8_t channel_buffer_bit_value_bit_value = 0U;\n\tuint8_t channel_buffer_bit_value_bit_count = 0U;\n\tuint8_t channel_buffer_bit_value_bit_value_index = 0U;\n\tuint8_t channel_buffer_bit_value_bit_value_mask = 0U;\n\tuint8_t channel_buffer_bit_value_bit_value_bit_index = 0U;\n\tuint8_t channel_buffer_bit_value_bit_value_bit_mask = 0U;\n\tuint8_t channel_buffer_bit_value_bit_value_bit_value = 0U;\n\tuint8_t channel_buffer_bit_value_bit_value_bit_count = 0U;\n\tuint8_t", "CodeBleu_score": 12.588196834138513}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tstruct ad559x_data *data = dev->data;\n\tuint8_t chan_mask;\n\tuint8_t chan_seq_len;\n\tuint8_t chan_seq_idx;\n\tuint8_t chan_seq_idx_max;\n\tuint8_t chan_seq_idx_min;\n\tuint8_t chan_seq_idx_tmp;\n\tuint8_t chan_seq_idx_tmp_max;\n\tuint8_t chan_seq_idx_tmp_min;\n\tuint8_t chan_seq_idx_tmp_prev;\n\tuint8_t chan_seq_idx_tmp_prev_max;\n\tuint8_t chan_seq_idx_tmp_prev_min;\n\tuint8_t chan_seq_idx_tmp_prev_prev;\n\tuint8_t chan_seq_idx_tmp_prev_prev_max;\n\tuint8_t chan_seq_idx_tmp_prev_prev_min;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev_max;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev_min;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev_prev;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev_prev_max;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev_prev_min;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev_prev_prev;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev_prev_prev_max;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev_prev_prev_min;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev_prev_prev_prev;\n\tuint8_t chan_seq_idx_tmp_prev_prev_prev_prev_prev_", "CodeBleu_score": 11.694264721379028}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tstruct ad559x_data *data = dev->data;\n\tuint8_t chan_mask;\n\tuint8_t chan_seq;\n\tuint8_t chan_seq_len;\n\tuint8_t chan_seq_idx;\n\tuint8_t chan_seq_idx_start;\n\tuint8_t chan_seq_idx_end;\n\tuint8_t chan_seq_idx_step;\n\tuint8_t chan_seq_idx_end_last;\n\tuint8_t chan_seq_idx_step_last;\n\tuint8_t chan_seq_idx_end_last_valid;\n\tuint8_t chan_seq_idx_step_last_valid;\n\tuint8_t chan_seq_idx_end_last_valid_last;\n\tuint8_t chan_seq_idx_step_last_valid_last;\n\tuint8_t chan_seq_idx_end_last_valid_last_last;\n\tuint8_t chan_seq_idx_step_last_valid_last_last;\n\tuint8_t chan_seq_idx_end_last_valid_last_last_last;\n\tuint8_t chan_seq_idx_step_last_valid_last_last_last;\n\tuint8_t chan_seq_idx_end_last_valid_last_last_last_last;\n\tuint8_t chan_seq_idx_step_last_valid_last_last_last_last;\n\tuint8_t chan_seq_idx_end_last_valid_last_last_last_last_last;\n\tuint8_t chan_seq_idx_step_last_valid_last_last_last_last_last;\n\tuint8_t chan_seq_idx_end_last_valid_last_last_last_last_last_last;\n\tuint8_t chan_seq_idx_step_last_valid_last_last_last_last_last_last;\n\tuint8_t chan_seq_idx_end_last_valid_last_last_last_", "CodeBleu_score": 11.919256844000014}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_sequence *seq = &ctx->sequence;\n\tconst struct device *dev = ctx->dev;\n\tuint8_t chan_list[seq->channels];\n\tuint16_t *repeat_buffer;\n\tuint16_t *data_buffer;\n\tuint32_t data_buffer_size;\n\tuint8_t i;\n\n\t/* Retrieve the ADC data structure from the context. */\n\tstruct ad559x_config *config = dev->config;\n\tstruct ad559x_data *data = dev->data;\n\n\t/* Set the channels to be sampled. */\n\tfor (i = 0; i < seq->channels; i++) {\n\t\tchan_list[i] = seq->channels[i].channel_id;\n\t}\n\n\t/* Initialize the repeat buffer with the data buffer. */\n\trepeat_buffer = data->buffer;\n\tdata_buffer = data->buffer;\n\tdata_buffer_size = sizeof(data->buffer);\n\n\t/* Release a semaphore to signal the start of sampling. */\n\tk_sem_give(&data->sem);\n\n\t/* Set the ADC configuration. */\n\tad559x_set_config(dev, seq->resolution, seq->oversampling, chan_list,\n\t\t\t seq->channels);\n\n\t/* Set the ADC data buffer. */\n\tad559x_set_data_buf(dev, data_buffer, data_buffer_size, repeat_buffer,\n\t\t\t    data_buffer_size);\n\n\t/* Start the ADC. */\n\tad559x_start(dev);\n}", "CodeBleu_score": 28.96288337226765}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = &ctx->data;\n\tconst struct device *dev = ctx->dev;\n\tconst struct ad559x_config *config = dev->config;\n\tuint8_t channel_mask = 0;\n\tint i;\n\n\tfor (i = 0; i < data->channel_count; i++) {\n\t\tchannel_mask |= BIT(data->channels[i].channel_id);\n\t}\n\n\tad559x_set_channel_mask(dev, channel_mask);\n\n\t/* Set the data buffer */\n\tfor (i = 0; i < data->channel_count; i++) {\n\t\tdata->buffer[i] = 0;\n\t}\n\n\t/* Set the repeat buffer */\n\tfor (i = 0; i < data->channel_count; i++) {\n\t\tdata->repeat_buffer[i] = 0;\n\t}\n\n\t/* Set the repeat count */\n\tdata->repeat_count = 0;\n\n\t/* Signal that the buffer is ready to be read */\n\tk_sem_give(&data->sem);\n\n\t/* Start the sampling */\n\tad559x_start_conversion(dev);\n}", "CodeBleu_score": 38.2928272933742}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tconst struct device *dev = ctx->dev;\n\tconst struct ad559x_config *config = dev->config;\n\tstruct ad559x_data *data = dev->data;\n\tstruct adc_sequence *seq = &ctx->sequence;\n\tconst struct adc_channel_cfg *channel = seq->channels;\n\tint i;\n\n\tfor (i = 0; i < seq->channels_num; i++) {\n\t\tif (channel[i].gain == ADC_GAIN_1) {\n\t\t\tdata->gain = AD559X_GAIN_1;\n\t\t} else if (channel[i].gain == ADC_GAIN_2) {\n\t\t\tdata->gain = AD559X_GAIN_2;\n\t\t} else if (channel[i].gain == ADC_GAIN_4) {\n\t\t\tdata->gain = AD559X_GAIN_4;\n\t\t} else if (channel[i].gain == ADC_GAIN_8) {\n\t\t\tdata->gain = AD559X_GAIN_8;\n\t\t} else {\n\t\t\tLOG_ERR(\"Unsupported gain value\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (channel[i].reference == ADC_REF_EXTERNAL0) {\n\t\t\tdata->reference = AD559X_REF_EXTERNAL0;\n\t\t} else if (channel[i].reference == ADC_REF_EXTERNAL1) {\n\t\t\tdata->reference = AD559X_REF_EXTERNAL1;\n\t\t} else if (channel[i].reference == ADC_REF_INTERNAL) {\n\t\t\tdata->reference = AD559X_REF_INTERNAL;\n\t\t} else {\n\t\t\tLOG_ERR(\"Unsupported reference value\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (channel[i].acquisition_time == ADC_ACQ_TIME_DEFAULT) {\n\t\t\tdata->acquisition_time = AD559X_ACQ_TIME_DEFAULT;\n\t\t} else if (channel[i].acquisition_time == ADC_ACQ_TIME_3_5) {\n\t\t\tdata->acquisition_time = AD559X_ACQ_TIME_3_5;\n\t\t} else if (channel[i].acquisition_time == ADC_ACQ_TIME_7_5)", "CodeBleu_score": 39.89749257938956}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer = ctx->buffer_tmp;\n\t}\n}", "CodeBleu_score": 46.77476177156553}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t}\n}", "CodeBleu_score": 44.32578164190454}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_sequence *seq = &ctx->sequence;\n\n\tif (seq->options & ADC_ITERATE_SAMPLES) {\n\t\tif (repeat_sampling) {\n\t\t\tseq->buffer = seq->buffer_repeat;\n\t\t} else {\n\t\t\tseq->buffer = seq->buffer_raw;\n\t\t}\n\t}\n}", "CodeBleu_score": 45.47972844676263}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint8_t i;\n\tuint8_t channel;\n\tint32_t raw_value;\n\tuint16_t raw_value_u16;\n\tint32_t raw_value_u32;\n\tuint32_t raw_value_u32_be;\n\tint16_t raw_value_s16;\n\tuint16_t raw_value_s16_be;\n\tint16_t raw_value_s16_le;\n\tint16_t raw_value_s16_be_u16;\n\tuint16_t raw_value_s16_le_u16;\n\tint16_t raw_value_s16_be_u32;\n\tuint16_t raw_value_s16_le_u32;\n\tint32_t raw_value_s32;\n\tuint32_t raw_value_s32_be;\n\tuint32_t raw_value_s32_le;\n\tint32_t raw_value_s32_be_u32;\n\tuint32_t raw_value_s32_le_u32;\n\tint32_t raw_value_s32_be_u16;\n\tuint32_t raw_value_s32_le_u16;\n\tint32_t raw_value_s32_be_u16_u16;\n\tuint32_t raw_value_s32_le_u16_u16;\n\tint32_t raw_value_s32_be_u32_u32;\n\tuint32_t raw_value_s32_le_u32_u32;\n\tint32_t raw_value_s32_be_u32_u16;\n\tuint32_t raw_value_s32_le_u32_u16;\n\tint32_t raw_value_s32_be_u16_u3", "CodeBleu_score": 5.382241319226808}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint err;\n\tuint16_t value;\n\tuint8_t channel;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < data->channel_count; channel++) {\n\t\t\terr = ad559x_read(data->dev, channel, &value);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d\", channel);\n\t\t\t\tdata->ctx.sampling_done = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdata->buffer[channel] = sys_le16_to_cpu(value);\n\t\t}\n\n\t\tdata->ctx.sampling_done = true;\n\t}\n}", "CodeBleu_score": 42.85863019273623}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct device *dev = data->dev;\n\tstruct adc_context *ctx = &data->ctx;\n\tconst struct adc_sequence *sequence = ctx->sequence;\n\tu8_t channel_id;\n\tu16_t value;\n\tint err;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel_id = 0; channel_id < sequence->channels; channel_id++) {\n\t\t\tconst struct adc_channel_cfg *channel = &sequence->channels[channel_id];\n\n\t\t\terr = adc_read(dev, channel, &value);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"ADC read failed (err %d)\", err);\n\t\t\t\tadc_context_stop_sampling(ctx);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx->buffer[channel_id] = sys_le16_to_cpu(value);\n\t\t}\n\n\t\tadc_context_on_sampling_done(ctx, sequence->resolution);\n\t}\n}", "CodeBleu_score": 38.32009737864141}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t     // \u7b49\u5f85ADS11112\u8bbe\u5907\u51c6\u5907\u597d\u6570\u636e\u8bfb\u53d6\n\n    const struct ads1112_config *config = dev->config;\n\n    uint8_t reg_val;\n\n    int ret;\n\n    uint32_t timeout = config->ready_time;\n\n    while (timeout > 0) {\n\n        ret = ads1112_reg_read(dev, ADS1112_REG_CONFIG, &reg_val);\n\n        if (ret != 0) {\n\n            return ret;\n\n        }\n\n        if (reg_val & ADS1112_CONFIG_OS_MASK) {\n\n            break;\n\n        }\n\n        k_usleep(100);\n\n        timeout--;\n\n    }\n\n    if (timeout == 0) {\n\n        return -EBUSY;\n\n    }\n\n    return 0;\n\n}", "CodeBleu_score": 48.71224484283878}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\n\tuint8_t reg;\n\tuint8_t ready_bit;\n\tint err;\n\tuint32_t ready_time;\n\tconst struct ads1112_config *config = dev->config;\n\tconst struct ads1112_dev_config *dev_config = config->dev_config;\n\tstruct ads1112_data *data = dev->data;\n\tconst struct ads1112_reg *reg_config = dev_config->reg;\n\tconst struct ads1112_reg *reg_config_p = reg_config;\n\tint16_t ready_delay = 0;\n\n\tif (data->continuous) {\n\t\tready_bit = ADS1112_CONFIG_OS_BIT;\n\t\tready_time = dev_config->ready_time_continuous;\n\t} else {\n\t\tready_bit = ADS1112_CONFIG_OS_BIT;\n\t\tready_time = dev_config->ready_time_single;\n\t}\n\n\tdo {\n\t\tk_sleep(100);\n\n\t\terr = ads1112_read_reg(dev, reg_config_p++, &reg);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\n\t\tready_delay += 100;\n\t} while (!(reg & ready_bit) && (ready_delay < ready_time));\n\n\tif (ready_delay >= ready_time) {\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 34.88290725231412}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t     // \u7b49\u5f85ADS11112\u8bbe\u5907\u51c6\u5907\u597d\u6570\u636e\u8bfb\u53d6\n    int err;\n    uint8_t config;\n\n    err = ads11112_reg_read(dev, ADS1112_REG_CONFIG, &config);\n    if (err) {\n        return err;\n    }\n\n    if (!(config & ADS1112_CONFIG_OS_MASK)) {\n        return -EBUSY;\n    }\n\n    return 0;\n}", "CodeBleu_score": 27.70181980336802}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_buffer_size = 0;\n\n\trequired_buffer_size = sequence->options.extra_samplings + 1;\n\n\tif (required_buffer_size > sequence->options.buffer_size) {\n\t\tLOG_ERR(\"Buffer size %d is too small for the sequence.\", sequence->options.buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 36.204203639497145}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint16_t required_buffer_size;\n\n\trequired_buffer_size = sequence->options.extra_samplings + 1;\n\n\tif (required_buffer_size > sequence->options.buffer_size) {\n\t\tLOG_ERR(\"buffer size too small\");\n\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 35.12989853195753}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_size = 0;\n\tsize_t i;\n\n\t/*\n\t * Loop through all entries in the sequence, calculating the\n\t * required buffer size.\n\t */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tconst struct adc_sequence_entry *entry = &sequence->entries[i];\n\t\tsize_t num_samplings = entry->options.extra_samplings + 1;\n\n\t\trequired_size += num_samplings * sizeof(uint16_t);\n\t}\n\n\t/*\n\t * Check if the buffer size is sufficient.\n\t */\n\tif (required_size > sequence->options.buffer_size) {\n\t\tLOG_ERR(\"Provided buffer size (%d) is too small (%d)\", sequence->options.buffer_size, required_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.54207271134825}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint err_code = 0;\n\tuint16_t *buf = NULL;\n\tuint16_t *buf_ptr = NULL;\n\tint32_t buf_len = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tuint8_t channel_count = 0;\n\tuint8_t channel_index = 0;\n\tuint8_t channel_mask = 0;\n\tuint8_t channel_gain = 0;\n\tuint8_t channel_mux = 0;\n\tuint8_t channel_mux_mask = 0;\n\tuint8_t channel_mux_value = 0;\n\tuint8_t channel_mux_offset = 0;\n\tuint8_t channel_mux_channel_count = 0;\n\tuint8_t channel_mux_channel_index = 0;\n\tuint8_t channel_mux_channel_gain = 0;\n\tuint8_t channel_mux_channel_mux = 0;\n\tuint8_t channel_mux_channel_mux_mask = 0;\n\tuint8_t channel_mux_channel_mux_value = 0;\n\tuint8_t channel_mux_channel_mux_offset = 0;\n\tuint8_t channel_mux_channel_mux_channel_count = 0;\n\tuint8_t channel_mux_channel_mux_channel_index = 0;\n\tuint8_t channel_mux_channel_mux_channel_gain = 0;\n\tuint8_t channel_mux_channel_mux_channel_mux = 0;\n\tuint8_t channel_mux_channel_mux_channel_mux_mask = 0;\n\tuint8_t channel_mux_channel_mux_channel_mux_value = 0;\n\tuint8_t channel_mux_channel_mux_channel_mux_offset = 0;\n\tuint8_t channel_mux_channel_mux_channel_", "CodeBleu_score": 16.778508461408574}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint err_code;\n\n\t/* Check if the driver is busy */\n\tif (data->ctx.read_pending) {\n\t\treturn -EBUSY;\n\t}\n\n\t/* Check if the sequence buffer is valid */\n\tif (!sequence || sequence->buffer == NULL ||\n\t    sequence->buffer_size == 0U) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested resolution is supported */\n\tif (sequence->resolution != 12U) {\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Check if the requested channels are supported */\n\tif (sequence->channels & ~((1U << config->channels) - 1U)) {\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Check if the requested gain is supported */\n\tif (sequence->gain != ADC_GAIN_1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Check if the requested acquisition time is supported */\n\tif (sequence->acquisition_time != ADC_ACQ_TIME_DEFAULT) {\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Check if the requested channel differential mode is supported */\n\tif (sequence->channel_differential) {\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Check if the requested external reference is supported */\n\tif (sequence->reference_external) {\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Check if the requested buffer is word-aligned */\n\tif ((u32_t)sequence->buffer & 0x3) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested buffer size is word-aligned */\n\tif (sequence->buffer_size & 0x3) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested buffer size is within limits */\n\tif (sequence->buffer_size > ADS1112_MAX_BUFFER_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested channels are within limits */\n\tif (sequence->channels > config->channels) {\n\t\treturn -EINVAL;\n\t", "CodeBleu_score": 41.762112202946604}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t *buffer = data->buffer;\n\tuint16_t *buffer16 = (uint16_t *)buffer;\n\tuint8_t *buf_ptr;\n\tuint16_t *buf_ptr16;\n\tuint16_t *buf_end16;\n\tuint8_t *buf_end;\n\tuint16_t raw;\n\tuint16_t raw_prev;\n\tuint16_t raw_diff;\n\tuint16_t raw_diff_prev;\n\tuint16_t raw_diff_sum;\n\tuint16_t raw_diff_sum_prev;\n\tuint16_t raw_diff_sum_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev_prev_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tuint16_t raw_diff_sum_prev_prev_prev_prev_prev_prev_", "CodeBleu_score": 15.581441023688264}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint err;\n\tint ret;\n\tint i;\n\tint j;\n\tint k;\n\tint num_of_props;\n\tint num_of_values;\n\tint prop_id;\n\tint prop_value;\n\tint prop_value_type;\n\tint prop_len;\n\tint prop_len_type;\n\tint prop_len_value;\n\tint prop_len_value_type;\n\tint prop_len_value_len;\n\tint prop_len_value_len_type;\n\tint prop_len_value_len_value;\n\tint prop_len_value_len_value_type;\n\tint prop_len_value_len_value_len;\n\tint prop_len_value_len_value_len_type;\n\tint prop_len_value_len_value_len_value;\n\tint prop_len_value_len_value_len_value_type;\n\tint prop_len_value_len_value_len_value_value;\n\tint prop_len_value_len_value_len_value_value_type;\n\tint prop_len_value_len_value_len_value_value_value;\n\tint prop_len_value_len_value_len_value_value_value_type;\n\tint prop_len_value_len_value_len_value_value_value_value;\n\tint prop_len_value_len_value_len_value_value_value_value_type;\n\tint prop_len_value_len_value_len_value_value_value_value_value;\n\tint prop_len_value_len_value_len_value_value_value_value_value_type;\n\tint prop_len_value_len_value_len_value_value_value_value_value_value;\n\tint prop_len_value_len_value_len_value_value_value_value_value_value_type;\n\tint prop_len_value_len_value_len_value_value_value_value_value_value_value;\n\tint prop_len_value_len_value_len_value_value_value_value", "CodeBleu_score": 34.96639794935326}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret = 0;\n\tstruct device *dev = NULL;\n\tstruct audio_codec_cfg cfg = {0};\n\n\tif (argc != 2) {\n\t\tshell_error(sh, \"Invalid number of arguments. Usage:\n%s <device_name>\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tcfg.dev = dev;\n\tcfg.is_capture = false;\n\tcfg.is_playback = true;\n\tcfg.data_format = AUDIO_CODEC_PCM;\n\tcfg.pcm.rate = 44100;\n\tcfg.pcm.channels = 2;\n\tcfg.pcm.format = AUDIO_PCM_S16_LE;\n\tcfg.pcm.period_bytes = 4096;\n\tcfg.pcm.periods = 4;\n\n\tret = audio_codec_set_config(dev, &cfg);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to set config\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 52.72134653234487}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret;\n\tint16_t val;\n\tuint16_t val16;\n\tuint32_t val32;\n\tuint8_t val8;\n\tstruct device *dev;\n\tstruct audio_codec_cfg cfg;\n\tstruct audio_codec_caps caps;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Could not get the device\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Missing property name\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (strcmp(argv[2], \"sample_rate\") == 0) {\n\t\tif (argc < 4) {\n\t\t\tshell_error(sh, \"Missing sample rate value\");\n\t\t\treturn -ENOEXEC;\n\t\t}\n\n\t\tval = atoi(argv[3]);\n\t\tret = audio_codec_set_property(dev, AUDIO_CODEC_PROP_SAMPLE_RATE, &val, sizeof(val));\n\t\tif (ret) {\n\t\t\tshell_error(sh, \"Could not set sample rate\");\n\t\t\treturn ret;\n\t\t}\n\t} else if (strcmp(argv[2], \"channels\") == 0) {\n\t\tif (argc < 4) {\n\t\t\tshell_error(sh, \"Missing channels value\");\n\t\t\treturn -ENOEXEC;\n\t\t}\n\n\t\tval = atoi(argv[3]);\n\t\tret = audio_codec_set_property(dev, AUDIO_CODEC_PROP_CHANNELS, &val, sizeof(val));\n\t\tif (ret) {\n\t\t\tshell_error(sh, \"Could not set channels\");\n\t\t\treturn ret;\n\t\t}\n\t} else if (strcmp(argv[2], \"bit_width\") == 0) {\n\t\tif (argc < 4) {\n\t\t\tshell_error(sh, \"Missing bit width value\");\n\t\t\treturn -ENOEXEC;\n\t\t}\n\n\t\tval = atoi(argv[3]);\n\t\tret = audio_codec_set_property(dev,", "CodeBleu_score": 49.04748519782206}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tconst struct mpxxdtyy_i2s_config *config = dev->config;\n\n\t/* Check if the device is in the correct state for the specified command. */\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\treturn i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid state for start command.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\treturn i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid state for stop command.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command.\");\n\t\treturn -EINVAL;\n\t}\n}", "CodeBleu_score": 52.11830517676095}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_dev_data *dd = (struct mpxxdtyy_dev_data *)dev->data;\n\tint ret = 0;\n\n\t/* Check if the device is in the configured state */\n\tif (dd->state != MPXXDTYY_STATE_CONFIGURED) {\n\t\tLOG_ERR(\"Device not configured\");\n\t\treturn -EIO;\n\t}\n\n\t/* Check if the device is already active */\n\tif (dd->state == MPXXDTYY_STATE_ACTIVE) {\n\t\tLOG_ERR(\"Device already active\");\n\t\treturn -EIO;\n\t}\n\n\t/* Check if the device is configured for the given trigger command */\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (dd->i2s_config.mode == I2S_MODE_MASTER) {\n\t\t\tif (dd->i2s_config.format == I2S_FMT_DATA_FORMAT_I2S) {\n\t\t\t\tif (dd->i2s_config.options == I2S_OPT_BIT_CLOCK_SLAVE_MODE) {\n\t\t\t\t\tif (dd->i2s_config.frame_clk_freq == 16000) {\n\t\t\t\t\t\tif (dd->i2s_config.channels == 2) {\n\t\t\t\t\t\t\tif (dd->i2s_config.sample_size == 16) {\n\t\t\t\t\t\t\t\tif (dd->i2s_config.word_select == I2S_WS_LEFT) {\n\t\t\t\t\t\t\t\t\tif (dd->i2s_config.frame_sync_mode == I2S_FS_MODE_LEFT_JUSTIFIED) {\n\t\t\t\t\t\t\t\t\t\tif (dd->i2s_config.frame_sync_active_level == I2S_FS_ACTIVE_LOW) {\n\t\t\t\t\t\t\t\t\t\t\tif (dd->i2s_config.frame_sync_width == 16) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (dd->i2s_config.frame_sync_polarity == I2S_FS_FALLING_EDGE) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (dd->i2s_config.frame_sync_delay == 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (dd->i2s_config.block_size == 16) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (dd->i2s_", "CodeBleu_score": 37.71060064088532}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *data = dev->data;\n\n\tint ret = 0;\n\n\tswitch (cmd) {\n\t\tcase DMIC_TRIGGER_START:\n\t\t\t/*\n\t\t\t * If the device is not yet configured, set the configuration and state to configured.\n\t\t\t * Otherwise, set the state to active.\n\t\t\t */\n\t\t\tif (data->state == DMIC_STATE_UNCONFIGURED) {\n\t\t\t\tret = mpxxdtyy_configure(dev);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to configure device\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} else if (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\t\tret = mpxxdtyy_activate(dev);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to activate device\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Device is already active\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DMIC_TRIGGER_STOP:\n\t\t\t/*\n\t\t\t * If the device is active, set the state to configured.\n\t\t\t * Otherwise, set the state to unconfigured.\n\t\t\t */\n\t\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\t\tret = mpxxdtyy_deactivate(dev);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to deactivate device\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} else if (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\t\tret = mpxxdtyy_unconfigure(dev);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to unconfigure device\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Device is already inactive\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tLOG_ERR(\"Invalid trigger command\");\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 51.887133537174634}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd;\n\n\tconst struct auxdisplay_hd44780_data *data = dev->data;\n\n\tif (enabled) {\n\t\tcmd = AUXDISPLAY_HD44780_DISPLAY_ON;\n\t} else {\n\t\tcmd = AUXDISPLAY_HD44780_DISPLAY_OFF;\n\t}\n\n\tif (data->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK;\n\t}\n\n\tif (data->cursor_reverse) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_REVERSE;\n\t}\n\n\tif (data->cursor_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->display_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->display_shift) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_SHIFT;\n\t}\n\n\tif (data->display_cursor) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_CURSOR;\n\t}\n\n\tif (data->display_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_BLINK;\n\t}\n\n\tif (data->display_reverse) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_REVERSE;\n\t}\n\n\tif (data->display_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->display_cursor) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_CURSOR;\n\t}\n\n\tif (data->display_shift) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_SHIFT;\n\t}\n\n\tif (data->display_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->display_", "CodeBleu_score": 59.87799991962193}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd |= BIT(0);\n\t}\n\n\tif (config->cursor) {\n\t\tcmd |= BIT(1);\n\t}\n\n\tif (config->blink) {\n\t\tcmd |= BIT(2);\n\t}\n\n\tif (config->display_on) {\n\t\tcmd |= BIT(3);\n\t}\n\n\tconst struct auxdisplay_hd44780_data *data = dev->data;\n\n\tdata->display_mode = cmd;\n\n\tif (config->display_on) {\n\t\tdata->flags |= BIT(0);\n\t}\n\n\tif (config->cursor) {\n\t\tdata->flags |= BIT(1);\n\t}\n\n\tif (config->blink) {\n\t\tdata->flags |= BIT(2);\n\t}\n\n\tif (data->flags) {\n\t\tdata->flags |= BIT(3);\n\t}\n\n\tconst struct device *gpio = device_get_binding(config->gpio_dev_name);\n\n\tgpio_pin_write(gpio, config->gpio_pin, data->display_mode);\n}", "CodeBleu_score": 52.69402519578511}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t} else {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_OFF;\n\t}\n\n\tif (config->flags & AUXDISPLAY_HD44780_FLAG_CURSOR_BLINK) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK_ON;\n\t} else {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK_OFF;\n\t}\n\n\tif (config->flags & AUXDISPLAY_HD44780_FLAG_CURSOR_ON) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t} else {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_OFF;\n\t}\n\n\tif (config->flags & AUXDISPLAY_HD44780_FLAG_DISPLAY_BLINK) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_BLINK_ON;\n\t} else {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_BLINK_OFF;\n\t}\n\n\tif (data->cursor_pos.x == data->cursor_pos.y) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_HOME;\n\t} else {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_SET;\n\t}\n\n\tif (data->cursor_pos.x == 0) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_DDRAM_SET;\n\t} else {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_CGRAM_SET;\n\t}\n\n\tif (data->cursor_pos.x == 0 && data->cursor_pos.y == 0) {\n\t\tcmd |= AUXDISPLAY_HD44780", "CodeBleu_score": 60.726036589564224}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tconst struct auxdisplay_itron_data *data = dev->data;\n\n\tif (config->busy_gpio_port == NULL) {\n\t\tLOG_ERR(\"busy GPIO port is not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 61.545748154795696}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config * const config = dev->config;\n\tint ret;\n\tint pin_status;\n\n\tif (!config->busy_gpio) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(config->busy_gpio, config->busy_pin, &pin_status);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn pin_status;\n}", "CodeBleu_score": 59.33209704158088}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config * const config = dev->config;\n\tconst struct auxdisplay_itron_data * const data = dev->data;\n\tint ret;\n\n\tif (config->busy_gpio == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(config->busy_gpio, config->busy_pin);\n\n\treturn ret;\n}", "CodeBleu_score": 63.10386966128887}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t command_buffer[2];\n\tint err;\n\n\tcommand_buffer[0] = config->special_command_prefix;\n\tcommand_buffer[1] = command;\n\n\terr = i2c_write(config->i2c, command_buffer, sizeof(command_buffer), config->i2c_address);\n\n\tif (err) {\n\t\tLOG_ERR(\"I2C write failed (err %d)\", err);\n\t\treturn err;\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay));\n\n\treturn 0;\n}", "CodeBleu_score": 62.0191071201409}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\n\tuint8_t buf[2];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write(data->i2c, buf, sizeof(buf), config->i2c_address);\n}", "CodeBleu_score": 61.33361060741296}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *cfg = dev->config;\n\n\tuint8_t buf[2];\n\n\tbuf[0] = cfg->special_command_prefix;\n\n\tbuf[1] = command;\n\n\treturn i2c_write(cfg->i2c_dev, &cfg->i2c_addr, buf, sizeof(buf),\n\t\t\t cfg->i2c_write_delay);\n}", "CodeBleu_score": 56.82621068144942}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tuint8_t *bbram_mem = (uint8_t *)config->bbram_mem;\n\tuint8_t *bbram_mem_end = (uint8_t *)config->bbram_mem + config->bbram_size;\n\tint ret = 0;\n\n\tif (offset + size > config->bbram_size) {\n\t\tLOG_ERR(\"Invalid read size: %d\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\tLOG_ERR(\"Invalid data pointer\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->bbram_size) {\n\t\tLOG_ERR(\"Read exceeds BBRAM size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_mem + offset + size > bbram_mem_end) {\n\t\tLOG_ERR(\"Read exceeds BBRAM size\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, bbram_mem + offset, size);\n\n\treturn ret;\n}", "CodeBleu_score": 55.55454070272494}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tuint8_t *memory = config->memory;\n\tsize_t mem_size = config->size;\n\n\tif (offset + size > mem_size) {\n\t\tLOG_ERR(\"Invalid read: offset 0x%lx, size 0x%lx\", offset, size);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, memory + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 62.647528643763884}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tuint8_t *mem = config->mem;\n\tsize_t mem_size = config->size;\n\tint err = 0;\n\n\tif (offset > mem_size) {\n\t\tLOG_ERR(\"Invalid offset\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((offset + size) > mem_size) {\n\t\tLOG_ERR(\"Invalid size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\tLOG_ERR(\"Invalid data\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, mem + offset, size);\n\n\treturn err;\n}", "CodeBleu_score": 56.595069948925115}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_dev_cfg *cfg = dev->config;\n\tstruct bbram_emul_dev_data *data_dev = dev->data;\n\tsize_t data_size = cfg->size;\n\tint ret_val = 0;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_dev->status == BBRAM_EMUL_STATUS_INVALID) {\n\t\treturn -EIO;\n\t}\n\n\tif (data_dev->status == BBRAM_EMUL_STATUS_WRITABLE) {\n\t\tmemcpy(&data_dev->bbram_data[offset], data, size);\n\t} else {\n\t\tret_val = -EPERM;\n\t}\n\n\treturn ret_val;\n}", "CodeBleu_score": 47.54180808216952}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_dev_cfg *cfg = dev->config;\n\tuint8_t *ram = cfg->ram;\n\tuint8_t *shadow_ram = cfg->shadow_ram;\n\tsize_t bbram_size = cfg->bbram_size;\n\n\tif (size == 0) {\n\t\tLOG_ERR(\"Invalid write size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((offset + size) > bbram_size) {\n\t\tLOG_ERR(\"Write exceeds BBRAM size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->invalid_state) {\n\t\tLOG_ERR(\"BBRAM is in invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(ram + offset, data, size);\n\tmemcpy(shadow_ram + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 55.3667441485317}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_dev_config *cfg = dev->config;\n\tuint8_t *mem_ptr = cfg->mem_ptr;\n\tsize_t mem_size = cfg->mem_size;\n\n\tif (offset >= mem_size) {\n\t\tLOG_ERR(\"Offset 0x%lx is out of bounds for device %s\", offset,\n\t\t\tdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((offset + size) > mem_size) {\n\t\tLOG_ERR(\"Write size 0x%lx is out of bounds for device %s\", size,\n\t\t\tdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->state == BBRAM_EMUL_STATE_INVALID) {\n\t\tLOG_ERR(\"BBRAM device %s is in an invalid state\", dev->name);\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(mem_ptr + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 54.18242203797319}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc == 1) {\n\t\tshell_fprintf(sh, SHELL_ERROR,\n\t\t\t      \"Error: missing device name argument\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_fprintf(sh, SHELL_ERROR,\n\t\t\t      \"Error: device '%s' not found.\n\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.45784750632842}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\tconst char *dev_name = NULL;\n\n\tif (argc == 1) {\n\t\tdev_name = DT_LABEL(DT_NODELABEL(bbram0));\n\t} else if (argc == 2) {\n\t\tdev_name = argv[1];\n\t} else {\n\t\tshell_error(sh, \"Invalid number of arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(dev_name);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Cannot get BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 67.73029579656584}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_fprintf(sh, SHELL_ERROR,\n\t\t\t      \"Error: No BBRAM device specified.\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_fprintf(sh, SHELL_ERROR,\n\t\t\t      \"Error: Could not get BBRAM device '%s'\n\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 70.49047736145158}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tuint8_t *buf = dev->driver_data;\n\tint err;\n\tint nbytes;\n\n\tnbytes = dev->driver_api->read(dev, buf + H4_HDR_SIZE, H4_HDR_SIZE);\n\tif (nbytes < 0) {\n\t\tLOG_ERR(\"Unable to read H4 header (err %d)\", nbytes);\n\t} else {\n\t\terr = hci_h4_hdr_parse(buf, nbytes);\n\t\tif (err) {\n\t\t\tLOG_ERR(\"Invalid H4 header (err %d)\", err);\n\t\t}\n\t}\n}", "CodeBleu_score": 33.21654675080916}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tsize_t bytes_read;\n\tint err;\n\tuint8_t *hdr_buf = dev->driver_data;\n\n\tbytes_read = dev->driver_api->fifo_read(dev, hdr_buf, 1);\n\tif (bytes_read != 1) {\n\t\tBT_ERR(\"Failed to read H4 header (err %d)\", err);\n\t\treturn;\n\t}\n\n\tdev->rx_remaining = hdr_buf[0];\n\tBT_DBG(\"H4 (%s) read %u bytes, %u remaining\", dev->name, bytes_read,\n\t       dev->rx_remaining);\n\n\tif (dev->rx_remaining > sizeof(dev->rx_buf)) {\n\t\tBT_ERR(\"Too long H4 message (%u)\", dev->rx_remaining);\n\t\treturn;\n\t}\n\n\terr = dev->driver_api->fifo_read(dev, dev->rx_buf, dev->rx_remaining);\n\tif (err != dev->rx_remaining) {\n\t\tBT_ERR(\"Failed to read H4 payload (err %d)\", err);\n\t\treturn;\n\t}\n}", "CodeBleu_score": 46.65597722886585}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tu8_t hdr_len;\n\tu8_t hdr_type;\n\tu8_t hdr_rem_len;\n\tu8_t hdr_bytes_read;\n\tu8_t *hdr_buf;\n\tu8_t *hdr_ptr;\n\tu8_t *hdr_end;\n\tu8_t *hdr_rem_len_ptr;\n\tu8_t *hdr_type_ptr;\n\tu8_t *hdr_len_ptr;\n\tu8_t *hdr_bytes_read_ptr;\n\tu8_t *hdr_bytes_read_end;\n\tu8_t *hdr_bytes_read_end_ptr;\n\tu8_t *hdr_bytes_read_end_end;\n\tu8_t *hdr_bytes_read_end_end_ptr;\n\tu8_t *hdr_bytes_read_end_end_end;\n\tu8_t *hdr_bytes_read_end_end_end_ptr;\n\tu8_t *hdr_bytes_read_end_end_end_end;\n\tu8_t *hdr_bytes_read_end_end_end_end_ptr;\n\tu8_t *hdr_bytes_read_end_end_end_end_end;\n\tu8_t *hdr_bytes_read_end_end_end_end_end_ptr;\n\tu8_t *hdr_bytes_read_end_end_end_end_end_end;\n\tu8_t *hdr_bytes_read_end_end_end_end_end_end_ptr;\n\tu8_t *hdr_bytes_read_end_end_end_end_end_end_end;\n\tu8_t *hdr_bytes_read_end_end_end_end_end_end_end_ptr;\n\tu8_t *hdr_bytes_read_end_end_end_end_end_end_end_end;\n\tu8_t *hdr_bytes_read_end_end_end_end_end_end_end_end_ptr;\n\tu8_t *hdr_bytes_read", "CodeBleu_score": 7.036922003986329}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t discard_len = 0;\n\tuint8_t discard_buf[33];\n\n\twhile (discard_len < len) {\n\t\tconst size_t discard_buf_len = min(len - discard_len, sizeof(discard_buf));\n\t\tconst int discard_ret = uart_fifo_read(uart, discard_buf, discard_buf_len);\n\n\t\tif (discard_ret < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART device: %d\", discard_ret);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdiscard_len += discard_ret;\n\t}\n\n\treturn discard_len;\n}", "CodeBleu_score": 45.94294275180043}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t ret;\n\tsize_t total = 0;\n\n\twhile (len > 0) {\n\t\tret = uart_fifo_read(uart, buf, min(len, sizeof(buf)));\n\t\tif (ret == 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART device %s\", uart->name);\n\t\t\treturn total;\n\t\t}\n\n\t\tlen -= ret;\n\t\ttotal += ret;\n\t}\n\n\treturn total;\n}", "CodeBleu_score": 44.37164872783153}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read;\n\tsize_t bytes_discarded;\n\n\tbytes_read = 0;\n\tbytes_discarded = 0;\n\n\twhile (bytes_read < len) {\n\t\tsize_t bytes_to_read;\n\t\tsize_t bytes_to_discard;\n\n\t\tbytes_to_read = MIN(len - bytes_read, sizeof(buf));\n\t\tbytes_to_discard = MIN(len - bytes_read, sizeof(buf));\n\n\t\tif (uart_fifo_read(uart, buf, bytes_to_read) != 0) {\n\t\t\tLOG_ERR(\"Failed to read %d bytes from UART device %s\", bytes_to_read, uart->name);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbytes_read += bytes_to_read;\n\t\tbytes_discarded += bytes_to_discard;\n\t}\n\n\treturn bytes_discarded;\n}", "CodeBleu_score": 44.51493566218206}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t hop = 0;\n\tstruct zbus_observer *obs;\n\n\t/*\n\t * We need to lock the channel data while iterating through the observers.\n\t */\n\tk_mutex_lock(&chan->lock, K_FOREVER);\n\n\tSYS_SLIST_FOR_EACH_CONTAINER(&chan->observers, obs, node) {\n\t\t/*\n\t\t * Check if the observer is enabled.\n\t\t */\n\t\tif (obs->enabled) {\n\t\t\t/*\n\t\t\t * Check if the observer's priority is higher than the current highest.\n\t\t\t */\n\t\t\tif (obs->priority < hop) {\n\t\t\t\thop = obs->priority;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Set the channel's highest observer priority to the determined value.\n\t */\n\tchan->hop = hop;\n\n\t/*\n\t * Unlock the channel data.\n\t */\n\tk_mutex_unlock(&chan->lock);\n}", "CodeBleu_score": 15.245386097381704}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint32_t hop = -1;\n\tstruct zbus_observer *obs;\n\n\tsys_mutex_lock(&chan->mutex, K_FOREVER);\n\tSYS_SLIST_FOR_EACH_CONTAINER(&chan->observers, obs, struct zbus_observer, node) {\n\t\tif (obs->priority > hop && obs->enabled) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\tchan->hop = hop;\n\tsys_mutex_unlock(&chan->mutex);\n}", "CodeBleu_score": 16.633890181351283}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tk_mutex_lock(&chan->lock, K_FOREVER);\n\n\tint hop = ZBUS_PRIORITY_LOWEST;\n\n\tstruct zbus_observer *obs, *tmp;\n\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan->observers, obs, tmp, node) {\n\t\tif (obs->enabled && (obs->priority < hop)) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\n\tchan->hop = hop;\n\n\tk_mutex_unlock(&chan->lock);\n}", "CodeBleu_score": 15.549843488610149}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *chan_obs;\n\tsys_slist_for_each_entry(&obs->channel_observations, chan_obs, struct zbus_channel_observation, node) {\n\t\tif (chan_obs->observer == obs) {\n\t\t\tupdate_channel_hop(chan_obs);\n\t\t}\n\t}\n}", "CodeBleu_score": 21.116484455983418}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel *channel;\n\tSYS_SLIST_FOR_EACH_CONTAINER(&obs->channels, channel, struct zbus_channel, node) {\n\t\tif (channel->observer == obs) {\n\t\t\tupdate_channel_hop(channel);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.744673004665593}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tconst struct zbus_channel_observer *chan_obs = NULL;\n\n\tSYS_SLIST_FOR_EACH_CONTAINER(&obs->channel_observers, chan_obs, struct zbus_channel_observer, node) {\n\t\tupdate_channel_hop(chan_obs->channel, chan_obs->observer);\n\t}\n}", "CodeBleu_score": 19.065737981840343}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tint ret = 0;\n\tunsigned int key;\n\tstruct zbus_observer *o;\n\tunsigned int prio;\n\n\tif (IS_ENABLED(CONFIG_ASSERT)) {\n\t\t__ASSERT(k_is_in_isr() == false, \"Cannot attach to thread in ISR\");\n\t\t__ASSERT(obs != NULL, \"Cannot attach to null observer\");\n\t}\n\n\tkey = <KEY>\n\tk_spinlock_key_init(&key);\n\to = (struct zbus_observer *)obs;\n\tprio = K_THREAD_PRIO_COOP(o->thread_id);\n\tk_spin_lock(&o->lock, key);\n\to->priority = prio;\n\tfor (int i = 0; i < CONFIG_ZBUS_OBSERVER_MAX_CHANNELS; i++) {\n\t\tif (o->channels[i] != NULL) {\n\t\t\tret = zbus_chan_set_priority(o->channels[i], prio);\n\t\t\tif (ret != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tk_spin_unlock(&o->lock, key);\n\treturn ret;\n}", "CodeBleu_score": 45.80157998716133}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tint rc = 0;\n\n\t__ASSERT_NO_MSG(k_is_in_isr() == false);\n\n\t__ASSERT_NO_MSG(obs != NULL);\n\n\tif (obs->zbus_obs_thread_id == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->zbus_obs_lock);\n\n\tobs->zbus_obs_priority = K_THREAD_PRIO_COOP(0);\n\n\trc = zbus_obs_update_channels(obs);\n\n\tk_spin_unlock(&obs->zbus_obs_lock, key);\n\n\treturn rc;\n}", "CodeBleu_score": 42.79872625831468}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tint ret;\n\tunsigned int key;\n\tstruct zbus_observer *obs_tmp;\n\tunsigned int min_prio;\n\n\tif (z_is_in_isr()) {\n\t\treturn -EPERM;\n\t}\n\n\tif (obs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tkey = <KEY>\n\tmin_prio = UINT_MAX;\n\tfor (obs_tmp = __zbus_observers_start; obs_tmp < __zbus_observers_end; obs_tmp++) {\n\t\tif (obs_tmp == obs) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs_tmp->thread == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs_tmp->thread->base.prio < min_prio) {\n\t\t\tmin_prio = obs_tmp->thread->base.prio;\n\t\t}\n\t}\n\n\tobs->thread = z_current_thread();\n\tobs->prio = min_prio;\n\n\tz_spin_lock(&__zbus_observers_lock, key);\n\tfor (obs_tmp = __zbus_observers_start; obs_tmp < __zbus_observers_end; obs_tmp++) {\n\t\tif (obs_tmp == obs) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs_tmp->thread == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs_tmp->thread->base.prio < obs->prio) {\n\t\t\tobs_tmp->prio = obs->prio;\n\t\t}\n\t}\n\n\tret = zbus_chan_update(obs->chan);\n\tz_spin_unlock(&__zbus_observers_lock, key);\n\n\treturn ret;\n}", "CodeBleu_score": 36.75805791903304}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\tstruct zbus_channel *chan_ = (struct zbus_channel *)chan;\n\tk_timeout_t timeout_ = timeout;\n\tstruct k_thread *thread;\n\tint prio;\n\tint prio_adjust;\n\tint prio_orig;\n\tint prio_min;\n\tint prio_max;\n\tint prio_next;\n\tint prio_next_min;\n\tint prio_next_max;\n\tint prio_next_adj;\n\tint prio_next_adj_min;\n\tint prio_next_adj_max;\n\tint prio_next_adj_orig;\n\tint prio_next_adj_orig_min;\n\tint prio_next_adj_orig_max;\n\tint prio_next_adj_orig_next;\n\tint prio_next_adj_orig_next_min;\n\tint prio_next_adj_orig_next_max;\n\tint prio_next_adj_orig_next_adj;\n\tint prio_next_adj_orig_next_adj_min;\n\tint prio_next_adj_orig_next_adj_max;\n\tint prio_next_adj_orig_next_adj_orig;\n\tint prio_next_adj_orig_next_adj_orig_min;\n\tint prio_next_adj_orig_next_adj_orig_max;\n\tint prio_next_adj_orig_next_adj_orig_next;\n\tint prio_next_adj_orig_next_adj_orig_next_min;\n\tint prio_next_adj_orig_next_adj_orig_next_max;\n\tint prio_next_adj_orig_next_adj_orig_next_adj;\n\tint prio_next_adj_orig_next_adj_orig_next_adj_min;\n\tint prio_next_adj_orig_next_adj_orig_next_adj_max;\n\tint prio_next_adj_orig_next_adj_orig_next_adj_orig;\n\tint prio_next_adj_orig_next", "CodeBleu_score": 7.558271154576287}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err = 0;\n\tstruct zbus_channel_ctx *ctx = NULL;\n\tk_timeout_t end_time;\n\tint prio;\n\tint ret;\n\n\t__ASSERT_NO_MSG(chan != NULL);\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = k_timeout_us_to_ticks(k_us_to_ticks_ceil32(k_timeout_to_us(timeout)));\n\t}\n\n\tend_time = k_uptime_get() + timeout;\n\n\tprio = k_thread_priority_get(k_current_get());\n\tctx = zbus_chan_lock(chan);\n\tif (ctx == NULL) {\n\t\treturn -EBUSY;\n\t}\n\n\tctx->prio = prio;\n\tctx->end_time = end_time;\n\tret = zbus_chan_notify_locked(chan, ctx);\n\tzbus_chan_unlock(chan, ctx);\n\treturn ret;\n}", "CodeBleu_score": 46.326500441101835}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint ret = 0;\n\tk_timeout_t end_time;\n\tstruct zbus_chan_ctx *ctx;\n\n\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (chan->state == ZBUS_CHAN_STATE_ACTIVE) {\n\t\tend_time = k_uptime_get() + timeout;\n\t} else {\n\t\tend_time = k_uptime_get() + K_MSEC(100);\n\t}\n\n\tif (k_is_in_isr()) {\n\t\tend_time = end_time + K_MSEC(100);\n\t}\n\n\tctx = chan->ctx;\n\tctx->priority = k_thread_priority_get(k_current_get());\n\n\tzbus_chan_lock(chan);\n\n\twhile (chan->state == ZBUS_CHAN_STATE_ACTIVE && k_uptime_get() < end_time && ret == 0) {\n\t\tif (chan->notify) {\n\t\t\tret = chan->notify(chan);\n\t\t}\n\t}\n\n\tzbus_chan_unlock(chan);\n\n\treturn ret;\n}", "CodeBleu_score": 39.63286745882464}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (Int > ETH_INT_ALL) {\n\t\treturn;\n\t}\n\n\tif (enable) {\n\t\tif (Int < ETH_INT_ABNORMAL) {\n\t\t\tETH->INTEN |= (1 << Int);\n\t\t} else {\n\t\t\tETH->INTEN |= (1 << (Int - 32));\n\t\t}\n\t} else {\n\t\tif (Int < ETH_INT_ABNORMAL) {\n\t\t\tETH->INTEN &= ~(1 << Int);\n\t\t} else {\n\t\t\tETH->INTEN &= ~(1 << (Int - 32));\n\t\t}\n\t}\n}", "CodeBleu_score": 29.49760336557462}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif ((Int == ETH_INT_RX) || (Int == ETH_INT_TX) || (Int == ETH_INT_ERR)) {\n\t\tif (enable) {\n\t\t\tif (Int == ETH_INT_RX) {\n\t\t\t\tETH->INTEN |= ETH_INTEN_RXIE;\n\t\t\t} else if (Int == ETH_INT_TX) {\n\t\t\t\tETH->INTEN |= ETH_INTEN_TXIE;\n\t\t\t} else {\n\t\t\t\tETH->INTEN |= ETH_INTEN_ERIE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (Int == ETH_INT_RX) {\n\t\t\t\tETH->INTEN &= ~ETH_INTEN_RXIE;\n\t\t\t} else if (Int == ETH_INT_TX) {\n\t\t\t\tETH->INTEN &= ~ETH_INTEN_TXIE;\n\t\t\t} else {\n\t\t\t\tETH->INTEN &= ~ETH_INTEN_ERIE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// TODO: Error handling\n\t\twhile(1);\n\t}\n}", "CodeBleu_score": 41.36997052985754}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif ((Int & 0xFFFFFFFE) != 0) {\n\t\treturn;\n\t}\n\n\tif (enable) {\n\t\tif (Int == ETH_INT_RX) {\n\t\t\tETH->INT_EN |= ETH_INT_RX;\n\t\t} else if (Int == ETH_INT_TX) {\n\t\t\tETH->INT_EN |= ETH_INT_TX;\n\t\t} else if (Int == ETH_INT_ERROR) {\n\t\t\tETH->INT_EN |= ETH_INT_ERROR;\n\t\t}\n\t} else {\n\t\tif (Int == ETH_INT_RX) {\n\t\t\tETH->INT_EN &= ~ETH_INT_RX;\n\t\t} else if (Int == ETH_INT_TX) {\n\t\t\tETH->INT_EN &= ~ETH_INT_TX;\n\t\t} else if (Int == ETH_INT_ERROR) {\n\t\t\tETH->INT_EN &= ~ETH_INT_ERROR;\n\t\t}\n\t}\n}", "CodeBleu_score": 41.200534887733866}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *txDesc;\n\tuint32_t descAddr;\n\n\tdescAddr = ETH_TX_DESC_ADDR;\n\twhile (1) {\n\t\ttxDesc = (ETH_TX_DESC *) descAddr;\n\t\tif ((txDesc->status & ETH_TX_DESC_OWN) == 0) {\n\t\t\treturn txDesc;\n\t\t}\n\t\tdescAddr += sizeof(ETH_TX_DESC);\n\t\tif (descAddr == (ETH_TX_DESC_ADDR + (ETH_TX_DESC_NUM * sizeof(ETH_TX_DESC)))) {\n\t\t\tdescAddr = ETH_TX_DESC_ADDR;\n\t\t}\n\t}\n}", "CodeBleu_score": 45.74630822941872}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\t/* Get the current transmit descriptor address. */\n\tpTxDesc = (ETH_TX_DESC *)ETH_TX_DESC_ADDR;\n\n\t/* Loop through the list of transmit descriptors, checking each one. */\n\tfor (i = 0; i < ETH_TX_DESC_COUNT; i++) {\n\t\t/* Check if the descriptor is owned by the device. */\n\t\tif (pTxDesc->dwStatus & ETH_TX_DESC_OWN) {\n\t\t\t/* The descriptor is owned by the device. */\n\t\t\tpTxDesc = (ETH_TX_DESC *)((uint32_t)pTxDesc + ETH_TX_DESC_SIZE);\n\t\t\tpTxDesc = (ETH_TX_DESC *)(((uint32_t)pTxDesc - ETH_TX_DESC_SIZE) & ETH_TX_DESC_ALIGN);\n\n\t\t\t/* Check if we've looped back to the starting address. */\n\t\t\tif (pTxDesc == (ETH_TX_DESC *)ETH_TX_DESC_ADDR) {\n\t\t\t\t/* We've looped back to the starting address. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\t/* The descriptor is owned by the CPU. */\n\t\t\treturn pTxDesc;\n\t\t}\n\t}\n\n\t/* No free descriptor was found. */\n\treturn 0;\n}", "CodeBleu_score": 47.76810428465632}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tuint32_t desc_addr;\n\tETH_TX_DESC *desc;\n\n\tdesc_addr = ETH->DMATXDESCADDR;\n\tdesc = (ETH_TX_DESC *)desc_addr;\n\n\twhile (desc_addr != ETH->DMATXDESCADDR) {\n\t\tif ((desc->CTRL & ETH_DMATXDESC_OWN) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tdesc_addr += sizeof(ETH_TX_DESC);\n\t\tdesc = (ETH_TX_DESC *)desc_addr;\n\t}\n\n\tif (desc_addr == ETH->DMATXDESCADDR) {\n\t\tdesc = 0;\n\t}\n\n\treturn desc;\n}", "CodeBleu_score": 46.720944903739515}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\tcy_stc_csd_config_t csdConfig;\n\tcy_stc_csd_context_t csdContext;\n\n\tif (device == RT_NULL) {\n\t\tresult = -RT_ERROR;\n\t\trt_kprintf(\"The device is NULL.", "CodeBleu_score": 30.278831916388594}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\tcy_stc_csd_config_t config;\n\tcy_stc_csd_context_t context;\n\tcy_stc_csd_idac_config_t idacConfig;\n\tcy_stc_csd_idac_context_t idacContext;\n\tcy_stc_sysint_t interrupt;\n\tcy_en_csd_status_t status;\n\n\tif (device == RT_NULL) {\n\t\tresult = -RT_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* Configure the CSD driver context structure. */\n\tcontext.ptr = device->parent.parent.parent.user_data;\n\tcontext.idx = device->channel;\n\n\t/* Configure the CSD driver IDAC context structure. */\n\tidacContext.ptr = device->parent.parent.parent.user_data;\n\tidacContext.idx = device->channel;\n\n\t/* Configure the CSD driver interrupt structure. */\n\tinterrupt.intrSrc = (IRQn_Type)device->parent.parent.parent.info->intr;\n\tinterrupt.intrPriority = device->parent.parent.parent.config->intrPriority;\n\tinterrupt.enableInt = true;\n\n\t/* Configure the CSD driver configuration structure. */\n\tconfig.context = &context;\n\tconfig.adcClockDiv = CY_CSD_ADC_CLOCK_DIV_BY_1;\n\tconfig.enableCsd = true;\n\tconfig.hwConfig = &device->parent.parent.parent.config->csd;\n\tconfig.interrupt = &interrupt;\n\tconfig.skipStandby = false;\n\tconfig.skipStandbyMode = CY_SYSINT_WAKEUP;\n\n\t/* Configure the CSD driver IDAC configuration structure. */\n\tidacConfig.context = &idacContext;\n\tidacConfig.enableIdac = true;\n\tidacConfig.idacGain = CY_CSD_IDAC_GAIN_1X;\n\tidacConfig.idacValue = *value;\n\tidacConfig.idacRef = CY_CSD_IDAC_REF_1_2V;\n\n\t/* Initialize the CSD driver. */\n\tstatus = Cy_CSD_Init(&config", "CodeBleu_score": 39.43525156678177}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result;\n\tcy_en_csd_dac_channel_t dacChannel;\n\tcy_stc_csd_config_t config;\n\tcy_stc_csd_context_t context;\n\tcy_en_csd_status_t status;\n\tcy_en_csd_dac_ref_sel_t refSel;\n\tcy_en_csd_dac_output_t output;\n\tcy_en_csd_dac_output_mode_t outputMode;\n\tcy_en_csd_dac_output_format_t outputFormat;\n\tcy_stc_csd_dac_config_t dacConfig;\n\tcy_stc_csd_dac_context_t dacContext;\n\tcy_stc_csd_dac_ref_config_t dacRefConfig;\n\tcy_stc_csd_dac_ref_context_t dacRefContext;\n\tcy_stc_csd_dac_output_config_t dacOutputConfig;\n\tcy_stc_csd_dac_output_context_t dacOutputContext;\n\tcy_stc_csd_idac_config_t idacConfig;\n\tcy_stc_csd_idac_context_t idacContext;\n\n\tresult = RT_EOK;\n\n\tif (device == NULL) {\n\t\tresult = -RT_ERROR;\n\t\tCY_ASSERT(0);\n\t\tCY_LOG_ERROR(\"The device parameter is NULL\", result);\n\t\treturn result;\n\t}\n\n\tdacChannel = (cy_en_csd_dac_channel_t)channel;\n\n\t/* Get the CSD configuration structure */\n\t(void)Cy_CSD_GetConfig(&config);\n\n\t/* Get the CSD context structure */\n\t(void)Cy_CSD_GetContext(&context);\n\n\t/* Enable the CSD block */\n\t(void)Cy_CSD_Enable();\n\n\t/* Configure the CSD block to operate in single-ended mode */\n\tconfig.ioMode = CY_CSD_SINGLE_ENDED;\n\n\t/* Configure the CSD block to operate in single-frequency mode */\n\tconfig.sampleMode = CY_CSD_SINGLE_FREQUENCY;\n\n\t/* Configure the CSD block to operate in single-reference", "CodeBleu_score": 39.35882522598189}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t *src;\n\trt_uint32_t *dst;\n\trt_uint32_t *end;\n\trt_uint32_t *start;\n\trt_uint32_t *end_of_flash;\n\trt_uint32_t *start_of_flash;\n\trt_uint32_t *end_of_32k_block;\n\trt_uint32_t *start_of_32k_block;\n\trt_uint32_t *end_of_32k_block_in_flash;\n\trt_uint32_t *start_of_32k_block_in_flash;\n\trt_uint32_t *end_of_32k_block_in_ram;\n\trt_uint32_t *start_of_32k_block_in_ram;\n\trt_uint32_t *end_of_32k_block_in_ram_plus_one;\n\trt_uint32_t *start_of_32k_block_in_ram_plus_one;\n\trt_uint32_t *end_of_32k_block_in_flash_plus_one;\n\trt_uint32_t *start_of_32k_block_in_flash_plus_one;\n\trt_uint32_t *end_of_32k_block_in_ram_minus_one;\n\trt_uint32_t *start_of_32k_block_in_ram_minus_one;\n\trt_uint32_t *end_of_32k_block_in_flash_minus_one;\n\trt_uint32_t *start_of_32k_block_in_flash_minus_one;\n\trt_uint32_t *end_of_32k_block_in_ram_plus_two;\n\trt_uint32_t *start_of_32k_block_in_ram_plus_two;\n\trt_uint3", "CodeBleu_score": 7.763695128625262}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t flash_end_addr;\n\n\t/* Check if the read operation would exceed the flash memory's end address */\n\tflash_end_addr = ifx_flash_get_end_addr();\n\tif (addr + size > flash_end_addr) {\n\t\trt_kprintf(\"ERROR: Read operation would exceed the flash memory's end address\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\t/* Read the specified size of data from the flash memory address into the buffer, byte by byte */\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)addr;\n\t\taddr++;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 45.31834046176251}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t end_addr;\n\trt_uint32_t offset;\n\trt_uint32_t page_addr;\n\trt_uint32_t page_size;\n\trt_uint32_t page_offset;\n\trt_uint32_t page_left;\n\trt_uint32_t read_size;\n\trt_uint32_t read_addr;\n\trt_uint32_t flash_addr;\n\trt_uint32_t flash_size;\n\trt_uint32_t flash_offset;\n\trt_uint32_t flash_left;\n\trt_uint32_t read_count;\n\trt_uint32_t *p_buf;\n\trt_uint8_t *p_byte_buf;\n\trt_uint32_t *p_flash_addr;\n\trt_uint32_t *p_flash_size;\n\trt_uint32_t *p_flash_offset;\n\trt_uint32_t *p_flash_left;\n\trt_uint32_t *p_read_count;\n\trt_uint32_t *p_read_size;\n\trt_uint32_t *p_read_addr;\n\trt_uint32_t *p_page_addr;\n\trt_uint32_t *p_page_size;\n\trt_uint32_t *p_page_offset;\n\trt_uint32_t *p_page_left;\n\trt_uint32_t *p_end_addr;\n\trt_uint32_t *p_offset;\n\trt_uint32_t *p_i;\n\trt_uint32_t *p_j;\n\trt_uint32_t *p_k;\n\trt_uint32_t *p_l;\n\trt_uint32_t *p_m;\n\trt_uint32_t *p_n;\n\trt_uint32_t *p_o;\n\t", "CodeBleu_score": 8.86855847377813}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tcyhal_timer_t *timer_obj;\n\trt_uint32_t counter_value;\n\n\ttimer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\n\tcounter_value = cyhal_timer_read(timer_obj);\n\n\treturn counter_value;\n}", "CodeBleu_score": 58.4889668810498}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tcyhal_timer_t *timer_obj;\n\tcyhal_timer_event_t event;\n\trt_uint32_t count;\n\n\ttimer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\n\tif (timer_obj == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\tevent = cyhal_timer_read(timer_obj);\n\n\tif (event == CYHAL_TIMER_RISING_EDGE) {\n\t\tcount = cyhal_timer_read_counter(timer_obj);\n\t} else {\n\t\tcount = cyhal_timer_read_counter(timer_obj);\n\t\tcount = cyhal_timer_get_max_value(timer_obj) - count;\n\t}\n\n\treturn count;\n}", "CodeBleu_score": 54.06132410736316}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tcyhal_timer_t *timer_obj;\n\trt_uint32_t count;\n\ttimer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\tcount = cyhal_timer_read(timer_obj);\n\treturn count;\n}", "CodeBleu_score": 64.1504895028858}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.28188135898199}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.28188135898199}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.28188135898199}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint i;\n\n\t/* Find an empty slot */\n\tfor (fd = startfd, i = 0; i < DFS_FD_SETSIZE; fd++, i++) {\n\t\tif (fd >= DFS_FD_SETSIZE) {\n\t\t\tfd = 0;\n\t\t}\n\n\t\tif (fdt->fd_table[fd] == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\t/* No empty slot was found. Expand the table. */\n\treturn fd_table_expand(fdt, startfd);\n}", "CodeBleu_score": 35.90711991913979}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tfor (fd = startfd; fd < fdt->maxfd; fd++) {\n\t\tif (fdt->fd[fd].fd == -1) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\tfor (fd = 0; fd < startfd; fd++) {\n\t\tif (fdt->fd[fd].fd == -1) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\tif (fd_table_expand(fdt) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 45.76653264016619}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\n\tfor (i = startfd; i < DFS_FD_MAX; i++) {\n\t\tif (fdt->fd[i].fd_type == FD_TYPE_NONE) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tfor (i = 0; i < startfd; i++) {\n\t\tif (fdt->fd[i].fd_type == FD_TYPE_NONE) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 32.687872650880394}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tswitch (error) {\n\tcase RT_EOK:\n\t\treturn \"EOK\";\n\tcase RT_EFAIL:\n\t\treturn \"EFAIL\";\n\tcase RT_EUNIMP:\n\t\treturn \"EUNIMP\";\n\tcase RT_EBUSY:\n\t\treturn \"EBUSY\";\n\tcase RT_ETIMEOUT:\n\t\treturn \"ETIMEOUT\";\n\tcase RT_EFULL:\n\t\treturn \"EFULL\";\n\tcase RT_EINTR:\n\t\treturn \"EINTR\";\n\tcase RT_EWOULDBLOCK:\n\t\treturn \"EWOULDBLOCK\";\n\tcase RT_EINVALID:\n\t\treturn \"EINVALID\";\n\tcase RT_ENOMEM:\n\t\treturn \"ENOMEM\";\n\tcase RT_EEXIST:\n\t\treturn \"EEXIST\";\n\tcase RT_EINVAL:\n\t\treturn \"EINVAL\";\n\tcase RT_EUNKNOW:\n\t\treturn \"EUNKNOW\";\n\tdefault:\n\t\treturn \"EUNKNOW\";\n\t}\n}", "CodeBleu_score": 33.028479074632735}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\trt_size_t i;\n\trt_err_t err;\n\n\terr = -error;\n\n\tfor (i = 0; i < sizeof(rt_error_strings) / sizeof(rt_error_strings[0]); i++) {\n\t\tif (rt_error_strings[i].error == err) {\n\t\t\treturn rt_error_strings[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 57.974088301805615}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tswitch (error) {\n\tcase RT_ERR_OK:\n\t\treturn \"OK\";\n\tcase RT_ERR_UNKNOWN:\n\t\treturn \"EUNKNOW\";\n\tcase RT_ERR_NULL_PTR:\n\t\treturn \"ENULLPTR\";\n\tcase RT_ERR_NO_MEM:\n\t\treturn \"ENOMEM\";\n\tcase RT_ERR_NOT_FOUND:\n\t\treturn \"ENOTFOUND\";\n\tcase RT_ERR_NOT_SUPPORT:\n\t\treturn \"ENOTSUPPORT\";\n\tcase RT_ERR_INPUT:\n\t\treturn \"EINPUT\";\n\tcase RT_ERR_NO_MODULE:\n\t\treturn \"ENOMODULE\";\n\tcase RT_ERR_NO_CMD:\n\t\treturn \"ENOCMD\";\n\tcase RT_ERR_CMD_EXEC:\n\t\treturn \"ECMDEXEC\";\n\tcase RT_ERR_TIMEOUT:\n\t\treturn \"ETIMEOUT\";\n\tcase RT_ERR_NOT_READY:\n\t\treturn \"ENOTREADY\";\n\tcase RT_ERR_BUS_BUSY:\n\t\treturn \"EBUSY\";\n\tcase RT_ERR_BUS_FAIL:\n\t\treturn \"EBUSFAIL\";\n\tcase RT_ERR_OS:\n\t\treturn \"EOS\";\n\tcase RT_ERR_FAILED:\n\t\treturn \"EFAILED\";\n\tcase RT_ERR_IN_USE:\n\t\treturn \"EINUSE\";\n\tcase RT_ERR_ALREADY_OPENED:\n\t\treturn \"EALREADYOPENED\";\n\tcase RT_ERR_NOT_OPENED:\n\t\treturn \"ENOTOPENED\";\n\tcase RT_ERR_NO_DEVICE:\n\t\treturn \"ENODEVICE\";\n\tcase RT_ERR_INVALID_DEVICE:\n\t\treturn \"EINVALIDDEVICE\";\n\tcase RT_ERR_NO_FILE:\n\t\treturn \"ENOFILE\";\n\tcase RT_ERR_INVALID_FILE:\n\t\treturn \"EINVALIDFILE\";\n\tcase RT_ERR_FILE_OPEN:\n\t\treturn \"EFILEOPEN\";\n\tcase RT_ERR_FILE_READ:\n\t\treturn \"EFILEREAD\";\n\tcase RT_ERR_FILE_WRITE:\n\t\treturn \"EFILEWRITE\";\n\tcase RT_ERR_FILE_", "CodeBleu_score": 30.935814840143916}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\trt_thread_idle_hook_t *idle_hook;\n\n\tlevel = rt_hw_interrupt_disable();\n\tidle_hook = &rt_thread_idle_hook;\n\n\twhile (idle_hook->next != RT_NULL) {\n\t\tif (idle_hook->next == RT_NULL) {\n\t\t\tresult = -RT_EFULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tidle_hook = idle_hook->next;\n\t}\n\n\tif (result == RT_EOK) {\n\t\tidle_hook->next = (rt_thread_idle_hook_t *)rt_malloc(sizeof(rt_thread_idle_hook_t));\n\t\tidle_hook->next->next = RT_NULL;\n\t\tidle_hook->next->hook = hook;\n\t}\n\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 34.856821671346275}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (idle_hook_list[0].func == RT_NULL) {\n\t\tidle_hook_list[0].func = hook;\n\t}\n\telse if (idle_hook_list[1].func == RT_NULL) {\n\t\tidle_hook_list[1].func = hook;\n\t}\n\telse if (idle_hook_list[2].func == RT_NULL) {\n\t\tidle_hook_list[2].func = hook;\n\t}\n\telse if (idle_hook_list[3].func == RT_NULL) {\n\t\tidle_hook_list[3].func = hook;\n\t}\n\telse {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 23.305465837836532}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_kprintf(\"rt_thread_idle_sethook\n\");\n\treturn RT_EOK;\n}", "CodeBleu_score": 7.0478867240691025}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_thread_idle_hook_t *p, *q;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* find the hook */\n\tfor (p = &rt_thread_idle_hook_list; p != RT_NULL; p = p->next) {\n\t\tif (p->hook == hook) {\n\t\t\t/* remove the hook */\n\t\t\tq = p->next;\n\t\t\tp->next = RT_NULL;\n\t\t\tp = q;\n\n\t\t\t/* resume scheduler */\n\t\t\trt_exit_critical();\n\n\t\t\t/* enable interrupt */\n\t\t\trt_hw_interrupt_enable(level);\n\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* resume scheduler */\n\trt_exit_critical();\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 42.121972209493364}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\trt_thread_idle_hook_t *hook_ptr;\n\trt_thread_idle_hook_t *hook_prev;\n\n\tif (hook == RT_NULL) {\n\t\treturn RT_EINVAL;\n\t}\n\n\tlevel = rt_hw_interrupt_disable();\n\thook_ptr = &rt_thread_idle_hook_list;\n\thook_prev = RT_NULL;\n\twhile (hook_ptr != RT_NULL) {\n\t\tif (hook_ptr->next == RT_NULL) {\n\t\t\tresult = RT_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tif (hook_ptr->next == hook) {\n\t\t\tif (hook_prev == RT_NULL) {\n\t\t\t\trt_thread_idle_hook_list = hook_ptr->next;\n\t\t\t} else {\n\t\t\t\thook_prev->next = hook_ptr->next;\n\t\t\t}\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t\thook_prev = hook_ptr;\n\t\thook_ptr = hook_ptr->next;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 42.97763465415891}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_kprintf(\"rt_thread_idle_delhook\n\");\n\treturn RT_EOK;\n}", "CodeBleu_score": 7.046567214662022}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_err_t result;\n\trt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check list */\n\tRT_ASSERT(susp_list != RT_NULL);\n\tRT_ASSERT(rt_list_isempty(susp_list) == RT_FALSE);\n\n\t/* resume all threads in list */\n\tlevel = rt_hw_interrupt_disable();\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, suspended_list);\n\t\trt_list_remove(&(thread->suspended_list));\n\t\trt_hw_interrupt_enable(level);\n\n\t\t/* resume thread */\n\t\tresult = rt_thread_resume(thread);\n\t\tif (result != RT_EOK) {\n\t\t\trt_kprintf(\"resume thread %s failed\n\", thread->name);\n\t\t\treturn result;\n\t\t}\n\n\t\t/* set thread error */\n\t\tthread->error = thread_error;\n\n\t\t/* disable interrupt */\n\t\tlevel = rt_hw_interrupt_disable();\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 38.15488519726694}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_err_t result;\n\trt_base_t level;\n\trt_thread_t current_thread = rt_thread_self();\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\tif (current_thread->current_task != RT_NULL) {\n\t\trt_kprintf(\"the current task is not RT_NULL\");\n\t\treturn -RT_ERROR;\n\t}\n\tlevel = rt_hw_interrupt_disable();\n\twhile (rt_list_isempty(susp_list) == 0) {\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, suspended_list);\n\t\trt_list_remove(&thread->suspended_list);\n\t\trt_hw_interrupt_enable(level);\n\t\tresult = rt_thread_resume(thread);\n\t\tlevel = rt_hw_interrupt_disable();\n\t\tif (result != RT_EOK) {\n\t\t\trt_kprintf(\"resume thread %s failed\n\", thread->name);\n\t\t}\n\t}\n\trt_hw_interrupt_enable(level);\n\treturn RT_EOK;\n}", "CodeBleu_score": 36.06308977217678}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_base_t level;\n\trt_err_t ret;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (\"resume all thread on suspension list\"));\n\n\t/* resume all thread on suspension list */\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\t/* get thread from suspension list */\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n\t\t/* resume thread */\n\t\tret = rt_thread_resume(thread, thread_error);\n\t\tif (ret != RT_EOK) {\n\t\t\t/* resume thread failed */\n\t\t\tRT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (\"resume thread %s failed\", thread->name));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 48.351260031793345}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t device, old_device;\n\trt_bool_t is_opened;\n\n\t/* get current console device */\n\told_device = rt_console_get_device();\n\n\t/* find the new device by its name */\n\tdevice = rt_device_find(name);\n\tif (device == RT_NULL) {\n\t\treturn old_device;\n\t}\n\n\t/* check if it is the same as the current device */\n\tif (device == old_device) {\n\t\treturn old_device;\n\t}\n\n\t/* close the current console device if it exists */\n\tif (old_device != RT_NULL) {\n\t\tis_opened = rt_device_open(old_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t\tif (is_opened == RT_EOK) {\n\t\t\trt_device_close(old_device);\n\t\t}\n\t}\n\n\t/* open the new console device with read/write and stream flags */\n\tis_opened = rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\tif (is_opened != RT_EOK) {\n\t\treturn old_device;\n\t}\n\n\t/* set it as the new console device */\n\trt_console_set_device(device);\n\n\treturn old_device;\n}", "CodeBleu_score": 54.73697523256579}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t new_device;\n\trt_device_t old_device;\n\n\told_device = rt_console_get_device();\n\n\tif (name != RT_NULL) {\n\t\tnew_device = rt_device_find(name);\n\n\t\tif (new_device != RT_NULL) {\n\t\t\tif (new_device != old_device) {\n\t\t\t\tif (old_device != RT_NULL) {\n\t\t\t\t\trt_device_close(old_device);\n\t\t\t\t}\n\n\t\t\t\tif (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\t\trt_console_set_device(new_device);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn old_device;\n}", "CodeBleu_score": 65.23171238002428}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t device;\n\trt_device_t old_device;\n\trt_err_t result;\n\n\told_device = rt_console_get_device();\n\tdevice = rt_device_find(name);\n\tif (device == RT_NULL) {\n\t\treturn old_device;\n\t}\n\n\t/* check device type */\n\tif (device->type != RT_Device_Class_Char) {\n\t\treturn old_device;\n\t}\n\n\t/* check device flag */\n\tif ((device->flag & RT_DEVICE_FLAG_RDWR) == 0 ||\n\t\t(device->flag & RT_DEVICE_FLAG_STREAM) == 0) {\n\t\treturn old_device;\n\t}\n\n\t/* close old device */\n\tif (old_device != RT_NULL) {\n\t\trt_device_close(old_device);\n\t}\n\n\t/* open device with read/write and stream flags */\n\tresult = rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\tif (result != RT_EOK) {\n\t\treturn old_device;\n\t}\n\n\t/* set new device as console device */\n\trt_console_set_device(device);\n\n\treturn old_device;\n}", "CodeBleu_score": 54.763038147862964}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_base_t level;\n\trt_object_information_t *information;\n\trt_object_t *object;\n\trt_uint32_t count;\n\n\tcount = 0;\n\n\t/* Get the object information table */\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn count;\n\t}\n\n\t/* Get the object list spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* Traverse the object list */\n\tfor (object = information->object_list; object != RT_NULL; object = object->information->next) {\n\t\tcount++;\n\t}\n\n\t/* Release the object list spinlock */\n\trt_hw_interrupt_enable(level);\n\n\treturn count;\n}", "CodeBleu_score": 41.11651139911486}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_base_t level;\n\trt_object_information_t *information;\n\trt_object_t *object;\n\trt_size_t count = 0;\n\n\t/* get object information */\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/* lock object list */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* iterate through object list */\n\tfor (object = information->object_list; object != RT_NULL; object = object->type->next) {\n\t\tcount++;\n\t}\n\n\t/* release object list */\n\trt_hw_interrupt_enable(level);\n\n\treturn count;\n}", "CodeBleu_score": 38.83108866359466}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_base_t level;\n\trt_object_information_t *information;\n\trt_object_t *object;\n\tint count;\n\n\t/* get object information */\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/* get object list lock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* get object count */\n\tcount = information->object_count;\n\n\t/* release object list lock */\n\trt_hw_interrupt_enable(level);\n\n\treturn count;\n}", "CodeBleu_score": 31.42455143953139}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\trt_object_information_t info;\n\trt_base_t level;\n\trt_object_t *object_list;\n\trt_object_t *object_next;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_DEBUG_NULL_POINTER(object);\n\n\tinfo = object->information;\n\tRT_DEBUG_NULL_POINTER(info);\n\n\t/* get object list */\n\tobject_list = info->object_list;\n\tRT_DEBUG_NULL_POINTER(object_list);\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* lock object */\n\trt_spin_lock(&(info->object_lock));\n\n\t/* detach object */\n\tobject_next = object_list;\n\twhile (*object_next != object) {\n\t\tobject_next = &((*object_next)->information->next);\n\t}\n\t*object_next = object->information->next;\n\n\t/* unlock object */\n\trt_spin_unlock(&(info->object_lock));\n\n\t/* set object type */\n\tobject->type = RT_Object_Class_Unknown;\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 45.92752500157471}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_object_information_t info;\n\trt_base_t level;\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check object */\n\tif (object == RT_NULL) {\n\t\trt_kprintf(\"detach object failed, object is RT_NULL\n\");\n\t\treturn;\n\t}\n\n\t/* get object information */\n\tinfo = (rt_object_information_t)object->information;\n\n\t/* check object information */\n\tif (info == RT_NULL) {\n\t\trt_kprintf(\"detach object failed, object->information is RT_NULL\n\");\n\t\treturn;\n\t}\n\n\t/* lock object */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* detach object */\n\tinfo->type = RT_Object_Class_Unknown;\n\trt_list_remove(&(object->list));\n\n\t/* unlock object */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 44.174749946386065}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_object_information_t information;\n\n\t/* check the object */\n\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* detach the object */\n\tinformation = (rt_object_information_t)object;\n\n\t/* detach the object */\n\tif (information->destructor != RT_NULL) {\n\t\tinformation->destructor(object);\n\t}\n\n\t/* remove the object from the object system */\n\trt_list_remove(&(information->parent.parent.list));\n\n\t/* unlock the object */\n\trt_spin_unlock(&(information->parent.lock));\n\n\t/* set the object type */\n\tinformation->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 37.179015403180586}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_custom_object_t custom_object;\n\trt_err_t result;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check object */\n\tif (obj == RT_NULL) {\n\t\trt_set_errno(RT_EINVAL);\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check object type */\n\tif (rt_object_get_type(obj) != RT_Object_Class_Custom) {\n\t\trt_set_errno(RT_ENOSYS);\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get custom object */\n\tcustom_object = (rt_custom_object_t)obj;\n\n\t/* call custom object's destroy method */\n\tif (custom_object->parent.type->custom_destroy != RT_NULL) {\n\t\tresult = custom_object->parent.type->custom_destroy(custom_object);\n\t} else {\n\t\tresult = RT_EOK;\n\t}\n\n\t/* delete object */\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 41.15249388512334}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\trt_custom_object_t custom_obj;\n\trt_object_information_t info;\n\trt_object_t parent;\n\trt_uint8_t *ptr;\n\trt_size_t size;\n\trt_uint8_t *ptr_tmp;\n\trt_size_t size_tmp;\n\trt_uint8_t *ptr_data;\n\trt_size_t size_data;\n\trt_uint8_t *ptr_parent;\n\trt_size_t size_parent;\n\trt_uint8_t *ptr_parent_tmp;\n\trt_size_t size_parent_tmp;\n\trt_uint8_t *ptr_parent_data;\n\trt_size_t size_parent_data;\n\trt_custom_destroy_t destroy;\n\trt_custom_delete_t delete;\n\trt_custom_get_information_t get_information;\n\trt_custom_get_parent_t get_parent;\n\trt_custom_get_data_t get_data;\n\trt_custom_get_size_t get_size;\n\trt_custom_get_type_t get_type;\n\trt_custom_get_name_t get_name;\n\trt_custom_get_sibling_t get_sibling;\n\trt_custom_get_child_t get_child;\n\trt_custom_get_object_t get_object;\n\trt_custom_get_object_size_t get_object_size;\n\trt_custom_get_object_type_t get_object_type;\n\trt_custom_get_object_name_t get_object_name;\n\trt_custom_get_object_information_t get_object_information;\n\trt_custom_get_object_parent_t get_object_parent;\n\trt_custom_get_object_sibling_t get_object_sibling;\n\trt_custom_get_object_child_t get_object_child;\n\trt_custom_get_object_data_t get_object_data;\n\trt_custom_get_object", "CodeBleu_score": 5.502925703529382}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result;\n\trt_object_information_t info;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tif (obj == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get object information */\n\trt_object_get_information(obj, &info);\n\n\t/* check object type */\n\tif (info.type != RT_Object_Class_Custom) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check object flag */\n\tif (info.flag & RT_OBJECT_FLAG_DESTRUCTOR) {\n\t\t/* call destructor */\n\t\tresult = ((rt_custom_object_destructor_t)info.destructor)(obj);\n\t\tif (result != RT_EOK) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/* delete object */\n\trt_object_delete(obj);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 42.138516169014}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\trt_ubase_t level;\n\n\tthread = rt_thread_self();\n\n\t/* check if the thread is initialized */\n\tif (thread->init_flag == RT_FALSE) {\n\t\trt_kprintf(\"thread:%s is not initialized\n\", thread->name);\n\t\treturn;\n\t}\n\n\t/* set thread state */\n\tthread->stat = RT_THREAD_CLOSE;\n\n\t/* release thread object */\n\trt_object_detach(thread);\n\n\t/* release thread stack */\n\trt_hw_release_stack(thread->stack_addr);\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* add to the defunct thread list */\n\trt_list_insert_before(&(rt_thread_defunct), &(thread->tlist));\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\t/* yield to schedule */\n\trt_schedule();\n}", "CodeBleu_score": 55.29677869699859}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\trt_uint8_t level;\n\n\tthread = rt_thread_self();\n\n\tlevel = rt_hw_interrupt_disable();\n\n\trt_thread_detach(thread);\n\n\t/* add to defunct list */\n\trt_list_insert_before(&rt_thread_defunct, &thread->tlist);\n\n\trt_hw_interrupt_enable(level);\n\n\t/* remove the thread */\n\trt_schedule();\n}", "CodeBleu_score": 34.88615634698934}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* check current thread */\n\tif (thread != RT_NULL) {\n\t\t/* disable interrupt */\n\t\trt_hw_interrupt_disable();\n\n\t\t/* add thread to the defunct thread list */\n\t\trt_thread_detach(thread);\n\n\t\t/* resume thread */\n\t\trt_schedule();\n\t}\n}", "CodeBleu_score": 54.331838136611935}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread;\n\trt_list_t *node;\n\trt_uint32_t tick;\n\n\tthread = (rt_thread_t)parameter;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check parameter */\n\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* check thread status */\n\tif (thread->stat != RT_THREAD_SUSPEND) {\n\t\trt_exit_critical();\n\t\treturn;\n\t}\n\n\t/* set thread error number */\n\tthread->error = -ETIME;\n\n\t/* remove thread from suspend list */\n\trt_list_del(&(thread->tlist));\n\n\t/* get current tick */\n\ttick = rt_tick_get();\n\n\t/* set the timeslice of thread */\n\tif (thread->remaining_tick > 0) {\n\t\tthread->init_tick = thread->remaining_tick;\n\t} else {\n\t\tthread->init_tick = thread->slice_tick;\n\t}\n\n\t/* reset the remaining time of thread */\n\tthread->remaining_tick = thread->init_tick;\n\n\t/* calculate the timeslice */\n\tthread->slice_tick = thread->init_tick - (tick - thread->init_tick);\n\n\t/* reset the timeslice of thread */\n\tif (thread->slice_tick > RT_THREAD_TIME_SLICE) {\n\t\tthread->slice_tick = RT_THREAD_TIME_SLICE;\n\t}\n\n\t/* set thread's timeslice */\n\tthread->remaining_tick = thread->slice_tick;\n\n\t/* reset thread's timeslice */\n\tthread->init_tick = tick;\n\n\t/* insert thread to ready list */\n\trt_list_insert_before(&(rt_thread_self()->tlist), &(thread->tlist));\n\n\t/* resume thread */\n\tthread->stat = RT_THREAD_READY;\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* yield to thread */\n\trt_schedule();\n}", "CodeBleu_score": 32.709427542624844}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread;\n\trt_list_t *node;\n\trt_list_t *n;\n\trt_uint8_t need_schedule;\n\n\tthread = (rt_thread_t)parameter;\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check parameter */\n\tRT_DEBUG_NULL_POINTER(thread);\n\tRT_DEBUG_THREAD_ID(thread);\n\tRT_DEBUG_THREAD_STATUS(thread, RT_THREAD_SUSPEND);\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* check thread status */\n\tif (thread->stat != RT_THREAD_SUSPEND) {\n\t\trt_exit_critical();\n\t\treturn;\n\t}\n\n\t/* set thread error number */\n\tthread->error = RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_for_each_safe(node, n, &rt_thread_suspend_list) {\n\t\tif (rt_list_entry(node, struct rt_thread, suspended_list)->thread_id == thread->thread_id) {\n\t\t\trt_list_remove(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* add to ready list */\n\trt_list_insert_before(&thread->list, &rt_thread_ready_list);\n\n\t/* set thread's stack */\n\trt_hw_stack_init(thread->sp, thread->stack_addr, thread->stack_size, thread->entry, thread->parameter);\n\n\t/* resume thread */\n\tthread->stat = RT_THREAD_READY;\n\n\t/* need schedule */\n\tneed_schedule = rt_thread_resume(thread);\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* thread ready and need schedule */\n\tif (need_schedule == RT_EOK) {\n\t\trt_schedule();\n\t}\n}", "CodeBleu_score": 38.906496071519356}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread;\n\trt_base_t level;\n\n\tthread = (rt_thread_t)parameter;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check thread */\n\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_READY);\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* suspend thread */\n\trt_thread_suspend(thread);\n\n\t/* set thread error number */\n\tthread->error = RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->suspend_thread));\n\n\t/* resume thread */\n\trt_schedule();\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 40.86533125704901}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_kprintf(\"thread detach from mutex\n\");\n}", "CodeBleu_score": 1.61209104801687}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_thread_t owner;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* If the thread is not waiting on a mutex, we're done. */\n\tif (thread->wait_object == RT_NULL) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn;\n\t}\n\n\t/* If the thread is waiting on a mutex, remove it from the mutex's waiting list. */\n\tif (thread->wait_object->owner == thread) {\n\t\trt_list_del(&(thread->wait_node));\n\t\tthread->wait_object->owner = RT_NULL;\n\t}\n\n\t/* If the thread is not the owner of any mutexes, we're done. */\n\tif (thread->mutex_list == RT_NULL) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn;\n\t}\n\n\t/* If the thread is the owner of any mutexes, release them. */\n\twhile (thread->mutex_list != RT_NULL) {\n\t\towner = thread->mutex_list->owner;\n\t\towner->mutex_count--;\n\t\tif (owner->mutex_count == 0) {\n\t\t\towner->wait_object = RT_NULL;\n\t\t\trt_list_init(&(owner->wait_node));\n\t\t}\n\t\tthread->mutex_list = thread->mutex_list->next;\n\t}\n\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 42.9199749470446}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_thread_t owner;\n\trt_thread_t new_owner;\n\trt_thread_t thread_next;\n\trt_thread_t thread_prev;\n\trt_thread_t thread_owner;\n\trt_thread_t thread_object;\n\trt_thread_t thread_object_next;\n\trt_thread_t thread_object_prev;\n\trt_thread_t thread_object_owner;\n\trt_thread_t thread_object_object;\n\trt_thread_t thread_object_object_next;\n\trt_thread_t thread_object_object_prev;\n\trt_thread_t thread_object_object_owner;\n\trt_thread_t thread_object_object_object;\n\trt_thread_t thread_object_object_object_next;\n\trt_thread_t thread_object_object_object_prev;\n\trt_thread_t thread_object_object_object_owner;\n\trt_thread_t thread_object_object_object_object;\n\trt_thread_t thread_object_object_object_object_next;\n\trt_thread_t thread_object_object_object_object_prev;\n\trt_thread_t thread_object_object_object_object_owner;\n\trt_thread_t thread_object_object_object_object_object;\n\trt_thread_t thread_object_object_object_object_object_next;\n\trt_thread_t thread_object_object_object_object_object_prev;\n\trt_thread_t thread_object_object_object_object_object_owner;\n\trt_thread_t thread_object_object_object_object_object_object;\n\trt_thread_t thread_object_object_object_object_object_object_next;\n\trt_thread_t thread_object_object_object_object_object_object_prev;\n\trt_thread_t thread_object_object_object_object_object_object_owner;\n\trt_thread_t thread_object_object_object_object_object_object_object;\n\trt_thread_t thread", "CodeBleu_score": 4.844442284517979}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\trt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_DEBUG_LOG(RT_DEBUG_THREAD, (\"start thread %s\n\", thread->name));\n\n\t/* check thread */\n\tRT_DEBUG_ASSERT(thread != RT_NULL);\n\tRT_DEBUG_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_DEBUG_ASSERT(thread->init_thread_flag == RT_TRUE);\n\tRT_DEBUG_ASSERT(thread->cleanup_thread_flag == RT_TRUE);\n\n\t/* set thread's priority */\n\tlevel = rt_hw_interrupt_disable();\n\trt_system_thread_set_priority(thread->tid, thread->current_priority);\n\trt_hw_interrupt_enable(level);\n\n\t/* reset thread's state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* trigger a scheduler */\n\trt_schedule();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 47.58904473005984}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(thread->type == RT_ThreadType);\n\n\trt_kprintf(\"thread %s startup\n\", thread->name);\n\n\t/* set thread's priority */\n\trt_thread_set_priority(thread, thread->init_priority);\n\n\t/* reset thread's stack */\n\trt_memset(thread->stack_addr, 0, thread->stack_size);\n\n\t/* reset thread's stack top */\n\tthread->sp = thread->stack_addr + thread->stack_size - sizeof(rt_uint32_t);\n\n\t/* set thread's stat as RT_THREAD_READY */\n\tthread->stat = RT_THREAD_READY;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* check if there is a system scheduler */\n\tif (rt_system_scheduler != RT_NULL) {\n\t\t/* if so, give the thread to system scheduler */\n\t\trt_system_scheduler(thread->current_priority);\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 52.542367833265565}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_DEBUG_LOG(RT_DEBUG_THREAD, (\"starting thread %s\", thread->name));\n\n\t/* check thread */\n\tRT_DEBUG_ASSERT(thread != RT_NULL);\n\tRT_DEBUG_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_DEBUG_ASSERT(thread->cleanup != RT_NULL);\n\tRT_DEBUG_ASSERT(thread->init_thread_stack != RT_NULL);\n\tRT_DEBUG_ASSERT(thread->stack_addr != RT_NULL);\n\n\t/* set thread's priority */\n\tthread->current_priority = thread->init_priority;\n\n\t/* set thread's stack */\n\tthread->sp = thread->stack_addr + thread->stack_size;\n\n\t/* set thread's state */\n\tthread->stat = RT_THREAD_READY;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* check if scheduler is available */\n\tif (rt_object_is_systemobject((rt_object_t)rt_thread_self())) {\n\t\trt_schedule();\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 47.784185264459275}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_uint8_t level;\n\trt_list_t *list;\n\trt_list_t *next;\n\trt_timer_t timer;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* Initialize the timeout tick to the maximum value. */\n\t*timeout_tick = RT_TICK_MAX;\n\n\t/* Traverse the timer skip list. */\n\tfor (level = 0; level < RT_TIMER_SKIPLIST_LEVELS; level++) {\n\t\tlist = &timer_list[level];\n\n\t\t/* Traverse the list. */\n\t\trt_list_for_each_entry(timer, list, list) {\n\t\t\t/* If the timer's timeout value is less than the current timeout tick, set the current timeout tick to the timer's timeout value. */\n\t\t\tif (timer->timeout_tick < *timeout_tick) {\n\t\t\t\t*timeout_tick = timer->timeout_tick;\n\t\t\t}\n\t\t}\n\n\t\t/* If the highest level of the timer skip list is not empty, return to the caller. */\n\t\tif (!rt_list_isempty(list)) {\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* The highest level of the timer skip list is empty. */\n\treturn -RT_ETIMEOUT;\n}", "CodeBleu_score": 43.24500883685645}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_list_head = &timer_list[0];\n\trt_list_t *timer_list_head_next;\n\trt_list_t *timer_list_next;\n\trt_timer_t *timer;\n\trt_uint8_t level;\n\n\t/* Check if the highest level of the timer skip list is not empty. */\n\ttimer_list_head_next = timer_list_head->next;\n\tif (timer_list_head_next == timer_list_head) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\t/* Get the first timer entry and set the provided timeout tick to the timer's timeout value. */\n\ttimer_list_next = timer_list_head_next;\n\tfor (level = 0; level < RT_TIMER_SKIPLIST_LEVELS; level++) {\n\t\ttimer = rt_list_entry(timer_list_next, struct rt_timer, list);\n\t\tif (timer->timeout_tick > *timeout_tick) {\n\t\t\t*timeout_tick = timer->timeout_tick;\n\t\t}\n\t\ttimer_list_next = timer_list_next->next;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 41.9690389153464}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_node;\n\trt_list_t *timer_list_head;\n\trt_timer_t timer;\n\trt_uint8_t level;\n\trt_uint8_t highest_level;\n\n\thighest_level = RT_TIMER_SKIPLIST_LEVELS - 1;\n\n\twhile (highest_level > 0) {\n\t\ttimer_list_head = &timer_list[highest_level];\n\t\tif (!rt_list_isempty(timer_list_head)) {\n\t\t\ttimer_node = rt_list_first(timer_list_head);\n\t\t\ttimer = rt_list_entry(timer_node, struct rt_timer, list);\n\t\t\t*timeout_tick = timer->timeout_tick;\n\t\t\treturn RT_EOK;\n\t\t}\n\t\thighest_level--;\n\t}\n\n\treturn -RT_ETIMEOUT;\n}", "CodeBleu_score": 42.206821297090734}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\n}", "CodeBleu_score": 11.501974892288617}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\tRT_ASSERT(timeout != RT_NULL);\n\tRT_ASSERT(time > 0);\n\tRT_ASSERT(flag == RT_TIMER_FLAG_ONE_SHOT || flag == RT_TIMER_FLAG_PERIODIC);\n\n\tstruct rt_timer *timer;\n\ttimer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer);\n\tif (timer == RT_NULL) return RT_NULL;\n\n\trt_timer_init(timer, name, timeout, parameter, time, flag);\n\n\treturn timer;\n}", "CodeBleu_score": 68.71496429780137}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\tRT_DEBUG_NULL_POINTER(timeout);\n\tRT_DEBUG_NULL_POINTER(parameter);\n\n\t/* parameter check */\n\tRT_ASSERT(time > 0);\n\n\t/* allocate memory */\n\trt_timer_t timer;\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL) return RT_NULL;\n\n\t/* initialize timer */\n\trt_timer_init(timer, timeout, parameter, time, flag);\n\n\treturn timer;\n}", "CodeBleu_score": 61.2825076266947}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(recorder, req)\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\ta.sendError(res, http.StatusUnauthorized, \"Not Authorized\")\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 51.97579917595916}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\ta.Router.ServeHTTP(recorder, req)\n\tfor k, v := range recorder.HeaderMap {\n\t\tres.Header().Set(k, v[0])\n\t}\n\tres.WriteHeader(recorder.Code)\n\tres.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 34.2402346270277}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\thandlers := []http.Handler{\n\t\ta.authHandler,\n\t\ta.router,\n\t}\n\tfor _, h := range handlers {\n\t\th.ServeHTTP(recorder, req)\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range recorder.HeaderMap {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tres.WriteHeader(recorder.Code)\n\t\tres.Write(recorder.Body.Bytes())\n\t}\n}", "CodeBleu_score": 50.61721066250935}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := strings.TrimPrefix(req.URL.Path, \"/robeaux/\")\n\tcontentType := \"text/plain\"\n\tcontent, err := a.assets.Asset(path)\n\tif err != nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tif strings.HasSuffix(path, \".js\") {\n\t\tcontentType = \"application/javascript\"\n\t}\n\tif strings.HasSuffix(path, \".css\") {\n\t\tcontentType = \"text/css\"\n\t}\n\tif strings.HasSuffix(path, \".html\") {\n\t\tcontentType = \"text/html\"\n\t}\n\tres.Header().Set(\"Content-Type\", contentType)\n\tres.Write(content)\n}", "CodeBleu_score": 42.764409641490076}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tif strings.HasSuffix(req.URL.Path, \".js\") {\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\t} else if strings.HasSuffix(req.URL.Path, \".css\") {\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\t} else if strings.HasSuffix(req.URL.Path, \".html\") {\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t} else {\n\t\tres.Header().Set(\"Content-Type\", \"text/plain\")\n\t}\n\thttp.ServeFile(res, req, req.URL.Path[1:])\n}", "CodeBleu_score": 26.881547625731233}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\thttp.ServeFile(res, req, a.robeauxPath+req.URL.Path)\n}", "CodeBleu_score": 8.268606562509575}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\tname := strings.Split(req.URL.Path, \"/\")[3]\n\n\t// Find the robot using the master instance\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": fmt.Sprintf(\"No robot found with name %s\", name)})\n\t\treturn\n\t}\n\n\t// Gather the robot's connections and convert them to JSON format\n\tconnections := []string{}\n\tfor _, connection := range robot.Connections() {\n\t\tconnections = append(connections, connection.Name())\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 46.25352209992014}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the name of the robot from the URL\n\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\tname = strings.TrimSuffix(name, \"/connections\")\n\t// Find the robot with the specified name\n\trobot := a.master.Robot(name)\n\t// If a robot was found, gather its connections and convert them to JSON format\n\tif robot != nil {\n\t\tconnections := []string{}\n\t\tfor _, conn := range robot.Connections() {\n\t\t\tconnections = append(connections, conn.Name())\n\t\t}\n\t\t// Write the JSON response containing the connections\n\t\ta.writeResponse(res, http.StatusOK, connections)\n\t} else {\n\t\t// If no robot was found, write a JSON error message indicating that no robot was found with the specified name\n\t\ta.writeResponse(res, http.StatusNotFound, fmt.Sprintf(\"no robot found with name '%s'\", name))\n\t}\n}", "CodeBleu_score": 44.33363885595114}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobotName = strings.TrimSuffix(robotName, \"/connections\")\n\n\t// Find the robot using the master instance\n\trobot := a.master.Robot(robotName)\n\n\t// If the robot was found\n\tif robot != nil {\n\t\t// Gather the connections of the robot\n\t\tconnections := robot.Connections()\n\n\t\t// Convert the connections to JSON format\n\t\tconnectionsJSON, err := json.Marshal(connections)\n\t\tif err != nil {\n\t\t\t// If there was an error converting the connections to JSON format\n\t\t\t// Write a JSON error message indicating that there was an error\n\t\t\ta.writeJSONError(res, http.StatusInternalServerError, \"Error gathering robot connections\")\n\t\t\treturn\n\t\t}\n\n\t\t// Write the JSON response containing the connections\n\t\ta.writeJSON(res, http.StatusOK, connectionsJSON)\n\t\treturn\n\t}\n\n\t// If the robot was not found\n\t// Write a JSON error message indicating that no robot was found with the specified name\n\ta.writeJSONError(res, http.StatusNotFound, fmt.Sprintf(\"No robot found with name '%s'\", robotName))\n}", "CodeBleu_score": 42.339721743263006}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tconst prefix = \"Basic \"\n\t\tif !strings.HasPrefix(auth, prefix) {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(auth[len(prefix):])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username)) == 1 && subtle.ConstantTimeCompare([]byte(pair[1]), []byte(password)) == 1 {\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 52.13337676907781}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\tif authHeader == \"\" {\n\t\t\t// If the \"Authorization\" header is not set, it means the user is not authenticated.\n\t\t\t// Set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response with a 401 status code.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+realm+`\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the \"Authorization\" header into 2 parts: \"Basic\" and the base64-encoded username and password.\n\t\tparts := strings.SplitN(authHeader, \" \", 2)\n\t\tif len(parts) != 2 {\n\t\t\t// If the \"Authorization\" header does not have 2 parts, it means the user is not authenticated.\n\t\t\t// Set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response with a 401 status code.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+realm+`\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the \"Authorization\" header does not start with \"Basic\", it means the user is not authenticated.\n\t\t// Set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response with a 401 status code.\n\t\tif parts[0] != \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+realm+`\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the base64-encoded username and password.\n\t\tdecoded, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err != nil {\n\t\t\t// If the base64-encoded username and password cannot be decoded, it means the user is not authenticated.\n\t\t\t// Set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response with a 401 status code.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm", "CodeBleu_score": 46.787637407882016}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Extract the \"Authorization\" header from the request.\n\t\tauth := r.Header.Get(\"Authorization\")\n\n\t\t// If the \"Authorization\" header is empty, return a \"Not Authorized\" response.\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the \"Authorization\" header is not prefixed with \"Basic \", return a \"Not Authorized\" response.\n\t\tif !strings.HasPrefix(auth, \"Basic \") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the username and password from the \"Authorization\" header.\n\t\tauth = auth[6:]\n\t\tauth, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the username and password.\n\t\tauth = strings.SplitN(string(auth), \":\", 2)\n\t\tif len(auth) != 2 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the username or password is empty, return a \"Not Authorized\" response.\n\t\tif auth[0] == \"\" || auth[1] == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password with the ones given to the function.\n\t\tif subtle.ConstantTimeCompare([]byte(auth[0]), []byte(username)) == 0 || subtle.ConstantTimeCompare([]byte(auth[1]), []byte(password)) == 0 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the comparison fails, return a \"Not Authorized\" response.\n\t\tw", "CodeBleu_score": 44.87079791639242}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept for the scaling transformation\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) int {\n\t\t// Calculate the scaled value\n\t\tscaled := int(slope*input + intercept)\n\n\t\t// Ensure the scaled value is within the target range\n\t\tif scaled < toMin {\n\t\t\tscaled = toMin\n\t\t}\n\t\tif scaled > toMax {\n\t\t\tscaled = toMax\n\t\t}\n\n\t\t// Return the scaled value\n\t\treturn scaled\n\t}\n}", "CodeBleu_score": 56.78464930943268}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) int {\n\t\tvalue := int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\treturn toMin\n\t\t} else if value > toMax {\n\t\t\treturn toMax\n\t\t} else {\n\t\t\treturn value\n\t\t}\n\t}\n}", "CodeBleu_score": 60.561041986308}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\tslope := toRange / fromRange\n\tintercept := toMin - slope * fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 50.34487236687157}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"No connection\")\n\t}\n\n\tif !a.connection.AnalogSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"Analog reading not supported\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 50.34084891108026}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tvar err error\n\ta.mutex.Lock()\n\tif a.connection.IsAnalog() {\n\t\ta.lastRaw, err = a.connection.AnalogRead(a.pin)\n\t\tif err == nil {\n\t\t\ta.lastScaled = a.scale(a.lastRaw)\n\t\t}\n\t} else {\n\t\terr = fmt.Errorf(\"AnalogRead not supported by this connection\")\n\t}\n\ta.mutex.Unlock()\n\treturn a.lastRaw, a.lastScaled, err\n}", "CodeBleu_score": 39.01060189527891}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.AnalogSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"analog reading not supported by connection\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 50.07640120750676}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}", "CodeBleu_score": 40.05919918036268}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}", "CodeBleu_score": 40.05919918036268}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 40.09414721088014}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tg := &GrovePiezoVibrationSensorDriver{\n\t\tname:         gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tpin:          pin,\n\t\tanalogReader: a,\n\t\tthreshold:    1000,\n\t}\n\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase string:\n\t\t\tg.name = o\n\t\tcase int:\n\t\t\tg.threshold = o\n\t\t}\n\t}\n\n\tg.analogReader.AddListener(g)\n\treturn g\n}", "CodeBleu_score": 32.51306265276091}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tvar name string\n\tvar threshold int\n\n\tfor _, o := range opts {\n\t\tswitch o.(type) {\n\t\tcase string:\n\t\t\tname = o.(string)\n\t\tcase int:\n\t\t\tthreshold = o.(int)\n\t\t}\n\t}\n\n\tif name == \"\" {\n\t\tname = fmt.Sprintf(\"GrovePiezoVibrationSensorDriver on pin %s\", pin)\n\t}\n\n\tg := &GrovePiezoVibrationSensorDriver{\n\t\tname:     name,\n\t\tanalog:   a,\n\t\tpin:      pin,\n\t\tthreshold: threshold,\n\t\tgobot:    gobot.NewGobot(),\n\t\tevents:   make(chan interface{}),\n\t\twork:     make(chan *gobot.Event),\n\t\ton:       make(chan interface{}),\n\t\toff:      make(chan interface{}),\n\t}\n\n\tg.gobot.AddEvent(vibrationEvent)\n\tg.gobot.AddEvent(gobot.On, func(data interface{}) {\n\t\tg.on <- data\n\t})\n\tg.gobot.AddEvent(gobot.Off, func(data interface{}) {\n\t\tg.off <- data\n\t})\n\n\tg.analog.AddListener(g)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase data := <-g.on:\n\t\t\t\tg.gobot.Publish(vibrationEvent{data.(int)})\n\t\t\tcase data := <-g.off:\n\t\t\t\tg.gobot.Publish(vibrationEvent{data.(int)})\n\t\t\tcase <-g.gobot.Events():\n\t\t\tcase <-g.work:\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn g\n}", "CodeBleu_score": 31.703089754547793}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tg := &GrovePiezoVibrationSensorDriver{\n\t\tname:         gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tanalogReader: a,\n\t\tpin:          pin,\n\t}\n\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase string:\n\t\t\tg.name = o\n\t\tcase int:\n\t\t\tg.threshold = o\n\t\t}\n\t}\n\n\tg.analogReader.AddListener(g.analogListener)\n\tg.AddEvent(gobot.Event(\"vibration\"))\n\n\treturn g\n}", "CodeBleu_score": 30.230690716660114}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.pin == nil {\n\t\treturn fmt.Errorf(\"Tone: pin not initialized\")\n\t}\n\tif hz < 0 {\n\t\treturn fmt.Errorf(\"Tone: hz must be positive\")\n\t}\n\tif duration < 0 {\n\t\treturn fmt.Errorf(\"Tone: duration must be positive\")\n\t}\n\n\t// Calculate the tone period based on the given frequency and tempo.\n\tperiod := 60.0 / d.bpm * 1000000.0 / hz\n\n\t// Calculate the number of times the tone period will fit into the duration.\n\tnumPeriods := int(duration * 1000000.0 / period)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period.\n\tfor i := 0; i < numPeriods; i++ {\n\t\tif err := d.pin.Write(1); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Microsecond * time.Duration(period))\n\t\tif err := d.pin.Write(0); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Microsecond * time.Duration(period))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.49602400782864}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn fmt.Errorf(\"invalid hz\")\n\t}\n\tif duration <= 0 {\n\t\treturn fmt.Errorf(\"invalid duration\")\n\t}\n\n\tperiod := 1.0 / hz\n\tdelay := period / 2\n\tbeats := int(60.0 / d.bpm * float64(duration))\n\n\tfor i := 0; i < beats; i++ {\n\t\td.pin.High()\n\t\ttime.Sleep(delay)\n\t\td.pin.Low()\n\t\ttime.Sleep(delay)\n\t}\n\treturn nil\n}", "CodeBleu_score": 34.157692473563564}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := 1.0 / hz\n\tdelay := period / 2\n\tcycles := int(duration * float64(d.BeatsPerMinute))\n\n\tfor i := 0; i < cycles; i++ {\n\t\tif err := d.Toggle(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay)\n\t\tif err := d.Toggle(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay)\n\t}\n\treturn nil\n}", "CodeBleu_score": 54.16355917220046}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\n\tif d.sleepPin.Read() != 0 {\n\t\treturn fmt.Errorf(\"sleep pin is not low\")\n\t}\n\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 34.757002694319986}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn fmt.Errorf(\"sleep pin is not configured\")\n\t}\n\tif d.sleepPin.Read() == 0 {\n\t\treturn fmt.Errorf(\"sleep pin is already set\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 37.48773250001811}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\tif d.sleepPin.Read() == 0 {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 38.2727021719703}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor not initialized\")\n\t}\n\tif _, ok := a.pins[id]; ok {\n\t\treturn a.pins[id], nil\n\t}\n\tpin, err := a.initPin(id, gobot.Analog)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 49.863215767105864}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pin not initialized\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\n\tpinPath, ok := a.AnalogPinPaths[id]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"analog pin path not found for id %s\", id)\n\t}\n\n\tpin = &AnalogPin{\n\t\tID:     id,\n\t\tPath:   pinPath,\n\t\tDriver: a.Driver,\n\t}\n\n\terr := pin.Init()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 55.98971212307463}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Analog pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin, err := a.newAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 47.39471302490239}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id, gobot.DigitalWriter)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 66.39855648689677}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.GetDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 64.50419399718643}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.digitalWrite(val)\n}", "CodeBleu_score": 65.41889090255559}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.digitalPins == nil {\n\t\ta.digitalPins = make(map[string]gobot.DigitalPinner)\n\t}\n\n\tif _, ok := a.digitalPins[id]; !ok {\n\t\tif a.connect() != nil {\n\t\t\treturn nil, fmt.Errorf(\"digital pin %s not available\", id)\n\t\t}\n\n\t\tpin, err := a.newDigitalPin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err := a.initDigitalPin(pin, opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.digitalPins[id] = pin\n\t} else {\n\t\tif err := a.applyDigitalPinOptions(a.digitalPins[id], opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn a.digitalPins[id], nil\n}", "CodeBleu_score": 50.67048452514445}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\t// If the adaptor is not connected, return an error\n\tif a.connection == nil {\n\t\treturn nil, fmt.Errorf(\"digital pin %s not available, %s not connected\", id, a.Name())\n\t}\n\n\t// If the pin is already configured, return it\n\tif _, ok := a.pins[id]; ok {\n\t\treturn a.pins[id], nil\n\t}\n\n\t// Translate the ID to obtain chip and line information\n\tchip, line, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new digital pin\n\tpin := gobot.NewDigitalPin(a, chip, line)\n\n\t// Initialize the pin\n\tif err := pin.Start(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Apply the provided options\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\t// Store the pin\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 52.294811882320566}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.digitalPins == nil {\n\t\ta.digitalPins = make(map[string]gobot.DigitalPinner)\n\t}\n\n\t// Check if pin is already configured\n\tif _, ok := a.digitalPins[id]; ok {\n\t\tpin := a.digitalPins[id]\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\t// Check if adaptor is connected\n\tif a.connection == nil {\n\t\treturn nil, fmt.Errorf(\"digital pin %s not configured, adaptor %s is not connected\", id, a.Name())\n\t}\n\n\t// Initialize pin\n\tpin, err := a.connection.DigitalPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Apply options\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\t// Store pin\n\ta.digitalPins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 43.83477311765533}]}
