{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> files;\n\tboost::filesystem::path folder_path(folder);\n\tif (!boost::filesystem::exists(folder_path)) {\n\t\tthrow std::runtime_error(\"Folder \" + folder + \" does not exist\");\n\t}\n\tif (!boost::filesystem::is_directory(folder_path)) {\n\t\tthrow std::runtime_error(\"Path \" + folder + \" is not a folder\");\n\t}\n\tfor (boost::filesystem::directory_iterator it(folder_path); it != boost::filesystem::directory_iterator(); ++it) {\n\t\tif (boost::filesystem::is_regular_file(it->path())) {\n\t\t\tstd::string file = it->path().string();\n\t\t\tif (download) {\n\t\t\t\tif (boost::filesystem::exists(file)) {\n\t\t\t\t\tlog_info(\"File \" + file + \" found in cache\");\n\t\t\t\t} else {\n\t\t\t\t\tlog_info(\"Requesting file \" + file);\n\t\t\t\t\tauto file_hash = GetFileHash(file);\n\t\t\t\t\tauto file_id = GetFileId(file_hash);\n\t\t\t\t\tauto file_path = GetFilePath(file_id);\n\t\t\t\t\tauto file_url = GetFileUrl(file_path);\n\t\t\t\t\tauto file_size = GetFileSize(file_id);\n\t\t\t\t\tauto file_name = GetFileName(file);\n\t\t\t\t\tauto file_content = GetFileContent(file_url);\n\t\t\t\t\tauto file_content_hash = GetFileContentHash(file_content);\n\t\t\t\t\tif (file_content_hash != file_hash) {\n\t\t\t\t\t\tthrow std::runtime_error(\"File \" + file + \" has a different hash\");\n\t\t\t\t\t}\n\t\t\t\t\tif (file_size != file_content.size()) {\n\t\t\t\t\t\tthrow std::runtime_error(\"File \" + file + \" has a different size\");\n\t\t\t\t\t}\n\t\t\t\t\tlog_info(\"Writing file \" + file + \" to cache\");\n\t\t\t\t\tstd::ofstream out(file, std::ios::binary);\n\t\t\t\t\tout.write(file_content.data(), file_content.size());\n\t\t\t\t\tout.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiles.push_back(file);\n\t\t}\n\t}\n\treturn files;\n}", "CodeBleu_score": 39.74121907182806}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> files;\n\tfor (auto &file : _files) {\n\t\tauto path = folder + file.filename;\n\t\tif (download) {\n\t\t\tif (!boost::filesystem::exists(path)) {\n\t\t\t\tauto file_data = _client.ReadBinary(file.hash);\n\t\t\t\tif (file_data.empty()) {\n\t\t\t\t\tlog_error(\"Could not retrieve file {}.\", file.filename);\n\t\t\t\t} else {\n\t\t\t\t\tlog_info(\"Retrieved file {}.\", file.filename);\n\t\t\t\t\tstd::ofstream ofs(path, std::ios::binary);\n\t\t\t\t\tofs.write(file_data.data(), file_data.size());\n\t\t\t\t\tofs.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_info(\"File {} found in cache.\", file.filename);\n\t\t\t}\n\t\t}\n\t\tfiles.push_back(path);\n\t}\n\treturn files;\n}", "CodeBleu_score": 47.37885720684125}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> files;\n\tif (folder.empty()) {\n\t\treturn files;\n\t}\n\tauto list = boost::filesystem::directory_iterator(folder);\n\tfor (auto it = list; it != boost::filesystem::directory_iterator(); ++it) {\n\t\tif (boost::filesystem::is_regular_file(*it)) {\n\t\t\tauto path = it->path().string();\n\t\t\tif (download) {\n\t\t\t\tif (boost::filesystem::exists(path)) {\n\t\t\t\t\tlogging::log(logging::log_level::debug, \"Found file {} in cache.\", path);\n\t\t\t\t} else {\n\t\t\t\t\tlogging::log(logging::log_level::debug, \"Downloading file {}.\", path);\n\t\t\t\t\tauto file_name = boost::filesystem::path(path).filename().string();\n\t\t\t\t\tauto file_hash = boost::filesystem::hash_value(path);\n\t\t\t\t\tauto file_size = boost::filesystem::file_size(path);\n\t\t\t\t\tauto file_data = FileTransfer::Read(file_name, file_hash, file_size);\n\t\t\t\t\tif (!file_data.empty()) {\n\t\t\t\t\t\tlogging::log(logging::log_level::debug, \"File {} downloaded successfully.\", path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiles.push_back(path);\n\t\t}\n\t}\n\treturn files;\n}", "CodeBleu_score": 39.295864261391124}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifdef LIBCARLA_WITH_PYTHON_SUPPORT\n  boost::python::gil_scoped_release release;\n#endif // LIBCARLA_WITH_PYTHON_SUPPORT\n  if (parent == 0u) {\n    return SpawnActor(description, transform, attachment_type, socket_name);\n  }\n  else {\n    if (auto *parent_actor = FindActor(parent)) {\n      if (attachment_type == rpc::AttachmentType::SpringArm) {\n        if (transform.location.z < parent_actor->GetBoundingBox().extent.z) {\n          std::stringstream ss;\n          ss << \"The provided transform is invalid. The translation is only in the 'z' axis, \" << transform.location;\n          throw_exception(ss.str());\n        }\n      }\n      else if (attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        if (transform.location.z < parent_actor->GetBoundingBox().extent.z) {\n          std::stringstream ss;\n          ss << \"The provided transform is invalid. The translation is only in the 'z' axis, \" << transform.location;\n          throw_exception(ss.str());\n        }\n      }\n      return SpawnActor(description, transform, parent, attachment_type, socket_name);\n    }\n    else {\n      std::stringstream ss;\n      ss << \"The provided parent actor id is invalid, \" << parent;\n      throw_exception(ss.str());\n    }\n  }\n}", "CodeBleu_score": 48.64556366011396}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\tif (parent == 0) {\n\t\treturn SpawnActor(description, transform, socket_name);\n\t}\n\tif (attachment_type == rpc::AttachmentType::SpringArm) {\n\t\tif (transform.location.x != 0.0 || transform.location.y != 0.0) {\n\t\t\t_log.warn(\"The translation of the transform is not zero for a SpringArm attachment. The attachment will be spawned with the translation set to zero.\");\n\t\t}\n\t\tif (transform.rotation.pitch != 0.0 || transform.rotation.roll != 0.0) {\n\t\t\t_log.warn(\"The rotation of the transform is not zero for a SpringArm attachment. The attachment will be spawned with the rotation set to zero.\");\n\t\t}\n\t}\n\treturn SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 42.427088071910234}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\tif (parent != 0u) {\n\t\tif (parent == _actor_id) {\n\t\t\tthrow_exception(\"actor parent is self\", \"carla.rpc.WrongParent\");\n\t\t}\n\t\tif (_actors.find(parent) == _actors.end()) {\n\t\t\tthrow_exception(\"actor parent does not exist\", \"carla.rpc.WrongParent\");\n\t\t}\n\t}\n\tif (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n\t\tif (transform.location.z != 0.0) {\n\t\t\t_log.warn(\"invalid transform for attachment type: {} (translation in z-axis is not zero)\".format(static_cast<int>(attachment_type)));\n\t\t}\n\t}\n\treturn SpawnActor(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 47.55704184961585}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n}", "CodeBleu_score": 7.390850490544927}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\ttry {\n\t\t// Subscribe to the G-buffer\n\t\tauto token = _streaming_client->SubscribeToGBuffer(ActorId, GBufferId);\n\t\t// Copy the token data\n\t\tauto token_data = token.GetData();\n\t\t// Subscribe to the streaming client\n\t\t_streaming_client->Subscribe(token_data, callback);\n\t}\n\tcatch (const std::exception &e) {\n\t\tthrow_exception(\"Failed to subscribe to G-buffer\", e);\n\t}\n}", "CodeBleu_score": 44.21727954917607}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\tauto token = _streaming_client->SubscribeToGBuffer(ActorId, GBufferId);\n\t_streaming_client->CopyFrom(token, callback);\n}", "CodeBleu_score": 34.95809241433984}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::unique_lock<std::mutex> lock(this->mutex);\n\tif (this->navigation == nullptr) {\n\t\tthis->navigation = std::make_shared<WalkerNavigation>(this->client);\n\t}\n\treturn this->navigation;\n}", "CodeBleu_score": 18.40190393025729}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (navigation == nullptr) {\n\t\tnavigation = std::make_shared<WalkerNavigation>(GetEpisodeId());\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 28.388855542912665}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tif (_navigation == nullptr) {\n\t\t_navigation = std::make_shared<WalkerNavigation>();\n\t}\n\treturn _navigation;\n}", "CodeBleu_score": 27.921873674057746}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (episode.GetFrameNumber() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (timeout.count() > 0.0) {\n\t\t\tif (episode.GetFrameNumber() >= frame) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (timeout.count() <= 0.0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttimeout -= milliseconds(100);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcarla::traffic_manager::TrafficManager::Get().Tick();\n\treturn true;\n}", "CodeBleu_score": 30.57602987765961}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tusing namespace std::chrono_literals;\n\tusing namespace std::placeholders;\n\n\tauto start = std::chrono::system_clock::now();\n\n\twhile (episode.GetFrameNumber() < frame) {\n\t\tauto now = std::chrono::system_clock::now();\n\t\tif (now - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\n\tcarla::client::detail::Simulator::get()->GetTrafficManager().Tick();\n\n\treturn true;\n}", "CodeBleu_score": 43.86621492775492}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = std::chrono::steady_clock::now();\n\twhile (episode.GetFrame() < frame) {\n\t\tauto now = std::chrono::steady_clock::now();\n\t\tif (now - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tcarla::traffic_manager::TrafficManager::Get().Tick(episode);\n\treturn true;\n}", "CodeBleu_score": 38.77761038330917}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tDEBUG_ASSERT(map_name.size() > 0u);\n\tDEBUG_ASSERT(map_name.find('/') == std::string::npos);\n\tDEBUG_ASSERT(map_name.find('\\\\') == std::string::npos);\n\tDEBUG_ASSERT(map_name.find(':') == std::string::npos);\n\tDEBUG_ASSERT(map_name.find('*') == std::string::npos);\n\tDEBUG_ASSERT(map_name.find('?') == std::string::npos);\n\tDEBUG_ASSERT(map_name.find('\"') == std::string::npos);\n\tDEBUG_ASSERT(map_name.find('<') == std::string::npos);\n\tDEBUG_ASSERT(map_name.find('>') == std::string::npos);\n\tDEBUG_ASSERT(map_name.find('|') == std::string::npos);\n\n\tauto start = std::chrono::steady_clock::now();\n\n\twhile (true) {\n\t\tauto new_episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n\t\tif (new_episode_id == _episode_id) {\n\t\t\treturn EpisodeProxy(_client, new_episode_id);\n\t\t}\n\n\t\tauto now = std::chrono::steady_clock::now();\n\n\t\tif (now - start > _timeout) {\n\t\t\tthrow TimeoutException(\"timeout expired\");\n\t\t}\n\t}\n}", "CodeBleu_score": 40.06787771793129}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(50));\n\tif (map_name.empty()) {\n\t\tmap_name = \"Town01\";\n\t}\n\tEpisodeProxy episode = EpisodeProxy(new Episode(map_name, reset_settings, map_layers));\n\tepisode.Connect(_timeout);\n\treturn episode;\n}", "CodeBleu_score": 23.026004858965305}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tDEBUG_ASSERT(map_name.size() > 0u);\n\tDEBUG_ASSERT(map_name.find('/') == std::string::npos);\n\n\tauto *simulator = _parent.lock();\n\tDEBUG_ASSERT(simulator != nullptr);\n\n\t// Create a new episode.\n\tauto *new_episode = simulator->CreateEpisode(map_name, reset_settings, map_layers);\n\tDEBUG_ASSERT(new_episode != nullptr);\n\n\t// Wait for the new episode to be fully loaded.\n\tauto start = std::chrono::system_clock::now();\n\twhile (true) {\n\t\tauto elapsed = std::chrono::system_clock::now() - start;\n\t\tif (elapsed > _timeout) {\n\t\t\tthrow TimeoutException(\"timeout expired while waiting for the new episode to be fully loaded\");\n\t\t}\n\n\t\tauto *current_episode = simulator->GetEpisode();\n\t\tif (current_episode != nullptr && current_episode->GetId() != new_episode->GetId()) {\n\t\t\tbreak;\n\t\t}\n\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t}\n\n\treturn EpisodeProxy(new_episode);\n}", "CodeBleu_score": 43.128687028225485}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (!episode.has_value()) {\n\t\tthrow_exception(\"Episode is not valid.\", \"Simulator::RegisterAIController\");\n\t}\n\tauto walker = FindWalker(controller.GetID());\n\tif (!walker.has_value()) {\n\t\tthrow_exception(\"Walker not found.\", \"Simulator::RegisterAIController\");\n\t}\n\tif (walker->GetNavigation() == nullptr) {\n\t\twalker->SetNavigation(std::make_shared<detail::WalkerNavigation>(walker->GetActor()));\n\t}\n\tcontroller.RegisterWalker(*walker);\n}", "CodeBleu_score": 41.321627654540094}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (!episode_) {\n\t\tthrow std::runtime_error(\"episode is nullptr\");\n\t}\n\tauto walker = FindWalker(controller.GetWalkerId());\n\tif (!walker) {\n\t\tthrow std::runtime_error(\"walker not found\");\n\t}\n\tif (!walker->HasNavigation()) {\n\t\twalker->SetNavigation(std::make_shared<WalkerNavigation>(walker, *episode_));\n\t}\n\tcontroller.RegisterWalker(*walker);\n}", "CodeBleu_score": 45.78467972348269}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tDEBUG_ASSERT(episode_ != nullptr);\n\tDEBUG_ASSERT(controller.GetActor() != nullptr);\n\tDEBUG_ASSERT(controller.GetActor()->GetParent() != nullptr);\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->IsA<Walker>());\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent() != nullptr);\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->IsA<Episode>());\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetId() == episode_->GetId());\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent() != nullptr);\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->IsA<Server>());\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->GetParent() != nullptr);\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->GetParent()->IsA<detail::Simulator>());\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent() != nullptr);\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->IsA<detail::Client>());\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent() != nullptr);\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->IsA<detail::Server>());\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent() != nullptr);\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->IsA<detail::Server>());\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent() != nullptr);\n\tDEBUG_ASSERT(controller.GetActor()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->GetParent()->IsA<detail::", "CodeBleu_score": 36.88372590893492}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tCHECK(IsEpisodeValid()) << \"Episode is not valid, use Episode::Start() to start the episode.\";\n\tCHECK(parent == nullptr || parent->IsAlive()) << \"Parent actor is not alive\";\n\tCHECK(blueprint.HasTag(TAG_CARLA_VERSION, Version.GetVersion())) << \"Blueprint version mismatch\";\n\tif (parent != nullptr) {\n\t\tCHECK(parent->GetParent() == nullptr) << \"Parent actor already has a parent actor\";\n\t}\n\tif (blueprint.HasTag(TAG_REQUIRED_AGENT, \"Vehicle\")) {\n\t\tCHECK(blueprint.HasTag(TAG_REQUIRED_ROLE, \"Autopilot\")) << \"Vehicle requires the autopilot agent\";\n\t}\n\tif (blueprint.HasTag(TAG_REQUIRED_AGENT, \"Pedestrian\")) {\n\t\tCHECK(blueprint.HasTag(TAG_REQUIRED_ROLE, \"Autopilot\")) << \"Pedestrian requires the autopilot agent\";\n\t}\n\tif (blueprint.HasTag(TAG_REQUIRED_AGENT, \"TrafficLight\")) {\n\t\tCHECK(blueprint.HasTag(TAG_REQUIRED_ROLE, \"TrafficLight\")) << \"TrafficLight requires the traffic light agent\";\n\t}\n\tif (blueprint.HasTag(TAG_REQUIRED_AGENT, \"SpeedLimit\")) {\n\t\tCHECK(blueprint.HasTag(TAG_REQUIRED_ROLE, \"SpeedLimit\")) << \"SpeedLimit requires the speed limit agent\";\n\t}\n\tif (blueprint.HasTag(TAG_REQUIRED_AGENT, \"Obstacle\")) {\n\t\tCHECK(blueprint.HasTag(TAG_REQUIRED_ROLE, \"Obstacle\")) << \"Obstacle requires the obstacle agent\";\n\t}\n\tif (blueprint.HasTag(TAG_REQUIRED_AGENT, \"NPC\")) {\n\t\tCHECK(blueprint.HasTag(TAG_REQUIRED_ROLE, \"NPC\")) << \"NPC requires the NPC agent\";\n\t}\n\n\tconst auto actor_id = _next_actor_id++;\n\tconst auto actor_type = blueprint.GetActorType();\n\tconst auto transform_data = transform.MakeTransformData();\n\tconst auto parent_id = parent != nullptr ? parent->GetActorId() : rpc::ActorId();\n\tconst auto attachment_type_data = static_cast<uint8_t>(attachment_type);\n\tconst auto socket", "CodeBleu_score": 33.394809281742745}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tDEBUG_ASSERT(IsEpisodeActive());\n\tDEBUG_ASSERT(blueprint.HasTag(TAG_CARLA_VERSION));\n\tDEBUG_ASSERT(blueprint.HasTag(TAG_MAP_NAME));\n\tDEBUG_ASSERT(blueprint.HasTag(TAG_EPISODE_NAME));\n\tDEBUG_ASSERT(blueprint.HasTag(TAG_OPENSCENARIO_VERSION));\n\tDEBUG_ASSERT(blueprint.HasTag(TAG_ROLE_NAME));\n\n\tDEBUG_ASSERT(blueprint.GetParentId() == parent->GetId() || parent == nullptr);\n\n\tDEBUG_ASSERT(attachment_type == rpc::AttachmentType::SpringArm || socket_name.empty());\n\n\t// Create the actor.\n\tauto actor = ActorFactory::MakeActor(blueprint, transform, parent, attachment_type, socket_name);\n\n\t// Register the actor.\n\tRegisterActor(actor);\n\n\t// Apply garbage collection policy.\n\tApplyGarbageCollectionPolicy(gc);\n\n\t// Log the creation details.\n\tLogActorCreation(actor);\n\n\treturn actor;\n}", "CodeBleu_score": 40.824098352346304}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tif (parent != nullptr) {\n\t\tif (!parent->IsAlive()) {\n\t\t\tthrow_exception(\"the parent actor is not alive\");\n\t\t}\n\t\tif (parent->GetParent() != nullptr) {\n\t\t\tthrow_exception(\"the parent actor already has a parent actor\");\n\t\t}\n\t\tif (parent->GetActorId() == 0) {\n\t\t\tthrow_exception(\"the parent actor is not valid\");\n\t\t}\n\t\tif (parent->GetEpisodeId() != _current_episode) {\n\t\t\tthrow_exception(\"the parent actor does not belong to the current episode\");\n\t\t}\n\t}\n\n\tconst auto actor_type = blueprint.GetActorType();\n\n\t// Check if the actor type is supported.\n\tif (!IsActorTypeSupported(actor_type)) {\n\t\tthrow_exception(std::string(\"actor type not supported: \") + actor_type);\n\t}\n\n\t// Check if the actor type is supported by the server.\n\tif (!IsActorTypeRegistered(actor_type)) {\n\t\tthrow_exception(std::string(\"actor type not registered: \") + actor_type);\n\t}\n\n\t// Check if the actor type is supported by the server.\n\tif (!IsActorTypeRegistered(actor_type)) {\n\t\tthrow_exception(std::string(\"actor type not registered: \") + actor_type);\n\t}\n\n\t// Check if the actor type is supported by the server.\n\tif (!IsActorTypeRegistered(actor_type)) {\n\t\tthrow_exception(std::string(\"actor type not registered: \") + actor_type);\n\t}\n\n\t// Check if the actor type is supported by the server.\n\tif (!IsActorTypeRegistered(actor_type)) {\n\t\tthrow_exception(std::string(\"actor type not registered: \") + actor_type);\n\t}\n\n\t// Check if the actor type is supported by the server.\n\tif (!IsActorTypeRegistered(actor_type)) {\n\t\tthrow_exception(std::string(\"actor type not registered: \") + actor_type);\n\t}\n\n\t// Check if the actor type is supported by the server.\n\tif (!IsActorTypeRegistered(actor_type)) {\n\t\tthrow_exception(std::string(\"actor type not registered: \") + actor_type);\n\t}\n\n", "CodeBleu_score": 33.35685439113299}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifndef LIBCARLA_WITH_PYTHON_SUPPORT\n  boost::python::lock_gil lock;", "CodeBleu_score": 10.19737179400177}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifdef LIBCARLA_WITH_PYTHON_SUPPORT\n  boost::python::gil_scoped_acquire acquire;\n#endif // LIBCARLA_WITH_PYTHON_SUPPORT\n\n  if (!episode.IsValid()) {\n    throw_exception(\"invalid episode\");\n  }\n\n  if (!sensor.is_alive()) {\n    throw_exception(\"invalid sensor\");\n  }\n\n  if (!callback) {\n    throw_exception(\"invalid callback\");\n  }\n\n  auto token = sensor.listen(callback);\n  token_to_callback[token] = callback;\n}", "CodeBleu_score": 33.600155569589965}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifdef LIBCARLA_WITH_PYTHON_SUPPORT\n  boost::python::gil_scoped_release release;\n#endif // LIBCARLA_WITH_PYTHON_SUPPORT\n  if (_episode == nullptr) {\n    log_and_throw(\"The episode is not valid.\");\n  }\n  _episode->SubscribeToSensor(sensor, callback);\n}", "CodeBleu_score": 27.987832776838715}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto &walkers = episode->GetWalkers();\n\tauto &state = episode->GetState();\n\tauto &simulator = episode->GetSimulator();\n\tauto &navigation = episode->GetNavigation();\n\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Remove any dead walkers.\n\tfor (auto it = walkers.begin(); it != walkers.end();) {\n\t\tif (it->second.GetController()->IsPendingKill()) {\n\t\t\tit = walkers.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t// Update the state of the episode.\n\tstate.Update();\n\n\t// Remove any walkers that have left the simulation.\n\tfor (auto it = walkers.begin(); it != walkers.end();) {\n\t\tif (it->second.GetActor().IsPendingKill()) {\n\t\t\tit = walkers.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t// Update the vehicles in the crowd.\n\tfor (auto &walker : walkers) {\n\t\twalker.second.Update(state);\n\t}\n\n\t// Update the crowd.\n\tnavigation.Update(state);\n\n\t// Apply the walker states to the simulation.\n\tauto walker_states = std::vector<rpc::WalkerState>();\n\tfor (auto &walker : walkers) {\n\t\twalker_states.push_back(walker.second.GetState());\n\t}\n\tsimulator.ApplyWalkerStateBatch(walker_states);\n\n\t// Check if any walker has been killed.\n\tfor (auto it = walkers.begin(); it != walkers.end();) {\n\t\tif (it->second.GetController()->IsPendingKill()) {\n\t\t\tit = walkers.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.62804687588901}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// Get the current list of walkers.\n\tauto walkers = episode->GetWalkers();\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get the current state of the episode.\n\tauto state = episode->GetState();\n\n\t// Remove any walkers that no longer exist.\n\tfor (auto it = _walkers.begin(); it != _walkers.end();) {\n\t\tif (std::find(walkers.begin(), walkers.end(), it->first) == walkers.end()) {\n\t\t\tit = _walkers.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t// Update the vehicles in the crowd and the crowd itself.\n\t_navigation.UpdateVehicles(state.GetVehicles());\n\t_navigation.Update(state.GetFrame());\n\n\t// For each walker, get their transform and speed, then apply these states in a batch to the simulator.\n\tauto walker_controls = std::vector<rpc::WalkerControl>();\n\tfor (const auto &walker : walkers) {\n\t\tauto transform = walker.second.GetTransform();\n\t\tauto speed = walker.second.GetSpeed();\n\n\t\t// Get the control for this walker.\n\t\tauto control = _navigation.GetWalkerControl(transform, speed);\n\n\t\t// If the walker is dead, remove them from the crowd and destroy their controller.\n\t\tif (walker.second.IsDead()) {\n\t\t\t_navigation.RemoveWalker(walker.first);\n\t\t\t_walkers.erase(walker.first);\n\t\t}\n\n\t\t// If the walker is still alive, add their control to the list.\n\t\telse {\n\t\t\twalker_controls.push_back(control);\n\t\t}\n\t}\n\n\t// Send the list of controls to the simulator.\n\tif (!walker_controls.empty()) {\n\t\tepisode->ApplyWalkerControls(walker_controls);\n\t}\n}", "CodeBleu_score": 44.443334757778295}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto simulator = episode->GetSimulator();\n\tauto client = simulator->GetClient();\n\tauto navigation = simulator->GetNavigation();\n\n\t// Load the walkers.\n\tauto walkers = client->GetWalkers();\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Retrieve the current episode state.\n\tauto episode_state = episode->GetState();\n\n\t// Remove any walkers that no longer exist.\n\tauto walker_ids = episode_state.GetWalkerIDs();\n\tfor (auto it = walker_ids.begin(); it != walker_ids.end();) {\n\t\tauto id = *it;\n\t\tif (std::find(walkers.begin(), walkers.end(), id) == walkers.end()) {\n\t\t\tit = walker_ids.erase(it);\n\t\t\tnavigation->RemoveWalker(id);\n\t\t}\n\t\telse {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t// Update the vehicles in the crowd and the crowd itself in the navigation module.\n\tnavigation->Update(client->GetWorld(), episode_state.GetVehicles());\n\n\t// Apply the walker states in a batch.\n\tauto walker_states = episode_state.GetWalkerStates();\n\tauto walker_controls = std::vector<rpc::WalkerControl>();\n\tfor (auto it = walker_states.begin(); it != walker_states.end(); ++it) {\n\t\tauto state = it->second;\n\t\tauto control = rpc::WalkerControl();\n\t\tcontrol.direction = state.GetDirection();\n\t\tcontrol.speed = state.GetSpeed();\n\t\twalker_controls.push_back(control);\n\t}\n\tclient->ApplyWalkerControls(walker_controls);\n\n\t// Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead.\n\tfor (auto it = walker_states.begin(); it != walker_states.end();) {\n\t\tauto id = it->first;\n\t\tauto state = it->second;\n\t\tif (state.IsAlive()) {\n\t\t\t++it;\n\t\t}\n\t\telse {\n\t\t\tnavigation->RemoveWalker(id);\n\t\t\tit = walker_states.erase(it);\n\t\t\tclient", "CodeBleu_score": 40.89492905049529}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription desc;\n\tdesc.uid = uid;\n\tdesc.id = id;\n\tdesc.type = type;\n\n\tfor (const auto &attribute : attributes) {\n\t\tdesc.attributes.emplace_back(attribute.MakeAttribute());\n\t}\n\n\treturn desc;\n}", "CodeBleu_score": 62.827078672369105}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = _uid;\n\tdescription.id = _id;\n\n\tfor (const auto &attribute : _attributes) {\n\t\tdescription.attributes.push_back(attribute.MakeAttribute());\n\t}\n\n\treturn description;\n}", "CodeBleu_score": 75.08136611898428}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = _uid;\n\tdescription.id = _id;\n\tdescription.type = _type;\n\tdescription.rolename = _rolename;\n\tdescription.parent_id = _parent_id;\n\tdescription.transform = _transform;\n\tdescription.attributes.reserve(_attributes.size());\n\tfor (const auto &attribute : _attributes) {\n\t\tdescription.attributes.emplace_back(attribute.MakeAttribute());\n\t}\n\treturn description;\n}", "CodeBleu_score": 74.63970280568955}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\t// Create a new BlueprintLibrary object\n\tauto result = MakeShared<BlueprintLibrary>();\n\t// Iterate through all blueprints\n\tfor (auto &blueprint : blueprints) {\n\t\t// Check if the blueprint has the attribute\n\t\tif (blueprint.attributes.find(name) != blueprint.attributes.end()) {\n\t\t\t// Check if the blueprint's value matches the specified value\n\t\t\tif (blueprint.attributes.at(name) == value) {\n\t\t\t\t// Add the blueprint to the result\n\t\t\t\tresult->AddBlueprint(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\t// Return the new BlueprintLibrary\n\treturn result;\n}", "CodeBleu_score": 32.20502716073895}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t// Start snippet\n#ifdef LIBCARLA_INCLUDED_FROM_UE4\n\n  SharedPtr<BlueprintLibrary> Result = MakeShared<BlueprintLibrary>();\n  for (const auto &Pair : _blueprints) {\n    auto &Blueprint = Pair.second;\n    if (Blueprint.HasAttribute(name)) {\n      if (Blueprint.GetAttribute(name).GetValue() == value) {\n        Result->Add(Blueprint);\n      }\n    }\n  }\n  return Result;\n\n#else\n\n  SharedPtr<BlueprintLibrary> Result = MakeShared<BlueprintLibrary>();\n  for (const auto &Pair : _blueprints) {\n    auto &Blueprint = Pair.second;\n    if (Blueprint.HasAttribute(name)) {\n      if (Blueprint.GetAttribute(name).GetValue() == value) {\n        Result->Add(Blueprint);\n      }\n    }\n  }\n  return Result;\n\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n// End snippet\n}", "CodeBleu_score": 49.41535943574083}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n/*\n * This function, BlueprintLibrary::FilterByAttribute, filters blueprints by a specified attribute name and value.", "CodeBleu_score": 13.989795762660274}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = path + \"/\" + std::to_string(carla::version::major) + \".\" + std::to_string(carla::version::minor) + \".\" + std::to_string(carla::version::patch) + \"/\" + path;\n\tstd::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tfile.write(reinterpret_cast<const char *>(content.data()), content.size());\n\tfile.close();\n\treturn true;\n}", "CodeBleu_score": 43.85689432844643}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Construct the full file path using a base folder and version information.\n\tstd::string full_path = path + CARLA_VERSION_STRING;\n\t// Validate the file path.\n\tif (full_path.find(\"..\") != std::string::npos) {\n\t\treturn false;\n\t}\n\t// Open the file in binary mode to truncate its contents.\n\tstd::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\t// Write the content and close the file.\n\tfile.write(reinterpret_cast<const char *>(&content[0]), content.size());\n\tfile.close();\n\treturn true;\n}", "CodeBleu_score": 43.11696136923197}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = path + \"/\" + std::to_string(carla::version::major) + \".\" + std::to_string(carla::version::minor) + \".\" + std::to_string(carla::version::patch);\n\tstd::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tfile.write(reinterpret_cast<const char*>(content.data()), content.size());\n\tfile.close();\n\treturn true;\n}", "CodeBleu_score": 44.003059968983635}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\nconst auto location = transform.location;\nconst auto yaw = transform.rotation.yaw;\n\nconst geom::Location extents{static_cast<float>(m_parent.m_extent), static_cast<float>(m_parent.m_extent), 0.0f};\n\nconst geom::Location corners[4] = {\n    geom::Math::Transform(extents, geom::Transform(geom::Location(0.0f, 0.0f, 0.0f), geom::Rotation(0.0f, 0.0f, yaw))),\n    geom::Math::Transform(extents, geom::Transform(geom::Location(0.0f, 0.0f, 0.0f), geom::Rotation(0.0f, 0.0f, yaw + 90.0f))),\n    geom::Math::Transform(extents, geom::Transform(geom::Location(0.0f, 0.0f, 0.0f), geom::Rotation(0.0f, 0.0f, yaw + 180.0f))),\n    geom::Math::Transform(extents, geom::Transform(geom::Location(0.0f, 0.0f, 0.0f), geom::Rotation(0.0f, 0.0f, yaw + 270.0f)))\n};\n\nconst geom::Location bbox_location = location + m_parent.m_parent.GetActorLocation();\n\nreturn std::make_shared<const Bounds>(frame, bbox_location, corners);\n\n}", "CodeBleu_score": 44.89113078568892}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\tconst auto location = transform.location;\n\tconst auto rotation = transform.rotation.yaw;\n\tconst auto extents = _parent.GetBoundingBox().extent;\n\n\tauto corners = std::vector<geom::Location>{};\n\tcorners.emplace_back(location + geom::Location(-extents.x, -extents.y, 0.0) * rotation.cos() - geom::Location(0.0, 0.0, extents.z) * rotation.sin());\n\tcorners.emplace_back(location + geom::Location(extents.x, -extents.y, 0.0) * rotation.cos() - geom::Location(0.0, 0.0, extents.z) * rotation.sin());\n\tcorners.emplace_back(location + geom::Location(extents.x, extents.y, 0.0) * rotation.cos() - geom::Location(0.0, 0.0, extents.z) * rotation.sin());\n\tcorners.emplace_back(location + geom::Location(-extents.x, extents.y, 0.0) * rotation.cos() - geom::Location(0.0, 0.0, extents.z) * rotation.sin());\n\n\treturn std::make_shared<const Bounds>(Bounds{frame, corners});\n}", "CodeBleu_score": 48.386996965684304}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n#ifdef LIBCARLA_INCLUDED_FROM_UE4\n\n  const geom::Location location = transform.location;\n  const geom::Vector3D extent = GetBoundingBox().extent;\n  const geom::Vector3D extent_rotated = extent.MakeRotated(transform.rotation.yaw);\n  const geom::Location location_rotated = location.MakeRotated(transform.rotation.yaw);\n\n  const geom::Location min_location = location_rotated - extent_rotated;\n  const geom::Location max_location = location_rotated + extent_rotated;\n\n  const geom::Location corners[] = {\n      geom::Location(min_location.x, min_location.y, min_location.z),\n      geom::Location(min_location.x, max_location.y, min_location.z),\n      geom::Location(max_location.x, max_location.y, min_location.z),\n      geom::Location(max_location.x, min_location.y, min_location.z)\n  };\n\n#else\n\n  const geom::Location location = transform.location;\n  const geom::Vector3D extent = GetBoundingBox().extent;\n  const geom::Vector3D extent_rotated = extent.MakeRotated(transform.rotation.yaw);\n  const geom::Location location_rotated = location.MakeRotated(transform.rotation.yaw);\n\n  const geom::Location min_location = location_rotated - extent_rotated;\n  const geom::Location max_location = location_rotated + extent_rotated;\n\n  const geom::Location corners[] = {\n      geom::Location(min_location.x, min_location.y, min_location.z),\n      geom::Location(min_location.x, max_location.y, min_location.z),\n      geom::Location(max_location.x, max_location.y, min_location.z),\n      geom::Location(max_location.x, min_location.y, min_location.z)\n  };\n\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n\n  return std::make_shared<const Bounds>(Bounds{frame, corners});\n\n}", "CodeBleu_score": 36.7410766466976}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t_lights.clear();\n\t_lights = _simulator->QueryLightsState();\n}", "CodeBleu_score": 15.151980822582404}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_lights_mutex);\n\tauto light_states = _simulator->QueryLightsState();\n\tfor (auto &light_state : light_states) {\n\t\tauto it = _lights.find(light_state.id);\n\t\tif (it == _lights.end()) {\n\t\t\t_lights[light_state.id] = std::make_shared<Light>(light_state, _simulator);\n\t\t}\n\t\telse {\n\t\t\tit->second->UpdateState(light_state);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.33477253223918}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto lights_state = _simulator->QueryLightsState();\n\tfor (auto &light_state : lights_state) {\n\t\tauto it = _lights.find(light_state.id);\n\t\tif (it == _lights.end()) {\n\t\t\tauto light = std::make_shared<Light>(light_state.id, _simulator);\n\t\t\t_lights[light_state.id] = light;\n\t\t}\n\t\telse {\n\t\t\tit->second->UpdateState(light_state);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.13444157678325}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (!dirty_) {\n\t\treturn;\n\t}\n\n\tauto *simulator = carla::client::detail::Simulator::Get();\n\tif (simulator == nullptr) {\n\t\treturn;\n\t}\n\n\tauto *server = simulator->server();\n\tif (server == nullptr) {\n\t\treturn;\n\t}\n\n\tauto *world = simulator->world();\n\tif (world == nullptr) {\n\t\treturn;\n\t}\n\n\tauto *town_map = world->GetMap();\n\tif (town_map == nullptr) {\n\t\treturn;\n\t}\n\n\tauto *vehicle = world->GetVehicle();\n\tif (vehicle == nullptr) {\n\t\treturn;\n\t}\n\n\tauto vehicle_transform = vehicle->GetTransform();\n\tauto vehicle_location = vehicle_transform.location;\n\n\tauto lights = world->GetStreetlights();\n\tauto lights_state = std::vector<carla::rpc::LightState>();\n\tfor (auto &light : lights) {\n\t\tauto light_state = carla::rpc::LightState();\n\t\tlight_state.id = light.GetId();\n\t\tlight_state.transform = light.GetTransform();\n\t\tlight_state.color = light.GetColor();\n\t\tlight_state.intensity = light.GetIntensity();\n\t\tlight_state.attenuation_radius = light.GetAttenuationRadius();\n\t\tlight_state.light_type = static_cast<int32_t>(light.GetLightType());\n\t\tlight_state.state = static_cast<int32_t>(light.GetState());\n\t\tlight_state.is_daytime = light.IsDaytime();\n\t\tlight_state.dynamic_object_id = light.GetDynamicObjectId();\n\t\tlight_state.trigger_volume_id = light.GetTriggerVolumeId();\n\t\tlight_state.reverse_traffic_light_id = light.GetReverseTrafficLightId();\n\t\tlight_state.pole_id = light.GetPoleId();\n\t\tlight_state.group_id = light.GetGroupId();\n\t\tlight_state.road_id = town_map->GetRoad(light_state.transform.location).id;\n\t\tlight_state.lane", "CodeBleu_score": 37.96110313437137}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (dirty_) {\n\t\tauto msg = carla::rpc::Command::Request();\n\t\tmsg.set_command(\"set_lights_state\");\n\t\tauto light_state_msg = msg.mutable_set_lights_state();\n\t\tlight_state_msg->set_frame(frame_);\n\t\tfor (auto it = lights_.begin(); it != lights_.end(); ++it) {\n\t\t\tauto light_state = light_state_msg->add_lights();\n\t\t\tlight_state->set_id(it->first);\n\t\t\tlight_state->set_state(it->second.state);\n\t\t\tlight_state->set_color(it->second.color);\n\t\t\tlight_state->set_intensity(it->second.intensity);\n\t\t\tlight_state->set_position(it->second.position);\n\t\t\tlight_state->set_direction(it->second.direction);\n\t\t\tlight_state->set_cast_shadows(it->second.cast_shadows);\n\t\t}\n\t\tsimulator_->SendLightState(msg, discard_client);\n\t\tdirty_ = false;\n\t}\n}", "CodeBleu_score": 49.32838404019021}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(this->mutex);\n\tif (this->dirty) {\n\t\tthis->dirty = false;\n\t\tif (!discard_client) {\n\t\t\tauto *simulator = this->simulator.get();\n\t\t\tif (simulator != nullptr) {\n\t\t\t\tauto *server = simulator->server();\n\t\t\t\tif (server != nullptr) {\n\t\t\t\t\tauto *message = server->NewMessage();\n\t\t\t\t\tif (message != nullptr) {\n\t\t\t\t\t\tauto *lights = message->mutable_all_lights();\n\t\t\t\t\t\tfor (auto &light : this->lights) {\n\t\t\t\t\t\t\tauto *light_state = lights->add_light_states();\n\t\t\t\t\t\t\tlight_state->set_id(light.id);\n\t\t\t\t\t\t\tlight_state->set_state(light.state);\n\t\t\t\t\t\t\tlight_state->set_color(light.color);\n\t\t\t\t\t\t\tlight_state->set_intensity(light.intensity);\n\t\t\t\t\t\t\tlight_state->set_position(light.position);\n\t\t\t\t\t\t\tlight_state->set_direction(light.direction);\n\t\t\t\t\t\t\tlight_state->set_attenuation_range(light.attenuation_range);\n\t\t\t\t\t\t\tlight_state->set_type(light.type);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tserver->SendMessage(message, false, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.6261104593684}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetParentId() != \"sensor.other.v2x_custom\") {\n\t\tLOG_WARNING(\"ServerSideSensor::Send: sensor.other.v2x_custom is not the parent of this sensor. This sensor will not send data to the server.\")\n\t}\n\telse {\n\t\tGetContext()->Send(message);\n\t}\n}", "CodeBleu_score": 49.49452248951825}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetSensorId() != \"sensor.other.v2x_custom\") {\n\t\tLOG_WARNING(\"The ServerSideSensor::Send function was called, but the sensor's ID was not \\\"sensor.other.v2x_custom\\\". This function will not work properly. The sensor's ID is: \" + GetSensorId());\n\t\treturn;\n\t}\n\n\tauto simulator = GetEpisode().GetSimulator();\n\tif (!simulator) {\n\t\tLOG_WARNING(\"The ServerSideSensor::Send function was called, but the sensor's episode does not have a valid simulator.\");\n\t\treturn;\n\t}\n\n\tauto client = simulator->GetClient();\n\tif (!client) {\n\t\tLOG_WARNING(\"The ServerSideSensor::Send function was called, but the sensor's episode does not have a valid client.\");\n\t\treturn;\n\t}\n\n\tauto sensor_context = GetContext();\n\tif (!sensor_context) {\n\t\tLOG_WARNING(\"The ServerSideSensor::Send function was called, but the sensor's context is nullptr.\");\n\t\treturn;\n\t}\n\n\tclient->WriteData(*sensor_context, message);\n}", "CodeBleu_score": 46.33674237745299}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetSensorId() == \"sensor.other.v2x_custom\") {\n\t\tLOG_DEBUG(\"Sending message to episode: \" + message);\n\t\tGetEpisode().Send(message);\n\t}\n\telse {\n\t\tLOG_WARNING(\"Trying to send message to episode, but sensor ID is not \\\"sensor.other.v2x_custom\\\".\");\n\t}\n}", "CodeBleu_score": 48.02275946012908}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (tm_port == 0) {\n\t\t_traffic_manager->UnregisterVehicle(_id);\n\t}\n\telse {\n\t\t_traffic_manager->RegisterVehicle(_id, tm_port);\n\t}\n}", "CodeBleu_score": 38.405525235124294}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (tm_port == 0) {\n\t\ttm_port = _traffic_manager.GetPort();\n\t}\n\tif (enabled) {\n\t\t_traffic_manager.RegisterVehicle(this, tm_port);\n\t} else {\n\t\t_traffic_manager.UnregisterVehicle(this, tm_port);\n\t}\n}", "CodeBleu_score": 46.513236054596234}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (tm_port == 0) {\n\t\t_traffic_manager.reset();\n\t} else {\n\t\tif (_traffic_manager == nullptr) {\n\t\t\t_traffic_manager = std::make_shared<carla::traffic_manager::TrafficManager>(GetMemory(), tm_port);\n\t\t}\n\t\t_traffic_manager->RegisterVehicle(this, enabled);\n\t}\n}", "CodeBleu_score": 42.53617867121328}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\t// Get the walker actor.\n\tauto *Actor = GetActor();\n\tif (Actor == nullptr) {\n\t\tUE_LOG(LogCarla, Error, TEXT(\"WalkerAIController: Start() failed. No actor set.\"));\n\t\treturn;\n\t}\n\n\t// Add the walker to the navigation system.\n\tauto *Nav = GetWorld().GetNavigationSystem();\n\tif (Nav == nullptr) {\n\t\tUE_LOG(LogCarla, Error, TEXT(\"WalkerAIController: Start() failed. No navigation system available.\"));\n\t\treturn;\n\t}\n\tauto *Walker = Cast<AWalkerAIController>(Actor);\n\tif (Walker == nullptr) {\n\t\tUE_LOG(LogCarla, Error, TEXT(\"WalkerAIController: Start() failed. Actor not a walker.\"));\n\t\treturn;\n\t}\n\tif (!Nav->AddWalker(Walker)) {\n\t\tUE_LOG(LogCarla, Error, TEXT(\"WalkerAIController: Start() failed. Could not add walker to navigation system.\"));\n\t\treturn;\n\t}\n\n\t// Disable physics simulation and collision.\n\tActor->SetActorEnableCollision(false);\n\tActor->SetActorEnablePhysics(false);\n}", "CodeBleu_score": 42.44454214445638}, {"code": "void WalkerAIController::Start(){\n\t\tif (_actor == nullptr) {\n\t\t_actor = _world.TryGetActor(_actor_id);\n\t}\n\n\tif (_actor == nullptr) {\n\t\tUE_LOG(LogCarla, Error, TEXT(\"WalkerAIController: Could not find actor with id %d\"), _actor_id);\n\t\treturn;\n\t}\n\n\t_nav = MakeShared<detail::WalkerNavigation>(_actor, _max_speed);\n\t_nav->UpdateLocation(_actor->GetLocation());\n\n\t_actor->DisablePhysics(true);\n\t_actor->SetSimulatePhysics(false);\n}", "CodeBleu_score": 34.934193054897385}, {"code": "void WalkerAIController::Start(){\n\t\tauto *Simulator = GetWorld().GetSimulator();\n\tauto *WalkerActor = GetActor();\n\tauto *WalkerController = GetController();\n\tauto *WalkerNavigation = Simulator->GetWalkerNavigation();\n\tauto WalkerLocation = WalkerActor->GetLocation();\n\n\tWalkerNavigation->AddWalker(WalkerActor);\n\tWalkerNavigation->SetWalkerLocation(WalkerActor, WalkerLocation);\n\tWalkerActor->SetSimulatePhysics(false);\n\tWalkerActor->SetEnableCollision(false);\n\tWalkerController->SetWalker(WalkerActor);\n}", "CodeBleu_score": 41.22793972774467}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (max_speed <= 0.0f) {\n\t\treturn;\n\t}\n\n\tauto simulator = GetWorld().GetSimulator();\n\tif (simulator == nullptr) {\n\t\treturn;\n\t}\n\n\tauto navigation = simulator->GetNavigation();\n\tif (navigation == nullptr) {\n\t\treturn;\n\t}\n\n\tauto parent_walker = navigation->GetParentWalker();\n\tif (parent_walker == nullptr) {\n\t\treturn;\n\t}\n\n\tauto walker_control = parent_walker->GetWalkerControl();\n\tif (walker_control == nullptr) {\n\t\treturn;\n\t}\n\n\tauto status = walker_control->SetMaxSpeed(max_speed);\n\tif (status != carla::rpc::Response::Success) {\n\t\tUE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set maximum speed for walker. Error: %s\"), carla::rpc::Response::ToString(status));\n\t}\n}", "CodeBleu_score": 47.328235280019456}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto navigation = GetEpisode().GetNavigation();\n\tif (navigation) {\n\t\tauto walker = GetParent();\n\t\tif (walker) {\n\t\t\tif (!navigation->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\t\tUE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Setting maximum speed failed\"));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tUE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Could not find parent walker\"));\n\t\t}\n\t}\n\telse {\n\t\tUE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Could not find navigation instance\"));\n\t}\n}", "CodeBleu_score": 52.06951945724021}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (auto *navigation = GetEpisode().GetNavigation()) {\n\t\tif (auto *walker = GetParent()) {\n\t\t\tif (navigation->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tLOG_WARNING(\"WalkerAIController::SetMaxSpeed() -- No valid navigation instance found.\");\n}", "CodeBleu_score": 37.16477665413962}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<carla::rpc::Waypoint> waypoints = Map::Get().GetPrevious(self, distance);\n\tstd::vector<SharedPtr<Waypoint>> result;\n\tfor (auto &waypoint : waypoints) {\n\t\tresult.push_back(MakeShared<Waypoint>(waypoint));\n\t}\n\treturn result;\n}", "CodeBleu_score": 56.800428548318685}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tfor (auto &wp : _parent.GetPrevious(this, distance)) {\n\t\tresult.emplace_back(MakeShared<Waypoint>(wp, _parent));\n\t}\n\treturn result;\n}", "CodeBleu_score": 46.64263945695906}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<carla::rpc::Waypoint> waypoints = _parent.GetPreviousWaypoints(_id, distance);\n\tstd::vector<SharedPtr<Waypoint>> result;\n\tfor (auto waypoint : waypoints) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(_parent, waypoint)));\n\t}\n\treturn result;\n}", "CodeBleu_score": 53.90688879677153}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\nstd::vector<SharedPtr<Landmark>> result;\n\n// Get all the signals in the distance\nstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\n// Check for repeated signals\nstd::unordered_set<std::string> ids;\nfor (auto signal : signals) {\n    if (ids.count(signal->GetId()) == 0) {\n        ids.insert(signal->GetId());\n    } else {\n        continue;\n    }\n\n    // Create a new Landmark\n    SharedPtr<Landmark> landmark(new Landmark(signal));\n\n    // Add it to the result\n    result.push_back(landmark);\n}\n\nreturn result;\n}", "CodeBleu_score": 39.586001937454775}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\n#ifdef DEBUG\n  std::cout << \"Waypoint::GetAllLandmarksInDistance() called.\" << std::endl;\n#endif\n\n  // Create a vector of SharedPtr<Landmark> objects.\n  std::vector<SharedPtr<Landmark>> landmarks;\n\n  // Get the signals within the distance.\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\n  // Create a set to store the signals to avoid duplicates.\n  std::unordered_set<std::string> signal_set;\n\n  // Iterate through the signals.\n  for (auto &signal : signals) {\n\n    // Check if the signal is already in the set.\n    if (signal_set.find(signal->GetId()) == signal_set.end()) {\n\n      // Add the signal to the set.\n      signal_set.insert(signal->GetId());\n\n      // Create a new Waypoint and Landmark.\n      SharedPtr<Waypoint> waypoint = MakeShared<Waypoint>(this->GetTransform());\n      SharedPtr<Landmark> landmark = MakeShared<Landmark>(waypoint, signal);\n\n      // Add the Landmark to the vector.\n      landmarks.push_back(landmark);\n\n    }\n\n  }\n\n  // Return the vector of Landmarks.\n  return landmarks;\n\n}", "CodeBleu_score": 47.69337587284933}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\n\t// Get all the signals within the distance.\n\tauto signals = GetSignalsInDistance(distance);\n\n\t// Check for repeated signals.\n\tstd::unordered_set<std::string> unique_signals;\n\tfor (auto &signal : signals) {\n\t\tif (unique_signals.find(signal->GetId()) == unique_signals.end()) {\n\t\t\tunique_signals.insert(signal->GetId());\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Create a new Waypoint and Landmark for each signal.\n\t\tauto waypoint = MakeShared<Waypoint>(GetTransform().TransformPoint(signal->GetTransform().location));\n\t\tauto landmark = MakeShared<Landmark>(waypoint, signal);\n\n\t\tresult.push_back(landmark);\n\n\t\tif (stop_at_junction) {\n\t\t\tif (waypoint->IsJunction()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 53.38990260269823}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tauto id = _simulator->ApplySettings(settings, timeout);\n\treturn id;\n}", "CodeBleu_score": 13.084028226336141}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (!settings.has_timeout()) {\n\t\tsettings.set_timeout(timeout);\n\t}\n\telse if (settings.timeout() > timeout) {\n\t\tsettings.set_timeout(timeout);\n\t}\n\treturn simulator->ApplySettings(settings);\n}", "CodeBleu_score": 15.183650213059744}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tauto *simulator = GetSimulator();\n\tif (!simulator) {\n\t\treturn 0;\n\t}\n\treturn simulator->ApplySettings(settings, timeout);\n}", "CodeBleu_score": 15.722425824792758}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segment_squared_length = (segment.second - segment.first).squared_length();\n\tif (segment_squared_length == 0.0f) {\n\t\treturn {0.0f, (segment.first - point).length()};\n\t}\n\tfloat t = std::max(0.0f, std::min(1.0f, (point - segment.first).dot(segment.second - segment.first) / segment_squared_length));\n\treturn {(segment.first + (segment.second - segment.first) * t - point).length(), t};\n}", "CodeBleu_score": 24.31281378246203}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\nfloat lengthSquared = (point2 - point1).LengthSquared();\n\nif (lengthSquared == 0.0f) {\n\nreturn std::make_pair(0.0f, (point1 - point2).Length());\n\n}\n\nfloat t = std::max(0.0f, std::min(1.0f, (point - point1).Dot(point2 - point1) / lengthSquared));\n\nreturn std::make_pair(t * (point2 - point1).Length(), (point - (point1 + t * (point2 - point1))).Length());\n\n}", "CodeBleu_score": 32.323819919495094}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst auto l2 = segment.length * segment.length;\n\tif (l2 < 0.0000001) {\n\t\treturn std::make_pair(0.0f, std::min(Math::Distance(segment.a, point), Math::Distance(segment.b, point)));\n\t}\n\tconst auto t = std::max(0.0f, std::min(1.0f, Math::Dot(point - segment.a, segment.b - segment.a) / l2));\n\tconst auto projection = segment.a + (segment.b - segment.a) * t;\n\treturn std::make_pair(t * segment.length, Math::Distance(projection, point));\n}", "CodeBleu_score": 36.19136659630499}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\n#ifndef NDEBUG\n\nif (vertices.size() < 3) {\n\nstd::stringstream ss;\n\nss << \"Mesh::AddTriangleFan: \"\n\n<< \"There must be at least three vertices in the list.\";\n\nthrow std::runtime_error(ss.str());\n\n}\n\n#endif\n\nauto index = vertices_.size();\n\nvertices_.insert(vertices_.end(), vertices.begin(), vertices.end());\n\nfor (auto i = index + 2u; i < vertices_.size(); ++i) {\n\ntriangles_.emplace_back(index, i - 1, i);\n\n}\n\n}", "CodeBleu_score": 40.78063480148045}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\n#ifndef NDEBUG\n\nassert(vertices.size() >= 3);\n\n#endif\n\nauto index = m_vertices.size();\n\nm_vertices.insert(m_vertices.end(), vertices.begin(), vertices.end());\n\nfor (std::size_t i = 2u; i < vertices.size(); ++i) {\n\nm_indices.push_back(index);\n\nm_indices.push_back(index + i - 1u);\n\nm_indices.push_back(index + i);\n\n}\n\n}", "CodeBleu_score": 47.492808548139024}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\n#ifndef NDEBUG\n\nassert(vertices.size() >= 3);\n\n#endif\n\nconst vertex_type &v0 = vertices[0];\n\nconst vertex_type &v1 = vertices[1];\n\nconst vertex_type &v2 = vertices[2];\n\nconst uint32_t index0 = AddVertex(v0);\n\nconst uint32_t index1 = AddVertex(v1);\n\nconst uint32_t index2 = AddVertex(v2);\n\nfor (size_t i = 3; i < vertices.size(); ++i) {\n\nconst vertex_type &v3 = vertices[i];\n\nconst uint32_t index3 = AddVertex(v3);\n\nAddTriangle(index0, index1, index2);\n\nindex1 = index2;\n\nindex2 = index3;\n\n}\n\n}", "CodeBleu_score": 38.61158991661724}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\tCARLA_LOG_ERROR(\"Primary\", \"Message is nullptr, not sending.\")\n\t\treturn;\n\t}\n\tif (!message->IsComplete()) {\n\t\tCARLA_LOG_ERROR(\"Primary\", \"Message is not complete, not sending.\")\n\t\treturn;\n\t}\n\tif (message->GetHeader().message_id == carla::streaming::detail::tcp::Message::ID::DISCONNECT) {\n\t\tCARLA_LOG_INFO(\"Primary\", \"Disconnecting.\")\n\t\tboost::asio::post(\n\t\t\t_strand,\n\t\t\t[this]() {\n\t\t\t\t_socket.close();\n\t\t\t}\n\t\t);\n\t\treturn;\n\t}\n\tif (_socket.is_open()) {\n\t\tboost::asio::async_write(\n\t\t\t_socket,\n\t\t\tboost::asio::buffer(message->GetData(), message->GetSize()),\n\t\t\tboost::asio::bind_executor(\n\t\t\t\t_strand,\n\t\t\t\t[this, message](const boost::system::error_code& error, std::size_t bytes_transferred) {\n\t\t\t\t\thandle_sent(error, bytes_transferred, message);\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t}\n}", "CodeBleu_score": 38.0234245851944}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"message is nullptr\");\n\t\treturn;\n\t}\n\n\tif (message->size() > _max_message_size) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"message too big, size = {}\", message->size());\n\t\treturn;\n\t}\n\n\tif (message->size() == 0) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"message size is 0\");\n\t\treturn;\n\t}\n\n\tif (!message->is_valid()) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"message is not valid\");\n\t\treturn;\n\t}\n\n\tif (_socket.is_open()) {\n\t\tboost::asio::async_write(\n\t\t\t\t_socket,\n\t\t\t\tboost::asio::buffer(message->data(), message->size()),\n\t\t\t\tboost::asio::bind_executor(_strand, [this, message](const boost::system::error_code &ec, std::size_t) {\n\t\t\t\t\tif (ec) {\n\t\t\t\t\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"error sending message: {}\", ec.message());\n\t\t\t\t\t\t_socket.close();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_listener.on_sent(message);\n\t\t\t\t\t}\n\t\t\t\t}));\n\t}\n}", "CodeBleu_score": 33.94483706282285}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"null message\");\n\t\treturn;\n\t}\n\tif (message->size() > carla::streaming::detail::tcp::Message::MAX_SIZE) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"message too large\");\n\t\treturn;\n\t}\n\tif (message->size() < carla::streaming::detail::tcp::Message::MIN_SIZE) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"message too small\");\n\t\treturn;\n\t}\n\tif (message->type() > carla::streaming::detail::tcp::Message::Type::MAX_TYPE) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"invalid message type\");\n\t\treturn;\n\t}\n\tif (message->type() < carla::streaming::detail::tcp::Message::Type::MIN_TYPE) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"invalid message type\");\n\t\treturn;\n\t}\n\tif (!message->is_valid()) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"invalid message\");\n\t\treturn;\n\t}\n\tif (!IsConnected()) {\n\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"not connected\");\n\t\treturn;\n\t}\n\tboost::asio::async_write(\n\t\t_socket,\n\t\tboost::asio::buffer(message->data(), message->size()),\n\t\tboost::asio::bind_executor(\n\t\t\t_strand,\n\t\t\t[this, message](boost::system::error_code ec, std::size_t) {\n\t\t\t\tif (ec) {\n\t\t\t\t\tCARLA_LOG_ERROR(\"Primary::Write\", \"write failed: \" + ec.message());\n\t\t\t\t\tClose();\n\t\t\t\t} else {\n\t\t\t\t\tCARLA_LOG_TRACE(\"Primary::Write\", \"write succeeded\");\n\t\t\t\t}\n\t\t\t\t_listener.handle_sent(message, ec);\n\t\t\t}\n\t\t)\n\t);\n}", "CodeBleu_score": 28.11371617427033}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tboost::system::error_code ignored_ec;\n\n\tif (m_deadline_timer) {\n\t\tm_deadline_timer->cancel(ignored_ec);\n\t}\n\n\tif (m_socket.is_open()) {\n\t\tm_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t\tm_socket.close(ignored_ec);\n\t}\n\n\tif (m_on_closed) {\n\t\tm_on_closed(ec);\n\t}\n\n\tCARLA_LOG_INFO(\"Session closed\")\n}", "CodeBleu_score": 52.72860359674466}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (!ec) {\n\t\tif (m_socket.is_open()) {\n\t\t\tboost::system::error_code ec;\n\t\t\tm_deadline.cancel(ec);\n\t\t\tm_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t\tm_socket.close(ec);\n\t\t}\n\t\tif (m_on_closed) {\n\t\t\tm_on_closed();\n\t\t}\n\t\tCARLA_LOG_INFO(\"Primary::CloseNow() : Session closed.\")\n\t}\n}", "CodeBleu_score": 59.37751328363405}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec != boost::system::errc::success) {\n\t\tCARLA_LOG_ERROR(\"Failed to close connection: \" << ec.message());\n\t}\n\telse {\n\t\tCARLA_LOG_DEBUG(\"Connection closed\");\n\t}\n\tdeadline_.cancel();\n\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\tsocket_.close();\n\ton_closed();\n}", "CodeBleu_score": 41.62819341171981}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\n#ifdef DEBUG_IS_ALIVE\n\n  std::cout << \"Sending is alive message\" << std::endl;\n\n#endif\n\n  // Creating the buffer for the message\n\n  std::vector<uint8_t> buffer;\n\n  buffer.reserve(1024);\n\n  // Creating the message\n\n  auto message = carla::streaming::detail::MakeMessage(carla::streaming::detail::Message::Type::COMMAND, carla::streaming::detail::Message::Priority::HIGH);\n\n  message.Add(carla::streaming::detail::MakeToken(carla::streaming::detail::Token::Type::COMMAND, carla::streaming::detail::Token::Subtype::IS_ALIVE));\n\n  // Logging the sending action\n\n  carla::log_info(\"Sending is alive message\")\n\n  // Sending the message to the next router with the command YOU_ALIVE\n\n  _primary.GetRouter().Write(carla::streaming::detail::Command::YOU_ALIVE, std::move(buffer));\n\n  // Waiting for and logging the response\n\n  auto response = _primary.GetRouter().Read();\n\n  carla::log_info(\"Received is alive response\")\n\n}", "CodeBleu_score": 45.5261703710658}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tauto buffer = carla::streaming::detail::tcp::MakeMessage(carla::streaming::detail::tcp::Message::YOU_ALIVE);\n\n\t// Log the sending action\n\tCARLA_LOG_DEBUG(\"Sending message: YOU_ALIVE\");\n\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\t_router.Write(buffer, carla::streaming::detail::Router::Command::YOU_ALIVE);\n\n\t// Wait for and log the response from the system\n\tauto response = _router.Read();\n\tCARLA_LOG_DEBUG(\"Received response: \" + std::string(response.data(), response.size()));\n}", "CodeBleu_score": 46.608028846980396}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\n// The buffer is created from the message.\n  std::vector<uint8_t> buffer = carla::streaming::detail::tcp::MakeBuffer(carla::streaming::detail::tcp::Message::Type::ALIVE);\n\n// The sending action is logged.\n  LOG4CXX_DEBUG(logger_, \"Sending ALIVE message\");\n\n// The buffer is written to the next router with the command YOU_ALIVE.\n  router_->Write(carla::streaming::detail::command::Command::YOU_ALIVE, buffer);\n\n// The response from the system is logged.\n  carla::streaming::detail::tcp::Message response = router_->Read();\n  LOG4CXX_DEBUG(logger_, \"Received \" << response.type << \" message\");\n}", "CodeBleu_score": 42.737337043677734}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Iterate through all the servers in the router\n\tfor (auto &server : _router.GetServers()) {\n\t\t// If the server has the sensor\n\t\tif (server.second.HasSensor(sensor_id)) {\n\t\t\t// Create a buffer with the sensor ID\n\t\t\tauto buffer = std::make_shared<std::vector<uint8_t>>();\n\t\t\tdetail::Write(*buffer, sensor_id);\n\t\t\t// Send an ENABLE_ROS command to the server\n\t\t\t_router.SendTo(server.first, make_command(Command::ENABLE_ROS, buffer));\n\t\t\t// Wait for the server's response\n\t\t\tauto response = _router.ReadFrom(server.first);\n\t\t\t// If the response is not a SUCCESS\n\t\t\tif (response.type() != detail::Response::SUCCESS) {\n\t\t\t\t// Log an error message\n\t\t\t\tlog_error(\"ENABLE_ROS command failed for sensor {} on server {}\", sensor_id, server.first);\n\t\t\t}\n\t\t\t// Return\n\t\t\treturn;\n\t\t}\n\t}\n\t// If the sensor is not found on any server\n\tlog_error(\"Sensor {} not found on any server\", sensor_id);\n}", "CodeBleu_score": 48.051138240470664}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if the sensor is already enabled\n\tif (sensor_id in _enabled_sensors) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already disabled\n\tif (sensor_id in _disabled_sensors) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already enabled on any server\n\tif (sensor_id in _enabled_sensors_on_servers) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already disabled on any server\n\tif (sensor_id in _disabled_sensors_on_servers) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already being enabled\n\tif (sensor_id in _enabling_sensors) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already being disabled\n\tif (sensor_id in _disabling_sensors) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already being enabled on any server\n\tif (sensor_id in _enabling_sensors_on_servers) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already being disabled on any server\n\tif (sensor_id in _disabling_sensors_on_servers) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already being enabled or disabled on any server\n\tif (sensor_id in _enabling_or_disabling_sensors_on_servers) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already being enabled or disabled\n\tif (sensor_id in _enabling_or_disabling_sensors) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already being enabled or disabled on any server\n\tif (sensor_id in _enabling_or_disabling_sensors_on_servers) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already being enabled or disabled\n\tif (sensor_id in _enabling_or_disabling_sensors) {\n\t\treturn;\n\t}\n\n\t// Check if the sensor is not already being enabled or disabled on any server\n\tif (sensor_id in _enabling_or_disabling_sensors_on_servers) {\n\t\treturn", "CodeBleu_score": 26.946856110837263}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tif (sensor_id == stream_id::invalid()) {\n\t\treturn;\n\t}\n\n\t// If the sensor is already enabled, return.\n\tif (sensor_id in _enabled_sensors) {\n\t\treturn;\n\t}\n\n\t// Find the server that contains the sensor.\n\tauto server_id = _router->GetServerIDForSensor(sensor_id);\n\tif (server_id == server_id::invalid()) {\n\t\tlog_error(\"Sensor {} not found on any server.\", sensor_id);\n\t\treturn;\n\t}\n\n\t// Create a buffer with the sensor ID.\n\tauto buffer = std::make_shared<tcp::Message>();\n\tbuffer->Write(sensor_id);\n\n\t// Send the ENABLE_ROS command.\n\t_router->Send(server_id, command::ENABLE_ROS, buffer);\n\n\t// Wait for the response.\n\tauto response = _router->Recv(server_id);\n\tif (response.command != command::ENABLE_ROS_RESPONSE) {\n\t\tlog_error(\"Expected ENABLE_ROS_RESPONSE, got {}.\", response.command);\n\t\treturn;\n\t}\n\n\t// Process the response.\n\tauto sensor_name = response.buffer->Read<std::string>();\n\tauto sensor_type = response.buffer->Read<std::string>();\n\tauto sensor_stream = response.buffer->Read<stream_id>();\n\tauto sensor_transform = response.buffer->Read<rpc::Transform>();\n\n\t// Add the sensor to the list of enabled sensors.\n\t_enabled_sensors.insert(sensor_id);\n\n\t// Create the sensor object.\n\tauto sensor = std::make_shared<Sensor>(sensor_id, sensor_name, sensor_type, sensor_stream, sensor_transform);\n\n\t// Add the sensor to the list of sensors.\n\t_sensors.insert(sensor);\n}", "CodeBleu_score": 41.56310763593261}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// If the sensor is already activated, return the existing token\n\tif (token_map.count(sensor_id) > 0) {\n\t\ttoken_type token = token_map[sensor_id];\n\t\tLOG4CXX_INFO(logger, \"Retrieved token for sensor_id \" << sensor_id << \" (token \" << token << \")\");\n\t\treturn token;\n\t}\n\n\t// If the sensor is not activated, enable the sensor on a secondary server\n\telse {\n\t\t// Send the enable command to a secondary server\n\t\tdetail::EnableSensorCommand enable_command(sensor_id);\n\t\trouter.Send(enable_command);\n\n\t\t// Wait until the sensor is enabled on the secondary server\n\t\tdetail::EnableSensorResponse enable_response;\n\t\trouter.Receive(enable_response);\n\n\t\t// If the sensor is not enabled on the secondary server, throw an exception\n\t\tif (!enable_response.is_enabled) {\n\t\t\tstd::stringstream ss;\n\t\t\tss << \"Sensor with id \" << sensor_id << \" could not be enabled on a secondary server\";\n\t\t\tthrow std::runtime_error(ss.str());\n\t\t}\n\n\t\t// Retrieve a new token\n\t\ttoken_type token = GetNewToken();\n\n\t\t// Update the maps\n\t\ttoken_map[sensor_id] = token;\n\t\tsensor_id_map[token] = sensor_id;\n\n\t\t// Log the action\n\t\tLOG4CXX_INFO(logger, \"Retrieved token for sensor_id \" << sensor_id << \" (token \" << token << \")\");\n\n\t\t// Return the new token\n\t\treturn token;\n\t}\n}", "CodeBleu_score": 42.830868892248375}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\n#ifdef DEBUG_PRIMARY_COMMANDS\n\n  std::cout << \"PrimaryCommands::GetToken(\" << sensor_id << \")\n\";\n\n#endif\n\n  // Get the token for the sensor.\n  auto token = GetTokenFromSensor(sensor_id);\n\n  // If the token is valid, return it.\n  if (token != token_type::invalid) {\n\n    // Log the action.\n    LogAction(sensor_id, token, \"GetToken\");\n\n    return token;\n\n  }\n\n  // If the token is invalid, activate the sensor.\n  if (!ActivateSensor(sensor_id)) {\n\n    // Log the action.\n    LogAction(sensor_id, token, \"GetToken (failed to activate)\");\n\n    return token_type::invalid;\n\n  }\n\n  // Get the token for the sensor.\n  token = GetTokenFromSensor(sensor_id);\n\n  // If the token is valid, return it.\n  if (token != token_type::invalid) {\n\n    // Log the action.\n    LogAction(sensor_id, token, \"GetToken (activated)\");\n\n    return token;\n\n  }\n\n  // If the token is invalid, log the action and return an invalid token.\n  LogAction(sensor_id, token, \"GetToken (failed to get token)\");\n\n  return token_type::invalid;\n\n}", "CodeBleu_score": 37.918583710492285}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\n#ifdef DEBUG_PRIMARY_SERVER\n  std::cout << \"PrimaryCommands::GetToken: \" << sensor_id << std::endl;\n#endif\n\n  auto &sensor_map = _primary.GetSensorMap();\n\n  // Check if sensor is already activated\n  auto it = sensor_map.find(sensor_id);\n\n  if (it != sensor_map.end()) {\n\n    // If so, return existing token\n    token_type token = it->second.token;\n\n#ifdef DEBUG_PRIMARY_SERVER\n    std::cout << \"PrimaryCommands::GetToken: \" << sensor_id << \" is already activated. Returning existing token \" << token << std::endl;\n#endif\n\n    return token;\n\n  }\n\n  // If not, activate sensor on a secondary server\n  auto &router = _primary.GetRouter();\n\n  // Get secondary server\n  auto &secondary_server = router.GetSecondaryServer();\n\n  // Create a command to enable the sensor\n  auto command = std::make_shared<EnableSensor>(sensor_id);\n\n  // Send command to secondary server\n  secondary_server.SendCommand(command);\n\n  // Wait for reply\n  auto reply = command->GetReply();\n\n  // Check if reply is valid\n  if (reply) {\n\n    // If so, get token\n    token_type token = reply->Get();\n\n#ifdef DEBUG_PRIMARY_SERVER\n    std::cout << \"PrimaryCommands::GetToken: \" << sensor_id << \" is now activated. Returning new token \" << token << std::endl;\n#endif\n\n    // Update sensor map\n    sensor_map.insert(std::make_pair(sensor_id, SensorState(token)));\n\n    // Log action\n    _primary.GetLog().Log(sensor_id, token, Log::Action::SENSOR_ENABLED);\n\n    return token;\n\n  }\n\n  // If not, return invalid token\n  token_type token = INVALID_TOKEN;\n\n#ifdef DEBUG_PRIMARY_SERVER\n  std::cout << \"PrimaryCommands::GetToken: \" << sensor_id << \" is not activated. Returning invalid token \" << token << std::endl;\n#endif\n\n  return token;\n\n}", "CodeBleu_score": 45.19472494395007}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (file.is_open()) {\n\t\tfile.seekg(0, std::ios::end);\n\t\tauto size = file.tellg();\n\t\tfile.seekg(0, std::ios::beg);\n\t\tstd::vector<uint8_t> data(size);\n\t\tfile.read(reinterpret_cast<char *>(data.data()), size);\n\t\tfile.close();\n\t\treturn Load(data);\n\t}\n\treturn false;\n}", "CodeBleu_score": 49.52270662111647}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (file.is_open()) {\n\t\tstd::vector<unsigned char> file_data((std::istreambuf_iterator<char>(file)), (std::istreambuf_iterator<char>()));\n\t\tfile.close();\n\t\treturn Load(file_data);\n\t}\n\treturn false;\n}", "CodeBleu_score": 48.77504953282211}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file;\n\tfile.open(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> file_data((std::istreambuf_iterator<char>(file)), (std::istreambuf_iterator<char>()));\n\tfile.close();\n\treturn Load(file_data);\n}", "CodeBleu_score": 61.38420959418962}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tstd::unique_lock<std::recursive_mutex> lock(_mutex);\n\tassert(_crowd != nullptr);\n\tif (_ready) {\n\t\tauto it = _walker_manager.FindAgent(id);\n\t\tif (it != _walker_manager.end()) {\n\t\t\t_walker_manager.RemoveAgent(it);\n\t\t\treturn true;\n\t\t}\n\t\tit = _vehicle_manager.FindAgent(id);\n\t\tif (it != _vehicle_manager.end()) {\n\t\t\t_vehicle_manager.RemoveAgent(it);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 47.75407784455048}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tstd::lock_guard<std::recursive_mutex> lock(mutex_);\n\tif (!ready_) {\n\t\treturn false;\n\t}\n\tif (crowd_ == nullptr) {\n\t\treturn false;\n\t}\n\n\tbool found = false;\n\tauto it = std::find(agent_ids_.begin(), agent_ids_.end(), id);\n\tif (it != agent_ids_.end()) {\n\t\tfound = true;\n\t\tagent_ids_.erase(it);\n\t}\n\n\tif (found) {\n\t\tauto walker_it = walker_manager_.find(id);\n\t\tif (walker_it != walker_manager_.end()) {\n\t\t\twalker_manager_.erase(walker_it);\n\t\t}\n\t\telse {\n\t\t\tauto vehicle_it = vehicle_manager_.find(id);\n\t\t\tif (vehicle_it != vehicle_manager_.end()) {\n\t\t\t\tvehicle_manager_.erase(vehicle_it);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}", "CodeBleu_score": 50.35631256675367}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tassert(crowd != nullptr);\n\tbool result = false;\n\tif (IsReady()) {\n\t\tif (id in walker_map) {\n\t\t\tauto it = walker_map.find(id);\n\t\t\tauto w = it->second;\n\t\t\tcrowd->removeAgent(w);\n\t\t\twalker_manager->RemoveWalker(w);\n\t\t\twalker_map.erase(it);\n\t\t\tresult = true;\n\t\t}\n\t\telse if (id in vehicle_map) {\n\t\t\tauto it = vehicle_map.find(id);\n\t\t\tauto v = it->second;\n\t\t\tcrowd->removeAgent(v);\n\t\t\tvehicle_manager->RemoveVehicle(v);\n\t\t\tvehicle_map.erase(it);\n\t\t\tresult = true;\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 45.201134934983216}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n\tstd::set<std::string> mapped_vehicles;\n\t{\n\t\tstd::lock_guard<std::mutex> lock(vehicles_mutex_);\n\t\tfor (auto it = vehicles_.begin(); it != vehicles_.end(); ++it) {\n\t\t\tmapped_vehicles.insert(it->first);\n\t\t}\n\t}\n\tfor (auto const &vehicle : vehicles) {\n\t\tif (vehicle.other_actor_id != vehicle.actor_id) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"ego\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_actor\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_vehicle\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_walker\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_vehicle_controller\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_walker_controller\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_walker_controller_0\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_walker_controller_1\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_walker_controller_2\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_walker_controller_3\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_walker_controller_4\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_walker_controller_5\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_walker_controller_6\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.other_actor_id == \"hero_walker_controller_7\") {", "CodeBleu_score": 33.01368287318591}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    // TODO: this is a naive implementation, but it works for now.\n  std::set<carla::client::Vehicle> vehicles_set;\n  for (auto vehicle : _vehicles) {\n    vehicles_set.insert(vehicle.second);\n  }\n\n  for (auto vehicle_collision : vehicles) {\n    auto vehicle_id = vehicle_collision.vehicle_id;\n    auto vehicle = vehicle_collision.vehicle;\n\n    if (vehicle_id == 0) {\n      continue;\n    }\n\n    auto vehicle_it = _vehicles.find(vehicle_id);\n    if (vehicle_it == _vehicles.end()) {\n      auto vehicle_state = VehicleState{vehicle, vehicle_collision.location, vehicle_collision.velocity, vehicle_collision.yaw};\n      _vehicles.insert(std::make_pair(vehicle_id, vehicle_state));\n    } else {\n      vehicle_it->second.Update(vehicle, vehicle_collision.location, vehicle_collision.velocity, vehicle_collision.yaw);\n    }\n\n    vehicles_set.erase(vehicle);\n  }\n\n  for (auto vehicle : vehicles_set) {\n    auto vehicle_state = _vehicles.find(vehicle.GetId());\n    if (vehicle_state != _vehicles.end()) {\n      _vehicles.erase(vehicle_state);\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 51.7280534322339}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n\tstd::set<ActorId> current_vehicles;\n\tfor (auto vehicle : _vehicles) {\n\t\tcurrent_vehicles.insert(vehicle.actor_id);\n\t}\n\n\tfor (auto vehicle : vehicles) {\n\t\tif (vehicle.actor_id == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (current_vehicles.find(vehicle.actor_id) == current_vehicles.end()) {\n\t\t\t_vehicles.push_back(vehicle);\n\t\t}\n\t\telse {\n\t\t\tauto it = std::find_if(_vehicles.begin(), _vehicles.end(), [vehicle](const VehicleCollisionInfo &v) {\n\t\t\t\treturn v.actor_id == vehicle.actor_id;\n\t\t\t});\n\t\t\t*it = vehicle;\n\t\t}\n\t}\n\n\tfor (auto it = _vehicles.begin(); it != _vehicles.end();) {\n\t\tif (it->actor_id == 0 || it->time_stamp < _time_stamp) {\n\t\t\tit = _vehicles.erase(it);\n\t\t}\n\t\telse {\n\t\t\t++it;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.83258918350164}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\t// Check if the actor is in the mapped walkers.\n\tauto walker = walkers.find(id);\n\tif (walker != walkers.end()) {\n\t\t// If it is, return the result of the crowd system.\n\t\treturn walker->second.HasVehicleNear(distance, direction);\n\t}\n\t// Check if the actor is in the mapped vehicles.\n\tauto vehicle = vehicles.find(id);\n\tif (vehicle != vehicles.end()) {\n\t\t// If it is, return the result of the crowd system.\n\t\treturn vehicle->second.HasVehicleNear(distance, direction);\n\t}\n\t// If it is not, return false.\n\treturn false;\n}", "CodeBleu_score": 49.63564130322292}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::recursive_mutex> lock(_mutex);\n\n\tif (id == 0) {\n\t\treturn false;\n\t}\n\n\tauto actor = GetActor(id);\n\tif (actor == nullptr) {\n\t\treturn false;\n\t}\n\n\tauto walker = std::dynamic_pointer_cast<Walker>(actor);\n\tif (walker != nullptr) {\n\t\treturn _walker_manager.HasVehicleNear(walker, distance, direction);\n\t}\n\n\tauto vehicle = std::dynamic_pointer_cast<Vehicle>(actor);\n\tif (vehicle != nullptr) {\n\t\treturn _crowd_manager.HasVehicleNear(vehicle, distance, direction);\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 46.501159442994506}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::mutex> lock(this->mutex);\n\n\tbool result = false;\n\n\tauto it = this->vehicles.find(id);\n\tif (it != this->vehicles.end()) {\n\t\tresult = this->crowd.IsVehicleNear(it->second, distance * distance, direction);\n\t}\n\n\tif (!result) {\n\t\tit = this->walkers.find(id);\n\t\tif (it != this->walkers.end()) {\n\t\t\tresult = this->crowd.IsVehicleNear(it->second, distance * distance, direction);\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 46.553056805978365}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\n// \tauto &walker_actor = GetActor(id);\n// \tauto &walker_state = walker_actor.state;\n// \tauto &walker_control = walker_actor.control;\n\n// \tauto &route = info.route;\n// \tauto &route_point = route[info.route_index];\n\n// \tauto &waypoint = GetWaypoint(route_point.waypoint_id);\n\n// \tauto result = EventResult::Continue;\n\n// \tWalkerEventVisitor visitor(id, info, delta);\n// \tboost::variant2::visit(visitor, route_point.event);\n\n// \treturn result;\n}", "CodeBleu_score": 9.085804425133198}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tif (info.route.empty()) {\n\t\treturn EventResult::Success;\n\t}\n\n\tauto &route = info.route;\n\tauto &waypoint = route.front();\n\tauto &location = waypoint.GetLocation();\n\tauto &transform = waypoint.GetTransform();\n\n\tWalkerEventVisitor visitor(info, delta);\n\treturn boost::apply_visitor(visitor, waypoint.GetEvent());\n}", "CodeBleu_score": 40.92393073260161}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto &walker = info.walker;\n\tauto &route = info.route;\n\tauto &waypoint = route.front();\n\tauto &context = info.context;\n\tauto &state = info.state;\n\tauto &event_queue = info.event_queue;\n\tauto &event_queue_lock = info.event_queue_lock;\n\tauto &event_visitor = info.event_visitor;\n\n\t// Get the current route point.\n\tauto current_route_point = waypoint;\n\n\t// Create a visitor to process the event.\n\tauto visitor = event_visitor;\n\tvisitor.context = &context;\n\tvisitor.state = &state;\n\tvisitor.delta = delta;\n\tvisitor.route = &route;\n\tvisitor.walker = &walker;\n\tvisitor.current_route_point = &current_route_point;\n\tvisitor.event_queue = &event_queue;\n\tvisitor.event_queue_lock = &event_queue_lock;\n\n\t// Process the event.\n\tauto result = boost::variant2::visit(visitor, waypoint.event);\n\n\t// If the event was processed, update the route.\n\tif (result.type != EventStatus::InProgress) {\n\t\t// If the event was not processed, remove the route point.\n\t\troute.pop_front();\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 43.62786053975511}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node and process each lane section\nfor (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"road\")) {\n  std::string road_id = road_node.attribute(\"id\").value();\n  for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n    std::string lane_section_id = lane_section_node.attribute(\"id\").value();\n    for (pugi::xml_node lane_node : lane_section_node.children(\"lane\")) {\n      std::string lane_id = lane_node.attribute(\"id\").value();\n      ParseLanes(lane_node, map_builder, road_id, lane_section_id, lane_id);\n    }\n  }\n}\n}", "CodeBleu_score": 40.69857086348196}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\t// Iterate through each road node.\n\tfor (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"ROAD\")) {\n\t\t// Retrieve the road ID.\n\t\tauto road_id = road_node.attribute(\"id\").as_uint();\n\n\t\t// Iterate through each lane section node.\n\t\tfor (pugi::xml_node lane_section_node : road_node.child(\"LANES\").child(\"LANESECTIONS\").children(\"LANESECTION\")) {\n\t\t\t// Retrieve the lane section ID.\n\t\t\tauto lane_section_id = lane_section_node.attribute(\"id\").as_uint();\n\n\t\t\t// Iterate through each left lane node.\n\t\t\tfor (pugi::xml_node left_lane_node : lane_section_node.child(\"LEFT\").children(\"LANE\")) {\n\t\t\t\t// Parse the left lane node.\n\t\t\t\tParseLane(left_lane_node, road_id, lane_section_id, true, map_builder);\n\t\t\t}\n\n\t\t\t// Iterate through each center lane node.\n\t\t\tfor (pugi::xml_node center_lane_node : lane_section_node.child(\"CENTER\").children(\"LANE\")) {\n\t\t\t\t// Parse the center lane node.\n\t\t\t\tParseLane(center_lane_node, road_id, lane_section_id, false, map_builder);\n\t\t\t}\n\n\t\t\t// Iterate through each right lane node.\n\t\t\tfor (pugi::xml_node right_lane_node : lane_section_node.child(\"RIGHT\").children(\"LANE\")) {\n\t\t\t\t// Parse the right lane node.\n\t\t\t\tParseLane(right_lane_node, road_id, lane_section_id, false, map_builder);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 52.41294749726367}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\tfor (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"road\")) {\n\t\tauto road_id = road_node.attribute(\"id\").as_uint();\n\t\tfor (pugi::xml_node lane_node : road_node.child(\"lanes\").children(\"lane\")) {\n\t\t\tauto lane_id = lane_node.attribute(\"id\").as_uint();\n\t\t\tauto lane_type = lane_node.attribute(\"type\").as_string();\n\t\t\tauto level = lane_node.attribute(\"level\").as_uint();\n\t\t\tauto predecessor = lane_node.attribute(\"predecessor\").as_uint();\n\t\t\tauto successor = lane_node.attribute(\"successor\").as_uint();\n\t\t\tauto left_neighbor = lane_node.attribute(\"left\").as_uint();\n\t\t\tauto right_neighbor = lane_node.attribute(\"right\").as_uint();\n\t\t\tauto left_lane_marking = lane_node.attribute(\"left_lane_marking\").as_string();\n\t\t\tauto right_lane_marking = lane_node.attribute(\"right_lane_marking\").as_string();\n\t\t\tauto left_lane_marking_color = lane_node.attribute(\"left_lane_marking_color\").as_string();\n\t\t\tauto right_lane_marking_color = lane_node.attribute(\"right_lane_marking_color\").as_string();\n\t\t\tauto center_lane_marking_type = lane_node.attribute(\"center_lane_marking_type\").as_string();\n\t\t\tauto center_lane_marking_color = lane_node.attribute(\"center_lane_marking_color\").as_string();\n\t\t\tauto lane_width = lane_node.attribute(\"width\").as_double();\n\t\t\tauto lane_width_inner = lane_node.attribute(\"width_inner\").as_double();\n\t\t\tauto lane_width_outer = lane_node.attribute(\"width_outer\").as_double();\n\t\t\tauto lane_edge_type = lane_node.attribute(\"edge_type\").as_string();\n\t\t\tauto lane_connection_id = lane_node.attribute(\"connection_id\").as_uint();\n\t\t\tauto lane_inner_border_type = lane_node.attribute(\"inner_border", "CodeBleu_score": 41.834564030121015}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tif (info.total_count == 1) {\n\t\t\tstd::cout << \"New match detected on topic \" << writer->get_topic_name() << std::endl;\n\t\t\t_matched = true;\n\t\t\t_first_connection = true;\n\t\t} else {\n\t\t\tstd::cout << \"Match lost on topic \" << writer->get_topic_name() << std::endl;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tif (info.total_count == 0) {\n\t\t\tstd::cout << \"No more matches on topic \" << writer->get_topic_name() << std::endl;\n\t\t\t_matched = false;\n\t\t} else if (info.total_count > 1) {\n\t\t\tstd::cout << \"Error: Current count change is -1, but total count is \" << info.total_count << std::endl;\n\t\t}\n\t} else {\n\t\tstd::cout << \"Error: Current count change is \" << info.current_count_change << \", but total count is \" << info.total_count << std::endl;\n\t}\n}", "CodeBleu_score": 51.623640621138}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tstd::cout << \"DataWriter \" << writer->guid().guidPrefix << \" matched\" << std::endl;\n\t\tmatched_ = true;\n\t\tfirst_connection_ = true;\n\t} else if (info.current_count_change == -1) {\n\t\tstd::cout << \"DataWriter \" << writer->guid().guidPrefix << \" unmatched\" << std::endl;\n\t\tmatched_ = false;\n\t\tfirst_connection_ = false;\n\t} else if (info.current_count_change == 0) {\n\t\tif (info.total_count == 0) {\n\t\t\tstd::cout << \"DataWriter \" << writer->guid().guidPrefix << \" unmatched\" << std::endl;\n\t\t\tmatched_ = false;\n\t\t\tfirst_connection_ = false;\n\t\t} else {\n\t\t\tstd::cout << \"DataWriter \" << writer->guid().guidPrefix << \" matched\" << std::endl;\n\t\t\tmatched_ = true;\n\t\t}\n\t} else {\n\t\tstd::cout << \"DataWriter \" << writer->guid().guidPrefix << \" changed status, but doesn't match\" << std::endl;\n\t}\n}", "CodeBleu_score": 56.13604592720633}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tif (info.total_count == 1) {\n\t\t\tfirstConnection = true;\n\t\t}\n\t\t++matched;\n\t} else if (info.current_count_change == -1) {\n\t\t--matched;\n\t} else {\n\t\tstd::cout << \"Unexpected PublicationMatchedStatus\" << std::endl;\n\t}\n}", "CodeBleu_score": 54.13847538883634}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t_matched_readers.insert(reader);\n\t\tif (_matched_readers.size() == 1) {\n\t\t\t_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t_matched_readers.erase(reader);\n\t\tif (_matched_readers.size() == 0) {\n\t\t\tdestroy_subscription();\n\t\t}\n\t} else {\n\t\tstd::cout << \"Received an unexpected number of matches: \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 53.608556404989415}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tstd::cout << \"New match discovered on reader \" << reader->get_name() << std::endl;\n\t\tif (info.total_count == 1) {\n\t\t\tstd::cout << \"First match!\" << std::endl;\n\t\t\t_first_connected = true;\n\t\t}\n\t\t_matched += info.current_count_change;\n\t} else if (info.current_count_change == -1) {\n\t\tstd::cout << \"Match lost on reader \" << reader->get_name() << std::endl;\n\t\t_matched += info.current_count_change;\n\t\tif (_matched == 0) {\n\t\t\tstd::cout << \"No more matches!\" << std::endl;\n\t\t\t_destroy_subscriber = true;\n\t\t}\n\t} else {\n\t\tstd::cout << \"Error: Invalid matched count change \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 55.18205918089738}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t_matched_count++;\n\t\tif (_matched_count == 1) {\n\t\t\t_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t_matched_count--;\n\t\tif (_matched_count == 0) {\n\t\t\t_subscriber.reset();\n\t\t}\n\t} else {\n\t\tRCLCPP_ERROR(get_logger(), \"Error in SubscriptionMatchedStatus: %d\", info.current_count_change);\n\t}\n}", "CodeBleu_score": 56.97145275410682}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\n\tCarlaCollisionEvent* p_type = (CarlaCollisionEvent*) data;\n\n\t// Get MD5 sum if forced\n\tif (force_md5 || !m_isKeyDefined) {\n\t\tMD5 md5;\n\t\tmd5.update((uint8_t*) p_type);\n\t\tmd5.finalize();\n\t\t*handle = md5.get();\n\t\treturn true;\n\t}\n\n\t// Copy key into handle\n\tmemcpy(handle, &m_key, sizeof(InstanceHandle_t));\n\treturn true;\n}", "CodeBleu_score": 23.40203960188042}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\n\tCarlaCollisionEvent* p_type = (CarlaCollisionEvent*) data;\n\n\t// Get MD5 from key\n\tMD5 md5;\n\tmd5.update((unsigned char*)&p_type->actor_id, sizeof(p_type->actor_id));\n\tmd5.update((unsigned char*)&p_type->other_actor_id, sizeof(p_type->other_actor_id));\n\tmd5.update((unsigned char*)&p_type->normal_impulse, sizeof(p_type->normal_impulse));\n\tmd5.update((unsigned char*)&p_type->penetration_depth, sizeof(p_type->penetration_depth));\n\tmd5.update((unsigned char*)&p_type->location, sizeof(p_type->location));\n\tmd5.update((unsigned char*)&p_type->other_location, sizeof(p_type->other_location));\n\tmd5.update((unsigned char*)&p_type->time_of_impact, sizeof(p_type->time_of_impact));\n\tmd5.final(handle->bytes);\n\n\treturn true;\n}", "CodeBleu_score": 21.97384497385}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t#ifdef FASTCDR_HAS_KEY_MEMBER_\n    if (false) {\n    } else if ((((CarlaCollisionEvent*)data)->_d != 0) && (!force_md5)) {\n        *handle = ((CarlaCollisionEvent*)data)->_d;\n        return true;\n    } else {\n        CarlaCollisionEventPubSubType::MD5 obj_md5;\n        obj_md5.update((char*)data, ((CarlaCollisionEvent*)data)->_d);\n        for (uint32_t i = 0; i < 16; ++i) {\n            handle->at(i) = obj_md5.digest[i];\n        }\n        return true;\n    }\n#else\n    (void)data;\n    (void)handle;\n    (void)force_md5;\n    return false;\n#endif\n}", "CodeBleu_score": 33.560430349664024}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\t// Allocate the serialized payload object\n\t*payload = new SerializedPayload(payloadMaxSize);\n\t// Create a CDR serialization object\n\tcdr = new eprosima::fastcdr::Cdr();\n\t// Set the fast buffer with the allocated memory\n\tcdr->set_buffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\t// Set the data reference to the data.\n\tcdr->set_data(reinterpret_cast<char*>(data));\n\n\tif (cdr->alignment() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS) {\n\t\tcdr->set_endianness(eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\t} else {\n\t\tcdr->set_endianness(eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS);\n\t}\n\n\ttry {\n\t\t// Serialize the object\n\t\tcdr->serialize_type<fastdds::dds::BuiltinTopicKey_t>(m_key);\n\n\t\tcdr->serialize_type<uint8_t>(m_control.throttle);\n\n\t\tcdr->serialize_type<uint8_t>(m_control.steer);\n\n\t\tcdr->serialize_type<uint8_t>(m_control.brake);\n\n\t\tcdr->serialize_type<uint8_t>(m_control.hand_brake);\n\n\t\tcdr->serialize_type<uint8_t>(m_control.reverse);\n\n\t\tcdr->serialize_type<uint8_t>(m_control.manual_gear_shift);\n\n\t\tcdr->serialize_type<int8_t>(m_control.gear);\n\n\t\tcdr->serialize_type<float>(m_control.manual_gear_shift);\n\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 58.37415275935556}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\t(void)payload;\n\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\n\t// Create a zero-copy buffer for serialization\n\t// Endianness does not matter here, as we use memcpy\n\t// to copy the bytes from the serialized payload\n\t// to the newly allocated buffer.\n\tFastBuffer fastbuffer(256);\n\t// Create a CDR serialization object\n\tCdr cdr(fastbuffer);\n\n\t// Serialize encapsulation\n\tcdr << p_type->encapsulation();\n\n\t// Serialize the object\n\tcdr << p_type->header();\n\tcdr << p_type->throttle();\n\tcdr << p_type->steer();\n\tcdr << p_type->brake();\n\tcdr << p_type->hand_brake();\n\tcdr << p_type->reverse();\n\tcdr << p_type->manual_gear_shift();\n\tcdr << p_type->gear();\n\n\t// Get serialized payload size\n\tuint32_t payloadSize = cdr.getSerializedDataLength();\n\t// Allocate a buffer\n\tuint8_t* buffer = (uint8_t*) malloc(payloadSize);\n\t// Copy serialized data into the buffer\n\tmemcpy(buffer, fastbuffer.getBuffer(), payloadSize);\n\t// Update the payload\n\tpayload->data = buffer;\n\tpayload->length = payloadSize;\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 43.476836140319065}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\t(void)payload;\n\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\n\t// Create and initialize serialization-related members.\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\teprosima::fastcdr::Cdr cdr(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = CDR_LE;\n\t// Serialize encapsulation\n\ttry {\n\t\tcdr.serialize_encapsulation();\n\n\t\t// Serialize the object.\n\t\tcdr << *p_type;\n\t}\n\tcatch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 53.97410219213161}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// Check if the target has been set already\n\tif(target_set) {\n\t\treturn;\n\t}\n\n\t// Decode the message\n\tmavlink_message_t msg_decoded;\n\tmavlink_msg_gps_raw_int_decode(&msg_decoded, &msg);\n\n\t// Check if the message type is one that should be tracked\n\tif(msg_decoded.msgid != MAVLINK_MSG_ID_GPS_RAW_INT) {\n\t\treturn;\n\t}\n\n\t// Check if the target system ID is set\n\tif(target_sysid == 0) {\n\t\ttarget_sysid = msg_decoded.sysid;\n\n\t\t// Request the position and air pressure data streams from the target\n\t\ttracker->mavlink_send_request_data_stream(target_sysid, MAVLINK_DATA_STREAM_POSITION, 1, 1, 1);\n\t\ttracker->mavlink_send_request_data_stream(target_sysid, MAVLINK_DATA_STREAM_PRESSURE, 1, 1, 1);\n\t}\n\n\t// Flag that the target has been set\n\ttarget_set = true;\n}", "CodeBleu_score": 32.0089201791865}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// If the target is already set, exit immediately\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// Decode the MAVLink message\n\tmavlink_message_t msg_decoded;\n\tmavlink_msg_command_long_decode(&msg, &msg_decoded);\n\n\t// If the message type is not one that should be tracked, exit\n\tif (msg_decoded.msgid != MAVLINK_MSG_ID_COMMAND_LONG) {\n\t\treturn;\n\t}\n\n\t// If the target system ID is not set, set the sysid to the target and request position and air pressure data streams from the target\n\tif (msg_decoded.sysid == 0) {\n\t\ttarget_sysid = msg_decoded.compid;\n\t\ttarget_set = true;\n\t\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_DATA_STREAM_POSITION, 1, 1);\n\t\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_DATA_STREAM_PRESSURE, 1, 1);\n\t}\n}", "CodeBleu_score": 35.28006148297177}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\tif (msg.msgid == MAVLINK_MSG_ID_GLOBAL_POSITION_INT) {\n\t\tmavlink_global_position_int_t pos;\n\t\tmavlink_msg_global_position_int_decode(&msg, &pos);\n\n\t\tif (pos.target_system == 0) {\n\t\t\tpos.target_system = pos.system_id;\n\t\t}\n\n\t\tif (pos.target_system == target_system) {\n\t\t\ttarget_set = true;\n\t\t\ttarget_system = pos.target_system;\n\t\t\ttarget_component = pos.target_component;\n\t\t\ttarget_alt = pos.relative_alt;\n\t\t\ttarget_lat = pos.lat * 1e-7;\n\t\t\ttarget_lon = pos.lon * 1e-7;\n\t\t\ttarget_alt_var = pos.abs_alt_variance;\n\t\t\ttarget_pos_var = pos.abs_pos_variance;\n\t\t\ttarget_hdg = pos.hdg;\n\t\t\ttarget_hdg_var = pos.hdg_variance;\n\t\t\ttarget_vel = sqrt(pos.vx * pos.vx + pos.vy * pos.vy);\n\t\t\ttarget_vel_var = pos.v_variance;\n\t\t\ttarget_acc_var = pos.h_acc;\n\t\t\ttarget_acc = sqrt(pos.vx_acc * pos.vx_acc + pos.vy_acc * pos.vy_acc);\n\t\t\ttarget_acc_var = pos.h_acc;\n\t\t\ttarget_time = pos.time_boot_ms;\n\n\t\t\tif (pos.time_boot_ms > 0) {\n\t\t\t\ttarget_time_valid = true;\n\t\t\t}\n\n\t\t\tif (target_system == 0) {\n\t\t\t\ttarget_system = pos.system_id;\n\t\t\t}\n\n\t\t\tif (target_system == 0) {\n\t\t\t\ttarget_system = pos.target_system;\n\t\t\t}\n\n\t\t\tif (target_component == 0) {\n\t\t\t\ttarget_component = pos.target_component;\n\t\t\t}\n\n\t\t\tif (target_alt == 0) {\n\t\t\t\ttarget_alt = pos.relative_alt;\n\t\t\t}\n\n\t\t\tif (target_lat == ", "CodeBleu_score": 33.65783747337015}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.5051219441432}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_altitude_calibration_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 53.43449346741591}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\tmavlink_command_long_t command;\n\tmavlink_msg_command_long_decode(&msg, &command);\n\tif (command.command == MAV_CMD_PREFLIGHT_CALIBRATION) {\n\t\tresult = GCS_MAVLINK::handle_command_preflight_calibration(msg);\n\t\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t\t_need_altitude_calibration = true;\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.86566133182663}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n\t// Check if the component is present\n\tif (packet.target_system == m_sysid && packet.target_component == m_compid) {\n\t\t// Check if the command is supported\n\t\tif (packet.command == MAV_CMD_COMPONENT_ARM_DISARM) {\n\t\t\t// Check if the command parameter is 1.0\n\t\t\tif (packet.param1 == 1.0) {\n\t\t\t\t// Arm the servos\n\t\t\t\tarmServos();\n\t\t\t\tresult = MAV_RESULT_ACCEPTED;\n\t\t\t}\n\t\t\t// Check if the command parameter is 0.0\n\t\t\telse if (packet.param1 == 0.0) {\n\t\t\t\t// Disarm the servos\n\t\t\t\tdisarmServos();\n\t\t\t\tresult = MAV_RESULT_ACCEPTED;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 47.52358290127023}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\tarm();\n\t} else if (packet.param1 == 0.0) {\n\t\tdisarm();\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 34.7478292815951}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 != 0.0 && packet.param1 != 1.0) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\tif (packet.param1 == 1.0) {\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tservo_tracker.set_servo_enabled(i, true);\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tservo_tracker.set_servo_enabled(i, false);\n\t\t}\n\t}\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 48.5997563517339}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over all channels\n\tfor (uint8_t i = 0; i < _gcs_channels; i++) {\n\t\t// Check if there is space available in the payload\n\t\tif (_gcs_channels_payload_space[i] >= 4) {\n\t\t\t// Set the payload space to zero\n\t\t\t_gcs_channels_payload_space[i] = 0;\n\t\t\t// Set the payload type to position\n\t\t\t_gcs_channels_payload_type[i] = PAYLOAD_TYPE_POSITION;\n\t\t\t// Set the payload data\n\t\t\t_gcs_channels_payload[i][0] = sysid;\n\t\t\t_gcs_channels_payload[i][1] = compid;\n\t\t\t_gcs_channels_payload[i][2] = i;\n\t\t\t_gcs_channels_payload[i][3] = 0;\n\t\t\t// Send the request to start the data stream\n\t\t\t_gcs_channels_payload_length[i] = 4;\n\t\t\t_gcs_channels_payload_request_counter[i] = 0;\n\t\t\t_gcs_channels_payload_request_sent[i] = true;\n\t\t\t_gcs_channels_payload_request_acknowledged[i] = false;\n\t\t\t_gcs_channels_payload_request_failed[i] = false;\n\t\t\t_gcs_channels_payload_request_timeout[i] = false;\n\t\t\t_gcs_channels_payload_request_timeout_counter[i] = 0;\n\t\t\t_gcs_channels_payload_request_timeout_max[i] = 10;\n\t\t\t_gcs_channels_payload_request_timeout_max_counter[i] = 0;\n\t\t\t_gcs_channels_payload_request_timeout_max_timeout[i] = 5000;\n\t\t\t_gcs_channels_payload_request_timeout_max_timeout_counter[i] = 0;\n\t\t\t_gcs_channels_payload_request_timeout_max_timeout_max[i] = 10000;\n\t\t\t_gcs_channels_payload_request_timeout_max_timeout_max_counter[i] = 0;\n\t\t\t_gcs_", "CodeBleu_score": 37.35041578761594}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tuint8_t i;\n\tuint8_t found_space = 0;\n\n\t// Iterate over all available channels\n\tfor (i = 0; i < CHANNEL_COUNT; i++) {\n\t\t// Check if there is space available on the channel\n\t\tif (channels[i].available_space > 0) {\n\t\t\t// Set the channel to the correct system ID and component ID\n\t\t\tchannels[i].system_id = sysid;\n\t\t\tchannels[i].component_id = compid;\n\n\t\t\t// Send the request to start streaming the position data\n\t\t\tchannels[i].request_datastream_position();\n\n\t\t\t// Update the available space\n\t\t\tchannels[i].available_space -= 3;\n\n\t\t\t// Update the available data\n\t\t\tavailable_data -= 3;\n\n\t\t\t// Update the number of streams\n\t\t\tstreams += 1;\n\n\t\t\t// Update the number of streams with position data\n\t\t\tstreams_with_position += 1;\n\n\t\t\t// Set the flag\n\t\t\tfound_space = 1;\n\n\t\t\t// Break from the loop\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Check if there was no space available\n\tif (!found_space) {\n\t\t// Throw an exception\n\t\tthrow std::runtime_error(\"No space available for a new stream\");\n\t}\n}", "CodeBleu_score": 31.957198232152972}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tuint8_t channel_id = 0;\n\tuint8_t payload_size = 0;\n\tuint16_t update_rate = 0;\n\tuint8_t available_channels[8] = {0};\n\tuint8_t available_payloads[8] = {0};\n\tuint8_t available_update_rates[8] = {0};\n\tuint8_t available_channels_count = 0;\n\tuint8_t available_payloads_count = 0;\n\tuint8_t available_update_rates_count = 0;\n\tuint8_t request_channel_id = 0;\n\tuint8_t request_payload_size = 0;\n\tuint16_t request_update_rate = 0;\n\tuint8_t request_channel_id_index = 0;\n\tuint8_t request_payload_size_index = 0;\n\tuint8_t request_update_rate_index = 0;\n\n\t// Iterate over all available channels\n\twhile (channel_id < 8) {\n\t\t// Check if channel is available\n\t\tif (m_tracker.get_channel_status(channel_id) == true) {\n\t\t\t// Check if payload space is available\n\t\t\tif (m_tracker.get_payload_size(channel_id) > 0) {\n\t\t\t\t// Add channel ID to list of available channels\n\t\t\t\tavailable_channels[available_channels_count] = channel_id;\n\t\t\t\tavailable_channels_count++;\n\t\t\t}\n\t\t}\n\n\t\tchannel_id++;\n\t}\n\n\t// Iterate over all available payload sizes\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\t// Check if payload space is available\n\t\tif (m_tracker.get_payload_size(i) > 0) {\n\t\t\t// Add payload size to list of available payload sizes\n\t\t\tavailable_payloads[available_payloads_count] = m_tracker.get_payload_size(i);\n\t\t\tavailable_payloads_count++;\n\t\t}\n\t}\n\n\t// Iterate over all available update rates\n\tfor (uint8_t i = 0; i < 8; i++) {", "CodeBleu_score": 29.76288065573149}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Retrieve the AHRS instance\n\tAHRS *ahrs = Tracker::get_ahrs();\n\t// Check for a zero pitch cosine to avoid division by zero\n\tif (ahrs->GetPitchCos() == 0.0) {\n\t\treturn false;\n\t}\n\t// Calculate the earth frame pitch and yaw using trigonometric conversions\n\tef_pitch = atan2(ahrs->GetPitchCos() * tan(pitch), ahrs->GetPitchSin());\n\tef_yaw = yaw + ahrs->GetYawOffset();\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 45.83209137530181}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS *ahrs = Tracker::get_ahrs();\n\tif (ahrs->GetPitch() == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = -asin(ahrs->GetPitch() * cos(yaw) / ahrs->GetRoll()) * 180 / M_PI;\n\tef_yaw = ahrs->GetYaw() * 180 / M_PI;\n\treturn true;\n}", "CodeBleu_score": 42.8773933714776}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Retrieve the AHRS instance\n\tAHRS* ahrs = Tracker::get_ahrs();\n\n\t// Check for a zero pitch cosine to avoid division by zero\n\tif (ahrs->GetPitchCosine() != 0) {\n\t\t// Calculate the earth frame pitch and yaw using trigonometric conversions\n\t\tef_pitch = atan2(ahrs->GetPitchCosine() * sin(pitch), cos(pitch));\n\t\tef_yaw = ahrs->GetYaw() + yaw;\n\n\t\t// Return true\n\t\treturn true;\n\t}\n\telse {\n\t\t// Return false\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 46.25511126664078}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t//If the target is valid, update the yaw and pitch\n\tif (tracker.target_valid) {\n\t\t//Compute the yaw and pitch in centidegrees\n\t\tfloat yaw_cd = tracker.target_yaw_cd;\n\t\tfloat pitch_cd = tracker.target_pitch_cd;\n\n\t\t//Check if the yaw is reversed\n\t\tif (tracker.yaw_reversed) {\n\t\t\tyaw_cd = -yaw_cd;\n\t\t}\n\n\t\t//Compute the angle error\n\t\tfloat yaw_error_cd = tracker.yaw_cd - yaw_cd;\n\t\tfloat pitch_error_cd = tracker.pitch_cd - pitch_cd;\n\n\t\t//Convert the errors from earth frame to body frame\n\t\tfloat yaw_error_bf = -yaw_error_cd;\n\t\tfloat pitch_error_bf = -pitch_error_cd;\n\n\t\t//If the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n\t\tif (tracker.target_distance_valid || !tracker.target_distance_min_valid) {\n\t\t\t//Update the yaw servo\n\t\t\ttracker.yaw_servo.update(yaw_error_bf);\n\n\t\t\t//Update the pitch servo\n\t\t\ttracker.pitch_servo.update(pitch_error_bf);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.494196556517263}, {"code": "void Mode::update_auto(void){\n\t\t// Calculate target yaw and pitch\n\tfloat yaw_error = 0.0;\n\tfloat pitch_error = 0.0;\n\tif (tracker.target_distance > 0.0) {\n\t\tyaw_error = tracker.target_yaw - tracker.yaw;\n\t\tpitch_error = tracker.target_pitch - tracker.pitch;\n\t}\n\n\t// Check if the direction is reversed\n\tif (tracker.yaw_direction < 0) {\n\t\tyaw_error = -yaw_error;\n\t}\n\tif (tracker.pitch_direction < 0) {\n\t\tpitch_error = -pitch_error;\n\t}\n\n\t// Convert the errors to body frame\n\tyaw_error = -yaw_error;\n\tpitch_error = -pitch_error;\n\n\t// Update the servos\n\tif (tracker.target_distance > 0.0 || tracker.min_distance == 0.0) {\n\t\ttracker.yaw_servo.write_angle(yaw_error);\n\t\ttracker.pitch_servo.write_angle(pitch_error);\n\t}\n}", "CodeBleu_score": 30.57142325149853}, {"code": "void Mode::update_auto(void){\n\t\tif (tracker.get_mode() == MODE_AUTO) {\n\t\tif (tracker.get_nav_status() == NAV_STATUS_VALID) {\n\t\t\ttracker.set_target_yaw(tracker.get_nav_yaw());\n\t\t\ttracker.set_target_pitch(tracker.get_nav_pitch());\n\t\t}\n\t\telse if (tracker.get_nav_status() == NAV_STATUS_NO_FIX) {\n\t\t\ttracker.set_target_yaw(tracker.get_nav_yaw());\n\t\t\ttracker.set_target_pitch(tracker.get_nav_pitch());\n\t\t}\n\t\telse if (tracker.get_nav_status() == NAV_STATUS_FIX) {\n\t\t\tif (tracker.get_target_distance() > 0) {\n\t\t\t\ttracker.set_target_yaw(tracker.get_nav_yaw());\n\t\t\t\ttracker.set_target_pitch(tracker.get_nav_pitch());\n\t\t\t}\n\t\t\telse if (tracker.get_target_distance() == 0) {\n\t\t\t\ttracker.set_target_yaw(tracker.get_nav_yaw());\n\t\t\t\ttracker.set_target_pitch(tracker.get_nav_pitch());\n\t\t\t}\n\t\t}\n\n\t\t// Check if the direction is reversed\n\t\tif (tracker.get_target_yaw() > 18000) {\n\t\t\ttracker.set_target_yaw(tracker.get_target_yaw() - 36000);\n\t\t}\n\t\tif (tracker.get_target_yaw() < -18000) {\n\t\t\ttracker.set_target_yaw(tracker.get_target_yaw() + 36000);\n\t\t}\n\t\tif (tracker.get_target_pitch() > 18000) {\n\t\t\ttracker.set_target_pitch(tracker.get_target_pitch() - 36000);\n\t\t}\n\t\tif (tracker.get_target_pitch() < -18000) {\n\t\t\ttracker.set_target_pitch(tracker.get_target_pitch() + 36000);\n\t\t}\n\n\t\t// Calculate the error\n\t\ttracker.set_yaw_error(tracker.get_target_yaw() - tracker.get_yaw", "CodeBleu_score": 15.014115630218372}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tif (millis() - last_gps_message > GPS_MESSAGE_INTERVAL) {\n\t\tlast_gps_message = millis();\n\t\tif (gps.newNMEAreceived()) {\n\t\t\tgps.processNewGNSSData();\n\t\t\tif (gps.fixType > 2) {\n\t\t\t\tif (gps_status != GPS_STATUS_3D_FIX) {\n\t\t\t\t\tgps_status = GPS_STATUS_3D_FIX;\n\t\t\t\t\tgps_status_changed = true;\n\t\t\t\t\tgps_status_changed_time = millis();\n\t\t\t\t\tgps_status_changed_count = 0;\n\t\t\t\t\tgps_status_changed_max = 3;\n\t\t\t\t}\n\t\t\t\tif (gps.fixType > 3) {\n\t\t\t\t\tif (gps_status != GPS_STATUS_3D_FIX) {\n\t\t\t\t\t\tgps_status = GPS_STATUS_3D_FIX;\n\t\t\t\t\t\tgps_status_changed = true;\n\t\t\t\t\t\tgps_status_changed_time = millis();\n\t\t\t\t\t\tgps_status_changed_count = 0;\n\t\t\t\t\t\tgps_status_changed_max = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (gps_status == GPS_STATUS_HOME_SET) {\n\t\t\t\t\tif (gps_status_changed_count > 0) {\n\t\t\t\t\t\tgps_status_changed_count--;\n\t\t\t\t\t}\n\t\t\t\t\tif (gps_status_changed_count == 0) {\n\t\t\t\t\t\tgps_status_changed = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (gps_status == GPS_STATUS_HOME_SET) {\n\t\t\t\t\tif (gps.location.isUpdated()) {\n\t\t\t\t\t\tgps_status_changed = true;\n\t\t\t\t\t\tgps_status_changed_time = millis();\n\t\t\t\t\t\tgps_status_changed_count = 0;\n\t\t\t\t\t\tgps_status_changed_max = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (gps_status == GPS_STATUS_HOME_SET) {\n\t\t\t\t\tif (gps.location.isUpdated()) {\n\t\t\t\t\t\tgps_status_changed = true;\n\t\t\t\t\t\tgps_status_changed_time = millis();\n\t\t\t\t\t\tgps_status_changed_count = 0;\n\t\t\t\t\t\tgps_status_changed_max = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (gps_status == GPS_STATUS_HOME_SET) {\n\t\t\t\t\t", "CodeBleu_score": 41.828891011402604}, {"code": "void Tracker::update_GPS(void){\n\t\tif (gps.newNMEAreceived()) {\n\t\tgps.processNMEA();\n\t\tif (gps.fixType < 3) {\n\t\t\tif (gps_last_msg_time != gps.last_msg_time) {\n\t\t\t\tgps_last_msg_time = gps.last_msg_time;\n\t\t\t\tif (gps_countdown > 0) {\n\t\t\t\t\tgps_countdown = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (gps_countdown == 0) {\n\t\t\t\tif (gps.fixType > 3) {\n\t\t\t\t\tgps_countdown = 30;\n\t\t\t\t\tgps_home_valid = false;\n\t\t\t\t\tgps_home_lat = gps.latitude;\n\t\t\t\t\tgps_home_lon = gps.longitude;\n\t\t\t\t\tgps_home_alt = gps.altitude;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgps_countdown--;\n\t\t\t\tif (gps_countdown == 0) {\n\t\t\t\t\tif (gps_home_valid == false) {\n\t\t\t\t\t\tgps_home_valid = true;\n\t\t\t\t\t\tgps_home_lat = gps.latitude;\n\t\t\t\t\t\tgps_home_lon = gps.longitude;\n\t\t\t\t\t\tgps_home_alt = gps.altitude;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.280867964797665}, {"code": "void Tracker::update_GPS(void){\n\t\tif (millis() - last_gps_update > GPS_UPDATE_INTERVAL) {\n\t\tlast_gps_update = millis();\n\t\tif (gps.update()) {\n\t\t\tif (gps.location.status() == 3) {\n\t\t\t\tif (gps_countdown == 0) {\n\t\t\t\t\tif (gps.location.isUpdated()) {\n\t\t\t\t\t\tif (home_lat == 0.0 && home_lon == 0.0) {\n\t\t\t\t\t\t\thome_lat = gps.location.lat();\n\t\t\t\t\t\t\thome_lon = gps.location.lon();\n\t\t\t\t\t\t\thome_alt = gps.altitude.meters();\n\t\t\t\t\t\t\thome_fix_time = gps.location.time();\n\t\t\t\t\t\t\thome_fix_count = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (gps.location.isUpdated()) {\n\t\t\t\t\t\t\t\tif (gps.location.distanceTo(home_lat, home_lon) > HOME_FIX_RADIUS) {\n\t\t\t\t\t\t\t\t\thome_lat = gps.location.lat();\n\t\t\t\t\t\t\t\t\thome_lon = gps.location.lon();\n\t\t\t\t\t\t\t\t\thome_alt = gps.altitude.meters();\n\t\t\t\t\t\t\t\t\thome_fix_time = gps.location.time();\n\t\t\t\t\t\t\t\t\thome_fix_count = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thome_fix_count++;\n\t\t\t\t\tif (home_fix_count > HOME_FIX_COUNT_MAX) {\n\t\t\t\t\t\thome_fix_count = 0;\n\t\t\t\t\t\thome_fix_time = 0;\n\t\t\t\t\t\thome_lat = 0.0;\n\t\t\t\t\t\thome_lon = 0.0;\n\t\t\t\t\t\thome_alt = 0.0;\n\t\t\t\t\t\thome_fix_count = 0;\n\t\t\t\t\t\tgps_countdown = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgps_countdown++;\n\t\t\t\tif (gps_countdown > GPS_COUNTDOWN_MAX) {\n\t\t\t\t\tgps_countdown = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.445875929352695}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// If the GPS is not initialized, initialize it and set the home location if the GPS is valid.\n\tif(!gps_initialized) {\n\t\tgps_initialized = true;\n\t\tif(gps.status() >= 3) {\n\t\t\thome_location = Location(gps.location());\n\t\t\thome_location.set_altitude(0.0);\n\t\t\thome_location.set_speed(0.0);\n\t\t\thome_location.set_course(0.0);\n\t\t}\n\t}\n\n\t// If the GPS is initialized, update the GPS data and check if the last message time has changed.\n\telse {\n\t\tgps.update();\n\t\tif(gps.last_message != last_message_time) {\n\t\t\tlast_message_time = gps.last_message;\n\n\t\t\t// If the GPS is at least 3D fix, set the home location if it has not been set.\n\t\t\tif(gps.status() >= 3) {\n\t\t\t\tif(!home_location_set) {\n\t\t\t\t\thome_location = Location(gps.location());\n\t\t\t\t\thome_location.set_altitude(0.0);\n\t\t\t\t\thome_location.set_speed(0.0);\n\t\t\t\t\thome_location.set_course(0.0);\n\t\t\t\t\thome_location_set = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the GPS is not at least 3D fix, reset the home location and home location set flag.\n\t\t\telse {\n\t\t\t\thome_location_set = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If the home location has been set, update the pitch and roll angles.\n\tif(home_location_set) {\n\t\t// Set the pitch angle to the difference between the current location and the home location.\n\t\tpitch_angle = gps.location().degrees_from(home_location) - 90.0;\n\n\t\t// If the pitch angle is less than 0, set it to 0.\n\t\tif(pitch_angle < 0) {\n\t\t\tpitch_angle = 0;\n\t\t}\n\n\t\t// If the pitch angle is greater than 180, set it to 180.\n\t\tif(pitch_angle > 180) {\n\t\t\tpitch_angle = 180;\n\t\t}\n\n\t\t", "CodeBleu_score": 32.61273330847898}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch < 0.0) {\n\t\t// Servo is off\n\t\tdigitalWrite(PITCH_ONOFF_SERVO_PIN, LOW);\n\t} else {\n\t\t// Servo is on\n\t\tdigitalWrite(PITCH_ONOFF_SERVO_PIN, HIGH);\n\t}\n}", "CodeBleu_score": 13.137453307055063}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0) {\n\t\t// Servo is on\n\t\tdigitalWrite(SERVO_PIN, HIGH);\n\t} else {\n\t\t// Servo is off\n\t\tdigitalWrite(SERVO_PIN, LOW);\n\t}\n}", "CodeBleu_score": 13.050052614852598}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool result = AP_Arming::barometer_checks(display_failure);\n\n\t// if we are arming and the barometer is enabled\n\tif (result && (g.baro_enabled == MAVLINK_STATUS_OK)) {\n\t\t// check that the barometer altitude is within a reasonable range of the inertial navigation altitude\n\t\tfloat baro_alt = g.baro_alt_meter;\n\t\tfloat inertial_alt = g.inertial_nav.alt_m;\n\t\tfloat alt_diff = baro_alt - inertial_alt;\n\t\tif (fabsf(alt_diff) > 0.5f) {\n\t\t\tif (display_failure) {\n\t\t\t\t// log a failure\n\t\t\t\tgcs_send_text_fmt(MAV_SEVERITY_WARNING, \"AP: Baro alt %f in meters, inertial nav alt %f in meters, diff %f in meters\", (double)baro_alt, (double)inertial_alt, (double)alt_diff);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 44.11829062518934}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool result = AP_Arming::barometer_checks(display_failure);\n\tif(result && _check_baro_arming) {\n\t\tfloat baro_alt = _ahrs->get_altitude_feet();\n\t\tfloat inav_alt = _ahrs->get_inertial_altitude_estimate_feet();\n\t\tfloat alt_diff = fabsf(baro_alt - inav_alt);\n\t\tif(alt_diff > _baro_alt_limit) {\n\t\t\tif(display_failure) {\n\t\t\t\tAP_Notify::flags->baro_hgt_out_of_range = true;\n\t\t\t\tAP_Notify::flags->baro_hgt_out_of_range_failsafe = true;\n\t\t\t\tnotify_out_of_range(ALTITUDE_SENSOR_SOURCE_BAROMETER, baro_alt, inav_alt);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 41.016651486442896}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t#if AP_ARMING_CHECK_BARO == 1\n    if (!Copter::barometer_checks(display_failure)) {\n        return false;\n    }\n    if (fabsf(baro_sensor->get_altitude() - inertial_nav->get_altitude()) > AP_ARMING_CHECK_BARO_MAX_DIFF) {\n        if (display_failure) {\n            hal.console->printf(\"Barometer reference too far from inertial navigation altitude\n\");\n        }\n        return false;\n    }\n#endif\n    return true;\n}", "CodeBleu_score": 30.310859717409343}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_rangefinder_required) {\n\t\treturn false;\n\t}\n\tif (_rtl_altitude_type == AP_Param::RTL_ALT_TYPE_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 37.08256238990174}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (_vehicle->rangefinder->enabled()) {\nreturn false;\n} else {\nreturn AP_Arming::terrain_database_required();\n}\n}", "CodeBleu_score": 31.127944463073977}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (g.ARTOO_ENABLED == true) {\n\t\treturn false;\n\t}\n\tif (g.terrain_source == MAVLINK_MSG_ID_RANGEFINDER_REPORT) {\n\t\treturn false;\n\t}\n\tif (g.terrain_source == MAVLINK_MSG_ID_TERRAIN_REPORT) {\n\t\tif (g.RTL_ALT == RTL_ALT_TERRAIN) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn AP_Arming_Base::terrain_database_required();\n}", "CodeBleu_score": 55.593016515443374}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// set loop time using last loop time from scheduler\n\t_loop_time = _scheduler.get_loop_time_micros();\n\n\t// run attitude controller\n\t_attitude_control.rate_controller_run(_loop_time);\n}", "CodeBleu_score": 30.425030255987938}, {"code": "void Copter::run_rate_controller(){\n\t\t// set loop time\n\tfloat loop_time = _scheduler->last_interval;\n\t_loop_counter++;\n\n\t// run attitude controller\n\t_attitude_control->rate_controller_run(loop_time);\n\n\t// run position controller\n\t_position_control->rate_controller_run(loop_time);\n\n\t// run motor controller\n\t_motor_control->rate_controller_run(loop_time);\n}", "CodeBleu_score": 43.45677900244619}, {"code": "void Copter::run_rate_controller(){\n\t\t// set loop time\n\tfloat loop_time = _scheduler->get_loop_time_micros() * 1.0e-6f;\n\n\t// run attitude controller\n\t_attitude_control.rate_controller_run(loop_time);\n}", "CodeBleu_score": 31.609418276296037}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// if the old location matches the next waypoint location and the altitude frames are the same, set the new location as the target\n\tif (old_loc.is_same_position(new_loc) && old_loc.alt_frame == new_loc.alt_frame) {\n\t\ttarget_loc = new_loc;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 40.29105623698942}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t/*\n\t * If the old location matches the new location, return false\n\t */\n\tif (old_loc.distance_to(new_loc) < 10) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * If the altitude frames of the old and new locations are the same, return false\n\t */\n\tif (old_loc.alt_frame != new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * If the old location is not set, set it to the new location\n\t */\n\tif (old_loc.is_zero()) {\n\t\told_loc = new_loc;\n\t\treturn true;\n\t}\n\n\t/*\n\t * If the old location is not the same as the new location, set the new location as the target and return true\n\t */\n\tif (old_loc != new_loc) {\n\t\ttarget_loc = new_loc;\n\t\treturn true;\n\t}\n\n\t/*\n\t * If the old location is the same as the new location, return false\n\t */\n\treturn false;\n}", "CodeBleu_score": 48.29578106123057}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t/*\n\t * If the old location is not the same as the new location, the altitude frame must be the same.\n\t */\n\tif (old_loc.alt_frame != new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * If the old location is the same as the new location, the altitude frame must be the same.\n\t */\n\tif (old_loc.alt_frame == MAV_FRAME_GLOBAL_RELATIVE_ALT) {\n\t\t/*\n\t\t * If the old location is the same as the new location, the altitude frame must be the same.\n\t\t */\n\t\tif (old_loc.alt != new_loc.alt) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * If the old location is the same as the new location, the altitude frame must be the same.\n\t */\n\tif (old_loc.alt_frame == MAV_FRAME_GLOBAL) {\n\t\t/*\n\t\t * If the old location is the same as the new location, the altitude frame must be the same.\n\t\t */\n\t\tif (old_loc.alt != new_loc.alt) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * If the old location is the same as the new location, the altitude frame must be the same.\n\t */\n\tif (old_loc.alt_frame == MAV_FRAME_GLOBAL_TERRAIN_ALT) {\n\t\t/*\n\t\t * If the old location is the same as the new location, the altitude frame must be the same.\n\t\t */\n\t\tif (old_loc.alt != new_loc.alt) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * If the old location is the same as the new location, the altitude frame must be the same.\n\t */\n\tif (old_loc.alt_frame == MAV_FRAME_GLOBAL_INT) {\n\t\t/*\n\t\t * If the old location is the same as the new location, the altitude frame must be the same.\n\t\t */\n\t\tif (old_loc.alt != new_loc.alt) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * If the old location is the same as the new location, the altitude frame must be the same.", "CodeBleu_score": 44.803415176146984}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (aux_switch_pos(ch_flag) == AuxSwitchPos::HIGH) {\n\t\tif (mode == Mode::MANUAL) {\n\t\t\tif (rc().mode_switch_pos(ch_flag) == AuxSwitchPos::LOW) {\n\t\t\t\trc().set_mode(mode, ch_flag);\n\t\t\t}\n\t\t} else {\n\t\t\trc().set_mode(mode, ch_flag);\n\t\t}\n\t} else {\n\t\tif (rc().mode_switch_pos(ch_flag) == AuxSwitchPos::LOW) {\n\t\t\trc().reset_mode_switch(ch_flag);\n\t\t}\n\t}\n}", "CodeBleu_score": 44.385698198702336}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode == Mode::LOITER) {\n\t\t\tset_mode(mode);\n\t\t}\n\t} else {\n\t\tif (mode == get_mode()) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 43.34355364647886}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode == get_mode()) {\n\t\t\trc().reset_mode_switch();\n\t\t} else {\n\t\t\tset_mode(mode);\n\t\t}\n\t} else if (get_mode() == mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 53.93217510192325}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// save trim\n\tahrs.set_roll_trim(RC_CHANNELS.control[roll_channel].control_in * (math::pi / 180.0f));\n\tahrs.set_pitch_trim(RC_CHANNELS.control[pitch_channel].control_in * (math::pi / 180.0f));\n\n\t// log trim\n\tevents.log(\"TRIM: Roll: %d, Pitch: %d\", (int)(RC_CHANNELS.control[roll_channel].control_in * (math::pi / 180.0f) * 100.0f), (int)(RC_CHANNELS.control[pitch_channel].control_in * (math::pi / 180.0f) * 100.0f));\n\n\t// send trim message\n\tmavlink_command_long_send(mavlink_fd, 0, 0, MAV_CMD_PREFLIGHT_CALIBRATION, 0, 0, 0, 0, 0, 0, 0, 0);\n}", "CodeBleu_score": 37.38010788862944}, {"code": "void Copter::save_trim(){\n\t\n#ifdef RC_CHANNELS_ENABLED\n\n    float roll_trim_input = rc_channels.roll_radio;\n    float pitch_trim_input = rc_channels.pitch_radio;\n\n    // convert trim inputs from [-100, 100] to [100, -100]\n    if (roll_trim_input > 0) {\n        roll_trim_input = 100.0f - roll_trim_input;\n    }\n    else {\n        roll_trim_input = -100.0f - roll_trim_input;\n    }\n\n    if (pitch_trim_input > 0) {\n        pitch_trim_input = 100.0f - pitch_trim_input;\n    }\n    else {\n        pitch_trim_input = -100.0f - pitch_trim_input;\n    }\n\n    // convert trim inputs from [100, -100] to [0, -180]\n    float roll_trim_deg = roll_trim_input * 180.0f / 100.0f;\n    float pitch_trim_deg = pitch_trim_input * 180.0f / 100.0f;\n\n    // add trim values to AHRS trim\n    ahrs.set_trim(roll_trim_deg, pitch_trim_deg);\n\n    // log trim values\n    Log.info(\"RC_CHANNELS: Roll trim: %f, Pitch trim: %f\", roll_trim_deg, pitch_trim_deg);\n\n    // send confirmation message\n    mavlink_message_t msg;\n    mavlink_msg_command_ack_encode(\n        MAVLINK_COMM_0,\n        cmd.get_command_ack_seq(),\n        MAV_CMD_DO_SET_TRIM,\n        MAV_RESULT_ACCEPTED,\n        cmd.get_command_ack_current(),\n        cmd.get_command_ack_autocontinue(),\n        &msg);\n    send_mavlink_message(msg);\n\n#endif // RC_CHANNELS_ENABLED\n\n}", "CodeBleu_score": 39.338792635497825}, {"code": "void Copter::save_trim(){\n\t\n#if CLI_ENABLED == ENABLED\n    if (cli_enabled) {\n        cliSerial->println_P(PSTR(\"Saving trim values\"));\n    }\n#endif\n\n    /*\n     * Get the current roll and pitch control inputs from the RC channels.\n     */\n    float roll_input = rc_channels.chan_roll->control;\n    float pitch_input = rc_channels.chan_pitch->control;\n\n    /*\n     * Convert the roll and pitch control inputs to radians.\n     */\n    float roll_rad = roll_input * DEGTORAD;\n    float pitch_rad = pitch_input * DEGTORAD;\n\n    /*\n     * Add the roll and pitch radians to the AHRS trim.\n     */\n    ahrs.set_trim(roll_rad, pitch_rad);\n\n    /*\n     * Log the event.\n     */\n    DataFlash.Log_Write_Event(DATA_FLASH_EVENT_ID::AHRS_TRIM_SAVE, 0, 0, 0);\n\n    /*\n     * Send a confirmation message.\n     */\n    mavlink_message_t msg;\n    mavlink_msg_command_ack_encode(\n        MAVLINK_COMM_0,\n        cmd_ack_last,\n        MAV_RESULT_ACCEPTED,\n        0,\n        MAV_CMD_DO_MOUNT_CONTROL,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n    );\n    mavlink_msg_command_ack_send(MAVLINK_COMM_0, &msg);\n}", "CodeBleu_score": 37.734940149928505}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\n\t/*\n\t * The velocity vector\n\t */\n\tVector3f velocity = this->vehicle.getVelocity();\n\n\t/*\n\t * The speed squared\n\t */\n\tfloat speed_squared = velocity.x * velocity.x + velocity.y * velocity.y;\n\n\t/*\n\t * The look-ahead yaw angle\n\t */\n\tfloat look_ahead_yaw = 0.0f;\n\n\t/*\n\t * If the copter is not in manual mode, it can look ahead\n\t */\n\tif (this->vehicle.getMode() != MANUAL) {\n\t\t/*\n\t\t * If the copter is not in a landing state, it can look ahead\n\t\t */\n\t\tif (this->vehicle.getMode() != LAND) {\n\t\t\t/*\n\t\t\t * If the copter is not in a takeoff state, it can look ahead\n\t\t\t */\n\t\t\tif (this->vehicle.getMode() != TAKEOFF) {\n\t\t\t\t/*\n\t\t\t\t * If the copter is not in a transition state, it can look ahead\n\t\t\t\t */\n\t\t\t\tif (this->vehicle.getMode() != TRANSITION) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If the copter is not in a RTL state, it can look ahead\n\t\t\t\t\t */\n\t\t\t\t\tif (this->vehicle.getMode() != RTL) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If the copter's position is valid, it can look ahead\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (this->vehicle.getPosition().isValid()) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * If the speed squared is greater than the minimum threshold, it can look ahead\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (speed_squared > MIN_SPEED_SQUARED) {\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * The look-ahead yaw angle is the arctangent of the velocity components\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tlook_ahead_yaw = atan2(velocity.y, velocity.x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Return the look-ahead yaw angle\n\t */\n\treturn look_ahead_yaw;\n}", "CodeBleu_score": 33.0092045660776}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    \n\n    float yaw_angle = 0.0;\n\n    // Retrieve the copter's velocity\n    float vx = copter.get_vx();\n    float vy = copter.get_vy();\n\n    // Calculate the speed squared\n    float speed_squared = vx * vx + vy * vy;\n\n    // If the copter's position is valid and the speed exceeds the minimum threshold, calculate the look-ahead yaw angle\n    if (copter.get_valid_position() && speed_squared > MIN_SPEED_SQUARED) {\n        yaw_angle = atan2(vy, vx);\n    }\n\n    return yaw_angle;\n}", "CodeBleu_score": 44.50752994173372}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\n\tfloat yaw_angle = 0.0;\n\tfloat speed_squared = 0.0;\n\tfloat velocity_x = 0.0;\n\tfloat velocity_y = 0.0;\n\tfloat velocity_z = 0.0;\n\tfloat velocity_xy_squared = 0.0;\n\tfloat velocity_xy = 0.0;\n\tfloat velocity_xy_abs = 0.0;\n\tfloat velocity_xy_abs_squared = 0.0;\n\tfloat velocity_xy_abs_cubed = 0.0;\n\tfloat velocity_xy_abs_cubed_reciprocal = 0.0;\n\tfloat yaw_angle_offset = 0.0;\n\tfloat yaw_angle_offset_squared = 0.0;\n\tfloat yaw_angle_offset_cubed = 0.0;\n\tfloat yaw_angle_offset_cubed_reciprocal = 0.0;\n\tfloat yaw_angle_offset_squared_reciprocal = 0.0;\n\tfloat yaw_angle_offset_squared_reciprocal_squared = 0.0;\n\tfloat yaw_angle_offset_cubed_reciprocal_squared = 0.0;\n\tfloat yaw_angle_offset_cubed_reciprocal_squared_reciprocal = 0.0;\n\tfloat yaw_angle_offset_cubed_reciprocal_squared_reciprocal_squared = 0.0;\n\tfloat yaw_angle_offset_cubed_reciprocal_squared_reciprocal_squared_reciprocal = 0.0;\n\tfloat yaw_angle_offset_cubed_reciprocal_squared_reciprocal_squared_reciprocal_squared = 0.0;\n\tfloat yaw_angle_offset_cubed_reciprocal_squared_reciprocal_squared_reciprocal_squared_reciprocal = 0.0;\n\tfloat yaw_angle_offset_cubed_reciprocal_squared_reciprocal_squared_reciprocal_squared_reciprocal_squared = 0.0;\n\tfloat yaw_angle_offset_cubed_reciprocal_squared_reciprocal", "CodeBleu_score": 8.044159563340331}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (arming_disabled() || watchdog_armed()) {\n\t\treturn true;\n\t}\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (g.disable_rudder_arming) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!plane.armed()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 38.81451007778601}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// bypass arming checks if watchdog is armed\n\tif (arming.watchdog_enabled()) {\n\t\treturn true;\n\t}\n\n\t// bypass arming checks if arming checks are disabled\n\tif (arming.arming_checks_disabled()) {\n\t\treturn true;\n\t}\n\n\t// check if rudder arming is disabled\n\tif (method == AP_Arming::RUDDER && !plane.rudder_enabled()) {\n\t\treturn false;\n\t}\n\n\t// check if throttle is not zero\n\tif (method == AP_Arming::THROTTLE && plane.throttle_zero()) {\n\t\treturn false;\n\t}\n\n\t// perform parent class's arming checks\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 47.879031872475394}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// check if arming checks are disabled\n\tif (motors.armed == AP_MOTORS_ARMED_DISABLED) {\n\t\treturn true;\n\t}\n\n\t// check if the watchdog was armed\n\tif (motors.armed == AP_MOTORS_ARMED_WATCHDOG) {\n\t\treturn true;\n\t}\n\n\t// call the parent class's arm_checks method\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 33.856398972915734}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\n#if defined(DEBUG_ARMING)\n    if (do_arming_checks) {\n        // print the arming checks\n        print_arming_checks();\n    }", "CodeBleu_score": 13.686068183686864}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// check if already armed\n\tif (armed) {\n\t\treturn true;\n\t}\n\n\t// check if arming checks are required\n\tif (do_arming_checks) {\n\t\t// check if the plane is in the air\n\t\tif (plane.get_mode() != MAV_MODE_GUIDED) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is already in the air\n\t\tif (plane.get_altitude() < 0.5f) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is on the ground\n\t\tif (plane.get_ground_alt() < 0.5f) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is in the air\n\t\tif (plane.get_groundspeed() > 0.5f) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is in the air\n\t\tif (plane.get_groundspeed() < -0.5f) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is in the air\n\t\tif (plane.get_airspeed() > 0.5f) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is in the air\n\t\tif (plane.get_airspeed() < -0.5f) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is in the air\n\t\tif (plane.get_ground_course_cd() > 0.5f) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is in the air\n\t\tif (plane.get_ground_course_cd() < -0.5f) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is in the air\n\t\tif (plane.get_air_course_cd() > 0.5f) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is in the air\n\t\tif (plane.get_air_course_cd() < -0.5f) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if the plane is in the air\n\t\tif (plane.get_ground_course_cd() > 0.5f) {\n\t\t\t", "CodeBleu_score": 31.049877892137857}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t#if 0\n    // arming checks disabled for now\n    if (do_arming_checks) {\n        // check if we should arm\n        if (!should_arm()) {\n            // we should not arm, set status text and return false\n            set_status(AP_Arming::DISARMED);\n            return false;\n        }\n    }\n#endif\n\n    // set the arming method\n    set_arming_method(method);\n\n    // arm the system\n    if (!do_arm()) {\n        // failed to arm system, set status text and return false\n        set_status(AP_Arming::FAILED);\n        return false;\n    }\n\n    // arming was successful, set status text and return true\n    set_status(AP_Arming::ARMED);\n    return true;\n}", "CodeBleu_score": 40.10947316014101}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (AP_Arming::pre_arm_checks(display_failure)) {\n\t\treturn true;\n\t}\n\tif (!disarm_button.configured()) {\n\t\treturn false;\n\t}\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 58.16348051442544}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// if the vehicle is already armed, return true\n\tif (vehicle->armed) {\n\t\treturn true;\n\t}\n\t// if disarm button is not configured, display failure message and return false\n\tif (vehicle->rc_channel_function[vehicle->rc_channel_function.find_first_index_of(RC_FUNCTION_DISARM)]) {\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t}\n\t// otherwise, return false\n\treturn false;\n}", "CodeBleu_score": 48.540451591314316}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// check if already armed\n\tif (armed()) {\n\t\treturn true;\n\t}\n\n\t// check if disarm button is configured\n\tif (disarm_button() == 0) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(MAV_SEVERITY_CRITICAL, PSTR(\"Disarm button not configured\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// perform standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 62.92218627867382}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tfloat temp_y = y;\n\tx = temp_x*cos(yaw) + temp_y*sin(yaw);\n\ty = -temp_x*sin(yaw) + temp_y*cos(yaw);\n}", "CodeBleu_score": 33.685192136135946}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tfloat temp_y = y;\n\tx = cos(yaw) * temp_x - sin(yaw) * temp_y;\n\ty = sin(yaw) * temp_x + cos(yaw) * temp_y;\n}", "CodeBleu_score": 33.80789783588142}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = cos(yaw) * x - sin(yaw) * y;\n\tfloat ne_y = sin(yaw) * x + cos(yaw) * y;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 52.808030947366966}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if the yaw angle and param4 values are within acceptable ranges\n\tif (packet.param1 >= 0 && packet.param1 <= 360 && packet.param4 >= -90 && packet.param4 <= 90) {\n\t\t// Set the yaw heading using the provided parameters\n\t\t_gcs_mavlink_sub.set_yaw_heading(packet.param1, packet.param2, packet.param3, packet.param4, packet.param5, packet.param6, packet.param7);\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\t// If not valid, return MAV_RESULT_DENIED\n\treturn MAV_RESULT_DENIED;\n}", "CodeBleu_score": 55.90696127033862}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// check if the yaw angle is within acceptable range\n\tif (fabsf(packet.param4) < 15000) {\n\t\t// check if the yaw mode is valid\n\t\tif (packet.param1 == MAV_YAW_MODE_HEADING_HOLD) {\n\t\t\t// set the yaw heading\n\t\t\tvehicle.set_yaw_heading(packet.param4);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else if (packet.param1 == MAV_YAW_MODE_HEADING_LOCK) {\n\t\t\t// set the yaw heading\n\t\t\tvehicle.set_yaw_heading(packet.param4);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else if (packet.param1 == MAV_YAW_MODE_HEADING_RACING) {\n\t\t\t// set the yaw heading\n\t\t\tvehicle.set_yaw_heading(packet.param4);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else if (packet.param1 == MAV_YAW_MODE_AUTO_ALIGN) {\n\t\t\t// set the yaw heading\n\t\t\tvehicle.set_yaw_heading(packet.param4);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else if (packet.param1 == MAV_YAW_MODE_LOCK) {\n\t\t\t// set the yaw heading\n\t\t\tvehicle.set_yaw_heading(packet.param4);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else if (packet.param1 == MAV_YAW_MODE_SPIN) {\n\t\t\t// set the yaw heading\n\t\t\tvehicle.set_yaw_heading(packet.param4);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else if (packet.param1 == MAV_YAW_MODE_SPIN_RACING) {\n\t\t\t// set the yaw heading\n\t\t\tvehicle.set_yaw_heading(packet.param4);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else if (packet.param1 == MAV_YAW_MODE_LOCK_RACING) {\n\t\t\t// set the yaw heading\n\t\t\tvehicle.set_yaw_heading(packet.param4);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else if (packet.param1 ==", "CodeBleu_score": 42.059641193170535}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// check if the yaw angle is within the acceptable range\n\tif (packet.param1 < 0 || packet.param1 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\t// check if the yaw speed is within the acceptable range\n\tif (packet.param2 < -1.0f || packet.param2 > 1.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\t// check if the yaw speed is within the acceptable range\n\tif (packet.param3 < 0 || packet.param3 > 25) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\t// check if the yaw speed is within the acceptable range\n\tif (packet.param4 < -180 || packet.param4 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\t// set the yaw heading using the provided parameters\n\tvehicle.set_yaw_heading(packet.param1, packet.param2, packet.param3, packet.param4);\n\t// return MAV_RESULT_ACCEPTED\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 50.14031477078008}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif ((control_mode() == MAV_MODE_FLAG_AUTO_ENABLED) || (control_mode() == MAV_MODE_FLAG_GUIDED_ENABLED)) {\n\t\treturn (uint8_t)(2 * (int16_t(waypoint_bearing()) + 18000) / 36000);\n\t}\n\treturn 0;\n}", "CodeBleu_score": 38.45286830966789}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n\t\treturn (uint8_t)((tgt_heading + 18000) / 360);\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 34.23123090705838}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode() == MAV_MODE_FLAG_AUTO_ENABLED || control_mode() == MAV_MODE_FLAG_GUIDED_ENABLED) {\n\t\treturn (uint8_t)((int32_t)(get_mav_param(MAV_PARAM_NAV_YAW_BEHAVIOR) + 18000) / 36000);\n\t}\n\treturn 0;\n}", "CodeBleu_score": 37.52142546429672}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (this->log_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.timestamp = millis();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tthis->log_queue.write_critical_block(packet);\n\t}\n}", "CodeBleu_score": 35.841045677548486}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (logger != NULL) {\n\t\tlogger->Log_Write_Data(id, value);\n\t}\n}", "CodeBleu_score": 24.814593475200823}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (m_log_enabled) {\n\t\tLog_Write_Data_Inner(id, value);\n\t}\n}", "CodeBleu_score": 17.79644977143173}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_set) {\n\t\treturn;\n\t}\n\n\tif (motors_armed) {\n\t\t// If the motors are armed, set the home to the current location in-flight\n\t\tset_home_position_in_air();\n\t}\n\telse {\n\t\t// If the motors are not armed, attempt to set the home to the current EKF location and ignore any failure in this attempt\n\t\tset_home_position_from_EKF();\n\t}\n}", "CodeBleu_score": 21.985250800118372}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\tif (motors_armed) {\n\t\thome_is_set = true;\n\t\thome_loc = get_position_ptr();\n\t}\n\telse {\n\t\tif (set_home_position_ptr(get_position_ptr())) {\n\t\t\thome_is_set = true;\n\t\t\thome_loc = get_position_ptr();\n\t\t}\n\t}\n}", "CodeBleu_score": 25.042035551065677}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\tif (motors_armed) {\n\t\thome_is_set = true;\n\t\thome_lat = ekf.get_lat();\n\t\thome_lon = ekf.get_lon();\n\t\thome_alt = ekf.get_alt();\n\t\thome_valid = true;\n\t\treturn;\n\t}\n\tif (motors_armed) {\n\t\thome_is_set = true;\n\t\thome_lat = ekf.get_lat();\n\t\thome_lon = ekf.get_lon();\n\t\thome_alt = ekf.get_alt();\n\t\thome_valid = true;\n\t\treturn;\n\t}\n\tif (motors_armed) {\n\t\thome_is_set = true;\n\t\thome_lat = ekf.get_lat();\n\t\thome_lon = ekf.get_lon();\n\t\thome_alt = ekf.get_alt();\n\t\thome_valid = true;\n\t\treturn;\n\t}\n\tif (motors_armed) {\n\t\thome_is_set = true;\n\t\thome_lat = ekf.get_lat();\n\t\thome_lon = ekf.get_lon();\n\t\thome_alt = ekf.get_alt();\n\t\thome_valid = true;\n\t\treturn;\n\t}\n\tif (motors_armed) {\n\t\thome_is_set = true;\n\t\thome_lat = ekf.get_lat();\n\t\thome_lon = ekf.get_lon();\n\t\thome_alt = ekf.get_alt();\n\t\thome_valid = true;\n\t\treturn;\n\t}\n\tif (motors_armed) {\n\t\thome_is_set = true;\n\t\thome_lat = ekf.get_lat();\n\t\thome_lon = ekf.get_lon();\n\t\thome_alt = ekf.get_alt();\n\t\thome_valid = true;\n\t\treturn;\n\t}\n\tif (motors_armed) {\n\t\thome_is_set = true;\n\t\thome_lat = ekf.get_lat();\n\t\thome_lon = ekf.get_", "CodeBleu_score": 16.47413267746109}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\tif (!motorsArmed) {\n\t\tmotors.setThrottle(0);\n\t\tspool.setState(Spool::UNLIMITED);\n\t\tattitudeController.relax();\n\t\treturn;\n\t}\n\n\tspool.setState(Spool::UNLIMITED);\n\n\tfloat rollRate, pitchRate, yawRate;\n\n\trollRate = pilot.roll - pilot.pitch;\n\tpitchRate = pilot.roll + pilot.pitch;\n\tyawRate = pilot.yaw;\n\n\tattitudeController.run(rollRate, pitchRate, yawRate);\n\n\tmotors.setThrottle(pilot.throttle);\n\tmotors.setMotor(Motor::LEFT, pilot.throttle + attitudeController.getMotor(Motor::LEFT));\n\tmotors.setMotor(Motor::RIGHT, pilot.throttle + attitudeController.getMotor(Motor::RIGHT));\n}", "CodeBleu_score": 41.38792053592002}, {"code": "void ModeAcro::run(){\n\t\t// If the motors are not armed, set throttle to zero, adjust spool state, relax attitude controllers, and exit\n\tif (!motorsArmed) {\n\t\tsetThrottle(0.0f);\n\t\tsetSpoolState(SPOOL_STATE_UNLIMITED_THROTTLE);\n\t\trelaxAttitudeControllers();\n\t\treturn;\n\t}\n\n\t// If armed, set spool state to unlimited throttle, convert pilot inputs to desired body rates, and run attitude controller\n\tsetSpoolState(SPOOL_STATE_UNLIMITED_THROTTLE);\n\tfloat rollRate = convertRollRate(pilot.roll);\n\tfloat pitchRate = convertPitchRate(pilot.pitch);\n\tfloat yawRate = convertYawRate(pilot.yaw);\n\trunAttitudeController(rollRate, pitchRate, yawRate);\n\n\t// Output pilot throttle without angle boost and set forward and lateral motor inputs based on pilot controls\n\tpilot.throttle = constrainf(pilot.throttle, 0.0f, 1.0f);\n\tsetMotorInputs(pilot.throttle, pilot.roll, pilot.pitch, pilot.yaw);\n}", "CodeBleu_score": 35.62884900573503}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed()) {\n\t\tmotors.setThrottle(0);\n\t\tspool.set(spool.UNLIMITED);\n\t\tattitude.relax();\n\t\treturn;\n\t}\n\tspool.set(spool.UNLIMITED);\n\tfloat roll = pilot.roll();\n\tfloat pitch = pilot.pitch();\n\tfloat yaw = pilot.yaw();\n\tfloat thrust = pilot.thrust();\n\tfloat rollRate = roll * ACRO_RATE_SCALAR;\n\tfloat pitchRate = pitch * ACRO_RATE_SCALAR;\n\tfloat yawRate = yaw * ACRO_RATE_SCALAR;\n\tfloat thrustRate = thrust * ACRO_RATE_SCALAR;\n\tattitude.run(rollRate, pitchRate, yawRate, thrustRate);\n\tmotors.setThrust(thrust);\n}", "CodeBleu_score": 39.15140023439335}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set the mode to position control\n\tmode = MODE_GUIDED_POS_CONTROL;\n\n\t// Initialize the waypoint controller\n\twaypoint_controller.init();\n\n\t// Set the waypoint destination\n\twaypoint_controller.set_destination(waypoint_controller.get_stopping_point());\n\n\t// Set the yaw using the default auto yaw mode\n\tyaw_controller.set_auto_yaw_mode();\n\n\t// Reset the yaw controller\n\tyaw_controller.reset();\n}", "CodeBleu_score": 33.16008386737804}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set the control mode to position control\n\tcontrol_mode = POSITION_CONTROL;\n\n\t// Get the stopping point\n\tposition_setpoint.x = get_stopping_point().x;\n\tposition_setpoint.y = get_stopping_point().y;\n\tposition_setpoint.z = get_stopping_point().z;\n\n\t// Initialize the waypoint controller\n\twaypoint_controller_init(&waypoint_controller, &position_setpoint, &velocity_setpoint, &position_error, &velocity_error, &position_error_integral, &velocity_error_integral, &yaw_setpoint, &position_setpoint_updated, &velocity_setpoint_updated, &yaw_setpoint_updated);\n\n\t// Initialize the yaw using the default auto yaw mode\n\tauto_yaw_init();\n}", "CodeBleu_score": 37.86449876594177}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set the current mode as GUIDED_POS_CONTROL\n\tcurrent_mode = GUIDED_POS_CONTROL;\n\n\t// Initialize the waypoint controller\n\twaypoint_controller_init();\n\n\t// Get the stopping point\n\tVector2D stopping_point = get_stopping_point();\n\n\t// Set the waypoint destination to the stopping point\n\twaypoint_controller_set_destination(stopping_point);\n\n\t// Set the yaw using the default auto yaw mode\n\tset_auto_yaw_mode(AUTO_YAW_MODE_DEFAULT);\n}", "CodeBleu_score": 22.11046626151612}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set the control mode to GUIDED_VEL_CONTROL\n\tcontrol_mode = GUIDED_VEL_CONTROL;\n\n\t// Initialize the vertical velocity controller\n\tvert_vel_ctrl.initialize();\n\n\t// Initialize the horizontal velocity controller\n\thoriz_vel_ctrl.initialize();\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD\n\tyaw_control_mode = AUTO_YAW_HOLD;\n}", "CodeBleu_score": 17.116300315786116}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set the vertical maximum speeds and acceleration\n\t_vel_control.set_vert_vel_max(_params.guided_vel_control_vz_max, _params.guided_vel_control_vz_max_th);\n\t_vel_control.set_vert_accel_max(_params.guided_vel_control_vz_accel_max, _params.guided_vel_control_vz_accel_max_th);\n\t_vel_control.set_vert_jerk_max(_params.guided_vel_control_vz_jerk_max, _params.guided_vel_control_vz_jerk_max_th);\n\n\t// Initialize the velocity controllers\n\t_vel_control.init_velocity_controllers();\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD\n\t_control_mode.flag_control_auto_enabled = true;\n\t_control_mode.flag_control_offboard_enabled = false;\n\t_control_mode.flag_control_position_enabled = false;\n\t_control_mode.flag_control_velocity_enabled = true;\n\t_control_mode.flag_control_acceleration_enabled = false;\n\t_control_mode.flag_control_attitude_enabled = false;\n\t_control_mode.flag_control_rates_enabled = false;\n\t_control_mode.flag_control_manual_enabled = false;\n\t_control_mode.flag_control_stabilized_enabled = false;\n\t_control_mode.flag_control_rattitude_enabled = false;\n\t_control_mode.flag_control_heading_enabled = false;\n\t_control_mode.flag_control_height_enabled = false;\n\t_control_mode.flag_control_transition_enabled = false;\n\t_control_mode.flag_control_fixedwing_enabled = false;\n\t_control_mode.flag_control_glideslope_enabled = false;\n\t_control_mode.flag_control_posctl_enabled = false;\n\t_control_mode.flag_control_auto_enabled = false;\n\t_control_mode.flag_control_offboard_enabled = true;\n\t_control_mode.", "CodeBleu_score": 43.47652602429033}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set the vertical maximum speeds and acceleration\n\tthis->vertical_speed_max = this->pilot_params.max_vert_speed;\n\tthis->vertical_accel_max = this->pilot_params.max_vert_accel;\n\n\t// Initialize the vertical and horizontal velocity controllers\n\tthis->vert_vel_controller.init(this->vertical_speed_max, this->vertical_accel_max);\n\tthis->horz_vel_controller.init(this->pilot_params.max_horz_speed, this->pilot_params.max_horz_accel);\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tthis->yaw_control_mode = AUTO_YAW_HOLD;\n}", "CodeBleu_score": 11.35770096084138}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if timeout has been exceeded\n\tif (millis() > (start_time + timeout)) {\n\t\treturn true;\n\t}\n\t// Check if current altitude is above minimum threshold\n\tif (vehicle.location.alt > alt_min) {\n\t\treturn false;\n\t}\n\t// Check if current altitude is below maximum threshold\n\tif (vehicle.location.alt < alt_max) {\n\t\treturn false;\n\t}\n\t// Check if horizontal distance moved exceeds limit\n\tif (distance_moved() > distance_max) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 19.631798314274597}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tif (millis() > this->guided_timeout) {\n\t\treturn true;\n\t}\n\tif (this->altitude < this->guided_min_altitude) {\n\t\treturn true;\n\t}\n\tif (this->altitude > this->guided_max_altitude) {\n\t\treturn true;\n\t}\n\tif (this->horizontal_distance > this->guided_max_horizontal_distance) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 15.45532683247777}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if timeout has been exceeded\n\tif (millis() - start_time > timeout_time) {\n\t\treturn true;\n\t}\n\t// Check if altitude is within limits\n\tif (current_altitude > max_altitude || current_altitude < min_altitude) {\n\t\treturn true;\n\t}\n\t// Check if horizontal distance is within limits\n\tif (abs(current_x_pos - previous_x_pos) > max_horizontal_dist || abs(current_y_pos - previous_y_pos) > max_horizontal_dist) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 23.015655396146002}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\t// TODO: Implement this method\n\treturn true;\n}", "CodeBleu_score": 4.877943933983955}, {"code": "bool Sub::verify_motor_test(){\n\t\t// TODO: Implement Sub::verify_motor_test\n\treturn true;\n}", "CodeBleu_score": 4.877943933983955}, {"code": "bool Sub::verify_motor_test(){\n\t\t// TODO: Implement Sub::verify_motor_test\n\treturn true;\n}", "CodeBleu_score": 4.877943933983955}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target_cd = wp_nav.roll_cd;\n\tfloat pitch_target_cd = wp_nav.pitch_cd;\n\tfloat roll_max_cd = 1000;\n\tfloat pitch_max_cd = 1000;\n\n\t/* Constrain roll_target_cd within roll_max_cd */\n\tif (roll_target_cd > roll_max_cd) {\n\t\troll_target_cd = roll_max_cd;\n\t}\n\telse if (roll_target_cd < -roll_max_cd) {\n\t\troll_target_cd = -roll_max_cd;\n\t}\n\n\t/* Constrain pitch_target_cd within pitch_max_cd */\n\tif (pitch_target_cd > pitch_max_cd) {\n\t\tpitch_target_cd = pitch_max_cd;\n\t}\n\telse if (pitch_target_cd < -pitch_max_cd) {\n\t\tpitch_target_cd = -pitch_max_cd;\n\t}\n\n\t/* Normalize roll_target_cd */\n\tlateral_out = roll_target_cd / roll_max_cd;\n\n\t/* Normalize pitch_target_cd */\n\tforward_out = pitch_target_cd / pitch_max_cd;\n}", "CodeBleu_score": 38.2084349120997}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_deg = wp_nav.roll_cd * 100.0f;\n\tfloat pitch_deg = wp_nav.pitch_cd * 100.0f;\n\n\tfloat roll_deg_norm = constrain_float(roll_deg, -WPNAV_MAX_ROLL_PITCH_CD, WPNAV_MAX_ROLL_PITCH_CD);\n\tfloat pitch_deg_norm = constrain_float(pitch_deg, -WPNAV_MAX_ROLL_PITCH_CD, WPNAV_MAX_ROLL_PITCH_CD);\n\n\troll_deg_norm /= WPNAV_MAX_ROLL_PITCH_CD;\n\tpitch_deg_norm /= WPNAV_MAX_ROLL_PITCH_CD;\n\n\tlateral_out = -pitch_deg_norm;\n\tforward_out = roll_deg_norm;\n}", "CodeBleu_score": 30.297375296414884}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_in = wp_nav.roll * 100;\n\tfloat pitch_in = wp_nav.pitch * 100;\n\n\tfloat roll_out = constrain(roll_in, -1000, 1000);\n\tfloat pitch_out = constrain(pitch_in, -1000, 1000);\n\n\troll_out = (roll_out + 1000) / 2000;\n\tpitch_out = (pitch_out + 1000) / 2000;\n\n\tlateral_out = roll_out;\n\tforward_out = pitch_out;\n}", "CodeBleu_score": 31.061284537294632}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\tif (this->altitude > 0.0) {\n\t\tthis->barometer_calibration_factor = this->altitude;\n\t}\n\n\tif (this->depth_sensor_present) {\n\t\tthis->barometer_health = this->barometer.check_health();\n\t}\n}", "CodeBleu_score": 16.779624761848787}, {"code": "void Sub::read_barometer(){\n\t\tif (this->altitude > 0) {\n\t\tthis->barometer_calibrated = true;\n\t}\n\tif (this->depth_sensor_present) {\n\t\tthis->barometer_health = this->barometer_health_ok;\n\t}\n}", "CodeBleu_score": 14.814615569359384}, {"code": "void Sub::read_barometer(){\n\t\tif (this->barometer_present) {\n\t\tthis->barometer_present = this->barometer.read();\n\t\tthis->barometer_health = this->barometer.health();\n\t\tif (this->barometer_present) {\n\t\t\tthis->barometer_calibration = this->barometer.calibration();\n\t\t\tif (this->barometer_calibration.altitude_valid) {\n\t\t\t\tthis->barometer_altitude = this->barometer_calibration.altitude;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 13.124872459719022}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\tif (motors.armed()) {\n\t\tif (position_ok) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 16.670232226457593}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!motors.armed()) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_NONE) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_ANGLE) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD_IN_RANGE) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD_IN_ANGLE) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD_IN_ANGULAR_RANGE) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD_IN_ANGULAR_SPEED) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD_IN_ANGULAR_SPEED_ACCEL) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD_IN_ANGULAR_SPEED_ACCEL_DECCEL) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD_IN_ANGULAR_SPEED_ACCEL_DECCEL_YAW) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD_IN_ANGULAR_SPEED_ACCEL_YAW) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD_IN_ANGULAR_SPEED_DECCEL_YAW) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() == MOTOR_MODE_HOLD_IN_SPEED_YAW) {\n\t\treturn true;\n\t}\n\tif (motors.get_mode() ==", "CodeBleu_score": 42.834011329493435}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.initialised()) {\n\t\treturn false;\n\t}\n\tif (motors.armed()) {\n\t\tif (motors.get_mode() == MOTOR_MODE_NONE) {\n\t\t\treturn true;\n\t\t}\n\t\tif (ahrs.get_ekf_ok()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 33.25814566073777}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (control_mode == STABILIZE) {\n\t\treturn true;\n\t}\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\tif (!ahrs.initialised) {\n\t\tif (display_failure) {\n\t\t\tprint_text(\"GPS AHRS not initialised\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (ekf.using_gps() && ekf.get_ekf_ok_status() != AP_InertialSensor::EKF_OK_GPS) {\n\t\tif (display_failure) {\n\t\t\tprint_text(\"EKF GPS fail\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (ahrs.get_status() != AP_AHRS::INITIALISED) {\n\t\tif (display_failure) {\n\t\t\tprint_text(\"GPS AHRS not initialised\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (ahrs.get_attitude().rollspeed > 0.2f || ahrs.get_attitude().pitchspeed > 0.2f || ahrs.get_attitude().yawspeed > 0.2f) {\n\t\tif (display_failure) {\n\t\t\tprint_text(\"GPS AHRS moving\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (!ahrs.get_position_valid()) {\n\t\tif (display_failure) {\n\t\t\tprint_text(\"GPS position invalid\");\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 48.028602991254346}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// call the parent class's GPS checks\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\t// check if the EKF has a valid position estimate\n\tif (!ahrs.is_healthy()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(MAV_SEVERITY_WARNING, PSTR(\"EKF not initialised\"));\n\t\t}\n\t\treturn false;\n\t}\n\t// check if the EKF failsafe is active\n\tif (ahrs.get_ekf_ok_status() != AP_AHRS::EKF_OK_STATUS_OK) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(MAV_SEVERITY_WARNING, PSTR(\"EKF failsafe active\"));\n\t\t}\n\t\treturn false;\n\t}\n\t// check if the AHRS system is ready\n\tif (!ahrs.get_status()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(MAV_SEVERITY_WARNING, PSTR(\"AHRS not initialised\"));\n\t\t}\n\t\treturn false;\n\t}\n\t// check if the position estimate is valid\n\tif (!ahrs.get_position_valid()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(MAV_SEVERITY_WARNING, PSTR(\"Position invalid\"));\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 53.077722474478364}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif ( _vehicle->control_mode != ROVER_GUIDED && _vehicle->control_mode != ROVER_AUTO && _vehicle->control_mode != ROVER_LOITER && _vehicle->control_mode != ROVER_STABILIZE && _vehicle->control_mode != ROVER_LAND ) {\n\t\treturn true;\n\t}\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\tif (!ahrs_check()) {\n\t\tif (display_failure) {\n\t\t\t_vehicle->console->print_no_lf(\"EKF not ready\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (!ekf_check()) {\n\t\tif (display_failure) {\n\t\t\t_vehicle->console->print_no_lf(\"EKF failsafe\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (!position_check()) {\n\t\tif (display_failure) {\n\t\t\t_vehicle->console->print_no_lf(\"Invalid position\");\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.04803404097213}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (do_arming_checks) {\n\t\tif (!check_prearm_conditions()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (!check_arming_requirements(method)) {\n\t\treturn false;\n\t}\n\tif (method == AP_Arming::DISARM) {\n\t\t// disarming\n\t\tif (!check_disarming_requirements()) {\n\t\t\treturn false;\n\t\t}\n\t\t// disarm\n\t\tif (!disarm()) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// arming\n\t\tif (!arm_motors()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_gps()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_optical_flow()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_camera()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_rangefinder()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_baro()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_rangefinder_leds()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_leds()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos_misc()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos_rc_override()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos_failsafe()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos_throttle()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos_yaw()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos_yaw_failsafe()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos_yaw_throttle()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos_yaw_control()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos_yaw_control_failsafe()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!arm_servos_yaw_control_throttle()) {\n\t\t\treturn false;\n\t\t", "CodeBleu_score": 23.131519099059012}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// arm the rover\n\tbool armed = AP_Arming::arm(method, do_arming_checks);\n\tif (!armed) {\n\t\treturn false;\n\t}\n\n\t// set the home location\n\tif (should_set_home_position()) {\n\t\tset_home_position();\n\t}\n\n\t// initialize the simple mode heading\n\tif (should_set_simple_mode_heading()) {\n\t\tset_simple_mode_heading();\n\t}\n\n\t// record the home heading for sail vehicles\n\tif (should_record_home_heading()) {\n\t\trecord_home_heading();\n\t}\n\n\t// update the soft armed status\n\tupdate_soft_armed_status();\n\n\t// send an arm/disarm status text\n\tsend_arm_status_text();\n\n\t// return success\n\treturn true;\n}", "CodeBleu_score": 46.98059611083982}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// check arming status\n\tif (is_armed()) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\t// check arming checks\n\tif (do_arming_checks) {\n\t\tif (!check_arming_checks()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// attempt to arm\n\tif (!attempt_arm(method)) {\n\t\t// arming failed\n\t\tset_armed(false);\n\t\tset_armed_status(AP_Arming::ARMED_STATUS_FAILED);\n\t\treturn false;\n\t}\n\t// arming succeeded\n\tset_armed(true);\n\tset_armed_status(AP_Arming::ARMED_STATUS_ARMED);\n\t// set home location\n\tif (!set_home_location()) {\n\t\t// home location not set\n\t\treturn false;\n\t}\n\t// set simple mode heading\n\tif (!set_simple_mode_heading()) {\n\t\t// simple mode heading not set\n\t\treturn false;\n\t}\n\t// record home heading\n\tif (is_sail_vehicle()) {\n\t\tif (!record_home_heading()) {\n\t\t\t// home heading not recorded\n\t\t\treturn false;\n\t\t}\n\t}\n\t// update soft armed status\n\tupdate_soft_armed_status();\n\t// send arm/disarm status text\n\tsend_arm_status_text();\n\treturn true;\n}", "CodeBleu_score": 42.42511976472708}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (charging_state == CHARGING_ENABLED) {\n\t\t\tif (charging_time_ms + CHARGING_TIME_MS < millis()) {\n\t\t\t\tcharging_time_ms = millis();\n\t\t\t\tcharging_state = CHARGING_TIMED_OUT;\n\t\t\t\tdigitalWrite(PIN_CHARGER_EN, LOW);\n\t\t\t\tSerial.println(\"Charging timed out\");\n\t\t\t}\n\t\t} else if (charging_state == CHARGING_TIMED_OUT) {\n\t\t\tif (charging_time_ms + CHARGING_RETRY_MS < millis()) {\n\t\t\t\tcharging_time_ms = millis();\n\t\t\t\tif (battery_voltage > BATTERY_VOLTAGE_CUTOFF) {\n\t\t\t\t\tcharging_state = CHARGING_ENABLED;\n\t\t\t\t\tdigitalWrite(PIN_CHARGER_EN, HIGH);\n\t\t\t\t\tSerial.println(\"Charging enabled\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_state == CHARGING_ENABLED) {\n\t\t\tcharging_state = CHARGING_DISABLED;\n\t\t\tdigitalWrite(PIN_CHARGER_EN, LOW);\n\t\t\tSerial.println(\"Charging disabled\");\n\t\t}\n\t}\n}", "CodeBleu_score": 52.966078189815825}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_start_time = millis();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tif (millis() - charging_start_time > CHARGING_DISABLE_DELAY) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t}\n\t\t} else {\n\t\t\tcharging_start_time = millis();\n\t\t}\n\t}\n}", "CodeBleu_score": 37.97093449713187}, {"code": "void updateChargingEnabled(){\n\t\t// If charging is not allowed, disable it.\n\tif (!charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_disabled_time = millis();\n\t\t}\n\t} else {\n\t\t// If charging is allowed, enable it.\n\t\tif (!charging_enabled) {\n\t\t\tcharging_enabled = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 24.91402899259559}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (rosRunning && size >= 4) {\n\t\tFastCRC8 crc8;\n\t\tuint8_t crc = crc8.calculate(message, size - 1);\n\t\t((uint8_t *)message)[size - 1] = crc;\n\t\tpacketSerial.write(message, size);\n\t}\n}", "CodeBleu_score": 39.93724947780809}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (rosRunning && size >= 4) {\n\t\tuint16_t crc = 0;\n\t\tFastCRC16 CRC16;\n\t\tcrc = CRC16.crc16(message, size);\n\t\tuint8_t crcBytes[2];\n\t\tcrcBytes[0] = crc >> 8;\n\t\tcrcBytes[1] = crc & 0xFF;\n\t\tpacketSerial.write(message, size);\n\t\tpacketSerial.write(crcBytes, 2);\n\t}\n}", "CodeBleu_score": 36.94278880834095}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (rosRunning && size >= 4) {\n\t\t// Calculate CRC\n\t\tFastCRC16 CRC16;\n\t\tuint16_t crc = CRC16.calculate((uint8_t *) message, size - 2);\n\t\t((uint8_t *) message)[size - 2] = crc & 0xFF;\n\t\t((uint8_t *) message)[size - 1] = crc >> 8;\n\t\t// Send message\n\t\tpacketSerial.write((uint8_t *) message, size);\n\t}\n}", "CodeBleu_score": 59.2701564949614}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\t// Initialize serial communication with the sound module\n\tSerial.begin(9600);\n\t// Clear any existing data in the buffer\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\t// Initialize the sound module\n\tSerial.write(0x01);\n\t// Retrieve the number of sound files available on the SD card\n\tSerial.write(0x02);\n\t// Return true if there are one or more sound files available\n\treturn Serial.read() > 0;\n}", "CodeBleu_score": 40.776224428309796}, {"code": "bool MP3Sound::begin(){\n\t\tif (!Serial.begin(9600)) {\n\t\treturn false;\n\t}\n\tSerial.flush();\n\tSerial.println(\"MP3Sound::begin\");\n\tif (!SD.begin(4)) {\n\t\tSerial.println(\"Card Mount Failed\");\n\t\treturn false;\n\t}\n\tSerial.println(\"Card Mounted\");\n\tif (!SD.exists(\"/sounds\")) {\n\t\tSerial.println(\"Sounds Directory Not Found\");\n\t\treturn false;\n\t}\n\tSerial.println(\"Sounds Directory Found\");\n\tFile soundsDir = SD.open(\"/sounds\");\n\tif (!soundsDir.isDirectory()) {\n\t\tSerial.println(\"Sounds Directory Not Found\");\n\t\treturn false;\n\t}\n\tSerial.println(\"Sounds Directory Found\");\n\tint fileCount = 0;\n\twhile (soundsDir.openNextFile()) {\n\t\tfileCount++;\n\t}\n\tsoundsDir.close();\n\tSerial.print(\"Sound Files Found: \");\n\tSerial.println(fileCount);\n\tif (fileCount == 0) {\n\t\tSerial.println(\"No Sound Files Found\");\n\t\treturn false;\n\t}\n\tSerial.println(\"Sound Module Initialized\");\n\treturn true;\n}", "CodeBleu_score": 44.43446999973522}, {"code": "bool MP3Sound::begin(){\n\t\t//Serial.begin(9600);\n\tif (!SD.begin(SD_CS)) {\n\t\tSerial.println(\"Card Mount Failed\");\n\t\treturn false;\n\t}\n\t//Serial.println(\"Card Mounted\");\n\tif (!MP3.begin(MP3_CS)) {\n\t\tSerial.println(\"MP3 Module Not Found\");\n\t\treturn false;\n\t}\n\t//Serial.println(\"MP3 Module Found\");\n\tMP3.volume(0);\n\tMP3.setLoop(true);\n\tMP3.setSingleLoop(true);\n\tMP3.setPin(MP3_CS);\n\tMP3.setPinEnable(MP3_CS);\n\t//Serial.println(\"MP3 Module Initialized\");\n\treturn true;\n}", "CodeBleu_score": 31.852338408877902}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (this->activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\telse if (this->activeSounds.front()->isPlaying()) {\n\t\treturn this->activeSounds.size();\n\t}\n\telse {\n\t\tthis->activeSounds.front()->play();\n\t\tthis->activeSounds.pop_front();\n\t\treturn this->activeSounds.size();\n\t}\n}", "CodeBleu_score": 15.867621428374862}, {"code": "int MP3Sound::processSounds(){\n\t\t// Check if there are any active sounds\n\tif(this->activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\n\t// Check if an MP3 is currently playing\n\tif(this->isPlaying) {\n\t\treturn this->activeSounds.size();\n\t}\n\n\t// Retrieve the last sound from the active sounds list\n\tSound* sound = this->activeSounds.back();\n\tthis->activeSounds.pop_back();\n\n\t// Play the sound\n\tthis->play(sound);\n\n\t// Return the updated number of active sounds\n\treturn this->activeSounds.size();\n}", "CodeBleu_score": 22.00595740308505}, {"code": "int MP3Sound::processSounds(){\n\t\tint numActiveSounds = 0;\n\tfor (int i = 0; i < MAX_ACTIVE_SOUNDS; i++) {\n\t\tif (activeSounds[i].sound != NULL) {\n\t\t\tnumActiveSounds++;\n\t\t}\n\t}\n\tif (numActiveSounds == 0) {\n\t\treturn 0;\n\t}\n\tif (isMP3Playing) {\n\t\treturn numActiveSounds;\n\t}\n\tif (numActiveSounds == 1) {\n\t\tplayMP3(activeSounds[0].sound);\n\t\tactiveSounds[0].sound = NULL;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < MAX_ACTIVE_SOUNDS; i++) {\n\t\tif (activeSounds[i].sound != NULL) {\n\t\t\tplayMP3(activeSounds[i].sound);\n\t\t\tactiveSounds[i].sound = NULL;\n\t\t\treturn numActiveSounds - 1;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 33.58986994214916}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\nWbAbstractCamera *ac = (WbAbstractCamera *)d;\n\nif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n\nif (ac->memory_mapped_file)\nfclose(ac->memory_mapped_file);\n\nac->memory_mapped_file = fopen(r->data, \"r+b\");\n\nif (!ac->memory_mapped_file)\nreturn false;\n\nac->memory_mapped_file_size = r->size;\n\nreturn true;\n\n}\n\nreturn false;\n\n}", "CodeBleu_score": 36.66943417728774}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *)d;\n\tif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n\t\tchar *filename = NULL;\n\t\tint width = 0;\n\t\tint height = 0;\n\t\tint format = 0;\n\t\tint quality = 0;\n\t\tint result = 0;\n\t\tif (r->p[0] == NULL || r->p[1] == NULL || r->p[2] == NULL || r->p[3] == NULL || r->p[4] == NULL)\n\t\t\treturn false;\n\t\tfilename = (char *)r->p[0];\n\t\twidth = atoi(r->p[1]);\n\t\theight = atoi(r->p[2]);\n\t\tformat = atoi(r->p[3]);\n\t\tquality = atoi(r->p[4]);\n\t\tif (ac->memory_mapped_filename)\n\t\t\tfree(ac->memory_mapped_filename);\n\t\tac->memory_mapped_filename = strdup(filename);\n\t\tif (ac->memory_mapped_filename == NULL)\n\t\t\treturn false;\n\t\tresult = wb_abstract_camera_setup_memory_mapped_file(ac, filename, width, height, format, quality);\n\t\tif (result == 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn false;\n}", "CodeBleu_score": 37.212461614242876}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\nWbAbstractCamera *cam = (WbAbstractCamera *)d;\n\nif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n\nif (cam->memory_mapped_file) {\n\nfclose(cam->memory_mapped_file);\n\n}\n\ncam->memory_mapped_file = fopen(r->data, \"r+b\");\n\nif (!cam->memory_mapped_file) {\n\nfprintf(stderr, \"Error opening memory mapped file '%s'.\n\", r->data);\n\nreturn true;\n\n}\n\nreturn true;\n\n}\n\nreturn false;\n\n}", "CodeBleu_score": 30.164549001825225}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\twb_abstract_camera_get_width(d);\n\treturn 0;\n}", "CodeBleu_score": 3.1190103828326423}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\nWbAbstractCamera *cam = (WbAbstractCamera *)d;\n\nint height;\n\nif (cam == NULL)\n\nreturn -1;\n\nif (cam->mutex == NULL)\n\nreturn -1;\n\nif (cam->mutex->status == MUTEX_LOCKED)\n\nreturn -1;\n\ncam->mutex->lock(cam->mutex);\n\nheight = cam->height;\n\ncam->mutex->unlock(cam->mutex);\n\nreturn height;\n\n}", "CodeBleu_score": 38.44385494677369}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\twb_abstract_camera_t *cam = (wb_abstract_camera_t *)d;\n\tint height = -1;\n\n\tif (cam->mutex != NULL)\n\t\tpthread_mutex_lock(cam->mutex);\n\n\tif (cam->data_available)\n\t\theight = cam->height;\n\n\tif (cam->mutex != NULL)\n\t\tpthread_mutex_unlock(cam->mutex);\n\n\treturn height;\n}", "CodeBleu_score": 41.50187752961136}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period = 0;\n\tWbDevice *device = robot_get_device_with_tag(tag);\n\n\tif (device == NULL) {\n\t\tfprintf(stderr, \"Error: Accelerometer device not found.\n\");\n\t\treturn 0;\n\t} else if (device->type != WB_NODE_ACCELEROMETER) {\n\t\tfprintf(stderr, \"Error: Device with tag %d is not an accelerometer.\n\", tag);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(device->mutex);\n\n\tsampling_period = ((WbAccelerometer *)device->pdata)->sampling_period;\n\n\tmutex_unlock(device->mutex);\n\n\treturn sampling_period;\n}", "CodeBleu_score": 50.14245030936312}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tstruct Accelerometer *accelerometer;\n\n\tif (tag < 0 || tag >= WB_MAX_DEVICES)\n\t\twb_log_error(\"Invalid device tag %d.\", tag);\n\telse if (!(accelerometer = robot_get_device_with_tag(tag, WB_NODE_ACCELEROMETER)))\n\t\twb_log_error(\"No accelerometer with tag %d.\", tag);\n\telse {\n\t\tpthread_mutex_lock(&accelerometer->mutex);\n\t\tsampling_period = accelerometer->sampling_period;\n\t\tpthread_mutex_unlock(&accelerometer->mutex);\n\t}\n\n\treturn sampling_period;\n}", "CodeBleu_score": 43.56053553099113}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period = 0;\n\tWbDevice *device = robot_get_device_with_node(tag, WB_NODE_ACCELEROMETER);\n\n\tif (device == NULL)\n\t\tfprintf(stderr, \"Error: wb_accelerometer_get_sampling_period() called with an invalid tag.\n\");\n\telse {\n\t\twb_mutex_lock(device->mutex);\n\t\tsampling_period = ((WbAccelerometer *)device->tag)->sampling_period;\n\t\twb_mutex_unlock(device->mutex);\n\t}\n\n\treturn sampling_period;\n}", "CodeBleu_score": 49.954651516759576}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring s(dmsString);\n\tfree(dmsString);\n\treturn s;\n}", "CodeBleu_score": 40.066746601473014}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tint degrees = (int) decimalDegree;\n\tint minutes = (int) round((decimalDegree - degrees) * 60);\n\tdouble seconds = (decimalDegree - degrees - minutes / 60.0) * 3600;\n\n\tstring dms = to_string(degrees) + \"\u00b0 \" + to_string(minutes) + \"' \" + to_string(seconds) + \"''\";\n\n\treturn dms;\n}", "CodeBleu_score": 40.21566850649803}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = dms;\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 41.90011620056393}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdVector3 p;\n\tdReal sign;\n\tdReal min_dist;\n\tdReal max_dist;\n\tdReal dist;\n\tdReal min_sign;\n\tdReal max_sign;\n\tdReal sign_x;\n\tdReal sign_y;\n\tdReal sign_z;\n\tdReal normal_x;\n\tdReal normal_y;\n\tdReal normal_z;\n\tdReal box_x;\n\tdReal box_y;\n\tdReal box_z;\n\tdReal box_r;\n\tdReal box_l;\n\tdReal box_b;\n\tdReal box_t;\n\tdReal box_c;\n\tdReal box_d;\n\tdReal box_e;\n\tdReal box_f;\n\tdReal box_g;\n\tdReal box_h;\n\tdReal box_i;\n\tdReal box_j;\n\tdReal box_k;\n\tdReal box_l;\n\tdReal box_m;\n\tdReal box_n;\n\tdReal box_o;\n\tdReal box_p;\n\tdReal box_q;\n\tdReal box_r;\n\tdReal box_s;\n\tdReal box_t;\n\tdReal box_u;\n\tdReal box_v;\n\tdReal box_w;\n\tdReal box_x;\n\tdReal box_y;\n\tdReal box_z;\n\tdReal box_aa;\n\tdReal box_ab;\n\tdReal box_ac;\n\tdReal box_ad;\n\tdReal box_ae;\n\tdReal box_af;\n\tdReal box_ag;\n\tdReal box_ah;\n\tdReal box_ai;\n\tdReal box_aj;\n\tdReal box_ak;\n\tdReal box_al;\n\tdReal box_am;\n\tdReal box_an;\n\tdReal box_ao;\n\tdReal box_ap;\n\tdReal box_aq;\n\tdReal box_ar;\n\tdReal box_as;\n\tdReal box_at;\n\tdReal box_", "CodeBleu_score": 8.574366757810376}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdVector3 p;\n\tdReal sign;\n\tdReal x_abs, y_abs, z_abs;\n\tdReal x_sign, y_sign, z_sign;\n\tdGeomBoxGetLengths (g, p);\n\tx -= dReal(0.5) * p[0];\n\ty -= dReal(0.5) * p[1];\n\tz -= dReal(0.5) * p[2];\n\tx_abs = dFabs (x);\n\ty_abs = dFabs (y);\n\tz_abs = dFabs (z);\n\tif (x_abs > y_abs) {\n\t\tif (x_abs > z_abs) {\n\t\t\tx_sign = dSign (x);\n\t\t\tsign = dReal(1.0) / dSqrt (x_abs * x_abs + y_abs * y_abs);\n\t\t\tplane[0] = x_sign * sign;\n\t\t\tplane[1] = y * sign;\n\t\t\tplane[2] = z * sign;\n\t\t\tplane[3] = -x * plane[0] - y * plane[1] - z * plane[2];\n\t\t}\n\t\telse {\n\t\t\tz_sign = dSign (z);\n\t\t\tsign = dReal(1.0) / dSqrt (x_abs * x_abs + z_abs * z_abs);\n\t\t\tplane[0] = x * sign;\n\t\t\tplane[1] = y * sign;\n\t\t\tplane[2] = z_sign * sign;\n\t\t\tplane[3] = -x * plane[0] - y * plane[1] - z * plane[2];\n\t\t}\n\t}\n\telse {\n\t\tif (y_abs > z_abs) {\n\t\t\ty_sign = dSign (y);\n\t\t\tsign = dReal(1.0) / dSqrt (y_abs * y_abs + z_abs * z_abs);\n\t\t\tplane[0] = x * sign;\n\t\t\tplane[1] = y_sign * sign;\n\t\t\tplane[2] = z * sign;\n\t\t\tplane[3] = -x * plane[0] - y * plane[1] - z * plane[2];\n\t", "CodeBleu_score": 35.03755646848211}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdAASSERT (g && plane);\n\tconst dReal *p = dGeomGetPosition (g);\n\tconst dReal *R = dGeomGetRotation (g);\n\tdReal a, b, c;\n\tdReal sign;\n\tdVector3 tmp;\n\tdVector3 pRel;\n\tdReal minProj;\n\tdReal maxProj;\n\tdReal minProjAxis;\n\tdReal maxProjAxis;\n\tdReal signAxis;\n\tdReal dist;\n\tdReal distAxis;\n\tdReal distAxis2;\n\tdReal distAxis3;\n\tdReal distAxis4;\n\tdReal distAxis5;\n\tdReal distAxis6;\n\tdReal distAxis7;\n\tdReal distAxis8;\n\tdReal distAxis9;\n\tdReal distAxis10;\n\tdReal distAxis11;\n\tdReal distAxis12;\n\tdReal distAxis13;\n\tdReal distAxis14;\n\tdReal distAxis15;\n\tdReal distAxis16;\n\tdReal distAxis17;\n\tdReal distAxis18;\n\tdReal distAxis19;\n\tdReal distAxis20;\n\tdReal distAxis21;\n\tdReal distAxis22;\n\tdReal distAxis23;\n\tdReal distAxis24;\n\tdReal distAxis25;\n\tdReal distAxis26;\n\tdReal distAxis27;\n\tdReal distAxis28;\n\tdReal distAxis29;\n\tdReal distAxis30;\n\tdReal distAxis31;\n\tdReal distAxis32;\n\tdReal distAxis33;\n\tdReal distAxis34;\n\tdReal distAxis35;\n\tdReal distAxis36;\n\tdReal distAxis37;\n\tdReal distAxis38;\n\tdReal distAxis39;\n\tdReal distAxis40;\n\tdReal distAxis41;\n\tdReal distAxis42;\n\tdReal distAxis43;\n\tdReal distAxis44;\n\tdReal distAxis45;\n\tdReal", "CodeBleu_score": 8.78869004607002}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdIASSERT (box);\n\tdIASSERT (box->body);\n\tdIASSERT (box->flags & dGeomBoxUser2);\n\tdIASSERT (fluidPlane);\n\tdIASSERT (immersion);\n\tdIASSERT (flags >= 0);\n\tdIASSERT (flags <= 15);\n\n\tdAASSERT (box);\n\tdAASSERT (box->body);\n\tdAASSERT (box->flags & dGeomBoxUser2);\n\tdAASSERT (fluidPlane);\n\tdAASSERT (immersion);\n\tdAASSERT (flags >= 0);\n\tdAASSERT (flags <= 15);\n\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.immersion = immersion;\n\tdata.flags = flags;\n\n\treturn dImmerseBox (&data);\n}", "CodeBleu_score": 40.57029501103319}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t#ifndef dNODEBUG\n  if (box == NULL) {\n    dDebug (0, \"argument 1 (box) is NULL\");\n    return -1;\n  }\n  if (fluidPlane == NULL) {\n    dDebug (0, \"argument 2 (fluidPlane) is NULL\");\n    return -2;\n  }\n  if (immersion == NULL) {\n    dDebug (0, \"argument 3 (immersion) is NULL\");\n    return -3;\n  }", "CodeBleu_score": 39.79512492231567}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdIASSERT (box);\n\tdIASSERT (box->body);\n\tdIASSERT (box->flags & dxBody::BF_ENABLED);\n\tdIASSERT (box->flags & dxBody::BF_IMMERSION_PERMITTED);\n\tdIASSERT (fluidPlane);\n\tdIASSERT (flags & (dImmersionGeom::IMMERSION_ALL | dImmersionGeom::IMMERSION_OUTLINE));\n\n\tsBoxImmersionData data (box, fluidPlane, flags);\n\tdImmersionGeom result = dImmersionBox (&data);\n\n\tif (immersion) {\n\t\t*immersion = result;\n\t}\n\n\treturn result.status;\n}", "CodeBleu_score": 44.821190505307634}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (o1->type == dBoxClass);\n\tdIASSERT (o2->type == dCapsuleClass);\n\tdIASSERT (flags & NUMC_MASK);\n\tdIASSERT (immersion);\n\n\tdAASSERT (dGeomGetClass (o1) == dBoxClass);\n\tdAASSERT (dGeomGetClass (o2) == dCapsuleClass);\n\tdAASSERT (dGeomGetSpaceID (o1) == dGeomGetSpaceID (o2));\n\n\tdVector3 p1, p2;\n\tdReal r;\n\tdGeomBoxGetLengths (o1, p1);\n\tdGeomCapsuleGetParams (o2, &r, &p2);\n\n\tdReal p1_x = p1[0];\n\tdReal p1_y = p1[1];\n\tdReal p1_z = p1[2];\n\n\tdReal p2_x = p2[0];\n\tdReal p2_y = p2[1];\n\tdReal p2_z = p2[2];\n\n\tdReal r_sq = r * r;\n\n\tdReal p1_x_sq = p1_x * p1_x;\n\tdReal p1_y_sq = p1_y * p1_y;\n\tdReal p1_z_sq = p1_z * p1_z;\n\n\tdReal p2_x_sq = p2_x * p2_x;\n\tdReal p2_y_sq = p2_y * p2_y;\n\tdReal p2_z_sq = p2_z * p2_z;\n\n\tdReal p1_x_p2_x_sq = p1_x_sq + p2_x_sq;\n\tdReal p1_y_p2_y_sq = p1_y_sq + p2_y_sq;\n\tdReal p1_z_p2_z_sq = p1_z_sq + p2_z_sq;\n\n\tdReal p1_x_p2_x = p1_x * p2_x;\n\tdReal p1_y_p2_y = p1", "CodeBleu_score": 33.12942341455277}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdAASSERT (o1 && o2 && immersion);\n\tdUASSERT (o1->type == dBoxClass && o2->type == dCapsuleClass, \"arguments must be a box and a capsule\");\n\tdUASSERT (o1->space == o2->space, \"arguments must be in the same space\");\n\tdUASSERT (flags & dImmersionGeom::dImmersionGeomCapsule, \"argument must be a capsule\");\n\n\tdAASSERT (o1->data && o2->data);\n\tdUASSERT (o1->data->fluid_data && o2->data->fluid_data, \"argument must be a fluid\");\n\n\tconst dImmersionGeomCapsule *immersion_capsule = static_cast<const dImmersionGeomCapsule *>(immersion);\n\n\tconst dImmersionGeomBox *immersion_box = static_cast<const dImmersionGeomBox *>(immersion);\n\n\tconst dReal *p1 = o1->final_posr->pos;\n\tconst dReal *p2 = o2->final_posr->pos;\n\tconst dReal *R1 = o1->final_posr->R;\n\tconst dReal *R2 = o2->final_posr->R;\n\n\tconst dReal *side_lengths = o1->data->side;\n\tconst dReal *capsule_radius = o2->data->radius;\n\tconst dReal *capsule_length = o2->data->length;\n\n\tdVector3 p1_capsule, p2_capsule;\n\tdMatrix3 R1_capsule, R2_capsule;\n\n\tdGeomTransformVector(o1, p1, p1_capsule);\n\tdGeomTransformVector(o2, p2, p2_capsule);\n\tdGeomTransformMatrix(o1, R1, R1_capsule);\n\tdGeomTransformMatrix(o2, R2, R2_capsule);\n\n\tdVector3 capsule_axis;\n\tdReal capsule_radius_squared;\n\tdReal capsule_length_squared;\n\tdReal capsule_center_distance_squared;\n\n\tdReal side_length_squared;\n\tdReal side_center_distance", "CodeBleu_score": 38.43260021017903}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdAASSERT (o1 && o2 && immersion);\n\tdAASSERT (o1->type == dBoxClass && o2->type == dCapsuleClass);\n\tdAASSERT (flags == 0);\n\n\tdImmersionBox *immBox = (dImmersionBox*) o1->data;\n\tdImmersionCapsule *immCapsule = (dImmersionCapsule*) o2->data;\n\n\t// Check the input arguments\n\tif (immCapsule->radius > immBox->radius) {\n\t\treturn 0;\n\t}\n\n\t// Set the immersion parameters\n\timmersion->type = dImmersionGeom::dIMMERSION_CAPSULE;\n\timmersion->o1 = o1;\n\timmersion->o2 = o2;\n\timmersion->immersionMode = dImmersionMode::dIMMERSION_MODE_NONE;\n\timmersion->immersionParams[0] = 0;\n\timmersion->immersionParams[1] = 0;\n\timmersion->immersionParams[2] = 0;\n\timmersion->immersionParams[3] = 0;\n\timmersion->immersionParams[4] = 0;\n\timmersion->immersionParams[5] = 0;\n\timmersion->immersionParams[6] = 0;\n\timmersion->immersionParams[7] = 0;\n\n\t// Compute the immersion plane\n\tdVector3 p1, p2;\n\tdGeomCapsuleGetParams (o2, &p1[0], &p2[0], &immersion->immersionParams[0]);\n\tdGeomBoxPointDepth (o1, &p1[0], &immersion->immersionParams[1]);\n\tdGeomBoxPointDepth (o1, &p2[0], &immersion->immersionParams[2]);\n\n\tif (immersion->immersionParams[1] > 0 && immersion->immersionParams[2] > 0) {\n\t\treturn 0;\n\t}\n\n\tif (immersion->immersionParams[1] < 0 && immersion->immersionParams[2] < 0) {\n\t\treturn 0;\n\t}\n\n\tif (imm", "CodeBleu_score": 39.57234732851379}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal volume = 0.0;\n\n\tdReal z0 = zIOverR * tanTheta0;\n\tdReal z1 = zIOverR * sinTheta1;\n\n\tif (z0 == 0.0) {\n\t\tvolume = 1.0 / 3.0 * M_PI * zIOverR * zIOverR * zIOverR;\n\t} else if (z1 == 0.0) {\n\t\tvolume = 1.0 / 3.0 * M_PI * zIOverR * zIOverR * zIOverR;\n\t} else {\n\t\tdReal z0OverZ1 = z0 / z1;\n\t\tdReal z1OverZ0 = z1 / z0;\n\n\t\tdReal z0OverZ1Squared = z0OverZ1 * z0OverZ1;\n\t\tdReal z1OverZ0Squared = z1OverZ0 * z1OverZ0;\n\n\t\tdReal z0OverZ1Cubed = z0OverZ1Squared * z0OverZ1;\n\t\tdReal z1OverZ0Cubed = z1OverZ0Squared * z1OverZ0;\n\n\t\tdReal z0OverZ1SquaredOverZ1 = z0OverZ1Squared / z1;\n\t\tdReal z1OverZ0SquaredOverZ0 = z1OverZ0Squared / z0;\n\n\t\tdReal z0OverZ1CubedOverZ1Squared = z0OverZ1Cubed / z1Squared;\n\t\tdReal z1OverZ0CubedOverZ0Squared = z1OverZ0Cubed / z0Squared;\n\n\t\tdReal term1 = z0OverZ1SquaredOverZ1 * (1.0 / 6.0 * z0OverZ1Cubed + 1.0 / 3.0 * z0OverZ1Squared);\n\t\tdReal term2 = z1OverZ0SquaredOverZ0 * (1.0 / 6.0 * z1OverZ0Cubed + 1.0 / 3.0 * z1OverZ0Squared);\n\n\t\tvolume = term1 + term2;\n\t}\n\n\treturn volume;\n}", "CodeBleu_score": 37.03007287774729}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal volume = 0.0;\n\tdReal zI = zIOverR * m_radius;\n\tdReal zJ = zIOverR * m_radius;\n\tdReal zK = zIOverR * m_radius;\n\tdReal zL = zIOverR * m_radius;\n\tdReal zM = zIOverR * m_radius;\n\tdReal zN = zIOverR * m_radius;\n\tdReal zO = zIOverR * m_radius;\n\tdReal zP = zIOverR * m_radius;\n\tdReal zQ = zIOverR * m_radius;\n\tdReal zR = zIOverR * m_radius;\n\tdReal zS = zIOverR * m_radius;\n\tdReal zT = zIOverR * m_radius;\n\tdReal zU = zIOverR * m_radius;\n\tdReal zV = zIOverR * m_radius;\n\tdReal zW = zIOverR * m_radius;\n\tdReal zX = zIOverR * m_radius;\n\tdReal zY = zIOverR * m_radius;\n\tdReal zZ = zIOverR * m_radius;\n\tdReal zA = zIOverR * m_radius;\n\tdReal zB = zIOverR * m_radius;\n\tdReal zC = zIOverR * m_radius;\n\tdReal zD = zIOverR * m_radius;\n\tdReal zE = zIOverR * m_radius;\n\tdReal zF = zIOverR * m_radius;\n\tdReal zG = zIOverR * m_radius;\n\tdReal zH = zIOverR * m_radius;\n\tdReal zI2 = zIOverR * m_radius;\n\tdReal zJ2 = zIOverR * m_radius;\n\tdReal zK2 = zIOverR * m_radius;\n\tdReal zL2 = zIOverR * m_radius;\n\tdReal zM2 = zIOverR * m_radius;\n", "CodeBleu_score": 15.390309281128859}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal volume = 0.0;\n\n\tdReal z0 = 0.0;\n\tdReal z1 = 0.0;\n\n\tdReal z0z0 = 0.0;\n\tdReal z0z1 = 0.0;\n\tdReal z1z1 = 0.0;\n\n\tdReal z0z0z0 = 0.0;\n\tdReal z0z0z1 = 0.0;\n\tdReal z0z1z1 = 0.0;\n\tdReal z1z1z1 = 0.0;\n\n\tdReal z0z0z0z0 = 0.0;\n\tdReal z0z0z0z1 = 0.0;\n\tdReal z0z0z1z1 = 0.0;\n\tdReal z0z1z1z1 = 0.0;\n\tdReal z1z1z1z1 = 0.0;\n\n\tdReal z0z0z0z0z0 = 0.0;\n\tdReal z0z0z0z0z1 = 0.0;\n\tdReal z0z0z0z1z1 = 0.0;\n\tdReal z0z0z1z1z1 = 0.0;\n\tdReal z0z1z1z1z1 = 0.0;\n\tdReal z1z1z1z1z1 = 0.0;\n\n\tdReal z0z0z0z0z0z0 = 0.0;\n\tdReal z0z0z0z0z0z1 = 0.0;\n\tdReal z0z0z0z0z1z1 = 0.0;\n\tdReal z0z0z0z1z1z1 = 0.0;\n\tdReal z0z0z1z1z1z1 = 0.0;\n\tdReal z0z1z1z1z1z1 = 0.0;\n\tdReal z1z1z1z1z1z1 = 0.0;\n\n\tdReal z0z0", "CodeBleu_score": 12.480526443825312}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal result = 0;\n\tdReal z0 = 0;\n\tdReal z1 = 0;\n\tdReal z2 = 0;\n\tdReal z3 = 0;\n\tdReal z4 = 0;\n\tdReal z5 = 0;\n\tdReal z6 = 0;\n\tdReal z7 = 0;\n\tdReal z8 = 0;\n\tdReal z9 = 0;\n\tdReal z10 = 0;\n\tdReal z11 = 0;\n\tdReal z12 = 0;\n\tdReal z13 = 0;\n\tdReal z14 = 0;\n\tdReal z15 = 0;\n\tdReal z16 = 0;\n\tdReal z17 = 0;\n\tdReal z18 = 0;\n\tdReal z19 = 0;\n\tdReal z20 = 0;\n\tdReal z21 = 0;\n\tdReal z22 = 0;\n\tdReal z23 = 0;\n\tdReal z24 = 0;\n\tdReal z25 = 0;\n\tdReal z26 = 0;\n\tdReal z27 = 0;\n\tdReal z28 = 0;\n\tdReal z29 = 0;\n\tdReal z30 = 0;\n\tdReal z31 = 0;\n\tdReal z32 = 0;\n\tdReal z33 = 0;\n\tdReal z34 = 0;\n\tdReal z35 = 0;\n\tdReal z36 = 0;\n\tdReal z37 = 0;\n\tdReal z38 = 0;\n\tdReal z39 = 0;\n\tdReal z40 = 0;\n\tdReal z41 = 0;\n\tdReal z42 = 0;\n\tdReal z43 = 0;\n\tdReal z44 = 0;\n\tdReal z45 = 0;\n\tdReal z46 =", "CodeBleu_score": 9.716700279525808}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal zI = zIOverR * m_radius;\n\tdReal z1 = zI * sinTheta1;\n\tdReal z0 = zI * cos(m_theta0);\n\tdReal z02 = z0 * z0;\n\tdReal z12 = z1 * z1;\n\tdReal z0z1 = z0 * z1;\n\tdReal z0z12 = z0z1 * z12;\n\tdReal z0z13 = z0z12 * z1;\n\tdReal z0z14 = z0z13 * z1;\n\tdReal z0z15 = z0z14 * z1;\n\tdReal z0z16 = z0z15 * z1;\n\tdReal z0z17 = z0z16 * z1;\n\tdReal z0z18 = z0z17 * z1;\n\tdReal z0z19 = z0z18 * z1;\n\tdReal z0z110 = z0z19 * z1;\n\tdReal z0z111 = z0z110 * z1;\n\tdReal z0z112 = z0z111 * z1;\n\tdReal z0z113 = z0z112 * z1;\n\tdReal z0z114 = z0z113 * z1;\n\tdReal z0z115 = z0z114 * z1;\n\tdReal z0z116 = z0z115 * z1;\n\tdReal z0z117 = z0z116 * z1;\n\tdReal z0z118 = z0z117 * z1;\n\tdReal z0z119 = z0z118 * z1;\n\tdReal z0z120 = z0z119 * z1;\n\tdReal z0z121 = z0z120 * z1;\n\tdReal z0z122 = z0z121 * z1", "CodeBleu_score": 35.164768296791635}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal volumeOver3 = volume / 3.0;\n\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal zIOverR3 = zIOverR2 * zIOverR;\n\tdReal zIOverR4 = zIOverR3 * zIOverR;\n\tdReal zIOverR5 = zIOverR4 * zIOverR;\n\tdReal zIOverR6 = zIOverR5 * zIOverR;\n\tdReal zIOverR7 = zIOverR6 * zIOverR;\n\tdReal zIOverR8 = zIOverR7 * zIOverR;\n\tdReal zIOverR9 = zIOverR8 * zIOverR;\n\tdReal zIOverR10 = zIOverR9 * zIOverR;\n\tdReal zIOverR11 = zIOverR10 * zIOverR;\n\tdReal zIOverR12 = zIOverR11 * zIOverR;\n\tdReal zIOverR13 = zIOverR12 * zIOverR;\n\tdReal zIOverR14 = zIOverR13 * zIOverR;\n\tdReal zIOverR15 = zIOverR14 * zIOverR;\n\tdReal zIOverR16 = zIOverR15 * zIOverR;\n\tdReal zIOverR17 = zIOverR16 * zIOverR;\n\tdReal zIOverR18 = zIOverR17 * zIOverR;\n\tdReal zIOverR19 = zIOverR18 * zIOverR;\n\tdReal zIOverR20 = zIOverR19 * zIOverR;\n\tdReal zIOverR21 = zIOverR20 * zIOverR;\n\tdReal zIOverR22 = zIOverR21 * zIOverR;\n\tdReal zIOverR23 = zIOverR22 * zIOverR;\n\tdReal zIOverR24", "CodeBleu_score": 34.55556813319811}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdReal *p1, *p2, *p3;\n\tdReal *v1, *v2, *v3;\n\tdReal *n1, *n2, *n3;\n\tdReal *o1p, *o2p;\n\tdReal *o1v, *o2v;\n\tdReal *o1n, *o2n;\n\tdReal *o1r, *o2r;\n\tdReal *o1t, *o2t;\n\tdReal *o1s, *o2s;\n\tdReal *o1v0, *o2v0;\n\tdReal *o1v1, *o2v1;\n\tdReal *o1v2, *o2v2;\n\tdReal *o1v3, *o2v3;\n\tdReal *o1v4, *o2v4;\n\tdReal *o1v5, *o2v5;\n\tdReal *o1v6, *o2v6;\n\tdReal *o1v7, *o2v7;\n\tdReal *o1v8, *o2v8;\n\tdReal *o1v9, *o2v9;\n\tdReal *o1v10, *o2v10;\n\tdReal *o1v11, *o2v11;\n\tdReal *o1v12, *o2v12;\n\tdReal *o1v13, *o2v13;\n\tdReal *o1v14, *o2v14;\n\tdReal *o1v15, *o2v15;\n\tdReal *o1v16, *o2v16;\n\tdReal *o1v17, *o2v17;\n\tdReal *o1v18, *o2v18;\n\tdReal *o1v19, *o2v19;\n\tdReal *o1v20, *o2v20;\n\tdReal *o1v21, *o2v21;\n\tdReal *", "CodeBleu_score": 4.5895387916786445}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdVector3\t\tp;\n\tdReal\t\t\ttheta, sinTheta, cosTheta, sinPhi, cosPhi;\n\tdReal\t\t\tvolume;\n\tdReal\t\t\ta, b, c, d, e, f, g, h, i, j, k, l;\n\tdReal\t\t\tx, y, z;\n\tdReal\t\t\ty0, y1, y2, y3, y4, y5, y6, y7, y8, y9;\n\tdReal\t\t\ty10, y11, y12, y13, y14, y15, y16, y17, y18, y19;\n\tdReal\t\t\ty20, y21, y22, y23, y24, y25, y26, y27, y28, y29;\n\tdReal\t\t\ty30, y31, y32, y33, y34, y35, y36, y37, y38, y39;\n\tdReal\t\t\ty40, y41, y42, y43, y44, y45, y46, y47, y48, y49;\n\tdReal\t\t\ty50, y51, y52, y53, y54, y55, y56, y57, y58, y59;\n\tdReal\t\t\ty60, y61, y62, y63, y64, y65, y66, y67, y68, y69;\n\tdReal\t\t\ty70, y71, y72, y73, y74, y75, y76, y77, y78, y79;\n\tdReal\t\t\ty80, y81, y82, y83, y84, y85, y86, y87, y88, y89;\n\tdReal\t\t\ty90, y91, y92, y93, y94, y95,", "CodeBleu_score": 6.191319304545616}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tsCapsuleImmersionData *data = (sCapsuleImmersionData*)immersion->data;\n\n\tdReal depthRatio = immersion->depthRatio;\n\n\tdReal tangent = immersion->tangent;\n\n\tdReal sinFinalAngle = immersion->sinFinalAngle;\n\n\tdReal volume = immersion->volume;\n\n\tdReal radius = data->radius;\n\n\tdReal height = data->height;\n\n\tdReal depth = data->depth;\n\n\tdReal x0 = data->x0;\n\n\tdReal y0 = data->y0;\n\n\tdReal z0 = data->z0;\n\n\tdReal x1 = data->x1;\n\n\tdReal y1 = data->y1;\n\n\tdReal z1 = data->z1;\n\n\tdReal x2 = data->x2;\n\n\tdReal y2 = data->y2;\n\n\tdReal z2 = data->z2;\n\n\tdReal x3 = data->x3;\n\n\tdReal y3 = data->y3;\n\n\tdReal z3 = data->z3;\n\n\tdReal x4 = data->x4;\n\n\tdReal y4 = data->y4;\n\n\tdReal z4 = data->z4;\n\n\tdReal x5 = data->x5;\n\n\tdReal y5 = data->y5;\n\n\tdReal z5 = data->z5;\n\n\tdReal x6 = data->x6;\n\n\tdReal y6 = data->y6;\n\n\tdReal z6 = data->z6;\n\n\tdReal x7 = data->x7;\n\n\tdReal y7 = data->y7;\n\n\tdReal z7 = data->z7;\n\n\tdReal x8 = data->x8;\n\n\tdReal y8 = data->y8;\n\n\tdReal z8 = data->z8;\n\n\tdReal x9 = data->x9;\n\n\tdReal y9 = data->y9;\n\n\tdReal z9 = data->z9;\n\n\tdReal x10 = data->x10;\n\n\tdReal y10 = data->y10;\n\n\tdReal z10 = data->z10;\n\n\tdReal x1", "CodeBleu_score": 30.578606632664247}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// Retrieve the sleep duration in milliseconds from the input\n\tconst int duration = getInput<int>(\"duration\");\n\n\t// If the duration is missing or non-positive, return SUCCESS\n\tif (duration <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start a timer to wake up the node after the specified duration\n\ttimer_ = create_timer(duration, std::bind(&SleepNode::onTimer, this));\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_.setCallback(std::bind(&SleepNode::onTimer, this));\n\n\t// Ensure the timer_waiting_ flag is reset\n\ttimer_waiting_ = false;\n\n\t// Return RUNNING\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 44.50408114569239}, {"code": "NodeStatus SleepNode::onStart(){\n\t\n/*\n * Retrieve the sleep duration in milliseconds from the input.\n */\n  double sleep_duration = getInput<double>(\"duration\");\n\n/*\n * If the duration is missing or non-positive, return SUCCESS.\n */\n  if (!sleep_duration) {\n    return NodeStatus::SUCCESS;\n  }\n\n/*\n * Set the node status to RUNNING, start a timer, and set a callback to emit a wake-up signal when the timer expires.\n */\n  setStatus(NodeStatus::RUNNING);\n  timer_ = nh_.createTimer(ros::Duration(sleep_duration / 1000.0), &SleepNode::onTimer, this);\n  timer_waiting_ = true;\n\n/*\n * Return RUNNING.\n */\n  return NodeStatus::RUNNING;\n\n}", "CodeBleu_score": 31.605587294000998}, {"code": "NodeStatus SleepNode::onStart(){\n\t\n// Retrieve the sleep duration in milliseconds from the input.", "CodeBleu_score": 2.660423118049321}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\n#ifdef DEBUG_OUTPUT\n    std::cout << \"EntryUpdatedAction::tick()\" << std::endl;\n#endif\n\n    if (blackboard->get(key, seq_id)) {\n        if (seq_id != blackboard->get(key, seq_id)) {\n            blackboard->set(key, seq_id, seq_id);\n            return NodeStatus::SUCCESS;\n        }\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 33.34060282379424}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (!getInput(\"key\", key_)) {\n\t\tROS_ERROR(\"Missing parameter [key] for the EntryUpdatedAction\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tif (!getInput(\"sequence_id\", sequence_id_)) {\n\t\tROS_ERROR(\"Missing parameter [sequence_id] for the EntryUpdatedAction\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tauto bb = this->get_blackboard();\n\n\tif (!bb) {\n\t\tROS_ERROR(\"No blackboard found\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tif (!bb->setWorkingMemory(key_, sequence_id_)) {\n\t\tROS_ERROR(\"Unable to set the sequence_id in the blackboard\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tauto entry = bb->get(key_);\n\n\tif (!entry) {\n\t\tROS_ERROR(\"Unable to retrieve the entry from the blackboard\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tauto sequence_id = entry->getSequenceID();\n\n\tif (sequence_id_ == sequence_id) {\n\t\tROS_DEBUG_STREAM(\"The entry \" << key_ << \" has not been updated\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tROS_DEBUG_STREAM(\"The entry \" << key_ << \" has been updated\");\n\treturn NodeStatus::SUCCESS;\n}", "CodeBleu_score": 37.53032000616777}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (!blackboard_) {\n\t\tthrow std::runtime_error(\"Missing blackboard, did you call setBlackboard()?\");\n\t}\n\n\tstd::string entry_name = this->getInput(\"entry_name\");\n\tint64_t last_sequence_id = this->getInput(\"last_sequence_id\");\n\n\tif (!blackboard_->exist(entry_name)) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tauto entry = blackboard_->get(entry_name);\n\tif (!entry) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tstd::unique_lock<std::mutex> lock(entry->mutex);\n\tif (entry->sequence_id != last_sequence_id) {\n\t\tthis->setOutput(\"current_sequence_id\", entry->sequence_id);\n\t\tthis->setOutput(\"value\", entry->value);\n\t\treturn NodeStatus::SUCCESS;\n\t} else {\n\t\treturn NodeStatus::FAILURE;\n\t}\n}", "CodeBleu_score": 48.9140972213503}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn std::max(static_cast<size_t>(success_threshold_), static_cast<size_t>(children_.size()));\n\t}\n\telse {\n\t\treturn success_threshold_;\n\t}\n}", "CodeBleu_score": 59.108034887179215}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn static_cast<size_t>(success_threshold_ * children_.size());\n\t} else {\n\t\treturn static_cast<size_t>(success_threshold_);\n\t}\n}", "CodeBleu_score": 57.32322436780484}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn std::max(static_cast<size_t>(success_threshold_), children_.size());\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 52.819657513773976}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (this->heartbeat_status != this->last_heartbeat_status) {\n\t\t\tthis->last_heartbeat_status = this->heartbeat_status;\n\t\t\tfor (auto& bp : this->breakpoints) {\n\t\t\t\tbp.second.enabled = this->heartbeat_status;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 24.179727377824598}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\t// if the heartbeat is active, check if it is time to disable the breakpoints\n\t\tif (heartbeat_active) {\n\t\t\tif (std::chrono::system_clock::now() > heartbeat_time + std::chrono::seconds(5)) {\n\t\t\t\theartbeat_active = false;\n\t\t\t\tfor (auto& breakpoint : breakpoints) {\n\t\t\t\t\tbreakpoint.second.enabled = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// if the heartbeat is inactive, check if it is time to enable the breakpoints\n\t\telse {\n\t\t\tif (std::chrono::system_clock::now() > heartbeat_time + std::chrono::seconds(10)) {\n\t\t\t\theartbeat_active = true;\n\t\t\t\tfor (auto& breakpoint : breakpoints) {\n\t\t\t\t\tbreakpoint.second.enabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.91848731567496}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\t// Sleep for 10 milliseconds\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\t// Get the current time\n\t\tauto currentTime = std::chrono::system_clock::now();\n\n\t\t// Check if the heartbeat is still active\n\t\tif(currentTime - lastHeartbeatTime > std::chrono::seconds(5)) {\n\t\t\t// If the heartbeat is no longer active, disable all breakpoints\n\t\t\tfor(auto& bp : breakpoints) {\n\t\t\t\tbp.second.enabled = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 31.33352841545015}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\tstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\tfor (auto bb_name : bb_names) {\n\t\tBlackboard::Ptr bb = tree_.blackboard();\n\t\tif (bb) {\n\t\t\tBlackboard::Tree::Ptr bb_tree = bb->getTree();\n\t\t\tif (bb_tree) {\n\t\t\t\tBlackboard::Tree::Nodes bb_nodes = bb_tree->find(bb_name);\n\t\t\t\tif (!bb_nodes.empty()) {\n\t\t\t\t\tstd::lock_guard<std::mutex> lock(bb_tree->mutex_);\n\t\t\t\t\tstd::string bb_json = Blackboard::Tree::to_json(bb_nodes);\n\t\t\t\t\tnlohmann::json j = nlohmann::json::parse(bb_json);\n\t\t\t\t\tstd::string bb_mpack = j.dump();\n\t\t\t\t\tstd::vector<uint8_t> bb_mpack_vec(bb_mpack.begin(), bb_mpack.end());\n\t\t\t\t\tresult.insert(result.end(), bb_mpack_vec.begin(), bb_mpack_vec.end());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 44.26565777893417}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> msg;\n\tmsgpack::sbuffer sbuf;\n\tmsgpack::pack(sbuf, bb_list);\n\tstd::string bb_list_str = sbuf.str();\n\tmsgpack::unpacked upd;\n\tmsgpack::unpack(upd, bb_list_str.data(), bb_list_str.size());\n\tmsgpack::object obj = upd.get();\n\tmsgpack::object_array obj_array = obj.as<msgpack::object_array>();\n\tfor (auto it = obj_array.cbegin(); it != obj_array.cend(); ++it) {\n\t\tstd::string bb_name = it->as<std::string>();\n\t\tauto subtree = blackboard_.getTree(bb_name);\n\t\tif (subtree) {\n\t\t\tsubtree->lock();\n\t\t\tauto json = blackboard_.toJson(bb_name);\n\t\t\tsubtree->unlock();\n\t\t\tmsgpack::sbuffer sbuf;\n\t\t\tmsgpack::pack(sbuf, json);\n\t\t\tstd::string json_str = sbuf.str();\n\t\t\tmsg.insert(msg.end(), json_str.begin(), json_str.end());\n\t\t}\n\t}\n\treturn msg;\n}", "CodeBleu_score": 41.155418809776144}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> bb_dump;\n\tbb_dump.reserve(1024);\n\n\tif (bb_list.empty()) {\n\t\treturn bb_dump;\n\t}\n\n\ttry {\n\t\tauto json = nlohmann::json::parse(bb_list);\n\t\tfor (auto& bb : json) {\n\t\t\tauto bb_name = bb.get<std::string>();\n\t\t\tauto bb_json = m_blackboard->getTree(bb_name);\n\t\t\tbb_dump.insert(bb_dump.end(), bb_json.begin(), bb_json.end());\n\t\t}\n\t}\n\tcatch (const std::exception& e) {\n\t\tROS_ERROR_STREAM(\"Groot2Publisher::generateBlackboardsDump: \" << e.what());\n\t\tbb_dump.clear();\n\t}\n\n\treturn bb_dump;\n}", "CodeBleu_score": 44.303646810544784}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\t// search for the node\n\tauto it = std::find_if(nodes_.begin(), nodes_.end(),\n\t                       [node_uid](const std::pair<uint16_t, Node>& node) {\n\t\t                       return node.second.uid == node_uid;\n\t                       });\n\tif (it == nodes_.end()) {\n\t\treturn false;\n\t}\n\n\t// get the node\n\tauto& node = it->second;\n\n\t// check if the node is valid\n\tif (node.status == NodeStatus::INVALID) {\n\t\treturn false;\n\t}\n\n\t// get the associated hook\n\tauto hook = node.hook;\n\n\t// check if the hook is in BREAKPOINT mode\n\tif (hook->mode != HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\t// lock the hook\n\tstd::unique_lock<std::mutex> lock(hook->mutex);\n\n\t// set the desired status and removal flag\n\thook->desired_status = result;\n\thook->remove = remove;\n\n\t// mark the hook as ready\n\thook->ready = true;\n\n\t// notify all waiting threads\n\thook->cond.notify_all();\n\n\t// unlock the hook\n\tlock.unlock();\n\n\treturn true;\n}", "CodeBleu_score": 56.28934506755744}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\t// Search for the node\n\tauto it = std::find_if(nodes.begin(), nodes.end(), [node_uid](const Node& n) {\n\t\treturn n.uid == node_uid;\n\t});\n\n\tif (it == nodes.end()) {\n\t\t// Node not found\n\t\treturn false;\n\t}\n\n\t// Retrieve the hook\n\tauto hook = it->hook;\n\n\tif (hook->mode != HookMode::BREAKPOINT) {\n\t\t// Node is not in BREAKPOINT mode\n\t\treturn false;\n\t}\n\n\t// Lock the hook's mutex\n\tstd::unique_lock<std::mutex> lock(hook->mutex);\n\n\t// Set the desired status and removal flag\n\thook->desired_status = result;\n\thook->remove = remove;\n\n\t// Mark the hook as ready\n\thook->ready = true;\n\n\t// Notify all waiting threads\n\thook->cv.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 50.436304783702134}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tauto it = _nodes.find(node_uid);\n\tif (it == _nodes.end()) {\n\t\treturn false;\n\t}\n\tauto& node = it->second;\n\tif (node.status != NodeStatus::BREAKPOINT) {\n\t\treturn false;\n\t}\n\tnode.status = result;\n\tnode.remove = remove;\n\tnode.ready = true;\n\tnode.cond.notify_all();\n\treturn true;\n}", "CodeBleu_score": 36.22954164946117}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\t// If the node is not running, start a new thread to run the tick function\n\tif (node_status_ == NodeStatus::IDLE) {\n\t\tnode_status_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tcoro_ = minicoro::coro();\n\t\tcoro_.spawn([this]() {\n\t\t\ttry {\n\t\t\t\t// Run the tick function\n\t\t\t\ttick_engine();\n\t\t\t} catch (std::exception& e) {\n\t\t\t\t// If an exception occurs, log an error and set the node status to IDLE\n\t\t\t\tROS_ERROR_STREAM(\"Exception in \" << get_name() << \" node: \" << e.what());\n\t\t\t\tnode_status_ = NodeStatus::IDLE;\n\t\t\t} catch (...) {\n\t\t\t\tROS_ERROR_STREAM(\"Exception in \" << get_name() << \" node\");\n\t\t\t\tnode_status_ = NodeStatus::IDLE;\n\t\t\t}\n\t\t});\n\t}\n\n\t// If the node is running, check if the thread is done\n\tif (node_status_ == NodeStatus::RUNNING) {\n\t\t// If the thread is done, check for any exceptions and halt the node if needed\n\t\tif (coro_.done()) {\n\t\t\ttry {\n\t\t\t\tcoro_.get();\n\t\t\t} catch (std::exception& e) {\n\t\t\t\tROS_ERROR_STREAM(\"Exception in \" << get_name() << \" node: \" << e.what());\n\t\t\t\tnode_status_ = NodeStatus::IDLE;\n\t\t\t} catch (...) {\n\t\t\t\tROS_ERROR_STREAM(\"Exception in \" << get_name() << \" node\");\n\t\t\t\tnode_status_ = NodeStatus::IDLE;\n\t\t\t}\n\n\t\t\tif (halt_requested_) {\n\t\t\t\tnode_status_ = NodeStatus::IDLE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node_status_;\n}", "CodeBleu_score": 42.32699333612746}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tco_switch(co_active());\n\t\tco_switch(co_active());\n\t}\n\n\tif (status_ == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t}\n\n\tif (exception_) {\n\t\tauto stored_exception = exception_;\n\t\texception_ = nullptr;\n\t\tstd::rethrow_exception(stored_exception);\n\t}\n\n\treturn status_;\n}", "CodeBleu_score": 36.06596294730576}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\t// If the node is currently running, we are done.\n\tif (status_ == NodeStatus::RUNNING) {\n\t\treturn status_;\n\t}\n\n\t// If the node is currently halted, we are also done.\n\tif (status_ == NodeStatus::HALTED) {\n\t\treturn status_;\n\t}\n\n\t// If an exception was thrown previously, we rethrow it here.\n\tif (exception_thrown_) {\n\t\texception_thrown_ = false;\n\t\tthrow stored_exception_;\n\t}\n\n\t// If the node is currently idle, we start the thread.\n\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\n\t\t// We start a new thread to run the tick function.\n\t\t// The thread function is defined in the class BT::ThreadedAction.\n\t\tthread_ = std::thread(&BT::ThreadedAction::threadTick, this);\n\t}\n\n\t// We return the current status of the node.\n\treturn status_;\n}", "CodeBleu_score": 19.22433540312435}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\tstream << std::string(root_node->depth() * 4, ' ') << root_node->name() << std::endl;\n\tif (const auto control_node = dynamic_cast<const ControlNode*>(root_node)) {\n\t\tfor (const auto& child : control_node->children()) {\n\t\t\tprintTreeRecursively(child.get(), stream);\n\t\t}\n\t} else if (const auto decorator_node = dynamic_cast<const DecoratorNode*>(root_node)) {\n\t\tprintTreeRecursively(decorator_node->child().get(), stream);\n\t}\n}", "CodeBleu_score": 30.320517409775732}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (!root_node) {\n\t\treturn;\n\t}\n\n\tconst auto separator = std::string(80, '-');\n\tstream << separator << std::endl;\n\tstream << root_node->name() << std::endl;\n\tstream << separator << std::endl;\n\n\tif (const auto control_node = dynamic_cast<const ControlNode*>(root_node)) {\n\t\tfor (const auto& child : control_node->children()) {\n\t\t\tprintTreeRecursively(child, stream);\n\t\t}\n\t} else if (const auto decorator_node = dynamic_cast<const DecoratorNode*>(root_node)) {\n\t\tprintTreeRecursively(decorator_node->child(), stream);\n\t}\n\tstream << separator << std::endl;\n}", "CodeBleu_score": 39.72332967691865}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (!root_node) {\n\t\treturn;\n\t}\n\tauto print_node = [&stream, &print_node](const TreeNode* node, int depth) {\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"  \";\n\t\t}\n\t\tstream << node->name() << std::endl;\n\t\tif (const auto control_node = dynamic_cast<const ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control_node->children()) {\n\t\t\t\tprint_node(child.get(), depth + 1);\n\t\t\t}\n\t\t} else if (const auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n\t\t\tprint_node(decorator_node->child().get(), depth + 1);\n\t\t}\n\t};\n\tstream << \"--------\" << std::endl;\n\tprint_node(root_node, 0);\n\tstream << \"--------\" << std::endl;\n}", "CodeBleu_score": 54.349122310322386}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"The given node is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (const auto controlNode = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const auto& child : controlNode->children) {\n\t\t\tapplyRecursiveVisitor(child.get(), visitor);\n\t\t}\n\t} else if (const auto decoratorNode = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decoratorNode->child.get(), visitor);\n\t}\n}", "CodeBleu_score": 61.18004906699986}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow std::logic_error(\"The node parameter cannot be null\");\n\t}\n\tvisitor(node);\n\tif (const auto control = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children) {\n\t\t\tapplyRecursiveVisitor(child.get(), visitor);\n\t\t}\n\t} else if (const auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child.get(), visitor);\n\t}\n}", "CodeBleu_score": 60.527416216054995}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow std::logic_error(\"The node parameter cannot be null\");\n\t}\n\n\tvisitor(node);\n\n\tif (const auto controlNode = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const auto& child : controlNode->children) {\n\t\t\tapplyRecursiveVisitor(child.get(), visitor);\n\t\t}\n\t} else if (const auto decoratorNode = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decoratorNode->child.get(), visitor);\n\t}\n}", "CodeBleu_score": 60.23761005789024}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t     // NOLINT\n    // Check if the registration ID already exists in the builders map\n    auto it = builders.find(manifest.registration_ID);\n    if (it != builders.end()) {\n        throw BehaviorTreeException(\"Error: registration_ID [\" + manifest.registration_ID + \"] already exists.\");\n    }\n\n    // Insert the builder and manifest into their respective maps using the registration ID\n    builders[manifest.registration_ID] = builder;\n    manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 57.39851864073135}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t     // throws std::invalid_argument\n    if (builders.find(manifest.registration_ID) != builders.end()) {\n        throw std::invalid_argument(\"A node builder with the same ID is already registered\");\n    }\n    builders[manifest.registration_ID] = builder;\n    manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 43.248124661605324}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\n\nif (builders_.count(manifest.registration_ID) > 0) {\nthrow BehaviorTreeException(\"A node with the same name is already registered: [\" + manifest.registration_ID + \"]\");\n}\n\nbuilders_[manifest.registration_ID] = builder;\nmanifests_[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 43.97655316772469}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\tauto builder = [tick_functor, ports]() {\n\t\treturn std::make_shared<SimpleActionNode>(tick_functor, ports);\n\t};\n\tregisterBuilder(ID, builder);\n}", "CodeBleu_score": 35.397559733611054}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\tNodeBuilder builder = [tick_functor, ports](const std::string& name) {\n\t\treturn std::make_shared<SimpleActionNode>(name, tick_functor, ports);\n\t};\n\n\tTreeNodeManifest manifest = {ID, ID, ports};\n\n\tregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 58.87446143391283}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\nNodeBuilder builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\nreturn SimpleActionNode::make_from_config(name, config, tick_functor);\n};\n\nTreeNodeManifest manifest = {ID, NodeType::ACTION, ports, builder};\nregisterBuilder(manifest);\n}", "CodeBleu_score": 59.01205495029597}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> blackboard_backups;\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tblackboard_backups.push_back(Blackboard::create());\n\t\tblackboard_backups.back()->clone(*(subtree.blackboard));\n\t}\n\treturn blackboard_backups;\n}", "CodeBleu_score": 51.958363889867876}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backup;\n\tfor (auto& subtree : tree.subtrees) {\n\t\tbackup.push_back(std::make_shared<Blackboard>(subtree.blackboard));\n\t}\n\treturn backup;\n}", "CodeBleu_score": 44.419086336074706}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backups;\n\tfor (auto& subtree : tree.subtrees()) {\n\t\tbb_backups.push_back(std::make_shared<Blackboard>(subtree.blackboard()));\n\t}\n\treturn bb_backups;\n}", "CodeBleu_score": 45.91248817222732}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto maybe_executor = ParseScript(script);\n\tif (maybe_executor) {\n\t\treturn maybe_executor->execute(env);\n\t} else {\n\t\treturn std::move(maybe_executor).error();\n\t}\n}", "CodeBleu_score": 60.146590674645026}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto result = ParseScript(env, script);\n\tif (result) {\n\t\treturn result.value()->execute(env);\n\t}\n\telse {\n\t\treturn std::move(result).error();\n\t}\n}", "CodeBleu_score": 56.50758241675127}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto result = ParseScript(env, script);\n\tif (!result) {\n\t\treturn std::move(result).error();\n\t}\n\treturn result.value().execute(env);\n}", "CodeBleu_score": 49.97618000912465}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (handle_) throw RuntimeError(\"Library already loaded\");\n\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle_) {\n\t\tthrow RuntimeError(\"Failed to load library: \" + std::string(dlerror()));\n\t}\n\n\tpath_ = path;\n}", "CodeBleu_score": 51.43012500136387}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::unique_lock<std::mutex> lock(mutex_);\nif (lib_) {\nthrow RuntimeError(\"Library already loaded\");\n}\nlib_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\nif (!lib_) {\nstd::string msg = std::string(\"Failed to load library: \") + std::string(dlerror());\nthrow RuntimeError(msg);\n}\npath_ = path;\n}", "CodeBleu_score": 55.16586958379903}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (lib_handle_) {\n\t\tthrow RuntimeError(\"Library '\" + path + \"' could not be loaded because it is already loaded\");\n\t}\n\n\tlib_handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!lib_handle_) {\n\t\tstd::string error_msg = std::string(dlerror());\n\t\tthrow RuntimeError(\"Library '\" + path + \"' could not be loaded. Reason: \" + error_msg);\n\t}\n\tlib_path_ = path;\n}", "CodeBleu_score": 58.448614322766545}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.substr(1, str.size() - 2);\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped;\n\t}\n\treturn stripped.size() > 0 && stripped[0] == '{' && stripped[stripped.size() - 1] == '}';\n}", "CodeBleu_score": 24.698540977608793}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) return false;\n\tstr = str.substr(1, str.size() - 2);\n\tif (stripped_pointer) *stripped_pointer = str;\n\treturn true;\n}", "CodeBleu_score": 13.456020114859463}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tauto trimmed = str.trim();\n\tif (trimmed.substr(0, 1) != \"{\" or trimmed.substr(trimmed.size() - 1, 1) != \"}\") {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = trimmed.substr(1, trimmed.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 22.9816682757936}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0.0;\n\tint x, y;\n\tdouble dx = x1 - x0;\n\tdouble dy = y1 - y0;\n\tdouble error = 0.0;\n\tdouble delta_error = 0.0;\n\tint sx, sy;\n\tint ex, ey;\n\n\tif (dx == 0.0) {\n\t\tif (dy == 0.0) {\n\t\t\treturn getCost(x0, y0);\n\t\t}\n\t\telse {\n\t\t\ty = y0 < y1 ? y0 : y1;\n\t\t\terror = y - y0;\n\t\t\tsy = 1;\n\t\t\tif (y0 < y1) {\n\t\t\t\tey = y1 + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tey = y0 + 1;\n\t\t\t}\n\t\t\tsx = 0;\n\t\t}\n\t}\n\telse if (dy == 0.0) {\n\t\tx = x0 < x1 ? x0 : x1;\n\t\terror = x - x0;\n\t\tsx = 1;\n\t\tif (x0 < x1) {\n\t\t\tex = x1 + 1;\n\t\t}\n\t\telse {\n\t\t\tex = x0 + 1;\n\t\t}\n\t\tsy = 0;\n\t}\n\telse {\n\t\tsx = x0 < x1 ? 1 : -1;\n\t\tsy = y0 < y1 ? 1 : -1;\n\t\tx = x0;\n\t\ty = y0;\n\t\tex = x1 + sx;\n\t\tey = y1 + sy;\n\t}\n\n\tLineIterator it(this, x, y);\n\tfor (int i = 0; i < it.count; i++) {\n\t\tcost = getCost(it.x, it.y);\n\t\tif (cost < 0) {\n\t\t\treturn cost;\n\t\t}\n\t\tdelta_error = 2 * error;\n\t\tif (delta_error > -dy) {\n\t\t\terror -= dy;\n\t\t\tx += sx;\n\t\t}\n\t\tif (delta_error < dx) {\n\t\t\terror += dx;\n\t\t\ty += sy;\n\t\t}\n\t}\n\treturn cost;\n}", "CodeBleu_score": 41.52893683437948}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble dx = x1 - x0;\n\tdouble dy = y1 - y0;\n\tdouble error = 0;\n\tdouble e2 = 0;\n\tint sx, sy, ex, ey;\n\tdouble line_cost = 0;\n\n\tif (dx < 0) {\n\t\tsx = -1;\n\t\tex = -dx;\n\t}\n\telse {\n\t\tsx = 1;\n\t\tex = dx;\n\t}\n\n\tif (dy < 0) {\n\t\tsy = -1;\n\t\tey = -dy;\n\t}\n\telse {\n\t\tsy = 1;\n\t\tey = dy;\n\t}\n\n\tdouble err = dx - dy;\n\tint x = x0;\n\tint y = y0;\n\n\twhile (x != x1 && y != y1) {\n\t\tint cost = getCost(x, y);\n\t\tif (cost < 0) {\n\t\t\treturn cost;\n\t\t}\n\n\t\tline_cost += cost;\n\n\t\te2 = 2 * err;\n\t\tif (e2 > -dy) {\n\t\t\terr = err - dy;\n\t\t\tx += sx;\n\t\t}\n\t\tif (e2 < dx) {\n\t\t\terr = err + dx;\n\t\t\ty += sy;\n\t\t}\n\t}\n\n\treturn line_cost;\n}", "CodeBleu_score": 33.471114732281826}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tint dx = x1 - x0;\n\tint dy = y1 - y0;\n\tint sx, sy;\n\tif (dx < 0) {\n\t\tsx = -1;\n\t\tdx = -dx;\n\t} else {\n\t\tsx = 1;\n\t}\n\tif (dy < 0) {\n\t\tsy = -1;\n\t\tdy = -dy;\n\t} else {\n\t\tsy = 1;\n\t}\n\tint err = dx - dy;\n\tint e2;\n\tint x2 = x0;\n\tint y2 = y0;\n\tdouble c_cost;\n\twhile (1) {\n\t\tc_cost = getCost(x2, y2);\n\t\tif (c_cost < 0) {\n\t\t\treturn c_cost;\n\t\t}\n\t\tline_cost = std::max(line_cost, c_cost);\n\t\te2 = 2 * err;\n\t\tif (e2 >= -dy) {\n\t\t\tif (x0 == x1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = err - dy;\n\t\t\tx0 = x0 + sx;\n\t\t}\n\t\tif (e2 <= dx) {\n\t\t\tif (y0 == y1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = err + dx;\n\t\t\ty0 = y0 + sy;\n\t\t}\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 39.87862611194017}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN(\"Path is empty, not publishing anything.\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Publishing plan\");\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = path.front().header.frame_id;\n\tgui_path.header.stamp = path.front().header.stamp;\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 70.60560309292214}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN(\"Path is empty, not publishing anything\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = path.front().header.frame_id;\n\tgui_path.header.stamp = path.front().header.stamp;\n\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 71.90941586901975}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif(path.empty())\n\t\treturn;\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.poses = path;\n\tgui_path.header.frame_id = path.front().header.frame_id;\n\tgui_path.header.stamp = path.front().header.stamp;\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 55.38272230414496}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tbool stopped = true;\n\t// check if the robot is moving\n\tif (base_odom.twist.twist.linear.x > trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (base_odom.twist.twist.angular.z > rot_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\treturn stopped;\n}", "CodeBleu_score": 51.86682143944186}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n//    ROS_INFO(\"Checking if robot has stopped...\");\n\n    bool is_stopped = false;\n\n    // Check if the robot is rotating\n    if (fabs(base_odom.twist.twist.angular.x) <= rot_stopped_velocity && fabs(base_odom.twist.twist.angular.y) <= rot_stopped_velocity && fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n\n        // Check if the robot is moving\n        if (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity && fabs(base_odom.twist.twist.linear.z) <= trans_stopped_velocity) {\n\n            is_stopped = true;\n\n        }\n\n    }\n\n    return is_stopped;\n\n}", "CodeBleu_score": 68.44383601755477}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n//  ROS_INFO(\"Checking if robot is stopped...\");\n\n  // 1) Get the linear and angular velocities from the odometry message\n  double linear_velocity = base_odom.twist.twist.linear.x;\n  double angular_velocity = base_odom.twist.twist.angular.z;\n\n  // 2) Check if the linear and angular velocities are below the given thresholds\n  bool linear_stopped = linear_velocity <= trans_stopped_velocity;\n  bool angular_stopped = angular_velocity <= rot_stopped_velocity;\n\n  // 3) Return true if the robot is stopped\n  return linear_stopped && angular_stopped;\n}", "CodeBleu_score": 47.67228128355837}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tboost::mutex::scoped_lock l(configuration_mutex_);\n\n\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t}\n\n\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tconfig_ = config;\n}", "CodeBleu_score": 67.30624890174553}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tboost::mutex::scoped_lock lock(configuration_mutex_);\n\n\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t\tsetup_ = false;\n\t}\n\n\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tconfig_ = config;\n}", "CodeBleu_score": 66.47054329936518}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig.max_vel_x = default_max_vel_x;\n\t\tconfig.min_vel_x = default_min_vel_x;\n\t\tconfig.max_vel_theta = default_max_vel_theta;\n\t\tconfig.min_vel_theta = default_min_vel_theta;\n\t\tconfig.acc_lim_x = default_acc_lim_x;\n\t\tconfig.acc_lim_theta = default_acc_lim_theta;\n\t\tconfig.min_in_place_vel_theta = default_min_in_place_vel_theta;\n\t\tconfig.yaw_goal_tolerance = default_yaw_goal_tolerance;\n\t\tconfig.xy_goal_tolerance = default_xy_goal_tolerance;\n\t\tconfig.transform_tolerance = default_transform_tolerance;\n\t\tconfig.sim_time = default_sim_time;\n\t\tconfig.angular_sim_time = default_angular_sim_time;\n\t\tconfig.vx_samples = default_vx_samples;\n\t\tconfig.vtheta_samples = default_vtheta_samples;\n\t\tconfig.controller_frequency = default_controller_frequency;\n\t\tconfig.planner_frequency = default_planner_frequency;\n\t\tconfig.max_planning_retries = default_max_planning_retries;\n\t\tconfig.max_goal_retries = default_max_goal_retries;\n\t\tconfig.is_setup = true;\n\t} else if (!config.is_setup) {\n\t\tdefault_max_vel_x = config.max_vel_x;\n\t\tdefault_min_vel_x = config.min_vel_x;\n\t\tdefault_max_vel_theta = config.max_vel_theta;\n\t\tdefault_min_vel_theta = config.min_vel_theta;\n\t\tdefault_acc_lim_x = config.acc_lim_x;\n\t\tdefault_acc_lim_theta = config.acc_lim_theta;\n\t\tdefault_min_in_place_vel_theta = config.min_in_place_vel_theta;\n\t\tdefault_yaw_goal_tolerance = config.yaw_goal_tolerance;\n\t\tdefault_xy_goal_tolerance = config.xy_goal_tolerance;\n\t", "CodeBleu_score": 30.472037686232884}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// check if the cell is an obstacle or has no information\n\tif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::NO_INFORMATION) {\n\t\tcurrent_cell->target_distance = std::numeric_limits<double>::max();\n\t\treturn false;\n\t}\n\telse if (costmap.getCost(check_cell->x, check_cell->y) >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\tcurrent_cell->target_distance = std::numeric_limits<double>::max();\n\t\treturn false;\n\t}\n\n\t// calculate the new target distance\n\tdouble new_target_distance = current_cell->target_distance + std::sqrt(std::pow(current_cell->x - check_cell->x, 2) + std::pow(current_cell->y - check_cell->y, 2));\n\n\t// update the target distance if the new distance is shorter\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 52.11450007428886}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// Check if the cell is an obstacle or has no information\n\tif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::NO_INFORMATION ||\n\t\t\tcostmap.getCost(check_cell->x, check_cell->y) == costmap_2d::LETHAL_OBSTACLE) {\n\t\t// Set the target distance of the cell to the maximum obstacle cost\n\t\tcheck_cell->target_distance = costmap.getLethalCost();\n\t\treturn false;\n\t}\n\t// Calculate the new target distance\n\tdouble new_target_distance = current_cell->target_distance + costmap.getCost(check_cell->x, check_cell->y);\n\t// Check if the new target distance is shorter than the current target distance\n\tif (new_target_distance < check_cell->target_distance) {\n\t\t// Update the target distance of the cell\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\t// Return false\n\treturn false;\n}", "CodeBleu_score": 52.661988012651726}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\n// Check if the cell is an obstacle\nif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n// The cell is an obstacle\ncurrent_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\nreturn false;\n}\n\n// Check if the cell has no information\nif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::NO_INFORMATION) {\n// The cell has no information\ncurrent_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\nreturn false;\n}\n\n// The cell is not an obstacle, so calculate a new target distance\ndouble new_target_distance = current_cell->target_distance + costmap.getCost(check_cell->x, check_cell->y);\n\n// Check if the new target distance is shorter\nif (new_target_distance < current_cell->target_distance) {\n// The new target distance is shorter, so update the cell's target distance\ncurrent_cell->target_distance = new_target_distance;\n}\n\nreturn true;\n}", "CodeBleu_score": 52.3813830098987}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty, cannot compute cost\");\n\t\treturn -9;\n\t}\n\n\tdouble cost = 0;\n\tdouble scaling_factor = 1;\n\n\tfor (unsigned int i = 0; i < traj.points.size(); ++i) {\n\t\tcost += getFootprintCost(traj.points[i].pose, scaling_factor);\n\t\tif (cost < 0) {\n\t\t\treturn cost;\n\t\t}\n\t}\n\n\tif (sum_scores_) {\n\t\treturn cost;\n\t} else {\n\t\treturn cost / scaling_factor;\n\t}\n}", "CodeBleu_score": 38.64516912103892}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty. Cannot calculate trajectory cost. Returning -9.\");\n\t\treturn -9;\n\t}\n\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\tif (traj.getRobotVel().norm() > min_traj_vel_) {\n\t\tscaling_factor = traj.getRobotVel().norm() / min_traj_vel_;\n\t}\n\n\tfor (int i = 0; i < traj.getPointsSize(); i++) {\n\t\tcost += footprintCost(traj.getPoint(i), scaling_factor);\n\t\tif (cost < 0.0) {\n\t\t\treturn cost;\n\t\t}\n\t}\n\n\tif (sum_scores_) {\n\t\treturn cost;\n\t} else {\n\t\treturn std::max(cost, 0.0);\n\t}\n}", "CodeBleu_score": 40.90734280384795}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty. Cannot compute obstacle cost function\");\n\t\treturn -9;\n\t}\n\n\tdouble cost = 0;\n\tdouble scaling_factor = 1;\n\tdouble obstacle_cost = 0;\n\n\tfor (int i = 0; i < traj.get_number_of_points(); i++) {\n\t\tobstacle_cost = calcFootprintCost(traj.get_position(i), traj.get_velocity(i));\n\t\tif (obstacle_cost < 0) {\n\t\t\treturn obstacle_cost;\n\t\t}\n\t\tscaling_factor = scaling_factor * obstacle_cost;\n\t\tcost += obstacle_cost;\n\t}\n\n\tif (sum_scores_) {\n\t\tcost = cost / scaling_factor;\n\t} else {\n\t\tcost = cost;\n\t}\n\n\treturn cost;\n}", "CodeBleu_score": 43.751287627297906}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//  ROS_INFO(\"footprintCost\");\n\n  double footprint_cost = 0.0;\n  double footprint_cost_scale = 1.0;\n  double cell_cost = 0.0;\n  double cell_cost_scale = 1.0;\n  double cost = -6.0;\n\n  double ox, oy, ot;\n  costmap->getOrigin(ox, oy);\n  costmap->getResolution(ot);\n\n  double wx, wy;\n  costmap->worldToMap(x, y, wx, wy);\n\n  int mx = int(wx);\n  int my = int(wy);\n\n  int minx = int(wx - footprint_spec[0].x);\n  int miny = int(wy - footprint_spec[0].y);\n  int maxx = int(wx + footprint_spec[0].x);\n  int maxy = int(wy + footprint_spec[0].y);\n\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    footprint_spec[i].x = footprint_spec[i].x * scale;\n    footprint_spec[i].y = footprint_spec[i].y * scale;\n  }\n\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    double angle = 0.0;\n    double px = 0.0;\n    double py = 0.0;\n    double ox = 0.0;\n    double oy = 0.0;\n\n    angle = th + footprint_spec[i].theta;\n\n    px = footprint_spec[i].x * cos(angle) - footprint_spec[i].y * sin(angle);\n    py = footprint_spec[i].x * sin(angle) + footprint_spec[i].y * cos(angle);\n\n    px += x;\n    py += y;\n\n    costmap->worldToMap(px, py, ox, oy);\n\n    int ix = int(ox);\n    int iy = int(oy);\n\n    if (ix < minx) {\n      minx = ix;\n    }\n    if (ix > maxx) {\n      maxx = ix;\n    }\n    if (iy < miny) {\n      miny = iy;\n    }\n    if (iy >", "CodeBleu_score": 51.27837932250379}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t//ROS_INFO(\"footprintCost\");\n\t//ROS_INFO(\"scale = %f\", scale);\n\tdouble footprint_cost = 0.0;\n\tdouble cell_cost = 0.0;\n\tdouble min_cost = 0.0;\n\tdouble cost = 0.0;\n\tdouble world_cost = 0.0;\n\tdouble world_cost_no_footprint = 0.0;\n\tdouble world_cost_no_footprint_no_robot = 0.0;\n\tdouble footprint_cost_no_robot = 0.0;\n\tdouble footprint_cost_no_robot_no_world = 0.0;\n\tdouble footprint_cost_no_world = 0.0;\n\tdouble footprint_cost_no_world_no_robot = 0.0;\n\tdouble footprint_cost_no_robot_no_world_no_footprint = 0.0;\n\tdouble footprint_cost_no_world_no_robot_no_footprint = 0.0;\n\tdouble footprint_cost_no_footprint = 0.0;\n\tdouble footprint_cost_no_footprint_no_robot = 0.0;\n\tdouble footprint_cost_no_footprint_no_world = 0.0;\n\tdouble footprint_cost_no_footprint_no_world_no_robot = 0.0;\n\tdouble footprint_cost_no_robot_no_footprint = 0.0;\n\tdouble footprint_cost_no_robot_no_footprint_no_world = 0.0;\n\tdouble footprint_cost_no_robot_no_footprint_no_world_no_robot = 0.0;\n\tdouble footprint_cost_no_world_no_footprint = 0.0;\n\tdouble footprint_cost_no_world_no_footprint_no_robot = 0.0;\n\tdouble footprint_cost_no_world_no_footprint_no_robot_no_footprint = 0.0;\n\tdouble footprint_cost_no_robot_no_world_no_", "CodeBleu_score": 13.911217781439245}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//  ROS_INFO(\"footprintCost called\");\n\n  double footprint_cost = 0.0;\n  double cell_cost = 0.0;\n  double cost = 0.0;\n  double x_world, y_world;\n  double cell_x, cell_y;\n  unsigned int cell_x_index, cell_y_index;\n\n  //  ROS_INFO(\"footprintCost: scale = %f\", scale);\n\n  //  ROS_INFO(\"footprintCost: footprint_spec.size() = %d\", footprint_spec.size());\n\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n\n    //  ROS_INFO(\"footprintCost: i = %d\", i);\n\n    //  ROS_INFO(\"footprintCost: footprint_spec[i].x = %f\", footprint_spec[i].x);\n\n    //  ROS_INFO(\"footprintCost: footprint_spec[i].y = %f\", footprint_spec[i].y);\n\n    //  ROS_INFO(\"footprintCost: footprint_spec[i].z = %f\", footprint_spec[i].z);\n\n    //  ROS_INFO(\"footprintCost: scale = %f\", scale);\n\n    x_world = x + scale * footprint_spec[i].x * cos(th) - scale * footprint_spec[i].y * sin(th);\n    y_world = y + scale * footprint_spec[i].x * sin(th) + scale * footprint_spec[i].y * cos(th);\n\n    //  ROS_INFO(\"footprintCost: x_world = %f\", x_world);\n\n    //  ROS_INFO(\"footprintCost: y_world = %f\", y_world);\n\n    cell_x = costmap->getOriginX() + x_world * costmap->getResolution();\n    cell_y = costmap->getOriginY() + y_world * costmap->getResolution();\n\n    //  ROS_INFO(\"footprintCost: cell_x = %f\", cell_x);\n\n    //  ROS_INFO(\"footprintCost: cell_y = %f\", cell_y);\n\n    cell_x_index = (unsigned int) cell_x;\n    cell_y_index =", "CodeBleu_score": 52.50945014475741}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic == odom_topic_) {\n\t\treturn;\n\t}\n\n\tif (!odom_topic.empty()) {\n\t\todom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\todom_topic_ = odom_topic;\n\t} else {\n\t\todom_sub_.shutdown();\n\t\todom_topic_ = odom_topic;\n\t}\n}", "CodeBleu_score": 42.63098891798446}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic == \"\") {\n\t\tROS_INFO(\"OdometryHelperRos: Subscribing to no odometry topic.\");\n\t\todom_sub_.shutdown();\n\t} else {\n\t\tif (odom_topic != odom_topic_) {\n\t\t\tROS_INFO(\"OdometryHelperRos: Subscribing to odometry topic: %s.\", odom_topic.c_str());\n\t\t\todom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t\todom_topic_ = odom_topic;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.498914489140105}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic != odom_topic_) {\n\t\tif (odom_topic.empty()) {\n\t\t\t// unsubscribe from old topic\n\t\t\tsub_odom_.shutdown();\n\t\t} else {\n\t\t\t// subscribe to new topic\n\t\t\tsub_odom_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t}\n\t\todom_topic_ = odom_topic;\n\t}\n}", "CodeBleu_score": 38.35432095052154}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// calculate the squared distance\n\tdouble dist_sqr = (pos.x() - prev.x()) * (pos.x() - prev.x()) + (pos.y() - prev.y()) * (pos.y() - prev.y());\n\n\t// calculate the angular difference\n\tdouble angle = atan2(pos.y() - prev.y(), pos.x() - prev.x()) - prev.theta();\n\tif (angle > M_PI)\n\t\tangle -= 2.0 * M_PI;\n\telse if (angle < -M_PI)\n\t\tangle += 2.0 * M_PI;\n\n\t// check if the squared distance is too large or the angular difference is too large\n\tif (dist_sqr > 0.25 && fabs(angle) > 0.5) {\n\t\t// reset the oscillation flags\n\t\toscillation_flags_ = 0;\n\t\toscillation_flags_ |= (1 << 0);\n\t}\n}", "CodeBleu_score": 37.11679444681315}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// Calculate the squared distance between the current and previous position\n\tfloat squared_dist = (pos - prev).squaredNorm();\n\n\t// If the distance is greater than the threshold, reset the oscillation flags\n\tif (squared_dist > oscillation_reset_dist_threshold_ * oscillation_reset_dist_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n\n\t// Calculate the angular difference between the current and previous position\n\tfloat angular_diff = calcAngularDifference(pos, prev);\n\n\t// If the angular difference is greater than the threshold, reset the oscillation flags\n\tif (angular_diff > oscillation_reset_angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 40.773697370002054}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// Calculate the squared distance between the current and previous positions\n\tfloat dist = (pos - prev).squaredNorm();\n\n\t// Calculate the angular difference between the current and previous positions\n\tfloat angle = atan2(pos.y - prev.y, pos.x - prev.x) - atan2(this->previous_pos_.y - this->previous_pos_.y, this->previous_pos_.x - this->previous_pos_.x);\n\n\t// If the squared distance is greater than the threshold or the angular difference is greater than the threshold, reset the oscillation flags\n\tif (dist > this->dist_threshold_ * this->dist_threshold_ || angle > this->angle_threshold_) {\n\t\tthis->oscillation_flags_ = 0;\n\t}\n\n\t// Update the previous position\n\tthis->previous_pos_ = pos;\n}", "CodeBleu_score": 31.994173366378252}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// determine the grid coordinates of the point\n\tint x = (int)floor((pt.x - min_x) / resolution);\n\tint y = (int)floor((pt.y - min_y) / resolution);\n\n\t// check if the point is in bounds\n\tif (x < 0 || x >= size_x || y < 0 || y >= size_y)\n\t\treturn;\n\n\t// determine the grid index of the point\n\tint index = x + y * size_x;\n\n\t// check if the point is too close to its nearest neighbor\n\tif (pt.z < grid[index].z)\n\t\treturn;\n\n\t// insert the point into the grid\n\tgrid[index] = pt;\n}", "CodeBleu_score": 38.61976213269186}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// Check if the point is valid\n\tif (!std::isfinite(pt.x) || !std::isfinite(pt.y) || !std::isfinite(pt.z)) {\n\t\tROS_ERROR(\"Invalid point (%f, %f, %f)!\", pt.x, pt.y, pt.z);\n\t\treturn;\n\t}\n\n\t// Determine the grid coordinates of the point\n\tunsigned int x_idx = (unsigned int) floor((pt.x - origin_.x) / resolution_);\n\tunsigned int y_idx = (unsigned int) floor((pt.y - origin_.y) / resolution_);\n\n\t// Check if the point is within the grid bounds\n\tif (x_idx >= width_ || y_idx >= height_) {\n\t\tROS_ERROR(\"Point (%f, %f, %f) is outside the grid bounds (%d, %d)!\", pt.x, pt.y, pt.z, width_, height_);\n\t\treturn;\n\t}\n\n\t// Determine the distance to the nearest neighbor\n\tfloat dist_sqr = (pt.x - (origin_.x + x_idx * resolution_)) * (pt.x - (origin_.x + x_idx * resolution_)) + (pt.y - (origin_.y + y_idx * resolution_)) * (pt.y - (origin_.y + y_idx * resolution_));\n\tif (dist_sqr < resolution_ * resolution_) {\n\t\tROS_ERROR(\"Point (%f, %f, %f) is too close to its nearest neighbor (%f)!\", pt.x, pt.y, pt.z, sqrt(dist_sqr));\n\t\treturn;\n\t}\n\n\t// Calculate the grid index\n\tunsigned int idx = y_idx * width_ + x_idx;\n\n\t// Insert the point into the grid\n\tgrid_.insert(idx, pt);\n}", "CodeBleu_score": 35.218041682788304}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// Check if point is inside grid bounds\n\tif (pt.x < min_x_ || pt.x > max_x_ || pt.y < min_y_ || pt.y > max_y_ || pt.z < min_z_ || pt.z > max_z_) {\n\t\tROS_DEBUG(\"Point is outside grid bounds: (%f, %f, %f)\", pt.x, pt.y, pt.z);\n\t\treturn;\n\t}\n\n\t// Check if point is too close to its nearest neighbor\n\tint grid_x = (int) floor((pt.x - min_x_) / cell_size_);\n\tint grid_y = (int) floor((pt.y - min_y_) / cell_size_);\n\tint grid_z = (int) floor((pt.z - min_z_) / cell_size_);\n\tif (grid_[grid_x][grid_y][grid_z] != -1) {\n\t\tROS_DEBUG(\"Point is too close to its nearest neighbor: (%f, %f, %f)\", pt.x, pt.y, pt.z);\n\t\treturn;\n\t}\n\n\t// Calculate grid index\n\tint grid_index = grid_x + grid_y * grid_size_x_ + grid_z * grid_size_x_ * grid_size_y_;\n\n\t// Insert point into grid\n\tgrid_[grid_x][grid_y][grid_z] = grid_index;\n}", "CodeBleu_score": 32.39017970599286}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\t// Create new velocity vector\n\tEigen::Vector3f new_vel;\n\tnew_vel << 0.0, 0.0, 0.0;\n\n\t// Compute new velocities for x, y, and z\n\tfor (unsigned int i = 0; i < 3; i++) {\n\t\t// If the target velocity is greater than the current velocity, increase the velocity by the acceleration limit\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = vel[i] + acclimits[i] * dt;\n\t\t}\n\t\t// If the target velocity is less than the current velocity, decrease the velocity by the acceleration limit\n\t\telse if (sample_target_vel[i] < vel[i]) {\n\t\t\tnew_vel[i] = vel[i] - acclimits[i] * dt;\n\t\t}\n\t\t// If the target velocity is equal to the current velocity, keep the current velocity\n\t\telse {\n\t\t\tnew_vel[i] = vel[i];\n\t\t}\n\t}\n\n\t// Return the new velocity vector\n\treturn new_vel;\n}", "CodeBleu_score": 66.69196578550026}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f newvel;\n\t// compute new velocities for each component\n\tfor (unsigned int i = 0; i < 3; i++) {\n\t\t// if we are not at the target velocity, compute new velocity\n\t\tif (sample_target_vel[i] != 0.0) {\n\t\t\t// compute acceleration\n\t\t\tdouble acc = (sample_target_vel[i] - vel[i]) / dt;\n\t\t\t// if the acceleration is greater than the acceleration limit, set new velocity to the acceleration limit\n\t\t\tif (acc > acclimits[i]) {\n\t\t\t\tnewvel[i] = vel[i] + acclimits[i] * dt;\n\t\t\t}\n\t\t\t// if the acceleration is less than the acceleration limit, set new velocity to the acceleration limit\n\t\t\telse if (acc < -acclimits[i]) {\n\t\t\t\tnewvel[i] = vel[i] - acclimits[i] * dt;\n\t\t\t}\n\t\t\t// if the acceleration is within the acceleration limits, set new velocity to the target velocity\n\t\t\telse {\n\t\t\t\tnewvel[i] = sample_target_vel[i];\n\t\t\t}\n\t\t}\n\t\t// if we are at the target velocity, set new velocity to the target velocity\n\t\telse {\n\t\t\tnewvel[i] = sample_target_vel[i];\n\t\t}\n\t}\n\treturn newvel;\n}", "CodeBleu_score": 61.123131456061806}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n//  ROS_INFO(\"sample_target_vel: [%f, %f, %f]\", sample_target_vel[0], sample_target_vel[1], sample_target_vel[2]);\n//  ROS_INFO(\"vel: [%f, %f, %f]\", vel[0], vel[1], vel[2]);\n//  ROS_INFO(\"acclimits: [%f, %f, %f]\", acclimits[0], acclimits[1], acclimits[2]);\n//  ROS_INFO(\"dt: %f\", dt);\n\n  Eigen::Vector3f new_vel(0,0,0);\n\n  // iterate through the three components of the velocity vector\n  for (unsigned int i=0; i<3; i++) {\n\n    // check if the target velocity is greater than the current velocity\n    if (sample_target_vel[i] > vel[i]) {\n\n      // if so, check if the difference between the target velocity and current velocity is greater than the acceleration limit\n      if (sample_target_vel[i] - vel[i] > acclimits[i]*dt) {\n\n        // if so, set the new velocity component to the current velocity plus the acceleration limit\n        new_vel[i] = vel[i] + acclimits[i]*dt;\n\n      } else {\n\n        // otherwise, set the new velocity component to the target velocity\n        new_vel[i] = sample_target_vel[i];\n\n      }\n\n    } else {\n\n      // if the target velocity is less than the current velocity, check if the difference between the target velocity and current velocity is greater than the acceleration limit\n      if (vel[i] - sample_target_vel[i] > acclimits[i]*dt) {\n\n        // if so, set the new velocity component to the current velocity minus the acceleration limit\n        new_vel[i] = vel[i] - acclimits[i]*dt;\n\n      } else {\n\n        // otherwise, set the new velocity component to the target velocity\n        new_vel[i] = sample_target_vel[i];\n\n      }\n\n    }\n\n  }\n\n  return new_vel;\n\n}", "CodeBleu_score": 60.68650195276756}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tint i = 0;\n\tdouble dist = 0.0;\n\tdouble angle = 0.0;\n\tdouble angle_diff = 0.0;\n\tdouble heading_diff = DBL_MAX;\n\tdouble dx = 0.0;\n\tdouble dy = 0.0;\n\tdouble x_new = 0.0;\n\tdouble y_new = 0.0;\n\tdouble x_old = 0.0;\n\tdouble y_old = 0.0;\n\tdouble x_diff = 0.0;\n\tdouble y_diff = 0.0;\n\tdouble dist_old = 0.0;\n\tdouble dist_new = 0.0;\n\tdouble dist_diff = 0.0;\n\tdouble angle_new = 0.0;\n\tdouble angle_old = 0.0;\n\tdouble angle_diff = 0.0;\n\tbool valid_point = false;\n\tbool valid_angle = false;\n\tbool valid_dist = false;\n\tbool valid_heading = false;\n\tbool valid_heading_diff = false;\n\tbool valid_angle_diff = false;\n\tbool valid_dist_diff = false;\n\tbool valid_dx = false;\n\tbool valid_dy = false;\n\tbool valid_x_new = false;\n\tbool valid_y_new = false;\n\tbool valid_x_old = false;\n\tbool valid_y_old = false;\n\tbool valid_x_diff = false;\n\tbool valid_y_diff = false;\n\tbool valid_dist_old = false;\n\tbool valid_dist_new = false;\n\tbool valid_dist_diff = false;\n\tbool valid_angle_new = false;\n\tbool valid_angle_old = false;\n\tbool valid_angle_diff = false;\n\tbool valid_x_new = false;\n\tbool valid_y_new = false;\n\tbool valid_x_old = false;\n\tbool valid_y_old = false;\n\tbool valid_x_diff = false;\n\tbool valid_y_diff = false;\n\tbool valid_dist_old = false;\n", "CodeBleu_score": 19.489123711501424}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble goal_x = x;\n\tdouble goal_y = y;\n\tdouble goal_theta = heading;\n\tdouble current_x = 0;\n\tdouble current_y = 0;\n\tdouble current_theta = 0;\n\tdouble diff = DBL_MAX;\n\tdouble dist = 0;\n\tint i = 0;\n\tdouble dx = 0;\n\tdouble dy = 0;\n\tdouble theta = 0;\n\tdouble dtheta = 0;\n\tdouble d = 0;\n\tdouble a = 0;\n\tdouble b = 0;\n\tdouble c = 0;\n\tdouble t = 0;\n\tdouble t1 = 0;\n\tdouble t2 = 0;\n\tdouble t3 = 0;\n\tdouble t4 = 0;\n\tdouble t5 = 0;\n\tdouble t6 = 0;\n\tdouble t7 = 0;\n\tdouble t8 = 0;\n\tdouble t9 = 0;\n\tdouble t10 = 0;\n\tdouble t11 = 0;\n\tdouble t12 = 0;\n\tdouble t13 = 0;\n\tdouble t14 = 0;\n\tdouble t15 = 0;\n\tdouble t16 = 0;\n\tdouble t17 = 0;\n\tdouble t18 = 0;\n\tdouble t19 = 0;\n\tdouble t20 = 0;\n\tdouble t21 = 0;\n\tdouble t22 = 0;\n\tdouble t23 = 0;\n\tdouble t24 = 0;\n\tdouble t25 = 0;\n\tdouble t26 = 0;\n\tdouble t27 = 0;\n\tdouble t28 = 0;\n\tdouble t29 = 0;\n\tdouble t30 = 0;\n\tdouble t31 = 0;\n\tdouble t32 = 0;\n\tdouble t33 = 0;\n\tdouble t34 = 0;\n\tdouble t35 = 0;\n\tdouble t36 = 0;\n\tdouble t37", "CodeBleu_score": 10.149331800019501}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = DBL_MAX;\n\tint i = 0;\n\tint x_ = cell_x;\n\tint y_ = cell_y;\n\tdouble x__ = x;\n\tdouble y__ = y;\n\tdouble heading_ = heading;\n\tdouble x_diff, y_diff, h_diff;\n\tdouble x_diff_prev, y_diff_prev, h_diff_prev;\n\tdouble x_diff_prev_prev, y_diff_prev_prev, h_diff_prev_prev;\n\tdouble x_diff_next, y_diff_next, h_diff_next;\n\tdouble x_diff_next_next, y_diff_next_next, h_diff_next_next;\n\tdouble x_diff_prev_next, y_diff_prev_next, h_diff_prev_next;\n\tdouble x_diff_prev_prev_next, y_diff_prev_prev_next, h_diff_prev_prev_next;\n\tdouble x_diff_prev_prev_prev, y_diff_prev_prev_prev, h_diff_prev_prev_prev;\n\tdouble x_diff_next_next_next, y_diff_next_next_next, h_diff_next_next_next;\n\tdouble x_diff_next_next_next_next, y_diff_next_next_next_next, h_diff_next_next_next_next;\n\tdouble x_diff_prev_next_next, y_diff_prev_next_next, h_diff_prev_next_next;\n\tdouble x_diff_prev_next_next_next, y_diff_prev_next_next_next, h_diff_prev_next_next_next;\n\tdouble x_diff_prev_prev_next_next, y_diff_prev_prev_next_next, h_diff_prev_prev_next_next;\n\tdouble x_diff_prev_prev_prev_next, y_diff_prev_prev_prev_next, h_diff_prev_prev_prev_next;\n\tdouble x_diff_prev_prev_prev_prev, y_diff_prev_prev_prev_", "CodeBleu_score": 12.553914651940076}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost < 0) {\n\t\tROS_WARN(\"Invalid Trajectory: x = %f, y = %f, theta = %f, vx = %f, vy = %f, vtheta = %f\", x, y, theta, vx, vy, vtheta);\n\t\tROS_WARN(\"cost = %f\", cost);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 67.45053441050105}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost < 0) {\n\t\tROS_WARN_STREAM(\"Invalid trajectory: \" << cost << \" \" << vx_samp << \" \" << vy_samp << \" \" << vtheta_samp);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 70.7513953572477}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t// compute the trajectory cost\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n\t// if the cost is non-negative, the trajectory is valid\n\tif (cost >= 0.0) {\n\t\treturn true;\n\t}\n\n\t// otherwise, log a warning and return false\n\tROS_WARN(\"Invalid Trajectory: cost = %f. (x, y, theta) = (%f, %f, %f), (vx, vy, vtheta) = (%f, %f, %f)\", cost, x, y, theta, vx, vy, vtheta);\n\treturn false;\n}", "CodeBleu_score": 69.87963329944745}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t\t// Check if the object is initialized.\n\tif (!initialized_) {\n\t\tROS_ERROR(\"ClearCostmapRecovery has not been initialized, but a recovery behavior was commanded. Please call initialize() to use this behavior.\");\n\t\treturn;\n\t}\n\n\t// Check if the costmaps are not NULL.\n\tif (!global_costmap_) {\n\t\tROS_ERROR(\"The global costmap is NULL, but a recovery behavior was commanded. Please check your costmap configuration.\");\n\t\treturn;\n\t}\n\tif (!local_costmap_) {\n\t\tROS_ERROR(\"The local costmap is NULL, but a recovery behavior was commanded. Please check your costmap configuration.\");\n\t\treturn;\n\t}\n\n\t// Check if the costmap sizes are not zero.\n\tif (global_costmap_->getSizeInCellsX() == 0 || global_costmap_->getSizeInCellsY() == 0) {\n\t\tROS_ERROR(\"The global costmap size is zero, but a recovery behavior was commanded. Please check your costmap configuration.\");\n\t\treturn;\n\t}\n\tif (local_costmap_->getSizeInCellsX() == 0 || local_costmap_->getSizeInCellsY() == 0) {\n\t\tROS_ERROR(\"The local costmap size is zero, but a recovery behavior was commanded. Please check your costmap configuration.\");\n\t\treturn;\n\t}\n\n\t// Check if the costmap resolutions are not zero.\n\tif (global_costmap_->getResolution() == 0.0 || local_costmap_->getResolution() == 0.0) {\n\t\tROS_ERROR(\"The costmap resolution is zero, but a recovery behavior was commanded. Please check your costmap configuration.\");\n\t\treturn;\n\t}\n\n\t// Check if the costmap origin is not at the origin.\n\tif (global_costmap_->getOriginX() != 0.0 || global_costmap_->getOriginY() != 0.0 || local_costmap_->getOriginX() != 0.0 || local_costmap_->getOriginY() != 0.0) {\n\t\tROS_ERROR(\"The costmap origin is not at the origin, but a recovery behavior was commanded. Please check your costmap configuration.\");\n\t\treturn;", "CodeBleu_score": 24.58013848840008}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\t// Check if initialized\n\tif (!initialized_) {\n\t\tROS_ERROR(\"ClearCostmapRecovery has not been initialized, but received a call to runBehavior(). Please call initialize() to use this recovery behavior.\");\n\t\treturn;\n\t}\n\n\t// Check if costmaps are NULL\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"ClearCostmapRecovery cannot clear the global costmap because it is NULL.\");\n\t}\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"ClearCostmapRecovery cannot clear the local costmap because it is NULL.\");\n\t}\n\n\t// Check if the costmaps are actually valid\n\tif (global_costmap_->is_initialized() == false) {\n\t\tROS_ERROR(\"ClearCostmapRecovery cannot clear the global costmap because it is not initialized.\");\n\t}\n\tif (local_costmap_->is_initialized() == false) {\n\t\tROS_ERROR(\"ClearCostmapRecovery cannot clear the local costmap because it is not initialized.\");\n\t}\n\n\t// Check if the costmaps are actually valid\n\tif (global_costmap_->is_enabled() == false) {\n\t\tROS_ERROR(\"ClearCostmapRecovery cannot clear the global costmap because it is disabled.\");\n\t}\n\tif (local_costmap_->is_enabled() == false) {\n\t\tROS_ERROR(\"ClearCostmapRecovery cannot clear the local costmap because it is disabled.\");\n\t}\n\n\t// Check if the costmaps are actually valid\n\tif (global_costmap_->getFrameId() != local_costmap_->getFrameId()) {\n\t\tROS_ERROR(\"ClearCostmapRecovery cannot clear the global costmap because it is in a different frame (%s) than the local costmap (%s).\", global_costmap_->getFrameId().c_str(), local_costmap_->getFrameId().c_str());\n\t}\n\n\t// Check if the costmaps are actually valid\n\tif (global_costmap_->getRobotBaseFrame() != local_costmap_->getRobotBaseFrame()) {\n\t\tROS_ERROR(\"ClearCostmapRecovery cannot clear the global costmap because it is in a different frame (%s) than the local costmap (%s).\", global_costmap_->getRobotBaseFrame().c_str(), local_costmap", "CodeBleu_score": 25.683428064224035}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object has not been initialized, please call initialize() before using this behavior\");\n\t\treturn;\n\t}\n\n\tif (!global_costmap_ || !local_costmap_) {\n\t\tROS_ERROR(\"This object has not been initialized with a costmap, please call initialize() before using this behavior\");\n\t\treturn;\n\t}\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing costmap inside specified area\");\n\t} else {\n\t\tROS_WARN(\"Clearing costmap outside specified area\");\n\t}\n\n\t// Clear the specified costmaps\n\tif (affected_maps_ & CLEAR_ALL_MAPS) {\n\t\t// Clear the global costmap\n\t\tros::Time clear_start_time = ros::Time::now();\n\t\tglobal_costmap_->clearMap(invert_area_to_clear_);\n\t\tros::Time clear_end_time = ros::Time::now();\n\t\tROS_INFO(\"Cleared global costmap in %f seconds\", (clear_end_time - clear_start_time).toSec());\n\n\t\t// Clear the local costmap\n\t\tclear_start_time = ros::Time::now();\n\t\tlocal_costmap_->clearMap(invert_area_to_clear_);\n\t\tclear_end_time = ros::Time::now();\n\t\tROS_INFO(\"Cleared local costmap in %f seconds\", (clear_end_time - clear_start_time).toSec());\n\t}\n\n\tif (affected_maps_ & CLEAR_GLOBAL_MAP) {\n\t\t// Clear the global costmap\n\t\tros::Time clear_start_time = ros::Time::now();\n\t\tglobal_costmap_->clearMap(invert_area_to_clear_);\n\t\tros::Time clear_end_time = ros::Time::now();\n\t\tROS_INFO(\"Cleared global costmap in %f seconds\", (clear_end_time - clear_start_time).toSec());\n\t}\n\n\tif (affected_maps_ & CLEAR_LOCAL_MAP) {\n\t\t// Clear the local costmap\n\t\tros::Time clear_start_time = ros::Time::now();\n\t\tlocal_costmap_->clearMap(invert_area_to_clear_);\n\t\t", "CodeBleu_score": 43.943210371461376}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells outline_cells;\n\tfor (unsigned int i = 0; i < polygon.size() - 1; i++) {\n\t\traytraceLine(polygon[i], polygon[i + 1], outline_cells);\n\t}\n\traytraceLine(polygon[polygon.size() - 1], polygon[0], outline_cells);\n\toutline_cells.closePolygon();\n\toutline_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 49.603502607092224}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\tPolygonOutlineCells outline;\n\tfor (unsigned int i = 0; i < polygon.size() - 1; i++) {\n\t\traytraceLine(polygon[i], polygon[i + 1], outline);\n\t}\n\traytraceLine(polygon[polygon.size() - 1], polygon[0], outline);\n\tpolygon_cells = outline.getCells();\n}", "CodeBleu_score": 48.72647296364266}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.size() == 0) {\n\t\treturn;\n\t}\n\n\tPolygonOutlineCells outline_cells;\n\tfor (unsigned int i = 0; i < polygon.size() - 1; i++) {\n\t\traytraceLine(polygon[i], polygon[i + 1], outline_cells);\n\t}\n\traytraceLine(polygon[polygon.size() - 1], polygon[0], outline_cells);\n\n\tpolygon_cells = outline_cells.cells;\n}", "CodeBleu_score": 51.2286020197089}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid);\n}", "CodeBleu_score": 73.1143176438417}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tROS_INFO(\"New subscriber detected on topic %s. Preparing grid.\", pub.getTopic());\n\tprepareGrid();\n\tROS_INFO(\"Publishing grid on topic %s.\", pub.getTopic());\n\tpub.publish(grid_msg_);\n}", "CodeBleu_score": 52.78618671986146}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tROS_INFO(\"New subscriber to costmap_2d detected. Preparing grid data...\");\n\tprepareGrid();\n\tROS_INFO(\"Publishing grid data to new subscriber...\");\n\tpub.publish(grid_msg_);\n}", "CodeBleu_score": 52.904227297806486}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap mutex\n\tcostmap_mutex_.lock();\n\n\t// Retrieve the resolution\n\tresolution_ = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\n\t// Set the grid's resolution\n\tgrid_.info.resolution = resolution_;\n\n\t// Set the grid's width and height\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tgeometry_msgs::Point origin_point;\n\tcostmap_->mapToWorld(0, 0, origin_point.x, origin_point.y);\n\n\t// Set the origin's position and orientation\n\tgrid_.info.origin.position = origin_point;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Save the origin coordinates\n\torigin_x_ = origin_point.x;\n\torigin_y_ = origin_point.y;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int x = 0; x < grid_.info.width; x++) {\n\t\tfor (unsigned int y = 0; y < grid_.info.height; y++) {\n\t\t\tint index = y * grid_.info.width + x;\n\t\t\tgrid_.data[index] = costmap_2d::Costmap2D::translateChar(costmap_->getCharMap()[y * costmap_->getSizeInCellsX() + x]);\n\t\t}\n\t}\n\n\t// Unlock the costmap mutex\n\tcostmap_mutex_.unlock();\n}", "CodeBleu_score": 54.3293103340356}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap mutex\n\tcostmap_mutex_.lock();\n\n\t// Get the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\n\t// Set the grid's resolution, width, and height\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tgeometry_msgs::Point origin_point;\n\tcostmap_->mapToWorld(0, 0, origin_point.x, origin_point.y);\n\n\t// Set the origin's position and orientation\n\tgrid_.info.origin.position.x = origin_point.x;\n\tgrid_.info.origin.position.y = origin_point.y;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Save the origin coordinates\n\torigin_x_ = origin_point.x;\n\torigin_y_ = origin_point.y;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tunsigned int size_in_cells = grid_.info.width * grid_.info.height;\n\tunsigned int index;\n\tunsigned int cost;\n\tfor (unsigned int i = 0; i < size_in_cells; ++i) {\n\t\tindex = i;\n\t\tcost = costmap_->getCharMap()[index];\n\t\tgrid_.data[index] = costmap_2d::Costmap2D::translateCost(cost);\n\t}\n\n\t// Unlock the costmap mutex\n\tcostmap_mutex_.unlock();\n}", "CodeBleu_score": 55.80619159771789}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tmutex_.lock();\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tmutex_.unlock();\n}", "CodeBleu_score": 41.1123355184893}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint_radius == old_config.footprint_radius && new_config.footprint_model.empty()) {\n\t\tROS_DEBUG(\"Footprint radius is unchanged, not updating footprint\");\n\t\treturn;\n\t}\n\tif (!new_config.footprint_model.empty()) {\n\t\tROS_DEBUG(\"Attempting to update footprint based on new footprint model\");\n\t\tcostmap_2d::Costmap2DROS::initializeFootprintFromParam(new_config.footprint_model, footprint_);\n\t\tROS_DEBUG(\"Footprint updated successfully\");\n\t\treturn;\n\t}\n\tROS_WARN(\"Footprint model string is empty, not updating footprint\");\n}", "CodeBleu_score": 40.39854715762517}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.robot_radius != old_config.robot_radius) {\n\t\trobot_radius_ = new_config.robot_radius;\n\t\tif (!footprint_.fromText(new_config.footprint_spec)) {\n\t\t\tROS_WARN(\"Invalid footprint provided on the parameter server, using default footprint\");\n\t\t\tfootprint_.fromPosition2D(0.5, 0.5, robot_radius_);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.4943109243791}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint_spec != old_config.footprint_spec) {\n\t\tif (new_config.footprint_spec.empty()) {\n\t\t\tROS_WARN(\"Footprint is not specified in the costmap configuration. Using the robot radius to create a circle footprint\");\n\t\t\tfootprint_ = createFootprintFromRadius(robot_radius_);\n\t\t} else {\n\t\t\tROS_INFO(\"Footprint is specified in the costmap configuration. Converting the footprint string into a polygon\");\n\t\t\tfootprint_ = createFootprintFromPolygonString(new_config.footprint_spec);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.96386058112958}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tgeometry_msgs::PoseStamped new_pose;\n\tif (!costmap_ros_->getRobotPose(new_pose)) {\n\t\tROS_WARN(\"Unable to retrieve robot pose, cancelling reconfiguration\");\n\t\treconfigure_server_->cancel();\n\t\treturn;\n\t}\n\tcurrent_pose_ = new_pose;\n}", "CodeBleu_score": 58.06788195470938}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!initialized_) {\n\t\tROS_WARN(\"Costmap2DROS is not yet initialized, cannot process movement callback\");\n\t\treturn;\n\t}\n\tif (!costmap_->getRobotPose(new_pose_)) {\n\t\tROS_WARN(\"Unable to get robot pose, cannot process movement callback\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 46.00816908831359}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\ntf2::Stamped<tf2::Transform> new_pose;\n", "CodeBleu_score": 9.879574658943504}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"Costmap2DROS::start() : The costmap has not been initialized yet. Please call initialize() before starting the costmap.\");\n\t\treturn;\n\t}\n\n\tif (initialized_ && !active_) {\n\t\tROS_DEBUG(\"Costmap2DROS::start() : The costmap has been initialized but not activated. Activating the costmap now.\");\n\t\tactivate();\n\t}\n\n\tif (initialized_ && active_ && !thread_initialized_) {\n\t\tROS_DEBUG(\"Costmap2DROS::start() : The costmap has been initialized, activated, and the map update thread has not been initialized. Initializing the map update thread now.\");\n\t\tinitializeThread();\n\t}\n\n\tif (initialized_ && active_ && thread_initialized_ && !thread_active_) {\n\t\tROS_DEBUG(\"Costmap2DROS::start() : The costmap has been initialized, activated, and the map update thread has been initialized but not activated. Activating the map update thread now.\");\n\t\tactivateThread();\n\t}\n\n\tif (initialized_ && active_ && thread_initialized_ && thread_active_) {\n\t\tROS_DEBUG(\"Costmap2DROS::start() : The costmap has been initialized, activated, and the map update thread has been initialized and activated. Waiting for the map update thread to become active.\");\n\t\twaitForThread();\n\t}\n\n\tif (initialized_ && active_ && thread_initialized_ && thread_active_) {\n\t\tROS_DEBUG(\"Costmap2DROS::start() : The costmap has been initialized, activated, the map update thread has been initialized and activated, and the map update thread is active. The costmap is now ready to be used.\");\n\t}\n}", "CodeBleu_score": 31.373313588856316}, {"code": "void Costmap2DROS::start(){\n\t\n// \tROS_INFO(\"Starting costmap\");\n\n// \tif (!initialized_) {\n// \t\tROS_ERROR(\"Costmap2DROS::start() can only be called after the costmap has been initialized\");\n// \t\treturn;\n// \t}\n\n// \t// get the list of active plugins\n// \tstd::vector<std::string> active_plugins;\n// \tfor (size_t i = 0; i < plugins_.size(); ++i) {\n// \t\tif (plugins_[i]->isStopped()) {\n// \t\t\tactive_plugins.push_back(plugins_[i]->getName());\n// \t\t}\n// \t}\n\n// \t// if the costmap is stopped, re-subscribe to all topics\n// \tif (isStopped()) {\n// \t\tfor (size_t i = 0; i < plugins_.size(); ++i) {\n// \t\t\tif (plugins_[i]->getName() != \"inflation_layer\") {\n// \t\t\t\tplugins_[i]->activate();\n// \t\t\t}\n// \t\t}\n// \t\tsetStopped(false);\n// \t}\n\n// \t// wait until the costmap is initialized and the map update thread is active\n// \twhile (!initialized_ || !update_thread_.isActive()) {\n// \t\tros::WallDuration(0.1).sleep();\n// \t}\n\n// \t// print the list of active plugins\n// \tstd::string active_plugins_string = \"\";\n// \tfor (size_t i = 0; i < active_plugins.size(); ++i) {\n// \t\tactive_plugins_string += active_plugins[i] + \" \";\n// \t}\n// \tROS_INFO(\"The following plugins are active: %s\", active_plugins_string.c_str());\n\n// \t// if there are any active plugins, print a warning\n// \tif (active_plugins.size() > 0) {\n// \t\tROS_WARN(\"Costmap2DROS::start() has been called on a costmap with the following active plugins: %s\", active_plugins_string.c_str());\n// \t}\n}", "CodeBleu_score": 1.5748498721036488}, {"code": "void Costmap2DROS::start(){\n\t\t// retrieve the list of plugins\n\tstd::vector<std::string> plugin_names = this->getCostmap()->getPluginNames();\n\n\t// check if the costmap was stopped\n\tif (this->isStopped()) {\n\t\t// re-subscribe to topics by activating each plugin\n\t\tfor (unsigned int i = 0; i < plugin_names.size(); i++) {\n\t\t\tthis->getCostmap()->activatePluginByName(plugin_names[i]);\n\t\t}\n\n\t\t// set the stopped flag to false\n\t\tthis->setStopped(false);\n\n\t\t// set stop_updates_ to false\n\t\tthis->stop_updates_ = false;\n\t}\n\n\t// wait until ROS is running, the costmap is initialized, and the map update thread is active\n\tros::Rate r(10);\n\twhile (!this->getCostmap()->isInit() || !this->getCostmap()->isActive()) {\n\t\tr.sleep();\n\t}\n}", "CodeBleu_score": 36.09623182313899}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// Check if the observation_keep_time_ is zero\n\tif (observation_keep_time_ == 0) {\n\t\t// If it is, then only keep the most recent observation\n\t\tif (observations_.size() > 0) {\n\t\t\tobservations_.erase(observations_.begin(), observations_.begin() + (observations_.size() - 1));\n\t\t}\n\t} else {\n\t\t// Otherwise, iterate through the list and remove observations that are older than the specified keep time\n\t\tfor (std::vector<Observation*>::iterator it = observations_.begin(); it != observations_.end();) {\n\t\t\tif ((*it)->getObservationAge() > observation_keep_time_) {\n\t\t\t\tit = observations_.erase(it);\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.293611650671224}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// Check if the keep time is zero, and if so, return\n\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\n\t// Get the current time\n\tros::Time current_time = ros::Time::now();\n\n\t// Iterate through the list and remove observations that are older than the keep time\n\tfor (std::vector<Observation>::iterator it = observations_.begin(); it != observations_.end();) {\n\t\tif ((current_time - it->stamp).toSec() > observation_keep_time_) {\n\t\t\tit = observations_.erase(it);\n\t\t} else {\n\t\t\tit++;\n\t\t}\n\t}\n}", "CodeBleu_score": 31.8701702682089}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If the observation keep time is zero, just return\n\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\n\t// Get the current time\n\tros::Time current_time = ros::Time::now();\n\n\t// Iterate through the list, removing observations that are too old\n\tfor (auto it = observations_.begin(); it != observations_.end();) {\n\t\t// If the observation is too old, remove it\n\t\tif ((current_time - it->header.stamp).toSec() > observation_keep_time_) {\n\t\t\tit = observations_.erase(it);\n\t\t}\n\t\telse {\n\t\t\t// Otherwise, move to the next observation\n\t\t\tit++;\n\t\t}\n\t}\n}", "CodeBleu_score": 29.937247232761454}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (start_index >= (int)path.size() || end_index >= (int)path.size()) {\n\t\tROS_ERROR(\"Invalid start or end index in OrientationFilter::interpolate\");\n\t\treturn;\n\t}\n\n\tif (start_index < 0 || end_index < 0) {\n\t\tROS_ERROR(\"Negative start or end index in OrientationFilter::interpolate\");\n\t\treturn;\n\t}\n\n\tif (start_index > end_index) {\n\t\tROS_ERROR(\"Start index greater than end index in OrientationFilter::interpolate\");\n\t\treturn;\n\t}\n\n\tif (start_index == end_index) {\n\t\tROS_ERROR(\"Start and end indices are equal in OrientationFilter::interpolate\");\n\t\treturn;\n\t}\n\n\t// Calculate the yaw angles at the start and end indices.\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Determine the shortest angular distance between the start and end yaw angles.\n\tdouble yaw_delta = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose and update the orientation of each pose in the specified range accordingly.\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\t// Calculate the incremental change in angle.\n\t\tdouble delta = yaw_delta / (end_index - start_index);\n\n\t\t// Calculate the new yaw angle.\n\t\tdouble new_yaw = start_yaw + delta * (i - start_index);\n\n\t\t// Update the orientation of the pose.\n\t\ttf2::Quaternion q;\n\t\tq.setRPY(0.0, 0.0, new_yaw);\n\t\tpath[i].pose.orientation.x = q.x();\n\t\tpath[i].pose.orientation.y = q.y();\n\t\tpath[i].pose.orientation.z = q.z();\n\t\tpath[i].pose.orientation.w = q.w();\n\t}\n}", "CodeBleu_score": 51.902064549790836}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (path.empty()) {\n\t\tROS_ERROR(\"Path is empty, cannot interpolate\");\n\t\treturn;\n\t}\n\n\t// Check if indices are valid\n\tif (start_index < 0 || start_index >= (int) path.size()) {\n\t\tROS_ERROR(\"Invalid start index, cannot interpolate\");\n\t\treturn;\n\t}\n\tif (end_index < 0 || end_index >= (int) path.size()) {\n\t\tROS_ERROR(\"Invalid end index, cannot interpolate\");\n\t\treturn;\n\t}\n\tif (start_index >= end_index) {\n\t\tROS_ERROR(\"Start index must be smaller than end index, cannot interpolate\");\n\t\treturn;\n\t}\n\n\t// Get yaw angles at start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate shortest angular distance between start and end yaw angles\n\tdouble angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute incremental change in angle\n\tdouble angle_increment = angular_distance / (end_index - start_index);\n\n\t// Update orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\t// Get current yaw angle\n\t\tdouble current_yaw = tf2::getYaw(path[i].pose.orientation);\n\n\t\t// Calculate new yaw angle\n\t\tdouble new_yaw = current_yaw + angle_increment;\n\n\t\t// Update orientation\n\t\ttf2::Quaternion q;\n\t\tq.setRPY(0, 0, new_yaw);\n\t\tpath[i].pose.orientation.x = q.x();\n\t\tpath[i].pose.orientation.y = q.y();\n\t\tpath[i].pose.orientation.z = q.z();\n\t\tpath[i].pose.orientation.w = q.w();\n\t}\n}", "CodeBleu_score": 51.30710563564811}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif(start_index < 0 || start_index >= (int)path.size() || end_index < 0 || end_index >= (int)path.size() || start_index >= end_index) {\n\t\treturn;\n\t}\n\n\t// Get the yaw angles at the start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between them\n\tdouble yaw_diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose and update the orientation of each pose in the specified range accordingly\n\tfor(int i = start_index; i <= end_index; i++) {\n\t\tdouble yaw = tf2::getYaw(path[i].pose.orientation);\n\t\tdouble new_yaw = angles::normalize_angle(yaw + yaw_diff);\n\t\tpath[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0.0, 0.0, 1.0), new_yaw));\n\t}\n}", "CodeBleu_score": 52.959160249878856}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a call to make a plan\");\n\n\t// Set the frame_id of the start and goal to \"map\"\n\tgeometry_msgs::PoseStamped start;\n\tstart.header.frame_id = \"map\";\n\tstart.pose.position.x = req.start.pose.position.x;\n\tstart.pose.position.y = req.start.pose.position.y;\n\tstart.pose.orientation.z = req.start.pose.orientation.z;\n\tstart.pose.orientation.w = req.start.pose.orientation.w;\n\n\tgeometry_msgs::PoseStamped goal;\n\tgoal.header.frame_id = \"map\";\n\tgoal.pose.position.x = req.goal.pose.position.x;\n\tgoal.pose.position.y = req.goal.pose.position.y;\n\tgoal.pose.orientation.z = req.goal.pose.orientation.z;\n\tgoal.pose.orientation.w = req.goal.pose.orientation.w;\n\n\t// Call makePlan to generate a path\n\tnavfn::MakeNavPlan::Response plan = makePlan(start, goal);\n\n\t// Update the response with the success status and the generated path if a plan is found\n\tif (plan.plan.poses.size() > 0) {\n\t\tresp.plan = plan.plan;\n\t\tresp.success = true;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 46.74516019249521}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a call to make a plan\");\n\n\t// Set the start and goal frame_ids to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a plan\n\tmakePlan(req.start, req.goal, resp.plan);\n\n\t// If a plan was found, set the response status to success\n\tif (resp.plan.poses.size() > 0) {\n\t\tROS_INFO(\"Plan found successfully\");\n\t\tresp.status.status = resp.status.SUCCESS;\n\t} else {\n\t\tROS_WARN(\"No plan found\");\n\t\tresp.status.status = resp.status.FAILURE;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.939641501762466}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a make plan request\");\n\n\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tnavfn::MakeNavPlan::Response plan = makePlan(req.start, req.goal);\n\n\t// Update the response with the success status and the generated path if a plan is found\n\tresp.plan = plan.plan;\n\tresp.success = plan.success;\n\n\tROS_INFO(\"Sending a make plan response\");\n\n\treturn true;\n}", "CodeBleu_score": 55.814544994086404}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\"~/\" + name);\n\tmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\n\tgoal_sub = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 57.874714303611974}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\"~/\" + name);\n\n\tmake_plan_srv_ = nh_.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\n\tgoal_sub_ = nh_.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 58.93496172091561}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\"~/\" + name);\n\tmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\n\tgoal_sub = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 57.874714303611974}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_ros_->getOriginX() || wy < costmap_ros_->getOriginY()) {\n\t\tROS_ERROR(\"The world coordinates (%f, %f) are outside the costmap's origin (%f, %f).\", wx, wy, costmap_ros_->getOriginX(), costmap_ros_->getOriginY());\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_ros_->getOriginX()) / costmap_ros_->getResolution();\n\tmy = (wy - costmap_ros_->getOriginY()) / costmap_ros_->getResolution();\n\tif (mx < 0 || my < 0 || mx >= costmap_ros_->getSizeInCellsX() || my >= costmap_ros_->getSizeInCellsY()) {\n\t\tROS_ERROR(\"The map coordinates (%f, %f) are outside the costmap's size limits.\", mx, my);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.44138205638865}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_ros_->getOriginX() || wy < costmap_ros_->getOriginY() || wx >= costmap_ros_->getOriginX() + costmap_ros_->getSizeInMetersX() || wy >= costmap_ros_->getOriginY() + costmap_ros_->getSizeInMetersY()) {\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_ros_->getOriginX()) / costmap_ros_->getResolution();\n\tmy = (wy - costmap_ros_->getOriginY()) / costmap_ros_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 41.34020223160076}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_ros_->getOriginX() || wy < costmap_ros_->getOriginY()) {\n\t\tROS_ERROR(\"The world coordinates (%f, %f) are outside the bounds of the costmap.\", wx, wy);\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_ros_->getOriginX()) / costmap_ros_->getResolution();\n\tmy = (wy - costmap_ros_->getOriginY()) / costmap_ros_->getResolution();\n\tif (mx < 0 || my < 0) {\n\t\tROS_ERROR(\"The world coordinates (%f, %f) are outside the bounds of the costmap.\", wx, wy);\n\t\treturn false;\n\t}\n\tif (mx >= costmap_ros_->getSizeInCellsX() || my >= costmap_ros_->getSizeInCellsY()) {\n\t\tROS_ERROR(\"The world coordinates (%f, %f) are outside the bounds of the costmap.\", wx, wy);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.184214630031924}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_)  {\n\t\tROS_ERROR(\"Call initialize() before using this planner\");\n\t\treturn;\n\t}\n\t// Create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Copy the plan to the message\n\tfor (unsigned int i = 0; i < path.size(); i++)  {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\t// Publish the plan\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 81.10843835563561}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_)  {\n\t\tROS_ERROR(\"Call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tROS_INFO(\"Publishing plan\");\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); i++)  {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 79.869630479834}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"The planner has not been initialized, please call initialize() to use the planner\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Publishing plan\");\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = global_frame_;\n\tgui_path.header.stamp = ros::Time::now();\n\tgui_path.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 77.85605574098946}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_STREAM(\"Received goal with frame_id \" << goal->header.frame_id << \" and timestamp \" << goal->header.stamp.toSec());\n\n\t// Create a MoveBaseActionGoal with the MoveBaseGoal inside\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\t// Publish the action goal\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 71.37627740912235}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Received a goal!\");\n\n\t// Create a MoveBaseActionGoal\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\n\t// Set the timestamp to \"now\"\n\taction_goal.header.stamp = ros::Time::now();\n\n\t// Assign the goal to the MoveBaseActionGoal\n\taction_goal.goal.target_pose = *goal;\n\n\t// Publish the MoveBaseActionGoal\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 66.9398489231982}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_STREAM(\"MoveBase::goalCB has been called\");\n\n\t// Create a MoveBaseActionGoal message\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\n\t// Set the timestamp to the current time\n\taction_goal.header.stamp = ros::Time::now();\n\n\t// Set the goal to the received goal\n\taction_goal.goal.target_pose = *goal;\n\n\t// Publish the action goal to the action_goal_pub_ topic\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 68.4330666675834}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble squared_limited_distance = pow(limited_distance, 2);\n\tdouble squared_current_distance = pow(current_distance, 2);\n\n\tif (squared_limited_distance < squared_current_distance) {\n\t\tROS_INFO(\"Robot has moved far enough, removing speed limit\");\n\t\tif (remove_limit_thread.joinable()) {\n\t\t\tremove_limit_thread.join();\n\t\t}\n\t\tremove_limit_thread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\t\tdistance_check_timer.stop();\n\t}\n}", "CodeBleu_score": 49.180621613117914}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\t// Check if the robot has moved far enough\n\tif (std::pow(distance_traveled_squared, 0.5) >= distance_threshold) {\n\t\t// Log a message\n\t\tROS_INFO(\"The robot has moved far enough to clear the speed limit\");\n\n\t\t// Join and delete the existing remove limit thread\n\t\tif (remove_limit_thread.joinable()) {\n\t\t\tremove_limit_thread.join();\n\t\t\tdelete remove_limit_thread;\n\t\t}\n\n\t\t// Start a new thread to remove the speed limit\n\t\tremove_limit_thread = std::thread(&MoveSlowAndClear::removeLimit, this);\n\t}\n}", "CodeBleu_score": 38.94831662706317}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (this->distance_squared > this->distance_limit_squared) {\n\t\tROS_INFO(\"Robot has moved %f meters\", sqrt(this->distance_squared));\n\t\tif (this->remove_limit_thread.joinable()) {\n\t\t\tthis->remove_limit_thread.join();\n\t\t}\n\t\tthis->remove_limit_thread = std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tthis->distance_check_timer.stop();\n\t}\n}", "CodeBleu_score": 23.147198554611442}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current pose of the robot\n\tgeometry_msgs::PoseStamped robot_pose = getRobotPose();\n\n\t// Make a plan from the current pose to the goal pose\n\tmakePlan(robot_pose, goal, path);\n}", "CodeBleu_score": 35.75375078178891}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Received a new goal\");\n\tgeometry_msgs::PoseStamped current_pose = getRobotPose();\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\tmakePlan(current_pose, goal, path);\n}", "CodeBleu_score": 45.2412864530011}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tgeometry_msgs::PoseStamped global_pose = getRobotPose();\n\tnavfn::MakeNavPlan srv;\n\tsrv.request.start = global_pose;\n\tsrv.request.goal = *goal;\n\tsrv.request.tolerance = 0.5;\n\tmakePlan(srv.request, srv.response);\n}", "CodeBleu_score": 44.85367152958205}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSetRequest param_set_request;\n\tmavros_msgs::ParamSetResponse param_set_response;\n\n\tparam_set_request.param_id = param_set.param_id;\n\tparam_set_request.value = param_set.value;\n\n\tparam_set_client_.call(param_set_request, param_set_response);\n}", "CodeBleu_score": 47.54392424352943}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Service request to set gimbal parameters\n\tmavros_msgs::ParamSetRequest param_set_request;\n\n\t// Assign parameter ID and value from the provided GimbalParamSet structure to the service request\n\tparam_set_request.param_id = param_set.param_id;\n\tparam_set_request.value = param_set.value;\n\n\t// Send service request\n\tif (param_set_client_.call(param_set_request)) {\n\t\tROS_INFO(\"Gimbal parameter set successfully\");\n\t}\n\telse {\n\t\tROS_ERROR(\"Gimbal parameter set failed\");\n\t}\n}", "CodeBleu_score": 47.324076078593805}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create service request\n\tmavros_msgs::ParamSetRequest request;\n\trequest.param_id = param_set.param_id;\n\trequest.value = param_set.value;\n\t// Call service\n\tparam_set_client_.call(request);\n}", "CodeBleu_score": 54.34764370317416}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\t// Create a TCP/IP socket\n\tint server_socket = socket(AF_INET, SOCK_STREAM, 0);\n\tif (server_socket < 0) {\n\t\tROS_ERROR(\"Failed to create socket: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\t// Bind the socket to the port\n\tstruct sockaddr_in server_addr;\n\tserver_addr.sin_family = AF_INET;\n\tserver_addr.sin_addr.s_addr = INADDR_ANY;\n\tserver_addr.sin_port = htons(port);\n\tif (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {\n\t\tROS_ERROR(\"Failed to bind socket: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\t// Listen for incoming connections\n\tif (listen(server_socket, 1) < 0) {\n\t\tROS_ERROR(\"Failed to listen: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\tROS_INFO(\"Server listening on port %d\", port);\n\n\t// Accept a connection\n\tstruct sockaddr_in client_addr;\n\tsocklen_t client_addr_len = sizeof(client_addr);\n\tint client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_len);\n\tif (client_socket < 0) {\n\t\tROS_ERROR(\"Failed to accept connection: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\tROS_INFO(\"Client connected\");\n\n\t// Close the server socket\n\tclose(server_socket);\n\n\t// Read from the client socket\n\tchar buf[1024];\n\tint len = recv(client_socket, buf, sizeof(buf), 0);\n\tif (len <= 0) {\n\t\tROS_ERROR(\"Failed to receive data: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\tROS_INFO(\"Received data: %s\", buf);\n\n\t// Close the client socket\n\tclose(client_socket);\n}", "CodeBleu_score": 43.9922765041486}, {"code": "void CommunicationBridge::serverFun(){\n\t\t// Create a TCP socket.\n\tint server_fd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (server_fd < 0) {\n\t\tROS_ERROR(\"Failed to create a socket.\");\n\t\treturn;\n\t}\n\n\t// Bind the socket to the specified port.\n\tstruct sockaddr_in server_addr;\n\tserver_addr.sin_family = AF_INET;\n\tserver_addr.sin_port = htons(port);\n\tserver_addr.sin_addr.s_addr = INADDR_ANY;\n\tif (bind(server_fd, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {\n\t\tROS_ERROR(\"Failed to bind the socket to the specified port.\");\n\t\treturn;\n\t}\n\n\t// Listen for incoming connections.\n\tif (listen(server_fd, 1) < 0) {\n\t\tROS_ERROR(\"Failed to listen for incoming connections.\");\n\t\treturn;\n\t}\n\n\t// Accept incoming connections.\n\tROS_INFO(\"Waiting for a connection from the ground station...\");\n\twhile (ros::ok()) {\n\t\t// Accept a connection.\n\t\tstruct sockaddr_in client_addr;\n\t\tsocklen_t client_addr_len = sizeof(client_addr);\n\t\tint client_fd = accept(server_fd, (struct sockaddr *) &client_addr, &client_addr_len);\n\t\tif (client_fd < 0) {\n\t\t\tROS_ERROR(\"Failed to accept a connection.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Receive data from the client.\n\t\tchar buffer[1024];\n\t\tint bytes_read = recv(client_fd, buffer, sizeof(buffer), 0);\n\t\tif (bytes_read <= 0) {\n\t\t\tROS_ERROR(\"Failed to receive data from the client.\");\n\t\t\tclose(client_fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Decode the message.\n\t\tstd::string message;\n\t\ttry {\n\t\t\tmessage = std::string(buffer, bytes_read);\n\t\t} catch (const std::exception &e) {\n\t\t\tROS_ERROR(\"Failed to decode the message.\");\n\t\t\tclose(client_fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Publish the message", "CodeBleu_score": 45.53266011335461}, {"code": "void CommunicationBridge::serverFun(){\n\t\t// Create a TCP socket\n\tint server_fd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (server_fd < 0) {\n\t\tROS_ERROR(\"Unable to create socket\");\n\t\treturn;\n\t}\n\n\t// Set socket options\n\tint opt = 1;\n\tif (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {\n\t\tROS_ERROR(\"Unable to set socket options\");\n\t\treturn;\n\t}\n\n\t// Bind the socket to the specified port\n\tstruct sockaddr_in server_addr;\n\tserver_addr.sin_family = AF_INET;\n\tserver_addr.sin_addr.s_addr = INADDR_ANY;\n\tserver_addr.sin_port = htons(server_port);\n\tif (bind(server_fd, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {\n\t\tROS_ERROR(\"Unable to bind to port\");\n\t\treturn;\n\t}\n\n\t// Listen for incoming connections\n\tif (listen(server_fd, 10) < 0) {\n\t\tROS_ERROR(\"Unable to listen\");\n\t\treturn;\n\t}\n\n\t// Accept incoming connections\n\tROS_INFO(\"Listening for incoming connections\");\n\twhile (ros::ok()) {\n\t\t// Accept a connection\n\t\tstruct sockaddr_in client_addr;\n\t\tsocklen_t client_len = sizeof(client_addr);\n\t\tint client_fd = accept(server_fd, (struct sockaddr *) &client_addr, &client_len);\n\t\tif (client_fd < 0) {\n\t\t\tROS_ERROR(\"Unable to accept connection\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Process the connection\n\t\tROS_INFO(\"Accepted connection from %s\", inet_ntoa(client_addr.sin_addr));\n\t\tprocessConnection(client_fd);\n\t}\n}", "CodeBleu_score": 45.30962892172617}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (uav_cmd.id == 0) {\n\t\treturn;\n\t}\n\tif (simulation_mode_) {\n\t\tboost::shared_lock<boost::shared_mutex> lock(swarm_control_simulation_mutex_);\n\t\tfor (auto it = swarm_control_simulation_.begin(); it != swarm_control_simulation_.end(); it++) {\n\t\t\tif (it->second.id == uav_cmd.id) {\n\t\t\t\tuav_cmd.x = it->second.x;\n\t\t\t\tuav_cmd.y = it->second.y;\n\t\t\t\tuav_cmd.z = it->second.z;\n\t\t\t\tuav_cmd.yaw = it->second.yaw;\n\t\t\t\tuav_cmd.pitch = it->second.pitch;\n\t\t\t\tuav_cmd.roll = it->second.roll;\n\t\t\t\tuav_cmd.vx = it->second.vx;\n\t\t\t\tuav_cmd.vy = it->second.vy;\n\t\t\t\tuav_cmd.vz = it->second.vz;\n\t\t\t\tuav_cmd.vyaw = it->second.vyaw;\n\t\t\t\tuav_cmd.vpitch = it->second.vpitch;\n\t\t\t\tuav_cmd.vroll = it->second.vroll;\n\t\t\t\tuav_cmd.height = it->second.height;\n\t\t\t\tuav_cmd.heading = it->second.heading;\n\t\t\t\tuav_cmd.status = it->second.status;\n\t\t\t\tuav_cmd.type = it->second.type;\n\t\t\t\tuav_cmd.action = it->second.action;\n\t\t\t\tuav_cmd.action_x = it->second.action_x;\n\t\t\t\tuav_cmd.action_y = it->second.action_y;\n\t\t\t\tuav_cmd.action_z = it->second.action_z;\n\t\t\t\tuav_cmd.action_yaw = it->second.action_yaw;\n\t\t\t\tuav_cmd.action_pitch = it->second.action_pitch;\n\t\t\t\tuav_cmd.action_roll = it->second.action_roll;\n\t\t\t\tuav_cmd.action_vx = it->second.action_vx;\n\t\t\t\tuav_cmd.action_vy = it->second.action", "CodeBleu_score": 34.72348242113113}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tboost::mutex::scoped_lock lock(mutex_data_in_);\n\n\tif (simulation_mode_ == true) {\n\t\tint id = uav_cmd.id;\n\t\tif (id < 0 || id >= swarm_control_simulation_.size()) {\n\t\t\treturn;\n\t\t}\n\t\tswarm_control_simulation_[id].uav_cmd_ = uav_cmd;\n\t}\n\telse {\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 37.431566804861674}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tboost::shared_lock<boost::shared_mutex> lock(mutex);\n\tif (sim_mode) {\n\t\tfor (auto it = swarm_control_simulation_.begin(); it != swarm_control_simulation_.end(); it++) {\n\t\t\tif (it->first == uav_cmd.id) {\n\t\t\t\tit->second.uav_cmd = uav_cmd;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 37.66458194157136}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tstd::string command = \"reboot\";\n\t\tstd::system(command.c_str());\n\t}\n\telse if (mode_selection.use_mode == EXITNX) {\n\t\tstd::string command = \"poweroff\";\n\t\tstd::system(command.c_str());\n\t}\n\telse if (mode_selection.use_mode == CREATE_MODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t}\n\telse if (mode_selection.use_mode == DELETE_MODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 50.30289084736162}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == ModeSelection::EXITNX) {\n\t\tstd::cout << \"Exiting SwitcherNX\" << std::endl;\n\t\texit(0);\n\t} else if (mode_selection.use_mode == ModeSelection::REBOOTNX) {\n\t\tstd::cout << \"Rebooting SwitcherNX\" << std::endl;\n\t\tsystem(\"reboot\");\n\t} else if (mode_selection.use_mode == ModeSelection::CREATE_MODE) {\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == ModeSelection::DELETE_MODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 64.66284679145734}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tboost::unique_lock<boost::shared_mutex> lock(mutex);\n\n\tif (mode_selection.use_mode == ModeSelection::USE_MODE_REBOOTNX) {\n\t\tstd::string command = \"rebootnx\";\n\t\tstd::system(command.c_str());\n\t} else if (mode_selection.use_mode == ModeSelection::USE_MODE_EXITNX) {\n\t\tstd::string command = \"exitnx\";\n\t\tstd::system(command.c_str());\n\t} else if (mode_selection.use_mode == ModeSelection::USE_MODE_CREATE) {\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == ModeSelection::USE_MODE_DELETE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 62.40035327783481}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tboost::unique_lock<boost::shared_mutex> lock(mutex);\n\n\t// Check if the heartbeat is lost\n\tif (heartbeat_lost_count > 0) {\n\t\tif (heartbeat_lost_count == max_heartbeat_lost_count) {\n\t\t\tROS_ERROR(\"No heartbeat received from the vehicle for %d seconds. Disconnecting.\", max_heartbeat_lost_count);\n\t\t\tif (vehicle_type == VehicleType::SWARM) {\n\t\t\t\tswarm_bridge.disconnectVehicle();\n\t\t\t}\n\t\t\telse if (vehicle_type == VehicleType::UAV) {\n\t\t\t\tuav_bridge.disconnectVehicle();\n\t\t\t}\n\t\t\telse if (vehicle_type == VehicleType::UGV) {\n\t\t\t\tugv_bridge.disconnectVehicle();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tROS_ERROR(\"No heartbeat received from the vehicle. Trying again...\");\n\t\t}\n\t}\n\telse {\n\t\tROS_INFO(\"Heartbeat received from the vehicle.\");\n\t}\n\n\t// Reset the heartbeat lost counter\n\theartbeat_lost_count = 0;\n}", "CodeBleu_score": 29.84026403518667}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tboost::shared_lock<boost::shared_mutex> lock(mutex);\n\tif (heartbeat_count == 0) {\n\t\theartbeat_count = 1;\n\t} else {\n\t\theartbeat_count++;\n\t}\n\tif (heartbeat_count > 5) {\n\t\tROS_ERROR(\"Lost connectivity to the vehicle. Check that the vehicle is powered on and the radio is turned on.\");\n\t\tif (vehicle_type == \"UGV\") {\n\t\t\tROS_ERROR(\"The UGV will now enter autonomous mode.\");\n\t\t\tautonomous_mode = true;\n\t\t} else if (vehicle_type == \"UAV\") {\n\t\t\tROS_ERROR(\"The UAV will now enter autonomous mode.\");\n\t\t\tautonomous_mode = true;\n\t\t} else if (vehicle_type == \"Swarm\") {\n\t\t\tROS_ERROR(\"The swarm will now enter autonomous mode.\");\n\t\t\tautonomous_mode = true;\n\t\t}\n\t\tdisconnect_flag = true;\n\t}\n\tlock.unlock();\n}", "CodeBleu_score": 31.804048559432772}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tboost::shared_lock<boost::shared_mutex> lock(mutex);\n\tif (disconnect_flag) {\n\t\treturn;\n\t}\n\tif (heartbeat_count < 0) {\n\t\theartbeat_count = 0;\n\t}\n\tif (heartbeat_count == 0) {\n\t\theartbeat_count = 1;\n\t}\n\telse {\n\t\theartbeat_count++;\n\t}\n\tif (heartbeat_count > 2) {\n\t\tif (type == \"swarm\") {\n\t\t\tROS_ERROR(\"Swarm lost connection to the server.\");\n\t\t\tswarm_status_pub.publish(swarm_msgs::swarm_status(swarm_msgs::swarm_status::LOST_CONNECTION));\n\t\t}\n\t\telse if (type == \"uav\") {\n\t\t\tROS_ERROR(\"UAV lost connection to the server.\");\n\t\t\tuav_status_pub.publish(swarm_msgs::uav_status(swarm_msgs::uav_status::LOST_CONNECTION));\n\t\t}\n\t\telse if (type == \"ugv\") {\n\t\t\tROS_ERROR(\"UGV lost connection to the server.\");\n\t\t\tugv_status_pub.publish(swarm_msgs::ugv_status(swarm_msgs::ugv_status::LOST_CONNECTION));\n\t\t}\n\t\tdisconnect_flag = true;\n\t}\n}", "CodeBleu_score": 32.85268214669315}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Get the drone ID from the message\n\tuint8_t drone_id = msg->id;\n\t// Get the trajectory data from the message\n\tstd::vector<MultiBspline> mbsplines = msg->mbsplines;\n\n\t// Create a TCP message\n\tprometheus_msgs::SwarmCommand sc_msg;\n\tsc_msg.header.stamp = ros::Time::now();\n\tsc_msg.id = drone_id;\n\tsc_msg.group = 0;\n\n\t// For each trajectory, create a Bspline struct, set its attributes, and populate its knots, position points, and yaw points\n\tfor (int i = 0; i < mbsplines.size(); i++) {\n\t\t// Create a Bspline struct\n\t\tBspline bspline;\n\t\t// Set the Bspline struct's attributes\n\t\tbspline.dt = mbsplines[i].dt;\n\t\tbspline.duration = mbsplines[i].duration;\n\t\tbspline.num_segments = mbsplines[i].num_segments;\n\t\tbspline.num_knots = mbsplines[i].num_knots;\n\t\tbspline.num_pos_points = mbsplines[i].num_pos_points;\n\t\tbspline.num_yaw_points = mbsplines[i].num_yaw_points;\n\t\t// Populate the Bspline struct's knots, position points, and yaw points\n\t\tfor (int j = 0; j < bspline.num_knots; j++) {\n\t\t\tbspline.knots.push_back(mbsplines[i].knots[j]);\n\t\t}\n\t\tfor (int j = 0; j < bspline.num_pos_points; j++) {\n\t\t\tgeometry_msgs::Point32 point;\n\t\t\tpoint.x = mbsplines[i].pos_points[j].x;\n\t\t\tpoint.y = mbsplines[i].pos_points[j].y;\n\t\t\tpoint.z = mbsplines[i].pos_points[j].z;\n\t\t\tbspline.pos_points.push_back(point);\n\t\t}\n\t\tfor (int j = 0; j < bspline.num_yaw_", "CodeBleu_score": 44.833104942403246}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Extract drone ID from message\n\tint drone_id = msg->id;\n\t// Extract trajectory data from message\n\tstd::vector<double> knots = msg->knots;\n\tstd::vector<geometry_msgs::Point> pos_points = msg->pos_points;\n\tstd::vector<double> yaw_points = msg->yaw_points;\n\t// Initialize a Bspline struct\n\tBspline bspline;\n\t// Set Bspline attributes\n\tbspline.set_id(drone_id);\n\tbspline.set_knots(knots);\n\tbspline.set_pos_points(pos_points);\n\tbspline.set_yaw_points(yaw_points);\n\t// Populate Bspline's knots, position points, and yaw points\n\tbspline.populate_knots();\n\tbspline.populate_pos_points();\n\tbspline.populate_yaw_points();\n\t// Encode Bspline data\n\tstd::vector<uint8_t> data_vec;\n\tdata_vec = bspline.encode();\n\t// Send encoded data via TCP\n\tcomm.send_data(data_vec);\n}", "CodeBleu_score": 17.441398528400562}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Extract drone ID and trajectory data from the message\n\tint drone_id = msg->id;\n\tvector<vector<double>> traj_data = msg->data;\n\n\t// Create a Bspline struct for each trajectory\n\tvector<Bspline> bsplines;\n\tfor (int i = 0; i < traj_data.size(); i++) {\n\t\tBspline bspline;\n\n\t\t// Set Bspline attributes\n\t\tbspline.id = drone_id;\n\t\tbspline.duration = traj_data[i][0];\n\t\tbspline.t_d = traj_data[i][1];\n\t\tbspline.t_start = traj_data[i][2];\n\t\tbspline.t_end = traj_data[i][3];\n\t\tbspline.t_s = traj_data[i][4];\n\t\tbspline.t_f = traj_data[i][5];\n\t\tbspline.t_c = traj_data[i][6];\n\t\tbspline.t_w = traj_data[i][7];\n\t\tbspline.t_v = traj_data[i][8];\n\t\tbspline.t_a = traj_data[i][9];\n\t\tbspline.t_p = traj_data[i][10];\n\t\tbspline.t_y = traj_data[i][11];\n\t\tbspline.t_r = traj_data[i][12];\n\t\tbspline.t_phi = traj_data[i][13];\n\t\tbspline.t_theta = traj_data[i][14];\n\t\tbspline.t_psi = traj_data[i][15];\n\t\tbspline.t_x = traj_data[i][16];\n\t\tbspline.t_y = traj_data[i][17];\n\t\tbspline.t_z = traj_data[i][18];\n\t\tbspline.t_xd = traj_data[i][19];\n\t\tbspline.t_yd = traj_data[i][20];\n\t\tbspline.t_zd = traj_data[i][21];\n\t\tbspline.t_xdd = traj_data[i][22];\n\t", "CodeBleu_score": 36.2398197881988}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Create a pcl::PointCloud object from the PointCloud2 message\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Create a pcl::octree::OctreePointCloudSearch object.\n\tpcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree(resolution);\n\n\t// Set the input point cloud to be stored in the octree\n\toctree.setInputCloud(cloud);\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> pointIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelCentroidIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelCentroidPointIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelPointIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelPointCentroidIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelPointCentroidPointIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelCentroidPointCentroidIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelCentroidPointCentroidPointIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelPointCentroidPointCentroidIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelPointCentroidPointCentroidPointIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelCentroidPointCentroidPointCentroidIndices;\n\n\t// Create a vector of point indices to be used in voxel filtering\n\tstd::vector<int> voxelCentroidPointCentroidPointCentroidPointIndices;\n\n\t//", "CodeBleu_score": 26.467368592295415}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Create a pcl::PointCloud from the PointCloud2 message\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Create a pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> object\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree (\"resolution\");\n\n\t// Set the input point cloud to be compressed\n\toctree.setInputCloud (cloud);\n\n\t// Compress the point cloud using the octree-based compression\n\toctree.compress();\n\n\t// Create a pcl::PointCloud<pcl::PointXYZ> object to store the compressed data\n\tpcl::PointCloud<pcl::PointXYZ> cloud_compressed;\n\n\t// Get the compressed data\n\toctree.getCompressedData(cloud_compressed);\n\n\t// Create a PointCloud2 message for the compressed data\n\tsensor_msgs::PointCloud2 cloud_msg;\n\n\t// Convert the compressed data to a PointCloud2 message\n\tpcl::toROSMsg(cloud_compressed, cloud_msg);\n\n\t// Return the compressed PointCloud2 message\n\treturn cloud_msg;\n}", "CodeBleu_score": 32.331302829153564}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the PointCloud2 message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZRGB> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Compress the point cloud\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree_compression;\n\toctree_compression.setInputCloud(cloud.makeShared());\n\toctree_compression.compress(cloud);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 output;\n\tpcl::toROSMsg(cloud, output);\n\n\treturn output;\n}", "CodeBleu_score": 24.039061363811577}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor(auto it = multi_uav_state_.begin(); it != multi_uav_state_.end(); ++it) {\n\t\tif(it->uav_id == uav_state.uav_id) {\n\t\t\t*it = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.06526591386332}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (auto& uav_state_ : multi_uav_state_) {\n\t\tif (uav_state_.id == uav_state.id) {\n\t\t\tuav_state_ = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 28.974220656714227}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor(int i = 0; i < multi_uav_state_.uav_states.size(); i++) {\n\t\tif(multi_uav_state_.uav_states[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_.uav_states[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 51.859865177994195}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_count = m_multi_ugv_state.ugv_count;\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tUGVState ugv_state;\n\t\tugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\t\tmulti_ugv_state.ugv_state[i] = ugv_state;\n\t}\n\tthis->ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 43.6710305667783}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState m_multi_ugv_state_msg;\n\tUGVState m_ugv_state_msg;\n\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tm_ugv_state_msg.ugv_id = m_multi_ugv_state.ugv_states[i].ugv_id;\n\t\tm_ugv_state_msg.battery = m_multi_ugv_state.ugv_states[i].battery;\n\t\tm_ugv_state_msg.position.x = m_multi_ugv_state.ugv_states[i].position.x;\n\t\tm_ugv_state_msg.position.y = m_multi_ugv_state.ugv_states[i].position.y;\n\t\tm_ugv_state_msg.position.z = m_multi_ugv_state.ugv_states[i].position.z;\n\t\tm_ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n\t\tm_ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n\t\tm_ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n\t\tm_ugv_state_msg.attitude.roll = m_multi_ugv_state.ugv_states[i].attitude.roll;\n\t\tm_ugv_state_msg.attitude.pitch = m_multi_ugv_state.ugv_states[i].attitude.pitch;\n\t\tm_ugv_state_msg.attitude.yaw = m_multi_ugv_state.ugv_states[i].attitude.yaw;\n\n\t\tm_multi_ugv_state_msg.ugv_states.push_back(m_ugv_state_msg);\n\t}\n\n\tm_multi_ugv_state_msg.ugv_count = m_multi_ugv_state.ugv_", "CodeBleu_score": 41.31131722866088}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState m_multi_ugv_state_msg;\n\tUGVState m_ugv_state_msg;\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tm_ugv_state_msg.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n\t\tm_ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tm_ugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tm_ugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tm_ugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tm_ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tm_ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tm_ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tm_ugv_state_msg.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tm_ugv_state_msg.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tm_ugv_state_msg.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\t\tm_multi_ugv_state_msg.ugv_state.push_back(m_ugv_state_msg);\n\t}\n\tm_multi_ugv_state_msg.ugv_count = m_multi_ugv_state.ugv_", "CodeBleu_score": 41.50198407675321}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize the cost and gradient to zero.\n\tcost = 0.0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through the control points of the B-spline.\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Compute the predicted position of the moving object.\n\t\tEigen::VectorXd q_pred = calcMovingObjPos(q.row(i));\n\n\t\t// Evaluate the distance between the control point and the predicted position of the moving object.\n\t\tdouble dist = (q.row(i) - q_pred).norm();\n\n\t\t// If the distance is less than the clearance, update the cost and gradient.\n\t\tif (dist < clearance) {\n\t\t\t// Update the cost.\n\t\t\tcost += dist;\n\n\t\t\t// Update the gradient.\n\t\t\tgradient.row(i) = (q.row(i) - q_pred).transpose();\n\t\t}\n\t}\n}", "CodeBleu_score": 23.650046672122546}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize the cost and gradient\n\tcost = 0.0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through the control points\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Calculate the predicted position of the moving object\n\t\tEigen::VectorXd q_pred = calcMovingObjPos(q.row(i));\n\n\t\t// Calculate the distance between the control point and the moving object\n\t\tdouble dist = (q.row(i) - q_pred).norm();\n\n\t\t// Update the cost and gradient based on the distance error\n\t\tif (dist > 0.0) {\n\t\t\tcost += dist * dist;\n\t\t\tgradient.row(i) += 2.0 * (q.row(i) - q_pred);\n\t\t}\n\t}\n}", "CodeBleu_score": 24.352154599952065}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize the cost and gradient\n\tcost = 0.0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through the control points\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Calculate the predicted position of the moving object\n\t\tEigen::VectorXd q_pred = calcMovingObjPos(q.row(i));\n\n\t\t// Calculate the distance between the control point and the moving object\n\t\tdouble dist = (q_pred - q.row(i)).norm();\n\n\t\t// If the distance is less than the clearance, update the cost and gradient\n\t\tif (dist < clearance) {\n\t\t\t// Calculate the cost\n\t\t\tcost += clearance - dist;\n\n\t\t\t// Calculate the gradient\n\t\t\tgradient.row(i) = (q_pred - q.row(i)) / clearance;\n\t\t}\n\t}\n}", "CodeBleu_score": 24.95635382372517}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize the cost and the gradient to zero\n\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through the control points of the trajectory\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Compute the position error\n\t\tEigen::VectorXd pos_error = q.row(i) - ref_points_.row(i);\n\n\t\t// Compute the velocity vector\n\t\tEigen::VectorXd vel_vector = (q.row(i) - q.row(i - 1)) / dt_;\n\n\t\t// Compute the cost function\n\t\tcost += a2_ * pos_error.transpose() * pos_error + b2_ * vel_vector.transpose() * vel_vector;\n\n\t\t// Compute the gradient\n\t\tgradient.row(i) = 2 * a2_ * pos_error + 2 * b2_ * vel_vector;\n\t}\n}", "CodeBleu_score": 24.64337125858554}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tint num_points = q.cols();\n\tint num_dims = q.rows();\n\n\tcost = 0;\n\tgradient.setZero();\n\n\t// Compute the cost and gradient for each point\n\tfor (int i = 0; i < num_points; i++) {\n\t\tEigen::VectorXd p = q.col(i);\n\t\tEigen::VectorXd v = (p - reference_points_.col(i)).transpose();\n\n\t\tcost += a2_ * v.dot(v) + b2_ * v.transpose() * v;\n\t\tgradient.col(i) = 2 * a2_ * v + 2 * b2_ * v;\n\t}\n}", "CodeBleu_score": 21.830081842585034}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize the cost and gradient to zero\n\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through the control points\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Compute the position error\n\t\tEigen::VectorXd p_err = q.row(i) - ref_points.row(i);\n\n\t\t// Compute the velocity vector\n\t\tEigen::VectorXd v = (q.row(i) - q.row(i - 1)) / dt;\n\n\t\t// Compute the cost\n\t\tcost += a2 * p_err.transpose() * p_err + b2 * v.transpose() * v;\n\n\t\t// Compute the gradient\n\t\tgradient.row(i) += 2 * a2 * p_err + 2 * b2 * v;\n\t}\n}", "CodeBleu_score": 23.73242184671186}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\t// Compute the third derivative of the spline\n\tdouble jerk = 0;\n\tfor (int i = 0; i < n_control_points - 2; i++) {\n\t\tjerk += pow(control_points[i + 2][0] - 2 * control_points[i + 1][0] + control_points[i][0], 3);\n\t\tjerk += pow(control_points[i + 2][1] - 2 * control_points[i + 1][1] + control_points[i][1], 3);\n\t\tjerk += pow(control_points[i + 2][2] - 2 * control_points[i + 1][2] + control_points[i][2], 3);\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 27.571223544273217}, {"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0;\n\tdouble jerk_sum = 0;\n\n\tfor(int i = 0; i < n_control_points_; i++) {\n\t\tfor(int j = 0; j < dim_; j++) {\n\t\t\tjerk_sum += pow(control_points_[i][j], 3) * (knot_times_[i + 1] - knot_times_[i]);\n\t\t}\n\t}\n\n\tjerk = jerk_sum / pow(knot_times_[n_control_points_], 3);\n\n\treturn jerk;\n}", "CodeBleu_score": 31.412130264337755}, {"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0.0;\n\tdouble delta_t;\n\tdouble delta_t_squared;\n\tdouble delta_t_cubed;\n\tdouble t;\n\tdouble t_squared;\n\tdouble t_cubed;\n\tdouble t_to_the_fourth;\n\tdouble t_to_the_sixth;\n\tdouble t_to_the_eight;\n\tdouble t_to_the_ten;\n\tdouble t_to_the_twelve;\n\tdouble t_to_the_fourteen;\n\tdouble t_to_the_sixteen;\n\tdouble t_to_the_eighteen;\n\tdouble t_to_the_twenty;\n\tdouble t_to_the_twentytwo;\n\tdouble t_to_the_twentyfour;\n\tdouble t_to_the_twentysix;\n\tdouble t_to_the_twentysix;\n\tdouble t_to_the_twentyeight;\n\tdouble t_to_the_thirty;\n\tdouble t_to_the_thirtytwo;\n\tdouble t_to_the_thirtyfour;\n\tdouble t_to_the_thirtysix;\n\tdouble t_to_the_thirtyeight;\n\tdouble t_to_the_forty;\n\tdouble t_to_the_fortytwo;\n\tdouble t_to_the_fortyfour;\n\tdouble t_to_the_fortysix;\n\tdouble t_to_the_fortyeight;\n\tdouble t_to_the_fifty;\n\tdouble t_to_the_fiftytwo;\n\tdouble t_to_the_fiftyfour;\n\tdouble t_to_the_fiftysix;\n\tdouble t_to_the_fiftyeight;\n\tdouble t_to_the_sixty;\n\tdouble t_to_the_sixtytwo;\n\tdouble t_to_the_sixtyfour;\n\tdouble t_to_the_sixtysix;\n\tdouble t_to_the_sixtyeight;\n\tdouble t_to_the_seventy;\n\tdouble t_to_the_seventytwo;", "CodeBleu_score": 7.218169925711115}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tfloat x = (u - cx_) * depth / fx_;\n\tfloat y = (v - cy_) * depth / fy_;\n\tfloat z = depth;\n\treturn Eigen::Vector4d(x, y, z, 1);\n}", "CodeBleu_score": 50.27364427922968}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\treturn Eigen::Vector4d((u-cx_)*depth/fx_, (v-cy_)*depth/fy_, depth, 1);\n}", "CodeBleu_score": 28.150823007803105}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\t// YOUR CODE HERE\n\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 61.97407747520547}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\t// Extract drone ID from child_frame_id field of odom message\n\t\tstd::string drone_id = odom.child_frame_id.substr(0, odom.child_frame_id.find('_'));\n\t\t// Call rcvDroneOdomCallbackBase with odom data and drone ID\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t}\n\tcatch (const std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback(): Exception caught: %s\", e.what());\n\t}\n}", "CodeBleu_score": 48.525439768113024}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstd::string drone_id = odom.child_frame_id;\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t}\n\tcatch (std::exception& e) {\n\t\tROS_ERROR(\"Exception caught in rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 47.85038724138968}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstd::string drone_id = odom.child_frame_id.substr(0, odom.child_frame_id.find(\"_\"));\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t}\n\tcatch (std::exception &e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 48.179629445934644}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the drone's current pose in the world frame.\n\tgeometry_msgs::PoseStamped world_pose = getWorldPose(drone_id);\n\tif (world_pose.pose.position.x == 0 && world_pose.pose.position.y == 0 && world_pose.pose.position.z == 0) {\n\t\tROS_WARN(\"DroneDetector::detect: Could not get the world pose of drone %d.\", drone_id);\n\t\treturn;\n\t}\n\n\t// Get the drone's current pose in the camera frame.\n\tgeometry_msgs::PoseStamped camera_pose = getCameraPose(drone_id);\n\tif (camera_pose.pose.position.x == 0 && camera_pose.pose.position.y == 0 && camera_pose.pose.position.z == 0) {\n\t\tROS_WARN(\"DroneDetector::detect: Could not get the camera pose of drone %d.\", drone_id);\n\t\treturn;\n\t}\n\n\t// Get the drone's current pixel position in the camera frame.\n\tEigen::Vector2i camera_pixel = getCameraPixel(drone_id);\n\tif (camera_pixel.x() == -1 && camera_pixel.y() == -1) {\n\t\tROS_WARN(\"DroneDetector::detect: Could not get the camera pixel of drone %d.\", drone_id);\n\t\treturn;\n\t}\n\n\t// Get the drone's current true pixel position in the camera frame.\n\ttrue_pixel = getTruePixel(drone_id);\n\tif (true_pixel.x() == -1 && true_pixel.y() == -1) {\n\t\tROS_WARN(\"DroneDetector::detect: Could not get the true pixel of drone %d.\", drone_id);\n\t\treturn;\n\t}\n\n\t// Check if the drone is visible in the camera frame.\n\tif (isDroneVisible(drone_id)) {\n\t\t// Compute the pose error between the camera and world coordinates.\n\t\tEigen::Vector3d world_position(world_pose.pose.position.x, world_pose.pose.position.y, world_pose.pose.position.z);\n\t\tEigen::Vector3d camera_", "CodeBleu_score": 32.63822533145645}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Check if the drone is in the list\n\tif (drone_id < 0 || drone_id >= _num_drones) {\n\t\tROS_WARN_STREAM(\"DroneDetector::detect: Invalid drone ID: \" << drone_id);\n\t\treturn;\n\t}\n\n\t// Check if the true pixel is valid\n\tif (true_pixel[0] < 0 || true_pixel[0] >= _image_width || true_pixel[1] < 0 || true_pixel[1] >= _image_height) {\n\t\tROS_WARN_STREAM(\"DroneDetector::detect: Invalid true pixel: \" << true_pixel[0] << \", \" << true_pixel[1]);\n\t\treturn;\n\t}\n\n\t// Check if the drone is already in the list\n\tif (_drones[drone_id].detected) {\n\t\tROS_WARN_STREAM(\"DroneDetector::detect: Drone already detected: \" << drone_id);\n\t\treturn;\n\t}\n\n\t// Check if the drone is in the image\n\tif (_image_mask[true_pixel[1], true_pixel[0]] == 0) {\n\t\tROS_WARN_STREAM(\"DroneDetector::detect: Drone not in image: \" << drone_id);\n\t\treturn;\n\t}\n\n\t// Check if the drone is in the mask\n\tif (_mask_mask[true_pixel[1], true_pixel[0]] == 0) {\n\t\tROS_WARN_STREAM(\"DroneDetector::detect: Drone not in mask: \" << drone_id);\n\t\treturn;\n\t}\n\n\t// Check if the drone is in the background\n\tif (_background_mask[true_pixel[1], true_pixel[0]] == 0) {\n\t\tROS_WARN_STREAM(\"DroneDetector::detect: Drone not in background: \" << drone_id);\n\t\treturn;\n\t}\n\n\t// Check if the drone is in the foreground\n\tif (_foreground_mask[true_pixel[1], true_pixel[0]] == 0) {\n\t\tROS_WARN_STREAM(\"DroneDetector::detect: Drone not in foreground: \" << drone_id);\n\t\treturn;", "CodeBleu_score": 21.445969506313272}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// TODO: detect the drone with ID drone_id and true_pixel\n\t// 1. Convert the true pixel position into a true pose in the camera frame\n\t// 2. Check for the drone's presence\n\t// 3. If the drone is present, compute the pose error between the camera and world coordinates, update the debug result, and publish the pose error\n\t// 4. If the drone is not present, update the debug result to indicate failure\n\t// 5. (Optional) If the drone is present, use the drone's true position to update the drone's estimated position\n}", "CodeBleu_score": 3.1919984578694347}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->getParent() != nullptr) {\n\t\tcurrent = current->getParent();\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.23334368688437}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current != start_) {\n\t\tcurrent = cameFrom_[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 70.27926815403814}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\twhile (current != start) {\n\t\tpath.push_back(current);\n\t\tcurrent = cameFrom[current];\n\t}\n\tpath.push_back(start);\n\treturn path;\n}", "CodeBleu_score": 56.91311835956975}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tVector3d start_pt_temp = start_pt;\n\tVector3d end_pt_temp = end_pt;\n\tVector3i start_idx_temp;\n\tVector3i end_idx_temp;\n\tbool start_success = ConvertToGridIndex(start_pt_temp, start_idx_temp);\n\tbool end_success = ConvertToGridIndex(end_pt_temp, end_idx_temp);\n\tif (start_success && end_success) {\n\t\treturn true;\n\t}\n\telse {\n\t\tif (start_success) {\n\t\t\twhile (true) {\n\t\t\t\tstart_pt_temp += Vector3d(0.0, 0.0, 0.1);\n\t\t\t\tstart_success = ConvertToGridIndex(start_pt_temp, start_idx_temp);\n\t\t\t\tif (start_success) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (end_success) {\n\t\t\twhile (true) {\n\t\t\t\tend_pt_temp += Vector3d(0.0, 0.0, 0.1);\n\t\t\t\tend_success = ConvertToGridIndex(end_pt_temp, end_idx_temp);\n\t\t\t\tif (end_success) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 32.526074937445244}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start point to grid indices\n\tstart_idx = Vector3i(start_pt.x / resolution_, start_pt.y / resolution_, start_pt.z / resolution_);\n\n\t// Convert end point to grid indices\n\tend_idx = Vector3i(end_pt.x / resolution_, end_pt.y / resolution_, end_pt.z / resolution_);\n\n\t// Check if the start point is inside an obstacle\n\tif (obstacle_map_.isObstacle(start_idx)) {\n\t\t// Iterate until the start point is not inside an obstacle\n\t\twhile (obstacle_map_.isObstacle(start_idx)) {\n\t\t\t// Check if the start point is on the x-axis\n\t\t\tif (start_pt.x == start_idx.x * resolution_) {\n\t\t\t\t// Check if the start point is to the left of the obstacle\n\t\t\t\tif (start_pt.y < start_idx.y * resolution_) {\n\t\t\t\t\t// Move the start point to the right\n\t\t\t\t\tstart_idx.y++;\n\t\t\t\t} else {\n\t\t\t\t\t// Move the start point to the left\n\t\t\t\t\tstart_idx.y--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if the start point is on the y-axis\n\t\t\telse if (start_pt.y == start_idx.y * resolution_) {\n\t\t\t\t// Check if the start point is above the obstacle\n\t\t\t\tif (start_pt.z < start_idx.z * resolution_) {\n\t\t\t\t\t// Move the start point down\n\t\t\t\t\tstart_idx.z++;\n\t\t\t\t} else {\n\t\t\t\t\t// Move the start point up\n\t\t\t\t\tstart_idx.z--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if the start point is on the z-axis\n\t\t\telse if (start_pt.z == start_idx.z * resolution_) {\n\t\t\t\t// Check if the start point is to the left of the obstacle\n\t\t\t\tif (start_pt.x < start_idx.x * resolution_) {\n\t\t\t\t\t// Move the start point to the right\n\t\t\t\t\tstart_idx.x++;\n\t\t\t\t} else {\n\t\t\t\t\t// Move the start point to the left\n\t\t\t\t\tstart_idx.x--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if the end point is inside an obstacle\n\tif (obstacle_map_.isOb", "CodeBleu_score": 28.231277733165005}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start point to grid indices\n\tif (!grid_map_.WorldToGridIndex(start_pt, start_idx)) {\n\t\tROS_ERROR_STREAM(\"Start point is outside the grid map\");\n\t\treturn false;\n\t}\n\n\t// Convert end point to grid indices\n\tif (!grid_map_.WorldToGridIndex(end_pt, end_idx)) {\n\t\tROS_ERROR_STREAM(\"End point is outside the grid map\");\n\t\treturn false;\n\t}\n\n\t// Check if start and end points are in obstacles\n\tif (grid_map_.GetGridValue(start_idx) == 1 || grid_map_.GetGridValue(end_idx) == 1) {\n\t\t// If start or end point is inside an obstacle, try to adjust the point until it is no longer in an obstacle\n\t\twhile (grid_map_.GetGridValue(start_idx) == 1 || grid_map_.GetGridValue(end_idx) == 1) {\n\t\t\tif (grid_map_.GetGridValue(start_idx) == 1) {\n\t\t\t\t// Move start point away from the end point\n\t\t\t\tstart_pt.x += 0.01;\n\t\t\t\tgrid_map_.WorldToGridIndex(start_pt, start_idx);\n\t\t\t}\n\n\t\t\tif (grid_map_.GetGridValue(end_idx) == 1) {\n\t\t\t\t// Move end point away from the start point\n\t\t\t\tend_pt.x -= 0.01;\n\t\t\t\tgrid_map_.WorldToGridIndex(end_pt, end_idx);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 33.85940536519196}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = getGridCoordinates(min_pos);\n\tEigen::Vector3i max_id = getGridCoordinates(max_pos);\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t\tdistance_buffer_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.091170084271916}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\tgrid_map_index_(min_pos, min_id);\n\tgrid_map_index_(max_pos, max_id);\n\tfor (int i = min_id[0]; i <= max_id[0]; i++) {\n\t\tfor (int j = min_id[1]; j <= max_id[1]; j++) {\n\t\t\tfor (int k = min_id[2]; k <= max_id[2]; k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0.0;\n\t\t\t\tdistance_buffer_inflate_(i, j, k) = 0.0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.16669142200659}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = GridMap::gridPosToIndex(min_pos);\n\tEigen::Vector3i max_id = GridMap::gridPosToIndex(max_pos);\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t\tdistance_buffer_inflate_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.57255232343562}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_scale = 1.0;\n\tdouble y_scale = 1.0;\n\tdouble z_scale = 1.0;\n\tif (diff[0] < 0.0) {\n\t\tx_scale = -1.0;\n\t}\n\tif (diff[1] < 0.0) {\n\t\ty_scale = -1.0;\n\t}\n\tif (diff[2] < 0.0) {\n\t\tz_scale = -1.0;\n\t}\n\tdouble max_x = (double)grid_map_.info.width * grid_map_.info.resolution;\n\tdouble max_y = (double)grid_map_.info.height * grid_map_.info.resolution;\n\tdouble max_z = (double)grid_map_.info.height * grid_map_.info.resolution;\n\tdouble min_x = 0.0;\n\tdouble min_y = 0.0;\n\tdouble min_z = 0.0;\n\tif (diff[0] > max_x) {\n\t\tmin_x = diff[0] - max_x;\n\t}\n\tif (diff[1] > max_y) {\n\t\tmin_y = diff[1] - max_y;\n\t}\n\tif (diff[2] > max_z) {\n\t\tmin_z = diff[2] - max_z;\n\t}\n\tif (min_x > 0.0) {\n\t\tx_scale = 1.0 - min_x / diff[0];\n\t}\n\tif (min_y > 0.0) {\n\t\ty_scale = 1.0 - min_y / diff[1];\n\t}\n\tif (min_z > 0.0) {\n\t\tz_scale = 1.0 - min_z / diff[2];\n\t}\n\tEigen::Vector3d new_pt;\n\tnew_pt[0] = camera_pt[0] + x_scale * diff[0];\n\tnew_pt[1] = camera_pt[1] + y_scale * diff[", "CodeBleu_score": 38.44469178852624}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_t = std::max(std::abs(diff[0]), std::max(std::abs(diff[1]), std::abs(diff[2])));\n\tdouble min_t = std::min(std::abs(diff[0]), std::min(std::abs(diff[1]), std::abs(diff[2])));\n\tEigen::Vector3d t = Eigen::Vector3d::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff[i] > 0) {\n\t\t\tt[i] = max_t;\n\t\t} else {\n\t\t\tt[i] = min_t;\n\t\t}\n\t}\n\treturn pt - t;\n}", "CodeBleu_score": 44.37009520072927}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_x = std::max(std::abs(diff(0)), std::abs(diff(0) - m_width));\n\tdouble max_y = std::max(std::abs(diff(1)), std::abs(diff(1) - m_height));\n\tdouble max_z = std::max(std::abs(diff(2)), std::abs(diff(2) - m_depth));\n\tdouble x_scale = m_width / max_x;\n\tdouble y_scale = m_height / max_y;\n\tdouble z_scale = m_depth / max_z;\n\tdouble scale = std::min(std::min(x_scale, y_scale), z_scale);\n\tEigen::Vector3d pt_scaled = scale * diff + camera_pt;\n\treturn pt_scaled;\n}", "CodeBleu_score": 32.109653003634385}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tros::Time time_now = ros::Time::now();\n\tif (time_now.toSec() - last_occupancy_update_time_.toSec() < occupancy_update_timeout_) {\n\t\treturn;\n\t}\n\tlast_occupancy_update_time_ = time_now;\n\tif (depth_image_.width == 0) {\n\t\tROS_WARN(\"Depth image is not available. Cannot update occupancy grid.\");\n\t\treturn;\n\t}\n\tif (odom_.header.stamp.toSec() - last_odom_update_time_.toSec() > occupancy_update_timeout_) {\n\t\tROS_WARN(\"Odometry data is not available. Cannot update occupancy grid.\");\n\t\treturn;\n\t}\n\tif (last_depth_update_time_.toSec() > occupancy_update_timeout_) {\n\t\tROS_WARN(\"Depth data is not available. Cannot update occupancy grid.\");\n\t\treturn;\n\t}\n\n\t// Update the local map if needed\n\tif (update_local_map_) {\n\t\tupdateLocalMap();\n\t}\n\n\t// Clear the occupancy grid\n\tclearOccupancyGrid();\n\n\t// Project the depth image into points\n\tint num_points = 0;\n\tfloat* points = new float[depth_image_.width * depth_image_.height * 3];\n\tfor (int i = 0; i < depth_image_.width; i++) {\n\t\tfor (int j = 0; j < depth_image_.height; j++) {\n\t\t\tfloat depth = depth_image_.data[j * depth_image_.width + i];\n\t\t\tif (depth == 0.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpoints[num_points * 3 + 0] = i;\n\t\t\tpoints[num_points * 3 + 1] = j;\n\t\t\tpoints[num_points * 3 + 2] = depth;\n\t\t\tnum_points++;\n\t\t}\n\t}\n\n\t// Process the points with raycasting\n\tprocessPoints(points, num_points);\n\n\t// Update the local map\n\tupdateLocalMap();\n\n\t// Update the global map\n\tupdateGlobalMap();\n\n\t// Update the occupancy grid\n\tupdateOccupancy", "CodeBleu_score": 33.82046495053186}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tif (this->last_occupancy_update_time.isZero()) {\n\t\tthis->last_occupancy_update_time = ros::Time::now();\n\t}\n\n\tif (this->last_occupancy_update_time.toSec() + this->occupancy_update_timeout < ros::Time::now().toSec()) {\n\t\tROS_WARN(\"No occupancy update for %f seconds\", ros::Time::now().toSec() - this->last_occupancy_update_time.toSec());\n\t\tthis->occupancy_update_timeout_error = true;\n\t\treturn;\n\t}\n\n\tif (this->last_occupancy_update_time.toSec() + this->occupancy_update_timeout < ros::Time::now().toSec()) {\n\t\tROS_WARN(\"No occupancy update for %f seconds\", ros::Time::now().toSec() - this->last_occupancy_update_time.toSec());\n\t\tthis->occupancy_update_timeout_error = true;\n\t\treturn;\n\t}\n\n\tif (this->occupancy_update_needed) {\n\t\tthis->occupancy_update_needed = false;\n\n\t\tthis->last_occupancy_update_time = ros::Time::now();\n\n\t\tif (this->local_map_update_needed) {\n\t\t\tthis->local_map_update_needed = false;\n\t\t\tthis->clearLocalMap();\n\t\t\tthis->inflateLocalMap();\n\t\t}\n\n\t\tthis->projectDepthImage();\n\t\tthis->processDepthImage();\n\n\t\tthis->occupancy_update_timeout_error = false;\n\t}\n}", "CodeBleu_score": 33.070356392637954}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the time of the last occupancy update\n\tlastOccupancyUpdateTime = ros::Time::now();\n\n\t// If the occupancy grid has been updated recently, return\n\tif (ros::Time::now() - lastOccupancyUpdateTime < occupancyUpdateInterval) {\n\t\treturn;\n\t}\n\n\t// Update the occupancy grid\n\tupdateOccupancyGrid();\n}", "CodeBleu_score": 18.10963672881227}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tint num_images = image_fns.size();\n\tfloat f_measure_sum = 0;\n\tfor (int i = 0; i < num_images; i++) {\n\t\tcv::Mat img = cv::imread(image_fns[i], cv::IMREAD_GRAYSCALE);\n\t\tcv::Mat gt = cv::imread(gt_fns[i], cv::IMREAD_GRAYSCALE);\n\t\tcv::Mat dt = cv::imread(dt_fns[i], cv::IMREAD_GRAYSCALE);\n\t\tvector<ellipse_t> ellipses;\n\t\tellipse_detector_t ellipse_detector;\n\t\tellipse_detector.detect(dt, ellipses);\n\t\tfloat f_measure = ellipse_detector.evaluate(gt, ellipses, gt_angle_radians);\n\t\tf_measure_sum += f_measure;\n\t}\n\treturn f_measure_sum / num_images;\n}", "CodeBleu_score": 50.702208230082114}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat f_measure = 0;\n\tint num_images = image_fns.size();\n\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load image and ground truth ellipses\n\t\tMat img = imread(image_fns[i], 1);\n\t\tvector<Ellipse> gt_ellipses = _load_ellipses(gt_fns[i]);\n\n\t\t// Load detected ellipses\n\t\tvector<Ellipse> dt_ellipses = _load_ellipses(dt_fns[i]);\n\n\t\t// Evaluate detection performance\n\t\tf_measure += _ellipse_f_measure(img, gt_ellipses, dt_ellipses, gt_angle_radians);\n\t}\n\n\treturn f_measure / num_images;\n}", "CodeBleu_score": 52.824156595751084}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat f_measure = 0.0;\n\tint num_images = image_fns.size();\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load the image and ground truth ellipses\n\t\tMat img = imread(image_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n\t\tvector<ellipse_t> gt_ellipses = load_ellipse_data(gt_fns[i], gt_angle_radians);\n\t\tvector<ellipse_t> dt_ellipses = load_ellipse_data(dt_fns[i], gt_angle_radians);\n\t\t// Calculate the F-measure for the current image\n\t\tf_measure += _ellipse_f_measure(img, gt_ellipses, dt_ellipses);\n\t}\n\treturn f_measure / num_images;\n}", "CodeBleu_score": 53.92603195425332}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tif (foci == NULL) {\n\t\treturn 0.0f;\n\t}\n\n\tfloat angle1 = atan2f(foci[1] - y, foci[0] - x);\n\tfloat angle2 = atan2f(foci[3] - y, foci[2] - x);\n\tfloat angle = angle1 - angle2;\n\n\tif (angle > M_PI) {\n\t\tangle -= 2.0f * M_PI;\n\t}\n\telse if (angle < -M_PI) {\n\t\tangle += 2.0f * M_PI;\n\t}\n\n\treturn angle;\n}", "CodeBleu_score": 38.0192482874023}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle = 0.0f;\n\tif (foci != NULL) {\n\t\tfloat foci_angle = atan2(foci[1] - y, foci[0] - x);\n\t\tfloat ellipse_angle = atan2(y, x);\n\t\tangle = foci_angle - ellipse_angle;\n\t\tif (angle > M_PI) {\n\t\t\tangle -= 2 * M_PI;\n\t\t}\n\t\telse if (angle < -M_PI) {\n\t\t\tangle += 2 * M_PI;\n\t\t}\n\t}\n\treturn angle;\n}", "CodeBleu_score": 34.526763739710944}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat normal_angle = 0;\n\tif (foci != NULL) {\n\t\tfloat angle1 = atan2(foci[1] - y, foci[0] - x);\n\t\tfloat angle2 = atan2(y - foci[1], x - foci[0]);\n\t\tnormal_angle = angle1 - angle2;\n\t}\n\tnormal_angle = fmodf(normal_angle, 2 * M_PI);\n\tif (normal_angle < 0) {\n\t\tnormal_angle += 2 * M_PI;\n\t}\n\treturn normal_angle;\n}", "CodeBleu_score": 40.890516216136795}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = std::numeric_limits<double>::max();\n\tdouble max_x = std::numeric_limits<double>::min();\n\tdouble min_y = std::numeric_limits<double>::max();\n\tdouble max_y = std::numeric_limits<double>::min();\n\n\tfor (int i = start; i < end; i++) {\n\t\tmin_x = std::min(min_x, vp1[i].x);\n\t\tmax_x = std::max(max_x, vp1[i].x);\n\t\tmin_y = std::min(min_y, vp1[i].y);\n\t\tmax_y = std::max(max_y, vp1[i].y);\n\t}\n\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\n\tfor (int i = start; i < end; i++) {\n\t\tdouble x_diff = vp1[i].x - min_x;\n\t\tdouble y_diff = vp1[i].y - min_y;\n\n\t\tintegral_above += (vp1[i].x + vp1[i].y) * x_diff;\n\t\tintegral_below += (vp1[i].x + vp1[i].y) * y_diff;\n\t}\n\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 41.18611418577116}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\n\tdouble integral_above = 0.0;\n\tdouble integral_below = 0.0;\n\tfor (int i = start; i < end; i++) {\n\t\tdouble x = vp1[i].x;\n\t\tdouble y = vp1[i].y;\n\t\tintegral_above += (y + x * x);\n\t\tintegral_below += (y - x * x);\n\t}\n\n\tif (integral_above < integral_below) return false;\n\telse return true;\n}", "CodeBleu_score": 43.31913128775343}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble minx = vp1[start].x;\n\tdouble maxx = vp1[start].x;\n\tdouble miny = vp1[start].y;\n\tdouble maxy = vp1[start].y;\n\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < minx) minx = vp1[i].x;\n\t\tif (vp1[i].x > maxx) maxx = vp1[i].x;\n\t\tif (vp1[i].y < miny) miny = vp1[i].y;\n\t\tif (vp1[i].y > maxy) maxy = vp1[i].y;\n\t}\n\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tintegral_above += (vp1[i].x + vp1[i].y) * (vp1[i].x - vp1[i - 1].x);\n\t\tintegral_below += (vp1[i].x + vp1[i].y) * (vp1[i - 1].x - vp1[i].x);\n\t}\n\n\tif (integral_above < integral_below) return false;\n\telse return true;\n}", "CodeBleu_score": 37.74830634926424}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t\tis_detected = true;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tsight_angle = msg->detection_info[i].angle;\n\t\t} else {\n\t\t\tsight_angle = -msg->detection_info[i].angle;\n\t\t}\n\t}\n}", "CodeBleu_score": 55.58496744333292}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor(int i = 0; i < msg->detection_info_length; i++) {\n\t\tif(msg->detection_info[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t\tis_detected = true;\n\t\t\tsight_angle = msg->detection_info[i].angle;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(num_lost > VISION_THRES) {\n\t\tis_detected = false;\n\t}\n\tif(num_regain > VISION_THRES) {\n\t\tis_detected = true;\n\t}\n\tdouble temp_sight_angle = sight_angle;\n\tsight_angle = -temp_sight_angle;\n}", "CodeBleu_score": 53.06879154191382}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t}\n\t\telse {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\tellipse_det.sight_angle = msg->detection_infos[i].sight_angle;\n\t\t}\n\t\telse {\n\t\t\tellipse_det.sight_angle = msg->detection_infos[i].sight_angle + M_PI;\n\t\t}\n\t}\n}", "CodeBleu_score": 56.40529024140165}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tdouble x_pos = cur_pos(0);\n\tdouble y_pos = cur_pos(1);\n\tdouble z_pos = cur_pos(2);\n\n\t// Check if the position is within the bounds of the Occupy_map_ptr\n\tif (x_pos < 0 || x_pos > Occupy_map_ptr->get_map_width() || y_pos < 0 || y_pos > Occupy_map_ptr->get_map_height() || z_pos < 0 || z_pos > Occupy_map_ptr->get_map_length()) {\n\t\treturn false;\n\t}\n\n\t// Check if the position is within the safety distance of the Occupy_map_ptr\n\tif (Occupy_map_ptr->get_occupancy(x_pos, y_pos, z_pos) < 0.5) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 40.42691545755191}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// TODO: Fill in this function\n\treturn false;\n}", "CodeBleu_score": 11.106345344215281}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// Check if the position is within the map boundaries\n\tif (cur_pos(0) < 0 || cur_pos(0) > map_width || cur_pos(1) < 0 || cur_pos(1) > map_height) {\n\t\treturn false;\n\t}\n\t// Check if the position is within the safety distance of the robot\n\tif (Occupy_map_ptr->is_occupied(cur_pos, safe_distance)) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 33.17323449252065}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr node = end_node;\n\twhile (node->parent_node) {\n\t\tpath_nodes_.push_front(node);\n\t\tnode = node->parent_node;\n\t}\n\tpath_nodes_.push_front(node);\n}", "CodeBleu_score": 45.54160475802432}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// TODO: Fill in this function to construct the path from the end node to the start node.\n\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node->parent_node) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent_node;\n\t}\n\tpath_nodes_.push_back(current_node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 57.31324638190943}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr curr_node = end_node;\n\twhile (curr_node->parent) {\n\t\tpath_nodes_.push_back(curr_node);\n\t\tcurr_node = curr_node->parent;\n\t}\n\tpath_nodes_.push_back(curr_node);\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.875821306256576}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t// ROS_INFO(\"nei_odom_cb: id = %d\", id);\n\t// ROS_INFO(\"nei_odom_cb: odom.pose.pose.position.x = %f\", odom->pose.pose.position.x);\n\t// ROS_INFO(\"nei_odom_cb: odom.pose.pose.position.y = %f\", odom->pose.pose.position.y);\n\t// ROS_INFO(\"nei_odom_cb: odom.pose.pose.position.z = %f\", odom->pose.pose.position.z);\n\t// ROS_INFO(\"nei_odom_cb: odom.pose.pose.orientation.x = %f\", odom->pose.pose.orientation.x);\n\t// ROS_INFO(\"nei_odom_cb: odom.pose.pose.orientation.y = %f\", odom->pose.pose.orientation.y);\n\t// ROS_INFO(\"nei_odom_cb: odom.pose.pose.orientation.z = %f\", odom->pose.pose.orientation.z);\n\t// ROS_INFO(\"nei_odom_cb: odom.pose.pose.orientation.w = %f\", odom->pose.pose.orientation.w);\n\t// ROS_INFO(\"nei_odom_cb: odom.twist.twist.linear.x = %f\", odom->twist.twist.linear.x);\n\t// ROS_INFO(\"nei_odom_cb: odom.twist.twist.linear.y = %f\", odom->twist.twist.linear.y);\n\t// ROS_INFO(\"nei_odom_cb: odom.twist.twist.linear.z = %f\", odom->twist.twist.linear.z);\n\t// ROS_INFO(\"nei_odom_cb: odom.twist.twist.angular.x = %f\", odom->twist.twist.angular.x);\n\t// ROS_INFO(\"nei_odom_cb: odom.twist.twist.angular.y = %f\", odom->tw", "CodeBleu_score": 3.243972840348349}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tstate_nei[id][0] = odom->pose.pose.position.x;\n\tstate_nei[id][1] = odom->pose.pose.position.y;\n\tstate_nei[id][2] = odom->pose.pose.position.z;\n\tif (sim_mode) {\n\t\tif (sqrt(pow(state_nei[id][0]-start_pos[0],2)+pow(state_nei[id][1]-start_pos[1],2)) > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 52.6375942894233}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tstate_nei[id][0] = odom->pose.pose.position.x;\n\tstate_nei[id][1] = odom->pose.pose.position.y;\n\tstate_nei[id][2] = odom->pose.pose.position.z;\n\tstate_nei[id][3] = odom->twist.twist.linear.x;\n\tstate_nei[id][4] = odom->twist.twist.linear.y;\n\tstate_nei[id][5] = odom->twist.twist.linear.z;\n\tstate_nei[id][6] = odom->twist.twist.angular.x;\n\tstate_nei[id][7] = odom->twist.twist.angular.y;\n\tstate_nei[id][8] = odom->twist.twist.angular.z;\n\tif(sim_mode == true)  {\n\t\tif(sqrt(pow(state_nei[id][0] - start_pos.x, 2) + pow(state_nei[id][1] - start_pos.y, 2)) > 5)  {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse  {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse  {\n\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 58.1859962629958}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    \n\n    if(!odometry_ready) {\n        return;\n    }\n\n    // update counter\n    update_counter++;\n\n    // if update counter is divisible by 5, update the map\n    if(update_counter % 5 == 0) {\n        // reset update counter\n        update_counter = 0;\n\n        // update map\n        updateMap(msg);\n\n        // reset sensor_ready flag\n        sensor_ready = false;\n    }\n\n    // set sensor_ready flag\n    sensor_ready = true;\n}", "CodeBleu_score": 50.760420604668646}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n\tif (odom_ready_ == false) {\n\t\treturn;\n\t}\n\tsensor_ready_ = true;\n\tupdate_counter_++;\n\tif (update_counter_ >= 5) {\n\t\tupdate_counter_ = 0;\n\t\tAstar_map_.update_map(msg);\n\t}\n}", "CodeBleu_score": 42.45209612067509}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    \n    \n    // if the odometry is not ready, return immediately\n    if (odom_ready_ == false) {\n        return;\n    }\n    \n    // if the sensor is not ready, set the flag and return immediately\n    if (sensor_ready_ == false) {\n        sensor_ready_ = true;\n        return;\n    }\n    \n    // if the sensor is ready, increment the update counter\n    update_counter_++;\n    \n    // if the update counter is not divisible by 5, return immediately\n    if (update_counter_ % 5 != 0) {\n        return;\n    }\n    \n    // reset the update counter\n    update_counter_ = 0;\n    \n    // set the sensor to not ready\n    sensor_ready_ = false;\n    \n    // process the point cloud data\n    processPointCloud(msg);\n}", "CodeBleu_score": 47.9448540573142}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl) {\n\t\treturn;\n\t}\n\tget_gpcl = true;\n\tpcl::fromROSMsg(*global_point, global_pc);\n\tglobal_pc.is_dense = false;\n\tglobal_pc.height = 1;\n\tglobal_pc.width = global_pc.points.size();\n\tglobal_pc.resize(global_pc.points.size());\n\tglobal_pc.header.frame_id = \"map\";\n\tglobal_pc.header.stamp = ros::Time::now();\n\tpcl::toROSMsg(global_pc, global_pc_msg);\n\tglobal_pc_pub.publish(global_pc_msg);\n\tglobal_pc_inflated.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\tglobal_pc_inflated->header = global_pc.header;\n\tglobal_pc_inflated->height = global_pc.height;\n\tglobal_pc_inflated->width = global_pc.width;\n\tglobal_pc_inflated->is_dense = global_pc.is_dense;\n\tglobal_pc_inflated->points.resize(global_pc.points.size());\n\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\tsor.setInputCloud(global_pc_inflated);\n\tsor.setLeafSize(0.05f, 0.05f, 0.05f);\n\tsor.filter(*global_pc_inflated);\n\tpcl::toROSMsg(*global_pc_inflated, global_pc_inflated_msg);\n\tglobal_pc_inflated_pub.publish(global_pc_inflated_msg);\n}", "CodeBleu_score": 52.72668657151121}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tpcl::fromROSMsg(*global_point, gpcl);\n\t\tpcl::toROSMsg(gpcl, gpcl_ros);\n\t\tget_gpcl = true;\n\t\tinflate_gpcl();\n\t}\n}", "CodeBleu_score": 46.57191073156969}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\t// Check if the global map has been updated already.\n\tif (get_gpcl) {\n\t\treturn;\n\t}\n\n\t// Convert the sensor message to a point cloud.\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr global_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*global_point, *global_cloud);\n\n\t// Store the point cloud.\n\tglobal_map = global_cloud;\n\n\t// Inflation of the point cloud.\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr inflated_global_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr temp_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);\n\ttree->setInputCloud(global_cloud);\n\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\tsor.setInputCloud(global_cloud);\n\tsor.setLeafSize(0.1, 0.1, 0.1);\n\tsor.filter(*temp_cloud);\n\tpcl::transformPointCloud(*temp_cloud, *inflated_global_cloud, trans_mat);\n\tglobal_map = inflated_global_cloud;\n\n\t// Set the get_gpcl flag to true.\n\tget_gpcl = true;\n}", "CodeBleu_score": 52.18765248436728}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t//convert the laser scan into a PointCloud2 format\n\tsensor_msgs::PointCloud2 laser_cloud;\n\tlaser_cloud = local_point;\n\n\t//convert the PointCloud2 format into a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(laser_cloud, *laser_cloud_pcl);\n\n\t//convert the odometry information into a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr odom_cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointXYZ point;\n\tpoint.x = odom.pose.pose.position.x;\n\tpoint.y = odom.pose.pose.position.y;\n\tpoint.z = odom.pose.pose.position.z;\n\todom_cloud_pcl->points.push_back(point);\n\n\t//merge the local map with the odometry data\n\tif(!simulation_mode) {\n\t\tmerge_map(odom_cloud_pcl, laser_cloud_pcl);\n\t}\n\n\t//update the occupancy map using the laser scan data\n\tupdate_map(laser_cloud_pcl);\n}", "CodeBleu_score": 45.726559762736464}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"local_point->header.frame_id: %s\", local_point->header.frame_id.c_str());\n\t//ROS_INFO(\"local_point->header.stamp: %d\", local_point->header.stamp.toSec());\n\t//ROS_INFO(\"local_point->angle_min: %f\", local_point->angle_min);\n\t//ROS_INFO(\"local_point->angle_max: %f\", local_point->angle_max);\n\t//ROS_INFO(\"local_point->angle_increment: %f\", local_point->angle_increment);\n\t//ROS_INFO(\"local_point->time_increment: %f\", local_point->time_increment);\n\t//ROS_INFO(\"local_point->scan_time: %f\", local_point->scan_time);\n\t//ROS_INFO(\"local_point->range_min: %f\", local_point->range_min);\n\t//ROS_INFO(\"local_point->range_max: %f\", local_point->range_max);\n\t//ROS_INFO(\"local_point->ranges.size(): %d\", local_point->ranges.size());\n\t//ROS_INFO(\"local_point->intensities.size(): %d\", local_point->intensities.size());\n\t//ROS_INFO(\"odom.header.frame_id: %s\", odom.header.frame_id.c_str());\n\t//ROS_INFO(\"odom.header.stamp: %d\", odom.header.stamp.toSec());\n\t//ROS_INFO(\"odom.pose.pose.position.x: %f\", odom.pose.pose.position.x);\n\t//ROS_INFO(\"odom.pose.pose.position.y: %f\", odom.pose.pose.position.y);\n\t//ROS_INFO(\"odom.pose.pose.position.z: %f\", odom.pose.pose.position.z);\n\t//ROS_INFO(\"odom.pose.pose.orientation.x: %f\", odom.pose.pose.orientation.x);\n\t//ROS_INFO(\"odom.pose", "CodeBleu_score": 9.548369361482886}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// std::cout << \"map_update_laser\" << std::endl;\n\t// std::cout << \"local_point->header.stamp = \" << local_point->header.stamp << std::endl;\n\t// std::cout << \"odom.header.stamp = \" << odom.header.stamp << std::endl;\n\t// std::cout << \"odom.header.frame_id = \" << odom.header.frame_id << std::endl;\n\t// std::cout << \"local_point->header.frame_id = \" << local_point->header.frame_id << std::endl;\n\n\tif (local_point->header.frame_id != odom.header.frame_id) {\n\t\tROS_ERROR(\"The odometry and laser scan data have different frames. The odometry frame is %s and the laser scan frame is %s.\", odom.header.frame_id.c_str(), local_point->header.frame_id.c_str());\n\t\treturn;\n\t}\n\n\tif (local_point->header.frame_id != \"base_link\") {\n\t\tROS_ERROR(\"The laser scan data is not in the base_link frame. The laser scan frame is %s.\", local_point->header.frame_id.c_str());\n\t\treturn;\n\t}\n\n\tif (local_point->header.frame_id != \"base_link\") {\n\t\tROS_ERROR(\"The laser scan data is not in the base_link frame. The laser scan frame is %s.\", local_point->header.frame_id.c_str());\n\t\treturn;\n\t}\n\n\t// std::cout << \"local_point->header.frame_id = \" << local_point->header.frame_id << std::endl;\n\t// std::cout << \"odom.header.frame_id = \" << odom.header.frame_id << std::endl;\n\n\t// std::cout << \"local_point->header.seq = \" << local_point->header.seq << std::endl;\n\t// std::cout << \"odom.header.seq = \" << odom.header.seq << std::endl;\n\n\t// std::cout << \"local_point->header.stamp = \" <<", "CodeBleu_score": 40.0619190955318}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t//ROS_INFO(\"pub_pcl_cb called\");\n\n\t// Convert the map to a point cloud\n\tpcl::toROSMsg(*map_ptr, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\n\t// Publish the point cloud\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// Convert the inflated map to a point cloud\n\tpcl::toROSMsg(*inflate_map_ptr, inflate_pcl_msg);\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\n\t// Publish the point cloud\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 48.804213657057275}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tros::Time t = ros::Time::now();\n\t// publish global map\n\tpcl::toROSMsg(*global_map, global_pcl);\n\tglobal_pcl.header.stamp = t;\n\tglobal_pcl.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(global_pcl);\n\t// publish inflated map\n\tpcl::toROSMsg(*inflate_map, inflate_pcl);\n\tinflate_pcl.header.stamp = t;\n\tinflate_pcl.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(inflate_pcl);\n}", "CodeBleu_score": 55.93280154705296}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n//  //  std::cout << \"pub_pcl_cb\" << std::endl;\n//  //  std::cout << \"global_pcl_pub.getNumSubscribers() = \" << global_pcl_pub.getNumSubscribers() << std::endl;\n//  //  std::cout << \"inflate_pcl_pub.getNumSubscribers() = \" << inflate_pcl_pub.getNumSubscribers() << std::endl;\n\n//  //  std::cout << \"global_pcl_pub.get_num_connections() = \" << global_pcl_pub.get_num_connections() << std::endl;\n//  //  std::cout << \"inflate_pcl_pub.get_num_connections() = \" << inflate_pcl_pub.get_num_connections() << std::endl;\n\n  if (global_pcl_pub.getNumSubscribers() > 0) {\n    pcl::toROSMsg(*global_pcl, global_pcl_msg);\n    global_pcl_msg.header.stamp = ros::Time::now();\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_msg);\n  }\n\n  if (inflate_pcl_pub.getNumSubscribers() > 0) {\n    pcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n    inflate_pcl_msg.header.stamp = ros::Time::now();\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n  }\n}", "CodeBleu_score": 56.46445674479488}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!sensor_ready) {\n\t\tsensor_ready = true;\n\t}\n\tpcl::fromROSMsg(*msg, map_cloud);\n\tmap_cloud.header.stamp = ros::Time::now();\n\tmap_cloud_pub.publish(map_cloud);\n\tstd::cout << \"Received new point cloud\" << std::endl;\n\tstd::cout << \"Number of points in map cloud: \" << map_cloud.width * map_cloud.height << std::endl;\n}", "CodeBleu_score": 47.05982338955209}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"point cloud received\");\n\t//ROS_INFO(\"", "CodeBleu_score": 8.100425375965159}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t// If the point cloud is empty, return\n\tif (msg->width == 0) {\n\t\treturn;\n\t}\n\n\t// If the sensor is not ready, return\n\tif (!sensor_ready) {\n\t\treturn;\n\t}\n\n\t// If the sensor is ready, set the sensor_ready flag to false\n\tsensor_ready = false;\n\n\t// Convert the point cloud message to a PCL point cloud\n\tpcl::PointCloud<pcl::PointXYZ> pointcloud;\n\tpcl::fromROSMsg(*msg, pointcloud);\n\n\t// Convert the point cloud to a vector of points\n\tstd::vector<Point> points;\n\tfor (pcl::PointCloud<pcl::PointXYZ>::const_iterator it = pointcloud.begin(); it != pointcloud.end(); it++) {\n\t\tPoint p;\n\t\tp.x = it->x;\n\t\tp.y = it->y;\n\t\tp.z = it->z;\n\t\tpoints.push_back(p);\n\t}\n\n\t// Update the A* algorithm's map\n\tupdate_map(points);\n\n\t// Set the sensor_ready flag to true\n\tsensor_ready = true;\n}", "CodeBleu_score": 56.76421126568234}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n// 1. Get current time\n  ros::Time current_time = event.current_real;\n", "CodeBleu_score": 13.135498562508541}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get the current time.\n\tros::Time time = event.current_real;\n\t// Get the current pose.\n\tgeometry_msgs::Pose current_pose = getCurrentPose();\n\t// Compute the desired pose.\n\tgeometry_msgs::Pose desired_pose = computeDesiredPose(current_pose, time);\n\t// Compute the desired leg foot positions.\n\tstd::vector<geometry_msgs::Point> desired_leg_foot_positions;\n\tcomputeDesiredLegFootPositions(desired_pose, desired_leg_foot_positions);\n\t// Compute the desired leg joint positions.\n\tstd::vector<std::vector<double>> desired_leg_joint_positions;\n\tcomputeDesiredLegJointPositions(desired_leg_foot_positions, desired_leg_joint_positions);\n\t// Compute the desired leg joint velocities.\n\tstd::vector<std::vector<double>> desired_leg_joint_velocities;\n\tcomputeDesiredLegJointVelocities(desired_leg_foot_positions, desired_leg_joint_velocities);\n\t// Compute the desired leg joint torques.\n\tstd::vector<std::vector<double>> desired_leg_joint_torques;\n\tcomputeDesiredLegJointTorques(desired_leg_joint_positions, desired_leg_joint_velocities, desired_leg_joint_torques);\n\t// Publish the leg joint torques.\n\tpublishLegJointTorques(desired_leg_joint_torques);\n\t// Publish the leg joint positions.\n\tpublishLegJointPositions(desired_leg_joint_positions);\n\t// Publish the leg joint velocities.\n\tpublishLegJointVelocities(desired_leg_joint_velocities);\n\t// Publish the leg joint efforts.\n\tpublishLegJointEfforts(desired_leg_joint_torques);\n\t// Publish the leg foot contact states.\n\tpublishLegFootContactStates();\n}", "CodeBleu_score": 35.08961356458266}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Update time.\n\tros::Time time = event.current_real;\n\n\t// Update desired state from ROS message.\n\tupdateDesiredStateFromROSMessage();\n\n\t// Update desired state from dynamic reconfigure.\n\tupdateDesiredStateFromDynamicReconfigure();\n\n\t// Update desired state from joystick.\n\tupdateDesiredStateFromJoystick();\n\n\t// Update desired state from trajectory generator.\n\tupdateDesiredStateFromTrajectoryGenerator(time);\n\n\t// Update desired state from vision.\n\tupdateDesiredStateFromVision(time);\n\n\t// Compute desired foot positions.\n\tcomputeDesiredFootPositions();\n\n\t// Compute desired joint positions.\n\tcomputeDesiredJointPositions();\n\n\t// Compute desired joint velocities.\n\tcomputeDesiredJointVelocities();\n\n\t// Compute desired joint torques.\n\tcomputeDesiredJointTorques();\n\n\t// Publish foot contact information.\n\tpublishFootContactStates();\n\n\t// Publish joint positions, velocities, and torques.\n\tpublishJointPositions();\n\tpublishJointVelocities();\n\tpublishJointTorques();\n\n\t// Publish desired joint positions, velocities, and torques.\n\tpublishDesiredJointPositions();\n\tpublishDesiredJointVelocities();\n\tpublishDesiredJointTorques();\n\n\t// Publish leg controller states.\n\tpublishLegControllerStates();\n\n\t// Publish body controller states.\n\tpublishBodyControllerStates();\n\n\t// Publish commanded leg controller states.\n\tpublishCommandedLegControllerStates();\n\n\t// Publish commanded body controller states.\n\tpublishCommandedBodyControllerStates();\n}", "CodeBleu_score": 31.219384117872167}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contact_publishing_enabled_ && !in_gazebo_) {\n\t\t// Create the message\n\t\tfoot_contacts_msg_.contacts.resize(4);\n\t\tfoot_contacts_msg_.header.stamp = ros::Time::now();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfoot_contacts_msg_.contacts[i].position.z = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].position.y = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].position.x = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].normal.z = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].normal.y = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].normal.x = 1.0;\n\t\t\tfoot_contacts_msg_.contacts[i].depth = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].force.z = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].force.y = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].force.x = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].header.stamp = ros::Time::now();\n\t\t\tfoot_contacts_msg_.contacts[i].header.frame_id = foot_frame_ids_[i];\n\t\t\tfoot_contacts_msg_.contacts[i].contact_positions.resize(1);\n\t\t\tfoot_contacts_msg_.contacts[i].contact_positions[0].z = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].contact_positions[0].y = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].contact_positions[0].x = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].contact_normals.resize(1);\n\t\t\tfoot_contacts_msg_.contacts[i].contact_normals[0].z = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].contact_normals[0].y = 0.0;\n\t\t\tfoot_contacts_msg_.contacts[i].contact_normals[", "CodeBleu_score": 47.53698300495594}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t#ifndef GAZEBO\n  if (foot_contacts_publisher_ != nullptr) {\n    ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    for (int leg_idx = 0; leg_idx < 4; leg_idx++) {\n      contacts_msg.contacts.push_back(ContactState());\n      contacts_msg.contacts[leg_idx].contact_positions.resize(1);\n      contacts_msg.contacts[leg_idx].contact_positions[0].x = 0.0;\n      contacts_msg.contacts[leg_idx].contact_positions[0].y = 0.0;\n      contacts_msg.contacts[leg_idx].contact_positions[0].z = 0.0;\n      contacts_msg.contacts[leg_idx].contact_normals.resize(1);\n      contacts_msg.contacts[leg_idx].contact_normals[0].x = 0.0;\n      contacts_msg.contacts[leg_idx].contact_normals[0].y = 0.0;\n      contacts_msg.contacts[leg_idx].contact_normals[0].z = 1.0;\n      contacts_msg.contacts[leg_idx].depths.resize(1);\n      contacts_msg.contacts[leg_idx].depths[0] = 0.0;\n      contacts_msg.contacts[leg_idx].states.resize(1);\n      contacts_msg.contacts[leg_idx].states[0] = foot_contacts[leg_idx] ? ContactState::CONTACT_STATE_IN_CONTACT : ContactState::CONTACT_STATE_NOT_IN_CONTACT;\n      contacts_msg.contacts[leg_idx].contact_names.resize(1);\n      contacts_msg.contacts[leg_idx].contact_names[0] = std::string(\"leg_\") + std::to_string(leg_idx);\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n#endif\n}", "CodeBleu_score": 36.572499635855195}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contact_state_publishing_enabled_ && !in_gazebo_) {\n\t\t// Create message\n\t\tfoot_contacts_msg_.header.stamp = ros::Time::now();\n\t\tfoot_contacts_msg_.left_front = foot_contacts[0];\n\t\tfoot_contacts_msg_.left_middle = foot_contacts[1];\n\t\tfoot_contacts_msg_.left_rear = foot_contacts[2];\n\t\tfoot_contacts_msg_.right_front = foot_contacts[3];\n\n\t\t// Publish message\n\t\tfoot_contacts_publisher_.publish(foot_contacts_msg_);\n\t}\n}", "CodeBleu_score": 51.78264104263711}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\tself.joints_msg.header.stamp = rospy.Time.now()\n\tself.joints_msg.position = joints.position[:12]\n\tself.joints_pub.publish(self.joints_msg)\n\tself.traj_msg.header.stamp = rospy.Time.now()\n\tself.traj_msg.joint_names = self.joints_msg.name\n\tself.traj_msg.points.append(JointTrajectoryPoint(positions=self.joints_msg.position, time_from_start=rospy.Duration(2.0)))\n\tself.traj_pub.publish(self.traj_msg)\n}", "CodeBleu_score": 27.675300212715342}, {"code": "def joints_cmd_callback(self, joints){\n\t\t# create a new message\n\tmsg = Joints()\n\t# fill in the message with the first 12 positions\n\tmsg.header.stamp = rospy.Time.now()\n\tmsg.position = joints.position[0:12]\n\t# publish the message\n\tself.pub_joints.publish(msg)\n\t# create a new joint trajectory message\n\ttraj_msg = JointTrajectory()\n\ttraj_msg.header.stamp = rospy.Time.now()\n\ttraj_msg.joint_names = self.joint_names\n\t# create a new trajectory point message\n\tpoint = JointTrajectoryPoint()\n\tpoint.positions = msg.position\n\tpoint.time_from_start = rospy.Duration(0.5)\n\t# fill in the trajectory message with the point\n\ttraj_msg.points.append(point)\n\t# publish the trajectory message\n\tself.pub_traj.publish(traj_msg)\n}", "CodeBleu_score": 46.4262298350871}, {"code": "def joints_cmd_callback(self, joints){\n\t\t# Create a message with the first 12 joint positions\n\tjoints_msg = Joints()\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tjoints_msg.header.frame_id = \"base_link\"\n\tjoints_msg.names = [\"hip_right_x\", \"hip_right_y\", \"hip_right_z\", \"knee_right\", \"ankle_right_x\", \"ankle_right_y\", \"ankle_right_z\", \"hip_left_x\", \"hip_left_y\", \"hip_left_z\", \"knee_left\", \"ankle_left_x\", \"ankle_left_y\", \"ankle_left_z\"]\n\tjoints_msg.position = joints.position[0:12]\n\n\t# Publish the joints message\n\tself.joints_pub.publish(joints_msg)\n\n\t# Construct a joint trajectory message\n\ttrajectory_msg = JointTrajectory()\n\ttrajectory_msg.header.stamp = rospy.Time.now()\n\ttrajectory_msg.joint_names = joints_msg.names\n\ttrajectory_msg.points.append(JointTrajectoryPoint())\n\ttrajectory_msg.points[0].positions = joints_msg.position\n\ttrajectory_msg.points[0].time_from_start = rospy.Duration(1.0)\n\n\t# Publish the joint trajectory message\n\tself.trajectory_pub.publish(trajectory_msg)\n}", "CodeBleu_score": 42.278070722315405}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tstd::map<std::string, bool> foot_contact_states;\n\n\tfoot_contact_states[\"FL_foot\"] = false;\n\tfoot_contact_states[\"FR_foot\"] = false;\n\tfoot_contact_states[\"BL_foot\"] = false;\n\tfoot_contact_states[\"BR_foot\"] = false;\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string link_name = _msg->contact(i).collision1().substr(0, _msg->contact(i).collision1().find_first_of(\"_\"));\n\t\tboost::to_upper(link_name);\n\t\tfoot_contact_states[link_name] = true;\n\t}\n\n\tfoot_contact_pub_.publish(foot_contact_states);\n}", "CodeBleu_score": 40.722895489132085}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize all foot contact states to false\n\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contact_states_[i] = false;\n\t}\n\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::vector<std::string> link_names;\n\t\tboost::split(link_names, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n\t\tstd::string link_name = link_names.back();\n\t\tboost::split(link_names, _msg->contact(i).collision2(), boost::is_any_of(\"::\"));\n\t\tstd::string link_name2 = link_names.back();\n\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tif (link_name == \"left_foot\" || link_name2 == \"left_foot\") {\n\t\t\tfoot_contact_states_[0] = true;\n\t\t}\n\t\tif (link_name == \"right_foot\" || link_name2 == \"right_foot\") {\n\t\t\tfoot_contact_states_[1] = true;\n\t\t}\n\t\tif (link_name == \"left_heel\" || link_name2 == \"left_heel\") {\n\t\t\tfoot_contact_states_[2] = true;\n\t\t}\n\t\tif (link_name == \"right_heel\" || link_name2 == \"right_heel\") {\n\t\t\tfoot_contact_states_[3] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 56.623738847347504}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string link = _msg->contact(i).collision1();\n\t\tboost::erase_all(link, \"::\");\n\t\tboost::erase_all(link, \"_foot_collision\");\n\t\tif (link == \"left_foot\") {\n\t\t\tleft_foot_contact = true;\n\t\t} else if (link == \"right_foot\") {\n\t\t\tright_foot_contact = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 35.25629028434842}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tif (!is_initialized_) {\n\t\tROS_ERROR(\"LeePositionController is not initialized!\");\n\t\treturn;\n\t}\n\tif (!is_active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\tif (desired_acceleration_.norm() > 0.0) {\n\t\t// Calculate the desired angular acceleration.\n\t\tEigen::Vector3d angular_acceleration;\n\t\tangular_acceleration.setZero();\n\t\tangular_acceleration.z() = -desired_acceleration_.norm() / vehicle_mass_;\n\n\t\t// Calculate the desired thrust acceleration.\n\t\tEigen::Vector3d thrust_acceleration;\n\t\tthrust_acceleration.setZero();\n\t\tthrust_acceleration.z() = -desired_acceleration_.norm();\n\n\t\t// Project the thrust acceleration onto the body z-axis.\n\t\tEigen::Vector3d thrust_acceleration_projected;\n\t\tthrust_acceleration_projected = thrust_acceleration.dot(body_z_axis_) * body_z_axis_;\n\t\tthrust_acceleration -= thrust_acceleration_projected;\n\n\t\t// Calculate the desired rotor velocities.\n\t\tEigen::VectorXd rotor_velocities_desired;\n\t\trotor_velocities_desired.setZero(num_rotors_);\n\t\tfor (int i = 0; i < num_rotors_; ++i) {\n\t\t\trotor_velocities_desired[i] = sqrt(thrust_acceleration.norm() * thrust_acceleration.norm() / (4.0 * rotor_thrusts_[i]));\n\t\t}\n\n\t\t// Calculate the rotor velocities.\n\t\tEigen::MatrixXd rotor_matrix;\n\t\trotor_matrix.setZero(num_rotors_, 3);\n\t\tfor (int i = 0; i < num_rotors_; ++i) {\n\t\t\trotor_matrix.row(i) = rotor_velocities_desired[i] * body_z_axis_;\n\t\t}\n\t\tEigen::VectorXd rotor_velocities_calculated = rotor_matrix * angular_acceleration.transpose();\n\n\t\t// Ensure the rotor velocities are non-negative.\n\t\tfor (int i = 0; i < num_rotors_; ++i) {\n\t\t\tif (rotor_ve", "CodeBleu_score": 38.09463391636246}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tif (rotor_velocities == NULL) {\n\t\tROS_ERROR(\"Rotor velocities pointer is NULL\");\n\t\treturn;\n\t}\n\n\tif (!is_initialized_) {\n\t\tROS_ERROR(\"Lee position controller is not initialized\");\n\t\treturn;\n\t}\n\n\tif (!is_active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\tEigen::VectorXd desired_acceleration = CalculateDesiredAcceleration();\n\tEigen::VectorXd desired_angular_acceleration = CalculateDesiredAngularAcceleration();\n\tEigen::VectorXd thrust_in_body_z_axis = CalculateThrustInBodyZAxis();\n\n\tEigen::VectorXd desired_acceleration_and_thrust_in_body_z_axis = desired_acceleration + thrust_in_body_z_axis;\n\tEigen::VectorXd desired_acceleration_and_thrust_in_body_z_axis_and_angular_acceleration = desired_acceleration_and_thrust_in_body_z_axis + desired_angular_acceleration;\n\n\tEigen::VectorXd rotor_velocities_in_body_z_axis = rotor_matrix_ * desired_acceleration_and_thrust_in_body_z_axis_and_angular_acceleration;\n\n\tfor (int i = 0; i < rotor_velocities->rows(); ++i) {\n\t\trotor_velocities->coeffRef(i) = sqrt(fmax(0.0, rotor_velocities_in_body_z_axis.coeff(i)));\n\t}\n}", "CodeBleu_score": 37.9760853873452}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tif (this->is_active_ == false) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\tEigen::VectorXd desired_acceleration(3);\n\tEigen::VectorXd angular_acceleration(3);\n\tdesired_acceleration << 0, 0, this->desired_thrust_;\n\tangular_acceleration << 0, 0, this->desired_yaw_rate_;\n\tEigen::VectorXd thrust_acceleration = desired_acceleration + angular_acceleration.cross(this->vehicle_position_);\n\tEigen::VectorXd thrust_acceleration_projected_z = thrust_acceleration.normalized().dot(this->vehicle_position_.normalized()) * this->vehicle_position_.normalized();\n\tEigen::VectorXd thrust_acceleration_projected_xy = thrust_acceleration - thrust_acceleration_projected_z;\n\tEigen::VectorXd thrust_acceleration_projected = thrust_acceleration_projected_xy.norm() * thrust_acceleration_projected_xy.normalized() + thrust_acceleration_projected_z;\n\tEigen::MatrixXd rotor_velocities_matrix(this->num_rotors_, 3);\n\tfor (int i = 0; i < this->num_rotors_; ++i) {\n\t\trotor_velocities_matrix.row(i) = this->rotor_matrix_.row(i) * thrust_acceleration_projected;\n\t}\n\tfor (int i = 0; i < this->num_rotors_; ++i) {\n\t\tEigen::VectorXd rotor_velocity_i = rotor_velocities_matrix.row(i);\n\t\trotor_velocities->coeffRef(i) = sqrt(max(0.0, rotor_velocity_i.dot(rotor_velocity_i)));\n\t}\n}", "CodeBleu_score": 37.292417730616236}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\n/*\n * The following block of code computes the position error (dx, dy, and dz) by comparing the current odometry data with the command trajectory.\n */\n\n  // Compute the current position error.\n  Eigen::Vector3d current_position_error;\n  current_position_error << state_.x - trajectory_.x, state_.y - trajectory_.y, state_.z - trajectory_.z;\n\n/*\n * The following block of code transforms the vehicle's velocity to the world frame and computes the velocity error.\n */\n\n  // Transform the vehicle's velocity to the world frame.\n  Eigen::Vector3d velocity_world;\n  velocity_world << state_.vx, state_.vy, state_.vz;\n  velocity_world = state_.rotor_frame_to_world_frame_rotation_matrix_ * velocity_world;\n\n/*\n * The following block of code calculates the desired acceleration by incorporating position and velocity gains, adjusting for vehicle mass, gravity, and the commanded acceleration.\n */\n\n  // Compute the desired acceleration.\n  *acceleration = (position_gain_ * current_position_error) + (velocity_gain_ * velocity_world) + (mass_ * gravity_) + (trajectory_.acceleration);\n}", "CodeBleu_score": 36.115266830665085}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d desired_acceleration;\n\tdesired_acceleration << 0.0, 0.0, 0.0;\n\n\tEigen::Vector3d position_error;\n\tposition_error = trajectory_reference_.position_ - vehicle_state_.position_;\n\n\tEigen::Vector3d velocity_error;\n\tvelocity_error = trajectory_reference_.velocity_ - vehicle_state_.velocity_;\n\n\tEigen::Vector3d acceleration_error;\n\tacceleration_error = trajectory_reference_.acceleration_ - vehicle_state_.acceleration_;\n\n\tEigen::Vector3d desired_acceleration_world;\n\tdesired_acceleration_world << 0.0, 0.0, 0.0;\n\n\tdesired_acceleration_world = position_gain_ * position_error + velocity_gain_ * velocity_error + acceleration_gain_ * acceleration_error;\n\n\t// Transform the desired acceleration to the body frame.\n\tdesired_acceleration = vehicle_state_.rotation_matrix_.transpose() * desired_acceleration_world;\n\n\t// Adjust for gravity.\n\tdesired_acceleration(2) -= vehicle_mass_ * gravity_;\n\n\t// Adjust for commanded acceleration.\n\tdesired_acceleration(2) += trajectory_reference_.commanded_acceleration_(2);\n\n\t*acceleration = desired_acceleration;\n}", "CodeBleu_score": 47.560921778143346}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position error.\n\tEigen::Vector3d position_error;\n\tposition_error = (desired_state_.position_N - state_.position_N);\n\n\t// Compute the velocity error.\n\tEigen::Vector3d velocity_error;\n\tvelocity_error = (desired_state_.velocity_N - state_.velocity_N);\n\n\t// Transform the vehicle's velocity to the world frame.\n\tEigen::Vector3d velocity_W;\n\tvelocity_W = state_.orientation_N.transpose() * velocity_error;\n\n\t// Calculate the desired acceleration.\n\tEigen::Vector3d desired_acceleration;\n\tdesired_acceleration = position_gain_ * position_error + velocity_gain_ * velocity_W + gravity_;\n\n\t// Adjust the desired acceleration for the commanded acceleration.\n\tdesired_acceleration += acceleration_command_;\n\n\t// Transform the desired acceleration to the vehicle frame.\n\t*acceleration = state_.orientation_N * desired_acceleration;\n}", "CodeBleu_score": 46.11331230001561}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tEigen::VectorXd thrust_reference = thrust_reference_;\n\tEigen::VectorXd angular_acceleration_reference = angular_acceleration_reference_;\n\tEigen::VectorXd rotor_velocities_temp(4);\n\tEigen::MatrixXd rotor_matrix(4,4);\n\tEigen::VectorXd rotor_velocities_temp2(4);\n\n\tif (rotor_velocities->size() != 4) {\n\t\trotor_velocities->resize(4);\n\t}\n\n\tif (thrust_reference.size() != 4) {\n\t\tthrust_reference.resize(4);\n\t}\n\n\tif (angular_acceleration_reference.size() != 3) {\n\t\tangular_acceleration_reference.resize(3);\n\t}\n\n\trotor_matrix << 1, 1, 1, 1, -1, -1, -1, -1;\n\n\trotor_velocities_temp = rotor_matrix * thrust_reference;\n\n\tfor (int i = 0; i < rotor_velocities_temp.size(); i++) {\n\t\tif (rotor_velocities_temp(i) < 1.0) {\n\t\t\trotor_velocities_temp(i) = 1.0;\n\t\t}\n\t}\n\n\trotor_velocities_temp2 = rotor_velocities_temp.array().sqrt();\n\n\trotor_velocities->noalias() = rotor_velocities_temp2;\n}", "CodeBleu_score": 40.15087029374355}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Check that the input pointer is not null\n\tif (rotor_velocities == NULL) {\n\t\tROS_ERROR(\"The rotor velocities pointer is null\");\n\t\treturn;\n\t}\n\n\t// Check that the input vector is not null\n\tif (rotor_velocities->rows() != num_rotors_) {\n\t\tROS_ERROR(\"The rotor velocities vector does not have the correct number of rows\");\n\t\treturn;\n\t}\n\n\t// Check that the input vector is not null\n\tif (rotor_velocities->cols() != 1) {\n\t\tROS_ERROR(\"The rotor velocities vector does not have the correct number of columns\");\n\t\treturn;\n\t}\n\n\t// Check that the input vector is not null\n\tif (thrust_reference_.rows() != num_rotors_) {\n\t\tROS_ERROR(\"The thrust reference vector does not have the correct number of rows\");\n\t\treturn;\n\t}\n\n\t// Check that the input vector is not null\n\tif (thrust_reference_.cols() != 1) {\n\t\tROS_ERROR(\"The thrust reference vector does not have the correct number of columns\");\n\t\treturn;\n\t}\n\n\t// Check that the input vector is not null\n\tif (angular_acceleration_reference_.rows() != num_rotors_) {\n\t\tROS_ERROR(\"The angular acceleration reference vector does not have the correct number of rows\");\n\t\treturn;\n\t}\n\n\t// Check that the input vector is not null\n\tif (angular_acceleration_reference_.cols() != 1) {\n\t\tROS_ERROR(\"The angular acceleration reference vector does not have the correct number of columns\");\n\t\treturn;\n\t}\n\n\t// Resize the rotor velocities vector to match the number of rotors\n\trotor_velocities->resize(num_rotors_);\n\n\t// Initialize the rotor velocities vector\n\trotor_velocities->setZero();\n\n\t// Check that the rotor velocities matrix is not null\n\tif (rotor_velocities_matrix_.rows() != num_rotors_) {\n\t\tROS_ERROR(\"The rotor velocities matrix does not have the correct number of rows\");\n\t\treturn;\n\t}\n\n\t// Check that the rotor velocities matrix is not null\n\tif", "CodeBleu_score": 34.17816772038849}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//TODO: Add a check to ensure the input is valid.\n\n//TODO: Resize the rotor velocities vector to match the number of rotors.\n\n//TODO: Calculate the desired angular acceleration.\n//TODO: Combine the desired angular acceleration with the thrust reference into a single vector.\n\n//TODO: Compute the rotor velocities.\n}", "CodeBleu_score": 4.0986584859826545}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices of the start and end times\n    start_index = numpy.searchsorted(self.time_stamps, start_time)\n    end_index = numpy.searchsorted(self.time_stamps, end_time)\n    # Create a copy of the object\n    new_object = copy.deepcopy(self)\n    # Update the copied object's attributes\n    new_object.time_stamps = self.time_stamps[start_index:end_index]\n    new_object.x_coordinates = self.x_coordinates[start_index:end_index]\n    new_object.y_coordinates = self.y_coordinates[start_index:end_index]\n    new_object.z_coordinates = self.z_coordinates[start_index:end_index]\n    new_object.rolls = self.rolls[start_index:end_index]\n    new_object.pitches = self.pitches[start_index:end_index]\n    new_object.yaws = self.yaws[start_index:end_index]\n    new_object.velocities = self.velocities[start_index:end_index]\n    new_object.accelerations = self.accelerations[start_index:end_index]\n    return new_object\n\n", "CodeBleu_score": 17.01927317581359}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices for the start and end times.\n    start_index = 0\n    end_index = 0\n    for i in range(len(self.time_stamps)):\n        if self.time_stamps[i] >= start_time:\n            start_index = i\n            break\n    for i in range(len(self.time_stamps)):\n        if self.time_stamps[i] >= end_time:\n            end_index = i\n            break\n    # Create a deep copy of the object.\n    sliced_object = copy.deepcopy(self)\n    # Update each attribute of the copied object.\n    sliced_object.time_stamps = self.time_stamps[start_index:end_index]\n    sliced_object.x = self.x[start_index:end_index]\n    sliced_object.y = self.y[start_index:end_index]\n    sliced_object.z = self.z[start_index:end_index]\n    sliced_object.roll = self.roll[start_index:end_index]\n    sliced_object.pitch = self.pitch[start_index:end_index]\n    sliced_object.yaw = self.yaw[start_index:end_index]\n    return sliced_object\n\n", "CodeBleu_score": 33.45779440244889}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices corresponding to the start and end times\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    # Make a deep copy of the object\n    new_object = copy.deepcopy(self)\n    # Update the attributes of the copied object\n    new_object.header = self.header[start_index:end_index+1]\n    new_object.pose = self.pose[start_index:end_index+1]\n    new_object.twist = self.twist[start_index:end_index+1]\n    new_object.accel = self.accel[start_index:end_index+1]\n    new_object.wrench = self.wrench[start_index:end_index+1]\n    new_object.time = self.time[start_index:end_index+1]\n    new_object.time_offset = self.time_offset\n    new_object.bag_name = self.bag_name\n    new_object.topic_name = self.topic_name\n    return new_object\n\n", "CodeBleu_score": 19.613103072178127}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint_msg is None or point.x != self.last_waypoint_msg.point.x or point.y != self.last_waypoint_msg.point.y or point.z != self.last_waypoint_msg.point.z or euler[2] != self.last_waypoint_msg.euler.z:\n        # Append new point, yaw, and corresponding times to their respective arrays\n        self.waypoint_positions.append(copy.deepcopy(point))\n        self.waypoint_yaws.append(euler[2])\n        self.waypoint_times.append(msg_time.to_sec() - bag_time.to_sec())\n        self.last_waypoint_msg = copy.deepcopy(waypoint_msg)\n\n", "CodeBleu_score": 27.999658235535023}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation\n    position = waypoint_msg.pose.position\n    orientation = waypoint_msg.pose.orientation\n\n    # Convert the rotation to Euler angles\n    quaternion = (\n        orientation.x,\n        orientation.y,\n        orientation.z,\n        orientation.w)\n    euler = tf.transformations.euler_from_quaternion(quaternion)\n    yaw = euler[2]\n\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the current waypoint is different from the last one\n    if self.last_point is None or (self.last_point.x != point.x or self.last_point.y != point.y or self.last_point.z != point.z or self.last_yaw != yaw):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.points.append(point)\n        self.yaws.append(yaw)\n        self.times.append(msg_time.to_sec() - bag_time.to_sec())\n\n        # Update the last point and yaw\n        self.last_point = copy.deepcopy(point)\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 29.95262849828655}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation from the message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert the rotation to Euler angles\n    (roll, pitch, yaw) = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object from the position\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n    # Check if the current waypoint is different from the last one\n    if (len(self.points) > 0) and (self.points[-1].x == point.x) and (self.points[-1].y == point.y) and (self.points[-1].z == point.z) and (self.yaws[-1] == yaw):\n        return\n    # Append the new point, yaw, and corresponding times to their respective arrays\n    self.points.append(point)\n    self.yaws.append(yaw)\n    self.times.append(msg_time - bag_time)\n\n", "CodeBleu_score": 24.58458619430167}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    # Convert the message time to seconds.\n    msg_time = msg.header.stamp.secs + msg.header.stamp.nsecs / 1000000000.0\n    # If the topic matches, append the linear acceleration data to the corresponding x, y, and z attributes.\n    if topic == self.imu_topic:\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n    # Append the message time and bag time to the time attributes.\n    self.message_time.append(msg_time)\n    self.bag_time.append(bag_time)\n\n", "CodeBleu_score": 33.85597619611469}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    self.acceleration_x.append(msg.linear_acceleration.x)\n    self.acceleration_y.append(msg.linear_acceleration.y)\n    self.acceleration_z.append(msg.linear_acceleration.z)\n    self.acceleration_time.append(msg.header.stamp.to_sec())\n    self.acceleration_bag_time.append(bag_time)\n\n", "CodeBleu_score": 18.81318963046457}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_msg_count += 1\n        self.imu_msg_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_linear_acceleration.append([msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z])\n    elif topic == '/imu/data_raw':\n        self.imu_msg_count += 1\n        self.imu_msg_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_raw_linear_acceleration.append([msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z])\n    elif topic == '/imu/data_raw_mag':\n        self.imu_msg_count += 1\n        self.imu_msg_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_raw_magnetic_field.append([msg.magnetic_field.x, msg.magnetic_field.y, msg.magnetic_field.z])\n    elif topic == '/imu/data_raw_accel':\n        self.imu_msg_count += 1\n        self.imu_msg_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_raw_acceleration.append([msg.acceleration.x, msg.acceleration.y, msg.acceleration.z])\n    elif topic == '/imu/data_raw_gyro':\n        self.imu_msg_count += 1\n        self.imu_msg_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_raw_angular_velocity.append([msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z])\n    elif topic == '/imu/mag':\n        self.imu_msg_count += 1\n        self.imu_msg_time.append(msg.header.stamp.to_", "CodeBleu_score": 25.72143522320832}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Get the acceleration data from the bag.\n    accelerations = self.get_accelerations()\n\n    # Create the plot.\n    fig = pyplot.figure()\n    fig.suptitle('Accelerations')\n    ax = fig.add_subplot(1, 1, 1)\n\n    # Plot the accelerations.\n    for i, acc in enumerate(accelerations):\n        ax.plot(acc[:, 0], acc[:, 1], acc[:, 2], label='acc' + str(i))\n\n    # Add labels and legend.\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    ax.legend()\n\n    # Save the plot if enabled.\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        pyplot.savefig(self.plot_prefix + '_accelerations' + plot_suffix + '.png')\n\n    # Show the plot if enabled.\n    if self.show_plots:\n        pyplot.show()\n\n", "CodeBleu_score": 35.07876900109088}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    ax = fig.add_subplot(111)\n    ax.set_title('Accelerations')\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    for i in range(len(self.accelerations)):\n        ax.plot(self.accelerations[i]['time'], self.accelerations[i]['x'], label=self.accelerations[i]['label'] + ' x', color='r')\n        ax.plot(self.accelerations[i]['time'], self.accelerations[i]['y'], label=self.accelerations[i]['label'] + ' y', color='g')\n        ax.plot(self.accelerations[i]['time'], self.accelerations[i]['z'], label=self.accelerations[i]['label'] + ' z', color='b')\n    ax.legend()\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        pyplot.savefig(self.plot_directory + 'accelerations' + plot_suffix + '.png')\n    pyplot.show()\n\n", "CodeBleu_score": 33.197968430998245}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.plot_accelerations_enabled:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        else:\n            plot_suffix = \"_\" + plot_suffix\n\n        # Create figure\n        fig = pyplot.figure(figsize=(12, 9))\n        fig.suptitle(\"Accelerations \" + self.name + plot_suffix)\n\n        # Plot accelerations\n        pyplot.subplot(3, 1, 1)\n        pyplot.plot(self.accelerations_time, self.accelerations_x, label=\"x\", color=\"r\")\n        pyplot.plot(self.accelerations_time, self.accelerations_y, label=\"y\", color=\"g\")\n        pyplot.plot(self.accelerations_time, self.accelerations_z, label=\"z\", color=\"b\")\n        pyplot.xlabel(\"Time (s)\")\n        pyplot.ylabel(\"Acceleration (m/s^2)\")\n        pyplot.legend(loc=\"upper left\")\n\n        # Plot jerk\n        pyplot.subplot(3, 1, 2)\n        pyplot.plot(self.accelerations_time, self.accelerations_jerk_x, label=\"x\", color=\"r\")\n        pyplot.plot(self.accelerations_time, self.accelerations_jerk_y, label=\"y\", color=\"g\")\n        pyplot.plot(self.accelerations_time, self.accelerations_jerk_z, label=\"z\", color=\"b\")\n        pyplot.xlabel(\"Time (s)\")\n        pyplot.ylabel(\"Jerk (m/s^3)\")\n        pyplot.legend(loc=\"upper left\")\n\n        # Plot snap\n        pyplot.subplot(3, 1, 3)\n        pyplot.plot(self.accelerations_time, self.accelerations_snap_x, label=\"x\", color=\"r\")\n        pyplot.plot(self.accelerations_time, self.accelerations_snap_y, label=\"y\", color=\"g\")\n        pyplot.plot(self.accelerations_time, self.accelerations_snap_z, label=\"z\", color=\"b\")\n        pyplot.xlabel(\"Time (s)\")\n        pyplot.ylabel(\"Snap (m/", "CodeBleu_score": 30.369979487203878}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    pose_indeces = copy.deepcopy(pose_indeces)\n    if len(pose_indeces) < 2:\n        print(\"Not enough poses to compare.\")\n        return False\n    else:\n        pose_indeces.sort()\n        for index in pose_indeces:\n            compare_two_xyz(self, index)\n\n", "CodeBleu_score": 25.23277114828233}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # pose_indeces is a list of pose indices\n    # pose_indeces[0] is the index of the first pose\n    # pose_indeces[1] is the index of the second pose\n    # pose_indeces[2] is the index of the third pose\n    # pose_indeces[3] is the index of the fourth pose\n    # pose_indeces[4] is the index of the fifth pose\n    # pose_indeces[5] is the index of the sixth pose\n    # pose_indeces[6] is the index of the seventh pose\n    # pose_indeces[7] is the index of the eighth pose\n    # pose_indeces[8] is the index of the ninth pose\n    # pose_indeces[9] is the index of the tenth pose\n    # pose_indeces[10] is the index of the eleventh pose\n    # pose_indeces[11] is the index of the twelfth pose\n    # pose_indeces[12] is the index of the thirteenth pose\n    # pose_indeces[13] is the index of the fourteenth pose\n    # pose_indeces[14] is the index of the fifteenth pose\n    # pose_indeces[15] is the index of the sixteenth pose\n    # pose_indeces[16] is the index of the seventeenth pose\n    # pose_indeces[17] is the index of the eighteenth pose\n    # pose_indeces[18] is the index of the nineteenth pose\n    # pose_indeces[19] is the index of the twentieth pose\n    # pose_indeces[20] is the index of the twenty-first pose\n    # pose_indeces[21] is the index of the twenty-second pose\n    # pose_indeces[22] is the index of the twenty-third pose\n    # pose_indeces[23] is the index of the twenty-fourth pose\n    # pose_indeces[24] is the index of the twenty-fifth pose\n    # pose_indeces[25] is the index of the twenty-sixth pose\n    # pose_indeces[26] is the index of", "CodeBleu_score": 2.864583333333333}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: Not enough pose indices provided to compare\")\n        return\n    for i in range(0, len(pose_indeces) - 1):\n        compare_two_xyz(self, pose_indeces[i], pose_indeces[i+1])\n\n", "CodeBleu_score": 31.516422225069267}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for i in range(len(self.wrench)):\n        if start_time is not None and end_time is not None:\n            if self.wrench[i][0] >= start_time and self.wrench[i][0] <= end_time:\n                collision_times.append(self.wrench[i][0])\n        elif start_time is not None and end_time is None:\n            if self.wrench[i][0] >= start_time:\n                collision_times.append(self.wrench[i][0])\n        elif start_time is None and end_time is not None:\n            if self.wrench[i][0] <= end_time:\n                collision_times.append(self.wrench[i][0])\n        else:\n            collision_times.append(self.wrench[i][0])\n    return collision_times\n\n", "CodeBleu_score": 35.226256898941706}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is not None and end_time is not None:\n            if collision.time >= start_time and collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None:\n            if collision.time >= start_time:\n                collision_times.append(collision.time)\n        elif end_time is not None:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 40.18091362583428}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    if start_time is None:\n        start_time = self.start_time\n    if end_time is None:\n        end_time = self.end_time\n    collision_times = []\n    for i in range(len(self.wrench)):\n        if self.wrench[i][0] >= start_time and self.wrench[i][0] <= end_time:\n            collision_times.append(self.wrench[i][0])\n    return collision_times\n\n", "CodeBleu_score": 37.52830823035316}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 33.45415835736383}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 29.32422071502378}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = settling_time + start_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 34.420208652620175}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t if (!data) {\n   return;\n }\n // Calculate a multiplier based on camera parameters.\n const float multiplier = std::sqrt(std::pow(std::tan(horizontal_fov_rad_ / 2), 2) +\n                                   std::pow(std::tan(vertical_fov_rad_ / 2), 2)) / 2.0;\n // Map the data to an Eigen vector.\n Eigen::Map<Eigen::VectorXf> data_vector(data, width * height);\n // Compute the RMS noise.\n const float rms_noise = multiplier * depth_noise_stddev_;\n // Compute the noise values.\n Eigen::VectorXf noise_values = rms_noise * Eigen::VectorXf::Random(width * height);\n // For each pixel, add noise if the pixel value is in range, otherwise set the pixel to a bad point value.\n for (uint32_t y = 0; y < height; ++y) {\n   for (uint32_t x = 0; x < width; ++x) {\n     const uint32_t index = y * width + x;\n     if (data_vector(index) != 0.0) {\n       data_vector(index) += noise_values(index);\n     } else {\n       data_vector(index) = kBadPointValue;\n     }\n   }\n }\n}", "CodeBleu_score": 42.14065110730378}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n  return;\n}\n\n// Calculate the multiplier.\nconst float multiplier = GetMultiplier(width, height);\n\n// Map the data to an Eigen vector.\nEigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>> depth_data(data, width * height);\n\n// Compute the RMS noise.\nconst float rms_noise = GetRMSNoise(multiplier);\n\n// Compute the noise values.\nconst float min_noise = -rms_noise;\nconst float max_noise = rms_noise;\n\n// Apply the noise to the data.\nfor (int i = 0; i < depth_data.size(); ++i) {\n  if (depth_data[i] > 0) {\n    depth_data[i] += min_noise + (max_noise - min_noise) * GetRandomValue();\n  } else {\n    depth_data[i] = kBadPointValue;\n  }\n}\n}", "CodeBleu_score": 50.92830041028411}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {", "CodeBleu_score": 4.557283611936493}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n//    ROS_INFO(\"WaypointCallback\");\n\n    if (!is_recording_) {\n        return;\n    }\n\n    // Get current simulation time\n    gazebo::common::Time current_time = world_->GetSimTime();\n\n    // Convert Gazebo time to ROS time\n    ros::Time ros_time = ros::Time(current_time.sec, current_time.nsec);\n\n    // Write the trajectory message to a bag file using the specified namespace and waypoint topic\n    bag_.write(waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 54.22580639248421}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n#if GAZEBO_MAJOR_VERSION >= 8\n  ros::Time sim_time = parent->GetWorld()->SimTime();\n#else\n  ros::Time sim_time = parent->GetWorldTime();\n#endif\n\n  // Convert the simulation time to a ROS time.\n  ros::Time ros_time;\n  ros_time.sec = sim_time.sec;\n  ros_time.nsec = sim_time.nsec;\n\n  // Write the trajectory message to a bag file.\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, trajectory_msg);\n}", "CodeBleu_score": 57.06032906922056}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\tros::Time current_time = ros::Time::now();\n\trosbag::Bag bag;\n\tbag.open(file_name_, bagmode_);\n\n\t// Write the trajectory message to the bag file\n\tfor (int i = 0; i < trajectory_msg->points.size(); i++) {\n\t\ttrajectory_msgs::MultiDOFJointTrajectoryPoint trajectory_point;\n\t\ttrajectory_point = trajectory_msg->points[i];\n\t\ttrajectory_point.time_from_start = current_time;\n\t\tbag.write(namespace_ + \"/\" + waypoint_topic_, trajectory_point);\n\t}\n\n\tbag.close();\n}", "CodeBleu_score": 46.825196483122625}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert the simulation time to a ROS time.\n\tros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n\t// Prepare a message for actuator velocities.\n\tmav_msgs::Actuators actuators_msg;\n\tactuators_msg.header.stamp = ros_time;\n\n\t// Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message.\n\tfor (int i = 0; i < joint_names_.size(); i++) {\n\t\t// Get the rotational velocity of the motor joint.\n\t\tdouble joint_vel = joint_velocities_[i];\n\n\t\t// Calculate the slowed-down rotational velocity.\n\t\tdouble slowed_down_vel = joint_vel * slowdown_factor_;\n\n\t\t// Assign the slowed-down rotational velocity to the message.\n\t\tactuators_msg.angular_velocities.push_back(slowed_down_vel);\n\t}\n\n\t// Write the message to a bag file using the specified namespace and motor topic.\n\tbag_.write(namespace_ + \"/\" + motor_topic_, ros_time, actuators_msg);\n}", "CodeBleu_score": 46.057126965805125}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Create a message for actuator velocities\n\tmav_msgs::Actuators motor_velocities;\n\n\t// Set the timestamp of the message\n\tmotor_velocities.header.stamp = ros::Time(now.sec, now.nsec);\n\n\t// Iterate through the motor joints\n\tfor (int i = 0; i < model_.joints_.size(); ++i) {\n\t\t// Get the joint name\n\t\tstd::string joint_name = model_.joints_[i].GetName();\n\n\t\t// Get the joint velocity\n\t\tdouble joint_velocity = model_.joints_[i].GetVelocity(0);\n\n\t\t// Get the joint position\n\t\tdouble joint_position = model_.joints_[i].GetAngle(0).Radian();\n\n\t\t// Get the joint effort\n\t\tdouble joint_effort = model_.joints_[i].GetForce(0);\n\n\t\t// Get the joint torque\n\t\tdouble joint_torque = model_.joints_[i].GetTorque(0);\n\n\t\t// Get the joint damping\n\t\tdouble joint_damping = model_.joints_[i].GetDampingCoefficient(0);\n\n\t\t// Get the joint friction\n\t\tdouble joint_friction = model_.joints_[i].GetFrictionTorque(0);\n\n\t\t// Get the joint velocity limit\n\t\tdouble joint_velocity_limit = model_.joints_[i].GetVelocityLimit(0);\n\n\t\t// Get the joint effort limit\n\t\tdouble joint_effort_limit = model_.joints_[i].GetEffortLimit(0);\n\n\t\t// Get the joint lower position limit\n\t\tdouble joint_lower_position_limit = model_.joints_[i].GetLowerLimit(0);\n\n\t\t// Get the joint upper position limit\n\t\tdouble joint_upper_position_limit = model_.joints_[i].GetUpperLimit(0);\n\n\t\t// Get the joint velocity limit\n\t\tdouble joint_velocity_limit = model_.joints_[i].GetVelocityLimit(0);\n\n\t\t// Get the joint effort limit\n\t\tdouble joint_effort_limit = model_.joints_[i].GetEffortLimit(0);\n\n\t\t// Get the joint lower position limit\n\t\tdouble joint_lower_position_limit = model_.joints_[i].GetLowerLimit(0);\n\n\t\t// Get the joint upper position limit\n\t\tdouble joint_upper_position_limit", "CodeBleu_score": 38.28689675030421}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\tmav_msgs::Actuators actuators;\n\tactuators.header.stamp = ros_now;\n\tactuators.header.frame_id = \"base_link\";\n\tfor (int i = 0; i < 4; i++) {\n\t\tactuators.angular_velocities.push_back(this->motor_velocities[i] * this->slowdown_factor);\n\t}\n\tthis->motor_velocities_pub.publish(actuators);\n\tthis->bag.write(this->namespace_ + \"/actuators/motor_velocities\", ros_now, actuators);\n}", "CodeBleu_score": 39.91247216715904}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\n#if GAZEBO_FW_DYNAMICS_PLUGIN_DEBUG_PRINT\n  gzdbg << \"RollPitchYawrateThrustCallback called\" << std::endl;\n#endif\n\n  // Convert normalized roll, pitch, and yaw rate values to control surface angles for ailerons, elevator, and rudder.\n  double aileron_angle = roll_pitch_yawrate_thrust_msg->roll * kRollPitchYawrateThrustToAileronAngleScale;\n  double elevator_angle = roll_pitch_yawrate_thrust_msg->pitch * kRollPitchYawrateThrustToElevatorAngleScale;\n  double rudder_angle = roll_pitch_yawrate_thrust_msg->yaw_rate * kRollPitchYawrateThrustToRudderAngleScale;\n\n  // Set the throttle value.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // Set the control surfaces.\n  double control_surfaces[3] = {aileron_angle, elevator_angle, rudder_angle};\n  this->SetControlSurfaces(control_surfaces);\n\n  // Set the throttle.\n  this->SetThrottle(throttle);\n}", "CodeBleu_score": 36.16819834819051}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_MAJOR_VERSION >= 9\n  gzmsg << \"RollPitchYawrateThrustCallback called\" << std::endl;\n#else\n  gzmsg << \"RollPitchYawrateThrustCallback called\" << std::endl;\n#endif\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll() * M_PI;\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch() * M_PI;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate() * M_PI;\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n\n  double aileron_angle = roll_angle + pitch_angle;\n  double elevator_angle = pitch_angle - roll_angle;\n  double rudder_angle = yaw_rate;\n\n  // Set the throttle value from the thrust message.\n  double throttle = thrust;\n\n  // Publish the control surface angles and throttle value.\n  this->PublishControlSurfaceAnglesThrottle(aileron_angle, elevator_angle, rudder_angle, throttle);\n}", "CodeBleu_score": 40.74976066569419}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_MAJOR_VERSION >= 8\n  gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called.\n\";\n#else\n  ROS_DEBUG_NAMED(\"gazebo_fw_dynamics_plugin\", \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called.\");\n#endif\n\n  if (debug_print_enabled_) {\n    gzdbg << \"RollPitchYawrateThrustCallback: roll=\" << roll_pitch_yawrate_thrust_msg->roll << \", pitch=\" << roll_pitch_yawrate_thrust_msg->pitch << \", yaw_rate=\" << roll_pitch_yawrate_thrust_msg->yaw_rate << \", thrust=\" << roll_pitch_yawrate_thrust_msg->thrust << \"\n\";\n  }\n\n  // Convert roll, pitch, yaw rate to aileron, elevator, and rudder control surface angles.\n  double aileron_angle, elevator_angle, rudder_angle;\n  ConvertRollPitchYawrateToAileronElevatorRudderAngles(roll_pitch_yawrate_thrust_msg->roll, roll_pitch_yawrate_thrust_msg->pitch, roll_pitch_yawrate_thrust_msg->yaw_rate, aileron_angle, elevator_angle, rudder_angle);\n\n  // Set the control surface angles.\n  aileron_joint_cmd_msg_.set_position(aileron_angle);\n  elevator_joint_cmd_msg_.set_position(elevator_angle);\n  rudder_joint_cmd_msg_.set_position(rudder_angle);\n\n  // Set the throttle value.\n  throttle_joint_cmd_msg_.set_velocity(roll_pitch_yawrate_thrust_msg->thrust);\n\n  // Publish the control surface angle and throttle messages.\n  aileron_joint_cmd_pub_.publish(aileron_joint_cmd_msg_);\n  elevator_joint_cmd_pub_.publish(elevator_joint_cmd_msg_);\n  rudder_joint_cmd_pub_.publish(rudder_joint_cmd_msg_);\n  throttle_joint_cmd_pub_.publish(throttle_joint_cmd_msg_);\n}", "CodeBleu_score": 35.50337338981856}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#ifndef __linux__\n  gzerr << \"pollForMAVLinkMessages() not implemented on this platform\" << std::endl;\n  return;\n#else\n  // Check if the serial port is open\n  if (!this->serial_port_open_) {\n    gzerr << \"pollForMAVLinkMessages() called without an open serial port\" << std::endl;\n    return;\n  }\n\n  // Convert the timeout in milliseconds to a timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for data on the serial port\n  int num_bytes = 0;\n  if ((num_bytes = poll(&serial_poll_fd_, 1, _timeoutMs)) > 0) {\n    // Read the data from the serial port\n    if (this->serial_port_.read(this->serial_buffer_, num_bytes)) {\n      // Parse the data\n      mavlink_message_t msg;\n      uint8_t* buffer = reinterpret_cast<uint8_t*>(this->serial_buffer_);\n      uint16_t buffer_len = num_bytes;\n      while (mavlink_parse_char(this->mavlink_system_.protocol_version(), buffer, &buffer_len, &msg) == MAVLINK_FRAMING_OK) {\n        // Send the message to the Gazebo MAVLink interface\n        this->handleIncomingMavlinkMessage(msg);\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 41.869467798063866}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t\n#if GAZEBO_MAJOR_VERSION >= 8\n  // Get the time at which the function was called.\n  const gazebo::common::Time now = gazebo::common::Time::GetWallTime();", "CodeBleu_score": 2.3236319089126796}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t//    gzdbg << \"GazeboMavlinkInterface::pollForMAVLinkMessages() called.\" << std::endl;\n\n    // Get the current time\n    struct timeval now;\n    gettimeofday(&now, NULL);\n\n    // Set the timeout\n    struct timeval timeout;\n    timeout.tv_sec = now.tv_sec + _dt;\n    timeout.tv_usec = now.tv_usec + (_dt - (double)now.tv_usec) * 1000000.0;\n\n    // If the timeout is in the past, set it to the current time\n    if (timeout.tv_sec < now.tv_sec) {\n        timeout.tv_sec = now.tv_sec;\n        timeout.tv_usec = now.tv_usec;\n    }\n\n    // Convert the timeout to a timespec structure\n    timespec timeoutSpec;\n    timeoutSpec.tv_sec = timeout.tv_sec;\n    timeoutSpec.tv_nsec = (timeout.tv_usec * 1000);\n\n    // Poll for data on the serial port\n    int numBytes = 0;\n    if (FD_ISSET(this->serialPort->GetFD(), &this->readSet)) {\n        numBytes = this->serialPort->Read(this->readBuffer, sizeof(this->readBuffer), _timeoutMs);\n    }\n\n    // Parse the messages\n    mavlink_message_t msg;\n    uint8_t *p = this->readBuffer;\n    for (int i = 0; i < numBytes; ++i) {\n        if (mavlink_parse_char(this->mavlinkSystem.target_system,\n                               this->mavlinkSystem.target_component,\n                               p[i], &msg, &this->mavlinkStatus)) {\n            this->handleMessage(&msg);\n        }\n    }\n\n    // Poll for data on the UDP port\n    if (FD_ISSET(this->udpPort->GetFD(), &this->readSet)) {\n        numBytes = this->udpPort->Read(this->readBuffer, sizeof(this->readBuffer), _timeoutMs);\n    }\n\n    // Parse the messages\n    p = this->readBuffer;\n    for (int i = 0; i < numBytes; ++i) {\n        if (mavlink_parse_char(this->mavlinkSystem.target_system,\n                               this", "CodeBleu_score": 41.91056880335523}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(mutex_);\n\tif (is_open_) {\n\t\tstop_io_service();\n\t\tif (serial_device_.is_open()) {\n\t\t\tserial_device_.close();\n\t\t}\n\t\tif (io_service_thread_.joinable()) {\n\t\t\tio_service_thread_.join();\n\t\t}\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 55.299567772468514}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::recursive_mutex::scoped_lock lock(mutex_);\n\tif (isOpen_)  {\n\t\tboost::system::error_code error_code;\n\t\tif (io_service_thread_.joinable())  {\n\t\t\tio_service_thread_.join(error_code);\n\t\t}\n\t\tif (serial_device_.is_open())  {\n\t\t\tserial_device_.close(error_code);\n\t\t}\n\t\tisOpen_ = false;\n\t}\n}", "CodeBleu_score": 50.00587327145435}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(mutex_);\n\n\tif (!is_open_) {\n\t\tROS_WARN_NAMED(\"gazebo_mavlink_interface\", \"Closing an already closed interface\");\n\t\treturn;\n\t}\n\n\t// Stop the I/O service\n\tstop();\n\n\t// Close the serial device\n\tserial_device_.close();\n\n\t// If the thread is joinable, join it\n\tif (io_service_thread_.joinable()) {\n\t\tio_service_thread_.join();\n\t}\n\n\tis_open_ = false;\n}", "CodeBleu_score": 55.221517536889486}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tignition::math::Vector3d GazeboWindPlugin::LinearInterpolation(ignition::math::Vector3d point1, ignition::math::Vector3d point2, double x) {\n  return (point2 - point1) * x + point1;\n}\n", "CodeBleu_score": 34.452957070390475}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x1, y1, z1, x2, y2, z2, x, y, z;\n\nx1 = x_points[i];\ny1 = y_points[i];\nz1 = z_points[i];\nx2 = x_points[i+1];\ny2 = y_points[i+1];\nz2 = z_points[i+1];\n\nx = x1 + (x2-x1)*(position-x1)/(x2-x1);\ny = y1 + (y2-y1)*(position-x1)/(x2-x1);\nz = z1 + (z2-z1)*(position-x1)/(x2-x1);\n\nreturn ignition::math::Vector3d(x, y, z);\n}", "CodeBleu_score": 36.702593836908946}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x1, y1, z1, x2, y2, z2, x, y, z;\n", "CodeBleu_score": 4.438823521337634}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (this->loop) {\n\t\tthis->time = fmod(_time, this->length);\n\t} else {\n\t\tthis->time = std::max(0.0, std::min(_time, this->length));\n\t}\n}", "CodeBleu_score": 38.232092922317634}, {"code": "void Animation::SetTime(double _time){\n\t\tif (this->loop) {\n\t\tthis->time = fmod(_time, this->length);\n\t} else {\n\t\tthis->time = std::min(std::max(_time, 0.0), this->length);\n\t}\n}", "CodeBleu_score": 38.23814655352884}, {"code": "void Animation::SetTime(double _time){\n\t\t// Check if the animation is looping\n\tif (this->loop) {\n\t\t// Wrap the time within the animation length\n\t\tthis->time = fmod(_time, this->GetLength());\n\t}\n\telse {\n\t\t// Clamp the time between 0 and the animation length\n\t\tthis->time = std::max(0.0, std::min(_time, this->GetLength()));\n\t}\n}", "CodeBleu_score": 37.87191810357028}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    rospy.wait_for_service('/mavros/cmd/arming')\n    armService = rospy.ServiceProxy('/mavros/cmd/arming', CommandBool)\n    armService(True)\n\n    rospy.wait_for_service('/mavros/set_mode')\n    flightModeService = rospy.ServiceProxy('/mavros/set_mode', SetMode)\n    flightModeService(custom_mode='OFFBOARD')\n\n    rospy.wait_for_service('/mavros/param/set')\n    paramSetService = rospy.ServiceProxy('/mavros/param/set', ParamSet)\n    paramSetService(param_id='SYS_MC_EST_GROUP', value=1)\n\n    rospy.wait_for_service('/mavros/param/set')\n    paramSetService = rospy.ServiceProxy('/mavros/param/set', ParamSet)\n    paramSetService(param_id='SYS_MC_EST_GROUP', value=1)\n\n    rospy.wait_for_service('/mavros/param/set')\n    paramSetService = rospy.ServiceProxy('/mavros/param/set', ParamSet)\n    paramSetService(param_id='MC_ROLL_P', value=0.0)\n\n    rospy.wait_for_service('/mavros/param/set')\n    paramSetService = rospy.ServiceProxy('/mavros/param/set', ParamSet)\n    paramSetService(param_id='MC_ROLLRATE_P', value=0.0)\n\n    rospy.wait_for_service('/mavros/param/set')\n    paramSetService = rospy.ServiceProxy('/mavros/param/set', ParamSet)\n    paramSetService(param_id='MC_PITCH_P', value=0.0)\n\n    rospy.wait_for_service('/mavros/param/set')\n    paramSetService = rospy.ServiceProxy('/mavros/param/set', ParamSet)\n    paramSetService(param_id='MC_PITCHRATE_P', value=0.0)\n\n    rospy.wait_for_service('/mavros/param/set')\n    paramSetService = rospy.ServiceProxy('/mavros/param/set', ParamSet)\n    paramSetService(param_id='MC_YAW_P', value=0.0)\n\n    rospy.wait_for_service('/mavros/param/set')\n   ", "CodeBleu_score": 16.410603335162865}, {"code": "def hover(self)\n\t\n    print(\"Vehicle Type: \" + str(vehicle_type) + \"", "CodeBleu_score": 2.1170174613406356}, {"code": "def hover(self)\n\t\n    # Create a PoseStamped message\n    msg = PositionTarget()\n    msg.coordinate_frame = 1\n    msg.type_mask = 0\n    msg.position.x = 0\n    msg.position.y = 0\n    msg.position.z = 0\n    msg.velocity.x = 0\n    msg.velocity.y = 0\n    msg.velocity.z = 0\n    msg.acceleration_or_force.x = 0\n    msg.acceleration_or_force.y = 0\n    msg.acceleration_or_force.z = 0\n    msg.yaw = 0\n    msg.yaw_rate = 0\n\n    # Send the message\n    self.pub.publish(msg)\n    print(\"Vehicle type: \" + str(self.vehicle_type) + \"", "CodeBleu_score": 19.779412656772287}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hover()\n        return True\n    elif self.flightMode == \"STABILIZE\":\n        if self.flightModeService(custom_mode=\"STABILIZE\") == True:\n            rospy.loginfo(\"Flight mode changed to STABILIZE\")\n            return True\n        else:\n            rospy.logerr(\"Failed to change flight mode to STABILIZE\")\n            return False\n    elif self.flightMode == \"OFFBOARD\":\n        if self.flightModeService(custom_mode=\"OFFBOARD\") == True:\n            rospy.loginfo(\"Flight mode changed to OFFBOARD\")\n            return True\n        else:\n            rospy.logerr(\"Failed to change flight mode to OFFBOARD\")\n            return False\n    elif self.flightMode == \"AUTO.LAND\":\n        if self.flightModeService(custom_mode=\"AUTO.LAND\") == True:\n            rospy.loginfo(\"Flight mode changed to AUTO.LAND\")\n            return True\n        else:\n            rospy.logerr(\"Failed to change flight mode to AUTO.LAND\")\n            return False\n    elif self.flightMode == \"RTL\":\n        if self.flightModeService(custom_mode=\"RTL\") == True:\n            rospy.loginfo(\"Flight mode changed to RTL\")\n            return True\n        else:\n            rospy.logerr(\"Failed to change flight mode to RTL\")\n            return False\n    elif self.flightMode == \"ACRO\":\n        if self.flightModeService(custom_mode=\"ACRO\") == True:\n            rospy.loginfo(\"Flight mode changed to ACRO\")\n            return True\n        else:\n            rospy.logerr(\"Failed to change flight mode to ACRO\")\n            return False\n    elif self.flightMode == \"ALTCTL\":\n        if self.flightModeService(custom_mode=\"ALTCTL\") == True:\n            rospy.loginfo(\"Flight mode changed to ALTCTL\")\n            return True\n        else:\n            rospy.logerr(\"Failed to change flight mode to ALTCTL\")\n            return False\n    elif self.flightMode == \"POSCTL\":\n        if self.flightModeService(custom_mode=\"POSCTL\") == True:\n            rospy.loginfo(\"Flight mode changed to POSCTL\")\n            return True\n        else:\n            rospy.logerr(\"Failed to change flight mode to POSCTL\")\n            return False\n    elif self.flightMode == \"MANUAL\":\n        if self.flightModeService(custom_mode=\"", "CodeBleu_score": 32.029743777898645}, {"code": "def flight_mode_switch(self)\n\t\n    # Get current flight mode\n    flightMode = self.flightModeService(0)\n    flightMode = flightMode.mode\n    # If the vehicle is in HOVER mode, set the hover flag to 1 and call the hover method\n    if flightMode == \"HOVER\":\n        self.hoverFlag = 1\n        self.hover()\n        rospy.loginfo(\"Vehicle is in HOVER mode.\")\n        return True\n    # If the vehicle is not in HOVER mode, attempt to switch modes\n    else:\n        # Get the list of available flight modes\n        flightModes = self.flightModeService(1)\n        # If the mode switch is successful, print a success message and return True\n        if flightMode in flightModes.mode_list:\n            self.flightModeService(flightMode)\n            rospy.loginfo(\"Vehicle successfully switched to \" + flightMode + \" mode.\")\n            return True\n        # If the mode switch is unsuccessful, print a failure message and return False\n        else:\n            rospy.loginfo(\"Vehicle failed to switch to \" + flightMode + \" mode.\")\n            return False\n\n", "CodeBleu_score": 28.705321050288696}, {"code": "def flight_mode_switch(self)\n\t\n    rospy.wait_for_service('/mavros/set_mode')\n    try:\n        flightModeService = rospy.ServiceProxy('/mavros/set_mode', SetMode)\n        if self.flightMode == \"HOVER\":\n            self.hover_flag = 1\n            self.hover()\n            return True\n        else:\n            flightModeService(custom_mode=self.flightMode)\n            return True\n    except rospy.ServiceException as e:\n        print(\"Service call failed: %s\"%e)\n        return False\n\n", "CodeBleu_score": 38.415509004689255}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if not self.hover_flag and not self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = PoseStamped()\n        self.target_motion.pose.position.x = msg.linear.x\n        self.target_motion.pose.position.y = msg.linear.y\n        self.target_motion.pose.position.z = msg.linear.z\n        self.target_motion.pose.orientation.x = 0\n        self.target_motion.pose.orientation.y = 0\n        self.target_motion.pose.orientation.z = msg.angular.z\n        self.target_motion.pose.orientation.w = 0\n        self.target_motion.header.frame_id = 'enu'\n\n", "CodeBleu_score": 43.891461603837314}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_pose.position.x = msg.linear.x\n        self.target_pose.position.y = msg.linear.y\n        self.target_pose.position.z = msg.linear.z\n        self.target_pose.orientation.x = msg.angular.x\n        self.target_pose.orientation.y = msg.angular.y\n        self.target_pose.orientation.z = msg.angular.z\n        self.target_pose.orientation.w = 0.0\n        self.target_pose.position.z = 0.0\n        self.target_pose.orientation.w = 1.0\n\n", "CodeBleu_score": 27.545154808981014}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.angular.z)\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion.position.x = msg.linear.x\n        self.target_motion.position.y = msg.linear.y\n        self.target_motion.position.z = msg.linear.z\n        self.target_motion.orientation = Quaternion(axis=[0, 0, 1], angle=msg.angular.z).elements\n        self.target_motion.type_mask = 64 + 128 + 16 + 2 + 1\n        self.target_motion.yaw = msg.angular.z\n        self.target_motion.yaw_rate = msg.linear.x\n\n", "CodeBleu_score": 43.41138628264722}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != 'HOVER':\n        if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02) or (abs(w) > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.set_mode(self.flight_mode)\n            rospy.loginfo('Transitioning to OFFBOARD')\n        elif self.hover_flag == 0:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.set_mode(self.flight_mode)\n            rospy.loginfo('Transitioning to HOVER')\n            self.hover()\n\n", "CodeBleu_score": 57.862919516291434}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode == \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.set_mode(custom_mode=\"OFFBOARD\")\n            self.rate.sleep()\n        else:\n            self.rate.sleep()\n    else:\n        if self.hover_flag == 1:\n            self.set_mode(custom_mode=\"HOVER\")\n            self.flight_mode = \"HOVER\"\n            self.hover_flag = 0\n            self.rate.sleep()\n        else:\n            self.rate.sleep()\n\n", "CodeBleu_score": 63.27451163196013}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != \"HOVER\":\n        if (\n            abs(x) > 0.02\n            or abs(y) > 0.02\n            or abs(z) > 0.02\n            or abs(w) > 0.005\n        ):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            rospy.loginfo(\n                \"Drone state transition: OFFBOARD\"\n            )\n            return\n        else:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            rospy.loginfo(\n                \"Drone state transition: HOVER\"\n            )\n            return\n    else:\n        if (\n            abs(x) < 0.02\n            and abs(y) < 0.02\n            and abs(z) < 0.02\n            and abs(w) < 0.005\n        ):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            rospy.loginfo(\n                \"Drone state transition: OFFBOARD\"\n            )\n            return\n        else:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            rospy.loginfo(\n                \"Drone state transition: HOVER\"\n            )\n            return\n\n", "CodeBleu_score": 58.28867876404254}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 24.58575872254351}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw_pitch_roll[0]\n    else:\n        q_yaw = Quaternion(q.w, q.x, q.y, q.z)\n        yaw = q_yaw.yaw_pitch_roll[0]\n    return yaw\n\n", "CodeBleu_score": 61.38178689352573}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 24.58575872254351}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.frame = \"BODY_NED\"\n    self.motion_type = \"HOVER\"\n    self.target_motion = PositionTarget()\n    self.target_motion.coordinate_frame = self.frame\n    self.target_motion.type_mask = self.motion_type\n    self.target_motion.position.x = self.current_pose.pose.position.x\n    self.target_motion.position.y = self.current_pose.pose.position.y\n    self.target_motion.position.z = self.current_pose.pose.position.z\n    self.target_motion.yaw = self.current_pose.pose.orientation.z\n    self.target_motion.yaw_rate = 0.0\n    self.target_motion.velocity.x = 0.0\n    self.target_motion.velocity.y = 0.0\n    self.target_motion.velocity.z = 0.0\n    self.target_motion.acceleration_or_force.x = 0.0\n    self.target_motion.acceleration_or_force.y = 0.0\n    self.target_motion.acceleration_or_force.z = 0.0\n    self.target_motion.yaw_rate = 0.0\n    self.target_motion.yaw = self.current_pose.pose.orientation.z\n    self.target_motion.yaw_rate = 0.0\n    self.target_motion.thrust = 0.0\n    self.target_motion.body_rate.x = 0.0\n    self.target_motion.body_rate.y = 0.0\n    self.target_motion.body_rate.z = 0.0\n    self.target_motion.thrust = 0.0\n    self.target_motion.type_mask = self.motion_type\n    rospy.loginfo(\"Vehicle Type: %s\", self.vehicle_type)\n    rospy.loginfo(\"Vehicle ID: %s\", self.vehicle_id)\n    rospy.loginfo(\"Vehicle Mode: %s\", self.flight_mode)\n    self.pub_target_motion.publish(self.target_motion)\n\n", "CodeBleu_score": 26.560444722549487}, {"code": "def hover(self)\n\t\n    self.motion_type = \"HOVER\"\n    self.frame = \"BODY\"\n    self.target_pose.header.frame_id = self.frame\n    self.target_pose.header.stamp = rospy.Time.now()\n    self.target_pose.pose.position.x = self.current_pose.pose.position.x\n    self.target_pose.pose.position.y = self.current_pose.pose.position.y\n    self.target_pose.pose.position.z = self.current_pose.pose.position.z\n    self.target_pose.pose.orientation = self.current_pose.pose.orientation\n    self.target_pose.pose.orientation.w = 1\n    self.target_pose.pose.orientation.x = 0\n    self.target_pose.pose.orientation.y = 0\n    self.target_pose.pose.orientation.z = 0\n    self.target_pose.pose.orientation = self.target_pose.pose.orientation.rotate(\n        Quaternion(axis=[0, 0, 1], angle=self.yaw))\n    self.target_pose.pose.position.x = self.target_pose.pose.position.x + 1\n    self.target_pose.pose.position.y = self.target_pose.pose.position.y + 1\n    self.target_pose.pose.position.z = self.target_pose.pose.position.z + 1\n    self.target_pose.pose.orientation = self.target_pose.pose.orientation.rotate(\n        Quaternion(axis=[0, 0, 1], angle=self.yaw))\n    self.target_pose.pose.position.x = self.target_pose.pose.position.x + 1\n    self.target_pose.pose.position.y = self.target_pose.pose.position.y + 1\n    self.target_pose.pose.position.z = self.target_pose.pose.position.z + 1\n    self.target_pose.pose.orientation = self.target_pose.pose.orientation.rotate(\n        Quaternion(axis=[0, 0, 1], angle=self.yaw))\n    self.target_pose.pose.position.x = self.target_pose.pose", "CodeBleu_score": 23.169333922281243}, {"code": "def hover(self)\n\t\n    rospy.wait_for_service('mavros/cmd/arming')\n    armService = rospy.ServiceProxy('mavros/cmd/arming', CommandBool)\n    armService(True)\n    rospy.wait_for_service('mavros/set_mode')\n    flightModeService = rospy.ServiceProxy('mavros/set_mode', SetMode)\n    flightModeService(custom_mode='AUTO.LAND')\n    print(\"Vehicle type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight mode: \", \"AUTO.LAND\")\n    return\n\n", "CodeBleu_score": 20.98658589660953}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == \"HOVER\":\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            rospy.loginfo(\"Flight mode switched to %s\", self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.logerr(\"Service call failed: %s\", e)\n            return False\n", "CodeBleu_score": 39.44822293438761}, {"code": "def flight_mode_switch(self)\n\t\n\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            rospy.loginfo(\"Flight mode switched to \" + self.flight_mode)\n            return True\n        except rospy.ServiceException, e:\n            rospy.logerr(\"Failed to switch flight mode to \" + self.flight_mode + \". Error: \" + str(e))\n            return False\n\n", "CodeBleu_score": 37.18184794927604}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flightMode)\n            rospy.loginfo(\"Flight mode switched to %s\", self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.logerr(\"Service call failed: %s\", e)\n            return False\n", "CodeBleu_score": 46.534876077944546}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t numpy_visualize to visualize the numpy array.", "CodeBleu_score": 9.561121957548362}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t django_visualizer.py to visualize the game state.\"\"\"\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 68.86102603628619}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t argparse arguments.", "CodeBleu_score": 8.929131706617094}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == str(i):\n        self.local_pose = msg\n        self.global_pose = PoseStamped()\n        self.global_pose.pose.position.x = msg.pose.position.x + self.bias_x\n        self.global_pose.pose.position.y = msg.pose.position.y + self.bias_y\n        self.global_pose.pose.position.z = msg.pose.position.z + self.bias_z\n        self.global_pose.pose.orientation = msg.pose.orientation\n        self.global_pose.header = msg.header\n        if self.takeoff_target_pose.header.frame_id == str(i):\n            self.takeoff_target_pose = PoseStamped()\n            self.takeoff_target_pose.pose.position.x = msg.pose.position.x + self.bias_x\n            self.takeoff_target_pose.pose.position.y = msg.pose.position.y + self.bias_y\n            self.takeoff_target_pose.pose.position.z = msg.pose.position.z + self.bias_z\n            self.takeoff_target_pose.pose.orientation = msg.pose.orientation\n            self.takeoff_target_pose.header = msg.header\n        if self.hover_target_pose.header.frame_id == str(i):\n            self.hover_target_pose = PoseStamped()\n            self.hover_target_pose.pose.position.x = msg.pose.position.x + self.bias_x\n            self.hover_target_pose.pose.position.y = msg.pose.position.y + self.bias_y\n            self.hover_target_pose.pose.position.z = msg.pose.position.z + self.bias_z\n            self.hover_target_pose.pose.orientation = msg.pose.orientation\n            self.hover_target_pose.header = msg.header\n\n", "CodeBleu_score": 19.262269099621214}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == self.uav_id:\n        self.local_pose = msg.pose\n        self.local_pose_time = msg.header.stamp\n        self.local_pose_seq = msg.header.seq\n        self.local_pose_set = True\n        if self.ground_control_station_command == \"takeoff\":\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n            self.hover_target_pose.position.z = self.hover_target_pose.position.z + self.hover_target_pose.position.z * self.hover_target_pose_z_bias\n            self.hover_target_pose.orientation.w = 1.0\n        elif self.ground_control_station_command == \"hover\":\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n            self.hover_target_pose.position.z = self.hover_target_pose.position.z + self.hover_target_pose.position.z * self.hover_target_pose_z_bias\n            self.hover_target_pose.orientation.w = 1.0\n        elif self.ground_control_station_command == \"land\":\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n            self.hover_target_pose.position.z = self.hover_target_pose.position.z + self.hover_target_pose.position.z * self.hover_target_pose_z_bias\n            self.hover_target_pose.orientation.w = 1.0\n        elif self.ground_control_station_command == \"stop\":\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n            self.hover_target_pose.position.z = self.hover_target_pose.position.z + self.hover_target_pose.position.z * self.hover_target_pose_z_bias\n            self.hover_target_pose.orientation.w = 1.0\n        elif self.ground_control_station_command == \"emergency\":\n            self.hover_target_pose = copy.deepcopy(self", "CodeBleu_score": 23.105008407909743}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.id:\n        self.local_pose = msg\n        self.local_pose.pose.position.x = self.local_pose.pose.position.x + self.bias_x\n        self.local_pose.pose.position.y = self.local_pose.pose.position.y + self.bias_y\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z + self.bias_z\n        self.global_pose = copy.deepcopy(self.local_pose)\n        if self.takeoff_target_pose is not None:\n            self.global_pose.pose.position.x = self.takeoff_target_pose.pose.position.x\n            self.global_pose.pose.position.y = self.takeoff_target_pose.pose.position.y\n            self.global_pose.pose.position.z = self.takeoff_target_pose.pose.position.z\n        elif self.hover_target_pose is not None:\n            self.global_pose.pose.position.x = self.hover_target_pose.pose.position.x\n            self.global_pose.pose.position.y = self.hover_target_pose.pose.position.y\n            self.global_pose.pose.position.z = self.hover_target_pose.pose.position.z\n\n", "CodeBleu_score": 25.053997162646052}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.arm_state and self.local_pose.pose.position.z > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 63.74420584470499}, {"code": "def takeoff_detection(self)\n\t\n    if self.arm_state and self.alt > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 56.89435026855273}, {"code": "def takeoff_detection(self)\n\t\n    if self.arm_state == True and self.current_alt > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 60.50276333252409}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Create empty distance matrix\n    dist_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    # Loop through all UAVs in the original formation\n    for i in range(len(orig_formation)):\n        # Loop through all UAVs in the changed formation\n        for j in range(len(change_formation)):\n            # Calculate Euclidean distance between UAVs\n            dist = numpy.linalg.norm(orig_formation[i] - change_formation[j])\n            # Adjust distance by subtracting from 50\n            dist = dist - 50\n            # Convert distance to integer\n            dist = int(dist)\n            # Add distance to distance matrix\n            dist_matrix[i][j] = dist\n    # Return distance matrix\n    return dist_matrix\n", "CodeBleu_score": 26.983481712970192}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation = numpy.array(orig_formation)\n    change_formation = numpy.array(change_formation)\n    dist_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = numpy.linalg.norm(orig_formation[i]-change_formation[j])\n    dist_matrix = dist_matrix - 50\n    dist_matrix = dist_matrix.astype(int)\n    return dist_matrix\n", "CodeBleu_score": 23.283673873823453}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = []\n    for i in range(len(orig_formation)):\n        row = []\n        for j in range(len(orig_formation)):\n            row.append(50 - int(numpy.linalg.norm(orig_formation[i] - change_formation[j])))\n        distance_matrix.append(row)\n    return distance_matrix\n", "CodeBleu_score": 24.69975758253989}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    if self.left_visited[i] == False:\n        self.left_visited[i] = True\n        for j in range(self.num_of_vertices_right):\n            if self.right_visited[j] == False:\n                if self.right_labels[j] == self.left_labels[i] + 1:\n                    self.right_visited[j] = True\n                    if find_path(self, j):\n                        return True\n                    self.right_visited[j] = False\n                elif self.right_labels[j] == self.left_labels[i]:\n                    self.right_slack[j] = min(self.right_slack[j], self.left_labels[i] - self.right_labels[j] + 1)\n        if self.right_slack[i] > 0:\n            return False\n        else:\n            self.right_visited[i] = True\n            for j in range(self.num_of_vertices_left):\n                if self.left_visited[j] == False:\n                    if self.left_labels[j] == self.right_labels[i] - 1:\n                        self.left_visited[j] = True\n                        if find_path(self, j):\n                            return True\n                        self.left_visited[j] = False\n                    elif self.left_labels[j] == self.right_labels[i]:\n                        self.left_slack[j] = min(self.left_slack[j], self.right_labels[i] - self.left_labels[j] + 1)\n            if self.left_slack[i] > 0:\n                return False\n            else:\n                return True\n    else:\n        return False\n", "CodeBleu_score": 27.573698772755524}, {"code": "def find_path(self, i)\n\t\n    if self.left_visited[i] == 1:\n        return False\n    self.left_visited[i] = 1\n    for j in range(self.n):\n        if self.right_visited[j] == 0 and self.B[i][j] == 1:\n            self.right_visited[j] = 1\n            if self.gap[i][j] == 0:\n                if self.find_path(j):\n                    return True\n                else:\n                    self.right_visited[j] = 0\n                    self.slack[j] = min(self.slack[j], self.gap[i][j])\n            else:\n                self.slack[j] = min(self.slack[j], self.gap[i][j])\n    return False\n", "CodeBleu_score": 31.32177176928359}, {"code": "def find_path(self, i)\n\t\n    if self.left_visited[i] == True:\n        return False\n    self.left_visited[i] = True\n    for j in range(self.n):\n        if self.right_visited[j] == False:\n            gap = self.left_labels[i] - self.right_labels[j]\n            if gap == 0:\n                self.right_visited[j] = True\n                if self.find_path(j) == True:\n                    return True\n                else:\n                    self.right_visited[j] = False\n                    self.right_slack[j] = min(self.right_slack[j], gap)\n            else:\n                self.right_slack[j] = min(self.right_slack[j], gap)\n    return False\n", "CodeBleu_score": 35.72750244280614}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    # initialize slack variables\n    for i in range(len(self.uavs)):\n        self.uavs[i].slack = 0\n    # initialize visit arrays\n    for i in range(len(self.uavs)):\n        self.uavs[i].visited = False\n    for i in range(len(self.uavs)):\n        self.uavs[i].visited = False\n    # iterate over UAVs\n    for i in range(len(self.uavs)):\n        # initialize visit arrays\n        for j in range(len(self.uavs)):\n            self.uavs[j].visited = False\n        # find path for UAV i\n        self.find_path(i)\n    # adjust labels based on minimum slack value\n    for i in range(len(self.uavs)):\n        for j in range(len(self.uavs)):\n            if self.uavs[i].label == j and self.uavs[i].slack < self.uavs[j].slack:\n                self.uavs[j].label = i\n                self.uavs[i].label = j\n    # return match results\n    for i in range(len(self.uavs)):\n        if self.uavs[i].label != i:\n            return False\n    return True\n", "CodeBleu_score": 27.983817416758633}, {"code": "def KM(self)\n\t\n    #Initialize variables\n    for uav in range(len(self.uavs)):\n        self.uavs[uav].slack = 0\n        self.uavs[uav].visit = False\n    #Iterate over UAVs\n    for uav in range(len(self.uavs)):\n        #If a UAV has not been visited, find a path\n        if not self.uavs[uav].visit:\n            #Initialize variables\n            self.uavs[uav].visit = True\n            self.uavs[uav].path = []\n            #Iterate over UAVs\n            for uav2 in range(len(self.uavs)):\n                #If a UAV has not been visited and is not the current UAV, find a path\n                if not self.uavs[uav2].visit and uav != uav2:\n                    #Initialize variables\n                    self.uavs[uav2].visit = True\n                    self.uavs[uav2].path = []\n                    #Iterate over UAVs\n                    for uav3 in range(len(self.uavs)):\n                        #If a UAV has not been visited and is not the current UAV and is not the other UAV, find a path\n                        if not self.uavs[uav3].visit and uav != uav3 and uav2 != uav3:\n                            #Initialize variables\n                            self.uavs[uav3].visit = True\n                            self.uavs[uav3].path = []\n                            #If a path is found, return the path\n                            if self.findPath(uav, uav2, uav3):\n                                return self.uavs[uav].path\n                            #If a path is not found, adjust the labels\n                            else:\n                                self.uavs[uav3].visit = False\n                                self.uavs[uav3].path = []\n                                self.uavs[uav3].slack += min(self.uavs[uav].slack, self.uavs[uav2].slack)\n                                self.uavs[uav2].visit = False\n                                self.uavs[uav2].path = []\n                                self.uavs[uav2].slack += min(self.uavs[uav].slack", "CodeBleu_score": 26.65048734392041}, {"code": "def KM(self)\n\t\n    #initialize the match matrix to all zeros\n    match = numpy.zeros((self.n_drones,self.n_drones))\n    #initialize the slack matrix to all zeros\n    slack = numpy.zeros((self.n_drones,self.n_drones))\n    #initialize the visit matrix to all zeros\n    visit = numpy.zeros((self.n_drones,self.n_drones))\n    #initialize the label matrix to all zeros\n    label = numpy.zeros((self.n_drones,self.n_drones))\n    #initialize the uav_match matrix to all zeros\n    uav_match = numpy.zeros((self.n_drones,1))\n    #initialize the uav_visit matrix to all zeros\n    uav_visit = numpy.zeros((self.n_drones,1))\n    #initialize the uav_label matrix to all zeros\n    uav_label = numpy.zeros((self.n_drones,1))\n    #initialize the uav_slack matrix to all zeros\n    uav_slack = numpy.zeros((self.n_drones,1))\n    #initialize the uav_slack_min matrix to all zeros\n    uav_slack_min = numpy.zeros((self.n_drones,1))\n    #initialize the uav_slack_max matrix to all zeros\n    uav_slack_max = numpy.zeros((self.n_drones,1))\n    #initialize the uav_slack_min_index matrix to all zeros\n    uav_slack_min_index = numpy.zeros((self.n_drones,1))\n    #initialize the uav_slack_max_index matrix to all zeros\n    uav_slack_max_index = numpy.zeros((self.n_drones,1))\n    #initialize the uav_slack_max_index matrix to all zeros\n    uav_slack_max_index = numpy.zeros((self.n_drones,1))\n    #initialize the uav_slack_max_index matrix to all zeros\n    uav_slack_max_index = numpy.zeros((self.n_drones,1))\n    #initialize the uav_slack_max_index matrix to all zeros\n    uav_slack_max_", "CodeBleu_score": 15.678921769082658}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Create a mask for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower = np.array([15, 100, 100])\n    upper = np.array([35, 255, 255])\n    mask = cv2.inRange(hsv, lower, upper)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 37.33656916949024}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\nbool found = false;\n\ntry {\n\nstd::lock_guard<std::mutex> lock(tagDescriptionsMutex_);\n\nauto it = standalone_tag_descriptions_.find(tag_id);\n\nif (it != standalone_tag_descriptions_.end()) {\n\nfound = true;\n\ndescriptionContainer = it->second;\n\n}\n\n} catch (std::exception &e) {\n\nROS_ERROR_STREAM(\"TagDetector::findStandaloneTagDescription: \" << e.what());\n\n}\n\nreturn found;\n\n}", "CodeBleu_score": 36.182015362182}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tbool TagDetector::findStandaloneTagDescription(int tagID, apriltag_ros::AprilTagDetection &descriptionContainer, bool printWarning) {\n    if (standalone_tag_descriptions_.find(tagID) == standalone_tag_descriptions_.end()) {\n        if (printWarning) {\n            ROS_WARN(\"Could not find standalone tag description for tag with ID %d\", tagID);\n        }\n        return false;\n    }\n    descriptionContainer = standalone_tag_descriptions_[tagID];\n    return true;\n}\n", "CodeBleu_score": 53.3600278440614}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tauto it = standalone_tag_descriptions_.find(tagId);\n\tif (it == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tROS_WARN(\"No description found for tag ID %d\", tagId);\n\t\t}\n\t\treturn false;\n\t}\n\tdescriptionContainer = it->second;\n\treturn true;\n}", "CodeBleu_score": 36.48390514157454}]}
