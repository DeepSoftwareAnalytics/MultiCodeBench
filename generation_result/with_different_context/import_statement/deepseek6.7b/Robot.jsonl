{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> required_files;\n  for (const auto &file : carla::client::detail::Client::GetRequiredFiles(folder)) {\n    if (download) {\n      if (!carla::client::FileTransfer::Exists(file)) {\n        carla::client::FileTransfer::Download(file);\n      } else {\n        carla::log_info(\"File found in cache: \", file);\n      }\n    }\n    required_files.push_back(file);\n  }\n  return required_files;\n}", "CodeBleu_score": 49.319581903257316}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> files;\n  for (const auto &file : _file_transfer->GetRequiredFiles(folder)) {\n    if (download) {\n      const auto path = _file_transfer->GetFilePath(file);\n      if (!std::experimental::filesystem::exists(path)) {\n        _file_transfer->RequestFile(file);\n        log_debug(\"Downloading file: \", file);\n      } else {\n        log_debug(\"File found in cache: \", file);\n      }\n    }\n    files.emplace_back(file);\n  }\n  return files;\n}", "CodeBleu_score": 52.04284305568315}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\n  std::vector<std::string> required_files;\n  for (auto &file : rpc::Client::GetRequiredFiles(folder)) {\n    if (download) {\n      if (!FileTransfer::Exists(file)) {\n        FileTransfer::Download(file);\n        log_debug(\"Downloading: \", file);\n      } else {\n        log_debug(\"Found in cache: \", file);\n      }\n    }\n    required_files.push_back(file);\n  }\n  return required_files;\n}", "CodeBleu_score": 53.405716048302956}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.z != 0.0) {\n      log_warning(\"SpringArm attachment type cannot have non-zero translation in the 'z' axis\");\n    }\n  }\n  return SpawnActorWithParent_Internal(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 37.978967800655816}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.z == 0.0) {\n      std::cout << \"Warning: Spawning a vehicle with a SpringArm attachment type and a translation only in the 'z' axis is ill-formed. The vehicle will be spawned at the default location.\" << std::endl;\n    }\n  }\n  return SpawnActorWithParentInternal(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 44.01739492371607}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.z != 0.0) {\n      log_warning(\"The actor will be spawned with a SpringArm attachment type, but the actor's location is not at the origin. This may cause issues with the actor's positioning.\");\n    }\n  }\n  return SpawnActor(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 39.562087432642215}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token = _client.SubscribeToGBuffer(ActorId, GBufferId);\n  auto buffer = token.GetBuffer();\n  auto token_data = buffer.GetData();\n  _streaming_client.Subscribe(token_data, std::move(callback));\n}", "CodeBleu_score": 44.46180652673971}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n  auto response = _client.SubscribeToGBuffer(ActorId, GBufferId);\n  if (!response.IsSuccessful()) {\n    throw_exception(std::move(response).GetErrorMessage());\n  }\n  auto token = response.GetResult();\n  auto buffer = token.GetBuffer();\n  _streaming_client->SubscribeToGBuffer(token.GetToken(), std::move(buffer), std::move(callback));\n}", "CodeBleu_score": 45.18570239583145}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token = _client.SubscribeToGBuffer(ActorId, GBufferId);\n  auto token_data = token.Serialize();\n  _streaming_client->SubscribeToGBuffer(token_data, std::move(callback));\n}", "CodeBleu_score": 43.34471829649854}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (_navigation == nullptr) {\n    _navigation = std::make_shared<WalkerNavigation>(*this);\n  }\n  return _navigation;\n}", "CodeBleu_score": 25.8653801533543}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (auto navigation = GetWalkerNavigation()) {\n    return navigation;\n  }\n  auto navigation = std::make_shared<WalkerNavigation>(GetClient().GetEpisode());\n  SetWalkerNavigation(navigation);\n  return navigation;\n}", "CodeBleu_score": 34.18677845602956}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\n  if (this->navigation == nullptr) {\n    this->navigation = std::make_shared<WalkerNavigation>(*this->client);\n  }\n\n  return this->navigation;\n}", "CodeBleu_score": 17.298221196257956}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::steady_clock::now();\n  auto end = start + timeout;\n  while (episode.GetState().frame < frame) {\n    if (std::chrono::steady_clock::now() > end) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  if (episode.GetTrafficManager().IsEnabled()) {\n    episode.GetTrafficManager().Tick();\n  }\n  return true;\n}", "CodeBleu_score": 46.86864787532813}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\n  using namespace std::chrono_literals;\n\n  auto end_time = std::chrono::steady_clock::now() + timeout;\n\n  while (episode.GetState().GetFrame() < frame) {\n    if (std::chrono::steady_clock::now() >= end_time) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n\n  auto traffic_manager = episode.GetTrafficManager();\n  if (traffic_manager != nullptr) {\n    traffic_manager->Tick(frame);\n  }\n\n  return true;\n}", "CodeBleu_score": 45.653903435689166}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::steady_clock::now();\n  auto end = start + timeout;\n  while (episode.GetState().GetFrame() < frame) {\n    std::this_thread::yield();\n    if (std::chrono::steady_clock::now() > end) {\n      return false;\n    }\n  }\n  carla::trafficmanager::TrafficManager::Instance()->Tick(0.0f);\n  return true;\n}", "CodeBleu_score": 45.086234054112026}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    const auto episode_id = client.LoadEpisode(map_name, reset_settings, map_layers);\n    return EpisodeProxy(client, episode_id);\n}", "CodeBleu_score": 20.30612432892197}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  auto future = _client.LoadEpisode(map_name, reset_settings, map_layers);\n  return EpisodeProxy(future);\n}", "CodeBleu_score": 17.392943883908917}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n  // Load the episode.\n  auto episode = client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Wait for the episode to be loaded.\n  auto episode_id = episode.GetEpisodeId();\n  auto timeout = std::chrono::seconds(10);\n  auto start = std::chrono::steady_clock::now();\n  while (episode_id == episode.GetEpisodeId()) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    if (std::chrono::steady_clock::now() - start > timeout) {\n      throw_exception(std::runtime_error(\"Failed to load episode \" + map_name));\n    }\n  }\n\n  return episode;\n}", "CodeBleu_score": 43.609361404804645}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\n  auto walker = controller.GetWalker();\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"The walker is null.\"));\n  }\n  CARLA_ASSERT(episode != nullptr);\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(episode);\n  }\n  navigation->Register(walker->GetId(), controller.GetId());\n}", "CodeBleu_score": 66.17403239621716}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = controller.GetWalker();\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"Invalid walker\"));\n  }\n  CARLA_ASSERT(episode != nullptr);\n  if (walker->GetNavigation() == nullptr) {\n    auto navigation = std::make_shared<WalkerNavigation>(walker, *this);\n    walker->SetNavigation(navigation);\n  }\n  episode->RegisterAIController(controller.GetId(), walker);\n}", "CodeBleu_score": 60.506049070131354}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = controller.GetWalker();\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"Couldn't find walker for controller.\"));\n  }\n  CARLA_ASSERT(episode != nullptr);\n  if (walker->GetNavigation() == nullptr) {\n    walker->SetNavigation(std::make_shared<WalkerNavigation>(walker));\n  }\n  episode->RegisterAIController(controller.GetId());\n}", "CodeBleu_score": 60.759111737706384}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n  auto actor = ActorFactory::MakeActor(\n      blueprint,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n\n  if (actor == nullptr) {\n    throw_exception(std::make_exception_ptr(std::runtime_error(\"Failed to spawn actor\")));\n  }\n\n  actor->SetGarbageCollectionPolicy(gc);\n  actor->SetEpisode(GetEpisode());\n  actor->SetSimulator(this);\n  actor->SetActorId(GetNextActorId());\n  actor->SetActorType(blueprint.GetActorType());\n  actor->SetActorBlueprint(blueprint);\n  actor->SetActorTransform(transform);\n\n  if (actor->GetActorType() == ActorType::Vehicle) {\n    auto vehicle = static_cast<Vehicle *>(actor);\n    vehicle->SetActorBlueprint(blueprint);\n    vehicle->SetActorTransform(transform);\n  }\n\n  actor->SetActorId(GetNextActorId());\n  actor->SetActorType(blueprint.GetActorType());\n\n  auto actor_id = actor->GetActorId();\n  auto actor_type = actor->GetActorType();\n\n  auto actor_info = std::make_tuple(\n      actor_id,\n      actor_type,\n      blueprint.GetActorType(),\n      blueprint.GetActorStaticDescription(),\n      transform,\n      parent,\n      attachment_type,\n      socket_name,\n      gc);\n\n  auto future = GetEpisode().GetFuture<rpc::Actor>(\n      [actor_info](auto &&fut) {\n        auto actor_id = std::get<0>(actor_info);\n        auto actor_type = std::get<1>(actor_info);\n        auto blueprint = std::get<2>(actor_info);\n        auto static_description = std::get<3>(actor_info);\n        auto transform = std::get<4>(actor_info);\n        auto parent = std::", "CodeBleu_score": 45.80523764137722}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  auto actor = ActorFactory::MakeActor(\n      *this,\n      blueprint,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n  actor->SetGarbageCollectionPolicy(gc);\n  return actor;\n}", "CodeBleu_score": 24.172425308063488}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n  auto actor = _actor_factory->SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n\n  if (gc == GarbageCollectionPolicy::Always) {\n    _garbage_collector.RegisterActor(actor);\n  }\n\n  return actor;\n}", "CodeBleu_score": 27.309412882220773}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (!IsEpisodeRunning()) {\n    throw std::runtime_error(\"cannot subscribe to sensors when episode is not running\");\n  }\n  sensor.SubscribeToStream(\n        [this, callback](const std::vector<uint8_t> &data) {\n          try {\n            auto deserialized_data = sensor::Deserializer::Deserialize(data);\n            auto episode = GetCurrentEpisode();\n            if (episode != nullptr) {\n              deserialized_data->SetEpisode(episode);\n            }\n            callback(deserialized_data);\n          } catch (const std::exception &e) {\n            log_error(\"failed to deserialize sensor data:\", e.what());\n          }\n        });\n}", "CodeBleu_score": 42.56400972384101}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (IsEpisodeRunning() == false) {\n    throw std::runtime_error(\"Cannot subscribe to a sensor in a stopped episode\");\n  }\n  sensor.SubscribeToStream(\n        [=](const void *data, size_t size) {\n          auto episode = GetCurrentEpisode();\n          auto sensor_data = sensor::Deserializer::Deserialize(data, size);\n          if (sensor_data == nullptr) {\n            return;\n          }\n          sensor_data->SetEpisode(episode);\n          callback(sensor_data);\n        });\n}", "CodeBleu_score": 42.55371193917645}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (!IsEpisodeRunning()) {\n    throw std::runtime_error(\"Episode not running\");\n  }\n  auto future = client.SubscribeToStream(sensor.GetStreamToken());\n  auto handle = future.GetSharedFuture();\n  auto deserializer = sensor::Deserializer(sensor.GetDescription());\n  auto callback_wrapper = [handle, deserializer, callback, this]() {\n    try {\n      auto data = handle.Get();\n      auto sensor_data = deserializer.Deserialize(data);\n      sensor_data->episode = episode;\n      callback(std::move(sensor_data));\n    } catch (const std::exception &e) {\n      log_error(e.what());\n    }\n  };\n  handle.Subscribe(callback_wrapper);\n}", "CodeBleu_score": 53.844017413495024}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n  auto state = episode->GetState();\n  if (state == EpisodeState::Finished) {\n    return;\n  }\n  auto sim = episode->GetSimulator();\n  auto nav = episode->GetNavigation();\n  auto client = episode->GetClient();\n  auto vehicle_ids = sim->GetVehicles();\n  auto vehicle_transforms = sim->GetVehicleTransforms();\n  auto vehicle_speeds = sim->GetVehicleSpeeds();\n  auto walker_ids = sim->GetWalkers();\n  auto walker_transforms = sim->GetWalkerTransforms();\n  auto walker_speeds = sim->GetWalkerSpeeds();\n  auto walker_controllers = sim->GetWalkerControllers();\n  auto walker_controllers_to_destroy = std::vector<uint32_t>();\n  auto walker_controllers_to_remove = std::vector<uint32_t>();\n  auto walker_transforms_to_remove = std::vector<uint32_t>();\n  auto walker_speeds_to_remove = std::vector<uint32_t>();\n  auto walker_controllers_to_add = std::vector<uint32_t>();\n  auto walker_transforms_to_add = std::vector<carla::geom::Transform>();\n  auto walker_speeds_to_add = std::vector<float>();\n  auto walker_controllers_to_update = std::vector<uint32_t>();\n  auto walker_transforms_to_update = std::vector<carla::geom::Transform>();\n  auto walker_speeds_to_update = std::vector<float>();\n  auto vehicle_ids_to_remove = std::vector<uint32_t>();\n  auto vehicle_transforms_to_remove = std::vector<carla::geom::Transform>();\n  auto vehicle_speeds_to_remove = std::vector<float", "CodeBleu_score": 30.304166100693525}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n  auto walkers = episode->GetWalkers();\n\n  if (walkers.empty()) {\n    return;\n  }\n\n  auto state = episode->GetState();\n\n  for (auto it = walkers.begin(); it != walkers.end(); ) {\n    if (state->GetActor(*it) == nullptr) {\n      it = walkers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  auto simulator = episode->GetSimulator();\n  auto nav = simulator->GetNavigation();\n\n  auto transforms = simulator->GetActorTransforms(walkers);\n  auto speeds = simulator->GetActorVelocities(walkers);\n\n  nav->UpdateVehicles(transforms, speeds);\n  nav->UpdateCrowd();\n\n  for (auto &walker : walkers) {\n    auto transform = transforms.at(walker);\n    auto speed = speeds.at(walker);\n\n    auto control = rpc::WalkerControl(transform, speed);\n    simulator->SetWalkerControl(walker, control);\n  }\n\n  auto killed_walkers = nav->GetKilledWalkers();\n  for (auto &walker : killed_walkers) {\n    nav->RemoveWalker(walker);\n    simulator->DestroyActor(walker);\n  }\n}", "CodeBleu_score": 45.90978506990436}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  auto state = episode->GetState();\n  if (state == EpisodeState::Finished) {\n    return;\n  }\n\n  auto simulator = episode->GetClient().GetSimulator();\n\n  auto walker_controls = std::vector<rpc::WalkerControl>{};\n  auto walker_transforms = std::vector<rpc::Transform>{};\n  auto walker_speeds = std::vector<float>{};\n\n  for (auto walker : walkers) {\n    if (walker->IsAlive()) {\n      walker_controls.push_back(walker->GetControl());\n      walker_transforms.push_back(walker->GetTransform());\n      walker_speeds.push_back(walker->GetSpeed());\n    } else {\n      episode->RemoveWalker(walker);\n      walker->Destroy();\n    }\n  }\n\n  auto navigation = episode->GetNavigation();\n\n  navigation->UpdateVehicles(walker_transforms, walker_speeds);\n  navigation->UpdateCrowd(walker_transforms, walker_speeds);\n\n  simulator->ApplyWalkerControls(walker_controls);\n\n  for (auto walker : walkers) {\n    if (walker->IsAlive()) {\n      walker->SetTransform(navigation->GetTransform(walker->GetId()));\n    }\n  }\n}", "CodeBleu_score": 44.62264662642211}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.id = GetActorId();\n  description.uid = GetActorUid();\n  description.attributes.reserve(GetAttributes().size());\n  for (const auto &attribute : GetAttributes()) {\n    description.attributes.emplace_back(attribute.first, attribute.second);\n  }\n  return description;\n}", "CodeBleu_score": 65.9639701584931}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.id = _id;\n  description.uid = _uid;\n  description.attributes.reserve(_attributes.size());\n  for (auto &attribute : _attributes) {\n    description.attributes.emplace_back(attribute.MakeAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 71.89131443352312}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.id = GetActorId();\n  description.uid = GetActorUid();\n  description.attributes.reserve(attributes.size());\n  for (auto &&attribute : attributes) {\n    description.attributes.emplace_back(attribute.GetAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 65.30229071019504}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  auto blueprints = std::make_shared<BlueprintLibrary>();\n  for (auto &blueprint : *this) {\n    if (blueprint.HasAttribute(name)) {\n      const auto &attr = blueprint.GetAttribute(name);\n      if (attr.GetRecommendedValues().size() > 0) {\n        if (std::find(attr.GetRecommendedValues().begin(), attr.GetRecommendedValues().end(), value) != attr.GetRecommendedValues().end()) {\n          blueprints->emplace_back(blueprint);\n        }\n      } else if (attr.GetValue() == value) {\n        blueprints->emplace_back(blueprint);\n      }\n    }\n  }\n  return blueprints;\n}", "CodeBleu_score": 46.71583174344621}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (auto &bp : *this) {\n    if (bp.GetAttribute(name) == value) {\n      result->Add(bp);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 25.488293198249917}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (auto &bp : _blueprints) {\n    auto attribute = bp.GetAttribute(name);\n    if (attribute == nullptr) {\n      continue;\n    }\n    if (attribute->GetRecommendedValue() == value) {\n      result->Add(bp);\n    } else {\n      auto values = attribute->GetRecommendedValues();\n      if (std::find(values.begin(), values.end(), value) != values.end()) {\n        result->Add(bp);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 47.9386048213113}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string baseFolder = \"C:\\\\Users\\\\\" + getenv(\"USERNAME\") + \"\\\\Documents\\\\Carla\\\\\";\n    std::string filePath = baseFolder + path;\n    std::ofstream file(filePath, std::ios::binary | std::ios::trunc);\n    if (file.is_open()) {\n        file.write(reinterpret_cast<const char*>(&content[0]), content.size());\n        file.close();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 43.91608681267801}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string filePath = GetFullFilePath(path);\n    if (!ValidateFilePath(filePath)) {\n        return false;\n    }\n\n    std::ofstream file(filePath, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    file.write(reinterpret_cast<const char*>(content.data()), content.size());\n    file.close();\n    return true;\n}", "CodeBleu_score": 46.19609248955038}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    // Construct the full file path using the base folder and version information\n    std::string full_path = path + \"\\\\\" + CARLA_VERSION + \"\\\\\";\n\n    // Validate the file path\n    if (!FileTransfer::ValidateFilePath(full_path)) {\n        return false;\n    }\n\n    // Open the file in binary mode to truncate its contents\n    std::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n\n    // If the file is successfully opened, write the content and close the file\n    if (file.is_open()) {\n        file.write(reinterpret_cast<const char*>(&content[0]), content.size());\n        file.close();\n        return true;\n    }\n\n    // If the file cannot be opened, return false\n    return false;\n}", "CodeBleu_score": 44.690360410346855}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto &extents = _parent->GetBoundingBox().extent;\n  const auto &location = transform.location + _parent->GetBoundingBox().location;\n  const auto &yaw = transform.rotation.yaw;\n  return std::make_shared<const Bounds>(frame,\n                                        location,\n                                        extents,\n                                        yaw);\n}", "CodeBleu_score": 35.49924131052325}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto &extents = transform.location + transform.rotation.GetForwardVector() * _parent->GetBoundingBox().extent;\n  const auto &location = transform.location + transform.rotation.GetForwardVector() * _parent->GetBoundingBox().location;\n  const auto &yaw = transform.rotation.GetForwardVector().yaw;\n  return std::make_shared<Bounds>(frame,\n      location + geom::Location(extents.x, extents.y, extents.z),\n      location + geom::Location(-extents.x, -extents.y, extents.z),\n      location + geom::Location(-extents.x, extents.y, extents.z),\n      location + geom::Location(extents.x, -extents.y, extents.z),\n      yaw);\n}", "CodeBleu_score": 51.068043202270196}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  auto corners = transform.location + transform.rotation.GetForwardVector() * 0.5f * transform.GetScale();\n  corners += transform.rotation.GetRightVector() * 0.5f * transform.GetScale();\n  corners += transform.rotation.GetUpVector() * 0.5f * transform.GetScale();\n  corners -= transform.rotation.GetForwardVector() * 0.5f * transform.GetScale();\n  corners -= transform.rotation.GetRightVector() * 0.5f * transform.GetScale();\n  corners -= transform.rotation.GetUpVector() * 0.5f * transform.GetScale();\n  return std::make_shared<Bounds>(frame, std::move(corners));\n}", "CodeBleu_score": 30.52241363009512}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto lights_state = _simulator.QueryLightsState();\n  for (auto &light_state : lights_state) {\n    auto light_id = light_state.id;\n    auto it = _lights.find(light_id);\n    if (it == _lights.end()) {\n      _lights.emplace(light_id, std::make_shared<Light>(light_state, *this));\n    } else {\n      it->second->Update(light_state);\n    }\n  }\n}", "CodeBleu_score": 37.119171093687484}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto lights_state = _simulator->GetLightStates();\n  for (auto &light_state : lights_state) {\n    auto it = _lights.find(light_state.id);\n    if (it == _lights.end()) {\n      _lights.emplace(light_state.id, std::make_shared<Light>(this, light_state));\n    } else {\n      it->second->Update(light_state);\n    }\n  }\n}", "CodeBleu_score": 34.04408761477604}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> guard(_mutex);\n    const auto light_states = _simulator->QueryLightsState();\n    for (const auto &light_state : light_states) {\n        auto light_id = light_state.first;\n        auto light = _lights.find(light_id);\n        if (light == _lights.end()) {\n            light = _lights.emplace(light_id, std::make_unique<Light>(light_id, _simulator)).first;\n        }\n        light->second->SetState(light_state.second);\n    }\n}", "CodeBleu_score": 41.92901093152351}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(mutex);\n  if (dirty) {\n    auto msg = carla::rpc::LightStateList();\n    for (auto &light : lights) {\n      msg.lights.emplace_back(light->GetLightState());\n    }\n    if (discard_client) {\n      msg.discard_client = true;\n    }\n    sim->GetServer().Send(msg);\n    dirty = false;\n  }\n}", "CodeBleu_score": 32.7636864897356}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (discard_client) {\n    _server_lights_state = _client_lights_state;\n  }\n  if (_dirty) {\n    auto message = MakeLightState(_server_lights_state);\n    _simulator.GetServer().Send(message);\n    _dirty = false;\n  }\n}", "CodeBleu_score": 28.16828359165703}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  if (dirty) {\n    auto lights_state = std::make_unique<carla::rpc::LightStateList>();\n    for (auto &light : lights) {\n      auto light_state = light->GetLightState();\n      if (light_state != nullptr) {\n        lights_state->emplace_back(std::move(*light_state));\n      }\n    }\n    if (!lights_state->empty()) {\n      auto client = detail::Simulator::GetClient();\n      client->SetLightState(std::move(lights_state));\n    }\n    dirty = false;\n  }\n}", "CodeBleu_score": 32.82069899884196}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  if (sensor_id == \"sensor.other.v2x_custom\") {\n    //log_debug(\"ServerSideSensor::Send() called\");\n    //log_debug(\"ServerSideSensor::Send() sensor_id: \", sensor_id);\n    //log_debug(\"ServerSideSensor::Send() message: \", message);\n    //log_debug(\"ServerSideSensor::Send() sensor_context: \", sensor_context);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.id: \", sensor_context.id);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.type: \", sensor_context.type);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.parent_id: \", sensor_context.parent_id);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.parent_type: \", sensor_context.parent_type);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.parent_actor: \", sensor_context.parent_actor);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.parent_actor.id: \", sensor_context.parent_actor.id);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.parent_actor.type: \", sensor_context.parent_actor.type);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.parent_actor.name: \", sensor_context.parent_actor.name);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.parent_actor.parent_id: \", sensor_context.parent_actor.parent_id);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.parent_actor.parent_type: \", sensor_context.parent_actor.parent_type);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.parent_actor.parent_actor: \", sensor_context.parent_actor.parent_actor);\n    //log_debug(\"ServerSideSensor::Send() sensor_context.parent_actor.parent_actor.id: \", sensor_context.parent_actor.parent_actor.", "CodeBleu_score": 5.972973727167334}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    if (GetSensorId() != \"sensor.other.v2x_custom\") {\n        LOG_DEBUG(\"ServerSideSensor::Send: Sensor ID is not sensor.other.v2x_custom, skipping\");\n        return;\n    }\n    LOG_WARNING(\"ServerSideSensor::Send: Sensor ID is sensor.other.v2x_custom, sending message: \" + message);\n    GetEpisode().Send(GetSensorContext(), message);\n}", "CodeBleu_score": 53.25418986533981}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    if (sensor_id == \"sensor.other.v2x_custom\") {\n        LOG_DEBUG(\"Sending message to server: \" + message);\n        return;\n    }\n    if (sensor_id != \"sensor.other.v2x_custom\") {\n        LOG_WARN(\"Sensor ID does not match. Expected: sensor.other.v2x_custom, Got: \" + sensor_id);\n        return;\n    }\n    if (context == nullptr) {\n        LOG_ERROR(\"Context is null. Cannot send message.\");\n        return;\n    }\n    context->Send(message);\n}", "CodeBleu_score": 44.220032968025826}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    auto traffic_manager = trafficmanager::TrafficManager::GetInstance();\n    if (enabled) {\n        traffic_manager->RegisterVehicle(tm_port, _actor->GetId());\n    } else {\n        traffic_manager->UnregisterVehicle(_actor->GetId());\n    }\n}", "CodeBleu_score": 42.05010746982521}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    auto traffic_manager = trafficmanager::TrafficManager::GetInstance();\n    traffic_manager->RegisterVehicle(tm_port, _actor->GetId());\n  } else {\n    auto traffic_manager = trafficmanager::TrafficManager::GetInstance();\n    traffic_manager->UnregisterVehicle(_actor->GetId());\n  }\n}", "CodeBleu_score": 40.30016177443962}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\n  if (enabled) {\n    auto traffic_manager = trafficmanager::TrafficManager::GetInstance(tm_port);\n    traffic_manager->RegisterVehicle(this);\n  } else {\n    auto traffic_manager = trafficmanager::TrafficManager::GetInstance(tm_port);\n    traffic_manager->UnregisterVehicle(this);\n  }\n}", "CodeBleu_score": 43.3266484352563}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t  auto walker = GetWalker();\n  auto walker_id = walker->GetId();\n  auto walker_transform = walker->GetTransform();\n  auto walker_navigation = GetEpisode().Lock()->GetWalkerNavigation();\n  walker_navigation->AddWalker(walker_id, walker_transform.location);\n  walker->DisablePhysicsSimulation();\n  walker->DisableCollision();\n}", "CodeBleu_score": 43.26078141234817}, {"code": "void WalkerAIController::Start(){\n\t  auto walker = GetWalker();\n  auto walker_navigation = GetWalkerNavigation();\n  walker_navigation->Register(walker);\n  walker->SetSimulatePhysics(false);\n  walker->SetEnableCollisions(false);\n}", "CodeBleu_score": 29.072733849976835}, {"code": "void WalkerAIController::Start(){\n\t  auto walker = GetWalker();\n  if (walker == nullptr) {\n    return;\n  }\n  auto simulator = GetEpisode().GetSimulator();\n  auto navigation = simulator->GetNavigation();\n  navigation->AddWalker(walker);\n  walker->SetEnablePhysics(false);\n  walker->SetEnableCollision(false);\n}", "CodeBleu_score": 43.786665804413445}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (auto navigation = GetNavigation()) {\n    if (auto walker = navigation->GetParentWalker()) {\n      if (!navigation->SetMaxSpeed(max_speed)) {\n        UE_LOG(LogCarla, Warning,\n          TEXT(\"Could not set maximum speed for walker %s\"),\n          *walker->GetName());\n      }\n    } else {\n      UE_LOG(LogCarla, Warning,\n        TEXT(\"Could not find walker for navigation %s\"),\n        *navigation->GetName());\n    }\n  } else {\n    UE_LOG(LogCarla, Warning,\n      TEXT(\"Could not find navigation for walker controller %s\"),\n      *GetName());\n  }\n}", "CodeBleu_score": 46.0387873878691}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto *navigation = GetNavigation();\n  if (navigation == nullptr) {\n    log_error(\"WalkerAIController: SetMaxSpeed: Invalid navigation instance\");\n    return;\n  }\n  auto walker = GetWalker();\n  if (walker == nullptr) {\n    log_error(\"WalkerAIController: SetMaxSpeed: Walker not found\");\n    return;\n  }\n  if (!navigation->SetMaxSpeed(walker, max_speed)) {\n    log_error(\"WalkerAIController: SetMaxSpeed: Failed to set max speed\");\n  }\n}", "CodeBleu_score": 56.248937249933626}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav == nullptr) {\n    log_warning(\"Cannot set max speed: no navigation.\");\n    return;\n  }\n  auto walker = GetParent().Cast<Walker>();\n  if (walker == nullptr) {\n    log_warning(\"Cannot set max speed: not a walker.\");\n    return;\n  }\n  if (!nav->SetMaxSpeed(*walker, max_speed)) {\n    log_warning(\"Cannot set max speed.\");\n  }\n}", "CodeBleu_score": 63.48043732993892}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  auto previous_waypoints = _map->GetPreviousWaypoints(GetTransform(), distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  for (auto &waypoint : previous_waypoints) {\n    result.push_back(MakeShared<Waypoint>(Waypoint(waypoint, _map)));\n  }\n  return result;\n}", "CodeBleu_score": 56.64962684581476}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  auto waypoints = _parent_map->GetWaypoints(GetTransform().location, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  for (auto &wp : waypoints) {\n    result.push_back(std::make_shared<Waypoint>(wp, _parent_map));\n  }\n  return result;\n}", "CodeBleu_score": 56.0343513743838}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\n    auto waypoints = _map->GetPreviousWaypoints(SharedPtr<Waypoint>(this), distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    for (auto waypoint : waypoints) {\n        result.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n    }\n    return result;\n}", "CodeBleu_score": 58.90850641347248}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  auto signals = GetSignalsInDistance(distance);\n  std::unordered_set<SharedPtr<Signal>> unique_signals;\n  for (auto &signal : signals) {\n    if (signal->GetType() == SignalType::TrafficLight) {\n      auto traffic_light = std::static_pointer_cast<TrafficLightSignal>(signal);\n      if (traffic_light->GetState() != TrafficLightState::Red) {\n        unique_signals.insert(signal);\n      }\n    } else {\n      unique_signals.insert(signal);\n    }\n  }\n  std::vector<SharedPtr<Landmark>> result;\n  for (auto &signal : unique_signals) {\n    auto waypoint = GetMap()->GetWaypoint(signal->GetLocation());\n    if (waypoint != nullptr) {\n      if (stop_at_junction && waypoint->GetJunction() != nullptr) {\n        continue;\n      }\n      auto landmark = std::make_shared<Landmark>(\n            waypoint->GetMap(),\n            waypoint->GetTransform(),\n            waypoint->GetType(),\n            waypoint->GetId(),\n            signal);\n      result.emplace_back(landmark);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 48.766043560845816}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::unordered_set<SharedPtr<Signal>> signals;\n  std::vector<SharedPtr<Landmark>> result;\n  for (auto signal : GetSignalsInDistance(distance)) {\n    if (signals.count(signal) == 0u) {\n      signals.insert(signal);\n      auto waypoint = MakeShared<Waypoint>(\n          _map, signal->GetLocation(), _id, signal->GetType());\n      auto landmark = MakeShared<Landmark>(waypoint);\n      result.push_back(landmark);\n    }\n  }\n  if (stop_at_junction) {\n    auto junction = GetJunction();\n    if (junction != nullptr) {\n      auto landmark = MakeShared<Landmark>(junction);\n      result.push_back(landmark);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 51.774720981136404}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::unordered_set<SharedPtr<Signal>> signals;\n  auto signals_in_distance = GetSignalsInDistance(distance, stop_at_junction);\n  for (auto signal : signals_in_distance) {\n    if (signals.find(signal) == signals.end()) {\n      signals.insert(signal);\n      result.emplace_back(new Landmark(signal));\n    }\n  }\n  return result;\n}", "CodeBleu_score": 39.462438869811734}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  auto simulator = GetEpisode().Lock()->GetSimulator();\n  auto identifier = simulator->ApplySettings(settings);\n  auto client_timeout = timeout.is_zero() ? simulator->GetTimeout() : timeout;\n  auto client_delta_seconds = settings.fixed_delta_seconds;\n  if (client_delta_seconds > 0.0) {\n    auto server_delta_seconds = simulator->GetWorldInfo().fixed_delta_seconds;\n    auto max_attempts = static_cast<uint32_t>(client_timeout.total_seconds() / client_delta_seconds);\n    auto attempts = 0u;\n    auto delta_seconds = server_delta_seconds;\n    while (attempts++ < max_attempts && delta_seconds != client_delta_seconds) {\n      delta_seconds = simulator->GetWorldInfo().fixed_delta_seconds;\n      LOG_INFO(\"Fixed delta seconds:\", delta_seconds, \"(expected:\", client_delta_seconds, \")\");\n    }\n    if (attempts >= max_attempts) {\n      LOG_WARNING(\"Failed to apply fixed delta seconds:\", client_delta_seconds);\n    }\n  }\n  return identifier;\n}", "CodeBleu_score": 46.200819983596375}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\n  auto future = _simulator.ApplySettings(settings);\n  auto status = future.wait_for(timeout);\n  if (status != std::future_status::ready) {\n    log_warning(\"Episode settings not applied:\", status);\n  }\n  return future.get();\n}", "CodeBleu_score": 20.038231283844976}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\n  using namespace std::chrono;\n  auto start = steady_clock::now();\n  auto end = start + timeout;\n  auto now = steady_clock::now();\n  uint64_t identifier = 0u;\n  while (now < end) {\n    try {\n      identifier = detail::Simulator::ApplySettings(GetEpisode(), settings);\n      break;\n    } catch (std::exception &e) {\n      log_warning(\"failed to apply settings:\", e.what());\n    }\n    now = steady_clock::now();\n  }\n  if (identifier == 0u) {\n    log_warning(\"failed to apply settings after\", timeout);\n  }\n  return identifier;\n}", "CodeBleu_score": 32.6623576744716}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  const Vector2D &point,\n  const Vector2D &start,\n  const Vector2D &end\n}", "CodeBleu_score": 10.887596618166627}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    const Vector2D &segment_start,\n    const Vector2D &segment_end,\n    const Vector2D &point\n}", "CodeBleu_score": 11.307577384981988}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    float const px, float const py,\n    float const x0, float const y0,\n    float const x1, float const y1\n}", "CodeBleu_score": 14.456096114785485}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  // Assert that there are at least three vertices.\n  if (vertices.size() < 3) {\n    return;\n  }\n  // Record the initial index.\n  const auto initial_index = vertices_.size();\n  // Add the vertices to the mesh.\n  vertices_.insert(vertices_.end(), vertices.begin(), vertices.end());\n  // Add indices to form triangles.\n  for (size_t i = 1; i < vertices.size() - 1; ++i) {\n    indices_.push_back(initial_index);\n    indices_.push_back(initial_index + i);\n    indices_.push_back(initial_index + i + 1);\n  }\n}", "CodeBleu_score": 48.10059058785644}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  // Assert that there are at least three vertices.\n  CARLA_CHECK(vertices.size() >= 3);\n\n  // Record the initial index.\n  const auto initial_index = vertices_.size();\n\n  // Add the vertices to the mesh.\n  vertices_.insert(vertices_.end(), vertices.begin(), vertices.end());\n\n  // Iteratively add indices to form triangles, connecting the initial vertex with each subsequent pair of vertices in the list.\n  for (auto i = initial_index + 2u; i < vertices_.size(); ++i) {\n    indices_.emplace_back(initial_index);\n    indices_.emplace_back(i - 1u);\n    indices_.emplace_back(i);\n  }\n}", "CodeBleu_score": 51.10072029824755}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  // Assert that there are at least three vertices in the list\n  if (vertices.size() < 3) {\n    return;\n  }\n\n  // Record the initial index\n  const auto initial_index = _vertices.size();\n\n  // Add the vertices to the mesh\n  _vertices.insert(_vertices.end(), vertices.begin(), vertices.end());\n\n  // Iterate through the list of vertices, adding indices to form triangles\n  for (auto i = 1u; i < vertices.size() - 1; ++i) {\n    AddTriangle(initial_index, initial_index + i, initial_index + i + 1);\n  }\n}", "CodeBleu_score": 43.02416910798244}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\n  if (message == nullptr) {\n    return;\n  }\n\n  boost::asio::post(strand, [this, message]() {\n    if (socket.is_open()) {\n      boost::asio::async_write(socket, boost::asio::buffer(message->GetData()),\n                               boost::asio::bind_executor(strand, [this, message](const boost::system::error_code &error, size_t bytes_transferred) {\n                                 HandleSent(message, error, bytes_transferred);\n                               }));\n    }\n  });\n}", "CodeBleu_score": 32.48432264660191}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\n  if (message == nullptr) {\n\n    CARLA_LOG_ERROR(\"Primary::Write\", \"Message is null\");\n\n    return;\n\n  }\n\n  boost::asio::post(strand, [this, message]() {\n\n    if (socket.is_open()) {\n\n      boost::asio::async_write(socket, boost::asio::buffer(message->GetData(), message->GetSize()), boost::asio::bind_executor(strand, [this](boost::system::error_code ec, std::size_t /*length*/) {\n\n        if (ec) {\n\n          CARLA_LOG_ERROR(\"Primary::Write\", \"Error sending message: \" << ec.message());\n\n          socket.close();\n\n        }\n\n      }));\n\n    }\n\n  });\n\n}", "CodeBleu_score": 34.66077241616715}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message == nullptr) {\n    carla::log_error(\"Primary::Write\", \"null message\");\n    return;\n  }\n  boost::asio::post(strand, [this, message]() {\n    if (!socket.is_open()) {\n      carla::log_error(\"Primary::Write\", \"socket not open\");\n      return;\n    }\n    socket.get_executor().bind([this, message]() {\n      boost::asio::steady_timer timer(socket.get_executor());\n      timer.expires_after(std::chrono::milliseconds(500));\n      timer.async_wait([this](const boost::system::error_code &error) {\n        if (error) {\n          carla::log_error(\"Primary::Write\", error.message());\n          return;\n        }\n        boost::asio::async_write(socket, boost::asio::buffer(message->data),\n                                 boost::asio::bind_executor(strand, [this](const boost::system::error_code &error, size_t) {\n                                   if (error) {\n                                     carla::log_error(\"Primary::Write\", error.message());\n                                     return;\n                                   }\n                                   carla::log_debug(\"Primary::Write\", \"sent\");\n                                 }));\n      });\n    });\n  });\n}", "CodeBleu_score": 36.17519002052096}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\n  if (ec) {\n\n    LOG_ERROR(\"Error closing socket: \", ec.message());\n\n  }\n\n  if (socket.is_open()) {\n\n    boost::system::error_code ec;\n\n    socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n    if (ec) {\n\n      LOG_ERROR(\"Error shutting down socket: \", ec.message());\n\n    }\n\n    socket.close(ec);\n\n    if (ec) {\n\n      LOG_ERROR(\"Error closing socket: \", ec.message());\n\n    }\n\n  }\n\n  if (on_closed) {\n\n    on_closed();\n\n  }\n\n  LOG_INFO(\"Session closed\");\n\n}", "CodeBleu_score": 51.90569646085154}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\n  if (!ec && m_socket.is_open()) {\n\n    boost::system::error_code ignored_ec;\n\n    m_deadline.cancel(ignored_ec);\n\n    m_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\n    m_socket.close(ignored_ec);\n\n  }\n\n  if (m_on_closed) {\n\n    m_on_closed(ec);\n\n  }\n\n  LOG_INFO(\"Session closed.\");\n\n}", "CodeBleu_score": 56.87260416494255}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\n    if (ec) {\n\n        if (ec == boost::asio::error::operation_aborted) {\n\n            return;\n\n        }\n\n        Logging::error(\"Primary::CloseNow: \", ec.message());\n\n    }\n\n    if (socket.is_open()) {\n\n        boost::system::error_code ec;\n\n        socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n        if (ec) {\n\n            Logging::error(\"Primary::CloseNow: \", ec.message());\n\n        }\n\n        socket.close(ec);\n\n        if (ec) {\n\n            Logging::error(\"Primary::CloseNow: \", ec.message());\n\n        }\n\n    }\n\n    on_closed();\n\n    Logging::info(\"Primary::CloseNow: session closed\");\n\n}", "CodeBleu_score": 49.22792737256615}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t    carla::streaming::detail::tcp::Message message;\n    message.WriteCommand(carla::multigpu::commands::YOU_ALIVE);\n    message.WriteToken(carla::streaming::detail::Token::GetNext());\n    message.WriteInt(Primary::GetInstance().GetRouterCount());\n    for (int i = 0; i < Primary::GetInstance().GetRouterCount(); i++) {\n        message.WriteInt(Primary::GetInstance().GetRouter(i).GetId());\n    }\n    message.WriteInt(Primary::GetInstance().GetRouterCount());\n    for (int i = 0; i < Primary::GetInstance().GetRouterCount(); i++) {\n        message.WriteInt(Primary::GetInstance().GetRouter(i).GetId());\n    }\n    message.WriteInt(Primary::GetInstance().GetRouterCount());\n    for (int i = 0; i < Primary::GetInstance().GetRouterCount(); i++) {\n        message.WriteInt(Primary::GetInstance().GetRouter(i).GetId());\n    }\n    message.WriteInt(Primary::GetInstance().GetRouterCount());\n    for (int i = 0; i < Primary::GetInstance().GetRouterCount(); i++) {\n        message.WriteInt(Primary::GetInstance().GetRouter(i).GetId());\n    }\n    message.WriteInt(Primary::GetInstance().GetRouterCount());\n    for (int i = 0; i < Primary::GetInstance().GetRouterCount(); i++) {\n        message.WriteInt(Primary::GetInstance().GetRouter(i).GetId());\n    }\n    message.WriteInt(Primary::GetInstance().GetRouterCount());\n    for (int i = 0; i < Primary::GetInstance().GetRouterCount(); i++) {\n        message.WriteInt(Primary::GetInstance().GetRouter(i).GetId());\n    }\n    message.WriteInt(Primary::GetInstance().GetRouterCount());\n    for (int i = 0; i < Primary::GetInstance().GetRouterCount(); i++) {\n        message.WriteInt(Primary::GetInstance().GetRouter(i", "CodeBleu_score": 25.54039413019681}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  carla::streaming::detail::Token token = carla::streaming::detail::Token::Create();\n\n  carla::streaming::detail::tcp::Message message(carla::streaming::detail::tcp::Message::Command::YOU_ALIVE, token);\n\n  carla::Buffer buffer = message.Serialize();\n\n  carla::log_info(\"PrimaryCommands\", \"Sending IsAlive\");\n\n  Primary::GetInstance().GetRouter().Send(buffer, carla::streaming::detail::Router::Command::YOU_ALIVE);\n\n  carla::Buffer response = Primary::GetInstance().GetRouter().Receive(token);\n\n  carla::streaming::detail::tcp::Message responseMessage(response);\n\n  if (responseMessage.GetCommand() == carla::streaming::detail::tcp::Message::Command::YOU_ALIVE) {\n    carla::log_info(\"PrimaryCommands\", \"Received IsAlive\");\n  } else {\n    carla::log_error(\"PrimaryCommands\", \"Received unknown response\");\n  }\n}", "CodeBleu_score": 39.54043918110948}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  carla::streaming::detail::Token token;\n  carla::streaming::detail::tcp::Message message(token, carla::streaming::detail::Command::YOU_ALIVE);\n  auto buffer = message.Serialize();\n  auto router = carla::multigpu::Primary::GetInstance().GetRouter();\n  router->Write(buffer);\n  carla::multigpu::Router::Logging::LogSend(buffer);\n  auto response = router->Read();\n  carla::multigpu::Router::Logging::LogReceive(response);\n}", "CodeBleu_score": 38.65021622360177}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  bool found = false;\n  for (auto &server : primary->servers) {\n    if (server.second->sensor_ids.find(sensor_id) != server.second->sensor_ids.end()) {\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n    std::cerr << \"ERROR: Sensor \" << sensor_id << \" not found on any server\" << std::endl;\n    return;\n  }\n  auto buffer = carla::streaming::detail::tcp::Buffer::Create();\n  buffer->Write<stream_id>(sensor_id);\n  auto token = primary->router->SendCommand(Command::ENABLE_ROS, std::move(buffer));\n  auto response = token.Get();\n  if (response->GetStatus() == carla::streaming::detail::Status::OK) {\n    std::cout << \"Sensor \" << sensor_id << \" enabled on server \" << response->GetServerId() << std::endl;\n  } else {\n    std::cerr << \"ERROR: Failed to enable sensor \" << sensor_id << \" on server \" << response->GetServerId() << std::endl;\n  }\n}", "CodeBleu_score": 48.50215701561786}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  // Check if sensor is activated on any secondary server\n  if (primary->GetRouter()->GetSecondary(sensor_id) == nullptr) {\n    // If not, log error message\n    std::cerr << \"Error: Sensor \" << sensor_id << \" not found on any server\" << std::endl;\n    return;\n  }\n\n  // Create buffer with sensor ID\n  std::vector<uint8_t> buffer(sizeof(stream_id));\n  std::memcpy(buffer.data(), &sensor_id, sizeof(stream_id));\n\n  // Send ENABLE_ROS command to server using router\n  primary->GetRouter()->SendCommand(Command::ENABLE_ROS, buffer);\n\n  // Wait for and process server's response\n  auto response = primary->GetRouter()->WaitForResponse(Command::ENABLE_ROS);\n  if (response.first == Command::ENABLE_ROS) {\n    // If response is valid, log success message\n    std::cout << \"Sensor \" << sensor_id << \" enabled for ROS\" << std::endl;\n  } else {\n    // If response is invalid, log error message\n    std::cerr << \"Error: Failed to enable sensor \" << sensor_id << \" for ROS\" << std::endl;\n  }\n}", "CodeBleu_score": 49.082754437773986}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\n  // Check if the sensor is enabled on any secondary server\n  if (router->GetServerForSensor(sensor_id) == nullptr) {\n    LOG_ERROR(\"Sensor \" << sensor_id << \" not found on any server\");\n    return;\n  }\n\n  // Create a buffer with the sensor ID\n  carla::Buffer buffer;\n  buffer << sensor_id;\n\n  // Send an ENABLE_ROS command to the server using the router\n  router->SendCommand(buffer, carla::multigpu::Command::ENABLE_ROS);\n\n  // Wait for and process the server's response\n  router->ProcessServerResponse();\n}", "CodeBleu_score": 34.82512543990283}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t    if (primary->IsSensorActivated(sensor_id)) {\n        primary->log->info(\"GetToken({}): sensor already activated\", sensor_id);\n        return primary->GetToken(sensor_id);\n    }\n    else {\n        primary->log->info(\"GetToken({}): sensor not activated\", sensor_id);\n        primary->EnableSensor(sensor_id);\n        token_type token = primary->GetToken(sensor_id);\n        primary->UpdateMaps();\n        primary->log->info(\"GetToken({}): sensor activated\", sensor_id);\n        return token;\n    }\n}", "CodeBleu_score": 40.813479954047416}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\n    token_type token;\n\n    // Check if the sensor is already activated.\n    if (Primary::instance().GetRouter().IsSensorActivated(sensor_id)) {\n\n        // Get the token for the sensor.\n        token = Primary::instance().GetRouter().GetToken(sensor_id);\n\n        // Log the action.\n        LOG_DEBUG(\"GetToken: sensor_id = \" << sensor_id << \", token = \" << token);\n\n    } else {\n\n        // Enable the sensor on a secondary server.\n        Primary::instance().GetRouter().EnableSensor(sensor_id);\n\n        // Get the token for the sensor.\n        token = Primary::instance().GetRouter().GetToken(sensor_id);\n\n        // Update the maps.\n        Primary::instance().GetRouter().UpdateMaps();\n\n        // Log the action.\n        LOG_DEBUG(\"GetToken: sensor_id = \" << sensor_id << \", token = \" << token);\n\n    }\n\n    return token;\n\n}", "CodeBleu_score": 35.3445115258026}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  if (enabled_sensors.find(sensor_id) != enabled_sensors.end()) {\n    return enabled_sensors[sensor_id];\n  }\n  else {\n    token_type token = router.EnableSensor(sensor_id);\n    enabled_sensors[sensor_id] = token;\n    return token;\n  }\n}", "CodeBleu_score": 34.66898430886175}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\n  std::ifstream file(filename, std::ios::binary);\n  if (!file) {\n    return false;\n  }\n  std::vector<char> data((std::istreambuf_iterator<char>(file)),\n                         std::istreambuf_iterator<char>());\n  return Load(data);\n}", "CodeBleu_score": 52.231726489042686}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\n  std::ifstream file(filename, std::ios::binary | std::ios::ate);\n\n  if (!file.is_open()) {\n    return false;\n  }\n\n  std::streamsize size = file.tellg();\n  file.seekg(0, std::ios::beg);\n\n  std::vector<char> buffer(size);\n\n  if (!file.read(buffer.data(), size)) {\n    return false;\n  }\n\n  file.close();\n\n  return Load(buffer.data(), size);\n}", "CodeBleu_score": 58.922147898272726}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\n    std::ifstream file(filename.c_str(), std::ios::binary);\n    if (!file) {\n        carla::log_error(\"Could not open file:\", filename);\n        return false;\n    }\n    std::vector<uint8_t> data(std::istreambuf_iterator<char>(file), {});\n    file.close();\n\n    return Load(data);\n}", "CodeBleu_score": 58.047933875639515}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\n    if (!ready) {\n        return false;\n    }\n\n    if (crowd == nullptr) {\n        return false;\n    }\n\n    std::lock_guard<std::mutex> lock(mutex);\n\n    if (walker_manager.HasAgent(id)) {\n        walker_manager.RemoveAgent(id);\n        return true;\n    }\n\n    if (vehicle_manager.HasAgent(id)) {\n        vehicle_manager.RemoveAgent(id);\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 38.79127067474541}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (!IsReady()) {\n    return false;\n  }\n  if (crowd == nullptr) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lock(_mutex);\n  auto it = walker_mappings.find(id);\n  if (it != walker_mappings.end()) {\n    crowd->removeAgent(it->second);\n    walker_mappings.erase(it);\n    return true;\n  }\n  it = vehicle_mappings.find(id);\n  if (it != vehicle_mappings.end()) {\n    crowd->removeAgent(it->second);\n    vehicle_mappings.erase(it);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 59.8334696620476}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\n  if (!ready) {\n    return false;\n  }\n\n  if (crowd == nullptr) {\n    return false;\n  }\n\n  std::lock_guard<std::mutex> lock(mutex);\n\n  auto it = walker_map.find(id);\n  if (it != walker_map.end()) {\n    crowd->removeWalker(it->second);\n    walker_map.erase(it);\n    return true;\n  }\n\n  it = vehicle_map.find(id);\n  if (it != vehicle_map.end()) {\n    crowd->removeVehicle(it->second);\n    vehicle_map.erase(it);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 59.92628819012925}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    std::lock_guard<std::mutex> lock(vehicle_mutex);\n\n    std::set<int> current_vehicles;\n    for (auto &vehicle : this->vehicles) {\n        current_vehicles.insert(vehicle.first);\n    }\n\n    for (auto &vehicle : vehicles) {\n        if (current_vehicles.find(vehicle.id) != current_vehicles.end()) {\n            this->vehicles[vehicle.id].Update(vehicle);\n        } else {\n            this->vehicles[vehicle.id] = Vehicle(vehicle);\n        }\n    }\n\n    for (auto it = this->vehicles.begin(); it != this->vehicles.end();) {\n        if (current_vehicles.find(it->first) == current_vehicles.end()) {\n            it = this->vehicles.erase(it);\n        } else {\n            it->second.updated = false;\n            ++it;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 52.63590788902499}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t  std::lock_guard<std::mutex> lock(vehicle_mutex);\n  std::set<int> current_vehicles;\n  for (auto it = vehicle_map.begin(); it != vehicle_map.end(); it++) {\n    current_vehicles.insert(it->first);\n  }\n  for (auto it = vehicles.begin(); it != vehicles.end(); it++) {\n    if (vehicle_map.find(it->id) == vehicle_map.end()) {\n      // New vehicle\n      vehicle_map[it->id] = Vehicle(it->id, it->location, it->rotation, it->velocity);\n    } else {\n      // Existing vehicle\n      vehicle_map[it->id].location = it->location;\n      vehicle_map[it->id].rotation = it->rotation;\n      vehicle_map[it->id].velocity = it->velocity;\n      vehicle_map[it->id].updated = true;\n    }\n  }\n  for (auto it = current_vehicles.begin(); it != current_vehicles.end(); it++) {\n    if (vehicle_map[*it].updated == false) {\n      // Removed vehicle\n      vehicle_map.erase(*it);\n    } else {\n      // Updated vehicle\n      vehicle_map[*it].updated = false;\n    }\n  }\n  return true;\n}", "CodeBleu_score": 47.586622893579}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n    std::lock_guard<std::mutex> lock(vehicle_mutex);\n\n    // Collect IDs of currently mapped vehicles.\n    std::set<int> current_ids;\n    for (auto &vehicle : vehicle_map) {\n        current_ids.insert(vehicle.first);\n    }\n\n    // Add or update vehicles from the provided list.\n    for (auto &vehicle : vehicles) {\n        auto it = vehicle_map.find(vehicle.id);\n        if (it == vehicle_map.end()) {\n            // Add new vehicle.\n            vehicle_map[vehicle.id] = std::make_shared<Vehicle>(vehicle.id, vehicle.transform, vehicle.velocity);\n        } else {\n            // Update existing vehicle.\n            it->second->Update(vehicle.transform, vehicle.velocity);\n        }\n    }\n\n    // Remove vehicles that are not in the current frame.\n    for (auto it = vehicle_map.begin(); it != vehicle_map.end();) {\n        if (current_ids.find(it->first) == current_ids.end()) {\n            it = vehicle_map.erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 52.05206005882238}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n  // Get the actor from the mapped walkers and vehicles.\n  auto walker = walker_manager->GetWalker(id);\n  auto vehicle = vehicle_manager->GetVehicle(id);\n\n  // If the actor is not found in the mapped walkers and vehicles, return false.\n  if (walker == nullptr && vehicle == nullptr) {\n    return false;\n  }\n\n  // Enter a critical section to compute the squared distance and use the crowd system to determine if a vehicle is nearby.\n  std::lock_guard<std::mutex> lock(mutex);\n  auto squared_distance = direction.SquaredLength();\n  auto is_near = (walker != nullptr) ? walker->IsNear(squared_distance) : vehicle->IsNear(squared_distance);\n  return is_near;\n}", "CodeBleu_score": 46.15865775805072}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    auto actor = _world->GetActor(id);\n    if (actor == nullptr) {\n        return false;\n    }\n    auto walker = _walker_manager->GetWalker(actor);\n    if (walker != nullptr) {\n        return walker->IsNear(distance, direction);\n    }\n    auto vehicle = _vehicle_manager->GetVehicle(actor);\n    if (vehicle != nullptr) {\n        return vehicle->IsNear(distance, direction);\n    }\n    return false;\n}", "CodeBleu_score": 46.61182171503969}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t    std::lock_guard<std::mutex> lock(navigation_mutex);\n\n    auto walker = walker_manager.GetWalker(id);\n    if (walker != nullptr) {\n        return walker->HasVehicleNear(distance, direction);\n    }\n\n    auto vehicle = vehicles.find(id);\n    if (vehicle != vehicles.end()) {\n        return vehicle->second->HasVehicleNear(distance, direction);\n    }\n\n    return false;\n}", "CodeBleu_score": 50.40048128982595}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    // Get the current route point.\n    const auto &route_point = info.route_point;\n\n    // Create a WalkerEventVisitor with the current context.\n    WalkerEventVisitor visitor{id, info, delta};\n\n    // Use boost::variant2::visit to process the event at the current route point.\n    return boost::variant2::visit(visitor, route_point);\n}", "CodeBleu_score": 56.38682565592098}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  WalkerEventVisitor visitor(info, delta);\n  return boost::apply_visitor(visitor, info.current_event);\n}", "CodeBleu_score": 34.68115640592387}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\n  WalkerEventVisitor visitor(info, delta);\n  return boost::variant2::visit(visitor, info.route_point.event);\n}", "CodeBleu_score": 38.32453325779257}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  // Iterate through each road node\n  for (const pugi::xml_node &road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    // Get the road ID\n    const auto road_id = road_node.attribute(\"id\").as_int();\n\n    // Iterate through each lane section within the lanes node\n    for (const pugi::xml_node &lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      // Get the lane section ID\n      const auto lane_section_id = lane_section_node.attribute(\"s\").as_double();\n\n      // Get the left, center, and right lane nodes\n      const pugi::xml_node left_lanes_node = lane_section_node.child(\"left\");\n      const pugi::xml_node center_lanes_node = lane_section_node.child(\"center\");\n      const pugi::xml_node right_lanes_node = lane_section_node.child(\"right\");\n\n      // Parse the left lane nodes\n      ParseLanes(road_id, lane_section_id, left_lanes_node, map_builder, true, false);\n\n      // Parse the center lane nodes\n      ParseLanes(road_id, lane_section_id, center_lanes_node, map_builder, false, false);\n\n      // Parse the right lane nodes\n      ParseLanes(road_id, lane_section_id, right_lanes_node, map_builder, false, true);\n    }\n  }\n}", "CodeBleu_score": 52.135486792129306}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (auto &road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    auto road_id = road_node.attribute(\"id\").as_int();\n    for (auto &lanes_node : road_node.children(\"lanes\")) {\n      for (auto &lane_section_node : lanes_node.children(\"laneSection\")) {\n        auto lane_section = map_builder.GetLaneSection(road_id, lane_section_node.attribute(\"s\").as_double());\n        for (auto &left_lane_node : lane_section_node.children(\"left\")) {\n          ParseLanes(left_lane_node, lane_section, true, true);\n        }\n        for (auto &center_lane_node : lane_section_node.children(\"center\")) {\n          ParseLanes(center_lane_node, lane_section, true, false);\n        }\n        for (auto &right_lane_node : lane_section_node.children(\"right\")) {\n          ParseLanes(right_lane_node, lane_section, true, false);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 51.83223047343629}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const auto road_id = road_node.attribute(\"id\").as_int();\n    for (pugi::xml_node lane_section_node :\n         road_node.child(\"lanes\").children(\"laneSection\")) {\n      const auto lane_section = map_builder.CreateLaneSection(road_id);\n      for (pugi::xml_node lane_node : lane_section_node.children(\"lane\")) {\n        const auto lane_id = lane_node.attribute(\"id\").as_int();\n        const auto lane_type = lane_node.attribute(\"type\").as_string();\n        const auto lane_width = lane_node.attribute(\"width\").as_double();\n        const auto lane_level = lane_node.attribute(\"level\").as_double();\n        const auto lane_material = lane_node.attribute(\"material\").as_string();\n        const auto lane_speed = lane_node.attribute(\"speed\").as_double();\n        const auto lane_access = lane_node.attribute(\"access\").as_string();\n        const auto lane_height = lane_node.attribute(\"height\").as_double();\n        const auto lane_curb = lane_node.attribute(\"curb\").as_string();\n        const auto lane_border = lane_node.attribute(\"border\").as_string();\n        const auto lane_border_sides =\n            lane_node.attribute(\"border_sides\").as_string();\n        const auto lane_border_type =\n            lane_node.attribute(\"border_type\").as_string();\n        const auto lane_border_width =\n            lane_node.attribute(\"border_width\").as_double();\n        const auto lane_border_height =\n            lane_node.attribute(\"border_height\").as_double();\n        const auto lane_border_depth =\n            lane_node.attribute(\"border_depth\").as_double();\n        const auto lane_border_offset =\n            lane_node.attribute(\"border_offset\").as_double();\n        const auto lane_border_smoothness =\n            lane_node.attribute(\"border_smooth", "CodeBleu_score": 34.82957494419001}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched = true;\n        std::cout << \"Publisher matched\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched = false;\n        std::cout << \"Publisher unmatched\" << std::endl;\n    } else {\n        std::cout << \"Publisher matched status changed\" << std::endl;\n    }\n}", "CodeBleu_score": 54.37135784080704}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched = true;\n        first_connection = true;\n    } else if (info.current_count_change == -1) {\n        matched = false;\n    } else {\n        std::cout << \"Invalid current_count_change \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 60.63291030400533}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched = true;\n        std::cout << \"CarlaListenerImpl::on_publication_matched - matched\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched = false;\n        std::cout << \"CarlaListenerImpl::on_publication_matched - unmatched\" << std::endl;\n    } else {\n        std::cout << \"CarlaListenerImpl::on_publication_matched - invalid count change\" << std::endl;\n    }\n}", "CodeBleu_score": 53.632900568375085}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched.\" << std::endl;\n        first_connected_ = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n        if (info.total_count == 0) {\n            std::cout << \"Subscriber destroyed.\" << std::endl;\n            reader->get_subscriber()->delete_datareader(reader);\n        }\n    } else {\n        std::cout << \"Invalid change in subscription count.\" << std::endl;\n    }\n}", "CodeBleu_score": 54.47809084520444}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched\" << std::endl;\n\n    if (info.current_count_change == 1) {\n        matched_count_++;\n        first_connected_ = true;\n    } else if (info.current_count_change == -1) {\n        matched_count_--;\n        if (matched_count_ <= 0) {\n            matched_count_ = 0;\n            first_connected_ = false;\n            if (subscriber_ != nullptr) {\n                subscriber_->destroy();\n                subscriber_ = nullptr;\n            }\n        }\n    } else {\n        std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: ERROR: invalid count change: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 53.03432577363626}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        if (first_connected_) {\n            std::cout << \"Subscriber matched with publisher\" << std::endl;\n        }\n        first_connected_ = true;\n    } else if (info.current_count_change == -1) {\n        if (info.total_count == 0) {\n            std::cout << \"Subscriber unmatched with publisher\" << std::endl;\n            reader->get_subscriber()->delete_datareader(reader);\n        }\n    } else {\n        std::cout << \"Invalid change in subscription count\" << std::endl;\n    }\n}", "CodeBleu_score": 54.307087147060486}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* myData = (CarlaCollisionEvent*) data;\n    if (force_md5 || DynamicTypes::keyDirty(myData->keyHash)) {\n        //Serialize the key into the member w/ the handle\n        force_md5 = DynamicTypes::serializeKey(myData->keyHash, myData->collision_id);\n        DynamicTypes::setKey(myData->keyHash);\n    }\n    *handle = DynamicTypes::get_instance_handle(myData->keyHash);\n    return (force_md5);\n}", "CodeBleu_score": 15.152075903597789}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* p_st = (CarlaCollisionEvent*) data;\n    (void)p_st;\n    (void)handle;\n    (void)force_md5;\n    return false;\n}", "CodeBleu_score": 10.25239791028325}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* myData = (CarlaCollisionEvent*)data;\n    if (force_md5 || !handle->isValid()) {\n        handle->value[0] = myData->object_id;\n        handle->value[1] = myData->other_object_id;\n        handle->value[2] = myData->collision_point.x;\n        handle->value[3] = myData->collision_point.y;\n        handle->value[4] = myData->collision_point.z;\n        handle->value[5] = myData->normal_impulse;\n        handle->value[6] = myData->tangent_impulse;\n        handle->value[7] = myData->lateral_impulse;\n        handle->value[8] = myData->contact_point.x;\n        handle->value[9] = myData->contact_point.y;\n        handle->value[10] = myData->contact_point.z;\n        handle->value[11] = myData->contact_normal.x;\n        handle->value[12] = myData->contact_normal.y;\n        handle->value[13] = myData->contact_normal.z;\n        handle->value[14] = myData->contact_friction;\n        handle->value[15] = myData->contact_restitution;\n        handle->value[16] = myData->contact_slip_speed;\n        handle->value[17] = myData->contact_slip_angle;\n        handle->value[18] = myData->contact_force.x;\n        handle->value[19] = myData->contact_force.y;\n        handle->value[20] = myData->contact_force.z;\n        handle->value[21] = myData->contact_torque.x;\n        handle->value[22] = myData->contact_torque.y;", "CodeBleu_score": 20.80613185136028}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        p_type->serialize(ser); // Serialize the object:\n        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n        return true;\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n}", "CodeBleu_score": 77.38074350906238}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        p_type->serialize(ser); // Serialize the object:\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    payload->length = (uint32_t) ser.getSerializedDataLength(); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 76.72238634899273}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    // Serialize the object.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    return ser.serialize(*p_type);\n}", "CodeBleu_score": 57.8605371971282}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\n    if (target_sysid != 0) {\n        return;\n    }\n\n    switch (msg.msgid) {\n        case MAVLINK_MSG_ID_ATTITUDE: {\n            mavlink_attitude_t att;\n            mavlink_msg_attitude_decode(&msg, &att);\n            target_sysid = att.target_system;\n            break;\n        }\n\n        case MAVLINK_MSG_ID_LOCAL_POSITION_NED: {\n            mavlink_local_position_ned_t pos;\n            mavlink_msg_local_position_ned_decode(&msg, &pos);\n            target_sysid = pos.target_system;\n            break;\n        }\n\n        case MAVLINK_MSG_ID_GLOBAL_POSITION_INT: {\n            mavlink_global_position_int_t pos;\n            mavlink_msg_global_position_int_decode(&msg, &pos);\n            target_sysid = pos.target_system;\n            break;\n        }\n\n        case MAVLINK_MSG_ID_SCALED_PRESSURE: {\n            mavlink_scaled_pressure_t press;\n            mavlink_msg_scaled_pressure_decode(&msg, &press);\n            target_sysid = press.target_system;\n            break;\n        }\n\n        default:\n            return;\n    }\n\n    tracker.request_stream(target_sysid, MAV_COMP_ID_ALL, MAV_STREAM_POSITION, 1000);\n    tracker.request_stream(target_sysid, MAV_COMP_ID_ALL, MAV_STREAM_EXTRA1, 1000);\n    tracker.request_stream(target_sysid, MAV_COMP_ID_ALL, MAV_STREAM_EXTRA2, 1000);\n\n    target_set = true;\n}", "CodeBleu_score": 39.06805048174501}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // Check if the target is already set\n    if (target_sysid != 0) {\n        return;\n    }\n\n    // Decode the message\n    mavlink_msg_to_send_buffer(mavlink_buffer, msg);\n    mavlink_status_t status;\n    mavlink_message_t message;\n    mavlink_parse_char(MAVLINK_COMM_0, mavlink_buffer[0], &message, &status);\n\n    // Check if the message type is one that should be tracked\n    if (message.msgid != MAVLINK_MSG_ID_HEARTBEAT &&\n        message.msgid != MAVLINK_MSG_ID_ATTITUDE &&\n        message.msgid != MAVLINK_MSG_ID_LOCAL_POSITION_NED &&\n        message.msgid != MAVLINK_MSG_ID_SYS_STATUS &&\n        message.msgid != MAVLINK_MSG_ID_VFR_HUD) {\n        return;\n    }\n\n    // Set the target system ID\n    target_sysid = message.sysid;\n\n    // Request position and air pressure data streams from the target\n    mavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_COMPONENT_ID_ALL,\n                                         MAV_DATA_STREAM_POSITION, 10, 1);\n    mavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_COMPONENT_ID_ALL,\n                                         MAV_DATA_STREAM_EXTRA1, 10, 1);\n\n    // Flag that the target has been set\n    target_set = true;\n}", "CodeBleu_score": 31.330171712574284}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // If the target is already set, exit immediately\n    if (target_system_id != 0) {\n        return;\n    }\n\n    // Decode the MAVLink message\n    mavlink_msg_decode(&msg, &target_system_id);\n\n    // Exit if the message type is not one that should be tracked\n    if (msg.msgid != MAVLINK_MSG_ID_HEARTBEAT &&\n        msg.msgid != MAVLINK_MSG_ID_ATTITUDE &&\n        msg.msgid != MAVLINK_MSG_ID_LOCAL_POSITION_NED &&\n        msg.msgid != MAVLINK_MSG_ID_VFR_HUD) {\n        return;\n    }\n\n    // If the target system ID is not set, set it to the target and request position and air pressure data streams from the target\n    if (target_system_id == 0) {\n        target_system_id = msg.sysid;\n        mavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_system_id, MAVLINK_COMPONENT_ID_ALL, MAV_DATA_STREAM_POSITION, 10, 1);\n        mavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_system_id, MAVLINK_COMPONENT_ID_ALL, MAV_DATA_STREAM_EXTRA1, 10, 1);\n    }\n\n    // Flag that the target has been set\n    target_set = true;\n}", "CodeBleu_score": 46.22145188179624}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT res = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (res == MAV_RESULT_ACCEPTED) {\n        _motors->set_alt_cal_needed(true);\n    }\n    return res;\n}", "CodeBleu_score": 63.403620262668305}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT res = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (res == MAV_RESULT_ACCEPTED) {\n        AP_Notify::flags.baro_calibration_needed = true;\n    }\n    return res;\n}", "CodeBleu_score": 67.99774950348593}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        // tell barometer to calibrate on next measurement\n        barometer.set_calibration_enabled(true);\n    }\n    return result;\n}", "CodeBleu_score": 64.6414555696336}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 > 0.0f) {\n        // set the arm state to disarm\n        _arm_state.set_armed(false);\n        // return success\n        return MAV_RESULT_ACCEPTED;\n    }\n    // set the arm state to disarm\n    _arm_state.set_armed(false);\n    // return success\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 45.91434855546664}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 > 1.0f) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    if (packet.param1 > 0.5f) {\n        if (!_tracker.arm()) {\n            return MAV_RESULT_FAILED;\n        }\n    } else {\n        if (!_tracker.disarm()) {\n            return MAV_RESULT_FAILED;\n        }\n    }\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 57.57714532424719}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    // check if the mode is supported\n    if (packet.target_component != MAV_COMP_ID_ALL && packet.target_component != MAV_COMP_ID_SERVO) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    // check if the mode is supported\n    if (packet.command != MAV_CMD_COMPONENT_ARM_DISARM) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    // check if the mode is supported\n    if (packet.param1 > 1.0f || packet.param1 < 0.0f) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    // arm the servos\n    if (packet.param1 == 1.0f) {\n        _tracker.arm();\n        return MAV_RESULT_ACCEPTED;\n    }\n\n    // disarm the servos\n    if (packet.param1 == 0.0f) {\n        _tracker.disarm();\n        return MAV_RESULT_ACCEPTED;\n    }\n\n    // return unsupported\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 62.29425928260193}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    // Iterate over all channels\n    for (uint8_t i = 0; i < GCS_MAVLINK_STREAM_CHAN_COUNT; i++) {\n        // Check if the channel is available\n        if (GCS_MAVLINK::stream_table[i].get_protocol() == MAV_COMP_ID_TRACKER) {\n            // Check if the channel has enough payload space for the message\n            if (GCS_MAVLINK::stream_table[i].chan_free() >= MAVLINK_MSG_ID_TRACKER_POSITION_LEN) {\n                // Send a request to start streaming position data on the channel\n                mavlink_msg_tracker_position_send(GCS_MAVLINK::get_channel(i), sysid, compid, 1000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ", "CodeBleu_score": 42.53318185686582}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i = 0; i < GCS_MAVLINK_STREAM_MAX_INSTANCES; i++) {\n        if (GCS_MAVLINK::stream_table[i].stream_id == MAV_DATA_STREAM_POSITION) {\n            if (GCS_MAVLINK::stream_table[i].payload_size >= MAVLINK_MSG_ID_TRACKER_POSITION_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n                GCS_MAVLINK::send_message_at_offset(MAVLINK_MSG_ID_TRACKER_POSITION, sysid, compid, GCS_MAVLINK::stream_table[i].chan, (const uint8_t*)&tracker_position, MAVLINK_MSG_ID_TRACKER_POSITION_LEN, GCS_MAVLINK::stream_table[i].payload_offset);\n                GCS_MAVLINK::stream_table[i].payload_size -= MAVLINK_MSG_ID_TRACKER_POSITION_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES;\n                break;\n            }\n        }\n    }\n}", "CodeBleu_score": 43.42434649698682}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    // Check if the system and component ID are valid\n    if (sysid == 0 || compid == 0) {\n        return;\n    }\n\n    // Iterate over the available GCS channels\n    for (uint8_t i = 0; i < _num_gcs; i++) {\n        // Check if the channel is available and has enough payload space for the data stream request\n        if (_gcs[i].available() && _gcs[i].num_free() >= MAVLINK_MSG_ID_DATAGRAM_POSITION_LEN) {\n            // Send the data stream request to the specified system and component ID on the channel\n            mavlink_msg_datagram_position_pack(\n                _gcs[i].get_system_id(),\n                _gcs[i].get_component_id(),\n                &_gcs[i].get_chan(),\n                sysid,\n                compid,\n                MAV_DATA_STREAM_POSITION,\n                1000,\n                0\n            );\n            _gcs[i].send_message();\n            return;\n        }\n    }\n}", "CodeBleu_score": 50.27649056126053}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const Vector3f &ahrs_p = ahrs.get_rotation();\n    float cos_pitch = ahrs_p.z;\n    if (fabsf(cos_pitch) < 0.0001f) {\n        return false;\n    }\n    ef_pitch = degrees(atan2f(ahrs_p.y, cos_pitch));\n    ef_yaw = degrees(atan2f(ahrs_p.x, ahrs_p.z));\n    return true;\n}", "CodeBleu_score": 47.17523057570814}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const Vector3f& ahrs_bf_p = ahrs.get_bf_p();\n    const float cos_pitch = ahrs_bf_p.z;\n    if (fabsf(cos_pitch) < FLT_EPSILON) {\n        return false;\n    }\n    ef_pitch = -asinf(ahrs_bf_p.y / cos_pitch);\n    ef_yaw = yaw - ahrs.wrap_180_cd(ahrs.get_yaw_from_accel_roll(ahrs_bf_p.x, cos_pitch));\n    return true;\n}", "CodeBleu_score": 48.89758687988473}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const Vector3f& ahrs_pitch_vector = ahrs.get_pitch_vector();\n    const float cos_pitch = ahrs_pitch_vector.z;\n    if (is_zero(cos_pitch)) {\n        return false;\n    }\n    ef_pitch = -asinf(cos_pitch * sinf(pitch));\n    ef_yaw = wrap_PI(ahrs.yaw_sensor + atan2f(ahrs_pitch_vector.y, ahrs_pitch_vector.x) - yaw);\n    return true;\n}", "CodeBleu_score": 49.89130873653164}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t    // calculate yaw and pitch in centidegrees\n    int32_t yaw_cd = (int32_t)(nav_controller->get_yaw_cd() * 100);\n    int32_t pitch_cd = (int32_t)(nav_controller->get_pitch_cd() * 100);\n\n    // check if direction is reversed\n    if (reverse_direction) {\n        yaw_cd = -yaw_cd;\n        pitch_cd = -pitch_cd;\n    }\n\n    // compute angle error\n    int32_t angle_error_yaw_cd = yaw_cd - target_yaw_cd;\n    int32_t angle_error_pitch_cd = pitch_cd - target_pitch_cd;\n\n    // convert errors from earth frame to body frame\n    int32_t angle_error_yaw_bf_cd = ahrs.cos_roll() * angle_error_yaw_cd + ahrs.sin_roll() * angle_error_pitch_cd;\n    int32_t angle_error_pitch_bf_cd = -ahrs.sin_roll() * angle_error_yaw_cd + ahrs.cos_roll() * angle_error_pitch_cd;\n\n    // update pitch and yaw servos\n    if (target_distance == -1 || target_distance >= nav_controller->get_min_distance()) {\n        update_pitch_servo(angle_error_pitch_bf_cd);\n        update_yaw_servo(angle_error_yaw_bf_cd);\n    }\n}", "CodeBleu_score": 36.12190011500511}, {"code": "void Mode::update_auto(void){\n\t    // get navigation status\n    float yaw_cd, pitch_cd;\n    if (ahrs.get_position(target.lat, target.lng, target.alt, &yaw_cd, &pitch_cd)) {\n        // convert yaw and pitch to centidegrees\n        yaw_cd = wrap_180_cd(yaw_cd);\n        pitch_cd = wrap_90_cd(pitch_cd);\n\n        // check if direction is reversed\n        if (tracker.get_reverse_direction()) {\n            yaw_cd = -yaw_cd;\n        }\n\n        // compute angle error\n        const float angle_error_yaw = wrap_180_cd(yaw_cd - ahrs.yaw_sensor);\n        const float angle_error_pitch = wrap_90_cd(pitch_cd - ahrs.pitch_sensor);\n\n        // convert errors from earth frame to body frame\n        const float angle_error_yaw_bf = wrap_180_cd(ahrs.cos_roll * angle_error_yaw + ahrs.sin_roll * angle_error_pitch);\n        const float angle_error_pitch_bf = wrap_90_cd(ahrs.sin_roll * angle_error_yaw - ahrs.cos_roll * angle_error_pitch);\n\n        // update pitch and yaw servos\n        if (target.alt_type == AltType::ABSOLUTE) {\n            // update target altitude\n            target.alt = location.alt;\n        }\n        if (target.alt_type == AltType::ABSOLUTE || target.alt_type == AltType::RELATIVE) {\n            // update target altitude\n            target.alt = location.alt;\n        }\n        if (target.alt_type == AltType::ABSOLUTE || target.alt_type == AltType::RELATIVE) {\n            // update target altitude\n            target.alt = location.alt;\n        }\n        if (target.alt_type == AltType::ABSOLUTE || target.alt_type == AltType::REL", "CodeBleu_score": 39.660598229455104}, {"code": "void Mode::update_auto(void){\n\t    // calculate yaw and pitch in centidegrees\n    int32_t yaw_cd = AP::ahrs().yaw_sensor->yaw_sensor_cd();\n    int32_t pitch_cd = AP::ahrs().pitch_sensor->get_pitch() * 100.0f;\n\n    // check if direction is reversed\n    if (AP::ahrs().reverse_direction()) {\n        yaw_cd = -yaw_cd;\n        pitch_cd = -pitch_cd;\n    }\n\n    // calculate angle error\n    int32_t angle_err_cd = wrap_180_cd(yaw_cd - target_yaw_cd);\n\n    // convert errors from earth frame to body frame\n    float angle_err = (float)angle_err_cd * 0.01f;\n    float angle_err_x = cosf(radians(angle_err));\n    float angle_err_y = sinf(radians(angle_err));\n\n    // update pitch and yaw servos\n    if (target_distance_cm > 0 || min_distance_to_target == 0) {\n        // update pitch servo\n        if (pitch_cd < target_pitch_cd - 500) {\n            // pitch down\n            tracker.set_pitch(constrain_int16(tracker.get_pitch() + pitch_rate_cd, 0, 3000));\n        } else if (pitch_cd > target_pitch_cd + 500) {\n            // pitch up\n            tracker.set_pitch(constrain_int16(tracker.get_pitch() - pitch_rate_cd, 0, 3000));\n        }\n\n        // update yaw servo\n        if (angle_err_x > 0) {\n            // turn right\n            tracker.set_yaw(constrain_int16(tracker.get_yaw() + yaw_rate_cd, 0, 3000));\n        } else {\n            // turn left\n            tracker.", "CodeBleu_score": 35.9667200564717}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t    // update the GPS\n    gps.update();\n\n    // check if the last message time has changed and if the GPS status is at least 3D fix\n    if (gps.last_message_time() != last_message_time || gps.last_message_time() == 0) {\n        // update the last message time\n        last_message_time = gps.last_message_time();\n\n        // check if the GPS status is at least 3D fix\n        if (gps.fix_type() >= 3) {\n            // check if the countdown is not at the maximum value\n            if (ground_start_countdown != 255) {\n                // check if the current location is valid\n                if (gps.location_is_valid()) {\n                    // check if the home location is not set\n                    if (!home_location_set) {\n                        // set the home location\n                        home_location.latitude = gps.latitude();\n                        home_location.longitude = gps.longitude();\n                        home_location.altitude = gps.altitude();\n                        home_location_set = true;\n                    }\n                }\n                // if the current location is not valid, reset the countdown\n                else {\n                    ground_start_countdown = 0;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 48.25427572875941}, {"code": "void Tracker::update_GPS(void){\n\t  if (gps.location.isValid()) {\n    // Update the GPS data\n    gps.update();\n    // Check if the last message time has changed\n    if (gps.lastMessageTime != last_message_time) {\n      last_message_time = gps.lastMessageTime;\n      // Check if the GPS status is at least 3D fix\n      if (gps.location.isValid() && gps.location.is3D()) {\n        // If the countdown is not running, start it\n        if (!countdown_running) {\n          countdown_running = true;\n          countdown_start_time = millis();\n        }\n        // Check if the countdown has reached one second\n        if (millis() - countdown_start_time >= 1000) {\n          // If the home location is not set, set it\n          if (!home_location_set) {\n            home_location_set = true;\n            home_lat = gps.location.lat();\n            home_lon = gps.location.lng();\n            home_alt = gps.location.alt();\n          }\n          // Reset the countdown\n          countdown_running = false;\n          countdown_start_time = 0;\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 45.50753342328966}, {"code": "void Tracker::update_GPS(void){\n\t  if (millis() - last_gps_time > gps_timeout) {\n    gps_status = -1;\n  }\n  if (gps.location.isValid() && gps.location.isValid() && gps.location.isValid()) {\n    last_gps_time = millis();\n    gps_status = 3;\n    if (gps_status == 3 && !home_set) {\n      home_set = true;\n      home_lat = gps.location.lat();\n      home_lon = gps.location.lng();\n      home_alt = gps.altitude.meters();\n      home_speed = gps.speed.kmph();\n      home_course = gps.course.deg();\n      home_time = gps.time.value();\n      home_date = gps.date.value();\n    }\n  }\n  else {\n    gps_status = 0;\n  }\n\n  if (ground_start_countdown > 0) {\n    ground_start_countdown--;\n  }\n  if (ground_start_countdown == 1 && !home_set) {\n    if (gps.location.isValid() && gps.location.isValid() && gps.location.isValid()) {\n      home_set = true;\n      home_lat = gps.location.lat();\n      home_lon = gps.location.lng();\n      home_alt = gps.altitude.meters();\n      home_speed = gps.speed.kmph();\n      home_course = gps.course.deg();\n      home_time = gps.time.value();\n      home_date = gps.date.value();\n    }\n    else {\n      ground_start_countdown = 10;\n    }\n  }\n}", "CodeBleu_score": 38.09171374467965}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch > 0) {\n        digitalWrite(PITCH_ON_PIN, HIGH);\n        digitalWrite(PITCH_OFF_PIN, LOW);\n    } else if (pitch < 0) {\n        digitalWrite(PITCH_ON_PIN, LOW);\n        digitalWrite(PITCH_OFF_PIN, HIGH);\n    } else {\n        digitalWrite(PITCH_ON_PIN, LOW);\n        digitalWrite(PITCH_OFF_PIN, LOW);\n    }\n}", "CodeBleu_score": 27.644662692637063}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch > 10) {\n        pitch = 10;\n    }\n    if (pitch < -10) {\n        pitch = -10;\n    }\n    // if (pitch > 10) {\n    //     pitch = 10;\n    // }\n    // if (pitch < -10) {\n    //     pitch = -10;\n    // }\n    // if (pitch > 10) {\n    //     pitch = 10;\n    // }\n    // if (pitch < -10) {\n    //     pitch = -10;\n    // }\n    // if (pitch > 10) {\n    //     pitch = 10;\n    // }\n    // if (pitch < -10) {\n    //     pitch = -10;\n    // }\n    // if (pitch > 10) {\n    //     pitch = 10;\n    // }\n    // if (pitch < -10) {\n    //     pitch = -10;\n    // }\n    // if (pitch > 10) {\n    //     pitch = 10;\n    // }\n    // if (pitch < -10) {\n    //     pitch = -10;\n    // }\n    // if (pitch > 10) {\n    //     pitch = 10;\n    // }\n    // if (pitch < -10) {\n    //     pitch = -10;\n    // }\n    // if (pitch > 10) {\n    //     pitch = 10;\n    // }\n    // if (pitch < -10) {\n    //     pitch = -10;\n    // }\n    // if (pitch > 10) {\n    //     pitch = 10;\n    // }\n    // if (pitch < -10) {\n    //     pitch = -10;\n    // }\n    // if (pitch > 10) {\n    //     pitch = 10;\n    // }\n    // if (pitch < -10) {\n    //     pitch = -10;\n    // }\n", "CodeBleu_score": 9.43328068668062}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t  if (pitch < 0) {\n    pitch = 0;\n  }\n  if (pitch > 180) {\n    pitch = 180;\n  }\n  if (pitch_onoff_servo_pwm_pin != -1) {\n    //pitch_onoff_servo.write(pitch);\n  }\n}", "CodeBleu_score": 9.85430807563302}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call parent arming checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check if barometer reference is valid\n    if (!AP::baro().get_reference_valid()) {\n        if (display_failure) {\n            AP_Notify::flags.baro_bad = true;\n        }\n        return false;\n    }\n\n    // check baro altitude difference\n    if (g.arm_check_baro_alt && (fabsf(inertial_nav.get_altitude() - barometer.get_altitude()) > ARM_BARO_ALT_MAX)) {\n        if (display_failure) {\n            AP_Notify::flags.baro_bad = true;\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 36.611668323282395}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call base class's barometer_checks function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if the barometer check is enabled, check the baro reference and altitude\n    if (check_enabled(ARMING_CHECK_BARO)) {\n        // check the baro reference\n        if (!check_baro_reference()) {\n            if (display_failure) {\n                AP_Notify::flags.baro_bad = true;\n            }\n            return false;\n        }\n\n        // check the baro altitude\n        if (!check_baro_altitude()) {\n            if (display_failure) {\n                AP_Notify::flags.baro_bad = true;\n            }\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 36.23002667810004}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call parent arming function to check barometer\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n#if ARMING_CHECK_BARO\n    // if baro reference is not set, set it now\n    if (!AP::baro().get_reference()) {\n        AP::baro().set_reference(AP::altitude().get_climb_start_alt());\n    }\n\n    // check if altitude disparity is too great\n    if (fabsf(AP::altitude().get_alt_climb_start() - (float)AP::baro().get_reference()) > ARMING_CHECK_BARO_ALT_DIFF) {\n        if (display_failure) {\n            AP_Notify::flags.baro_bad = true;\n        }\n        return false;\n    }\n#endif\n\n    return true;\n}", "CodeBleu_score": 37.49633558245316}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if rangefinder based altitude source, then no terrain database required\n    if (copter.rangefinder_alt_cm_source() != RANGEFINDER_ALT_SOURCE_TERRAIN) {\n        return false;\n    }\n\n    // if RTL and terrain altitude, then a terrain database is required\n    if (copter.mode_rtl.is_active() && copter.g.terrain_source != AP_TERRAIN_SOURCE_DISABLED) {\n        return true;\n    }\n\n    // defer to base class\n    return AP_Arming_Plane::terrain_database_required();\n}", "CodeBleu_score": 63.68258048272145}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if rangefinder, no terrain database required\n    if (copter.rangefinder.get_status() >= RangeFinder::Status::Processed) {\n        return false;\n    }\n\n    // if terrain database and RTL altitude is terrain, require terrain database\n    if ((copter.ap.terrain_source == AP_Arming::TerrainSource::TerrainDatabase) && (copter.g.rtl_alt_type == RTL_ALT_TERRAIN)) {\n        return true;\n    }\n\n    // defer to base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 71.6240138889745}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if we are using a rangefinder, we do not need a terrain database\n    if (copter.rangefinder_state.alt_healthy && copter.rangefinder_state.alt_healthy_all) {\n        return false;\n    }\n\n    // if we are using a terrain database and we are using terrain altitude, we do need a terrain database\n    if (copter.terrain.status() == AP_Terrain::Terrain_Status_OK && copter.g.terrain_source == AP_TERRAIN_SOURCE_TERRAIN_PDB) {\n        return true;\n    }\n\n    // otherwise defer to the base class implementation\n    return AP_Arming_Plane::terrain_database_required();\n}", "CodeBleu_score": 64.16539066296443}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    // if not armed or throttle is zero, set throttle to zero and exit immediately\n    if (!motors->armed() || ap.throttle_zero) {\n        attitude_control->set_throttle_zero();\n        return;\n    }\n\n    // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(channel_roll->norm_input(), channel_pitch->norm_input(), channel_yaw->norm_input());\n}", "CodeBleu_score": 29.01574679474462}, {"code": "void Copter::run_rate_controller(){\n\t    // run the rate controllers\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 11.259248511475347}, {"code": "void Copter::run_rate_controller(){\n\t    // set loop time\n    attitude_control.set_loop_time_from_scheduler(scheduler.get_last_loop_time_us());\n\n    // run rate controllers\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 27.533296368023525}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // check if the old location matches this waypoint\n    if (old_loc.lat != new_loc.lat || old_loc.lng != new_loc.lng) {\n        return false;\n    }\n\n    // check if the altitude frames of the old and new locations are the same\n    if (old_loc.relative_alt && new_loc.relative_alt) {\n        return false;\n    }\n\n    // set the new location as the target\n    target_location = new_loc;\n    return true;\n}", "CodeBleu_score": 46.154301271330326}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // check if the old and new locations are the same\n    if (old_loc == new_loc) {\n        return false;\n    }\n\n    // check if the new location's altitude frame is the same as the old location\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set the new location as the target\n    target_location = new_loc;\n    return true;\n}", "CodeBleu_score": 54.74710474780419}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // check if we are going to change the target\n    if (old_loc.lat != new_loc.lat || old_loc.lng != new_loc.lng || old_loc.alt != new_loc.alt || old_loc.relative_alt != new_loc.relative_alt || old_loc.terrain_alt != new_loc.terrain_alt || old_loc.terrain_alt_valid != new_loc.terrain_alt_valid || old_loc.alt_frame != new_loc.alt_frame) {\n        // check if the target location is a valid location\n        if (new_loc.lat == 0 && new_loc.lng == 0 && new_loc.alt == 0) {\n            // this is a stop command\n            return false;\n        }\n        // check if the target location is a valid location\n        if (new_loc.lat == 0 && new_loc.lng == 0 && new_loc.alt == 0) {\n            // this is a stop command\n            return false;\n        }\n        // check if the target location is a valid location\n        if (new_loc.lat == 0 && new_loc.lng == 0 && new_loc.alt == 0) {\n            // this is a stop command\n            return false;\n        }\n        // check if the target location is a valid location\n        if (new_loc.lat == 0 && new_loc.lng == 0 && new_loc.alt == 0) {\n            // this is a stop command\n            return false;\n        }\n        // check if the target location is a valid location\n        if (new_loc.lat == 0 && new_loc.lng == 0 && new_loc.alt == 0) {\n            // this is a stop command\n            return false;\n        }\n        // check if the target location is a valid location\n        if (new_loc.lat == 0 && new_loc.lng == 0 && new_loc.alt == 0) {\n            // this is a stop command\n            return false;\n        }\n        // check if the target location is a valid location\n        if (new_loc.lat == 0 && new_loc.lng == ", "CodeBleu_score": 35.672540660097695}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\n    // check if we are in the correct mode to be able to change\n    if (copter.mode_number != mode) {\n        return;\n    }\n\n    // check if we are in the correct position to be able to change\n    if (copter.channel_aux->get_control_in() != ch_flag) {\n        return;\n    }\n\n    // exit immediately if we are not in a failsafe that would allow changing\n    // modes.  We don't want to go from LOITER to ACRO if we are in a\n    // failsafe that would prevent that (i.e. if we are in a failsafe that\n    // prevents motors from stopping).\n    if (!copter.ap.land_complete && (copter.failsafe.mode_change != Mode::Number::ACRO)) {\n        return;\n    }\n\n    // if we are in the correct position and in the correct mode, and we are\n    // not in a failsafe that would prevent changing modes, then reset the\n    // mode switch\n    rc().reset_mode_switch();\n\n    // attempt to set the mode using the copter's set_mode method.  if this\n    // is successful, exit immediately\n    if (copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n        return;\n    }\n\n    // if we got this far we failed to set the mode.  This could be because\n    // the mode is not supported, or because the mode change is not allowed\n    // (i.e. the copter is not in a failsafe that would prevent a mode change).\n    // In either case, we do nothing.\n}", "CodeBleu_score": 55.16522762805492}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    // if ch_flag is not set, or we are not in a mode that can be changed by aux switch, exit\n    if (!(ch_flag & RC_Channel::k_aux_function_flag) || !copter.mode_allows_aux_function()) {\n        return;\n    }\n\n    // if ch_flag is set, and we are in the correct mode, reset the mode switch\n    if (mode == copter.control_mode) {\n        rc().reset_mode_switch();\n        return;\n    }\n\n    // if ch_flag is set, and we are not in the correct mode, set the mode\n    copter.set_mode(mode, ch_flag);\n}", "CodeBleu_score": 52.5285632855135}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    // if the mode is not active or we are not in a mode that supports this aux switch, then exit\n    if (!copter.mode_has_manual_throttle(mode) ||\n        copter.control_mode == mode) {\n        return;\n    }\n\n    // if the mode switch is not in the high position, and we are in the correct mode, then reset the mode switch\n    if (copter.control_mode == mode &&\n        copter.channel_aux->get_control_in() != ch_flag) {\n        copter.channel_aux->reset_mode_switch();\n    }\n\n    // if the mode switch is in the high position, then set the mode\n    if (copter.channel_aux->get_control_in() == ch_flag) {\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    }\n}", "CodeBleu_score": 53.17091219027452}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // save trim\n    float roll_trim = channel_roll->control_in;\n    float pitch_trim = channel_pitch->control_in;\n    ahrs.set_roll_pitch_trim(radians(roll_trim), radians(pitch_trim));\n\n    // log and report back to pilot\n    AP_Notify::flags.save_trim = true;\n    AP_Notify::flags.save_params = false;\n    AP_Notify::flags.save_eeprom = false;\n    AP_Notify::flags.save_options = false;\n    AP_Notify::flags.save_terrain = false;\n    AP_Notify::flags.save_ahrs = false;\n    AP_Notify::flags.save_attitude = false;\n    AP_Notify::flags.save_airspeed = false;\n    AP_Notify::flags.save_gps = false;\n    AP_Notify::flags.save_gps_rtk = false;\n    AP_Notify::flags.save_gps_rtk_rtcm = false;\n    AP_Notify::flags.save_gps_rtk_rtcm_ref = false;\n    AP_Notify::flags.save_gps_rtk_rtcm_corr = false;\n    AP_Notify::flags.save_gps_rtk_rtcm_ref_corr = false;\n    AP_Notify::flags.save_gps_rtk_rtcm_ref_corr_corr = false;\n    AP_Notify::flags.save_gps_rtk_rtcm_ref_corr_corr_corr = false;\n    AP_Notify::flags.save_gps_rtk_rtcm_ref_corr_corr_corr_corr = false;\n    AP_Notify::flags.save_gps_rtk_rtcm_ref_corr_corr_corr_corr_corr = false;\n    AP_Notify::flags.save_gps_rtk_rtcm_ref_corr_corr_corr_corr_corr_cor", "CodeBleu_score": 38.68396799550636}, {"code": "void Copter::save_trim(){\n\t    // get roll and pitch input\n    float roll_input = channel_roll->control_in;\n    float pitch_input = channel_pitch->control_in;\n\n    // convert to radians\n    float roll_rad = radians(roll_input);\n    float pitch_rad = radians(pitch_input);\n\n    // add to AHRS\n    ahrs.add_trim(roll_rad, pitch_rad);\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send message\n    gcs().send_MAV_CMD_ACK(MAV_CMD_SAVE_TRIM, MAV_RESULT_ACCEPTED);\n}", "CodeBleu_score": 48.090896473770236}, {"code": "void Copter::save_trim(){\n\t    // calculate the roll trim\n    float roll_trim = channel_roll->get_control_in() * 0.01f;\n    // calculate the pitch trim\n    float pitch_trim = channel_pitch->get_control_in() * 0.01f;\n    // add the roll trim to the AHRS\n    ahrs.add_roll_trim(roll_trim);\n    // add the pitch trim to the AHRS\n    ahrs.add_pitch_trim(pitch_trim);\n    // log the event\n    AP_Notify::flags.save_trim = true;\n    // send a message to say the trim is saved\n    AP_Notify::flags.save_trim = true;\n    AP_Notify::flags.save_trim_complete = true;\n    // send a message to say the trim is saved\n    AP_Notify::flags.save_trim_complete = true;\n    AP_Notify::flags.save_trim_complete_complete = true;\n    AP_Notify::flags.save_trim_complete_complete_complete = true;\n    AP_Notify::flags.save_trim_complete_complete_complete_complete = true;\n    AP_Notify::flags.save_trim_complete_complete_complete_complete_complete = true;\n    AP_Notify::flags.save_trim_complete_complete_complete_complete_complete_complete = true;\n    AP_Notify::flags.save_trim_complete_complete_complete_complete_complete_complete_complete = true;\n    AP_Notify::flags.save_trim_complete_complete_complete_complete_complete_complete_complete_complete = true;\n    AP_Notify::flags.save_trim_complete_complete_complete_complete_complete_complete_complete_complete_complete = true;\n    AP_Notify::flags.save_trim_complete_complete_complete_complete_complete_complete_complete_complete_complete_complete = true;\n    AP_Notify::flags.save_trim_complete_complete_complete_complete_complete_complete_complete_complete_complete_complete_complete = true;\n    AP_Notify::flags.save_trim_complete_complete", "CodeBleu_score": 41.45571594341318}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    float yaw_angle;\n\n    // get velocity vector\n    Vector2f vel = inertial_nav.get_velocity();\n\n    // get horizontal speed\n    float speed = vel.length();\n\n    // if we are not at least speed_min_cm/s, do not change heading\n    if (speed < MINIMUM_SPEED) {\n        return ahrs.yaw;\n    }\n\n    // calculate the yaw angle\n    yaw_angle = degrees(atan2f(vel.y, vel.x));\n\n    // ensure yaw is between 0 and 360 degrees\n    yaw_angle = wrap_360(yaw_angle);\n\n    // ensure yaw is within 180 of the heading\n    float yaw_error = wrap_180(ahrs.yaw - yaw_angle);\n    if (fabsf(yaw_error) > 90) {\n        yaw_angle += 180;\n    }\n\n    return yaw_angle;\n}", "CodeBleu_score": 49.57788235624824}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    float speed_xy = copter.velocity.x * copter.velocity.x + copter.velocity.y * copter.velocity.y;\n    if (copter.position_ok() && speed_xy > 0.00001f) {\n        return atan2f(copter.velocity.y, copter.velocity.x);\n    }\n    return 0.0f;\n}", "CodeBleu_score": 28.185026546076198}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // get velocity components\n    float vx, vy;\n    if (!copter.position_ok()) {\n        // if we don't know where we are, then we don't know where we are looking\n        return 0.0f;\n    }\n    vx = copter.velocity_x;\n    vy = copter.velocity_y;\n\n    // calculate the speed squared\n    float speedSq = vx * vx + vy * vy;\n\n    // if we are not moving, then we don't want to look\n    if (speedSq < MIN_SPEED_SQ_FOR_YAW) {\n        return 0.0f;\n    }\n\n    // calculate the yaw\n    return atan2f(vy, vx);\n}", "CodeBleu_score": 40.93516197125332}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // if arming checks are disabled, or we are watching the watchdog,\n    // then we pass immediately\n    if (!_arming_checks_enabled || _watchdog.is_armed()) {\n        return true;\n    }\n\n    switch (method) {\n    case AP_Arming::Method::ANGLE_MODE:\n        return true;\n\n    case AP_Arming::Method::RUDDER:\n        if (_rudder_arming_disabled || _motors->get_throttle() > 0) {\n            return false;\n        }\n        return true;\n\n    case AP_Arming::Method::THROTTLE_UNLIMITED:\n    case AP_Arming::Method::THROTTLE_LIMITED:\n        return true;\n\n    default:\n        return AP_Arming::arm_checks(method);\n    }\n}", "CodeBleu_score": 46.00468981806759}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // exit immediately if arming checks are disabled\n    if (!arming_checks_enabled) {\n        return true;\n    }\n\n    // exit immediately if the watchdog was armed (i.e. we're in the failsafe event)\n    if (watchdog_armed) {\n        return true;\n    }\n\n    // exit immediately if rudder arming is disabled\n    if (plane.g.rudder_arm_disabled) {\n        return true;\n    }\n\n    // exit immediately if throttle is not zero\n    if (plane.channel_throttle->get_control_in() != 0) {\n        return false;\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 44.640885995679525}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (checks_disabled) {\n        return true;\n    }\n\n    // check watchdog was not armed\n    if (watchdog_armed) {\n        return true;\n    }\n\n    switch (method) {\n\n    case AP_Arming::Method::ANGLE_PASSTHROUGH:\n        // always allow angle passthrough arming\n        return true;\n\n    case AP_Arming::Method::RUDDER:\n        // rudder arming is disabled if the throttle is zero\n        if (plane.g.rudder_arming == 0) {\n            return false;\n        }\n        return true;\n\n    default:\n        // call parent class's arm_checks\n        return AP_Arming::arm_checks(method);\n    }\n}", "CodeBleu_score": 43.8391441110769}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\n    // set arming method\n    _arm_method = method;\n\n    // run any arming checks\n    if (do_arming_checks && !arming_checks()) {\n        return false;\n    }\n\n    // set home location\n    plane.set_home();\n\n    // set home location in AHRS\n    plane.ahrs.set_home(plane.current_loc.lat, plane.current_loc.lng);\n\n    // set current location\n    plane.current_loc.lat = plane.ahrs.get_home().lat;\n    plane.current_loc.lng = plane.ahrs.get_home().lng;\n\n    // change arm state\n    plane.arming.armed = true;\n\n    // set delay arming flag\n    plane.arming.delay_arming = true;\n\n    // send status text\n    plane.gcs_send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n\n    // return success\n    return true;\n\n}", "CodeBleu_score": 46.91525201609619}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\n    // exit immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // return immediately if pre-arm checks fail\n    if (do_arming_checks && !pre_arm_checks(method)) {\n        return false;\n    }\n\n    // record the arming source\n    _arming_method = method;\n\n    // set the arming state\n    _armed_state = ARMED_STATE_ARMED;\n\n    // set the arming flag\n    _arming_complete = true;\n\n    // set the arming delay flag\n    _arming_delay_active = true;\n\n    // send the arming status text\n    AP_Notify::flags.armed = true;\n\n    // send the pre arm notification\n    AP_Notify::flags.pre_arm_check = false;\n\n    // send the arming complete notification\n    AP_Notify::flags.armed_complete = true;\n\n    // set home to current position\n    set_home_to_current_location();\n\n    // set home to current location\n    _plane.set_home_to_current_location();\n\n    // return success\n    return true;\n}", "CodeBleu_score": 50.60061451067324}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // return immediately if already armed\n    if (plane.motors->armed()) {\n        return true;\n    }\n\n    // return immediately if method is not a valid arm method\n    if (method != AP_Arming::Method::AUTOMATIC && method != AP_Arming::Method::MANUAL) {\n        return false;\n    }\n\n    // perform arming checks\n    if (do_arming_checks && !plane.g.fs_checks && !plane.g2.fs_checks) {\n        return false;\n    }\n\n    // set the arming method\n    _arming_method = method;\n\n    // set the arming state\n    _arming_state = AP_Arming::ArmingState::ARMING;\n\n    // update the home location\n    plane.set_home_to_current_location();\n\n    // set the home location in the AHRS system\n    plane.ahrs.set_home(plane.current_loc);\n\n    // update the current location\n    plane.update_current_loc();\n\n    // change the arm state\n    plane.change_arm_state();\n\n    // set the delay arming flag\n    plane.delay_arming = true;\n\n    // send a status text\n    plane.gcs().send_text(MAV_SEVERITY_INFO, \"Throttle Armed\");\n\n    // return success\n    return true;\n}", "CodeBleu_score": 47.313750367897086}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (armed()) {\n        return true;\n    }\n\n    if (!_disarm_button_configured) {\n        if (display_failure) {\n            AP_Notify::flags.pre_arm_disarm_fail = true;\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 66.51614139884936}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if we've already been armed, then we're done\n    if (armed()) {\n        return true;\n    }\n\n    // check if a disarm button is configured\n    if (hal.util->get_soft_armed()) {\n        // if we get here then the user has configured a disarm button\n        // if display_failure is true, then we want to display a failure\n        // message to the user explaining the failure and why arming\n        // failed\n        if (display_failure) {\n            AP_Notify::flags.pre_arm_disarm_fail = true;\n        }\n        return false;\n    }\n\n    // if we get here then the user has not configured a disarm button\n    // so we can perform the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 65.76553927294363}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\n    // if vehicle is already armed, return true\n    if (armed()) {\n        return true;\n    }\n\n    // if disarm button is not configured, display failure message and return false\n    if (hal.util->get_soft_armed() != AP_HAL::HAL_SOFT_DISARMED) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Arming failed: disarm button not configured\");\n        }\n        return false;\n    }\n\n    // if disarm button is configured, proceed with standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.77797757047851}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float yaw = ahrs.yaw;\n    float ne_x = x * cos(yaw) + y * sin(yaw);\n    float ne_y = -x * sin(yaw) + y * cos(yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 58.55314467142887}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float yaw = ahrs.yaw;\n    float ne_x = x * cos(yaw) + y * sin(yaw);\n    float ne_y = -x * sin(yaw) + y * cos(yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 58.55314467142887}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cosf(-ahrs.yaw) - y * sinf(-ahrs.yaw);\n    float ne_y = x * sinf(-ahrs.yaw) + y * cosf(-ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 61.48228977778387}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // check if yaw angle is within acceptable range\n    if (packet.param4 < -360 || packet.param4 > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // check if param4 is within acceptable range\n    if (packet.param4 < -180 || packet.param4 > 180) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set the yaw heading using the provided parameters\n    set_yaw_heading(packet.param4, packet.param5);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 45.54143800255055}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // exit immediately if not armed\n    if (!motors->armed()) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // convert param4 from centi-degrees to degrees\n    float yaw_angle = packet.param4 / 100.0f;\n\n    // check if the yaw angle is within the acceptable range\n    if (yaw_angle < -180.0f || yaw_angle > 180.0f) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // check if param4 is within the acceptable range\n    if (packet.param4 < -36000.0f || packet.param4 > 36000.0f) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set the yaw heading using the provided parameters\n    set_yaw_heading(yaw_angle, packet.param5, packet.param6);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 43.65486565473864}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // check if vehicle is in Guided, Acro, Auto or Land states\n    if (!copter.ap.auto_mode) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // check if vehicle has a position\n    if (!copter.ap.home.alt) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // check if vehicle is landed\n    if (!copter.ap.land_complete) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // get the yaw angle\n    float yaw_angle = packet.param4;\n\n    // check if the yaw angle is within acceptable range\n    if (yaw_angle > 360.0f || yaw_angle < -360.0f) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // check if the yaw rate is within acceptable range\n    if (packet.param5 > 360.0f || packet.param5 < -360.0f) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // check if the direction is within acceptable range\n    if (packet.param6 > 1 || packet.param6 < -1) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // set the yaw angle using the provided parameters\n    copter.guided_set_yaw_angle(yaw_angle, packet.param5, packet.param6, packet.param7);\n\n    // return MAV_RESULT_ACCEPTED if the yaw angle was set successfully\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 48.22552035495057}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    uint8_t ret = 0;\n    if (control_mode == AUTO || control_mode == GUIDED) {\n        ret = (wp_bearing / 2) % 360;\n    }\n    return ret;\n}", "CodeBleu_score": 43.162987370332715}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if ((control_mode == Mode::Number::AUTO || control_mode == Mode::Number::GUIDED) &&\n        (control_mode != Mode::Number::AUTO_RTL)) {\n        return (wp_bearing / 2) % 360;\n    }\n    return 0;\n}", "CodeBleu_score": 57.177147639808304}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    uint8_t retval = 0;\n\n    // if we're in AUTO or GUIDED mode, convert the waypoint bearing from -18000->18000 to 0->360 and then divides by 2\n    if ((control_mode == AUTO || control_mode == GUIDED) && (flightmode == FlightMode::NORMAL || flightmode == FlightMode::STEERING)) {\n        int32_t tgt_heading = ap.nav_controller->target_bearing_cd() / 100;\n        if (tgt_heading < 0) {\n            tgt_heading += 36000;\n        }\n        retval = tgt_heading / 2;\n    }\n    return retval;\n}", "CodeBleu_score": 44.99574454129603}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (log_enabled) {\n        Log_Data_t log_data;\n        log_data.time = millis();\n        log_data.id = id;\n        log_data.value = value;\n        logger.write_critical_block((uint8_t *) &log_data, sizeof(log_data));\n    }\n}", "CodeBleu_score": 43.070886164174645}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (log_enabled) {\n\t\tLogData log_data;\n\t\tlog_data.id = id;\n\t\tlog_data.value = value;\n\t\tlog_data.timestamp = HAL_GetTick();\n\t\tlogger.Log_Critical(log_data);\n\t}\n}", "CodeBleu_score": 36.049746992419195}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (!Log_Is_Enabled()) {\n        return;\n    }\n\n    LogPacket packet = {\n        .timestamp = HAL_GetTick(),\n        .id = id,\n        .value = value\n    };\n\n    Log_Write_Packet(packet);\n}", "CodeBleu_score": 38.15905867415904}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\n    // exit immediately if home is already set\n    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if motors are armed, set home to current location\n    if (motors.armed()) {\n        ahrs.set_home(inertial_nav.get_position());\n        return;\n    }\n\n    // if motors are not armed, attempt to set home to EKF location\n    Location ekf_origin;\n    if (ahrs.get_position(ekf_origin)) {\n        ahrs.set_home(ekf_origin);\n    }\n}", "CodeBleu_score": 39.78619532383307}, {"code": "void Sub::update_home_from_EKF(){\n\t\n    // if home is already set, exit immediately\n    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if motors are armed, set home to current location\n    if (motors.armed()) {\n        ahrs.set_home(gps.location());\n        return;\n    }\n\n    // if motors are not armed, attempt to set home to EKF location\n    Location ekf_loc;\n    if (ahrs.get_position(ekf_loc)) {\n        ahrs.set_home(ekf_loc);\n    }\n}", "CodeBleu_score": 41.65672513230021}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (home_is_set) {\n        return;\n    }\n    if (motors->armed()) {\n        set_home_to_current_location();\n    } else {\n        set_home_to_EKF_location();\n    }\n}", "CodeBleu_score": 37.38533379367266}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t    float target_roll, target_pitch;\n    float target_yaw_rate;\n\n    // if not armed set throttle to zero and exit immediately\n    if (!motors.armed()) {\n        motors.output_min();\n        attitude_control.set_throttle_out(0, true, g.throttle_filt);\n        attitude_control.relax_attitude_controllers();\n        pos_control.relax_alt_hold_controllers(0.0f);\n        return;\n    }\n\n    // process pilot inputs\n    if (!acro_use_pilot_yaw) {\n        // if using Euler method get yaw input\n        target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input());\n    } else {\n        // if using mixer method get yaw from mixer\n        target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n    }\n\n    // get pilot's desired roll and pitch rates\n    target_roll = get_pilot_desired_roll_rate(channel_roll->get_control_in());\n    target_pitch = get_pilot_desired_pitch_rate(channel_pitch->get_control_in());\n\n    // run attitude controller\n    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate);\n\n    // set motors to desired throttle\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    float target_lean_roll, target_lean_pitch;\n    get_pilot_desired_lean_angles(target_lean_roll, target_lean_pitch, target_roll, target_pitch, target_yaw_rate);\n\n    // run position controller\n    pos_control.", "CodeBleu_score": 58.52080242950494}, {"code": "void ModeAcro::run(){\n\t    // if not armed set throttle to zero and exit immediately\n    if (!motors.armed()) {\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control.set_throttle_out(0.0f, true, g.throttle_filt);\n        attitude_control.relax_attitude_controllers();\n        return;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    float target_roll, target_pitch;\n    get_pilot_desired_lean_angles(target_roll, target_pitch, copter.aparm.angle_max);\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // send the attitude command\n    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate);\n}", "CodeBleu_score": 58.0548449311538}, {"code": "void ModeAcro::run(){\n\t    float target_roll, target_pitch;\n    float pilot_throttle_scaled = 0;\n\n    // if not armed set throttle to zero and exit immediately\n    if (!motors.armed()) {\n        motors.output_min();\n        attitude_control.set_throttle_rate_and_angle(0.0f, 0.0f, 0.0f);\n        return;\n    }\n\n    // convert the input to the desired body frame rate\n    get_pilot_desired_angle_rates(channel_roll->norm_input(), channel_pitch->norm_input(), target_roll, target_pitch);\n\n    // set motors to unlimited range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // run attitude controller\n    attitude_control.input_rate_bf_roll_pitch(target_roll, target_pitch);\n\n    // get pilot's desired throttle\n    pilot_throttle_scaled = channel_throttle->norm_input();\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // send output to motors\n    motors.set_throttle(pilot_throttle_scaled * 0.01f);\n}", "CodeBleu_score": 57.913441862955096}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set position controller mode\n    guided_pos_control.set_mode(POSITION_CONTROL_MODE_POSITION);\n\n    // set current waypoint to stopping point\n    guided_pos_control.set_destination(guided_pos_control.get_stopping_point());\n\n    // initialise yaw\n    auto_yaw.set_mode_to_default(true);\n}", "CodeBleu_score": 27.349204467626365}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set position controller mode\n    pos_control->init_z_controller();\n    pos_control->init_xy_controller();\n    pos_control->set_yaw_mode(AUTO_YAW_HOLD);\n\n    // set waypoint destination\n    Vector3f stopping_point;\n    if (guided_pos_state.stopping_point_valid) {\n        stopping_point = guided_pos_state.stopping_point;\n    } else {\n        stopping_point = guided_pos_state.target_pos;\n    }\n\n    // set position controller target\n    pos_control->set_pos_target_z_from_climb_rate_cm(stopping_point.z);\n    pos_control->set_pos_target_xy(stopping_point);\n}", "CodeBleu_score": 42.79976032773581}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set position target to stopping point\n    guided_pos_control_set_destination(guided_pos_control_get_stopping_point());\n\n    // initialize yaw\n    auto_yaw.mode_guided_set_yaw_mode(auto_yaw.get_mode_from_acceleration(ahrs.get_accel_z_vector()));\n    auto_yaw.set_yaw_mode_from_acceleration(ahrs.get_accel_z_vector());\n    auto_yaw.set_yaw_mode_from_heading(guided_pos_control_get_yaw_heading());\n\n    // set position control to be active\n    guided_pos_control_set_active(true);\n}", "CodeBleu_score": 37.48563410362704}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t    // initialize vertical speed and acceleration\n    pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_vel_accel_z, g.pilot_vel_decel_z);\n    pos_control->set_correction_speed_accel_z(-get_pilot_speed_dn(), g.pilot_vel_accel_z, g.pilot_vel_decel_z);\n\n    // initialise horizontal speed and acceleration\n    pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), g.accel_xy);\n\n    // initialise yaw\n    attitude_control->set_yaw_mode(ANGLE_YAW_HOLD);\n}", "CodeBleu_score": 51.63768247274507}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\n    // set vertical speed and acceleration limits\n    pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_up);\n    pos_control->set_correction_speed_accel_z(g.acro_p.speed_damping, g.acro_p.accel_dz);\n\n    // initialise horizontal speed and acceleration\n    pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_default_accel_xy());\n\n    // initialise yaw\n    pos_control->init_z_controller();\n    pos_control->init_xy_controller();\n    pos_control->set_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 54.038153924654466}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // initialize vertical speed and acceleration\n    pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z);\n    pos_control->set_correction_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z);\n\n    // initialize horizontal speed and acceleration\n    pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_default_accel_xy());\n\n    // initialise yaw\n    yaw_control->set_mode(AUTO_YAW_HOLD);\n\n    // initialise velocity controller\n    pos_control->init_z_controller();\n\n    // initialise horizontal velocity controller\n    pos_control->init_xy_controller();\n}", "CodeBleu_score": 55.84034578685366}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // Check if we've timed out\n    if (millis() - guided_start_time > GUIDED_TIMEOUT_MS) {\n        return true;\n    }\n\n    // Check if we've been outside of our limits\n    if (current_loc.alt < guided_min_alt || current_loc.alt > guided_max_alt) {\n        return true;\n    }\n\n    // Check if we've moved too far\n    if (guided_distance_to_destination() > GUIDED_DISTANCE_MAX) {\n        return true;\n    }\n\n    // Check if we've reached our target\n    if (guided_distance_to_destination() < GUIDED_DISTANCE_MIN) {\n        return true;\n    }\n\n    // Check if we've reached our target\n    if (guided_distance_to_destination() < GUIDED_DISTANCE_MIN) {\n        return true;\n    }\n\n    // Check if we've reached our target\n    if (guided_distance_to_destination() < GUIDED_DISTANCE_MIN) {\n        return true;\n    }\n\n    // Check if we've reached our target\n    if (guided_distance_to_destination() < GUIDED_DISTANCE_MIN) {\n        return true;\n    }\n\n    // Check if we've reached our target\n    if (guided_distance_to_destination() < GUIDED_DISTANCE_MIN) {\n        return true;\n    }\n\n    // Check if we've reached our target\n    if (guided_distance_to_destination() < GUIDED_DISTANCE_MIN) {\n        return true;\n    }\n\n    // Check if we've reached our target\n    if (guided_distance_to_destination() < GUIDED_DISTANCE_MIN) {\n        return true;\n    }\n\n    // Check if we've reached our target\n    if (guided_distance_to_destination() < GUIDED_DISTANCE_MIN) {\n        return true;\n    }\n\n    // Check", "CodeBleu_score": 35.2018349288564}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have timed out\n    if (should_exit()) {\n        return true;\n    }\n\n    // check if we have moved too far\n    if (guided_limit.timeout_ms > 0 &&\n        (g.g2.guided_limit > 0 || guided_limit.alt_min > 0 || guided_limit.alt_max > 0) &&\n        (guided_limit.pos_xy_cm != Vector2l(0,0))) {\n        // check if we have moved too far\n        if ((Vector2l(ahrs.get_position()) - guided_limit.pos_xy_cm).length() > guided_limit.pos_xy_max) {\n            gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Guided: pos error %.0fm\", (Vector2l(ahrs.get_position()) - guided_limit.pos_xy_cm).length());\n            return true;\n        }\n    }\n\n    // check if we have moved horizontally\n    if (guided_limit.pos_xy_max > 0) {\n        if ((Vector2l(ahrs.get_position()) - guided_limit.pos_xy_cm).length() > guided_limit.pos_xy_max) {\n            gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Guided: pos error %.0fm\", (Vector2l(ahrs.get_position()) - guided_limit.pos_xy_cm).length());\n            return true;\n        }\n    }\n\n    // check if we have moved vertically\n    if (guided_limit.alt_min > 0 || guided_limit.alt_max > 0) {\n        float alt = inertial_nav.get_altitude();\n        if (guided_limit.alt_min > 0 && alt < guided_limit.alt_min) {\n            gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Guided: alt error %.0fm\", (float)alt - guided_limit.alt_min);\n            return true;\n        }\n        if (gu", "CodeBleu_score": 52.176462166221235}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check timeout\n    if (millis() - guided_start_time > GUIDED_TIMEOUT_MS) {\n        return true;\n    }\n\n    // check altitude\n    float alt_error = guided_state.pos_offset.z - pos_control->get_pos_z_target();\n    if (fabsf(alt_error) > GUIDED_ALT_LIMIT_MAX) {\n        return true;\n    }\n\n    // check horizontal position\n    if (guided_state.horizontal_pos_limit_type != GUIDED_POS_LIMIT_NONE) {\n        float horiz_error = get_horizontal_distance_to_target();\n        if (horiz_error > GUIDED_HORIZ_LIMIT_MAX) {\n            return true;\n        }\n    }\n\n    // check horizontal velocity\n    if (guided_state.horizontal_vel_limit_type != GUIDED_VEL_LIMIT_NONE) {\n        float horiz_vel_error = get_horizontal_velocity_to_target();\n        if (fabsf(horiz_vel_error) > GUIDED_HORIZ_VEL_LIMIT_MAX) {\n            return true;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 43.504767061911146}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t    // Get the current time\n    ros::Time current_time = ros::Time::now();\n\n    // If the motor test is not enabled, return true\n    if (!motor_test_enabled) {\n        return true;\n    }\n\n    // If the motor test is enabled and the time since the last request is greater than the timeout period, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false\n    if (current_time - motor_test_last_request_time > ros::Duration(2)) {\n        ROS_ERROR(\"Motor test request timed out\");\n        motor_test_pass = false;\n        motor_test_enabled = false;\n        arming_client.call(arm_srv);\n        motor_test_failure_time = current_time;\n        return false;\n    }\n\n    // If the motor test is enabled and the time since the last request is less than or equal to the timeout period, return true\n    return true;\n}", "CodeBleu_score": 54.23230178229408}, {"code": "bool Sub::verify_motor_test(){\n\t    // Initialize the pass flag to true\n    bool pass = true;\n\n    // Initialize the timeout flag to false\n    bool timeout = false;\n\n    // Initialize the timeout counter to 0\n    int timeout_counter = 0;\n\n    // Initialize the timeout threshold to 100\n    int timeout_threshold = 100;\n\n    // Initialize the timeout message to false\n    bool timeout_message = false;\n\n    // Initialize the timeout message counter to 0\n    int timeout_message_counter = 0;\n\n    // Initialize the timeout message threshold to 5\n    int timeout_message_threshold = 5;\n\n    // Initialize the timeout message interval to 1000\n    int timeout_message_interval = 1000;\n\n    // Initialize the timeout message time to 0\n    int timeout_message_time = 0;\n\n    // Initialize the timeout message time interval to 1000\n    int timeout_message_time_interval = 1000;\n\n    // Initialize the timeout message time counter to 0\n    int timeout_message_time_counter = 0;\n\n    // Initialize the timeout message time threshold to 5\n    int timeout_message_time_threshold = 5;\n\n    // Initialize the timeout message time interval to 1000\n    int timeout_message_time_interval_2 = 1000;\n\n    // Initialize the timeout message time counter to 0\n    int timeout_message_time_counter_2 = 0;\n\n    // Initialize the timeout message time threshold to 5\n    int timeout_message_time_threshold_2 = 5;\n\n    // Initialize the timeout message time interval to 1000\n    int timeout_message_time_interval_3 = 1000;\n\n    // Initialize the timeout message time counter to 0\n    int timeout_message_time_counter_3 = 0;\n\n    // Initialize the timeout message time threshold to 5\n    int timeout_message_time_threshold_3 = 5;\n\n    // Initialize the timeout message time interval to 1000\n    int timeout_message_time_interval_4 = 10", "CodeBleu_score": 12.414227639321323}, {"code": "bool Sub::verify_motor_test(){\n\t\n    // Check if motor test requests are received at least every 2 Hz\n    if (motor_test_request_received_time == 0 || millis() - motor_test_request_received_time > 500) {\n        // Send a timeout message\n        Serial.println(\"Motor test timed out\");\n\n        // Set the pass flag to false\n        motor_test_pass = false;\n\n        // Disable the motor test\n        motor_test_enabled = false;\n\n        // Disarm the system\n        disarm();\n\n        // Record the failure time\n        motor_test_failure_time = millis();\n\n        // Return false\n        return false;\n    }\n\n    // Return true\n    return true;\n}", "CodeBleu_score": 48.467495633997466}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    float roll_target_cd, pitch_target_cd;\n\n    // retrieve roll and pitch targets\n    wp_nav->get_roll_pitch(roll_target_cd, pitch_target_cd);\n\n    // constrain target roll and pitch to the range of roll and pitch limits\n    roll_target_cd = constrain_float(roll_target_cd, -roll_limit_cd, roll_limit_cd);\n    pitch_target_cd = constrain_float(pitch_target_cd, -pitch_limit_cd, pitch_limit_cd);\n\n    // normalize the roll and pitch targets\n    lateral_out = roll_target_cd / 100.0f;\n    forward_out = pitch_target_cd / 100.0f;\n}", "CodeBleu_score": 35.45314014624134}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch from wp_nav\n    float roll_cd, pitch_cd;\n    wp_nav.get_roll_pitch(roll_cd, pitch_cd);\n\n    // constrain target roll and pitch\n    float roll_out_cd = constrain_float(roll_cd, -roll_limit_cd, roll_limit_cd);\n    float pitch_out_cd = constrain_float(pitch_cd, -pitch_limit_cd, pitch_limit_cd);\n\n    // convert centidegrees to degrees\n    float roll_out = roll_out_cd * 0.01f;\n    float pitch_out = pitch_out_cd * 0.01f;\n\n    // rotate roll and pitch target to body frame\n    float roll_out_body, pitch_out_body;\n    rotate_bodyframe_to_neuframe(roll_out, pitch_out, yaw_deg, roll_out_body, pitch_out_body);\n\n    // convert body frame to forward/lateral\n    lateral_out = pitch_out_body;\n    forward_out = -roll_out_body;\n}", "CodeBleu_score": 32.434305703913516}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    float roll_target, pitch_target;\n    float max_roll, max_pitch;\n    float roll_in_cd, pitch_in_cd;\n    float roll_out_cd, pitch_out_cd;\n    float roll_out_ef, pitch_out_ef;\n\n    // get roll and pitch targets from wp_nav\n    wp_nav.get_roll_pitch(roll_target, pitch_target);\n\n    // get maximum roll and pitch\n    max_roll = constrain_float(wp_nav.get_max_roll_cd(), -roll_limit_cd, roll_limit_cd);\n    max_pitch = constrain_float(wp_nav.get_max_pitch_cd(), -pitch_limit_cd, pitch_limit_cd);\n\n    // constrain roll and pitch to the maximum range\n    roll_in_cd = constrain_float(roll_target, -max_roll, max_roll);\n    pitch_in_cd = constrain_float(pitch_target, -max_pitch, max_pitch);\n\n    // convert roll and pitch from centidegrees to degrees\n    roll_out_cd = roll_in_cd * 0.01f;\n    pitch_out_cd = pitch_in_cd * 0.01f;\n\n    // convert roll and pitch from degrees to earth frame\n    roll_out_ef = cosf(pitch_out_cd) * roll_out_cd + sinf(pitch_out_cd) * pitch_out_cd;\n    pitch_out_ef = -sinf(pitch_out_cd) * roll_out_cd + cosf(pitch_out_cd) * pitch_out_cd;\n\n    // apply lateral and forward limits\n    lateral_out = constrain_float(roll_out_ef, -roll_limit, roll_limit);\n    forward_out = constrain_float(pitch_out_ef, -pitch_limit, pitch_limit);\n}", "CodeBleu_score": 35.483055785917884}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t    // get barometer data\n    barometer.read();\n\n    // update barometer calibration\n    if (barometer.get_altitude() > 0.0f) {\n        barometer.update_calibration();\n    }\n\n    // update sensor health status based on barometer's health\n    if (depth_sensor_present) {\n        barometer_healthy = barometer.healthy();\n    }\n}", "CodeBleu_score": 67.04481026833481}, {"code": "void Sub::read_barometer(){\n\t\n    // read barometer\n    _barometer.read();\n\n    // update barometer calibration\n    if (_barometer.get_altitude() > 0) {\n        _barometer.update_calibration();\n    }\n\n    // update depth sensor health status based on barometer health\n    if (_depth_sensor.present()) {\n        _depth_sensor.set_healthy(_barometer.healthy());\n    }\n}", "CodeBleu_score": 64.18411077895495}, {"code": "void Sub::read_barometer(){\n\t    // read the barometer\n    barometer.update();\n\n    // update the barometer calibration\n    if (barometer.healthy() && barometer.altitude() > 0) {\n        barometer_calibration.update(barometer.altitude(), barometer.altitude_baro());\n    }\n\n    // update the sensor health status\n    if (depth_sensor_health_sensor != nullptr) {\n        depth_sensor_health_sensor->set_status(barometer.healthy());\n    }\n}", "CodeBleu_score": 57.472481745221295}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    // if we are in inertial navigation mode, we require a good absolute position\n    if (inertial_nav->get_filter_status() >= AP_InertialNav::EKF_OK_2D) {\n        // check if we are in constant position mode\n        if (is_flying_wing() && ahrs.in_constant_position_mode()) {\n            // if we are in constant position mode, we do not allow navigation\n            return false;\n        }\n        return true;\n    }\n\n    // if we are not in inertial navigation mode, we accept a predicted horizontal position\n    return is_flying_wing();\n}", "CodeBleu_score": 34.85876903448}, {"code": "bool Sub::ekf_position_ok(){\n\t    // if we have no inertial navigation, we don't know where we are, so we don't know if we are 'flying'\n    if (!have_inertial_nav()) {\n        return false;\n    }\n\n    // if motors are disarmed, we can only rely on EKF for horizontal position\n    if (motors->armed()) {\n        if (is_flying()) {\n            // if we are flying, we need to be flying with an absolute position\n            if (!ekf_absolute_position_ok()) {\n                return false;\n            }\n        } else {\n            // if we are not flying, we can only rely on EKF for horizontal position\n            if (!ekf_horizontal_position_ok()) {\n                return false;\n            }\n        }\n    }\n\n    // if we got this far we must be OK\n    return true;\n}", "CodeBleu_score": 25.824770317196105}, {"code": "bool Sub::ekf_position_ok(){\n\t    // if inertial navigation is not available, return false\n    if (!inertial_nav.enabled()) {\n        return false;\n    }\n\n    // if motors are disarmed, return true if we are in a constant position mode\n    if (!motors.armed()) {\n        return ahrs.precland_ekf_healthy();\n    }\n\n    // if motors are armed, require a good absolute position\n    // and ensure the EKF is not in constant position mode\n    return (ahrs.precland_ekf_healthy() &&\n            (AP::ahrs().precland_ekf_status() & (uint16_t)AHRS_EKF_CONSTPOS));\n}", "CodeBleu_score": 45.972493319070026}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // ensure position estimate is valid\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure AHRS system checks pass\n    if (!AP_Arming::ahrs_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure EKF failsafe is not tripped\n    if (!AP_Arming::ekf_failsafe_check(display_failure)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 23.406590154891415}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // call parent GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // exit immediately on fixed wing\n    if (rover.ap.land_complete || rover.failsafe.rth) {\n        return true;\n    }\n\n    // ensure position estimate is valid\n    if (!AP::ahrs().home_is_set() || AP::ahrs().prearm_home_state() != AP_AHRS::HOMED) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"GPS not ready\");\n        }\n        return false;\n    }\n\n    // ensure EKF is healthy\n    if (!AP::ahrs().healthy()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"EKF not healthy\");\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 51.31795595568865}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // call parent GPS check\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure position estimate is valid\n    if (!inertial_nav.has_valid_position()) {\n        if (display_failure) {\n            AP_HAL::console().printf(\"GPS fail\n\");\n        }\n        return false;\n    }\n\n    // ensure EKF is accepting position measurements\n    if (!inertial_nav.get_filter_status().flags.gps) {\n        if (display_failure) {\n            AP_HAL::console().printf(\"GPS fail\n\");\n        }\n        return false;\n    }\n\n    // ensure EKF is accepting velocity measurements\n    if (!inertial_nav.get_filter_status().flags.velocity_ok) {\n        if (display_failure) {\n            AP_HAL::console().printf(\"GPS fail\n\");\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 47.73303426924407}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // call the correct arming function\n    switch (method) {\n    case AP_Arming::Method::AUTO:\n        return arm_auto();\n    case AP_Arming::Method::STABILIZE:\n        return arm_stabilize();\n    case AP_Arming::Method::ACRO:\n        return arm_acro();\n    case AP_Arming::Method::RATTITUDE:\n        return arm_rattitude();\n    case AP_Arming::Method::MANUAL:\n        return arm_manual();\n    case AP_Arming::Method::SIMULATION:\n        return arm_simulation();\n    case AP_Arming::Method::INITIALISING:\n        return arm_initialising();\n    case AP_Arming::Method::DISARMED:\n        return arm_disarmed();\n    }\n    return false;\n}", "CodeBleu_score": 22.073679139478315}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // exit immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // exit immediately if not in a valid arming state\n    if (!_in_arming_checks && !_in_arming_delay && !_in_arming_delay_check) {\n        return false;\n    }\n\n    // record the arming method\n    _arming_method = method;\n\n    // run pre-checks\n    if (do_arming_checks) {\n        if (!pre_arm_checks(false)) {\n            return false;\n        }\n    }\n\n    // handle arming using the specified method\n    switch (method) {\n\n    case AP_Arming::Method::ANGLE_PASSTHROUGH:\n        // pass through to simple arming\n        return arm_simple();\n\n    case AP_Arming::Method::ANGLE_AUTO:\n        // pass through to simple arming\n        return arm_simple();\n\n    case AP_Arming::Method::ANGLE_INPUT:\n        // pass through to simple arming\n        return arm_simple();\n\n    case AP_Arming::Method::ANGLE_COMPASS:\n        // pass through to simple arming\n        return arm_simple();\n\n    case AP_Arming::Method::ANGLE_MOUNT:\n        // pass through to simple arming\n        return arm_simple();\n\n    case AP_Arming::Method::ANGLE_CUSTOM:\n        // pass through to simple arming\n        return arm_simple();\n\n    case AP_Arming::Method::ANGLE_CUSTOM_COMPASS:\n        // pass through to simple arming\n        return arm_simple();\n\n    case AP_Arming::Method::ANGLE_CUSTOM_MOUNT:\n        // pass through to simple arming\n        return arm_simple();\n\n    case AP_Arming::Method::ANGLE_GPS:\n        // pass through to simple arming\n        return arm_simple();\n\n    case AP_Arming::Method::ANGLE_GPS_COMPASS:\n        // pass through to simple arming\n        return arm_simple();\n\n    case AP_", "CodeBleu_score": 31.9738503250232}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // call parent arm method\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // if we're using a sailboat, we need to set the home position\n    // to the current location\n    if (rover.is_boat()) {\n        // set the home position to the current location\n        rover.set_home_to_current_location(false);\n    }\n\n    // set the initial simple mode heading\n    if (rover.control_mode == &rover.mode_simple) {\n        rover.mode_simple.set_heading(rover.ahrs.yaw);\n    }\n\n    // record the home heading for sail vehicles\n    if (rover.is_boat()) {\n        rover.mode_sailboat.record_home_heading();\n    }\n\n    // update the soft armed status\n    rover.set_armed_for_autotune(armed);\n\n    // send an arming status text\n    if (armed) {\n        AP_Notify::flags.armed = true;\n    } else {\n        AP_Notify::flags.armed = false;\n    }\n\n    // return success\n    return true;\n}", "CodeBleu_score": 61.08468256452553}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (!charging_enabled) {\n      charging_enabled = true;\n      charging_enabled_time = millis();\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      charging_disabled_time = millis();\n    }\n  }\n}", "CodeBleu_score": 31.392161787318784}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (!charging_enabled) {\n      // If we're not charging, and charging should be allowed, enable charging.\n      charging_enabled = true;\n      charging_disabled_time = 0;\n      // If we're not charging, and charging should be allowed, enable charging.\n      //Serial.println(\"Enabling charging\");\n      //digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n      //digitalWrite(CHARGE_DISABLE_PIN, LOW);\n      //digitalWrite(CHARGE_FAULT_PIN, LOW);\n    }\n  } else {\n    // If we're not allowed to charge, and we're charging, disable charging.\n    if (charging_enabled) {\n      // If we're charging, and charging should not be allowed, disable charging.\n      charging_enabled = false;\n      charging_disabled_time = millis();\n      //Serial.println(\"Disabling charging\");\n      //digitalWrite(CHARGE_ENABLE_PIN, LOW);\n      //digitalWrite(CHARGE_DISABLE_PIN, HIGH);\n      //digitalWrite(CHARGE_FAULT_PIN, LOW);\n    }\n  }\n}", "CodeBleu_score": 30.600512007294633}, {"code": "void updateChargingEnabled(){\n\t  static unsigned long last_enabled_time = 0;\n  static unsigned long last_disabled_time = 0;\n  static bool last_enabled_state = false;\n  static bool last_disabled_state = false;\n\n  // If charging is enabled, but should not continue, disable it and record the time.\n  if (charging_allowed && !last_enabled_state) {\n    charging_enabled = false;\n    last_disabled_time = millis();\n    last_disabled_state = true;\n    last_enabled_state = false;\n  }\n\n  // If charging is not allowed, retry enabling it after a specified delay, checking the conditions again to decide whether to enable or continue disabling it.\n  if (!charging_allowed && last_disabled_state && millis() - last_disabled_time > CHARGING_RETRY_DELAY) {\n    charging_enabled = true;\n    last_enabled_time = millis();\n    last_enabled_state = true;\n    last_disabled_state = false;\n  }\n}", "CodeBleu_score": 43.33552100745097}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t  if (packetSerial.availableForWrite() >= size + 2 && ros_running) {\n    FastCRC16 CRC;\n    CRC.add(message, size);\n    uint16_t crc = CRC.value();\n    packetSerial.write(message, size);\n    packetSerial.write(crc);\n    packetSerial.write(crc >> 8);\n  }\n}", "CodeBleu_score": 37.462416258669364}, {"code": "void sendMessage(void *message, size_t size){\n\t\n    if (!ui_board_is_ros_running()) {\n        return;\n    }\n\n    if (size < 4) {\n        return;\n    }\n\n    FastCRC32 crc32;\n    uint32_t crc = crc32.s32(message, size);\n\n    uint8_t *msg = (uint8_t *) malloc(size + 4);\n    memcpy(msg, message, size);\n    memcpy(msg + size, &crc, 4);\n\n    packetSerial.sendMessage(msg, size + 4);\n    free(msg);\n}", "CodeBleu_score": 47.42680683657965}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (ros_running && size >= 4) {\n        FastCRC16 CRC;\n        uint16_t crc = CRC.ccitt(message, size);\n        uint8_t *message_with_crc = (uint8_t *) malloc(size + 2);\n        memcpy(message_with_crc, message, size);\n        message_with_crc[size] = crc & 0xFF;\n        message_with_crc[size + 1] = crc >> 8;\n        packetSerial.write(message_with_crc, size + 2);\n        free(message_with_crc);\n    }\n}", "CodeBleu_score": 50.42076290248452}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t  Serial.begin(9600);\n  delay(100);\n  Serial.println(\"begin\");\n  delay(100);\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n    Serial.read();\n  }\n  if (Serial.available()) {\n", "CodeBleu_score": 43.25334318017246}, {"code": "bool MP3Sound::begin(){\n\t  Serial.begin(9600);\n  Serial.println(\"Initializing sound module...\");\n  delay(1000);\n  Serial.println(\"Sound module initialized\");\n  Serial.println(\"Retrieving number of sound files on SD card...\");\n  delay(1000);\n  soundFileCount = SD.open(\"/\").listDir(NULL, 0);\n  if (soundFileCount == 0) {\n    Serial.println(\"No sound files found on SD card\");\n    return false;\n  }\n  Serial.println(\"Sound files found on SD card\");\n  return true;\n}", "CodeBleu_score": 38.93193458672343}, {"code": "bool MP3Sound::begin(){\n\t\n  Serial.begin(9600);\n  delay(1000);\n  Serial.println(\"Sound module initializing...\");\n  Serial.println();\n  delay(1000);\n\n  Serial.println(\"Initializing sound module...\");\n  Serial.println();\n  delay(1000);\n  Serial.println(\"Clearing sound buffer...\");\n  delay(1000);\n  Serial.println();\n\n  if (Serial.available() > 0) {\n    Serial.read();\n  }\n\n  Serial.println(\"Sound module initialized.\");\n  Serial.println();\n  delay(1000);\n  Serial.println(\"Retrieving number of sound files available...\");\n  Serial.println();\n  delay(1000);\n\n  Serial.println(\"Number of sound files available:\");\n  Serial.println();\n  delay(1000);\n\n  if (Serial.available() > 0) {\n    Serial.read();\n  }\n\n  Serial.println(\"Sound module initialized.\");\n  Serial.println();\n  delay(1000);\n  Serial.println(\"Retrieving number of sound files available...\");\n  Serial.println();\n  delay(1000);\n\n  Serial.println(\"Number of sound files available:\");\n  Serial.println();\n  delay(1000);\n\n  if (Serial.available() > 0) {\n    Serial.read();\n  }\n\n  Serial.println(\"Sound module initialized.\");\n  Serial.println();\n  delay(1000);\n  Serial.println(\"Retrieving number of sound files available...\");\n  Serial.println();\n  delay(1000);\n\n  Serial.println(\"Number of sound files available:\");\n  Serial.println();\n  delay(1000);\n\n  if (Serial.available() > 0) {\n    Serial.read();\n  }\n\n  Serial.println(\"Sound module initialized.\");\n  Serial.println();\n  delay(1000);\n  Serial.println(\"Retrieving number of sound files available...\");\n  Serial.println();\n  delay(1000);\n\n  Serial.println(\"", "CodeBleu_score": 40.34389861567909}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t  if (activeSounds.size() == 0) {\n    return 0;\n  }\n  if (playing) {\n    return activeSounds.size();\n  }\n  sound = activeSounds.back();\n  activeSounds.pop_back();\n  playing = true;\n  return activeSounds.size();\n}", "CodeBleu_score": 41.794306239752245}, {"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (mp3Playing) {\n\t\treturn activeSounds.size();\n\t}\n\tmp3Playing = true;\n\tplaySound(activeSounds.back());\n\tactiveSounds.pop_back();\n\treturn activeSounds.size();\n}", "CodeBleu_score": 38.880580459607295}, {"code": "int MP3Sound::processSounds(){\n\t    if (activeSounds.size() == 0 || !mp3.isPlaying()) {\n        if (activeSounds.size() > 0) {\n            mp3.play(activeSounds.back());\n            activeSounds.pop_back();\n        }\n        return activeSounds.size();\n    }\n    return activeSounds.size();\n}", "CodeBleu_score": 40.57611943372875}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (camera->mmap_file != NULL)\n      munmap(camera->mmap_file, camera->mmap_file_size);\n    if (camera->mmap_file_size != r->size) {\n      if (camera->mmap_file != NULL)\n        close(camera->mmap_file_descriptor);\n      if (r->size == 0) {\n        camera->mmap_file = NULL;\n        camera->mmap_file_size = 0;\n        camera->mmap_file_descriptor = -1;\n        return true;\n      }\n      camera->mmap_file_size = r->size;\n      camera->mmap_file_descriptor = open(r->name, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n      if (camera->mmap_file_descriptor == -1) {\n        wbr_error(d->robot, \"cannot open memory-mapped file '%s'\", r->name);\n        return false;\n      }\n      if (ftruncate(camera->mmap_file_descriptor, camera->mmap_file_size) == -1) {\n        wbr_error(d->robot, \"cannot truncate memory-mapped file '%s'\", r->name);\n        return false;\n      }\n    }\n    camera->mmap_file = mmap(NULL, camera->mmap_file_size, PROT_READ | PROT_WRITE, MAP_SHARED, camera->mmap_file_descriptor, 0);\n    if (camera->mmap_file == MAP_FAILED) {\n      wbr_error(d->robot, \"cannot map memory-mapped file '%s'\", r->name);\n     ", "CodeBleu_score": 36.78074797633788}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (d->memory_mapped_file)\n      wb_abstract_camera_cleanup_memory_mapped_file(d);\n\n    d->memory_mapped_file = wb_abstract_camera_setup_memory_mapped_file(d, r);\n    return true;\n  } else {\n    d->command_handled = false;\n    return false;\n  }\n}", "CodeBleu_score": 27.900705584781}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      if (d->memory_mapped_file)\n        wb_abstract_camera_cleanup_memory_mapped_file(d);\n      return wb_abstract_camera_setup_memory_mapped_file(d, r);\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 38.341066468374045}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (d->type != WB_NODE_CAMERA) {\n    wb_robot_log_error(\"wb_abstract_camera_get_height\", \"Invalid device type.\");\n    return -1;\n  }\n\n  int height;\n  wb_mutex_lock(d->mutex);\n  if (d->camera_data_available) {\n    height = d->camera_data.height;\n  } else {\n    height = -1;\n  }\n  wb_mutex_unlock(d->mutex);\n\n  return height;\n}", "CodeBleu_score": 38.43049046356295}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (!d || d->type != WB_NODE_CAMERA) {\n    wb_robot_cleanup();\n    wb_exit(EXIT_FAILURE, \"Invalid device tag (%p) or wrong device type (%d).\", d, d ? d->type : -1);\n  }\n\n  wb_mutex_lock(&d->mutex);\n  int height = d->camera.height;\n  wb_mutex_unlock(&d->mutex);\n\n  return height;\n}", "CodeBleu_score": 43.802991899873575}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (d->type != WB_NODE_ABSTRACT_CAMERA) {\n    wb_robot_log_error(wb_robot_get_instance(), WB_ERROR_INVALID_ARGUMENT, \"wb_abstract_camera_get_height\", \"invalid device\");\n    return -1;\n  }\n\n  wb_abstract_camera_lock(d);\n  int height = d->camera_data.height;\n  wb_abstract_camera_unlock(d);\n  return height;\n}", "CodeBleu_score": 41.458304441349284}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  wb_accelerometer_t *accelerometer = wb_robot_get_device(tag);\n  if (!accelerometer) {\n    wb_error_with_tag(tag, \"device does not exist\");\n    return -1;\n  }\n  return accelerometer->sampling_period;\n}", "CodeBleu_score": 15.778001521580526}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  wb_accelerometer_t *accelerometer = wb_robot_get_device(tag);\n  if (accelerometer)\n    return accelerometer->sampling_period;\n\n  wb_robot_console_print_error(tag, \"wb_accelerometer_get_sampling_period: invalid device tag (%d).\n\", tag);\n  return 0;\n}", "CodeBleu_score": 33.038919355364385}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  wb_accelerometer_t *accelerometer = wb_robot_get_device_by_tag(tag);\n  if (!accelerometer) {\n    wb_robot_log_error_and_exit(\"wb_accelerometer_get_sampling_period\", \"invalid device tag\");\n  }\n  return accelerometer->sampling_period;\n}", "CodeBleu_score": 18.35555550067374}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  wb_gps_free_string(dms);\n  return result;\n}", "CodeBleu_score": 40.13597297503696}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *degreesMinutesSeconds = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dms = string(degreesMinutesSeconds);\n  wb_gps_free_string(degreesMinutesSeconds);\n  return dms;\n}", "CodeBleu_score": 48.25922015844922}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = dms;\n  wb_gps_free_string(dms);\n  return result;\n}", "CodeBleu_score": 43.852731638300156}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  dReal *axes;\n  dReal *p;\n  dReal *v;\n  dReal *c;\n  dReal *l;\n  dReal *h;\n  dReal *n;\n  dReal *d;\n  dReal *t;\n  dReal *s;\n  dReal *q;\n  dReal *r;\n  dReal *u;\n  dReal *v;\n  dReal *w;\n  dReal *x;\n  dReal *y;\n  dReal *z;\n  dReal *a;\n  dReal *b;\n  dReal *c;\n  dReal *d;\n  dReal *e;\n  dReal *f;\n  dReal *g;\n  dReal *h;\n  dReal *i;\n  dReal *j;\n  dReal *k;\n  dReal *l;\n  dReal *m;\n  dReal *n;\n  dReal *o;\n  dReal *p;\n  dReal *q;\n  dReal *r;\n  dReal *s;\n  dReal *t;\n  dReal *u;\n  dReal *v;\n  dReal *w;\n  dReal *x;\n  dReal *y;\n  dReal *z;\n  dReal *a;\n  dReal *b;\n  dReal *c;\n  dReal *d;\n  dReal *e;\n  dReal *f;\n  dReal *g;\n  dReal *h;\n  dReal *i;\n  dReal *j;\n  dReal *k;\n  dReal *l;\n  dReal *m;\n  dReal *n;\n  dReal *o;\n  dReal *p;\n  dReal *q;\n  dReal *r;\n  dReal *s;\n  dReal *t;\n  dReal *u;\n  dReal *v;\n  dReal *w;\n  dReal *x;\n  dReal *y;\n  dReal *z;\n  dReal *a;\n  dReal *b;\n  dReal *c;\n", "CodeBleu_score": 22.587550276134554}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dVector3 p;\n    dGeomGetOffsetPosition (g, p);\n    dReal dx = x - p[0];\n    dReal dy = y - p[1];\n    dReal dz = z - p[2];\n    dReal x2 = dx * dx;\n    dReal y2 = dy * dy;\n    dReal z2 = dz * dz;\n    dReal xy = dx * dy;\n    dReal xz = dx * dz;\n    dReal yz = dy * dz;\n    dReal x2_y2 = x2 + y2;\n    dReal x2_z2 = x2 + z2;\n    dReal y2_z2 = y2 + z2;\n    dReal x2_y2_z2 = x2_y2 + z2;\n    dReal xy_z2 = xy + z2;\n    dReal xy_yz = xy + yz;\n    dReal xz_yz = xz + yz;\n    dReal x2_y2_z2_xy_z2 = x2_y2_z2 + xy_z2;\n    dReal x2_y2_z2_xy_yz = x2_y2_z2 + xy_yz;\n    dReal x2_y2_z2_xz_yz = x2_y2_z2 + xz_yz;\n    dReal x2_y2_z2_xy_yz_xz_yz = x2_y2_z2_xy_yz + xz_yz;\n    dReal x2_y2_z2_xy_z2_xz_yz = x2_y2_z2_xz_yz + xy_z2;\n    dReal x2_y2_z2_xy_yz_xz_yz_xy_z2 = x2_y2_z2_xy_yz_xz_yz + xy_z2;\n    dReal x2_y2_z2_xy_yz_xz_yz_", "CodeBleu_score": 29.6278741415402}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dVector3 p;\n    dReal dx, dy, dz;\n    dReal x0, y0, z0;\n    dReal x1, y1, z1;\n    dReal x2, y2, z2;\n    dReal x3, y3, z3;\n    dReal x4, y4, z4;\n    dReal x5, y5, z5;\n    dReal x6, y6, z6;\n    dReal x7, y7, z7;\n    dReal x8, y8, z8;\n    dReal x9, y9, z9;\n    dReal x10, y10, z10;\n    dReal x11, y11, z11;\n    dReal x12, y12, z12;\n    dReal x13, y13, z13;\n    dReal x14, y14, z14;\n    dReal x15, y15, z15;\n    dReal x16, y16, z16;\n    dReal x17, y17, z17;\n    dReal x18, y18, z18;\n    dReal x19, y19, z19;\n    dReal x20, y20, z20;\n    dReal x21, y21, z21;\n    dReal x22, y22, z22;\n    dReal x23, y23, z23;\n    dReal x24, y24, z24;\n    dReal x25, y25, z25;\n    dReal x26, y26, z26;\n    dReal x27, y27, z27;\n    dReal x28, y28, z28;\n    dReal x29, y29, z29;\n    dReal x30, y30, z30;\n    dReal x31, y31, z31;\n    dReal x32, y32, z", "CodeBleu_score": 7.749764043999606}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  sBoxImmersionData data;\n  dGeomID geom = box->body;\n  int result;\n\n  assert (box->body);\n  assert (flags & dImmerseBoxFlags_All);\n  assert (flags & dImmerseBoxFlags_Geom);\n  assert (flags & dImmerseBoxFlags_Immersion);\n  assert (flags & dImmerseBoxFlags_FluidPlane);\n\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.immersion = immersion;\n  data.flags = flags;\n\n  result = dImmerseBoxInternal (&data);\n\n  return result;\n}", "CodeBleu_score": 42.18758705515334}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  sBoxImmersionData data;\n\n  data.box = box;\n  data.immersion = immersion;\n  data.flags = flags;\n  data.fluidPlane = fluidPlane;\n\n  return dImmerseBoxData (&data);\n}", "CodeBleu_score": 43.146084352669924}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t   dImmersionGeom *immersionData;\n   int result;\n\n   if (!box->body) {\n      immersion->flags = dImmersionGeomFlags_NoBody;\n      return 0;\n   }\n   if (!(flags & dImmersionGeomFlags_Immersion)) {\n      immersion->flags = dImmersionGeomFlags_NoImmersion;\n      return 0;\n   }\n   if (flags & dImmersionGeomFlags_NoImmersion) {\n      immersion->flags = dImmersionGeomFlags_NoImmersion;\n      return 0;\n   }\n   if (!(flags & dImmersionGeomFlags_FluidPlane)) {\n      immersion->flags = dImmersionGeomFlags_NoFluidPlane;\n      return 0;\n   }\n   if (flags & dImmersionGeomFlags_NoFluidPlane) {\n      immersion->flags = dImmersionGeomFlags_NoFluidPlane;\n      return 0;\n   }\n\n   immersionData = (dImmersionGeom *) dAlloc (sizeof (dImmersionGeom));\n   if (!immersionData) {\n      immersion->flags = dImmersionGeomFlags_NoMem;\n      return 0;\n   }\n   immersionData->box = box;\n   immersionData->fluidPlane = fluidPlane;\n   immersionData->flags = flags;\n\n   result = dImmersionBox (immersionData, immersion);\n   dFree (immersionData);\n\n   return result;\n}", "CodeBleu_score": 38.16719043681985}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dReal *p1, *p2, *p3, *p4;\n  dReal *p5, *p6, *p7, *p8;\n  dReal *p9, *p10, *p11, *p12;\n  dReal *p13, *p14, *p15, *p16;\n  dReal *p17, *p18, *p19, *p20;\n  dReal *p21, *p22, *p23, *p24;\n  dReal *p25, *p26, *p27, *p28;\n  dReal *p29, *p30, *p31, *p32;\n  dReal *p33, *p34, *p35, *p36;\n  dReal *p37, *p38, *p39, *p40;\n  dReal *p41, *p42, *p43, *p44;\n  dReal *p45, *p46, *p47, *p48;\n  dReal *p49, *p50, *p51, *p52;\n  dReal *p53, *p54, *p55, *p56;\n  dReal *p57, *p58, *p59, *p60;\n  dReal *p61, *p62, *p63, *p64;\n  dReal *p65, *p66, *p67, *p68;\n  dReal *p69, *p70, *p71, *p72;\n  dReal *p73, *p74, *p75, *p76;\n  dReal *p77, *p78, *p79, *p80;\n  dReal *p81, *p82, *p83, *p84;\n  dReal *p85, *p86, *p87", "CodeBleu_score": 5.658280597815608}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dReal *pos1;\n  dReal *pos2;\n  dReal *rot1;\n  dReal *rot2;\n  dReal *pos1_imm;\n  dReal *pos2_imm;\n  dReal *rot1_imm;\n  dReal *rot2_imm;\n  dReal *imm_plane;\n  dReal *imm_plane_normal;\n  dReal *imm_plane_point;\n  dReal *imm_plane_point_normal;\n  dReal *imm_plane_point_normal_imm;\n  dReal *imm_plane_point_normal_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm_imm_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm_imm_imm_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm;\n  dReal *imm_plane_point_normal_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm_imm;\n  dReal *", "CodeBleu_score": 5.315382421852838}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dImmerseBoxCapsuleData *data;\n  dImmerseBoxCapsuleData *data2;\n  dReal *pos1, *pos2, *quat1, *quat2;\n  dReal *box_pos, *box_quat;\n  dReal *capsule_pos, *capsule_quat;\n  dReal *box_pos2, *box_quat2;\n  dReal *capsule_pos2, *capsule_quat2;\n  dReal *box_pos3, *box_quat3;\n  dReal *capsule_pos3, *capsule_quat3;\n  dReal *box_pos4, *box_quat4;\n  dReal *capsule_pos4, *capsule_quat4;\n  dReal *box_pos5, *box_quat5;\n  dReal *capsule_pos5, *capsule_quat5;\n  dReal *box_pos6, *box_quat6;\n  dReal *capsule_pos6, *capsule_quat6;\n  dReal *box_pos7, *box_quat7;\n  dReal *capsule_pos7, *capsule_quat7;\n  dReal *box_pos8, *box_quat8;\n  dReal *capsule_pos8, *capsule_quat8;\n  dReal *box_pos9, *box_quat9;\n  dReal *capsule_pos9, *capsule_quat9;\n  dReal *box_pos10, *box_quat10;\n  dReal *capsule_pos10, *capsule_quat10;\n  dReal *box_pos11, *box_quat11;\n  dReal *capsule_pos11, *capsule_quat11;\n  dReal *box_pos12, *box_quat12;\n  dReal *capsule_pos12, *capsule_quat1", "CodeBleu_score": 7.236095394352522}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t  dReal zIOverR2 = zIOverR * zIOverR;\n  dReal tanTheta02 = tanTheta0 * tanTheta0;\n  dReal sinTheta12 = sinTheta1 * sinTheta1;\n  dReal sinTheta14 = sinTheta12 * sinTheta12;\n\n  dReal zIOverR4 = zIOverR2 * zIOverR2;\n  dReal tanTheta04 = tanTheta02 * tanTheta02;\n  dReal sinTheta16 = sinTheta12 * sinTheta14;\n\n  dReal zIOverR6 = zIOverR2 * zIOverR4;\n  dReal tanTheta06 = tanTheta02 * tanTheta04;\n  dReal sinTheta18 = sinTheta12 * sinTheta16;\n\n  dReal zIOverR8 = zIOverR2 * zIOverR6;\n  dReal tanTheta08 = tanTheta02 * tanTheta06;\n  dReal sinTheta110 = sinTheta12 * sinTheta18;\n\n  dReal zIOverR10 = zIOverR2 * zIOverR8;\n  dReal tanTheta010 = tanTheta02 * tanTheta08;\n  dReal sinTheta112 = sinTheta12 * sinTheta110;\n\n  dReal zIOverR12 = zIOverR2 * zIOverR10;\n  dReal tanTheta012 = tanTheta02 * tanTheta010;\n  dReal sinTheta114 = sinTheta12 * sinTheta112;\n\n  dReal zIOverR14 = zIOverR2 * zIOverR12;\n  dReal tanTheta014 = tanTheta02 * tanTheta012;\n  dReal sinTheta116 = sinTheta12 * sinTheta114;\n\n  dReal zIOverR16 = zIOverR2 * zIOverR14;\n  dReal tanTheta016 = tanTheta02 * tanTheta014;\n  dReal sinTheta118 = sin", "CodeBleu_score": 34.36342415179028}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal tanTheta02 = tanTheta0 * tanTheta0;\n\tdReal sinTheta12 = sinTheta1 * sinTheta1;\n\tdReal sinTheta14 = sinTheta12 * sinTheta12;\n\n\tdReal volume = 0.0;\n\n\tvolume += (zIOverR2 + tanTheta02) / (zIOverR2 + 1.0);\n\tvolume += (zIOverR2 + tanTheta02) * (1.0 - tanTheta02) / (zIOverR2 + 1.0) * (sinTheta12 + tanTheta02);\n\tvolume += (zIOverR2 + tanTheta02) * (1.0 - tanTheta02) * (1.0 - 2.0 * tanTheta02) / (zIOverR2 + 1.0) * (sinTheta14 + sinTheta12 + 2.0 * tanTheta02);\n\n\treturn volume;\n}", "CodeBleu_score": 38.86381434473721}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal tanTheta02 = tanTheta0 * tanTheta0;\n\n\tdReal a = zIOverR * tanTheta0;\n\tdReal b = zIOverR2 * tanTheta02;\n\tdReal c = zIOverR2 * tanTheta0;\n\n\tdReal d = a * a - b;\n\tdReal e = a * a - c;\n\n\tdReal f = sqrt(d);\n\tdReal g = sqrt(e);\n\n\tdReal h = a + f;\n\tdReal i = a + g;\n\n\tdReal j = a - f;\n\tdReal k = a - g;\n\n\tdReal l = zIOverR * (h + i);\n\tdReal m = zIOverR2 * (j + k);\n\n\tdReal n = zIOverR * (h - i);\n\tdReal o = zIOverR2 * (j - k);\n\n\tdReal p = l + m;\n\tdReal q = n + o;\n\n\tdReal r = l - m;\n\tdReal s = n - o;\n\n\tdReal t = zIOverR * (p + q);\n\tdReal u = zIOverR2 * (r + s);\n\n\tdReal v = zIOverR * (p - q);\n\tdReal w = zIOverR2 * (r - s);\n\n\tdReal x = (u + w) * (u + w) + (v + w) * (v + w);\n\n\tdReal y = (u - w) * (u - w) + (v - w) * (v - w);\n\n\tdReal z = sqrt(x);\n\n\tdReal A = (z - y) / (2 * z);\n\n\tdReal B = (z + y) / (2 * z);\n\n\tdReal C = (z + y) / (2 * z);\n\n\tdReal D = (z - y) / (2 * z);\n\n\tdReal E = (z + y) / (2", "CodeBleu_score": 32.41280351722907}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal xBuoyancyCenter;\n\n\txBuoyancyCenter = (zIOverR * tanTheta0 + zIOverR * (zIOverR * tanTheta0 + sinTheta1) / 3.0) * volume;\n\n\treturn xBuoyancyCenter;\n}", "CodeBleu_score": 32.23530383840757}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal r = immersionDepthRatio * radius;\n\tdReal r2 = r * r;\n\tdReal r4 = r2 * r2;\n\tdReal r6 = r4 * r2;\n\tdReal r8 = r4 * r4;\n\tdReal r10 = r8 * r2;\n\tdReal r12 = r8 * r4;\n\tdReal r14 = r12 * r2;\n\tdReal r16 = r12 * r4;\n\tdReal r18 = r16 * r2;\n\tdReal r20 = r16 * r4;\n\tdReal r22 = r20 * r2;\n\tdReal r24 = r20 * r4;\n\tdReal r26 = r24 * r2;\n\tdReal r28 = r24 * r4;\n\tdReal r30 = r28 * r2;\n\tdReal r32 = r28 * r4;\n\tdReal r34 = r32 * r2;\n\tdReal r36 = r32 * r4;\n\tdReal r38 = r36 * r2;\n\tdReal r40 = r36 * r4;\n\tdReal r42 = r40 * r2;\n\tdReal r44 = r40 * r4;\n\tdReal r46 = r44 * r2;\n\tdReal r48 = r44 * r4;\n\tdReal r50 = r48 * r2;\n\tdReal r52 = r48 * r4;\n\tdReal r54 = r52 * r2;\n\tdReal r56 = r52 * r4;\n\tdReal r58 = r56 * r2;\n\tdReal r60 = r56 * r4;\n\tdReal r62 = r60 * r2;\n\tdReal r64 = r60 * r4;\n\tdReal r66 = r64 * r2;\n\tdReal r68 = r64 * r4;\n", "CodeBleu_score": 34.378346010619296}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal x = 0.0;\n\tdReal r = m_radius;\n\tdReal r2 = r * r;\n\tdReal z0 = zIOverR * r;\n\tdReal z1 = z0 * tanTheta0;\n\tdReal z2 = z1 * tanTheta0;\n\tdReal z3 = z2 * tanTheta0;\n\tdReal z4 = z3 * tanTheta0;\n\tdReal z5 = z4 * tanTheta0;\n\tdReal z6 = z5 * tanTheta0;\n\tdReal z7 = z6 * tanTheta0;\n\tdReal z8 = z7 * tanTheta0;\n\tdReal z9 = z8 * tanTheta0;\n\tdReal z10 = z9 * tanTheta0;\n\tdReal z11 = z10 * tanTheta0;\n\tdReal z12 = z11 * tanTheta0;\n\tdReal z13 = z12 * tanTheta0;\n\tdReal z14 = z13 * tanTheta0;\n\tdReal z15 = z14 * tanTheta0;\n\tdReal z16 = z15 * tanTheta0;\n\tdReal z17 = z16 * tanTheta0;\n\tdReal z18 = z17 * tanTheta0;\n\tdReal z19 = z18 * tanTheta0;\n\tdReal z20 = z19 * tanTheta0;\n\tdReal z21 = z20 * tanTheta0;\n\tdReal z22 = z21 * tanTheta0;\n\tdReal z23 = z22 * tanTheta0;\n\tdReal z24 = z23 * tanTheta0;\n\tdReal z25 = z24 * tanTheta0;\n\tdReal z26 = z25 * tanTheta0;\n\tdReal z27 = z26 * tanTheta0;\n\tdReal z28 = z27 * tanTheta0;\n\tdReal z29 = z28 * tanTheta0;\n\tdReal z30 = z29 * tanTheta0;\n\tdReal z31", "CodeBleu_score": 35.5624503901448}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdReal volume;\n\tdReal immersion_depth_ratio;\n\tdReal tangent_of_initial_angle;\n\tdReal sine_of_final_angle;\n\tdReal x_coordinate_of_buoyancy_center;\n\tdReal radius;\n\tdReal radius_squared;\n\tdReal volume_scaled_by_radius;\n\tdReal volume_scaled_by_radius_and_adjusted_by_volume;\n\tdReal radius_squared_scaled_by_volume;\n\tdReal radius_squared_scaled_by_volume_and_adjusted_by_volume;\n\tdReal volume_scaled_by_radius_squared;\n\tdReal volume_scaled_by_radius_squared_and_adjusted_by_volume;\n\tdReal radius_squared_scaled_by_volume_squared;\n\tdReal radius_squared_scaled_by_volume_squared_and_adjusted_by_volume;\n\tdReal volume_scaled_by_radius_cubed;\n\tdReal volume_scaled_by_radius_cubed_and_adjusted_by_volume;\n\tdReal radius_squared_scaled_by_volume_cubed;\n\tdReal radius_squared_scaled_by_volume_cubed_and_adjusted_by_volume;\n\tdReal volume_scaled_by_radius_to_the_power_of_four;\n\tdReal volume_scaled_by_radius_to_the_power_of_four_and_adjusted_by_volume;\n\tdReal radius_squared_scaled_by_volume_to_the_power_of_four;\n\tdReal radius_squared_scaled_by_volume_to_the_power_of_four_and_adjusted_by_volume;\n\tdReal volume_scaled_by_radius_to_the_power_of_five;\n\tdReal volume_scaled_by_radius_to_the_power_of_five_and_adjusted_by_volume;\n\td", "CodeBleu_score": 5.500014744661711}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dImmerseCapsuleTrimeshData *data = (dImmerseCapsuleTrimeshData *)immersion->data;\n  dImmerseCapsuleTrimeshData *data1 = (dImmerseCapsuleTrimeshData *)o1->data;\n  dImmerseCapsuleTrimeshData *data2 = (dImmerseCapsuleTrimeshData *)o2->data;\n  dReal depth;\n  dReal depth1;\n  dReal depth2;\n  dReal depth_ratio;\n  dReal depth_ratio1;\n  dReal depth_ratio2;\n  dReal depth_ratio_ratio;\n  dReal depth_ratio_ratio1;\n  dReal depth_ratio_ratio2;\n  dReal depth_ratio_ratio_ratio;\n  dReal depth_ratio_ratio_ratio1;\n  dReal depth_ratio_ratio_ratio2;\n  dReal depth_ratio_ratio_ratio_ratio;\n  dReal depth_ratio_ratio_ratio_ratio1;\n  dReal depth_ratio_ratio_ratio_ratio2;\n  dReal depth_ratio_ratio_ratio_ratio_ratio;\n  dReal depth_ratio_ratio_ratio_ratio_ratio1;\n  dReal depth_ratio_ratio_ratio_ratio_ratio2;\n  dReal depth_ratio_ratio_ratio_ratio_ratio_ratio;\n  dReal depth_ratio_ratio_ratio_ratio_ratio_ratio1;\n  dReal depth_ratio_ratio_ratio_ratio_ratio_ratio2;\n  dReal depth_ratio_ratio_ratio_ratio_ratio_ratio_ratio;\n  dReal depth_ratio_ratio_ratio_ratio_ratio_ratio_ratio1;\n  dReal depth_ratio_ratio_ratio_ratio_ratio_ratio_ratio2;\n  dReal depth_ratio_ratio_ratio_ratio_ratio_ratio_ratio_ratio;\n  dReal depth_ratio_ratio_ratio_ratio_ratio_ratio_ratio_ratio1;\n  dReal depth_ratio_ratio_ratio_ratio_ratio_ratio_ratio_ratio2;\n  dReal depth_ratio_ratio_", "CodeBleu_score": 20.61186605585153}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmerseCapsuleTrimeshData *data;\n\tdImmerseCapsuleTrimeshData *data2;\n\tdImmerseCapsuleTrimeshData *data3;\n\tdImmerseCapsuleTrimeshData *data4;\n\tdImmerseCapsuleTrimeshData *data5;\n\tdImmerseCapsuleTrimeshData *data6;\n\tdImmerseCapsuleTrimeshData *data7;\n\tdImmerseCapsuleTrimeshData *data8;\n\tdImmerseCapsuleTrimeshData *data9;\n\tdImmerseCapsuleTrimeshData *data10;\n\tdImmerseCapsuleTrimeshData *data11;\n\tdImmerseCapsuleTrimeshData *data12;\n\tdImmerseCapsuleTrimeshData *data13;\n\tdImmerseCapsuleTrimeshData *data14;\n\tdImmerseCapsuleTrimeshData *data15;\n\tdImmerseCapsuleTrimeshData *data16;\n\tdImmerseCapsuleTrimeshData *data17;\n\tdImmerseCapsuleTrimeshData *data18;\n\tdImmerseCapsuleTrimeshData *data19;\n\tdImmerseCapsuleTrimeshData *data20;\n\tdImmerseCapsuleTrimeshData *data21;\n\tdImmerseCapsuleTrimeshData *data22;\n\tdImmerseCapsuleTrimeshData *data23;\n\tdImmerseCapsuleTrimeshData *data24;\n\tdImmerseCapsuleTrimeshData *data25;\n\tdImmerseCapsuleTrimeshData *data26;\n\tdImmerseCapsuleTrimeshData *data27;\n\tdImmerseCapsuleTrimeshData *data28;\n\tdImmerseCapsuleTrimeshData *data29;\n", "CodeBleu_score": 6.304552759751464}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t  // Get the sleep duration\n  double duration = getInput<double>(\"duration\");\n\n  // If the duration is missing or non-positive, return SUCCESS\n  if (!duration || duration <= 0.0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n\n  // Start a timer\n  timer_ = std::make_unique<ros::Timer>(\n      nh_.createTimer(ros::Duration(duration), &SleepNode::onTimer, this));\n\n  // Set a callback to emit a wake-up signal when the timer expires\n  timer_waiting_ = true;\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 38.71712620114025}, {"code": "NodeStatus SleepNode::onStart(){\n\t  if ( !getInput<int>(\"duration_ms\", duration_ms_) ) {\n    return NodeStatus::SUCCESS;\n  }\n\n  if ( duration_ms_ <= 0 ) {\n    return NodeStatus::SUCCESS;\n  }\n\n  status_ = NodeStatus::RUNNING;\n  timer_waiting_ = true;\n  timer_ = nh_.createTimer(ros::Duration(duration_ms_/1000.0), &SleepNode::timerCallback, this);\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 35.4568263286675}, {"code": "NodeStatus SleepNode::onStart(){\n\t\n  double duration_ms;\n  if (!getInput(\"duration_ms\", duration_ms)) {\n    return NodeStatus::SUCCESS;\n  }\n\n  if (duration_ms <= 0.0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  setStatus(NodeStatus::RUNNING);\n  timer_waiting_ = true;\n  timer_ = std::make_shared<ros::Timer>(nh_.createTimer(ros::Duration(duration_ms / 1000.0), &SleepNode::timerCallback, this, true, false));\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 47.55657307016949}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  Entry* entry = getEntry();\n  if (entry == nullptr) {\n    return NodeStatus::FAILURE;\n  }\n\n  EntryLock lock(entry);\n  if (entry->sequence_id != sequence_id_) {\n    sequence_id_ = entry->sequence_id;\n    return NodeStatus::SUCCESS;\n  }\n\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 37.690337491021765}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    EntryState state;\n    if (blackboard->getEntryState(key, state)) {\n        if (state.sequence_id != sequence_id) {\n            sequence_id = state.sequence_id;\n            return NodeStatus::SUCCESS;\n        }\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 29.56903814117463}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    EntryState* entry = getInput<EntryState>(\"entry\");\n    if (!entry) {\n        throw BT::RuntimeError(\"missing required input [entry]\");\n    }\n\n    std::lock_guard<std::mutex> lock(entry->mutex);\n\n    if (entry->sequence_id != sequence_id_) {\n        sequence_id_ = entry->sequence_id;\n        return NodeStatus::SUCCESS;\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 33.357549730718816}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t  if (m_successThreshold < 0) {\n    return static_cast<size_t>(std::max(m_successThreshold, -static_cast<int>(m_children.size())));\n  }\n  return static_cast<size_t>(m_successThreshold);\n}", "CodeBleu_score": 53.62245290337548}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  if (m_successThreshold < 0) {\n    return static_cast<size_t>(\n        std::max(0, static_cast<int>(m_children.size()) + m_successThreshold));\n  }\n  return m_successThreshold;\n}", "CodeBleu_score": 53.76710696365825}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  if (m_successThreshold < 0) {\n    return std::max<int>(0, m_successThreshold + static_cast<int>(m_children.size()));\n  } else {\n    return static_cast<size_t>(m_successThreshold);\n  }\n}", "CodeBleu_score": 58.24907637675049}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t    bool is_active = false;\n    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        auto now = std::chrono::system_clock::now();\n        auto diff = now - last_heartbeat_;\n        if (diff > std::chrono::seconds(10)) {\n            if (is_active) {\n                is_active = false;\n                enable_breakpoints_ = false;\n                for (auto& bp : breakpoints_) {\n                    bp.second.enabled = false;\n                }\n            }\n        } else {\n            if (!is_active) {\n                is_active = true;\n                enable_breakpoints_ = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 51.42131379867063}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        // Sleep for 10 milliseconds\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n        // Get the current time\n        auto now = std::chrono::high_resolution_clock::now();\n\n        // Check if the heartbeat is still active\n        bool heartbeat_active = (now - last_heartbeat) < std::chrono::milliseconds(1000);\n\n        // Check if the heartbeat status has changed\n        if (heartbeat_active != heartbeat_enabled) {\n            // Enable or disable all breakpoints\n            if (heartbeat_active) {\n                enableAllBreakpoints();\n            } else {\n                disableAllBreakpoints();\n            }\n\n            // Update the heartbeat status\n            heartbeat_enabled = heartbeat_active;\n        }\n    }\n}", "CodeBleu_score": 50.030566419404146}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while(true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n    if (heartbeat_active_ == false) {\n      continue;\n    }\n\n    auto now = std::chrono::steady_clock::now();\n\n    if (now > last_heartbeat_ + std::chrono::seconds(10)) {\n      heartbeat_active_ = false;\n      enableAllBreakpoints(false);\n    }\n  }\n}", "CodeBleu_score": 36.83754646260493}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> output;\n\n  if (bb_list.empty()) {\n    return output;\n  }\n\n  std::vector<std::string> bb_names = splitString(bb_list, ',');\n\n  for (const auto& bb_name : bb_names) {\n    auto subtree = root_node_->getSubtree(bb_name);\n\n    if (!subtree) {\n      continue;\n    }\n\n    subtree->lock();\n\n    if (subtree->getStatus() != BT::NodeStatus::IDLE) {\n      subtree->unlock();\n      continue;\n    }\n\n    auto bb = subtree->blackboard();\n\n    if (!bb) {\n      subtree->unlock();\n      continue;\n    }\n\n    auto json_str = bb->toJson();\n\n    if (json_str.empty()) {\n      subtree->unlock();\n      continue;\n    }\n\n    rapidjson::Document json_doc;\n    json_doc.Parse(json_str.c_str());\n\n    if (json_doc.HasParseError()) {\n      subtree->unlock();\n      continue;\n    }\n\n    output.insert(output.end(), json_doc.GetString(), json_doc.GetString() + json_doc.GetStringLength());\n    output.push_back('\n');\n\n    subtree->unlock();\n  }\n\n  return output;\n}", "CodeBleu_score": 44.179823951495344}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\n    // Split the input string into a vector of blackboard names\n    std::vector<std::string> bb_names = BT::splitString(bb_list, \",\");\n\n    // Create a JSON object to store the blackboards\n    json j;\n\n    // Iterate through the blackboard names\n    for (const auto& bb_name : bb_names) {\n        // Find the corresponding subtree\n        auto subtree = _tree.rootNode()->subtree(bb_name);\n\n        // Lock the subtree\n        std::unique_lock<std::mutex> lock(subtree->mutex());\n\n        // Check if the subtree is valid\n        if (subtree) {\n            // Export the blackboard to JSON\n            json j_bb = subtree->blackboard_mutable_ptr()->toJson();\n\n            // Add the blackboard to the JSON object\n            j[bb_name] = j_bb;\n        }\n    }\n\n    // Convert the JSON object to MessagePack format\n    std::vector<uint8_t> msgpack_data = json::to_msgpack(j);\n\n    // Return the MessagePack data\n    return msgpack_data;\n}", "CodeBleu_score": 48.24734992434424}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    rapidjson::Document json_bb_list(rapidjson::kArrayType);\n\n    std::vector<std::string> bb_names = splitString(bb_list, ',');\n    for (const std::string& bb_name : bb_names) {\n        rapidjson::Value json_bb_name;\n        json_bb_name.SetString(bb_name.c_str(), bb_name.size(), json_bb_list.GetAllocator());\n        json_bb_list.PushBack(json_bb_name, json_bb_list.GetAllocator());\n    }\n\n    rapidjson::Document json_bb(rapidjson::kObjectType);\n    for (const auto& bb_name : bb_names) {\n        auto subtree = tree_->rootNode().getSubtree(bb_name);\n        if (subtree) {\n            subtree->lock();\n            std::string json_str = subtree->toJSON();\n            rapidjson::Document json_subtree;\n            json_subtree.Parse(json_str.c_str());\n            json_bb.AddMember(bb_name.c_str(), json_subtree, json_bb.GetAllocator());\n        }\n    }\n\n    rapidjson::Document json_message(rapidjson::kObjectType);\n    json_message.AddMember(\"type\", \"blackboards\", json_message.GetAllocator());\n    json_message.AddMember(\"blackboards\", json_bb, json_message.GetAllocator());\n    json_message.AddMember(\"blackboard_names\", json_bb_list, json_message.GetAllocator());\n\n    std::vector<uint8_t> msg;\n    rapidjson::StringBuffer buffer;\n    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);\n    json_message.Accept(writer);\n    msg.insert(msg.end(), buffer.GetString(), buffer.GetString() + buffer.GetSize());\n\n    return msg;\n}", "CodeBleu_score": 43.388240217086874}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::lock_guard<std::mutex> lock(mutex_);\n  auto it = hooks_.find(pos);\n  if (it == hooks_.end()) {\n    return false;\n  }\n  auto hook = it->second;\n  if (hook->node_uid != node_uid) {\n    return false;\n  }\n  if (hook->status != HookStatus::BREAKPOINT) {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->cond.notify_all();\n  return true;\n}", "CodeBleu_score": 51.86629432207008}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto it = hooks_.find(node_uid);\n  if (it == hooks_.end()) {\n    return false;\n  }\n\n  auto& hook = it->second;\n  if (hook.node_status != NodeStatus::BREAKPOINT) {\n    return false;\n  }\n\n  std::lock_guard<std::mutex> lock(hook.mutex);\n\n  hook.node_status = result;\n  hook.remove = remove;\n  hook.ready = true;\n  hook.condition.notify_all();\n\n  return true;\n}", "CodeBleu_score": 43.877243592256356}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  // Search for the node by its UID\n  auto it = std::find_if(nodes_.begin(), nodes_.end(),\n                         [node_uid](const NodeInfo& node) {\n                           return node.uid == node_uid;\n                         });\n\n  // If the node is not found, return false\n  if (it == nodes_.end()) {\n    return false;\n  }\n\n  // Retrieve the associated hook\n  Hook& hook = it->hook;\n\n  // Lock the hook's mutex\n  std::unique_lock<std::mutex> lock(hook.mutex);\n\n  // Check if the hook is in BREAKPOINT mode\n  if (hook.mode == Hook::BREAKPOINT) {\n    // Set the desired status and removal flag\n    hook.status = result;\n    hook.remove = remove;\n\n    // Mark the hook as ready and notify all waiting threads\n    hook.ready = true;\n    hook.condition.notify_all();\n\n    // Return true to indicate success\n    return true;\n  }\n\n  // Return false to indicate failure\n  return false;\n}", "CodeBleu_score": 51.14717787721486}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    if (status() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_ = false;\n\n        coro_go(tick_thread);\n    }\n\n    if (halt_requested_) {\n        setStatus(NodeStatus::IDLE);\n        halt_requested_ = false;\n    }\n\n    if (exception_) {\n        try {\n            std::rethrow_exception(exception_);\n        } catch (const std::exception& e) {\n            exception_ = nullptr;\n            setStatus(NodeStatus::FAILURE);\n            logError(\"%s\", e.what());\n        }\n    }\n\n    return status();\n}", "CodeBleu_score": 43.244688359655726}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status() == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_ = false;\n\n    // start a new asynchronous thread to run the tick function\n    coro_go(tick_thread_func());\n  }\n\n  // if the tick function completes without a halt request, update the node status\n  if (!halt_requested_) {\n    setStatus(NodeStatus::SUCCESS);\n  }\n\n  // check for any stored exceptions and rethrow them if present\n  try {\n    if (exception_) {\n      std::rethrow_exception(exception_);\n    }\n  } catch (const std::exception& e) {\n    setStatus(NodeStatus::FAILURE);\n    exception_ = nullptr;\n    throw;\n  }\n\n  return status();\n}", "CodeBleu_score": 31.828099599395276}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    if (status() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_ = false;\n        coro_ = std::thread([this]() {\n            try {\n                tick();\n                if (!halt_requested_) {\n                    setStatus(NodeStatus::SUCCESS);\n                }\n            } catch (...) {\n                setStatus(NodeStatus::IDLE);\n                exception_ = std::current_exception();\n            }\n        });\n    }\n\n    if (exception_) {\n        std::rethrow_exception(exception_);\n    }\n    return status();\n}", "CodeBleu_score": 41.39086357677887}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  stream << \"------------------------------\" << std::endl;\n  stream << \"Printing tree\" << std::endl;\n  stream << \"------------------------------\" << std::endl;\n\n  auto print_node = [&stream, &print_node](const TreeNode* node, int depth) {\n    char separator[200] = \"\";\n    for (int i = 0; i < depth; i++) {\n      strcat(separator, \"| \");\n    }\n\n    if (node->type() == NodeType::ROOT) {\n      stream << separator << \"ROOT\" << std::endl;\n    } else if (node->type() == NodeType::CONTROL) {\n      stream << separator << \"ControlNode: \" << node->name() << std::endl;\n    } else if (node->type() == NodeType::DECORATOR) {\n      stream << separator << \"DecoratorNode: \" << node->name() << std::endl;\n    } else if (node->type() == NodeType::ACTION) {\n      stream << separator << \"ActionNode: \" << node->name() << std::endl;\n    } else if (node->type() == NodeType::CONDITIONAL) {\n      stream << separator << \"ConditionalNode: \" << node->name() << std::endl;\n    }\n\n    if (node->type() == NodeType::CONTROL || node->type() == NodeType::DECORATOR) {\n      for (auto child : node->children()) {\n        print_node(child, depth + 1);\n      }\n    } else if (node->type() == NodeType::ACTION || node->type() == NodeType::CONDITIONAL) {\n      print_node(node->child(), depth + 1);\n    }\n  };\n\n  print_node(root_node, 0);\n\n  stream << \"------------------------------\" << std::endl;\n}", "CodeBleu_score": 49.38854754093737}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    stream << \"-------------------------\n\";\n    auto print_node = [&](const TreeNode* node, unsigned depth) {\n        stream << std::string(depth, ' ') << node->name() << std::endl;\n    };\n    std::function<void(const TreeNode*, unsigned)> print_tree;\n    print_tree = [&](const TreeNode* node, unsigned depth) {\n        print_node(node, depth);\n        if (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n            for (const TreeNode* child : control_node->children()) {\n                print_tree(child, depth + 2);\n            }\n        } else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n            print_tree(decorator_node->child(), depth + 2);\n        }\n    };\n    print_tree(root_node, 0);\n    stream << \"-------------------------\n\";\n}", "CodeBleu_score": 47.22595903661256}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    const auto print_separator = [&stream]() {\n        stream << \"------------------------\n\";\n    };\n\n    const auto print_node = [&stream](const TreeNode* node, int depth) {\n        stream << std::string(depth, '-') << node->name() << \"\n\";\n    };\n\n    const auto print_children = [&](const TreeNode* node) {\n        for (const auto& child : node->children()) {\n            printTreeRecursively(child, stream);\n        }\n    };\n\n    const auto print_child = [&](const TreeNode* node) {\n        printTreeRecursively(node->child(), stream);\n    };\n\n    const auto print_control_node = [&](const TreeNode* node) {\n        print_children(node);\n    };\n\n    const auto print_decorator_node = [&](const TreeNode* node) {\n        print_child(node);\n    };\n\n    print_separator();\n    print_node(root_node, 0);\n\n    if (is_control_node(root_node)) {\n        print_control_node(root_node);\n    } else if (is_decorator_node(root_node)) {\n        print_decorator_node(root_node);\n    }\n\n    print_separator();\n}", "CodeBleu_score": 44.16247459685723}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (node == nullptr) {\n    throw BT::LogicError(\"The input node is nullptr\");\n  }\n\n  visitor(node);\n\n  if (node->type() == TreeNodeType::Control) {\n    const ControlNode* control_node = static_cast<const ControlNode*>(node);\n    for (auto& child : control_node->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->type() == TreeNodeType::Decorator) {\n    const DecoratorNode* decorator_node =\n        static_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decorator_node->child(), visitor);\n  }\n}", "CodeBleu_score": 61.542706838676075}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw BT::LogicError(\"called applyRecursiveVisitor on a null node\");\n  }\n\n  visitor(node);\n\n  if (node->type() == TreeNode::Type::Control) {\n    const ControlNode* control = static_cast<const ControlNode*>(node);\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->type() == TreeNode::Type::Decorator) {\n    const DecoratorNode* decorator = static_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 64.38495808208977}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw BT::LogicError(\"Trying to apply visitor to a null node\");\n  }\n\n  visitor(node);\n\n  if (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n    for (auto& child : control_node->children()) {\n      applyRecursiveVisitor(child.get(), visitor);\n    }\n  } else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator_node->child().get(), visitor);\n  }\n}", "CodeBleu_score": 62.192123198795656}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (builders.count(manifest.registration_ID) > 0) {\n    throw BehaviorTreeException(\n        \"BehaviorTreeFactory::registerBuilder(): registration ID already \"\n        \"exists: \" +\n        manifest.registration_ID);\n  }\n  builders[manifest.registration_ID] = builder;\n  manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 45.42537827392958}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (builders.find(manifest.id) != builders.end()) {\n    throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder(): \"\n                                \"ID '\" +\n                                manifest.id + \"' already registered\");\n  }\n\n  builders.insert(std::make_pair(manifest.id, builder));\n  manifests.insert(std::make_pair(manifest.id, manifest));\n}", "CodeBleu_score": 47.41842364993356}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  auto it = builders.find(manifest.registration_ID);\n  if (it != builders.end()) {\n    throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder(): \"\n                                \"ID '\" +\n                                manifest.registration_ID + \"' already \"\n                                \"registered.\");\n  }\n\n  builders[manifest.registration_ID] = builder;\n  manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 52.373917134552926}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ports](const std::string& name,\n                                              const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, ports,\n                                              config);\n  };\n\n  TreeNodeManifest manifest = {ID, builder};\n\n  registerBuilder(manifest);\n}", "CodeBleu_score": 69.43471310972073}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ports](const std::string& name,\n                                              const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(\n        name, tick_functor, ports, config.blackboard);\n  };\n\n  TreeNodeManifest manifest(NodeType::ACTION, ID, ports);\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 66.29100574160934}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor, ports](const std::string& name,\n                                       const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, ports,\n                                              config);\n  };\n\n  TreeNodeManifest manifest(NodeType::ACTION, ID, ports);\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 65.44314414921485}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.nodes.size());\n    for (const auto& node : tree.nodes) {\n        if (node.type == BT::NodeType::SUBTREE) {\n            backups.push_back(node.blackboard->clone());\n        }\n    }\n    return backups;\n}", "CodeBleu_score": 55.56679183968629}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> blackboards;\n    blackboards.reserve(tree.rootNodes().size());\n    for (auto& subtree : tree.rootNodes()) {\n        blackboards.push_back(subtree->blackboard());\n    }\n    return blackboards;\n}", "CodeBleu_score": 54.463107121545775}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> blackboards;\n    blackboards.reserve(tree.nodes.size());\n\n    for (const auto& node : tree.nodes) {\n        if (node->type != NodeType::SUBTREE) {\n            continue;\n        }\n\n        auto blackboard = node->blackboard;\n        if (!blackboard) {\n            continue;\n        }\n\n        blackboards.emplace_back(blackboard->clone());\n    }\n\n    return blackboards;\n}", "CodeBleu_score": 51.3388503440936}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto ast = ParseScript(script);\n\n    if (!ast) {\n        return nonstd::make_unexpected(ast.error());\n    }\n\n    return ast->Execute(env);\n}", "CodeBleu_score": 59.96145986797165}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto input = lexy::zstring_input(script);\n\n    auto result = ParseScript(env, input);\n\n    if (result) {\n        return result.value().Execute(env);\n    }\n\n    return nonstd::make_unexpected(result.error());\n}", "CodeBleu_score": 52.4854253377776}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    // Parse the script\n    auto result = ParseScript(script);\n    if (!result) {\n        return nonstd::make_unexpected(result.error());\n    }\n\n    // Execute the script\n    return result->Execute(env);\n}", "CodeBleu_score": 60.72475585757376}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t  std::lock_guard<std::mutex> lock(mutex_);\n  if (handle_) {\n    throw RuntimeError(\"Library already loaded\");\n  }\n\n  handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!handle_) {\n    throw RuntimeError(dlerror());\n  }\n\n  path_ = path;\n}", "CodeBleu_score": 49.65296549869306}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t  std::lock_guard<std::mutex> lock(mutex_);\n  if (handle_ != nullptr) {\n    throw RuntimeError(\"A library is already loaded.\");\n  }\n\n  handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!handle_) {\n    throw RuntimeError(dlerror());\n  }\n  path_ = path;\n}", "CodeBleu_score": 48.65955321784423}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n\n    if (handle_ != nullptr) {\n        throw RuntimeError(\"A shared library is already loaded\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    if (handle_ == nullptr) {\n        throw RuntimeError(std::string(\"Failed to load library: \") + dlerror());\n    }\n\n    path_ = path;\n}", "CodeBleu_score": 51.100241108360954}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n\n  str = str.trim();\n\n  if (str[0] != '{' || str[str.size() - 1] != '}') {\n    return false;\n  }\n\n  if (stripped_pointer) {\n    *stripped_pointer = str.substr(1, str.size() - 2);\n  }\n\n  return true;\n}", "CodeBleu_score": 23.686567326448674}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n\n  // strip leading and trailing spaces\n  StringView stripped = str.trim();\n\n  // check if the stripped string starts with '{' and ends with '}'\n  if (stripped.startsWith('{') && stripped.endsWith('}')) {\n    if (stripped_pointer) {\n      *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    }\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 24.647358508196753}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n\n  // strip leading and trailing spaces\n  auto start = str.begin();\n  auto end = str.end();\n  while (start != end && std::isspace(*start)) {\n    ++start;\n  }\n  while (end != start && std::isspace(*(end - 1))) {\n    --end;\n  }\n\n  if (start == end) {\n    return false;\n  }\n\n  if (*start != '{' || *(end - 1) != '}') {\n    return false;\n  }\n\n  if (stripped_pointer) {\n    *stripped_pointer = StringView(start + 1, end - 1);\n  }\n\n  return true;\n}", "CodeBleu_score": 44.198146355043036}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\n  // Initialize the line cost to zero\n  double line_cost = 0.0;\n\n  // Initialize the line iterator\n  LineIterator line(x0, y0, x1, y1);\n\n  // Iterate through each point on the line\n  for (unsigned int i = 0; i < line.num_pts; ++i, line.advance()) {\n\n    // Get the point cost\n    double point_cost = pointCost(line.x, line.y);\n\n    // If the point cost is negative, return it immediately\n    if (point_cost < 0) {\n      return point_cost;\n    }\n\n    // Update the line cost if the point cost is higher\n    line_cost = std::max(line_cost, point_cost);\n  }\n\n  // Return the total line cost\n  return line_cost;\n}", "CodeBleu_score": 60.67643723367608}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  double point_cost = 0.0;\n\n  // Iterate through each point on the line\n  for (LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance()) {\n    // Get the cost of the current point\n    point_cost = pointCost(line.getX(), line.getY());\n\n    // If the point cost is negative, return it immediately\n    if (point_cost < 0) {\n      return point_cost;\n    }\n\n    // Update the line cost if the point cost is higher\n    if (point_cost > line_cost) {\n      line_cost = point_cost;\n    }\n  }\n\n  // Return the total line cost\n  return line_cost;\n}", "CodeBleu_score": 76.62788670651776}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    double line_cost = 0.0;\n    double point_cost = 0.0;\n    LineIterator line(x0, y0, x1, y1);\n\n    for (unsigned int x = line.x0_; x <= line.x1_; x++) {\n        for (unsigned int y = line.y0_; y <= line.y1_; y++) {\n            point_cost = pointCost(x, y);\n            if (point_cost < 0) {\n                return point_cost;\n            }\n            line_cost = std::max(line_cost, point_cost);\n        }\n    }\n    return line_cost;\n}", "CodeBleu_score": 60.68073591037613}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = path[0].header.frame_id;\n        gui_path.header.stamp = path[0].header.stamp;\n    }\n\n    //extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    pub.publish(gui_path);\n}", "CodeBleu_score": 81.41332283966605}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = path[0].header.frame_id;\n        gui_path.header.stamp = path[0].header.stamp;\n    }\n\n    //extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    pub.publish(gui_path);\n}", "CodeBleu_score": 81.41332283966605}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  //given a path, publish it as a nav_msgs::Path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  if (!path.empty()) {\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n  }\n\n  //we assume the path is already transformed into the frame for the planner to work on.\n  //we will just visualize it in the frame for our convenience\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 83.31417000485905}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return (std::abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) &&\n         (std::abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity);\n}", "CodeBleu_score": 52.284086809641295}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) &&\n         (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity);\n}", "CodeBleu_score": 55.88679458340139}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n  double linear_vel = base_odom.twist.twist.linear.x;\n  double angular_vel = base_odom.twist.twist.angular.z;\n\n  if (std::abs(linear_vel) <= trans_stopped_velocity && std::abs(angular_vel) <= rot_stopped_velocity) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 51.1088910895245}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\n  // If setup is not yet done, initialize the default limits with the provided configuration and set up the flag\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n\n  // If restore_defaults is requested, reset the configuration to default limits\n  if (restore_defaults) {\n    config = default_limits_;\n  }\n\n  // Lock the configuration mutex and update the current limits with the new configuration\n  boost::mutex::scoped_lock lock(configuration_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 72.38195389006668}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (restore_defaults) {\n    config = default_limits_;\n  }\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n\n  limits_mutex_.lock();\n  limits_ = config;\n  limits_mutex_.unlock();\n}", "CodeBleu_score": 64.81270258913719}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  // if we just want to restore the default configuration\n  if (restore_defaults) {\n    config = default_limits_;\n    return;\n  }\n\n  // if we haven't initialized the configuration yet\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n    return;\n  }\n\n  // lock the configuration mutex\n  boost::mutex::scoped_lock lock(configuration_mutex_);\n\n  // update the current limits\n  current_limits_ = config;\n}", "CodeBleu_score": 68.1744400013758}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\n  if (cost == costmap_2d::NO_INFORMATION)\n    return false;\n\n  if (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  // The target distance is the minimum distance to an obstacle\n  unsigned char target_distance = std::min(cost, check_cell->target_distance);\n\n  // If the target distance is the same, we've already checked this cell\n  if (target_distance == current_cell->target_distance)\n    return false;\n\n  // If the target distance is shorter, update the cell\n  if (target_distance < current_cell->target_distance) {\n    current_cell->target_distance = target_distance;\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 55.7144633093454}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\n  if (cost == costmap_2d::NO_INFORMATION) {\n    return false;\n  }\n\n  if (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  double new_target_distance = current_cell->target_distance + cost;\n  if (new_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_target_distance;\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 60.51801635481582}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\n  if (cost == costmap_2d::NO_INFORMATION)\n    return false;\n\n  if (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  unsigned int new_distance = current_cell->target_distance + cost;\n\n  if (new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 58.16342724497437}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  // Initialize the cost and scaling factor based on the trajectory and speed parameters\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  if (traj.xv.size() > 1) {\n    scaling_factor = sqrt(pow(traj.xv[1] - traj.xv[0], 2) + pow(traj.yv[1] - traj.yv[0], 2)) / traj.xv[1];\n  }\n\n  // If the footprint specification is empty, log an error and return -9\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint specification is empty.  This cost function will be skipped.\");\n    return -9.0;\n  }\n\n  // Calculate the footprint cost for each point in the trajectory\n  for (unsigned int i = 0; i < traj.xv.size(); ++i) {\n    double footprint_cost = scoreFootprint(traj.xv[i], traj.yv[i], traj.thetav[i]);\n    // If the footprint cost is negative, return the cost immediately\n    if (footprint_cost < 0)\n      return footprint_cost;\n    // Otherwise, either sum the scores or take the maximum score based on the sum_scores_ flag\n    if (sum_scores_)\n      cost += footprint_cost;\n    else\n      cost = (footprint_cost > cost) ? footprint_cost : cost;\n  }\n\n  // Return the total cost\n  return cost * scaling_factor;\n}", "CodeBleu_score": 51.808917692681014}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scaling_factor = 1.0;\n\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty.  Aborting cost calculation\");\n    return -9.0;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.x[i], traj.y[i], traj.th[i]);\n    if (footprint_cost < 0)\n      return footprint_cost;\n    if (sum_scores_)\n      cost += footprint_cost;\n    else\n      scaling_factor = std::max(scaling_factor, footprint_cost);\n  }\n\n  if (sum_scores_)\n    return cost;\n  else\n    return scaling_factor;\n}", "CodeBleu_score": 55.69068483660183}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scaling_factor = 1.0;\n\n  // Initialize the cost and scaling factor based on the trajectory and speed parameters\n  if (traj.getParam(\"max_trans_vel\", max_trans_vel_)) {\n    scaling_factor = max_trans_vel_ * max_trans_vel_;\n  } else {\n    ROS_ERROR(\"ObstacleCostFunction: max_trans_vel_ not set\");\n    return -9.0;\n  }\n\n  // If the footprint specification is empty, log an error and return -9\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"ObstacleCostFunction: footprint_spec_ is empty\");\n    return -9.0;\n  }\n\n  // Calculate the cost for each point in the trajectory\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    // Calculate the footprint cost for the current point\n    double footprint_cost = scoreFootprint(traj.x[i], traj.y[i], traj.theta[i]);\n\n    // If the footprint cost is negative, return the cost immediately\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    // If sum_scores_ is true, sum the scores; otherwise, take the maximum score\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      if (footprint_cost > cost) {\n        cost = footprint_cost;\n      }\n    }\n  }\n\n  // Return the total cost\n  return cost * scaling_factor;\n}", "CodeBleu_score": 54.985117379427784}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  // Check if the footprint is off the map\n  if (!world_model->worldModel_->worldModel_->isPositionExplored(x, y, th)) {\n    return -7.0;\n  }\n\n  // Check if the footprint is off the map\n  if (!costmap->worldToMap(x, y, x, y)) {\n    return -7.0;\n  }\n\n  // Check if the footprint is off the map\n  if (!costmap->getCostmap()->getCharMap()) {\n    return -7.0;\n  }\n\n  // Check if the footprint is off the map\n  if (!costmap->getCostmap()->getSizeInCellsX()) {\n    return -7.0;\n  }\n\n  // Check if the footprint is off the map\n  if (!costmap->getCostmap()->getSizeInCellsY()) {\n    return -7.0;\n  }\n\n  // Check if the footprint is off the map\n  if (!costmap->getCostmap()->getSizeInCellsX() || !costmap->getCostmap()->getSizeInCellsY()) {\n    return -7.0;\n  }\n\n  // Check if the footprint is off the map\n  if (!costmap->getCostmap()->getCharMap()[static_cast<int>(y) * costmap->getCostmap()->getSizeInCellsX() + static_cast<int>(x)]) {\n    return -7.0;\n  }\n\n  // Check if the footprint is off the map\n  if (!costmap->getCostmap()->getCharMap()[static_cast<int>(y) * costmap->getCostmap()->getSizeInCellsX() + static_cast<int>(x)]) {\n    return -7.0;\n  }\n\n  // Check if the footprint is off the map\n  if (!costmap->getCostmap()->getSizeInCellsX() || !costmap->getCostmap()->getSizeInCellsY()) {\n    return -7.0;\n  }\n\n  // Check if", "CodeBleu_score": 30.40582295630824}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  // Check to make sure the footprint is not empty\n  if (footprint_spec.size() == 0) {\n    ROS_ERROR(\"Attempting to cost a footprint with no points\");\n    return -6.0;\n  }\n\n  // Check to make sure the footprint is not out of bounds\n  if (!costmap->worldToMap(x, y, map_x, map_y)) {\n    ROS_ERROR(\"Attempting to cost a footprint outside of the costmap\");\n    return -7.0;\n  }\n\n  // Scale the footprint\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    footprint_spec[i].x *= scale;\n    footprint_spec[i].y *= scale;\n  }\n\n  // Get the footprint cost\n  double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec);\n\n  // Get the cell cost\n  unsigned int cell_cost = costmap->getCost(map_x, map_y);\n\n  // Return the maximum cost\n  return std::max(footprint_cost, (double)cell_cost);\n}", "CodeBleu_score": 59.13262909195329}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  //check to make sure the footprint is not empty\n  if (footprint_spec.size() == 0) {\n    ROS_ERROR(\"Attempting to pass a zero-sized footprint to the world model\");\n    return -6.0;\n  }\n\n  //check to make sure the footprint is oriented properly\n  if (th != 0) {\n    ROS_ERROR(\"Footprints oriented other than 0 are not supported yet\");\n    return -6.0;\n  }\n\n  //check to make sure the scale is not zero\n  if (scale == 0) {\n    ROS_ERROR(\"Attempting to scale the footprint by zero\");\n    return -6.0;\n  }\n\n  //check to make sure the costmap is not empty\n  if (costmap == NULL) {\n    ROS_ERROR(\"Attempting to pass a null costmap to the world model\");\n    return -6.0;\n  }\n\n  //check to make sure the world model is not empty\n  if (world_model == NULL) {\n    ROS_ERROR(\"Attempting to pass a null world model to the world model\");\n    return -6.0;\n  }\n\n  //scale the footprint\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    footprint_spec[i].x *= scale;\n    footprint_spec[i].y *= scale;\n  }\n\n  //compute the footprint cost\n  double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec, costmap);\n\n  //return the cost\n  return footprint_cost;\n}", "CodeBleu_score": 48.27300988762695}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_.empty()) {\n      odom_sub_.shutdown();\n    } else {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n  }\n}", "CodeBleu_score": 45.67084826080766}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    if (odom_topic != odom_topic_) {\n        odom_topic_ = odom_topic;\n        if (odom_topic_ != \"\") {\n            odom_sub_ = nh_.subscribe(odom_topic_, 10, &OdometryHelperRos::odomCallback, this);\n        }\n    }\n}", "CodeBleu_score": 38.32214199314429}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_.empty()) {\n      odom_sub_.shutdown();\n    } else {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n  }\n}", "CodeBleu_score": 45.67084826080766}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  // check if we can use the squared error instead of the error\n  float sq_dist = (pos.x() - prev.x()) * (pos.x() - prev.x()) + (pos.y() - prev.y()) * (pos.y() - prev.y());\n  if (sq_dist > oscillation_reset_dist_threshold_) {\n    oscillation_x_ = pos.x();\n    oscillation_y_ = pos.y();\n    oscillation_count_ = 0;\n    return;\n  }\n\n  // check if we can use the squared error instead of the error\n  float sq_angle_diff = fabs((pos.y() - prev.y()) * (prev.x() - pos.x()) -\n                             (pos.x() - prev.x()) * (prev.y() - pos.y()));\n  if (sq_angle_diff > oscillation_reset_angle_threshold_) {\n    oscillation_x_ = pos.x();\n    oscillation_y_ = pos.y();\n    oscillation_count_ = 0;\n    return;\n  }\n\n  // check if the robot has moved significantly in the x direction\n  if (fabs(pos.x() - oscillation_x_) > oscillation_x_threshold_) {\n    oscillation_x_ = pos.x();\n    oscillation_count_ = 0;\n    return;\n  }\n\n  // check if the robot has moved significantly in the y direction\n  if (fabs(pos.y() - oscillation_y_) > oscillation_y_threshold_) {\n    oscillation_y_ = pos.y();\n    oscillation_count_ = 0;\n    return;\n  }\n\n  // check if the robot has moved significantly in the y direction\n  if (fabs(pos.y() - oscillation_y_) > oscillation_y_threshold_) {\n    oscillation_y_ = pos.y();\n    oscillation_count_ = 0;\n    return;\n  }\n\n  // check if the robot has moved significantly in the y direction\n  if (fabs(pos.y() - oscillation_y_) > oscillation_y_th", "CodeBleu_score": 36.59824210458622}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos.head(2) - prev.head(2)).squaredNorm();\n  double sq_angle_diff = fabs(atan2(pos.y(), pos.x()) - atan2(prev.y(), prev.x()));\n  if (sq_dist > oscillation_reset_dist_ * oscillation_reset_dist_ || sq_angle_diff > oscillation_reset_angle_) {\n    oscillation_x_ = pos.x();\n    oscillation_y_ = pos.y();\n    oscillation_count_ = 0;\n  }\n}", "CodeBleu_score": 47.790133664712414}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  // Calculate the squared distance and the angular difference\n  float sq_dist = (pos - prev).squaredNorm();\n  float ang_diff = atan2(pos.y() - prev.y(), pos.x() - prev.x()) - prev.z();\n\n  // Reset oscillation flags if the squared distance exceeds a threshold or the angular difference is greater than a set angle\n  if (sq_dist > oscillation_reset_dist_threshold_ * oscillation_reset_dist_threshold_ ||\n      fabs(ang_diff) > oscillation_reset_angle_threshold_) {\n    oscillation_reset_count_ = 0;\n  }\n}", "CodeBleu_score": 43.48392344350355}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // determine the grid coordinates of the point\n  int ix = (int)floor((pt.x - min_x_) / cell_size_);\n  int iy = (int)floor((pt.y - min_y_) / cell_size_);\n  int iz = (int)floor((pt.z - min_z_) / cell_size_);\n\n  // check if the point is too close to its nearest neighbor\n  double dx = pt.x - (ix * cell_size_ + min_x_);\n  double dy = pt.y - (iy * cell_size_ + min_y_);\n  double dz = pt.z - (iz * cell_size_ + min_z_);\n  double dist = sqrt(dx * dx + dy * dy + dz * dz);\n  if (dist < min_pt_separation_) {\n    return;\n  }\n\n  // check if the point is outside the grid bounds\n  if (ix < 0 || ix >= (int)grid_.size() || iy < 0 || iy >= (int)grid_[0].size() || iz < 0 || iz >= (int)grid_[0][0].size()) {\n    return;\n  }\n\n  // calculate the grid index\n  int idx = ix + iy * grid_[0].size() + iz * grid_[0].size() * grid_[0][0].size();\n\n  // insert the point into the corresponding cell\n  grid_[ix][iy][iz].push_back(pt);\n}", "CodeBleu_score": 38.84935667262466}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // determine the grid coordinates of the point\n  int x = (int)floor(pt.x / grid_size_);\n  int y = (int)floor(pt.y / grid_size_);\n  int z = (int)floor(pt.z / grid_size_);\n\n  // if the point is outside the grid bounds, return\n  if (x < 0 || x >= num_x_cells_ || y < 0 || y >= num_y_cells_ || z < 0 || z >= num_z_cells_)\n    return;\n\n  // calculate the grid index\n  int idx = x + y * num_x_cells_ + z * num_x_cells_ * num_y_cells_;\n\n  // insert the point into the corresponding cell\n  grid_[idx].push_back(pt);\n}", "CodeBleu_score": 43.47452160143139}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //ROS_INFO(\"Inserting point (%f, %f, %f)\", pt.x, pt.y, pt.z);\n  //ROS_INFO(\"Grid bounds: (%f, %f, %f) - (%f, %f, %f)\", min_x_, min_y_, min_z_, max_x_, max_y_, max_z_);\n\n  //ROS_INFO(\"PointGrid::insert: (%f, %f, %f)\", pt.x, pt.y, pt.z);\n\n  // check if point is in bounds\n  if (pt.x < min_x_ || pt.x > max_x_ || pt.y < min_y_ || pt.y > max_y_ || pt.z < min_z_ || pt.z > max_z_) {\n    //ROS_INFO(\"Point out of bounds\");\n    return;\n  }\n\n  // calculate grid coordinates\n  int ix = (pt.x - min_x_) / cell_size_;\n  int iy = (pt.y - min_y_) / cell_size_;\n  int iz = (pt.z - min_z_) / cell_size_;\n\n  // check if point is too close to nearest neighbor\n  if (ix < 0 || ix >= num_x_cells_ || iy < 0 || iy >= num_y_cells_ || iz < 0 || iz >= num_z_cells_) {\n    //ROS_INFO(\"Point too close to nearest neighbor\");\n    return;\n  }\n\n  // calculate grid index\n  int idx = ix + iy * num_x_cells_ + iz * num_x_cells_ * num_y_cells_;\n\n  // insert point into grid\n  grid_[idx].push_back(pt);\n}", "CodeBleu_score": 37.74814585051482}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n    for (int i = 0; i < 3; ++i) {\n        // compute the difference between the target and current velocities\n        float diff = sample_target_vel[i] - vel[i];\n\n        // compute the acceleration required to get from the current velocity to the target velocity\n        float acc = diff / dt;\n\n        // if the acceleration is too great, then we need to clip it\n        if (acc > acclimits[i]) {\n            acc = acclimits[i];\n        } else if (acc < -acclimits[i]) {\n            acc = -acclimits[i];\n        }\n\n        // update the new velocity based on the acceleration\n        new_vel[i] = vel[i] + acc * dt;\n    }\n\n    return new_vel;\n}", "CodeBleu_score": 63.3782635878208}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n  Eigen::Vector3f new_vel;\n\n  // Compute the difference between the target and current velocities\n  Eigen::Vector3f delta_vel = sample_target_vel - vel;\n\n  // Compute the acceleration limits for each velocity component\n  Eigen::Vector3f acc_limit;\n  for (int i = 0; i < 3; i++) {\n    if (delta_vel[i] > 0) {\n      acc_limit[i] = std::min(delta_vel[i], acclimits[i] * dt);\n    }\n    else {\n      acc_limit[i] = std::max(delta_vel[i], -acclimits[i] * dt);\n    }\n  }\n\n  // Compute the new velocity for each velocity component\n  for (int i = 0; i < 3; i++) {\n    if (delta_vel[i] > 0) {\n      new_vel[i] = std::min(vel[i] + acc_limit[i], sample_target_vel[i]);\n    }\n    else {\n      new_vel[i] = std::max(vel[i] + acc_limit[i], sample_target_vel[i]);\n    }\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 59.75273091481546}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    // Increase velocity if necessary\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n    }\n    // Decrease velocity if necessary\n    else if (sample_target_vel[i] < vel[i]) {\n      new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n    }\n    // Else maintain current velocity\n    else {\n      new_vel[i] = vel[i];\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 79.94437953958783}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\n    int i = global_plan_.size() - 1;\n\n    while (i >= 0) {\n\n        int xi = global_plan_[i].x;\n        int yi = global_plan_[i].y;\n\n        // Check if the cell is clear\n        if (costmap_->getCost(xi, yi) != costmap_2d::FREE_SPACE) {\n\n            // Check if the cell is within the robot's footprint\n            if (robot_radius_ > 0.0) {\n\n                // Check if the cell is within the robot's footprint\n                if (!costmap_->getRobotFootprintCell(xi, yi, footprint_spec_, x, y)) {\n\n                    // Check if the cell is within the robot's footprint\n                    if (!costmap_->getRobotFootprintCell(cell_x, cell_y, footprint_spec_, x, y)) {\n\n                        // Check if the cell is within the robot's footprint\n                        if (!costmap_->getRobotFootprintCell(xi, yi, footprint_spec_, x, y)) {\n\n                            // Check if the cell is within the robot's footprint\n                            if (!costmap_->getRobotFootprintCell(cell_x, cell_y, footprint_spec_, x, y)) {\n\n                                // Check if the cell is within the robot's footprint\n                                if (!costmap_->getRobotFootprintCell(xi, yi, footprint_spec_, x, y)) {\n\n                                    // Check if the cell is within the robot's footprint\n                                    if (!costmap_->getRobotFootprintCell(cell_x, cell_y, footprint_spec_, x, y)) {\n\n                                        // Check if the cell is within the robot's footprint\n                                        if (!costmap_->getRobotFootprintCell(xi, yi, footprint_spec_, x, y)) {\n\n                                            // Check if the cell is within the robot's footprint\n                                            if (!costmap_->getRobotFootprintCell(cell_x, cell_y, footprint_spec_, x, y)) {\n\n                                                // Check if the cell is within the robot's footprint\n                                                if (!costmap", "CodeBleu_score": 38.58484420197806}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double dx = x - cell_x;\n  double dy = y - cell_y;\n  double distance = sqrt(dx * dx + dy * dy);\n\n  // if the goal is in the robot's local costmap, we can just compare headings\n  if (distance < costmap_.getSizeInCellsX() / 2) {\n    double yaw = atan2(dy, dx);\n    double diff = angles::shortest_angular_distance(heading, yaw);\n    return fabs(diff);\n  }\n\n  // if the goal is outside the local costmap, we need to check line of sight to the goal point\n  // we do this by iterating through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  double min_distance = distance;\n  double min_diff = DBL_MAX;\n  double min_yaw = heading;\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    double gx = global_plan_[i].pose.position.x;\n    double gy = global_plan_[i].pose.position.y;\n    double gyaw = tf2::getYaw(global_plan_[i].pose.orientation);\n    double gdx = gx - cell_x;\n    double gdy = gy - cell_y;\n    double gdistance = sqrt(gdx * gdx + gdy * gdy);\n    if (gdistance > distance) {\n      continue;\n    }\n    if (!costmap_.lineOfSight(cell_x, cell_y, gx, gy)) {\n      continue;\n    }\n    if (gdistance < min_distance) {\n      min_distance = gdistance;\n      min_yaw = gyaw;\n      double diff = angles::shortest_angular_distance(heading, min_yaw);\n      if (fabs(diff) < min_diff) {\n        min_diff = fabs(diff);\n      }\n    }\n  }\n  return min_diff;\n}", "CodeBleu_score": 51.70960247851686}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    int gx = global_plan_[i].x;\n    int gy = global_plan_[i].y;\n\n    // check if the cell is clear\n    if (costmap_->getCost(gx, gy) == costmap_2d::FREE_SPACE) {\n      // convert the goal cell coordinates to world coordinates\n      double wx, wy;\n      costmap_->mapToWorld(gx, gy, wx, wy);\n\n      // calculate the shortest angular distance between the current heading and the direction to the goal point\n      double diff = angles::shortest_angular_distance(heading, atan2(wy - y, wx - x));\n      return fabs(diff);\n    }\n  }\n\n  // no valid point was found\n  return DBL_MAX;\n}", "CodeBleu_score": 53.97812116100984}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  if (cost >= 0) {\n    return true;\n  }\n\n  ROS_WARN(\"TrajectoryPlanner: Trajectory with sample velocities (%.2f, %.2f, %.2f) has cost %.3f\",\n           vx_samp, vy_samp, vtheta_samp, cost);\n\n  return false;\n}", "CodeBleu_score": 81.37648552694715}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost >= 0) {\n    return true;\n  }\n  else {\n    ROS_WARN(\"Sample trajectory (%.2f, %.2f, %.2f) with cost %.3f\", vx_samp, vy_samp, vtheta_samp, cost);\n    return false;\n  }\n}", "CodeBleu_score": 81.44694362501693}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  // Compute the trajectory cost\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  // If the cost is negative, log a warning and return false\n  if (cost < 0) {\n    ROS_WARN(\"[TrajectoryPlanner]: Trajectory (%.2f, %.2f, %.2f, %.2f, %.2f, %.2f) has negative cost (%.2f)\",\n      x, y, theta, vx, vy, vtheta, cost);\n    return false;\n  }\n\n  // If the cost is non-negative, return true\n  return true;\n}", "CodeBleu_score": 68.11760409032274}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t    if (!initialized_) {\n        ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n        return;\n    }\n\n    if (global_costmap_ == NULL || local_costmap_ == NULL) {\n        ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do you have \"\n                  \"both a global and a local costmap?\");\n        return;\n    }\n\n    if (invert_area_to_clear_)\n        ROS_WARN(\"Area to clear is inside the polygon, not outside\");\n\n    ros::Time start_time = ros::Time::now();\n\n    if (affected_maps_ & clear_local_map_) {\n        local_costmap_->setConvexPolygonCost(clear_polygon_, costmap_2d::FREE_SPACE);\n        local_costmap_->updateMap(start_time);\n        local_costmap_->clearArea();\n    }\n\n    if (affected_maps_ & clear_global_map_) {\n        global_costmap_->setConvexPolygonCost(clear_polygon_, costmap_2d::FREE_SPACE);\n        global_costmap_->updateMap(start_time);\n        global_costmap_->clearArea();\n    }\n\n    if (force_update_) {\n        if (affected_maps_ & clear_local_map_)\n            local_costmap_->updateMap(start_time);\n\n        if (affected_maps_ & clear_global_map_)\n            global_costmap_->updateMap(start_time);\n    }\n\n    ROS_INFO(\"Clearing costmap took %.3f seconds\", (ros::Time::now() - start_time).toSec());\n}", "CodeBleu_score": 55.005485140768805}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\n    if (!initialized_) {\n        ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n        return;\n    }\n\n    if (global_costmap_ == NULL || local_costmap_ == NULL) {\n        ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do you have \"\n                  \"both a global and a local costmap?\");\n        return;\n    }\n\n    if (invert_area_to_clear_) {\n        ROS_WARN(\"Clearing area inside footprint\");\n    } else {\n        ROS_WARN(\"Clearing area outside footprint\");\n    }\n\n    ros::Time start = ros::Time::now();\n\n    if (affected_maps_ & clear_local_costmap_) {\n        clearArea(local_costmap_, start);\n    }\n\n    if (affected_maps_ & clear_global_costmap_) {\n        clearArea(global_costmap_, start);\n    }\n\n    if (force_update_) {\n        if (affected_maps_ & clear_local_costmap_) {\n            local_costmap_->resetMaps();\n        }\n        if (affected_maps_ & clear_global_costmap_) {\n            global_costmap_->resetMaps();\n        }\n    }\n\n    ROS_INFO(\"Cleared %d cells in %.3f seconds\", cells_cleared_, (ros::Time::now() - start).toSec());\n}", "CodeBleu_score": 56.38123388061247}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t    ROS_ASSERT(initialized_);\n    if (!costmaps_) {\n        ROS_ERROR(\"The costmaps passed in to the ClearCostmapRecovery object are null. Did you load the costmaps for your particular controller?\");\n        return;\n    }\n\n    if (invert_area_to_clear_) {\n        ROS_WARN(\"This object is configured to clear inside the area, not outside\");\n    }\n\n    ros::Time start = ros::Time::now();\n\n    if (affected_maps_ & clear_costmap_recovery::AffectedMaps::GLOBAL_COSTMAP) {\n        if (clear_only_local_){\n            ROS_WARN(\"This object is configured to clear the local costmap only, not the global costmap\");\n        }\n        else {\n            clear_costmap_recovery::clearArea(costmaps_->getCostmap(),\n                                              x_offset_, y_offset_,\n                                              width_, height_,\n                                              invert_area_to_clear_);\n        }\n    }\n\n    if (affected_maps_ & clear_costmap_recovery::AffectedMaps::LOCAL_COSTMAP) {\n        if (clear_only_local_){\n            clear_costmap_recovery::clearArea(costmaps_->getCostmap(),\n                                              x_offset_, y_offset_,\n                                              width_, height_,\n                                              invert_area_to_clear_);\n        }\n        else {\n            ROS_WARN(\"This object is configured to clear the global costmap only, not the local costmap\");\n        }\n    }\n\n    if (force_update_){\n        costmaps_->updateMap();\n    }\n\n    ROS_INFO(\"Cleared costmap in %.3f seconds\", (ros::Time::now() - start).toSec());\n}", "CodeBleu_score": 47.72774005678932}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t    if (polygon.empty()) {\n        return;\n    }\n\n    // TODO: use a PolygonOutlineCells object to collect the cells\n    // TODO: iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points\n    // TODO: if the polygon is not empty, close it by connecting the last point to the first\n}", "CodeBleu_score": 9.840916960107746}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\n  // If the polygon is empty, we're done.\n  if (polygon.empty()) {\n    return;\n  }\n\n  // Add the cells between each consecutive pair of points in the polygon.\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n  }\n\n  // If the polygon is not closed, connect the last point to the first.\n  if (!is_footprint_polygon_closed_) {\n    raytraceLine(polygon.back(), polygon.front(), polygon_cells);\n  }\n}", "CodeBleu_score": 46.2016250714252}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  // Initialize the PolygonOutlineCells object\n  PolygonOutlineCells outline_cells(this);\n\n  // Iterate through the polygon vertices\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    // Get the current vertex and the next vertex\n    const MapLocation& p0 = polygon[i];\n    const MapLocation& p1 = polygon[(i + 1) % polygon.size()];\n\n    // Use raytraceLine to gather cells between the current vertex and the next vertex\n    outline_cells.raytraceLine(p0, p1);\n  }\n\n  // If the polygon is not empty, connect the last point to the first\n  if (polygon.size() > 1) {\n    outline_cells.raytraceLine(polygon.back(), polygon.front());\n  }\n\n  // Copy the cells from the PolygonOutlineCells object to the polygon_cells vector\n  polygon_cells.insert(polygon_cells.end(), outline_cells.begin(), outline_cells.end());\n}", "CodeBleu_score": 51.443354853316706}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  // Prepare the grid data\n  prepareGrid();\n\n  // Publish the prepared grid\n  costmap_2d::Costmap2DPublisher::onNewSubscription(pub);\n}", "CodeBleu_score": 55.106995618945994}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  // Prepare the grid data\n  prepareGrid();\n\n  // Publish the prepared grid\n  pub.publish(grid_);\n}", "CodeBleu_score": 98.05533239138548}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t    boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n    double resolution = costmap_->getResolution();\n\n    grid_.info.resolution = resolution;\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    grid_.info.origin.position.x = costmap_->getOriginX();\n    grid_.info.origin.position.y = costmap_->getOriginY();\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    origin_x_ = costmap_->getOriginX();\n    origin_y_ = costmap_->getOriginY();\n\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    unsigned char* data = costmap_->getCharMap();\n    for (unsigned int i = 0; i < grid_.data.size(); i++) {\n        grid_.data[i] = costmap2d::toLethal(data[i]);\n    }\n}", "CodeBleu_score": 72.10464437985375}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  origin_x_ = costmap_->getOriginX();\n  origin_y_ = costmap_->getOriginY();\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n}", "CodeBleu_score": 55.4237022997627}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n\n  grid_.header.frame_id = costmap_->getBaseFrameID();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // convert the map coordinates to world coordinates for the origin\n  unsigned int mx, my;\n  costmap_->getOriginInGlobalFrame(mx, my);\n  double wx, wy;\n  costmap_->mapToWorld(mx, my, wx, wy);\n  grid_.info.origin.position.x = wx;\n  grid_.info.origin.position.y = wy;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // save the origin coordinates and resize the grid data vector\n  origin_x_ = wx;\n  origin_y_ = wy;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // populate the grid data from the costmap's character map using a translation table\n  unsigned char* map = costmap_->getCharMap();\n  unsigned int size_x = costmap_->getSizeInCellsX(), size_y = costmap_->getSizeInCellsY();\n  for (unsigned int i = 0; i < size_x; ++i) {\n    for (unsigned int j = 0; j < size_y; ++j) {\n      unsigned int index = costmap_->getIndex(i, j);\n      grid_.data[index] = cost_translation_table_[map[index]];\n    }\n  }\n}", "CodeBleu_score": 71.4905184471982}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.robot_radius == old_config.robot_radius &&\n      new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  if (new_config.footprint.empty()) {\n    ROS_WARN_STREAM(\"Footprint string is empty. Setting footprint based on robot radius.\");\n    setRobotFootprint(new_config.robot_radius);\n    return;\n  }\n\n  std::vector<geometry_msgs::Point> footprint;\n  if (!costmap_2d::makeFootprintFromString(new_config.footprint, footprint)) {\n    ROS_ERROR_STREAM(\"Footprint string is invalid. Setting footprint based on robot radius.\");\n    setRobotFootprint(new_config.robot_radius);\n    return;\n  }\n\n  setRobotFootprint(footprint);\n}", "CodeBleu_score": 61.42107276336173}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t    if (new_config.footprint_radius == old_config.footprint_radius &&\n        new_config.footprint_string == old_config.footprint_string) {\n        return;\n    }\n\n    if (new_config.footprint_string != \"\") {\n        std::vector<geometry_msgs::Point> footprint;\n        if (!costmap_2d::makeFootprintFromString(new_config.footprint_string, footprint)) {\n            ROS_ERROR(\"Error parsing footprint string \\\"%s\\\" into points\",\n                      new_config.footprint_string.c_str());\n            return;\n        }\n        setRobotFootprint(footprint);\n    } else {\n        setRobotFootprintFromRadius(new_config.footprint_radius);\n    }\n}", "CodeBleu_score": 57.90290892400165}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // If the footprint and radius are the same, we don't need to update the footprint\n  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // If a valid footprint string is provided, convert it to a footprint\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> footprint_spec;\n    if (!costmap_2d::makeFootprintFromString(new_config.footprint, footprint_spec)) {\n      ROS_ERROR(\"Error parsing footprint string '%s'\", new_config.footprint.c_str());\n      return;\n    }\n\n    // Set the footprint\n    setFootprint(footprint_spec);\n    return;\n  }\n\n  // If no valid footprint string is provided, set the footprint based on the robot radius\n  setFootprintFromRadius(new_config.robot_radius);\n}", "CodeBleu_score": 63.53641996524394}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t    geometry_msgs::PoseStamped pose;\n    if (!costmap_ros_->getRobotPose(pose)) {\n        ROS_WARN(\"Could not get robot pose\");\n        return;\n    }\n\n    // If the robot is moving, we need to update the controller\n    if (new_pose_ != pose) {\n        new_pose_ = pose;\n        if (reconfigure_pending_) {\n            ROS_INFO(\"Reconfigure requested at %.2f\", event.current_real.toSec());\n            reconfigure_pending_ = false;\n            reconfigure();\n        }\n    }\n}", "CodeBleu_score": 47.92190811687244}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Failed to get robot pose, canceling reconfiguration\");\n    return;\n  }\n\n  // Check if the robot's pose has changed significantly\n  if (new_pose.header.frame_id != old_pose.header.frame_id ||\n      tf2::getYaw(new_pose.pose.orientation) != tf2::getYaw(old_pose.pose.orientation) ||\n      new_pose.pose.position.x != old_pose.pose.position.x ||\n      new_pose.pose.position.y != old_pose.pose.position.y) {\n    old_pose = new_pose;\n    reconfigure();\n  }\n}", "CodeBleu_score": 49.52749736009275}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\n  // Get the robot's current pose\n  geometry_msgs::PoseStamped current_pose;\n  if (!costmap_ros_->getRobotPose(current_pose)) {\n    ROS_WARN(\"Could not get robot pose\");\n    return;\n  }\n\n  // Convert the pose to a tf2::Transform\n  tf2::Transform new_pose;\n  tf2::convert(current_pose.pose, new_pose);\n\n  // Check if the robot's pose has changed significantly\n  if (new_pose.getOrigin() != last_pose_.getOrigin() ||\n      tf2::getYaw(new_pose.getRotation()) != tf2::getYaw(last_pose_.getRotation())) {\n    // Update the robot's pose\n    last_pose_ = new_pose;\n    // Update the costmap\n    updateMap(current_pose.header.stamp, new_pose);\n  }\n}", "CodeBleu_score": 47.18170365632677}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t    if (!stopped_) {\n        return;\n    }\n\n    stopped_ = false;\n\n    std::vector < std::string > plugins = layered_costmap_->getPlugins();\n\n    for (std::vector < std::string >::const_iterator plugin = plugins.begin(); plugin != plugins.end(); ++plugin) {\n        layered_costmap_->activatePlugin(*plugin);\n    }\n\n    stop_updates_ = false;\n\n    while (!ros::isInitialized()) {\n        usleep(100000);\n    }\n\n    while (!layered_costmap_->isInitialized()) {\n        usleep(100000);\n    }\n\n    while (!map_update_thread_.isActive()) {\n        usleep(100000);\n    }\n}", "CodeBleu_score": 50.28418822920231}, {"code": "void Costmap2DROS::start(){\n\t  std::vector<std::string> plugins;\n  if (stopped_) {\n    // Reactivate the plugins\n    plugins = layered_costmap_->getPlugins();\n    for (std::vector<std::string>::iterator plugin = plugins.begin(); plugin != plugins.end(); ++plugin) {\n      layered_costmap_->activatePlugin(*plugin);\n    }\n    stopped_ = false;\n  }\n\n  // Wait until the costmap is initialized\n  while (!initialized_) {\n    usleep(100000);\n  }\n\n  // Wait until the map update thread is active\n  while (!map_update_thread_.isActive()) {\n    usleep(100000);\n  }\n}", "CodeBleu_score": 52.84832099546524}, {"code": "void Costmap2DROS::start(){\n\t    if (stopped_) {\n        stopped_ = false;\n\n        for (auto plugin : plugins_) {\n            plugin->onStart();\n        }\n\n        ROS_INFO(\"Starting costmap2d\");\n\n        ros::Rate r(10);\n\n        while (!initialized_ || !map_update_thread_.isActive()) {\n            ros::spinOnce();\n\n            r.sleep();\n        }\n    }\n}", "CodeBleu_score": 37.4127530512187}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  ros::Time now = ros::Time::now();\n  if (observation_keep_time_ == ros::Duration(0.0)) {\n    // If we're keeping only the most recent observation, just truncate the list.\n    observations_.erase(observations_.begin() + 1, observations_.end());\n  } else {\n    // Otherwise, iterate through the list and remove observations that are too old.\n    while (observations_.size() > 1 &&\n           (now - observations_.front().header.stamp) > observation_keep_time_) {\n      observations_.pop_front();\n    }\n  }\n}", "CodeBleu_score": 32.32065600501884}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  ros::Time now = ros::Time::now();\n  if (observation_keep_time_.toSec() == 0.0) {\n    // If we aren't supposed to keep any observations, just remove all but the most recent one.\n    while (observations_.size() > 1) {\n      observations_.pop_back();\n    }\n  } else {\n    // Otherwise, remove all observations older than the specified time.\n    std::vector<Observation>::iterator iter = observations_.begin();\n    while (iter != observations_.end()) {\n      if (now - iter->last_updated_ > observation_keep_time_) {\n        iter = observations_.erase(iter);\n      } else {\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 38.174450412359064}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    return;\n  }\n  ros::Time now = observation_buffer_get_latest_timestamp();\n  ros::Time keep_until = now - observation_keep_time_;\n  while (observations_.size() > 1) {\n    if (observations_.front().header.stamp < keep_until) {\n      observations_.pop_front();\n    } else {\n      break;\n    }\n  }\n}", "CodeBleu_score": 33.99569619053794}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  // Calculate the yaw angles at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end indices\n  double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Compute the incremental change in angle for each pose\n  double delta_angle = delta_yaw / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    double yaw = start_yaw + delta_angle * (i - start_index);\n    tf2::Quaternion q;\n    q.setRPY(0, 0, yaw);\n    path[i].pose.orientation = tf2::toMsg(q);\n  }\n}", "CodeBleu_score": 63.98608437269425}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    // Calculate the yaw angles at the start and end indices\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Determine the shortest angular distance between the start and end yaw angles\n    double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Calculate the incremental change in angle for each pose in the specified range\n    double increment = delta_yaw / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index + 1; i < end_index; i++) {\n        double yaw = start_yaw + increment * (i - start_index);\n        tf2::Quaternion q;\n        q.setRPY(0, 0, yaw);\n        path[i].pose.orientation = tf2::toMsg(q);\n    }\n}", "CodeBleu_score": 68.8258703123357}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n  // Get the yaw angles at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Compute the shortest angular distance between the start and end yaw angles\n  double angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Compute the incremental change in angle\n  double increment = angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; ++i) {\n    double yaw = start_yaw + increment * (i - start_index);\n    tf2::Quaternion quat;\n    quat.setRPY(0, 0, yaw);\n    path[i].pose.orientation = tf2::toMsg(quat);\n  }\n}", "CodeBleu_score": 67.84240903861064}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    geometry_msgs::PoseStamped start, goal;\n    start.header.frame_id = \"map\";\n    goal.header.frame_id = \"map\";\n    start.pose = req.start;\n    goal.pose = req.goal;\n\n    std::vector<geometry_msgs::PoseStamped> plan;\n    bool found_plan = makePlan(start, goal, plan);\n\n    if (found_plan) {\n        resp.plan = plan;\n    }\n\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n\n    return true;\n}", "CodeBleu_score": 54.652371324662106}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  // Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  bool found_plan = makePlan(req.start, req.goal, resp.plan.poses);\n\n  // Update the response with the success status and the generated path if a plan is found\n  resp.plan.header.stamp = ros::Time::now();\n  resp.plan.header.frame_id = \"map\";\n  resp.plan.poses.resize(resp.plan.poses.size());\n  resp.plan.cost = found_plan ? 1 : 0;\n  resp.plan.error_code.val = found_plan ? 1 : 0;\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 52.96551299759634}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    std::vector<geometry_msgs::PoseStamped> plan;\n    bool found_plan = makePlan(req.start, req.goal, plan);\n\n    // Update the response with the success status and the generated path if a plan is found\n    resp.plan = plan;\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.frame_id = \"map\";\n    resp.success = found_plan;\n\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 65.25137361317384}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle n;\n    make_plan_srv_ = n.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = n.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n    tf_ = new tf2_ros::Buffer;\n    tf_listener_ = new tf2_ros::TransformListener(*tf_);\n}", "CodeBleu_score": 57.48271094350479}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n    ros::NodeHandle private_nh(\"~/\" + name);\n    private_nh.param(\"tolerance\", tolerance_, 0.0);\n    private_nh.param(\"sim_time\", sim_time_, 1.0);\n    private_nh.param(\"visualize_potential\", visualize_potential_, false);\n\n    // advertise the make_plan service\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n    // subscribe to the goal topic\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n\n    // initialize the tf listener\n    tf_listener_.reset(new tf2_ros::TransformListener(private_nh));\n\n    // initialize the costmap client\n    costmap_client_.reset(new navfn::CostmapClient(name, true));\n}", "CodeBleu_score": 58.80559872949268}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n    ros::NodeHandle private_nh(\"~/\" + name);\n\n    // advertise the make plan service\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n    // subscribe to the goal topic\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, boost::bind(&PlannerWithCostmap::goalCB, this, _1));\n\n    // initialize the transform listener\n    tf_ = new tf2_ros::Buffer(ros::Duration(10));\n    tf_listener_ = new tf2_ros::TransformListener(*tf_);\n\n    // initialize the costmap\n    costmap_ = cmap;\n\n    // initialize the costmap ros\n    costmap_ros_ = cmap;\n\n    // initialize the planner\n    planner_ = new navfn::NavfnROS();\n    planner_->initialize(name, tf_, costmap_ros_);\n}", "CodeBleu_score": 61.11545538109431}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (costmap_->worldToMap(wx, wy, mx, my)) {\n    unsigned int x_cell = int(std::floor(mx));\n    unsigned int y_cell = int(std::floor(my));\n\n    //now check if the cell is in bounds. If it is not, return false\n    if (x_cell < costmap_->getSizeInCellsX() && y_cell < costmap_->getSizeInCellsY())\n      return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 43.4396825076925}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  // Convert the world coordinates to map coordinates\n  mx = (wx - costmap->getOriginX()) / costmap->getResolution();\n  my = (wy - costmap->getOriginY()) / costmap->getResolution();\n\n  // Check if the map coordinates are within the costmap's size limits\n  unsigned int x_cell = int(floor(mx));\n  unsigned int y_cell = int(floor(my));\n\n  if (x_cell < costmap->getSizeInCellsX() && y_cell < costmap->getSizeInCellsY()) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 46.50863651339858}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    // Check if the world coordinates are within the bounds of the costmap's origin\n    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n        // If not, return false\n        return false;\n    }\n\n    // Calculate the map coordinates using the costmap's resolution and an offset\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n    // Check if the map coordinates are within the costmap's size limits\n    unsigned int x_cell = int(floor(mx));\n    unsigned int y_cell = int(floor(my));\n    if (x_cell < costmap_->getSizeInCellsX() && y_cell < costmap_->getSizeInCellsY()) {\n        // If so, return true\n        return true;\n    }\n\n    // If not, return false\n    return false;\n}", "CodeBleu_score": 54.40561978299602}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    // Check if the planner is initialized\n    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    // Create a Path message and set its header\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Copy the poses from the input path\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    // Publish the Path message\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 97.13906450046564}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\n    // Check if the planner is initialized\n    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    // Create a Path message\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    // Set the header of the Path message\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Copy the poses from the input path to the Path message\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    // Publish the Path message\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 97.13906450046564}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    //make sure that the planner is initialized\n    ROS_ASSERT_MSG(initialized_, \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = path[0].header.frame_id;\n        gui_path.header.stamp = path[0].header.stamp;\n    }\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 83.10750305249326}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_STREAM(\"Wrapping received Pose -> MoveBaseAction\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 70.62380531344242}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG(\"wrapping goal in an action\");\n  move_base_msgs::MoveBaseGoal action_goal;\n  action_goal.target_pose = *goal;\n  action_server_->acceptNewGoal(action_goal);\n}", "CodeBleu_score": 41.84798417872152}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  // log that we've received a new goal\n  ROS_DEBUG(\"I heard a goal\");\n\n  // create a new action goal\n  move_base_msgs::MoveBaseActionGoal action_goal;\n\n  // set the stamp to the current time\n  action_goal.header.stamp = ros::Time::now();\n\n  // set the target pose\n  action_goal.goal.target_pose = *goal;\n\n  // publish the action goal\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 68.60198050262957}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (std::pow(distance_limit.getOrigin().x(), 2) + std::pow(distance_limit.getOrigin().y(), 2) < std::pow(current_distance.getOrigin().x(), 2) + std::pow(current_distance.getOrigin().y(), 2)) {\n    ROS_INFO(\"MoveSlowAndClear: Distance limit reached, stopping.\");\n    distance_limit_thread.join();\n    distance_limit_thread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n    distance_timer.stop();\n  }\n}", "CodeBleu_score": 44.70548368481968}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    // Calculate the squared distance the robot has moved\n    double squared_distance = pow(current_x - last_x, 2) + pow(current_y - last_y, 2);\n\n    // Check if the robot has moved far enough\n    if (squared_distance > pow(distance_limit, 2)) {\n        // Log a message\n        ROS_INFO(\"Robot has moved far enough\");\n\n        // Join and delete any existing remove limit thread\n        if (remove_limit_thread.joinable()) {\n            remove_limit_thread.join();\n        }\n\n        // Start a new thread to remove the speed limit\n        remove_limit_thread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n        // Stop the distance check timer\n        distance_check_timer.stop();\n    }\n}", "CodeBleu_score": 53.00699521014942}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    double current_distance = std::sqrt(std::pow(current_position.x - last_position.x, 2) + std::pow(current_position.y - last_position.y, 2));\n    if (current_distance >= distance) {\n        ROS_INFO(\"Distance check passed\");\n        distance_check_timer.stop();\n        if (remove_limit_thread) {\n            remove_limit_thread->join();\n            delete remove_limit_thread;\n        }\n        remove_limit_thread = new std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n        remove_limit_thread->detach();\n    }\n}", "CodeBleu_score": 48.64890660056233}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  geometry_msgs::PoseStamped global_pose;\n  try {\n    tf2_ros::Buffer buffer;\n    tf2_ros::TransformListener tf2_listener(buffer);\n    geometry_msgs::TransformStamped transform = buffer.lookupTransform(\"map\", \"base_link\", ros::Time(0));\n    global_pose.header.frame_id = \"map\";\n    global_pose.header.stamp = ros::Time::now();\n    global_pose.pose.position.x = transform.transform.translation.x;\n    global_pose.pose.position.y = transform.transform.translation.y;\n    global_pose.pose.position.z = transform.transform.translation.z;\n    global_pose.pose.orientation.x = transform.transform.rotation.x;\n    global_pose.pose.orientation.y = transform.transform.rotation.y;\n    global_pose.pose.orientation.z = transform.transform.rotation.z;\n    global_pose.pose.orientation.w = transform.transform.rotation.w;\n  } catch (tf2::TransformException& ex) {\n    ROS_ERROR(\"%s\", ex.what());\n    return;\n  }\n\n  nav_msgs::Path path;\n  if (!makePlan(global_pose, *goal, path)) {\n    ROS_ERROR(\"Failed to generate path\");\n    return;\n  }\n\n  // Publish the path\n  path_pub_.publish(path);\n}", "CodeBleu_score": 47.864209638147926}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the current global pose of the robot\n  geometry_msgs::PoseStamped global_pose;\n  if (!costmap_ros_->getRobotPose(global_pose)) {\n    ROS_WARN(\"Could not get robot pose\");\n    return;\n  }\n\n  // Convert the goal pose to the global frame\n  geometry_msgs::PoseStamped goal_pose;\n  goal_pose.header.frame_id = goal->header.frame_id;\n  goal_pose.header.stamp = goal->header.stamp;\n  goal_pose.pose = goal->pose;\n  tf2::doTransform(goal_pose, goal_pose, transform_stamped_);\n\n  // Generate a path from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> plan;\n  if (!makePlan(global_pose, goal_pose, plan)) {\n    ROS_WARN(\"Could not generate path\");\n    return;\n  }\n\n  // Publish the path as a Path message\n  nav_msgs::Path path_msg;\n  path_msg.header.frame_id = global_pose.header.frame_id;\n  path_msg.header.stamp = global_pose.header.stamp;\n  path_msg.poses.insert(path_msg.poses.end(), plan.begin(), plan.end());\n  path_pub_.publish(path_msg);\n}", "CodeBleu_score": 45.97956926974714}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Get the current global pose of the robot\n    geometry_msgs::PoseStamped robot_pose;\n    costmap_ros_->getRobotPose(robot_pose);\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<geometry_msgs::PoseStamped> plan;\n    makePlan(robot_pose, *goal, plan);\n\n    // Publish the path\n    nav_msgs::Path path;\n    path.header.frame_id = \"map\";\n    path.header.stamp = ros::Time::now();\n    path.poses = plan;\n    path_pub_.publish(path);\n}", "CodeBleu_score": 53.510432345134205}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    mavros_msgs::ParamSet param_set_request;\n    param_set_request.param_id = param_set.param_id;\n    param_set_request.value.integer = param_set.value.integer;\n    param_set_request.value.real = param_set.value.real;\n    param_set_request.value.bool_val = param_set.value.bool_val;\n    param_set_request.value.str_val = param_set.value.str_val;\n    param_set_client_.call(param_set_request);\n}", "CodeBleu_score": 48.7765460862875}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    mavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.real = param_set.value;\n    if (param_set_client_.call(param_set_srv)) {\n        ROS_INFO(\"Param set (%s) request sent - %s\", param_set.param_id.c_str(), param_set_srv.response.success ? \"true\" : \"false\");\n    } else {\n        ROS_ERROR(\"Failed to call param set service\");\n    }\n}", "CodeBleu_score": 53.76737754992556}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    param_set_client_.request.param_id = param_set.param_id;\n    param_set_client_.request.value = param_set.value;\n    param_set_client_.call(param_set_client_);\n}", "CodeBleu_score": 55.56224811784786}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t    // Create a socket\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket == -1) {\n        ROS_ERROR(\"Failed to create socket\");\n        return;\n    }\n\n    // Set socket options\n    int option = 1;\n    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &option, sizeof(option)) == -1) {\n        ROS_ERROR(\"Failed to set socket options\");\n        return;\n    }\n\n    // Bind the socket to the specified port\n    struct sockaddr_in server_address;\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = INADDR_ANY;\n    server_address.sin_port = htons(server_port_);\n    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {\n        ROS_ERROR(\"Failed to bind socket to port %d\", server_port_);\n        return;\n    }\n\n    // Listen for incoming connections\n    if (listen(server_socket, 1) == -1) {\n        ROS_ERROR(\"Failed to listen on socket\");\n        return;\n    }\n\n    ROS_INFO(\"Server listening on port %d\", server_port_);\n\n    // Accept incoming connections and handle them\n    while (ros::ok()) {\n        // Accept incoming connection\n        int client_socket = accept(server_socket, NULL, NULL);\n        if (client_socket == -1) {\n            ROS_ERROR(\"Failed to accept incoming connection\");\n            continue;\n        }\n\n        // Receive data from client\n        char buffer[1024];\n        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);\n        if (bytes_received <= 0) {\n            ROS_ERROR(\"Failed to receive data from client\");\n            close(client_socket);\n            continue;\n        }\n\n        // Process received data\n        std::string message(buffer, bytes_received);", "CodeBleu_score": 49.37993839778305}, {"code": "void CommunicationBridge::serverFun(){\n\t    // Create a socket and bind it to the specified port\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket == -1) {\n        std::cerr << \"Error: Failed to create server socket\" << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server_address;\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = INADDR_ANY;\n    server_address.sin_port = htons(server_port);\n\n    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {\n        std::cerr << \"Error: Failed to bind server socket\" << std::endl;\n        return;\n    }\n\n    if (listen(server_socket, 5) == -1) {\n        std::cerr << \"Error: Failed to listen on server socket\" << std::endl;\n        return;\n    }\n\n    // Accept incoming connections and handle them\n    while (true) {\n        struct sockaddr_in client_address;\n        socklen_t client_address_length = sizeof(client_address);\n        int client_socket = accept(server_socket, (struct sockaddr *)&client_address, &client_address_length);\n        if (client_socket == -1) {\n            std::cerr << \"Error: Failed to accept client connection\" << std::endl;\n            continue;\n        }\n\n        // Receive data from the client\n        char buffer[1024];\n        ssize_t bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Error: Failed to receive data from client\" << std::endl;\n            close(client_socket);\n            continue;\n        }\n\n        // Process the received data\n        std::string message(buffer, bytes_received);\n        std::cout << \"Received message: \" << message << std::endl;", "CodeBleu_score": 47.69742166527335}, {"code": "void CommunicationBridge::serverFun(){\n\t\n    boost::asio::io_service io_service;\n\n    boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port_);\n\n    boost::asio::ip::tcp::acceptor acceptor(io_service, endpoint);\n\n    boost::asio::ip::tcp::socket socket(io_service);\n\n    while (true) {\n\n        acceptor.accept(socket);\n\n        boost::system::error_code error;\n\n        std::vector<char> buffer(1024);\n\n        size_t bytes_read = socket.read_some(boost::asio::buffer(buffer), error);\n\n        if (bytes_read > 0) {\n\n            std::string message(buffer.begin(), buffer.begin() + bytes_read);\n\n            std::cout << \"Received message: \" << message << std::endl;\n\n            // Process the message and publish it\n\n            boost::shared_lock<boost::shared_mutex> lock(mutex_);\n\n            if (message == \"takeoff\") {\n\n                takeoff_ = true;\n\n            } else if (message == \"land\") {\n\n                land_ = true;\n\n            } else if (message == \"emergency\") {\n\n                emergency_ = true;\n\n            } else if (message == \"stop\") {\n\n                stop_ = true;\n\n            } else if (message == \"reset\") {\n\n                reset_ = true;\n\n            } else if (message == \"go\") {\n\n                go_ = true;\n\n            } else if (message == \"stop_go\") {\n\n                stop_go_ = true;\n\n            } else if (message == \"stop_emergency\") {\n\n                stop_emergency_ = true;\n\n            } else if (message == \"stop_reset\") {\n\n                stop_reset_ = true;\n\n            } else if (message == \"stop_takeoff\") {\n\n                stop_takeoff_ = true;\n\n            } else if (message == \"stop_land\") {\n\n                stop_land_ = true;\n\n            } else if (message", "CodeBleu_score": 33.486256189812}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (!simulation_mode_) {\n        uav_basic_.publish(uav_cmd);\n    } else {\n        boost::shared_lock<boost::shared_mutex> lock(simulation_mutex_);\n        if (swarm_control_simulation_.find(uav_cmd.id) != swarm_control_simulation_.end()) {\n            swarm_control_simulation_[uav_cmd.id].publish(uav_cmd);\n        }\n    }\n}", "CodeBleu_score": 40.0423728962519}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (!simulation_mode_) {\n        uav_basic_.publish(uav_cmd);\n    } else {\n        for (auto& uav : swarm_control_simulation_->uavs) {\n            if (uav.id == uav_cmd.id) {\n                uav.uav_basic_.publish(uav_cmd);\n            }\n        }\n    }\n}", "CodeBleu_score": 34.29695614213554}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if(!simulation_mode_) {\n        uav_basic_.publish(uav_cmd);\n    } else {\n        boost::shared_lock<boost::shared_mutex> lock(swarm_control_simulation_mutex_);\n        std::map<int, SwarmControlSimulation>::iterator it = swarm_control_simulation_.find(uav_cmd.id);\n        if(it != swarm_control_simulation_.end()) {\n            it->second.publish(uav_cmd);\n        }\n    }\n}", "CodeBleu_score": 41.243175760511654}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.mode == ModeSelection::REBOOTNX) {\n        system(\"reboot\");\n    } else if (mode_selection.mode == ModeSelection::EXITNX) {\n        system(\"exit\");\n    } else {\n        if (mode_selection.use_mode) {\n            createMode(mode_selection.mode);\n        } else {\n            deleteMode(mode_selection.mode);\n        }\n    }\n}", "CodeBleu_score": 50.81009523262367}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.mode == \"REBOOTNX\") {\n        system(\"reboot\");\n    } else if (mode_selection.mode == \"EXITNX\") {\n        exit(0);\n    } else {\n        if (mode_selection.use_mode) {\n            createMode(mode_selection);\n        } else {\n            deleteMode(mode_selection);\n        }\n    }\n}", "CodeBleu_score": 53.081742659340236}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t  boost::unique_lock<boost::shared_mutex> lock(mode_selection_mutex);\n  this->mode_selection = mode_selection;\n  lock.unlock();\n\n  if (mode_selection.mode == Mode::REBOOTNX) {\n    std::system(\"reboot\");\n  } else if (mode_selection.mode == Mode::EXITNX) {\n    std::system(\"exit\");\n  } else {\n    if (mode_selection.use_mode) {\n      createMode(mode_selection.mode);\n    } else {\n      deleteMode(mode_selection.mode);\n    }\n  }\n}", "CodeBleu_score": 52.702666154402145}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    // Check if the heartbeat count remains unchanged for a specified number of attempts\n    if (heartbeat_count_ == heartbeat_attempts_) {\n        // Print an error message and trigger appropriate actions based on the type of vehicle\n        if (vehicle_type_ == \"swarm\") {\n            ROS_ERROR(\"Heartbeat lost, swarm disconnected\");\n            // Set the disconnect_flag to true\n            disconnect_flag_ = true;\n        } else if (vehicle_type_ == \"UAV\") {\n            ROS_ERROR(\"Heartbeat lost, UAV disconnected\");\n            // Set the disconnect_flag to true\n            disconnect_flag_ = true;\n        } else if (vehicle_type_ == \"UGV\") {\n            ROS_ERROR(\"Heartbeat lost, UGV disconnected\");\n            // Set the disconnect_flag to true\n            disconnect_flag_ = true;\n        }\n    }\n\n    // Reset the heartbeat count if it is less than the maximum value\n    if (heartbeat_count_ < heartbeat_max_) {\n        heartbeat_count_ = 0;\n    }\n}", "CodeBleu_score": 34.829841309272695}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    // Check if heartbeat is received\n    if (heartbeat_received) {\n        // Reset heartbeat received flag\n        heartbeat_received = false;\n\n        // Reset heartbeat counter\n        heartbeat_counter = 0;\n    } else {\n        // Increment heartbeat counter\n        heartbeat_counter++;\n    }\n\n    // Check if heartbeat count exceeds threshold\n    if (heartbeat_counter >= heartbeat_threshold) {\n        // Print error message\n        ROS_ERROR(\"Heartbeat lost, triggering disconnection\");\n\n        // Set disconnect flag\n        disconnect_flag = true;\n    }\n}", "CodeBleu_score": 20.103818404763963}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    // Increment heartbeat count\n    heartbeat_count++;\n\n    // Check if heartbeat count has reached maximum attempts\n    if (heartbeat_count == HEARTBEAT_MAX_ATTEMPTS) {\n        // Print error message\n        ROS_ERROR(\"Heartbeat lost. Disconnecting...\");\n\n        // Set disconnect flag based on vehicle type\n        if (vehicle_type == \"swarm\") {\n            // Disconnect from swarm\n            // ...\n        } else if (vehicle_type == \"UAV\") {\n            // Disconnect from UAV\n            // ...\n        } else if (vehicle_type == \"UGV\") {\n            // Disconnect from UGV\n            // ...\n        }\n\n        // Set heartbeat count to 0\n        heartbeat_count = 0;\n    }\n}", "CodeBleu_score": 20.70658219669016}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract drone ID and trajectory data from message\n    int drone_id = msg->drone_id;\n    std::vector<prometheus_msgs::Bspline> traj_data = msg->traj_data;\n\n    // Initialize Bspline struct for each trajectory\n    for (int i = 0; i < traj_data.size(); i++) {\n        Bspline bspline;\n        bspline.drone_id = drone_id;\n        bspline.traj_id = traj_data[i].traj_id;\n        bspline.order = traj_data[i].order;\n        bspline.knots = traj_data[i].knots;\n        bspline.position_points = traj_data[i].position_points;\n        bspline.yaw_points = traj_data[i].yaw_points;\n\n        // Populate Bspline struct with trajectory data\n        bsplines[drone_id][i] = bspline;\n    }\n\n    // Encode MultiBsplines data and send via TCP\n    std::string encoded_data = encodeMultiBsplines(drone_id, traj_data);\n    sendMultiBsplinesTcp(encoded_data);\n}", "CodeBleu_score": 33.63289065093338}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract drone ID and trajectory data from the message\n    int drone_id = msg->drone_id;\n    std::vector<prometheus_msgs::Bspline> traj_data = msg->traj_data;\n\n    // Initialize a Bspline struct for each trajectory\n    std::vector<Bspline> traj_list;\n    for (int i = 0; i < traj_data.size(); i++) {\n        Bspline bspline;\n        bspline.id = traj_data[i].id;\n        bspline.order = traj_data[i].order;\n        bspline.knots = traj_data[i].knots;\n        bspline.pos_pts = traj_data[i].pos_pts;\n        bspline.yaw_pts = traj_data[i].yaw_pts;\n        traj_list.push_back(bspline);\n    }\n\n    // Encode the MultiBsplines data and send it via TCP using the communication module\n    std::string encoded_data = encodeMultiBsplines(drone_id, traj_list);\n    comm_->send(encoded_data);\n}", "CodeBleu_score": 30.259751527265077}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract drone ID from the message\n    int drone_id = msg->drone_id;\n\n    // Create a Bspline struct for each trajectory in the message\n    for (int i = 0; i < msg->traj_num; i++) {\n        Bspline bspline;\n        bspline.drone_id = drone_id;\n        bspline.traj_id = i;\n        bspline.order = msg->order;\n        bspline.knots = msg->knots[i];\n        bspline.pos_points = msg->pos_points[i];\n        bspline.yaw_points = msg->yaw_points[i];\n\n        // Initialize the Bspline struct\n        bspline.init();\n\n        // Populate the Bspline struct with the trajectory data\n        bspline.set_knots(bspline.knots);\n        bspline.set_pos_points(bspline.pos_points);\n        bspline.set_yaw_points(bspline.yaw_points);\n\n        // Encode the Bspline struct and send it via TCP\n        send_bspline_via_tcp(bspline);\n    }\n}", "CodeBleu_score": 32.15436054350335}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Create a new PointCloud2 message\n    sensor_msgs::PointCloud2 compressed_msg;\n\n    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree;\n    octree.setInputCloud(cloud);\n    octree.setResolution(0.1);\n    octree.setMinimumPointsPerVoxel(1);\n    octree.setPointCloudCompression(compressed_cloud);\n\n    // Store the compressed data\n    octree.getOccupiedVoxelCenters(compressed_points);\n\n    // Convert the compressed data to a PointCloud2 message\n    pcl::toROSMsg(*compressed_cloud, compressed_msg);\n\n    // Release dynamically allocated memory\n    compressed_cloud.reset();\n    compressed_points.clear();\n\n    // Return the compressed message\n    return compressed_msg;\n}", "CodeBleu_score": 36.63184458863396}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Convert the input PointCloud2 message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud using an octree compression technique\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.05);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n\n    // Get the compressed data\n    std::vector<int> pointIdxVector;\n    octree.getOccupiedVoxelCenters(pointIdxVector);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 output;\n    pcl::toROSMsg(*cloud, output);\n    output.header = msg.header;\n    output.width = pointIdxVector.size();\n    output.height = 1;\n    output.is_dense = true;\n\n    // Release dynamically allocated memory\n    cloud.reset();\n\n    return output;\n}", "CodeBleu_score": 38.375106654952276}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n    // Convert the PointCloud2 message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud using an octree compression technique\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.1); // 0.1 is the resolution of the octree\n    octree.setInputCloud(cloud);\n    octree.defineCompression<pcl::octree::OCTREE_GROUPING>();\n    octree.compress();\n\n    // Store the compressed data\n    std::vector<uint8_t> compressed_data;\n    octree.getCompressedPointCloud(compressed_data);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.size();\n    compressed_msg.fields.resize(1);\n    compressed_msg.fields[0].name = \"x\";\n    compressed_msg.fields[0].offset = 0;\n    compressed_msg.fields[0].datatype = sensor_msgs::PointField::FLOAT32;\n    compressed_msg.fields[0].count = 1;\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = 4;\n    compressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n    compressed_msg.is_dense = true;\n    compressed_msg.data.resize(compressed_msg.row_step * compressed_msg.height);\n    memcpy(&compressed_msg.data[0], &compressed_data[0], compressed_msg.row_step * compressed_msg.height);\n\n    // Release dynamically allocated memory\n    cloud.reset();\n\n    return compressed_msg;\n}", "CodeBleu_score": 49.21171405634634}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_[i] = uav_state;\n            return;\n        }\n    }\n    multi_uav_state_.push_back(uav_state);\n}", "CodeBleu_score": 62.26376498644433}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 58.33579600082278}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t  for (int i = 0; i < multi_uav_state_.size(); i++) {\n    if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n      multi_uav_state_[i] = uav_state;\n      break;\n    }\n  }\n}", "CodeBleu_score": 61.64500347906683}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    // Initialize a MultiUGVState message\n    swarm_control_topic::MultiUGVState multi_ugv_state;\n    // Initialize a UGVState message\n    swarm_control_topic::UGVState ugv_state;\n    // Initialize a UGVAttitude message\n    swarm_control_topic::UGVAttitude ugv_attitude;\n    // Initialize a UGVPosition message\n    swarm_control_topic::UGVPosition ugv_position;\n    // Initialize a UGVVelocity message\n    swarm_control_topic::UGVVelocity ugv_velocity;\n    // Initialize a UGVBattery message\n    swarm_control_topic::UGVBattery ugv_battery;\n    // Initialize a UGVCommand message\n    swarm_control_topic::UGVCommand ugv_command;\n    // Initialize a UGVCommand message\n    swarm_control_topic::UGVCommand ugv_command_last;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.ugv_num; i++) {\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        ugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n        ugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n        ugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        ugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        ugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        ugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        ugv_state.velocity", "CodeBleu_score": 36.98468353436261}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\n    // Initialize the MultiUGVState message\n    ugv_msgs::MultiUGVState multi_ugv_state_msg;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\n        // Initialize the UGVState message\n        ugv_msgs::UGVState ugv_state_msg;\n\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        ugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n        ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n        ugv_state_msg.position = m_multi_ugv_state.ugv_state[i].position;\n        ugv_state_msg.velocity = m_multi_ugv_state.ugv_state[i].velocity;\n        ugv_state_msg.attitude = m_multi_ugv_state.ugv_state[i].attitude;\n\n        // Increment the UGV count and add the UGVState message to the MultiUGVState message\n        multi_ugv_state_msg.ugv_count++;\n        multi_ugv_state_msg.ugv_state.push_back(ugv_state_msg);\n    }\n\n    // Publish the assembled MultiUGVState message\n    m_all_ugv_state_pub.publish(multi_ugv_state_msg);\n}", "CodeBleu_score": 39.750742079886386}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    MultiUGVState ugv_state_msg;\n    ugv_state_msg.header.stamp = ros::Time::now();\n    ugv_state_msg.header.frame_id = \"world\";\n    ugv_state_msg.ugv_count = m_multi_ugv_state.ugv_count;\n\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n        UGVState ugv_state;\n        ugv_state.id = m_multi_ugv_state.ugv_states[i].id;\n        ugv_state.battery = m_multi_ugv_state.ugv_states[i].battery;\n        ugv_state.position.x = m_multi_ugv_state.ugv_states[i].position.x;\n        ugv_state.position.y = m_multi_ugv_state.ugv_states[i].position.y;\n        ugv_state.position.z = m_multi_ugv_state.ugv_states[i].position.z;\n        ugv_state.velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n        ugv_state.velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n        ugv_state.velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n        ugv_state.attitude.x = m_multi_ugv_state.ugv_states[i].attitude.x;\n        ugv_state.attitude.y = m_multi_ugv_state.ugv_states[i].attitude.y;\n        ugv_state.attitude.z = m_multi_ugv_state.ugv_states[i].attitude.z;\n        ugv_state.attitude.w = m_multi_ugv_state.ugv_states[i].attitude.w;\n        ugv_state_msg.ugv", "CodeBleu_score": 44.71671438150195}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    // Get the number of control points\n    int n = q.rows();\n\n    // Initialize the cost and gradient to zero\n    cost = 0.0;\n    gradient.setZero(n, 3);\n\n    // Iterate through the control points\n    for (int i = 0; i < n; i++) {\n        // Get the current control point\n        Eigen::Vector3d q_i = q.row(i);\n\n        // Get the predicted positions of the moving objects\n        std::vector<Eigen::Vector3d> predicted_positions;\n        for (int j = 0; j < moving_objects_.size(); j++) {\n            // Get the current moving object\n            MovingObject *moving_object = moving_objects_[j];\n\n            // Get the predicted position of the moving object\n            Eigen::Vector3d predicted_position = moving_object->getPredictedPosition(q_i);\n\n            // Add the predicted position to the list of predicted positions\n            predicted_positions.push_back(predicted_position);\n        }\n\n        // Evaluate the distance between the control point and the predicted positions of the moving objects\n        double min_distance = std::numeric_limits<double>::max();\n        for (int j = 0; j < predicted_positions.size(); j++) {\n            // Get the predicted position of the moving object\n            Eigen::Vector3d predicted_position = predicted_positions[j];\n\n            // Compute the distance between the control point and the predicted position\n            double distance = (q_i - predicted_position).norm();\n\n            // Update the minimum distance if necessary\n            if (distance < min_distance) {\n                min_distance = distance;\n            }\n        }\n\n        // If the distance is less than the clearance, update the cost and gradient\n        if (min_distance < clearance_) {\n            // Compute the distance error\n            double distance_error = clearance_ - min_distance;\n\n            // Update the cost\n            cost += distance_error * distance_error;\n\n            // Compute the gradient\n            Eigen::Vector3d gradient_i;\n            for (int j = 0; j < predicted_positions", "CodeBleu_score": 44.65552000365175}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  double dist, dist_grad;\n  double dist_sum = 0.0;\n  double dist_sum_grad = 0.0;\n  double dist_sum_grad_sq = 0.0;\n  double dist_sum_grad_sq_sq = 0.0;\n\n  for (int i = 0; i < q.rows(); i++) {\n    dist = calcMovingObjDist(q.row(i));\n    dist_grad = calcMovingObjDistGrad(q.row(i));\n    dist_sum += dist;\n    dist_sum_grad += dist_grad;\n    dist_sum_grad_sq += dist_grad * dist_grad;\n    dist_sum_grad_sq_sq += dist_grad * dist_grad * dist_grad * dist_grad;\n  }\n\n  cost = dist_sum;\n  gradient = dist_sum_grad * Eigen::MatrixXd::Ones(q.rows(), q.cols());\n}", "CodeBleu_score": 33.09617970107478}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Calculate the predicted positions of moving objects\n  Eigen::MatrixXd q_pred;\n  calcMovingObjPredPos(q, q_pred);\n\n  // Initialize cost and gradient\n  cost = 0.0;\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n  // Iterate through control points\n  for (int i = 0; i < q.rows(); i++) {\n    // Iterate through moving objects\n    for (int j = 0; j < moving_objs_.size(); j++) {\n      // Calculate the distance between the control point and the predicted position of the moving object\n      double dist = (q.row(i) - q_pred.row(i)).norm();\n\n      // Check if the distance is less than the clearance\n      if (dist < moving_objs_[j].clearance) {\n        // Update cost and gradient\n        double dist_error = moving_objs_[j].clearance - dist;\n        cost += dist_error * dist_error;\n        gradient.row(i) += 2.0 * dist_error * (q.row(i) - q_pred.row(i));\n      }\n    }\n  }\n}", "CodeBleu_score": 35.83777556514238}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    // Initialize cost to zero\n    cost = 0.0;\n\n    // Initialize gradient to zero\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    // Iterate through the control points of the trajectory\n    for (int i = 0; i < q.rows(); i++) {\n        // Compute the positional error relative to reference points\n        Eigen::Vector3d error = q.row(i) - _reference_points.row(i);\n\n        // Compute the velocity vector\n        Eigen::Vector3d velocity = Eigen::Vector3d::Zero();\n        if (i > 0) {\n            velocity = q.row(i) - q.row(i - 1);\n        }\n\n        // Compute the squared dot product of the error and velocity vectors\n        double dot_product = error.dot(velocity);\n        double squared_dot_product = dot_product * dot_product;\n\n        // Compute the squared cross product of the error and velocity vectors\n        Eigen::Vector3d cross_product = error.cross(velocity);\n        double squared_cross_product = cross_product.dot(cross_product);\n\n        // Compute the fitness cost\n        double a2 = _a * _a;\n        double b2 = _b * _b;\n        double fitness_cost = squared_dot_product / a2 + squared_cross_product / b2;\n\n        // Update the cost\n        cost += fitness_cost;\n\n        // Compute the gradient for the current control point\n        double derivative_dot_product = error.dot(velocity) * 2.0 / a2;\n        double derivative_squared_cross_product = cross_product.dot(velocity) * 2.0 / b2;\n        Eigen::Vector3d derivative = derivative_dot_product * error + derivative_squared_cross_product * cross_product;\n\n        // Update the gradient\n        gradient.row(i) = derivative;\n    }\n}", "CodeBleu_score": 39.44899090985926}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n    // Initialize the cost and gradient to zero\n    cost = 0.0;\n    gradient.setZero();\n\n    // Loop through the control points of the trajectory\n    for (int i = 0; i < q.cols(); i++) {\n        // Compute the positional error and velocity vectors\n        Eigen::Vector3d error = q.col(i) - reference_points_.col(i);\n        Eigen::Vector3d velocity = (i > 0) ? (q.col(i) - q.col(i - 1)) : Eigen::Vector3d::Zero();\n\n        // Compute the squared dot product and cross product of the error and velocity vectors\n        double dot_product = error.dot(velocity);\n        Eigen::Vector3d cross_product = error.cross(velocity);\n\n        // Normalize the dot product and cross product by constants a2 and b2\n        double a2 = a_ * a_;\n        double b2 = b_ * b_;\n        double a2_dot_product = a2 * dot_product;\n        double b2_cross_product = b2 * cross_product.squaredNorm();\n\n        // Update the cost and gradient for this control point\n        cost += a2_dot_product + b2_cross_product;\n        gradient.col(i) = a2 * velocity + 2.0 * b2 * cross_product;\n    }\n}", "CodeBleu_score": 40.06945382598469}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Initialize cost and gradient to zero\n  cost = 0.0;\n  gradient.setZero();\n\n  // Iterate through control points\n  for (int i = 0; i < q.cols(); i++) {\n    // Compute positional error\n    Eigen::Vector3d pos_error = q.col(i) - reference_points_.col(i);\n\n    // Compute velocity vector\n    Eigen::Vector3d vel_vec;\n    if (i == 0) {\n      vel_vec = (q.col(i + 1) - q.col(i)) / delta_t_;\n    } else if (i == q.cols() - 1) {\n      vel_vec = (q.col(i) - q.col(i - 1)) / delta_t_;\n    } else {\n      vel_vec = (q.col(i + 1) - q.col(i - 1)) / (2 * delta_t_);\n    }\n\n    // Compute cost and gradient\n    double cost_i = pos_error.squaredNorm() * a2_ + vel_vec.squaredNorm() * b2_;\n    Eigen::Vector3d grad_i = 2 * a2_ * pos_error + 2 * b2_ * vel_vec;\n\n    // Update cost and gradient\n    cost += cost_i;\n    gradient.col(i) = grad_i;\n  }\n}", "CodeBleu_score": 35.78669258723654}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t    double jerk = 0.0;\n    // Compute the third derivative of the spline\n    bspline_opt::UniformBspline third_derivative = getThirdDerivative();\n    // Retrieve the knot times and control points of the third derivative\n    std::vector<double> knot_times = third_derivative.getKnotTimes();\n    std::vector<std::vector<double>> control_points = third_derivative.getControlPoints();\n    // Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n    for (int i = 0; i < control_points.size(); i++) {\n        for (int j = 0; j < control_points[i].size(); j++) {\n            jerk += control_points[i][j] * control_points[i][j] * (knot_times[i+1] - knot_times[i]);\n        }\n    }\n    return jerk;\n}", "CodeBleu_score": 50.31516736511556}, {"code": "double UniformBspline::getJerk(){\n\t    // Compute third derivative of the spline to obtain the jerk trajectory\n    UniformBspline jerk_spline = this->getThirdDerivative();\n\n    // Retrieve knot times and control points of the jerk trajectory\n    std::vector<double> knot_times = jerk_spline.getKnotTimes();\n    std::vector<std::vector<double>> control_points = jerk_spline.getControlPoints();\n\n    // Iterate through control points and dimensions to compute the jerk value\n    double jerk = 0.0;\n    for (int i = 0; i < control_points.size(); i++) {\n        for (int j = 0; j < control_points[i].size(); j++) {\n            jerk += control_points[i][j] * control_points[i][j] * (knot_times[i+1] - knot_times[i]);\n        }\n    }\n\n    return jerk;\n}", "CodeBleu_score": 49.22285470611884}, {"code": "double UniformBspline::getJerk(){\n\t    // Calculate the third derivative of the spline\n    Eigen::MatrixXd d3 = this->getThirdDerivative();\n\n    // Retrieve the knot times and control points of the jerk trajectory\n    std::vector<double> jerk_knots = this->getKnots(3);\n    Eigen::MatrixXd jerk_control_points = this->getControlPoints(3);\n\n    // Initialize the total jerk value\n    double jerk = 0.0;\n\n    // Iterate through the control points and dimensions\n    for (int i = 0; i < jerk_control_points.rows(); i++) {\n        for (int j = 0; j < jerk_control_points.cols(); j++) {\n            // Sum the squared control point values multiplied by the differences in knot times\n            jerk += jerk_control_points(i, j) * jerk_control_points(i, j) * (jerk_knots[i + 1] - jerk_knots[i]);\n        }\n    }\n\n    // Return the total jerk value\n    return jerk;\n}", "CodeBleu_score": 50.09053596677426}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n    return pos;\n}", "CodeBleu_score": 49.315525916455506}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1;\n    return pos;\n}", "CodeBleu_score": 77.10646079020273}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1;\n    return pos;\n}", "CodeBleu_score": 63.352792714373265}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, extractDroneIdFromFrameId(odom.child_frame_id));\n    } catch (const std::exception& e) {\n        ROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n    }\n}", "CodeBleu_score": 40.83252492595277}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    std::string drone_id = odom.child_frame_id.substr(0, 1);\n    try {\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (std::exception& e) {\n        ROS_ERROR_STREAM(e.what());\n    }\n}", "CodeBleu_score": 51.368584644947155}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, odom.child_frame_id.substr(0, odom.child_frame_id.find('_')));\n    }\n    catch (const std::exception& e) {\n        ROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n    }\n}", "CodeBleu_score": 41.98644270138978}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // TODO: Implement this function\n    // Hint: Use the function DroneDetector::getPoseError to calculate the pose error\n    // Hint: Use the function DroneDetector::updateDebugResult to update the debug result\n    // Hint: Use the function DroneDetector::publishPoseError to publish the pose error\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose to get the true pose of the drone in the camera frame\n    // Hint: Use the function DroneDetector::getDronePose", "CodeBleu_score": 3.1170532294091036}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n    // Get the camera pose\n    Eigen::Matrix4f camera_pose = camera_model.get_pose();\n\n    // Compute the true pose of the drone in the camera frame\n    Eigen::Vector3f true_position = camera_pose.block<3, 3>(0, 0) * drone_positions[drone_id] + camera_pose.block<3, 1>(0, 3);\n    Eigen::Matrix3f true_rotation = camera_pose.block<3, 3>(0, 0) * drone_rotations[drone_id];\n\n    // Check if the drone is in the image\n    Eigen::Vector2i pixel;\n    if (camera_model.world_to_pixel(true_position, pixel)) {\n\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3f pose_error = camera_pose.block<3, 3>(0, 0).transpose() * (true_position - camera_pose.block<3, 3>(0, 0) * true_pixel - camera_pose.block<3, 1>(0, 3));\n\n        // Update the debug result\n        debug_result.drone_detected = true;\n        debug_result.drone_id = drone_id;\n        debug_result.true_position = true_position;\n        debug_result.true_rotation = true_rotation;\n        debug_result.pixel = pixel;\n        debug_result.pose_error = pose_error;\n\n        // Publish the pose error\n        pose_error_pub.publish(pose_error);\n\n    } else {\n\n        // Update the debug result to indicate failure\n        debug_result.drone_detected = false;\n        debug_result.drone_id = -1;\n        debug_result.true_position = Eigen::Vector3f::Zero();\n        debug_result.true_rotation = Eigen::Matrix3f::Zero();\n        debug_result.pixel = Eigen::Vector2i::Zero();\n        debug_result.pose_error =", "CodeBleu_score": 37.93211195887077}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Compute the true pose of the drone in the camera frame.\n    Eigen::Vector3d true_pose = drone_pose_estimator.estimatePose(drone_id, true_pixel);\n    // Check if the drone is present in the image.\n    bool drone_present = drone_pose_estimator.isDronePresent(true_pose);\n    // If the drone is present, compute the pose error between the camera and world coordinates.\n    if (drone_present) {\n        // Compute the pose error between the camera and world coordinates.\n        Eigen::Vector3d pose_error = drone_pose_estimator.computePoseError(true_pose);\n        // Update the debug result.\n        debug_result.drone_id = drone_id;\n        debug_result.true_pixel = true_pixel;\n        debug_result.true_pose = true_pose;\n        debug_result.pose_error = pose_error;\n        debug_result.drone_present = true;\n        // Publish the pose error.\n        pose_error_publisher.publish(pose_error);\n    }\n    // If the drone is not present, update the debug result to indicate failure.\n    else {\n        debug_result.drone_id = drone_id;\n        debug_result.true_pixel = true_pixel;\n        debug_result.true_pose = true_pose;\n        debug_result.pose_error = Eigen::Vector3d::Zero();\n        debug_result.drone_present = false;\n    }\n}", "CodeBleu_score": 40.58179308770015}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->parent != nullptr) {\n        current = current->parent;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 83.98978867982879}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getParent() != NULL) {\n        current = current->getParent();\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 80.77684409742409}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getParent() != NULL) {\n        current = current->getParent();\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 80.77684409742409}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\n    // Convert start and end points to indices\n    start_idx = grid.ConvertWorldToGrid(start_pt);\n    end_idx = grid.ConvertWorldToGrid(end_pt);\n\n    // If start or end point is inside an obstacle, adjust it\n    if (grid.CheckIfInObstacle(start_idx)) {\n        // Adjust start point\n        while (grid.CheckIfInObstacle(start_idx)) {\n            start_idx += Vector3i(1, 0, 0);\n        }\n    }\n    if (grid.CheckIfInObstacle(end_idx)) {\n        // Adjust end point\n        while (grid.CheckIfInObstacle(end_idx)) {\n            end_idx += Vector3i(1, 0, 0);\n        }\n    }\n\n    // Check if start and end points are still inside the grid\n    if (start_idx.x() < 0 || start_idx.y() < 0 || start_idx.z() < 0 || start_idx.x() >= grid.GetNumCellsX() || start_idx.y() >= grid.GetNumCellsY() || start_idx.z() >= grid.GetNumCellsZ()) {\n        return false;\n    }\n    if (end_idx.x() < 0 || end_idx.y() < 0 || end_idx.z() < 0 || end_idx.x() >= grid.GetNumCellsX() || end_idx.y() >= grid.GetNumCellsY() || end_idx.z() >= grid.GetNumCellsZ()) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 33.06737031690597}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\n  // Convert start point to grid index\n  start_idx = ConvertToGridIndex(start_pt);\n\n  // If start point is inside an obstacle, adjust it\n  if (CheckIfInsideObstacles(start_idx)) {\n    start_idx = AdjustPointToBeOutsideObstacles(start_idx, end_idx);\n    if (start_idx == Vector3i(-1, -1, -1)) {\n      return false;\n    }\n  }\n\n  // Convert end point to grid index\n  end_idx = ConvertToGridIndex(end_pt);\n\n  // If end point is inside an obstacle, adjust it\n  if (CheckIfInsideObstacles(end_idx)) {\n    end_idx = AdjustPointToBeOutsideObstacles(end_idx, start_idx);\n    if (end_idx == Vector3i(-1, -1, -1)) {\n      return false;\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 34.48045298469925}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\n    // Convert the start point to a grid index\n    start_idx = ConvertToGridIndex(start_pt);\n\n    // If the start point is inside an obstacle, adjust it\n    if (IsInsideObstacle(start_idx)) {\n        start_idx = AdjustPointToGridBoundary(start_idx, end_idx);\n    }\n\n    // Convert the end point to a grid index\n    end_idx = ConvertToGridIndex(end_pt);\n\n    // If the end point is inside an obstacle, adjust it\n    if (IsInsideObstacle(end_idx)) {\n        end_idx = AdjustPointToGridBoundary(end_idx, start_idx);\n    }\n\n    // Return true if the start and end points are valid\n    return (IsValidGridIndex(start_idx) && IsValidGridIndex(end_idx));\n}", "CodeBleu_score": 28.820031919945073}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    // Get the grid index of the minimum and maximum positions\n    int min_id = coord2gridIndex(min_pos);\n    int max_id = coord2gridIndex(max_pos);\n\n    // Iterate over the grid indices from min_id to max_id\n    for (int i = min_id; i <= max_id; ++i) {\n        occupancy_buffer_inflate_[i] = 0;\n    }\n}", "CodeBleu_score": 30.88466078163713}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  // Get the grid index of the minimum and maximum positions\n  Eigen::Vector3i min_id, max_id;\n  min_id << static_cast<int>(std::floor(min_pos(0) / resolution_)),\n      static_cast<int>(std::floor(min_pos(1) / resolution_)),\n      static_cast<int>(std::floor(min_pos(2) / resolution_));\n  max_id << static_cast<int>(std::ceil(max_pos(0) / resolution_)),\n      static_cast<int>(std::ceil(max_pos(1) / resolution_)),\n      static_cast<int>(std::ceil(max_pos(2) / resolution_));\n\n  // Reset the occupancy and distance buffers within the specified region\n  for (int x = min_id(0); x <= max_id(0); ++x) {\n    for (int y = min_id(1); y <= max_id(1); ++y) {\n      for (int z = min_id(2); z <= max_id(2); ++z) {\n        occupancy_buffer_inflate_(x, y, z) = 0.0;\n        distance_buffer_inflate_(x, y, z) = std::numeric_limits<double>::infinity();\n      }\n    }\n  }\n}", "CodeBleu_score": 69.79054697989385}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n  min_id = coord2gridIndex(min_pos);\n  max_id = coord2gridIndex(max_pos);\n  for (int x = min_id.x(); x <= max_id.x(); x++) {\n    for (int y = min_id.y(); y <= max_id.y(); y++) {\n      for (int z = min_id.z(); z <= max_id.z(); z++) {\n        occupancy_buffer_inflate_[x][y][z] = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 48.36719404005502}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n\n    double tx_max = (diff.x() > 0) ? (map_size_.x() - camera_pt.x()) / diff.x() : -camera_pt.x() / diff.x();\n    double tx_min = (diff.x() < 0) ? -camera_pt.x() / diff.x() : (0 - camera_pt.x()) / diff.x();\n    double ty_max = (diff.y() > 0) ? (map_size_.y() - camera_pt.y()) / diff.y() : -camera_pt.y() / diff.y();\n    double ty_min = (diff.y() < 0) ? -camera_pt.y() / diff.y() : (0 - camera_pt.y()) / diff.y();\n    double tz_max = (diff.z() > 0) ? (map_size_.z() - camera_pt.z()) / diff.z() : -camera_pt.z() / diff.z();\n    double tz_min = (diff.z() < 0) ? -camera_pt.z() / diff.z() : (0 - camera_pt.z()) / diff.z();\n\n    double tx_final = std::min(std::max(tx_min, tx_max), 1.0);\n    double ty_final = std::min(std::max(ty_min, ty_max), 1.0);\n    double tz_final = std::min(std::max(tz_min, tz_max), 1.0);\n\n    return camera_pt + tx_final * diff.x() * Eigen::Vector3d::UnitX() + ty_final * diff.y() * Eigen::Vector3d::UnitY() + tz_final * diff.z() * Eigen::Vector3d::UnitZ();\n}", "CodeBleu_score": 33.17346285447456}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    // Compute the difference vector between the point and the camera position\n    Eigen::Vector3d diff = pt - camera_pt;\n\n    // Determine the maximum and minimum translation coefficients along each axis\n    double max_trans_coeffs[3] = {0.0, 0.0, 0.0};\n    double min_trans_coeffs[3] = {0.0, 0.0, 0.0};\n    for (int i = 0; i < 3; i++) {\n        if (diff[i] > 0) {\n            max_trans_coeffs[i] = std::ceil(diff[i] / cell_size_[i]);\n        } else {\n            min_trans_coeffs[i] = std::floor(diff[i] / cell_size_[i]);\n        }\n    }\n\n    // Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n    double min_scaling_factor = 1.0;\n    for (int i = 0; i < 3; i++) {\n        if (max_trans_coeffs[i] > 0 && min_trans_coeffs[i] < 0) {\n            double scaling_factor = std::min(max_trans_coeffs[i], -min_trans_coeffs[i]);\n            if (scaling_factor < min_scaling_factor) {\n                min_scaling_factor = scaling_factor;\n            }\n        }\n    }\n\n    // Return the adjusted point near the boundary\n    Eigen::Vector3d adjusted_pt = pt - diff * min_scaling_factor;\n    return adjusted_pt;\n}", "CodeBleu_score": 46.837619390798736}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    double x_max = std::min(diff.x() / grid_size_x_, 1.0);\n    double x_min = std::max(diff.x() / grid_size_x_, -1.0);\n    double y_max = std::min(diff.y() / grid_size_y_, 1.0);\n    double y_min = std::max(diff.y() / grid_size_y_, -1.0);\n    double z_max = std::min(diff.z() / grid_size_z_, 1.0);\n    double z_min = std::max(diff.z() / grid_size_z_, -1.0);\n\n    double x_scale = x_max > 0 ? x_max : x_min;\n    double y_scale = y_max > 0 ? y_max : y_min;\n    double z_scale = z_max > 0 ? z_max : z_min;\n\n    double scale = std::max(x_scale, std::max(y_scale, z_scale));\n\n    return pt + diff * scale;\n}", "CodeBleu_score": 35.92423328100439}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t    // Update last occupancy update time\n    last_occupancy_update_time_ = ros::Time::now();\n\n    // Check if the local map has been updated\n    if (update_local_map_) {\n        // Clear the local map\n        local_map_.clear();\n\n        // Inflate the local map\n        local_map_.inflate();\n\n        // Reset the update local map flag\n        update_local_map_ = false;\n    }\n\n    // Check if the timeout for odometry or depth data has occurred\n    if (ros::Time::now() - last_odom_update_time_ > odom_timeout_ ||\n        ros::Time::now() - last_depth_update_time_ > depth_timeout_) {\n        // Set the timeout flag\n        timeout_ = true;\n\n        // Reset the last odometry update time\n        last_odom_update_time_ = ros::Time::now();\n\n        // Reset the last depth update time\n        last_depth_update_time_ = ros::Time::now();\n    }\n\n    // Check if the timeout flag is set\n    if (timeout_) {\n        // Clear the local map\n        local_map_.clear();\n\n        // Inflate the local map\n        local_map_.inflate();\n\n        // Reset the timeout flag\n        timeout_ = false;\n    }\n}", "CodeBleu_score": 41.83167060537896}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update last occupancy update time\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // Check if we have new data\n  if (depth_data_queue_.empty()) {\n    return;\n  }\n\n  // Get latest depth data\n  const auto &depth_data = depth_data_queue_.front();\n\n  // Check if we have new data\n  if (depth_data.stamp == ros::Time(0)) {\n    return;\n  }\n\n  // Check if the data is too old\n  if (depth_data.stamp < last_occupancy_update_time_) {\n    return;\n  }\n\n  // Check if we have new data\n  if (odom_data_queue_.empty()) {\n    return;\n  }\n\n  // Get latest odometry data\n  const auto &odom_data = odom_data_queue_.front();\n\n  // Check if we have new data\n  if (odom_data.stamp == ros::Time(0)) {\n    return;\n  }\n\n  // Check if the data is too old\n  if (odom_data.stamp < last_occupancy_update_time_) {\n    return;\n  }\n\n  // Check if the data is too old\n  if (odom_data.stamp > depth_data.stamp) {\n    return;\n  }\n\n  // Check if the data is too old\n  if (depth_data.stamp - odom_data.stamp > ros::Duration(0.5)) {\n    return;\n  }\n\n  // Check if we have new data\n  if (odom_data.stamp < last_occupancy_update_time_) {\n    return;\n  }\n\n  // Check if we have new data\n  if (odom_data.stamp > depth_data.stamp) {\n    return;\n  }\n\n  // Check if the data is too old\n  if (depth_data.stamp - odom_data.stamp > ros::Duration(0.5)) {\n    return;\n  }\n\n  // Check if we have new data\n", "CodeBleu_score": 35.75532043210479}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t    // Update last occupancy update time\n    last_occupancy_update_time_ = ros::Time::now();\n\n    // Update occupancy\n    if (update_occupancy_) {\n        update_occupancy_ = false;\n\n        // Project depth image into points\n        cv::Mat points;\n        projectDepthImage(points);\n\n        // Process points with raycasting\n        processPoints(points);\n\n        // If local map has been updated, clear and inflate local map\n        if (local_map_updated_) {\n            local_map_updated_ = false;\n            clearLocalMap();\n            inflateLocalMap();\n        }\n\n        // Handle timeout errors for odometry or depth data\n        if (odom_timeout_) {\n            odom_timeout_ = false;\n            ROS_WARN(\"Odometry timeout\");\n        }\n        if (depth_timeout_) {\n            depth_timeout_ = false;\n            ROS_WARN(\"Depth timeout\");\n        }\n    }\n}", "CodeBleu_score": 34.52668116911825}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float f_measure = 0;\n    for (int i = 0; i < image_fns.size(); i++) {\n        vector<Ellipse> gt_ellipses;\n        vector<Ellipse> dt_ellipses;\n        load_ellipses(gt_ellipses, gt_fns[i]);\n        load_ellipses(dt_ellipses, dt_fns[i]);\n        f_measure += evaluate_ellipse_detection(gt_ellipses, dt_ellipses, gt_angle_radians);\n    }\n    f_measure /= image_fns.size();\n    return f_measure;\n}", "CodeBleu_score": 64.10221666084077}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float f_measure = 0;\n\n    for (int i = 0; i < image_fns.size(); i++) {\n        string image_fn = image_fns[i];\n        string gt_fn = gt_fns[i];\n        string dt_fn = dt_fns[i];\n\n        // load the image\n        Mat image = imread(image_fn);\n        if (image.empty()) {\n            cerr << \"Error: Failed to load image \" << image_fn << endl;\n            continue;\n        }\n\n        // load the ground truth ellipses\n        vector<Ellipse> gt_ellipses;\n        if (!load_ellipses(gt_fn, gt_ellipses, gt_angle_radians)) {\n            cerr << \"Error: Failed to load ground truth ellipses from \" << gt_fn << endl;\n            continue;\n        }\n\n        // load the detected ellipses\n        vector<Ellipse> dt_ellipses;\n        if (!load_ellipses(dt_fn, dt_ellipses, false)) {\n            cerr << \"Error: Failed to load detected ellipses from \" << dt_fn << endl;\n            continue;\n        }\n\n        // evaluate the detection performance\n        float f_measure_i = evaluate_ellipses(image, gt_ellipses, dt_ellipses);\n\n        // accumulate the F-measure\n        f_measure += f_measure_i;\n    }\n\n    // calculate the average F-measure\n    float average_f_measure = f_measure / image_fns.size();\n\n    return average_f_measure;\n}", "CodeBleu_score": 55.266440601720255}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float f_measure = 0;\n    for (int i = 0; i < image_fns.size(); i++) {\n        // Load image\n        Mat image = imread(image_fns[i]);\n        if (image.empty()) {\n            cerr << \"Error: Could not load image \" << image_fns[i] << endl;\n            return -1;\n        }\n\n        // Load ground truth ellipses\n        vector<Ellipse> gt_ellipses;\n        if (!_ellipse_load_ellipses(gt_fns[i], gt_ellipses, gt_angle_radians)) {\n            cerr << \"Error: Could not load ground truth ellipses for image \" << image_fns[i] << endl;\n            return -1;\n        }\n\n        // Load detected ellipses\n        vector<Ellipse> dt_ellipses;\n        if (!_ellipse_load_ellipses(dt_fns[i], dt_ellipses, true)) {\n            cerr << \"Error: Could not load detected ellipses for image \" << image_fns[i] << endl;\n            return -1;\n        }\n\n        // Evaluate detection performance\n        float f_measure_i = _ellipse_evaluate_image(image, gt_ellipses, dt_ellipses);\n        f_measure += f_measure_i;\n    }\n    f_measure /= image_fns.size();\n    return f_measure;\n}", "CodeBleu_score": 61.071304131745244}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float a = foci[0];\n    float b = foci[1];\n    float c = foci[2];\n    float d = foci[3];\n\n    float x_a = x - a;\n    float y_a = y - b;\n    float x_c = x - c;\n    float y_c = y - d;\n\n    float angle_a = atan2(y_a, x_a);\n    float angle_c = atan2(y_c, x_c);\n\n    float normal_angle = angle_a - angle_c;\n\n    if (normal_angle < -M_PI) {\n        normal_angle += 2 * M_PI;\n    } else if (normal_angle > M_PI) {\n        normal_angle -= 2 * M_PI;\n    }\n\n    return normal_angle;\n}", "CodeBleu_score": 37.73273094547399}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float a = foci[0], b = foci[1];\n    float xa = x - a, ya = y - a;\n    float xb = x - b, yb = y - b;\n    float a_angle = atan2(ya, xa);\n    float b_angle = atan2(yb, xb);\n    float normal_angle = a_angle - b_angle;\n    if (normal_angle > M_PI)\n        normal_angle -= 2 * M_PI;\n    else if (normal_angle < -M_PI)\n        normal_angle += 2 * M_PI;\n    return normal_angle;\n}", "CodeBleu_score": 38.57698514223264}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    if (foci == NULL)\n        return 0.0f;\n\n    float angle1 = atan2(y - foci[1], x - foci[0]);\n    float angle2 = atan2(y - foci[3], x - foci[2]);\n    float angle = angle2 - angle1;\n    if (angle > M_PI)\n        angle -= 2 * M_PI;\n    else if (angle < -M_PI)\n        angle += 2 * M_PI;\n    return angle;\n}", "CodeBleu_score": 50.30575919510763}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    double min_x = std::numeric_limits<double>::max();\n    double max_x = std::numeric_limits<double>::min();\n    double min_y = std::numeric_limits<double>::max();\n    double max_y = std::numeric_limits<double>::min();\n\n    for (int i = start; i < end; i++) {\n        if (vp1[i].x < min_x) min_x = vp1[i].x;\n        if (vp1[i].x > max_x) max_x = vp1[i].x;\n        if (vp1[i].y < min_y) min_y = vp1[i].y;\n        if (vp1[i].y > max_y) max_y = vp1[i].y;\n    }\n\n    double integral_above = 0.0;\n    double integral_below = 0.0;\n\n    for (int i = start; i < end; i++) {\n        if (vp1[i].x > min_x && vp1[i].x < max_x && vp1[i].y > min_y && vp1[i].y < max_y) {\n            if (vp1[i].y > (vp1[i].x - min_x) * (max_y - min_y) / (max_x - min_x) + min_y) {\n                integral_above += (vp1[i].x - min_x) * (max_y - min_y) / (max_x - min_x) - min_y;\n            } else {\n                integral_below += (vp1[i].x - min_x) * (max_y - min_y) / (max_x - min_x) - min_y;\n            }\n        }\n    }\n\n    return integral_above < integral_below;\n}", "CodeBleu_score": 39.732857688022946}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\n    // Get the minimum and maximum x and y coordinates of the points in the section\n    auto [xmin, xmax, ymin, ymax] = std::accumulate(vp1.begin() + start, vp1.begin() + end, std::make_tuple(std::numeric_limits<double>::max(), std::numeric_limits<double>::min(), std::numeric_limits<double>::max(), std::numeric_limits<double>::min()),\n        [](std::tuple<double, double, double, double>& t, const VP::value_type& p) {\n            return std::make_tuple(std::min(std::get<0>(t), p.x), std::max(std::get<1>(t), p.x), std::min(std::get<2>(t), p.y), std::max(std::get<3>(t), p.y));\n        });\n\n    // Compute the integral above and below the polygon section\n    double integral_above = 0.0, integral_below = 0.0;\n    for (int i = start; i < end; ++i) {\n        const VP::value_type& p1 = vp1[i];\n        const VP::value_type& p2 = vp1[(i + 1) % vp1.size()];\n        double x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;\n        if (x1 > x2) std::swap(x1, x2), std::swap(y1, y2);\n        if (x1 < xmin) x1 = xmin;\n        if (x2 > xmax) x2 = xmax;\n        if (x1 < x2) {\n            double y_min = y1, y_max = y2;\n            if (y_min > y_max) std::swap(y_min, y_max);\n            if (y_min < ymin) y_min = ymin;\n            if (y_max > ymax) y_max = ymax;\n            integral", "CodeBleu_score": 39.36675495192171}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t  // Calculate the minimum and maximum x and y coordinates of the points in the section\n  double min_x = std::numeric_limits<double>::max();\n  double max_x = std::numeric_limits<double>::min();\n  double min_y = std::numeric_limits<double>::max();\n  double max_y = std::numeric_limits<double>::min();\n  for (int i = start; i < end; ++i) {\n    if (vp1[i].x < min_x) min_x = vp1[i].x;\n    if (vp1[i].x > max_x) max_x = vp1[i].x;\n    if (vp1[i].y < min_y) min_y = vp1[i].y;\n    if (vp1[i].y > max_y) max_y = vp1[i].y;\n  }\n\n  // Calculate the integral above and below the polygon section\n  double above = 0, below = 0;\n  for (int i = start; i < end; ++i) {\n    double x = vp1[i].x, y = vp1[i].y;\n    if (x >= min_x && x <= max_x && y >= min_y && y <= max_y) {\n      above += (x - min_x) * (y - min_y);\n      below += (max_x - x) * (max_y - y);\n    }\n  }\n\n  // If the integral above is less than the integral below, the section is convex; otherwise, it is concave\n  return above < below;\n}", "CodeBleu_score": 40.22637892209413}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (int i = 0; i < msg->detection_info.size(); i++) {\n        if (msg->detection_info[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n            if (num_regain > VISION_THRES) {\n                is_detected = true;\n            }\n        } else {\n            num_regain = 0;\n            num_lost++;\n            if (num_lost > VISION_THRES) {\n                is_detected = false;\n            }\n        }\n    }\n    if (is_detected) {\n        ellipse_det.sight_angle = -ellipse_det.sight_angle;\n    }\n}", "CodeBleu_score": 63.01621868365231}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (int i = 0; i < msg->detection_info.size(); i++) {\n        if (msg->detection_info[i].object_name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        } else if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n    }\n    if (is_detected) {\n        if (msg->detection_info[0].object_name == \"T\") {\n            ellipse_det.sight_angle = msg->detection_info[0].sight_angle;\n        } else {\n            ellipse_det.sight_angle = msg->detection_info[1].sight_angle;\n        }\n    } else {\n        if (msg->detection_info[0].object_name == \"T\") {\n            ellipse_det.sight_angle = msg->detection_info[1].sight_angle;\n        } else {\n            ellipse_det.sight_angle = msg->detection_info[0].sight_angle;\n        }\n    }\n}", "CodeBleu_score": 63.9083355839982}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    int num_regain = 0;\n    int num_lost = 0;\n    bool is_detected = false;\n\n    for (int i = 0; i < msg->detections.size(); i++) {\n        if (msg->detections[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n    }\n\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    } else if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n\n    if (is_detected) {\n        ellipse_det.sight_angle = ellipse_det.sight_angle * -1;\n    }\n}", "CodeBleu_score": 66.17986744687899}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    // check if the current position is within the safety distance of the obstacle\n    if (Occupy_map_ptr->get_occupancy_state(cur_pos) < safe_distance) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 35.15928938963619}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    return Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 45.68302491297701}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    if (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 45.605529573253236}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    while (current_node != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.40075271088732}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    path_nodes_.clear();\n    NodePtr curr = end_node;\n    while (curr->parent != nullptr) {\n        path_nodes_.push_back(curr);\n        curr = curr->parent;\n    }\n    path_nodes_.push_back(curr);\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.66248670939732}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    while (current_node != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.40075271088732}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    if (simulation_mode) {\n        double dist = sqrt(pow(odom->pose.pose.position.x - start_pos[0], 2) + pow(odom->pose.pose.position.y - start_pos[1], 2));\n        if (dist > 5.0) {\n            get_nei_state[id] = false;\n        }\n        else {\n            get_nei_state[id] = true;\n        }\n    }\n    else {\n        get_nei_state[id] = true;\n    }\n\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n}", "CodeBleu_score": 59.96633371751193}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t  state_nei[id].x = odom->pose.pose.position.x;\n  state_nei[id].y = odom->pose.pose.position.y;\n  state_nei[id].z = odom->pose.pose.position.z;\n  state_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n  state_nei[id].vx = odom->twist.twist.linear.x;\n  state_nei[id].vy = odom->twist.twist.linear.y;\n  state_nei[id].vz = odom->twist.twist.linear.z;\n  state_nei[id].yaw_dot = odom->twist.twist.angular.z;\n\n  if(simulation_mode) {\n    if(sqrt(pow(state_nei[id].x - start_x, 2) + pow(state_nei[id].y - start_y, 2)) > 5) {\n      get_nei_state[id] = false;\n    }\n    else {\n      get_nei_state[id] = true;\n    }\n  }\n  else {\n    get_nei_state[id] = true;\n  }\n}", "CodeBleu_score": 55.50457761463675}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    if (simulation_mode) {\n        if (sqrt(pow(odom->pose.pose.position.x - start_x, 2) + pow(odom->pose.pose.position.y - start_y, 2)) > 5) {\n            get_nei_state = false;\n        }\n        else {\n            get_nei_state = true;\n        }\n    }\n    else {\n        get_nei_state = true;\n    }\n\n    if (get_nei_state) {\n        state_nei[id].x = odom->pose.pose.position.x;\n        state_nei[id].y = odom->pose.pose.position.y;\n        state_nei[id].z = odom->pose.pose.position.z;\n    }\n}", "CodeBleu_score": 48.13747621903158}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n  // If odometry is not ready, return immediately\n  if (!odom_ready) {\n    return;\n  }\n\n  // Update the update counter\n  update_counter++;\n\n  // If the update counter is divisible by 5, update the Astar map with the new point cloud data and reset the update counter\n  if (update_counter % 5 == 0) {\n    update_counter = 0;\n    // Update the Astar map with the new point cloud data\n    update_map(msg);\n  }\n}", "CodeBleu_score": 45.531265441159874}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    if (!odom_ready) {\n        return;\n    }\n\n    update_count++;\n\n    if (update_count == 5) {\n        update_count = 0;\n        sensor_ready = true;\n        ROS_INFO(\"Got new point cloud data\");\n\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*msg, *cloud);\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::VoxelGrid<pcl::PointXYZ> vg;\n        vg.setInputCloud(cloud);\n        vg.setLeafSize(0.1f, 0.1f, 0.1f);\n        vg.filter(*cloud_filtered);\n\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::VoxelGrid<pcl::PointXYZ> vg_downsampled;\n        vg_downsampled.setInputCloud(cloud_filtered);\n        vg_downsampled.setLeafSize(0.2f, 0.2f, 0.2f);\n        vg_downsampled.filter(*cloud_filtered_downsampled);\n\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_cropped(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::CropBox<pcl::PointXYZ> cropper;\n        cropper.setInputCloud(cloud_filtered_downsampled);\n        cropper.setMin(Eigen::Vector4f(-5.0, -5.0, -1.0, 1.0));\n        cropper.setMax(Eigen::Vector4f(5.0, 5.0, 1.0, 1.0));\n       ", "CodeBleu_score": 50.624298995208896}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    //ROS_INFO(\"Gpointcloud_cb\");\n    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter == 5) {\n        update_counter = 0;\n        //ROS_INFO(\"Updating Astar map\");\n        update_astar_map(msg);\n    }\n}", "CodeBleu_score": 57.23122039919931}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (!get_gpcl) {\n    get_gpcl = true;\n    // convert sensor_msgs::PointCloud2 to pcl::PointCloud<pcl::PointXYZ>\n    pcl::fromROSMsg(*global_point, *global_cloud);\n    // store the point cloud\n    global_cloud_store = *global_cloud;\n    // inflate the point cloud\n    inflate_cloud(global_cloud, global_cloud_inflate);\n  }\n}", "CodeBleu_score": 53.37202035692472}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, *global_map);\n\t\tglobal_map_inflate();\n\t}\n}", "CodeBleu_score": 40.280095275019654}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (!get_gpcl) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_cloud);\n    global_cloud->header.frame_id = \"map\";\n    pcl::PointCloud<pcl::PointXYZ>::Ptr global_cloud_inflate(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;\n    voxel_grid.setLeafSize(0.1, 0.1, 0.1);\n    voxel_grid.setInputCloud(global_cloud);\n    voxel_grid.filter(*global_cloud_inflate);\n    global_cloud = global_cloud_inflate;\n  }\n}", "CodeBleu_score": 52.3458085541513}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t  // Convert the laser scan to a PointCloud2 format\n  sensor_msgs::PointCloud2 laser_cloud;\n  projector.projectLaser(*local_point, laser_cloud);\n\n  // Convert the PointCloud2 format to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(laser_cloud, *cloud);\n\n  // If not in simulation mode, merge the local map with the provided odometry data\n  if (!simulation_mode) {\n    // Convert the odometry data to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr odom_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    odom_cloud->width = 1;\n    odom_cloud->height = 1;\n    odom_cloud->points.push_back(pcl::PointXYZ(odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z));\n\n    // Merge the local map with the odometry data\n    pcl::PointCloud<pcl::PointXYZ>::Ptr merged_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::concatenatePointCloud(*cloud, *odom_cloud, *merged_cloud);\n    cloud = merged_cloud;\n  }\n\n  // Update the occupancy map using the PointCloud\n  map_update(cloud);\n}", "CodeBleu_score": 49.33186256517794}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n  // Convert laser scan to PointCloud2\n  sensor_msgs::PointCloud2 laser_cloud;\n  projector_.projectLaser(*local_point, laser_cloud);\n\n  // Convert PointCloud2 to pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(laser_cloud, *cloud);\n\n  // Update the occupancy map\n  update_map(cloud, odom);\n}", "CodeBleu_score": 47.66645670562573}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // Create a PointCloud2 object to store the laser scan data\n    sensor_msgs::PointCloud2 laser_cloud;\n\n    // Convert the laser scan data to a PointCloud2 format\n    projector_.projectLaser(*local_point, laser_cloud);\n\n    // Convert the PointCloud2 object to a pcl::PointCloud object\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(laser_cloud, *cloud);\n\n    // If not in simulation mode, merge the local map with the provided odometry data\n    if (!simulation_mode_) {\n        // Convert the odometry data to a pcl::PointCloud object\n        pcl::PointCloud<pcl::PointXYZ>::Ptr odom_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(odom.pose.pose, *odom_cloud);\n\n        // Merge the local map with the odometry data\n        pcl::PointCloud<pcl::PointXYZ>::Ptr merged_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::concatenatePointCloud(*cloud, *odom_cloud, *merged_cloud);\n\n        // Update the occupancy map with the merged cloud\n        map_update_cloud(merged_cloud);\n    } else {\n        // Update the occupancy map with the laser scan data\n        map_update_cloud(cloud);\n    }\n}", "CodeBleu_score": 53.57427231542202}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n    // Convert the global point cloud map to a ROS message and publish it with the frame ID \"world\" to the global_pcl_pub topic\n    pcl::toROSMsg(global_map, global_pcl_pub.msg);\n    global_pcl_pub.msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_pub.msg);\n\n    // Convert and publish the inflated point cloud to the inflate_pcl_pub topic with the same frame ID\n    pcl::toROSMsg(inflate_map, inflate_pcl_pub.msg);\n    inflate_pcl_pub.msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_pub.msg);\n}", "CodeBleu_score": 42.802356808788375}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  // Convert the global point cloud map to a ROS message\n  sensor_msgs::PointCloud2 pcl_msg;\n  pcl::toROSMsg(global_pcl, pcl_msg);\n  pcl_msg.header.frame_id = \"world\";\n\n  // Publish the global point cloud map\n  global_pcl_pub.publish(pcl_msg);\n\n  // Convert the inflated point cloud to a ROS message\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(inflate_pcl, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n\n  // Publish the inflated point cloud\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 56.66437114069319}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  //ROS_INFO(\"Publishing point cloud\");\n\n  // Publish the global point cloud\n  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(global_pcl, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // Publish the inflated point cloud\n  sensor_msgs::PointCloud2 inflated_pcl_msg;\n  pcl::toROSMsg(inflated_pcl, inflated_pcl_msg);\n  inflated_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflated_pcl_msg);\n}", "CodeBleu_score": 58.06706960091811}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    //ROS_INFO(\"pointcloud_cb\");\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg, *cloud);\n\n    if (sensor_ready) {\n        //ROS_INFO(\"sensor_ready\");\n        //ROS_INFO(\"cloud->size() %d\", cloud->size());\n        //ROS_INFO(\"cloud->points.size() %d\", cloud->points.size());\n        //ROS_INFO(\"cloud->width %d\", cloud->width);\n        //ROS_INFO(\"cloud->height %d\", cloud->height);\n        //ROS_INFO(\"cloud->is_dense %d\", cloud->is_dense);\n        //ROS_INFO(\"cloud->isOrganized %d\", cloud->isOrganized);\n        //ROS_INFO(\"cloud->sensor_origin_.x %f\", cloud->sensor_origin_.x);\n        //ROS_INFO(\"cloud->sensor_origin_.y %f\", cloud->sensor_origin_.y);\n        //ROS_INFO(\"cloud->sensor_origin_.z %f\", cloud->sensor_origin_.z);\n        //ROS_INFO(\"cloud->sensor_orientation_.x %f\", cloud->sensor_orientation_.x);\n        //ROS_INFO(\"cloud->sensor_orientation_.y %f\", cloud->sensor_orientation_.y);\n        //ROS_INFO(\"cloud->sensor_orientation_.z %f\", cloud->sensor_orientation_.z);\n        //ROS_INFO(\"cloud->sensor_orientation_.w %f\", cloud->sensor_orientation_.w);\n        //ROS_INFO(\"cloud->header.seq %d\", cloud->header.seq);\n        //ROS_INFO(\"cloud->header.stamp.sec %d\", cloud->header.stamp.sec);\n        //ROS_INFO(\"cloud->header.stamp.nsec %", "CodeBleu_score": 38.435785239318164}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    //ROS_INFO(\"In pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"Pointcloud callback\");\n    //ROS_INFO(\"", "CodeBleu_score": 8.101402066304516}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    //ROS_INFO(\"Pointcloud received.\");\n    if (odom_ready) {\n        sensor_ready = true;\n        //ROS_INFO(\"Odometry ready.\");\n    }\n    if (sensor_ready) {\n        //ROS_INFO(\"Sensor ready.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>());\n        pcl::fromROSMsg(*msg, *cloud);\n        //ROS_INFO(\"Pointcloud converted.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");\n        //ROS_INFO(\"Pointcloud received.\");", "CodeBleu_score": 48.85848727827268}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Get current robot state\n    QuadrupedState current_state = quadruped_state_estimator_.getState();\n\n    // Calculate desired foot positions\n    QuadrupedState desired_state = body_controller_.getDesiredState(current_state);\n\n    // Compute velocity commands for the legs\n    QuadrupedState velocity_commands = leg_controller_.getVelocityCommands(current_state, desired_state);\n\n    // Perform inverse kinematics to determine target joint positions\n    QuadrupedState joint_positions = inverse_kinematics_.getJointPositions(velocity_commands);\n\n    // Publish foot contact information\n    quadruped_msgs::FootContacts foot_contacts_msg;\n    foot_contacts_msg.header.stamp = ros::Time::now();\n    foot_contacts_msg.header.frame_id = \"base_link\";\n    foot_contacts_msg.contacts = {\n        quadruped_msgs::FootContact(desired_state.left_front_foot.x, desired_state.left_front_foot.y, desired_state.left_front_foot.z, true),\n        quadruped_msgs::FootContact(desired_state.right_front_foot.x, desired_state.right_front_foot.y, desired_state.right_front_foot.z, true),\n        quadruped_msgs::FootContact(desired_state.left_back_foot.x, desired_state.left_back_foot.y, desired_state.left_back_foot.z, true),\n        quadruped_msgs::FootContact(desired_state.right_back_foot.x, desired_state.right_back_foot.y, desired_state.right_back_foot.z, true)\n    };\n    foot_contacts_pub_.publish(foot_contacts_msg);\n\n    // Publish joint positions\n    quadruped_msgs::JointPositions joint_positions_msg;\n    joint_positions_msg.header.stamp = ros::Time::now();\n    joint_positions_msg.header", "CodeBleu_score": 43.853518008864654}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n    // Check if the robot is in a safe state\n    if (!robot_state_estimator_.is_safe()) {\n        ROS_ERROR_STREAM(\"Robot is not in a safe state. Stopping control loop.\");\n        return;\n    }\n\n    // Get the current time\n    const ros::Time current_time = ros::Time::now();\n\n    // Get the current robot state\n    const RobotState& robot_state = robot_state_estimator_.get_robot_state();\n\n    // Get the desired pose of the robot\n    const Pose& desired_pose = robot_state.pose;\n\n    // Compute the desired foot positions based on the desired pose\n    const std::vector<Pose> desired_foot_positions = body_controller_.compute_foot_positions(desired_pose);\n\n    // Compute the desired foot velocities based on the desired foot positions\n    const std::vector<Twist> desired_foot_velocities = body_controller_.compute_foot_velocities(desired_foot_positions);\n\n    // Compute the desired joint positions for each leg\n    const std::vector<JointPosition> desired_joint_positions = inverse_kinematics_.compute_joint_positions(desired_foot_positions);\n\n    // Compute the desired joint velocities for each leg\n    const std::vector<JointVelocity> desired_joint_velocities = inverse_kinematics_.compute_joint_velocities(desired_foot_velocities);\n\n    // Publish the desired foot positions and velocities\n    publish_foot_positions_and_velocities(desired_foot_positions, desired_foot_velocities);\n\n    // Publish the desired joint positions and velocities\n    publish_joint_positions_and_velocities(desired_joint_positions, desired_joint_velocities);\n\n    // Publish the foot contact information\n    publish_foot_contact_information();\n\n    // Update the robot state\n    robot_state_estimator_.update_robot_state(current_time, desired_foot_positions, desired_foot_velocities);\n}", "CodeBleu_score": 38.13359823881519}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Get the current time\n    const ros::Time t = ros::Time::now();\n\n    // Get the current pose of the robot\n    const Pose2D currentPose = robot_->getPose();\n\n    // Get the desired pose of the robot\n    const Pose2D desiredPose = poseGenerator_->getDesiredPose(t);\n\n    // Calculate the target foot positions based on the desired pose\n    const std::vector<Pose2D> targetFootPositions = bodyController_->getTargetFootPositions(desiredPose, currentPose, t);\n\n    // Calculate the velocity commands for the legs\n    const std::vector<Velocity2D> legVelocities = legController_->getTargetLegVelocities(targetFootPositions, currentPose, t);\n\n    // Perform inverse kinematics to determine target joint positions\n    const std::vector<JointPositions> targetJointPositions = inverseKinematics_->getTargetJointPositions(legVelocities, t);\n\n    // Publish foot contact information\n    const std::vector<bool> footContacts = footSensors_->getFootContacts(t);\n    footContactPublisher_.publish(footContacts);\n\n    // Publish joint positions\n    jointPositionPublisher_.publish(targetJointPositions);\n}", "CodeBleu_score": 45.077852908835915}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (publish_foot_contacts_ && !is_in_gazebo_) {\n    ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.header.frame_id = \"world\";\n    contacts_msg.contacts.resize(4);\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i].id = i;\n      contacts_msg.contacts[i].state = foot_contacts[i] ? Contact::CONTACT : Contact::NO_CONTACT;\n      contacts_msg.contacts[i].phase = gait_generator_.getLegGaitPhase(i);\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 63.241305500332054}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_.getNumSubscribers() > 0 && !gazebo_) {\n    // Create message\n    quadruped_msgs::ContactsStamped msg;\n    msg.header.stamp = ros::Time::now();\n    msg.header.frame_id = \"world\";\n\n    // Populate message\n    for (int i = 0; i < 4; i++) {\n      msg.contacts[i] = foot_contacts[i];\n    }\n\n    // Publish message\n    foot_contacts_publisher_.publish(msg);\n  }\n}", "CodeBleu_score": 49.333540965887835}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contact_publishing_enabled_ && !is_gazebo_) {\n    ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i].header.stamp = contacts_msg.header.stamp;\n      contacts_msg.contacts[i].header.frame_id = foot_names_[i];\n      contacts_msg.contacts[i].contact_state = foot_contacts[i];\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 62.6483169533266}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t  joints_msg = Joints()\n  joints_msg.header.stamp = rospy.Time.now()\n  joints_msg.header.frame_id = 'joint_states'\n  joints_msg.names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n  joints_msg.positions = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]]\n  joints_msg.velocities = [joints.velocity[0], joints.velocity[1], joints.velocity[2], joints.velocity[3], joints.velocity[4], joints.velocity[5], joints.velocity[6], joints.velocity[7], joints.velocity[8], joints.velocity[9], joints.velocity[10], joints.velocity[11]]\n  joints_msg.effort = [joints.effort[0], joints.effort[1], joints.effort[2], joints.effort[3], joints.effort[4], joints.effort[5], joints.effort[6], joints.effort[7], joints.effort[8], joints.effort[9], joints.effort[10], joints.effort[11]]\n  self.joints_pub.publish(joints_msg)\n\n  trajectory = JointTrajectory()\n  trajectory.header.stamp = rospy.Time.now()\n  trajectory.header.frame_id = 'joint_states'\n  trajectory.joint_names = ['joint_1', 'joint_2", "CodeBleu_score": 31.568507690590703}, {"code": "def joints_cmd_callback(self, joints){\n\t    joints_msg = Joints()\n    joints_msg.position = joints.position[0:12]\n    self.joints_pub.publish(joints_msg)\n\n    joint_traj_msg = JointTrajectory()\n    joint_traj_msg.joint_names = joints.name\n    joint_traj_msg.points.append(JointTrajectoryPoint(positions=joints.position[0:12], time_from_start=rospy.Duration(0.5)))\n    self.joint_traj_pub.publish(joint_traj_msg)\n}", "CodeBleu_score": 36.263772702620614}, {"code": "def joints_cmd_callback(self, joints){\n\t  joint_state = JointState()\n  joint_state.name = [\"joint1\", \"joint2\", \"joint3\", \"joint4\", \"joint5\", \"joint6\", \"joint7\", \"joint8\", \"joint9\", \"joint10\", \"joint11\", \"joint12\"]\n  joint_state.position = joints.positions\n  self.joint_state_pub.publish(joint_state)\n\n  joint_trajectory = JointTrajectory()\n  joint_trajectory.joint_names = [\"joint1\", \"joint2\", \"joint3\", \"joint4\", \"joint5\", \"joint6\", \"joint7\", \"joint8\", \"joint9\", \"joint10\", \"joint11\", \"joint12\"]\n  joint_trajectory.points = [JointTrajectoryPoint(positions=joints.positions, time_from_start=rospy.Duration(1.0))]\n  self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 38.8573950087904}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  std::vector<std::string> foot_names;\n  foot_names.push_back(\"left_sole\");\n  foot_names.push_back(\"right_sole\");\n\n  for (int i = 0; i < foot_names.size(); i++) {\n    foot_contact_states_[i] = false;\n  }\n\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::string collision = _msg->contact(i).collision1();\n    boost::algorithm::to_lower(collision);\n\n    for (int j = 0; j < foot_names.size(); j++) {\n      if (collision.find(foot_names[j]) != std::string::npos) {\n        foot_contact_states_[j] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 56.67070858544482}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    ROS_DEBUG(\"Gazebo contact callback\");\n    champ::utils::URDFLoader urdf_loader;\n    std::vector<std::string> foot_links = urdf_loader.getFootLinks();\n\n    for (int i = 0; i < foot_links.size(); i++) {\n        foot_contacts_[i] = false;\n    }\n\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        std::string collision1 = _msg->contact(i).collision1();\n        std::string collision2 = _msg->contact(i).collision2();\n        std::string foot_link;\n\n        if (collision1.find(\"_link\") != std::string::npos) {\n            foot_link = collision1;\n        } else if (collision2.find(\"_link\") != std::string::npos) {\n            foot_link = collision2;\n        } else {\n            continue;\n        }\n\n        boost::algorithm::to_lower(foot_link);\n\n        for (int i = 0; i < foot_links.size(); i++) {\n            if (foot_link.find(foot_links[i]) != std::string::npos) {\n                foot_contacts_[i] = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 50.08459857788472}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\n  // Initialize foot contact states to false\n  foot_contact_states_[0] = false;\n  foot_contact_states_[1] = false;\n\n  // For each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n\n    // Get the collision string\n    std::string collision = _msg->contact(i).collision1();\n\n    // Split the collision string to identify the contact link\n    std::vector<std::string> collision_split;\n    boost::split(collision_split, collision, boost::is_any_of(\"::\"));\n\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true\n    if (collision_split[0] == \"link_left_foot\" || collision_split[0] == \"link_right_foot\") {\n      if (collision_split[0] == \"link_left_foot\") {\n        foot_contact_states_[0] = true;\n      } else {\n        foot_contact_states_[1] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 43.78862232792542}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  rotor_velocities->resize(num_rotors_);\n  if (!active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Calculate desired acceleration and angular acceleration.\n  Eigen::Vector3d acceleration_desired =\n      (position_command_ - position_) / dt_ - velocity_;\n  Eigen::Vector3d angular_acceleration_desired =\n      orientation_.inverse() * (angular_velocity_command_ - angular_velocity_);\n\n  // Project thrust onto the body z-axis.\n  double thrust_desired =\n      acceleration_desired.dot(orientation_.linear() * z_axis_);\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d acceleration_angular_desired =\n      angular_acceleration_desired - orientation_.linear() * z_axis_ * thrust_desired;\n\n  // Calculate rotor velocities.\n  *rotor_velocities = rotor_velocities_matrix_ *\n                      Eigen::Vector4d(acceleration_desired.x(),\n                                      acceleration_desired.y(),\n                                      acceleration_angular_desired.x(),\n                                      acceleration_angular_desired.y());\n\n  // Ensure non-negative values.\n  for (int i = 0; i < num_rotors_; ++i) {\n    (*rotor_velocities)(i) = std::max((*rotor_velocities)(i), 0.0);\n  }\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 47.51432975834769}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == kNumRotors_);\n\n  // If the controller is not active, set all rotor velocities to zero.\n  if (!controller_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Calculate the desired acceleration and angular acceleration.\n  Eigen::Vector3d desired_acceleration = desired_acceleration_;\n  Eigen::Vector3d angular_acceleration = angular_acceleration_;\n\n  // Project thrust onto the body z-axis and combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d thrust_vector = Eigen::Vector3d::UnitZ() * thrust_;\n  Eigen::Vector3d acceleration = desired_acceleration + thrust_vector + angular_acceleration;\n\n  // Compute the rotor velocities by multiplying with a predefined matrix, ensuring non-negative values, and taking the square root of each component.\n  *rotor_velocities = rotor_velocity_matrix_.cwiseProduct(acceleration).cwiseMax(0.0).cwiseSqrt();\n}", "CodeBleu_score": 35.33569807302639}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  CHECK_NOTNULL(rotor_velocities);\n  CHECK_EQ(rotor_velocities->size(), kNumRotors);\n\n  // Check if controller is active.\n  if (!controller_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Compute desired acceleration and angular acceleration.\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_angular_acceleration;\n  ComputeDesiredAcceleration(&desired_acceleration, &desired_angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust_body;\n  thrust_body = desired_acceleration;\n  thrust_body(2) += desired_angular_acceleration.dot(position_gps_);\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d angular_acceleration_thrust;\n  angular_acceleration_thrust = desired_angular_acceleration;\n  angular_acceleration_thrust(2) = thrust_body(2);\n\n  // Compute rotor velocities.\n  *rotor_velocities = rotor_velocity_matrix_ * angular_acceleration_thrust;\n  rotor_velocities->array() = rotor_velocities->array().max(0.0);\n  rotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 46.682842856283735}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // Get current position and velocity\n  const Eigen::Vector3d position = odometry_.position;\n  const Eigen::Vector3d velocity = odometry_.velocity;\n\n  // Get the commanded position and velocity\n  const Eigen::Vector3d position_cmd = trajectory_.position;\n  const Eigen::Vector3d velocity_cmd = trajectory_.velocity;\n\n  // Transform the velocity to the world frame\n  const Eigen::Vector3d velocity_world = odometry_.orientation.conjugate() * velocity;\n\n  // Compute the position and velocity errors\n  const Eigen::Vector3d position_error = position_cmd - position;\n  const Eigen::Vector3d velocity_error = velocity_cmd - velocity_world;\n\n  // Compute the desired acceleration\n  *acceleration = position_gains_ * position_error + velocity_gains_ * velocity_error + acceleration_cmd_;\n\n  // Adjust for vehicle mass, gravity, and commanded acceleration\n  *acceleration -= mass_ * gravity_ + acceleration_cmd_;\n}", "CodeBleu_score": 50.327733759535434}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // Get the current odometry.\n  const Eigen::Vector3d position = odometry_->GetPosition();\n  const Eigen::Quaterniond orientation = odometry_->GetOrientation();\n  const Eigen::Vector3d linear_velocity = odometry_->GetLinearVelocity();\n  const Eigen::Vector3d angular_velocity = odometry_->GetAngularVelocity();\n\n  // Transform the velocity to the world frame.\n  const Eigen::Vector3d velocity = orientation * linear_velocity;\n\n  // Compute the position and velocity errors.\n  const Eigen::Vector3d position_error = position - trajectory_->GetCurrentPosition();\n  const Eigen::Vector3d velocity_error = velocity - trajectory_->GetCurrentVelocity();\n\n  // Compute the desired acceleration.\n  const Eigen::Vector3d acceleration_position = position_gains_.cwiseProduct(position_error);\n  const Eigen::Vector3d acceleration_velocity = velocity_gains_.cwiseProduct(velocity_error);\n  const Eigen::Vector3d acceleration_total = acceleration_position + acceleration_velocity;\n  const Eigen::Vector3d acceleration_gravity = -mass_ * gravity_;\n  const Eigen::Vector3d acceleration_commanded = acceleration_total + acceleration_gravity + acceleration_command_;\n\n  // Apply the acceleration limits.\n  const Eigen::Vector3d acceleration_clamped = acceleration_commanded.cwiseMin(acceleration_limits_.cwiseMax(-acceleration_limits_));\n\n  // Set the desired acceleration.\n  *acceleration = acceleration_clamped;\n}", "CodeBleu_score": 41.811802980545274}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // Calculate position error\n  const Eigen::Vector3d position_error = trajectory_.ComputePositionError(vehicle_state_.position);\n  const double yaw_error = trajectory_.ComputeHeadingError(vehicle_state_.yaw);\n\n  // Calculate velocity error\n  const Eigen::Vector3d velocity_error = vehicle_state_.velocity - trajectory_.ComputeVelocity(vehicle_state_.position);\n\n  // Transform velocity error to world frame\n  const Eigen::Vector3d velocity_error_world =\n      Eigen::Quaterniond(vehicle_state_.orientation).toRotationMatrix() * velocity_error;\n\n  // Calculate desired acceleration\n  *acceleration =\n      position_gains_ * position_error + velocity_gains_ * velocity_error_world +\n      Eigen::Vector3d(0.0, 0.0, -gravity_ + trajectory_.ComputeAcceleration(vehicle_state_.position));\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n  *acceleration += feedforward_acceleration_;\n\n  // Add feedforward acceleration\n ", "CodeBleu_score": 39.34480869547079}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  // Check if the input is valid.\n  if (rotor_velocities == nullptr) {\n    std::cout << \"The rotor velocities pointer is null\" << std::endl;\n    return;\n  }\n\n  // Resize the rotor velocities vector to match the number of rotors.\n  rotor_velocities->resize(num_rotors_);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration =\n      -kp_ * (euler_angles_ - euler_angles_ref_) - kd_ * angular_velocity_ref_;\n\n  // Combine the desired angular acceleration with the thrust reference to create the desired acceleration.\n  Eigen::Vector3d desired_acceleration =\n      thrust_ref_ * Eigen::Vector3d::UnitZ() + angular_acceleration;\n\n  // Calculate the rotor velocities by multiplying with a predefined matrix.\n  Eigen::Matrix3d rotor_velocities_matrix =\n      rotor_velocities_matrix_ * desired_acceleration;\n\n  // Ensure the rotor velocities are at least one.\n  rotor_velocities_matrix = rotor_velocities_matrix.cwiseMax(1.0);\n\n  // Take the square root of each component to get the rotor velocities.\n  *rotor_velocities = rotor_velocities_matrix.cwiseSqrt();\n}", "CodeBleu_score": 45.532972064180555}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  // Check if the input is valid.\n  if (!rotor_velocities) {\n    std::cout << \"Input to CalculateRotorVelocities is null\" << std::endl;\n    return;\n  }\n\n  // Check if the number of rotors is valid.\n  if (rotor_velocities->size() != num_rotors_) {\n    std::cout << \"Input to CalculateRotorVelocities does not match number of rotors\" << std::endl;\n    return;\n  }\n\n  // Check if the thrust reference is valid.\n  if (thrust_reference_ <= 0.0) {\n    std::cout << \"Thrust reference is not positive\" << std::endl;\n    return;\n  }\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration_desired =\n      angular_acceleration_desired_ +\n      angular_acceleration_feedforward_;\n\n  // Combine the thrust reference with the desired angular acceleration.\n  Eigen::Vector4d thrust_and_angular_acceleration_desired;\n  thrust_and_angular_acceleration_desired << thrust_reference_,\n      angular_acceleration_desired;\n\n  // Calculate the rotor velocities.\n  *rotor_velocities = rotor_velocity_matrix_ * thrust_and_angular_acceleration_desired;\n\n  // Ensure the rotor velocities are at least one.\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    if ((*rotor_velocities)[i] < 1.0) {\n      (*rotor_velocities)[i] = 1.0;\n    }\n  }\n\n  // Take the square root of each component.\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    (*rotor_velocities)[i] = sqrt((*rotor_velocities)[i]);\n  }\n}", "CodeBleu_score": 44.484715840775124}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n  // Check if the input is valid.\n  if (rotor_velocities == nullptr) {\n    std::cout << \"Input to CalculateRotorVelocities is nullptr\" << std::endl;\n    return;\n  }\n\n  // Check if the parameters are valid.\n  if (params_ == nullptr) {\n    std::cout << \"Params_ is nullptr\" << std::endl;\n    return;\n  }\n\n  // Resize the rotor velocities vector to match the number of rotors.\n  rotor_velocities->resize(params_->rotors.size());\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration_desired =\n      params_->angular_acceleration_gain * (params_->angular_acceleration_reference - angular_acceleration_estimated_);\n\n  // Combine the desired angular acceleration with the thrust reference into a single vector.\n  Eigen::Vector4d angular_acceleration_thrust_reference;\n  angular_acceleration_thrust_reference << angular_acceleration_desired, thrust_reference_;\n\n  // Compute the rotor velocities by multiplying with a predefined matrix, ensuring they are at least one, and taking the square root of each component.\n  *rotor_velocities =\n      (params_->rotor_velocity_matrix * angular_acceleration_thrust_reference).cwiseMax(1.0).cwiseSqrt();\n}", "CodeBleu_score": 41.41261059397221}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n    copy_object = copy.deepcopy(self)\n    copy_object.time = copy_object.time[start_index:end_index]\n    copy_object.x = copy_object.x[start_index:end_index]\n    copy_object.y = copy_object.y[start_index:end_index]\n    copy_object.z = copy_object.z[start_index:end_index]\n    copy_object.vx = copy_object.vx[start_index:end_index]\n    copy_object.vy = copy_object.vy[start_index:end_index]\n    copy_object.vz = copy_object.vz[start_index:end_index]\n    copy_object.ax = copy_object.ax[start_index:end_index]\n    copy_object.ay = copy_object.ay[start_index:end_index]\n    copy_object.az = copy_object.az[start_index:end_index]\n    return copy_object\n\n", "CodeBleu_score": 16.349902134750273}, {"code": "def slice(self, start_time, end_time)\n\t\n    # find the corresponding indices for the start and end times\n    start_index = self.timestamps.index(start_time)\n    end_index = self.timestamps.index(end_time)\n\n    # make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # update each attribute of the copied object to contain only the sliced data\n    sliced_object.timestamps = sliced_object.timestamps[start_index:end_index]\n    sliced_object.poses = sliced_object.poses[start_index:end_index]\n    sliced_object.twists = sliced_object.twists[start_index:end_index]\n    sliced_object.accelerations = sliced_object.accelerations[start_index:end_index]\n    sliced_object.jerks = sliced_object.jerks[start_index:end_index]\n\n    return sliced_object\n\n", "CodeBleu_score": 18.483549002611145}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n\n    sliced_object = copy.deepcopy(self)\n\n    for key, value in sliced_object.__dict__.items():\n        if key == \"time\":\n            sliced_object.__dict__[key] = value[start_index:end_index]\n        elif key == \"data\":\n            sliced_object.__dict__[key] = value[start_index:end_index]\n        else:\n            sliced_object.__dict__[key] = value\n\n    return sliced_object\n\n", "CodeBleu_score": 31.51229624994501}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion(\n        [rotation.x, rotation.y, rotation.z, rotation.w]\n    )\n\n    # Create a Point object from the position\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if (\n        self.last_waypoint_position is not None\n        and self.last_waypoint_yaw is not None\n        and self.last_waypoint_position != point\n        and self.last_waypoint_yaw != euler[2]\n    ):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints_x.append(point.x)\n        self.waypoints_y.append(point.y)\n        self.waypoints_z.append(point.z)\n        self.waypoints_yaw.append(euler[2])\n        self.waypoints_time.append(bag_time)\n        self.last_waypoint_position = copy.deepcopy(point)\n        self.last_waypoint_yaw = copy.deepcopy(euler[2])\n\n", "CodeBleu_score": 32.07644225232576}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    pos = waypoint_msg.pose.position\n    rot = waypoint_msg.pose.orientation\n    quat = (rot.x, rot.y, rot.z, rot.w)\n    euler = tf.transformations.euler_from_quaternion(quat)\n    yaw = euler[2]\n    point = Point(pos.x, pos.y, pos.z)\n\n    if self.last_waypoint is None or (\n        self.last_waypoint.position.x != pos.x\n        or self.last_waypoint.position.y != pos.y\n        or self.last_waypoint.position.z != pos.z\n        or self.last_waypoint.orientation.yaw != yaw\n    ):\n        self.waypoints.append(point)\n        self.yaw.append(yaw)\n        self.time.append(msg_time)\n        self.bag_time.append(bag_time)\n        self.last_waypoint = copy.deepcopy(waypoint_msg)\n\n", "CodeBleu_score": 29.18564041452901}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert rotation to Euler angles\n    (_, _, yaw) = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object with the extracted position\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if self.waypoints and self.waypoints[-1].position == point and math.isclose(self.yaws[-1], yaw, rel_tol=1e-3):\n        return\n\n    # Append the new point, yaw, and corresponding times to their respective arrays\n    self.waypoints.append(point)\n    self.yaws.append(yaw)\n    self.times.append(msg_time)\n    self.bag_times.append(bag_time)\n\n", "CodeBleu_score": 24.44206023185982}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.time.append(msg.header.stamp.to_sec())\n        self.bag_time.append(bag_time)\n\n", "CodeBleu_score": 30.95095452456637}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic:\n        self.time.append(msg.header.stamp.to_sec())\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.bag_time = bag_time\n\n", "CodeBleu_score": 32.264786246514085}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu0':\n        self.x.append(msg.linear_acceleration.x)\n        self.y.append(msg.linear_acceleration.y)\n        self.z.append(msg.linear_acceleration.z)\n        self.time.append(msg.header.stamp.secs + msg.header.stamp.nsecs / 1000000000.0)\n        self.bag_time.append(bag_time)\n\n", "CodeBleu_score": 30.625297767981895}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n\n    # Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration Data\")\n    ax = fig.add_subplot(111)\n\n    # Plot the x, y, and z components over time with different colors and labels\n    ax.plot(self.accelerations[\"x\"], color=\"red\", label=\"x\")\n    ax.plot(self.accelerations[\"y\"], color=\"green\", label=\"y\")\n    ax.plot(self.accelerations[\"z\"], color=\"blue\", label=\"z\")\n\n    # Add labels for the x and y axes and include a legend\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = \"accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n        fig.savefig(filename)\n\n", "CodeBleu_score": 35.084627414013916}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.plot_accelerations:\n        # Create a figure with a title\n        pyplot.figure(figsize=(10, 5))\n        pyplot.title(\"Acceleration Data\")\n\n        # Create a subplot for accelerations\n        ax = pyplot.subplot(111)\n\n        # Plot the x, y, and z components of each acceleration dataset\n        for i, accel_data in enumerate(self.accelerations):\n            ax.plot(accel_data[\"time\"], accel_data[\"x\"], label=\"x\" + str(i + 1))\n            ax.plot(accel_data[\"time\"], accel_data[\"y\"], label=\"y\" + str(i + 1))\n            ax.plot(accel_data[\"time\"], accel_data[\"z\"], label=\"z\" + str(i + 1))\n\n        # Add labels for the x and y axes\n        ax.set_xlabel(\"Time (s)\")\n        ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n        # Include a legend\n        ax.legend()\n\n        # Save the plot if enabled\n        if self.save_plots:\n            filename = \"accelerations\"\n            if plot_suffix is not None:\n                filename += \"_\" + plot_suffix\n            pyplot.savefig(filename + \".png\")\n\n        # Show the plot\n        pyplot.show()\n\n", "CodeBleu_score": 35.02255731234125}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n\n    # Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure(figsize=(12, 8))\n    ax = fig.add_subplot(1, 1, 1)\n\n    # Plot the x, y, and z components over time with different colors and labels\n    ax.plot(self.acceleration_x, color=\"blue\", label=\"X Acceleration\")\n    ax.plot(self.acceleration_y, color=\"green\", label=\"Y Acceleration\")\n    ax.plot(self.acceleration_z, color=\"red\", label=\"Z Acceleration\")\n\n    # Add labels for the x and y axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n    # Include a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = f\"{self.plot_prefix}_accelerations\"\n        if plot_suffix:\n            filename += f\"_{plot_suffix}\"\n        filename += \".png\"\n        fig.savefig(filename)\n\n", "CodeBleu_score": 32.70009927753293}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 24.708386770158015}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(0, len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(self, pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 20.644879311145225}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"You need to specify at least two pose indices to compare them.\")\n        return\n    else:\n        for i in range(len(pose_indeces)):\n            for j in range(i + 1, len(pose_indeces)):\n                compare_two_xyz(self, pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 27.74209916729331}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time and end_time:\n            if start_time <= collision.header.stamp.to_sec() <= end_time:\n                collision_times.append(collision.header.stamp.to_sec())\n        else:\n            collision_times.append(collision.header.stamp.to_sec())\n    return collision_times\n\n", "CodeBleu_score": 42.894615170527416}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is None or end_time is None:\n            if collision.header.stamp.secs >= start_time and collision.header.stamp.secs <= end_time:\n                collision_times.append(collision.header.stamp.secs)\n        else:\n            if collision.header.stamp.secs >= start_time and collision.header.stamp.secs <= end_time:\n                collision_times.append(collision.header.stamp.secs)\n    return collision_times\n\n", "CodeBleu_score": 41.36750378177264}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision_time in self.wrench:\n        if start_time is not None and collision_time < start_time:\n            continue\n        if end_time is not None and collision_time > end_time:\n            continue\n        collision_times.append(collision_time)\n    return collision_times\n\n", "CodeBleu_score": 39.426292227103005}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 35.617081494174855}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n\n    # Calculate the absolute settling time\n    settling_time = start_time + settling_time\n\n    # Plot the angular velocities\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 35.617081494174855}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    # Calculate the absolute settling time\n    absolute_settling_time = start_time + settling_time\n\n    # Call the analyze_bag function to plot the angular velocities\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 32.10207328495848}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    std::cerr << \"Depth noise model data is null.\" << std::endl;\n    return;\n  }\n\n  float fx = this->camera_info_.K[0];\n  float fy = this->camera_info_.K[4];\n  float cx = this->camera_info_.K[2];\n  float cy = this->camera_info_.K[5];\n\n  Eigen::VectorXf depth_map(width * height);\n  for (uint32_t i = 0; i < width * height; i++) {\n    depth_map(i) = data[i];\n  }\n\n  float rms_noise = this->rms_noise_ * 0.001f;\n  float noise_values[width * height];\n  for (uint32_t i = 0; i < width * height; i++) {\n    noise_values[i] = rms_noise * randn(0, 1);\n  }\n\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (depth_map(i) > 0.0f && depth_map(i) < this->max_depth_) {\n      float x = (i % width - cx) / fx;\n      float y = (i / width - cy) / fy;\n      float z = depth_map(i);\n      float x_noise = x * noise_values[i];\n      float y_noise = y * noise_values[i];\n      float z_noise = z * noise_values[i];\n      float x_noise_map = x + x_noise;\n      float y_noise_map = y + y_noise;\n      float z_noise_map = z + z_noise;\n      float x_map = x_noise_map * fx + cx;\n      float y_map = y_noise_map * fy + cy;\n      float z_map = z_noise_map;\n      float x_map_round = round(x_map);\n      float y_map_round", "CodeBleu_score": 45.01076935773831}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n  Eigen::Map<Eigen::VectorXf> depth_vec(data, width * height);\n\n  double multiplier =\n      (fx_ * 0.5) / (double)depth_vec(0) +\n      (cx_ - (double)width * 0.5) / (double)depth_vec(0);\n  double rms_noise = rms_noise_ * multiplier;\n  double noise_val = 0.0;\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (depth_vec(i) != 0.0) {\n      noise_val = rms_noise * sqrt(-2.0 * log(drand48()));\n      depth_vec(i) += noise_val;\n    } else {\n      depth_vec(i) = bad_point_;\n    }\n  }\n}", "CodeBleu_score": 47.841098059119155}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  // Convert data to Eigen vector\n  Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic,\n                           Eigen::RowMajor>>\n      depth_data(data, width, height);\n\n  // Calculate noise multiplier\n  float noise_multiplier =\n      sqrtf(k_ * static_cast<float>(width) * static_cast<float>(height));\n\n  // Compute RMS noise\n  float rms_noise = noise_multiplier * sqrtf(k_ * static_cast<float>(width) *\n                                             static_cast<float>(height));\n\n  // Compute noise values\n  Eigen::VectorXf noise_values =\n      Eigen::VectorXf::NullaryExpr(width * height, [&]() {\n        return noise_multiplier *\n               static_cast<float>(rand_generator_.Get());\n      });\n\n  // Apply noise to data\n  for (int i = 0; i < width * height; i++) {\n    if (depth_data(i) > kMinDepth && depth_data(i) < kMaxDepth) {\n      depth_data(i) += noise_values(i);\n    } else {\n      depth_data(i) = kBadPoint;\n    }\n  }\n}", "CodeBleu_score": 45.576515030582776}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time ros_time = ros::Time::now();\n  ros::Time sim_time = model_->GetWorld()->SimTime();\n  ros::Duration time_diff = sim_time - ros_time;\n\n  // Write the trajectory message to the bag file.\n  bag_.write(namespace_ + \"/waypoints\", ros::Time::now() + time_diff,\n             *trajectory_msg);\n}", "CodeBleu_score": 47.00600937294554}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time ros_time = ros::Time::now();\n  ros::Duration sim_time = model_->GetWorld()->GetSimTime();\n  ros::Time ros_sim_time(sim_time.sec, sim_time.nsec);\n  ros::Duration time_diff = ros_sim_time - ros_time;\n  ros::Time ros_sim_time_adjusted = ros_sim_time - time_diff;\n\n  trajectory_bag_.write(namespace_ + \"/waypoint\", ros_sim_time_adjusted,\n                        *trajectory_msg);\n}", "CodeBleu_score": 44.26679005787143}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time ros_time = ros::Time::now();\n  ros::Time sim_time = this->world_->GetSimTime();\n  ros::Duration sim_time_offset = sim_time - ros_time;\n\n  trajectory_msgs::MultiDOFJointTrajectory trajectory_msg_ros =\n      *trajectory_msg;\n  trajectory_msg_ros.header.stamp = ros_time;\n\n  this->bag_writer_.write(this->namespace_ + \"/waypoint\", trajectory_msg_ros);\n}", "CodeBleu_score": 45.38838914395591}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  ros::Time ros_time = ros::Time::now();\n  mav_msgs::ActuatorsPtr actuators_msg(new mav_msgs::Actuators);\n  actuators_msg->header.stamp = ros_time;\n  for (int i = 0; i < motor_joints_.size(); i++) {\n    double motor_velocity = motor_joints_[i]->GetVelocity(0);\n    actuators_msg->angular_velocities[i] = motor_velocity * motor_slowdown_;\n  }\n  motor_publisher_.publish(actuators_msg);\n}", "CodeBleu_score": 38.35267911795436}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time ros_time = ros::Time::now();\n\n  // Prepare message\n  mav_msgs::Actuators msg;\n  msg.header.stamp = ros_time;\n\n  // Iterate through all motor joints\n  for (unsigned int i = 0; i < motor_joints_.size(); i++) {\n    // Calculate slowed-down rotational velocity\n    double velocity = motor_joints_[i]->GetVelocity(0);\n    velocity *= motor_velocity_slowdown_;\n\n    // Assign rotational velocity to message\n    msg.angular_velocities[i] = velocity;\n  }\n\n  // Set message timestamp and write to bag file\n  msg.header.stamp = ros_time;\n  bag_.write(namespace_ + motor_topic_, ros::Time::now(), msg);\n}", "CodeBleu_score": 42.8279082491295}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  ros::Time ros_time = ros::Time::now();\n\n  // Prepare message.\n  mav_msgs::ActuatorsPtr msg(new mav_msgs::Actuators());\n  msg->angular_velocities.resize(motor_joints_.size());\n  msg->header.stamp = ros_time;\n\n  // Iterate through all motor joints.\n  for (unsigned int i = 0; i < motor_joints_.size(); ++i) {\n    // Calculate slowed-down rotational velocity.\n    double motor_velocity = motor_joints_[i]->GetVelocity(0);\n    double motor_velocity_slowed = motor_velocity * slowdown_factor_;\n\n    // Assign slowed-down rotational velocity to message.\n    msg->angular_velocities[i] = motor_velocity_slowed;\n  }\n\n  // Set message timestamp and write to bag file.\n  msg->header.stamp = ros_time;\n  bag_writer_.write(motor_topic_, ros_time, msg);\n}", "CodeBleu_score": 49.56059096939585}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    ROS_INFO_STREAM(\"RollPitchYawrateThrustCallback called\");\n  }\n\n  // Convert normalized roll, pitch, and yaw rate to control surface angles\n  // for ailerons, elevator, and rudder respectively.\n  double aileron_angle =\n      roll_pitch_yawrate_thrust_msg->roll() * max_aileron_angle_;\n  double elevator_angle =\n      roll_pitch_yawrate_thrust_msg->pitch() * max_elevator_angle_;\n  double rudder_angle =\n      roll_pitch_yawrate_thrust_msg->yaw_rate() * max_rudder_angle_;\n\n  // Set the throttle value from the thrust message.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Apply the control surface angles and throttle value to the vehicle.\n  vehicle_->SetControlSurfaceAngles(aileron_angle, elevator_angle, rudder_angle);\n  vehicle_->SetThrottle(throttle);\n}", "CodeBleu_score": 42.26250378261548}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    ROS_INFO_STREAM(\n        \"RollPitchYawrateThrustCallback called with roll: \"\n        << roll_pitch_yawrate_thrust_msg->roll()\n        << \", pitch: \" << roll_pitch_yawrate_thrust_msg->pitch()\n        << \", yaw_rate: \" << roll_pitch_yawrate_thrust_msg->yaw_rate()\n        << \", thrust: \" << roll_pitch_yawrate_thrust_msg->thrust());\n  }\n\n  // Convert normalized roll, pitch, and yaw rate to control surface angles\n  double aileron_angle =\n      -roll_pitch_yawrate_thrust_msg->roll() * max_aileron_angle_;\n  double elevator_angle =\n      roll_pitch_yawrate_thrust_msg->pitch() * max_elevator_angle_;\n  double rudder_angle =\n      -roll_pitch_yawrate_thrust_msg->yaw_rate() * max_rudder_angle_;\n\n  // Set the control surface angles\n  SetControlSurfaceAngles(aileron_angle, elevator_angle, rudder_angle);\n\n  // Set the throttle value\n  SetThrottle(roll_pitch_yawrate_thrust_msg->thrust());\n}", "CodeBleu_score": 43.071965699516326}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // Convert normalized values to control surface angles\n  double aileron_angle = roll_pitch_yawrate_thrust_msg->roll() *\n                         aileron_control_saturation_ *\n                         aileron_control_saturation_;\n  double elevator_angle = -roll_pitch_yawrate_thrust_msg->pitch() *\n                          elevator_control_saturation_ *\n                          elevator_control_saturation_;\n  double rudder_angle = roll_pitch_yawrate_thrust_msg->yaw_rate() *\n                        rudder_control_saturation_ * rudder_control_saturation_;\n\n  // Set control surface angles\n  SetControlSurfaceAngles(aileron_angle, elevator_angle, rudder_angle);\n\n  // Set throttle value\n  SetThrottle(roll_pitch_yawrate_thrust_msg->thrust());\n}", "CodeBleu_score": 41.72198563185836}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Convert timeout to timeval\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for data\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(serialPort_->getFileDescriptor(), &readfds);\n\n  int retval = select(\n      serialPort_->getFileDescriptor() + 1, &readfds, NULL, NULL, &timeout);\n\n  if (retval == -1) {\n    ROS_ERROR_NAMED(\"mavlink_interface\", \"Error in select(): %s\",\n                    strerror(errno));\n    return;\n  } else if (retval == 0) {\n    // ROS_DEBUG_NAMED(\"mavlink_interface\", \"No data available.\");\n    return;\n  }\n\n  // Check if data is available\n  if (FD_ISSET(serialPort_->getFileDescriptor(), &readfds)) {\n    // Read data from serial port\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    int bytesRead = serialPort_->read(buffer, MAVLINK_MAX_PACKET_LEN);\n\n    if (bytesRead <= 0) {\n      ROS_ERROR_NAMED(\"mavlink_interface\",\n                      \"Error reading from serial port: %s\", strerror(errno));\n      return;\n    }\n\n    // Parse MAVLink messages from buffer\n    mavlink_message_t msg;\n    mavlink_status_t status;\n    for (int i = 0; i < bytesRead; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n        // Handle message\n        handleMAVLinkMessage(msg);\n      }\n    }\n  }\n}", "CodeBleu_score": 50.931998215315865}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t\n  // Timeout for the poll operation\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for data\n  int ret = select(m_fd, &m_fd_set, NULL, NULL, &tv);\n\n  // If data is available, read it and parse MAVLink messages\n  if (ret > 0) {\n    // Read data from the serial port\n    int bytes_read = read(m_fd, m_buffer, BUFFER_SIZE);\n\n    // Parse the MAVLink messages\n    mavlink_message_t msg;\n    mavlink_status_t status;\n    for (int i = 0; i < bytes_read; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, m_buffer[i], &msg, &status)) {\n        // Handle the parsed message\n        handleMAVLinkMessage(msg);\n      }\n    }\n  }\n}", "CodeBleu_score": 49.91994811054063}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // TODO: add timeout\n  // TODO: add error handling\n\n  // Convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for data\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(serial_fd, &readfds);\n\n  int ret = select(serial_fd + 1, &readfds, NULL, NULL, &timeout);\n\n  if (ret == -1) {\n    ROS_ERROR(\"Error polling for data\");\n    return;\n  } else if (ret == 0) {\n    // Timeout occurred\n    return;\n  }\n\n  // Data is available, so receive it\n  uint8_t buffer[255];\n  int bytes_read = read(serial_fd, buffer, sizeof(buffer));\n\n  if (bytes_read == -1) {\n    ROS_ERROR(\"Error reading data\");\n    return;\n  }\n\n  // Parse MAVLink messages from the buffer\n  mavlink_message_t msg;\n  mavlink_status_t status;\n  for (int i = 0; i < bytes_read; i++) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n      // Message successfully parsed\n      handleMAVLinkMessage(msg);\n    }\n  }\n}", "CodeBleu_score": 54.713315634853096}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t    boost::mutex::scoped_lock lock(mutex_);\n    if (open_) {\n        io_service_.stop();\n        serial_port_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n        open_ = false;\n    }\n}", "CodeBleu_score": 57.98696151649615}, {"code": "void GazeboMavlinkInterface::close() {\n\t    std::lock_guard<std::mutex> lock(mutex_);\n    if (open_) {\n        io_service_.stop();\n        serial_port_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n        open_ = false;\n    }\n}", "CodeBleu_score": 58.47522209344294}, {"code": "void GazeboMavlinkInterface::close() {\n\t    if (this->is_open) {\n        this->io_service.stop();\n        this->serial_device.close();\n        if (this->io_thread.joinable()) {\n            this->io_thread.join();\n        }\n        this->is_open = false;\n    }\n}", "CodeBleu_score": 30.6558549150158}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d(double x1, double y1, double x2, double y2, double x) {\n    return ignition::math::Vector3d(x1 + (x - x1) * (y2 - y1) / (x2 - x1), 0, 0);\n  }\n}", "CodeBleu_score": 35.05173419412008}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d(const ignition::math::Vector3d &p1,\n                           const ignition::math::Vector3d &p2,\n                           const ignition::math::Vector3d &v1,\n                           const ignition::math::Vector3d &v2,\n                           double position) {\n    ignition::math::Vector3d p = p1 + (p2 - p1) * position;\n    ignition::math::Vector3d v = v1 + (v2 - v1) * position;\n    return p + v;\n  }\n", "CodeBleu_score": 32.770275302388704}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d(const ignition::math::Vector3d &point1, const ignition::math::Vector3d &point2, const double &position) {\n    return point1 + (point2 - point1) * position;\n  }\n}", "CodeBleu_score": 35.66354856785491}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t    if (_time == this->time) {\n        return;\n    }\n\n    double oldTime = this->time;\n    this->time = _time;\n\n    if (this->looping) {\n        this->time = std::fmod(this->time, this->length);\n        if (this->time < 0.0) {\n            this->time += this->length;\n        }\n    } else {\n        this->time = ignition::math::clamp(this->time, 0.0, this->length);\n    }\n\n    if (this->time != oldTime) {\n        this->Update();\n    }\n}", "CodeBleu_score": 59.57344364547457}, {"code": "void Animation::SetTime(double _time){\n\t  // If the new time is different from the current time, update the time position.\n  if (_time != this->time) {\n    this->time = _time;\n\n    // If looping is enabled, wrap the time within the animation length.\n    if (this->loop) {\n      this->time = fmod(this->time, this->length);\n    }\n    // If looping is disabled, clamp the time between 0 and the animation length.\n    else {\n      this->time = ignition::math::clamp(this->time, 0.0, this->length);\n    }\n  }\n}", "CodeBleu_score": 51.13987331817118}, {"code": "void Animation::SetTime(double _time){\n\t\n  // Check if the time is different from the current time\n  if (_time != this->time) {\n\n    // Check if the animation is looping\n    if (this->loop) {\n\n      // Wrap the time within the animation length\n      this->time = fmod(_time, this->length);\n    }\n    else {\n\n      // Clamp the time between 0 and the animation length\n      this->time = ignition::math::clamp(_time, 0.0, this->length);\n    }\n\n    // Update the animation time position\n    this->UpdateTime();\n  }\n}", "CodeBleu_score": 44.97757036663136}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    # Set the coordinate frame of the position and velocity to 1\n    self.pos_msg.coordinate_frame = 1\n    self.pos_msg.type_mask = 0\n\n    # Set the position and yaw of the quadcopter\n    self.pos_msg.position.x = 0\n    self.pos_msg.position.y = 0\n    self.pos_msg.position.z = 2\n    self.pos_msg.yaw = 0\n\n    # Publish the position and yaw\n    self.pos_pub.publish(self.pos_msg)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + self.vehicle_id)\n    print(\"Flight mode: \" + self.flight_mode)\n\n", "CodeBleu_score": 27.459784162491307}, {"code": "def hover(self)\n\t\n    self.set_mode_client(base_mode=0, custom_mode=\"GUIDED\")\n    self.set_arm_client(True)\n\n    self.target_pose = PoseStamped()\n    self.target_pose.pose = Pose()\n    self.target_pose.pose.position.x = 0\n    self.target_pose.pose.position.y = 0\n    self.target_pose.pose.position.z = 2\n    self.target_pose.pose.orientation.x = 0\n    self.target_pose.pose.orientation.y = 0\n    self.target_pose.pose.orientation.z = 0\n    self.target_pose.pose.orientation.w = 1\n\n    self.target_pose.header.stamp = rospy.Time.now()\n    self.target_pose.header.frame_id = \"map\"\n\n    self.current_pose = PoseStamped()\n    self.current_pose.pose = Pose()\n\n    self.current_pose.header.stamp = rospy.Time.now()\n    self.current_pose.header.frame_id = \"map\"\n\n    self.target_velocity = Twist()\n    self.target_velocity.linear.x = 0\n    self.target_velocity.linear.y = 0\n    self.target_velocity.linear.z = 0\n    self.target_velocity.angular.x = 0\n    self.target_velocity.angular.y = 0\n    self.target_velocity.angular.z = 0\n\n    self.target_velocity.header.stamp = rospy.Time.now()\n    self.target_velocity.header.frame_id = \"map\"\n\n    self.target_msg = PositionTarget()\n    self.target_msg.header.stamp = rospy.Time.now()\n    self.target_msg.header.frame_id = \"map\"\n\n    self.target_msg.coordinate_frame = 1\n    self.target_msg.type_mask = 0\n\n    self.target_msg.position.x = self.target_pose", "CodeBleu_score": 31.88002042703051}, {"code": "def hover(self)\n\t\n    self.set_mode_client(1, 'OFFBOARD')\n    self.set_mode_client(1, 'STABILIZE')\n    self.set_mode_client(1, 'HOVER')\n    self.set_mode_client(1, 'ALT_HOLD')\n    self.set_mode_client(1, 'GUIDED')\n    self.set_mode_client(1, 'AUTO')\n    self.set_mode_client(1, 'LOITER')\n    self.set_mode_client(1, 'RTL')\n    self.set_mode_client(1, 'LAND')\n    self.set_mode_client(1, 'TAKEOFF')\n    self.set_mode_client(1, 'POSITION')\n    self.set_mode_client(1, 'OFFBOARD')\n    self.set_mode_client(1, 'STABILIZE')\n    self.set_mode_client(1, 'HOVER')\n    self.set_mode_client(1, 'ALT_HOLD')\n    self.set_mode_client(1, 'GUIDED')\n    self.set_mode_client(1, 'AUTO')\n    self.set_mode_client(1, 'LOITER')\n    self.set_mode_client(1, 'RTL')\n    self.set_mode_client(1, 'LAND')\n    self.set_mode_client(1, 'TAKEOFF')\n    self.set_mode_client(1, 'POSITION')\n    self.set_mode_client(1, 'OFFBOARD')\n    self.set_mode_client(1, 'STABILIZE')\n    self.set_mode_client(1, 'HOVER')\n    self.set_mode_client(1, 'ALT_HOLD')\n    self.set_mode_client(1, 'GUIDED')\n    self.set_mode_client(1, 'AUTO')\n    self.set_mode_client(1, 'LOITER')\n    self.set_mode_client(1, 'RTL')\n    self", "CodeBleu_score": 11.950199821343325}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService(0, self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Flight Mode switch failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 58.87313145434984}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy(\n                \"/mavros/set_mode\", SetMode)\n            flightModeService(0, self.flight_mode)\n            print(\"Mode switch successful\")\n            return True\n        except:\n            print(\"Mode switch failed\")\n            return False\n\n", "CodeBleu_score": 47.67653401404704}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(0, self.flight_mode)\n            print('Mode switch successful')\n            return True\n        except rospy.ServiceException as e:\n            print('Mode switch failed: %s' % e)\n            return False\n\n", "CodeBleu_score": 35.412370800550036}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.position_target_pub.publish(self.target_motion)\n\n", "CodeBleu_score": 25.169318843929684}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if not self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    elif not self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    else:\n        self.target_pose.coordinate_frame = 1\n        self.target_pose.type_mask = 1\n        self.target_pose.velocity.x = msg.linear.x\n        self.target_pose.velocity.y = msg.linear.y\n        self.target_pose.velocity.z = msg.linear.z\n        self.target_pose.acceleration_or_force.x = msg.angular.x\n        self.target_pose.acceleration_or_force.y = msg.angular.y\n        self.target_pose.acceleration_or_force.z = msg.angular.z\n        self.target_pose_pub.publish(self.target_pose)\n\n", "CodeBleu_score": 40.52319541174857}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = PositionTarget()\n        self.target_motion.header.stamp = rospy.Time.now()\n        self.target_motion.header.frame_id = 'enu'\n        self.target_motion.position.x = msg.linear.x\n        self.target_motion.position.y = msg.linear.y\n        self.target_motion.position.z = msg.linear.z\n        self.target_motion.velocity.x = msg.angular.x\n        self.target_motion.velocity.y = msg.angular.y\n        self.target_motion.velocity.z = msg.angular.z\n\n", "CodeBleu_score": 41.14279541653823}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (x > 0.02 or x < -0.02 or y > 0.02 or y < -0.02 or z > 0.02 or z < -0.02) or w > 0.005:\n        self.hover_flag = 0\n        self.set_mode(0, \"OFFBOARD\")\n        self.hover_flag = 1\n        self.set_mode(0, \"HOVER\")\n\n", "CodeBleu_score": 36.8713030444895}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 1:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.hover_mode = \"OFFBOARD\"\n            print(\"HOVER OFFBOARD\")\n            self.hover_offboard_pub.publish(String(\"OFFBOARD\"))\n        else:\n            self.hover_mode = \"HOVER\"\n            self.hover_offboard_pub.publish(String(\"HOVER\"))\n    elif self.hover_flag == 0:\n        if x <= 0.02 and y <= 0.02 and z <= 0.02 and w <= 0.005:\n            self.hover_flag = 1\n            self.hover_mode = \"HOVER\"\n            print(\"HOVER ON\")\n            self.hover_offboard_pub.publish(String(\"HOVER\"))\n\n", "CodeBleu_score": 36.30427854866698}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 0:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.hover_state_transition(x, y, z, w)\n        else:\n            self.hover_flag = 1\n            self.hover_state_transition(x, y, z, w)\n    elif self.hover_flag == 1:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.hover_state_transition(x, y, z, w)\n        else:\n            self.hover_flag = 1\n            self.hover_state_transition(x, y, z, w)\n\n", "CodeBleu_score": 30.797551892756285}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q.w, q.x, q.y, q.z)\n        return q.yaw_pitch_roll[0]\n\n", "CodeBleu_score": 48.77390960520454}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q.w, q.x, q.y, q.z).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 30.1393927143279}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q.w, q.x, q.y, q.z)\n        yaw = q.yaw_pitch_roll[0]\n    return yaw\n\n", "CodeBleu_score": 60.94785503739226}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n\n    # Update the coordinate frame\n    self.msg.coordinate_frame = 1\n\n    # Update the motion type\n    self.msg.type_mask = 0b0000111111000111\n\n    # Construct the target motion\n    self.msg.position.x = self.current_pos.pose.position.x\n    self.msg.position.y = self.current_pos.pose.position.y\n    self.msg.position.z = self.current_pos.pose.position.z\n\n    # Get the current yaw\n    self.yaw = self.current_pos.pose.orientation\n\n    # Convert the yaw to a quaternion\n    self.yaw = Quaternion(self.yaw.w, self.yaw.x, self.yaw.y, self.yaw.z)\n\n    # Calculate the target yaw\n    self.target_yaw = self.yaw * self.yaw_offset\n\n    # Convert the target yaw to a quaternion\n    self.target_yaw = Quaternion(\n        self.target_yaw.w, self.target_yaw.x, self.target_yaw.y, self.target_yaw.z\n    )\n\n    # Set the target yaw\n    self.msg.orientation.w = self.target_yaw.w\n    self.msg.orientation.x = self.target_yaw.x\n    self.msg.orientation.y = self.target_yaw.y\n    self.msg.orientation.z = self.target_yaw.z\n\n    # Publish the target motion\n    self.target_pub.publish(self.msg)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\n        \"Vehicle Type: \"\n        + str(self.vehicle_type)\n        + \" Vehicle ID: \"\n        + str(self.vehicle_id)\n        + \" Flight Mode: \"\n        + str(self.flight_mode)\n    )\n\n", "CodeBleu_score": 35.211017851722055}, {"code": "def hover(self)\n\t\n    # Set the coordinate frame of the position and velocity targets to be the body frame\n    self.target_pose.type_mask = PositionTarget.IGNORE_PX | PositionTarget.IGNORE_PY | PositionTarget.IGNORE_PZ | PositionTarget.IGNORE_AFX | PositionTarget.IGNORE_AFY | PositionTarget.IGNORE_AFZ | PositionTarget.IGNORE_YAW_RATE\n\n    # Set the motion type to hover\n    self.target_pose.type_mask |= PositionTarget.TYPEMASK_POSITION\n\n    # Set the desired position and yaw values\n    self.target_pose.position.x = 0.0\n    self.target_pose.position.y = 0.0\n    self.target_pose.position.z = 0.0\n    self.target_pose.yaw = 0.0\n\n    # Publish the target motion\n    self.target_pose_pub.publish(self.target_pose)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight mode: \", self.flight_mode)\n\n", "CodeBleu_score": 24.190227787173143}, {"code": "def hover(self)\n\t\n    # Set the coordinate frame of the position and velocity setpoints.\n    self.pos_setpoint.coordinate_frame = 1\n    self.vel_setpoint.coordinate_frame = 1\n\n    # Set the type of motion of the position and velocity setpoints.\n    self.pos_setpoint.type_mask = 1\n    self.vel_setpoint.type_mask = 1\n\n    # Set the target position of the vehicle to the current position.\n    self.pos_setpoint.position.x = self.curr_pos.pose.position.x\n    self.pos_setpoint.position.y = self.curr_pos.pose.position.y\n    self.pos_setpoint.position.z = self.curr_pos.pose.position.z\n\n    # Set the target yaw of the vehicle to the current yaw.\n    self.pos_setpoint.yaw = self.curr_yaw\n\n    # Publish the position and velocity setpoints.\n    self.pos_pub.publish(self.pos_setpoint)\n    self.vel_pub.publish(self.vel_setpoint)\n\n    # Print the vehicle type, vehicle ID, and flight mode.\n    print(f\"{self.vehicle_type} {self.vehicle_id} is in {self.flight_mode} mode\")\n\n", "CodeBleu_score": 35.02904799760439}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService(self.flightMode)\n            print('Flight mode switched to: ' + self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            print('Flight mode switch failed: ' + str(e))\n            return False\n\n", "CodeBleu_score": 33.219673042450346}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy(\n                '/mavros/set_mode', SetMode)\n            flightModeService(0, self.flight_mode)\n            self.flight_mode = self.flight_mode\n            print(\"Flight mode switched to: \", self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Flight mode switch failed: \", e)\n            return False\n\n", "CodeBleu_score": 35.230319253980085}, {"code": "def flight_mode_switch(self)\n\t\n\n    if self.flight_mode == \"HOVER\":\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(\"Flight mode switched to: \" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Flight mode switch failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 41.345078603934155}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n\n    self.get_total_reward()\n\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == i:\n        self.local_pose = msg\n        if self.gcs_command == \"TAKEOFF\":\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n            self.takeoff_target_pose.pose.position.z += 1.5\n        elif self.gcs_command == \"HOVER\":\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose = copy.deepcopy(self.local_pose)\n        self.global_pose.pose.position.x += self.bias_x\n        self.global_pose.pose.position.y += self.bias_y\n        self.global_pose.pose.position.z += self.bias_z\n\n", "CodeBleu_score": 33.7129902172928}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.global_pose = copy.deepcopy(msg)\n        self.global_pose.pose.position.x += self.bias[0]\n        self.global_pose.pose.position.y += self.bias[1]\n        self.global_pose.pose.position.z += self.bias[2]\n\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n            self.takeoff_target_pose.pose.position.z += 1.5\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n            self.hover_target_pose.pose.position.z += 0.5\n\n", "CodeBleu_score": 34.775317676795524}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == i:\n        self.local_pose = msg\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n            self.takeoff_target_pose.pose.position.z += 1\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose = copy.deepcopy(self.local_pose)\n        self.global_pose.pose.position.x += self.bias[0]\n        self.global_pose.pose.position.y += self.bias[1]\n\n", "CodeBleu_score": 35.468314473017266}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.state.mode == \"OFFBOARD\" and self.state.armed and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\" and self.state.mode == \"OFFBOARD\"", "CodeBleu_score": 32.06211440441057}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.mode == \"OFFBOARD\" and self.state.mode == \"AUTO.TAKEOFF\":\n        if self.state.position.z > 0.2:\n            return True\n        else:\n            return False\n    else:\n        return False\n\n", "CodeBleu_score": 59.88212505143097}, {"code": "def takeoff_detection(self)\n\t\n    if self.current_state.armed and self.current_state.mode == \"OFFBOARD\" and self.current_state.mode != \"AUTO.TAKEOFF\":\n        if self.current_pose.pose.position.z > 0.2:\n            return True\n    return False\n\n", "CodeBleu_score": 52.9920998279088}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize the distance matrix with zeros\n    dist_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    # Loop through all possible pairs of UAVs\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            # Calculate the Euclidean distance between the UAVs\n            dist = numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j]))\n            # Adjust the distance by subtracting it from 50 and rounding it to the nearest integer\n            dist = int(round(50 - dist))\n            # Store the adjusted distance in the distance matrix\n            dist_matrix[i, j] = dist\n    # Return the distance matrix\n    return dist_matrix\n\n", "CodeBleu_score": 29.02318704956677}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    dist_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = int(numpy.linalg.norm(orig_formation[i] - change_formation[j]) - 50)\n    return dist_matrix\n\n", "CodeBleu_score": 26.621558782340944}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    distances = numpy.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distances[i][j] = int(numpy.linalg.norm(orig_formation[i] - change_formation[j]) - 50)\n\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    distances = numpy.array(distances, dtype=int)\n    return distances\n", "CodeBleu_score": 29.769219947739796}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    if i in self.visited_left:\n        return False\n    self.visited_left.add(i)\n    for j in self.adj_list[i]:\n        if j not in self.visited_right:\n            self.visited_right.add(j)\n            if self.match[j] == -1 or find_path(self, self.match[j]):\n                self.match[j] = i\n                return True\n    return False\n\n", "CodeBleu_score": 29.309279975240983}, {"code": "def find_path(self, i)\n\t\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in range(self.n):\n        if not self.visited[self.n + j] and self.graph[i][j] - self.match[i] - self.match[self.n + j] == 0:\n            self.visited[self.n + j] = True\n            if self.match[self.n + j] == -1 or self.find_path(self.match[self.n + j]):\n                self.match[i] = j\n                self.match[self.n + j] = i\n                return True\n    return False\n\n", "CodeBleu_score": 35.27114199085961}, {"code": "def find_path(self, i)\n\t\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in range(self.n_right):\n        if self.match[j] == -1 or find_path(self, self.match[j]):\n            self.match[j] = i\n            return True\n    return False\n", "CodeBleu_score": 25.015607201321554}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    # Initialize slack variables and visit arrays\n    slack = numpy.zeros((self.n, self.m))\n    u_visit = numpy.zeros(self.n)\n    v_visit = numpy.zeros(self.m)\n\n    # Iterate over UAVs\n    for u in range(self.n):\n        # Initialize slack variables and visit arrays\n        slack = numpy.zeros((self.n, self.m))\n        u_visit = numpy.zeros(self.n)\n        v_visit = numpy.zeros(self.m)\n\n        # Find a path for the current UAV\n        while True:\n            # Reset visit arrays\n            u_visit = numpy.zeros(self.n)\n            v_visit = numpy.zeros(self.m)\n\n            # Find a path using DFS\n            if self.dfs(u, slack, u_visit, v_visit):\n                break\n\n            # Adjust labels based on minimum slack value\n            d = numpy.inf\n            for i in range(self.n):\n                for j in range(self.m):\n                    if not u_visit[i] and not v_visit[j] and slack[i, j] < d:\n                        d = slack[i, j]\n            for i in range(self.n):\n                if u_visit[i]:\n                    self.u_labels[i] -= d\n            for j in range(self.m):\n                if v_visit[j]:\n                    self.v_labels[j] += d\n\n    # Return match results for the right side of the bipartite graph\n    return [self.v_labels[j] for j in self.match]\n\n", "CodeBleu_score": 37.06197122246989}, {"code": "def KM(self)\n\t\n    UAV_num = len(self.UAVs)\n    self.match_results = [-1 for _ in range(UAV_num)]\n    self.visited_UAVs = [False for _ in range(UAV_num)]\n    self.visited_targets = [False for _ in range(len(self.targets))]\n    self.slack = [sys.maxsize for _ in range(len(self.targets))]\n    for uav_index in range(UAV_num):\n        while True:\n            self.visited_UAVs = [False for _ in range(UAV_num)]\n            self.visited_targets = [False for _ in range(len(self.targets))]\n            self.slack = [sys.maxsize for _ in range(len(self.targets))]\n            if self.find_path(uav_index):\n                break\n            self.adjust_labels()\n    return self.match_results\n\n", "CodeBleu_score": 24.122183866635226}, {"code": "def KM(self)\n\t\n    # Initialize variables\n    n = len(self.right)\n    m = len(self.left)\n    match = [-1] * m\n    slack = [[sys.maxsize] * m for _ in range(n)]\n    u_visit = [False] * n\n    v_visit = [False] * m\n\n    # Iterate over UAVs\n    for u in range(n):\n        # Reset visit arrays\n        u_visit = [False] * n\n        v_visit = [False] * m\n\n        # Find a path using DFS\n        while True:\n            # Find the minimum slack value\n            min_slack = sys.maxsize\n            for v in range(m):\n                if not v_visit[v]:\n                    min_slack = min(min_slack, slack[u][v])\n\n            # Update slack values\n            for v in range(m):\n                if not v_visit[v]:\n                    slack[u][v] -= min_slack\n\n            # Find a path using DFS\n            if self.dfs(u, match, u_visit, v_visit):\n                break\n\n            # Adjust labels based on the minimum slack value\n            for v in range(m):\n                if v_visit[v]:\n                    slack[u][v] += min_slack\n\n    # Return the match results\n    return match\n", "CodeBleu_score": 25.709262671496823}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Convert the image from BGR to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds for yellow color in HSV color space\n    lower_yellow = (20, 100, 100)\n    upper_yellow = (30, 255, 255)\n\n    # Create a mask for yellow color using the lower and upper bounds\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n", "CodeBleu_score": 46.45006548587249}, {"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds for yellow color in HSV color space\n    lower_yellow = (20, 100, 100)\n    upper_yellow = (30, 255, 255)\n\n    # Create a mask for yellow color using the specified HSV bounds\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n", "CodeBleu_score": 46.45006548587249}, {"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper HSV bounds for yellow color\n    lower_yellow = (20, 100, 100)\n    upper_yellow = (30, 255, 255)\n\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n", "CodeBleu_score": 46.45006548587249}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t    const int id,\n    const bool printWarning,\n    TagDescriptionContainer& descriptionContainer\n}", "CodeBleu_score": 1.1463299246280485}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    const int32_t id,\n    TagDescriptionContainer& descriptionContainer,\n    bool printWarning = true\n}", "CodeBleu_score": 1.1948421866868408}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    const int32_t id, TagDescriptionContainer *descriptionContainer, bool printWarning) {\n  if (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN(\"Could not find standalone tag description for ID %d\", id);\n    }\n    return false;\n  }\n  *descriptionContainer = standalone_tag_descriptions_[id];\n  return true;\n}\n\n", "CodeBleu_score": 47.27151466264643}]}
