{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *desc_ptr = (uint8_t *) desc;\n\tuint8_t *desc_end = (uint8_t *) desc + desc->bLength;\n\twhile (desc_ptr < desc_end) {\n\t\tif (desc_ptr[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\t}\n\t\tdesc_ptr += desc_ptr[0];\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 36.54099712132117}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *p_desc = desc;\n\tuint8_t desc_len;\n\n\twhile (p_desc->bLength != 0) {\n\t\tdesc_len = p_desc->bLength;\n\t\tif (p_desc->bDescriptorType == desc_id) {\n\t\t\treturn p_desc;\n\t\t}\n\t\tp_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) p_desc + desc_len);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 39.25563509730049}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *desc_ptr = (uint8_t *) desc;\n\tuint8_t desc_len;\n\n\twhile (1) {\n\t\tdesc_len = desc_ptr[1];\n\t\tif (desc_ptr[0] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\t}\n\t\tif (desc_len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tdesc_ptr += desc_len;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.87540952860177}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    uint8_t *desc_ptr;\n    uint8_t desc_len;\n    uint8_t desc_type;\n    uint8_t desc_index;\n    uint8_t desc_iface_num;\n    uint8_t desc_setting_num;\n    bool match;\n\n    if (usb_config_desc_ptr == NULL) {\n        return false;\n    }\n\n    if (iface_num >= usb_config_desc_ptr->bNumInterfaces) {\n        return false;\n    }\n\n    desc_ptr = usb_config_desc_ptr->bConfigurationValue;\n    desc_len = usb_config_desc_ptr->wTotalLength;\n    desc_type = desc_ptr[0];\n\n    if (desc_type != USB_DESC_TYPE_CONFIG) {\n        return false;\n    }\n\n    desc_index = 0;\n    match = false;\n\n    while (desc_index < desc_len) {\n        desc_type = desc_ptr[desc_index];\n        desc_len = desc_ptr[desc_index + 1];\n\n        if (desc_type == USB_DESC_TYPE_INTERFACE) {\n            desc_iface_num = desc_ptr[desc_index + 6];\n            desc_setting_num = desc_ptr[desc_index + 7];\n\n            if ((desc_iface_num == iface_num) && (desc_setting_num == setting_num)) {\n                match = true;\n                break;\n            }\n        }\n\n        desc_index += desc_len;\n    }\n\n    return match;\n}", "CodeBleu_score": 42.38519173015931}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t  struct usb_config_descriptor *config;\n  struct usb_interface_descriptor *iface;\n  struct usb_endpoint_descriptor *ep;\n  uint8_t i, j;\n  bool found = false;\n\n  if (!udc_get_config()) {\n    return false;\n  }\n  if (iface_num >= udc_get_config()->bNumInterfaces) {\n    return false;\n  }\n  config = (struct usb_config_descriptor *)udc_get_config();\n  iface = (struct usb_interface_descriptor *)&config[1];\n  for (i = 0; i < iface_num; i++) {\n    iface = (struct usb_interface_descriptor *)((uint8_t *)iface +\n                                                iface->bLength);\n  }\n  if (iface->bNumEndpoints == 0) {\n    return false;\n  }\n  ep = (struct usb_endpoint_descriptor *)&iface[1];\n  for (j = 0; j < iface->bNumEndpoints; j++) {\n    if (ep->bInterfaceNumber == iface_num &&\n        ep->bEndpointAddress == setting_num) {\n      found = true;\n      break;\n    }\n    ep = (struct usb_endpoint_descriptor *)((uint8_t *)ep + ep->bLength);\n  }\n  return found;\n}", "CodeBleu_score": 39.94622587894811}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t  uint8_t *p = udc_conf_desc;\n  uint8_t iface_num_tmp;\n  uint8_t setting_num_tmp;\n\n  if (udc_conf_desc == NULL) {\n    return false;\n  }\n\n  if (iface_num >= udc_conf_desc[1]) {\n    return false;\n  }\n\n  while (p < udc_conf_desc + udc_conf_desc[0]) {\n    switch (p[1]) {\n      case USB_DESC_TYPE_INTERFACE:\n        iface_num_tmp = p[5];\n        setting_num_tmp = p[7];\n        if (iface_num == iface_num_tmp && setting_num == setting_num_tmp) {\n          return true;\n        }\n        break;\n      case USB_DESC_TYPE_ENDPOINT:\n        break;\n      default:\n        break;\n    }\n    p += p[0];\n  }\n  return false;\n}", "CodeBleu_score": 37.64220062141117}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t  uint8_t *buf = (uint8_t *)&udc_req.setup_req;\n  uint8_t ep_num = buf[2];\n  uint8_t ep_dir = buf[3] & 0x03;\n  uint8_t *ep_status = (uint8_t *)&udc_ep[ep_num].status;\n  uint8_t *ep_halted = (uint8_t *)&udc_ep[ep_num].halted;\n\n  if (buf[1] != sizeof(udc_ep[ep_num].status)) {\n    return false;\n  }\n\n  if (ep_dir == USB_DIR_IN) {\n    ep_status[0] = ep_halted[0] ? USB_EP_STS_HALT : 0;\n  } else {\n    ep_status[0] = ep_halted[1] ? USB_EP_STS_HALT : 0;\n  }\n\n  udc_req.payload_len = sizeof(udc_ep[ep_num].status);\n  udc_req.payload = (uint8_t *)&udc_ep[ep_num].status;\n\n  return true;\n}", "CodeBleu_score": 45.692381350382284}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t  if (req.wLength != sizeof(uint8_t))\n    return false;\n\n  uint8_t ep_status = (udc_ep[req.wIndex].ep.stall) ? USB_EP_STATUS_HALTED : 0;\n\n  usbd_ep_setup_xfer(req.wIndex, &req, req.wLength, ep_status);\n\n  return true;\n}", "CodeBleu_score": 25.172423317751146}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    uint8_t *p = (uint8_t *)&udc_ep_status[0];\n    uint8_t len = sizeof(udc_ep_status);\n\n    if (udc_req.wLength != len) {\n        return false;\n    }\n\n    if (udc_ep_halted[udc_req.wIndex]) {\n        *p = USB_EP_STATUS_HALTED;\n    } else {\n        *p = 0;\n    }\n\n    return true;\n}", "CodeBleu_score": 39.86196858272377}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t  bool result;\n  uint8_t altsetting;\n  uint8_t iface_num;\n  uint8_t iface_num_max;\n  uint8_t iface_num_min;\n  uint8_t iface_num_valid;\n  uint8_t iface_num_valid_max;\n  uint8_t iface_num_valid_min;\n  uint8_t iface_num_valid_valid;\n  uint8_t iface_num_valid_valid_max;\n  uint8_t iface_num_valid_valid_min;\n  uint8_t iface_num_valid_valid_valid;\n  uint8_t iface_num_valid_valid_valid_max;\n  uint8_t iface_num_valid_valid_valid_min;\n  uint8_t iface_num_valid_valid_valid_valid;\n  uint8_t iface_num_valid_valid_valid_valid_max;\n  uint8_t iface_num_valid_valid_valid_valid_min;\n  uint8_t iface_num_valid_valid_valid_valid_valid;\n  uint8_t iface_num_valid_valid_valid_valid_valid_max;\n  uint8_t iface_num_valid_valid_valid_valid_valid_min;\n  uint8_t iface_num_valid_valid_valid_valid_valid_valid;\n  uint8_t iface_num_valid_valid_valid_valid_valid_valid_max;\n  uint8_t iface_num_valid_valid_valid_valid_valid_valid_min;\n  uint8_t iface_num_valid_valid_valid_valid_valid_valid_valid;\n  uint8_t iface_num_valid_valid_valid_valid_valid_valid_valid_max;\n  uint8_t iface_num_valid_valid_valid_valid_valid_valid_valid_min;\n  uint8_t iface_num_valid_valid_valid_valid_valid_valid_valid_valid;\n  uint8_t iface", "CodeBleu_score": 5.4625135806160845}, {"code": "static bool udc_req_iface(void){\n\t  bool ret;\n  uint8_t iface_num;\n  uint8_t alt_num;\n  uint8_t iface_num_next;\n  uint8_t alt_num_next;\n  uint8_t iface_num_prev;\n  uint8_t alt_num_prev;\n  uint8_t iface_num_next_next;\n  uint8_t alt_num_next_next;\n  uint8_t iface_num_prev_prev;\n  uint8_t alt_num_prev_prev;\n  uint8_t iface_num_next_next_next;\n  uint8_t alt_num_next_next_next;\n  uint8_t iface_num_prev_prev_prev;\n  uint8_t alt_num_prev_prev_prev;\n  uint8_t iface_num_next_next_next_next;\n  uint8_t alt_num_next_next_next_next;\n  uint8_t iface_num_prev_prev_prev_prev;\n  uint8_t alt_num_prev_prev_prev_prev;\n  uint8_t iface_num_next_next_next_next_next;\n  uint8_t alt_num_next_next_next_next_next;\n  uint8_t iface_num_prev_prev_prev_prev_prev;\n  uint8_t alt_num_prev_prev_prev_prev_prev;\n  uint8_t iface_num_next_next_next_next_next_next;\n  uint8_t alt_num_next_next_next_next_next_next;\n  uint8_t iface_num_prev_prev_prev_prev_prev_prev;\n  uint8_t alt_num_prev_prev_prev_prev_prev_prev;\n  uint8_t iface_num_next_next_next_next_next_next_next;\n  uint8_t alt_num_next_next_next_next_next_next_next;\n  uint8_t iface_num_prev_prev_prev_prev", "CodeBleu_score": 5.632950770688799}, {"code": "static bool udc_req_iface(void){\n\t\tbool ret = false;\n\n\tif (!udc_is_configured()) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_DIR_IN) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_TYPE_STANDARD) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_TYPE_CLASS) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_TYPE_VENDOR) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_RECIP_DEVICE) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_RECIP_INTERFACE) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_RECIP_ENDPOINT) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_RECIP_OTHER) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_RECIP_MASK) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_TYPE_MASK) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_DIR_MASK) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_RECIP_MASK) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_TYPE_MASK) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.bRequestType & USB_REQTYPE_DIR_MASK) {\n\t\tgoto out;\n\t}\n\n\tif (udc_req.", "CodeBleu_score": 32.77932397695864}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t    // Initialize the MSC interface\n    udi_msc_init();\n\n    // Enable the MSC interface\n    udi_msc_enable_ext();\n\n    // Get the number of LUNs\n    udi_msc_lun_num = udi_msc_get_lun_num();\n\n    // Check if there are LUNs available\n    if (udi_msc_lun_num == 0) {\n        // No LUNs available, return false\n        return false;\n    }\n\n    // Unload the medium on each LUN\n    for (uint8_t i = 0; i < udi_msc_lun_num; i++) {\n        udi_msc_unload_medium(i);\n    }\n\n    // Start the MSC process\n    udi_msc_process();\n\n    // Return true\n    return true;\n}", "CodeBleu_score": 36.61446287420523}, {"code": "bool udi_msc_enable(void){\n\t  // Initialize the MSC interface\n  udi_msc_init();\n\n  // Check if there are any LUNs available\n  if (udi_msc_lun_count == 0) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t lun = 0; lun < udi_msc_lun_count; lun++) {\n    udi_msc_unload_medium(lun);\n  }\n\n  // Start the MSC process\n  udi_msc_process();\n\n  return true;\n}", "CodeBleu_score": 31.529617017281364}, {"code": "bool udi_msc_enable(void){\n\t    // Initialize the USB Mass Storage Class (MSC) interface\n    udi_msc_init();\n\n    // Enable the USB Mass Storage Class (MSC) interface\n    udi_msc_enable();\n\n    // Check if there are any LUNs available\n    if (udi_msc_lun_count() == 0) {\n        // No LUNs available, return false\n        return false;\n    }\n\n    // Unload the medium on each LUN\n    for (uint8_t i = 0; i < udi_msc_lun_count(); i++) {\n        udi_msc_unload_medium(i);\n    }\n\n    // Start the MSC process by waiting for a Command Block Wrapper (CBW) reception\n    while (1) {\n        // Wait for a Command Block Wrapper (CBW) reception\n        udi_msc_wait_cbw();\n\n        // Process the Command Block Wrapper (CBW)\n        udi_msc_process_cbw();\n    }\n\n    // Return true if the MSC process has been started successfully\n    return true;\n}", "CodeBleu_score": 41.72442734027305}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    udi_msc_t *msc = udi_msc_inst;\n    uint32_t csw_data_residue = msc->csw.data_residue;\n    uint32_t csw_status = msc->csw.status;\n    uint8_t *csw_sense_data = msc->csw.sense_data;\n    uint8_t sense_key = csw_sense_data[0];\n    uint8_t asc = csw_sense_data[1];\n    uint8_t ascq = csw_sense_data[2];\n    uint8_t csw_status_code = (csw_status >> 16) & 0xFF;\n    uint8_t csw_status_code_qualifier = (csw_status >> 8) & 0xFF;\n\n    if (status != UDD_EP_STATUS_SUCCESS) {\n        /*\n         * If the transfer is not successful, wait for a MSC setup reset to restart CBW reception.\n         */\n        udi_msc_reset_cbw_waiting(msc);\n    } else {\n        /*\n         * If the transfer is successful, update the sense data and decrease the data residue in the CSW by the amount of data sent.\n         */\n        csw_data_residue -= nb_sent;\n        csw_sense_data[0] = sense_key;\n        csw_sense_data[1] = asc;\n        csw_sense_data[2] = ascq;\n        csw_sense_data[3] = csw_status_code;\n        csw_sense_data[4] = csw_status_code_qualifier;\n        csw_sense_data[5] = nb_sent & 0xFF;\n        csw_sense_data[6] = (n & 0xFF00) >> 8;\n        csw_sense_data[7] = (n & 0xFF0000) >> 16;\n        csw_sense_data[8] = (", "CodeBleu_score": 40.204306017755705}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    udi_msc_t *msc = udi_msc_get_instance();\n    udi_msc_cbw_t *cbw = &msc->cbw;\n    udi_msc_csw_t *csw = &msc->csw;\n    uint8_t *sense = cbw->sense;\n    uint32_t residue = cbw->residue;\n\n    if (status != UDD_EP_STATUS_OK) {\n        /*\n         * If the status is not UDD_EP_STATUS_OK, the transfer was not successful.\n         * Wait for a MSC setup reset to restart CBW reception.\n         */\n        udi_msc_reset();\n        return;\n    }\n\n    /*\n     * If the transfer is successful, update the sense data and decrease the data residue in the CSW by the amount of data sent.\n     */\n    if (sense != NULL) {\n        /*\n         * If there is sense data, update it.\n         */\n        if (residue < nb_sent) {\n            /*\n             * If the data residue is less than the amount of data sent, set the sense data to a generic \"end of medium\" error.\n             */\n            sense[0] = 0x0;\n            sense[1] = 0x2;\n            sense[2] = 0x0;\n            sense[3] = 0x0;\n            sense[4] = 0x0;\n            sense[5] = 0x0;\n            sense[6] = 0x0;\n            sense[7] = 0x0;\n            sense[8] = 0x0;\n            sense[9] = 0x0;\n            sense[10] = 0x0;\n            sense[11] = 0x0;\n        } else {\n            /*\n             * If the data residue is greater than or equal to the amount of data sent, set the sense data to a generic \"no error\" error.\n             */\n            sense[0] = 0x0;\n            sense[1] = 0x0;\n            sense[2] = 0x0;\n", "CodeBleu_score": 44.76145702561429}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    if (status != UDD_EP_STATUS_OK) {\n        udi_msc_reset();\n        return;\n    }\n\n    if (udi_msc_csw.b_sign) {\n        udi_msc_csw.b_sign = 0;\n        udi_msc_csw.b_status = UDI_MSC_CSW_STATUS_PHASE_ERROR;\n    }\n\n    udi_msc_csw.dw_residue -= nb_sent;\n\n    if (udi_msc_csw.dw_residue == 0) {\n        udi_msc_process_csw();\n    }\n}", "CodeBleu_score": 52.288696873918525}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t  uint8_t *csw = (uint8_t *) &udi_msc_csw;\n  uint32_t residue = udi_msc_cbw.bmTransferFlags & USB_MSC_CBW_FLAG_DATA_PHASE ? udi_msc_cbw.dCBWDataTransferLength : udi_msc_cbw.dCBWCBLength;\n  if (residue) {\n    udi_msc_stall_next_request(udi_msc_cbw.bmTransferFlags & USB_MSC_CBW_FLAG_DIR_IN ? UDI_MSC_DIR_IN : UDI_MSC_DIR_OUT);\n  }\n  csw[0] = udi_msc_cbw.bCSWStatus;\n  csw[1] = 0;\n  csw[2] = 0;\n  csw[3] = 0;\n  csw[7] = udi_msc_cbw.bCSWStatus;\n  csw[8] = 0;\n  csw[9] = 0;\n  csw[10] = 0;\n  csw[11] = 0;\n  csw[12] = udi_msc_cbw.dCSWDataResidue[0];\n  csw[13] = udi_msc_cbw.dCSWDataResidue[1];\n  csw[14] = udi_msc_cbw.dCSWDataResidue[2];\n  csw[15] = udi_msc_cbw.dCSWDataResidue[3];\n  udi_msc_csw_send();\n}", "CodeBleu_score": 43.71565161071177}, {"code": "static void udi_msc_csw_process(void){\n\t    uint32_t csw_tag;\n    uint32_t csw_residue;\n    uint32_t csw_status;\n    uint32_t csw_status_code;\n    uint32_t csw_status_code_mask;\n    uint32_t csw_status_code_shift;\n    uint32_t csw_status_code_value;\n    uint32_t csw_status_code_value_mask;\n    uint32_t csw_status_code_value_shift;\n    uint32_t csbw_flags;\n    uint32_t csbw_flags_mask;\n    uint32_t csbw_flags_shift;\n    uint32_t csbw_flags_value;\n    uint32_t csbw_flags_value_mask;\n    uint32_t csbw_flags_value_shift;\n    uint32_t csbw_flags_value_value;\n    uint32_t csbw_flags_value_value_mask;\n    uint32_t csbw_flags_value_value_shift;\n    uint32_t csbw_flags_value_value_value;\n    uint32_t csbw_flags_value_value_value_mask;\n    uint32_t csbw_flags_value_value_value_shift;\n    uint32_t csbw_flags_value_value_value_value;\n    uint32_t csbw_flags_value_value_value_value_mask;\n    uint32_t csbw_flags_value_value_value_value_shift;\n    uint32_t csbw_flags_value_value_value_value_value;\n    uint32_t csbw_flags_value_value_value_value_value_mask;\n    uint32_t csbw_flags_value_value_value_value_value_shift;\n    uint32_t csbw_flags_value_value_value_value_value_value;\n    uint3", "CodeBleu_score": 4.51949166122437}, {"code": "static void udi_msc_csw_process(void){\n\t  uint32_t csw_data_residue;\n  uint8_t *csw_ptr;\n  uint8_t *cbw_ptr;\n  uint8_t *cbw_ptr_end;\n  uint8_t *cbw_ptr_end_minus_one;\n  uint8_t *cbw_ptr_end_minus_two;\n  uint8_t *cbw_ptr_end_minus_three;\n  uint8_t *cbw_ptr_end_minus_four;\n  uint8_t *cbw_ptr_end_minus_five;\n  uint8_t *cbw_ptr_end_minus_six;\n  uint8_t *cbw_ptr_end_minus_seven;\n  uint8_t *cbw_ptr_end_minus_eight;\n  uint8_t *cbw_ptr_end_minus_nine;\n  uint8_t *cbw_ptr_end_minus_ten;\n  uint8_t *cbw_ptr_end_minus_eleven;\n  uint8_t *cbw_ptr_end_minus_twelve;\n  uint8_t *cbw_ptr_end_minus_thirteen;\n  uint8_t *cbw_ptr_end_minus_fourteen;\n  uint8_t *cbw_ptr_end_minus_fifteen;\n  uint8_t *cbw_ptr_end_minus_sixteen;\n  uint8_t *cbw_ptr_end_minus_seventeen;\n  uint8_t *cbw_ptr_end_minus_eighteen;\n  uint8_t *cbw_ptr_end_minus_nineteen;\n  uint8_t *cbw_ptr_end_minus_twenty;\n  uint8_t *cbw_ptr_end_minus_twenty_one;\n  uint8_t *cbw_ptr_end_minus_twenty_two;\n  uint8_t *cbw_ptr_end_minus_twenty_three;\n  uint8_t *cbw_ptr_end_minus_twenty_four", "CodeBleu_score": 4.253327552258551}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    usb_cdc_port_t *p_port = &usb_cdc_port[port];\n\n    p_port->dtr = b_enable;\n\n    if (p_port->dtr && p_port->dtr_rate == 1200) {\n        if (p_port->reset_task_id != INVALID_TASK_ID) {\n            task_cancel(p_port->reset_task_id);\n            p_port->reset_task_id = INVALID_TASK_ID;\n        }\n    } else if (!p_port->dtr && p_port->dtr_rate == 1200) {\n        p_port->reset_task_id = task_schedule_us(initiateReset, 500000, NULL, 0);\n    } else if (p_port->reset_task_id != INVALID_TASK_ID) {\n        task_cancel(p_port->reset_task_id);\n        p_port->reset_task_id = INVALID_TASK_ID;\n    }\n}", "CodeBleu_score": 37.57097014990237}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  // Update the DTR status\n  g_usb_dtr_status[port] = b_enable;\n\n  // Check if the DTR rate is 1200\n  if (g_usb_dtr_rate[port] == 1200) {\n    // If the DTR signal is disabled and the DTR rate is 1200, schedule a delayed system reset\n    if (!b_enable) {\n      g_usb_dtr_reset_scheduled[port] = true;\n      g_usb_dtr_reset_time[port] = g_time_ms + USB_DTR_RESET_DELAY;\n      usb_task_cdc_write_reset_controller(port, true);\n    }\n    // If the DTR signal is enabled, cancel any scheduled reset\n    else {\n      g_usb_dtr_reset_scheduled[port] = false;\n      usb_task_cdc_write_reset_controller(port, false);\n    }\n  }\n}", "CodeBleu_score": 41.14195727319658}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  // Get the USB port configuration\n  const usb_cdc_port_config_t * const p_port_config = usb_cdc_get_port_config(port);\n\n  // Check if the DTR signal is enabled\n  if (b_enable) {\n    // Update the DTR status\n    p_port_config->b_dtr_enabled = true;\n\n    // Check if the DTR rate is 1200\n    if (p_port_config->dtr_rate == 1200) {\n      // Check if the reset is already scheduled\n      if (!p_port_config->b_reset_scheduled) {\n        // Schedule a delayed system reset\n        p_port_config->b_reset_scheduled = true;\n        initiateReset();\n      }\n    } else {\n      // Cancel any scheduled reset\n      cancelReset();\n    }\n  } else {\n    // Update the DTR status\n    p_port_config->b_dtr_enabled = false;\n\n    // Cancel any scheduled reset\n    cancelReset();\n  }\n}", "CodeBleu_score": 35.57835042793571}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t  if (usb_request.request_type == USB_REQUEST_TYPE_VENDOR) {\n    switch (usb_request.request_index) {\n      case 0x04:\n        usb_request.request_data_out = (uint8_t *)&usb_descriptor_microsoft_id_descriptor;\n        usb_request.request_data_out_size = sizeof(usb_descriptor_microsoft_id_descriptor);\n        usb_request.request_data_in = NULL;\n        usb_request.request_data_in_size = 0;\n        usb_request.request_data_in_length = 0;\n        return true;\n      case 0x05:\n        usb_request.request_data_out = (uint8_t *)&usb_descriptor_microsoft_extended_properties_descriptor;\n        usb_request.request_data_out_size = sizeof(usb_descriptor_microsoft_extended_properties_descriptor);\n        usb_request.request_data_in = NULL;\n        usb_request.request_data_in_size = 0;\n        usb_request.request_data_in_length = 0;\n        return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 29.030913750921734}, {"code": "bool usb_task_other_requests(void){\n\t  uint8_t request_type;\n  uint8_t request_index;\n  uint8_t request_length;\n  uint8_t *request_payload;\n  uint8_t *descriptor_pointer;\n  uint16_t descriptor_size;\n\n  // Get the request type, index, length, and payload from the USB device\n  request_type = usb_get_request_type();\n  request_index = usb_get_request_index();\n  request_length = usb_get_request_length();\n  request_payload = usb_get_request_payload();\n\n  // Check if the request type is vendor-specific (0x05) and the request index is 0x04 or 0x05\n  if (request_type == 0x05 && (request_index == 0x04 || request_index == 0x05)) {\n    // Set up the pointer and size for the Microsoft-compatible ID or extended properties descriptor\n    if (request_index == 0x04) {\n      descriptor_pointer = &descriptor_microsoft_id;\n      descriptor_size = sizeof(descriptor_microsoft_id);\n    } else {\n      descriptor_pointer = &descriptor_microsoft_extended_properties;\n      descriptor_size = sizeof(descriptor_microsoft_extended_properties);\n    }\n\n    // Update the control request payload and size with the descriptor pointer and size\n    usb_set_request_payload(descriptor_pointer);\n    usb_set_request_length(descriptor_size);\n\n    // Return true to indicate that the request is processed\n    return true;\n  }\n\n  // Return false to indicate that the request index is not recognized\n  return false;\n}", "CodeBleu_score": 21.23115770424954}, {"code": "bool usb_task_other_requests(void){\n\t  // Check if the request type is vendor-specific\n  if (usb_setup.bmRequestType != 0x40) {\n    return false;\n  }\n\n  // Check if the request index is 0x04 or 0x05\n  if (usb_setup.bRequest != 0x04 && usb_setup.bRequest != 0x05) {\n    return false;\n  }\n\n  // Set up pointers and sizes for Microsoft-compatible ID and extended properties descriptors\n  if (usb_setup.bRequest == 0x04) {\n    usb_setup.wValue = 0x0300;\n    usb_setup.wLength = 0x0012;\n    usb_setup.wIndex = 0x0000;\n    usb_setup.wLength = 0x0012;\n    usb_setup.wIndex = 0x0000;\n    usb_setup.wLength = 0x0012;\n    usb_setup.wIndex = 0x0000;\n  } else if (usb_setup.bRequest == 0x05) {\n    usb_setup.wValue = 0x0300;\n    usb_setup.wLength = 0x0012;\n    usb_setup.wIndex = 0x0000;\n    usb_setup.wLength = 0x0012;\n    usb_setup.wIndex = 0x0000;\n    usb_setup.wLength = 0x0012;\n    usb_setup.wIndex = 0x0000;\n  }\n\n  // Update the control request payload and size\n  usb_setup.wLength = 0;\n  usb_setup.wIndex = 0;\n\n  // Return true to indicate that the request was processed\n  return true;\n}", "CodeBleu_score": 19.90088774221035}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (!nbyte) return;\n  while (--nbyte) {\n    SPDR = 0xff;\n    while (!(SPSR & (1 << SPIF)));\n    *buf++ = SPDR;\n  }\n  *buf = spiRec();\n}", "CodeBleu_score": 36.06425537501738}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  uint8_t i;\n\n  if (!nbyte)\n    return;\n  for (i = 0; i < nbyte; i++)\n    *buf++ = spiRec();\n  *buf = spiRec();\n}", "CodeBleu_score": 45.40838242165321}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  uint8_t i;\n\n  if (nbyte == 0)\n    return;\n  for (i = 0; i < nbyte - 1; i++) {\n    spiSend(0x00);\n    buf[i] = spiRec();\n  }\n  buf[i] = spiRec();\n}", "CodeBleu_score": 50.13899917829276}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  pfnISR_Handler oldHandler;\n  uint32_t *pISRVectors = (uint32_t *)&NVIC_VTOR;\n\n  // Disable global interrupts to ensure atomic operation\n  __disable_irq();\n\n  // Retrieve the current handler for the specified IRQ\n  oldHandler = (pfnISR_Handler)pISRVectors[irq];\n\n  // Replace the handler with the new handler\n  pISRVectors[irq] = (uint32_t)newHandler;\n\n  // Re-enable global interrupts\n  __enable_irq();\n\n  // Return the original ISR handler\n  return oldHandler;\n}", "CodeBleu_score": 51.18077082042507}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler = (pfnISR_Handler)__get_IPSR_Handler(irq);\n    __set_IPSR_Handler(irq, newHandler);\n    return oldHandler;\n}", "CodeBleu_score": 33.67419940853576}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n    uint32_t *pISR;\n\n    __disable_irq();\n\n    pISR = (uint32_t *) (NVIC_BASE + irq * 4);\n    oldHandler = (pfnISR_Handler) *pISR;\n    *pISR = (uint32_t) newHandler;\n\n    __enable_irq();\n\n    return oldHandler;\n}", "CodeBleu_score": 49.88163365662528}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  // Check if the USB CDC is enabled\n  if (!cdc_enabled) {\n    return -1;\n  }\n\n  // Check if there are any bytes available in the serial USB buffer\n  if (serial_usb.available()) {\n    // Read the next character from the serial USB buffer\n    char c = serial_usb.read();\n\n    // Process the character if the emergency parser is enabled\n    if (emergency_parser_enabled) {\n      process_emergency_char(c);\n    }\n\n    // Return the character\n    return c;\n  }\n\n  // No bytes available\n  return -1;\n}", "CodeBleu_score": 26.492815719232667}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!enabled)\n    return -1;\n\n  int c = -1;\n  if (SerialUSB.available())\n    c = SerialUSB.peek();\n\n  if (emergency_parser)\n    return emergency_parser(c);\n\n  return c;\n}", "CodeBleu_score": 24.313046169422257}, {"code": "int MarlinSerialUSB::peek(){\n\t    if (!usb_enabled || !usb_configured) {\n        return -1;\n    }\n    if (usb_cdc_rx_buffer_len == 0) {\n        return -1;\n    }\n    return usb_cdc_rx_buffer[usb_cdc_rx_buffer_index];\n}", "CodeBleu_score": 11.373727790771259}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  // Check if there is a pending character\n  if (pendingChar != -1) {\n    int c = pendingChar;\n    pendingChar = -1;\n    return c;\n  }\n\n  // Check if the USB CDC is enabled and configured\n  if (!usb_serial_enabled || !usb_serial_configured) {\n    return -1;\n  }\n\n  // Check if there are any bytes available to read from the PC\n  if (!usb_serial_available()) {\n    return -1;\n  }\n\n  // Read the byte\n  int c = usb_serial_getchar();\n\n  // Update the emergency parser if enabled\n  if (emergency_parser_enabled) {\n    emergency_parser_update(c);\n  }\n\n  // Return the read character\n  return c;\n}", "CodeBleu_score": 47.6854710385987}, {"code": "int MarlinSerialUSB::read(){\n\t    if (pendingChar != -1) {\n        int c = pendingChar;\n        pendingChar = -1;\n        return c;\n    }\n    if (!cdc_configured) return -1;\n    if (!SerialUSB.available()) return -1;\n    int c = SerialUSB.read();\n    if (emergency_parser_enabled) {\n        emergency_parser.parse(c);\n    }\n    return c;\n}", "CodeBleu_score": 52.556979598799835}, {"code": "int MarlinSerialUSB::read(){\n\t  if (pendingChar != -1) {\n    int c = pendingChar;\n    pendingChar = -1;\n    return c;\n  }\n\n  if (!usb_cdc_enabled || !usb_cdc_configured)\n    return -1;\n\n  if (!usb_cdc_available())\n    return -1;\n\n  int c = usb_cdc_getchar();\n\n  if (emergency_parser_enabled)\n    emergency_parser.parse(c);\n\n  return c;\n}", "CodeBleu_score": 53.3941201205806}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (SerialUSB.available()) {\n    return 1;\n  }\n  return 0;\n}", "CodeBleu_score": 28.58577906327061}, {"code": "int MarlinSerialUSB::available(){\n\t  return (SerialUSB.available() || (USB_CDC_ENABLED && USB_CDC_CONNECTED));\n}", "CodeBleu_score": 26.929706888332323}, {"code": "int MarlinSerialUSB::available(){\n\t  if (USB_SERIAL_READY) {\n    return usb_serial_available();\n  }\n  return 0;\n}", "CodeBleu_score": 15.984613575190915}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t    uint8_t data;\n\n    while (size--) {\n        if (read(pos, &data, 1) != 1) {\n            return false;\n        }\n        if (writing) {\n            if (value) {\n                *value = data;\n            }\n            value++;\n        }\n        if (crc) {\n            *crc = update_crc(*crc, data);\n        }\n        pos++;\n    }\n    return true;\n}", "CodeBleu_score": 50.946048830114336}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t    if (pos < 0)\n        return false;\n    if (size == 0)\n        return true;\n    if (size > (int)m_size - pos)\n        return false;\n    uint8_t *buffer = value;\n    int remaining = size;\n    while (remaining-- > 0) {\n        if (writing) {\n            if (!read_byte(pos, *buffer++))\n                return false;\n        }\n        else {\n            if (!read_byte(pos, *buffer++, true))\n                return false;\n        }\n        if (crc)\n            *crc = crc16_update(*crc, *(buffer - 1));\n    }\n    return true;\n}", "CodeBleu_score": 41.91789468195089}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t    if (pos < 0) {\n        return false;\n    }\n\n    if (pos + size > _size) {\n        return false;\n    }\n\n    for (size_t i = 0; i < size; i++) {\n        uint8_t byte;\n        if (!read_byte(pos, &byte)) {\n            return false;\n        }\n\n        if (writing && value) {\n            value[i] = byte;\n        }\n\n        if (crc) {\n            *crc = update_crc(*crc, byte);\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 44.38181928800378}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t    if (pin >= NUM_DIGITAL_PINS)\n        return;\n\n    // Try to use hardware PWM channels if possible.\n    if (ledc_channel_config_t *channel = ledc_channel_find(pin)) {\n        ledc_set_duty(channel->speed_mode, channel->channel, value);\n        ledc_update_duty(channel->speed_mode, channel->channel);\n        return;\n    }\n\n    // Find a software PWM state for the pin.\n    software_pwm_t *pwm = software_pwm_find(pin);\n    if (!pwm) {\n        // Allocate a new PWM state for the pin.\n        if (!software_pwm_allocate(pin, freq, res))\n            return;\n        pwm = software_pwm_find(pin);\n    }\n\n    // Set the PWM value.\n    pwm->value = value;\n}", "CodeBleu_score": 33.85846101109865}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\n  // check if pin is valid\n  if (pin >= GPIO_PINS_COUNT) {\n    return;\n  }\n\n  // check if pin is PWM capable\n  if (!isPwmPin(pin)) {\n    return;\n  }\n\n  // check if frequency is valid\n  if (freq < 1 || freq > PWM_FREQUENCY) {\n    return;\n  }\n\n  // check if resolution is valid\n  if (res < 1 || res > 16) {\n    return;\n  }\n\n  // check if value is valid\n  if (value > (1 << res) - 1) {\n    return;\n  }\n\n  // check if pin is already used\n  for (uint8_t i = 0; i < PWM_CHANNELS_COUNT; i++) {\n    if (pwmState[i].pin == pin) {\n      // update PWM value\n      pwmState[i].value = value;\n      // update PWM frequency\n      pwmState[i].freq = freq;\n      // update PWM resolution\n      pwmState[i].res = res;\n      // update PWM duty\n      pwmState[i].duty = (uint16_t)(((float)value / (1 << res)) * 1024);\n      // update PWM period\n      pwmState[i].period = (uint32_t)(1024 / (float)freq * 1000);\n      // update PWM timer\n      pwmState[i].timer = (uint8_t)(i / PWM_CHANNELS_PER_TIMER);\n      // update PWM channel\n      pwmState[i].channel = (uint8_t)(i % PWM_CHANNELS_PER_TIMER);\n      // update PWM pin\n      pwmState[i].pin = pin;\n      // update PWM enabled\n      pwmState[i].enabled = true;\n      // update PWM mode\n      pwmState[i].mode = PWM_MODE_PWM;\n      // update PWM type\n      pwmState[i].type = PWM", "CodeBleu_score": 45.01954614152586}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin >= NUM_DIGITAL_PINS) return;\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value == UINT16_MAX) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (value >= (1 << res)) return;\n  if (freq < 1) return;\n  if (freq > 16000000) return;\n  if (res < 1) return;\n  if (res > 15) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL_PINS) return;\n  if (pin >= NUM_DIGITAL", "CodeBleu_score": 28.883810412913146}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(servo_delay) / sizeof(int) == SERVO_CHANNELS, \"Servo delay array size does not match the number of servo channels\");\n  if (servo.attach(pin)) {\n    servo.write(value);\n    delay(servo_delay[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      servo.detach();\n    }\n  }\n}", "CodeBleu_score": 45.88433619774108}, {"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(SERVO_DELAYS) / sizeof(SERVO_DELAYS[0]) == SERVO_CHANNELS,\n                \"SERVO_DELAYS array length must match SERVO_CHANNELS\");\n\n  if (servo.attach(SERVO_PINS[channel])) {\n    servo.write(value);\n    delay(SERVO_DELAYS[channel]);\n\n    if constexpr (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      servo.detach();\n    }\n  }\n}", "CodeBleu_score": 50.064691248039416}, {"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == SERVO_CHANNEL_COUNT,\n                \"Servo delay array length does not match the number of servo channels\");\n\n  if (servo_attached[channel]) {\n    servo_value[channel] = value;\n    Serial.print(\"Servo \");\n    Serial.print(channel);\n    Serial.print(\": \");\n    Serial.println(value);\n\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      detach();\n    }\n  }\n}", "CodeBleu_score": 40.11677881009307}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t  // Iterate over all pins\n  for (uint8_t i = 0; i < NUM_PINS; i++) {\n    // Check if the pin has active PWM\n    if (pwm_duty_cycles[i] > 0) {\n      // Decrement the PWM tick count for the pin\n      pwm_ticks[i]--;\n\n      // If the PWM tick count reaches zero, toggle the pin state\n      if (pwm_ticks[i] == 0) {\n        // Toggle the pin state between high and low\n        if (pins[i].state == HIGH) {\n          pins[i].state = LOW;\n        } else {\n          pins[i].state = HIGH;\n        }\n\n        // Set the tick count for the next transition\n        pwm_ticks[i] = pwm_periods[i] - pwm_duty_cycles[i];\n      }\n    }\n\n    // Store the updated pin state into the current position of the DMA buffer\n    if (pins[i].state == HIGH) {\n      // Set the corresponding bit in the DMA buffer\n      dma_buffer[dma_buffer_pos] |= (1 << i);\n    }\n  }\n\n  // Increment the buffer position\n  dma_buffer_pos++;\n}", "CodeBleu_score": 35.362806069825716}, {"code": "void i2s_push_sample(){\n\t    // Loop through each pin\n    for (int i = 0; i < NUM_PINS; i++) {\n        // Check if the pin has active PWM\n        if (pwm_tick_count[i] > 0) {\n            // Decrement the tick count\n            pwm_tick_count[i]--;\n\n            // If the tick count reaches zero, toggle the pin state\n            if (pwm_tick_count[i] == 0) {\n                // Toggle the pin state\n                if (pin_state[i]) {\n                    pin_state[i] = 0;\n                } else {\n                    pin_state[i] = 1;\n                }\n\n                // Set the tick count for the next transition\n                pwm_tick_count[i] = pwm_period[i];\n            }\n        }\n\n        // Store the updated pin state into the DMA buffer\n        if (pin_state[i]) {\n            i2s_buffer[i2s_buffer_pos] |= (1 << i);\n        } else {\n            i2s_buffer[i2s_buffer_pos] &= ~(1 << i);\n        }\n    }\n\n    // Increment the buffer position\n    i2s_buffer_pos++;\n\n    // If the buffer position reaches the end of the buffer, wrap around to the beginning\n    if (i2s_buffer_pos == I2S_BUFFER_SIZE) {\n        i2s_buffer_pos = 0;\n    }\n}", "CodeBleu_score": 41.52850083898729}, {"code": "void i2s_push_sample(){\n\t    uint32_t port_data = 0;\n    uint32_t pin_mask = 1;\n    uint32_t pin_state = 0;\n    uint32_t pin_tick = 0;\n    uint32_t pin_duty = 0;\n    uint32_t pin_next = 0;\n    uint32_t pin_index = 0;\n    uint32_t pin_count = 0;\n    uint32_t pin_pos = 0;\n    uint32_t pin_pos_mask = 0;\n    uint32_t pin_pos_shift = 0;\n    uint32_t pin_pos_data = 0;\n    uint32_t pin_pos_data_mask = 0;\n    uint32_t pin_pos_data_shift = 0;\n    uint32_t pin_pos_data_mask_shift = 0;\n    uint32_t pin_pos_data_mask_shift_mask = 0;\n    uint32_t pin_pos_data_mask_shift_mask_mask = 0;\n    uint32_t pin_pos_data_mask_shift_mask_mask_mask = 0;\n    uint32_t pin_pos_data_mask_shift_mask_mask_mask_mask = 0;\n    uint32_t pin_pos_data_mask_shift_mask_mask_mask_mask_mask = 0;\n    uint32_t pin_pos_data_mask_shift_mask_mask_mask_mask_mask_mask = 0;\n    uint32_t pin_pos_data_mask_shift_mask_mask_mask_mask_mask_mask_mask = 0;\n    uint32_t pin_pos_data_mask_shift_mask_mask_mask_mask_mask_mask_mask_mask = 0;\n    uint32_t pin_pos_data_mask_shift_mask_mask_mask_mask_mask_mask_mask_mask_mask = 0;\n    uint32_t pin_pos_data_mask_shift_mask_mask_mask_mask_mask_mask_mask_mask_mask_", "CodeBleu_score": 6.188777840648081}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    return (hal_timer_t)HAL_timer_get_count_raw(timer_num);\n}", "CodeBleu_score": 15.782338889693252}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  hal_timer_t timer_count = 0;\n  hal_timer_t *timer_ptr = NULL;\n\n  if (timer_num < HAL_TIMER_MAX_TIMERS) {\n    timer_ptr = &hal_timer_config[timer_num];\n    if (timer_ptr->timer_init_flag == HAL_TIMER_INIT) {\n      if (timer_ptr->timer_mode == HAL_TIMER_MODE_TIMER) {\n        timer_count = timer_ptr->timer_count;\n      } else if (timer_ptr->timer_mode == HAL_TIMER_MODE_COUNTER) {\n        timer_count = timer_ptr->counter_count;\n      }\n    }\n  }\n\n  return timer_count;\n}", "CodeBleu_score": 43.35746690813414}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  hal_timer_t timer_count = 0;\n\n  if (timer_num < HAL_TIMER_NUM) {\n    timer_count = (hal_timer_t)hal_timer_config[timer_num].timer_count;\n  }\n\n  return timer_count;\n}", "CodeBleu_score": 38.57570055215266}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint8_t read_byte;\n  for (size_t i = 0; i < size; i++) {\n    read_byte = eeprom_read_byte(pos);\n    if (writing) {\n      value[i] = read_byte;\n    }\n    *crc = update_crc(*crc, read_byte);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 62.068643122058944}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t    for (size_t i = 0; i < size; i++) {\n        uint8_t data = EEPROM.read(pos + i);\n        *crc = crc16_update(*crc, data);\n        if (writing)\n            value[i] = data;\n    }\n    pos += size;\n    return false;\n}", "CodeBleu_score": 72.43961084597768}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t    for (size_t i = 0; i < size; i++) {\n        uint8_t b = EEPROM.read(pos + i);\n        if (writing) {\n            value[i] = b;\n        }\n        *crc = update_crc(*crc, b);\n    }\n    pos += size;\n    return false;\n}", "CodeBleu_score": 70.59581246091066}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  if (SDIO_Handle == NULL || src == NULL) {\n    return false;\n  }\n\n  uint8_t retry_count = 0;\n  while (retry_count < MAX_RETRIES) {\n    if (SDIO_WriteBlock_Internal(block, src)) {\n      return true;\n    }\n    retry_count++;\n  }\n\n  printf(\"SDIO write block failed after %d retries\n\", MAX_RETRIES);\n  return false;\n}", "CodeBleu_score": 33.08170223687005}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  uint32_t retries = 0;\n  while (retries < SDIO_MAX_RETRIES) {\n    if (SDIO_WriteBlock_Internal(block, src)) {\n      return true;\n    }\n    retries++;\n  }\n  printf(\"SDIO_WriteBlock failed\n\");\n  return false;\n}", "CodeBleu_score": 22.63997991188143}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  uint32_t i;\n\n  /* Check that the SDIO handle and source pointer are not null. */\n  if (sdio == NULL || src == NULL) {\n    return false;\n  }\n\n  /* Try to write the block, retrying up to a defined number of times if the write operation fails. */\n  for (i = 0; i < SDIO_MAX_RETRIES; i++) {\n    if (SDIO_WriteBlock_Internal(block, src) == true) {\n      return true;\n    }\n  }\n\n  /* If all retries fail, print an error message and return false. */\n  printf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n  return false;\n}", "CodeBleu_score": 28.817882951305418}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\n  /*\n   * The function \"HAL_timer_start\" initializes a hardware timer with a specified frequency based on the provided timer channel.", "CodeBleu_score": 16.449735323263713}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  if (timer_num == TEMPERATURE_TIMER) {\n    // Set the temperature timer prescale\n    TIMER_PRESCALE_SET(TEMPERATURE_TIMER_PRESCALE);\n\n    // Start the timer with the given frequency\n    TIMER_START(TEMPERATURE_TIMER, frequency);\n\n    // Set the callback priority for temperature\n    TIMER_CALLBACK_PRIORITY_SET(TEMPERATURE_TIMER, TEMPERATURE_TIMER_CALLBACK_PRIORITY);\n  } else if (timer_num == STEPPER_TIMER) {\n    // Set the stepper timer prescale\n    TIMER_PRESCALE_SET(STEPPER_TIMER_PRESCALE);\n\n    // Start the timer with the given frequency\n    TIMER_START(STEPPER_TIMER, frequency);\n\n    // Set the callback priority for stepper\n    TIMER_CALLBACK_PRIORITY_SET(STEPPER_TIMER, STEPPER_TIMER_CALLBACK_PRIORITY);\n  } else {\n    // Invalid timer channel\n    ASSERT(0);\n  }\n}", "CodeBleu_score": 40.75884589442645}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  if (timer_num == TEMPERATURE_TIMER_CHANNEL) {\n    // Initialize the timer with the given frequency and temperature timer prescale\n    timer_init(TEMPERATURE_TIMER, frequency, TEMPERATURE_TIMER_PRESCALE);\n    // Set the callback priority for temperature\n    timer_set_callback(TEMPERATURE_TIMER, TEMPERATURE_TIMER_CHANNEL, temperature_timer_callback, PRIORITY_TEMPERATURE);\n    // Start the timer\n    timer_start(TEMPERATURE_TIMER, TEMPERATURE_TIMER_CHANNEL);\n  } else if (timer_num == STEPPER_TIMER_CHANNEL) {\n    // Initialize the timer with the given frequency and stepper timer prescale\n    timer_init(STEPPER_TIMER, frequency, STEPPER_TIMER_PRESCALE);\n    // Set the callback priority for stepper\n    timer_set_callback(STEPPER_TIMER, STEPPER_TIMER_CHANNEL, stepper_timer_callback, PRIORITY_STEPPER);\n    // Start the timer\n    timer_start(STEPPER_TIMER, STEPPER_TIMER_CHANNEL);\n  } else {\n    // Trigger an assertion failure if the timer channel is invalid\n    ASSERT(0);\n  }\n}", "CodeBleu_score": 39.961603736476306}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  if (file.open(file_name, O_RDWR | O_CREAT) == false) {\n    return false;\n  }\n\n  if (file.size() < EEPROM_SIZE) {\n    file.write(0, EEPROM_SIZE - file.size());\n  }\n\n  file.read(0, EEPROM_SIZE);\n  file.close();\n  return true;\n}", "CodeBleu_score": 16.173971576193757}, {"code": "bool PersistentStore::access_start(){\n\t  if (file) {\n    file.close();\n  }\n  file = SPIFFS.open(filename, \"r+\");\n  if (!file) {\n    file = SPIFFS.open(filename, \"w+\");\n    if (!file) {\n      return false;\n    }\n    for (uint32_t i = 0; i < EEPROM_SIZE; i++) {\n      file.write(EEPROM_ERASE_VALUE);\n    }\n  }\n  file.seek(0);\n  file.read(buffer, EEPROM_SIZE);\n  return true;\n}", "CodeBleu_score": 31.64899810088989}, {"code": "bool PersistentStore::access_start(){\n\t  if (file == NULL) {\n    file = fopen(filename, \"r+\");\n    if (file == NULL) {\n      file = fopen(filename, \"w+\");\n      if (file == NULL) {\n        return false;\n      }\n    }\n  }\n\n  if (fseek(file, 0, SEEK_END) != 0) {\n    return false;\n  }\n  long size = ftell(file);\n  if (size < 0) {\n    return false;\n  }\n  if (size > EEPROM_SIZE) {\n    return false;\n  }\n  if (size < EEPROM_SIZE) {\n    if (fseek(file, size, SEEK_SET) != 0) {\n      return false;\n    }\n    for (long i = size; i < EEPROM_SIZE; i++) {\n      if (fputc(EEPROM_ERASE, file) == EOF) {\n        return false;\n      }\n    }\n    if (fflush(file) != 0) {\n      return false;\n    }\n  }\n  if (fseek(file, 0, SEEK_SET) != 0) {\n    return false;\n  }\n  if (fread(buffer, 1, EEPROM_SIZE, file) != EEPROM_SIZE) {\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 37.093545582246335}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t r = 0;\n  for (uint8_t i = 0; i < 8; i++) {\n    uint8_t bit = (b & 0x80) ? 1 : 0;\n    HAL_GPIO_STM32_WritePin(SPI_SCK_PIN, 0);\n    HAL_GPIO_STM32_WritePin(SPI_MOSI_PIN, bit);\n    HAL_GPIO_STM32_WritePin(SPI_SCK_PIN, 1);\n    r = (r << 1) | HAL_GPIO_STM32_ReadPin(SPI_MISO_PIN);\n    b <<= 1;\n  }\n  HAL_DELAY_STM32_us(1);\n  return r;\n}", "CodeBleu_score": 47.053717943657524}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    for (uint8_t i = 0; i < 8; i++) {\n        r <<= 1;\n        if (b & 0x80) {\n            GPIO_SET_BIT(GPIO_PORT_SPI_MOSI);\n        } else {\n            GPIO_CLEAR_BIT(GPIO_PORT_SPI_MOSI);\n        }\n        b <<= 1;\n        GPIO_SET_BIT(GPIO_PORT_SPI_SCK);\n        GPIO_CLEAR_BIT(GPIO_PORT_SPI_SCK);\n        if (GPIO_GET_BIT(GPIO_PORT_SPI_MISO)) {\n            r |= 1;\n        }\n    }\n    HAL_SPI_STM32_Delay();\n    return r;\n}", "CodeBleu_score": 43.50720175662435}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t i, r = 0;\n\n  for (i = 0; i < 8; i++) {\n    // Set clock low\n    HAL_GPIO_STM32_SetPin(SPI_CLK_PIN);\n\n    // Write the most significant bit of the byte to MOSI\n    if (b & 0x80) {\n      HAL_GPIO_STM32_SetPin(SPI_MOSI_PIN);\n    } else {\n      HAL_GPIO_STM32_ClearPin(SPI_MOSI_PIN);\n    }\n\n    // Toggle clock high\n    HAL_GPIO_STM32_ClearPin(SPI_CLK_PIN);\n\n    // Read the bit from MISO\n    if (HAL_GPIO_STM32_ReadPin(SPI_MISO_PIN)) {\n      r |= 0x80;\n    }\n\n    // Shift the byte left\n    b <<= 1;\n\n    // Delay to allow the slave to sample the data\n    HAL_DELAY_MS(1);\n  }\n\n  // Return the received byte\n  return r;\n}", "CodeBleu_score": 41.46801325308462}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 49.60985958482258}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 46.64045728127212}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 49.60292079256846}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t    uint8_t c;\n    if (obj->_emergency_parser) {\n        obj->_emergency_parser->rx_char(c);\n    }\n    if (obj->_parity_error) {\n        obj->_parity_error = false;\n        return;\n    }\n    c = obj->_rx_buffer[obj->_rx_buffer_head];\n    obj->_rx_buffer_head = (obj->_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n    obj->_rx_buffer[obj->_rx_buffer_head] = c;\n}", "CodeBleu_score": 44.537566145754695}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t    // read the received byte\n    uint8_t ch = obj->read();\n    // check if we have a parity error\n    if (!obj->parity_error()) {\n        // check if there is space in the buffer\n        if (obj->availableForWrite() > 0) {\n            // store the byte in the buffer\n            obj->write(ch);\n            // update the next buffer index\n            obj->_rx_in = (obj->_rx_in + 1) % obj->_rx_buffer_size;\n            // update the head pointer\n            obj->_rx_head = (obj->_rx_head + 1) % obj->_rx_buffer_size;\n        }\n    }\n    // update the emergency parser with the received byte\n    obj->_emergency_parser.update(ch);\n}", "CodeBleu_score": 37.32966894115184}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t    if (obj->parity_error) {\n        obj->parity_error = false;\n        obj->rx_buffer_overflow = true;\n        return;\n    }\n    if (obj->rx_buffer_overflow) {\n        obj->rx_buffer_overflow = false;\n        return;\n    }\n    uint8_t c = obj->read_register();\n    uint8_t head = obj->rx_head;\n    uint8_t tail = obj->rx_tail;\n    uint8_t next = head + 1;\n    if (next >= RX_BUFFER_SIZE) {\n        next = 0;\n    }\n    if (next == tail) {\n        obj->rx_buffer_overflow = true;\n        return;\n    }\n    obj->rx_buffer[head] = c;\n    obj->rx_head = next;\n    if (obj->emergency_parser) {\n        obj->emergency_parser->rx_char(c);\n    }\n}", "CodeBleu_score": 40.57747136502128}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\n    switch (timer_num) {\n        case MF_TIMER_STEP:\n            attachInterrupt(digitalPinToInterrupt(PIN_TIMER_STEP), Step_Handler, CHANGE);\n            break;\n        case MF_TIMER_TEMP:\n            attachInterrupt(digitalPinToInterrupt(PIN_TIMER_TEMP), Temp_Handler, CHANGE);\n            break;\n        default:\n            break;\n    }\n}", "CodeBleu_score": 42.611767807606974}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\n    if (timer_num == MF_TIMER_STEP) {\n        // attach interrupt handler\n        attachInterrupt(digitalPinToInterrupt(MF_TIMER_STEP_PIN), Step_Handler, CHANGE);\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n        // attach interrupt handler\n        attachInterrupt(digitalPinToInterrupt(MF_TIMER_TEMP_PIN), Temp_Handler, CHANGE);\n    }\n}", "CodeBleu_score": 31.51633100058261}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\n    if (timer_num == MF_TIMER_STEP) {\n        TIMER_STEP_IRQ_ENABLE();\n        TIMER_STEP_IRQ_SET_PRIORITY(0);\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n        TIMER_TEMP_IRQ_ENABLE();\n        TIMER_TEMP_IRQ_SET_PRIORITY(0);\n    }\n}", "CodeBleu_score": 20.375227161777687}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\n\tvar hashsep, hash uint64\n\tfor i := 0; i < len(sep); i++ {\n\t\thashsep = hashsep*prime + uint64(sep[i])\n\t\thash = hash*prime + uint64(s[len(s)-len(sep)+i])\n\t}\n\n\tif hash == hashsep && s[len(s)-len(sep):] == sep {\n\t\treturn len(s) - len(sep)\n\t}\n\n\tvar pow uint64 = 1\n\tfor i := 0; i < len(sep); i++ {\n\t\tpow *= prime\n\t}\n\n\tfor i := len(s) - len(sep) - 1; i >= 0; i-- {\n\t\thash = hash*prime + uint64(s[i]) - pow*uint64(s[i+len(sep)])\n\t\tif hash == hashsep && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}", "CodeBleu_score": 43.44537713849246}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\thash, pow := hash(sep), 1\n\tfor i := len(sep) - 1; i >= 0; i-- {\n\t\thash += uint32(s[i]) * uint32(pow)\n\t\tpow *= base\n\t}\n\tif hash == hash(s[:len(sep)]) && sep == s[len(s)-len(sep):] {\n\t\treturn len(s) - len(sep)\n\t}\n\tvar h uint32\n\tfor i := len(s) - len(sep); i > 0; {\n\t\th = h*base + uint32(s[i+len(sep)-1])\n\t\tif h == hash && sep == s[i:i+len(sep)] {\n\t\t\treturn i\n\t\t}\n\t\th -= uint32(s[i-1]) * pow\n\t\ti--\n\t}\n\treturn -1\n}", "CodeBleu_score": 46.099436739633674}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(s)\n\tm := len(sep)\n\tif m > n || m == 0 {\n\t\treturn -1\n\t}\n\n\thashsep := hash(sep)\n\thash := hash(s[n-m:])\n\tlast := n - m\n\n\tfor i := n - m; i >= 0; i-- {\n\t\tif hash == hashsep && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t\thash = rollingHash(s[i-1], s[i+m-1], hash)\n\t}\n\treturn -1\n}", "CodeBleu_score": 35.503240236820574}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txHead != usbcdc.txTail {\n\t\tusbcdc.waitTxc = false\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 46.4159098810622}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txc != 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 45.079467981252186}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txc > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 44.98714851559838}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.ctrl.Set(i2c.ctrl.Get() &^ avr.I2C_MASK_TWINT)\n\ti2c.ctrl.Set(i2c.ctrl.Get() | avr.I2C_TWSTA)\n\ti2c.ctrl.Set(i2c.ctrl.Get() | avr.I2C_TWEN)\n\n\tfor !i2c.ctrl.HasBits(avr.I2C_TWINT) {\n\t}\n\n\ti2c.addr.Set(address << 1)\n\tif write {\n\t\ti2c.addr.Set(i2c.addr.Get() &^ avr.I2C_TW_READ)\n\t} else {\n\t\ti2c.addr.Set(i2c.addr.Get() | avr.I2C_TW_READ)\n\t}\n\ti2c.ctrl.Set(i2c.ctrl.Get() &^ avr.I2C_TWSTA)\n\ti2c.ctrl.Set(i2c.ctrl.Get() | avr.I2C_TWINT)\n\n\tfor !i2c.ctrl.HasBits(avr.I2C_TWINT) {\n\t}\n}", "CodeBleu_score": 32.361040799676545}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.ctrl.Set(avr.I2C_MASK_MULTI | avr.I2C_MASK_START)\n\ti2c.ctrl.Set(avr.I2C_MASK_START)\n\ti2c.ctrl.Set(avr.I2C_MASK_MULTI)\n\n\tinterrupt.SleepUntil(func() bool {\n\t\treturn i2c.ctrl.Get()&avr.I2C_MASK_IF == 0\n\t})\n\n\ti2c.addr.Set(uint8(address << 1) | avr.I2C_MASK_READ)\n\tif write {\n\t\ti2c.ctrl.Set(avr.I2C_MASK_MULTI)\n\t}\n}", "CodeBleu_score": 30.95094856012124}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.Set(avr.I2C_START_BIT)\n\ti2c.control.Set(avr.I2C_ENABLE_BIT)\n\ti2c.waitForInterrupt()\n\ti2c.bus = (address << 1) | uint8(write)\n\ti2c.control.Set(avr.I2C_ENABLE_BIT)\n}", "CodeBleu_score": 34.91673292545413}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := uint32(f.blockSize) * uint32(start)\n\tendAddr := startAddr + uint32(f.blockSize)*uint32(len)\n\n\tinterrupt.Disable()\n\n\t// wait for flash to be ready\n\tfor nrf.FLASH.Busy() {\n\t}\n\n\t// set flash to erase mode\n\tnrf.FLASH.EraseConfigSet(nrf.FLASH_ERASE_PAGES)\n\n\t// erase blocks\n\tfor addr := startAddr; addr < endAddr; addr += uint32(f.blockSize) {\n\t\tnrf.FLASH.ErasePage(addr)\n\n\t\t// wait for flash to be ready\n\t\tfor nrf.FLASH.Busy() {\n\t\t}\n\t}\n\n\t// set flash to read mode\n\tnrf.FLASH.EraseConfigSet(nrf.FLASH_ERASE_NONE)\n\n\tinterrupt.Enable()\n\n\treturn nil\n}", "CodeBleu_score": 42.074166778236325}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tf.busy()\n\tdefer f.idle()\n\tstartAddr := f.startAddr + uint32(start*f.blockSize)\n\tendAddr := startAddr + uint32(len*f.blockSize)\n\tfor addr := startAddr; addr < endAddr; addr += f.blockSize {\n\t\tnrf.Flash.Erase(addr)\n\t\tnrf.Flash.Wait()\n\t}\n\treturn nil\n}", "CodeBleu_score": 34.49425625793718}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := uint32(f.startAddr) + uint32(start*f.blockSize)\n\tendAddr := startAddr + uint32(len*f.blockSize)\n\n\t// Wait for flash operations to complete.\n\tnrf.FLASH.TASKS_LATCH.Set(1)\n\tnrf.FLASH.TASKS_LATCH.Set(0)\n\n\t// Configure flash for erasing.\n\tnrf.FLASH.CONFIG.Set(nrf.FLASH_CONFIG_WEN_Een)\n\n\t// Erase blocks.\n\tfor addr := startAddr; addr < endAddr; addr += uint32(f.blockSize) {\n\t\tnrf.FLASH.ADDR.Set(addr)\n\t\tnrf.FLASH.TASKS_ERASE.Set(1)\n\t\tfor nrf.FLASH.EVENTS_ERASEEND.Get() == 0 {\n\t\t}\n\t\tnrf.FLASH.EVENTS_ERASEEND.Set(0)\n\t}\n\n\t// Set flash back to read mode.\n\tnrf.FLASH.CONFIG.Set(nrf.FLASH_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 38.86187520096348}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif int64(len(p))+off > int64(f.size) {\n\t\treturn 0, ErrWriteOutOfRange\n\t}\n\n\tstart := f.offset + off\n\tend := start + int64(len(p))\n\n\tif end > int64(f.size) {\n\t\tend = int64(f.size)\n\t}\n\n\tstartBlock := start / f.blockSize\n\tendBlock := end / f.blockSize\n\tstartOffset := start % f.blockSize\n\tendOffset := end % f.blockSize\n\n\tbuf := make([]byte, f.blockSize)\n\tbinary.LittleEndian.PutUint32(buf[0:4], uint32(startBlock))\n\tbinary.LittleEndian.PutUint32(buf[4:8], uint32(endBlock))\n\n\tbinary.LittleEndian.PutUint32(buf[8:12], uint32(startOffset))\n\tbinary.LittleEndian.PutUint32(buf[12:16], uint32(endOffset))\n\n\tbinary.LittleEndian.PutUint32(buf[16:20], uint32(len(p)))\n\tcopy(buf[20:], p)\n\n\tbuf = bytes.Repeat([]byte{0}, int(f.blockSize-uint32(len(buf))))\n\tbuf = append(buf, p...)\n\n\tf.enableWrite()\n\tdefer f.disableWrite()\n\n\tstartAddr := f.addr + uint32(startBlock)*f.blockSize\n\tendAddr := f.addr + uint32(endBlock)*f.blockSize\n\n\tfor addr := startAddr; addr < endAddr; addr += f.blockSize {\n\t\tbinary.LittleEndian.PutUint32(buf[0:4], uint32(addr))\n\n\t\tf.write(buf)\n\t\tf.wait()\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 32.92026400340923}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif int64(len(p)) > f.size-off {\n\t\treturn 0, ErrWriteOutOfRange\n\t}\n\tstart := uint32(off)\n\tend := start + uint32(len(p))\n\tif end > f.size {\n\t\tend = f.size\n\t}\n\tn = int(end - start)\n\tif n == 0 {\n\t\treturn\n\t}\n\n\twriteBlockSize := f.writeBlockSize()\n\twriteBlockCount := (n + writeBlockSize - 1) / writeBlockSize\n\twriteBlockSizeBytes := writeBlockSize * 4\n\twriteBlockCountBytes := writeBlockCount * 4\n\n\tstartAddr := f.start + start\n\tendAddr := startAddr + uint32(n)\n\n\tnrf.SCB.ClearPendingIRQ(nrf.IRQ_FLASH)\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Wen)\n\tnrf.NVMC.READY.Set(0)\n\n\tstartAddrBytes := (*[4]byte)(unsafe.Pointer(&startAddr))\n\tendAddrBytes := (*[4]byte)(unsafe.Pointer(&endAddr))\n\twriteBlockSizeBytesBytes := (*[4]byte)(unsafe.Pointer(&writeBlockSizeBytes))\n\twriteBlockCountBytesBytes := (*[4]byte](unsafe.Pointer(&writeBlockCountBytes)))\n\n\tnrf.NVMC.ERASEPAGE.Set(0)\n\tnrf.NVMC.ERASEPAGE.Set(1)\n\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\tnrf.NVMC.READY.Set(0)\n\n\tnrf.FLASH.TASKS_ERASEPAGE.Set(1)\n\tfor nrf.FLASH.EVENTS_ERASEPAGEEND.Get() == 0 {\n\t}\n\tnrf.FLASH.EVENTS_ERASEPAGEEND.Set(0)\n\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Wen", "CodeBleu_score": 31.275744111538568}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, ErrInvalidWrite\n\t}\n\taddr := uint32(f.base + off)\n\tn = len(p)\n\tif len(p)%f.blockSize != 0 {\n\t\tp = append(p, make([]byte, f.blockSize-len(p)%f.blockSize)...)\n\t}\n\tf.enableWrite()\n\tfor i := 0; i < len(p); i += f.blockSize {\n\t\tnrf.Flash.Store(unsafe.Pointer(uintptr(addr + uint32(i))), binary.LittleEndian.Uint32(p[i:i+4]))\n\t\tinterrupt.AsmFull(interrupt.FLASH_CRITICAL_SECTION_END)\n\t}\n\treturn n, nil\n}", "CodeBleu_score": 33.50827997348565}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tfd2, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdirp, err := syscall.Fdopendir(fd2)\n\t\tif err == nil {\n\t\t\treturn uintptr(fd2), \"\", nil\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(fd2)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 63.840919798169274}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdirp, err := syscall.Fdopendir(fd)\n\tif err != nil {\n\t\tsyscall.Close(fd)\n\t\treturn 0, \"\", &PathError{Op: \"opendir\", Path: \"\", Err: err}\n\t}\n\treturn uintptr(dirp), \"\", nil\n}", "CodeBleu_score": 37.11182907923607}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdirp, err := syscall.Fdopendir(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tdir := uintptr(unsafe.Pointer(dirp))\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 37.47059814622285}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  esp_partition_iterator_t iterator = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_OTA_0, NULL);\n  esp_partition_t *partition = esp_partition_get(iterator);\n  esp_partition_iterator_release(iterator);\n\n  if (partition == NULL) {\n    return 0;\n  }\n\n  uint32_t size = partition->size;\n  if (response == freeSpace) {\n    return size;\n  }\n\n  uint32_t offset = size - 128;\n  uint32_t *ptr = (uint32_t *) (partition->address + offset);\n  uint32_t magic = *ptr;\n  if (magic != 0x534b4354) {\n    return 0;\n  }\n\n  offset -= 4;\n  ptr = (uint32_t *) (partition->address + offset);\n  size = *ptr;\n  return size;\n}", "CodeBleu_score": 41.257011138640536}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n  esp_partition_t *running_partition = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_OTA_0, NULL);\n\n  if (running_partition == NULL) {\n    return 0;\n  }\n\n  if (response == sketchSize_t::sketchSize_t_freeSpace) {\n    return running_partition->size - running_partition->address;\n  }\n\n  return running_partition->size;\n}", "CodeBleu_score": 33.58541253511104}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t *running_partition = esp_ota_get_running_partition();\n\n  if (running_partition == nullptr) {\n    return 0;\n  }\n\n  uint32_t size = running_partition->size;\n\n  if (response == sketchSize_t::SKETCH_SIZE_FREE_SPACE) {\n    size -= running_partition->size;\n  }\n\n  return size;\n}", "CodeBleu_score": 39.326745990056935}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t disk_sectors = (uint32_t) (((sizeof(msc_ram_disk) - 1) / 512) + 1);\n\n    msc_ram_disk = (uint8_t *) malloc(disk_sectors * 512);\n    if (!msc_ram_disk) {\n        log_error(\"Failed to allocate RAM disk\n\");\n        return false;\n    }\n\n    msc_update_boot_sector(volume_label, serial_number, disk_sectors);\n    msc_update_fat(disk_sectors);\n\n    if (running_partition == PARTITION_FIRMWARE) {\n        msc_update_root_directory_entry(disk_sectors);\n    }\n\n    return true;\n}", "CodeBleu_score": 28.19798341330636}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    // Calculate the number of disk sectors required for the RAM disk\n    uint32_t sectors = (RAM_DISK_SIZE + RAM_DISK_SECTOR_SIZE - 1) / RAM_DISK_SECTOR_SIZE;\n\n    // Allocate memory for the RAM disk\n    uint8_t *ram_disk = (uint8_t *)malloc(RAM_DISK_SIZE);\n    if (ram_disk == NULL) {\n        log_error(\"Failed to allocate RAM disk memory\");\n        return false;\n    }\n\n    // Set up the boot sector\n    msc_update_setup_boot_sector(ram_disk, volume_label, serial_number);\n\n    // Set up the file allocation table (FAT)\n    msc_update_setup_fat(ram_disk, sectors);\n\n    // Add a root directory entry for a firmware file if a partition is running\n    if (partition_running) {\n        msc_update_add_root_dir_entry(ram_disk, \"firmware.bin\", 0xFFFFFFFF);\n    }\n\n    return true;\n}", "CodeBleu_score": 33.29299921145124}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\n    uint32_t sectors = ((FIRMWARE_SIZE + SECTOR_SIZE - 1) / SECTOR_SIZE);\n    uint8_t *disk_buffer = malloc(sectors * SECTOR_SIZE);\n\n    if (disk_buffer == NULL) {\n        log_error(\"Failed to allocate memory for MSC disk\");\n        return false;\n    }\n\n    memset(disk_buffer, 0, sectors * SECTOR_SIZE);\n\n    msc_update_setup_boot_sector(disk_buffer, volume_label, serial_number, sectors);\n    msc_update_setup_fat(disk_buffer, sectors);\n\n    if (running_partition == FIRMWARE_PARTITION) {\n        msc_update_add_firmware_file(disk_buffer);\n    }\n\n    return true;\n}", "CodeBleu_score": 28.978084061980603}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    if (offset % ESP_PARTITION_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"offset %08x is not sector aligned\", offset);\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    esp_err_t err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase sector at offset 0x%08x, %s\", offset, esp_err_to_name(err));\n        return err;\n    }\n\n    return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 56.14014294044167}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n\n    if (offset % partition->flash_size != 0) {\n        ESP_LOGE(TAG, \"offset 0x%x is not aligned with flash sector size 0x%x\", offset, partition->flash_size);\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    if (size % partition->flash_size != 0) {\n        ESP_LOGE(TAG, \"size 0x%x is not aligned with flash sector size 0x%x\", size, partition->flash_size);\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    if (offset % partition->flash_size == 0) {\n        err = esp_partition_erase_range(partition, offset, size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"failed to erase sector at offset 0x%x\", offset);\n            return err;\n        }\n    }\n\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"failed to write data to partition %s at offset 0x%x\", partition->label, offset);\n    }\n\n    return err;\n}", "CodeBleu_score": 55.26561793179143}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    if (offset % partition->flash_size != 0) {\n        ESP_LOGE(TAG, \"Offset is not aligned with flash sector size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    esp_err_t err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase sector at offset %08x, %s\", offset, esp_err_to_name(err));\n        return err;\n    }\n\n    return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 55.63932655166365}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t outlen = 0;\n  while (maxlen > 0 && *in) {\n    if (*in >= '0' && *in <= '9') {\n      *out = *out * 16 + *in - '0';\n    } else if (*in >= 'A' && *in <= 'F') {\n      *out = *out * 16 + *in - 'A' + 10;\n    } else if (*in >= 'a' && *in <= 'f') {\n      *out = *out * 16 + *in - 'a' + 10;\n    } else {\n      return outlen;\n    }\n    in++;\n    if (++outlen > maxlen) {\n      return outlen;\n    }\n    out++;\n  }\n  return outlen;\n}", "CodeBleu_score": 39.58225997742092}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i, j;\n  uint8_t v;\n\n  for (i = 0, j = 0; i < strlen(in) && j < maxlen; i += 2, j++) {\n    if (in[i] >= '0' && in[i] <= '9') {\n      v = in[i] - '0';\n    } else if (in[i] >= 'a' && in[i] <= 'f') {\n      v = in[i] - 'a' + 10;\n    } else if (in[i] >= 'A' && in[i] <= 'F') {\n      v = in[i] - 'A' + 10;\n    } else {\n      break;\n    }\n    v <<= 4;\n    if (in[i + 1] >= '0' && in[i + 1] <= '9') {\n      v |= in[i + 1] - '0';\n    } else if (in[i + 1] >= 'a' && in[i + 1] <= 'f') {\n      v |= in[i + 1] - 'a' + 10;\n    } else if (in[i + 1] >= 'A' && in[i + 1] <= 'F') {\n      v |= in[i + 1] - 'A' + 10;\n    } else {\n      break;\n    }\n    out[j] = v;\n  }\n  return j;\n}", "CodeBleu_score": 41.01999671449701}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i = 0;\n    while (*in && i < maxlen) {\n        unsigned char c = *in++;\n        if (c >= '0' && c <= '9') {\n            c -= '0';\n        } else if (c >= 'a' && c <= 'f') {\n            c -= 'a' - 10;\n        } else if (c >= 'A' && c <= 'F') {\n            c -= 'A' - 10;\n        } else {\n            continue;\n        }\n        if (i & 1) {\n            out[i >> 1] = (out[i >> 1] << 4) | c;\n        } else {\n            out[i >> 1] = c;\n        }\n        i++;\n    }\n    return i >> 1;\n}", "CodeBleu_score": 51.24957275078139}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t    int freeSize = 0;\n\n    if (txRingBuffer == NULL || txLock == NULL) {\n        return 0;\n    }\n\n    if (xSemaphoreTake(txLock, 1000) == pdTRUE) {\n        freeSize = xRingbufferGetFreeSize(txRingBuffer);\n        xSemaphoreGive(txLock);\n    }\n\n    return freeSize;\n}", "CodeBleu_score": 59.92478948120865}, {"code": "int HWCDC::availableForWrite(void){\n\t\n\tif (!tx_ring_buffer) {\n\t\treturn 0;\n\t}\n\n\tif (!tx_ring_buffer_lock) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(tx_ring_buffer_lock, 1000) == pdTRUE) {\n\t\tint free_size = tx_ring_buffer->availableForWrite();\n\t\txSemaphoreGive(tx_ring_buffer_lock);\n\t\treturn free_size;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.169173734365636}, {"code": "int HWCDC::availableForWrite(void){\n\t    if (!_tx_buffer || !_tx_lock) {\n        return 0;\n    }\n\n    if (!xSemaphoreTake(_tx_lock, USB_TX_LOCK_TIMEOUT)) {\n        return 0;\n    }\n\n    int free = _tx_buffer->availableForWrite();\n    xSemaphoreGive(_tx_lock);\n\n    return free;\n}", "CodeBleu_score": 52.157748606467614}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  if (function == NULL) {\n    return;\n  }\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  uart_set_fifo_full_thresh(_uart_num, 1);\n  if (!_eventTask) {\n    xTaskCreate(eventTaskCode, \"eventTask\", 256, this, 1, &_eventTask);\n  }\n}", "CodeBleu_score": 32.76793167938202}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  lock();\n  _onReceiveCB = function;\n  _rxTimeout = onlyOnTimeout;\n  uart_set_fifo_full_thresh(_port, UART_FIFO_LEN, UART_FIFO_LEVEL_8_BITS);\n  if (_onReceiveTask == NULL) {\n    _onReceiveTask = xTaskCreate(onReceiveTask, \"onReceiveTask\", 256, this, 2, NULL);\n  }\n  unlock();\n}", "CodeBleu_score": 41.31308065075397}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t    lock();\n    _onReceiveCB = function;\n    _onlyOnTimeout = onlyOnTimeout;\n    if (_onReceiveCB) {\n        uart_set_fifo_full_thresh(_uart_num, 0x7FF);\n        if (!_eventTask) {\n            xTaskCreate(_eventTaskCode, \"uart_event\", 256, this, 10, &_eventTask);\n        }\n    }\n    unlock();\n}", "CodeBleu_score": 41.119458612380825}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if (length < 1) {\n        return 0;\n    }\n\n    size_t index = 0;\n    while (index < length) {\n        int c = read();\n        if (c < 0) {\n            break;\n        }\n        *buffer++ = c;\n        index++;\n        if (c == terminator) {\n            break;\n        }\n    }\n    return index;\n}", "CodeBleu_score": 83.46489530356575}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    buffer[index++] = (char)c;\n    if (c == terminator) {\n      break;\n    }\n  }\n\n  return index;\n}", "CodeBleu_score": 80.48551079539747}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if (length < 1) {\n        return 0;\n    }\n    size_t index = 0;\n    while (index < length) {\n        int c = read();\n        if (c < 0) {\n            break;\n        }\n        *buffer++ = c;\n        index++;\n        if (c == terminator) {\n            break;\n        }\n    }\n    return index;\n}", "CodeBleu_score": 83.46489530356575}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  Serial.print(\"tone(pin=\");\n  Serial.print(pin);\n  Serial.print(\", frequency=\");\n  Serial.print(frequency);\n  Serial.print(\", duration=\");\n  Serial.print(duration);\n  Serial.println(\")\");\n\n  if (ledc_get_duty(LEDC_HIGH_SPEED_MODE, pin) > 0) {\n    Serial.print(\"Pin \");\n    Serial.print(pin);\n    Serial.println(\" is already in use\");\n    return;\n  }\n\n  ledc_channel_config_t channel = {\n    .gpio_num = pin,\n    .speed_mode = LEDC_HIGH_SPEED_MODE,\n    .channel = pin,\n    .intr_type = LEDC_INTR_DISABLE,\n    .timer_sel = LEDC_TIMER_0,\n    .duty = 0,\n    .hpoint = 0\n  };\n\n  ledc_channel_config(&channel);\n\n  ledc_set_duty(LEDC_HIGH_SPEED_MODE, pin, 1023);\n\n  ledc_update_duty(LEDC_HIGH_SPEED_MODE, pin);\n\n  ledc_timer_config_t timer = {\n    .speed_mode = LEDC_HIGH_SPEED_MODE,\n    .duty_resolution = LEDC_TIMER_13_BIT,\n    .timer_num = LEDC_TIMER_0,\n    .freq_hz = 1000,\n    .clk_cfg = LEDC_AUTO_CLK\n  };\n\n  ledc_timer_config(&timer);\n\n  QueueHandle_t queue = xQueueCreate(10, sizeof(tone_command_t));\n\n  tone_command_t command = {\n    .pin = pin,\n    .frequency = frequency,\n    .duration = duration\n  };\n\n  xQueueSend(queue, &command, 0);\n}", "CodeBleu_score": 45.95421311664343}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  Serial.print(\"Tone on pin \");\n  Serial.print(pin);\n  Serial.print(\" with frequency \");\n  Serial.print(frequency);\n  Serial.print(\" and duration \");\n  Serial.println(duration);\n\n  // Check if the pin is available\n  if (ledc_get_freq(LEDC_HIGH_SPEED_MODE, pin) == 0) {\n    // Initialize the tone\n    ledc_timer_config_t timer_conf = {\n      .speed_mode = LEDC_HIGH_SPEED_MODE,\n      .duty_resolution = LEDC_TIMER_10_BIT,\n      .timer_num = pin,\n      .freq_hz = frequency,\n      .clk_cfg = LEDC_AUTO_CLK\n    };\n    ledc_timer_config(&timer_conf);\n\n    ledc_channel_config_t channel_conf = {\n      .gpio_num = pin,\n      .speed_mode = LEDC_HIGH_SPEED_MODE,\n      .channel = pin,\n      .timer_sel = pin,\n      .duty = 512,\n      .hpoint = 0\n    };\n    ledc_channel_config(&channel_conf);\n\n    // Send a start command to the queue\n    tone_command_t command = {\n      .command = TONE_START,\n      .pin = pin,\n      .frequency = frequency,\n      .duration = duration\n    };\n    xQueueSend(tone_queue, &command, 0);\n  } else {\n    // Log an error message\n    Serial.print(\"Pin \");\n    Serial.print(pin);\n    Serial.println(\" is already in use\");\n  }\n}", "CodeBleu_score": 49.45944907518089}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    Serial.print(\"tone: pin: \");\n    Serial.print(pin);\n    Serial.print(\", frequency: \");\n    Serial.print(frequency);\n    Serial.print(\", duration: \");\n    Serial.println(duration);\n\n    if (ledcRead(LEDC_CHANNEL_0 + pin)) {\n        Serial.print(\"tone: pin \");\n        Serial.print(pin);\n        Serial.println(\" is already in use\");\n        return;\n    }\n\n    ledcAttachPin(pin, LEDC_CHANNEL_0 + pin);\n    ledcWriteTone(LEDC_CHANNEL_0 + pin, frequency);\n\n    QueueHandle_t queue = xQueueCreate(10, sizeof(int));\n\n    xQueueSend(queue, &pin, portMAX_DELAY);\n    xQueueSend(queue, &frequency, portMAX_DELAY);\n    xQueueSend(queue, &duration, portMAX_DELAY);\n\n    xQueueSend(queue, &1, portMAX_DELAY);\n\n    vQueueDelete(queue);\n}", "CodeBleu_score": 41.29429802214033}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (started) {\n        if (enabled) {\n            if (usb_version() < 0x0210) {\n                return false;\n            }\n            usb_set_webusb_enabled(true);\n        }\n        usb_set_webusb_enabled(enabled);\n        return false;\n    }\n    webusb_enabled = enabled;\n    return true;\n}", "CodeBleu_score": 37.109615739448955}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (!_usbStarted) {\n        _webUsbEnabled = enabled;\n        if (enabled) {\n            if (_usbVersion < 0x0210) {\n                _usbVersion = 0x0210;\n            }\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 53.37532118498888}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!started) {\n    webUSBBool = enabled;\n    return true;\n  } else {\n    if (enabled) {\n      if (usbVersion < 0x0210) {\n        return false;\n      }\n    }\n    return true;\n  }\n}", "CodeBleu_score": 38.28912810553074}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t  int count = this->_cdc->available();\n  if (count) {\n    if (this->_rxQueue.availableForStore() < count) {\n      this->_rxQueue.flush();\n      this->_rxQueue.postOverflow(count);\n      this->_log->error(F(\"USB CDC RX overflow\"));\n    } else {\n      while (count--) {\n        this->_rxQueue.post(this->_cdc->read());\n      }\n      this->_rxQueue.postReceive(count);\n    }\n  }\n}", "CodeBleu_score": 13.022576767187397}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t data[64];\n\tuint32_t len = USBCDC::_usb->read(data, 64);\n\tif (len > 0) {\n\t\tif (USBCDC::_rxQueue.write(data, len)) {\n\t\t\tUSBCDC::_rxEvent.post(len);\n\t\t} else {\n\t\t\tUSBCDC::_rxOverflowEvent.post(len);\n\t\t\tUSBCDC::_logger->log(LogLevel::WARN, \"USBCDC::_onRX: Overflow occurred\");\n\t\t}\n\t}\n}", "CodeBleu_score": 9.281252852710956}, {"code": "void USBCDC::_onRX(){\n\t    uint8_t b;\n    while (true) {\n        if (USB.available()) {\n            b = USB.read();\n            if (b != USB_SERIAL_CONTROL_LINE_STATE_DTR && b != USB_SERIAL_CONTROL_LINE_STATE_RTS) {\n                if (this->_rxQueue.write(b)) {\n                    this->_onReceive(1);\n                } else {\n                    this->_onReceiveError(1, USBCDC::RECEIVE_QUEUE_OVERFLOW);\n                }\n            }\n        } else {\n            break;\n        }\n    }\n}", "CodeBleu_score": 15.026784908697655}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\ta.mutex.RLock()\n\tdefer a.mutex.RUnlock()\n\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\ta.writeJSON(res, map[string]string{\"error\": fmt.Sprintf(\"no robot found with name %s\", robotName)})\n\t\treturn\n\t}\n\n\tdevices := robot.Devices()\n\n\ta.writeJSON(res, devices)\n}", "CodeBleu_score": 27.632377406982034}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\":name\")\n\trobot := a.robots[name]\n\tif robot == nil {\n\t\ta.writeJSONResponse(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name \" + name})\n\t\treturn\n\t}\n\n\tdevices := robot.Devices()\n\ta.writeJSONResponse(res, http.StatusOK, devices)\n}", "CodeBleu_score": 32.23201740528729}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tname := req.URL.Query().Get(\":name\")\n\trobot := a.robot(name)\n\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": fmt.Sprintf(\"no robot named %s found\", name)})\n\t\treturn\n\t}\n\n\tdevices := a.devices(robot)\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 31.842753081454756}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobotName = strings.TrimSuffix(robotName, \"/connections\")\n\trobot, ok := a.robotManager.Robot(robotName)\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with the name %s was found\", robotName)\n\t\treturn\n\t}\n\n\tconnections := []robeaux.Connection{}\n\tfor _, c := range robot.Connections() {\n\t\tconnections = append(connections, robeaux.Connection{\n\t\t\tName: c.Name(),\n\t\t\tPort: c.Port(),\n\t\t})\n\t}\n\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 41.18217973805242}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobotName = strings.TrimSuffix(robotName, \"/connections\")\n\trobot := a.robotByName(robotName)\n\tif robot == nil {\n\t\ta.NotFound(res, req)\n\t\treturn\n\t}\n\n\tconnections := []robeaux.Connection{}\n\tfor _, c := range robot.Connections() {\n\t\tconnections = append(connections, robeaux.Connection{\n\t\t\tName:         c.Name(),\n\t\t\tPort:         c.Port(),\n\t\t\tAdaptorName:  c.Adaptor().Name(),\n\t\t\tDriverName:   c.Driver().Name(),\n\t\t\tInitialized:  c.Driver().Initialized,\n\t\t\tConnected:    c.Driver().Connected,\n\t\t\tHalted:       c.Driver().Halted,\n\t\t\tOperating:    c.Driver().Operating,\n\t\t\tDefaultName:  c.Driver().DefaultName,\n\t\t\tDefaultPort:  c.Driver().DefaultPort,\n\t\t\tDefaultEvent: c.Driver().DefaultEvent,\n\t\t})\n\t}\n\n\tjson, err := json.Marshal(connections)\n\tif err != nil {\n\t\ta.NotFound(res, req)\n\t\treturn\n\t}\n\n\ta.Write(res, json)\n}", "CodeBleu_score": 37.75466217660379}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\":name\")\n\tif r := a.robot(name); r != nil {\n\t\tconnections := []robeaux.Connection{}\n\t\tfor _, c := range r.Connections() {\n\t\t\tconnections = append(connections, robeaux.Connection{\n\t\t\t\tName: c.Name(),\n\t\t\t\tPort: c.Port(),\n\t\t\t})\n\t\t}\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tjson.NewEncoder(res).Encode(connections)\n\t} else {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"no robot with name %s\", name)))\n\t}\n}", "CodeBleu_score": 49.628741679952384}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\n\trobot := a.robotByName(robotName)\n\tif robot == nil {\n\t\ta.writeError(res, fmt.Errorf(\"robot not found: %s\", robotName))\n\t\treturn\n\t}\n\n\tdevice := robot.DeviceByName(deviceName)\n\tif device == nil {\n\t\ta.writeError(res, fmt.Errorf(\"device not found: %s\", deviceName))\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\":command\")\n\targs := req.URL.Query()[\"args\"]\n\n\tlog.Printf(\"Executing command %s on device %s\", command, deviceName)\n\n\t_, err := device.Command(command).(func(params ...interface{}) (interface{}, error))(args...)\n\tif err != nil {\n\t\ta.writeError(res, err)\n\t\treturn\n\t}\n\n\ta.writeJSON(res, map[string]interface{}{\n\t\t\"success\": true,\n\t})\n}", "CodeBleu_score": 52.753492959217226}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\trobot := a.robotByName(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": fmt.Sprintf(\"robot %s not found\", robotName)})\n\t\treturn\n\t}\n\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": fmt.Sprintf(\"device %s not found\", deviceName)})\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\"command\")\n\n\tswitch command {\n\tcase \"On\":\n\t\tdevice.(*gobot.LedDriver).On()\n\tcase \"Off\":\n\t\tdevice.(*gobot.LedDriver).Off()\n\tcase \"Toggle\":\n\t\tdevice.(*gobot.LedDriver).Toggle()\n\tcase \"Brightness\":\n\t\tbrightness := req.URL.Query().Get(\"brightness\")\n\t\tdevice.(*gobot.LedDriver).Brightness(uint8(a.parseInt(brightness)))\n\tcase \"Start\":\n\t\tdevice.(*gobot.ServoDriver).Start()\n\tcase \"Stop\":\n\t\tdevice.(*gobot.ServoDriver).Stop()\n\tcase \"Move\":\n\t\tangle := req.URL.Query().Get(\"angle\")\n\t\tdevice.(*gobot.ServoDriver).Move(uint8(a.parseInt(angle)))\n\tcase \"Tilt\":\n\t\tpan := req.URL.Query().Get(\"pan\")\n\t\ttilt := req.URL.Query().Get(\"tilt\")\n\t\tdevice.(*robeaux.ServoDriver).Tilt(uint8(a.parseInt(pan)), uint8(a.parseInt(tilt)))\n\tcase \"Trigger\":\n\t\tdevice.(*robeaux.ServoDriver).Trigger()\n\t}\n\n\ta.writeJSON(res, http.StatusOK, map[string]string", "CodeBleu_score": 44.70756404883558}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robotName\")\n\tdeviceName := req.URL.Query().Get(\":deviceName\")\n\tcommand := req.URL.Query().Get(\":command\")\n\n\trobot := a.robotByName(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": fmt.Sprintf(\"Robot %s not found\", robotName)}, http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": fmt.Sprintf(\"Device %s not found\", deviceName)}, http.StatusNotFound)\n\t\treturn\n\t}\n\n\tlog.Printf(\"Executing command %s on device %s\", command, deviceName)\n\n\tresult, err := device.Command(command).(func(map[string]interface{}) (map[string]interface{}, error))(nil)\n\tif err != nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": err.Error()}, http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\ta.writeJSON(res, result, http.StatusOK)\n}", "CodeBleu_score": 51.9410219411107}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauth = auth[len(\"Basic \"):]\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := [][]byte(nil)\n\t\tfor _, p := range bytes.Split(payload, []byte(\":\")) {\n\t\t\tpair = append(pair, p)\n\t\t}\n\n\t\tif len(pair) != 2 || !bytes.Equal(pair[0], []byte(username)) || !bytes.Equal(pair[1], []byte(password)) {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 50.06934221540775}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := r.Header.Get(\"Authorization\")\n\t\tif s == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := make([]string, 2)\n\t\tpair = append(pair, string(b))\n\n\t\tpair = append(pair, \":\")\n\t\tpair = append(pair, password)\n\n\t\tpair = append(pair, \":\")\n\t\tpair = append(pair, username)\n\n\t\tif subtle.ConstantTimeCompare([]byte(pair[0]), []byte(pair[1])) != 1 || subtle.ConstantTimeCompare([]byte(pair[2]), []byte(pair[3])) != 1 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.74223636770291}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := []byte(username + \":\" + password)\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\texpected := \"Basic \" + base64.StdEncoding.EncodeToString(s)\n\n\t\tif subtle.ConstantTimeCompare([]byte(auth), []byte(expected)) != 1 {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 56.05852322527116}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\n\tif !a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, fmt.Errorf(\"%v does not support analog reading\", a.name)\n\t}\n\n\traw, err := a.connection.ReadAnalog(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw)\n\tif a.config.Scale != 0 {\n\t\tscaled = float64(raw) * a.config.Scale\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 53.32819463483997}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.connection.ReadAnalog(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw)\n\tif a.config.Scale != 0 {\n\t\tscaled = float64(raw) * a.config.Scale\n\t}\n\n\ta.lastRead = time.Now()\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 54.83638781146153}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.connection.ReadAnalog(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscale := a.Scale()\n\tscaled := float64(raw) * scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.52205682433}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tname:         gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:          pin,\n\t\tanalogReader: a,\n\t\tconnection:   a.Connection(),\n\t\th:            make(Events),\n\t}\n\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase Eventer:\n\t\t\td.AddEvent(opt.(Eventer).Event())\n\t\tcase string:\n\t\t\td.name = opt.(string)\n\t\t}\n\t}\n\n\treturn d\n}", "CodeBleu_score": 37.00202164155621}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               gobot.DefaultName(\"GroveSoundSensor\"),\n\t}\n\n\tg.AddEvent(Data)\n\n\treturn g\n}", "CodeBleu_score": 45.095016260503684}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               gobot.DefaultName(\"GroveSoundSensor\"),\n\t}\n}", "CodeBleu_score": 45.84196667511645}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeReg(0x01, 0x0F) // Soft reset command\n\n\t// Wait for the soft reset to complete\n\ttime.Sleep(15 * time.Millisecond)\n\n\t// Read the command register to check if the soft reset completed\n\tstatus, err := d.readReg(0x01)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the power-down bit is still set\n\tif status&0x08 != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.93140881291006}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write the command to the command register\n\td.writeRegister(CommandReg, SoftReset)\n\n\t// Wait for the initialization time\n\ttime.Sleep(15 * time.Millisecond)\n\n\t// Read the command register to check the status\n\tstatus, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the power-down bit is still set\n\tif status&0x01 == 0 {\n\t\treturn fmt.Errorf(\"soft reset failed: initialization took too long\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 52.61537066202712}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(CommandReg, SoftReset)\n\ttime.Sleep(15 * time.Millisecond)\n\tstatus, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status&0x01 != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.91480872634966}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check the number of bytes available in the FIFO\n\tbytesAvailable, err := d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the number of bytes available matches the expected length of the byte slice\n\tif bytesAvailable != len(backData) {\n\t\treturn 0, fmt.Errorf(\"expected %d bytes, got %d\", len(backData), bytesAvailable)\n\t}\n\n\t// Read each byte from the FIFO into the byte slice\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tcontrol, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn control & 0x07, nil\n}", "CodeBleu_score": 50.602864568474615}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tnumOfBytes, err := d.GetNumOfBytesInFifo()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif numOfBytes != len(backData) {\n\t\treturn 0, fmt.Errorf(\"numOfBytes != len(backData)\")\n\t}\n\n\td.WriteReg(FIFODataReg, backData)\n\tlastBits := d.ReadReg(ControlReg) & 0x07\n\treturn lastBits, nil\n}", "CodeBleu_score": 27.376338429607078}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tlen, err := d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"fifo length is %d, but expected %d\", len, len(backData))\n\t}\n\t_, err = d.readRegister(FIFODataReg, backData)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tcontrol, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn control & 0x07, nil\n}", "CodeBleu_score": 50.895721920236035}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Log debug message if debugging is enabled\n\tif d.debug {\n\t\tfmt.Println(\"Halting PICC...\")\n\t}\n\n\t// Create a halt command\n\tcommand := []byte{0x50, 0x00, 0x00, 0x00, 0x00}\n\n\t// Calculate the CRC for the command\n\tcrc := d.calcCRC(command)\n\n\t// Append the CRC result to the command\n\tcommand = append(command, crc...)\n\n\t// Send the halt command to the PICC\n\terr := d.sendCommand(command, 0x00)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Expect an error to indicate successful halting\n\terr = d.waitForACK()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the halt is successful, return nil\n\treturn nil\n}", "CodeBleu_score": 38.92335755645659}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"Halting PICC\")\n\t}\n\tcommand := []byte{0x50, 0x00, 0x00, 0x00, 0x00}\n\tcrc := d.calculateCRC(command)\n\tcommand = append(command, crc[0], crc[1])\n\t_, err := d.device.Write(command)\n\tif err != nil {\n\t\treturn err\n\t}\n\tresponse, err := d.device.Read(6)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif response[0] != 0x00 || response[1] != 0x00 || response[2] != 0x00 || response[3] != 0x00 || response[4] != 0x00 {\n\t\treturn fmt.Errorf(\"Halt failed\")\n\t}\n\tif d.debug {\n\t\tfmt.Println(\"PICC halted\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 46.165201206676656}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.DebugLog(\"piccHalt\")\n\thaltCommand := []byte{0x50, 0x00, 0x00, 0x00, 0x00}\n\tcrc := d.calculateCRC(haltCommand)\n\thaltCommand = append(haltCommand, crc...)\n\t_, err := d.Write(haltCommand)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"piccHalt: %v\", err)\n\t}\n\t_, err = d.Read(5)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"piccHalt: %v\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 41.95401656811457}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\n\tbuf := make([]byte, 18)\n\tbuf[0] = 0xFF\n\tbuf[1] = 0xCA\n\tbuf[2] = 0x00\n\tbuf[3] = 0x04\n\tbuf[4] = 0x08\n\tbuf[5] = block\n\tbuf[6] = 0x00\n\n\tcrc := d.calcCRC(buf[0:7])\n\tbuf[7] = crc[0]\n\tbuf[8] = crc[1]\n\n\terr := d.write(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata, err := d.read()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif data[0] != 0x90 || data[1] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"piccRead: error reading block %d\", block)\n\t}\n\n\treturn data[6:16], nil\n}", "CodeBleu_score": 33.727246199727986}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tdata := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n\tdata[0] = 0xFF\n\tdata[1] = 0xCA\n\tdata[2] = 0x00\n\tdata[3] = 0x00\n\tdata[4] = block\n\n\tdata = append(data, d.calcCRC(data)...)\n\t_, err := d.MFRC522.Write(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata, err = d.MFRC522.Read(18)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif data[0] != 0xFF {\n\t\treturn nil, fmt.Errorf(\"invalid response\")\n\t}\n\n\tif data[1] != 0xCA {\n\t\treturn nil, fmt.Errorf(\"invalid response\")\n\t}\n\n\tif data[2] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"invalid response\")\n\t}\n\n\tif data[3] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"invalid response\")\n\t}\n\n\tif data[4] != block {\n\t\treturn nil, fmt.Errorf(\"invalid response\")\n\t}\n\n\treturn data[5:16], nil\n}", "CodeBleu_score": 35.360815108494236}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Construct the read command\n\tcommand := []byte{0xFF, 0xB0, block, 0x00, 0x00, 0x00}\n\n\t// Calculate the CRC for the command\n\tcrc := d.calcCRC(command)\n\n\t// Append the CRC to the command\n\tcommand = append(command, crc...)\n\n\t// Communicate with the RFID card using the command\n\t_, err := d.Write(command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the response from the RFID card\n\tresponse, err := d.Read()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the response for errors\n\tif response[0] != 0x90 || response[1] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"MFRC522 read error: %v\", response)\n\t}\n\n\t// Extract the data from the response\n\tdata := response[6:22]\n\n\treturn data, nil\n}", "CodeBleu_score": 47.13057208355262}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t\n\t// Check if the answer buffer has at least 2 bytes of space.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer has insufficient space\")\n\t}\n\n\t// Clear collision register.\n\td.writeRegister(CollReg, 0x80)\n\n\t// Set transmission to use only 7 bits of the last byte.\n\tif reqMode & 0x07 == 0 {\n\t\td.writeRegister(TxLastBitsReg, 0x07)\n\t} else {\n\t\td.writeRegister(TxLastBitsReg, 0x00)\n\t}\n\n\t// Communicate with the PICC using the transceive command.\n\t_, err := d.transceive(reqMode, answer)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"transceive error: %v\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.914674567720695}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer must be at least 2 bytes\")\n\t}\n\n\t// Clear collision register\n\td.WriteRegister(CollReg, 0x80)\n\n\t// Set transmission bits\n\tif reqMode == PiccRequestAlive {\n\t\td.WriteRegister(CommIEnReg, 0x10)\n\t} else {\n\t\td.WriteRegister(CommIEnReg, 0x00)\n\t}\n\n\t// Write the request command to the FIFO buffer\n\td.WriteRegister(FIFOLevelReg, 0x80)\n\td.WriteRegister(FIFODataReg, reqMode)\n\n\t// Execute the command\n\td.WriteRegister(CommandReg, PiccGoToReqIDl)\n\n\t// Wait for the command to complete\n\tfor {\n\t\tstatus, _ := d.ReadRegister(CommIEnReg)\n\t\tif status&0x01 != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Read the response into the answer buffer\n\tsize, err := d.ReadRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif size > uint8(len(answer)) {\n\t\treturn fmt.Errorf(\"answer buffer is too small\")\n\t}\n\td.ReadRegister(FIFODataReg, answer[:size])\n\n\t// Return any errors encountered during the process\n\treturn nil\n}", "CodeBleu_score": 53.35118220668381}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\td.ClearBitMask(d.Status2Reg, 0x08) // Clear MFRC522_STATUS2_REQ_IDLE_IRQ\n\n\td.Write(d.BitFramingReg, 0x80) // Start bit\n\td.Write(d.BitFramingReg, 0x08) // TxLastBists = BitFramingReg[2..0]\n\n\td.Write(d.CommandReg, reqMode)\n\n\ti := uint8(0)\n\tfor i < 100 {\n\t\ti++\n\t\tstatus, err := d.Read(d.Status1Reg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif status&0x01 != 0 { // MFRC522_STATUS1_IDLE_STATE\n\t\t\tbreak\n\t\t}\n\t}\n\tif i >= 100 {\n\t\treturn fmt.Errorf(\"piccRequest: timeout\")\n\t}\n\n\tsize := len(answer)\n\ti = 4\n\tlastBits := reqMode & 0x07\n\tif lastBits != 0 {\n\t\ti--\n\t}\n\tfor i > 0 {\n\t\tval, err := d.Read(d.FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tanswer[size-i] = val\n\t\ti--\n\t}\n\n\tif lastBits != 0 {\n\t\tval, err := d.Read(d.ControlReg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tval &= 0x07\n\t\tval <<= 4\n\t\tval |= lastBits\n\t\tanswer[0] = val\n\t}\n\n\td.ClearBitMask(d.CollReg, 0x80) // CRC_A valid\n\n\treturn nil\n}", "CodeBleu_score": 47.00664146927743}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a valid step by setting the step pin low, waiting for a delay, and setting the step pin high.\n\tif d.stepPin == nil {\n\t\treturn fmt.Errorf(\"step pin not set\")\n\t}\n\n\tif err := d.stepPin.DigitalWrite(0); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\tif err := d.stepPin.DigitalWrite(1); err != nil {\n\t\treturn err\n\t}\n\n\t// Depending on the direction, increment or decrement the step number.\n\tif d.direction == \"forward\" {\n\t\td.stepNumber++\n\t} else if d.direction == \"backward\" {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 61.58582743540154}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.board.DigitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.delay)\n\n\terr = d.board.DigitalWrite(d.stepPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == \"cw\" {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 67.58994133313396}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.stepPin.DigitalWrite(0); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.delay)\n\n\tif err := d.stepPin.DigitalWrite(1); err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == \"CW\" {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 64.60892650262115}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.stopDistanceMonitor = make(chan bool)\n\td.wg.Add(1)\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopDistanceMonitor:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.Distance()\n\t\t\t\tif err != nil {\n\t\t\t\t\td.logger.Error(err.Error())\n\t\t\t\t} else {\n\t\t\t\t\td.logger.Debugf(\"Distance: %.2f cm\", distance)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(d.distanceMonitorInterval)\n\t\t\t}\n\t\t}\n\t}()\n\td.distanceMonitorRunning = true\n\treturn nil\n}", "CodeBleu_score": 40.041554382568584}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorWG = &sync.WaitGroup{}\n\td.distanceMonitorWG.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorWG.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.Distance()\n\t\t\t\tif err != nil {\n\t\t\t\t\td.Logger().Error(err)\n\t\t\t\t} else {\n\t\t\t\t\td.Logger().Debugf(\"Distance: %f cm\", distance)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(d.distanceMonitorInterval)\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\treturn nil\n}", "CodeBleu_score": 52.79699738374295}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStop = make(chan bool)\n\td.distanceMonitorWg = &sync.WaitGroup{}\n\td.distanceMonitorWg.Add(1)\n\tgo d.distanceMonitor()\n\td.distanceMonitorRunning = true\n\treturn nil\n}", "CodeBleu_score": 31.89066245856504}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, edge string, value uint32, timestamp uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\td.mutex.Lock()\n\t\t\td.duration = time.Since(start)\n\t\t\td.mutex.Unlock()\n\t\t\td.durationChan <- d.duration\n\t\t}\n\t}\n}", "CodeBleu_score": 37.6076455043767}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, event string, data uint32, data2 uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\td.durationChan <- time.Since(start)\n\t\t}\n\t}\n}", "CodeBleu_score": 35.17750031266826}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, edge string, value uint32, timestamp uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\td.durationChan <- time.Since(start)\n\t\t}\n\t}\n}", "CodeBleu_score": 35.48517081975958}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\td.triggerPin.DigitalWrite(1)\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.DigitalWrite(0)\n\n\ttimeout := time.After(d.timeout)\n\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout reached\")\n\t\tdefault:\n\t\t\tif d.echoPin.DigitalRead() == 1 {\n\t\t\t\tstart := time.Now()\n\t\t\t\tfor d.echoPin.DigitalRead() == 1 {\n\t\t\t\t}\n\t\t\t\td.measuredTime = time.Since(start)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.916441953384826}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\terr := d.triggerPin.Toggle()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(time.Microsecond * 10)\n\n\td.triggerPin.Toggle()\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 100)\n\t\td.measurementMutex.Lock()\n\t\td.measurementMutex.Unlock()\n\t}()\n\n\tstart := time.Now()\n\tfor {\n\t\td.measurementMutex.Lock()\n\t\tstate, err := d.echoPin.DigitalRead()\n\t\td.measurementMutex.Unlock()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif state == 1 {\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(start) > time.Millisecond*100 {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\t}\n\t}\n\n\tstart = time.Now()\n\tfor {\n\t\td.measurementMutex.Lock()\n\t\tstate, err := d.echoPin.DigitalRead()\n\t\td.measurementMutex.Unlock()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif state == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(start) > time.Millisecond*100 {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\t}\n\t}\n\n\td.measurementMutex.Lock()\n\td.measurement = time.Since(start)\n\td.measurementMutex.Unlock()\n\n\treturn nil\n}", "CodeBleu_score": 52.3976496965906}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\td.trigger.Low()\n\ttime.Sleep(1 * time.Microsecond)\n\td.trigger.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.trigger.Low()\n\n\td.timeout = time.After(1 * time.Second)\n\tfor {\n\t\tselect {\n\t\tcase <-d.timeout:\n\t\t\treturn fmt.Errorf(\"timeout\")\n\t\tdefault:\n\t\t\tif d.echo.State() {\n\t\t\t\tstart := time.Now()\n\t\t\t\tfor !d.echo.State() {\n\t\t\t\t\ttime.Sleep(10 * time.Microsecond)\n\t\t\t\t}\n\t\t\t\td.measuredTime = time.Since(start)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 43.836742302979445}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    access_token = os.getenv(\"PLATFORMIO_AUTH_TOKEN\")\n    if access_token:\n        return access_token\n    state = app.get_state()\n    if state.get(\"access_token\"):\n        if time.time() < state.get(\"access_token_expiration\"):\n            return state.get(\"access_token\")\n        if state.get(\"refresh_token\"):\n            try:\n                new_token = self._fetch_access_token(state.get(\"refresh_token\"))\n                app.set_state({\n                    \"access_token\": new_token.get(\"access_token\"),\n                    \"access_token_expiration\": new_token.get(\"access_token_expiration\"),\n                    \"refresh_token\": new_token.get(\"refresh_token\")\n                })\n                return new_token.get(\"access_token\")\n            except HTTPClientError as e:\n                if e.response.status_code == 400:\n                    raise UserSideException(\"Invalid refresh token\")\n                raise PlatformioException(\"Failed to fetch new access token\")\n    raise PlatformioException(\"Account is not authorized\")\n\n", "CodeBleu_score": 38.630737989771575}, {"code": "def fetch_authentication_token(self)\n\t\n    # Check if the token is available in the environment variables\n    token = os.environ.get(\"PLATFORMIO_AUTH_TOKEN\")\n    if token:\n        return token\n\n    # Check the local state for a valid access token and its expiration time\n    state = app.get_state()\n    if state.get(\"access_token\") and state.get(\"expires_at\") > time.time():\n        return state[\"access_token\"]\n\n    # Check the local state for a refresh token and attempt to fetch a new access token\n    if state.get(\"refresh_token\"):\n        try:\n            response = __accounts_api__.refresh_token(state[\"refresh_token\"])\n        except HTTPClientError as e:\n            raise AccountNotAuthorized(\n                \"Failed to refresh authentication token: %s\" % e.message\n            )\n        if response.get(\"access_token\") and response.get(\"expires_in\"):\n            # Update the local state with the new authentication data\n            app.set_state(\n                {\n                    \"access_token\": response[\"access_token\"],\n                    \"expires_at\": time.time() + response[\"expires_in\"],\n                }\n            )\n            return response[\"access_token\"]\n\n    # If all methods fail, raise an \"AccountNotAuthorized\" exception\n    raise AccountNotAuthorized(\n        \"Failed to fetch authentication token: no valid access token found\"\n    )\n\n", "CodeBleu_score": 41.04902321455839}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get(\"PLATFORMIO_AUTH_TOKEN\")\n    if token:\n        return token\n\n    state = self._load_state()\n    if state.get(\"access_token\") and state.get(\"expiration_time\"):\n        if state[\"expiration_time\"] > time.time():\n            return state[\"access_token\"]\n\n        if state.get(\"refresh_token\"):\n            try:\n                response = self._refresh_token(state[\"refresh_token\"])\n                self._update_state(response)\n                return response[\"access_token\"]\n            except HTTPClientError as e:\n                if e.status_code == 401:\n                    raise UserSideException(\n                        \"The refresh token has expired. Please login again.\"\n                    )\n                raise\n\n    raise PlatformioException(\"You are not authorized. Please login.\")\n\n", "CodeBleu_score": 38.49702388294993}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    if refresh_token:\n        self.delete_session()\n        try:\n            __accounts_api__.post(\"/v1/logout\", data={\"refresh_token\": refresh_token})\n        except HTTPClientError as e:\n            if e.response.status_code != 400:\n                raise\n        return True\n\n", "CodeBleu_score": 41.9696591042052}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    if not refresh_token:\n        return True\n    self.delete_session()\n    try:\n        self.__accounts_api__.logout(refresh_token)\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 41.805201541384726}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_session()\n    try:\n        __accounts_api__.logout(refresh_token)\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 32.88364367970665}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for package_name in self.get_used_packages():\n        if self.is_package_optional(package_name):\n            continue\n        package_spec = PackageSpec(package_name)\n        package_info = self.get_package_metadata(package_spec)\n        if package_info.get(\"type\") == \"external\":\n            package_info[\"url\"] = package_info[\"url\"].get(\n                \"url\", package_info[\"url\"][\"git\"]\n            )\n        packages.append(package_info)\n    return packages\n\n", "CodeBleu_score": 32.92298912667021}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if package.is_optional:\n            continue\n        metadata = package.get_metadata()\n        if metadata[\"type\"] == \"external\":\n            result.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                    \"source\": metadata[\"url\"],\n                }\n            )\n        else:\n            result.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                }\n            )\n    return result\n\n", "CodeBleu_score": 25.829061194656934}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, spec in self.items():\n        if spec.is_optional:\n            continue\n        if spec.is_external:\n            result.append((name, spec.version, spec.source))\n        else:\n            result.append((name, spec.version))\n    return result\n\n", "CodeBleu_score": 23.681596407235865}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    config = ProjectConfig()\n    config.load()\n    if env not in config.envs:\n        raise UndefinedEnvPlatformError(env)\n    platform_spec = config.get(\"env:%s\" % env, \"platform\")\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n    if not targets:\n        targets = config.get(\"env:%s\" % env, \"targets\")\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.env = env\n    instance.configure_project_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 43.04420748023218}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not env:\n        raise UndefinedEnvPlatformError(\n            \"Please specify an environment name (e.g. 'uno', 'due', etc.)\"\n        )\n    if targets is None:\n        targets = []\n    if not issubclass(cls, base.BasePlatform):\n        raise UnknownPlatform(\n            \"Platform class must be inherited from platformio.platform.base.BasePlatform\"\n        )\n    if not isinstance(env, ProjectConfig):\n        env = ProjectConfig(env)\n    platform_spec = env.get(\"platform\")\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(\n            \"Platform specification is not found in the project configuration for the environment '%s'\"\n            % env.name\n        )\n    platform = cls(platform_spec)\n    platform.env = env\n    platform.autoinstall = autoinstall\n    platform.configure_packages(env.get(\"packages\", targets=targets))\n    return platform\n\n", "CodeBleu_score": 29.64616124049917}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    config = ProjectConfig()\n    try:\n        platform_spec = config.get_env_build_data(env, \"platform\")\n    except UndefinedEnvPlatformError:\n        raise\n    except Exception as e:\n        raise UnknownPlatform(e)\n\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n\n    platform = cls(platform_spec, autoinstall)\n    platform.env = env\n    platform.configure_packages(config.get_env_build_data(env, \"packages\"), targets)\n    return platform\n\n", "CodeBleu_score": 36.04104407758314}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  while (Wire.available() != Size);\n  for (uint8_t i = 0; i < Size; i++) Buff[i] = Wire.read();\n}", "CodeBleu_score": 67.13479855845546}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire.beginTransmission(0x34);\n    Wire.write(Addr);\n    Wire.endTransmission();\n\n    Wire.requestFrom(0x34, Size);\n    for (uint8_t i = 0; i < Size; i++) {\n        Buff[i] = Wire.read();\n    }\n}", "CodeBleu_score": 71.57101429945992}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n\n  Wire.requestFrom(0x34, Size);\n  uint8_t i = 0;\n  while (Wire.available()) {\n    Buff[i] = Wire.read();\n    i++;\n  }\n}", "CodeBleu_score": 56.259079843616114}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep(time_in_us);\n    if (time_in_us > 0) {\n        // Set the timer wakeup source to be enabled\n        Write8bit(0x33, 0x01);\n        // Set the timer wakeup duration in microseconds\n        Write32bit(0x34, time_in_us);\n        // Set the timer wakeup duration in microseconds\n        Write32bit(0x35, time_in_us);\n    } else {\n        // Disable the timer wakeup source\n        Write8bit(0x33, 0x00);\n    }\n    // Initiate deep sleep\n    Write8bit(0x32, 0x01);\n}", "CodeBleu_score": 55.94630814886359}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep(time_in_us);\n    if (time_in_us == 0) {\n        Write8(AXP192_TIMER_CONTROL1, 0);\n    }\n    Write8(AXP192_SLEEP_CONTROL, 0x03);\n    delay(100);\n}", "CodeBleu_score": 37.39405963229967}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep(time_in_us);\n    if (time_in_us == 0) {\n        Write8bit(0x32, 0x01);\n    } else {\n        Write8bit(0x32, 0x02);\n    }\n}", "CodeBleu_score": 37.366038855534214}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint prev_y = y;\n\n\ty = (y + text_height) % (height - tteBar);\n\tif (y >= height - tteBar) y = 0;\n\n\tfill_rect(x, y, width, text_height, color);\n\n\treturn prev_y;\n}", "CodeBleu_score": 18.42154376207604}, {"code": "int Display::scroll_line(uint32_t color){\n\t    int y = scroll_y;\n    scroll_y += TEXT_HEIGHT;\n    if (scroll_y >= DISPLAY_HEIGHT - BOTTOM_FIXED_AREA) {\n        scroll_y -= DISPLAY_HEIGHT - BOTTOM_FIXED_AREA;\n    }\n    tft.fillRect(0, y, DISPLAY_WIDTH, TEXT_HEIGHT, color);\n    if (tteBar) {\n        scroll_y = TOP_FIXED_AREA_TTE;\n    }\n    tft.setScroll(0, scroll_y);\n    return y;\n}", "CodeBleu_score": 28.37755554968202}, {"code": "int Display::scroll_line(uint32_t color){\n\t    int y = scroll_y;\n    int x = scroll_x;\n    int y_max = height - tteBar;\n    if (scroll_y == y_max) {\n        scroll_y = 0;\n    } else {\n        scroll_y++;\n    }\n    fillRect(x, y, width, 1, color);\n    return y;\n}", "CodeBleu_score": 15.898051337069008}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  if (ssids == nullptr || access_points == nullptr) {\n    return false;\n  }\n  _ssids = ssids;\n  _access_points = access_points;\n  _server.on(\"/\", [this]() {\n    _server.send(200, \"text/html\", _html_content);\n  });\n  _server.on(\"/scan\", [this]() {\n    _server.send(200, \"text/html\", _scan_html_content);\n  });\n  _server.on(\"/scan.json\", [this]() {\n    String json_string = \"{\";\n    json_string += \"\\\"ssids\\\":[\";\n    for (int i = 0; i < _ssids->size(); i++) {\n      json_string += \"{\\\"ssid\\\":\\\"\" + _ssids->get(i).ssid + \"\\\",\";\n      json_string += \"\\\"rssi\\\":\" + String(_ssids->get(i).rssi) + \",\";\n      json_string += \"\\\"encryption\\\":\\\"\" + _ssids->get(i).encryption + \"\\\"}\";\n      if (i < _ssids->size() - 1) {\n        json_string += \",\";\n      }\n    }\n    json_string += \"]\";\n    json_string += \"}\";\n    _server.send(200, \"application/json\", json_string);\n  });\n  _server.on(\"/connect\", [this]() {\n    String ssid = _server.arg(\"ssid\");\n    String password = _server.arg(\"password\");\n    for (int i = 0; i < _access_points->size(); i++) {\n      if (_access_points->get(i).ssid == ssid) {\n        _access_points->get(i).password = password;\n        _server.send(200, \"text/plain\", \"connected\");\n        return;\n      }\n    }\n    _server.send(400, \"text/plain\", \"not connected\");\n  });\n  _server.on(\"/disconnect\", [", "CodeBleu_score": 40.464988593395915}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  if (access_points != NULL) {\n    this->access_points = access_points;\n  }\n  if (ssids != NULL) {\n    this->ssids = ssids;\n  }\n\n  if (!this->set_ap_list()) {\n    return false;\n  }\n\n  if (!this->set_html_content()) {\n    return false;\n  }\n\n  if (!this->start_portal()) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 55.0289840942924}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  // set up access points\n  if (access_points != NULL) {\n    if (!setAccessPoints(access_points)) {\n      return false;\n    }\n  }\n\n  // set up HTML content\n  if (!setHTMLContent()) {\n    return false;\n  }\n\n  // start the portal\n  start();\n  return true;\n}", "CodeBleu_score": 44.92854550198966}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t    if (!queue_enabled_flag) {\n        queue_enabled_flag = true;\n        queue_size = 0;\n        text = \"\";\n        text_in = \"\";\n    }\n}", "CodeBleu_score": 8.410394605007374}, {"code": "void GpsInterface::enable_queue(){\n\t  if (!queue_enabled_flag) {\n    queue_enabled_flag = true;\n    queue = xQueueCreate(queue_length, sizeof(char *));\n    text = (char *)malloc(queue_length * sizeof(char));\n    text_in = (char *)malloc(queue_length * sizeof(char));\n  }\n}", "CodeBleu_score": 10.794822985256179}, {"code": "void GpsInterface::enable_queue(){\n\t    if (queue_enabled_flag == false) {\n        queue_enabled_flag = true;\n        queue = \"\";\n        text = \"\";\n        text_in = \"\";\n    }\n}", "CodeBleu_score": 8.560161573480936}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (queue_nmea.size() > 0) {\n        queue_nmea.clear();\n    }\n    queue_nmea = std::queue<std::string>();\n}", "CodeBleu_score": 36.19518312166481}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue_nmea != NULL) {\n        if (this->queue_nmea->size() > 0) {\n            this->queue_nmea->clear();\n        }\n    } else {\n        this->queue_nmea = new std::queue<std::string>();\n    }\n}", "CodeBleu_score": 25.024432811717784}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (queue_nmea.size() > 0) {\n        queue_nmea = std::queue<std::string>();\n    }\n}", "CodeBleu_score": 34.254984141151354}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t  uint32_t x, y;\n  uint32_t w = (area->x2 - area->x1 + 1);\n  uint32_t h = (area->y2 - area->y1 + 1);\n  uint32_t size = w * h;\n\n  lcd_write_cmd(disp->user_data, 0x2C);\n\n  lcd_write_data_start(disp->user_data);\n\n  for (y = area->y1; y <= area->y2; y++) {\n    for (x = area->x1; x <= area->x2; x++) {\n      lcd_write_data(disp->user_data, color_p->full);\n      color_p++;\n    }\n  }\n\n  lcd_write_data_end(disp->user_data);\n\n  lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 60.45568421908777}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    int32_t x, y;\n    uint32_t w, h;\n    uint32_t buf_w = disp->hor_res;\n    uint32_t buf_h = disp->ver_res;\n\n    lcd_write_cmd(disp->user_data, LCD_CMD_WRITE_START);\n\n    /* Set the address window */\n    lcd_write_cmd(disp->user_data, LCD_CMD_SET_COL_ADDRESS);\n    lcd_write_cmd(disp->user_data, area->x1);\n    lcd_write_cmd(disp->user_data, area->x2);\n\n    lcd_write_cmd(disp->user_data, LCD_CMD_SET_PAGE_ADDRESS);\n    lcd_write_cmd(disp->user_data, area->y1);\n    lcd_write_cmd(disp->user_data, area->y2);\n\n    /* Iterate through each pixel in the area */\n    for (y = area->y1; y <= area->y2; y++) {\n      for (x = area->x1; x <= area->x2; x++) {\n        lcd_write_data(disp->user_data, color_p->full);\n        color_p++;\n      }\n    }\n\n    /* End the write transaction */\n    lcd_write_cmd(disp->user_data, LCD_CMD_WRITE_END);\n\n    /* Notify that the display flush is complete */\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 49.94513854735277}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t x, y;\n    uint32_t width = (area->x2 - area->x1 + 1);\n    uint32_t height = (area->y2 - area->y1 + 1);\n\n    /* Start a write */\n    ST7789_WriteReg(disp->user_data, ST7789_CMD_WRITE_MEMORY_START);\n\n    /* Set the address window */\n    ST7789_WriteReg(disp->user_data, ST7789_CMD_SET_COLUMN_ADDRESS);\n    ST7789_WriteReg(disp->user_data, area->x1);\n    ST7789_WriteReg(disp->user_data, area->x2);\n\n    ST7789_WriteReg(disp->user_data, ST7789_CMD_SET_PAGE_ADDRESS);\n    ST7789_WriteReg(disp->user_data, area->y1);\n    ST7789_WriteReg(disp->user_data, area->y2);\n\n    /* Write the color data for each pixel in the area */\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++) {\n            ST7789_WriteData(disp->user_data, color_p->full);\n            color_p++;\n        }\n    }\n\n    /* End the write transaction and notify that the display flush is complete */\n    ST7789_WriteReg(disp->user_data, ST7789_CMD_WRITE_MEMORY_END);\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 46.57002640631557}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    if (menu == nullptr) {\n        return;\n    }\n\n    for (int i = 0; i < layer; i++) {\n        cout << \"    \";\n    }\n    cout << menu->getName() << endl;\n\n    for (int i = 0; i < menu->getMenuNodeCount(); i++) {\n        showMenuList(menu->getMenuNode(i), layer + 1);\n    }\n    cout << endl;\n}", "CodeBleu_score": 46.94762740387113}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    if (menu->getNodes().size() == 0) {\n        std::cout << std::string(layer * 2, ' ') << \" - \" << menu->getName() << std::endl;\n    }\n    else {\n        std::cout << std::string(layer * 2, ' ') << \" - \" << menu->getName() << std::endl;\n        for (auto & node : menu->getNodes()) {\n            showMenuList(node, layer + 1);\n        }\n    }\n    std::cout << std::endl;\n}", "CodeBleu_score": 35.73391484837614}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    if (menu == nullptr) {\n        return;\n    }\n    for (auto & node : menu->getNodes()) {\n        for (int i = 0; i < layer; i++) {\n            std::cout << \"    \";\n        }\n        std::cout << node->getName() << std::endl;\n    }\n    std::cout << std::endl;\n}", "CodeBleu_score": 45.15253970453505}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\n  for (int i = 0; i < count; i++) {\n\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += (char)(rand() % 26 + 65);\n    }\n\n    int channel = rand() % 13 + 1;\n    String mac = \"\";\n    for (int j = 0; j < 6; j++) {\n      mac += String(rand() % 16, HEX);\n      if (j < 5) {\n        mac += \":\";\n      }\n    }\n\n    ssids.push_back(ssid);\n    channels.push_back(channel);\n    macs.push_back(mac);\n\n    Serial.print(ssid);\n    Serial.print(\", \");\n    Serial.print(channel);\n    Serial.print(\", \");\n    Serial.print(mac);\n    Serial.println();\n  }\n\n  return count;\n}", "CodeBleu_score": 42.338550430478385}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  // Iterate through the given count\n  for (int i = 0; i < count; i++) {\n    // Create a random SSID\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += (char) (rand() % 26 + 'a');\n    }\n\n    // Create a random channel\n    int channel = rand() % 13 + 1;\n\n    // Create a random MAC address\n    String mac = \"\";\n    for (int j = 0; j < 6; j++) {\n      mac += String(rand() % 256, HEX);\n      if (j < 5) mac += \":\";\n    }\n\n    // Add the SSID to the list\n    ssids.push_back({ssid, channel, mac});\n\n    // Print the SSID to the serial output\n    Serial.print(ssid);\n    Serial.print(\" \");\n    Serial.print(channel);\n    Serial.print(\" \");\n    Serial.print(mac);\n    Serial.println();\n  }\n\n  // Return the number of generated SSIDs\n  return ssids.size();\n}", "CodeBleu_score": 42.10917624056615}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    Serial.println(F(\"Generating SSIDs...\"));\n    int generated = 0;\n    for (int i = 0; i < count; i++) {\n        // Generate random SSID\n        String ssid = \"\";\n        for (int j = 0; j < 6; j++) {\n            ssid += (char) (random(0, 26) + 'a');\n        }\n        // Generate random channel\n        int channel = random(1, 14);\n        // Generate random MAC address\n        uint8_t mac[6];\n        for (int j = 0; j < 6; j++) {\n            mac[j] = random(0, 256);\n        }\n        // Add SSID to list\n        WiFi.softAP(ssid.c_str(), NULL, channel, mac);\n        // Print SSID to serial output\n        Serial.print(F(\"Generated SSID: \"));\n        Serial.print(ssid);\n        Serial.print(F(\" (Channel: \"));\n        Serial.print(channel);\n        Serial.println(F(\")\"));\n        generated++;\n    }\n    return generated;\n}", "CodeBleu_score": 42.77876356258998}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n\n    publisher_client = pubsub_v1.PublisherClient()\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n\n    try:\n        topic = publisher_client.create_topic(request={\"name\": topic_path})\n        print(f\"Created topic: {topic.name}\")\n    except Exception as e:\n        print(e)\n\n", "CodeBleu_score": 56.73322605279897}, {"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 68.7473289562988}, {"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 68.7473289562988}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n\n    now = datetime.datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print(\n        f'Creating JWT using {private_key_file} private key file')\n\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 54.519391016127294}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    now = datetime.datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print(\n        f'Creating JWT using {algorithm} with given private key file.')\n\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 54.34786545817043}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    now = datetime.datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print(\n        f'Creating JWT using {private_key_file}, algorithm={algorithm}')\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 53.99736265906214}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(f\"Received message from {message.topic}: {message.payload}\")\n    if message.payload.decode() == \"on\":\n        capture_preview_image()\n        upload_file_to_bucket()\n        publish_file_url_to_event()\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 12.105693869242039}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message '\" + payload + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos))\n    if payload == \"on\":\n        print(\"Capturing preview image\")\n        capture_preview_image()\n        print(\"Uploading preview image to GCS\")\n        upload_file_to_gcs()\n        print(\"Publishing image URL to MQTT event topic\")\n        publish_image_url_to_mqtt()\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 26.62016054969511}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message from topic:\", message.topic)\n    print(\"Payload:\", message.payload.decode())\n    print(\"QoS:\", message.qos)\n    print(\"****************************\")\n\n    if message.payload.decode() == \"on\":\n        capture_preview_image()\n        upload_file_to_bucket(file_name)\n        publish_file_url(file_url)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 22.745529921482827}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description='Publish messages to a Cloud Pub/Sub topic.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='Cloud Pub/Sub subscription name.')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=1,\n        help='Number of messages to publish.')\n\n    return parser.parse_args()\n\n", "CodeBleu_score": 46.24030333690576}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Cloud IoT Core MQTT example for PubSub')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        required=True,\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--subscription_name',\n        default='sub-mqtt-1',\n        help='Cloud Pub/Sub subscription name.')\n    parser.add_argument(\n        '--topic_name',\n        default='mqtt-1',\n        help='Cloud Pub/Sub topic name.')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=1,\n        help='Number of messages to pull.')\n    parser.add_argument(\n        '--ack_deadline_seconds',\n        type=int,\n        default=10,\n        help='Cloud Pub/Sub subscription ack deadline in seconds.')\n    return parser.parse_args()\n\n", "CodeBleu_score": 43.69421258735462}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Process some integers.')\n    parser.add_argument('--project_id',\n                        help='GCP cloud project name',\n                        required=True)\n    parser.add_argument('--subscription_name',\n                        help='Cloud Pub/Sub subscription name',\n                        required=True)\n    parser.add_argument('--message_count',\n                        type=int,\n                        help='Number of messages to pull',\n                        default=1)\n    parser.add_argument('--wait_time',\n                        type=int,\n                        help='Time (in seconds) to wait for a message',\n                        default=60)\n    parser.add_argument('--verbosity',\n                        choices=['debug', 'info', 'error'],\n                        help='Set the logging level',\n                        default='info')\n    args = parser.parse_args()\n    return args\n\n", "CodeBleu_score": 34.68839478553966}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_url = ('https://cloudiot.googleapis.com/$discovery/rest')\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n\n    # Build the service object.\n    service = discovery.build(\n        'cloudiot', api_version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n\n    return service\n\n", "CodeBleu_score": 55.15105142597477}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_url = (\"https://cloudiot.googleapis.com/\"\n                     \"$discovery/rest?version={}\".format(api_version))\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(\n        api_scopes)\n    return discovery.build(\n        \"cloudiot\",\n        api_version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n\n", "CodeBleu_score": 46.038322802584894}, {"code": "def get_client(service_account_json)\n\t\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=[\"https://www.googleapis.com/auth/cloud-platform\"])\n    return discovery.build(\"cloudiot\", \"v1\", credentials=credentials,\n                           discoveryServiceUrl=\"https://cloudiot.googleapis.com/$discovery/rest\")\n\n", "CodeBleu_score": 17.64367869978632}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == 'SHA-1':\n        asn1_code = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == 'SHA-256':\n        asn1_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'SHA-512':\n        asn1_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n\n    hash_value = asn1_code + hash_value\n    padded_hash = common.byte_pad(hash_value, priv_key.size_in_bytes())\n    signature = priv_key.blinded_encrypt(padded_hash)\n    return signature\n\n", "CodeBleu_score": 31.293885957685774}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == \"SHA-1\":\n        asn1_code = b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\"\n    elif hash_method == \"SHA-224\":\n        asn1_code = b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x1c\"\n    elif hash_method == \"SHA-256\":\n        asn1_code = b\"\\x30\\x31\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x20\"\n    elif hash_method == \"SHA-384\":\n        asn1_code = b\"\\x30\\x41\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x30\"\n    elif hash_method == \"SHA-512\":\n        asn1_code = b\"\\x30\\x51\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x40\"\n    else:\n        raise ValueError(\"Invalid hash method\")\n    hash_value = asn1_code + hash_value\n    hash_value = common.byte_pad(hash_value, priv_key.size_in_bytes())\n    return priv_key.blinded_crt_sign(hash_value)\n\n", "CodeBleu_score": 23.695452885918325}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == \"SHA-1\":\n        asn1_code = b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\"\n    elif hash_method == \"SHA-256\":\n        asn1_code = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    elif hash_method == \"SHA-384\":\n        asn1_code = b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30\"\n    elif hash_method == \"SHA-512\":\n        asn1_code = b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\"\n    else:\n        raise ValueError(\"Invalid hash method\")\n\n    asn1_hash = asn1_code + hash_value\n    padded_hash = common.byte_pad(asn1_hash, priv_key.size_in_bytes())\n    return priv_key.blinded_crt_sign(padded_hash)\n\n", "CodeBleu_score": 23.751141755553963}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    signature = transform.bytes2int(signature)\n    signature = pub_key.decrypt(signature)\n\n    # Find the hash method used\n    hash_method = common.hash_method_from_signature(signature)\n    if hash_method is None:\n        raise ValueError(\"Unknown hash method in signature\")\n\n    # Compute the hash of the message\n    hash_obj = hash_method()\n    hash_obj.update(message)\n    message_hash = hash_obj.digest()\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = common.padded_hash(signature, hash_method)\n\n    # Compare the expected padded hash with the clear signature\n    if expected_padded_hash != message_hash:\n        raise ValueError(\"Signature does not match message\")\n\n    return hash_method\n\n", "CodeBleu_score": 33.51646981213876}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(pub_key, core.RSAKey):\n        raise TypeError(\"pub_key must be RSAKey\")\n    if not isinstance(message, bytes):\n        raise TypeError(\"message must be bytes\")\n    if not isinstance(signature, bytes):\n        raise TypeError(\"signature must be bytes\")\n    if len(signature) != pub_key.size_in_bytes():\n        raise ValueError(\"signature length is not valid for key size\")\n    if pub_key.size_in_bits() < common.SHA256.digest_size * 8:\n        raise ValueError(\"key length must be at least %d bits\" % (common.SHA256.digest_size * 8))\n    signature = transform.bytes2int(signature)\n    clear_signature = pub_key.blinding_inverse(signature)\n    if clear_signature is None:\n        raise ValueError(\"signature is not invertible\")\n    hash_method = common.SHA256\n    hash_size = hash_method.digest_size\n    if pub_key.size_in_bits() < hash_size * 8:\n        raise ValueError(\"key length must be at least %d bits\" % (hash_size * 8))\n    if clear_signature >= pub_key.n:\n        raise ValueError(\"signature is too large\")\n    expected_padded_hash = transform.int2bytes(clear_signature, hash_size)\n    padded_hash = hash_method.new(message).digest()\n    if expected_padded_hash != padded_hash:\n        raise common.VerificationError(\"signature is not valid for this message\")\n    return hash_method\n\n", "CodeBleu_score": 36.356525430258735}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError('message must be of type bytes')\n    if not isinstance(signature, bytes):\n        raise TypeError('signature must be of type bytes')\n    if not isinstance(pub_key, common.RSAkey):\n        raise TypeError('pub_key must be of type RSAkey')\n\n    if pub_key.size() < common.SHA256.digest_size * 8:\n        raise ValueError('key length must be at least %d bits' % (common.SHA256.digest_size * 8))\n\n    if len(signature) != pub_key.size() // 8:\n        raise ValueError('signature length must be %d bytes' % (pub_key.size() // 8))\n\n    signature = transform.bytes2int(signature)\n    signature = core.decrypt(signature, pub_key)\n\n    hash_method, signature = _parse_signature(signature)\n\n    expected = _compute_hash(message, hash_method)\n\n    if signature != expected:\n        raise core.VerificationError('Signature did not match message')\n\n    return hash_method\n\n", "CodeBleu_score": 36.271640443007755}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\n    // Get current time\n    time_t current_time;\n    time(&current_time);\n\n    // Update JWT with current time\n    if (current_time != -1) {\n        updateJWT(current_time);\n    }\n\n    // Connect to MQTT client\n    connectMQTTClient();\n\n    // Set flag to send MQTT SUBSCRIBE packet after connection is established\n    setFlagMQTTSubscribe();\n\n    // Print debug message indicating MQTT connection attempt\n    DEBUG_PRINT(\"MQTT connection attempt\n\");\n}", "CodeBleu_score": 25.16257355044929}, {"code": "static void connectMQTT(){\n\t    if (getTime() != 0) {\n        updateJWT();\n    }\n    mqtt_connect();\n    mqtt_set_subscribe_flag();\n    debug_print(DEBUG_INFO, \"MQTT connection attempt\n\");\n}", "CodeBleu_score": 17.521439220440303}, {"code": "static void connectMQTT(){\n\t  if (get_time() != 0) {\n    update_jwt();\n  }\n\n  if (mqtt_connect(MQTT_CLIENT_ID, MQTT_USERNAME, MQTT_PASSWORD, MQTT_HOST, MQTT_PORT, 0, 1) == 0) {\n    mqtt_set_flag(MQTT_FLAG_CONNECTED);\n    mqtt_set_flag(MQTT_FLAG_SUBSCRIBE);\n    DEBUG_PRINT(\"MQTT CONNECTED\n\");\n  } else {\n    DEBUG_PRINT(\"MQTT CONNECTION FAILED\n\");\n  }\n}", "CodeBleu_score": 41.38145664941688}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        value *= 10;\n        value += (str[i] - '0');\n    }\n    *num = value;\n    return str + width;\n}", "CodeBleu_score": 26.690050402901043}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t n = 0;\n    int i;\n\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        n = n * 10 + (str[i] - '0');\n    }\n    *num = n;\n    return str + i;\n}", "CodeBleu_score": 25.977155755659947}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    uint32_t digit;\n    int i;\n\n    for (i = 0; i < width; i++) {\n        digit = *str - '0';\n        if (digit > 9)\n            return str;\n        value = value * 10 + digit;\n        str++;\n    }\n\n    *num = value;\n    return str;\n}", "CodeBleu_score": 29.40088737620843}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int retval = 0;\n    atcacert_der_encoder_t der_encoder;\n    atcacert_der_encoder_init(&der_encoder);\n\n    // Encode the certificate\n    retval = atcacert_der_encode_certificate(&der_encoder, build_state->certificate);\n    if (retval != ATCACERT_OK) {\n        return retval;\n    }\n\n    // Calculate the certificate hash\n    atca_sha2_256_context_t sha256_ctx;\n    atca_sha2_256_init(&sha256_ctx);\n    atca_sha2_256_update(&sha256_ctx, der_encoder.data, der_encoder.size);\n    atca_sha2_256_finish(&sha256_ctx, build_state->certificate_hash);\n\n    return ATCACERT_OK;\n}", "CodeBleu_score": 41.84288411364269}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    // If the build state is NULL, return an error\n    if (build_state == NULL) {\n        return ATCACERT_ERR_BAD_PARAM;\n    }\n\n    // Initialize the build state\n    memset(build_state, 0, sizeof(atcacert_build_state_t));\n\n    // Return success\n    return ATCACERT_SUCCESS;\n}", "CodeBleu_score": 23.099351510542725}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = 0;\n    atcacert_cert_t* cert = build_state->cert;\n\n    // Build the DER encoded cert\n    ret = atcacert_der_encode_cert(cert->der, build_state->cert);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    // Calculate the SHA1 hash of the DER encoded cert\n    ret = atca_crypto_sw_sha1(cert->der, cert->der_len, cert->sha1);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    // Calculate the SHA256 hash of the DER encoded cert\n    ret = atca_crypto_sw_sha256(cert->der, cert->der_len, cert->sha256);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    return ret;\n}", "CodeBleu_score": 52.71560749798765}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n    int ret = 0;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n    // Retrieve the digest of the certificate's to-be-signed (TBS) portion\n    uint8_t tbs_digest[32];\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_SUCCESS) {\n        return ret;\n    }\n\n    // Retrieve the certificate's signature\n    uint8_t signature[64];\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the TBS digest against the signature using the CA public key\n    ret = atcacert_verify_signature(ca_public_key, tbs_digest, signature);\n    if (ret != ATCACERT_SUCCESS) {\n        return ATCACERT_VERIFY_FAIL;\n    }\n\n    return ATCACERT_SUCCESS;\n}", "CodeBleu_score": 77.90872648709461}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int retval = ATCA_BAD_PARAM;\n\n    if (cert_def && cert && ca_public_key) {\n        atca_sha2_context_t sha2_ctx;\n        uint8_t             digest[32];\n        uint8_t             signature[64];\n\n        /* Retrieve the digest of the certificate's to-be-signed (TBS) portion */\n        retval = atcacert_get_tbs_digest_hw(cert_def, cert, cert_size, &sha2_ctx);\n        if (retval == ATCA_SUCCESS) {\n            /* Retrieve the certificate's signature */\n            retval = atcacert_get_signature_hw(cert_def, cert, cert_size, signature);\n            if (retval == ATCA_SUCCESS) {\n                /* Verify the TBS digest against the signature using the CA public key */\n                retval = atcacert_verify_signature_hw(digest, signature, ca_public_key);\n            }\n        }\n    }\n\n    return retval;\n}", "CodeBleu_score": 50.030321167491046}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret;\n    atca_sha2_context_t sha2_ctx;\n    uint8_t             digest[32];\n    uint8_t             sig_r[32];\n    uint8_t             sig_s[32];\n    uint8_t             tbs[ATCACERT_MAX_TBS_SIZE];\n    size_t              tbs_size;\n\n    if ((cert_def == NULL) || (cert == NULL) || (ca_public_key == NULL)) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n    if (cert_size > ATCACERT_MAX_CERT_SIZE) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n    if (cert_def->cert_type == ATCACERT_CERT_TYPE_CA) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n    tbs_size = cert_def->tbs_size;\n    if (tbs_size > ATCACERT_MAX_TBS_SIZE) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n    if (tbs_size > cert_size) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n    if (cert_def->tbs_offset > cert_size) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n    if (cert_def->sig_offset > cert_size) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n    if (cert_def->sig_offset + ATCACERT_SIG_SIZE > cert_size) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n    if (cert_def->sig_size != ATCACERT_SIG_SIZE) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n    if (cert_def->sig_type != ATCACERT_SIG_TYPE_ECDSA) {\n        return ATCACERT_BAD_PARAM;\n    }\n\n   ", "CodeBleu_score": 42.14450053293298}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if (list == NULL || *list == NULL || timer == NULL) {\n        return false;\n    }\n\n    timerStruct_t *prev = NULL;\n    timerStruct_t *curr = *list;\n\n    while (curr != timer) {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    if (prev == NULL) {\n        *list = curr->next;\n    } else {\n        prev->next = curr->next;\n    }\n\n    return true;\n}", "CodeBleu_score": 32.21036478218354}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t *prev = NULL;\n    timerStruct_t *curr = *list;\n    while (curr != NULL)\n    {\n        if (curr == timer)\n        {\n            if (prev == NULL)\n            {\n                *list = curr->next;\n            }\n            else\n            {\n                prev->next = curr->next;\n            }\n            curr->next = NULL;\n            return true;\n        }\n        prev = curr;\n        curr = curr->next;\n    }\n    return false;\n}", "CodeBleu_score": 39.541411148116914}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t *prev;\n    timerStruct_t *curr;\n\n    prev = NULL;\n    curr = *list;\n    while (curr != NULL && curr != timer) {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    if (curr == NULL) {\n        return false;\n    }\n\n    if (prev == NULL) {\n        *list = curr->next;\n    } else {\n        prev->next = curr->next;\n    }\n\n    return true;\n}", "CodeBleu_score": 30.21464798745293}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t    struct socket_info *socket_info = get_socket_info(socket);\n    if (socket_info == NULL) {\n        return BSD_ERROR;\n    }\n    socket_info->state = NOT_A_SOCKET;\n    int ret = close(socket);\n    if (ret < 0) {\n        if (errno == EBADF) {\n            set_error_number(BSD_EBADF);\n        } else if (errno == EINVAL) {\n            set_error_number(BSD_EINVAL);\n        } else if (errno == ENOTCONN) {\n            set_error_number(BSD_ENOTCONN);\n        } else if (errno == ENOTSOCK) {\n            set_error_number(BSD_ENOTSOCK);\n        } else {\n            set_error_number(BSD_ERROR);\n        }\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 48.441535303183315}, {"code": "int BSD_close(int socket){\n\t  int status = BSD_SUCCESS;\n  if (socket < 0 || socket >= MAX_SOCKETS) {\n    return BSD_ERROR;\n  }\n\n  if (sockets[socket].state == NOT_A_SOCKET) {\n    return BSD_ERROR;\n  }\n\n  status = close(socket);\n  if (status < 0) {\n    switch (errno) {\n      case EBADF:\n        errno = BSD_EBADF;\n        break;\n      case ENOTCONN:\n        errno = BSD_ENOTCONN;\n        break;\n      case ENOTSOCK:\n        errno = BSD_ENOTSOCK;\n        break;\n      case EINVAL:\n        errno = BSD_EINVAL;\n        break;\n      default:\n        errno = BSD_EINVAL;\n        break;\n    }\n    return BSD_ERROR;\n  }\n  return BSD_SUCCESS;\n}", "CodeBleu_score": 50.61798099146504}, {"code": "int BSD_close(int socket){\n\t\n    int ret;\n\n    int sock_type;\n\n    int sock_state;\n\n    int sock_errno;\n\n    int sock_err;\n\n    struct bsd_socket *sock;\n\n    sock = &bsd_socket_table[socket];\n\n    if (sock->state == NOT_A_SOCKET) {\n\n        sock_errno = BSD_EBADF;\n\n        return BSD_ERROR;\n\n    }\n\n    sock_type = sock->type;\n\n    sock_state = sock->state;\n\n    sock->state = NOT_A_SOCKET;\n\n    if (sock_type == SOCK_STREAM) {\n\n        ret = close(socket);\n\n    } else if (sock_type == SOCK_DGRAM) {\n\n        ret = close(socket);\n\n    } else {\n\n        sock_errno = BSD_EBADF;\n\n        return BSD_ERROR;\n\n    }\n\n    if (ret < 0) {\n\n        sock_err = errno;\n\n        if (sock_err == EBADF) {\n\n            sock_errno = BSD_EBADF;\n\n        } else if (sock_err == EINVAL) {\n\n            sock_errno = BSD_EINVAL;\n\n        } else if (sock_err == ENOTTY) {\n\n            sock_errno = BSD_ENOTTY;\n\n        } else {\n\n            sock_errno = BSD_EINVAL;\n\n        }\n\n        return BSD_ERROR;\n\n    }\n\n    return BSD_SUCCESS;\n\n}", "CodeBleu_score": 44.80738318949777}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t  int response = listen(socket, backlog);\n  if (response == -1) {\n    errno = BSD_ERROR;\n    return BSD_ERROR;\n  }\n  return BSD_SUCCESS;\n}", "CodeBleu_score": 15.294144941883314}, {"code": "int BSD_listen(int socket, int backlog){\n\t    int response;\n    response = listen(socket, backlog);\n    if (response != 0) {\n        perror(\"listen\");\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 20.93807890317489}, {"code": "int BSD_listen(int socket, int backlog){\n\t    int result = listen(socket, backlog);\n\n    if (result < 0) {\n        switch (errno) {\n            case EBADF:\n                BSD_set_error(BSD_EBADF);\n                break;\n\n            case ENOTSOCK:\n                BSD_set_error(BSD_ENOTSOCK);\n                break;\n\n            case EOPNOTSUPP:\n                BSD_set_error(BSD_EOPNOTSUPP);\n                break;\n\n            case EINVAL:\n                BSD_set_error(BSD_EINVAL);\n                break;\n\n            case ENOBUFS:\n                BSD_set_error(BSD_ENOBUFS);\n                break;\n\n            case ECONNABORTED:\n                BSD_set_error(BSD_ECONNABORTED);\n                break;\n\n            case ECONNRESET:\n                BSD_set_error(BSD_ECONNRESET);\n                break;\n\n            case EISCONN:\n                BSD_set_error(BSD_EISCONN);\n                break;\n\n            case EADDRINUSE:\n                BSD_set_error(BSD_EADDRINUSE);\n                break;\n\n            case EADDRNOTAVAIL:\n                BSD_set_error(BSD_EADDRNOTAVAIL);\n                break;\n\n            case ENETDOWN:\n                BSD_set_error(BSD_ENETDOWN);\n                break;\n\n            case ENETUNREACH:\n                BSD_set_error(BSD_ENETUNREACH);\n                break;\n\n            case ENETRESET:\n                BSD_set_error(BSD_ENETRESET);\n                break;\n\n            case ECONNABORTED:\n                BSD_set_error(BSD_ECONNABORTED);\n                break;\n\n            case ECONNRESET:\n                BSD_set_error(BSD_ECONNRESET);\n                break;\n\n            case ENOBUFS:\n", "CodeBleu_score": 37.02885095189083}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    int ret;\n    if (addr == NULL || addrlen == NULL) {\n        return -1;\n    }\n    if (addr->sa_family != AF_INET) {\n        return -1;\n    }\n    ret = accept(socket, (struct sockaddr *) addr, addrlen);\n    if (ret == -1) {\n        switch (socket) {\n            case SOCKET_UDP:\n                bsd_errno = BSD_EINVAL;\n                break;\n            case SOCKET_TCP:\n                bsd_errno = BSD_EINVAL;\n                break;\n            default:\n                bsd_errno = BSD_EINVAL;\n                break;\n        }\n        return -1;\n    }\n    return ret;\n}", "CodeBleu_score": 39.97485742774912}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    struct sockaddr_in * addr_in = (struct sockaddr_in *) addr;\n    int sockaddr_family = addr_in->sin_family;\n    if (sockaddr_family == AF_INET) {\n        int ret = accept(socket, (struct sockaddr *) addr_in, addrlen);\n        if (ret == -1) {\n            switch (socket) {\n                case SOCKET_TCP:\n                    errno = EBADF;\n                    break;\n                case SOCKET_UDP:\n                    errno = EINVAL;\n                    break;\n                default:\n                    errno = ENOTSUP;\n                    break;\n            }\n            return -1;\n        } else {\n            return 0;\n        }\n    } else {\n        errno = EAFNOSUPPORT;\n        return -1;\n    }\n}", "CodeBleu_score": 41.48290073491614}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    int ret_val = -1;\n    struct sockaddr_in * addr_in = (struct sockaddr_in *) addr;\n    if (addr_in->sin_family == AF_INET) {\n        int addrlen_in = * addrlen;\n        int accept_ret_val = accept(socket, (struct sockaddr *) addr_in, & addrlen_in);\n        if (accept_ret_val < 0) {\n            switch (socket) {\n                case SOCK_TCP:\n                    bsd_set_error(BSD_SOCKET_TCP_ACCEPT_FAILED);\n                    break;\n                case SOCK_UDP:\n                    bsd_set_error(BSD_SOCKET_UDP_ACCEPT_FAILED);\n                    break;\n                default:\n                    bsd_set_error(BSD_SOCKET_ACCEPT_FAILED);\n                    break;\n            }\n            return BSD_SOCKET_ACCEPT_FAILED;\n        }\n        * addrlen = addrlen_in;\n        ret_val = accept_ret_val;\n    } else {\n        bsd_set_error(BSD_SOCKET_ACCEPT_FAILED);\n        return BSD_SOCKET_ACCEPT_FAILED;\n    }\n    return ret_val;\n}", "CodeBleu_score": 41.82776505254113}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t    if (mqtt_connection_state != MQTT_CONNECTED) {\n        uint32_t current_time = get_current_time();\n        if (current_time != 0) {\n            update_jwt_with_current_time_offset(current_time);\n            mqtt_connection_state = MQTT_CONNECTING;\n            DEBUG_PRINTF(\"Connecting to MQTT\n\");\n            mqtt_connect();\n        } else {\n            DEBUG_PRINTF(\"Error: Invalid time\n\");\n        }\n    }\n    send_subscribe_packet_flag = 1;\n}", "CodeBleu_score": 45.513770841888686}, {"code": "static void connectMQTT(){\n\t  uint32_t time_now = time(NULL);\n  if (time_now > 0) {\n    time_t t = time(NULL);\n    struct tm *time_info = localtime(&t);\n    uint32_t current_time_offset = time_info->tm_hour * 3600 + time_info->tm_min * 60 + time_info->tm_sec;\n    updateJWT(current_time_offset);\n    if (mqtt_connect(MQTT_BROKER_ADDRESS, MQTT_BROKER_PORT, MQTT_KEEP_ALIVE_INTERVAL) == 0) {\n      DEBUG_PRINT(\"MQTT connection established\n\");\n      mqtt_send_subscribe_packet_flag = 1;\n    } else {\n      DEBUG_PRINT(\"MQTT connection failed\n\");\n    }\n  } else {\n    DEBUG_PRINT(\"Invalid time\n\");\n  }\n}", "CodeBleu_score": 46.25302286937449}, {"code": "static void connectMQTT(){\n\t    uint32_t current_time = get_current_time();\n    if (current_time != -1) {\n        update_jwt(current_time);\n        mqtt_connect();\n        print_debug_msg(\"MQTT connect attempt\n\");\n        mqtt_send_subscribe_packet_flag = 1;\n    }\n}", "CodeBleu_score": 25.06918348232352}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\n    if (mqtt_get_connection_state() == CONNECTED) {\n\n        mqtt_client_connection_info_t client_connection_info;\n\n        mqtt_get_client_connection_info(&client_connection_info);\n\n        mqtt_disconnect(client_connection_info.client_id);\n\n    }\n\n    debug_print(DEBUG_INFO, \"Cloud service disconnected\n\");\n\n}", "CodeBleu_score": 48.56010309766675}, {"code": "void CLOUD_disconnect(void){\n\t    if (MQTT_get_connection_state() == CONNECTED) {\n        DEBUG_PRINT(\"Disconnecting from cloud service\n\");\n\n        mqtt_client_connection_info_t client_info;\n\n        MQTT_get_client_connection_info(&client_info);\n\n        MQTT_disconnect(client_info.client_id);\n    }\n}", "CodeBleu_score": 53.972166373781405}, {"code": "void CLOUD_disconnect(void){\n\t  if (MQTT_get_connection_state() == CONNECTED) {\n    mqtt_client_info_t client_info;\n    MQTT_get_client_connection_info(&client_info);\n    MQTT_disconnect_client(client_info.client_id, client_info.client_id_len, client_info.client_id_len, client_info.keep_alive_interval);\n  }\n  DEBUG_PRINT_INFO((\"Disconnected from cloud service\n\"));\n}", "CodeBleu_score": 47.523798649552525}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t  bool wifi_connected = false;\n  uint8_t wifi_creds = passed_wifi_creds;\n  uint8_t wifi_ssid_len = 0;\n  uint8_t wifi_pass_len = 0;\n  uint8_t wifi_auth_type = 0;\n  uint8_t wifi_ssid[32] = {0};\n  uint8_t wifi_pass[64] = {0};\n  uint8_t wifi_ssid_default[32] = {0};\n  uint8_t wifi_pass_default[64] = {0};\n  uint8_t wifi_auth_type_default = 0;\n\n  /*\n   * If the passed_wifi_creds parameter is not equal to 1, then the function attempts to connect to the access point using default credentials.\n   */\n  if (wifi_creds != 1) {\n    /*\n     * The function attempts to get the Wi-Fi SSID, password, and authentication type from the credentials storage. If the function fails to retrieve the credentials, it sets the wifi_creds variable to 1.\n     */\n    if (credentials_storage_getWifiCredentials(wifi_ssid, &wifi_ssid_len, wifi_pass, &wifi_pass_len, &wifi_auth_type) != 0) {\n      wifi_creds = 1;\n    }\n  }\n\n  /*\n   * If the wifi_creds variable is equal to 1, then the function attempts to get the default Wi-Fi SSID, password, and authentication type from the configuration file.\n   */\n  if (wifi_creds == 1) {\n    /*\n     * The function attempts to get the default Wi-Fi SSID, password, and authentication type from the configuration file. If the function fails to retrieve the default credentials, it logs an error message and returns false.\n     */\n    if (conf_winc_getDefaultWifiCredentials(wifi_ssid_default, wifi_pass_default, &wifi_auth_type_default) != 0) {\n      debug_print(\"wifi_connectToAp: Failed to get default wifi credentials.", "CodeBleu_score": 33.81266562626604}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    uint8_t wifi_creds = passed_wifi_creds;\n    uint8_t wifi_status = M2M_WIFI_CONNECTED;\n    uint8_t wifi_auth = M2M_WIFI_AUTH_OPEN;\n    char wifi_ssid[32];\n    char wifi_password[64];\n    char wifi_auth_mode[32];\n    uint8_t wifi_ssid_len;\n    uint8_t wifi_password_len;\n    uint8_t wifi_auth_mode_len;\n    uint8_t wifi_auth_mode_len_max = 32;\n    bool wifi_connected = false;\n    bool wifi_creds_valid = true;\n    uint8_t wifi_retry_count = 0;\n    uint8_t wifi_retry_max = 10;\n    uint8_t wifi_retry_delay = 2000;\n\n    if (wifi_creds == WIFI_CREDS_VALID) {\n        wifi_creds_valid = true;\n        wifi_ssid_len = strlen(WIFI_SSID);\n        wifi_password_len = strlen(WIFI_PASSWORD);\n        wifi_auth_mode_len = strlen(WIFI_AUTH_MODE);\n        if (wifi_ssid_len > 32) {\n            wifi_ssid_len = 32;\n        }\n        if (wifi_password_len > 64) {\n            wifi_password_len = 64;\n        }\n        if (wifi_auth_mode_len > wifi_auth_mode_len_max) {\n            wifi_auth_mode_len = wifi_auth_mode_len_max;\n        }\n        strncpy(wifi_ssid, WIFI_SSID, wifi_ssid_len);\n        strncpy(wifi_password, WIFI_PASSWORD, wifi_password_len);\n        strncpy(wifi_auth_mode, WIFI_AUTH_MODE, wifi_auth_mode_len);\n        if (strcmp(wifi_auth_mode, \"open\") == 0) {\n            wifi_", "CodeBleu_score": 34.16450356754807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n  /*\n   * The variable \"wifi_creds\" is used to store the Wi-Fi credentials.\n   * It is set to the value of the passed parameter \"passed_wifi_creds\".\n   */\n  uint8_t wifi_creds = passed_wifi_creds;\n\n  /*\n   * The variable \"wifi_ssid\" is used to store the SSID of the Wi-Fi access point.\n   * It is set to the value of the \"WIFI_SSID\" macro.\n   */\n  char wifi_ssid[32] = WIFI_SSID;\n\n  /*\n   * The variable \"wifi_auth_type\" is used to store the authentication type of the Wi-Fi access point.\n   * It is set to the value of the \"WIFI_AUTH_TYPE\" macro.\n   */\n  char wifi_auth_type[32] = WIFI_AUTH_TYPE;\n\n  /*\n   * The variable \"wifi_password\" is used to store the password of the Wi-Fi access point.\n   * It is set to the value of the \"WIFI_PASSWORD\" macro.\n   */\n  char wifi_password[64] = WIFI_PASSWORD;\n\n  /*\n   * The variable \"wifi_status\" is used to store the status of the Wi-Fi connection.\n   * It is set to the value of the \"WIFI_STATUS\" macro.\n   */\n  char wifi_status[32] = WIFI_STATUS;\n\n  /*\n   * The variable \"wifi_ip_addr\" is used to store the IP address of the Wi-Fi access point.\n   * It is set to the value of the \"WIFI_IP_ADDR\" macro.\n   */\n  char wifi_ip_addr[32] = WIFI_IP_ADDR;\n\n  /*\n   * The variable \"wifi_ip_mask\" is used to store the IP mask of the Wi-Fi access point.\n   * It is set to the value of the \"WIFI_IP_MASK\" macro.\n   */\n  char wifi_ip_mask[32] = WIFI_IP_MASK;\n\n  /*\n   * The variable \"wifi", "CodeBleu_score": 8.217797942269538}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t  const client = new GraphQLClient(\n    \"https://xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", "CodeBleu_score": 4.402099155051584}, {"code": "async function DisplaySensors(map){\n\t  const client = await API.graphql(graphqlOperation(listSensors));\n  console.log(client);\n  const sensors = client.data.listSensors.items;\n  console.log(\"Retrieving sensors\");\n  sensors.forEach((sensor) => {\n    const marker = new maplibregl.Marker().setLngLat(\n      [sensor.location.longitude, sensor.location.latitude]\n    );\n    marker.addTo(map);\n  });\n}", "CodeBleu_score": 39.66621273621003}, {"code": "async function DisplaySensors(map){\n\t    const client = createGraphQLClient();\n    const query = gql`\n        query ListSensors {\n            listSensors {\n                items {\n                    id\n                    lat\n                    lon\n                    name\n                    description\n                }\n            }\n        }\n    `;\n\n    const response = await client.query({ query });\n    console.log(response);\n    console.log(\"Retrieving Sensors\");\n    response.data.listSensors.items.forEach((sensor) => {\n        const marker = new maplibregl.Marker()\n            .setLngLat([sensor.lon, sensor.lat])\n            .addTo(map);\n    });\n}", "CodeBleu_score": 47.019528924508094}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = 'red';\n  marker.style.border = '2px solid white';\n  return marker;\n}", "CodeBleu_score": 48.56888588345766}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"marker\";\n  marker.style.backgroundColor = \"red\";\n  marker.style.border = \"2px solid white\";\n  return marker;\n}", "CodeBleu_score": 44.38433384925175}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"marker\";\n  marker.style.backgroundColor = \"red\";\n  marker.style.border = \"2px solid #fff\";\n  return marker;\n}", "CodeBleu_score": 44.092057137255466}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"custom_components.mfa.mfa_modules.{module_name}\"\n    module = await async_import_module(module_path)\n    if not hasattr(module, \"requirements\"):\n        return module\n    if module.requirements:\n        if not hass.config.skip_pip:\n            reqs = requirements.Requirements(hass)\n            await reqs.async_process_requirements(module.requirements)\n        else:\n            _LOGGER.warning(\"Skipping pip install for %s\", module_name)\n    return module\n\n", "CodeBleu_score": 27.69492169063796}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.mfa.{module_name}\"\n    module = await async_import_module(module_path)\n\n    if module.REQUIREMENTS:\n        if not hass.config.skip_pip:\n            try:\n                await requirements.async_process_requirements(\n                    hass, module.REQUIREMENTS, module_name\n                )\n            except HomeAssistantError as err:\n                raise HomeAssistantError(\n                    f\"Error processing requirements for {module_name}: {err}\"\n                ) from err\n\n    return module\n\n", "CodeBleu_score": 31.50196250342587}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"custom_components.{module_name}\"\n    module = await async_import_module(module_path)\n\n    if module is None:\n        raise HomeAssistantError(f\"Unable to load module '{module_path}'\")\n\n    if not hasattr(module, \"DOMAIN\"):\n        raise HomeAssistantError(f\"Module '{module_path}' does not have a DOMAIN\")\n\n    if module.DOMAIN in hass.config_entries.flow.async_progress():\n        raise HomeAssistantError(\n            f\"Module '{module_path}' is already being installed\"\n        )\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        reqs = module.REQUIREMENTS\n        if isinstance(reqs, str):\n            reqs = [reqs]\n        if not hass.config.skip_pip:\n            try:\n                await requirements.async_process_requirements(\n                    hass,\n                    reqs,\n                    f\"custom_components.{module_name}\",\n                    module.__name__,\n                )\n            except HomeAssistantError as err:\n                raise HomeAssistantError(\n                    f\"Error processing requirements for module '{module_path}': {err}\"\n                )\n\n    return module\n\n", "CodeBleu_score": 35.780779756260564}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n\n", "CodeBleu_score": 35.20745562491782}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        raise ValueError(\"No PIN provided\")\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n    return True\n\n", "CodeBleu_score": 36.191281896564526}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        raise ValueError(\"PIN is missing\")\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n    return True\n\n", "CodeBleu_score": 36.145339603857316}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        store = Store(self._hass, self.DOMAIN, self.VERSION)\n        data = await store.async_load()\n        if data is None:\n            self._user_settings = {}\n            return\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id,\n                data[user_id].get(CONF_EXCLUDE, []),\n                data[user_id].get(CONF_INCLUDE, []),\n            )\n            for user_id in data\n        }\n\n", "CodeBleu_score": 47.03941833432307}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        self._user_settings = {}\n        store = Store(self.hass, self.domain, self.version)\n        data = await store.async_load()\n        if data is None:\n            return\n        for user_id, data in data.items():\n            self._user_settings[user_id] = NotifySetting(\n                user_id,\n                data.get(CONF_INCLUDE),\n                data.get(CONF_EXCLUDE),\n                data.get(\"notifications\", {}),\n            )\n\n", "CodeBleu_score": 43.49477670873334}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is None:\n            store = Store(self.hass, self.DOMAIN, self.VERSION)\n            data = await store.async_load()\n            if data is None:\n                data = {}\n            self._user_settings = OrderedDict()\n            for user_id, user_data in data.items():\n                self._user_settings[user_id] = NotifySetting(\n                    user_id,\n                    user_data.get(CONF_INCLUDE),\n                    user_data.get(CONF_EXCLUDE),\n                )\n\n", "CodeBleu_score": 40.733315611036524}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._load_user_settings(user_id)\n    settings = self._user_settings[user_id]\n    if not settings:\n        return False\n    if not self._executor.submit(self._validate_otp, user_input.get(\"otp\")).result():\n        return False\n    return True\n\n", "CodeBleu_score": 37.12357017759365}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load_user_settings(user_id)\n    settings = self._get_notification_settings(user_id)\n    if not settings:\n        return False\n    if not user_input:\n        return True\n    if not user_input.get(CONF_EXCLUDE):\n        return True\n    if not user_input.get(CONF_INCLUDE):\n        return True\n    if user_input.get(CONF_INCLUDE) and user_input.get(CONF_EXCLUDE):\n        return True\n    return await self.hass.async_add_executor_job(\n        self._async_validate_otp,\n        settings.get(CONF_EXCLUDE),\n        settings.get(CONF_INCLUDE),\n        user_input.get(CONF_OTP),\n    )\n\n", "CodeBleu_score": 47.46460608035928}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    user_settings = await self.async_get_user_settings(user_id)\n    if user_settings is None:\n        return False\n    if user_input[\"otp\"] == \"\":\n        return False\n    if user_input[\"otp\"] == user_settings[\"otp\"]:\n        return True\n    return False\n\n", "CodeBleu_score": 36.8635341522507}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get(entity.device_id)\n    if not device:\n        return None\n    if not device.area_id:\n        return None\n    area = area_dict.get(device.area_id)\n    if not area:\n        return None\n    return area.permissions\n\n", "CodeBleu_score": 49.48120138971788}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entity(entity_id)\n    if not entity:\n        return None\n\n    device = perm_lookup.device(entity.device_id)\n    if not device:\n        return None\n\n    if not device.area_id:\n        return None\n\n    return area_dict.get(device.area_id)\n\n", "CodeBleu_score": 44.583661660415174}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entities.get(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.devices.get(entity.device_id)\n    if device is None or device.area_id is None:\n        return None\n    area = area_dict.get(device.area_id)\n    if area is None:\n        return None\n    return area.permissions\n\n", "CodeBleu_score": 65.31640120644636}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {\"categories\": {}}\n    seen_categories: set[str] = set()\n    for policy_ in policies:\n        for category, categories in policy_.get(\"categories\", {}).items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                policy[\"categories\"][category] = categories\n    return cast(PolicyType, policy)", "CodeBleu_score": 42.06392907221191}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = cast(PolicyType, {})\n    seen_categories = set()\n\n    for policy in policies:\n        for category, category_policy in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = {\n                    **category_policy,\n                    **{\n                        subcategory: {\n                            **subpolicy,\n                            **{\n                                subsubcategory: {\n                                    **subsubpolicy,\n                                    **{\n                                        subsubsubcategory: {\n                                            **subsubsubpolicy,\n                                            **{\n                                                subsubsubsubcategory: {\n                                                    **subsubsubsubpolicy,\n                                                    **{\n                                                        subsubsubsubsubcategory: {\n                                                            **subsubsubsubsubpolicy,\n                                                            **{\n                                                                subsubsubsubsubsubcategory: {\n                                                                    **subsubsubsubsubsubpolicy,\n                                                                    **{\n                                                                        subsubsubsubsubsubsubcategory: {\n                                                                            **subsubsubsubsubsubsubpolicy,\n                                                                            **{\n                                                                                subsubsubsubsubsubsubsubcategory: {\n                                                                                    **subsubsubsubsubsubsubsubpolicy,\n                                                                                    **{\n                                                                                        subsubsubsubsubsubsubsubsubcategory: {\n                                                                                            **subsubsubsubsubsubsubsubsubpolicy,\n                                                                                            **{\n                                                                                                subsubsubsubsubsubsubsubsubsubcategory: {\n                                                                                                    **subsubsubsubsubsubsubsubsubsubpolicy,\n                                                                                                    **{\n                                                                                                        subsubsubsubsubsubsubsubsubsubsubcategory: {\n                                                                                                            **subsubsubsubsubsubsubsubsubsubsubpolicy,\n                                                                                                            **{\n                                                                                                                subsubsubsubsubsubsubsubsubsubsubsubcategory: {\n                                                                                                                    **subsubsubsubsubsubsubsubsubsubsubsubpolicy,\n                                                                                                                },\n                                                                                                            },\n                                                                                                        },\n                                                                                                    },\n                                                                                                },\n                                                                                            },\n                                                                                        },\n                                                                                    },\n                                                                                },\n                                                                            },\n                                                                        },\n                                                                    },\n                                                                },\n                                                            },\n                                                        },\n                                                    },\n                                                },\n                                            },\n                                        },\n                                    },\n                                },\n", "CodeBleu_score": 27.48267678692437}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy_dict in policies:\n        for category, category_dict in policy_dict.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                policy[category] = {}\n                for subcategory, subcategory_dict in category_dict.items():\n                    policy[category][subcategory] = {}\n                    for key, value in subcategory_dict.items():\n                        if key not in policy[category][subcategory]:\n                            policy[category][subcategory][key] = value\n                        else:\n                            policy[category][subcategory][key].extend(value)\n    return cast(PolicyType, policy)", "CodeBleu_score": 42.15414856325735}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(provider)\n    except ImportError as err:\n        _LOGGER.error(\"Failed to import %s auth provider module\", provider)\n        raise HomeAssistantError(\n            \"Error: {} ({})\".format(err, provider)\n        ) from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not hass.data.get(HassKey.AUTH_PROVIDER_REQUIREMENTS):\n        hass.data[HassKey.AUTH_PROVIDER_REQUIREMENTS] = set()\n\n    for requirement in module.REQUIREMENTS:\n        if requirement in hass.data[HassKey.AUTH_PROVIDER_REQUIREMENTS]:\n            continue\n\n        try:\n            await requirements.async_process_requirement(\n                hass, requirement, \"auth provider\"\n            )\n        except HomeAssistantError as err:\n            _LOGGER.error(\n                \"Error processing requirement %s for %s auth provider\",\n                requirement,\n                provider,\n            )\n            raise HomeAssistantError(\n                \"Error: {} ({})\".format(err, provider)\n            ) from err\n\n        hass.data[HassKey.AUTH_PROVIDER_REQUIREMENTS].add(requirement)\n\n    return module\n\n", "CodeBleu_score": 42.089844878117475}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\"Failed to load auth provider module %s: %s\", provider, err)\n        raise HomeAssistantError(\n            f\"Error loading auth provider module {provider}: {err}\"\n        ) from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not hass.auth.processed_requirements.add(provider):\n        return module\n\n    if not await requirements.async_process_requirements(\n        hass,\n        module.REQUIREMENTS,\n        f\"auth provider {provider}\",\n    ):\n        raise HomeAssistantError(\n            f\"Failed to process requirements for auth provider {provider}\"\n        )\n\n    return module\n\n", "CodeBleu_score": 52.26669889517446}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(\n            f\"homeassistant.auth.providers.{provider}\"\n        )\n    except ImportError:\n        _LOGGER.exception(\n            \"Error while loading auth provider module %s\", provider\n        )\n        raise HomeAssistantError(\n            \"Error while loading auth provider module\", provider\n        )\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, \"auth provider\"\n        )\n\n    return module\n\n", "CodeBleu_score": 40.10987518866168}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    store = Store(self._hass, 1, \"user\")\n    data = await store.async_load()\n    if data is None:\n        self._users = []\n        return\n    if not isinstance(data, list):\n        raise HomeAssistantError(\"Invalid user data\")\n    self._users = data\n    for user in self._users:\n        if not isinstance(user, Mapping):\n            raise HomeAssistantError(\"Invalid user data\")\n        if CONF_ID not in user:\n            raise HomeAssistantError(\"Invalid user data\")\n        if not isinstance(user[CONF_ID], str):\n            raise HomeAssistantError(\"Invalid user data\")\n        if not user[CONF_ID].isalnum():\n            raise HomeAssistantError(\n                \"Invalid user data: Usernames can only contain alphanumeric characters\"\n            )\n        if user[CONF_ID] != user[CONF_ID].lower():\n            raise HomeAssistantError(\n                \"Invalid user data: Usernames can only contain lowercase characters\"\n            )\n\n", "CodeBleu_score": 16.398905629148793}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self._store.async_load()\n    except FileNotFoundError:\n        data = {}\n\n    if data is None:\n        data = {}\n\n    if not isinstance(data, Mapping):\n        raise ValueError(\"Invalid data format\")\n\n    for username, user_data in data.items():\n        if not isinstance(user_data, Mapping):\n            raise ValueError(f\"Invalid data format for user {username}\")\n\n        if not user_data.get(\"username\"):\n            raise ValueError(f\"Missing username for user {username}\")\n\n        if not user_data.get(\"password_hash\"):\n            raise ValueError(f\"Missing password hash for user {username}\")\n\n    self._users = data\n\n", "CodeBleu_score": 32.18658433754745}, {"code": "async def async_load(self) -> None\n\t\n    store = Store(self._hass, 1, \"auth\")\n    data = await store.async_load()\n    if data is None:\n        data = {\n            \"users\": [],\n        }\n    else:\n        for user in data[\"users\"]:\n            if not isinstance(user[CONF_ID], str):\n                user[CONF_ID] = user[CONF_ID].id\n        data[\"users\"] = [user for user in data[\"users\"] if user[CONF_ID]]\n    self._data = data\n    self._users = self._data[\"users\"]\n\n", "CodeBleu_score": 35.77082455327402}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    normalized_username = username.lower()\n    dummy_hash = bcrypt.gensalt()\n    for user in self._users:\n        if user[CONF_ID] == normalized_username:\n            stored_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise InvalidAuth()\n    bcrypt.checkpw(password.encode(), dummy_hash)\n    raise InvalidAuth()\n\n", "CodeBleu_score": 41.573910458451714}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    password_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[CONF_ID] == username:\n            password_hash = base64.b64decode(user[\"password\"])\n            break\n    if not bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n        raise InvalidAuth\n\n", "CodeBleu_score": 38.504508320429615}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    # Normalize the provided username\n    username = username.lower().strip()\n\n    # Initialize a dummy hash to prevent timing attacks\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n\n    # Iterate through all users to find a matching username\n    for user in self.users:\n        if user[CONF_ID] == username:\n            # Decode the stored password hash\n            stored_hash = base64.b64decode(user[\"password\"].encode())\n\n            # Use bcrypt's timing-safe check to compare the provided password with the stored hash\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n\n    # If no matching user is found, raise an \"InvalidAuth\" exception\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth()\n\n", "CodeBleu_score": 40.53677569127798}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    del self.users[username]\n    await self.store.async_save(self.users)\n\n", "CodeBleu_score": 21.330416346072717}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    users = await self.async_get_users()\n    if username not in users:\n        raise InvalidUser(\"user_not_found\")\n    users.pop(username)\n    await self.async_save_users(users)\n\n", "CodeBleu_score": 25.043804747128824}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    if username in self._users:\n        del self._users[username]\n    else:\n        raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 18.055468433616195}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    await self.async_initialize()\n    try:\n        await self.async_remove_credentials(credentials)\n    except InvalidUser as err:\n        _LOGGER.info(\n            \"User %s is not valid, ignoring\", credentials[CONF_ID]\n        )\n        return\n\n", "CodeBleu_score": 42.714499933657365}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    await self._async_initialize()\n\n    try:\n        await self._async_remove_credentials(credentials)\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 33.30425331256067}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n    try:\n        self._data.remove_credentials(credentials)\n        await self.async_save()\n    except ValueError:\n        _LOGGER.warning(\"Removing credentials for %s failed\", credentials.username)\n\n", "CodeBleu_score": 50.18462185846455}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            pass\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n        elif log:\n            logging.warning(f\"Thread {thread.ident} is still running\")\n    for thread in threads - joined:\n        try:\n            thread.raise_exception()\n        except SystemExit:\n            pass\n    return joined\n\n", "CodeBleu_score": 45.28624085700114}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread.join(timeout=timeout)\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n    if log:\n        for thread in threads:\n            if thread.is_alive():\n                logging.warning(\n                    f\"Thread {thread.ident} ({thread.name}) is still running after {timeout} seconds\"\n                )\n    for thread in threads - joined:\n        thread.raise_exception(SystemExit)\n    return joined\n\n", "CodeBleu_score": 45.7636410559938}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        thread.join(timeout)\n        if thread.is_alive():\n            if log:\n                logging.warning(\n                    f\"Thread {thread.name} ({thread.ident}) did not terminate within {timeout} seconds\"\n                )\n            thread.raise_exc = SystemExit\n        else:\n            joined.add(thread)\n    for thread in threads - joined:\n        thread.raise_exc = SystemExit\n    return joined\n\n", "CodeBleu_score": 42.972941116797216}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    timeout = 0.01\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.is_daemon()\n    ]\n    for thread in threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            logging.warning(f\"Thread {thread.name} did not shut down in time.\")\n\n", "CodeBleu_score": 33.42893593581702}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    remaining_threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread != threading.main_thread() and not thread.is_daemon()\n    ]\n    total_timeout = 5\n    timeout = total_timeout / len(remaining_threads)\n    for thread in remaining_threads:\n        try:\n            thread.join(timeout=timeout)\n        except Exception as e:\n            logging.warning(\n                f\"Failed to join thread {thread.name} ({thread.ident}): {e}\"\n            )\n\n", "CodeBleu_score": 41.45762150476693}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get all non-main, non-daemon, alive threads\n    threads = [\n        t\n        for t in threading.enumerate()\n        if t != threading.main_thread() and not t.daemon and t.is_alive()\n    ]\n\n    # Calculate the timeout for each thread\n    timeout = 1.0 / len(threads)\n\n    # Join each thread within the calculated timeout\n    for t in threads:\n        try:\n            t.join(timeout)\n        except Exception as e:\n            logging.warning(\n                f\"Failed to join thread {t.name} with timeout {timeout}: {e}\"\n            )\n\n", "CodeBleu_score": 29.36619841691403}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self.internal_dispatcher.dispatch(\n            \"setup_remaining\", remaining_with_setup_started\n        )\n    self._remaining_with_setup_started = remaining_with_setup_started\n\n", "CodeBleu_score": 44.82697393916446}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._internal_dispatcher.send(\n            self._internal_dispatcher.SIGNAL_DISPATCH,\n            remaining_with_setup_started=remaining_with_setup_started,\n        )\n    self._remaining_with_setup_started = {}\n\n", "CodeBleu_score": 45.213245269665755}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self._internal_dispatcher.send(\n            self._remaining_with_setup_started,\n            remaining_with_setup_started=remaining_with_setup_started,\n        )\n    self._remaining_with_setup_started = remaining_with_setup_started\n\n\n def _async_dispatch_setup_started(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_setup_started\" dispatches a signal for a setup started event.", "CodeBleu_score": 45.24266544876055}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Initialize the Bluetooth content\n    bluetooth_content = BluetoothContent()\n    # Iterate over the integrations\n    for integration in integrations.values():\n        # Check if the integration is a Bluetooth integration\n        if integration.bluetooth:\n            # Get the Bluetooth integration\n            bluetooth_integration = integration.bluetooth\n            # Add the Bluetooth integration to the Bluetooth content\n            bluetooth_content.add_integration(bluetooth_integration)\n    # Generate the Bluetooth content\n    bluetooth_content.generate()\n    # Get the current content of bluetooth.py\n    current_content = config.get_bluetooth_content()\n    # Check if the current content is different from the generated content\n    if current_content != bluetooth_content.content:\n        # Add an error to the configuration indicating that bluetooth.py is not up to date\n        config.add_error(\"bluetooth.py is not up to date\", fixable=True)\n        # Add a fixable suggestion to the configuration to update bluetooth.py\n        config.add_suggestion(\"Update bluetooth.py\", fixable=True)\n        # Add the generated content to the configuration\n        config.add_bluetooth_content(bluetooth_content.content)\n    # Return None\n    return None", "CodeBleu_score": 37.34741818832804}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Generate the Bluetooth content based on the provided integrations\n    bluetooth_content = generate_bluetooth_content(integrations)\n\n    # Check if the generated content is different from the current content of bluetooth.py\n    if bluetooth_content != config.cache.get(\"bluetooth\", \"\"):\n        # Add an error to the configuration indicating that bluetooth.py is not up to date\n        config.add_error(\n            \"bluetooth.py is not up to date\",\n            \"Update bluetooth.py to match the latest integrations\",\n            fixable=True,\n            fix=lambda: config.cache.set(\"bluetooth\", bluetooth_content),\n        )\n\n\n\n", "CodeBleu_score": 31.84514421710517}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    generated_content = generate_bluetooth_content(integrations)\n    if not config.bluetooth_content:\n        config.bluetooth_content = generated_content\n    elif config.bluetooth_content != generated_content:\n        config.add_error('bluetooth.py is not up to date', fixable_suggestion=f'Add the following content to your bluetooth.py:\n", "CodeBleu_score": 28.79105054373175}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tlogger.Info(\"refresh token\")\n\tclient := resty.New()\n\tclient.SetTimeout(d.timeout)\n\tclient.SetDebug(d.debug)\n\tclient.SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tresp, err := client.R().\n\t\tSetHeader(\"Authorization\", \"Basic \"+d.appKey).\n\t\tSetBody(fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s\", d.refreshToken)).\n\t\tPost(fmt.Sprintf(\"https://%s/oauth2/token\", d.endpoint))\n\tif err != nil {\n\t\tlogger.Error(\"refresh token failed\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"refresh token failed\", zap.Any(\"response\", resp))\n\t\treturn fmt.Errorf(\"refresh token failed: %s\", resp.String())\n\t}\n\n\ttokenResp := struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}{}\n\tif err := base.Json.Unmarshal(resp.Body(), &tokenResp); err != nil {\n\t\tlogger.Error(\"refresh token failed\", zap.Error(err))\n\t\treturn err\n\t}\n\n\td.accessToken = tokenResp.AccessToken\n\tlogger.Info(\"refresh token success\", zap.String(\"access_token\", d.accessToken))\n\treturn nil\n}", "CodeBleu_score": 46.098725436376554}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp, err := d.client.R().\n\t\tSetBody(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.refreshToken,\n\t\t}).\n\t\tSetResult(&base.TokenResp{}).\n\t\tPost(\"https://api.dropboxapi.com/oauth2/token\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif resp.IsError() {\n\t\tlogger.Error(\"refresh token\", zap.String(\"response\", resp.String()))\n\t\treturn fmt.Errorf(\"refresh token error\")\n\t}\n\td.accessToken = resp.Result().(*base.TokenResp).AccessToken\n\treturn nil\n}", "CodeBleu_score": 53.443983996105096}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tlogger.Info(\"Refreshing Dropbox access token\")\n\n\tresp, err := d.client.R().\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.refreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).\n\t\tPost(d.tokenEndpoint)\n\n\tif err != nil {\n\t\tlogger.Error(\"Error refreshing Dropbox access token\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"Error refreshing Dropbox access token\", zap.Error(fmt.Errorf(\"error refreshing Dropbox access token: %s\", resp.Status())))\n\t\treturn fmt.Errorf(\"error refreshing Dropbox access token: %s\", resp.Status())\n\t}\n\n\ttokenResp := &TokenResponse{}\n\terr = base.Unmarshal(resp.Body(), tokenResp)\n\tif err != nil {\n\t\tlogger.Error(\"Error unmarshalling Dropbox access token response\", zap.Error(err))\n\t\treturn err\n\t}\n\n\td.accessToken = tokenResp.AccessToken\n\n\tlogger.Info(\"Dropbox access token refreshed successfully\")\n\n\treturn nil\n}", "CodeBleu_score": 49.173685894135765}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\td.Lock()\n\tdefer d.Unlock()\n\n\treq := resty.New().R()\n\treq.SetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.accessToken))\n\treq.SetHeader(\"Content-Type\", \"application/json\")\n\treq.SetHeader(\"Accept\", \"application/json\")\n\treq.SetHeader(\"Drive-API-Version\", \"3\")\n\treq.SetHeader(\"X-Goog-Drive-Use-Restricted-User-Agent\", \"true\")\n\treq.SetHeader(\"X-Goog-Drive-Shared-With-Me-Link-Sharing\", \"true\")\n\treq.SetHeader(\"X-Goog-Drive-Shared-With-Me-Link-Sharing-Permission-Level\", \"anyoneWithLink\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tvar respBody []byte\n\tvar err error\n\n\tfor i := 0; i < d.retryCount; i++ {\n\t\tif resp != nil {\n\t\t\t_, err = req.SetResult(resp).Send(method, url)\n\t\t} else {\n\t\t\trespBody, err = req.Send(method, url)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tlog.Error(\"request failed\", zap.Error(err))\n\t\t\tif utils.IsRetryableError(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif respBody != nil {\n\t\t\treturn respBody, nil\n\t\t}\n\n\t\tlog.Error(\"request failed\", zap.Error(err))\n\t\tif utils.IsRetryableError(err) {\n\t\t\tcontinue\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn nil, err\n}", "CodeBleu_score": 48.60281147175263}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tclient := resty.New()\n\tclient.SetDebug(true)\n\n\treq := client.R()\n\treq.SetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.token.AccessToken))\n\treq.SetHeader(\"Content-Type\", \"application/json\")\n\treq.SetHeader(\"Accept\", \"application/json\")\n\treq.SetHeader(\"X-Goog-Drive-Api-Version\", \"2\")\n\treq.SetHeader(\"X-Goog-Drive-Use-Restricted-Api\", \"true\")\n\treq.SetHeader(\"X-Goog-Drive-Shared-With-Me-Authorized-User\", \"true\")\n\treq.SetHeader(\"X-Goog-Drive-Shared-With-Me-Authorized-User-Identity\", \"true\")\n\treq.SetHeader(\"X-Goog-Drive-Shared-With-Me-Authorized-User-Identity-Email\", \"true\")\n\treq.SetHeader(\"X-Goog-Drive-Shared-With-Me-Authorized-User-Identity-Name\", \"true\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tvar err error\n\tvar respBody []byte\n\n\tfor i := 0; i < 3; i++ {\n\t\tif resp != nil {\n\t\t\t_, err = req.SetResult(resp).Send(method, url)\n\t\t} else {\n\t\t\trespBody, err = req.Send(method, url)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tlog.Error(\"request failed:\", err)\n\t\t\tif utils.Is401Error(err) {\n\t\t\t\td.refreshToken()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\n\t\tbreak\n\t}\n\n\treturn respBody, nil\n}", "CodeBleu_score": 45.63760276901952}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := resty.New().R().SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken).SetHeader(\"Content-Type\", \"application/json\").SetHeader(\"Accept\", \"application/json\")\n\n\tif d.SupportAllDrives {\n\t\treq.SetHeader(\"X-Goog-Drive-Api-Support-All-Drives\", \"true\")\n\t}\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tvar err error\n\tvar respBody []byte\n\n\tretryCount := 0\n\tfor {\n\t\trespBody, err = req.Execute(method, url).Body()\n\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\n\t\t\tif respErr, ok := err.(*resty.ResponseError); ok {\n\t\t\t\tif respErr.Response.StatusCode() == http.StatusUnauthorized {\n\t\t\t\t\tlog.Info(\"Google Drive access token expired, refreshing...\")\n\t\t\t\t\terr = d.refreshToken()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tretryCount++\n\t\t\t\t\tif retryCount > 3 {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"failed to refresh Google Drive access token after %d retries\", retryCount)\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil, err\n\t\t}\n\n\t\tbreak\n\t}\n\n\treturn respBody, nil\n}", "CodeBleu_score": 54.98113438821284}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 1024 // 1GB\n\tbuf := make([]byte, chunkSize)\n\tuploadedBytes := 0\n\n\tfor {\n\t\tn, err := stream.Read(buf)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, bytes.NewReader(buf[:n]))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", uploadedBytes, uploadedBytes+n-1, stream.Size()))\n\n\t\tresp, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent {\n\t\t\treturn fmt.Errorf(\"failed to upload chunk, status code: %d\", resp.StatusCode)\n\t\t}\n\n\t\tuploadedBytes += n\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 40.8883679020071}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 1024\n\tchunk := make([]byte, chunkSize)\n\n\toffset := 0\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tn, err := stream.Read(chunk)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treq, err := http.NewRequestWithContext(ctx, \"PUT\", url, bytes.NewReader(chunk[:n]))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+n-1, stream.Size()))\n\n\t\t\tresp, err := d.client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\tif resp.StatusCode != http.StatusNoContent {\n\t\t\t\tbody, err := io.ReadAll(resp.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn fmt.Errorf(\"failed to upload chunk: %s\", string(body))\n\t\t\t}\n\n\t\t\toffset += n\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.03345488638772}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 15 // 15MB\n\tchunk := make([]byte, chunkSize)\n\n\tuploaded := 0\n\n\tfor {\n\t\tn, err := stream.Read(chunk)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\treq, err := http.NewRequest(\"PUT\", url, bytes.NewReader(chunk[:n]))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.Header.Set(\"Content-Length\", strconv.Itoa(n))\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", uploaded, uploaded+n-1, stream.Size()))\n\n\t\tresp, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent {\n\t\t\treturn fmt.Errorf(\"upload failed: %s\", resp.Status)\n\t\t}\n\n\t\tuploaded += n\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.62672038512228}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tmountPoint := ctx.Get(\"mount_point\").(string)\n\tif mountPoint == \"\" {\n\t\treturn httper.SetResponse(ctx, common_err.ERROR_INVALID_PARAMS, nil, http.StatusBadRequest)\n\t}\n\n\terr := service.UmountStorage(mountPoint)\n\tif err != nil {\n\t\treturn httper.SetResponse(ctx, common_err.ERROR_STORAGE_UNMOUNT_FAIL, err, http.StatusInternalServerError)\n\t}\n\n\terr = service.DeleteStorageConfig(mountPoint)\n\tif err != nil {\n\t\treturn httper.SetResponse(ctx, common_err.ERROR_STORAGE_UNMOUNT_FAIL, err, http.StatusInternalServerError)\n\t}\n\n\treturn httper.SetResponse(ctx, common_err.SUCCESS, nil, http.StatusOK)\n}", "CodeBleu_score": 38.9972624046301}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tmountPoint := ctx.Bind(&model.UmountStorageReq{}).(*model.UmountStorageReq).MountPoint\n\tif mountPoint == \"\" {\n\t\treturn httper.SetBadRequestError(ctx, common_err.ErrInvalidParam)\n\t}\n\n\tstorage, err := service.GetStorageByMountPoint(mountPoint)\n\tif err != nil {\n\t\tlogger.Error(\"get storage by mount point failed\", zap.Error(err))\n\t\treturn httper.SetInternalServerError(ctx, common_err.ErrGetStorageByMountPoint)\n\t}\n\n\tswitch storage.Driver {\n\tcase \"onedrive\":\n\t\tif err := onedrive.Umount(storage.MountPoint); err != nil {\n\t\t\tlogger.Error(\"umount storage failed\", zap.Error(err))\n\t\t\treturn httper.SetInternalServerError(ctx, common_err.ErrUmountStorage)\n\t\t}\n\tcase \"google_drive\":\n\t\tif err := google_drive.Umount(storage.MountPoint); err != nil {\n\t\t\tlogger.Error(\"umount storage failed\", zap.Error(err))\n\t\t\treturn httper.SetInternalServerError(ctx, common_err.ErrUmountStorage)\n\t\t}\n\tcase \"dropbox\":\n\t\tif err := dropbox.Umount(storage.MountPoint); err != nil {\n\t\t\tlogger.Error(\"umount storage failed\", zap.Error(err))\n\t\t\treturn httper.SetInternalServerError(ctx, common_err.ErrUmountStorage)\n\t\t}\n\tdefault:\n\t\tlogger.Error(\"umount storage failed\", zap.Error(common_err.ErrUmountStorage))\n\t\treturn httper.SetInternalServerError(ctx, common_err.ErrUmountStorage)\n\t}\n\n\tif err := service.DeleteStorageByMountPoint(mountPoint); err != nil {\n\t\tlogger.Error(\"delete storage failed\", zap.Error(err))\n\t\treturn httper.SetInternalServerError(ctx, common_err.ErrDeleteStorage)\n\t}\n\n\treturn httper.SetOK(ctx, nil)\n}", "CodeBleu_score": 37.99212317129069}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tstorage := model.Storage{}\n\tif err := ctx.Bind(&storage); err != nil {\n\t\treturn httper.Wrap(err, common_err.ErrInvalidParam)\n\t}\n\tif storage.MountPoint == \"\" {\n\t\treturn httper.Wrap(nil, common_err.ErrInvalidParam)\n\t}\n\n\tif err := service.UmountStorage(storage.MountPoint); err != nil {\n\t\treturn httper.Wrap(err, common_err.ErrStorageUnmountFailed)\n\t}\n\n\tif err := service.DeleteStorageConfig(storage.MountPoint); err != nil {\n\t\treturn httper.Wrap(err, common_err.ErrStorageUnmountFailed)\n\t}\n\n\treturn httper.Ok(ctx)\n}", "CodeBleu_score": 31.116050740830776}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrInvalidParam)\n\t}\n\n\tfilePath = utils.GetLocalPath(filePath)\n\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.ErrFileNotFound)\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 35.3862241986338}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, model.Result{Success: false, Message: \"file path is missing\"})\n\t}\n\n\tfilePath = path.Join(utils.GetLocalFilePath(), filePath)\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, model.Result{Success: false, Message: \"file not found\"})\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 44.12741067382988}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrMissingPath)\n\t}\n\n\tfilePath = path.Clean(filePath)\n\n\t_, err := os.Stat(filePath)\n\tif os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.ErrFileNotFound)\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 37.236984317611146}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.New(common_err.BadRequest, err.Error())\n\t}\n\n\tif err := service.NotifyService.Send(name, message); err != nil {\n\t\treturn common_err.New(common_err.BadRequest, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, model.Result{\n\t\tSuccess: true,\n\t\tMessage: \"success\",\n\t})\n}", "CodeBleu_score": 64.77982088653806}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.New(common_err.BadRequest, err.Error())\n\t}\n\n\terr := service.NotifyService.Send(name, message)\n\tif err != nil {\n\t\treturn common_err.New(common_err.BadRequest, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, model.Result{\n\t\tSuccess: true,\n\t\tMessage: \"ok\",\n\t})\n}", "CodeBleu_score": 64.64006259247998}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.New(common_err.BadRequest, err.Error())\n\t}\n\tservice.NotifyMessage(name, message)\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: common_err.Success})\n}", "CodeBleu_score": 54.338722619337666}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupgrader := websocket.Upgrader{}\n\tc, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer c.Close()\n\n\tservice.AddNotifyConn(c)\n\tgo service.NotifyService()\n\n\tfor {\n\t\tmt, message, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"recv:\", mt, string(message), err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.15322139489548}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupgrader := websocket.Upgrader{}\n\tc, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer c.Close()\n\n\tservice.AddNotifyConn(c)\n\n\tgo service.NotifyMsgSendService()\n\n\tfor {\n\t\tmt, message, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"recv:\", mt, string(message), err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.32399826938405}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\tc, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tservice.AddWS(c)\n\tservice.StartSendService()\n\n\tgo func() {\n\t\tfor {\n\t\t\tmt, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tservice.RemoveWS(c)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfmt.Println(\"recv:\", mt, string(message), err)\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 44.09130728597137}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tinfo := model.GetSystemHardwareInfo()\n\n\tif info == nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.ErrSystemNotSupported.WithData(\"\"))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.Success.WithData(info))\n}", "CodeBleu_score": 16.580724692475574}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tcpuInfo := service.GetCPUInfo()\n\tif cpuInfo == nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.CommonError{\n\t\t\tCode:    common_err.SUCCESS,\n\t\t\tMessage: \"Get system hardware info success\",\n\t\t\tData:    nil,\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.CommonError{\n\t\tCode:    common_err.SUCCESS,\n\t\tMessage: \"Get system hardware info success\",\n\t\tData:    cpuInfo,\n\t})\n}", "CodeBleu_score": 27.630645743425887}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\n\ttype HardwareInfo struct {\n\t\tDriveModel  string `json:\"drive_model\"`\n\t\tArchitecture string `json:\"architecture\"`\n\t\tCPUInfo     *model.CPUInfo `json:\"cpu_info,omitempty\"`\n\t}\n\n\tinfo := HardwareInfo{\n\t\tDriveModel:  utils.GetDriveModel(),\n\t\tArchitecture: runtime.GOARCH,\n\t}\n\n\tcpuInfo, err := utils.GetCPUInfo()\n\tif err == nil {\n\t\tinfo.CPUInfo = cpuInfo\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common.SuccessPayload(info))\n}", "CodeBleu_score": 21.768981667014504}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.Status == \"running\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 73.49606056498284}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.Name == \"casaos\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-agent\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-docker\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-k8s\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-compose\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-podman\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-lxd\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-rancher\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-swarm\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-nomad\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-mesos\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-k3s\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-rke\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-openshift\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"casaos-ui-agent-eks\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name == \"", "CodeBleu_score": 34.162198015000136}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 79.59633022603168}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageStr, err := json2.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"marshal message error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tif err := i.mq.Publish(ctx, notify.NotifyExchange, name, messageStr); err != nil {\n\t\tlogger.Error(\"publish message error\", zap.Error(err))\n\t}\n}", "CodeBleu_score": 33.06444664562169}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageStr, err := json2.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"marshal message error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tres, err := i.messageBus.Publish(context.Background(), name, messageStr)\n\tif err != nil {\n\t\tlogger.Error(\"publish message error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tif res.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"publish message error\", zap.Any(\"response\", res))\n\t\treturn\n\t}\n}", "CodeBleu_score": 37.362023666216956}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmsg, err := json2.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"marshal message\", zap.Error(err))\n\t\treturn\n\t}\n\ti.publish(name, string(msg))\n}", "CodeBleu_score": 18.14390409843804}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.messageBusAddress, websocket.DefaultDialer)\n\treturn client\n}", "CodeBleu_score": 11.629528505382721}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.config.MessageBus.Server, c.config.MessageBus.Client.Transport)\n\tclient.Client = external.NewClientWithResponses(c.config.MessageBus.Server, c.config.MessageBus.Client.Transport)\n\treturn client\n}", "CodeBleu_score": 32.32412385028632}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tif c.messageBusClient != nil {\n\t\treturn c.messageBusClient\n\t}\n\n\tclient := message_bus.NewClientWithResponses(\"http://\" + c.getRuntimePath() + \":12345\", &message_bus.ClientWithResponsesOpts{\n\t\tBaseURL: \"http://\" + c.getRuntimePath() + \":12345\",\n\t\tHTTPClient: external.NewHTTPClient().Client,\n\t})\n\n\tc.messageBusClient = client\n\n\treturn client\n}", "CodeBleu_score": 35.55609726111836}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\n\tif strings.Contains(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\tif strings.Contains(ip, \"::ffff:\") {\n\t\tip = strings.Replace(ip, \"::ffff:\", \"\", -1)\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 55.95734259825683}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\n\tif strings.Contains(ip, \"::\") {\n\t\tip = strings.Replace(ip, \"::\", \"\", -1)\n\t}\n\n\tif strings.Contains(ip, \"::ffff:\") {\n\t\tip = strings.Replace(ip, \"::ffff:\", \"\", -1)\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 50.562835949330406}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\n\tif strings.Contains(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.Contains(ip, \"::ffff:\") {\n\t\tip = strings.Replace(ip, \"::ffff:\", \"\", 1)\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 56.976671700559635}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesDir := filepath.Join(config.GetConfig().System.ModuleDir)\n\tentryFilePath := filepath.Join(modulesDir, \"entry.json\")\n\n\tentries := make([]model.SystemEntry, 0)\n\n\tdirs, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlogger.Error(\"read modules dir error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tfor _, dir := range dirs {\n\t\tif !dir.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tentryFile := filepath.Join(modulesDir, dir.Name(), \"entry.json\")\n\t\tif !file.Exists(entryFile) {\n\t\t\tcontinue\n\t\t}\n\n\t\tentryContent, err := os.ReadFile(entryFile)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"read entry file error\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tvar entry model.SystemEntry\n\t\terr = json.Unmarshal(entryContent, &entry)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"unmarshal entry file error\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, entry)\n\t}\n\n\tentryContent, err := json.Marshal(entries)\n\tif err != nil {\n\t\tlogger.Error(\"marshal entry file error\", zap.Error(err))\n\t\treturn\n\t}\n\n\terr = os.WriteFile(entryFilePath, entryContent, 0644)\n\tif err != nil {\n\t\tlogger.Error(\"write entry file error\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 57.77203540958896}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesDir := filepath.Join(common.GetSystemPath(), \"modules\")\n\tentryFile := filepath.Join(modulesDir, \"entry.json\")\n\n\t// Check if the entry file exists\n\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\t// Create the entry file if it doesn't exist\n\t\terr = os.MkdirAll(modulesDir, 0755)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to create modules directory\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\n\t\t_, err = os.Create(entryFile)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to create entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tentries := make([]model.ModuleEntry, 0)\n\tmodules, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlogger.Error(\"failed to read modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\tfor _, module := range modules {\n\t\tif !module.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tentryPath := filepath.Join(modulesDir, module.Name(), \"entry.json\")\n\t\tentryBytes, err := os.ReadFile(entryPath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to read entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tvar entry model.ModuleEntry\n\t\terr = json.Unmarshal(entryBytes, &entry)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to unmarshal entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, entry)\n\t}\n\n\t// Write the entries to the entry file\n\tentryBytes, err := json.Marshal(entries)\n\tif err != nil {\n\t\tlogger.Error(\"failed to marshal entries\", zap.Error(err))\n\t\treturn\n\t}\n\n\terr = os.WriteFile(", "CodeBleu_score": 49.643659878804634}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesPath := config.GetModulesPath()\n\tentryFilePath := filepath.Join(modulesPath, \"entry.json\")\n\n\t// Check if the entry file exists\n\tif _, err := os.Stat(entryFilePath); err == nil {\n\t\t// Entry file exists, delete it\n\t\tif err := os.Remove(entryFilePath); err != nil {\n\t\t\tlogger.Error(\"Failed to delete existing entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Create the entry file\n\tif err := os.MkdirAll(filepath.Dir(entryFilePath), 0755); err != nil {\n\t\tlogger.Error(\"Failed to create entry file directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\tentryFile, err := os.Create(entryFilePath)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\n\t// Write the JSON array to the entry file\n\tentryFile.WriteString(\"[\")\n\n\t// Read each module directory for entry.json files\n\tmodules, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to read modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\tfor _, module := range modules {\n\t\tif !module.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tmodulePath := filepath.Join(modulesPath, module.Name())\n\t\tentryPath := filepath.Join(modulePath, \"entry.json\")\n\n\t\t// Check if the entry file exists\n\t\tif _, err := os.Stat(entryPath); err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Read the entry file\n\t\tentryFile, err := os.Open(entryPath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to open entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdefer entryFile.Close()\n\n\t\tentryBytes, err := io.ReadAll(entryFile)\n\t\tif", "CodeBleu_score": 45.37353923941742}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.systemService.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, netName := range netNames {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 65.48186327184668}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net2.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnames, err := c.systemService.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range names {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 64.18508431441373}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.systemService.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, netName := range netNames {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 65.48186327184668}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\n  int32_t rc;\n\n  SAppObj *pAppObj;\n\n  SRequestObj *pRequestObj;\n\n  /*\n   * Add a reference to the request object.\n   */\n  rc = addRef(pRequest, sizeof(SRequestObj));\n  if (rc != TC_SUCCESS) {\n    return rc;\n  }\n\n  /*\n   * Increment the request count for the associated TSC object.\n   */\n  pTscObj->requestCount++;\n\n  /*\n   * If the TSC object has application information, update the application's request summary, including total and current request counts.\n   */\n  if (pTscObj->pAppObj != NULL) {\n    pAppObj = pTscObj->pAppObj;\n\n    pAppObj->requestCount++;\n\n    pAppObj->requestCountCur = pTscObj->requestCount;\n  }\n\n  /*\n   * Log debug information about the new request.\n   */\n  logDebug(\"New request: %s %s %s %s %s\", pRequest->pUrl->pPath, pRequest->pUrl->pQuery, pRequest->pUrl->pFragment, pRequest->pUrl->pUserInfo, pRequest->pUrl->pHost);\n\n  /*\n   * Return a success code.\n   */\n  return TC_SUCCESS;\n}", "CodeBleu_score": 37.579556681551985}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t retVal = SUCCESS;\n\n    if (pRequest != NULL && pTscObj != NULL) {\n        if (pTscObj->pAppInfo != NULL) {\n            pTscObj->pAppInfo->totalReqs++;\n            pTscObj->pAppInfo->currReqs++;\n            updateAppReqSummary(pTscObj->pAppInfo);\n        }\n\n        addRef(pRequest);\n        pTscObj->reqCount++;\n\n        LOG_DEBUG(\"New request %d for TSC %d\", pRequest->reqId, pTscObj->tscId);\n    } else {\n        retVal = ERR_INVALID_PARAM;\n    }\n\n    return retVal;\n}", "CodeBleu_score": 31.48138704367297}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t retCode = SUCCESS;\n\n    if (pRequest == NULL || pTscObj == NULL) {\n        return INVALID_PARAM;\n    }\n\n    /*\n     * Add a reference to the request object.\n     */\n    trefAddRef(pRequest);\n\n    /*\n     * Increment the request count for the TSC object.\n     */\n    pTscObj->requestCount++;\n\n    /*\n     * If the TSC object has application information, update the application's request summary.\n     */\n    if (pTscObj->pAppInfo != NULL) {\n        pTscObj->pAppInfo->totalRequestCount++;\n        pTscObj->pAppInfo->currentRequestCount++;\n    }\n\n    /*\n     * Log debug information about the new request.\n     */\n    logDebug(\"Request added: %s %s %s %s\", pRequest->pUrl, pRequest->pMethod, pRequest->pBody, pRequest->pHeaders);\n\n    return retCode;\n}", "CodeBleu_score": 32.01648350214696}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    char *pDbName = NULL;\n    char *pSchemaName = NULL;\n    char *pDbName2 = NULL;\n    char *pSchemaName2 = NULL;\n    int n = 0;\n\n    if (pRequest == NULL) {\n        return true;\n    }\n\n    if (exceptDb == NULL) {\n        return true;\n    }\n\n    pDbName = pRequest->pDbName;\n    pSchemaName = pRequest->pSchemaName;\n\n    if (pDbName != NULL && strcmp(pDbName, exceptDb) == 0) {\n        return false;\n    }\n\n    if (pSchemaName != NULL && strcmp(pSchemaName, exceptDb) == 0) {\n        return false;\n    }\n\n    n = pRequest->nDb;\n\n    for (int i = 0; i < n; i++) {\n        pDbName2 = pRequest->pDbNameList[i];\n        pSchemaName2 = pRequest->pSchemaNameList[i];\n\n        if (pDbName2 != NULL && strcmp(pDbName2, exceptDb) == 0) {\n            return false;\n        }\n\n        if (pSchemaName2 != NULL && strcmp(pSchemaName2, exceptDb) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 50.29902544726943}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    char *db;\n    if (strcmp(pRequest->pPrimary->db, exceptDb) != 0) {\n        for (db = pRequest->pPrimary->db; *db != '\\0'; db++) {\n            if (*db == '.') {\n                db++;\n                break;\n            }\n        }\n        if (strcmp(db, exceptDb) == 0) {\n            return false;\n        }\n        for (db = pRequest->pSecondary->db; *db != '\\0'; db++) {\n            if (*db == '.') {\n                db++;\n                break;\n            }\n        }\n        if (strcmp(db, exceptDb) == 0) {\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 46.023814753690694}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    int i;\n    char *dbName;\n    char *schemaName;\n    char *dbNameExcept;\n    int dbNameLen;\n    int dbNameExceptLen;\n    char *dbNameExceptLower;\n    char *dbNameLower;\n    int dbNameLenLower;\n    int dbNameExceptLenLower;\n    int rc;\n\n    dbName = pRequest->dbName;\n    dbNameExcept = exceptDb;\n    dbNameLen = strlen(dbName);\n    dbNameExceptLen = strlen(dbNameExcept);\n    dbNameExceptLower = (char *)malloc(dbNameExceptLen + 1);\n    dbNameLower = (char *)malloc(dbNameLen + 1);\n    if (dbNameExceptLower == NULL || dbNameLower == NULL) {\n        return false;\n    }\n    strcpy(dbNameExceptLower, dbNameExcept);\n    strcpy(dbNameLower, dbName);\n    dbNameExceptLenLower = strlen(dbNameExceptLower);\n    dbNameLenLower = strlen(dbNameLower);\n    for (i = 0; i < dbNameLenLower; i++) {\n        dbNameLower[i] = tolower(dbNameLower[i]);\n    }\n    for (i = 0; i < dbNameExceptLenLower; i++) {\n        dbNameExceptLower[i] = tolower(dbNameExceptLower[i]);\n    }\n    rc = strcmp(dbNameLower, dbNameExceptLower);\n    if (rc == 0) {\n        free(dbNameExceptLower);\n        free(dbNameLower);\n        return false;\n    }\n    for (i = 0; i < pRequest->dbNum; i++) {\n        schemaName = pRequest->db[i]->schemaName;\n        if (schemaName != NULL) {\n            dbName = schemaName;\n            dbNameLen = strlen(dbName);\n            dbNameLower = (char *)malloc(dbNameLen + 1);\n            if (dbNameLower == NULL) {\n                free(dbNameExceptLower", "CodeBleu_score": 35.51421452351502}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  bool rfp = false;\n\n  if (code == TERR_REDIR) {\n    switch (msgType) {\n      case TMSG_RPC:\n      case TMSG_RPC_RESP:\n      case TMSG_RPC_REDIR:\n      case TMSG_RPC_REDIR_RESP:\n        rfp = true;\n        break;\n      default:\n        rfp = false;\n        break;\n    }\n  }\n\n  return rfp;\n}", "CodeBleu_score": 33.94099273846328}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\n    /*\n     * If the error code is not one of the following, redirection is not needed:\n     */\n    if (code != E_TIMEDOUT && code != E_RETRY && code != E_REDIRECT && code != E_REDIRECT_NO_RETRY && code != E_REDIRECT_NO_RETRY_NO_RESPONSE) {\n        return false;\n    }\n\n    /*\n     * If the message type is one of the following, redirection is not needed:\n     */\n    if (msgType == TMSG_RPC_RESPONSE || msgType == TMSG_RPC_RESPONSE_FAILED || msgType == TMSG_RPC_RESPONSE_FAILED_RETRY) {\n        return false;\n    }\n\n    /*\n     * Redirection is needed.\n     */\n    return true;\n}", "CodeBleu_score": 51.1107776542612}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\n    if (code == TERR_NOT_READY) {\n        if (msgType != TMSG_MONITOR_REQ && msgType != TMSG_MONITOR_REP) {\n            return true;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 31.239669914317407}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t    SHashObjIter iter;\n    SHashObjIter_init(&iter, pRequests);\n\n    SHashObj *pRequest;\n    while ((pRequest = SHashObjIter_next(&iter))) {\n        SHashObj *pQuery;\n        if (SHashObj_get(pRequest, \"query\", &pQuery)) {\n            Query *pQueryObj = (Query *) pQuery;\n            if (pQueryObj->pQuery != NULL) {\n                Query_stop(pQueryObj);\n            }\n        }\n\n        SHashObj_release(pRequest);\n    }\n}", "CodeBleu_score": 42.85044872688971}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t    SHashObj *pRequest;\n    SHashIter iter;\n    SHashIter *pIter = &iter;\n    SRequest *pRequestData;\n\n    // Iterate through the hash table\n    while (shashIterate(pRequests, pIter, (void **)&pRequest)) {\n        // Acquire the request\n        pRequestData = (SRequest *)shashGetData(pRequest);\n\n        // Check if the request is valid\n        if (pRequestData) {\n            // Stop the query associated with the request\n            stopQuery(pRequestData->pQuery);\n\n            // Release the request\n            shashRelease(pRequest);\n        }\n    }\n}", "CodeBleu_score": 43.221697884166765}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t    SHashIter iter;\n    SHashIterInit(&iter, pRequests);\n    SHashIterNext(&iter);\n    while (iter.pNode) {\n        SHashNode *pNode = iter.pNode;\n        SHashIterNext(&iter);\n        SRequest *pRequest = (SRequest *) pNode->pData;\n        if (pRequest) {\n            stopRequest(pRequest);\n        }\n    }\n}", "CodeBleu_score": 37.468928153454115}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t    if ( !clientCrashReport ) {\n        return;\n    }\n\n    if ( !atomic_compare_exchange_strong( &clientStop, &clientStop, 1 ) ) {\n        log_printf( LOG_INFO, \"Crash report thread already stopped\n\" );\n        return;\n    }\n\n    while ( clientStop ) {\n        osSleep( 10 );\n    }\n}", "CodeBleu_score": 57.723857993958816}, {"code": "void tscStopCrashReport(){\n\t    if (clientCrashReport != 1) {\n        return;\n    }\n    if (clientStop == 1) {\n        return;\n    }\n    if (atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n        log_warn(\"Crash report thread already stopped\");\n        return;\n    }\n    while (clientStop == 0) {\n        osSleep(100);\n    }\n}", "CodeBleu_score": 63.09513971348404}, {"code": "void tscStopCrashReport(){\n\t    int clientStop;\n    int clientStopNew;\n\n    if (!tscCrashReportEnabled) {\n        return;\n    }\n\n    clientStop = 0;\n    clientStopNew = 1;\n\n    if (tscAtomicCasInt(&clientStop, clientStopNew, &clientStop)) {\n        LOG(LOG_INFO, \"Crash report thread already stopped\");\n        return;\n    }\n\n    while (clientStop) {\n        osSleep(1000);\n    }\n}", "CodeBleu_score": 57.786749176008854}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\n    int32_t rc = TDB_RC_OK;\n\n    struct TRpcViewInfo *pViewInfo = NULL;\n\n    int32_t i = 0;\n\n    int32_t numViews = 0;\n\n    int32_t numCols = 0;\n\n    int32_t viewId = 0;\n\n    int32_t viewColId = 0;\n\n    char *pViewName = NULL;\n\n    char *pViewColName = NULL;\n\n    char *pViewColType = NULL;\n\n    struct TCatalogView *pView = NULL;\n\n    struct TCatalogViewCol *pViewCol = NULL;\n\n    struct TCatalogViewCol *pViewColTmp = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrev = NULL;\n\n    struct TCatalogViewCol *pViewColTmpNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNextNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNextNextNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNextNextNextNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNextNextNextNextNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNextNextNextNextNextNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNextNextNextNextNextNextNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNextNextNextNextNextNextNextNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNextNextNextNextNextNextNextNextNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNextNextNextNextNextNextNextNextNextNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNextNextNextNextNextNextNextNextNextNextNext = NULL;\n\n    struct TCatalogViewCol *pViewColTmpPrevNext", "CodeBleu_score": 10.59411715164209}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\n    int32_t rc;\n\n    int32_t i;\n\n    int32_t numViews;\n\n    int32_t viewId;\n\n    int32_t numColumns;\n\n    int32_t *pViewIds;\n\n    int32_t *pNumColumns;\n\n    int32_t *pColumnIds;\n\n    int32_t *pColumnTypes;\n\n    int32_t *pColumnSizes;\n\n    int32_t *pColumnOffsets;\n\n    char *pViewNames;\n\n    char *pColumnNames;\n\n    struct SViewMetaData *pViewMetaData;\n\n    struct SViewMetaData *pViewMetaData2;\n\n    struct SViewMetaData *pViewMetaData3;\n\n    struct SViewMetaData *pViewMetaData4;\n\n    struct SViewMetaData *pViewMetaData5;\n\n    struct SViewMetaData *pViewMetaData6;\n\n    struct SViewMetaData *pViewMetaData7;\n\n    struct SViewMetaData *pViewMetaData8;\n\n    struct SViewMetaData *pViewMetaData9;\n\n    struct SViewMetaData *pViewMetaData10;\n\n    struct SViewMetaData *pViewMetaData11;\n\n    struct SViewMetaData *pViewMetaData12;\n\n    struct SViewMetaData *pViewMetaData13;\n\n    struct SViewMetaData *pViewMetaData14;\n\n    struct SViewMetaData *pViewMetaData15;\n\n    struct SViewMetaData *pViewMetaData16;\n\n    struct SViewMetaData *pViewMetaData17;\n\n    struct SViewMetaData *pViewMetaData18;\n\n    struct SViewMetaData *pViewMetaData19;\n\n    struct SViewMetaData *pViewMetaData20;\n\n    struct SViewMetaData *pViewMetaData21;\n\n    struct SViewMetaData *pViewMetaData22;\n\n    struct SViewMetaData *pViewMetaData23;\n\n", "CodeBleu_score": 9.527922754892595}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\n    int32_t rc = TM_OK;\n\n    /*\n     * The following variables are used to deserialize the view metadata.\n     */\n    uint8_t *p = (uint8_t *) value;\n    uint8_t *pEnd = p + valueLen;\n\n    /*\n     * The following variables are used to iterate through the view metadata.\n     */\n    uint32_t i;\n    uint32_t j;\n\n    /*\n     * The following variables are used to store the view metadata.\n     */\n    uint32_t viewCount;\n    uint32_t *pViewCount = (uint32_t *) p;\n    p += sizeof(uint32_t);\n\n    /*\n     * The following variables are used to store the view metadata.\n     */\n    uint32_t viewNameLen;\n    uint32_t *pViewNameLen = (uint32_t *) p;\n    p += sizeof(uint32_t);\n\n    /*\n     * The following variables are used to store the view metadata.\n     */\n    uint32_t viewColumnCount;\n    uint32_t *pViewColumnCount = (uint32_t *) p;\n    p += sizeof(uint32_t);\n\n    /*\n     * The following variables are used to store the view metadata.\n     */\n    uint32_t viewColumnNameLen;\n    uint32_t *pViewColumnNameLen = (uint32_t *) p;\n    p += sizeof(uint32_t);\n\n    /*\n     * The following variables are used to store the view metadata.\n     */\n    uint32_t viewColumnType;\n    uint32_t *pViewColumnType = (uint32_t *) p;\n    p += sizeof(uint32_t);\n\n    /*\n     * The following variables are used to store the view metadata.\n     */\n    uint32_t viewColumnTypeLen;\n    uint32_t *pViewColumnTypeLen = (uint32_t *) p;\n    p += sizeof(uint32_t);\n\n   ", "CodeBleu_score": 12.576604564796522}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3UInt64 contentLength = properties->contentLength;\n    if (contentLength > 0) {\n        S3UInt64 *contentLengthPtr = (S3UInt64 *) callbackData;\n        *contentLengthPtr = contentLength;\n    }\n    return S3StatusOK;\n}", "CodeBleu_score": 56.530622836008206}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n\n    if (properties->contentLength > 0) {\n        *(size_t *) callbackData = properties->contentLength;\n    } else {\n        *(size_t *) callbackData = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 66.02762475387327}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3SizeType contentLength = 0;\n    S3Status status = S3StatusOK;\n\n    if (properties) {\n        contentLength = properties->contentLength;\n    }\n\n    if (contentLength > 0) {\n        *(S3SizeType *) callbackData = contentLength;\n    } else {\n        *(S3SizeType *) callbackData = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 56.04721705699944}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t    char *checkpointBackupDir = getenv(\"CHECKPOINT_BACKUP_DIR\");\n    if (checkpointBackupDir == NULL) {\n        logError(\"CHECKPOINT_BACKUP_DIR environment variable not set\");\n        return;\n    }\n\n    // Create the checkpoint backup directory if it doesn't exist\n    if (mkdir(checkpointBackupDir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) == -1 && errno != EEXIST) {\n        logError(\"Failed to create checkpoint backup directory\");\n        return;\n    }\n\n    // Remove empty directories\n    removeEmptyDirectories(checkpointBackupDir);\n\n    // Generate Rsync configuration file\n    char *rsyncConfigFile = generateRsyncConfigFile(checkpointBackupDir);\n    if (rsyncConfigFile == NULL) {\n        logError(\"Failed to generate Rsync configuration file\");\n        return;\n    }\n\n    // Construct and execute Rsync daemon command\n    char *rsyncDaemonCommand = constructRsyncDaemonCommand(rsyncConfigFile);\n    if (rsyncDaemonCommand == NULL) {\n        logError(\"Failed to construct Rsync daemon command\");\n        return;\n    }\n\n    int rsyncDaemonResult = system(rsyncDaemonCommand);\n    if (rsyncDaemonResult == -1) {\n        logError(\"Failed to start Rsync daemon\");\n    } else if (WIFEXITED(rsyncDaemonResult) && WEXITSTATUS(rsyncDaemonResult) == 0) {\n        logInfo(\"Rsync daemon started successfully\");\n    } else {\n        logError(\"Rsync daemon exited with non-zero status\");\n    }\n\n    // Clean up\n    free(rsyncConfigFile);\n    free(rsyncDaemonCommand);\n}", "CodeBleu_score": 30.46011342938745}, {"code": "void startRsync(){\n\t\n    if (!createBackupDir()) {\n        logError(\"Failed to create checkpoint backup directory.\");\n        return;\n    }\n\n    removeEmptyDirs();\n\n    if (!generateRsyncConfig()) {\n        logError(\"Failed to generate Rsync configuration file.\");\n        return;\n    }\n\n    char *rsyncCommand = (char *) malloc(strlen(RSYNC_DAEMON_PATH) + strlen(RSYNC_CONFIG_FILE_PATH) + 20);\n    sprintf(rsyncCommand, \"%s %s -p %d\", RSYNC_DAEMON_PATH, RSYNC_CONFIG_FILE_PATH, RSYNC_PORT);\n\n    if (system(rsyncCommand) == 0) {\n        logInfo(\"Rsync server started successfully.\");\n    } else {\n        logError(\"Failed to start Rsync server.\");\n    }\n\n    free(rsyncCommand);\n}", "CodeBleu_score": 30.935783495451197}, {"code": "void startRsync(){\n\t    char *command;\n    char *dir = T_CHECKPOINT_DIR;\n    char *config = T_CHECKPOINT_DIR \"rsyncd.conf\";\n\n    if (mkdir(dir, 0777) == -1) {\n        printf(\"Error creating checkpoint directory: %s\n\", strerror(errno));\n        return;\n    }\n\n    removeEmptyDirs(dir);\n\n    if (generateRsyncConfig(dir, config) == -1) {\n        printf(\"Error generating Rsync configuration file: %s\n\", strerror(errno));\n        return;\n    }\n\n    command = malloc(strlen(\"rsync --daemon --config=\") + strlen(config) + 1);\n    sprintf(command, \"rsync --daemon --config=%s\", config);\n\n    int pid = fork();\n    if (pid == -1) {\n        printf(\"Error forking process: %s\n\", strerror(errno));\n        return;\n    }\n\n    if (pid == 0) {\n        execlp(\"rsync\", \"rsync\", \"--daemon\", \"--config=\" config, NULL);\n        printf(\"Error executing Rsync daemon: %s\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Rsync daemon started successfully\n\");\n}", "CodeBleu_score": 38.47015049074767}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.executor.shutdownNow();\n        dispatchers.remove(dispatcherId);\n    } else {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" not found\");\n    }\n}", "CodeBleu_score": 70.88194660435263}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.executor.shutdownNow();\n    } else {\n        throw new IllegalArgumentException(\"Dispatcher with id \" + dispatcherId + \" not found\");\n    }\n}", "CodeBleu_score": 69.11178992553924}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.executor.shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n    }\n}", "CodeBleu_score": 73.45021531335023}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Set<TbActorId> children = childrenMap.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                if (actorRegistry.isRegistered(child)) {\n                    actorRegistry.tell(child, msg, highPriority);\n                } else {\n                    log.warn(\"[{}] Failed to send message to actor [{}] as it is not registered\", parent, child);\n                }\n            });\n        }\n    }", "CodeBleu_score": 57.306973194126286}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    Set<TbActorId> children = children.get(parent);\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(child -> {\n            if (actorSystem.isRegistered(child)) {\n                if (highPriority) {\n                    actorSystem.tell(child, msg);\n                } else {\n                    actorSystem.tell(child, msg, ActorRef.noSender());\n                }\n            } else {\n                log.warn(\"Failed to send message to unregistered actor [{}]\", child);\n            }\n        });\n    }\n}", "CodeBleu_score": 56.07410981007784}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    Set<TbActorId> children = childrenMap.get(parent);\n    if (children == null) {\n        log.warn(\"No children found for parent {}\", parent);\n        return;\n    }\n    children = children.stream().filter(childFilter).collect(Collectors.toSet());\n    for (TbActorId child : children) {\n        if (!child.isRegistered()) {\n            log.warn(\"Child {} is not registered\", child);\n            continue;\n        }\n        if (highPriority) {\n            child.tell(msg, self());\n        } else {\n            child.tell(msg);\n        }\n    }\n}", "CodeBleu_score": 53.029974183759066}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (isDestroyInProgress.get()) {\n        if (msg.getType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            log.info(\"[{}] Destruction in progress, reinitializing actor\", getName());\n            init();\n        } else {\n            log.info(\"[{}] Destruction in progress, notifying actor that it has stopped\", getName());\n            msg.notifyStop(TbActorStopReason.DESTROY_IN_PROGRESS);\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processMsgs();\n    }\n}", "CodeBleu_score": 46.75979368776632}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (destroyInProgress.get()) {\n        if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (msg.getEntityType() == EntityType.RULE_NODE) {\n                if (msg.getTbActorError() == TbActorError.ACTOR_INIT_ERROR) {\n                    log.error(\"Rule node [{}] failed to initialize. Reinitializing...\", msg.getEntityId());\n                    initActor();\n                }\n            }\n        } else {\n            msg.notifyStop(TbActorStopReason.ACTOR_STOPPED);\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    }\n}", "CodeBleu_score": 57.019225282586675}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n        if (isDestructionInProgress() && highPriority) {\n            if (isInitialized()) {\n                log.info(\"{}: {} is already initialized, reinitializing\", getName(), getId());\n                reinitialize();\n            } else {\n                log.info(\"{}: {} is already initialized, but not initialized yet\", getName(), getId());\n            }\n        } else {\n            log.info(\"{}: {} is stopping, not processing message {}\", getName(), getId(), msg.getMsgType());\n            msg.tell(TbActorStopReason.STOPPED, getSelf());\n        }\n    } else {\n        if (isDestructionInProgress()) {\n            log.info(\"{}: {} is stopping, not processing message {}\", getName(), getId(), msg.getMsgType());\n            msg.tell(TbActorStopReason.STOPPED, getSelf());\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            processQueues();\n        }\n    }\n}", "CodeBleu_score": 58.78264747893085}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    if (mailbox.isStopped()) {\n        return;\n    }\n    if (mailbox.isPaused()) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isInitializing()) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isDestroying()) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isDestroyed()) {\n        return;\n    }\n    if (mailbox.isFree()) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isOverloaded()) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isOverloaded(this)) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isOverloaded(this)) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isOverloaded(this)) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isOverloaded(this)) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isOverloaded(this)) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isOverloaded(this)) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isOverloaded(this)) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isOverloaded(this)) {\n        mailbox.scheduleMailboxProcessing(this);\n        return;\n    }\n    if (mailbox.isOverloaded(this)) {\n        mailbox.scheduleMailboxProcessing(this);\n", "CodeBleu_score": 14.530432882009361}, {"code": "private void processMailbox(){\n\t    if (stopped.get()) {\n        return;\n    }\n    if (initializationFailed) {\n        setStopReason(TbActorStopReason.INITIALIZATION_FAILED);\n        destroy();\n        return;\n    }\n    boolean highPriorityMessagesProcessed = false;\n    boolean normalPriorityMessagesProcessed = false;\n    boolean lowPriorityMessagesProcessed = false;\n    try {\n        while (true) {\n            if (!highPriorityMessagesProcessed) {\n                highPriorityMessagesProcessed = processQueue(highPriorityMessages, highPriorityMessagesProcessed, highPriorityThroughputLimit);\n            }\n            if (!normalPriorityMessagesProcessed) {\n                normalPriorityMessagesProcessed = processQueue(normalPriorityMessages, normalPriorityMessagesProcessed, normalPriorityThroughputLimit);\n            }\n            if (!lowPriorityMessagesProcessed) {\n                lowPriorityMessagesProcessed = processQueue(lowPriorityMessages, lowPriorityMessagesProcessed, lowPriorityThroughputLimit);\n            }\n            if (!highPriorityMessagesProcessed && !normalPriorityMessagesProcessed && !lowPriorityMessagesProcessed) {\n                setStatus(ActorStatus.FREE);\n                scheduleQueueProcessingAttempt();\n                return;\n            }\n        }\n    } catch (Exception e) {\n        log.error(\"Error processing mailbox for actor [{}]: {}\", getName(), e.getMessage(), e);\n        if (processFailureStrategy == ProcessFailureStrategy.STOP) {\n            setStopReason(TbActorStopReason.PROCESS_FAILURE);\n            destroy();\n            return;\n        }\n    }\n}", "CodeBleu_score": 28.821818273232005}, {"code": "private void processMailbox(){\n\t    // Process high priority messages\n    processQueue(highPriorityQueue, false);\n    // Process normal priority messages\n    processQueue(normalPriorityQueue, true);\n    // Check if there are more messages in the queues\n    if (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n        // If not, set the actor's status to free and schedule a queue processing attempt\n        setStatus(ActorStatus.FREE);\n        scheduleQueueProcessingAttempt();\n    } else {\n        // If there are more messages, continue processing the mailbox\n        processMailbox();\n    }\n}", "CodeBleu_score": 6.384885697024275}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.DESTROY;\n    }\n    if (destroying.compareAndSet(false, true)) {\n        log.debug(\"{}: destroying actor {}\", name, getId());\n        getDispatcher().schedule(() -> {\n            try {\n                setReady(false);\n                destroy(stopReason, cause);\n                notifyQueuedMessages(TbActorStopReason.DESTROY, cause);\n            } catch (Exception e) {\n                log.warn(\"Failed to destroy actor {}\", getId(), e);\n            }\n        });\n    }\n}", "CodeBleu_score": 45.31716493651074}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.DESTROY;\n    }\n    if (stopCause == null) {\n        stopCause = cause;\n    }\n    if (isDestroyed.compareAndSet(false, true)) {\n        log.info(\"{} is going to be destroyed due to {}\", this, stopReason);\n        dispatcher.getExecutor().schedule(() -> {\n            log.info(\"{} is going to be destroyed due to {}\", this, stopReason);\n            isReady.set(false);\n            try {\n                destroy(stopReason, stopCause);\n            } catch (Exception e) {\n                log.warn(\"Failed to destroy actor {} due to {}\", this, stopReason, e);\n            }\n            notifyQueuedMessages(TbActorStopReason.DESTROY, cause);\n        }, 0, TimeUnit.MILLISECONDS);\n    }\n}", "CodeBleu_score": 45.86550995754787}, {"code": "public void destroy(Throwable cause){\n\t    if (stopped.compareAndSet(false, true)) {\n        stopReason = TbActorStopReason.fromThrowable(cause);\n        dispatcher.execute(() -> {\n            try {\n                ready.set(false);\n                destroy(stopReason, cause);\n                notifyQueuedMessages(stopReason, cause);\n            } catch (Exception e) {\n                log.warn(\"Failed to destroy actor [{}]\", getName(), e);\n            }\n        });\n    }\n}", "CodeBleu_score": 38.280162207730804}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId == null) {\n        return true;\n    }\n    if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimitsTrigger();\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits().get(api);\n    if (rateLimits == null) {\n        return true;\n    }\n    if (rateLimits.getLimit() == 0) {\n        return true;\n    }\n    if (rateLimits.getLimit() < 0) {\n        return false;\n    }\n    String key = tenantId.toString();\n    if (level != null) {\n        key += \":\" + level.toString();\n    }\n    Long count = rateLimitsCache.getIfPresent(key);\n    if (count == null) {\n        count = 0L;\n    }\n    if (count < rateLimits.getLimit()) {\n        rateLimitsCache.put(key, count + 1);\n        return true;\n    }\n    if (rateLimitsTrigger.isNotifyOnLimitExceeded()) {\n        notificationRuleProcessor.process(tenantId, rateLimitsTrigger.getRateLimitNotificationRuleChainId(), EntityId.NULL_UUID, null, null, null, null, null);\n    }\n    return false;\n}", "CodeBleu_score": 55.787695708838726}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileService.findTenantProfileById(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        }\n        throw new TenantProfileNotFoundException(tenantId);\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimitsTrigger();\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits rateLimits = rateLimitsTrigger.getRateLimits(api, level);\n    if (rateLimits == null) {\n        return true;\n    }\n    if (rateLimits.getLimit() == 0) {\n        return true;\n    }\n    if (rateLimits.getLimit() == 1) {\n        return false;\n    }\n    RateLimitCacheKey key = new RateLimitCacheKey(api, tenantId, level);\n    RateLimitCacheValue value = rateLimitsCache.getIfPresent(key);\n    if (value == null) {\n        value = new RateLimitCacheValue();\n    }\n    long now = System.currentTimeMillis();\n    if (now - value.getLastTime() > rateLimits.getPeriod()) {\n        value.setCount(0);\n    }\n    value.setLastTime(now);\n    value.setCount(value.getCount() + 1);\n    rateLimitsCache.put(key, value);\n    if (value.getCount() > rateLimits.getLimit()) {\n        if (notificationRuleProcessor != null) {\n            notificationRuleProcessor.processRateLimitNotification(tenantId, api, level, value.getCount(), rateLimits);\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 48.703290040481264}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        }\n        throw new TenantProfileNotFoundException(tenantId);\n    }\n\n    TbRateLimits rateLimits = tenantProfile.getRateLimits();\n    if (rateLimits == null) {\n        return true;\n    }\n\n    RateLimitsTrigger rateLimitsTrigger = rateLimits.getTrigger(api, level);\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n\n    if (rateLimitsTrigger.getLimit() <= 0) {\n        return true;\n    }\n\n    String key = tenantId.toString() + \":\" + api.name() + \":\" + level;\n    Long count = rateLimitCache.getIfPresent(key);\n    if (count == null) {\n        count = 0L;\n    }\n\n    if (count >= rateLimitsTrigger.getLimit()) {\n        log.warn(\"Rate limit exceeded for tenantId [{}], api [{}], level [{}], limit [{}], current count [{}]\", tenantId, api, level, rateLimitsTrigger.getLimit(), count);\n        if (rateLimitsTrigger.isProcessNotification()) {\n            notificationRuleProcessor.processNotificationRule(tenantId, api, level, rateLimitsTrigger.getNotificationRuleId());\n        }\n        return false;\n    }\n\n    rateLimitCache.put(key, count + 1);\n    return true;\n}", "CodeBleu_score": 51.16193987445422}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    dtlsSessions.entrySet().removeIf(entry -> entry.getValue().getLastActivity() < expirationTime);\n    log.info(\"Removed {} DTLS sessions that have been inactive for more than {} ms\", removedSessions, inactivityTimeout);\n}", "CodeBleu_score": 45.99797131571714}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - (dtlsSessionsTimeout * 1000);\n    for (ConcurrentMap.Entry<InetSocketAddress, DTLSSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            log.debug(\"DTLS session removed: {}\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 46.30305538443769}, {"code": "public void evictTimeoutSessions(){\n\t    final long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    dtlsSessions.entrySet().removeIf(entry -> entry.getValue().lastActivityTime < expirationTime);\n}", "CodeBleu_score": 32.74434766952818}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (CollectionUtils.isEmpty(timeseries)) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> result = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        for (JsonNode value : values) {\n            if (value.isNull()) {\n                result.add(new BasicTsKvEntry(key, null));\n            } else if (value.isTextual()) {\n                result.add(new StringDataEntry(key, value.asText()));\n            } else if (value.isBoolean()) {\n                result.add(new BooleanDataEntry(key, value.asBoolean()));\n            } else if (value.isNumber()) {\n                result.add(new DoubleDataEntry(key, value.asDouble()));\n            } else if (value.isObject()) {\n                result.add(new JsonDataEntry(key, value));\n            } else if (value.isArray()) {\n                result.add(new JsonDataEntry(key, value));\n            } else {\n                throw new IllegalArgumentException(\"Unsupported data type for key: \" + key);\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 40.197956444313014}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (CollectionUtils.isEmpty(timeseries)) {\n        return Collections.emptyList();\n    }\n    return timeseries.entrySet().stream().flatMap(entry -> {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (JsonNode value : entry.getValue()) {\n            result.add(new BasicTsKvEntry(entry.getKey(), value.asLong(), value));\n        }\n        return result.stream();\n    }).collect(Collectors.toList());\n}", "CodeBleu_score": 47.50114312231853}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (CollectionUtils.isEmpty(timeseries)) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> result = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        for (JsonNode value : values) {\n            KvEntry kvEntry = parseValue(value);\n            if (kvEntry instanceof TsKvEntry) {\n                result.add((TsKvEntry) kvEntry);\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 46.942718499718985}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\"grant_type\", \"refresh_token\");\n    request.put(\"refresh_token\", token.getRefreshToken());\n    HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n    headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));\n    HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(request, headers);\n    ResponseEntity<Map> response = restTemplate.postForEntity(authUrl + \"/oauth/token\", requestEntity, Map.class);\n    if (response.getStatusCode() == HttpStatus.OK) {\n        Map<String, String> responseBody = response.getBody();\n        token.setAccessToken(responseBody.get(\"access_token\"));\n        token.setRefreshToken(responseBody.get(\"refresh_token\"));\n        token.setExpiresIn(responseBody.get(\"expires_in\"));\n        token.setTimestamp(System.currentTimeMillis());\n    } else {\n        throw new IllegalStateException(\"Failed to refresh token: \" + response.getStatusCode());\n    }\n}", "CodeBleu_score": 46.09934191178973}, {"code": "public void refreshToken(){\n\t    Map<String, Object> request = new HashMap<>();\n    request.put(\"refreshToken\", getToken().getRefreshToken());\n    ResponseEntity<Map> response = restTemplate.postForEntity(getAuthUrl(), request, Map.class);\n    if (response.getStatusCode() == HttpStatus.OK) {\n        Map<String, Object> body = response.getBody();\n        if (body != null) {\n            token.setAccessToken(body.get(\"accessToken\").toString());\n            token.setRefreshToken(body.get(\"refreshToken\").toString());\n            token.setTimestamp(System.currentTimeMillis());\n        }\n    }\n}", "CodeBleu_score": 47.932384866796774}, {"code": "public void refreshToken(){\n\t    // Create a request map containing the current refresh token\n    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"grant_type\", \"refresh_token\");\n    requestMap.put(\"refresh_token\", tokenInfo.getRefreshToken());\n\n    // Send a POST request to the authentication endpoint\n    ResponseEntity<Map<String, String>> response = restTemplate.postForEntity(authUrl, requestMap, new ParameterizedTypeReference<Map<String, String>>() {\n    });\n\n    // Update the token information with the current timestamp and the response body\n    tokenInfo.setTimestamp(System.currentTimeMillis());\n    tokenInfo.setAccessToken(response.getBody().get(\"access_token\"));\n    tokenInfo.setRefreshToken(response.getBody().get(\"refresh_token\"));\n}", "CodeBleu_score": 45.460713142473516}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t    long timestamp = System.currentTimeMillis();\n    Map<String, Object> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n    ResponseEntity<Map> response = restTemplate.postForEntity(getBaseUrl() + \"/api/auth/login\", loginRequest, Map.class);\n    tokenInfo.setToken(response.getBody().get(\"token\").toString());\n    tokenInfo.setRefreshToken(response.getBody().get(\"refreshToken\").toString());\n    tokenInfo.setTimestamp(timestamp);\n}", "CodeBleu_score": 66.58397831482013}, {"code": " private void doLogin(){\n\t    long now = System.currentTimeMillis();\n    Map<String, Object> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n    ResponseEntity<Map> response = restTemplate.postForEntity(authUrl + \"/api/auth/login\", loginRequest, Map.class);\n    tokenInfo.setAccessToken(response.getBody().get(\"token\").toString());\n    tokenInfo.setRefreshToken(response.getBody().get(\"refreshToken\").toString());\n    tokenInfo.setTimestamp(now);\n}", "CodeBleu_score": 70.749573462831}, {"code": " private void doLogin(){\n\t    long timestamp = System.currentTimeMillis();\n    Map<String, Object> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n    ResponseEntity<Map> response = restTemplate.postForEntity(authUrl + \"/api/auth/login\", loginRequest, Map.class);\n    Map<String, Object> responseData = response.getBody();\n    if (responseData != null) {\n        tokenInfo.setAccessToken((String) responseData.get(\"accessToken\"));\n        tokenInfo.setRefreshToken((String) responseData.get(\"refreshToken\"));\n        tokenInfo.setTimestamp(timestamp);\n    }\n}", "CodeBleu_score": 67.81847663973511}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    return getDeviceById(deviceId, false);\n}", "CodeBleu_score": 6.445908939037034}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    return getById(deviceId, Device.class);\n}", "CodeBleu_score": 5.120772693805745}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    return get(new RestJsonConverter<>(Device.class), \"/api/device/\" + deviceId);\n}", "CodeBleu_score": 7.9713139488991445}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    RestTemplate restTemplate = new RestTemplate();\n    HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_JSON);\n    headers.setBearerAuth(jwtToken);\n    HttpEntity<SaveDeviceWithCredentialsRequest> request = new HttpEntity<>(new SaveDeviceWithCredentialsRequest(device, credentials), headers);\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(url + \"/api/device-with-credentials\", request, Device.class);\n        if (response.getStatusCode() == HttpStatus.OK) {\n            return Optional.of(response.getBody());\n        } else {\n            return Optional.empty();\n        }\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 61.596882750673196}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest(device, credentials);\n    return saveDeviceWithCredentials(request);\n}", "CodeBleu_score": 19.033648904579604}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest();\n    request.setDevice(device);\n    request.setCredentials(credentials);\n    return post(ApiUrls.DEVICE_WITH_CREDENTIALS, request, Device.class);\n}", "CodeBleu_score": 20.252580957587313}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n        this.sendCommand(0x01, [addr, 0x01, val]);\n    } else if (arguments.length === 2) {\n        this.sendCommand(0x01, [addr, 0x01, Math.floor(val / 100 * 15)]);\n    }\n    return this;\n}", "CodeBleu_score": 45.41669081463999}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n        return this.write(0x00, addr, val);\n    }\n    return this.write(0x00, addr, val / 100 * 15);\n}", "CodeBleu_score": 37.606492526617544}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n        this.setBrightness(addr, val);\n    } else if (arguments.length === 2) {\n        this.setBrightness(addr, Math.round(val * 15 / 100));\n    }\n    return this;\n}", "CodeBleu_score": 55.95356030929008}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t  let device = Object.create(LedControl.prototype);\n  device.address = addr;\n  for (let key in LedControl.prototype) {\n    device[key] = LedControl.prototype[key].bind(device);\n  }\n  return device;\n}", "CodeBleu_score": 21.979092435690344}, {"code": "device(addr){\n\t  var device = {};\n  for (var key in LedControl.prototype) {\n    if (LedControl.prototype.hasOwnProperty(key)) {\n      device[key] = LedControl.prototype[key].bind(this, addr);\n    }\n  }\n  for (var key in this) {\n    if (this.hasOwnProperty(key)) {\n      device[key] = this[key];\n    }\n  }\n  return device;\n}", "CodeBleu_score": 42.27059452364236}, {"code": "device(addr){\n\t    const device = Object.create(LedControl.prototype);\n    device.address = addr;\n    Object.keys(LedControl.prototype).forEach((key) => {\n        if (key !== 'constructor') {\n            device[key] = device[key].bind(device);\n        }\n    });\n    Object.keys(device).forEach((key) => {\n        if (key !== 'constructor') {\n            device[key] = device[key].bind(device);\n        }\n    });\n    return device;\n}", "CodeBleu_score": 30.2672208130445}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = (duration = 1000, callback) => {\n            const promises = this.map(element => {\n                return new Promise(resolve => {\n                    setTimeout(() => {\n                        element[method]();\n                        resolve();\n                    }, duration);\n                });\n            });\n            Promise.all(promises).then(callback);\n        };\n    });\n}", "CodeBleu_score": 34.610536391397446}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = (duration, callback) => {\n            if (typeof callback !== 'function') {\n                throw new Error('Callback must be a function');\n            }\n            const promises = [];\n            this.forEach(item => {\n                promises.push(item[method](duration));\n            });\n            Promise.all(promises).then(callback);\n        };\n    });\n}", "CodeBleu_score": 32.53919275541886}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach((method) => {\n    target[method] = (duration, callback) => {\n      const promises = [];\n      const methodFn = target[method];\n      const durationMs = duration || 1000;\n      const callbackFn = callback || (() => {});\n      const callbackWrapper = (element) => {\n        return new Promise((resolve, reject) => {\n          setTimeout(() => {\n            try {\n              const result = methodFn.call(element);\n              resolve(result);\n            } catch (error) {\n              reject(error);\n            }\n          }, durationMs);\n        });\n      };\n      target.forEach((element) => {\n        promises.push(callbackWrapper(element));\n      });\n      Promise.all(promises).then(() => {\n        callbackFn();\n      });\n    };\n  });\n}", "CodeBleu_score": 32.81865966590165}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t  inputString = \"\";\n  while (Serial.available()) {\n    char inChar = (char)Serial.read();\n    inputString += inChar;\n    if (inChar == '\n') {\n      String sentence = inputString.substring(0, inputString.length() - 2);\n      parseNmeaSentence(sentence);\n      inputString = \"\";\n    }\n  }\n}", "CodeBleu_score": 15.529098917597878}, {"code": "listen(){\n\t    let input = \"\";\n    const serialPort = new SerialPort(serialPortName, {\n        baudRate: 9600,\n        dataBits: 8,\n        parity: \"none\",\n        stopBits: 1,\n        flowControl: false\n    });\n\n    serialPort.on(\"data\", (data) => {\n        input += data.toString();\n        const sentences = input.split(\"\\r\n\");\n        input = sentences.pop();\n        sentences.forEach(parseNmeaSentence);\n    });\n}", "CodeBleu_score": 38.430649120821336}, {"code": "listen(){\n\t    let input = '';\n    let port = serial.openPort({ baudRate: 9600 });\n\n    while (true) {\n        let data = port.read();\n        if (data) {\n            input += data;\n            let sentences = input.split('\\r\n');\n            input = sentences.pop();\n            for (let sentence of sentences) {\n                parseNmeaSentence(sentence);\n            }\n        }\n    }\n}", "CodeBleu_score": 32.960113386173404}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\n    // Get the number of channels in the sequence\n    uint8_t num_channels = sequence->channels_count;\n\n    // Calculate the size of each data sample based on the number of channels\n    uint8_t data_sample_size = num_channels * sizeof(uint16_t);\n\n    // Calculate the number of data samples needed based on the sequence length\n    uint32_t num_data_samples = sequence->length;\n\n    // Calculate the total buffer size needed for the sequence\n    uint32_t buffer_size = num_data_samples * data_sample_size;\n\n    // Check if the provided buffer size is sufficient\n    if (buffer_size > sequence->buffer_size) {\n        return -ENOMEM;\n    }\n\n    // If the buffer size is sufficient, return 0 to indicate success\n    return 0;\n}", "CodeBleu_score": 33.648517820979386}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\n  /*\n   * Calculate the number of active channels based on the provided sequence.\n   */\n  uint8_t num_active_channels = 0;\n\n  for (uint8_t i = 0; i < sequence->channels; i++) {\n    if (sequence->options & ADC_OPT_CHANNEL(i)) {\n      num_active_channels++;\n    }\n  }\n\n  /*\n   * Calculate the needed buffer size based on the number of active channels and the size of each data sample.\n   */\n  size_t needed_buffer_size = num_active_channels * sequence->buffer_size * sizeof(uint16_t);\n\n  /*\n   * Check if the provided buffer size is sufficient for the needed buffer size.\n   */\n  if (sequence->buffer_size < needed_buffer_size) {\n    LOG_ERR(\"Insufficient buffer size provided (%d bytes) for %d active channels (%d bytes needed)\",\n\t    sequence->buffer_size, num_active_channels, needed_buffer_size);\n    return -ENOMEM;\n  }\n\n  return 0;\n}", "CodeBleu_score": 45.43690089541681}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\n\tsize_t buffer_size = sequence->buffer_size;\n\tsize_t sample_size = ad559x_sample_size(dev);\n\tsize_t num_channels = ad559x_num_channels(dev);\n\n\tsize_t num_samples = buffer_size / sample_size;\n\n\tif (num_samples < num_channels) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 37.936060602974834}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    const struct ad559x_config *config = dev->config;\n    const struct ad559x_channel *channels = config->channels;\n    uint8_t channel_count = config->channel_count;\n    uint8_t resolution = config->resolution;\n\n    if (sequence->resolution != resolution) {\n        LOG_ERR(\"ADC resolution (%u) does not match expected resolution (%u)\", sequence->resolution, resolution);\n        return -EINVAL;\n    }\n\n    for (uint8_t i = 0; i < sequence->channels; i++) {\n        uint8_t channel_index = sequence->channel_id[i];\n        if (channel_index >= channel_count) {\n            LOG_ERR(\"Invalid channel index %u\", channel_index);\n            return -EINVAL;\n        }\n        if (channels[channel_index].adc_channel_id != channel_index) {\n            LOG_ERR(\"Channel index %u does not match channel ID %u\", channel_index, channels[channel_index].adc_channel_id);\n            return -EINVAL;\n        }\n    }\n\n    if (sequence->buffer_length < sequence->channels * sizeof(uint16_t)) {\n        LOG_ERR(\"Insufficient buffer size for ADC read (%u bytes required)\", sequence->channels * sizeof(uint16_t));\n        return -ENOMEM;\n    }\n\n    struct ad559x_context *ctx = dev->data;\n    ctx->sequence = *sequence;\n\n    int ret = ad559x_start_read(dev);\n    if (ret != 0) {\n        return ret;\n    }\n\n    k_sem_take(&ctx->read_complete, K_FOREVER);\n\n    return 0;\n}", "CodeBleu_score": 45.47217757092374}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    const struct ad559x_config *config = dev->config;\n    struct ad559x_data *data = dev->data;\n\n    if (sequence->resolution != config->resolution) {\n        LOG_ERR(\"Invalid resolution\");\n        return -EINVAL;\n    }\n\n    if (sequence->channels_count > config->channel_count) {\n        LOG_ERR(\"Invalid channel count\");\n        return -EINVAL;\n    }\n\n    for (int i = 0; i < sequence->channels_count; i++) {\n        if (sequence->channels[i].type != ADC_CHANNEL_DIFF) {\n            LOG_ERR(\"Invalid channel type\");\n            return -EINVAL;\n        }\n\n        if (sequence->channels[i].channel_id >= config->channel_count) {\n            LOG_ERR(\"Invalid channel ID\");\n            return -EINVAL;\n        }\n    }\n\n    if (sequence->buffer_size < sequence->channels_count * config->resolution / 8) {\n        LOG_ERR(\"Insufficient buffer size\");\n        return -EINVAL;\n    }\n\n    data->sequence = *sequence;\n\n    ad559x_start_read(dev);\n\n    return adc_read(dev, &data->sequence);\n}", "CodeBleu_score": 45.236503622210975}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    const struct ad559x_config *config = dev->config;\n    struct adc_ad559x_context *ctx = dev->data;\n    int err;\n\n    if (sequence->resolution != config->resolution) {\n        LOG_ERR(\"Resolution mismatch\");\n        return -EINVAL;\n    }\n\n    if (sequence->options & ADC_OPT_CHANNEL_MASK) {\n        if (sequence->options & ADC_OPT_DIFFERENTIAL) {\n            LOG_ERR(\"Differential channels not supported\");\n            return -EINVAL;\n        }\n\n        for (int i = 0; i < sequence->channels_count; i++) {\n            if (sequence->channels[i] >= config->channel_count) {\n                LOG_ERR(\"Invalid channel\");\n                return -EINVAL;\n            }\n        }\n    }\n\n    if (sequence->buffer_size < sequence->channels_count * sizeof(uint16_t)) {\n        LOG_ERR(\"Buffer too small\");\n        return -EINVAL;\n    }\n\n    ctx->buffer = sequence->buffer;\n    ctx->buffer_size = sequence->buffer_size;\n    ctx->channels = sequence->channels;\n    ctx->channels_count = sequence->channels_count;\n\n    ctx->status = ad559x_read(dev, ctx->channels, ctx->channels_count, ctx->buffer, ctx->buffer_size);\n\n    if (ctx->status != 0) {\n        LOG_ERR(\"ADC read failed\");\n        return -EIO;\n    }\n\n    return 0;\n}", "CodeBleu_score": 46.40692625314359}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = ctx->data;\n\n    adc_channel_setup_databuf(data->dev, data->channel_mask, data->buffer,\n                              ADC_BUF_SIZE);\n    adc_start_sampling(data->dev);\n\n    k_sem_give(&ctx->sem);\n}", "CodeBleu_score": 44.167042497065424}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    const struct device *adc = ctx->dev;\n    struct adc_channel_cfg chan_cfg = {\n        .gain             = ADC_GAIN_1,\n        .reference        = ADC_REF_INTERNAL,\n        .acquisition_time = ADC_ACQ_TIME(ADC_ACQ_TIME_MICROSECONDS, 10),\n        .channel_id       = ctx->channels[0],\n        .differential     = 0,\n    };\n\n    for (int i = 0; i < ctx->channels_count; i++) {\n        adc_channel_setup_read(adc, &chan_cfg);\n        chan_cfg.channel_id = ctx->channels[i + 1];\n    }\n\n    adc_read(adc, ctx->buf);\n\n    k_sem_give(&ctx->sem);\n}", "CodeBleu_score": 27.70916388304353}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->data;\n\n\tadc_channel_setup_batch(data->dev, data->channels, ARRAY_SIZE(data->channels));\n\tadc_repeat_buffer_set(data->dev, data->buffer, ARRAY_SIZE(data->buffer));\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 52.93632668765994}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->adc_data_container.buffer = ctx->adc_data_container.repeat_buffer;\n\t}\n}", "CodeBleu_score": 44.24018626554722}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\n    struct adc_data_container *adc_data_container = &ctx->adc_data_container;\n\n    if (repeat_sampling) {\n        adc_data_container->buffer_pointer = adc_data_container->repeat_buffer;\n    }\n\n}", "CodeBleu_score": 50.653138234088125}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    if (repeat_sampling) {\n        ctx->adc_data->buffer_ptr = ctx->adc_data->repeat_buffer;\n    } else {\n        ctx->adc_data->buffer_ptr = ctx->adc_data->buffer;\n    }\n}", "CodeBleu_score": 46.86155268040279}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\n    while (1) {\n\n        k_sem_take(&data->sem, K_FOREVER);\n\n        for (int i = 0; i < data->adc_context->num_channels; i++) {\n\n            if (data->adc_context->channels[i].active) {\n\n                int32_t adc_value;\n                int err = ad559x_read_channel(data->ad559x_dev,\n                                              data->adc_context->channels[i].channel_id,\n                                              &adc_value);\n\n                if (err) {\n                    LOG_ERR(\"Failed to read ADC channel %d: %d\",\n                            data->adc_context->channels[i].channel_id,\n                            err);\n                    data->adc_context->complete = true;\n                    break;\n                }\n\n                data->adc_context->channels[i].adc_value = adc_value;\n\n            }\n\n        }\n\n        k_sem_give(&data->adc_context->sem);\n\n    }\n\n}", "CodeBleu_score": 32.663823985751236}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t\tLOG_DBG(\"adc_ad559x_acquisition_thread: semaphore acquired\");\n\n\t\tfor (int i = 0; i < data->channels_count; i++) {\n\t\t\tuint16_t adc_value;\n\t\t\tint ret = adc_channel_raw_to_millivolts(data->adc, &data->channels[i], &adc_value);\n\n\t\t\tif (ret != 0) {\n\t\t\t\tLOG_ERR(\"adc_ad559x_acquisition_thread: Failed to read ADC value for channel %d\", i);\n\t\t\t\tdata->is_complete = true;\n\t\t\t\tk_sem_give(&data->sem_complete);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->buffer[i] = adc_value;\n\t\t}\n\n\t\tk_sem_give(&data->sem_complete);\n\t\tLOG_DBG(\"adc_ad559x_acquisition_thread: semaphore released\");\n\t}\n}", "CodeBleu_score": 38.21629064562151}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    while (1) {\n        k_sem_take(&data->sem, K_FOREVER);\n        for (int i = 0; i < data->channels_num; i++) {\n            if (data->channels[i].active) {\n                int ret = adc_channel_raw_read(data->adc, data->channels[i].channel, &data->channels[i].value);\n                if (ret < 0) {\n                    LOG_ERR(\"Failed to read channel %d: %d\", i, ret);\n                    data->complete = 1;\n                    break;\n                }\n            }\n        }\n        k_sem_give(&data->done_sem);\n    }\n}", "CodeBleu_score": 41.85505189161972}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    int ret = 0;\n    uint8_t config_reg;\n    int32_t timeout_ms = 0;\n\n    // Wait for the device to be ready for data reading\n    while (timeout_ms < dev->config->ready_time_ms) {\n        k_sleep(K_MSEC(100));\n        timeout_ms += 100;\n\n        // Read the configuration register to check the status\n        ret = i2c_reg_read_byte(dev->config->i2c_dev, dev->config->i2c_addr, ADS1112_REG_CONFIG, &config_reg);\n        if (ret < 0) {\n            LOG_ERR(\"Failed to read configuration register: %d\", ret);\n            return ret;\n        }\n\n        // Check if the device is ready for data reading\n        if (!(config_reg & ADS1112_CONFIG_RDY)) {\n            continue;\n        }\n\n        // Device is ready for data reading\n        return 0;\n    }\n\n    LOG_ERR(\"Device not ready after %d ms\", timeout_ms);\n    return -ETIMEDOUT;\n}", "CodeBleu_score": 36.211203615788094}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    int ret;\n    uint8_t reg_val;\n    uint32_t wait_time = sys_cpu_to_be32(ADS1112_READY_TIME_US);\n\n    /* Wait for the device to be ready for data reading */\n    ret = i2c_write_register(dev, ADS1112_REG_CONFIG, &wait_time, 1);\n    if (ret != 0) {\n        return ret;\n    }\n\n    k_sleep(K_MSEC(ADS1112_READY_TIME_MS));\n\n    /* Check the status of the device */\n    do {\n        ret = i2c_read_register(dev, ADS1112_REG_CONFIG, &reg_val, 1);\n        if (ret != 0) {\n            return ret;\n        }\n    } while (reg_val & ADS1112_CONFIG_START);\n\n    return 0;\n}", "CodeBleu_score": 40.123687474334005}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\n  // Wait for the device to be ready for data reading\n  k_sleep(K_MSEC(ADS1112_READY_TIME));\n\n  // Read the configuration register to check the status\n  uint16_t config_reg;\n  int ret = adc_reg_read(dev, ADS1112_REG_CONFIG, &config_reg);\n  if (ret != 0) {\n    return ret;\n  }\n\n  // If the device is not ready, wait for it to be ready\n  while ((config_reg & ADS1112_CONFIG_OS) == 0) {\n    k_sleep(K_USEC(100));\n    ret = adc_reg_read(dev, ADS1112_REG_CONFIG, &config_reg);\n    if (ret != 0) {\n      return ret;\n    }\n  }\n\n  // Return 0 if the device is ready\n  return 0;\n}", "CodeBleu_score": 57.63549129870362}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    const struct ads1112_context *context =\n        container_of(sequence->sampling_device, const struct ads1112_context, adc);\n\n    uint32_t samplings = sequence->length;\n\n    if (sequence->options & ADC_SEQ_OPT_ACQUIRE_TIME) {\n        samplings += sequence->options & ADC_SEQ_OPT_ACQUIRE_TIME_MASK;\n    }\n\n    if (sequence->options & ADC_SEQ_OPT_TRIGGER_OWN) {\n        samplings += 1;\n    }\n\n    if (sequence->options & ADC_SEQ_OPT_TRIGGER_SINGLE) {\n        samplings += 1;\n    }\n\n    if (samplings > context->buffer_size) {\n        LOG_ERR(\"Buffer size too small for %d samplings\", samplings);\n        return -ENOTSUP;\n    }\n\n    return 0;\n}", "CodeBleu_score": 46.14299852986839}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    int buffer_size = sequence->length;\n    int extra_samplings = 0;\n\n    if (sequence->options & ADC_OPTION_CONTINUOUS) {\n        extra_samplings = sequence->options & ADC_OPTION_CONTINUOUS_SAMPLINGS_MASK;\n    }\n\n    buffer_size += extra_samplings;\n\n    if (buffer_size > sequence->buffer_size) {\n        LOG_ERR(\"Buffer size %d is too small, at least %d is required\",\n                sequence->buffer_size, buffer_size);\n        return -ENOMEM;\n    }\n\n    return 0;\n}", "CodeBleu_score": 50.57081817293913}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\n  int buffer_size = sequence->buffer_length * sizeof(u16_t);\n\n  int samplings = sequence->options & ADC_OPT_SINGLE_SHOT ? 1 : 2;\n\n  int extra_samplings = (sequence->options & ADC_OPT_CYCLE_TIME_MASK) >> ADC_OPT_CYCLE_TIME_SHIFT;\n\n  int required_buffer_size = samplings * sequence->buffer_length + extra_samplings * sequence->buffer_length;\n\n  if (buffer_size < required_buffer_size) {\n\n    LOG_ERR(\"Buffer size is too small (%d) for %d samplings (%d)\", buffer_size, samplings, required_buffer_size);\n\n    return -ENOMEM;\n\n  }\n\n  return 0;\n\n}", "CodeBleu_score": 46.76960932589862}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_adc_data *data = dev->data;\n\n\tif (data->adc_sequence.buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tdata->adc_sequence = *sequence;\n\n\tdata->adc_context.sequence = &data->adc_sequence;\n\n\tdata->adc_context.callback = ads1112_adc_read_callback;\n\n\treturn adc_read(dev, &data->adc_context);\n}", "CodeBleu_score": 39.15602521187845}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t  struct ads1112_adc_data *data = dev->data;\n  int ret;\n\n  if (sequence->options & ADC_OPTION_CYCLE_WITH_TRIGGER) {\n    LOG_ERR(\"Cycle with trigger not supported\");\n    return -ENOTSUP;\n  }\n\n  if (sequence->options & ADC_OPTION_CONTINUOUS) {\n    LOG_ERR(\"Continuous mode not supported\");\n    return -ENOTSUP;\n  }\n\n  if (sequence->options & ADC_OPTION_STOP_ON_FIRST_DONE) {\n    LOG_ERR(\"Stop on first done not supported\");\n    return -ENOTSUP;\n  }\n\n  if (sequence->options & ADC_OPTION_TRIGGER_HW) {\n    LOG_ERR(\"Trigger HW not supported\");\n    return -ENOTSUP;\n  }\n\n  if (sequence->options & ADC_OPTION_TRIGGER_SW) {\n    LOG_ERR(\"Trigger SW not supported\");\n    return -ENOTSUP;\n  }\n\n  if (sequence->options & ADC_OPTION_DIFFERENTIAL) {\n    LOG_ERR(\"Differential mode not supported\");\n    return -ENOTSUP;\n  }\n\n  if (sequence->options & ADC_OPTION_SCAN_INPUT) {\n    LOG_ERR(\"Scan input not supported\");\n    return -ENOTSUP;\n  }\n\n  if (sequence->options & ADC_OPTION_CONTINUOUS) {\n    LOG_ERR(\"Continuous mode not supported\");\n    return -ENOTSUP;\n  }\n\n  if (sequence->options & ADC_OPTION_STOP_ON_FIRST_DONE) {\n    LOG_ERR(\"Stop on first done not supported\");\n    return -ENOTSUP;\n  }\n\n  if (sequence->options & ADC_OPTION_TRIGGER_HW) {\n    LOG_ERR(\"Trigger HW not supported\");\n    return -ENOTSUP;\n  }\n\n  if", "CodeBleu_score": 39.48215275505005}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tARG_UNUSED(dev);\n\n\tARG_UNUSED(wait);\n\n\tstruct ads1112_data *data = dev->data;\n\n\tint ret = 0;\n\n\tif (!sequence->buffer) {\n\t\treturn -EINVAL;\n\t}\n\n\tdata->sequence = sequence;\n\n\tdata->context.buffer = sequence->buffer;\n\n\tdata->context.length = sequence->length;\n\n\tdata->context.resolution = sequence->resolution;\n\n\tdata->context.oversampling = sequence->oversampling;\n\n\tdata->context.channel = sequence->channels[0].channel_id;\n\n\tret = ads1112_read_adc(data);\n\n\treturn ret;\n}", "CodeBleu_score": 49.51446483759153}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    const struct device *dev;\n    int ret;\n\n    if (argc != 2) {\n        shell_error(sh, \"Invalid arguments\");\n        return -EINVAL;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Device not found\");\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_properties(dev);\n    if (ret) {\n        shell_error(sh, \"Failed to apply properties (%d)\", ret);\n        return ret;\n    }\n\n    shell_print(sh, \"Properties applied successfully\");\n    return 0;\n}", "CodeBleu_score": 64.04245909969137}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    struct device *dev;\n\n    if (argc != 2) {\n        shell_error(sh, \"Usage: apply_prop <device name>\");\n        return -ENOEXEC;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Device not found: %s\", argv[1]);\n        return -ENODEV;\n    }\n\n    if (!device_is_ready(dev)) {\n        shell_error(sh, \"Device not ready: %s\", argv[1]);\n        return -ENODEV;\n    }\n\n    if (!IS_ENABLED(CONFIG_AUDIO_CODEC)) {\n        shell_error(sh, \"Audio codec support is not enabled\");\n        return -ENOEXEC;\n    }\n\n    struct audio_codec_api *api = (struct audio_codec_api *)dev->api;\n    if (!api) {\n        shell_error(sh, \"Device API not found: %s\", argv[1]);\n        return -ENOEXEC;\n    }\n\n    if (api->apply_properties(dev)) {\n        shell_error(sh, \"Failed to apply properties to device: %s\", argv[1]);\n        return -EFAULT;\n    }\n\n    shell_print(sh, \"Properties applied to device: %s\", argv[1]);\n    return 0;\n}", "CodeBleu_score": 53.70744859944887}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\n    struct device *dev;\n    int ret;\n\n    if (argc != 2) {\n        shell_error(sh, \"Usage: apply_prop <device>\");\n        return -EINVAL;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Device %s not found\", argv[1]);\n        return -ENODEV;\n    }\n\n    if (IS_ENABLED(CONFIG_AUDIO_CODEC)) {\n        struct audio_codec_api *api = (struct audio_codec_api *)dev->api;\n\n        if (api->apply_properties) {\n            ret = api->apply_properties(dev);\n            if (ret) {\n                shell_error(sh, \"Failed to apply properties to device %s\", argv[1]);\n                return ret;\n            }\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 55.27379716763273}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    struct mpxxdtyy_data *data = dev->data;\n    int err;\n    uint32_t i2s_cmd;\n    uint32_t i2s_cmd_mask;\n    uint32_t i2s_cmd_state;\n    uint32_t i2s_cmd_state_mask;\n\n    if (cmd == DMIC_START) {\n        i2s_cmd = MPXXDTYY_I2S_CMD_START;\n        i2s_cmd_mask = MPXXDTYY_I2S_CMD_MASK;\n        i2s_cmd_state = MPXXDTYY_I2S_CMD_STATE_ACTIVE;\n        i2s_cmd_state_mask = MPXXDTYY_I2S_CMD_STATE_MASK;\n    } else if (cmd == DMIC_STOP) {\n        i2s_cmd = MPXXDTYY_I2S_CMD_STOP;\n        i2s_cmd_mask = MPXXDTYY_I2S_CMD_MASK;\n        i2s_cmd_state = MPXXDTYY_I2S_CMD_STATE_CONFIGURED;\n        i2s_cmd_state_mask = MPXXDTYY_I2S_CMD_STATE_MASK;\n    } else {\n        LOG_ERR(\"Invalid DMIC trigger command\");\n        return -EINVAL;\n    }\n\n    if (data->state != i2s_cmd_state) {\n        err = i2s_write_cmd(data->i2s_dev, i2s_cmd, i2s_cmd_mask);\n        if (err) {\n            LOG_ERR(\"Failed to send I2S command: %d\", err);\n            return err;\n        }\n        data->state = i2s_cmd_state;\n    }\n\n    return 0;\n}", "CodeBleu_score": 51.445323798707236}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    const struct mpxxdtyy_config *config = dev->config;\n    const struct mpxxdtyy_data *data = dev->data;\n\n    int ret;\n    struct i2s_config i2s_cfg;\n\n    if (cmd == DMIC_TRIGGER_START) {\n        if (data->state == MPXXDTYY_STATE_CONFIGURED) {\n            i2s_cfg.cmd = I2S_CMD_START;\n            i2s_cfg.rx_channel = config->rx_channel;\n            i2s_cfg.tx_channel = config->tx_channel;\n            i2s_cfg.rx_data_format = config->rx_data_format;\n            i2s_cfg.tx_data_format = config->tx_data_format;\n            i2s_cfg.rx_frame_size = config->rx_frame_size;\n            i2s_cfg.tx_frame_size = config->tx_frame_size;\n            i2s_cfg.rx_sample_rate = config->rx_sample_rate;\n            i2s_cfg.tx_sample_rate = config->tx_sample_rate;\n            i2s_cfg.rx_channel_num = config->rx_channel_num;\n            i2s_cfg.tx_channel_num = config->tx_channel_num;\n            i2s_cfg.rx_dma_channel = config->rx_dma_channel;\n            i2s_cfg.tx_dma_channel = config->tx_dma_channel;\n            i2s_cfg.rx_dma_burst_size = config->rx_dma_burst_size;\n            i2s_cfg.tx_dma_burst_size = config->tx_dma_burst_size;\n            i2s_cfg.rx_dma_burst_count = config->rx_dma_burst_count;\n            i2s_cfg.tx_dma_burst_count = config->tx_dma_burst_count;\n            i2s_cfg.rx_", "CodeBleu_score": 26.47870394656619}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    const struct mpxxdtyy_dev_cfg *cfg = dev->config;\n    struct mpxxdtyy_dev_data *data = dev->data;\n\n    int err;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state != MPXXDYY_STATE_CONFIGURED) {\n                LOG_ERR(\"Invalid state transition: %d -> %d\",\n                        data->state, MPXXDYY_STATE_CONFIGURED);\n                return -EINVAL;\n            }\n\n            err = i2s_write_cmd(cfg->i2s_dev, cfg->i2s_cmd_start);\n            if (err) {\n                LOG_ERR(\"Failed to send I2S command: %d\", err);\n                return err;\n            }\n\n            data->state = MPXXDYY_STATE_ACTIVE;\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (data->state != MPXXDYY_STATE_ACTIVE) {\n                LOG_ERR(\"Invalid state transition: %d -> %d\",\n                        data->state, MPXXDYY_STATE_ACTIVE);\n                return -EINVAL;\n            }\n\n            err = i2s_write_cmd(cfg->i2s_dev, cfg->i2s_cmd_stop);\n            if (err) {\n                LOG_ERR(\"Failed to send I2S command: %d\", err);\n                return err;\n            }\n\n            data->state = MPXXDYY_STATE_CONFIGURED;\n            break;\n\n        default:\n            LOG_ERR(\"Invalid trigger command: %d\", cmd);\n            return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 53.83737758510965}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    const struct auxdisplay_hd44780_config *config = dev->config;\n    uint8_t command = config->display_mode;\n\n    if (enabled) {\n        command |= BIT(config->display_enable_bit);\n    }\n\n    if (config->cursor_blink_mode == AUXDISPLAY_HD44780_CURSOR_BLINK_MODE_ON) {\n        command |= BIT(config->cursor_blink_bit);\n    }\n\n    if (config->cursor_blink_mode == AUXDISPLAY_HD44780_CURSOR_BLINK_MODE_BLINK) {\n        command |= BIT(config->cursor_blink_bit);\n    }\n\n    if (config->cursor_blink_mode == AUXDISPLAY_HD44780_CURSOR_BLINK_MODE_OFF) {\n        command &= ~BIT(config->cursor_blink_bit);\n    }\n\n    if (config->cursor_blink_mode == AUXDISPLAY_HD44780_CURSOR_BLINK_MODE_OFF) {\n        command &= ~BIT(config->cursor_blink_bit);\n    }\n\n    if (config->cursor_blink_mode == AUXDISPLAY_HD44780_CURSOR_BLINK_MODE_ON) {\n        command |= BIT(config->cursor_blink_bit);\n    }\n\n    if (config->cursor_blink_mode == AUXDISPLAY_HD44780_CURSOR_BLINK_MODE_BLINK) {\n        command |= BIT(config->cursor_blink_bit);\n    }\n\n    if (config->cursor_blink_mode == AUXDISPLAY_HD44780_CURSOR_BLINK_MODE_OFF) {\n        command &= ~BIT(config->cursor_blink_bit);\n    }\n\n    if (config->cursor_blink_mode", "CodeBleu_score": 47.82042556811499}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    struct auxdisplay_hd44780_config *config = dev->config;\n    struct auxdisplay_hd44780_data *data = dev->data;\n\n    uint8_t command = data->config_command;\n\n    if (data->cursor_blink) {\n        command |= config->cursor_blink_flag;\n    }\n\n    if (data->position_blink) {\n        command |= config->position_blink_flag;\n    }\n\n    if (enabled) {\n        command |= config->display_flag;\n    }\n\n    data->config_command = command;\n\n    auxdisplay_write(dev, &command, 1);\n}", "CodeBleu_score": 52.721793665597104}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t  struct auxdisplay_hd44780_config *config = dev->config;\n  uint8_t command = config->display_mode;\n\n  if (config->cursor_enabled) {\n    command |= BIT(BIT_HD44780_DISPLAY_CURSOR);\n  }\n\n  if (config->cursor_blink) {\n    command |= BIT(BIT_HD44780_DISPLAY_BLINK);\n  }\n\n  if (enabled) {\n    command |= BIT(BIT_HD44780_DISPLAY_ENABLE);\n  }\n\n  auxdisplay_write(dev, command);\n}", "CodeBleu_score": 44.94605346253135}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\n    const struct auxdisplay_itron_config *config = dev->config;\n\n    if (!config->busy_gpios) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get_raw(config->busy_gpios, config->busy_pin);\n}", "CodeBleu_score": 42.710101213889196}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\n  const struct auxdisplay_itron_config *cfg = dev->config;\n\n  if (!cfg->busy_gpio_port) {\n\n    return -ENOTSUP;\n  }\n\n  return gpio_pin_get_raw(cfg->busy_gpio_port, cfg->busy_gpio_pin);\n}", "CodeBleu_score": 37.882360621316906}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\n    const struct auxdisplay_itron_config *config = dev->config;\n\n    if (!config->busy_gpios) {\n\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get_raw(config->busy_gpios, config->busy_gpios_pin);\n}", "CodeBleu_score": 42.13651677783113}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *cfg = dev->config;\n\n\tuint8_t buf[2] = { cfg->special_command_prefix, command };\n\n\tint ret = i2c_write_dt(&cfg->i2c, buf, sizeof(buf));\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(cfg->delay_after_special_command));\n\n\treturn 0;\n}", "CodeBleu_score": 53.26583387152199}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t  const struct auxdisplay_serlcd_config *cfg = dev->config;\n  uint8_t buf[2];\n\n  buf[0] = cfg->special_command_prefix;\n  buf[1] = command;\n\n  if (i2c_write_dt(&cfg->i2c, buf, sizeof(buf))) {\n    return -EIO;\n  }\n\n  k_sleep(K_MSEC(cfg->special_command_delay_ms));\n\n  return 0;\n}", "CodeBleu_score": 64.00370747256099}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n  const struct auxdisplay_serlcd_config *config = dev->config;\n\n  uint8_t command_buffer[2] = {0xFE, command};\n\n  int ret = i2c_write(config->i2c, config->i2c_addr, command_buffer, sizeof(command_buffer));\n\n  if (ret < 0) {\n    LOG_ERR(\"Failed to send special command 0x%02X: %d\", command, ret);\n    return ret;\n  }\n\n  k_sleep(K_MSEC(config->delay));\n\n  return 0;\n}", "CodeBleu_score": 64.69433431759626}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\n    if (size == 0 || offset + size > BBRAM_EMUL_SIZE) {\n        return -EINVAL;\n    }\n\n    memcpy(data, &bbram_emul_data[offset], size);\n\n    return 0;\n}", "CodeBleu_score": 42.24926984033052}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\tLOG_ERR(\"Requested read size exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &bbram_emul_data[offset], size);\n\treturn 0;\n}", "CodeBleu_score": 38.53080840158237}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\n\tARG_UNUSED(dev);\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &bbram_emul_mem[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 38.30942870251518}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tARG_UNUSED(dev);\n\tARG_UNUSED(offset);\n\tARG_UNUSED(size);\n\tARG_UNUSED(data);\n\treturn 0;\n}", "CodeBleu_score": 31.7949649120011}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tARG_UNUSED(dev);\n\n\tif (size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&bbram_emul_data[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 44.02487792808575}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&bbram_emul_data[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 39.6829027579775}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device path argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found: %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 78.78249328968832}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t  if (argc < 2) {\n    shell_error(sh, \"Missing device path\");\n    return -EINVAL;\n  }\n\n  *bbram_dev = device_get_binding(argv[1]);\n  if (*bbram_dev == NULL) {\n    shell_error(sh, \"Device not found: %s\", argv[1]);\n    return -ENODEV;\n  }\n\n  return 0;\n}", "CodeBleu_score": 80.96427651576722}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t  if (argc < 2) {\n    shell_error(sh, \"Missing device name\");\n    return -EINVAL;\n  }\n\n  *bbram_dev = device_get_binding(argv[1]);\n  if (*bbram_dev == NULL) {\n    shell_error(sh, \"Device not found: %s\", argv[1]);\n    return -ENODEV;\n  }\n\n  return 0;\n}", "CodeBleu_score": 81.08684560301212}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t    int read_bytes;\n    int bytes_to_read = H4_HDR_SIZE - h4_hdr_bytes_read;\n\n    read_bytes = uart_fifo_read(dev, h4_hdr_buf + h4_hdr_bytes_read, bytes_to_read);\n    if (read_bytes < 0) {\n        LOG_ERR(\"uart_fifo_read failed: %d\", read_bytes);\n        return;\n    }\n\n    h4_hdr_bytes_read += read_bytes;\n}", "CodeBleu_score": 32.372410667266564}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    uint32_t bytes_read;\n    uint32_t bytes_to_read = sizeof(h4_hdr_t);\n\n    bytes_read = uart_fifo_read(dev, h4_hdr_buf, bytes_to_read);\n\n    if (bytes_read != bytes_to_read) {\n        LOG_ERR(\"h4_read_hdr: uart_fifo_read failed\");\n        return;\n    }\n\n    h4_hdr_rem_bytes -= bytes_read;\n}", "CodeBleu_score": 36.49340010619982}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\n    uint32_t n_bytes_read = h4_hdr_len - h4_hdr_bytes_read;\n    int ret = uart_fifo_read(dev, &h4_hdr_buf[h4_hdr_bytes_read], n_bytes_read);\n    if (ret < 0) {\n        LOG_ERR(\"uart_fifo_read failed: %d\", ret);\n        return;\n    }\n    h4_hdr_bytes_read += ret;\n}", "CodeBleu_score": 25.227754398800638}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\n  uint8_t buf[33];\n\n  size_t rc;\n\n  if (len > 32) {\n\n    len = 32;\n\n  }\n\n  rc = uart_fifo_read(uart, buf, len);\n\n  if (rc != len) {\n\n    LOG_ERR(\"Failed to read from UART: %d\", rc);\n\n    return 0;\n\n  }\n\n  return rc;\n\n}", "CodeBleu_score": 58.66971863738577}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t rc;\n\n    rc = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n    if (rc < 0) {\n        LOG_ERR(\"Failed to read %zu bytes from UART: %d\", len, rc);\n        return 0;\n    }\n\n    return rc;\n}", "CodeBleu_score": 65.61132683608024}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t read;\n\n    read = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n    if (read) {\n        LOG_DBG(\"discarded %u bytes\", read);\n    }\n    return read;\n}", "CodeBleu_score": 54.44555826724}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    uint8_t highest = 0;\n    for (size_t i = 0; i < chan->observers.size; i++) {\n        if (chan->observers.entries[i].priority > highest && chan->observers.entries[i].enabled) {\n            highest = chan->observers.entries[i].priority;\n        }\n    }\n    chan->highest_observer_priority = highest;\n}", "CodeBleu_score": 21.33258461314987}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    uint8_t highest = 0;\n    for (uint8_t i = 0; i < chan->observers_count; i++) {\n        if (chan->observers[i].priority > highest && chan->observers[i].enabled) {\n            highest = chan->observers[i].priority;\n        }\n    }\n    chan->highest_observer_priority = highest;\n}", "CodeBleu_score": 18.73537151404189}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t hop = 0;\n\n\tk_mutex_lock(&chan->lock, K_FOREVER);\n\n\tzbus_iter_observers(chan, obs) {\n\t\tif (obs->priority > hop && obs->enabled) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\n\tchan->hop = hop;\n\n\tk_mutex_unlock(&chan->lock);\n}", "CodeBleu_score": 12.499451917914167}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tITERABLE_SECTION_FOREACH(channel_hop, {\n\t\tif (channel_hop->observer == obs) {\n\t\t\tchannel_hop->update_channel(obs, channel_hop);\n\t\t}\n\t});\n}", "CodeBleu_score": 22.063272015677565}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    for (struct zbus_channel_observation *obs =\n             ZBUS_ITERABLE_SECTION_ITER(channel_observations);\n         obs != NULL; obs = ZBUS_ITERABLE_SECTION_NEXT(channel_observations, obs)) {\n        if (obs->observer == obs) {\n            zbus_channel_update(obs->channel);\n        }\n    }\n}", "CodeBleu_score": 25.855326155771465}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    for (const struct zbus_channel *ch = ZBUS_CHANNEL_ITER_BEGIN();\n         ch != ZBUS_CHANNEL_ITER_END();\n         ch = ZBUS_CHANNEL_ITER_NEXT(ch)) {\n        if (zbus_channel_is_observed(ch, obs)) {\n            zbus_channel_update(ch);\n        }\n    }\n}", "CodeBleu_score": 18.233294729838235}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    if (obs == NULL) {\n        return -EINVAL;\n    }\n    if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION)) {\n        if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS_INIT)) {\n            if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS_INIT_THREAD)) {\n                if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS_INIT_THREAD_THREAD)) {\n                    if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS_INIT_THREAD_THREAD_THREAD)) {\n                        if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS_INIT_THREAD_THREAD_THREAD_THREAD)) {\n                            if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS_INIT_THREAD_THREAD_THREAD_THREAD_THREAD)) {\n                                if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS_INIT_THREAD_THREAD_THREAD_THREAD_THREAD_THREAD)) {\n                                    if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS_INIT_THREAD_THREAD_THREAD_THREAD_THREAD_THREAD_THREAD)) {\n                                        if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS_INIT_THREAD_THREAD_THREAD_THREAD_THREAD_THREAD_THREAD_THREAD)) {\n                                            if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS_INIT_THREAD_THREAD_THREAD_THREAD_THREAD_THREAD_THREAD_THREAD_THREAD)) {\n                                                if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTION_ALLOW_SYS", "CodeBleu_score": 20.86589111827898}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\n  if (obs == NULL) {\n    return -EINVAL;\n  }\n\n  k_spinlock_key_t key = k_spin_lock(&obs->lock);\n\n  obs->priority = k_thread_priority_get_min();\n\n  k_spin_unlock(&obs->lock, key);\n\n  return 0;\n}", "CodeBleu_score": 17.96775090759643}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    return 0;\n}", "CodeBleu_score": 6.203992247536536}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\n  int err;\n\n  if (chan == NULL) {\n    return -EINVAL;\n  }\n\n  if (timeout == K_FOREVER) {\n    timeout = K_MSEC(100);\n  }\n\n  if (timeout == K_NO_WAIT) {\n    timeout = K_MSEC(1);\n  }\n\n  if (timeout == K_NO_WAIT) {\n    return -EINVAL;\n  }\n\n  if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n    timeout = K_MSEC(1);\n  }\n\n  if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n    timeout = K_MSEC(1);\n  }\n\n  if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n    timeout = K_MSEC(1);\n  }\n\n  if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n    timeout = K_MSEC(1);\n  }\n\n  if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n    timeout = K_MSEC(1);\n  }\n\n  if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n    timeout = K_MSEC(1);\n  }\n\n  if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n    timeout = K_MSEC(1);\n  }\n\n  if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n    timeout = K_MSEC(1);\n  }\n\n  if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n    timeout = K_MSEC(1);\n  }\n\n  if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n    timeout = K_MSEC(1);\n  }\n\n  if (IS_ENABLED", "CodeBleu_score": 36.28639125097502}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    int err;\n\n    if (chan == NULL) {\n        return -EINVAL;\n    }\n\n    if (IS_ENABLED(CONFIG_ISR_STACK_PROTECTOR)) {\n        timeout = k_us_to_timeout_s(timeout);\n    }\n\n    k_tick_t end_time = k_uptime_ticks() + timeout;\n\n    struct zbus_channel_ctx ctx = {\n        .priority = k_current_get_priority(),\n        .end_time = end_time,\n    };\n\n    k_mutex_lock(&chan->mutex, K_FOREVER);\n\n    err = zbus_chan_notify_locked(chan, &ctx);\n\n    k_mutex_unlock(&chan->mutex);\n\n    return err;\n}", "CodeBleu_score": 28.855810794650477}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\n\n  /*\n   * The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout.\nIt asserts that the channel is not null and adjusts the timeout if in an ISR.\nIt calculates the end time based on the timeout and initializes the context priority.\nIt then locks the channel, executes the notification logic, unlocks the channel, and returns any error encountered during the process.\n   */\n  return 0;\n}", "CodeBleu_score": 3.994868034060268}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t tmp;\n\t\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT_OK(Int));\n\t\n\t/* Enable or disable the specified Ethernet interrupt */\n\tif (enable) {\n\t\tif (Int == ETH_INT_ABNORMAL) {\n\t\t\tETH->INTEN |= ETH_INTEN_ABNORMAL_Msk;\n\t\t}\n\t\telse {\n\t\t\ttmp = ETH->INTEN & ~ETH_INTEN_ABNORMAL_Msk;\n\t\t\ttmp |= Int;\n\t\t\tETH->INTEN = tmp;\n\t\t}\n\t}\n\telse {\n\t\tETH->INTEN &= ~Int;\n\t}\n}", "CodeBleu_score": 36.36625611364388}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  if (enable) {\n    /* Enable the Ethernet interrupt */\n    if (Int & ETH_IT_NORMAL) {\n      /* Enable the Ethernet normal interrupt */\n      ETH->INTEN |= ETH_INTEN_NORMAL_Msk;\n    }\n    if (Int & ETH_IT_ABNORMAL) {\n      /* Enable the Ethernet abnormal interrupt */\n      ETH->INTEN |= ETH_INTEN_ABNORMAL_Msk;\n    }\n  } else {\n    /* Disable the Ethernet interrupt */\n    if (Int & ETH_IT_NORMAL) {\n      /* Disable the Ethernet normal interrupt */\n      ETH->INTEN &= ~ETH_INTEN_NORMAL_Msk;\n    }\n    if (Int & ETH_IT_ABNORMAL) {\n      /* Disable the Ethernet abnormal interrupt */\n      ETH->INTEN &= ~ETH_INTEN_ABNORMAL_Msk;\n    }\n  }\n}", "CodeBleu_score": 42.843713803967155}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    if (enable == TRUE) {\n        if (Int & ETH_IT_NIS) {\n            ETH->ISR |= ETH_ISR_NIS;\n        }\n        if (Int & ETH_IT_AIS) {\n            ETH->ISR |= ETH_ISR_AIS;\n        }\n    } else {\n        if (Int & ETH_IT_NIS) {\n            ETH->ISR &= ~ETH_ISR_NIS;\n        }\n        if (Int & ETH_IT_AIS) {\n            ETH->ISR &= ~ETH_ISR_AIS;\n        }\n    }\n}", "CodeBleu_score": 42.92740094397472}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\n    ETH_TX_DESC *tx_desc;\n\n    tx_desc = (ETH_TX_DESC *)ETH_TX_DESC_ADDR;\n\n    if (tx_desc->status & ETH_TX_DESC_STATUS_OWN) {\n        return 0;\n    }\n\n    while (1) {\n        if (tx_desc->status & ETH_TX_DESC_STATUS_OWN) {\n            return 0;\n        }\n\n        tx_desc = (ETH_TX_DESC *)((uint32_t)tx_desc + ETH_TX_DESC_SIZE);\n\n        if ((uint32_t)tx_desc == ETH_TX_DESC_ADDR) {\n            return 0;\n        }\n    }\n}", "CodeBleu_score": 52.56360159295905}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *txDesc;\n\tuint32_t i;\n\n\ttxDesc = (ETH_TX_DESC *)ETH_TX_DESC_ADDR;\n\n\tfor (i = 0; i < ETH_TX_DESC_COUNT; i++) {\n\t\tif (txDesc->owner == 0) {\n\t\t\ttxDesc->owner = ETH_DESC_OWNER_DEVICE;\n\t\t\treturn txDesc;\n\t\t}\n\t\ttxDesc = (ETH_TX_DESC *)((uint32_t)txDesc + ETH_TX_DESC_SIZE);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.82672461784698}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *txDesc;\n\tuint32_t i;\n\n\ttxDesc = (ETH_TX_DESC *)ETH_GetTxDescAddr();\n\n\tfor (i = 0; i < ETH_TX_DESC_NUM; i++) {\n\t\tif (ETH_IsTxDescFree(txDesc)) {\n\t\t\treturn txDesc;\n\t\t}\n\t\ttxDesc++;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 28.331034731271675}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\n    CY_CSDIDAC_Type *csdiDac = (CY_CSDIDAC_Type *)device->config.base_addr;\n    CY_CSDIDAC_CH_Type *csdiDacCh = (CY_CSDIDAC_CH_Type *)(device->config.base_addr + CY_CSDIDAC_CH_OFFSET);\n\n    rt_uint32_t dac_value = *value;\n\n    /* Initialize DAC channel */\n    Cy_CSDIDAC_Init(csdiDac, &device->config.init);\n\n    /* Enable DAC output */\n    Cy_CSDIDAC_OutputEnable(csdiDac, channel, dac_value);\n\n    return RT_EOK;\n}", "CodeBleu_score": 42.78314499835704}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    rt_err_t result = RT_EOK;\n\n    // Get the DAC channel\n    Cy_CSDIDAC_Channel_t dacChannel = (Cy_CSDIDAC_Channel_t)channel;\n\n    // Enable the DAC output with the specified value\n    Cy_CSDIDAC_OutputEnable(dacChannel, *value);\n\n    return result;\n}", "CodeBleu_score": 48.3224803089289}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_err_t ret = RT_EOK;\n\n    RT_ASSERT(device != RT_NULL);\n\n    Cy_CSDIDAC_OutputEnable(device->config.base, channel);\n\n    return ret;\n}", "CodeBleu_score": 30.885254483851774}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > FLASH_END_ADDR) {\n        rt_kprintf(\"flash read addr out of range: 0x%x, 0x%x\n\", addr, size);\n        return -1;\n    }\n\n    int i;\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 52.11492441401388}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > FLASH_END_ADDR) {\n        return -EINVAL;\n    }\n\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *) (addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 42.02348869942391}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n\n    if ((addr + size) > FLASH_END_ADDR) {\n        rt_kprintf(\"flash read error, addr=0x%x, size=%d\n\", addr, size);\n        return -1;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *) (addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 61.031423882983205}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    rt_uint32_t count = 0;\n    cyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->user_data;\n\n    RT_ASSERT(cyhal_timer != NULL);\n\n    count = cyhal_timer_read(cyhal_timer);\n\n    return count;\n}", "CodeBleu_score": 58.857311480295024}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    cyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->user_data;\n    cyhal_timer_read(cyhal_timer);\n    return cyhal_timer_get_count(cyhal_timer);\n}", "CodeBleu_score": 48.03337313655028}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 29.114912051891924}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    int rc;\n\n    rc = dfs_mutex_lock(&dfs_fs_mutex);\n    assert(rc == 0);\n}", "CodeBleu_score": 6.243236161255585}, {"code": "void dfs_lock(void){\n\t    int ret;\n\n    do {\n        ret = mutex_trylock(&g_fs_mutex);\n    } while (ret != 0);\n}", "CodeBleu_score": 8.79580685500683}, {"code": "void dfs_lock(void){\n\t    int res;\n\n    res = mutex_trylock(&dfs_mutex);\n    while (res != 0) {\n        if (res == -EBUSY) {\n            mutex_lock(&dfs_mutex);\n        } else {\n            assert(0);\n        }\n        res = mutex_trylock(&dfs_mutex);\n    }\n}", "CodeBleu_score": 39.85921690126046}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i, n;\n\n    if (fdt->fd_nr >= fdt->fd_size) {\n        n = fdt->fd_size + FDT_INCR;\n        if (n > fdt->fd_size) {\n            fdt->fd_size = n;\n        } else {\n            fdt->fd_size += FDT_INCR;\n        }\n\n        fdt->fd_array = (struct dfs_fd *)realloc(fdt->fd_array, fdt->fd_size * sizeof(struct dfs_fd));\n        if (fdt->fd_array == NULL) {\n            return -1;\n        }\n\n        memset(fdt->fd_array + fdt->fd_nr, 0, (fdt->fd_size - fdt->fd_nr) * sizeof(struct dfs_fd));\n    }\n\n    for (i = startfd; i < fdt->fd_size; i++) {\n        if (fdt->fd_array[i].fd_file == NULL) {\n            return i;\n        }\n    }\n\n    return -1;\n}", "CodeBleu_score": 40.762764668901454}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\n    int i;\n    int fd = startfd;\n\n    if (fdt == NULL)\n        return -1;\n\n    /* Search for an empty slot */\n    for (i = startfd; i < fdt->fd_nr; i++) {\n        if (fdt->fd_array[i].fd_file == NULL) {\n            fd = i;\n            break;\n        }\n    }\n\n    /* If no empty slot was found, try to expand the fd table */\n    if (i == fdt->fd_nr) {\n        if (fd_table_expand(fdt) < 0) {\n            return -1;\n        }\n        fd = startfd;\n    }\n\n    return fd;\n}", "CodeBleu_score": 52.82369622121708}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    for (i = startfd; i < fdt->nr; i++) {\n        if (fdt->fd[i].file == NULL) {\n            return i;\n        }\n    }\n\n    return -1;\n}", "CodeBleu_score": 26.244634768667986}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (rt_size_t i = 0; i < RT_ERROR_COUNT; i++) {\n        if (error == rt_error_strings[i].error) {\n            return rt_error_strings[i].string;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 55.84129862253027}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\n    if (error < 0) {\n        error = -error;\n    }\n\n    switch (error) {\n        case RT_EOK:\n            return \"EOK\";\n        case RT_ENOMEM:\n            return \"ENOMEM\";\n        case RT_ENOENT:\n            return \"ENOENT\";\n        case RT_EINVAL:\n            return \"EINVAL\";\n        case RT_EIO:\n            return \"EIO\";\n        case RT_EBUSY:\n            return \"EBUSY\";\n        case RT_EAGAIN:\n            return \"EAGAIN\";\n        case RT_EINTR:\n            return \"EINTR\";\n        case RT_EPERM:\n            return \"EPERM\";\n        case RT_EUNKNOW:\n            return \"EUNKNOW\";\n        default:\n            return \"EUNKNOW\";\n    }\n}", "CodeBleu_score": 35.08235244718087}, {"code": "const char *rt_strerror(rt_err_t error){\n\t  if (error < 0) error = -error;\n\n  switch (error) {\n    case RT_OK:\n      return \"RT_OK\";\n    case RT_EUNKNOW:\n      return \"EUNKNOW\";\n    case RT_EINVAL:\n      return \"EINVAL\";\n    case RT_EBADALLOC:\n      return \"EBADALLOC\";\n    case RT_EBADF:\n      return \"EBADF\";\n    case RT_EBADFD:\n      return \"EBADFD\";\n    case RT_EBADR:\n      return \"EBADR\";\n    case RT_EBADW:\n      return \"EBADW\";\n    case RT_EBADRW:\n      return \"EBADRW\";\n    case RT_EBADRWF:\n      return \"EBADRWF\";\n    case RT_EBADRWFD:\n      return \"EBADRWFD\";\n    case RT_EBADRWFDS:\n      return \"EBADRWFDS\";\n    case RT_EBADRWFDSM:\n      return \"EBADRWFDSM\";\n    case RT_EBADRWFDSMS:\n      return \"EBADRWFDSMS\";\n    case RT_EBADRWFDSMSM:\n      return \"EBADRWFDSMSM\";\n    case RT_EBADRWFDSMSMN:\n      return \"EBADRWFDSMSMN\";\n    case RT_EBADRWFDSMSMNS:\n      return \"EBADRWFDSMSMNS\";\n    case RT_EBADRWFDSMSMNSM:\n      return \"EBADRWFDSMSMNSM\";\n    case RT_EBADRWFDSMSMNSMS:\n      return \"EBADRWFDSMSMNSMS\";\n    case RT_EBADRWFDSMSMNSMSM:\n      return \"EBADRWFDSMSMNSMSM\";\n    case RT", "CodeBleu_score": 35.30934077579629}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t result;\n    rt_base_t index;\n    rt_base_t *p_hook;\n\n    /* lock spinlock */\n    rt_hw_spin_lock(&rt_thread_idle_spinlock);\n\n    /* find an empty slot */\n    for (index = 0; index < RT_THREAD_IDLE_HOOK_NUM; index++) {\n        p_hook = &rt_thread_idle_hook[index];\n\n        if (*p_hook == RT_NULL) {\n            break;\n        }\n    }\n\n    /* no empty slot */\n    if (index == RT_THREAD_IDLE_HOOK_NUM) {\n        result = -RT_EFULL;\n        goto __exit;\n    }\n\n    /* set hook */\n    *p_hook = hook;\n    result = RT_EOK;\n\n__exit:\n    /* unlock spinlock */\n    rt_hw_spin_unlock(&rt_thread_idle_spinlock);\n\n    return result;\n}", "CodeBleu_score": 51.1978044048162}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t result;\n\trt_base_t *ptr;\n\trt_base_t *ptr_end;\n\trt_base_t *ptr_start;\n\trt_base_t *ptr_temp;\n\n\tresult = RT_EOK;\n\tptr_start = &rt_thread_idle.hook_list[0];\n\tptr_end = &rt_thread_idle.hook_list[RT_THREAD_IDLE_MAX_HOOK_NUM - 1];\n\tptr = ptr_start;\n\n\trt_hw_interrupt_disable();\n\n\twhile (ptr <= ptr_end) {\n\t\tif (*ptr == RT_NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (ptr > ptr_end) {\n\t\tresult = -RT_EFULL;\n\t} else {\n\t\t*ptr = hook;\n\t}\n\n\trt_hw_interrupt_enable();\n\n\treturn result;\n}", "CodeBleu_score": 39.23919423016094}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\n\trt_base_t level;\n\trt_err_t result = -RT_EFULL;\n\n\t/* lock spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* iterate through idle hook list */\n\tfor (rt_uint8_t i = 0; i < RT_THREAD_IDLE_HOOK_MAX_NUM; i++) {\n\t\tif (rt_thread_idle_hook[i] == RT_NULL) {\n\t\t\trt_thread_idle_hook[i] = hook;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unlock spinlock */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 51.225795690752804}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t i;\n    rt_base_t *p_idle_hook_list;\n    rt_base_t *p_idle_hook_list_end;\n\n    /* lock spinlock */\n    rt_hw_spin_lock(&rt_thread_spinlock);\n\n    /* get idle hook list */\n    p_idle_hook_list = rt_thread_idle_get_hook_list();\n\n    /* get idle hook list end */\n    p_idle_hook_list_end = p_idle_hook_list + rt_thread_idle_get_hook_list_size();\n\n    /* find the specified hook */\n    for (i = 0; i < rt_thread_idle_get_hook_list_size(); i++) {\n        if (p_idle_hook_list[i] == (rt_base_t)hook) {\n            /* set the corresponding entry to null */\n            p_idle_hook_list[i] = (rt_base_t)RT_NULL;\n\n            /* return success code */\n            result = RT_EOK;\n\n            /* unlock spinlock */\n            rt_hw_spin_unlock(&rt_thread_spinlock);\n\n            /* return success code */\n            return result;\n        }\n    }\n\n    /* unlock spinlock */\n    rt_hw_spin_unlock(&rt_thread_spinlock);\n\n    /* return error code */\n    return -RT_ERROR;\n}", "CodeBleu_score": 47.792094479448565}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n\n    if (hook == RT_NULL) {\n        return RT_ERROR;\n    }\n\n    rt_base_t level;\n    level = rt_hw_interrupt_disable();\n\n    rt_list_t *node;\n    rt_list_t *next;\n    rt_list_for_each_safe(node, next, &rt_thread_idle_hook_list) {\n        if (node->item == hook) {\n            rt_list_remove(node);\n            result = RT_EOK;\n            goto exit;\n        }\n    }\n\n    result = RT_ERROR;\n\nexit:\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 36.57120021556091}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t i;\n\n    rt_enter_critical();\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_MAX_NUM; i++) {\n        if (rt_thread_idle_hook_table[i] == hook) {\n            rt_thread_idle_hook_table[i] = RT_NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n    if (i == RT_THREAD_IDLE_HOOK_MAX_NUM) {\n        result = RT_ERROR;\n    }\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 65.07400283086736}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_base_t level;\n    rt_thread_t thread;\n\n    /* check parameter */\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* lock scheduler */\n    level = rt_hw_interrupt_disable();\n\n    /* resume all threads in the suspension list */\n    while (!rt_list_isempty(susp_list)) {\n        thread = (rt_thread_t)rt_list_entry(susp_list->next,\n                                            struct rt_thread,\n                                            tlist);\n        rt_list_remove(&(thread->tlist));\n\n        /* resume the thread */\n        rt_thread_resume(thread);\n\n        /* notify the thread that it has been resumed */\n        if (thread_error == RT_EOK) {\n            rt_thread_notify(thread, RT_THREAD_NOTIFY_RESUME);\n        } else {\n            rt_thread_set_errno(thread, thread_error);\n        }\n    }\n\n    /* unlock scheduler */\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 34.47292132340806}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_base_t level;\n    rt_thread_t *thread;\n    rt_list_t *node;\n    rt_err_t result;\n\n    /*\n     * Check the suspension list.\n     */\n    if (susp_list == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    /*\n     * Ensure the scheduler is unlocked.\n     */\n    level = rt_hw_interrupt_disable();\n\n    /*\n     * Dequeue and wake up each suspended thread from the list one by one until the list is empty.\n     */\n    while ((node = rt_list_entry(susp_list->next, rt_list_t, next)) != susp_list) {\n        thread = rt_list_entry(node, rt_thread_t, thread_suspend_list);\n\n        /*\n         * Remove the thread from the suspension list.\n         */\n        rt_list_remove(&thread->thread_suspend_list);\n\n        /*\n         * Wake up the thread.\n         */\n        result = rt_thread_resume(thread, thread_error);\n        if (result != RT_EOK) {\n            /*\n             * Restore the suspension list.\n             */\n            rt_list_insert_after(susp_list, &thread->thread_suspend_list);\n        }\n    }\n\n    /*\n     * Restore the scheduler lock.\n     */\n    rt_hw_interrupt_enable(level);\n\n    /*\n     * Return RT_EOK to indicate successful completion.\n     */\n    return RT_EOK;\n}", "CodeBleu_score": 40.20927088963347}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_base_t level;\n\n    level = rt_hw_interrupt_disable();\n\n    while (!rt_list_isempty(susp_list)) {\n        rt_thread_t thread;\n\n        thread = (rt_thread_t)rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n        /* remove thread from suspension list */\n        rt_list_remove(&(thread->tlist));\n\n        /* resume thread */\n        rt_thread_resume(thread);\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 32.43787293546879}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t device = RT_NULL;\n    rt_device_t old_device = RT_NULL;\n\n    old_device = rt_console_get_device();\n\n    if (old_device != RT_NULL) {\n        rt_device_close(old_device);\n    }\n\n    device = rt_device_find(name);\n    if (device == RT_NULL) {\n        LOG_E(\"Can't find the device: %s\n\", name);\n        return RT_NULL;\n    }\n\n    if (device == old_device) {\n        return old_device;\n    }\n\n    if (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        LOG_E(\"Can't open the device: %s\n\", name);\n        return RT_NULL;\n    }\n\n    rt_console_set_device(device);\n\n    return old_device;\n}", "CodeBleu_score": 56.97350738475379}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t current_device = rt_console_get_device();\n    rt_device_t device = RT_NULL;\n\n    /* check the parameter */\n    if (name == RT_NULL) {\n        return current_device;\n    }\n\n    /* find the device by name */\n    device = rt_device_find(name);\n    if (device == RT_NULL) {\n        return current_device;\n    }\n\n    /* check if the device is the same as the current device */\n    if (device == current_device) {\n        return current_device;\n    }\n\n    /* close the current console device if it exists */\n    if (current_device != RT_NULL) {\n        rt_device_close(current_device);\n    }\n\n    /* open the new console device with read/write and stream flags */\n    if (rt_device_open(device, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return current_device;\n    }\n\n    /* set the new console device */\n    rt_console_set_device(device);\n\n    return current_device;\n}", "CodeBleu_score": 56.4097484822882}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t dev, old_dev;\n    rt_err_t result;\n\n    /* save the current console device */\n    old_dev = rt_console_get_device();\n\n    /* find the new device */\n    dev = rt_device_find(name);\n    if (dev == RT_NULL) {\n        LOG_E(\"Can't find console device: %s\", name);\n        return old_dev;\n    }\n\n    /* check if it is the same as the current device */\n    if (dev == old_dev) {\n        return old_dev;\n    }\n\n    /* close the current console device if it exists */\n    if (old_dev != RT_NULL) {\n        rt_device_close(old_dev);\n    }\n\n    /* open the new console device with read/write and stream flags */\n    result = rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        LOG_E(\"Can't open console device: %s\", name);\n        return old_dev;\n    }\n\n    /* set it as the new console device */\n    rt_console_set_device(dev);\n\n    return old_dev;\n}", "CodeBleu_score": 56.46212868875337}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    rt_object_t *object;\n    int count = 0;\n\n    /* check parameter */\n    RT_ASSERT(type < RT_Object_Class_Max);\n\n    /* lock object list */\n    rt_base_t level = rt_hw_interrupt_disable();\n\n    /* count objects */\n    for (object = rt_object_list[type]; object != RT_NULL; object = object->next)\n    {\n        count++;\n    }\n\n    /* unlock object list */\n    rt_hw_interrupt_enable(level);\n\n    return count;\n}", "CodeBleu_score": 30.682469979201432}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    rt_object_t object;\n    rt_base_t level;\n\n    level = rt_hw_interrupt_disable();\n\n    if (type == RT_Object_Class_Thread) {\n        object = rt_thread_self();\n    } else if (type == RT_Object_Class_Semaphore) {\n        object = rt_sem_self();\n    } else if (type == RT_Object_Class_Mutex) {\n        object = rt_mutex_self();\n    } else if (type == RT_Object_Class_Event) {\n        object = rt_event_self();\n    } else if (type == RT_Object_Class_MailBox) {\n        object = rt_mb_self();\n    } else if (type == RT_Object_Class_MessageQueue) {\n        object = rt_mq_self();\n    } else if (type == RT_Object_Class_MemoryPool) {\n        object = rt_mp_self();\n    } else if (type == RT_Object_Class_MemoryManager) {\n        object = rt_mm_self();\n    } else if (type == RT_Object_Class_Module) {\n        object = rt_module_self();\n    } else if (type == RT_Object_Class_Device) {\n        object = rt_device_self();\n    } else if (type == RT_Object_Class_Filesystem) {\n        object = rt_fs_self();\n    } else if (type == RT_Object_Class_Dump) {\n        object = rt_dump_self();\n    } else if (type == RT_Object_Class_Timer) {\n        object = rt_timer_self();\n    } else if (type == RT_Object_Class_Unknown) {\n        object = RT_NULL;\n    } else {\n        object = RT_NULL;\n    }\n\n    if (object != RT_NULL) {\n        rt_base_t i;\n        rt_object_t *object_list = (rt_object_t *)object;\n\n        for (i = 0; i <", "CodeBleu_score": 36.01100983611897}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    rt_base_t count = 0;\n    rt_base_t level;\n    rt_object_t object;\n\n    /* check the parameter */\n    RT_ASSERT(type < RT_Object_Class_MAX);\n\n    /* lock the spinlock */\n    level = rt_hw_interrupt_disable();\n\n    /* get the object list */\n    object = rt_object_list[type];\n\n    /* iterate through the object list */\n    while (object != RT_NULL) {\n        count++;\n        object = object->next;\n    }\n\n    /* unlock the spinlock */\n    rt_hw_interrupt_enable(level);\n\n    return count;\n}", "CodeBleu_score": 37.16130042551649}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n    rt_object_info_t *info;\n\n    /* check parameter */\n    RT_ASSERT(object != RT_NULL);\n\n    /* get object information */\n    info = (rt_object_info_t *)object;\n\n    /* lock spinlock */\n    level = rt_hw_interrupt_disable();\n\n    /* remove object from list */\n    rt_list_remove(&(info->list));\n\n    /* unlock spinlock */\n    rt_hw_interrupt_enable(level);\n\n    /* set object type to zero */\n    info->type = 0;\n}", "CodeBleu_score": 25.219826945162705}, {"code": "void rt_object_detach(rt_object_t object){\n\t\n  rt_base_t level;\n  rt_object_info_t *object_info;\n\n  if (object != RT_NULL) {\n    level = rt_hw_interrupt_disable();\n\n    object_info = (rt_object_info_t *)object;\n\n    /* detach object from the object list */\n    rt_list_remove(&(object_info->list));\n\n    /* detach object from the object name list */\n    rt_list_remove(&(object_info->name_list));\n\n    /* set object type to zero */\n    object_info->type = 0;\n\n    rt_hw_interrupt_enable(level);\n  }\n}", "CodeBleu_score": 39.30695235563309}, {"code": "void rt_object_detach(rt_object_t object){\n\t\n    rt_base_t level;\n\n    /* check the object */\n    if (object == RT_NULL)\n        return;\n\n    /* call the detach hook */\n    rt_object_on_detach(object);\n\n    /* get the object's info structure */\n    rt_object_info_t *info = &object->info;\n\n    /* lock the spinlock */\n    level = rt_hw_interrupt_disable();\n\n    /* remove the object from its list */\n    rt_list_remove(&(info->list));\n\n    /* unlock the spinlock */\n    rt_hw_interrupt_enable(level);\n\n    /* set the object's type to zero */\n    info->type = 0;\n}", "CodeBleu_score": 27.680934940435588}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\trt_object_class_t class;\n\trt_object_custom_t *custom;\n\n\t/* check if the object is valid */\n\tif (obj == RT_NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/* get the object's class */\n\tclass = rt_object_get_class(obj);\n\n\t/* check if the object is of the custom class type */\n\tif (class != RT_Object_Class_Custom) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/* get the custom object's data */\n\tcustom = (rt_object_custom_t *)obj;\n\n\t/* check if the object has a destroy method */\n\tif (custom->destroy == RT_NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/* call the object's destroy method */\n\tresult = custom->destroy(obj);\n\n\t/* delete the object */\n\trt_free(obj);\n\n\t/* return the result of the destroy operation */\n\treturn result;\n}", "CodeBleu_score": 45.39510354057176}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n    rt_object_t *object = (rt_object_t *)obj;\n\n    if (object == RT_NULL) {\n        return RT_ERROR;\n    }\n\n    if (object->type != RT_Object_Class_Custom) {\n        return RT_ERROR;\n    }\n\n    if (object->destroy != RT_NULL) {\n        result = object->destroy(object);\n    }\n\n    rt_free(object);\n\n    return result;\n}", "CodeBleu_score": 50.80473787281705}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_base_t result;\n\n    /* Check if the object is valid. */\n    if (!obj) {\n        return RT_EINVAL;\n    }\n\n    /* Check if the object is of the custom object class type. */\n    if (obj->type != RT_Object_Class_Custom) {\n        return RT_ETYPE;\n    }\n\n    /* Check if the object has a destroy method. */\n    if (!obj->destroy) {\n        return RT_ENOSYS;\n    }\n\n    /* Call the destroy method. */\n    result = obj->destroy(obj);\n\n    /* Delete the object. */\n    rt_free(obj);\n\n    /* Return the result of the destroy operation. */\n    return result;\n}", "CodeBleu_score": 48.8621450946454}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t thread = rt_thread_self();\n\n    rt_enter_critical();\n\n    /* close thread */\n    thread->state = RT_THREAD_CLOSE;\n    rt_list_remove(&(thread->tlist));\n\n    /* add to defunct list */\n    rt_list_append(&(rt_thread_list.defunct), &(thread->tlist));\n\n    rt_exit_critical();\n\n    /* trigger context switch */\n    rt_schedule();\n}", "CodeBleu_score": 51.48799869633458}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n\n    thread = rt_thread_self();\n    if (thread != RT_NULL) {\n        rt_enter_critical();\n        rt_thread_close(thread);\n        rt_exit_critical();\n        rt_schedule();\n    }\n}", "CodeBleu_score": 62.189823511983654}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n    if (thread == RT_NULL)\n        return;\n\n    /* enter critical section */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* leave critical section */\n    rt_exit_critical();\n\n    /* trigger context switch */\n    rt_schedule();\n}", "CodeBleu_score": 62.202365795066264}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t) parameter;\n\n    if (thread == NULL) {\n        return;\n    }\n\n    rt_base_t level;\n\n    level = rt_hw_interrupt_disable();\n\n    if (thread->current_priority != RT_THREAD_PRIORITY_MAX) {\n        rt_kprintf(\"thread %s timeout\n\", thread->name);\n        thread->error_code = -RT_ETIMEOUT;\n        rt_list_remove(&(thread->tlist));\n        rt_list_insert_after(&(rt_current_thread->tlist), &(thread->tlist));\n    }\n\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 44.8754713043308}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t)parameter;\n\n    if (thread == RT_NULL) {\n        return;\n    }\n\n    rt_enter_critical();\n\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_set_errno(RT_ERROR);\n        rt_exit_critical();\n        return;\n    }\n\n    thread->stat = RT_THREAD_READY;\n    rt_list_remove(&(thread->tlist));\n    rt_list_insert_tail(&(rt_thread_priority_table[thread->current_priority].tlist), &(thread->tlist));\n    rt_exit_critical();\n\n    rt_schedule();\n}", "CodeBleu_score": 39.11225701361439}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread;\n    rt_list_t *node;\n\n    thread = (rt_thread_t)parameter;\n\n    /* check parameter */\n    if (thread == RT_NULL) {\n        return;\n    }\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* check thread state */\n    if (thread->state != RT_THREAD_SUSPEND) {\n        rt_exit_critical();\n        return;\n    }\n\n    /* set thread error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove thread from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert thread into ready list */\n    rt_list_insert_before(&(thread->node), &(rt_thread_priority_table[thread->current_priority].tlist));\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    return;\n}", "CodeBleu_score": 37.908792308887406}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_thread_t curr_thread;\n    rt_thread_t next_thread;\n\n    /* lock thread spinlock */\n    level = rt_hw_interrupt_disable();\n\n    /* get current thread */\n    curr_thread = rt_thread_self();\n\n    /* check if the thread is waiting on a mutex */\n    if (thread->mutex != RT_NULL) {\n        /* remove the thread from the mutex's waiting list */\n        next_thread = thread->mutex->wait_list;\n        while (next_thread != RT_NULL) {\n            if (next_thread == thread) {\n                thread->mutex->wait_list = next_thread->next;\n                break;\n            }\n            next_thread = next_thread->next;\n        }\n\n        /* clear the pending object */\n        thread->mutex->pending_object = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    while (thread->mutex_taken != RT_NULL) {\n        rt_mutex_release(thread->mutex_taken);\n    }\n\n    /* restore the spinlock state */\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 42.25832903194881}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_thread_t thread_to_detach;\n\trt_thread_t thread_to_detach_next;\n\trt_mutex_t mutex;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\tthread_to_detach = thread;\n\n\t/*\n\t * Check if the thread is waiting on a mutex\n\t */\n\twhile (thread_to_detach != RT_NULL) {\n\t\tmutex = thread_to_detach->wait_mutex;\n\n\t\tif (mutex != RT_NULL) {\n\t\t\t/*\n\t\t\t * Remove the thread from the waiting list of the mutex\n\t\t\t */\n\t\t\tthread_to_detach_next = thread_to_detach->next;\n\t\t\tthread_to_detach->next = RT_NULL;\n\t\t\tthread_to_detach->wait_mutex = RT_NULL;\n\t\t\tmutex->wait_list = thread_to_detach_next;\n\n\t\t\tif (mutex->wait_list == RT_NULL) {\n\t\t\t\tmutex->pending_object = RT_NULL;\n\t\t\t}\n\n\t\t\tthread_to_detach = thread_to_detach_next;\n\t\t} else {\n\t\t\tthread_to_detach = RT_NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Release all mutexes the thread has taken\n\t */\n\tthread_to_detach = thread;\n\n\twhile (thread_to_detach != RT_NULL) {\n\t\tmutex = thread_to_detach->taken_mutex;\n\n\t\tif (mutex != RT_NULL) {\n\t\t\tthread_to_detach->taken_mutex = RT_NULL;\n\t\t\trt_mutex_release(mutex);\n\t\t}\n\n\t\tthread_to_detach = thread_to_detach->next;\n\t}\n\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 32.19426143494778}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n\n    /* lock the thread's spinlock */\n    level = rt_hw_interrupt_disable();\n\n    /* check if the thread is waiting on a mutex */\n    if (thread->mutex != RT_NULL) {\n        rt_mutex_t mutex = thread->mutex;\n\n        /* remove the thread from the mutex's waiting list */\n        mutex->wait_list.next = thread->mutex_wait_next;\n\n        /* clear the pending object */\n        mutex->pending = RT_NULL;\n\n        /* set the thread's mutex to NULL */\n        thread->mutex = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    while (thread->mutex_list.next != &thread->mutex_list) {\n        rt_mutex_t mutex = (rt_mutex_t)thread->mutex_list.next;\n\n        /* remove the mutex from the thread's list */\n        thread->mutex_list.next = mutex->wait_list.next;\n\n        /* release the mutex */\n        rt_mutex_release(mutex);\n    }\n\n    /* restore the spinlock state */\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 42.26717985814817}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\n    rt_err_t result = RT_EOK;\n\n    if (thread == RT_NULL) {\n        result = RT_ERROR;\n    } else if (thread->state == RT_THREAD_INIT) {\n        rt_kprintf(\"[%s] start, prio: %d, stack: %d\n\", thread->name, thread->current_priority, thread->stack_size);\n\n        thread->priority_attribute = rt_thread_get_priority_attribute(thread);\n\n        thread->state = RT_THREAD_SUSPEND;\n\n        rt_hw_interrupt_enable(RT_IPL_NONE);\n\n        rt_thread_resume(thread);\n\n        if (rt_system_scheduler_isexist() == RT_TRUE) {\n            rt_system_scheduler_up(thread);\n        }\n    } else {\n        result = RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 42.341972367241674}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\n    /* check the parameter */\n    RT_ASSERT(thread != RT_NULL);\n\n    /* check the thread state */\n    if (thread->state != RT_THREAD_INIT)\n    {\n        rt_kprintf(\"The thread[%s] is not in initialization state.\n\", thread->name);\n        return -RT_ERROR;\n    }\n\n    /* check the thread type */\n    if (thread->type != RT_THREAD_TYPE_NORMAL)\n    {\n        rt_kprintf(\"The thread[%s] is not a normal thread.\n\", thread->name);\n        return -RT_ERROR;\n    }\n\n    /* log the thread name and priority */\n    rt_kprintf(\"The thread[%s] is starting, priority is %d.\n\", thread->name, thread->current_priority);\n\n    /* calculate the thread priority attributes */\n    rt_thread_priority_calc(thread);\n\n    /* reset the thread state to suspended */\n    thread->state = RT_THREAD_SUSPEND;\n\n    /* resume the thread */\n    rt_thread_resume(thread);\n\n    /* trigger a scheduler if available */\n    if (rt_thread_self() == RT_NULL)\n    {\n        rt_schedule();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 49.60703708213454}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\n    rt_base_t level;\n\n    /* check parameter */\n    if (thread == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    /* check thread state */\n    if (thread->state != RT_THREAD_INIT) {\n        return -RT_ERROR;\n    }\n\n    /* check thread type */\n    if (thread->type != RT_THREAD_TYPE_NORMAL) {\n        return -RT_ERROR;\n    }\n\n    /* log thread name and priority */\n    rt_kprintf(\"[%s] prio:%u, stack:%u, ticks:%u\n\",\n               thread->name, thread->current_priority,\n               thread->stack_size, thread->time_slice);\n\n    /* calculate thread priority attributes */\n    thread->init_priority = thread->current_priority;\n    thread->init_priority_time_slice = thread->time_slice;\n    thread->init_priority_time_slice_max = thread->time_slice;\n    thread->init_priority_time_slice_min = thread->time_slice;\n    thread->init_priority_time_slice_remain = thread->time_slice;\n\n    /* reset thread state to suspended */\n    thread->state = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    level = rt_hw_interrupt_disable();\n    thread->resume_count++;\n    rt_hw_interrupt_enable(level);\n\n    /* trigger scheduler if available */\n    if (thread->init_priority != RT_THREAD_PRIORITY_MAX) {\n        rt_schedule();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 41.00993981060275}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *node;\n    rt_tick_t tick;\n    rt_uint8_t level;\n\n    /* check if the highest level of the timer skip list is not empty */\n    for (level = 0; level < RT_TIMER_SKIP_LIST_LEVEL; level++) {\n        if (timer_list[level].next != &(timer_list[level])) {\n            /* get the first timer entry and sets the provided timeout tick to the timer's timeout value */\n            node = timer_list[level].next;\n            tick = node->tick;\n            *timeout_tick = tick;\n\n            return RT_EOK;\n        }\n    }\n\n    /* if the list is empty, it returns an error code */\n    return -RT_ERROR;\n}", "CodeBleu_score": 41.73878647554563}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_timer_t timer;\n    rt_timer_node_t *node;\n    rt_uint32_t level;\n    rt_list_t *list;\n\n    /* get the highest level of the timer skip list */\n    for (level = RT_TIMER_SKIP_LIST_MAX_LEVEL; level > 0; level--) {\n        list = &timer_list[level];\n        if (list->next != list) {\n            break;\n        }\n    }\n\n    /* the highest level of the timer skip list is empty */\n    if (level == 0) {\n        return -RT_ERROR;\n    }\n\n    /* get the first timer entry */\n    node = (rt_timer_node_t *)list->next;\n    timer = node->timer;\n\n    /* set the timeout tick to the timer's timeout value */\n    *timeout_tick = timer->timeout;\n\n    return RT_EOK;\n}", "CodeBleu_score": 41.25411607745431}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_base_t level = 0;\n\n    /* check if the highest level of the timer skip list is not empty */\n    while (level < RT_TIMER_SKIP_LIST_MAX_LEVEL) {\n        if (!rt_list_isempty(&timer_list[level])) {\n            /* get the first timer entry */\n            rt_timer_t *timer = rt_list_entry(timer_list[level].next, rt_timer_t, list);\n\n            /* set the provided timeout tick to the timer's timeout value */\n            *timeout_tick = timer->timeout_tick;\n\n            /* return RT_EOK */\n            return RT_EOK;\n        }\n\n        /* increase the level */\n        level++;\n    }\n\n    /* return an error code */\n    return -RT_ERROR;\n}", "CodeBleu_score": 49.18815031060929}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* check the argument */\n    RT_ASSERT(timeout);\n\n    /* create a timer object */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    /* initialize the timer object */\n    rt_memset(timer, 0, sizeof(struct rt_timer));\n    rt_strncpy(timer->name, name, RT_NAME_MAX);\n    timer->timeout = timeout;\n    timer->parameter = parameter;\n    timer->flag = flag;\n\n    /* set the timer period */\n    rt_timer_set_period(timer, time);\n\n    return timer;\n}", "CodeBleu_score": 51.510556534864136}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL) {\n        rt_list_init(&(timer->list));\n        timer->name = name;\n        timer->timeout = timeout;\n        timer->parameter = parameter;\n        timer->flag = flag;\n        timer->time = time;\n        timer->current = time;\n        timer->owner = RT_NULL;\n        timer->magic = TIMER_MAGIC;\n    }\n\n    return timer;\n}", "CodeBleu_score": 49.20076518280463}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer = RT_NULL;\n\n    /* check the timer name */\n    RT_ASSERT(name != RT_NULL);\n\n    /* check the timeout function */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* check the time */\n    RT_ASSERT(time > 0);\n\n    /* create timer object */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL) {\n        /* initialize timer */\n        rt_memset(timer, 0, sizeof(struct rt_timer));\n\n        /* set timer name */\n        rt_strncpy(timer->name, name, RT_NAME_MAX);\n\n        /* set timer timeout function */\n        timer->timeout = timeout;\n\n        /* set timer parameter */\n        timer->parameter = parameter;\n\n        /* set timer time */\n        timer->time = time;\n\n        /* set timer flag */\n        timer->flag = flag;\n\n        /* set timer list */\n        rt_list_init(&(timer->list));\n\n        /* set timer thread */\n        timer->thread = rt_thread_self();\n\n        /* set timer state */\n        timer->state = RT_TIMER_STATE_INACTIVE;\n    }\n\n    return timer;\n}", "CodeBleu_score": 49.8857191719645}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\ta.handlers.ServeHTTP(recorder, req)\n\n\tfor k, v := range recorder.Header() {\n\t\tres.Header()[k] = v\n\t}\n\n\tif recorder.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 58.37778410170744}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\thandler := http.HandlerFunc(a.handleRequest)\n\thandler.ServeHTTP(recorder, req)\n\tcopyHeaders(recorder.HeaderMap, res.Header())\n\tres.WriteHeader(recorder.Code)\n\t_, err := recorder.Body.WriteTo(res)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}", "CodeBleu_score": 33.52135252384464}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tvar (\n\t\trecorder *httptest.ResponseRecorder\n\t\thandler  http.Handler\n\t)\n\n\tfor _, handler = range a.middleware {\n\t\trecorder = httptest.NewRecorder()\n\t\thandler.ServeHTTP(recorder, req)\n\t\tcopyHeaders(res, recorder.Result())\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 51.684481816211616}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := strings.TrimPrefix(req.URL.Path, \"/\")\n\tasset, err := robeaux.Asset(path)\n\tif err != nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\n\tvar contentType string\n\tswitch {\n\tcase strings.HasSuffix(path, \".js\"):\n\t\tcontentType = \"application/javascript\"\n\tcase strings.HasSuffix(path, \".css\"):\n\t\tcontentType = \"text/css\"\n\tcase strings.HasSuffix(path, \".html\"):\n\t\tcontentType = \"text/html\"\n\tdefault:\n\t\tcontentType = \"text/plain\"\n\t}\n\n\tres.Header().Set(\"Content-Type\", contentType)\n\tres.Write(asset)\n}", "CodeBleu_score": 44.58606386126981}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := a.assets.Get(req.URL.Path)\n\tif err != nil {\n\t\thttp.Error(res, http.StatusText(404), 404)\n\t\treturn\n\t}\n\tswitch {\n\tcase strings.HasSuffix(req.URL.Path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase strings.HasSuffix(req.URL.Path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(req.URL.Path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 51.5727738587049}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := a.assets.Get(req.URL.Path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch {\n\tcase strings.HasSuffix(asset.Name(), \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase strings.HasSuffix(asset.Name(), \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(asset.Name(), \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t_, err = res.Write(asset.Data())\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}", "CodeBleu_score": 61.64497464220925}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"no robot named %s\", name),\n\t\t})\n\t\treturn\n\t}\n\tconnections := make([]map[string]string, 0)\n\tfor _, c := range robot.Connections() {\n\t\tconnections = append(connections, map[string]string{\n\t\t\t\"name\": c.Name(),\n\t\t\t\"adaptor\": c.Adaptor().Name(),\n\t\t\t\"driver\": c.Driver().Name(),\n\t\t})\n\t}\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 46.04199621675921}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.respond(res, http.StatusNotFound, fmt.Sprintf(\"No robot with name %s\", name))\n\t\treturn\n\t}\n\ta.respond(res, http.StatusOK, robot.Connections())\n}", "CodeBleu_score": 25.131279770642855}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.respond(res, req, http.StatusNotFound, map[string]string{\"error\": fmt.Sprintf(\"No robot named %s\", name)})\n\t\treturn\n\t}\n\n\tconnections := a.master.Robot(name).Connections()\n\ta.respond(res, req, http.StatusOK, connections)\n}", "CodeBleu_score": 31.51492029664096}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := basicAuth(r)\n\t\tif s == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tu, p, ok := basicAuth(r)\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(u), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(p), []byte(password)) != 1 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.393677742495555}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := r.Header.Get(\"Authorization\")\n\t\tif s == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := make([]string, 2)\n\t\tpair = append(pair, string(b))\n\n\t\tif len(pair) != 2 || !validate(pair[0], pair[1], username, password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.84730299160146}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := r.Header.Get(\"Authorization\")\n\t\tif s == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tpair := make([]string, 2)\n\t\tpair = append(pair, string(b))\n\n\t\tif len(pair) != 2 || !validate(pair[0], pair[1], username, password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.72835016467452}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tfromRange := fromMax - fromMin\n\ttoRange := float64(toMax - toMin)\n\tslope := toRange / fromRange\n\tintercept := float64(toMin) - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 55.13177438558462}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tscale := float64(toMax - toMin) / float64(fromMax - fromMin)\n\toffset := toMin - fromMin * scale\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(input * scale + offset)\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t} else if value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.39035254725874}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tfromMin = float64(fromMin)\n\tfromMax = float64(fromMax)\n\ttoMin = float64(toMin)\n\ttoMax = float64(toMax)\n\n\tscale := (toMax - toMin) / (fromMax - fromMin)\n\toffset := toMin - fromMin * scale\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(input * scale + offset)\n\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn\n\t}\n}", "CodeBleu_score": 47.90071376012893}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif !a.connection.(*AnalogSensor).connection.(*I2CConnection).valid {\n\t\treturn 0, 0, fmt.Errorf(\"invalid connection\")\n\t}\n\traw, err := a.connection.(*AnalogSensor).connection.(*I2CConnection).ReadWordData(a.connection.(*AnalogSensor).address)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.connection.(*AnalogSensor).connection.(*I2CConnection).scaledRead(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 49.78088743904298}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.SupportsAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog\")\n\t}\n\n\traw, err := a.connection.ReadAnalog(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.connection.Scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 50.241194535388544}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection is nil\")\n\t}\n\traw, err := a.connection.Read(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 47.90274106182395}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tdeltaX := float64(fromMax - fromMin)\n\tdeltaY := float64(toMax - toMin)\n\tm := deltaY / deltaX\n\tn := toMin - m*float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 53.94664257666749}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 40.09414721088014}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\n\tm := float64(toRange) / float64(fromRange)\n\tn := toMin - m*float64(fromMin)\n\n\treturn func(input int) float64 {\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 60.40627165306333}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tdriver := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t}\n\n\tdriver.AddEvent(Vibration)\n\tdriver.AddEvent(Data)\n\n\tdriver.On(Data, func(data interface{}) {\n\t\tif driver.Threshold() > 0 && data.(int) > driver.Threshold() {\n\t\t\tdriver.Publish(Vibration, true)\n\t\t}\n\t})\n\n\treturn driver\n}", "CodeBleu_score": 42.39624139093527}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t}\n\n\td.AddEvent(d.Event(\"Vibration\"))\n\n\td.AddEvent(d.Event(\"Data\"))\n\n\td.AddHandler(d.Event(\"Data\"), func(data interface{}) {\n\t\tif d.threshold != 0 && data.(int) > d.threshold {\n\t\t\td.Publish(d.Event(\"Vibration\"), data)\n\t\t}\n\t})\n\n\td.AddHandler(d.Event(\"Data\"), func(data interface{}) {\n\t\td.Publish(d.Event(\"Data\"), data)\n\t})\n\n\treturn d\n}", "CodeBleu_score": 43.535678900380546}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t}\n\n\td.AddEvent(Vibration)\n\n\td.AddEvent(Data)\n\td.On(Data, func(data interface{}) {\n\t\tif d.threshold > 0 && data.(int) > d.threshold {\n\t\t\td.Publish(Vibration, data)\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 44.39283352351102}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\td.Tone(hz, duration)\n\treturn nil\n}", "CodeBleu_score": 7.418085365988249}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := (1 / hz) * 1000\n\ttempo := (60 / d.bpm) * 1000\n\td.frequency = hz\n\td.duration = duration\n\n\td.interval = period\n\n\treturn gobot.Every(time.Duration(d.interval)*time.Millisecond, func() {\n\t\tif d.interval > 0 {\n\t\t\td.interval = period\n\t\t}\n\t\tif d.duration > 0 {\n\t\t\td.duration = d.duration - (d.interval / 1000)\n\t\t}\n\n\t\td.Toggle()\n\t})\n}", "CodeBleu_score": 30.9965450436019}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := (1 / hz) * 1000\n\ttempo := (60 * 1000) / d.bpm\n\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.pwm.SetPeriod(int64(period))\n\td.pwm.SetPulseWidth(int64(tempo / 2))\n\n\ttime.Sleep(time.Duration(duration) * time.Millisecond)\n\n\td.pwm.SetPulseWidth(0)\n\n\treturn nil\n}", "CodeBleu_score": 28.906747396741768}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.SleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\n\td.stop()\n\td.setSleepPinLow()\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 28.69466633510705}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.Stop()\n\td.sleepPin.DigitalWrite(0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.889790011570597}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\n\td.Stop()\n\n\td.sleepPin.Write(byte(0))\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 30.42980234577874}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp := system.NewAnalogPin(path, params)\n\ta.pins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 51.88798982442576}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins not supported\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, params, err := a.translatePin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := system.NewAnalogPin(path, params...)\n\ta.pins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 50.56947924808466}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := system.NewAnalogPin(path, params)\n\ta.pins[id] = p\n\n\treturn p, nil\n}", "CodeBleu_score": 51.88798982442576}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\n\tpin, err := a.getPin(id, \"digital\", \"output\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ta.pins[pin.id].write(val)\n\treturn nil\n}", "CodeBleu_score": 58.79303650767014}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\n\tpin, err := a.getDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 57.85643555020452}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\tpin, err := a.getDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = pin.Output(); err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 64.97454201382075}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.connected {\n\t\treturn nil, fmt.Errorf(\"adaptor is not connected\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := a.translateID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = a.chip(chip).pin(line)\n\t\tpin.Options(opts...)\n\t\tif err := pin.Init(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t} else {\n\t\tpin.Options(opts...)\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 55.39202250203283}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.connected {\n\t\treturn nil, fmt.Errorf(\"adaptor not connected\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := a.translateID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = system.NewDigitalPin(chip, line)\n\t\ta.pins[id] = pin\n\t}\n\n\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 52.42798764787633}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.connected {\n\t\treturn nil, fmt.Errorf(\"adaptor is not connected\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = gobot.NewDigitalPin(id, chip, line)\n\t\tpin.Init(a.connector, opts...)\n\n\t\ta.pins[id] = pin\n\t} else {\n\t\tpin.Init(a.connector, opts...)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 47.581925893663055}]}
