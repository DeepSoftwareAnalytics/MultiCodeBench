{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> files;\n    std::vector<std::string> required_files;\n\n    // Get the list of files in the specified folder\n    files = _pimpl->CallAndWait<std::vector<std::string>>(\"GetFilesInFolder\", folder);\n\n    // Check if each file exists locally\n    for (const auto &file : files) {\n        if (download && !_pimpl->CallAndWait<bool>(\"FileExists\", file)) {\n            // Request the file and log the download action\n            _pimpl->CallAndWait<void>(\"RequestFile\", file);\n            log_info(\"Downloading file: \" + file);\n        } else {\n            // Log that the file is found in the cache\n            log_info(\"File found in cache: \" + file);\n        }\n        required_files.push_back(file);\n    }\n\n    return required_files;\n}", "CodeBleu_score": 52.395718906322365}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    log_info\n    std::vector<std::string> required_files;\n    std::string file_path;\n    for (const auto &file : _pimpl->GetFileList(folder)) {\n        file_path = folder + \"/\" + file;\n        if (download && !_pimpl->FileExists(file_path)) {\n            _pimpl->RequestFile(file_path);\n            log_info\n        } else {\n            log_info\n        }\n        required_files.push_back(file_path);\n    }\n    return required_files;\n}", "CodeBleu_score": 51.36521549588329}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> required_files;\n    for (const auto &file : m_required_files[folder]) {\n        if (download && !FileExists(file)) {\n            required_files.push_back(file);\n            RequestFile(file);\n            log_info(\"Downloading file: \" + file);\n        } else if (!download) {\n            required_files.push_back(file);\n        } else {\n            log_info(\"File found in cache: \" + file);\n        }\n    }\n    return required_files;\n}", "CodeBleu_score": 55.160779408366864}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the transformation is valid for SpringArm and SpringArmGhost attachment types.\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    geom::Vector3D location = transform.location;\n    if (location.x == 0.0f && location.y == 0.0f && location.z != 0.0f) {\n      LOG(WARNING) << \"Invalid transformation for SpringArm or SpringArmGhost attachment type. \"\n                   << \"Translation is only in the 'z' axis. \"\n                   << \"The actor will be spawned with a default location.\";\n      location = geom::Vector3D::Zero();\n    }\n  }\n\n  // Call the internal function to complete the actor spawning process.\n  return _pimpl->CallAndWait<rpc::Actor>(\n      [&](rpc::Client &client) {\n        return client.SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n      });\n}", "CodeBleu_score": 52.71969353277651}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the transformation is valid.\n  if (attachment_type == rpc::AttachmentType::SPRINGARM ||\n      attachment_type == rpc::AttachmentType::SPRINGARM_GHOST) {\n    if (transform.location.z != 0.0f) {\n      LOG(WARNING) << \"Invalid transformation for attachment type \"\n                   << attachment_type << \": translation in 'z' axis is not 0.\";\n    }\n  }\n\n  // Call the internal function to complete the actor spawning process.\n  return SpawnActorWithParentInternal(\n      description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 38.39772196033993}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the transformation is valid\n  if (attachment_type == rpc::AttachmentType::SPRING_ARM ||\n      attachment_type == rpc::AttachmentType::SPRING_ARM_GHOST) {\n    if (transform.location.z == 0.0f) {\n      LOG(WARNING) << \"Invalid transformation for attachment type \"\n                   << attachment_type << \": translation only in 'z' axis\";\n    }\n  }\n  // Call the internal function to complete the actor spawning process\n  return SpawnActorWithParentInternal(description, transform, parent,\n                                      attachment_type, socket_name);\n}", "CodeBleu_score": 38.81381865355666}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token_data = _pimpl->GetGBufferToken(ActorId, GBufferId);\n  auto token_data_copy = std::vector<unsigned char>(token_data.size());\n  std::memcpy(token_data_copy.data(), token_data.data(), token_data.size());\n  _pimpl->streaming_client.Subscribe(std::move(token_data_copy), callback);\n}", "CodeBleu_score": 58.23793981705929}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  std::vector<unsigned char> token_data =\n      _pimpl->streaming_client.GetTokenForGBuffer(ActorId, GBufferId);\n  std::vector<unsigned char> token_data_copy(token_data.size());\n  std::memcpy(token_data_copy.data(), token_data.data(), token_data.size());\n  _pimpl->streaming_client.Subscribe(std::move(token_data_copy), callback);\n}", "CodeBleu_score": 60.88672957974901}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token_data = _pimpl->streaming_client.GetGBufferToken(ActorId, GBufferId);\n  std::vector<unsigned char> token_vector(token_data.size());\n  std::memcpy(token_vector.data(), token_data.data(), token_data.size());\n  _pimpl->streaming_client.Subscribe(std::move(token_vector), callback);\n}", "CodeBleu_score": 60.98774646417142}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n  if (navigation == nullptr) {\n    std::shared_ptr<WalkerNavigation> new_navigation = std::make_shared<WalkerNavigation>();\n    navigation = _walker_navigation.compare_exchange(navigation, new_navigation)\n        ? navigation\n        : new_navigation;\n  }\n  return navigation;\n}", "CodeBleu_score": 56.76859290357436}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>();\n    _walker_navigation.compare_exchange(navigation, nullptr);\n  }\n  return navigation;\n}", "CodeBleu_score": 51.00783513168856}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>();\n    if (!_walker_navigation.compare_exchange_weak(navigation, navigation)) {\n      navigation = _walker_navigation.load();\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 54.10459986138505}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::system_clock::now();\n  while (episode.GetState()->GetTimestamp() < frame) {\n    std::this_thread::yield();\n    auto now = std::chrono::system_clock::now();\n    if (std::chrono::duration_cast<std::chrono::milliseconds>(now - start) > timeout) {\n      return false;\n    }\n  }\n  TrafficManager::GetInstance().Tick();\n  return true;\n}", "CodeBleu_score": 50.95266939595871}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::system_clock::now();\n  auto end = start + timeout.to_chrono();\n  while (std::chrono::system_clock::now() < end) {\n    if (episode.GetState()->GetTimestamp() >= frame) {\n      TrafficManager::Tick();\n      return true;\n    }\n    std::this_thread::yield();\n  }\n  return false;\n}", "CodeBleu_score": 46.74352612432144}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = system_clock::now();\n  while (episode.GetState()->GetTimestamp() < frame) {\n    std::this_thread::yield();\n    auto now = system_clock::now();\n    if (now - start > timeout) {\n      return false;\n    }\n  }\n  TrafficManager::Tick();\n  return true;\n}", "CodeBleu_score": 36.21675351581379}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  EpisodeProxy episode;\n  rpc::EpisodeSettings settings;\n  settings.set_map_name(map_name);\n  settings.set_reset_settings(reset_settings);\n  settings.set_map_layers(map_layers);\n  episode.SetId(_client.LoadEpisode(settings));\n  _client.GetTimeout().milliseconds(10000);\n  for (int i = 0; i < 10; i++) {\n    episode.WaitForState(rpc::EpisodeState::Running);\n    if (episode.GetId() != GetCurrentEpisode().GetId()) {\n      return episode;\n    }\n    _client.GetTimeout().milliseconds(10000);\n  }\n  throw_exception(\"Failed to connect to the new episode within the allowed attempts.\");\n}", "CodeBleu_score": 49.02358521719164}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Wait for the episode to connect.\n  auto timeout = _client.GetTimeout();\n  auto start = std::chrono::steady_clock::now();\n  auto end = start + timeout;\n  auto episode_id = GetCurrentEpisode().GetId();\n  while (episode_id == _episode->GetId()) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    if (std::chrono::steady_clock::now() > end) {\n      throw_exception(std::runtime_error(\"Failed to connect to episode.\"));\n    }\n  }\n\n  return GetCurrentEpisode();\n}", "CodeBleu_score": 50.489747530462026}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  EpisodeProxy episode;\n\n  // Load the new episode\n  _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Attempt to connect to the new episode within a certain timeout period\n  for (int i = 0; i < _client.GetTimeout().milliseconds(); i++) {\n    // Check if the episode ID has changed\n    if (GetCurrentEpisode().GetId() != episode.GetId()) {\n      // If the episode ID has changed, break out of the loop\n      break;\n    }\n    // Wait for a short period of time before checking again\n    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n  }\n\n  // Check if the episode ID has changed\n  if (GetCurrentEpisode().GetId() != episode.GetId()) {\n    // If the episode ID has not changed, throw a runtime exception\n    throw std::runtime_error(\"Failed to connect to new episode within timeout period\");\n  }\n\n  // Return the episode object\n  return episode;\n}", "CodeBleu_score": 46.20121644556464}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    // Get the walker associated with the controller.\n    Walker *walker = _episode->GetWalker(controller.GetId());\n    // Throw an exception if the walker is not found.\n    if (!walker) {\n        throw std::runtime_error(\"Walker not found\");\n    }\n    // Assert that the episode is not null.\n    DEBUG_ASSERT(_episode);\n    // Create navigation if it is missing.\n    Navigation *nav = _episode->CreateNavigationIfMissing();\n    // Register the walker with the controller's ID.\n    nav->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 50.94227454313541}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  Walker *walker = _episode->GetWalker(controller.GetId());\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n  DEBUG_ASSERT(_episode != nullptr, \"Episode is null\");\n  if (!_episode->CreateNavigationIfMissing()) {\n    throw std::runtime_error(\"Failed to create navigation\");\n  }\n  Navigation *nav = _episode->GetNavigation();\n  nav->RegisterWalker(walker);\n}", "CodeBleu_score": 54.59785125626079}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    Walker *walker = _episode->GetWalker(controller.GetId());\n    if (walker == nullptr) {\n        throw std::runtime_error(\"Walker not found\");\n    }\n    DEBUG_ASSERT(walker != nullptr);\n    Navigation *nav = _episode->CreateNavigationIfMissing(walker);\n    nav->RegisterWalker(controller.GetId());\n}", "CodeBleu_score": 59.62859237046864}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  // Get the current episode\n  auto episode = GetCurrentEpisode();\n  // Make an actor description\n  auto actor_desc = blueprint.MakeActorDescription();\n  // Set the actor's transform\n  actor_desc->SetTransform(transform);\n  // Set the parent actor, attachment type, and socket name\n  actor_desc->SetParent(parent);\n  actor_desc->SetAttachmentType(attachment_type);\n  actor_desc->SetSocketName(socket_name);\n  // Register the actor in the current episode\n  episode->RegisterActor(actor_desc);\n  // Apply the garbage collection policy\n  episode->ApplyGarbageCollectionPolicy(gc);\n  // Log the creation details\n  log_debug(\"Spawned actor {}\", actor_desc->GetId());\n  // Return the new actor\n  return actor_desc->GetActor();\n}", "CodeBleu_score": 38.322484823413646}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  auto result = _client.SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n  auto actor = result->GetActor();\n  if (actor) {\n    _episode->RegisterActor(actor);\n  }\n  if (gc == GarbageCollectionPolicy::Always) {\n    _episode->AddToGarbageCollection(actor);\n  }\n  log_debug(\"Spawned actor {}\", actor->GetId());\n  return actor;\n}", "CodeBleu_score": 39.02871394642304}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  auto result = _client.SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n  auto actor = result->GetActor();\n  _episode->RegisterActor(actor);\n  actor->SetGarbageCollectionPolicy(gc);\n  log_debug(\"Spawned actor {} ({})\", actor->GetName(), actor->GetId());\n  return actor;\n}", "CodeBleu_score": 34.575404230391634}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  // Check that the episode is valid\n  if (!ep.IsValid()) {\n    throw std::runtime_error(\"Episode is not valid\");\n  }\n\n  // Subscribe to the sensor's data stream\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [this, sensor, callback](const msr::airlib::VehicleCameraBase::ImageResponse\n                                   &response) {\n        // Deserialize the incoming data\n        auto data = sensor::Deserializer::Deserialize(response.image_data);\n\n        // Associate the data with the current episode\n        data->episode_id = ep.GetEpisodeId();\n\n        // Invoke the callback with the sensor data\n        callback(data);\n      });\n}", "CodeBleu_score": 48.63426055820186}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  // Ensure the episode is valid\n  if (ep.expired()) {\n    throw std::runtime_error(\"Episode is invalid\");\n  }\n\n  // Subscribe to the sensor's data stream\n  _client->SubscribeToStream(sensor.GetActorDescription().GetStreamToken(),\n                             [this, callback](const msgs::BytesValue &msg) {\n                               // Deserialize the incoming data\n                               auto data = sensor::Deserialize(msg);\n\n                               // Associate the data with the current episode\n                               data->SetEpisode(ep.lock());\n\n                               // Invoke the callback with the sensor data\n                               callback(data);\n                             });\n}", "CodeBleu_score": 47.03344706983916}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(ep.IsValid());\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [this, sensor, callback](const msr::airlib::VectorString& data) {\n        // deserialize the data\n        auto sensor_data = sensor::Deserializer::Deserialize(data);\n        // associate the sensor data with the current episode\n        sensor_data->episode = ep.GetEpisode();\n        // invoke the callback with the sensor data\n        callback(sensor_data);\n      });\n}", "CodeBleu_score": 48.721961114587195}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    auto walkers = _nav.GetWalkers();\n    if (walkers->empty())\n        return;\n\n    auto state = episode->GetState();\n    RemoveWalkers(state);\n\n    UpdateVehiclesInCrowd(state);\n    _nav.UpdateCrowd();\n\n    std::vector<WalkerCommand> commands;\n    commands.reserve(walkers->size());\n    for (auto& walker : *walkers) {\n        auto transform = _nav.GetWalkerTransform(walker);\n        auto speed = _nav.GetWalkerSpeed(walker);\n        commands.emplace_back(transform, speed);\n    }\n    _simulator.lock()->ApplyBatchSync(commands);\n\n    for (auto& walker : *walkers) {\n        if (!_nav.IsWalkerAlive(walker)) {\n            _nav.RemoveAgent(walker);\n            UnregisterWalker(walker);\n            if (_nav.IsWalkerDead(walker))\n                _simulator.lock()->DestroyActor(walker);\n        }\n    }\n}", "CodeBleu_score": 44.79356752590694}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    // Load the current walkers\n    std::vector<std::shared_ptr<Walker>> walkers = _nav.Load();\n    // Check if the list is empty\n    if (walkers.empty()) {\n        return;\n    }\n    // Get the current state of the episode\n    const State& state = episode->GetState();\n    // Remove any walkers that no longer exist\n    RemoveWalkers(walkers, state);\n    // Update the vehicles in the crowd\n    UpdateVehiclesInCrowd(walkers, state);\n    // Update the crowd itself in the navigation module\n    _nav.UpdateCrowd();\n    // Apply the states of the walkers in a batch to the simulator\n    ApplyWalkerStates(walkers, state);\n    // Check if any walker has been killed\n    CheckIfWalkerExist(walkers, state);\n}", "CodeBleu_score": 21.462456627547166}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    // Load the walkers from the episode\n    auto walkers = _walkers.Load(episode);\n    if (walkers->empty()) {\n        // If the list is empty, return\n        return;\n    }\n\n    // Get the current state of the episode\n    auto state = episode->GetState();\n\n    // Remove any walkers that no longer exist\n    for (auto it = walkers->begin(); it != walkers->end();) {\n        if (!state->Exist(it->first)) {\n            it = walkers->erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    // Update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, walkers);\n\n    // Update the crowd itself in the navigation module\n    _nav.UpdateCrowd();\n\n    // Apply the current states of the walkers to the simulator\n    std::vector<Command> commands;\n    commands.reserve(walkers->size());\n    for (auto& pair : *walkers) {\n        auto walker = pair.second;\n        auto transform = walker->GetTransform();\n        auto speed = _nav.GetWalkerSpeed(walker);\n        commands.emplace_back(transform, speed);\n    }\n    _simulator.lock()->ApplyBatchSync(commands);\n\n    // Check if any walker has been killed\n    for (auto& pair : *walkers) {\n        auto walker = pair.second;\n        if (_nav.IsWalkerAlive(walker) == false) {\n            // If the walker is dead, remove them from the crowd and destroy their controller\n            _nav.RemoveAgent(walker);\n            UnregisterWalker(walker);\n            _simulator.lock()->DestroyActor(walker);\n        }\n    }\n}", "CodeBleu_score": 53.024398580897994}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.set_uid(uid);\n    description.set_id(id);\n    description.attributes.reserve(_attributes.size());\n    for (auto& attribute : _attributes) {\n        *description.attributes.add_attributes() = attribute;\n    }\n    return description;\n}", "CodeBleu_score": 64.97658144486408}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.set_uid(uid);\n  description.set_id(id);\n  description.attributes.reserve(_attributes.size());\n  for (const auto& attribute : _attributes) {\n    description.attributes.push_back(attribute.MakeActorAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 67.01969745245239}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.set_uid(uid);\n  description.set_id(id);\n  description.attributes.reserve(_attributes.size());\n  for (const auto& attribute : _attributes) {\n    description.attributes.push_back(attribute.MakeAttributeDescription());\n  }\n  return description;\n}", "CodeBleu_score": 66.61310500226058}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n  for (const auto& pair : blueprints) {\n    const SharedPtr<Blueprint>& blueprint = pair.second;\n    if (blueprint->ContainsAttribute(name)) {\n      const std::string& blueprint_value = blueprint->GetValue(name);\n      if (blueprint_value == value) {\n        result->AddBlueprint(pair.first, blueprint);\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 40.94612106169833}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto& pair : blueprints_) {\n    if (pair.second.ContainsAttribute(name)) {\n      const Attribute& attribute = pair.second.GetAttribute(name);\n      if (attribute.GetValue() == value || attribute.GetRecommendedValues().contains(value)) {\n        result->AddBlueprint(pair.second);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 42.49813377962486}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto &pair : blueprints_) {\n    if (pair.second.ContainsAttribute(name)) {\n      if (pair.second.GetAttribute(name) == value) {\n        result->AddBlueprint(pair.first, pair.second);\n      } else if (pair.second.GetRecommendedValues().contains(value)) {\n        result->AddBlueprint(pair.first, pair.second);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 40.73534102989036}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string fullPath = path + \"/\" + version;\n  if (!FileSystem::ValidateFilePath(fullPath)) {\n    return false;\n  }\n  std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n  if (!file.is_open()) {\n    return false;\n  }\n  file.write(reinterpret_cast<const char*>(&content[0]), content.size());\n  file.close();\n  return true;\n}", "CodeBleu_score": 47.47695283123633}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string filePath = path + \"/\" + std::to_string(version) + \".bin\";\n  if (!FileSystem::ValidateFilePath(filePath)) {\n    return false;\n  }\n  std::ofstream out(filePath, std::ios::binary | std::ios::trunc);\n  if (out.good()) {\n    out.write(reinterpret_cast<const char*>(&content[0]), content.size());\n    out.close();\n    return true;\n  }\n  out.close();\n  return false;\n}", "CodeBleu_score": 50.47993946209033}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  // Construct the full file path using the base folder and version information\n  std::string file_path = path + \"\\\\\" + std::to_string(version) + \".bin\";\n\n  // Validate the file path\n  if (!carla::FileSystem::ValidateFilePath(file_path)) {\n    return false;\n  }\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(file_path, std::ios::binary | std::ios::trunc);\n  if (!file.is_open()) {\n    return false;\n  }\n\n  // Write the content to the file\n  file.write(reinterpret_cast<const char*>(content.data()), content.size());\n\n  // Close the file\n  file.close();\n\n  return true;\n}", "CodeBleu_score": 48.43649527375046}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  geom::Location location = transform.location + parent_->bounds().location;\n  geom::Rotation rotation = transform.rotation * parent_->bounds().rotation;\n  const geom::Extents &extents = parent_->bounds().extents;\n  geom::Location p0 = location + rotation.RotateVector(extents.center());\n  geom::Location p1 = location + rotation.RotateVector(\n      extents.center() + geom::Location(extents.x(), 0, 0));\n  geom::Location p2 = location + rotation.RotateVector(\n      extents.center() + geom::Location(extents.x(), extents.y(), 0));\n  geom::Location p3 = location + rotation.RotateVector(\n      extents.center() + geom::Location(0, extents.y(), 0));\n  return std::make_shared<const Bounds>(frame, p0, p1, p2, p3);\n}", "CodeBleu_score": 42.06162783775718}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto &extents = parent_bounding_box_.extents;\n  const auto &location = parent_bounding_box_.location;\n  const auto &yaw = transform.rotation.GetYaw();\n\n  const auto &x_axis = transform.GetXAxis();\n  const auto &y_axis = transform.GetYAxis();\n  const auto &z_axis = transform.GetZAxis();\n\n  const auto &x_extent = extents.x * x_axis;\n  const auto &y_extent = extents.y * y_axis;\n  const auto &z_extent = extents.z * z_axis;\n\n  const auto &corner_a = location + x_extent + y_extent + z_extent;\n  const auto &corner_b = location + x_extent + y_extent - z_extent;\n  const auto &corner_c = location + x_extent - y_extent + z_extent;\n  const auto &corner_d = location + x_extent - y_extent - z_extent;\n\n  const auto &corner_e = location - x_extent + y_extent + z_extent;\n  const auto &corner_f = location - x_extent + y_extent - z_extent;\n  const auto &corner_g = location - x_extent - y_extent + z_extent;\n  const auto &corner_h = location - x_extent - y_extent - z_extent;\n\n  const auto &rotation = Rotate(yaw);\n\n  auto corners = std::make_shared<Bounds::Corners>();\n  corners->push_back(rotation * corner_a + transform.location);\n  corners->push_back(rotation * corner_b + transform.location);\n  corners->push_back(rotation * corner_c + transform.location);\n  corners->push_back(rotation * corner_d + transform.location);\n  corners->push_back(rotation * corner_e + transform.location);\n  corners->push", "CodeBleu_score": 32.91522809614439}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  // Compute the center of the bounding box in the world frame.\n  const geom::Location center = transform.location + parent_bounds_.location;\n\n  // Compute the extents of the bounding box in the world frame.\n  const geom::Vector3<double> extents =\n      transform.rotation * parent_bounds_.extents;\n\n  // Compute the four corners of the bounding box in the world frame.\n  const std::vector<geom::Location> corners = {\n      center + extents,\n      center + geom::Vector3<double>{-extents.x(), extents.y(), extents.z()},\n      center + geom::Vector3<double>{-extents.x(), -extents.y(), extents.z()},\n      center + geom::Vector3<double>{extents.x(), -extents.y(), extents.z()},\n      center + geom::Vector3<double>{extents.x(), extents.y(), extents.z()},\n      center + geom::Vector3<double>{extents.x(), extents.y(), -extents.z()},\n      center + geom::Vector3<double>{extents.x(), -extents.y(), -extents.z()},\n      center + geom::Vector3<double>{-extents.x(), -extents.y(), -extents.z()},\n  };\n\n  // Return a shared pointer to a Bounds object containing the frame number and\n  // the calculated corners.\n  return std::make_shared<Bounds>(frame, corners);\n}", "CodeBleu_score": 36.88618128027482}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  LightState state;\n  if (_episode.Lock()->QueryLightsStateToServer(state)) {\n    for (const auto& light : state.lights()) {\n      if (_lights.find(light.id()) == _lights.end()) {\n        _lights.emplace(light.id(), std::make_shared<Light>(light.id(), light.color()));\n      } else {\n        _lights[light.id()]->SetColor(light.color());\n      }\n    }\n  }\n}", "CodeBleu_score": 35.67878514242504}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> guard(_mutex);\n  std::vector<LightState> lightStates;\n  _episode.Lock()->QueryLightsStateToServer(lightStates);\n  for (auto lightState : lightStates) {\n    auto light = _lights.find(lightState.GetLightId());\n    if (light == _lights.end()) {\n      _lights[lightState.GetLightId()] = std::make_shared<Light>(lightState);\n    } else {\n      light->second->SetState(lightState);\n    }\n  }\n}", "CodeBleu_score": 38.78275368719004}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  // Lock the mutex to ensure thread safety\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Get the current state of lights from the server\n  std::vector<LightState> light_states = _episode.Lock()->QueryLightsStateToServer();\n\n  // Update the local light states and create new light objects if they do not already exist in the _lights map\n  for (const auto& light_state : light_states) {\n    // Find the light object in the _lights map\n    auto it = _lights.find(light_state.GetLightGroup());\n    if (it != _lights.end()) {\n      // Update the light object with the new state\n      it->second->Update(light_state);\n    } else {\n      // Create a new light object and add it to the _lights map\n      _lights[light_state.GetLightGroup()] = std::make_unique<Light>(light_state);\n    }\n  }\n}", "CodeBleu_score": 41.35459032132099}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(_episode.Lock());\n    if (_lights_changes.empty()) return;\n    std::vector<rpc::Color> message;\n    for (const auto& light : _lights) {\n        message.push_back(light.second.GetLocation());\n    }\n    _episode.UpdateServerLightsState(message);\n    _lights_changes.clear();\n    _dirty = false;\n}", "CodeBleu_score": 35.39658963218486}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n\n    if (!_dirty) {\n        return;\n    }\n\n    std::vector<uint8_t> message;\n    for (auto it = _lights.begin(); it != _lights.end(); ++it) {\n        message.push_back(it->second.GetID());\n        message.push_back(it->second.GetState());\n    }\n\n    _episode.Lock()->UpdateServerLightsState(message);\n\n    _lights_changes.clear();\n    _dirty = false;\n}", "CodeBleu_score": 39.27027723015886}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    if (_lights_changes.empty()) {\n        return;\n    }\n\n    std::vector<rpc::LightState> message;\n    for (auto it = _lights_changes.begin(); it != _lights_changes.end(); ++it) {\n        message.push_back(it->second);\n    }\n\n    _lights_changes.clear();\n    _dirty = false;\n\n    _episode.Lock()->UpdateServerLightsState(message, discard_client);\n}", "CodeBleu_score": 40.1679252158089}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t    if (GetId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID does not match\");\n        return;\n    }\n    GetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 52.29101606807956}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    if (GetSensorId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID does not match\");\n        return;\n    }\n    GetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 51.95923886980419}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    if (GetSensorId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID is not 'sensor.other.v2x_custom'\");\n        return;\n    }\n\n    GetEpisode().Lock()->Send(GetSensorContext(), message);\n}", "CodeBleu_score": 55.209073069078826}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        tm.RegisterVehicles(tm_port, 1, &this);\n    } else {\n        tm.UnregisterVehicles(tm_port, 1, &this);\n    }\n}", "CodeBleu_score": 49.5267694888642}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        tm.RegisterVehicles(tm_port, this);\n    } else {\n        tm.UnregisterVehicles(tm_port, this);\n    }\n}", "CodeBleu_score": 49.467119726895405}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        tm.RegisterVehicles(tm_port, this);\n    } else {\n        tm.UnregisterVehicles(tm_port, this);\n    }\n}", "CodeBleu_score": 49.467119726895405}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\twalker = GetEpisode().Lock()->GetActor<Walker>(walker_id);\n\twalker->SetLocation(walker->GetLocation() + walker->GetUp() * 0.5f);\n\tGetEpisode().Lock()->GetNavigation()->Add(walker);\n\twalker->SetActorCollisions(false);\n\twalker->SetActorSimulatePhysics(false);\n}", "CodeBleu_score": 36.2157243924188}, {"code": "void WalkerAIController::Start(){\n\t  // Retrieve the walker actor\n  auto walker = GetActor();\n\n  // Register the AI controller with the episode\n  GetEpisode().Lock()->RegisterAIController(this);\n\n  // Add the walker actor to the navigation system with its current location\n  GetEpisode().Lock()->GetNavigation()->AddWalker(walker, walker->GetLocation());\n\n  // Disable the physics simulation and collisions for the walker actor\n  walker->SetActorSimulatePhysics(false);\n  walker->SetActorCollisions(false);\n}", "CodeBleu_score": 39.71533910939302}, {"code": "void WalkerAIController::Start(){\n\t\tauto walker = GetPawn<Walker>();\n\tif (!walker) {\n\t\treturn;\n\t}\n\n\tauto episode = GetEpisode();\n\tif (!episode) {\n\t\treturn;\n\t}\n\n\tauto navigation = episode->GetNavigation();\n\tif (!navigation) {\n\t\treturn;\n\t}\n\n\tnavigation->AddActor(walker, walker->GetLocation());\n\twalker->SetActorCollisions(false);\n\twalker->SetActorSimulatePhysics(false);\n}", "CodeBleu_score": 43.87971343113307}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (!episode_) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: WalkerAIController not \"\n                \"initialized.\");\n    return;\n  }\n\n  auto* walker = GetWalker();\n  if (!walker) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: Walker not found.\");\n    return;\n  }\n\n  auto* nav = walker->GetEpisode().Lock()->GetNavigation();\n  if (!nav) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: Navigation not found.\");\n    return;\n  }\n\n  if (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: Failed to set max speed.\");\n  }\n}", "CodeBleu_score": 50.37136826327553}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (!m_episode) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: No episode set.\");\n    return;\n  }\n\n  Walker* walker = GetWalker();\n  if (!walker) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: No walker found.\");\n    return;\n  }\n\n  Navigation* nav = m_episode->GetNavigation();\n  if (!nav) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: No navigation found.\");\n    return;\n  }\n\n  if (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: Failed to set walker max speed.\");\n  }\n}", "CodeBleu_score": 45.83517734138193}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto nav = GetEpisode().Lock()->GetNavigation();\n  if (!nav) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: No navigation in episode\");\n    return;\n  }\n  auto walker = GetParent().Lock();\n  if (!walker) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: No walker\");\n    return;\n  }\n  if (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: Failed to set max speed\");\n  }\n}", "CodeBleu_score": 61.44985293337748}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (const auto& waypoint : waypoints) {\n        result.emplace_back(std::make_shared<Waypoint>(waypoint, _parent->GetMap().GetPrevious(waypoint, distance)));\n    }\n    return result;\n}", "CodeBleu_score": 64.65727219739637}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto& waypoint : waypoints) {\n    result.emplace_back(std::make_shared<Waypoint>(_parent->GetMap().GetPrevious(waypoint, distance)));\n  }\n  return result;\n}", "CodeBleu_score": 61.915552685344565}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto& waypoint : waypoints) {\n    result.emplace_back(std::make_shared<Waypoint>(\n        _parent->GetMap().GetPrevious(waypoint, distance)));\n  }\n  return result;\n}", "CodeBleu_score": 62.28534899125611}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::set<SharedPtr<Signal>> added_signals;\n\n  // Get all signals within the specified distance\n  std::vector<SharedPtr<Signal>> signals_in_distance =\n      GetSignalsInDistance(distance, stop_at_junction);\n\n  // Check for repeated signals and add them to the result\n  for (const auto& signal : signals_in_distance) {\n    if (added_signals.count(signal) == 0) {\n      // Create a new waypoint and landmark for the signal\n      SharedPtr<Waypoint> waypoint =\n          std::make_shared<Waypoint>(signal->GetPosition());\n      SharedPtr<Landmark> landmark =\n          std::make_shared<Landmark>(signal->GetPosition());\n      landmark->SetSignal(signal);\n      waypoint->AddLandmark(landmark);\n      result.push_back(landmark);\n      added_signals.insert(signal);\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 50.155303225962655}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::set<SharedPtr<Signal>> added_signals;\n\n  for (const auto& signal : GetSignalsInDistance(distance, stop_at_junction)) {\n    if (added_signals.count(signal) == 0) {\n      auto new_waypoint = std::make_shared<Waypoint>(signal->GetPosition());\n      auto new_landmark = std::make_shared<Landmark>(new_waypoint);\n      result.emplace_back(new_landmark);\n      added_signals.insert(signal);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 47.83078972424277}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::set<SharedPtr<Signal>> added_signals;\n  for (const auto& signal : signals) {\n    if (added_signals.count(signal) == 0) {\n      added_signals.insert(signal);\n      SharedPtr<Waypoint> waypoint = SharedPtr<Waypoint>(new Waypoint(signal->GetPosition()));\n      result.emplace_back(new Landmark(waypoint));\n    }\n  }\n  return result;\n}", "CodeBleu_score": 48.35440406194561}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  // Set a local timeout based on the provided timeout or the episode's networking timeout\n  time_duration curr_timeout = timeout.milliseconds() > 0 ? timeout : _episode.Lock()->GetNetworkingTimeout();\n\n  // Apply the provided episode settings to the world\n  uint64_t identifier = _episode.Lock()->ApplySettings(settings);\n\n  // If the settings include a fixed delta time, verify the accuracy of this setting over a series of ticks\n  if (settings.fixed_delta_seconds.has_value()) {\n    float delta_seconds = settings.fixed_delta_seconds.get();\n    float tolerance = std::numeric_limits<float>::epsilon();\n    float prev_delta_seconds = delta_seconds;\n    float total_delta_seconds = 0.0f;\n    int num_attempts = 0;\n    while (std::abs(delta_seconds - prev_delta_seconds) > tolerance) {\n      prev_delta_seconds = delta_seconds;\n      total_delta_seconds += delta_seconds;\n      if (total_delta_seconds > curr_timeout.seconds()) {\n        log_warning(\"Fixed delta time setting was not applied correctly after {} attempts\", num_attempts);\n        break;\n      }\n      Tick();\n      delta_seconds = _episode.Lock()->GetSettings().fixed_delta_seconds.get();\n      ++num_attempts;\n    }\n  }\n\n  // Return the identifier of the applied settings\n  return identifier;\n}", "CodeBleu_score": 52.468435944689816}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  uint64_t identifier = _settings_identifier++;\n\n  // Set a local timeout based on the provided timeout or the episode's networking timeout\n  time_duration local_timeout = timeout.milliseconds() > 0 ? timeout : _episode.Lock()->GetNetworkingTimeout();\n\n  // If the settings include a fixed delta time, verify the accuracy of this setting over a series of ticks\n  if (settings.fixed_delta_seconds.has_value()) {\n    float fixed_delta_seconds = settings.fixed_delta_seconds.get();\n    float epsilon = std::numeric_limits<float>::epsilon();\n    float delta_seconds = 0.0f;\n    for (int i = 0; i < 100; i++) {\n      // Get the current snapshot\n      auto curr_snapshot = GetSnapshot();\n      time_duration curr_timestamp = curr_snapshot.GetTimestamp();\n\n      // Calculate the elapsed time\n      delta_seconds = (curr_timestamp - _last_timestamp).seconds();\n\n      // Check if the elapsed time is within the acceptable range\n      if (abs(delta_seconds - fixed_delta_seconds) < epsilon) {\n        break;\n      }\n\n      // Wait for the next tick\n      curr_snapshot.WaitNextTick(local_timeout);\n    }\n\n    // If the setting is not correctly applied after a number of attempts, log a warning\n    if (abs(delta_seconds - fixed_delta_seconds) > epsilon) {\n      log_warning(\"Failed to set fixed delta time to {} seconds\", fixed_delta_seconds);\n    }\n  }\n\n  // Apply the new settings\n  _episode.Lock()->SetEpisodeSettings(settings);\n\n  // Return the identifier of the applied settings\n  return identifier;\n}", "CodeBleu_score": 59.61895206441401}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  auto curr_snapshot = GetSnapshot();\n  auto curr_settings = curr_snapshot.GetSettings();\n  if (settings.fixed_delta_seconds.has_value()) {\n    auto new_settings = curr_settings;\n    new_settings.fixed_delta_seconds = settings.fixed_delta_seconds;\n    auto identifier = ApplySettings(new_settings, timeout);\n    if (identifier == curr_settings.identifier) {\n      // We've successfully applied the new settings.\n      return identifier;\n    }\n    // We've failed to apply the new settings.\n    // We'll try to revert to the old settings.\n    auto old_settings = curr_settings;\n    old_settings.fixed_delta_seconds = std::nullopt;\n    auto old_identifier = ApplySettings(old_settings, timeout);\n    if (old_identifier != curr_settings.identifier) {\n      // We've successfully reverted to the old settings.\n      return old_identifier;\n    }\n    // We've failed to revert to the old settings.\n    // We'll log a warning and return the old settings.\n    log_warning(\"Failed to revert to old settings after applying new settings.\");\n    return old_identifier;\n  }\n  // We'll try to apply the new settings.\n  auto new_settings = curr_settings;\n  new_settings.fixed_delta_seconds = std::nullopt;\n  auto identifier = ApplySettings(new_settings, timeout);\n  if (identifier != curr_settings.identifier) {\n    // We've successfully applied the new settings.\n    return identifier;\n  }\n  // We've failed to apply the new settings.\n  // We'll log a warning and return the old settings.\n  log_warning(\"Failed to apply new settings.\");\n  return curr_settings.identifier;\n}", "CodeBleu_score": 46.39379663555473}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  float const lengthSquared = DistanceSquared2D(segment.first, segment.second);\n  if (lengthSquared == 0.0f) {\n    return std::make_pair(0.0f, Distance2D(point, segment.first));\n  }\n  float const length = std::sqrt(lengthSquared);\n  float const t = Clamp(Dot2D(point, segment.second - segment.first) / lengthSquared, 0.0f, 1.0f);\n  return std::make_pair(t * length, Distance2D(point, segment.first + t * (segment.second - segment.first)));\n}", "CodeBleu_score": 42.302460515882714}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat const& x1, float const& y1, float const& x2, float const& y2, float const& x, float const& y\n}", "CodeBleu_score": 15.166670570652746}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    float dx = segment.second.x - segment.first.x;\n    float dy = segment.second.y - segment.first.y;\n    float lengthSquared = dx * dx + dy * dy;\n    if (lengthSquared == 0.0f) {\n        return std::make_pair(0.0f, Distance2D(segment.first, point));\n    }\n    float t = Clamp((point.x - segment.first.x) * dx + (point.y - segment.first.y) * dy, 0.0f, lengthSquared) / lengthSquared;\n    float x = segment.first.x + t * dx;\n    float y = segment.first.y + t * dy;\n    return std::make_pair(t, Distance2D(point, { x, y }));\n}", "CodeBleu_score": 43.59877175607488}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t     DEBUG_ASSERT(vertices.size() >= 3);\n     AddVertices(vertices);\n     for (size_t i = 2; i < vertices.size(); i++) {\n         AddIndex(vertices[0].index);\n         AddIndex(vertices[i - 1].index);\n         AddIndex(vertices[i].index);\n     }\n }", "CodeBleu_score": 46.358059728942806}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    DEBUG_ASSERT(vertices.size() >= 3);\n\n    AddVertices(vertices);\n\n    unsigned int initialIndex = GetVerticesNum() - vertices.size();\n    for (unsigned int i = 0; i < vertices.size() - 2; i++) {\n        AddIndex(initialIndex);\n        AddIndex(initialIndex + i + 1);\n        AddIndex(initialIndex + i + 2);\n    }\n}", "CodeBleu_score": 52.88881653921235}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t     DEBUG_ASSERT(vertices.size() >= 3);\n     AddVertices(vertices);\n     for (size_t i = 2; i < vertices.size(); i++) {\n         AddIndex(vertices[0].index);\n         AddIndex(vertices[i - 1].index);\n         AddIndex(vertices[i].index);\n     }\n }", "CodeBleu_score": 46.358059728942806}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message->empty()) {\n    log_error(\"Empty message received\");\n    return;\n  }\n  boost::asio::post(\n      self->_strand,\n      [self, message]() {\n        if (self->_socket.is_open()) {\n          self->_deadline.expires_from_now(boost::posix_time::seconds(30));\n          boost::asio::async_write(\n              self->_socket,\n              message->GetBufferSequence(),\n              boost::asio::bind_executor(\n                  self->_strand,\n                  [self, message](const boost::system::error_code &ec, std::size_t) {\n                    self->HandleSent(message, ec);\n                  }));\n        } else {\n          log_error(\"Socket is not open\");\n        }\n      });\n}", "CodeBleu_score": 39.2905453441071}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message->empty()) {\n    log_error(\"Can't send empty message\");\n    return;\n  }\n  auto self = shared_from_this();\n  boost::asio::post(self->_strand, [self, message]() {\n    if (!self->_socket.is_open()) {\n      log_error(\"Socket is not open\");\n      return;\n    }\n    self->_deadline.expires_from_now(boost::posix_time::seconds(30));\n    boost::asio::async_write(self->_socket, message->GetBufferSequence(),\n                             boost::asio::bind_executor(self->_strand, [self, message](const boost::system::error_code &ec, std::size_t) {\n                               self->HandleSent(message, ec);\n                             }));\n  });\n}", "CodeBleu_score": 41.363649609229455}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message->empty()) {\n    log_error(\"Cannot write empty message.\");\n    return;\n  }\n\n  boost::asio::post(\n      _strand,\n      [self = shared_from_this(), message]() {\n        if (self->_socket.is_open()) {\n          self->_deadline.expires_from_now(std::chrono::seconds(30));\n          boost::asio::async_write(\n              self->_socket,\n              message->GetBufferSequence(),\n              boost::asio::bind_executor(\n                  self->_strand,\n                  [self, message](const boost::system::error_code &ec, size_t) {\n                    self->handle_sent(ec, message);\n                  }));\n        } else {\n          log_error(\"Cannot write to closed socket.\");\n        }\n      });\n}", "CodeBleu_score": 40.10996586288441}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if (!ec) {\n    _deadline.cancel();\n\n    if (_socket.is_open()) {\n      boost::system::error_code ignored_ec;\n      _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n      _socket.close(ignored_ec);\n    }\n  }\n\n  _on_closed();\n  log_debug(\"Session closed\");\n}", "CodeBleu_score": 68.13635641733376}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  log_debug(\"Primary::CloseNow\");\n  _deadline.cancel();\n  if (!ec) {\n    if (_socket.is_open()) {\n      boost::system::error_code ignored_ec;\n      _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n      _socket.close(ignored_ec);\n    }\n    _on_closed();\n  }\n  log_debug(\"Primary::CloseNow done\");\n}", "CodeBleu_score": 65.72202889202512}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n\n  if (!ec) {\n    if (_socket.is_open()) {\n      boost::system::error_code ignored_ec;\n      _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n      _socket.close(ignored_ec);\n    }\n\n    _on_closed();\n    log_debug(\"session closed\");\n  }\n}", "CodeBleu_score": 73.39942304110596}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t    auto msg = \"Are you alive?\";\n    auto response = std::make_unique<Buffer>(msg, strlen(msg) + 1);\n    log_info(\"Sending message: \", msg);\n    _router->WriteToNext(std::move(response), YOU_ALIVE);\n    auto fut = _router->ReadFromNext();\n    log_info(\"Response: \", fut.get()->buffer.data);\n}", "CodeBleu_score": 52.580622669200984}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  std::string msg = \"Are you alive?\";\n  std::vector<uint8_t> buffer = std::vector<uint8_t>(msg.begin(), msg.end());\n  log_info(\"Sending: %s\", msg.c_str());\n  _router->WriteToNext(buffer, YOU_ALIVE);\n  auto fut = _router->ReadFromNext();\n  auto response = fut.get();\n  log_info(\"Response: %s\", response.buffer.data.c_str());\n}", "CodeBleu_score": 57.41686447576589}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  // Create a buffer from the message\n  auto msg = \"Are you alive?\";\n  auto buffer = Buffer::CreateBuffer(msg);\n\n  // Log the sending action\n  LOG_INFO(\"Sending message: \" << msg);\n\n  // Write the buffer to the next router with the command YOU_ALIVE\n  _router->WriteToNext(buffer, YOU_ALIVE);\n\n  // Wait for and log the response from the system\n  auto response = _router->ReadFromPrev();\n  LOG_INFO(\"Received message: \" << response.buffer.data);\n}", "CodeBleu_score": 49.179972097044626}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  std::string sensor_name = _sensor_names[sensor_id];\n  bool found = false;\n  for (auto &server : _servers) {\n    if (server.second->sensors.find(sensor_id) != server.second->sensors.end()) {\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n    log_error(\"Sensor %s not found on any server\", sensor_name.c_str());\n    return;\n  }\n  Buffer buffer;\n  buffer.WriteU8(static_cast<uint8_t>(Command::ENABLE_ROS));\n  buffer.WriteU32(sensor_id);\n  Response response = _router->WriteToOne(buffer);\n  if (response.status == Response::Status::ERROR) {\n    log_error(\"Error sending ENABLE_ROS command to server: %s\", response.message.c_str());\n    return;\n  }\n  if (response.buffer.ReadU8() != static_cast<uint8_t>(Command::ENABLE_ROS)) {\n    log_error(\"Unexpected response to ENABLE_ROS command: %s\", response.message.c_str());\n    return;\n  }\n  if (response.buffer.ReadU8() != 0) {\n    log_error(\"Error enabling ROS for sensor %s: %s\", sensor_name.c_str(), response.message.c_str());\n    return;\n  }\n  log_info(\"Enabled ROS for sensor %s\", sensor_name.c_str());\n}", "CodeBleu_score": 45.74582703721952}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    auto fut = _router->WriteToOne(sensor_id, Commands::ENABLE_ROS);\n\n    if (fut.get()) {\n        auto response = fut.get();\n        if (response.buffer.data.size() == 0) {\n            log_error(\"No server found for sensor %d\", sensor_id);\n        } else {\n            auto server_id = *reinterpret_cast<stream_id *>(response.buffer.data.data());\n            log_debug(\"Sensor %d enabled on server %d\", sensor_id, server_id);\n        }\n    }\n}", "CodeBleu_score": 47.21603434464389}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  bool found = false;\n  for (auto &it : _servers) {\n    if (it.second->IsSensorEnabled(sensor_id)) {\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n    log_error(\"Sensor %d not found on any secondary server\", sensor_id);\n    return;\n  }\n  auto buffer = CreateEnableForROSBuffer(sensor_id);\n  for (auto &it : _servers) {\n    it.second->Send(buffer);\n  }\n  for (auto &it : _servers) {\n    auto fut = it.second->Receive();\n    auto response = fut.get();\n    if (response.buffer.data[0] != ENABLE_ROS) {\n      log_error(\"Unexpected response: %d\", response.buffer.data[0]);\n      return;\n    }\n    if (response.buffer.data[1] != 0) {\n      log_error(\"Error enabling sensor %d on server %d: %d\", sensor_id, it.first, response.buffer.data[1]);\n      return;\n    }\n  }\n}", "CodeBleu_score": 49.12015938483763}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t    auto it = _tokens.find(sensor_id);\n    if (it != _tokens.end()) {\n        log_debug(\"GetToken: %d, %d\", sensor_id, it->second.get_port());\n        return it->second;\n    }\n    else {\n        // Enable the sensor on a secondary server\n        int port = _router->GetNextServer();\n        if (port < 0) {\n            log_error(\"GetToken: No secondary servers available\");\n            return token_type(-1, -1);\n        }\n        SendGetToken(port, sensor_id);\n        token_type token = _token_queue.pop();\n        _tokens[sensor_id] = token;\n        log_debug(\"GetToken: %d, %d\", sensor_id, token.get_port());\n        return token;\n    }\n}", "CodeBleu_score": 63.61882002795498}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t    if (_tokens.find(sensor_id) != _tokens.end()) {\n        log_debug(\"GetToken: sensor %d already activated\", sensor_id);\n        return _tokens[sensor_id];\n    }\n    log_debug(\"GetToken: sensor %d not activated, enabling\", sensor_id);\n    stream_id stream_id = _router->GetNextServer(sensor_id);\n    token_type token = SendGetToken(stream_id);\n    _tokens[sensor_id] = token;\n    _ports[token.get_port()] = sensor_id;\n    _stream_ids[token.get_stream_id()] = sensor_id;\n    log_debug(\"GetToken: sensor %d enabled, new token %d:%d\", sensor_id, token.get_port(), token.get_stream_id());\n    return token;\n}", "CodeBleu_score": 50.19612164901774}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // check if sensor is already activated\n  if (_tokens.find(sensor_id) != _tokens.end()) {\n    log_debug(\"GetToken: sensor already activated, returning existing token\");\n    return _tokens[sensor_id];\n  }\n\n  // enable sensor on secondary server\n  server_type secondary_server = _router->GetNextServer();\n  log_debug(\"GetToken: enabling sensor on secondary server %d\", secondary_server);\n  secondary_server->EnableSensor(sensor_id);\n\n  // retrieve new token\n  token_type token = secondary_server->GetToken(sensor_id);\n\n  // update maps\n  _tokens[sensor_id] = token;\n  _tokens_by_port[token.get_port()] = token;\n  _tokens_by_stream_id[token.get_stream_id()] = token;\n\n  // log action\n  log_debug(\"GetToken: retrieved new token %s for sensor %d\", token.to_string().c_str(), sensor_id);\n\n  return token;\n}", "CodeBleu_score": 51.82449478819075}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  f.seekg(0, std::ios::end);\n  size_t size = f.tellg();\n  f.seekg(0, std::ios::beg);\n  std::vector<char> buffer(size);\n  f.read(buffer.data(), size);\n  f.close();\n  return Load(std::move(buffer));\n}", "CodeBleu_score": 63.88727165446897}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  f.seekg(0, std::ios::end);\n  size_t size = f.tellg();\n  f.seekg(0, std::ios::beg);\n  std::vector<char> data(size);\n  f.read(data.data(), size);\n  f.close();\n  return Load(std::move(data));\n}", "CodeBleu_score": 64.16875855038803}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f(filename, std::ios::binary);\n    if (!f.is_open()) {\n        return false;\n    }\n    f.seekg(0, std::ios::end);\n    std::streampos file_size = f.tellg();\n    f.seekg(0, std::ios::beg);\n    std::vector<char> buffer(file_size);\n    f.read(buffer.data(), file_size);\n    f.close();\n    return Load(std::move(buffer));\n}", "CodeBleu_score": 61.92952674414415}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    // Check if the system is ready\n    if (!_is_ready) {\n        return false;\n    }\n\n    // Assert the crowd object is not null\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // Search for the agent id in the walker and vehicle mappings\n    auto walker_it = _mapped_walkers_id.find(id);\n    auto vehicle_it = _mapped_vehicles_id.find(id);\n\n    // If the agent is a walker\n    if (walker_it != _mapped_walkers_id.end()) {\n        // Enter a critical section to safely remove the agent from the crowd\n        _critical_section.lock();\n        _crowd->removeAgent(walker_it->second);\n        _walker_manager.RemoveWalker(walker_it->second);\n        _mapped_walkers_id.erase(walker_it);\n        _critical_section.unlock();\n        return true;\n    }\n\n    // If the agent is a vehicle\n    if (vehicle_it != _mapped_vehicles_id.end()) {\n        // Enter a critical section to safely remove the agent from the crowd\n        _critical_section.lock();\n        _crowd->removeAgent(vehicle_it->second);\n        _mapped_vehicles_id.erase(vehicle_it);\n        _mapped_by_index.erase(vehicle_it->second);\n        _critical_section.unlock();\n        return true;\n    }\n\n    // If the agent is not found, return false\n    return false;\n}", "CodeBleu_score": 63.458265213974876}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  bool result = false;\n\n  if (_crowd) {\n    // find the agent in the walker and vehicle mappings\n    auto walker_it = _mapped_walkers_id.find(id);\n    auto vehicle_it = _mapped_vehicles_id.find(id);\n\n    // if found, remove the agent from the crowd\n    if (walker_it != _mapped_walkers_id.end()) {\n      _mapped_walkers_id.erase(walker_it);\n      _mapped_by_index.erase(walker_it->second);\n      _walker_manager.RemoveWalker(walker_it->second);\n      result = true;\n    } else if (vehicle_it != _mapped_vehicles_id.end()) {\n      _mapped_vehicles_id.erase(vehicle_it);\n      _mapped_by_index.erase(vehicle_it->second);\n      _vehicle_manager.RemoveVehicle(vehicle_it->second);\n      result = true;\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 51.419605346513904}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!_is_ready) {\n        return false;\n    }\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    auto it = _mapped_vehicles_id.find(id);\n    if (it != _mapped_vehicles_id.end()) {\n        _crowd->removeAgent(it->second);\n        _mapped_vehicles_id.erase(it);\n        _mapped_by_index.erase(it->second);\n        return true;\n    }\n\n    it = _mapped_walkers_id.find(id);\n    if (it != _mapped_walkers_id.end()) {\n        _walker_manager.RemoveWalker(it->second);\n        _mapped_walkers_id.erase(it);\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 75.79832490418626}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    std::set<int> current_vehicles;\n    for (auto &vehicle : vehicles) {\n        current_vehicles.insert(vehicle.id);\n    }\n\n    for (auto &vehicle : updated) {\n        if (current_vehicles.find(vehicle.id) == current_vehicles.end()) {\n            RemoveAgent(vehicle.id);\n        } else {\n            vehicle.updated = true;\n        }\n    }\n\n    for (auto &vehicle : vehicles) {\n        if (vehicle.updated) {\n            AddOrUpdateVehicle(vehicle);\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 59.10204028126209}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t  std::set<int> current_vehicles;\n  for (auto &vehicle : vehicles) {\n    current_vehicles.insert(vehicle.id);\n  }\n\n  for (auto &vehicle : vehicles) {\n    auto it = this->vehicles.find(vehicle.id);\n    if (it == this->vehicles.end()) {\n      this->vehicles.insert(std::make_pair(vehicle.id, vehicle));\n      this->updated.insert(vehicle.id);\n    } else {\n      it->second = vehicle;\n      this->updated.insert(vehicle.id);\n    }\n  }\n\n  for (auto &vehicle : this->vehicles) {\n    if (current_vehicles.find(vehicle.first) == current_vehicles.end()) {\n      this->updated.erase(vehicle.first);\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 52.28360257739322}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    std::set<int> ids;\n    for (auto v : vehicles) {\n        ids.insert(v.id);\n    }\n    for (auto v : mappedVehicles) {\n        if (ids.find(v.id) == ids.end()) {\n            v.updated = false;\n            updated.erase(v);\n        }\n    }\n    for (auto v : vehicles) {\n        auto it = mappedVehicles.find(v.id);\n        if (it != mappedVehicles.end()) {\n            it->updated = true;\n            it->position = v.position;\n            it->rotation = v.rotation;\n            it->velocity = v.velocity;\n            updated.insert(*it);\n        } else {\n            v.updated = true;\n            mappedVehicles.insert(v);\n            updated.insert(v);\n        }\n    }\n    return true;\n}", "CodeBleu_score": 50.45311339416306}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    // Search in the mapped walkers\n    auto walker = it->second;\n    auto squared_distance = distance * distance;\n    auto squared_direction = carla::geom::Math::SquaredDistance(walker->GetActor()->GetLocation(), direction);\n    if (squared_direction < squared_distance) {\n      return _crowd->HasVehicleNear(walker->GetActor()->GetLocation(), distance);\n    }\n  } else {\n    // Search in the mapped vehicles\n    it = _mapped_vehicles_id.find(id);\n    if (it != _mapped_vehicles_id.end()) {\n      // Search in the mapped vehicles\n      auto vehicle = it->second;\n      auto squared_distance = distance * distance;\n      auto squared_direction = carla::geom::Math::SquaredDistance(vehicle->GetActor()->GetLocation(), direction);\n      if (squared_direction < squared_distance) {\n        return _crowd->HasVehicleNear(vehicle->GetActor()->GetLocation(), distance);\n      }\n    }\n  }\n  return false;\n}", "CodeBleu_score": 58.41326189027433}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  bool result = false;\n  {\n    std::lock_guard<std::mutex> lock(_mapped_vehicles_mutex);\n    auto it = _mapped_vehicles_id.find(id);\n    if (it != _mapped_vehicles_id.end()) {\n      result = _crowd->hasVehicleNear(it->second, distance, direction);\n    }\n  }\n  {\n    std::lock_guard<std::mutex> lock(_mapped_walkers_mutex);\n    auto it = _mapped_walkers_id.find(id);\n    if (it != _mapped_walkers_id.end()) {\n      result = _crowd->hasVehicleNear(it->second, distance, direction);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 64.16850269356122}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    carla::geom::Location actor_location = it->second->GetLocation();\n    float squared_distance = carla::geom::Math::DistanceSquared(actor_location, _location);\n    if (squared_distance <= distance * distance) {\n      carla::geom::Location actor_direction = carla::geom::Math::Normalize(direction);\n      carla::geom::Location actor_to_location = carla::geom::Math::GetDirection(actor_location, _location);\n      carla::geom::Location actor_to_direction = carla::geom::Math::Normalize(actor_to_location);\n      float dot_product = carla::geom::Math::Dot(actor_direction, actor_to_direction);\n      if (dot_product > 0.0f) {\n        return _crowd->HasVehicleNear(actor_location, distance, direction);\n      }\n    }\n  }\n  return false;\n}", "CodeBleu_score": 50.67645081591399}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    RoutePoint *rp = info.GetCurrentRoutePoint();\n    WalkerEventVisitor visitor(info, delta);\n    return boost::variant2::visit(visitor, rp->event);\n}", "CodeBleu_score": 50.382570237564664}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  // Get the current route point for the walker\n  RoutePoint *point = info.GetCurrentRoutePoint();\n  if (point == nullptr) {\n    return EventResult::FAILURE;\n  }\n\n  // Create a WalkerEventVisitor with the current context\n  WalkerEventVisitor visitor(this, id, info, delta);\n\n  // Use boost::variant2::visit to process the event at the current route point\n  boost::variant2::visit(visitor, point->GetEvent());\n\n  // Return the result of the event execution\n  return visitor.GetResult();\n}", "CodeBleu_score": 52.72000609152606}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  RoutePoint *rp = info.GetRoutePoint();\n  if (rp == NULL) {\n    return EventResult::EVENT_RESULT_NO_EVENT;\n  }\n\n  WalkerEventVisitor visitor(info, delta);\n  return boost::variant2::visit(visitor, *rp);\n}", "CodeBleu_score": 45.38692250069566}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  pugi::xml_node open_drive_node = xml.child(\"OpenDRIVE\");\n  if (!open_drive_node) {\n    std::cerr << \"OpenDRIVE node not found in XML document.\" << std::endl;\n    return;\n  }\n\n  for (pugi::xml_node road_node : open_drive_node.children(\"road\")) {\n    auto road_id = road_node.attribute(\"id\").as_uint();\n    for (pugi::xml_node lane_section_node : road_node.children(\"lanes\")) {\n      auto lane_section_s = lane_section_node.attribute(\"s\").as_double();\n      auto lane_section = map_builder.CreateLaneSection(road_id, lane_section_s);\n      for (pugi::xml_node lanes_node : lane_section_node.children(\"lanes\")) {\n        for (pugi::xml_node lane_node : lanes_node.children(\"lane\")) {\n          auto lane_id = lane_node.attribute(\"id\").as_int();\n          auto lane = lane_section->CreateLane(lane_id);\n          ParseLanes(lane_node, lane);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 59.870079204767734}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (auto road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const auto road_id = road_node.attribute(\"id\").as_uint();\n    for (auto lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      auto left_lanes = lane_section_node.child(\"left\");\n      auto center_lanes = lane_section_node.child(\"center\");\n      auto right_lanes = lane_section_node.child(\"right\");\n      ParseLanes(left_lanes, road_id, map_builder);\n      ParseLanes(center_lanes, road_id, map_builder);\n      ParseLanes(right_lanes, road_id, map_builder);\n    }\n  }\n}", "CodeBleu_score": 46.288044152224835}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (auto road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    auto road_id = road_node.attribute(\"id\").as_uint();\n    for (auto lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      auto left_lanes = lane_section_node.child(\"left\");\n      auto center_lanes = lane_section_node.child(\"center\");\n      auto right_lanes = lane_section_node.child(\"right\");\n      auto lane_section = map_builder.GetLaneSection(road_id, lane_section_node.attribute(\"s\").as_double());\n      ParseLanes(left_lanes, lane_section.GetLeftLanes());\n      ParseLanes(center_lanes, lane_section.GetCenterLanes());\n      ParseLanes(right_lanes, lane_section.GetRightLanes());\n    }\n  }\n}", "CodeBleu_score": 47.56822755553698}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.total_count_change == 0) {\n        return;\n    }\n\n    if (info.total_count == 0) {\n        if (m_matched == MATCHED_STATUS::NOT_MATCHED) {\n            m_matched = MATCHED_STATUS::NEW_MATCH;\n        } else if (m_matched == MATCHED_STATUS::MATCHED) {\n            m_matched = MATCHED_STATUS::NOT_MATCHED;\n        } else {\n            log_error(\"CarlaListenerImpl\", \"on_publication_matched\", \"Unexpected matched state.\");\n        }\n    } else {\n        if (m_matched == MATCHED_STATUS::NOT_MATCHED) {\n            m_matched = MATCHED_STATUS::MATCHED;\n        } else if (m_matched == MATCHED_STATUS::MATCHED) {\n            m_matched = MATCHED_STATUS::MATCHED;\n        } else {\n            log_error(\"CarlaListenerImpl\", \"on_publication_matched\", \"Unexpected matched state.\");\n        }\n    }\n}", "CodeBleu_score": 36.16815526503555}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  std::unique_lock<std::mutex> lock(mutex_);\n  if (info.current_count_change == 1) {\n    matched_count_++;\n    if (matched_count_ == 1) {\n      first_connection_ = true;\n    }\n  } else if (info.current_count_change == -1) {\n    matched_count_--;\n  } else {\n    // No change in count.\n  }\n\n  if (matched_count_ < 0) {\n    matched_count_ = 0;\n  }\n\n  if (matched_count_ == 0) {\n    first_connection_ = false;\n  }\n}", "CodeBleu_score": 50.93832100446647}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.total_count_change == 1) {\n        matched_ = true;\n    } else if (info.total_count_change == -1) {\n        matched_ = false;\n    } else {\n        // No action needed.\n    }\n}", "CodeBleu_score": 40.47736831858124}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    // first_connected_ is set to true if the first subscription is matched.\n    if (!first_connected_) {\n      first_connected_ = true;\n      std::cout << \"Subscriber matched\" << std::endl;\n    }\n  } else if (info.current_count_change == -1) {\n    // If the last subscription is unmatched, destroy the subscriber.\n    if (info.total_count == 0) {\n      std::cout << \"Subscriber unmatched\" << std::endl;\n      _owner->DestroySubscriber();\n    }\n  } else {\n    std::cout << \"Invalid subscription change count: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 60.77435252842146}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        _matched = true;\n        _first_connected = true;\n    } else if (info.current_count_change == -1) {\n        _matched = false;\n        if (info.total_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::cerr << \"ERROR: Subscription change is out of bounds\" << std::endl;\n    }\n}", "CodeBleu_score": 63.417544675723846}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        if (info.total_count == 1) {\n            _first_connected = true;\n        }\n        _matched_count++;\n    } else if (info.current_count_change == -1) {\n        _matched_count--;\n        if (_matched_count == 0) {\n            if (_owner->_verbose) {\n                std::cout << \"Subscriber \" << _owner->_subscriber_name << \": Destroying subscriber\" << std::endl;\n            }\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::cerr << \"Subscriber \" << _owner->_subscriber_name << \": Invalid count change: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 62.6963360068136}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* myData = (CarlaCollisionEvent*) data;\n    if(force_md5 || DynamicType::getKeyMaxSerializedSizeInBytes < KEY_SERIALIZED_SIZE){\n        static unsigned char keyBuffer[KEY_SERIALIZED_SIZE];\n        static bool initialized = false;\n        if (!initialized) {\n            initialized = true;\n            UA_ByteSeq_init(&typeId);\n            typeId.length = UA_BYTESTRING_SIZE(sizeof(TypeId_t));\n            memcpy(typeId.buffer, &TypeId_CarlaCollisionEvent, sizeof(TypeId_t));\n        }\n        keyBuffer[0] = (unsigned char) myData->getObjectId();\n        keyBuffer[1] = (unsigned char) myData->getObjectId() >> 8;\n        keyBuffer[2] = (unsigned char) myData->getObjectId() >> 16;\n        keyBuffer[3] = (unsigned char) myData->getObjectId() >> 24;\n        keyBuffer[4] = (unsigned char) myData->getObjectId() >> 32;\n        keyBuffer[5] = (unsigned char) myData->getObjectId() >> 40;\n        keyBuffer[6] = (unsigned char) myData->getObjectId() >> 48;\n        keyBuffer[7] = (unsigned char) myData->getObjectId() >> 56;\n        keyBuffer[8] = (unsigned char) myData->getObjectId2();\n        keyBuffer[9] = (unsigned char) myData->getObjectId2() >> 8;\n        keyBuffer[10] = (unsigned char) myData->getObjectId2() >> 16;\n        keyBuffer[11] = (unsigned char) myData->getObjectId2() >> 24;\n        keyBuffer[12] = (unsigned char) myData->getObjectId2() >> 32;\n        keyBuffer[13] = (unsigned char) myData->getObjectId2() >> 40;\n        keyBuffer[1", "CodeBleu_score": 29.94840070832311}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* myData = (CarlaCollisionEvent*)data;\n    if (!myData) {\n        return false;\n    }\n    if (force_md5 || DynamicType::getCdrSerializedSize(typeObject.get()) > DynamicType::getKeyMaxSerializedSize(typeObject.get())) {\n        return getKeyMD5(myData, handle, force_md5);\n    } else {\n        return getKeyDirect(myData, handle, force_md5);\n    }\n}", "CodeBleu_score": 23.24683396133505}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* myData = (CarlaCollisionEvent*) data;\n    if (force_md5 || DynamicType::getKeyMaxCdrSerializedSize > 16) {\n        static unsigned char keyBuffer[33];\n        unsigned char* upBuffer = keyBuffer;\n        static_cast<unsigned int>(m_md5.finalize(upBuffer, 32));\n        upBuffer[32] = 0;\n        DDS_OctetSeq_set_length(&m_keyBuf, 33);\n        memcpy(m_keyBuf.buffer, keyBuffer, 33);\n    } else {\n        m_keyBuf.buffer = (Octet*) myData->key;\n        m_keyBuf.buffer_length = 33;\n    }\n\n    *handle = (InstanceHandle_t) myData->_instanceHandle;\n    return true;\n}", "CodeBleu_score": 35.97748872872756}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n\n    try {\n        p_type->serialize(ser);\n        payload->length = (uint32_t)ser.getSerializedDataLength();\n        return true;\n    }\n    catch (eprosima::fastcdr::exception::Exception& e) {\n        return false;\n    }\n}", "CodeBleu_score": 77.61490744193406}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE :\n    CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n    // Serialize object\n    p_type->serialize(ser);\n    // Get serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get serialized length\n    return true;\n}", "CodeBleu_score": 83.22169228921669}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\n    CarlaEgoVehicleControl* p_data = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n    // Serialize object\n    p_data->serialize(ser);\n    // Get serialized length\n    payload->length = ser.getSerializedDataLength();\n    return true;\n}", "CodeBleu_score": 71.20426022195645}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (target_sysid != 0) {\n        return;\n    }\n    mavlink_msg_heartbeat_decode(&msg, &heartbeat);\n    if (heartbeat.type != MAV_TYPE_GCS_SYSTEM_ID) {\n        return;\n    }\n    target_sysid = heartbeat.system_id;\n    tracker.gcs().request_datastream_position(target_sysid);\n    tracker.gcs().request_datastream_airpressure(target_sysid);\n    target_set = true;\n}", "CodeBleu_score": 37.64968045374288}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (target_sysid != 0) {\n        return;\n    }\n\n    mavlink_msg_heartbeat_decode(msg, &heartbeat);\n    if (heartbeat.type != MAV_TYPE_GCS_SYSTEM_ID) {\n        return;\n    }\n\n    target_sysid = heartbeat.system_id;\n    tracker.gcs().request_datastream_position(target_sysid);\n    tracker.gcs().request_datastream_airpressure(target_sysid);\n    target_set = true;\n}", "CodeBleu_score": 36.54109763190618}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t  if (target_sysid != 0)\n    return;\n\n  mavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n  if (heartbeat.type != MAV_TYPE_GCS && heartbeat.type != MAV_TYPE_ONBOARD_CONTROLLER)\n    return;\n\n  target_sysid = heartbeat.system_id;\n  tracker.gcs().request_datastream_position(target_sysid, true);\n  tracker.gcs().request_datastream_airpressure(target_sysid, true);\n  target_set = true;\n}", "CodeBleu_score": 37.6837722597736}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _alt_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.4066070872933}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        // indicate that we need to do altitude calibration\n        _baro_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.2567519064801}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _barometer_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.41507448421682}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.target_component != _tracker.get_servo_system_id()) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    if (packet.command == MAV_CMD_COMPONENT_ARM_DISARM) {\n        if (packet.param1 == 1.0f) {\n            _tracker.arm_servos();\n            return MAV_RESULT_ACCEPTED;\n        }\n        if (packet.param1 == 0.0f) {\n            _tracker.disarm_servos();\n            return MAV_RESULT_ACCEPTED;\n        }\n    }\n\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 63.42815234370228}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0) {\n        _tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0) {\n        _tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 72.88077534465691}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 > 1.0f) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n    if (packet.param1 == 1.0f) {\n        if (!tracker.arm_servos()) {\n            return MAV_RESULT_FAILED;\n        }\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (packet.param1 == 0.0f) {\n        if (!tracker.disarm_servos()) {\n            return MAV_RESULT_FAILED;\n        }\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 63.11470203292275}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    // Iterate over the available GCS channels\n    for (uint8_t i = 0; i < num_gcs; i++) {\n        // Check if the GCS has available payload space\n        if (GCS_MAVLINK::gcs[i].available() >= MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n            // Send a request to start the data stream on the channel with the specified update rate\n            mavlink_msg_request_data_stream_send(\n                GCS_MAVLINK::gcs[i].get_chan(),\n                sysid,\n                compid,\n                MAV_DATA_STREAM_POSITION,\n                10,\n                1\n            );\n            return;\n        }\n    }\n}", "CodeBleu_score": 54.5974738691678}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t  // Check if there is enough payload space to send the message\n  if (mavlink_msg_request_data_stream_get_packed_size(sysid, compid, MAV_DATA_STREAM_POSITION) > mavlink_msg_to_send_buffer.len) {\n    return;\n  }\n\n  // Iterate over the available GCS channels\n  for (uint8_t i = 0; i < num_gcs; i++) {\n    // Check if the channel is available\n    if (gcs[i].available()) {\n      // Check if there is enough payload space to send the message on this channel\n      if (mavlink_msg_request_data_stream_get_packed_size(sysid, compid, MAV_DATA_STREAM_POSITION) > gcs[i].tx_buffer.available()) {\n        continue;\n      }\n\n      // Send the request to start the data stream on this channel\n      mavlink_msg_request_data_stream_send(sysid, compid, gcs[i].chan, MAV_DATA_STREAM_POSITION, 100, 1);\n      break;\n    }\n  }\n}", "CodeBleu_score": 39.4706711394661}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    // Iterate over the available GCS channels\n    for (uint8_t i = 0; i < num_gcs; i++) {\n        // Check if the GCS channel is available\n        if (gcs[i].available()) {\n            // Check if the GCS channel has enough payload space for the data stream request\n            if (gcs[i].num_free_payload_space() >= HAVE_PAYLOAD_SPACE(mavlink_msg_request_data_stream_pack)) {\n                // Send the data stream request to the GCS channel\n                mavlink_msg_request_data_stream_send(sysid, compid, i, MAV_DATA_STREAM_POSITION, 1000, 1);\n            }\n        }\n    }\n}", "CodeBleu_score": 51.81176102144247}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t  const AHRS& ahrs = AP_AHRS_Nav::get_singleton();\n  if (ahrs.cos_pitch() != 0.0f) {\n    ef_pitch = atan2f(ahrs.sin_roll() * ahrs.cos_pitch(), ahrs.cos_roll());\n    ef_yaw = atan2f(ahrs.sin_yaw() * ahrs.cos_roll() - ahrs.sin_roll() * ahrs.cos_yaw() * ahrs.cos_pitch(),\n                    ahrs.cos_roll() * ahrs.cos_yaw() + ahrs.sin_roll() * ahrs.sin_yaw() * ahrs.cos_pitch());\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 44.10316099816689}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t  AHRS &ahrs = AP_AHRS_Nav::get_singleton();\n  if (ahrs.cos_pitch() == 0.0f) {\n    return false;\n  }\n  ef_pitch = -asin(ahrs.sin_roll * ahrs.cos_pitch);\n  ef_yaw = wrap_PI(ahrs.yaw - atan2f(ahrs.sin_pitch, ahrs.cos_pitch * ahrs.cos_roll));\n  return true;\n}", "CodeBleu_score": 47.186755587815824}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    AHRS *ahrs = AP_AHRS::get_singleton();\n    if (ahrs == nullptr) {\n        return false;\n    }\n    if (fabsf(ahrs->cos_pitch()) < FLT_EPSILON) {\n        return false;\n    }\n    ef_pitch = atan2f(ahrs->sin_roll() * ahrs->cos_pitch(), ahrs->cos_roll());\n    ef_yaw = atan2f(ahrs->sin_pitch() * ahrs->sin_yaw(), ahrs->cos_pitch() * ahrs->cos_yaw() - ahrs->sin_roll() * ahrs->sin_yaw() * ahrs->cos_pitch());\n    return true;\n}", "CodeBleu_score": 45.391256123987624}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t    // calculate yaw and pitch in centidegrees\n    const float yaw_cd = calc_yaw_cd();\n    const float pitch_cd = calc_pitch_cd();\n\n    // check if direction is reversed\n    const bool reversed = get_ef_yaw_direction();\n\n    // compute angle error\n    const float angle_error = calc_angle_error(yaw_cd, pitch_cd, reversed);\n\n    // convert errors from earth frame to body frame\n    const float yaw_error_bf = convert_ef_to_bf(angle_error);\n    const float pitch_error_bf = convert_ef_to_bf(angle_error);\n\n    // update target yaw and pitch if target distance is valid or no minimum distance is set\n    if (target_distance_valid || !MIN_DISTANCE) {\n        tracker.update_yaw_servo(yaw_error_bf);\n        tracker.update_pitch_servo(pitch_error_bf);\n    }\n}", "CodeBleu_score": 33.84520864339798}, {"code": "void Mode::update_auto(void){\n\t    float yaw_cd, pitch_cd;\n\n    // calculate yaw and pitch in centidegrees\n    yaw_cd = calc_yaw_cd();\n    pitch_cd = calc_pitch_cd();\n\n    // check if direction is reversed\n    const bool reversed = (get_ef_yaw_direction() != get_yaw_direction());\n\n    // compute angle error\n    const float angle_error = wrap_180_cd(yaw_cd - ahrs.yaw_sensor) * 100.0f;\n\n    // convert errors from earth frame to body frame\n    const Vector3f angle_error_bf = convert_ef_to_bf(Vector3f(0.0f, angle_error, 0.0f));\n\n    // update pitch and yaw servos\n    if (target_distance_valid() || !aparm.min_pitch_cd) {\n        tracker.update_pitch_servo(pitch_cd);\n        tracker.update_yaw_servo(angle_error_bf.y);\n    }\n\n    // set reverse flag\n    tracker.set_reverse(reversed);\n\n    // set angle error\n    tracker.set_angle_error(angle_error);\n}", "CodeBleu_score": 32.565068198549994}, {"code": "void Mode::update_auto(void){\n\t    // calculate target yaw and pitch\n    int16_t target_yaw_cd = get_yaw_cd_to_navigate(true);\n    int16_t target_pitch_cd = get_pitch_cd_to_navigate(true);\n\n    // check if direction is reversed\n    bool reversed = (target_yaw_cd < 0) != (tracker.get_ef_yaw_direction() > 0);\n\n    // calculate angle error\n    int16_t angle_error_yaw_cd = constrain_int16(target_yaw_cd - tracker.get_ef_yaw_cd(), -18000, 18000);\n    int16_t angle_error_pitch_cd = constrain_int16(target_pitch_cd - tracker.get_ef_pitch_cd(), -18000, 18000);\n\n    // convert errors from earth frame to body frame\n    int16_t angle_error_yaw_bf_cd = convert_ef_to_bf(angle_error_yaw_cd, reversed);\n    int16_t angle_error_pitch_bf_cd = convert_ef_to_bf(angle_error_pitch_cd, reversed);\n\n    // update pitch and yaw servos\n    if (tracker.get_target_distance_valid() || tracker.get_min_distance() == 0.0f) {\n        tracker.update_yaw_servo(angle_error_yaw_bf_cd);\n        tracker.update_pitch_servo(angle_error_pitch_bf_cd);\n    }\n}", "CodeBleu_score": 35.45712828567529}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t  // Update GPS\n  gps.update();\n\n  // Check if GPS is at least 3D fix\n  if (gps.status() == gps.FIX_3D) {\n    // Check if location is valid\n    if (gps.location.isValid()) {\n      // Check if countdown reached one\n      if (ground_start_countdown == 1) {\n        // Set home location\n        set_home();\n      }\n      // Check if countdown reached zero\n      if (ground_start_countdown == 0) {\n        // Reset countdown\n        ground_start_countdown = GROUND_START_COUNTDOWN;\n      }\n    } else {\n      // Reset countdown\n      ground_start_countdown = 0;\n    }\n  } else {\n    // Reset countdown\n    ground_start_countdown = 0;\n  }\n}", "CodeBleu_score": 32.39044473461115}, {"code": "void Tracker::update_GPS(void){\n\t  gps.update();\n  if (gps.location.isValid() && gps.location.isUpdated()) {\n    if (gps.last_message_time_ms != gps.last_message_time_ms) {\n      gps.last_message_time_ms = gps.last_message_time_ms;\n      if (gps.status >= 3) {\n        if (home_set == false) {\n          set_home();\n        }\n      }\n    }\n  } else {\n    ground_start_countdown = 0;\n  }\n}", "CodeBleu_score": 28.336455529408955}, {"code": "void Tracker::update_GPS(void){\n\t  // update the GPS\n  gps.update();\n\n  // check if the last message time has changed and if the GPS status is at least 3D fix\n  if (gps.last_message_time_ms != last_message_time_ms && gps.status >= 3) {\n    // update the last message time\n    last_message_time_ms = gps.last_message_time_ms;\n\n    // check if the countdown is set\n    if (ground_start_countdown > 0) {\n      // check if the current location is valid\n      if (gps.location.is_valid()) {\n        // set the home location\n        set_home();\n      } else {\n        // reset the countdown\n        ground_start_countdown = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 35.69112665964154}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t  if (pitch > 180) {\n    pitch = 180;\n  }\n  if (pitch < 0) {\n    pitch = 0;\n  }\n  // 180 is the middle of the servo\n  // 1000 is the max of the servo\n  // 500 is the min of the servo\n  // 1000 - 500 = 500\n  // 180 - 0 = 180\n  // 500 / 180 = 2.7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777", "CodeBleu_score": 13.059407929624783}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch < 0) {\n        pitch = 0;\n    }\n    if (pitch > 180) {\n        pitch = 180;\n    }\n    SRV_Channels::set_output_scaled(SRV_Channel::k_pitch_control, pitch);\n}", "CodeBleu_score": 11.09011928423026}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t  if (pitch > 0.0f) {\n    // pitch up\n    servo_pitch.write(180);\n  } else {\n    // pitch down\n    servo_pitch.write(0);\n  }\n}", "CodeBleu_score": 13.186778264590638}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call base class barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if ARMING_CHECK_BARO is enabled, check the baro against the inertial nav\n    if (copter.aparm.arming_check_baro > 0) {\n        // get barometer altitude\n        float baro_alt = copter.barometer.get_altitude(copter.G_Dt);\n\n        // get inertial nav altitude\n        float inertial_alt = copter.inertial_nav.get_position_z_up_cm();\n\n        // calculate the difference\n        float diff = baro_alt - inertial_alt;\n\n        // if the difference is greater than the check value, log a failure\n        if (fabsf(diff) > copter.aparm.arming_check_baro) {\n            if (display_failure) {\n                gcs().send_text(MAV_SEVERITY_CRITICAL, \"Arming failed baro check\");\n            }\n            check_failed(ARMING_CHECK_BARO);\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 54.44006741546452}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call base class's barometer_checks function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if ARMING_CHECK_BARO is enabled, check the barometer reference and compare the barometer altitude with the inertial navigation altitude\n    if (copter.aparm.arming_check_baro) {\n        // get the barometer reference\n        float baro_reference = copter.inertial_nav.get_position_z_up_cm();\n\n        // get the barometer altitude\n        float baro_altitude = copter.barometer.get_altitude();\n\n        // calculate the difference between the barometer reference and the barometer altitude\n        float baro_diff = fabsf(baro_reference - baro_altitude);\n\n        // if the difference exceeds the predefined limit, log a failure and return false\n        if (baro_diff > copter.aparm.arming_check_baro_max_diff) {\n            if (display_failure) {\n                AP_Notify::flags.baro_check_failed = true;\n            }\n            return false;\n        }\n    }\n\n    // if we get here, all checks passed\n    return true;\n}", "CodeBleu_score": 52.324474629969544}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (!AP_Arming::pre_arm_checks(display_failure)) {\n        return false;\n    }\n\n    if (AP_Arming::is_arm_checks_enabled(AP_ARMING_CHECK_BARO)) {\n        // check barometer reference\n        if (copter.inertial_nav.get_position_z_up_cm() - copter.barometer.get_altitude() > ARMING_CHECK_BARO_ALT_DIFF_MAX) {\n            if (display_failure) {\n                AP_Notify::flags.baro_bad = true;\n            }\n            return false;\n        }\n\n        // check barometer variance\n        if (copter.inertial_nav.get_filter_status().flags.variance_bad) {\n            if (display_failure) {\n                AP_Notify::flags.baro_bad = true;\n            }\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 47.09807304099412}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == AP_Terrain::TerrainSource::TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    if (copter.mode_rtl.get_alt_type() == RTL_ALT_TYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 69.49234622136274}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == AP_Terrain::TerrainSource::TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    if (copter.mode_rtl.get_alt_type() == RTL_ALT_TYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 69.49234622136274}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if the terrain source is from a rangefinder, it's not required\n    if (copter.wp_nav->get_terrain_source() == AC_WPNav::TerrainSource::RANGEFINDER) {\n        return false;\n    }\n\n    // if the terrain source is from the terrain database and the RTL altitude type is terrain, it's required\n    if (copter.mode_rtl.get_alt_type() == ModeRTL::RTL_ALTTYPE_TERRAIN) {\n        return true;\n    }\n\n    // otherwise defer to base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 69.58181751505357}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    float dt = scheduler.get_last_loop_time_s();\n\n    attitude_control->set_dt(dt);\n    attitude_control->rate_controller_run();\n\n    pos_control->set_dt(dt);\n}", "CodeBleu_score": 51.898010602876}, {"code": "void Copter::run_rate_controller(){\n\t    // set loop time for rate controllers\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    pos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n    // run low-level rate controllers\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 49.51466761076095}, {"code": "void Copter::run_rate_controller(){\n\t    // set the loop time for attitude, position, and motor controllers using the last loop time from the scheduler\n    attitude_control->set_loop_time_from_scheduler(AP::scheduler().get_last_loop_time_s());\n    pos_control->set_loop_time_from_scheduler(AP::scheduler().get_last_loop_time_s());\n    motors->set_loop_time_from_scheduler(AP::scheduler().get_last_loop_time_s());\n\n    // run the low-level rate controllers that require only IMU data\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 47.17907852062437}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // check if the old location matches the new waypoint\n    if (!old_loc.same_loc_as(new_loc)) {\n        // if the altitude frame is the same, then use the new waypoint\n        if (old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n            set_target_location(new_loc);\n            return true;\n        }\n        // if the altitude frame is different, then use the old waypoint\n        else {\n            set_target_location(old_loc);\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 58.60720972197904}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (!new_loc.same_loc_as(old_loc) || old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        set_target_location(new_loc);\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 61.007521801990926}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // check if the old location matches this waypoint\n    if (!old_loc.same_loc_as(new_loc)) {\n        // check if the altitude frames of the old and new locations are the same\n        if (old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n            // set the new location as the target\n            set_target_location(new_loc);\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 54.81796900134942}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    // if aux switch is not in high position, or mode is not active, do nothing\n    if (ch_flag != AuxSwitchPos::HIGH || !copter.flightmode->mode_number(mode)) {\n        return;\n    }\n\n    // if mode is not active, do nothing\n    if (!copter.flightmode->mode_number(mode)) {\n        return;\n    }\n\n    // if mode is active, set mode\n    copter.set_mode(mode, ModeReason::RC_COMMAND);\n\n    // reset mode switch\n    rc().reset_mode_switch();\n}", "CodeBleu_score": 58.276601709802236}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    // if the switch is in the HIGH position, set the mode\n    if (aux_switch_pos == ch_flag) {\n        copter.set_mode(mode, MODE_REASON_AUX_FUNCTION);\n    }\n\n    // if the switch is not in the HIGH position and the current flight mode matches the given mode, reset the mode switch\n    if (aux_switch_pos != ch_flag && copter.flightmode->mode_number == mode) {\n        rc().reset_mode_switch(ch_flag);\n    }\n}", "CodeBleu_score": 54.93406147210859}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // switch is in high position -> set the mode\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else {\n        // switch is in low position -> reset the mode\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 44.26957894990106}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // save roll and pitch trim\n    channel_roll->get_control_in();\n    channel_pitch->get_control_in();\n    LOGGER_WRITE_EVENT(LoggerEvent::TRIM_SAVE);\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 28.234678501541566}, {"code": "void Copter::save_trim(){\n\t    // get roll and pitch control inputs\n    float roll_control_in = channel_roll->get_control_in();\n    float pitch_control_in = channel_pitch->get_control_in();\n\n    // convert to radians\n    float roll_trim_rad = ToRad(roll_control_in);\n    float pitch_trim_rad = ToRad(pitch_control_in);\n\n    // add to ahrs\n    ahrs.add_trim(roll_trim_rad, pitch_trim_rad);\n\n    // log event\n    LOGGER_WRITE_EVENT(events.save_trim);\n\n    // send message\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 59.665834711853094}, {"code": "void Copter::save_trim(){\n\t    // convert to radians\n    float roll_trim = channel_roll->get_control_in() * ToRad;\n    float pitch_trim = channel_pitch->get_control_in() * ToRad;\n\n    // add to ahrs\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log event\n    LOGGER_WRITE_EVENT(events.save_trim);\n\n    // send message\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 68.11645841959262}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    Vector2f vel = inertial_nav.get_velocity_neu_cms();\n    float speed_sq = vel.length_squared();\n    if (copter.position_ok() && speed_sq > 0.1f) {\n        return degrees(atan2f(vel.y, vel.x));\n    }\n    return 0.0f;\n}", "CodeBleu_score": 39.2634735054893}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    float yaw_angle = copter.ahrs.yaw_sensor;\n    Vector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n    float speed_sq = vel.xy().length_squared();\n    if (copter.position_ok() && speed_sq > 1.0f) {\n        yaw_angle = atan2f(vel.y, vel.x);\n    }\n    return yaw_angle;\n}", "CodeBleu_score": 55.7260140784239}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    Vector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n    float speed_sq = vel.xy().length_squared();\n    if (copter.position_ok() && speed_sq > 0.0001f) {\n        return atan2f(vel.y, vel.x) * RAD_TO_DEG;\n    }\n    return 0.0f;\n}", "CodeBleu_score": 51.774679369921685}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (checks_disabled) {\n        return true;\n    }\n\n    if (hal.util->was_watchdog_armed()) {\n        return true;\n    }\n\n    switch (method) {\n    case AP_Arming::Method::ANGLE_PASSTHRU:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTHOLD:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTCTL:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTCTL_RAT:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTCTL_RAT_RATTUNE:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTCTL_RAT_RATTUNE_THR_FWD:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTCTL_RAT_RATTUNE_THR_FWD_VEL:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTCTL_RAT_RATTUNE_THR_FWD_VEL_YAW:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTCTL_RAT_RATTUNE_THR_FWD_VEL_YAW_POS:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTCTL_RAT_RATTUNE_THR_FWD_VEL_YAW_POS_ATT:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTCTL_RAT_RATTUNE_THR_FWD_VEL_YAW_POS_ATT_EKF:\n    case AP_Arming::Method::ANGLE_PASSTHRU_ALTCTL_RAT_RATTUNE_THR_FWD_VEL_YAW_POS_ATT_EKF_AHRS:\n    case AP_Arming", "CodeBleu_score": 27.128335869429353}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (checks_disabled) {\n        return true;\n    }\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n    switch (method) {\n        case AP_Arming::Method::RUDDER:\n            if (plane.get_rudder_arming_type() == AP_Rudder::RUDDER_ARMING_DISABLED) {\n                return false;\n            }\n            if (plane.get_throttle_input() != 0) {\n                return false;\n            }\n            break;\n        default:\n            return AP_Arming::arm_checks(method);\n    }\n    return true;\n}", "CodeBleu_score": 58.59596873371338}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // if arming checks are disabled or the watchdog was armed, bypass checks\n    if (arming_checks_disabled() || hal.util->was_watchdog_armed()) {\n        return true;\n    }\n\n    // return false if we are not in a landed state\n    if (!AP::ahrs().prearm_check(false)) {\n        return false;\n    }\n\n    // return false if rudder arming is disabled or throttle is not zero\n    if (method == AP_Arming::Method::RUDDER) {\n        if (get_rudder_arming_type() == RUDDER_DISABLED || plane.get_throttle_input() != 0) {\n            return false;\n        }\n    }\n\n    // call parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 51.538000380990866}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // If arming checks are enabled, perform them\n    if (do_arming_checks && !arming_checks()) {\n        return false;\n    }\n\n    // Change the arm state\n    plane.change_mode(plane.mode_auto, ModeReason::ARMING);\n\n    // Set delay arming flag\n    plane.set_delay_arming(true);\n\n    // Send arm/disarm status text\n    plane.send_statustext_armed();\n\n    // Return success\n    return true;\n}", "CodeBleu_score": 36.89659388210672}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // check if arming is allowed\n    if (!AP_Arming::is_arming_allowed()) {\n        return false;\n    }\n\n    // check if arming checks are enabled\n    if (do_arming_checks) {\n        // run all arming checks\n        if (!AP_Arming::run_arming_checks(method)) {\n            return false;\n        }\n    }\n\n    // set home location\n    plane.update_home();\n\n    // set home location in ahrs\n    plane.ahrs.set_home(plane.current_loc);\n\n    // set current location\n    plane.update_current_loc();\n\n    // change arm state\n    plane.change_arm_state(AP_Arming::ARMED);\n\n    // set delay arming flag\n    plane.delay_arming = true;\n\n    // send arm/disarm status text\n    send_arm_disarm_statustext(true);\n\n    return true;\n}", "CodeBleu_score": 53.22125615863283}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // check if arming is allowed\n    if (!is_arm_allowed()) {\n        return false;\n    }\n\n    // check if arming checks are required\n    if (do_arming_checks) {\n        // run the arming checks\n        if (!arming_checks()) {\n            return false;\n        }\n    }\n\n    // set the arming method\n    set_arming_method(method);\n\n    // update home location\n    plane.update_home();\n\n    // set home location in AHRS\n    plane.ahrs.set_home(plane.current_loc);\n\n    // update current location\n    plane.update_current_loc();\n\n    // change arm state\n    plane.change_arm_state(AP_Arming::ARMED);\n\n    // set delay arming flag\n    plane.delay_arming = true;\n\n    // send status text\n    send_arm_disarm_statustext();\n\n    return true;\n}", "CodeBleu_score": 54.571468635349106}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    if (!hal.util->get_disarm_button()) {\n        if (display_failure) {\n            AP_Notify::flags.pre_arm_check = true;\n            AP_Notify::flags.armed_state = false;\n            AP_Notify::flags.armed_state_changed = true;\n            AP_Notify::flags.pre_arm_check_fail = true;\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 58.40767753362526}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if we are already armed, return true\n    if (AP_Arming::pre_arm_checks(display_failure)) {\n        return true;\n    }\n\n    // check if a disarm button is configured\n    if (hal.util->get_soft_armed()) {\n        // if not, display a failure message if requested and return false\n        if (display_failure) {\n            AP_Notify::flags.arming_failed = true;\n        }\n        return false;\n    }\n\n    // if a disarm button is configured, proceed with the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 63.0855164953243}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (arming.is_armed()) {\n        return true;\n    }\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n    if (!AP_Arming::pre_arm_checks(display_failure)) {\n        return false;\n    }\n    if (!pre_arm_checks_sub()) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 55.84985929789457}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.35798259889287}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x*ahrs.cos_yaw - y*ahrs.sin_yaw;\n    float ne_y = x*ahrs.sin_yaw + y*ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 70.04660597491264}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    // Calculate the rotation matrix\n    float cos_yaw = ahrs.cos_yaw;\n    float sin_yaw = ahrs.sin_yaw;\n    float R[2][2] = {{cos_yaw, -sin_yaw},\n                     {sin_yaw, cos_yaw}};\n\n    // Apply the rotation matrix to the input coordinates\n    float ne_x = R[0][0] * x + R[0][1] * y;\n    float ne_y = R[1][0] * x + R[1][1] * y;\n\n    // Update the input coordinates with the new values\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 53.1882579766113}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    float yaw_angle_cd;\n    float yaw_rate_cds;\n    uint8_t yaw_relative_flag;\n    uint8_t yaw_look_at_heading_flag;\n    uint8_t yaw_look_at_heading_valid;\n\n    /*\n     * Check if the yaw angle and param4 values are within acceptable ranges.\n     */\n    if (packet.param1 > MAV_YAW_ANGLE_MAX || packet.param1 < -MAV_YAW_ANGLE_MAX) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param4 > MAV_YAW_RATE_MAX || packet.param4 < -MAV_YAW_RATE_MAX) {\n        return MAV_RESULT_DENIED;\n    }\n\n    /*\n     * Set the yaw heading using the provided parameters.\n     */\n    yaw_angle_cd = packet.param1;\n    yaw_rate_cds = packet.param4;\n    yaw_relative_flag = packet.param5;\n    yaw_look_at_heading_flag = packet.param6;\n    yaw_look_at_heading_valid = packet.param7;\n\n    /*\n     * Set the yaw heading using the provided parameters.\n     */\n    sub.set_yaw_angle_rate_cds(yaw_angle_cd, yaw_rate_cds, yaw_relative_flag, yaw_look_at_heading_flag, yaw_look_at_heading_valid);\n\n    /*\n     * Return MAV_RESULT_ACCEPTED.\n     */\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 45.85905567731162}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    /*\n     * Check if the heading is within acceptable ranges.\n     */\n    if (is_zero(packet.param4) || is_equal(packet.param4, 360.0f)) {\n        /*\n         * If the heading is within acceptable ranges, set the yaw heading using the provided parameters and return MAV_RESULT_ACCEPTED.\n         */\n        set_auto_yaw_look_at_heading(packet.param1, packet.param2);\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        /*\n         * If the heading is not within acceptable ranges, return MAV_RESULT_DENIED.\n         */\n        return MAV_RESULT_DENIED;\n    }\n}", "CodeBleu_score": 41.40338124152257}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t  float angle_cd = packet.param1 * 100;\n  float yaw_rate_cds = packet.param2 * 100;\n  float look_ahead = packet.param3;\n  float heading = packet.param4;\n  if (is_zero(angle_cd) && is_zero(yaw_rate_cds) && is_zero(look_ahead)) {\n    // if no parameters were provided, set yaw to current heading\n    heading = ahrs.yaw_sensor;\n  } else if (!is_equal(angle_cd, 0.0f) && !is_equal(yaw_rate_cds, 0.0f) && !is_equal(look_ahead, 0.0f)) {\n    // if angle, yaw rate, and look ahead are provided, set yaw to heading\n    heading = ahrs.yaw_sensor + angle_cd * 0.01f * (look_ahead / G_Dt);\n  } else if (!is_equal(angle_cd, 0.0f) && !is_equal(yaw_rate_cds, 0.0f)) {\n    // if angle and yaw rate are provided, set yaw to heading\n    heading = ahrs.yaw_sensor + angle_cd * 0.01f * G_Dt;\n  } else if (!is_equal(angle_cd, 0.0f)) {\n    // if angle is provided, set yaw to heading\n    heading = ahrs.yaw_sensor + angle_cd * 0.01f * G_Dt;\n  } else if (!is_equal(yaw_rate_cds, 0.0f)) {\n    // if yaw rate is provided, set yaw to heading\n    heading = ahrs.yaw_sensor + yaw_rate_cds * 0.01f * G_Dt;\n  } else if (!is_equal(look_ahead, 0.0f)) {\n    // if look ahead is provided, set yaw to heading\n    heading = ahrs.yaw_sensor + angle_", "CodeBleu_score": 29.016351761328917}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return wrap_360_cd(wp_bearing_cd) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 40.591103488613754}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == GUIDED || control_mode == AUTO) {\n        return wrap_360_cd(wp_bearing_cd) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 40.22822827873057}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return wrap_360_cd(wp_bearing_cd) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 40.591103488613754}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(id)) {\n        logger.WriteCriticalBlock(LOG_PACKET_HEADER_INIT, id, value);\n    }\n}", "CodeBleu_score": 28.080677678091703}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(id)) {\n        logger.WriteCriticalBlock(LOG_PACKET_HEADER_INIT, id, value);\n    }\n}", "CodeBleu_score": 28.080677678091703}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(id)) {\n        logger.WriteCriticalBlock(LOG_PACKET_HEADER_INIT, id, value);\n    }\n}", "CodeBleu_score": 28.080677678091703}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home is already set\n    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if motors are armed, set home to current location\n    if (motors.armed()) {\n        set_home_to_current_location();\n        return;\n    }\n\n    // if motors are not armed, attempt to set home to current EKF location\n    set_home_to_current_location_inflight();\n}", "CodeBleu_score": 46.11617089078514}, {"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home is already set\n    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if motors are armed, set home to current location\n    if (motors.armed()) {\n        set_home_to_current_location();\n        return;\n    }\n\n    // if motors are not armed, attempt to set home to EKF location\n    set_home_to_current_location_inflight();\n}", "CodeBleu_score": 46.11617089078514}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (ahrs.home_is_set()) {\n        return;\n    }\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location();\n    }\n}", "CodeBleu_score": 53.65764826129899}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t    // if motors are not armed set throttle to zero and exit immediately\n    if (!motors.armed()) {\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    float target_roll, target_pitch;\n    get_pilot_desired_angle_rates(channel_roll->norm_input(), channel_pitch->norm_input(), target_roll, target_pitch);\n\n    // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, channel_yaw->norm_input());\n\n    // set motors based on angle boost\n    motors.set_lateral(channel_lateral->norm_input());\n    motors.set_forward(channel_forward->norm_input());\n\n    // output pilot's throttle without angle boost\n    motors.set_throttle(channel_throttle->norm_input());\n}", "CodeBleu_score": 56.987481583694176}, {"code": "void ModeAcro::run(){\n\t    float target_roll, target_pitch;\n    float target_yaw_rate;\n    float target_climb_rate;\n    float pilot_throttle_scaled;\n\n    // if not armed or channel_throttle->norm_input is below throttle deadzone, set throttle to zero and exit immediately\n    if (!motors.armed() || channel_throttle->norm_input < get_non_takeoff_throttle_deadzone()) {\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // convert pilot input to lean angles\n    // To-Do: convert roll pitch to desired body frame rate\n    target_roll = channel_roll->norm_input();\n    target_pitch = channel_pitch->norm_input();\n\n    // get pilot's desired yaw rate\n    target_yaw_rate = channel_yaw->norm_input();\n\n    // get pilot's desired climb rate\n    target_climb_rate = channel_throttle->norm_input();\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yaw_rate);\n\n    // set motors to desired climb rate (but don't set throttle directly to allow throttle intercept)\n    motors.set_forward(target_climb_rate);\n\n    // set lateral controller\n    // To-Do: convert lateral to desired body frame rate\n    float lateral = channel_lateral->norm_input();\n    motors.set_lateral(lateral);\n\n    // scale the pilot throttle down to represent base throttle\n    pilot_throttle_scaled = channel_throttle->norm_input", "CodeBleu_score": 58.209517964198994}, {"code": "void ModeAcro::run(){\n\t    // if not armed set throttle to zero and exit immediately\n    if (!motors.armed()) {\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    float target_roll, target_pitch;\n    get_pilot_desired_angle_rates(channel_roll->norm_input(), channel_pitch->norm_input(), target_roll, target_pitch);\n\n    // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, channel_yaw->norm_input());\n\n    // output pilot's throttle without angle boost\n    motors.set_throttle(channel_throttle->norm_input());\n\n    // convert pilot input to forward / backward and left / right\n    float target_forward, target_lateral;\n    get_pilot_desired_forward_backward_and_left_right(channel_forward->norm_input(), channel_lateral->norm_input(), target_forward, target_lateral);\n\n    // run lateral controller\n    motors.set_lateral(target_lateral);\n\n    // run forward controller\n    motors.set_forward(target_forward);\n}", "CodeBleu_score": 65.13136144985025}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // Set mode to position control\n    _sub.set_mode(Mode::POSITION);\n\n    // Set the yaw state to use the default auto yaw heading\n    _sub.set_auto_yaw_mode(get_default_auto_yaw_mode());\n\n    // Initialize the waypoint controller\n    _sub.wp_nav.wp_and_spline_init();\n}", "CodeBleu_score": 29.059486069383844}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // Set position control mode\n    sub.set_mode(MODE_POSITION_CONTROL);\n\n    // Set the destination to the stopping point\n    sub.wp_nav.set_wp_destination(sub.wp_nav.get_wp_stopping_point());\n\n    // Set the default auto yaw mode\n    set_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 32.944124520273306}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    sub.pos_control.init_z_controller();\n    sub.pos_control.init_yaw_controller();\n    sub.pos_control.set_alt_target_to_current_alt();\n    sub.pos_control.set_yaw_target_to_current_heading();\n    sub.pos_control.init_z_controller();\n    sub.pos_control.init_yaw_controller();\n    sub.pos_control.set_alt_target_to_current_alt();\n    sub.pos_control.set_yaw_target_to_current_heading();\n    sub.pos_control.init_z_controller();\n    sub.pos_control.init_yaw_controller();\n    sub.pos_control.set_alt_target_to_current_alt();\n    sub.pos_control.set_yaw_target_to_current_heading();\n    sub.pos_control.init_z_controller();\n    sub.pos_control.init_yaw_controller();\n    sub.pos_control.set_alt_target_to_current_alt();\n    sub.pos_control.set_yaw_target_to_current_heading();\n    sub.pos_control.init_z_controller();\n    sub.pos_control.init_yaw_controller();\n    sub.pos_control.set_alt_target_to_current_alt();\n    sub.pos_control.set_yaw_target_to_current_heading();\n    sub.pos_control.init_z_controller();\n    sub.pos_control.init_yaw_controller();\n    sub.pos_control.set_alt_target_to_current_alt();\n    sub.pos_control.set_yaw_target_to_current_heading();\n    sub.pos_control.init_z_controller();\n    sub.pos_control.init_yaw_controller();\n    sub.pos_control.set_alt_target_to_current_alt();\n    sub.pos_control.set_yaw_target_to_current_heading();\n    sub.pos_control.init_z_controller();\n    sub.pos_control.init", "CodeBleu_score": 27.33947902034336}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration limits\n    position_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n\n    // initialise position and desired velocity\n    if (!wp_nav->reached_destination()) {\n        // if we are not at the destination point, use the WPNav approach target\n        wp_nav->init_velocity_to_point();\n    } else {\n        // if we have reached the destination point, initiate the velocity to the current velocity\n        // this ensures we maintain the correct velocity when we reach the destination\n        wp_nav->init_velocity();\n    }\n\n    // initialise vertical speed and acceleration to zero\n    position_control->set_vel_decay_rate(0.0f);\n\n    // initialise horizontal speed and acceleration to the desired speed\n    position_control->init_xy_controller();\n\n    // initialise yaw\n    position_control->init_z_controller();\n    position_control->set_correction_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n\n    // set yaw state\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 48.15209932793686}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // initialise vertical speed and acceleration\n    float target_speed_up, target_speed_down;\n    float target_accel_up, target_accel_down;\n    if (!get_pilot_desired_velocity(target_speed_up, target_speed_down, target_accel_up, target_accel_down)) {\n        // if no update from pilot, use the previous speed\n        target_speed_up = guided_state.vel_up_ef_cmss;\n        target_speed_down = guided_state.vel_down_ef_cmss;\n        target_accel_up = guided_state.accel_up_cmss;\n        target_accel_down = guided_state.accel_down_cmss;\n    }\n\n    // initialise horizontal speed\n    float target_speed_xy;\n    if (!get_pilot_desired_velocity_xy(target_speed_xy)) {\n        // if no update from pilot, use the previous speed\n        target_speed_xy = guided_state.vel_xy_ef_cms;\n    }\n\n    // initialise yaw\n    float target_yaw_rate;\n    if (!get_pilot_desired_yaw_rate(target_yaw_rate)) {\n        // if no update from pilot, use the previous yaw rate\n        target_yaw_rate = guided_state.yaw_rate_cds;\n    }\n\n    // initialise velocity controller\n    position_control->init_xy_controller(target_speed_xy);\n    position_control->set_max_speed_accel_z(target_speed_up, target_speed_down, target_accel_up, target_accel_down);\n    position_control->init_z_controller();\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 50.3999392168901}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration limits\n    position_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n\n    // initialise position and vertical controllers\n    position_control->init_xy_controller();\n    position_control->init_z_controller();\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 44.158043692630024}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    if (millis() - guided_limit.start_time > GUIDED_LIMIT_TIMEOUT) {\n        return true;\n    }\n    if (guided_limit.alt_min_cm > 0 && inertial_nav.get_position_z_up_cm() < guided_limit.alt_min_cm) {\n        return true;\n    }\n    if (guided_limit.alt_max_cm > 0 && inertial_nav.get_position_z_up_cm() > guided_limit.alt_max_cm) {\n        return true;\n    }\n    if (guided_limit.horiz_max_cm > 0 && get_horizontal_distance_cm(guided_limit.start_pos.xy, inertial_nav.get_position_neu_cm()) > guided_limit.horiz_max_cm) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 51.333725756889706}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we've timed out\n    if (millis() - guided_limit.start_time > GUIDED_LIMIT_TIMEOUT) {\n        return true;\n    }\n\n    // check if we've moved too far\n    if (is_zero(guided_limit.start_pos.xy)) {\n        // if we haven't set a start position, we can't do this check\n        return false;\n    }\n    if (get_horizontal_distance_cm(guided_limit.start_pos.xy, curr_pos.xy) > GUIDED_LIMIT_DISTANCE) {\n        return true;\n    }\n\n    // check if we've climbed too high or too low\n    if (!is_zero(guided_limit.alt_min_cm) && curr_pos.z < guided_limit.alt_min_cm) {\n        return true;\n    }\n    if (!is_zero(guided_limit.alt_max_cm) && curr_pos.z > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n    // if we get here all limits have been passed\n    return false;\n}", "CodeBleu_score": 53.105613190837644}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check timeout\n    if (millis() - guided_limit.start_time_ms > guided_limit.timeout_ms) {\n        return true;\n    }\n\n    // check altitude limits\n    if (guided_limit.alt_min_cm > 0 && inertial_nav.get_position_z_up_cm() < guided_limit.alt_min_cm) {\n        return true;\n    }\n    if (guided_limit.alt_max_cm > 0 && inertial_nav.get_position_z_up_cm() > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n    // check horizontal distance moved\n    if (guided_limit.horiz_max_cm > 0 && get_horizontal_distance_cm(guided_limit.start_pos.xy) > guided_limit.horiz_max_cm) {\n        return true;\n    }\n\n    // all limits passed\n    return false;\n}", "CodeBleu_score": 51.34310924742675}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t  static uint32_t last_request_ms = 0;\n  static uint32_t timeout_ms = 0;\n  static bool pass = false;\n\n  if (millis() - last_request_ms > 2000) {\n    last_request_ms = millis();\n    gcs().send_text(MAV_SEVERITY_CRITICAL, \"MOTOR_TEST: waiting for request\");\n  }\n\n  if (millis() - timeout_ms > 10000) {\n    gcs().send_text(MAV_SEVERITY_CRITICAL, \"MOTOR_TEST: TIMEOUT\");\n    pass = false;\n    AP::arming().disarm(AP_Arming::Method::MOTOR_TEST_FAIL);\n    gcs().send_text(MAV_SEVERITY_CRITICAL, \"MOTOR_TEST: disarmed\");\n    return false;\n  }\n\n  if (pass) {\n    return true;\n  }\n\n  if (gcs().motor_test_triggered(channel_count)) {\n    timeout_ms = millis();\n    gcs().send_text(MAV_SEVERITY_CRITICAL, \"MOTOR_TEST: triggered\");\n    pass = true;\n  }\n\n  return false;\n}", "CodeBleu_score": 52.63179704412495}, {"code": "bool Sub::verify_motor_test(){\n\t    if (millis() - last_motor_test_request_ms > 2000) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout\");\n        pass = false;\n        arming.disarm(AP_Arming::Method::MOTORTEST);\n        last_motor_test_request_ms = millis();\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 53.0706257284427}, {"code": "bool Sub::verify_motor_test(){\n\t    // check for timeout\n    if (millis() - motor_test_start_time > MOTOR_TEST_TIMEOUT_MS) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout\");\n        pass = false;\n        motor_test_enabled = false;\n        AP::arming().disarm(AP_Arming::Method::MOTOR_TEST_FAIL);\n        motor_test_fail_time = millis();\n        return false;\n    }\n\n    // check for pass\n    if (motor_test_pass) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 46.344375244425486}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t  float roll_target, pitch_target;\n  wp_nav.get_roll(&roll_target);\n  wp_nav.get_pitch(&pitch_target);\n\n  // constrain roll and pitch to 30 degrees\n  roll_target = constrain_float(roll_target, -3000, 3000);\n  pitch_target = constrain_float(pitch_target, -3000, 3000);\n\n  // lateral and forward controller\n  lateral_out = roll_target;\n  forward_out = pitch_target;\n}", "CodeBleu_score": 32.4883256140309}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // wp_nav.get_roll() and wp_nav.get_pitch() return roll and pitch targets in centidegrees\n    float roll_target_cd = wp_nav.get_roll() * 100.0f;\n    float pitch_target_cd = wp_nav.get_pitch() * 100.0f;\n\n    // apply roll/pitch limits\n    roll_target_cd = constrain_float(roll_target_cd, -roll_limit_cd, roll_limit_cd);\n    pitch_target_cd = constrain_float(pitch_target_cd, -pitch_limit_cd, pitch_limit_cd);\n\n    // normalize the roll and pitch targets\n    float roll_target;\n    float pitch_target;\n    wp_nav.nav_roll_pitch_to_rate(roll_target_cd, pitch_target_cd, roll_target, pitch_target);\n\n    // send the targets to the lateral and forward navigation controllers\n    lateral_out = roll_target;\n    forward_out = pitch_target;\n}", "CodeBleu_score": 39.21317858508622}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t  float roll_out, pitch_out;\n  wp_nav.get_roll_pitch(roll_out, pitch_out);\n\n  // constrain target roll and pitch angles\n  roll_out = constrain_float(roll_out, -roll_limit, roll_limit);\n  pitch_out = constrain_float(pitch_out, -pitch_limit, pitch_limit);\n\n  // apply deadzone\n  roll_out = apply_deadzone(roll_out, roll_in_deadzone, 0.0f);\n  pitch_out = apply_deadzone(pitch_out, pitch_in_deadzone, 0.0f);\n\n  // normalize\n  float roll_out_norm = norm_constrain(roll_out, roll_out_max, roll_out_min);\n  float pitch_out_norm = norm_constrain(pitch_out, pitch_out_max, pitch_out_min);\n\n  // lateral and forward targets\n  lateral_out = roll_out_norm;\n  forward_out = pitch_out_norm;\n}", "CodeBleu_score": 32.75371827048581}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t  barometer.update();\n  if (depth_sensor_present) {\n    depth_sensor.update();\n  }\n\n  if (barometer.get_altitude() > 0) {\n    barometer.update_calibration();\n  }\n\n  if (depth_sensor_present) {\n    depth_sensor.healthy = barometer.healthy;\n  }\n}", "CodeBleu_score": 70.87256075342276}, {"code": "void Sub::read_barometer(){\n\t    if (failsafe.barometer) {\n        barometer.set_healthy(false);\n    } else {\n        barometer.update();\n        if (failsafe.depth) {\n            barometer.set_healthy(depth.healthy());\n        }\n        if (g.baro_type == BARO_BMP280 && barometer.get_altitude() > 0.0f) {\n            barometer.update_calibration(barometer.get_altitude());\n        }\n    }\n}", "CodeBleu_score": 41.079300738883475}, {"code": "void Sub::read_barometer(){\n\t    barometer.update();\n    barometer.get_altitude(barometer_alt);\n\n    // update barometer calibration\n    if (barometer_alt > 0.0f) {\n        barometer.update_calibration(barometer_alt);\n    }\n\n    // update sensor health status based on barometer health\n    if (depth_sensor.healthy()) {\n        depth_sensor.update();\n    }\n}", "CodeBleu_score": 55.21390375017112}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    if (!ahrs.have_inertial_nav) {\n        return false;\n    }\n\n    if (!motors.armed) {\n        // we can't know if we're in a good position if the motors are not armed\n        return true;\n    }\n\n    // check if the ekf is in constant position mode\n    if (inertial_nav.get_filter_status().flags.pred_horiz_pos_ok) {\n        // we're good\n        return true;\n    }\n\n    // if we're not in constant position mode, we need to know if the position estimate is good\n    // we use the EKF's status flags for this\n    return inertial_nav.get_filter_status().flags.pred_horiz_pos_ok &&\n           inertial_nav.get_filter_status().flags.pred_horiz_vel_ok;\n}", "CodeBleu_score": 46.617941563473806}, {"code": "bool Sub::ekf_position_ok(){\n\t    if (!ahrs.have_inertial_nav) {\n        return false;\n    }\n    if (!motors.armed) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.pred_horiz_pos_ok) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.horiz_pos_ok) {\n        return !inertial_nav.get_filter_status().flags.const_pos_mode;\n    }\n    return false;\n}", "CodeBleu_score": 46.52478100382691}, {"code": "bool Sub::ekf_position_ok(){\n\t    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n    if (!motors.armed()) {\n        return true;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_horiz_pos_good)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_horiz_vel_good)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_horiz_acc_good)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_terrain_alt)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_horiz_pos_ok)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_horiz_vel_ok)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_horiz_acc_ok)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_terrain_alt_ok)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_pos_horiz_rel)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_pos_horiz_abs)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_vel_horiz_abs)) {\n        return false;\n    }\n    if (is_negative(inertial_nav.get_filter_status().flags.pred_pos_horiz_abs_ok))", "CodeBleu_score": 53.506846202312474}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\n        return true;\n    }\n\n    // call parent gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the ahrs system is ready\n    if (!ahrs.pre_arm_check(display_failure)) {\n        return false;\n    }\n\n    // check if the EKF failsafe is active\n    if (rover.ekf_position_ok()) {\n        return true;\n    }\n\n    // check if the position estimate is valid\n    if (rover.inertial_nav.status() < AP_InertialNav::NAV_OK) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Position estimate bad\");\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 49.2013667938864}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (rover.control_mode->requires_position || rover.control_mode->requires_velocity) {\n        if (!AP_Arming::gps_checks(display_failure)) {\n            return false;\n        }\n        if (!ahrs.pre_arm_check(display_failure)) {\n            return false;\n        }\n        if (!rover.ekf_position_ok()) {\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 36.8140278406738}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // if we don't require position control, we're done\n    if (!rover.control_mode->requires_position()) {\n        return true;\n    }\n\n    // call the parent class's GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure position estimate is valid\n    if (!rover.ekf_position_ok()) {\n        check_failed(AP_Arming::CHECK_PREARM_POSITION, display_failure);\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 34.90179198479335}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (method == AP_Arming::Method::AUTO) {\n        method = _arm_method;\n    }\n\n    if (method == AP_Arming::Method::NONE) {\n        return false;\n    }\n\n    if (do_arming_checks) {\n        if (!check_pre_arm()) {\n            return false;\n        }\n    }\n\n    switch (method) {\n    case AP_Arming::Method::NONE:\n        return false;\n\n    case AP_Arming::Method::AUTO:\n        // fall through\n    case AP_Arming::Method::MAVLINK:\n        if (!arm_mavlink()) {\n            return false;\n        }\n        break;\n\n    case AP_Arming::Method::STEERING:\n        if (!arm_steering()) {\n            return false;\n        }\n        break;\n\n    case AP_Arming::Method::ANGLE:\n        if (!arm_angle()) {\n            return false;\n        }\n        break;\n\n    case AP_Arming::Method::GPS:\n        if (!arm_gps()) {\n            return false;\n        }\n        break;\n\n    case AP_Arming::Method::THROTTLE:\n        if (!arm_throttle()) {\n            return false;\n        }\n        break;\n\n    case AP_Arming::Method::INITIALIZE:\n        if (!arm_initial()) {\n            return false;\n        }\n        break;\n\n    case AP_Arming::Method::RC:\n        if (!arm_rc()) {\n            return false;\n        }\n        break;\n\n    case AP_Arming::Method::MAVLINK_COMPONENT:\n        if (!arm_mavlink_component()) {\n            return false;\n        }\n        break;\n    }\n\n    if (method != AP_Arming::Method::INITIALIZE) {\n        _arm_method = method;\n    }\n\n    return true;\n}", "CodeBleu_score": 36.22847141460453}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (method == AP_Arming::Method::AUTO) {\n        method = AP_Arming::Method::STANDARD;\n    }\n    if (method == AP_Arming::Method::STANDARD) {\n        // check if vehicle is armed\n        if (rover.ap.rc_calibration_complete) {\n            // if RC input is present, we can't arm\n            if (rover.g2.failsafe.radio || rover.g2.failsafe.throttle) {\n                return false;\n            }\n            // check if we're in the air\n            if (rover.ap.in_air) {\n                return false;\n            }\n            // check if motors are enabled\n            if (!rover.motors.armed()) {\n                return false;\n            }\n            // check if we're in the home and fence\n            if (!rover.mode_simple.in_home()) {\n                return false;\n            }\n            // check if we're in the fence\n            if (!rover.mode_simple.in_fence()) {\n                return false;\n            }\n            // check if we're on the ground\n            if (!rover.ap.on_ground) {\n                return false;\n            }\n            // check if we're on the surface\n            if (!rover.ap.on_surface) {\n                return false;\n            }\n            // check if we're in the safety fence\n            if (!rover.mode_simple.in_safety_fence()) {\n                return false;\n            }\n            // check if we're on the ground\n            if (!rover.ap.on_ground) {\n                return false;\n            }\n            // check if we're on the surface\n            if (!rover.ap.on_surface) {\n                return false;\n            }\n            // check if we're in the safety fence\n            if (!rover.mode_simple.in_safety_fence()) {\n                return false;\n            }\n            // check if we're in the safety fence\n            if (!rover.mode_simple.in_safety_fence", "CodeBleu_score": 34.398757740315546}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // set arming method\n    set_arming_method(method);\n\n    // return true if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // if arming checks are not required, or arming checks pass, arm immediately\n    if (!do_arming_checks || arming_checks()) {\n        // arm immediately\n        AP_Arming::set_arming_state(true);\n\n        // set arming method complete\n        set_arming_method_complete(true);\n\n        // set arming method complete\n        set_arming_method_complete(true);\n\n        // record arming timestamp\n        _arming_start_time_ms = millis();\n\n        // update arming status\n        update_arming_status();\n\n        // update soft armed status\n        update_soft_armed();\n\n        // send arm/disarm status text\n        send_arm_disarm_statustext();\n\n        // return true\n        return true;\n    }\n\n    // arming checks failed\n    return false;\n}", "CodeBleu_score": 41.37725345797052}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t  if (charging_allowed && !charging_enabled) {\n    // If charging is allowed but should not continue, it disables charging and records the time.\n    charging_enabled = false;\n    charging_disabled_time = millis();\n  } else if (!charging_allowed && charging_enabled) {\n    // If charging is not allowed, it retries enabling charging after a specified delay, checking the conditions again to decide whether to enable or continue disabling charging.\n    if (millis() - charging_disabled_time >= charging_retry_delay) {\n      charging_enabled = true;\n      charging_disabled_time = 0;\n    }\n  }\n}", "CodeBleu_score": 36.55621994097447}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed && !charging_enabled) {\n    if (shouldCharge()) {\n      enableCharging();\n      charging_enabled = true;\n    } else {\n      charging_disabled_at = millis();\n    }\n  } else if (!charging_allowed && charging_enabled) {\n    if (millis() - charging_disabled_at > DISABLE_CHARGING_DELAY) {\n      if (shouldCharge()) {\n        enableCharging();\n        charging_enabled = true;\n      } else {\n        disableCharging();\n        charging_enabled = false;\n      }\n    }\n  }\n}", "CodeBleu_score": 47.27802610670252}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed && !charging_enabled) {\n    if (checkShouldCharge()) {\n      charging_enabled = true;\n      charging_disabled_start_time = 0;\n    } else {\n      charging_disabled_start_time = millis();\n    }\n  } else if (!charging_allowed && charging_enabled) {\n    charging_enabled = false;\n    charging_disabled_start_time = 0;\n  }\n}", "CodeBleu_score": 31.294473150189184}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t  if (ros_running && size >= 4) {\n    uint16_t crc = CRC16.ccitt(message, size);\n    packetSerial.send(message, size);\n    packetSerial.send(&crc, sizeof(crc));\n  }\n}", "CodeBleu_score": 32.96434801273212}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros_running && size >= 4) {\n    uint16_t crc = CRC16.ccitt(message, size);\n    packetSerial.send(message, size + 2);\n    packetSerial.send((uint8_t *)&crc, 2);\n  }\n}", "CodeBleu_score": 34.99821053898591}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros::isStarted()) {\n    uint16_t crc = CRC16.ccitt(message, size);\n    uint8_t *messageWithCRC = (uint8_t *)malloc(size + 2);\n    memcpy(messageWithCRC, message, size);\n    messageWithCRC[size] = (uint8_t)(crc >> 8);\n    messageWithCRC[size + 1] = (uint8_t)(crc & 0xFF);\n    packetSerial.send(messageWithCRC, size + 2);\n    free(messageWithCRC);\n  }\n}", "CodeBleu_score": 50.54265607570279}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  soundSerial.flush();\n  soundSerial.println(\"AT+VRESET\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+VLST\");\n  delay(1000);\n  soundSerial.println(\"AT+V", "CodeBleu_score": 41.53050440628407}, {"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  soundSerial.flush();\n  if (myMP3.begin()) {\n    numSdTracks = myMP3.read();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 42.95014443851646}, {"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  soundSerial.flush();\n  if (myMP3.begin()) {\n    numSdTracks = myMP3.numSdTracks();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 44.07285631991496}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying) {\n\t\treturn active_sounds.size();\n\t}\n\tmyMP3.play(active_sounds.back());\n\tactive_sounds.pop_back();\n\treturn active_sounds.size();\n}", "CodeBleu_score": 42.67325349738649}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t} else {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.30795718535374}, {"code": "int MP3Sound::processSounds(){\n\t    if (active_sounds.size() == 0 || myMP3.isPlaying) {\n        return active_sounds.size();\n    }\n    else {\n        myMP3.play(active_sounds.back());\n        active_sounds.pop_back();\n        return active_sounds.size();\n    }\n}", "CodeBleu_score": 46.69349189203949}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  bool command_handled = true;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    // clean up existing memory-mapped file\n    if (d->camera_mmap_file != NULL) {\n      munmap(d->camera_mmap_file, d->camera_mmap_file_size);\n      close(d->camera_mmap_file_fd);\n    }\n    d->camera_mmap_file = NULL;\n    d->camera_mmap_file_size = 0;\n    d->camera_mmap_file_fd = -1;\n    // set up new memory-mapped file\n    if (r->data_length == 0) {\n      d->camera_mmap_file = NULL;\n      d->camera_mmap_file_size = 0;\n      d->camera_mmap_file_fd = -1;\n    } else {\n      d->camera_mmap_file_size = r->data_length;\n      d->camera_mmap_file_fd = open(r->data, O_RDWR | O_CREAT, 0644);\n      if (d->camera_mmap_file_fd < 0) {\n        d->camera_mmap_file = NULL;\n        d->camera_mmap_file_size = 0;\n        d->camera_mmap_file_fd = -1;\n      } else {\n        ftruncate(d->camera_mmap_file_fd, d->camera_mmap_file_size);\n        d->camera_mmap_file = mmap(NULL, d->camera_mmap_file_size, PROT_READ | PROT_WRITE, MAP_SHARED, d->camera_mmap_file_fd, 0);\n        if (d->camera_mmap_file == MAP_FAILED) {\n          d->camera_mmap_file =", "CodeBleu_score": 41.9289881150367}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *ac = (WbAbstractCamera *)d;\n  bool handled = false;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (ac->mmap_file)\n      munmap(ac->mmap_file, ac->mmap_size);\n    ac->mmap_file = mmap(NULL, ac->mmap_size, PROT_READ, MAP_SHARED, ac->mmap_fd, 0);\n    if (ac->mmap_file == MAP_FAILED)\n      ac->mmap_file = NULL;\n    ac->mmap_file_size = ac->mmap_size;\n    handled = true;\n  } else {\n    ac->command_handled = false;\n  }\n  return handled;\n}", "CodeBleu_score": 42.41686011233228}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t    if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n        if (d->camera_memory_mapped_file) {\n            image_cleanup(d);\n        }\n        d->camera_memory_mapped_file = r;\n        d->camera_memory_mapped_file_size = r->size;\n        image_setup(d);\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 44.78970551945302}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height;\n  wb_robot_mutex_lock();\n  height = d->camera->height;\n  wb_robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 47.3024130931925}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  if (d->camera) {\n    wb_robot_mutex_lock(d->robot);\n    if (d->camera->data)\n      height = d->camera->data->height;\n    wb_robot_mutex_unlock(d->robot);\n  }\n  return height;\n}", "CodeBleu_score": 45.21341849569323}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height;\n  wb_robot_mutex_lock();\n  if (d->camera)\n    height = d->camera->height;\n  else\n    height = -1;\n  wb_robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 51.282781179863356}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  wb_robot_mutex_lock();\n  WbDevice *device = wb_robot_get_device(tag);\n  if (device == NULL || device->nodeType != WB_NODE_ACCELEROMETER) {\n    wb_robot_mutex_unlock();\n    wb_error(\"wb_accelerometer_get_sampling_period: invalid device tag (%d)\", tag);\n    return -1;\n  }\n  wb_accelerometer_get_struct(device)->samplingPeriod = wb_robot_get_basic_time_step();\n  wb_robot_mutex_unlock();\n  return wb_accelerometer_get_struct(device)->samplingPeriod;\n}", "CodeBleu_score": 47.71437147523896}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  wb_accelerometer_t *accelerometer;\n  wb_robot_mutex_lock();\n  accelerometer = wb_robot_get_device(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    wb_fprintf(stderr, \"wb_accelerometer_get_sampling_period: invalid device tag (%d)\n\", tag);\n  wb_robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 56.76412583531302}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  wb_robot_mutex_lock(tag);\n  WbDevice *device = wb_robot_get_device(tag);\n  if (device && device->type == WB_NODE_ACCELEROMETER) {\n    WbAccelerometer *accelerometer = (WbAccelerometer *)device->data;\n    wb_robot_mutex_unlock(tag);\n    return accelerometer->sampling_period;\n  } else {\n    wb_robot_mutex_unlock(tag);\n    wb_error(\"Invalid device tag (%d).\", tag);\n    return -1;\n  }\n}", "CodeBleu_score": 42.67307725709454}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result = string(dms);\n    free(dms);\n    return result;\n}", "CodeBleu_score": 45.238715163656906}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsString(dms);\n    free(dms);\n    return dmsString;\n}", "CodeBleu_score": 40.9693929303718}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = string(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 44.86400676137465}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  const dReal *p0 = dGeomGetOffsetPosition (g);\n  dReal dx = x - p0[0];\n  dReal dy = y - p0[1];\n  dReal dz = z - p0[2];\n  dReal ax = dGeomBoxGetLengths (g)[0] * 0.5;\n  dReal ay = dGeomBoxGetLengths (g)[1] * 0.5;\n  dReal az = dGeomBoxGetLengths (g)[2] * 0.5;\n  dReal d, d0, d1;\n  int i;\n  dReal n[3];\n  dReal p[3];\n  dReal u[3];\n  dReal v[3];\n  dReal w[3];\n  dReal *nrm = plane;\n  dReal *dst = plane + 3;\n  dReal *pnt = p;\n  dReal *up = u;\n  dReal *vp = v;\n  dReal *wp = w;\n  dReal *nrmp = nrm;\n  dReal *dstp = dst;\n  dReal *pntp = pnt;\n  dReal *upp = up;\n  dReal *vpp = vp;\n  dReal *wpp = wp;\n  dReal *nrmpp = nrmp;\n  dReal *dstpp = dstp;\n  dReal *pntpp = pntp;\n  dReal *uppp = upp;\n  dReal *vppp = vpp;\n  dReal *wppp = wpp;\n  dReal *nrmppp = nrmpp;\n  dReal *dstppp = dstpp;\n  dReal *pntppp = pntpp;\n  dReal *upppp = uppp;\n  dReal *vpppp = vppp;\n  dReal *wpppp = wppp;\n  dReal *nrmpppp = nrmppp;\n  dReal *dstpppp = dstppp;\n  dReal *pntpppp = pntppp", "CodeBleu_score": 28.581871347085475}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdReal dx, dy, dz;\n\tdReal x0, y0, z0;\n\tdReal x1, y1, z1;\n\tdReal x2, y2, z2;\n\tdReal x3, y3, z3;\n\tdReal x4, y4, z4;\n\tdReal x5, y5, z5;\n\tdReal x6, y6, z6;\n\tdReal x7, y7, z7;\n\tdReal x8, y8, z8;\n\tdReal x9, y9, z9;\n\tdReal x10, y10, z10;\n\tdReal x11, y11, z11;\n\tdReal x12, y12, z12;\n\tdReal x13, y13, z13;\n\tdReal x14, y14, z14;\n\tdReal x15, y15, z15;\n\tdReal x16, y16, z16;\n\tdReal x17, y17, z17;\n\tdReal x18, y18, z18;\n\tdReal x19, y19, z19;\n\tdReal x20, y20, z20;\n\tdReal x21, y21, z21;\n\tdReal x22, y22, z22;\n\tdReal x23, y23, z23;\n\tdReal x24, y24, z24;\n\tdReal x25, y25, z25;\n\tdReal x26, y26, z26;\n\tdReal x27, y27, z27;\n\tdReal x28, y28, z28;\n\tdReal x29, y29, z29;\n\tdReal x30, y30, z30;\n\tdReal x31, y31, z31;\n\tdReal x32, y32, z32;\n\tdReal", "CodeBleu_score": 3.157300116374026}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdVector3 p;\n\tdReal dx, dy, dz;\n\tdGeomID g2;\n\tdReal x0, y0, z0;\n\tdReal x1, y1, z1;\n\tdReal x2, y2, z2;\n\tdReal x3, y3, z3;\n\tdReal x4, y4, z4;\n\tdReal x5, y5, z5;\n\tdReal x6, y6, z6;\n\tdReal x7, y7, z7;\n\tdReal x8, y8, z8;\n\tdReal x9, y9, z9;\n\tdReal x10, y10, z10;\n\tdReal x11, y11, z11;\n\tdReal x12, y12, z12;\n\tdReal x13, y13, z13;\n\tdReal x14, y14, z14;\n\tdReal x15, y15, z15;\n\tdReal x16, y16, z16;\n\tdReal x17, y17, z17;\n\tdReal x18, y18, z18;\n\tdReal x19, y19, z19;\n\tdReal x20, y20, z20;\n\tdReal x21, y21, z21;\n\tdReal x22, y22, z22;\n\tdReal x23, y23, z23;\n\tdReal x24, y24, z24;\n\tdReal x25, y25, z25;\n\tdReal x26, y26, z26;\n\tdReal x27, y27, z27;\n\tdReal x28, y28, z28;\n\tdReal x29, y29, z29;\n\tdReal x30, y30, z30;\n\tdReal x31, y31, z31;\n\tdReal", "CodeBleu_score": 3.527963549822232}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dImmersionData data;\n  dImmersionGeom *geom;\n  int result;\n\n  D_ASSERT (box != NULL);\n  D_ASSERT (box->body != NULL);\n  D_ASSERT (flags == dImmersionChecking || flags == dImmersionChecking_1);\n  D_ASSERT (immersion != NULL);\n\n  data.flags = flags;\n  data.box = box;\n  data.immersion = immersion;\n  data.fluidPlane = fluidPlane;\n\n  geom = dAllocImmersionGeom ();\n  dImmersionInitGeom (geom, box->body);\n\n  result = dImmersionCheck (&data, geom);\n\n  dFreeImmersionGeom (geom);\n\n  return result;\n}", "CodeBleu_score": 42.85418836438837}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dImmersionGeom immersionGeom;\n  dImmersionData data;\n  int result;\n  dGeomID geom;\n  dReal boxHalfLengths[3];\n  dReal boxCenter[3];\n  dReal boxOrientation[3];\n  dReal boxOrientationMatrix[12];\n  dReal boxOrientationMatrixTranspose[12];\n  dReal boxOrientationMatrixTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTransposeTranspose[12];\n  dReal boxOrientationMatrixTransposeTransposeTranspose", "CodeBleu_score": 16.610364707317252}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dImmersionGeom imm;\n  dImmersionData data;\n  int result;\n\n  D_ASSERT (box && box->body);\n  D_ASSERT (dIsValidImmersionFlags (flags));\n\n  imm.flags = flags;\n  imm.immersion = immersion;\n  imm.box = box;\n  imm.fluidPlane = fluidPlane;\n\n  data.imm = &imm;\n  data.flags = flags;\n  data.performImmersionChecking = dImmerseBox_PerformImmersionChecking;\n\n  result = dImmerse (&data);\n\n  return result;\n}", "CodeBleu_score": 43.45279470902751}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dReal *p1, *p2;\n  dReal a, b, c, d, e, f;\n  dReal A, B, C, D, E, F;\n  dReal s, t, u, v;\n  dReal r1, r2;\n  dReal t1, t2;\n  dReal *p;\n  dReal *q;\n  dReal *r;\n  dReal *s;\n  dReal *t;\n  dReal *u;\n  dReal *v;\n  dReal *w;\n  dReal *x;\n  dReal *y;\n  dReal *z;\n  dReal *w1;\n  dReal *w2;\n  dReal *w3;\n  dReal *w4;\n  dReal *w5;\n  dReal *w6;\n  dReal *w7;\n  dReal *w8;\n  dReal *w9;\n  dReal *w10;\n  dReal *w11;\n  dReal *w12;\n  dReal *w13;\n  dReal *w14;\n  dReal *w15;\n  dReal *w16;\n  dReal *w17;\n  dReal *w18;\n  dReal *w19;\n  dReal *w20;\n  dReal *w21;\n  dReal *w22;\n  dReal *w23;\n  dReal *w24;\n  dReal *w25;\n  dReal *w26;\n  dReal *w27;\n  dReal *w28;\n  dReal *w29;\n  dReal *w30;\n  dReal *w31;\n  dReal *w32;\n  dReal *w33;\n  dReal *w34;\n  dReal *w35;\n  dReal *w36;\n  dReal *w37;\n  dReal *w38;\n  dReal *w39;\n  dReal *w40;\n  dReal *w41;", "CodeBleu_score": 12.819548466427005}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmersionGeom *imm;\n\tdReal *a, *b, *c, *d, *e, *f, *g, *h, *i, *j, *k, *l, *m, *n, *o, *p, *q, *r, *s, *t, *u, *v, *w, *x, *y, *z;\n\tdReal *a1, *b1, *c1, *d1, *e1, *f1, *g1, *h1, *i1, *j1, *k1, *l1, *m1, *n1, *o11, *p1, *q1, *r1, *s1, *t1, *u1, *v1, *w1, *x1, *y1, *z1;\n\tdReal *a2, *b2, *c2, *d2, *e2, *f2, *g2, *h2, *i2, *j2, *k2, *l2, *m2, *n2, *o22, *p2, *q2, *r2, *s2, *t2, *u2, *v2, *w2, *x2, *y2, *z2;\n\tdReal *a3, *b3, *c3, *d3, *e3, *f3, *g3, *h3, *i3, *j3, *k3, *l3, *m3, *n3, *o33, *p3, *q3, *r3, *s3, *t3, *u3, *v3, *w3, *x3, *y3, *z3;\n\tdReal *a4, *b4, *c4, *d4, *e4, *f4, *g4, *h4, *i4, *j4, *k4, *l4, *m4, *n4, *o44, *p4, *q4, *r4, *s4, *t4, *u4, *v4,", "CodeBleu_score": 5.070771301685183}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdGeomID g1, g2;\n\tdReal m1[12], m2[12];\n\tdReal *p1, *p2;\n\tdReal r1, r2;\n\tdReal s1, s2;\n\tdReal s12, s21;\n\tdReal s12_2, s21_2;\n\tdReal s12_4, s21_4;\n\tdReal c1, c2;\n\tdReal c12, c21;\n\tdReal c12_2, c21_2;\n\tdReal c12_4, c21_4;\n\tdReal c12_8, c21_8;\n\tdReal d1, d2;\n\tdReal d12, d21;\n\tdReal d12_2, d21_2;\n\tdReal d12_4, d21_4;\n\tdReal d12_8, d21_8;\n\tdReal d12_16, d21_16;\n\tdReal d12_32, d21_32;\n\tdReal d12_64, d21_64;\n\tdReal d12_128, d21_128;\n\tdReal d12_256, d21_256;\n\tdReal d12_512, d21_512;\n\tdReal d12_1024, d21_1024;\n\tdReal d12_2048, d21_2048;\n\tdReal d12_4096, d21_4096;\n\tdReal d12_8192, d21_8192;\n\tdReal d12_16384, d21_16384;\n\tdReal d12_32768, d21_32768;\n\tdReal d12_65536, d21_6", "CodeBleu_score": 4.923460652943942}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal tanTheta02 = tanTheta0 * tanTheta0;\n\tdReal sinTheta12 = sinTheta1 * sinTheta1;\n\n\tdReal a = zIOverR2 + tanTheta02;\n\tdReal b = zIOverR2 + tanTheta02 + sinTheta12;\n\n\tsHemisphereIntegrationData data(zIOverR2, tanTheta02, sinTheta12, a, b);\n\n\treturn (simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(data, 0.0, 1.0, 1e-10) +\n\t\t\tsimpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(data, 1.0, 2.0, 1e-10)) / 2.0;\n}", "CodeBleu_score": 48.52263908079634}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t  dReal z = zIOverR * m_radius;\n  dReal z2 = z * z;\n  dReal tanTheta1 = z / m_radius;\n  dReal sinTheta0 = sqrt(1 - tanTheta0 * tanTheta0);\n  dReal sinTheta1Squared = sinTheta1 * sinTheta1;\n  dReal sinTheta0Squared = sinTheta0 * sinTheta0;\n  dReal sinTheta1SquaredMinusSinTheta0Squared = sinTheta1Squared - sinTheta0Squared;\n  dReal tanTheta1Squared = tanTheta1 * tanTheta1;\n  dReal tanTheta0Squared = tanTheta0 * tanTheta0;\n  dReal tanTheta1SquaredMinusTanTheta0Squared = tanTheta1Squared - tanTheta0Squared;\n\n  dReal sinTheta0CosTheta1 = sinTheta0 * cos(m_theta);\n  dReal sinTheta1CosTheta1 = sinTheta1 * cos(m_theta);\n  dReal tanTheta0CosTheta1 = tanTheta0 * cos(m_theta);\n  dReal tanTheta1CosTheta1 = tanTheta1 * cos(m_theta);\n\n  dReal sinTheta0CosTheta1Squared = sinTheta0CosTheta1 * sinTheta0CosTheta1;\n  dReal sinTheta1CosTheta1Squared = sinTheta1CosTheta1 * sinTheta1CosTheta1;\n  dReal tanTheta0CosTheta1Squared = tanTheta0CosTheta1 * tanTheta0CosTheta1;\n  dReal tanTheta1CosTheta1Squared = tanTheta1CosTheta1 * tanTheta1CosTheta1;\n\n  dReal sinTheta0SquaredMinusSinTheta1Squared = sinTheta0Squared - sinTheta1Squared;\n  dReal tanTheta0SquaredMinusTanTheta1Squared = tanTheta0Squared - tanTheta1Squared;\n\n  dReal sinTheta0CosTheta1MinusSinTheta1CosTheta1 = sinTheta0Cos", "CodeBleu_score": 36.43129105248295}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    sHemisphereIntegrationData data;\n    data.zIOverR = zIOverR;\n    data.tanTheta0 = tanTheta0;\n    data.sinTheta1 = sinTheta1;\n    data.cosTheta1 = sqrt(1.0 - sinTheta1 * sinTheta1);\n\n    // Calculate the volume of the immersed hemisphere using Simpson's rule\n    dReal volume = simpson(data, 0.0, 1.0, 100);\n\n    // Normalize the volume to the hemisphere's surface area\n    volume /= (2.0 * M_PI * (1.0 - tanTheta0));\n\n    return volume;\n}", "CodeBleu_score": 29.659765394093963}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    // Check if the immersion depth ratio is within the valid range\n    if (zIOverR <= 0.0 || zIOverR >= 1.0) {\n        return 0.0;\n    }\n\n    // Check if the tangent of the initial angle is within the valid range\n    if (tanTheta0 <= 0.0) {\n        return 0.0;\n    }\n\n    // Check if the sine of the final angle is within the valid range\n    if (sinTheta1 <= 0.0 || sinTheta1 >= 1.0) {\n        return 0.0;\n    }\n\n    // Check if the volume is within the valid range\n    if (volume <= 0.0) {\n        return 0.0;\n    }\n\n    // Calculate the initial and final angles\n    dReal theta0 = atan(tanTheta0);\n    dReal theta1 = asin(sinTheta1);\n\n    // Calculate the radius of the hemisphere\n    dReal r = radius * sqrt(1.0 - zIOverR * zIOverR);\n\n    // Calculate the x-coordinate of the buoyancy center\n    dReal xBuoyancyCenter = r * (theta1 - theta0) / (2.0 * M_PI) * (1.0 - zIOverR * zIOverR) * volume;\n\n    // Adjust the x-coordinate by the volume\n    xBuoyancyCenter /= volume;\n\n    // Return the x-coordinate of the buoyancy center\n    return xBuoyancyCenter;\n}", "CodeBleu_score": 39.50396879856508}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  dReal xBuoyancyCenter;\n  sHemisphereIntegrationData hemisphereIntegrationData;\n  hemisphereIntegrationData.zIOverR = zIOverR;\n  hemisphereIntegrationData.tanTheta0 = tanTheta0;\n  hemisphereIntegrationData.sinTheta1 = sinTheta1;\n  hemisphereIntegrationData.volume = volume;\n  xBuoyancyCenter = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(hemisphereIntegrationData, 0.0, 2.0 * M_PI, 1000);\n  return xBuoyancyCenter / (M_PI * zIOverR * zIOverR);\n}", "CodeBleu_score": 47.58750686805615}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal xCenterOfMass = 0.0;\n\n\tif (zIOverR < 1.0) {\n\t\tdReal zOverR = zIOverR * radius;\n\t\tdReal zOverR2 = zOverR * zOverR;\n\t\tdReal zOverR3 = zOverR2 * zOverR;\n\n\t\tdReal tanTheta02 = tanTheta0 * tanTheta0;\n\t\tdReal tanTheta03 = tanTheta02 * tanTheta0;\n\t\tdReal tanTheta04 = tanTheta03 * tanTheta0;\n\t\tdReal tanTheta05 = tanTheta04 * tanTheta0;\n\n\t\tdReal tanTheta12 = tanTheta02 * tanTheta1 * tanTheta1;\n\t\tdReal tanTheta13 = tanTheta12 * tanTheta1;\n\t\tdReal tanTheta14 = tanTheta13 * tanTheta1;\n\t\tdReal tanTheta15 = tanTheta14 * tanTheta1;\n\n\t\tdReal tanTheta2 = tanTheta02 * tanTheta1;\n\t\tdReal tanTheta3 = tanTheta2 * tanTheta1;\n\t\tdReal tanTheta4 = tanTheta3 * tanTheta1;\n\t\tdReal tanTheta5 = tanTheta4 * tanTheta1;\n\n\t\tdReal sinTheta12 = sinTheta1 * sinTheta1;\n\t\tdReal sinTheta13 = sinTheta12 * sinTheta1;\n\t\tdReal sinTheta14 = sinTheta13 * sinTheta1;\n\t\tdReal sinTheta15 = sinTheta14 * sinTheta1;\n\n\t\tdReal sinTheta2 = sinTheta1 * sinTheta0;\n\t\tdReal sinTheta3 = sinTheta2 * sinTheta1;\n\t\tdReal sinTheta4 = sinTheta3 * sinTheta1;\n\t\tdReal sinTheta5 = sinTheta4 * sinTheta1;\n\n\t\tdReal sinTheta02 = sinTheta0 * sinTheta0;\n\t\tdReal sinTheta03 = sinTheta02 * sinTheta0;\n\t\tdReal sinTheta04 = sinTheta03 * sinTheta0;\n\t\td", "CodeBleu_score": 35.92794635591851}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdReal depth;\n\tdReal radius;\n\tdReal volume;\n\tdReal tangent;\n\tdReal sin_final;\n\tdReal sin_initial;\n\tdReal cos_initial;\n\tdReal cos_final;\n\tdReal x_buoyancy_center;\n\tdReal y_buoyancy_center;\n\tdReal z_buoyancy_center;\n\tdReal x_buoyancy_center_scaled;\n\tdReal y_buoyancy_center_scaled;\n\tdReal z_buoyancy_center_scaled;\n\tdReal x_buoyancy_center_adjusted;\n\tdReal y_buoyancy_center_adjusted;\n\tdReal z_buoyancy_center_adjusted;\n\tdReal x_buoyancy_center_adjusted_scaled;\n\tdReal y_buoyancy_center_adjusted_scaled;\n\tdReal z_buoyancy_center_adjusted_scaled;\n\tdReal x_buoyancy_center_adjusted_scaled_adjusted;\n\tdReal y_buoyancy_center_adjusted_scaled_adjusted;\n\tdReal z_buoyancy_center_adjusted_scaled_adjusted;\n\tdReal x_buoyancy_center_adjusted_scaled_adjusted_scaled;\n\tdReal y_buoyancy_center_adjusted_scaled_adjusted_scaled;\n\tdReal z_buoyancy_center_adjusted_scaled_adjusted_scaled;\n\tdReal x_buoyancy_center_adjusted_scaled_adjusted_scaled_adjusted;\n\tdReal y_buoyancy_center_adjusted_scaled_adjusted_scaled_adjusted;\n\tdReal z_buoyancy_center_adjusted_scaled_adjusted_scaled_adjusted;\n\tdReal x_buoyancy_center_adjusted_scaled_adjusted_scaled_adjusted_scaled;", "CodeBleu_score": 4.90865660153229}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n\tdReal depth;\n\tdReal radius;\n\tdReal volume;\n\tdReal tangent;\n\tdReal sine;\n\tdReal x;\n\tdReal y;\n\tdReal z;\n\tdReal x0;\n\tdReal y0;\n\tdReal z0;\n\tdReal x1;\n\tdReal y1;\n\tdReal z1;\n\tdReal x2;\n\tdReal y2;\n\tdReal z2;\n\tdReal x3;\n\tdReal y3;\n\tdReal z3;\n\tdReal x4;\n\tdReal y4;\n\tdReal z4;\n\tdReal x5;\n\tdReal y5;\n\tdReal z5;\n\tdReal x6;\n\tdReal y6;\n\tdReal z6;\n\tdReal x7;\n\tdReal y7;\n\tdReal z7;\n\tdReal x8;\n\tdReal y8;\n\tdReal z8;\n\tdReal x9;\n\tdReal y9;\n\tdReal z9;\n\tdReal x10;\n\tdReal y10;\n\tdReal z10;\n\tdReal x11;\n\tdReal y11;\n\tdReal z11;\n\tdReal x12;\n\tdReal y12;\n\tdReal z12;\n\tdReal x13;\n\tdReal y13;\n\tdReal z13;\n\tdReal x14;\n\tdReal y14;\n\tdReal z14;\n\tdReal x15;\n\tdReal y15;\n\tdReal z15;\n\tdReal x16;\n\tdReal y16;\n\tdReal z16;\n\tdReal x17;\n\tdReal y17;\n\tdReal z17;\n\tdReal x18;\n\tdReal y18;\n\tdReal z18;\n\tdReal x19;\n\tdReal y19;\n\tdReal z19;\n\tdReal x20;\n\tdReal y", "CodeBleu_score": 7.2530007315864635}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdReal *p1, *p2, *p3;\n\tdReal *n1, *n2, *n3;\n\tdReal *v1, *v2, *v3;\n\tdReal *v1n, *v2n, *v3n;\n\tdReal *v1v, *v2v, *v3v;\n\tdReal *v1vn, *v2vn, *v3vn;\n\tdReal *v1vnv, *v2vnv, *v3vnv;\n\tdReal *v1vnvn, *v2vnvn, *v3vnvn;\n\tdReal *v1vnvnv, *v2vnvnv, *v3vnvnv;\n\tdReal *v1vnvnvn, *v2vnvnvn, *v3vnvnvn;\n\tdReal *v1vnvnvnv, *v2vnvnvnv, *v3vnvnvnv;\n\tdReal *v1vnvnvnvn, *v2vnvnvnvn, *v3vnvnvnvn;\n\tdReal *v1vnvnvnvnv, *v2vnvnvnvnv, *v3vnvnvnvnv;\n\tdReal *v1vnvnvnvnvn, *v2vnvnvnvnvn, *v3vnvnvnvnvn;\n\tdReal *v1vnvnvnvnvnv, *v2vnvnvnvnvnv, *v3vnvnvnvnvnv;\n\tdReal *v1vnvnvnvnvnvn, *v2vnvnvnvnvnvn, *v3vnvnvnvnvnvn;\n\tdReal *v1vnvnvnvnvnvnv, *v2vnvnvnvnvnvnv, *v3vnvnvnvnvnvnv;\n\tdReal *v1vnvnvnvnvnvnvn, *v2vnvnvnvnvnvnvn, *v3vnvnvnvnvnvnvn;\n\tdReal *v1vnvnvnvnvnvnvnv, *v2vnvnvnvnvnvnvnv, *v3vnv", "CodeBleu_score": 6.551077460050572}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t    // Get the sleep duration in milliseconds from the input\n    double duration;\n    if (!getInput(\"duration\", duration)) {\n        return SUCCESS;\n    }\n\n    // Set the node status to RUNNING\n    setStatus(RUNNING);\n\n    // Start a timer\n    timer_.add(std::chrono::milliseconds(static_cast<int>(duration)));\n\n    // Set a callback to emit a wake-up signal when the timer expires\n    timer_.addCallback(std::bind(&SleepNode::emitWakeUpSignal, this));\n\n    // Set a callback to ensure the timer_waiting_ flag is reset when the timer is aborted\n    timer_.addAbortCallback(std::bind(&SleepNode::resetTimerWaitingFlag, this));\n\n    return RUNNING;\n}", "CodeBleu_score": 40.004480025479225}, {"code": "NodeStatus SleepNode::onStart(){\n\t    // Get the sleep duration in milliseconds from the input\n    double duration_ms;\n    if (!getInput(\"duration\", duration_ms)) {\n        // Return SUCCESS if the duration is missing or non-positive\n        return SUCCESS;\n    }\n\n    // Set the node status to RUNNING\n    setStatus(RUNNING);\n\n    // Start a timer\n    timer_.add(std::chrono::milliseconds(static_cast<int>(duration_ms)),\n               [this](const ros::TimerEvent& event) {\n                   // Emit a wake-up signal\n                   emitWakeUpSignal();\n               });\n\n    // Set a callback to ensure the timer_waiting_ flag is reset\n    timer_waiting_ = true;\n    timer_.setOnStopCallback([this]() { timer_waiting_ = false; });\n\n    // Return SUCCESS\n    return SUCCESS;\n}", "CodeBleu_score": 46.82322271165166}, {"code": "NodeStatus SleepNode::onStart(){\n\t  int64_t sleep_duration_ms;\n  if (!getInput(\"sleep_duration_ms\", sleep_duration_ms)) {\n    return SUCCESS;\n  }\n  if (sleep_duration_ms <= 0) {\n    return SUCCESS;\n  }\n  setStatus(RUNNING);\n  timer_.add(std::chrono::milliseconds(sleep_duration_ms),\n             [this]() { emitWakeUpSignal(); });\n  timer_waiting_ = true;\n  return SUCCESS;\n}", "CodeBleu_score": 38.44608441541857}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  // Get the entry from the blackboard\n  Entry* entry = config().blackboard->getEntry(config().entry_name);\n  // Check if the entry exists\n  if (entry == nullptr) {\n    return NodeStatus::FAILURE;\n  }\n  // Lock the entry's mutex\n  entry->mutex.lock();\n  // Check if the entry's sequence ID has changed\n  if (entry->sequence_id != config().sequence_id) {\n    // Update the stored sequence ID\n    config().sequence_id = entry->sequence_id;\n    // Unlock the entry's mutex\n    entry->mutex.unlock();\n    // Return success\n    return NodeStatus::SUCCESS;\n  }\n  // Unlock the entry's mutex\n  entry->mutex.unlock();\n  // Return failure\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 44.39048683679834}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  Entry* entry = blackboard->getEntry(entry_name);\n  if (entry == nullptr) {\n    return NodeStatus::FAILURE;\n  }\n  entry->mutex.lock();\n  if (entry->sequence_id != sequence_id) {\n    sequence_id = entry->sequence_id;\n    entry->mutex.unlock();\n    return NodeStatus::SUCCESS;\n  }\n  entry->mutex.unlock();\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 40.13948337188191}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  if (entry_.isNull()) {\n    entry_ = config().blackboard->getEntry(config().entry_name);\n  }\n  if (entry_.isNull()) {\n    return NodeStatus::FAILURE;\n  }\n  entry_.lock();\n  if (entry_.getSequenceID() != sequence_id_) {\n    sequence_id_ = entry_.getSequenceID();\n    entry_.unlock();\n    return NodeStatus::SUCCESS;\n  }\n  entry_.unlock();\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 45.28670267761725}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return static_cast<size_t>(std::max(success_threshold_ * children_nodes_.size(), 0));\n    } else {\n        return static_cast<size_t>(success_threshold_);\n    }\n}", "CodeBleu_score": 61.61178271958555}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return std::max(0, static_cast<int>(children_nodes_.size()) + success_threshold_);\n    }\n    return success_threshold_;\n}", "CodeBleu_score": 56.90829819345681}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  if (success_threshold_ < 0) {\n    return std::max(0, static_cast<int>(children_nodes_.size() + success_threshold_));\n  }\n  return success_threshold_;\n}", "CodeBleu_score": 55.038994615450086}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n    std::chrono::milliseconds elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - lastHeartbeatTime);\n    if (elapsed.count() > 1000) {\n      if (heartbeatActive) {\n        heartbeatActive = false;\n        enableAllHooks(false);\n      }\n    } else {\n      if (!heartbeatActive) {\n        heartbeatActive = true;\n        enableAllHooks(true);\n      }\n    }\n  }\n}", "CodeBleu_score": 44.798537767271704}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    auto now = std::chrono::system_clock::now();\n    auto elapsed = now - lastHeartbeatTime;\n    if (elapsed > std::chrono::milliseconds(1000)) {\n      // Heartbeat has stopped\n      enableAllHooks(false);\n    } else if (elapsed < std::chrono::milliseconds(1000)) {\n      // Heartbeat is still active\n      enableAllHooks(true);\n    }\n  }\n}", "CodeBleu_score": 51.64724948292757}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        auto now = std::chrono::system_clock::now();\n        if (now - lastHeartbeat < std::chrono::milliseconds(1000)) {\n            enableAllHooks(true);\n        } else {\n            enableAllHooks(false);\n        }\n    }\n}", "CodeBleu_score": 43.650198126627735}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> blackboards_dump;\n    std::vector<std::string> bb_names = splitString(bb_list, ',');\n    for (const auto& bb_name : bb_names) {\n        auto it = _p->subtrees.find(bb_name);\n        if (it != _p->subtrees.end()) {\n            auto subtree = it->second.lock();\n            if (subtree) {\n                auto bb = subtree->blackboard();\n                if (bb) {\n                    nlohmann::json json_obj;\n                    json_obj[bb_name] = ExportBlackboardToJSON(bb);\n                    blackboards_dump = json_obj.dump();\n                }\n            }\n        }\n    }\n    return blackboards_dump;\n}", "CodeBleu_score": 56.175820004647946}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    // Split the input string into a vector of blackboard names\n    std::vector<std::string> bb_names = splitString(bb_list, ',');\n\n    // Create a JSON object to store the blackboard data\n    nlohmann::json json_obj;\n\n    // Iterate through the blackboard names\n    for (const auto& bb_name : bb_names) {\n        // Find the subtree with the given blackboard name\n        auto it = _p->subtrees.find(bb_name);\n        if (it != _p->subtrees.end()) {\n            // Lock the subtree\n            auto subtree_lock = it->second.lock();\n            if (subtree_lock) {\n                // Export the blackboard to JSON\n                nlohmann::json json_bb = ExportBlackboardToJSON(subtree_lock);\n                // Add the blackboard to the JSON object\n                json_obj[bb_name] = json_bb;\n            }\n        }\n    }\n\n    // Convert the JSON object to MessagePack format\n    std::vector<uint8_t> msgpack_data = json_obj.dump();\n\n    return msgpack_data;\n}", "CodeBleu_score": 55.76750214051634}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> msgpack_dump;\n    std::vector<std::string> bb_names;\n    boost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n    for (const auto& bb_name : bb_names) {\n        auto it = _p->subtrees.find(bb_name);\n        if (it != _p->subtrees.end()) {\n            auto subtree = it->second.lock();\n            if (subtree) {\n                auto blackboard = subtree->blackboard();\n                if (blackboard) {\n                    nlohmann::json json_dump;\n                    json_dump[bb_name] = ExportBlackboardToJSON(*blackboard);\n                    auto json_str = json_dump.dump();\n                    auto msgpack_str = nlohmann::json::to_msgpack(json_str);\n                    msgpack_dump.insert(msgpack_dump.end(), msgpack_str.begin(), msgpack_str.end());\n                }\n            }\n        }\n    }\n    return msgpack_dump;\n}", "CodeBleu_score": 54.52047301451333}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::lock_guard<std::mutex> lk(_p->mutex);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  auto node = it->second.lock();\n  if (!node) {\n    return false;\n  }\n  auto hook = node->getHook();\n  if (!hook) {\n    return false;\n  }\n  if (hook->getMode() != Hook::BREAKPOINT) {\n    return false;\n  }\n  hook->setStatus(result);\n  hook->setRemove(remove);\n  hook->setReady(true);\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 58.85500561110941}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::unique_lock<std::mutex> lk(_p->mtx);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  auto node = it->second.lock();\n  if (!node) {\n    return false;\n  }\n  auto hook = node->getHook();\n  if (!hook) {\n    return false;\n  }\n  lk.unlock();\n  std::unique_lock<std::mutex> hlk(hook->mtx);\n  if (hook->mode != HookMode::BREAKPOINT) {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hlk.unlock();\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 74.14242239828621}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::lock_guard<std::mutex> lk(_p->mutex);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  auto node = it->second.lock();\n  if (!node) {\n    return false;\n  }\n  auto hook = getHook(node);\n  if (!hook) {\n    return false;\n  }\n  std::lock_guard<std::mutex> lk_hook(hook->wakeup.mutex);\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 60.82308003112087}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    if (status() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_ = false;\n        std::async(std::launch::async, [this]() {\n            try {\n                tick();\n                if (!halt_requested_) {\n                    setStatus(NodeStatus::SUCCESS);\n                }\n            } catch (...) {\n                setStatus(NodeStatus::IDLE);\n                exception_ptr_ = std::current_exception();\n                std::cerr << \"Error in threaded action \" << registrationName() << \": \" << std::endl;\n            }\n        });\n    }\n    if (exception_ptr_) {\n        std::rethrow_exception(exception_ptr_);\n    }\n    return status();\n}", "CodeBleu_score": 50.52392567342502}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status_ == NodeStatus::IDLE) {\n    status_ = NodeStatus::RUNNING;\n    halt_requested_ = false;\n    std::async(std::launch::async, [this] {\n      try {\n        tick();\n        if (!halt_requested_) {\n          status_ = NodeStatus::SUCCESS;\n        }\n      } catch (...) {\n        status_ = NodeStatus::IDLE;\n        exception_ = std::current_exception();\n        ROS_ERROR(\"Exception thrown in %s: %s\", registration_name_.c_str(),\n                  exception_name(exception_).c_str());\n      }\n    });\n  }\n\n  if (exception_) {\n    std::rethrow_exception(exception_);\n  }\n\n  return status_;\n}", "CodeBleu_score": 38.76798956252079}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status() == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_ = false;\n    std::async(std::launch::async, [this]() {\n      try {\n        tick();\n        if (!halt_requested_) {\n          setStatus(NodeStatus::SUCCESS);\n        }\n      } catch (...) {\n        setStatus(NodeStatus::FAILURE);\n        exception_ = std::current_exception();\n      }\n    });\n  }\n  if (exception_) {\n    std::rethrow_exception(exception_);\n  }\n  return status();\n}", "CodeBleu_score": 38.06712771477551}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  stream << \"----------------------------------------\n\";\n  stream << \"Tree structure:\n\";\n  stream << \"----------------------------------------\n\";\n\n  // Define a recursive lambda function to handle the printing\n  std::function<void(const TreeNode*, int)> print_node = [&](const TreeNode* node, int depth) {\n    // Indent the output based on the node's depth\n    for (int i = 0; i < depth; ++i) {\n      stream << \"  \";\n    }\n\n    // Print the node's name\n    stream << node->name << \"\n\";\n\n    // Recursively print the children for ControlNode or the child for DecoratorNode\n    if (auto control_node = dynamic_cast<const BT::ControlNode*>(node)) {\n      for (const auto& child : control_node->children) {\n        print_node(child, depth + 1);\n      }\n    } else if (auto decorator_node = dynamic_cast<const BT::DecoratorNode*>(node)) {\n      print_node(decorator_node->child, depth + 1);\n    }\n  };\n\n  // Call the recursive lambda function with the root node and depth 0\n  print_node(root_node, 0);\n\n  stream << \"----------------------------------------\n\";\n}", "CodeBleu_score": 51.44304574954934}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  stream << \"----------------------------------------\n\";\n  auto print_node = [&](const TreeNode* node, unsigned int depth) {\n    for (unsigned int i = 0; i < depth; ++i) {\n      stream << \"--\";\n    }\n    stream << node->name << std::endl;\n  };\n  std::function<void(const TreeNode*, unsigned int)> recursive_print;\n  recursive_print = [&](const TreeNode* node, unsigned int depth) {\n    print_node(node, depth);\n    if (const auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n      for (const auto& child : control->children) {\n        recursive_print(child, depth + 1);\n      }\n    } else if (const auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n      recursive_print(decorator->child, depth + 1);\n    }\n  };\n  recursive_print(root_node, 0);\n  stream << \"----------------------------------------\n\";\n}", "CodeBleu_score": 56.14273219425914}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    stream << \"-------------------------\n\";\n    auto print_node = [&](const TreeNode* node, int depth) {\n        stream << std::string(depth, '-') << node->name << \"\n\";\n    };\n    std::function<void(const TreeNode*, int)> recursive_print;\n    recursive_print = [&](const TreeNode* node, int depth) {\n        print_node(node, depth);\n        if (auto control = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control->children) {\n                recursive_print(child, depth + 1);\n            }\n        } else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n            recursive_print(decorator->child, depth + 1);\n        }\n    };\n    recursive_print(root_node, 0);\n    stream << \"-------------------------\n\";\n}", "CodeBleu_score": 44.87030955273728}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (node == nullptr) {\n    throw LogicError(\"applyRecursiveVisitor: node is null\");\n  }\n  visitor(node);\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child, visitor);\n  }\n}", "CodeBleu_score": 67.61427858112378}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (node == nullptr) {\n    throw LogicError(\"The node is null\");\n  }\n  visitor(node);\n  if (const ControlNode* control = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : control->children) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (const DecoratorNode* decorator =\n                 dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child, visitor);\n  }\n}", "CodeBleu_score": 62.007961242377874}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (node == nullptr) {\n    throw LogicError(\"node cannot be null\");\n  }\n  visitor(node);\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child, visitor);\n  }\n}", "CodeBleu_score": 67.20671026980814}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  std::string registration_id = manifest.registration_id;\n\n  if (_p->builders.find(registration_id) != _p->builders.end()) {\n    throw BehaviorTreeException(\"ID already registered: \" + registration_id);\n  }\n\n  _p->builders.insert(std::make_pair(registration_id, builder));\n  _p->manifests.insert(std::make_pair(registration_id, manifest));\n}", "CodeBleu_score": 53.971728139150784}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  auto it = _p->builders.find(manifest.id);\n  if (it != _p->builders.end()) {\n    throw BehaviorTreeException(\"BehaviorTreeFactory: registration ID already registered\");\n  }\n  _p->builders.insert(std::make_pair(manifest.id, builder));\n  _p->manifests.insert(std::make_pair(manifest.id, manifest));\n}", "CodeBleu_score": 63.86595178565477}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    auto it = _p->builders.find(manifest.id);\n    if (it != _p->builders.end()) {\n        throw BehaviorTreeException(\n            \"BehaviorTreeFactory::registerBuilder: ID already registered: \" +\n            manifest.id);\n    }\n\n    _p->builders.insert({manifest.id, builder});\n    _p->manifests.insert({manifest.id, manifest});\n}", "CodeBleu_score": 68.50081808032658}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor](const TreeNode::TreeNodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(tick_functor, config);\n  };\n  TreeNodeManifest manifest(TreeNodeType::ACTION, ID, std::move(ports));\n  registerBuilder(std::move(manifest), std::move(builder));\n}", "CodeBleu_score": 50.14001203148474}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t    auto builder = [tick_functor, ports](const TreeNode& config) {\n        return std::make_unique<SimpleActionNode>(tick_functor, ports, config);\n    };\n\n    TreeNodeManifest manifest(NodeType::ACTION, ID, std::move(ports));\n    registerBuilder(std::move(manifest), std::move(builder));\n}", "CodeBleu_score": 58.15260238802979}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor, ports](const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(tick_functor, config.blackboard,\n                                              ports);\n  };\n  TreeNodeManifest manifest = {TreeNodeType::ACTION, ID, ports};\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 60.23505181555241}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (const auto& sub : tree.subtrees) {\n        bb.push_back(sub->blackboard->cloneInto(sub->blackboard->create()));\n    }\n    return bb;\n}", "CodeBleu_score": 74.5365050893254}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> bbs;\n    bbs.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        auto bb = Blackboard::create();\n        subtree->blackboard->cloneInto(bb);\n        bbs.push_back(bb);\n    }\n    return bbs;\n}", "CodeBleu_score": 60.6248300746549}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> bb_backup;\n    bb_backup.reserve(tree.subtrees.size());\n    for (const auto& sub : tree.subtrees) {\n        Blackboard::Ptr bb = Blackboard::create();\n        sub->blackboard->cloneInto(bb);\n        bb_backup.push_back(bb);\n    }\n    return bb_backup;\n}", "CodeBleu_score": 64.72161420834921}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if (executor) {\n    return executor->Execute(env);\n  }\n  return nonstd::make_unexpected(executor.error());\n}", "CodeBleu_score": 70.16964322992403}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if (executor.error) {\n    return nonstd::make_unexpected(executor.error);\n  }\n  return executor.value()(env);\n}", "CodeBleu_score": 69.61635625540494}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (executor.has_value()) {\n        return executor.value()(env);\n    } else {\n        return nonstd::make_unexpected(executor.error());\n    }\n}", "CodeBleu_score": 89.32791845565633}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\"Library is already loaded\");\n    }\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    loaded = true;\n    this->path = path;\n}", "CodeBleu_score": 53.82602753129002}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    loaded = true;\n}", "CodeBleu_score": 48.90341411765831}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t  std::lock_guard<std::mutex> lock(mutex);\n  if (loaded) {\n    throw RuntimeError(\"Library already loaded\");\n  }\n  handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!handle) {\n    throw RuntimeError(dlerror());\n  }\n  loaded = true;\n  this->path = path;\n}", "CodeBleu_score": 53.7387916693295}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size < 3) {\n    return false;\n  }\n\n  StringView stripped = str.strip();\n  if (stripped[0] != '{' || stripped[stripped.size - 1] != '}') {\n    return false;\n  }\n\n  if (stripped_pointer) {\n    *stripped_pointer = stripped.substr(1, stripped.size - 2);\n  }\n\n  return true;\n}", "CodeBleu_score": 24.224982164499202}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size < 3) {\n    return false;\n  }\n\n  str = str.trim();\n  if (str.size < 3) {\n    return false;\n  }\n\n  if (str.at(0) != '{' || str.at(str.size - 1) != '}') {\n    return false;\n  }\n\n  if (stripped_pointer) {\n    *stripped_pointer = str.substr(1, str.size - 2);\n  }\n\n  return true;\n}", "CodeBleu_score": 23.898297499277852}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size < 3) {\n    return false;\n  }\n  auto stripped = str.strip();\n  if (stripped.startsWith(\"{\") && stripped.endsWith(\"}\")) {\n    if (stripped_pointer != nullptr) {\n      *stripped_pointer = stripped.substring(1, stripped.size - 1);\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 22.228876039078447}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    double line_cost = 0.0;\n    LineIterator line(x0, y0, x1, y1);\n    while (line.isValid()) {\n        double point_cost = pointCost(line.getX(), line.getY());\n        if (point_cost < 0.0) {\n            return point_cost;\n        }\n        line_cost = std::max(line_cost, point_cost);\n        line.advance();\n    }\n    return line_cost;\n}", "CodeBleu_score": 65.93096228788748}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    double line_cost = 0.0;\n    LineIterator line(x0, y0, x1, y1);\n    while (line.isValid()) {\n        double point_cost = pointCost(line.getX(), line.getY());\n        if (point_cost < 0.0) {\n            return point_cost;\n        }\n        line_cost = std::max(line_cost, point_cost);\n        line.advance();\n    }\n    return line_cost;\n}", "CodeBleu_score": 65.93096228788748}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  double point_cost = 0.0;\n  LineIterator line(x0, y0, x1, y1);\n  while (line.isValid()) {\n    point_cost = pointCost(line.getX(), line.getY());\n    if (point_cost < 0.0) {\n      return point_cost;\n    }\n    line_cost = std::max(line_cost, point_cost);\n    line.advance();\n  }\n  return line_cost;\n}", "CodeBleu_score": 70.0683615831696}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  //if the path is empty, return without doing anything\n  if (path.empty())\n    return;\n\n  //create a nav_msgs::Path message and initialize its header with the frame_id and timestamp from the first pose in the path\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  //copy each pose from the input path to the path message\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  //publish the path message using the provided ROS publisher\n  pub.publish(gui_path);\n}", "CodeBleu_score": 89.55562385721949}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  // Check if the path is empty\n  if (path.empty()) {\n    ROS_WARN_NAMED(\"planning_utils\", \"Path is empty\");\n    return;\n  }\n\n  // Create a nav_msgs::Path message and initialize its header\n  nav_msgs::Path path_msg;\n  path_msg.header.frame_id = path[0].header.frame_id;\n  path_msg.header.stamp = path[0].header.stamp;\n\n  // Copy each pose from the input path to the path message\n  path_msg.poses.resize(path.size());\n  for (size_t i = 0; i < path.size(); ++i) {\n    path_msg.poses[i] = path[i];\n  }\n\n  // Publish the path message\n  pub.publish(path_msg);\n}", "CodeBleu_score": 66.44343535668749}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    if (path.empty())\n        return;\n\n    //create a nav_msgs::Path message\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n\n    // Copy the plan in the message\n    for (unsigned int i = 0; i < path.size(); i++)\n        gui_path.poses[i] = path[i];\n\n    // Publish the plan\n    pub.publish(gui_path);\n}", "CodeBleu_score": 83.20735930292646}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n    // Get the linear and angular velocities from the odometry message\n    double linear_velocity = base_odom.twist.twist.linear.x;\n    double angular_velocity = base_odom.twist.twist.angular.z;\n\n    // Check if the linear and angular velocities are below or equal to the given thresholds\n    if (linear_velocity <= trans_stopped_velocity && angular_velocity <= rot_stopped_velocity) {\n        return true;\n    }\n\n    // If the velocities are above the thresholds, return false\n    return false;\n}", "CodeBleu_score": 50.310909909606025}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n    double rot_vel = sqrt(pow(base_odom.twist.twist.linear.x, 2) + pow(base_odom.twist.twist.linear.y, 2));\n    double trans_vel = sqrt(pow(base_odom.twist.twist.angular.z, 2) + pow(base_odom.twist.twist.linear.z, 2));\n\n    return (fabs(rot_vel) <= rot_stopped_velocity && fabs(trans_vel) <= trans_stopped_velocity);\n}", "CodeBleu_score": 52.65637848754775}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  // Check if robot has stopped\n  if (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 65.80210305709669}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  // If setup is false, initialize the default limits with the provided configuration\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n\n  // If restore_defaults is true, reset the configuration to default limits\n  if (restore_defaults) {\n    config = default_limits_;\n  }\n\n  // Lock the configuration mutex and update the current limits with the new configuration\n  boost::unique_lock<boost::mutex> lock(configuration_mutex_);\n  current_limits_ = config;\n}", "CodeBleu_score": 69.27195729704727}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t    // If setup is not yet done, initialize the default limits with the provided configuration and set up the flag\n    if (!setup) {\n        default_limits = config;\n        setup = true;\n    }\n\n    // If restore_defaults is requested, reset the configuration to default limits\n    if (restore_defaults) {\n        config = default_limits;\n    }\n\n    // Lock the configuration mutex and update the current limits with the new configuration\n    boost::unique_lock<boost::mutex> lock(configuration_mutex);\n    current_limits = config;\n}", "CodeBleu_score": 58.39636833897961}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  // if setup is not done, initialize the default limits with the provided configuration\n  if (!setup) {\n    default_limits = config;\n    setup = true;\n  }\n  // if restore_defaults is requested, reset the configuration to default limits\n  if (restore_defaults) {\n    config = default_limits;\n  }\n  // lock the configuration mutex and update the current limits with the new configuration\n  boost::unique_lock<boost::mutex> lock(configuration_mutex);\n  current_limits = config;\n}", "CodeBleu_score": 58.28913005021271}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t    unsigned int x = check_cell->x;\n    unsigned int y = check_cell->y;\n\n    // check if the cell is an obstacle or has no information\n    if (costmap.getCost(x, y) == costmap_2d::NO_INFORMATION) {\n      check_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n      return false;\n    }\n\n    // calculate a new target distance\n    double new_distance = current_cell->target_distance + costmap.getCost(x, y);\n\n    // update the cell's target distance if the new distance is shorter\n    if (new_distance < check_cell->target_distance) {\n      check_cell->target_distance = new_distance;\n      return true;\n    }\n\n    return false;\n  }", "CodeBleu_score": 54.70837894463577}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int check_idx = check_cell->index;\n  unsigned int current_idx = current_cell->index;\n\n  // check if the cell is an obstacle\n  if (check_cell->cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    // set the target distance to the maximum obstacle cost\n    check_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  // calculate the new target distance\n  double new_distance = costmap.getCost(check_idx % costmap.getSizeInCellsX(),\n                                        check_idx / costmap.getSizeInCellsX()) +\n                        distance(current_idx % costmap.getSizeInCellsX(),\n                                 current_idx / costmap.getSizeInCellsX(),\n                                 check_idx % costmap.getSizeInCellsX(),\n                                 check_idx / costmap.getSizeInCellsX());\n\n  // update the target distance if the new distance is shorter\n  if (new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n  }\n\n  return true;\n}", "CodeBleu_score": 51.1847422490975}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\n  unsigned int x, y;\n  costmap.worldToMap(check_cell->world_x, check_cell->world_y, x, y);\n  unsigned char cost = costmap.getCost(x, y);\n  if (cost == costmap_2d::NO_INFORMATION)\n    return false;\n\n  if (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_dist = max_obstacle_cost_;\n    return false;\n  }\n\n  double new_dist = current_cell->target_dist + cost;\n  if (new_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_dist;\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 60.432520934055724}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t    double cost = -9;\n    double scaling_factor = getScalingFactor(traj);\n    if (footprint_spec_.size() == 0) {\n        ROS_ERROR(\"Footprint spec is empty\");\n        return cost;\n    }\n    for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n        double footprint_cost = footprintCost(traj.getPoint(i), scaling_factor);\n        if (footprint_cost < 0) {\n            return footprint_cost;\n        }\n        if (sum_scores_) {\n            cost += footprint_cost;\n        } else {\n            cost = std::max(cost, footprint_cost);\n        }\n    }\n    return cost;\n}", "CodeBleu_score": 56.5497756250787}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scaling_factor = getScalingFactor(traj);\n\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty, can't score trajectory\");\n    return -9;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.getPoint(i));\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost * scaling_factor;\n}", "CodeBleu_score": 57.28841676350217}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t    double cost = 0;\n    double scaling_factor = 1;\n    if (footprint_spec_.size() == 0) {\n        ROS_ERROR(\"No footprint specified for ObstacleCostFunction\");\n        return -9;\n    }\n    for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n        double footprint_cost = footprintCost(traj.getPoint(i), traj.getPoint(i + 1), traj.getPoint(i + 2), traj.getPoint(i + 3), traj.getPoint(i + 4));\n        if (footprint_cost < 0) {\n            return footprint_cost;\n        }\n        if (sum_scores_) {\n            cost += footprint_cost;\n        } else {\n            if (footprint_cost > cost) {\n                cost = footprint_cost;\n            }\n        }\n    }\n    return cost;\n}", "CodeBleu_score": 51.44800122879975}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  //check to make sure the footprint is not empty\n  if (footprint_spec.size() == 0) {\n    return -1.0;\n  }\n\n  //now we need to transform all of the points in the footprint into the frame of the robot\n  std::vector<geometry_msgs::Point> footprint;\n  double s = sin(th);\n  double c = cos(th);\n\n  for (unsigned int i = 0 ; i < footprint_spec.size() ; i++) {\n    geometry_msgs::Point new_pt;\n    new_pt.x = x + (footprint_spec[i].x * c - footprint_spec[i].y * s);\n    new_pt.y = y + (footprint_spec[i].x * s + footprint_spec[i].y * c);\n    footprint.push_back(new_pt);\n  }\n\n  //we now have to account for the robot's size by scaling the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint = scaleFootprint(footprint, scale);\n\n  //now we need to check that the footprint is legal\n  double footprint_cost = world_model->footprintCost(scaled_footprint, costmap);\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  //check if the footprint is in collision\n  unsigned int x0, x1, y0, y1;\n  if (!costmap->worldToMap(scaled_footprint[0].x, scaled_footprint[0].y, x0, y0)) {\n    return -7.0;\n  }\n  if (!costmap->worldToMap(scaled_footprint.back().x, scaled_footprint.back().y, x1, y1)) {\n    return -7.0;\n  }\n\n  unsigned int footprint_size = scaled_footprint.size();\n  for (unsigned int i = 0 ; i < footprint_size ; i++) {\n    unsigned int cell_x, cell_y;\n    if (!costmap->worldToMap(scaled_footprint[i].x, scaled", "CodeBleu_score": 62.006964306042065}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    // Get the robot's footprint\n    std::vector<geometry_msgs::Point> footprint = footprint_spec;\n\n    // Scale the footprint\n    for (unsigned int i = 0; i < footprint.size(); ++i) {\n        footprint[i].x *= scale;\n        footprint[i].y *= scale;\n    }\n\n    // Transform the footprint to the global frame\n    std::vector<geometry_msgs::Point> global_footprint;\n    costmap->transformFootprint(x, y, th, footprint, global_footprint);\n\n    // Compute the footprint cost\n    double footprint_cost = world_model->footprintCost(global_footprint);\n\n    // Return the maximum cost between the footprint cost and the cell cost at the given position\n    return std::max(footprint_cost, static_cast<double>(costmap->getCost(x, y)));\n}", "CodeBleu_score": 49.3481169331247}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  //check to make sure the footprint is not empty\n  if (footprint_spec.size() == 0) {\n    ROS_ERROR(\"Footprint model is empty\");\n    return -1.0;\n  }\n\n  //transform footprint to world coordinates\n  std::vector<geometry_msgs::Point> footprint = footprint_spec;\n  double s = sin(th);\n  double c = cos(th);\n\n  for (unsigned int i = 0 ; i < footprint.size() ; i++) {\n    //apply the footprint translation\n    footprint[i].x = x + (footprint[i].x * c - footprint[i].y * s);\n    footprint[i].y = y + (footprint[i].x * s + footprint[i].y * c);\n  }\n\n  //check if the footprint is in collision\n  if (world_model->footprintCost(x, y, th, footprint))\n    return -1.0;\n\n  //check if the footprint is off the map\n  unsigned int x0, xn, y0, yn;\n  if (!costmap->worldToMap(footprint[0].x, footprint[0].y, x0, y0) ||\n      !costmap->worldToMap(footprint.back().x, footprint.back().y, xn, yn))\n    return -1.0;\n\n  //check if the footprint is in collision with the costmap\n  unsigned char cost = 0;\n  for (unsigned int i = x0 ; i <= xn ; i++) {\n    for (unsigned int j = y0 ; j <= yn ; j++) {\n      cost = costmap->getCost(i, j);\n      if (cost == costmap_2d::INSCRIBED_INFLATED_OBSTACLE)\n        return -1.0;\n    }\n  }\n\n  //scale the footprint\n  for (unsigned int i = 0 ; i < footprint.size() ; i++) {\n    footprint[i].x *= scale;\n    footprint[i].y *= scale;\n  }\n\n  //compute the footprint cost\n  double footprint_cost = world_model", "CodeBleu_score": 52.15656535400968}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 50.935962829856976}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 50.935962829856976}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    if (odom_topic != odom_topic_) {\n        odom_topic_ = odom_topic;\n        if (odom_topic != \"\") {\n            odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n        } else {\n            odom_sub_.shutdown();\n        }\n    }\n}", "CodeBleu_score": 51.64916793057519}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  const float dist = (pos - prev).squaredNorm();\n  const float angle = std::abs(std::atan2(pos.y(), pos.x()) - std::atan2(prev.y(), prev.x()));\n  if (dist > distThreshold || angle > angleThreshold) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 36.13376247358608}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    // Calculate squared distance\n    const float dist2 = (pos - prev).squaredNorm();\n\n    // Check if distance exceeds threshold\n    if (dist2 > m_distThreshold2) {\n        m_isOscillation = false;\n        m_isOscillation2 = false;\n        m_isOscillation3 = false;\n        m_isOscillation4 = false;\n        return;\n    }\n\n    // Calculate angular difference\n    const Eigen::Vector3f dir = (pos - prev).normalized();\n    const float angle = std::acos(dir.dot(m_prevDir));\n\n    // Check if angle is greater than threshold\n    if (angle > m_angleThreshold) {\n        m_isOscillation = false;\n        m_isOscillation2 = false;\n        m_isOscillation3 = false;\n        m_isOscillation4 = false;\n        return;\n    }\n\n    // Reset oscillation flags\n    m_isOscillation = true;\n    m_isOscillation2 = true;\n    m_isOscillation3 = true;\n    m_isOscillation4 = true;\n}", "CodeBleu_score": 34.16265311591572}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    float dist2 = (pos - prev).squaredNorm();\n    float angle = std::abs(Eigen::Quaternionf::FromTwoVectors(pos, prev).angularDistance(Eigen::Quaternionf::Identity()));\n    if (dist2 > sqDistThreshold || angle > angleThreshold) {\n        resetOscillationFlags();\n    }\n}", "CodeBleu_score": 31.41475872609465}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // Get the grid coordinates of the point\n  const int x = static_cast<int>(std::floor(pt.x / cell_size_));\n  const int y = static_cast<int>(std::floor(pt.y / cell_size_));\n  const int z = static_cast<int>(std::floor(pt.z / cell_size_));\n\n  // Check if the point is within the grid bounds\n  if (x < 0 || x >= grid_size_ || y < 0 || y >= grid_size_ || z < 0 || z >= grid_size_) {\n    return;\n  }\n\n  // Calculate the grid index\n  const int grid_index = x + y * grid_size_ + z * grid_size_ * grid_size_;\n\n  // Calculate the distance to the nearest neighbor\n  const double nearest_neighbor_distance = nearestNeighborDistance(pt, grid_index);\n\n  // If the point is too close to its nearest neighbor, return without inserting it\n  if (nearest_neighbor_distance < min_distance_) {\n    return;\n  }\n\n  // Insert the point into the corresponding cell\n  cells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 45.30319168119858}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    // Calculate the grid coordinates of the point\n    geometry_msgs::Point32 gridCoords = calcGridCoords(pt);\n\n    // If the coordinates are outside the grid bounds, return without inserting the point\n    if (!isInBounds(gridCoords)) {\n        return;\n    }\n\n    // Calculate the grid index\n    int gridIndex = calcGridIndex(gridCoords);\n\n    // Calculate the nearest neighbor distance\n    float nearestNeighborDistance = calcNearestNeighborDistance(gridCoords);\n\n    // If the point is too close to its nearest neighbor, return without inserting the point\n    if (nearestNeighborDistance < minNeighborDist_) {\n        return;\n    }\n\n    // Insert the point into the corresponding cell\n    int pt_index = gridIndex;\n    cells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 44.569677430090614}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // TODO: Implement\n}", "CodeBleu_score": 5.235712737215651}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n  for (int i = 0; i < 3; ++i) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n    } else if (sample_target_vel[i] < vel[i]) {\n      new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n    } else {\n      new_vel[i] = sample_target_vel[i];\n    }\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 81.44807041434383}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; ++i) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n        } else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n        } else {\n            new_vel[i] = sample_target_vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 75.61604285122804}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n        } else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n        } else {\n            new_vel[i] = sample_target_vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 78.01942408720538}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // Find the closest point on the path with a clear line of sight\n  int closest_point = -1;\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    double dx = global_plan_[i].pose.position.x - x;\n    double dy = global_plan_[i].pose.position.y - y;\n    double dist = sqrt(dx * dx + dy * dy);\n    if (dist > lookahead_dist_) {\n      break;\n    }\n    int map_x, map_y;\n    costmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y, map_x, map_y);\n    if (costmap_.getCost(map_x, map_y) == costmap_2d::FREE_SPACE) {\n      closest_point = i;\n      break;\n    }\n  }\n\n  // If no valid point is found, return DBL_MAX\n  if (closest_point == -1) {\n    return DBL_MAX;\n  }\n\n  // Convert the goal cell coordinates to world coordinates\n  double goal_x, goal_y;\n  costmap_.mapToWorld(cell_x, cell_y, goal_x, goal_y);\n\n  // Calculate the shortest angular distance between the current heading and the direction to the goal point\n  double dx = goal_x - x;\n  double dy = goal_y - y;\n  double angle = atan2(dy, dx);\n  double diff = angles::shortest_angular_distance(heading, angle);\n\n  return fabs(diff);\n}", "CodeBleu_score": 57.295745256528804}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // Find the farthest point in the global plan with a clear line of sight to the robot's current cell\n  double best_dist = -1.0;\n  double best_x, best_y;\n  int best_idx = -1;\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    double gx = global_plan_[i].pose.position.x;\n    double gy = global_plan_[i].pose.position.y;\n    double dx = gx - x;\n    double dy = gy - y;\n    double dist = sqrt(dx * dx + dy * dy);\n    if (dist > best_dist && costmap_.cellDistance(cell_x, cell_y, gx, gy) < 0.0) {\n      best_dist = dist;\n      best_x = gx;\n      best_y = gy;\n      best_idx = i;\n    }\n  }\n\n  // If a valid point was found, calculate the shortest angular distance between the current heading and the direction to the goal point\n  if (best_idx >= 0) {\n    double dx = best_x - x;\n    double dy = best_y - y;\n    double angle = atan2(dy, dx);\n    double diff = angles::shortest_angular_distance(heading, angle);\n    return fabs(diff);\n  }\n\n  // If no valid point was found, return DBL_MAX\n  return DBL_MAX;\n}", "CodeBleu_score": 56.113416645322786}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // Calculate the difference in heading between the robot's current position and a goal point on the path\n  double min_dist = DBL_MAX;\n  int min_index = -1;\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    int g_x = global_plan_[i].getX();\n    int g_y = global_plan_[i].getY();\n    double dx = g_x - cell_x;\n    double dy = g_y - cell_y;\n    double dist = sqrt(dx * dx + dy * dy);\n    if (dist < min_dist && lineCost(cell_x, cell_y, g_x, g_y) == 0) {\n      min_dist = dist;\n      min_index = i;\n    }\n  }\n  if (min_index == -1) {\n    return DBL_MAX;\n  }\n  double g_x = global_plan_[min_index].getX();\n  double g_y = global_plan_[min_index].getY();\n  double wx, wy;\n  costmap_.mapToWorld(g_x, g_y, wx, wy);\n  double angle = angles::shortest_angular_distance(heading, atan2(wy - y, wx - x));\n  return fabs(angle);\n}", "CodeBleu_score": 55.372717646538725}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost < 0) {\n    ROS_WARN(\"TrajectoryPlanner::checkTrajectory: trajectory with sample velocities (%f, %f, %f) has cost %f\",\n      vx_samp, vy_samp, vtheta_samp, cost);\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 78.22207935010027}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0) {\n        return true;\n    }\n    ROS_WARN(\"TrajectoryPlanner: trajectory cost is negative. x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f, cost: %f\",\n             x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\n    return false;\n}", "CodeBleu_score": 74.96358890974022}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  // compute the cost of the trajectory\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost < 0) {\n    ROS_WARN(\"TrajectoryPlanner: Trajectory with sample velocities (%f, %f, %f) has cost %f\",\n             vx_samp, vy_samp, vtheta_samp, cost);\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 79.08428060436059}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t    if (!initialized_) {\n        ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n        return;\n    }\n\n    if (!local_costmap_ || !global_costmap_) {\n        ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do you want to use the costmap_2d::NullCostmap2D?\");\n        return;\n    }\n\n    if (invert_area_to_clear_) {\n        ROS_WARN(\"Area to clear is inside the polygon. This is not what you want?\");\n    }\n\n    ros::WallTime t0 = ros::WallTime::now();\n    if (affected_maps_ & clearing_robot_local_costmap_) {\n        local_costmap_->updateMap(0, 0, 0, 0);\n        ROS_DEBUG(\"Clearing local costmap\");\n    }\n\n    if (affected_maps_ & clearing_global_costmap_) {\n        global_costmap_->updateMap(0, 0, 0, 0);\n        ROS_DEBUG(\"Clearing global costmap\");\n    }\n\n    if (force_clearing_) {\n        if (affected_maps_ & clearing_robot_local_costmap_) {\n            local_costmap_->clear();\n        }\n\n        if (affected_maps_ & clearing_global_costmap_) {\n            global_costmap_->clear();\n        }\n    }\n\n    ROS_DEBUG(\"Clearing costmap cell contents took %.2f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 54.037997175100536}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t    if (!initialized_) {\n        ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n        return;\n    }\n\n    if (!local_costmap_ || !global_costmap_) {\n        ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do you want to load the \"\n                  \"costmap_2d nodelet? \");\n        return;\n    }\n\n    ROS_DEBUG(\"Checking if the robot has moved by %.3f m in the last %.1f seconds\", linear_tolerance_,\n              angular_tolerance_);\n\n    // Check if the robot has moved by linear_tolerance_ or angular_tolerance_ in the last linear_tolerance_ seconds\n    if (initial_pose_received_) {\n        double dx = fabs(tf::getX(current_robot_pose_.getOrigin()) -\n                         tf::getX(initial_robot_pose_.getOrigin()));\n        double dy = fabs(tf::getY(current_robot_pose_.getOrigin()) -\n                         tf::getY(initial_robot_pose_.getOrigin()));\n        double da = fabs(tf::getYaw(current_robot_pose_.getRotation()) -\n                         tf::getYaw(initial_robot_pose_.getRotation()));\n        if (dx < linear_tolerance_ && dy < linear_tolerance_ && da < angular_tolerance_) {\n            ROS_DEBUG(\"The robot has not moved by %.3f m in the last %.1f seconds\", linear_tolerance_,\n                      angular_tolerance_);\n            return;\n        }\n    }\n\n    ROS_DEBUG(\"The robot has moved by %.3f m in the last %.1f seconds\", linear_tolerance_, angular_tolerance_);\n\n    if (invert_area_to_clear_) {\n        ROS_WARN(\"Clearing inside the area\");\n    } else {\n        ROS_WARN(\"Clearing outside the area\");\n    }\n\n    // Clear the local costmap\n    if (affected_maps_.find('l", "CodeBleu_score": 45.48416729994237}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (!local_costmap_ || !global_costmap_) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do you want to load the default configuration?\");\n    return;\n  }\n\n  ROS_DEBUG(\"Checking if the robot's footprint is fully contained in the global costmap\");\n\n  // check if the robot's footprint is inside the global costmap\n  if (!local_costmap_->isRobotFootprintWithinGlobalCostmap()) {\n    ROS_WARN(\"The footprint of the robot is not in global costmap. Cannot clear the costmap.\");\n    return;\n  }\n\n  ROS_DEBUG(\"The footprint is inside the global costmap\");\n\n  // check if we're actually inverting the area to clear\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Inverting the area to clear\");\n  }\n\n  // clear the local and/or global costmap\n  ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_ == \"local\") {\n    local_costmap_->clearArea(markers_clearing_enabled_);\n    ROS_DEBUG(\"Cleared the local costmap to the size of the robot's footprint in %.2f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n  else if (affected_maps_ == \"global\") {\n    global_costmap_->clearArea(markers_clearing_enabled_);\n    ROS_DEBUG(\"Cleared the global costmap to the size of the robot's footprint in %.2f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n  else if (affected_maps_ == \"roi\") {\n    // clear the local and/or global costmap\n    if (local_costmap_) {\n      local_costmap_->clearArea(markers_clearing_enabled_);\n      ROS_DEBUG", "CodeBleu_score": 55.570425482005106}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\n\tif (polygon.empty())\n\t\treturn;\n\n\tPolygonOutlineCells outline_cells;\n\toutline_cells.header.frame_id = frame_id_;\n\toutline_cells.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < polygon.size(); ++i) {\n\t\tunsigned int j = (i + 1) % polygon.size();\n\t\traytraceLine(polygon[i], polygon[j], outline_cells);\n\t}\n\n\t// close polygon\n\traytraceLine(polygon.back(), polygon.front(), outline_cells);\n\n\tpolygon_cells.insert(polygon_cells.end(), outline_cells.cells.begin(), outline_cells.cells.end());\n}", "CodeBleu_score": 48.414765809674705}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\n\tif (polygon.empty())\n\t\treturn;\n\n\tMapLocation last = polygon.back();\n\n\tfor (std::vector<MapLocation>::const_iterator it = polygon.begin(); it != polygon.end(); ++it) {\n\t\traytraceLine(last, *it, polygon_cells);\n\t\tlast = *it;\n\t}\n}", "CodeBleu_score": 27.548012949811685}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\n  polygon_cells.clear();\n\n  if (polygon.empty())\n    return;\n\n  // initialize the cells vector with the first point\n  MapLocation cell = worldToMap(polygon.front().x, polygon.front().y);\n  polygon_cells.push_back(cell);\n\n  // for each edge, add cells between the polygon vertices\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n  }\n\n  // close the polygon by connecting the last point to the first\n  if (polygon.size() >= 3) {\n    raytraceLine(polygon.back(), polygon.front(), polygon_cells);\n  }\n}", "CodeBleu_score": 56.470125658096606}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t    prepareGrid();\n    pub.publish(grid_);\n}", "CodeBleu_score": 95.04328695786512}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t    prepareGrid();\n    pub.publish(grid_);\n}", "CodeBleu_score": 95.04328695786512}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n\n  grid_.header.frame_id = costmap_->getBaseFrameID();\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx;\n  grid_.info.origin.position.y = wy;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  origin_x_ = wx;\n  origin_y_ = wy;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n}", "CodeBleu_score": 63.6068391141266}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t    boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n    double resolution = costmap_->getResolution();\n\n    grid_.header.stamp = ros::Time::now();\n    grid_.header.frame_id = costmap_ros_->getGlobalFrameID();\n    grid_.info.resolution = resolution;\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    costmap_2d::MapLocation origin_loc;\n    origin_loc.x = costmap_->getSizeInCellsX() / 2;\n    origin_loc.y = costmap_->getSizeInCellsY() / 2;\n    costmap_->mapToWorld(origin_loc, origin_x_, origin_y_);\n    grid_.info.origin.position.x = origin_x_;\n    grid_.info.origin.position.y = origin_y_;\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    origin_x_ = costmap_->getOriginX();\n    origin_y_ = costmap_->getOriginY();\n\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    static const char* const TRANSLATION_TABLE = \" 0123456789abcdefghij\";\n    unsigned char* costmap = costmap_->getCharMap();\n    for (unsigned int i = 0; i < grid_.data.size(); i++) {\n        unsigned char value = costmap[i];\n        grid_.data[i] = TRANSLATION_TABLE[value];\n    }\n}", "CodeBleu_score": 68.16125965813806}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.header.frame_id = costmap_->getBaseFrameID();\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx;\n  grid_.info.origin.position.y = wy;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  origin_x_ = wx;\n  origin_y_ = wy;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = data[i];\n  }\n}", "CodeBleu_score": 79.81073790848303}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.robot_radius == old_config.robot_radius && new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  if (new_config.footprint.empty()) {\n    setUnpaddedRobotFootprint(new_config.robot_radius);\n    return;\n  }\n\n  std::vector<geometry_msgs::Point> footprint = makeFootprintFromString(new_config.footprint);\n  if (footprint.empty()) {\n    ROS_ERROR(\"The footprint string does not define any vertices or the format is invalid.\");\n    return;\n  }\n\n  setUnpaddedRobotFootprint(footprint);\n}", "CodeBleu_score": 57.77987747131985}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n    if (new_config.robot_radius == old_config.robot_radius &&\n        new_config.footprint == old_config.footprint) {\n        return;\n    }\n\n    std::vector<geometry_msgs::Point> footprint;\n    if (!new_config.footprint.empty()) {\n        try {\n            footprint = costmap_2d::makeFootprintFromString(new_config.footprint);\n        }\n        catch (const std::runtime_error &e) {\n            ROS_ERROR(\"Error parsing footprint string '%s': %s\",\n                      new_config.footprint.c_str(), e.what());\n        }\n    }\n\n    if (footprint.empty()) {\n        footprint = costmap_2d::makeFootprintFromRadius(new_config.robot_radius);\n    }\n\n    setUnpaddedRobotFootprint(footprint);\n}", "CodeBleu_score": 58.40871062844036}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.robot_radius == old_config.robot_radius &&\n      new_config.robot_base_frame == old_config.robot_base_frame &&\n      new_config.robot_base_link == old_config.robot_base_link &&\n      new_config.global_frame == old_config.global_frame &&\n      new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  // If we have a valid footprint string, we'll use it.\n  if (!new_config.footprint.empty()) {\n    // Convert the string to a vector of points.\n    std::vector<geometry_msgs::Point> points;\n    if (!costmap_2d::makeFootprintFromString(new_config.footprint, points)) {\n      ROS_ERROR(\"Error parsing footprint string '%s'\", new_config.footprint.c_str());\n      return;\n    }\n\n    // If we have a valid footprint, we'll use it.\n    if (!points.empty()) {\n      setUnpaddedRobotFootprint(points);\n      return;\n    }\n  }\n\n  // If we have a valid radius, we'll use it.\n  if (new_config.robot_radius > 0.0) {\n    // Make a circular footprint.\n    std::vector<geometry_msgs::Point> points;\n    costmap_2d::makeFootprintFromRadius(new_config.robot_radius, points);\n\n    // If we have a valid footprint, we'll use it.\n    if (!points.empty()) {\n      setUnpaddedRobotFootprint(points);\n      return;\n    }\n  }\n\n  // If we get here, we have a problem.\n  ROS_ERROR(\"Could not determine a valid footprint\");\n}", "CodeBleu_score": 55.74400941590856}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  tf::Stamped<tf::Pose> new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose\");\n    return;\n  }\n\n  // if we've already received our first pose, do nothing\n  if (initialized_) {\n    // check if the robot has moved far enough for us to update the map\n    double sq_dist = tf::quatDistance(last_pose_.getRotation(), new_pose.getRotation()) *\n                     tf::quatDistance(last_pose_.getRotation(), new_pose.getRotation());\n    if (sq_dist > reset_distance_sq_) {\n      ROS_DEBUG(\"Robot has moved more than reset distance (%g > %g)\", sq_dist, reset_distance_sq_);\n      resetMaps();\n    }\n  }\n  last_pose_ = new_pose;\n\n  // check if the robot has moved far enough for us to update the map\n  double sq_dist = tf::quatDistance(last_pose_.getRotation(), new_pose.getRotation()) *\n                   tf::quatDistance(last_pose_.getRotation(), new_pose.getRotation());\n  if (sq_dist > reset_distance_sq_) {\n    ROS_DEBUG(\"Robot has moved more than reset distance (%g > %g)\", sq_dist, reset_distance_sq_);\n    resetMaps();\n  }\n\n  last_pose_ = new_pose;\n}", "CodeBleu_score": 54.03514135296863}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Could not get robot pose\");\n    return;\n  }\n\n  if (current_ != new_pose) {\n    current_ = new_pose;\n    publishPose(current_);\n  }\n}", "CodeBleu_score": 77.08065021619804}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  tf::Stamped<tf::Pose> new_pose;\n  try {\n    tf_listener.lookupTransform(global_frame, robot_base_frame, ros::Time(0), new_pose);\n  }\n  catch (tf::TransformException ex) {\n    ROS_WARN(\"Failed to get transform from %s to %s\", global_frame.c_str(), robot_base_frame.c_str());\n    return;\n  }\n\n  //check if the robot has moved far enough for us to update the map\n  if (new_pose.stamp_ - last_transform_update_ < transform_tolerance_) {\n    return;\n  }\n  last_transform_update_ = new_pose.stamp_;\n\n  //get the robot's position, round to the nearest grid cell\n  unsigned int mx, my;\n  if (!worldToMap(new_pose.getOrigin().x(), new_pose.getOrigin().y(), mx, my)) {\n    ROS_WARN_THROTTLE(1.0, \"Robot out of costmap range\");\n    return;\n  }\n\n  //check if the robot has moved far enough for us to update the map\n  if (last_position_[0] == mx && last_position_[1] == my) {\n    return;\n  }\n  last_position_[0] = mx;\n  last_position_[1] = my;\n\n  //make sure to process the pending reconfigure request, if there is one\n  if (reconfigure_pending_) {\n    //call reconfigure\n    if (reconfigureCB(last_reconfigure_)) {\n      //successfully updated the costmap\n      //publish the full costmap\n      publishCostmap();\n    }\n    //clear the pending flag\n    reconfigure_pending_ = false;\n  }\n\n  //update the controller\n  controller.updateMap(mx, my);\n\n  //update the costmap\n  updateCostmap();\n\n  //publish the full costmap\n  publishCostmap();\n}", "CodeBleu_score": 45.05341258177306}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  // if we've been stopped, we need to re-subscribe to topics\n  if (stopped_) {\n    stopped_ = false;\n    // re-subscribe to topics\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = layered_costmap_->getPlugins()->begin();\n         plugin != layered_costmap_->getPlugins()->end(); ++plugin) {\n      (*plugin)->activate();\n    }\n  }\n\n  // wait until ROS is running\n  while (!ros::isInitialized()) {\n    ROS_INFO(\"Waiting for ROS to come up\");\n    ros::WallDuration(0.5).sleep();\n  }\n\n  // wait until the costmap is initialized\n  while (!initialized_) {\n    ROS_INFO(\"Waiting for costmap to be initialized\");\n    ros::WallDuration(0.5).sleep();\n  }\n\n  // wait until the map update thread is running\n  while (!map_update_thread_) {\n    ROS_INFO(\"Waiting for map update thread to be running\");\n    ros::WallDuration(0.5).sleep();\n  }\n}", "CodeBleu_score": 52.29883721884594}, {"code": "void Costmap2DROS::start(){\n\t  // Reactivate plugins if they were stopped\n  std::vector<boost::shared_ptr<Layer> >::iterator plugin = layered_costmap_->getPlugins()->begin();\n  for(; plugin != layered_costmap_->getPlugins()->end(); plugin++) {\n    if ((*plugin)->isStopped()) {\n      (*plugin)->activate();\n    }\n  }\n\n  // If we're stopped, we need to re-subscribe to topics\n  if (stopped_) {\n    // Set stopped flag to false\n    stopped_ = false;\n\n    // Re-subscribe to topics\n    for(plugin = layered_costmap_->getPlugins()->begin(); plugin != layered_costmap_->getPlugins()->end(); plugin++) {\n      (*plugin)->subscribe();\n    }\n\n    // Set stop_updates_ to false\n    stop_updates_ = false;\n  }\n\n  // Wait until ROS is running\n  while (!ros::isInitialized()) {\n    ros::WallDuration(0.1).sleep();\n  }\n\n  // Wait until the costmap is initialized\n  while (!initialized_) {\n    ros::WallDuration(0.1).sleep();\n  }\n\n  // Wait until the map update thread is active\n  while (!map_update_thread_.isActive()) {\n    ros::WallDuration(0.1).sleep();\n  }\n}", "CodeBleu_score": 54.77874209492014}, {"code": "void Costmap2DROS::start(){\n\t  std::vector<boost::shared_ptr<Layer> >::iterator plugin;\n  for (plugin = layered_costmap_->getPlugins()->begin();\n       plugin != layered_costmap_->getPlugins()->end(); ++plugin) {\n    if ((*plugin)->stopped()) {\n      ROS_INFO(\"Re-activating costmap plugin %s\", (*plugin)->getName().c_str());\n      (*plugin)->activate();\n    }\n  }\n\n  if (stopped_) {\n    ROS_INFO(\"Re-starting costmap2D\");\n    stop_updates_ = false;\n    stopped_ = false;\n    update_timer_ = nh_.createTimer(ros::Duration(0.1), &Costmap2DROS::update, this);\n  }\n\n  while (!initialized_ && ros::ok()) {\n    ROS_INFO(\"Waiting for costmap2D to be fully initialized...\");\n    ros::WallDuration d(0.5);\n    d.sleep();\n  }\n\n  while (!layered_costmap_->isCurrent() && ros::ok()) {\n    ROS_INFO(\"Waiting for costmap2D to become available...\");\n    ros::WallDuration d(0.5);\n    d.sleep();\n  }\n}", "CodeBleu_score": 55.79950315040223}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ > ros::Duration(0)) {\n    // Iterate through the list of observations, keeping the most recent one.\n    // If the observation_keep_time_ is zero, we don't need to do anything.\n    std::vector<Observation>::iterator iter = observation_list_.begin();\n    while (iter != observation_list_.end()) {\n      if (ros::Time::now() - iter->time > observation_keep_time_) {\n        // If the observation is too old, remove it from the list.\n        iter = observation_list_.erase(iter);\n      } else {\n        // If the observation is not too old, we are done.\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 36.68448239686012}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ > 0.0) {\n    ros::Time now = ros::Time::now();\n    while (!observation_list_.empty() &&\n           (now - observation_list_.front().header.stamp) >\n               observation_keep_time_) {\n      observation_list_.pop_front();\n    }\n  } else {\n    observation_list_.clear();\n  }\n}", "CodeBleu_score": 27.702670231899628}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0)) {\n    // Keep only the most recent observation\n    while (observation_list_.size() > 1) {\n      observation_list_.pop_front();\n    }\n  } else {\n    // Remove observations older than observation_keep_time_\n    ros::Time now = ros::Time::now();\n    ros::Duration keep_time = observation_keep_time_;\n    while (observation_list_.size() > 1) {\n      ros::Time oldest_time = observation_list_.front().header.stamp;\n      if (now - oldest_time > keep_time) {\n        observation_list_.pop_front();\n      } else {\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 37.06322900059301}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  // Get the yaw angles at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end yaw angles\n  double angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Compute the incremental change in angle\n  double increment = angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    double yaw = start_yaw + increment * (i - start_index);\n    path[i].pose.orientation = tf2::set_angle(path[i].pose.orientation, yaw);\n  }\n}", "CodeBleu_score": 68.79238387012293}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    // Get the yaw angles at the start and end indices\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Determine the shortest angular distance between the start and end yaw angles\n    double angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Compute the incremental change in angle for each pose in the specified range\n    double increment = angular_distance / (end_index - start_index);\n    for (int i = start_index + 1; i < end_index; ++i) {\n        // Update the orientation of the pose\n        double yaw = start_yaw + increment * (i - start_index);\n        path[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), yaw));\n    }\n}", "CodeBleu_score": 68.43162447468562}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    // Get the yaw angles at the start and end indices\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Calculate the shortest angular distance between the start and end yaw angles\n    double angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Calculate the incremental change in angle for each pose\n    double increment = angular_distance / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index + 1; i < end_index; ++i) {\n        double yaw = start_yaw + increment * (i - start_index);\n        path[i].pose.orientation = tf2::set_angle(path[i].pose.orientation, yaw);\n    }\n}", "CodeBleu_score": 68.99811080101011}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    std::vector<geometry_msgs::PoseStamped> plan;\n    bool success = makePlan(req.start, req.goal, plan);\n\n    // Update the response with the success status and the generated path if a plan is found\n    resp.plan.poses.clear();\n    if (success) {\n        resp.plan.poses = plan;\n    }\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.frame_id = \"map\";\n\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 67.12032590705259}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    bool success = makePlan(req.start, req.goal, resp.plan);\n\n    // Update the response with the success status and the generated path if a plan is found\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.success = success;\n\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 65.3471308418658}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    bool found_plan = makePlan(req.start, req.goal, resp.plan.poses);\n\n    // Update the response with the success status and the generated path if a plan is found\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.frame_id = \"map\";\n    resp.success = found_plan;\n\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 58.7749749597271}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 64.72319019104005}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    //private_nh.setCallbackQueue(&queue);\n    service = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 69.61985244510434}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 70.13391576745558}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (costmap_->worldToMap(wx, wy, mx, my)) {\n    unsigned int mx0, my0;\n    if (costmap_->worldToMap(wx - costmap_->getResolution() / 2, wy - costmap_->getResolution() / 2, mx0, my0)) {\n      unsigned int mx1, my1;\n      if (costmap_->worldToMap(wx + costmap_->getResolution() / 2, wy + costmap_->getResolution() / 2, mx1, my1)) {\n        if (mx0 < 0 || mx1 >= costmap_->getSizeInCellsX() || my0 < 0 || my1 >= costmap_->getSizeInCellsY()) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 48.45304783813615}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  // Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    ROS_WARN_THROTTLE(1.0, \"worldToMap: wx, wy (%.4f, %.4f) is off the map origin (%.4f, %.4f)\",\n                      wx, wy, costmap_->getOriginX(), costmap_->getOriginY());\n    return false;\n  }\n\n  // Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // Check if the map coordinates are within the costmap's size limits\n  if (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\n    ROS_WARN_THROTTLE(1.0, \"worldToMap: wx, wy (%.4f, %.4f) is off the map (%d, %d)\",\n                      wx, wy, costmap_->getSizeInCellsX(), costmap_->getSizeInCellsY());\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 45.15207440372748}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (costmap_->worldToMap(wx, wy, mx, my)) {\n    unsigned int index = costmap_->getIndex(mx, my);\n    if (costmap_->getCost(index) == NO_INFORMATION) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 29.36213552771286}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  //make sure that the planner is initialized\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  //create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  //extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  //publish the plan\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.3355739336173}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before using this planner\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.69410577923674}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  //make sure that the planner is initialized\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n    return;\n  }\n  \n  //create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n  \n  //extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for(unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n  \n  //publish the plan\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 86.0723742514994}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Received new goal\");\n  // create the action message and fill in the goal\n  move_base_msgs::MoveBaseGoal action_goal;\n  action_goal.target_pose = *goal;\n  // we have to make sure that the action client has subscribed to the\n  // move_base action server before we send a goal\n  if (!ac_.waitForServer(ros::Duration(5.0))) {\n    ROS_ERROR_NAMED(\"move_base\", \"Could not connect to move_base action server\");\n    return;\n  }\n  ROS_INFO_NAMED(\"move_base\", \"Sending goal\");\n  ac_.sendGoal(action_goal);\n}", "CodeBleu_score": 48.14010201891223}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(LOGNAME, \"Wrapping received PoseStamped goal in an action message and publishing.\");\n\n  // create the action message and fill in the needed components\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n\n  // publish the action goal\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 76.00260850576137}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Received new goal\");\n\n  // create the action message and fill in the goal\n  move_base_msgs::MoveBaseGoal action_goal;\n  action_goal.target_pose = *goal;\n\n  // we'll send a goal to the action server that has an empty header, so we need\n  // to fill it in here even though it's ignored by the server code\n  action_goal.target_pose.header.stamp = ros::Time::now();\n\n  // publish the goal\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 58.11714758617062}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  double sq_distance = getSqDistance(current_position_, previous_position_);\n  if (sq_distance > sq_distance_limit_) {\n    ROS_INFO(\"Moving far enough to remove speed limit\");\n    remove_limit_thread_->join();\n    delete remove_limit_thread_;\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 68.05991603952084}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    double sq_dist = sqrt(pow(current_x_ - start_x_, 2) + pow(current_y_ - start_y_, 2));\n    if (sq_dist >= sq_lim_dist_) {\n        ROS_INFO(\"Moved far enough!\");\n        remove_limit_thread_->join();\n        delete remove_limit_thread_;\n        remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n        distance_check_timer_.stop();\n    }\n}", "CodeBleu_score": 62.716279179010506}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  double sq_dist = sqrt(getSqDistance(prev_x_, prev_y_, x_, y_));\n  if (sq_dist > sq_dist_limit_) {\n    ROS_INFO(\"Moved %.2f meters, stopping\", sq_dist);\n    if (remove_limit_thread_ != NULL) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 73.82214451839917}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Get the current global pose of the robot\n    geometry_msgs::PoseStamped global_pose;\n    costmap_->getRobotPose(global_pose);\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<geometry_msgs::PoseStamped> plan;\n    makePlan(global_pose, *goal, plan);\n\n    // Publish the path\n    path_pub_.publish(plan);\n}", "CodeBleu_score": 62.82014069183227}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Get the current global pose of the robot\n    geometry_msgs::PoseStamped current_pose;\n    if (!costmap_->getRobotPose(current_pose)) {\n        ROS_ERROR(\"Could not get robot pose\");\n        return;\n    }\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<geometry_msgs::PoseStamped> path;\n    if (!makePlan(current_pose.pose, goal->pose, path)) {\n        ROS_ERROR(\"Could not generate path\");\n        return;\n    }\n\n    // Publish the path\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = costmap_->getGlobalFrameID();\n    path_msg.header.stamp = ros::Time::now();\n    path_msg.poses = path;\n    path_pub_.publish(path_msg);\n}", "CodeBleu_score": 45.79047233767432}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the current global pose of the robot\n  geometry_msgs::PoseStamped global_pose;\n  if (!costmap_->getRobotPose(global_pose)) {\n    ROS_WARN(\"Could not get robot pose\");\n    return;\n  }\n\n  // Generate a path from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> plan;\n  if (!makePlan(global_pose, *goal, plan)) {\n    ROS_WARN(\"Could not generate a plan\");\n    return;\n  }\n\n  // Publish the path\n  nav_msgs::Path path;\n  path.header.frame_id = global_pose.header.frame_id;\n  path.header.stamp = ros::Time::now();\n  path.poses = plan;\n  path_pub_.publish(path);\n}", "CodeBleu_score": 52.54902545061467}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    // Create a ParamSet service request\n    mavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.integer = param_set.value.integer;\n    param_set_srv.request.value.real = param_set.value.real;\n    param_set_srv.request.value.type = param_set.value.type;\n\n    // Call the param_set_client_ to send the request\n    if (param_set_client_.call(param_set_srv)) {\n        ROS_INFO(\"Gimbal parameter set request sent successfully.\");\n    } else {\n        ROS_ERROR(\"Failed to send gimbal parameter set request.\");\n    }\n}", "CodeBleu_score": 50.514126890610065}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    // Create a ParamSet service request\n    dji_sdk::ParamSet param_set_srv;\n    param_set_srv.request.id = param_set.id;\n    param_set_srv.request.value = param_set.value;\n\n    // Call the param_set_client_ to send the request\n    if (param_set_client_.call(param_set_srv)) {\n        ROS_INFO(\"Gimbal parameter set request sent\");\n    } else {\n        ROS_ERROR(\"Failed to call ParamSet service\");\n    }\n}", "CodeBleu_score": 51.02907604238215}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    param_set_client_.request.param_id = param_set.param_id;\n    param_set_client_.request.value = param_set.value;\n    param_set_client_.call(param_get_client_);\n}", "CodeBleu_score": 51.99081954641929}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t    int newSocket;\n    struct sockaddr_in serverAddr, clientAddr;\n    socklen_t addr_size;\n    int n;\n    char buffer[1024];\n    int port = 9999;\n\n    // Create a socket\n    int server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd == -1) {\n        perror(\"socket\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Set up the server address\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\n\n    // Bind the socket to the server address\n    if (bind(server_fd, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0) {\n        perror(\"bind\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 5) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Accept incoming connections and handle them\n    while (true) {\n        addr_size = sizeof(clientAddr);\n        newSocket = accept(server_fd, (struct sockaddr *)&clientAddr, &addr_size);\n        if (newSocket < 0) {\n            perror(\"accept\");\n            exit(EXIT_FAILURE);\n        }\n\n        // Receive data from the client\n        n = recv(newSocket, buffer, 1024, 0);\n        if (n <= 0) {\n            perror(\"recv\");\n            close(newSocket);\n            continue;\n        }\n\n        // Process the received data\n        std::string msg(buffer, n);\n        decodeMsg(msg);\n\n        // Close the socket\n        close(newSocket);\n    }\n}", "CodeBleu_score": 56.03255669020062}, {"code": "void CommunicationBridge::serverFun(){\n\t  int sockfd, newsockfd, portno, n;\n  socklen_t clilen;\n  char buffer[256];\n  struct sockaddr_in serv_addr, cli_addr;\n\n  // Create a socket\n  sockfd = socket(AF_INET, SOCK_STREAM, 0);\n  if (sockfd < 0) {\n    perror(\"ERROR opening socket\");\n    exit(1);\n  }\n\n  // Initialize the socket address structure\n  bzero((char *) &serv_addr, sizeof(serv_addr));\n  portno = PORT_NUMBER;\n  serv_addr.sin_family = AF_INET;\n  serv_addr.sin_addr.s_addr = INADDR_ANY;\n  serv_addr.sin_port = htons(portno);\n\n  // Bind the socket to the specified port\n  if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n    perror(\"ERROR on binding\");\n    exit(1);\n  }\n\n  // Listen for incoming connections\n  listen(sockfd, 5);\n  clilen = sizeof(cli_addr);\n\n  // Accept incoming connections and handle them\n  while (1) {\n    newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n    if (newsockfd < 0) {\n      perror(\"ERROR on accept\");\n      exit(1);\n    }\n\n    // Receive data from the client\n    bzero(buffer, 256);\n    n = recv(newsockfd, buffer, 255, 0);\n    if (n < 0) {\n      perror(\"ERROR reading from socket\");\n      exit(1);\n    }\n\n    // Process the received data\n    if (n > 0) {\n      // Decode the message\n      std::string msg = decodeMsg(buffer);\n\n      // Publish the message\n      pubMsg(msg);\n    } else {\n      // Log an error and close the socket\n      ROS", "CodeBleu_score": 46.434016809307835}, {"code": "void CommunicationBridge::serverFun(){\n\t    int sockfd, newsockfd, portno;\n    socklen_t clilen;\n    struct sockaddr_in serv_addr, cli_addr;\n    int n;\n\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    bzero((char *) &serv_addr, sizeof(serv_addr));\n    portno = PORT_NO;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    serv_addr.sin_port = htons(portno);\n\n    if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"ERROR on binding\");\n        exit(1);\n    }\n\n    listen(sockfd, 5);\n    clilen = sizeof(cli_addr);\n\n    while (true) {\n        newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n        if (newsockfd < 0) {\n            perror(\"ERROR on accept\");\n            exit(1);\n        }\n\n        while (true) {\n            char buffer[256];\n            bzero(buffer, 256);\n            n = recv(newsockfd, buffer, 255, 0);\n            if (n <= 0) {\n                if (n < 0) {\n                    perror(\"ERROR reading from socket\");\n                }\n                break;\n            }\n\n            if (n <= 0) {\n                ROS_ERROR(\"Received message length is zero or less\");\n                close(newsockfd);\n                break;\n            }\n\n            // Decode the message and publish it\n            decodeMsg(buffer);\n        }\n    }\n}", "CodeBleu_score": 54.65238599046172}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->simulation_mode_) {\n        if (this->swarm_control_simulation_.find(uav_cmd.uav_id) != this->swarm_control_simulation_.end()) {\n            this->swarm_control_simulation_[uav_cmd.uav_id]->uavCmdPub.publish(uav_cmd);\n        }\n    } else {\n        this->uav_basic_->uavCmdPub.publish(uav_cmd);\n    }\n}", "CodeBleu_score": 33.75983962988619}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (!simulation_mode_) {\n    uav_basic_->uavCmdPub(uav_cmd);\n  } else {\n    std::map<int, UAVBasic*>::iterator it;\n    it = swarm_control_simulation_.find(uav_cmd.uav_id);\n    if (it != swarm_control_simulation_.end()) {\n      it->second->uavCmdPub(uav_cmd);\n    }\n  }\n}", "CodeBleu_score": 39.772537302709374}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (this->simulation_mode_) {\n    if (this->swarm_control_simulation_.find(uav_cmd.id) !=\n        this->swarm_control_simulation_.end()) {\n      this->swarm_control_simulation_.at(uav_cmd.id)->uavCmdPub.publish(uav_cmd);\n    } else {\n      ROS_WARN(\"UAV %d not found in simulation\", uav_cmd.id);\n    }\n  } else {\n    this->uav_basic_->uavCmdPub.publish(uav_cmd);\n  }\n}", "CodeBleu_score": 34.552905364984696}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode) {\n        if (mode_selection.mode == ModeSelection::REBOOTNX) {\n            system(\"rebootnx\");\n        } else if (mode_selection.mode == ModeSelection::EXITNX) {\n            system(\"exitnx\");\n        } else if (mode_selection.mode == ModeSelection::CREATE_MODE) {\n            createMode();\n        } else if (mode_selection.mode == ModeSelection::DELETE_MODE) {\n            deleteMode();\n        }\n    }\n}", "CodeBleu_score": 54.975293954254845}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.mode == Mode::REBOOTNX) {\n        system(\"reboot\");\n    }\n    if (mode_selection.mode == Mode::EXITNX) {\n        system(\"exit\");\n    }\n    if (mode_selection.use_mode) {\n        createMode(mode_selection);\n    }\n    else {\n        deleteMode(mode_selection);\n    }\n}", "CodeBleu_score": 56.870730389833746}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t  if (mode_selection.use_mode) {\n    if (mode_selection.mode == REBOOTNX) {\n      system(\"reboot\");\n    } else if (mode_selection.mode == EXITNX) {\n      system(\"exit\");\n    } else {\n      if (mode_selection.mode == CREATE) {\n        createMode();\n      } else if (mode_selection.mode == DELETE) {\n        deleteMode();\n      }\n    }\n  }\n}", "CodeBleu_score": 50.566003319396046}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  // Check the heartbeat status\n  if (heartbeat_status_ == HeartbeatStatus::OK) {\n    // If the heartbeat is OK, reset the heartbeat count\n    heartbeat_count_ = 0;\n  } else {\n    // If the heartbeat is not OK, increment the heartbeat count\n    ++heartbeat_count_;\n  }\n\n  // If the heartbeat count exceeds the maximum number of allowed missed heartbeats, print an error message and take appropriate actions\n  if (heartbeat_count_ > max_missed_heartbeats_) {\n    ROS_ERROR(\"Heartbeat lost. Triggering UAV/UGV/Swarm control.\");\n\n    // Trigger the appropriate actions based on the type of vehicle\n    if (vehicle_type_ == VehicleType::UAV) {\n      triggerUAV();\n    } else if (vehicle_type_ == VehicleType::UGV) {\n      triggerUGV();\n    } else if (vehicle_type_ == VehicleType::Swarm) {\n      triggerSwarmControl();\n    }\n\n    // Set the disconnect_flag to true\n    disconnect_flag_ = true;\n  }\n}", "CodeBleu_score": 31.343986629359883}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  // Check the heartbeat status of the vehicle\n  if (heartbeat_status_ == HeartbeatStatus::kGood) {\n    // Reset the heartbeat count if the status is good\n    heartbeat_count_ = 0;\n  } else {\n    // Increment the heartbeat count if the status is bad\n    ++heartbeat_count_;\n  }\n\n  // Check if the heartbeat count has reached the threshold\n  if (heartbeat_count_ >= heartbeat_threshold_) {\n    // Print an error message if the heartbeat count has reached the threshold\n    ROS_ERROR(\"Heartbeat status is bad for %d consecutive attempts\", heartbeat_threshold_);\n\n    // Trigger appropriate actions based on the type of vehicle\n    if (vehicle_type_ == VehicleType::kSwarm) {\n      // Trigger the swarm control\n      triggerSwarmControl();\n    } else if (vehicle_type_ == VehicleType::kUAV) {\n      // Trigger the UAV control\n      triggerUAV();\n    } else if (vehicle_type_ == VehicleType::kUGV) {\n      // Trigger the UGV control\n      triggerUGV();\n    }\n\n    // Set the disconnect flag to true\n    disconnect_flag_ = true;\n  }\n}", "CodeBleu_score": 40.426194966662784}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (heartbeat_count_ == 0) {\n        ROS_ERROR(\"Heartbeat lost for %d seconds\", time_event.current_real.toSec() - last_heartbeat_time_.toSec());\n        if (vehicle_type_ == \"swarm\") {\n            triggerSwarmControl();\n        } else if (vehicle_type_ == \"UAV\") {\n            triggerUAV();\n        } else if (vehicle_type_ == \"UGV\") {\n            triggerUGV();\n        }\n        disconnect_flag_ = true;\n    } else {\n        heartbeat_count_--;\n    }\n}", "CodeBleu_score": 34.82631987569124}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\n    std::vector<Bspline> bsplines;\n\n    for (int i = 0; i < msg->traj.size(); i++) {\n        Bspline bspline;\n\n        bspline.drone_id = msg->traj[i].drone_id;\n        bspline.start_time = msg->traj[i].start_time;\n        bspline.end_time = msg->traj[i].end_time;\n        bspline.order = msg->traj[i].order;\n        bspline.knots.resize(msg->traj[i].knots.size());\n        bspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n        bspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots[j] = msg->traj[i].knots[j];\n        }\n\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts[j] = msg->traj[i].pos_pts[j];\n        }\n\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n        }\n\n        bsplines.push_back(bspline);\n    }\n\n    prometheus_msgs::MultiBsplinesPtr msg_out(new prometheus_msgs::MultiBsplines);\n\n    msg_out->header.stamp = ros::Time::now();\n    msg_out->traj.resize(bsplines.size());\n\n    for (int i = 0; i < bsplines.size", "CodeBleu_score": 72.10014912368466}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    for (int i = 0; i < msg->traj.size(); i++) {\n        Bspline bspline;\n        bspline.id = msg->traj[i].id;\n        bspline.start_time = msg->traj[i].start_time.toSec();\n        bspline.end_time = msg->traj[i].end_time.toSec();\n        bspline.order = msg->traj[i].order;\n        bspline.num_pts = msg->traj[i].num_pts;\n        bspline.knots.resize(msg->traj[i].knots.size());\n        bspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n        bspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots[j] = msg->traj[i].knots[j];\n        }\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts[j].x = msg->traj[i].pos_pts[j].x;\n            bspline.pos_pts[j].y = msg->traj[i].pos_pts[j].y;\n            bspline.pos_pts[j].z = msg->traj[i].pos_pts[j].z;\n        }\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n        }\n        this->communication->encodeMsg(bspline);\n        this->communication->sendMsgByTcp();\n    }", "CodeBleu_score": 67.84198712951792}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    for (int i = 0; i < msg->traj.size(); i++) {\n        Bspline bspline;\n        bspline.id = msg->traj[i].id;\n        bspline.start_time = msg->traj[i].start_time.toSec();\n        bspline.duration = msg->traj[i].duration.toSec();\n        bspline.order = msg->traj[i].order;\n        bspline.knots.resize(msg->traj[i].knots.size());\n        bspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n        bspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots[j] = msg->traj[i].knots[j];\n        }\n\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts[j].x = msg->traj[i].pos_pts[j].x;\n            bspline.pos_pts[j].y = msg->traj[i].pos_pts[j].y;\n            bspline.pos_pts[j].z = msg->traj[i].pos_pts[j].z;\n        }\n\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n        }\n\n        this->communication->encodeMsg(bspline);\n    }\n}", "CodeBleu_score": 66.16505176632849}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    std::vector<uint8_t> compressed_data;\n    pcl::io::compression_Profiles_e compression_profile = pcl::io::MED_RES_ONLINE_COMPRESSION_WITH_COLOR;\n    pcl::io::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n    octree_compression.setInputCloud(cloud);\n    octree_compression.encodePointCloud(compressed_data, compression_profile);\n\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.size();\n    compressed_msg.is_dense = true;\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = 3 * sizeof(float);\n    compressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n    compressed_msg.data.resize(compressed_msg.row_step);\n    std::memcpy(&compressed_msg.data[0], &compressed_data[0], compressed_msg.row_step);\n    compressed_msg.fields.resize(3);\n    compressed_msg.fields[0].name = \"x\";\n    compressed_msg.fields[0].offset = 0;\n    compressed_msg.fields[0].count = 1;\n    compressed_msg.fields[0].datatype = sensor_msgs::PointField::FLOAT32;\n    compressed_msg.fields[1].name = \"y\";\n    compressed_msg.fields[1].offset = 4;\n    compressed_msg.fields[1].count = 1;\n    compressed_msg.fields[1].datatype = sensor_msgs::PointField::FLOAT32;\n    compressed_msg.fields[2].name = \"z\";\n    compressed_msg.fields[", "CodeBleu_score": 51.808014354013466}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud using an octree compression technique\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n    octree_compression.setInputCloud(cloud);\n    octree_compression.setResolution(0.01); // Adjust the resolution as needed\n    octree_compression.setMinimumPointsPerNode(10); // Adjust the minimum points per node as needed\n    octree_compression.setPointIncrementalEncoding(false); // Disable point incremental encoding\n    octree_compression.setPointIncrementalDecoding(false); // Disable point incremental decoding\n    octree_compression.setPointIncrementalTraversal(false); // Disable point incremental traversal\n\n    // Compress the point cloud\n    std::vector<uint8_t> compressed_data;\n    octree_compression.encodePointCloud(compressed_data);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.size();\n    compressed_msg.fields = msg.fields;\n    compressed_msg.is_bigendian = msg.is_bigendian;\n    compressed_msg.point_step = msg.point_step;\n    compressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n    compressed_msg.is_dense = msg.is_dense;\n    compressed_msg.data.resize(compressed_data.size());\n    std::memcpy(&compressed_msg.data[0], &compressed_data[0], compressed_data.size());\n\n    // Release dynamically allocated memory\n    cloud.reset();\n", "CodeBleu_score": 49.73310561301817}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t  // Create a new PointCloud2 message to store the compressed data\n  sensor_msgs::PointCloud2 compressed_msg;\n\n  // Convert the input message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Create an octree compression object\n  pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\n  // Compress the point cloud\n  std::vector<uint8_t> compressed_data;\n  octree_compression.encodePointCloud(cloud, compressed_data);\n\n  // Create a string to store the compressed data\n  std::string compressed_data_str;\n\n  // Copy the compressed data into the string\n  std::memcpy(&compressed_data_str[0], compressed_data.data(), compressed_data.size());\n\n  // Set the compressed data in the output message\n  compressed_msg.data = compressed_data_str;\n\n  // Set the size of the compressed data in the output message\n  compressed_msg.size = compressed_data.size();\n\n  // Return the compressed message\n  return compressed_msg;\n}", "CodeBleu_score": 39.70928754778489}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 96.75999708297736}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 86.38256457558022}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t  for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n    if (this->multi_uav_state_.uav_state_all[i].id == uav_state.id) {\n      this->multi_uav_state_.uav_state_all[i] = uav_state;\n      break;\n    }\n  }\n}", "CodeBleu_score": 88.27753170308547}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    // Initialize a MultiUGVState message\n    ugv_msgs::MultiUGVState m_ugv_state_all;\n    m_ugv_state_all.header.stamp = ros::Time::now();\n    m_ugv_state_all.header.frame_id = \"world\";\n    m_ugv_state_all.ugv_state_all.clear();\n\n    // Initialize a UGVState message\n    ugv_msgs::UGVState m_ugv_state;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (std::vector<UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); ++it) {\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        m_ugv_state.id = it->id;\n        m_ugv_state.battery = it->battery;\n        m_ugv_state.pos.x = it->pos.x;\n        m_ugv_state.pos.y = it->pos.y;\n        m_ugv_state.pos.z = it->pos.z;\n        m_ugv_state.vel.x = it->vel.x;\n        m_ugv_state.vel.y = it->vel.y;\n        m_ugv_state.vel.z = it->vel.z;\n        m_ugv_state.att.x = it->att.x;\n        m_ugv_state.att.y = it->att.y;\n        m_ugv_state.att.z = it->att.z;\n        m_ugv_state.att.w = it->att.w;\n\n        // Increment the UGV count and add the UGVState to the MultiUGVState message\n        m_ugv_state_all.ugv_count++;\n        m_", "CodeBleu_score": 45.0311253655455}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    // Initialize the MultiUGVState message\n    MultiUGVState multi_ugv_state;\n    multi_ugv_state.ugv_count = 0;\n    multi_ugv_state.ugv_state_all.clear();\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (std::vector<UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); ++it) {\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        UGVState ugv_state;\n        ugv_state.id = it->id;\n        ugv_state.battery = it->battery;\n        ugv_state.position.x = it->position.x;\n        ugv_state.position.y = it->position.y;\n        ugv_state.position.z = it->position.z;\n        ugv_state.velocity.x = it->velocity.x;\n        ugv_state.velocity.y = it->velocity.y;\n        ugv_state.velocity.z = it->velocity.z;\n        ugv_state.attitude.x = it->attitude.x;\n        ugv_state.attitude.y = it->attitude.y;\n        ugv_state.attitude.z = it->attitude.z;\n        ugv_state.attitude.w = it->attitude.w;\n\n        // Increment the UGV count and add the UGVState to the MultiUGVState message\n        multi_ugv_state.ugv_count++;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n    }\n\n    // Publish the assembled MultiUGVState message\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 50.564385647242574}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  // Initialize the MultiUGVState message\n  multi_ugv_state.header.stamp = ros::Time::now();\n  multi_ugv_state.header.frame_id = \"world\";\n  multi_ugv_state.ugv_count = 0;\n  multi_ugv_state.ugv_state_all.clear();\n\n  // Iterate through each UGV state in the provided MultiUGVState structure\n  for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); ++it) {\n    // Initialize the UGVState message for the current UGV\n    ugv_state.id = it->id;\n    ugv_state.battery = it->battery;\n    ugv_state.position = it->position;\n    ugv_state.velocity = it->velocity;\n    ugv_state.attitude = it->attitude;\n\n    // Increment the UGV count and add the UGVState to the MultiUGVState message\n    multi_ugv_state.ugv_count++;\n    multi_ugv_state.ugv_state_all.push_back(ugv_state);\n  }\n\n  // Publish the assembled MultiUGVState message\n  m_multi_ugv_state.all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 38.27236094502246}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    // TODO: add moving object cost\n    cost = 0.0;\n    gradient.setZero();\n    for (int i = 0; i < q.cols(); i++) {\n        // Get predicted positions of moving objects\n        Eigen::MatrixXd obj_prid;\n        moving_objs_->evaluateConstVel(q.col(i), obj_prid);\n\n        // Iterate through moving objects\n        for (int j = 0; j < moving_objs_->getObjNums(); j++) {\n            // Compute distance between control point and predicted position of moving object\n            double dist = (cps_.points.col(i) - obj_prid.col(j)).norm();\n\n            // Check if distance is less than clearance\n            if (dist < clearance_) {\n                // Compute cost and gradient based on distance error\n                double dist_cost = pow(dist - clearance_, 2);\n                cost += dist_cost;\n                Eigen::VectorXd dist_grad = (cps_.points.col(i) - obj_prid.col(j)).normalized() * 2 * (dist - clearance_);\n                gradient.col(i) += dist_grad;\n            }\n        }\n    }\n}", "CodeBleu_score": 47.758058769116204}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    double dist;\n    double dist_grad;\n    double dist_grad_sq;\n    double dist_sq;\n    double dist_sq_grad;\n    double dist_sq_grad_sq;\n    double dist_sq_grad_sq_grad;\n    double dist_sq_grad_sq_grad_sq;\n    double dist_sq_grad_sq_grad_sq_grad;\n    double dist_sq_grad_sq_grad_sq_grad_sq;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad;\n    double dist_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq_grad_sq;\n    double dist_sq_grad_sq_grad_sq_grad_", "CodeBleu_score": 7.989221410970426}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0;\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n    double obj_prid;\n    for (int i = 0; i < q.cols(); i++) {\n        for (int j = 0; j < moving_objs_->getObjNums(); j++) {\n            obj_prid = moving_objs_->evaluateConstVel(ros::Time::now().toSec(), j, q.col(i))(0);\n            if ((cps_.points.col(i) - obj_prid).norm() < moving_objs_->getObjRad(j)) {\n                cost += pow((cps_.points.col(i) - obj_prid).norm() - moving_objs_->getObjRad(j), 2);\n                gradient.col(i) += 2 * (cps_.points.col(i) - obj_prid).normalized() * (cps_.points.col(i) - obj_prid).norm();\n            }\n        }\n    }\n}", "CodeBleu_score": 41.4496884489369}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0;\n    gradient.setZero();\n\n    // Iterate through the control points\n    for (int i = 2; i < ref_pts_.rows(); i++) {\n        // Compute the positional error and velocity vectors\n        Eigen::Vector3d pos_err = q.col(i) - ref_pts_.col(i);\n        Eigen::Vector3d vel = (q.col(i) - q.col(i - 1)) / dt_;\n\n        // Compute the squared dot product and cross product of the vectors\n        double dot_prod = pos_err.dot(vel);\n        Eigen::Vector3d cross_prod = pos_err.cross(vel);\n\n        // Normalize the dot product and cross product by constants a2 and b2\n        double a2 = std::max(dot_prod * dot_prod / (pos_err.norm() * pos_err.norm()), 1e-12);\n        double b2 = std::max(cross_prod.norm() * cross_prod.norm() / (vel.norm() * vel.norm()), 1e-12);\n\n        // Update the cost and gradient\n        cost += a2 + b2;\n        gradient.col(i) += (2 * a2 * pos_err + b2 * cross_prod) / (pos_err.norm() * pos_err.norm());\n    }\n}", "CodeBleu_score": 38.011786878936114}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0;\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n  double a2 = 100;\n  double b2 = 100;\n  double c2 = 100;\n\n  for (int i = 2; i < ref_pts_.size(); i++) {\n    Eigen::Vector3d x = (q.row(i) - q.row(i - 2)).normalized();\n    Eigen::Vector3d v = (q.row(i) - q.row(i - 1)).normalized();\n    Eigen::Vector3d xcrossv = x.cross(v);\n    double xdotv = x.dot(v);\n\n    cost += a2 * xdotv * xdotv + b2 * xcrossv.norm() * xcrossv.norm() + c2 * x.norm() * x.norm();\n\n    Eigen::Vector3d grad_xdotv = 2 * a2 * xdotv * x;\n    Eigen::Vector3d grad_xcrossv = 2 * b2 * xcrossv.norm() * xcrossv;\n    Eigen::Vector3d grad_xnorm = 2 * c2 * x.norm() * x;\n\n    gradient.row(i) += grad_xdotv + grad_xcrossv + grad_xnorm;\n    gradient.row(i - 1) -= grad_xdotv + grad_xcrossv + grad_xnorm;\n    gradient.row(i - 2) += grad_xdotv + grad_xcrossv + grad_xnorm;\n  }\n}", "CodeBleu_score": 46.85685511822183}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0;\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    const double a2 = 1e-3;\n    const double b2 = 1e-2;\n\n    for (int i = 2; i < q.rows(); i++) {\n        // Compute the positional error relative to reference points\n        Eigen::Vector3d pos_error = (q.row(i) - ref_pts_[i]).normalized();\n\n        // Compute the velocity vector\n        Eigen::Vector3d v = (q.row(i) - q.row(i - 2)).normalized();\n\n        // Compute the squared dot product and cross product of the vectors\n        double dot_prod = pos_error.dot(v);\n        Eigen::Vector3d cross_prod = pos_error.cross(v);\n\n        // Normalize the dot product and cross product by constants a2 and b2\n        double a2_dot_prod = a2 * dot_prod;\n        double b2_cross_prod = b2 * cross_prod.norm();\n\n        // Update the cost and gradient\n        cost += a2_dot_prod * a2_dot_prod + b2_cross_prod * b2_cross_prod;\n        gradient.row(i) += a2 * 2 * a2_dot_prod * v.transpose() + b2 * 2 * b2_cross_prod * cross_prod.transpose();\n    }\n}", "CodeBleu_score": 39.257238871131825}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t  double jerk = 0;\n  double knot_time;\n  double knot_time_diff;\n  double knot_time_diff_squared;\n  double knot_time_diff_cubed;\n  double knot_time_diff_to_the_fourth;\n  double knot_time_diff_to_the_fifth;\n  double knot_time_diff_to_the_sixth;\n  double knot_time_diff_to_the_seventh;\n  double knot_time_diff_to_the_eighth;\n  double knot_time_diff_to_the_ninth;\n  double knot_time_diff_to_the_tenth;\n  double knot_time_diff_to_the_eleventh;\n  double knot_time_diff_to_the_twelfth;\n  double knot_time_diff_to_the_thirteenth;\n  double knot_time_diff_to_the_fourteenth;\n  double knot_time_diff_to_the_fifteenth;\n  double knot_time_diff_to_the_sixteenth;\n  double knot_time_diff_to_the_seventeenth;\n  double knot_time_diff_to_the_eighteenth;\n  double knot_time_diff_to_the_nineteenth;\n  double knot_time_diff_to_the_twentieth;\n  double knot_time_diff_to_the_twenty_first;\n  double knot_time_diff_to_the_twenty_second;\n  double knot_time_diff_to_the_twenty_third;\n  double knot_time_diff_to_the_twenty_fourth;\n  double knot_time_diff_to_the_twenty_fifth;\n  double knot_time_diff_to_the_twenty_sixth;\n  double knot_time_diff_to_the_twenty_seventh;\n  double knot_time_diff_to_the_twenty_eighth;\n  double knot_time_diff_to_the_twenty_ninth;\n  double knot_time_diff_to_the_thirt", "CodeBleu_score": 5.538136943459648}, {"code": "double UniformBspline::getJerk(){\n\t    // Get the third derivative of the spline\n    UniformBspline jerk_traj = getDerivative().getDerivative();\n\n    // Get the knot times and control points of the jerk trajectory\n    double knot_times[jerk_traj.getKnot().size()];\n    double ctrl_pts[jerk_traj.getControlPoint().rows()][jerk_traj.getControlPoint().cols()];\n    for (int i = 0; i < jerk_traj.getKnot().size(); i++) {\n        knot_times[i] = jerk_traj.getKnot()[i];\n    }\n    for (int i = 0; i < jerk_traj.getControlPoint().rows(); i++) {\n        for (int j = 0; j < jerk_traj.getControlPoint().cols(); j++) {\n            ctrl_pts[i][j] = jerk_traj.getControlPoint()(i, j);\n        }\n    }\n\n    // Compute the total jerk value\n    double jerk = 0;\n    for (int i = 0; i < jerk_traj.getControlPoint().rows(); i++) {\n        for (int j = 0; j < jerk_traj.getControlPoint().cols(); j++) {\n            jerk += ctrl_pts[i][j] * ctrl_pts[i][j] * (knot_times[i+1] - knot_times[i]);\n        }\n    }\n\n    return jerk;\n}", "CodeBleu_score": 47.70676385947413}, {"code": "double UniformBspline::getJerk(){\n\t  // Calculate the third derivative of the spline\n  UniformBspline jerk_traj = getDerivative().getDerivative();\n\n  // Get the knot times and control points of the jerk trajectory\n  vector<double> knot_times = jerk_traj.getKnot();\n  vector<vector<double>> ctrl_pts = jerk_traj.getControlPoint();\n\n  // Initialize the total jerk value\n  double jerk = 0;\n\n  // Iterate through the control points and dimensions\n  for (int i = 0; i < ctrl_pts.size(); i++) {\n    for (int j = 0; j < ctrl_pts[i].size(); j++) {\n      // Sum the squared control point values multiplied by the differences in knot times\n      jerk += pow(ctrl_pts[i][j], 2) * (knot_times[i+1] - knot_times[i]);\n    }\n  }\n\n  // Return the total jerk value\n  return jerk;\n}", "CodeBleu_score": 56.94312563915521}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    return Eigen::Vector4d(\n        (u - cx_) * depth / fx_,\n        (v - cy_) * depth / fy_,\n        depth,\n        1.0\n    );\n}", "CodeBleu_score": 42.420552481686315}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t  return Eigen::Vector4d(\n    (u - cx_) * depth / fx_,\n    (v - cy_) * depth / fy_,\n    depth,\n    1\n  );\n}", "CodeBleu_score": 41.10741373819526}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos << (u - cx_) / fx_ * depth, (v - cy_) / fy_ * depth, depth, 1;\n    return pos;\n}", "CodeBleu_score": 41.95513722156573}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(6)));\n    } catch (const std::exception& e) {\n        std::cerr << e.what() << '\n';\n    }\n}", "CodeBleu_score": 45.40806483644527}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, odom.child_frame_id.substr(0, odom.child_frame_id.find('_')));\n    } catch (const std::exception& e) {\n        ROS_ERROR_STREAM(\"Error: \" << e.what());\n    }\n}", "CodeBleu_score": 41.914634546514094}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(5)));\n    } catch (std::exception& e) {\n        ROS_ERROR_STREAM(\"Exception caught: \" << e.what());\n    }\n}", "CodeBleu_score": 41.92987944404681}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Calculate the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = camera_pose_ * drone_poses_[drone_id];\n\n    // Check if the drone is visible in the image\n    if (true_pose(2) > 0) {\n        // Calculate the pixel position of the drone in the image\n        Eigen::Vector2d pixel_position = project(true_pose);\n\n        // Calculate the pose error between the camera and world coordinates\n        Eigen::Vector3d pose_error = true_pose - camera_pose_;\n\n        // Update the debug result\n        debug_result_.drone_id = drone_id;\n        debug_result_.true_pose = true_pose;\n        debug_result_.pixel_position = pixel_position;\n        debug_result_.pose_error = pose_error;\n\n        // Publish the pose error\n        drone_pose_err_pub_[drone_id].publish(pose_error);\n    } else {\n        // Update the debug result to indicate failure\n        debug_result_.drone_id = -1;\n        debug_result_.true_pose = Eigen::Vector3d::Zero();\n        debug_result_.pixel_position = Eigen::Vector2d::Zero();\n        debug_result_.pose_error = Eigen::Vector3d::Zero();\n    }\n}", "CodeBleu_score": 44.89970888381427}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // Compute true pose of drone in camera frame\n  Eigen::Vector3d true_pose = camera_model_->getPose(true_pixel);\n  // Check for drone presence\n  if (!checkDronePresence(drone_id, true_pose)) {\n    // Drone not found\n    debug_result_.drone_found = false;\n    return;\n  }\n  // Drone found\n  debug_result_.drone_found = true;\n  // Compute pose error\n  Eigen::Vector3d pose_error = true_pose - drone_poses_[drone_id];\n  // Publish pose error\n  drone_pose_err_pub_[drone_id].publish(pose_error);\n}", "CodeBleu_score": 28.972647325657437}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Compute the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = camera_pose_ * drone_poses_[drone_id];\n\n    // Check if the drone is visible\n    if (true_pose[2] > 0) {\n        // Compute the pixel position of the drone in the image\n        Eigen::Vector2d pixel = camera_matrix_ * true_pose.head<3>();\n        pixel /= pixel[2];\n\n        // Check if the drone is within the image bounds\n        if (pixel[0] >= 0 && pixel[0] < image_.cols && pixel[1] >= 0 && pixel[1] < image_.rows) {\n            // Compute the pose error between the camera and world coordinates\n            Eigen::Vector3d pose_error = true_pose - camera_pose_.inverse() * pixel.homogeneous();\n\n            // Update the debug result\n            debug_result_.detected = true;\n            debug_result_.drone_id = drone_id;\n            debug_result_.pixel_position = pixel;\n            debug_result_.pose_error = pose_error;\n\n            // Publish the pose error\n            drone_pose_err_pub_[drone_id].publish(pose_error);\n        } else {\n            // Update the debug result to indicate failure\n            debug_result_.detected = false;\n        }\n    } else {\n        // Update the debug result to indicate failure\n        debug_result_.detected = false;\n    }\n}", "CodeBleu_score": 43.771491329919066}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current != startNode) {\n        current = cameFrom[current];\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 76.33852897754325}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->parent != nullptr) {\n        current = current->parent;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 83.98978867982879}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->parent != nullptr) {\n        path.push_back(current->parent);\n        current = current->parent;\n    }\n    path.push_back(startNode);\n    return path;\n}", "CodeBleu_score": 73.23737612477952}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  // Convert start and end points to grid indices\n  start_idx = world_map_->coord2gridIndex(start_pt);\n  end_idx = world_map_->coord2gridIndex(end_pt);\n\n  // Check if start or end point is inside an obstacle\n  if (world_map_->isObs(start_idx)) {\n    // Adjust start point\n    while (world_map_->isObs(start_idx)) {\n      start_idx -= (start_pt - world_map_->gridIndex2coord(start_idx)).normalized();\n    }\n  }\n  if (world_map_->isObs(end_idx)) {\n    // Adjust end point\n    while (world_map_->isObs(end_idx)) {\n      end_idx -= (end_pt - world_map_->gridIndex2coord(end_idx)).normalized();\n    }\n  }\n\n  // Check if start or end point is inside an obstacle after adjustment\n  if (world_map_->isObs(start_idx) || world_map_->isObs(end_idx)) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 32.37138203626246}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  // Convert the start point to grid indices\n  start_idx = Coord2Index(start_pt);\n\n  // Check if the start point is inside an obstacle\n  if (CheckOccupancy(start_idx)) {\n    // If it is, adjust the start point by moving it away from the end point\n    Vector3d start_pt_adjusted = start_pt;\n    Vector3d end_pt_adjusted = end_pt;\n    Vector3i start_idx_adjusted = start_idx;\n    Vector3i end_idx_adjusted = end_idx;\n    while (CheckOccupancy(start_idx_adjusted)) {\n      start_pt_adjusted += (end_pt_adjusted - start_pt_adjusted).normalized() * 0.1;\n      start_idx_adjusted = Coord2Index(start_pt_adjusted);\n    }\n    start_idx = start_idx_adjusted;\n    start_pt = start_pt_adjusted;\n  }\n\n  // Convert the end point to grid indices\n  end_idx = Coord2Index(end_pt);\n\n  // Check if the end point is inside an obstacle\n  if (CheckOccupancy(end_idx)) {\n    // If it is, adjust the end point by moving it away from the start point\n    Vector3d start_pt_adjusted = start_pt;\n    Vector3d end_pt_adjusted = end_pt;\n    Vector3i start_idx_adjusted = start_idx;\n    Vector3i end_idx_adjusted = end_idx;\n    while (CheckOccupancy(end_idx_adjusted)) {\n      end_pt_adjusted -= (end_pt_adjusted - start_pt_adjusted).normalized() * 0.1;\n      end_idx_adjusted = Coord2Index(end_pt_adjusted);\n    }\n    end_idx = end_idx_adjusted;\n    end_pt = end_pt_adjusted;\n  }\n\n  // Check if the start and", "CodeBleu_score": 42.350869270153666}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    start_idx = Coord2Index(start_pt);\n    end_idx = Coord2Index(end_pt);\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_idx)) {\n        return false;\n    }\n    if (CheckOccupancy(start_idx, end_", "CodeBleu_score": 31.401521307117402}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  // Convert the minimum and maximum positions to grid indices\n  int min_id_x = (min_pos.x() - origin_.x()) / resolution_;\n  int min_id_y = (min_pos.y() - origin_.y()) / resolution_;\n  int min_id_z = (min_pos.z() - origin_.z()) / resolution_;\n  int max_id_x = (max_pos.x() - origin_.x()) / resolution_;\n  int max_id_y = (max_pos.y() - origin_.y()) / resolution_;\n  int max_id_z = (max_pos.z() - origin_.z()) / resolution_;\n\n  // Clip the grid indices to ensure they are within the bounds of the map\n  min_id_x = std::max(min_id_x, 0);\n  min_id_y = std::max(min_id_y, 0);\n  min_id_z = std::max(min_id_z, 0);\n  max_id_x = std::min(max_id_x, static_cast<int>(size_x_));\n  max_id_y = std::min(max_id_y, static_cast<int>(size_y_));\n  max_id_z = std::min(max_id_z, static_cast<int>(size_z_));\n\n  // Iterate over the grid indices and reset the occupancy and distance buffers\n  for (int i = min_id_x; i <= max_id_x; ++i) {\n    for (int j = min_id_y; j <= max_id_y; ++j) {\n      for (int k = min_id_z; k <= max_id_z; ++k) {\n        int id = getIndex(i, j, k);\n        occupancy_buffer_inflate_[id] = 0.0;\n        distance_buffer_[id] = std::numeric_limits<double>::max();\n      }\n    }\n  }\n}", "CodeBleu_score": 37.86630350998997}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    Eigen::Vector3i min_id, max_id;\n    min_id = coordToIndex(min_pos);\n    max_id = coordToIndex(max_pos);\n\n    for (int x = min_id[0]; x <= max_id[0]; x++) {\n        for (int y = min_id[1]; y <= max_id[1]; y++) {\n            for (int z = min_id[2]; z <= max_id[2]; z++) {\n                occupancy_buffer_inflate_[x][y][z] = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 46.52473504007935}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  // Get the grid coordinates of the minimum and maximum positions\n  int min_id_x = (int)((min_pos.x() - origin_position_.x()) / resolution_);\n  int min_id_y = (int)((min_pos.y() - origin_position_.y()) / resolution_);\n  int min_id_z = (int)((min_pos.z() - origin_position_.z()) / resolution_);\n  int max_id_x = (int)((max_pos.x() - origin_position_.x()) / resolution_);\n  int max_id_y = (int)((max_pos.y() - origin_position_.y()) / resolution_);\n  int max_id_z = (int)((max_pos.z() - origin_position_.z()) / resolution_);\n\n  // Check if the minimum and maximum grid coordinates are within the map's boundaries\n  if (min_id_x < 0 || min_id_y < 0 || min_id_z < 0 || max_id_x >= x_size_ ||\n      max_id_y >= y_size_ || max_id_z >= z_size_) {\n    // If not, return without doing anything\n    return;\n  }\n\n  // Iterate over the grid coordinates and set the corresponding elements in the occupancy buffer to zero\n  for (int x = min_id_x; x <= max_id_x; x++) {\n    for (int y = min_id_y; y <= max_id_y; y++) {\n      for (int z = min_id_z; z <= max_id_z; z++) {\n        int index = getIndex(x, y, z);\n        occupancy_buffer_[index] = 0.0;\n      }\n    }\n  }\n}", "CodeBleu_score": 42.707699301055854}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  double max_translation_coeff = std::numeric_limits<double>::max();\n  double min_translation_coeff = -std::numeric_limits<double>::max();\n\n  for (int i = 0; i < 3; i++) {\n    if (diff[i] > 0) {\n      max_translation_coeff = std::min(max_translation_coeff, (max_[i] - camera_pt[i]) / diff[i]);\n    } else if (diff[i] < 0) {\n      min_translation_coeff = std::max(min_translation_coeff, (min_[i] - camera_pt[i]) / diff[i]);\n    }\n  }\n\n  double translation_coeff = std::max(min_translation_coeff, max_translation_coeff);\n  return camera_pt + translation_coeff * diff;\n}", "CodeBleu_score": 47.127776878697816}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    double min_scale_x = std::numeric_limits<double>::max();\n    double min_scale_y = std::numeric_limits<double>::max();\n    double min_scale_z = std::numeric_limits<double>::max();\n    double max_scale_x = std::numeric_limits<double>::min();\n    double max_scale_y = std::numeric_limits<double>::min();\n    double max_scale_z = std::numeric_limits<double>::min();\n\n    for (int i = 0; i < 3; i++) {\n        if (diff[i] > 0) {\n            if (diff[i] / resolution_[i] > max_scale_x) {\n                max_scale_x = diff[i] / resolution_[i];\n            }\n        } else {\n            if (-diff[i] / resolution_[i] > max_scale_x) {\n                max_scale_x = -diff[i] / resolution_[i];\n            }\n        }\n        if (diff[i] < 0) {\n            if (diff[i] / resolution_[i] < min_scale_x) {\n                min_scale_x = diff[i] / resolution_[i];\n            }\n        } else {\n            if (-diff[i] / resolution_[i] < min_scale_x) {\n                min_scale_x = -diff[i] / resolution_[i];\n            }\n        }\n    }\n\n    Eigen::Vector3d min_scale(min_scale_x, min_scale_y, min_scale_z);\n    Eigen::Vector3d max_scale(max_scale_x, max_scale_y, max_scale_z);\n    double min_scale_coeff = min_scale.minCoeff();\n    double max_scale_coeff = max_scale.maxCoeff();\n\n    if (min_scale_coeff > 0 && min_scale_coeff <= max_scale_coeff) {\n        return camera_pt +", "CodeBleu_score": 48.19657946849825}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n    Eigen::Vector3d diff = pt - camera_pt;\n\n    double max_x_translation = (x_max - pt[0]) / diff[0];\n    double min_x_translation = (x_min - pt[0]) / diff[0];\n\n    double max_y_translation = (y_max - pt[1]) / diff[1];\n    double min_y_translation = (y_min - pt[1]) / diff[1];\n\n    double max_z_translation = (z_max - pt[2]) / diff[2];\n    double min_z_translation = (z_min - pt[2]) / diff[2];\n\n    double x_translation = max_x_translation;\n    double y_translation = max_y_translation;\n    double z_translation = max_z_translation;\n\n    if (min_x_translation > x_translation) {\n        x_translation = min_x_translation;\n    }\n    if (min_y_translation > y_translation) {\n        y_translation = min_y_translation;\n    }\n    if (min_z_translation > z_translation) {\n        z_translation = min_z_translation;\n    }\n\n    return pt + diff * std::min(std::min(x_translation, y_translation), z_translation);\n}", "CodeBleu_score": 35.38776227088361}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update the last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if an update is needed\n  if (md_.update_occ_map_) {\n    // Project the depth image into points and process them with raycasting\n    projectDepthImage();\n    raycastProcess();\n\n    // If the local map has been updated, clear and inflate the local map\n    if (md_.local_map_updated_) {\n      clearAndInflateLocalMap();\n    }\n\n    // Reset the update flags\n    md_.update_occ_map_ = false;\n    md_.local_map_updated_ = false;\n  }\n\n  // Handle timeout errors for odometry and depth data\n  if (ros::Time::now() - md_.last_odom_update_time_ > md_.odom_timeout_ ||\n      ros::Time::now() - md_.last_depth_update_time_ > md_.depth_timeout_) {\n    // Set the relevant flags\n    md_.odom_timeout_error_ = true;\n    md_.depth_timeout_error_ = true;\n  }\n}", "CodeBleu_score": 55.71143706471655}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update the last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if we need to update the occupancy grid\n  if (md_.update_occ_grid_ && md_.depth_image_received_) {\n    // Project the depth image into points\n    projectDepthImage();\n\n    // Process the points with raycasting\n    raycastProcess();\n\n    // If the local map has been updated, clear and inflate the local map\n    if (md_.local_map_updated_) {\n      clearAndInflateLocalMap();\n    }\n\n    // Reset the flags\n    md_.update_occ_grid_ = false;\n    md_.local_map_updated_ = false;\n  }\n\n  // Handle timeout errors for odometry or depth data\n  if (ros::Time::now().toSec() - md_.last_odom_time_.toSec() > md_.odom_timeout_) {\n    md_.odom_timeout_error_ = true;\n  }\n  if (ros::Time::now().toSec() - md_.last_depth_time_.toSec() > md_.depth_timeout_) {\n    md_.depth_timeout_error_ = true;\n  }\n}", "CodeBleu_score": 57.76553804834654}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update the last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // If an update is needed, project the depth image into points and process them\n  if (md_.update_needed_) {\n    md_.update_needed_ = false;\n    projectDepthImage();\n    raycastProcess();\n\n    // If the local map has been updated, clear and inflate the local map\n    if (md_.local_map_updated_) {\n      md_.local_map_updated_ = false;\n      clearAndInflateLocalMap();\n    }\n  }\n\n  // Handle timeout errors for odometry or depth data and set relevant flags\n  if ((ros::Time::now() - md_.last_odom_time_).toSec() > md_.odom_timeout_) {\n    md_.odom_timeout_flag_ = true;\n  } else {\n    md_.odom_timeout_flag_ = false;\n  }\n\n  if ((ros::Time::now() - md_.last_depth_time_).toSec() > md_.depth_timeout_) {\n    md_.depth_timeout_flag_ = true;\n  } else {\n    md_.depth_timeout_flag_ = false;\n  }\n}", "CodeBleu_score": 59.16453323057349}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t  float f_measure = 0;\n  for (int i = 0; i < image_fns.size(); i++) {\n    vector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n    vector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i]);\n    f_measure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses);\n  }\n  return f_measure / image_fns.size();\n}", "CodeBleu_score": 56.47901095335055}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n    float f_score = 0.0;\n    float f_score_accum = 0.0;\n    int num_images = image_fns.size();\n\n    for (int i = 0; i < num_images; i++) {\n        // Load ground truth and detected ellipses for the current image\n        vector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n        vector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i]);\n\n        // Evaluate the detection performance for the current image\n        f_score = _ellipse_evaluate_one(gt_ellipses, dt_ellipses);\n\n        // Accumulate the F-measure for all images\n        f_score_accum += f_score;\n    }\n\n    // Calculate the average F-measure\n    float f_score_avg = f_score_accum / num_images;\n\n    return f_score_avg;\n}", "CodeBleu_score": 55.77538403843224}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float f_measure_avg = 0.0;\n    for (int i = 0; i < image_fns.size(); i++) {\n        vector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n        vector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i]);\n        float f_measure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses);\n        f_measure_avg += f_measure;\n    }\n    f_measure_avg /= image_fns.size();\n    return f_measure_avg;\n}", "CodeBleu_score": 64.22418367810737}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle_diff_signed;\n    float angle_diff_abs;\n    float angle_diff_abs_signed;\n    float angle_diff_abs_signed_signed;\n    float angle_diff_abs_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed;\n    float angle_diff_abs_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed_signed", "CodeBleu_score": 4.562563270072834}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle1, angle2;\n    float diff;\n\n    if (foci == NULL) {\n        return 0.0;\n    }\n\n    angle1 = atan2(y - foci[1], x - foci[0]);\n    angle2 = atan2(y - foci[3], x - foci[2]);\n\n    diff = angle_diff_signed(angle1, angle2);\n\n    if (diff < -M_PI) {\n        diff += 2.0 * M_PI;\n    } else if (diff > M_PI) {\n        diff -= 2.0 * M_PI;\n    }\n\n    return diff;\n}", "CodeBleu_score": 54.849605200575304}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle1, angle2, angle_diff_signed;\n\n    if (foci == NULL) {\n        return 0.0;\n    }\n\n    angle1 = atan2(y - foci[1], x - foci[0]);\n    angle2 = atan2(y - foci[3], x - foci[2]);\n    angle_diff_signed = angle2 - angle1;\n\n    if (angle_diff_signed > M_PI) {\n        angle_diff_signed -= 2 * M_PI;\n    } else if (angle_diff_signed < -M_PI) {\n        angle_diff_signed += 2 * M_PI;\n    }\n\n    return angle_diff_signed;\n}", "CodeBleu_score": 52.18089570343783}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t  int i;\n  double minx, maxx, miny, maxy;\n  double integral_above, integral_below;\n\n  minx = maxx = vp1[start].x;\n  miny = maxy = vp1[start].y;\n\n  for (i = start + 1; i < end; i++) {\n    if (vp1[i].x < minx)\n      minx = vp1[i].x;\n    else if (vp1[i].x > maxx)\n      maxx = vp1[i].x;\n    if (vp1[i].y < miny)\n      miny = vp1[i].y;\n    else if (vp1[i].y > maxy)\n      maxy = vp1[i].y;\n  }\n\n  integral_above = integral_below = 0.0;\n  for (i = start; i < end; i++) {\n    if (vp1[i].x >= minx && vp1[i].x <= maxx) {\n      if (vp1[i].y < vp1[start].y)\n        integral_above += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y - vp1[start].y);\n      else\n        integral_below += (vp1[i].x - vp1[i - 1].x) * (vp1[start].y - vp1[i].y);\n    }\n  }\n\n  return integral_above < integral_below;\n}", "CodeBleu_score": 33.93701812890496}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x, max_x, min_y, max_y;\n\n\tmin_x = vp1[start].x;\n\tmax_x = vp1[start].x;\n\tmin_y = vp1[start].y;\n\tmax_y = vp1[start].y;\n\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\n\tdouble integral_above = 0, integral_below = 0;\n\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].y < min_y)\n\t\t\tintegral_above += (vp1[i].x - vp1[i + 1].x) * (min_y - vp1[i].y);\n\t\tif (vp1[i].y > max_y)\n\t\t\tintegral_below += (vp1[i].x - vp1[i + 1].x) * (max_y - vp1[i].y);\n\t}\n\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 34.90672156666317}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    // Find the minimum and maximum x and y coordinates of the points in the section\n    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n    for (int i = start + 1; i < end; i++) {\n        if (vp1[i].x < min_x) {\n            min_x = vp1[i].x;\n        } else if (vp1[i].x > max_x) {\n            max_x = vp1[i].x;\n        }\n        if (vp1[i].y < min_y) {\n            min_y = vp1[i].y;\n        } else if (vp1[i].y > max_y) {\n            max_y = vp1[i].y;\n        }\n    }\n\n    // Compute the integral above and below the polygon section\n    double integral_above = 0;\n    double integral_below = 0;\n    for (int i = start; i < end; i++) {\n        if (vp1[i].x >= min_x && vp1[i].x <= max_x) {\n            if (vp1[i].y >= min_y) {\n                integral_above += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y - min_y);\n            }\n            if (vp1[i].y <= max_y) {\n                integral_below += (vp1[i].x - vp1[i - 1].x) * (max_y - vp1[i].y);\n            }\n        }\n    }\n\n    // If the integral above is less than the integral below, the section is convex\n    return integral_above < integral_below;\n}", "CodeBleu_score": 36.23479297294722}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (int i = 0; i < msg->detections.size(); i++) {\n        if (msg->detections[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        } else if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n        if (is_detected) {\n            ellipse_det.sight_angle_1 = msg->detections[i].sight_angle_1;\n            ellipse_det.sight_angle_2 = msg->detections[i].sight_angle_2;\n        }\n    }\n}", "CodeBleu_score": 65.81803300548918}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  for (int i = 0; i < msg->detections.size(); i++) {\n    if (msg->detections[i].name == \"T\") {\n      num_regain++;\n      num_lost = 0;\n    } else {\n      num_regain = 0;\n      num_lost++;\n    }\n    if (num_lost > VISION_THRES) {\n      is_detected = false;\n    } else if (num_regain > VISION_THRES) {\n      is_detected = true;\n    }\n  }\n  ellipse_det.sight_angle = -ellipse_det.sight_angle;\n}", "CodeBleu_score": 58.52013891481145}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  prometheus_msgs::DetectionInfo det;\n  for (int i = 0; i < msg->detections.size(); i++) {\n    det = msg->detections[i];\n    if (det.name == \"T\") {\n      num_regain++;\n      num_lost = 0;\n      if (num_regain > VISION_THRES) {\n        is_detected = true;\n      }\n    } else {\n      num_regain = 0;\n      num_lost++;\n      if (num_lost > VISION_THRES) {\n        is_detected = false;\n      }\n    }\n  }\n  // Swap sight_angle values\n  ellipse_det.sight_angle_1 = msg->detections[0].sight_angle_2;\n  ellipse_det.sight_angle_2 = msg->detections[0].sight_angle_1;\n}", "CodeBleu_score": 65.50983569577474}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    return Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 45.68302491297701}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    if (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 45.605529573253236}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    // Check if the position is within the occupancy map\n    if (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 45.71135752887545}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    while (current_node != start_node_) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n    path_nodes_.push_back(start_node_);\n    reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 59.08129681257657}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    while (current_node->parent_ != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent_;\n    }\n    path_nodes_.push_back(current_node);\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 65.57108588383753}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    // Trace path back to start node\n    NodePtr current_node = end_node;\n    while (current_node != start_node_) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n    path_nodes_.push_back(current_node);\n\n    // Reverse path to present from start to end\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 63.19721165236768}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id].position.x = odom->pose.pose.position.x;\n    state_nei[id].position.y = odom->pose.pose.position.y;\n    state_nei[id].position.z = odom->pose.pose.position.z;\n    state_nei[id].orientation = odom->pose.pose.orientation;\n    state_nei[id].velocity.linear.x = odom->twist.twist.linear.x;\n    state_nei[id].velocity.linear.y = odom->twist.twist.linear.y;\n    state_nei[id].velocity.linear.z = odom->twist.twist.linear.z;\n    state_nei[id].velocity.angular.x = odom->twist.twist.angular.x;\n    state_nei[id].velocity.angular.y = odom->twist.twist.angular.y;\n    state_nei[id].velocity.angular.z = odom->twist.twist.angular.z;\n\n    if(simulation_mode) {\n        if((start_pos-state_nei[id]).norm() > 5) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    } else {\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 60.0247696640268}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id].x = odom->pose.pose.position.x;\n    state_nei[id].y = odom->pose.pose.position.y;\n    state_nei[id].z = odom->pose.pose.position.z;\n    state_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\n    if(sim_mode){\n        if((start_pos-state_nei[id]).norm() > 5){\n            get_nei_state = false;\n        }\n        else{\n            get_nei_state = true;\n        }\n    }\n    else{\n        get_nei_state = true;\n    }\n}", "CodeBleu_score": 48.09810249853213}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id] = Eigen::Vector3d(odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n    if (simulation_mode) {\n        if ((start_pos-state_nei[id]).norm() > 5) {\n            get_nei_state = false;\n        }\n        else {\n            get_nei_state = true;\n        }\n    }\n    else {\n        get_nei_state = true;\n    }\n}", "CodeBleu_score": 44.41594527737638}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  update_count++;\n\n  if (update_count == 5) {\n    update_count = 0;\n    Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg, Astar_ptr->Occupy_map_ptr->map_ptr);\n  }\n}", "CodeBleu_score": 59.384702827590594}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready)\n        return;\n\n    sensor_ready = true;\n    update_counter++;\n\n    if (update_counter % 5 == 0) {\n        update_counter = 0;\n        Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n    }\n}", "CodeBleu_score": 51.53488180324424}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!sensor_ready)\n    return;\n\n  update_counter++;\n\n  if (update_counter % 5 == 0) {\n    update_counter = 0;\n    ROS_INFO(\"[GlobalPlannerUGV] Updating map with new point cloud data\");\n    Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n  }\n}", "CodeBleu_score": 47.17079221871171}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n  if (!get_gpcl) {\n    get_gpcl = true;\n\n    // convert sensor message to point cloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_msg(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*global_point, *cloud_msg);\n\n    // store point cloud\n    cloud_msg->header.frame_id = \"map\";\n    global_map = *cloud_msg;\n\n    // inflate point cloud\n    inflate_point_cloud(global_map);\n  }\n}", "CodeBleu_score": 55.306912307758196}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl == false) {\n    get_gpcl = true;\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*global_point, *cloud);\n    cloud_global = cloud;\n    inflate_point_cloud(cloud_global);\n  }\n}", "CodeBleu_score": 57.16851427403328}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl) {\n    return;\n  }\n  get_gpcl = true;\n  pcl::PointCloud<pcl::PointXYZ>::Ptr global_point_cloud(new pcl::PointCloud<pcl::PointXYZ>());\n  pcl::PointCloud<pcl::PointXYZ>::Ptr global_point_cloud_inflate(new pcl::PointCloud<pcl::PointXYZ>());\n  pcl::fromROSMsg(*global_point, *global_point_cloud);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr global_point_cloud_inflate_ptr(global_point_cloud_inflate);\n  inflate_point_cloud(global_point_cloud, global_point_cloud_inflate_ptr);\n  global_point_cloud_inflate_ptr->header = global_point->header;\n  global_map_pub.publish(*global_point_cloud_inflate_ptr);\n}", "CodeBleu_score": 58.96533278503422}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t  // Create a PointCloud2 object to store the laser scan data\n  sensor_msgs::PointCloud2 cloud_msg;\n\n  // Convert the laser scan data to a PointCloud2 format\n  projector_.projectLaser(*local_point, cloud_msg);\n\n  // Convert the PointCloud2 message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(cloud_msg, *cloud);\n\n  // Update the occupancy map using the PointCloud\n  map_update_pointcloud(cloud, odom);\n}", "CodeBleu_score": 47.40465621817413}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud(new pcl::PointCloud<pcl::PointXYZ>());\n    pcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>());\n\n    pcl::fromROSMsg(*local_point, *laser_cloud);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>());\n    pcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>());\n\n    // Filtering the laser scan data using a PassThrough filter to remove points that are too close or too far away from the robot.\n    pcl::PassThrough<pcl::PointXYZ> pass;\n    pass.setInputCloud(laser_cloud);\n    pass.setFilterFieldName(\"z\");\n    pass.setFilterLimits(0.0, 10.0);\n    pass.filter(*laser_cloud_filtered);\n\n    // Downsampling the filtered laser scan data using a VoxelGrid filter to reduce the number of points in the cloud.\n    pcl::VoxelGrid<pcl::PointXYZ> vox;\n    vox.setInputCloud(laser_cloud_filtered);\n    vox.setLeafSize(0.2, 0.2, 0.2);\n    vox.filter(*laser_cloud_filtered_downsampled);\n\n    // Transforming the filtered and downsampled laser scan data into the map frame.\n    Eigen::Affine3f transform = Eigen::Affine3f::Identity();\n    transform.translation() << odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z;\n    transform.rotate(Eigen::Quaternionf(odom.pose.pose.orientation.w, odom.pose.pose.orientation.x,", "CodeBleu_score": 41.09616875657568}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    // Project laser scan to a point cloud\n    sensor_msgs::PointCloud2 cloud;\n    projector_.projectLaser(*local_point, cloud);\n\n    // Convert point cloud to pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(cloud, *cloud_pcl);\n\n    // Update occupancy grid map using point cloud\n    if (!sim_mode_) {\n        // Merge local map with odometry data\n        Eigen::Matrix4f transform;\n        tf::transformMsgToEigen(odom.pose.pose, transform);\n        local_map_merge_odom(cloud_pcl, transform);\n    } else {\n        // Update occupancy grid map directly using point cloud\n        update_map(cloud_pcl);\n    }\n}", "CodeBleu_score": 56.80101256969311}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    sensor_msgs::PointCloud2 global_pcl_msg;\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(*global_pcl, global_pcl_msg);\n    pcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_msg);\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 59.16925539127122}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr global_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr inflate_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\n    // Get the global point cloud\n    occupy_map_.get_global_pcl(global_pcl);\n\n    // Get the inflated point cloud\n    occupy_map_.get_inflate_pcl(inflate_pcl);\n\n    // Convert the point cloud to a ROS message\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(*global_pcl, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n\n    // Publish the global point cloud\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // Convert the inflated point cloud to a ROS message\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n\n    // Publish the inflated point cloud\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 54.25887977833072}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Convert the global point cloud map to a ROS message and publish it with the frame ID \"world\" to the global_pcl_pub topic\n    pcl::toROSMsg(global_map, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // Convert and publish the inflated point cloud to the inflate_pcl_pub topic with the same frame ID\n    pcl::toROSMsg(inflated_map, inflated_pcl_msg);\n    inflated_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflated_pcl_msg);\n}", "CodeBleu_score": 45.77867383378073}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    // Update the map\n    if (sensor_ready) {\n        Occupy_map_ptr->map_update_lpcl(msg);\n    }\n}", "CodeBleu_score": 40.28810882606092}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (sensor_ready) {\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg, *cloud);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_transformed_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_transformed_transformed_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_transformed_transformed_transformed_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_transformed_transformed_transformed_transformed_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_transformed_transformed_transformed_transformed_transformed_transformed_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::", "CodeBleu_score": 35.388203044296404}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  //ROS_INFO(\"Point cloud received\");\n  if (sensor_ready) {\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Point cloud received", "CodeBleu_score": 9.110846557518606}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Calculate target foot positions based on desired pose\n    std::vector<Eigen::Vector3d> target_foot_positions;\n    body_controller_.getTargetFootPositions(target_foot_positions);\n\n    // Compute velocity commands for the legs\n    std::vector<Eigen::Vector3d> leg_velocity_commands;\n    leg_controller_.computeVelocityCommands(target_foot_positions, leg_velocity_commands);\n\n    // Perform inverse kinematics to determine target joint positions\n    std::vector<Eigen::VectorXd> joint_positions;\n    kinematics_.inverse(leg_velocity_commands, joint_positions);\n\n    // Publish foot contact information\n    publishFootContacts_(event.current_real);\n\n    // Publish joint positions\n    publishJoints_(joint_positions, event.current_real);\n}", "CodeBleu_score": 50.1076298919041}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Get current time\n  const ros::Time current_time = ros::Time::now();\n\n  // Get desired body pose from the body controller\n  const Eigen::Vector3d body_position = body_controller_.poseCommand(current_time);\n  const Eigen::Quaterniond body_orientation = body_controller_.poseCommand(current_time);\n\n  // Compute target foot positions based on desired body pose\n  Eigen::Vector3d target_feet_position[4];\n  for (int i = 0; i < 4; i++) {\n    target_feet_position[i] = body_position + body_orientation * foot_offsets_[i];\n  }\n\n  // Compute velocity commands for the legs\n  Eigen::Vector3d leg_velocity[4];\n  for (int i = 0; i < 4; i++) {\n    leg_velocity[i] = body_controller_.velocityCommand(current_time, target_feet_position[i]);\n  }\n\n  // Perform inverse kinematics to determine target joint positions\n  Eigen::VectorXd target_joint_positions[4];\n  for (int i = 0; i < 4; i++) {\n    target_joint_positions[i] = kinematics_.inverse(target_feet_position[i], leg_velocity[i]);\n  }\n\n  // Publish foot contact information\n  publishFootContacts_(current_time);\n\n  // Publish joint positions\n  publishJoints_(current_time, target_joint_positions);\n}", "CodeBleu_score": 46.948337811328486}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Calculate target foot positions\n    for (int i = 0; i < 4; i++) {\n        body_controller_.poseCommand.position.x = body_controller_.poseCommand.position.x + body_controller_.poseCommand.position.x * 0.1;\n        body_controller_.poseCommand.position.y = body_controller_.poseCommand.position.y + body_controller_.poseCommand.position.y * 0.1;\n        body_controller_.poseCommand.position.z = body_controller_.poseCommand.position.z + body_controller_.poseCommand.position.z * 0.1;\n        body_controller_.poseCommand.orientation.x = body_controller_.poseCommand.orientation.x + body_controller_.poseCommand.orientation.x * 0.1;\n        body_controller_.poseCommand.orientation.y = body_controller_.poseCommand.orientation.y + body_controller_.poseCommand.orientation.y * 0.1;\n        body_controller_.poseCommand.orientation.z = body_controller_.poseCommand.orientation.z + body_controller_.poseCommand.orientation.z * 0.1;\n        body_controller_.poseCommand.orientation.w = body_controller_.poseCommand.orientation.w + body_controller_.poseCommand.orientation.w * 0.1;\n\n        leg_controller_.velocityCommand[i] = body_controller_.calculateLegVelocityCommand(i);\n        leg_controller_.targetPosition[i] = kinematics_.inverse(leg_controller_.velocityCommand[i]);\n    }\n\n    // Publish foot contact information\n    publishFootContacts_();\n\n    // Publish joint positions\n    publishJoints_();\n}", "CodeBleu_score": 39.59335069448769}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_ && !gazebo_) {\n    contacts_msg.header.stamp = ros::Time::now();\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i].state = foot_contacts[i] ? 1 : 0;\n      contacts_msg.contacts[i].phase = base_.legs[i]->gait_phase;\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 54.91289647908919}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_ && !gazebo_mode_) {\n    contacts_msg.header.stamp = ros::Time::now();\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i].gait_phase = base_.legs[i]->gait_phase;\n      contacts_msg.contacts[i].contact_state = foot_contacts[i];\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 55.214675185509854}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contact_publishing_ && !ros::isInitialized()) {\n    return;\n  }\n  if (foot_contact_publishing_) {\n    contacts_msg.header.stamp = ros::Time::now();\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i].state = foot_contacts[i];\n      contacts_msg.contacts[i].phase = base_.legs[i]->gait_phase;\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 54.23746630179489}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t  if joints.position.size() < 12 {\n    return\n  }\n  joints_msg = JointState()\n  joints_msg.position = joints.position[0:12]\n  self.joints_pub.publish(joints_msg)\n  joint_trajectory_msg = JointTrajectory()\n  joint_trajectory_msg.joint_names = joints.name[0:12]\n  point = JointTrajectoryPoint()\n  point.positions = joints.position[0:12]\n  point.time_from_start = Duration(sec=1)\n  joint_trajectory_msg.points.append(point)\n  self.joint_trajectory_pub.publish(joint_trajectory_msg)\n}", "CodeBleu_score": 53.66759659126451}, {"code": "def joints_cmd_callback(self, joints){\n\t    self.joints_msg.position = joints.position[0:12]\n    self.joints_pub.publish(self.joints_msg)\n\n    self.joint_trajectory_msg.joint_names = joints.name\n    self.joint_trajectory_msg.points[0].positions = joints.position[0:12]\n    self.joint_trajectory_msg.points[0].time_from_start = rospy.Duration(1.0)\n    self.joint_trajectory_pub.publish(self.joint_trajectory_msg)\n}", "CodeBleu_score": 29.55117286663277}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message\n    joints_msg = JointState()\n    joints_msg.position = joints.position[:12]\n    joints_msg.velocity = joints.velocity[:12]\n    joints_msg.effort = joints.effort[:12]\n    joints_msg.header.stamp = rospy.Time.now()\n    self.joints_pub.publish(joints_msg)\n\n    # Construct a trajectory message\n    trajectory_msg = JointTrajectory()\n    trajectory_msg.joint_names = joints.name[:12]\n    trajectory_msg.points.append(JointTrajectoryPoint(positions=joints.position[:12], time_from_start=rospy.Duration(2.0)))\n\n    # Publish the trajectory message\n    self.trajectory_pub.publish(trajectory_msg)\n}", "CodeBleu_score": 46.06936258029121}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    // initialize foot contact states to false\n    for (int i = 0; i < 4; i++) {\n        footContact_[i] = false;\n    }\n\n    // for each contact in the message, split the collision string to identify the contact link\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        std::string collision1 = _msg->contact(i).collision1();\n        std::string collision2 = _msg->contact(i).collision2();\n        std::vector<std::string> collision1_split;\n        boost::split(collision1_split, collision1, boost::is_any_of(\"::\"));\n        std::vector<std::string> collision2_split;\n        boost::split(collision2_split, collision2, boost::is_any_of(\"::\"));\n\n        // if a contact matches one of the foot links, set the corresponding foot contact state to true\n        if (collision1_split[1] == \"foot_link\") {\n            footContact_[0] = true;\n        } else if (collision2_split[1] == \"foot_link\") {\n            footContact_[0] = true;\n        } else if (collision1_split[1] == \"foot_link2\") {\n            footContact_[1] = true;\n        } else if (collision2_split[1] == \"foot_link2\") {\n            footContact_[1] = true;\n        } else if (collision1_split[1] == \"foot_link3\") {\n            footContact_[2] = true;\n        } else if (collision2_split[1] == \"foot_link3\") {\n            footContact_[2] = true;\n        } else if (collision1_split[1] == \"foot_link4\") {\n            footContact_[3] = true;\n        } else if (collision2_split[1] == \"foot_link4\") {\n            footContact_[3] = true;\n        }\n    }\n}", "CodeBleu_score": 52.792433722546825}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::string link_name = _msg->contact(i).collision1();\n    if (link_name == \"left_sole_link\") {\n      left_foot_contact_ = true;\n    } else if (link_name == \"right_sole_link\") {\n      right_foot_contact_ = true;\n    }\n  }\n}", "CodeBleu_score": 33.1117055072109}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    // Reset contact states\n    for (int i = 0; i < num_legs_; ++i) {\n        contact_states_[i] = false;\n    }\n\n    // Check contact for each leg\n    for (int i = 0; i < _msg->contact_size(); ++i) {\n        // Get contact link name\n        std::string collision1_name = _msg->contact(i).collision1();\n        std::string collision2_name = _msg->contact(i).collision2();\n\n        // Check if contact is one of the feet\n        for (int j = 0; j < num_legs_; ++j) {\n            if (collision1_name.find(foot_link_names_[j]) != std::string::npos) {\n                contact_states_[j] = true;\n                break;\n            }\n            if (collision2_name.find(foot_link_names_[j]) != std::string::npos) {\n                contact_states_[j] = true;\n                break;\n            }\n        }\n    }\n}", "CodeBleu_score": 61.177662223323395}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n  if (!controller_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  Eigen::Vector3d angular_acceleration_thrust;\n  ComputeDesiredAcceleration(&acceleration);\n  ComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n  Eigen::Vector3d thrust_body = odometry_.orientation.toRotationMatrix().col(2) *\n      vehicle_parameters_.rotor_configuration_.thrust_coefficient;\n  Eigen::Vector3d acceleration_thrust = acceleration + thrust_body;\n  angular_acceleration_thrust += acceleration_thrust;\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  rotor_velocities->head(4) =\n      angular_acceleration_thrust.cwiseProduct(\n          vehicle_parameters_.rotor_configuration_.rotor_directions)\n          .cwiseMax(0.0);\n  rotor_velocities->tail(4) = -rotor_velocities->head(4);\n  rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 51.00127915030992}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t    assert(rotor_velocities);\n\n    // If the controller is not active, set all rotor velocities to zero.\n    if (!controller_active_) {\n        rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n        rotor_velocities->setZero();\n        return;\n    }\n\n    // Compute the desired acceleration and angular acceleration.\n    Eigen::Vector3d acceleration = ComputeDesiredAcceleration();\n    Eigen::Vector3d angular_acceleration = ComputeDesiredAngularAcc();\n\n    // Project thrust onto the body z-axis and combine angular acceleration and thrust into a single vector.\n    Eigen::Vector3d acceleration_thrust = odometry_.orientation.toRotationMatrix().col(2).cwiseProduct(acceleration);\n    Eigen::Vector3d angular_acceleration_thrust = angular_acceleration + acceleration_thrust;\n\n    // Compute the rotor velocities by multiplying with a predefined matrix, ensuring non-negative values, and taking the square root of each component.\n    rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n    rotor_velocities->setZero();\n    rotor_velocities->head(4) = rotor_velocities_matrix_ * angular_acceleration_thrust;\n    rotor_velocities->cwiseMax(0.0);\n    rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 47.804677909294526}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n\n  if (!active_) {\n    rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAcceleration(&acceleration, &angular_acceleration);\n\n  Eigen::Vector3d acceleration_thrust;\n  acceleration_thrust.z() = acceleration.norm();\n  if (acceleration_thrust.z() > 0.0) {\n    acceleration_thrust.normalize();\n  }\n  acceleration_thrust *= acceleration_thrust.z() * vehicle_parameters_.mass_;\n\n  Eigen::Vector3d angular_acceleration_thrust;\n  angular_acceleration_thrust = odometry_.orientation.toRotationMatrix().col(2).cross(acceleration_thrust);\n\n  Eigen::Vector3d acceleration_thrust_angular_acceleration_thrust = angular_acceleration_thrust + acceleration_thrust;\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  rotor_velocities->setZero();\n  rotor_velocities->head(4) = rotor_velocities_matrix_.block<4, 3>(0, 0) * acceleration_thrust_angular_acceleration_thrust;\n  rotor_velocities->tail(4) = rotor_velocities_matrix_.block<4, 3>(4, 0) * acceleration_thrust_angular_acceleration_thrust;\n\n  rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->size()));\n  rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 58.187612362819785}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // Calculate the position and velocity errors\n  Eigen::Vector3d position_error = odometry_.position - command_trajectory_.position;\n  Eigen::Vector3d velocity_error = odometry_.orientation.toRotationMatrix() * odometry_.velocity - command_trajectory_.velocity;\n\n  // Transform the velocity to the world frame\n  Eigen::Vector3d velocity_world = odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n\n  // Compute the desired acceleration\n  Eigen::Vector3d acceleration_desired = position_error.cwiseProduct(position_gains_) +\n                                         velocity_error.cwiseProduct(velocity_gains_) +\n                                         odometry_.orientation.toRotationMatrix() * odometry_.acceleration +\n                                         command_trajectory_.acceleration -\n                                         vehicle_mass_ * gravity_;\n\n  // Limit the acceleration to the maximum acceleration\n  acceleration_desired.cwiseMin(max_acceleration_);\n  acceleration_desired.cwiseMax(-max_acceleration_);\n\n  // Set the output acceleration\n  *acceleration = acceleration_desired;\n}", "CodeBleu_score": 46.100762318397656}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // Calculate the position error.\n  Eigen::Vector3d position_error = command_trajectory_.GetPositionError(odometry_);\n\n  // Calculate the velocity error.\n  Eigen::Vector3d velocity_error = command_trajectory_.GetVelocityError(odometry_);\n\n  // Transform the vehicle's velocity to the world frame.\n  Eigen::Vector3d velocity_in_world_frame =\n      odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n\n  // Compute the desired acceleration.\n  *acceleration =\n      position_gain_.cwiseProduct(position_error) +\n      velocity_gain_.cwiseProduct(velocity_error - velocity_in_world_frame) +\n      acceleration_bias_;\n\n  // Adjust for vehicle mass, gravity, and commanded acceleration.\n  *acceleration +=\n      -vehicle_mass_ * gravity_ + command_trajectory_.GetAcceleration();\n}", "CodeBleu_score": 42.052491783041376}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // Compute the position error\n  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n  // Compute the velocity error\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity - odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n\n  // Compute the desired acceleration\n  *acceleration = position_error.cwiseProduct(position_gains_) + velocity_error.cwiseProduct(velocity_gains_) + gravity_ + command_trajectory_.acceleration;\n\n  // Adjust for vehicle mass and gravity\n  *acceleration -= mass_ * gravity_;\n}", "CodeBleu_score": 38.31348158275239}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n  assert(rotor_velocities->rows() == num_rotors_);\n  rotor_velocities->resize(num_rotors_);\n  Eigen::VectorXd angular_acceleration_thrust =\n      control_attitude_thrust_reference_.block<3, 1>(0, 0) +\n      control_attitude_thrust_reference_.block<3, 1>(3, 0);\n  angular_acceleration_thrust =\n      angular_acceleration_thrust.cwiseMax(Eigen::VectorXd::Ones(3) * 1e-6);\n  *rotor_velocities =\n      rotor_velocities_matrix_ * angular_acceleration_thrust.cwiseSqrt();\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 55.717816995692026}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n  assert(rotor_velocities->rows() == kNumRotors);\n  rotor_velocities->resize(kNumRotors);\n  Eigen::VectorXd angular_acceleration_thrust =\n      angular_acceleration_thrust_ + control_attitude_thrust_reference_;\n  *rotor_velocities =\n      (angular_acceleration_thrust.array() * kOmega0.array()).matrix().cwiseMax(\n          Eigen::VectorXd::Ones(kNumRotors));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 47.67316023169922}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n\n  // Resize the rotor velocities vector to match the number of rotors.\n  rotor_velocities->resize(num_rotors_);\n\n  // Calculate the desired angular acceleration and combine it with the thrust reference.\n  Eigen::VectorXd angular_acceleration_thrust =\n      control_attitude_thrust_reference_[0] * control_attitude_thrust_reference_[1] *\n      Eigen::VectorXd::Ones(num_rotors_);\n\n  // Compute the rotor velocities by multiplying with a predefined matrix.\n  *rotor_velocities = rotors_angular_velocity_matrix_ * angular_acceleration_thrust;\n\n  // Ensure the rotor velocities are at least one.\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(num_rotors_));\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 51.829361224899095}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in dir(self):\n        if not attr.startswith(\"_\"):\n            setattr(copied_obj, attr, getattr(self, attr)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 49.02072619147965}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.data = copied_obj.data[start_index:end_index]\n    copied_obj.time_units = copied_obj.time_units\n    copied_obj.data_units = copied_obj.data_units\n    return copied_obj\n\n", "CodeBleu_score": 35.114502253531796}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in copied_obj.__dict__:\n        setattr(copied_obj, attr, copied_obj.__dict__[attr][start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 42.44385866925873}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    pos = waypoint_msg.pose.position\n    rot = waypoint_msg.pose.orientation\n    yaw = euler_from_quaternion([rot.x, rot.y, rot.z, rot.w])[2]\n    if self.current_waypoint is not None:\n        if self.current_waypoint.position != pos or self.current_waypoint.yaw != yaw:\n            self.append_times.append(bag_time)\n            self.append_point.append(Point(pos.x, pos.y, pos.z))\n    self.current_waypoint = Waypoint(pos, yaw)\n\n", "CodeBleu_score": 21.378074416455807}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Get position and rotation from waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    euler = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object from the position\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one\n    if self.last_point is None or self.last_point != point or self.last_yaw != euler[2]:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_times.append(bag_time)\n        self.append_point.append(point)\n        self.last_point = point\n        self.last_yaw = euler[2]\n\n", "CodeBleu_score": 23.945945499438352}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    pos = waypoint_msg.pose.pose.position\n    rot = waypoint_msg.pose.pose.orientation\n    yaw = euler_from_quaternion([rot.x, rot.y, rot.z, rot.w])[2]\n    point = Point(pos.x, pos.y, pos.z)\n    if not self.last_waypoint or (self.last_waypoint.x != point.x or self.last_waypoint.y != point.y or self.last_waypoint.z != point.z or self.last_yaw != yaw):\n        self.append_times.append(bag_time)\n        self.append_point.append(point)\n        self.last_waypoint = point\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 22.398014275010954}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic:\n        self.x.append(msg.linear_acceleration.x)\n        self.y.append(msg.linear_acceleration.y)\n        self.z.append(msg.linear_acceleration.z)\n        self.time.append(to_sec(msg.header.stamp))\n        self.bag_time.append(bag_time)\n\n", "CodeBleu_score": 29.102099590826953}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic:\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.time.append(to_sec(msg.header.stamp))\n        self.bag_time.append(bag_time)\n\n", "CodeBleu_score": 30.62973795688141}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_accel_x.append(msg.linear_acceleration.x)\n        self.imu_accel_y.append(msg.linear_acceleration.y)\n        self.imu_accel_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(to_sec(msg.header.stamp))\n        self.imu_bag_time.append(to_sec(bag_time))\n\n", "CodeBleu_score": 30.136622232014503}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(f'Acceleration Data')\n    ax_x = fig.add_subplot(1, 1, 1)\n    ax_y = ax_x.twinx()\n    ax_z = ax_x.twinx()\n    ax_z.spines['right'].set_position(('outward', 60))\n    for i, (acceleration_name, acceleration_data) in enumerate(self.accelerations.items()):\n        ax_x.plot(acceleration_data['x'], label=acceleration_name, color='red')\n        ax_y.plot(acceleration_data['y'], label=acceleration_name, color='green')\n        ax_z.plot(acceleration_data['z'], label=acceleration_name, color='blue')\n    ax_x.set_ylabel('Acceleration (m/s^2)')\n    ax_y.set_ylabel('Acceleration (m/s^2)')\n    ax_z.set_ylabel('Acceleration (m/s^2)')\n    ax_x.set_xlabel('Time (s)')\n    ax_y.set_xlabel('Time (s)')\n    ax_z.set_xlabel('Time (s)')\n    ax_x.legend(loc='upper left')\n    ax_y.legend(loc='upper left')\n    ax_z.legend(loc='upper left')\n    if self.save_plots:\n        if plot_suffix:\n            filename = f'{self.plot_prefix}_accelerations_{plot_suffix}.png'\n        else:\n            filename = f'{self.plot_prefix}_accelerations.png'\n        pyplot.savefig(filename)\n    pyplot.show()\n\n", "CodeBleu_score": 35.25834034204253}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.plot_accelerations:\n        fig = pyplot.figure()\n        fig.suptitle('Accelerations')\n        ax = fig.add_subplot(1, 1, 1)\n        for i, (name, data) in enumerate(self.accelerations.items()):\n            ax.plot(data[:, 0], data[:, 1], label=name + ' X')\n            ax.plot(data[:, 0], data[:, 2], label=name + ' Y')\n            ax.plot(data[:, 0], data[:, 3], label=name + ' Z')\n        ax.set_xlabel('Time (s)')\n        ax.set_ylabel('Acceleration (m/s^2)')\n        ax.legend()\n        if self.plot_suffix is not None:\n            plot_suffix = '_' + plot_suffix\n        else:\n            plot_suffix = ''\n        pyplot.savefig(self.plot_prefix + 'accelerations' + plot_suffix + '.png')\n\n", "CodeBleu_score": 37.15186128355032}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.plot_accelerations:\n        fig = pyplot.figure()\n        fig.suptitle(self.prefix + \" Accelerations\")\n        ax_x = fig.add_subplot(311)\n        ax_y = fig.add_subplot(312)\n        ax_z = fig.add_subplot(313)\n        for i, (name, data) in enumerate(self.accelerations.items()):\n            ax_x.plot(data[0], label=name + \" X\")\n            ax_y.plot(data[1], label=name + \" Y\")\n            ax_z.plot(data[2], label=name + \" Z\")\n        ax_x.set_ylabel(\"X Acceleration (m/s^2)\")\n        ax_y.set_ylabel(\"Y Acceleration (m/s^2)\")\n        ax_z.set_ylabel(\"Z Acceleration (m/s^2)\")\n        ax_x.set_xlabel(\"Time (s)\")\n        ax_y.set_xlabel(\"Time (s)\")\n        ax_z.set_xlabel(\"Time (s)\")\n        ax_x.legend()\n        ax_y.legend()\n        ax_z.legend()\n        if self.save_plots:\n            filename = self.prefix\n            if plot_suffix is not None:\n                filename += \"_\" + plot_suffix\n            filename += \"_accelerations.png\"\n            pyplot.savefig(filename)\n\n", "CodeBleu_score": 35.94238131083879}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Please provide at least two pose indices for comparison.\")\n        return\n    for i, pose_index in enumerate(pose_indeces):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(pose_index, pose_indeces[j])\n\n", "CodeBleu_score": 40.34062523639772}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: At least two pose indices are required to compare positions.\")\n        return\n    for i, pose_index in enumerate(pose_indeces):\n        for j in range(i+1, len(pose_indeces)):\n            pose_index2 = pose_indeces[j]\n            compare_two_xyz(pose_index, pose_index2)\n\n", "CodeBleu_score": 40.52217744946515}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for index, pose_index in enumerate(pose_indeces):\n        for pose_index_2 in pose_indeces[index+1:]:\n            compare_two_xyz(self, pose_index, pose_index_2)\n\n", "CodeBleu_score": 25.713975526423667}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is not None and end_time is not None:\n            if start_time <= collision <= end_time:\n                collision_times.append(collision)\n        else:\n            collision_times.append(collision)\n    return collision_times\n\n", "CodeBleu_score": 45.348576786492465}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is not None and end_time is not None:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None:\n            if start_time <= collision.time:\n                collision_times.append(collision.time)\n        elif end_time is not None:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 39.56249004507008}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    max = 0\n    for i in self.wrench:\n        if start_time is not None and end_time is not None:\n            if i[0] >= start_time and i[0] <= end_time:\n                collision_times.append(i)\n        else:\n            if i[0] > max:\n                max = i[0]\n            collision_times.append(i)\n    if start_time is None and end_time is None:\n        return collision_times\n    else:\n        return collision_times, max\n\n", "CodeBleu_score": 43.26245072871495}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 33.45415835736383}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    # Calculate the absolute settling time\n    absolute_settling_time = start_time + settling_time\n\n    # Call the analyze_bag.plot_angular_velocities function with the specified parameters\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])", "CodeBleu_score": 30.087936187511037}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    # Calculate the absolute settling time by adding the settling time to the start time\n    settling_time_abs = start_time + settling_time\n\n    # Plot the angular velocities over the specified time range\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time_abs, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 30.55242519553917}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  float fx = camera_intrinsics_.fx;\n  float fy = camera_intrinsics_.fy;\n  float cx = camera_intrinsics_.cx;\n  float cy = camera_intrinsics_.cy;\n\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n  Eigen::VectorXf rms_noise =\n      (data_vector_map.array() * 1000.0).array().square().sqrt() *\n      rms_noise_multiplier_;\n  Eigen::VectorXf noise = rms_noise.array().random(generator_);\n\n  for (uint32_t i = 0; i < width * height; i++) {\n    float x = (i % width) - cx;\n    float y = (i / width) - cy;\n    float depth = data_vector_map(i);\n\n    if (depth != 0.0 && depth != bad_point_value_) {\n      float x_noise = x * (rms_noise(i) / depth);\n      float y_noise = y * (rms_noise(i) / depth);\n\n      float x_noise_pixels = x_noise * fx;\n      float y_noise_pixels = y_noise * fy;\n\n      float x_noise_pixels_rounded = std::round(x_noise_pixels);\n      float y_noise_pixels_rounded = std::round(y_noise_pixels);\n\n      float x_noise_pixels_remainder = x_noise_pixels - x_noise_pixels_rounded;\n      float y_noise_pixels_remainder = y_noise_pixels - y_noise_pixels_rounded;\n\n      float x_noise_pixels_rounded_tan = tanf(x_noise_pixels_rounded);\n      float y_noise_pixels_rounded_tan = tanf(y", "CodeBleu_score": 48.5632725040423}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  // Compute multiplier based on camera parameters\n  const float multiplier =\n      std::min(width, height) / std::max(width, height) *\n      (static_cast<float>(width) / static_cast<float>(height));\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>>\n      data_vector_map(data, height, width);\n\n  // Compute RMS noise\n  const Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>\n      rms_noise = (data_vector_map * 1000.0).array().square().sqrt();\n\n  // Compute noise values\n  const Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>\n      noise = rms_noise.array() *\n              Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>::Random(\n                  height, width);\n\n  // Add noise to data\n  for (uint32_t y = 0; y < height; y++) {\n    for (uint32_t x = 0; x < width; x++) {\n      // Check if pixel value is in range\n      if (data_vector_map(y, x) >= depth_min_ && data_vector_map(y, x) <= depth_max_) {\n        data_vector_map(y, x) += noise(y, x);\n      } else {\n        // Set pixel to bad point value\n        data_vector_map(y, x) = bad_point_value_;\n      }\n    }\n  }\n}", "CodeBleu_score": 48.79605550257154}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  float fx = camera_parameters_.fx;\n  float fy = camera_parameters_.fy;\n  float cx = camera_parameters_.cx;\n  float cy = camera_parameters_.cy;\n\n  Eigen::VectorXf data_vector_map(width * height);\n  for (uint32_t i = 0; i < width * height; i++) {\n    data_vector_map[i] = data[i];\n  }\n\n  Eigen::VectorXf rms_noise =\n      (data_vector_map * 1000.0).array().square().sqrt();\n  Eigen::VectorXf noise = rms_noise.array() *\n                          Eigen::VectorXf::Random(width * height).array();\n\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data[i] > min_depth_ && data[i] < max_depth_) {\n      data[i] += noise[i];\n    } else {\n      data[i] = bad_point_value_;\n    }\n  }\n}", "CodeBleu_score": 53.88575756241648}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  gazebo::common::Time sim_time = world_->SimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = writeBag(sim_time, trajectory_msg);\n\n  // Print the ROS time\n  ROS_INFO_STREAM(\"ROS time: \" << ros_time);\n}", "CodeBleu_score": 51.09845227675726}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time current_time = ros::Time::now();\n  trajectory_msg->header.stamp = current_time;\n  trajectory_msg->header.frame_id = \"world\";\n  trajectory_msg->header.seq = trajectory_msg->header.seq + 1;\n  writeBag(trajectory_msg, trajectory_topic_);\n}", "CodeBleu_score": 35.62878829804506}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  gazebo::common::Time sim_time = world_->SimTime();\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = ros::Time::fromBoost(sim_time.Double());\n  // Write the trajectory message to the bag file\n  writeBag(trajectory_msg, ros_time, \"waypoint\");\n}", "CodeBleu_score": 52.77814781663983}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\n  // Convert simulation time to ROS time\n  ros::Time ros_time = ros::Time::now();\n\n  // Prepare message for actuator velocities\n  sensor_msgs::JointState rot_velocities_msg;\n  rot_velocities_msg.header.stamp = ros_time;\n  rot_velocities_msg.name.resize(motor_joints_.size());\n  rot_velocities_msg.velocity.resize(motor_joints_.size());\n\n  // Iterate through motor joints, calculate slowed-down rotational velocities, and assign them to the message\n  int i = 0;\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    rot_velocities_msg.name[i] = m->second->GetName();\n    rot_velocities_msg.velocity[i] = m->second->GetVelocity() * slow_down_factor_;\n    ++i;\n  }\n\n  // Set message timestamp\n  rot_velocities_msg.header.stamp = ros_time;\n\n  // Write data to bag file using the specified namespace and motor topic\n  motor_vel_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 55.51826672884649}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time ros_time = ros::Time::fromBoost(now.toBoost());\n\n  // Prepare message for actuator velocities\n  sensor_msgs::JointState rot_velocities_msg;\n  rot_velocities_msg.header.stamp = ros_time;\n  rot_velocities_msg.header.frame_id = \"world\";\n  rot_velocities_msg.name.resize(motor_joints_.size());\n  rot_velocities_msg.velocity.resize(motor_joints_.size());\n\n  // Iterate through motor joints, calculate slowed-down rotational velocities, and assign them to the message\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Get the motor joint\n    physics::JointPtr joint = m->second;\n\n    // Get the motor joint type\n    std::string joint_type = joint->GetScopedName();\n\n    // Get the motor joint velocity\n    double velocity = joint->GetVelocity(0);\n\n    // Slow down the motor joint velocity if it is a linear joint\n    if (joint_type.find(\"linear\") != std::string::npos) {\n      velocity *= linear_joint_slowdown_;\n    }\n\n    // Assign the motor joint velocity to the message\n    rot_velocities_msg.name[m - motor_joints_.begin()] = joint->GetName();\n    rot_velocities_msg.velocity[m - motor_joints_.begin()] = velocity;\n  }\n\n  // Set the message timestamp and write the data to a bag file using the specified namespace and motor topic\n  rot_velocities_msg.header.stamp = ros_time;\n  motor_bag_.write(motor_topic_, rot_velocities_msg);\n}", "CodeBleu_score": 54.551091254541596}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time ros_time = ros::Time::fromBoost(now.Double());\n\n  // Prepare message for actuator velocities\n  sensor_msgs::JointState rot_velocities_msg;\n  rot_velocities_msg.header.stamp = ros_time;\n  rot_velocities_msg.header.frame_id = \"world\";\n  rot_velocities_msg.name.resize(motor_joints_.size());\n  rot_velocities_msg.velocity.resize(motor_joints_.size());\n\n  // Iterate through motor joints, calculate rotational velocities, and assign to message\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Get motor joint name\n    rot_velocities_msg.name[m - motor_joints_.begin()] = m->first;\n\n    // Get motor joint velocity and apply slowdown factor\n    rot_velocities_msg.velocity[m - motor_joints_.begin()] =\n        m->second->GetVelocity(0) * slowdown_factor_;\n  }\n\n  // Set message timestamp and write to bag file\n  rot_velocities_msg.header.stamp = ros_time;\n  writeBag(rot_velocities_msg, motor_topic_, ros_time, motor_namespace_);\n}", "CodeBleu_score": 57.30671949158679}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  // If debug printing is enabled, log that the callback was called\n  if (debug_printing_enabled) {\n    std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to\n  // control surface angles for ailerons, elevator, and rudder respectively\n  ailerons_cmd_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  elevator_cmd_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch());\n  rudder_cmd_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message\n  throttle_cmd_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 39.915239815552}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_printing_) {\n    ROS_INFO_STREAM(\"RollPitchYawrateThrustCallback called.\");\n  }\n  roll_pitch_yawrate_thrust_msg->roll =\n      NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  roll_pitch_yawrate_thrust_msg->pitch =\n      NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch());\n  roll_pitch_yawrate_thrust_msg->yaw_rate =\n      NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate());\n  roll_pitch_yawrate_thrust_msg->thrust =\n      NormalizedInputToThrottle(roll_pitch_yawrate_thrust_msg->thrust());\n}", "CodeBleu_score": 43.7567264685466}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_printing_) {\n    std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n  roll_pitch_yawrate_thrust_msg->roll() =\n      NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  roll_pitch_yawrate_thrust_msg->pitch() =\n      NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch());\n  roll_pitch_yawrate_thrust_msg->yaw_rate() =\n      NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate());\n  roll_pitch_yawrate_thrust_msg->thrust() =\n      NormalizedInputToThrust(roll_pitch_yawrate_thrust_msg->thrust());\n}", "CodeBleu_score": 44.931878852108255}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Set up the timeout for the poll operation\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Perform the poll operation on file descriptors\n  int ret = poll(&m_pollfd, 1, _timeoutMs);\n\n  // If data is available, receive and parse MAVLink messages\n  if (ret > 0) {\n    char buf[1024];\n    int bytes_read = recvfrom(m_pollfd.fd, buf, sizeof(buf), 0, NULL, NULL);\n    if (bytes_read <= 0) {\n      return;\n    }\n    for (int i = 0; i < bytes_read; i++) {\n      mavlink_parse_char(m_mavlink_channel, buf[i], &m_mavlink_msg,\n                         &m_mavlink_status);\n      if (m_mavlink_status.packet_rx_success) {\n        handleMAVLinkMessage(m_mavlink_msg);\n      }\n    }\n  }\n}", "CodeBleu_score": 49.71008639105365}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(m_serialFd, &readfds);\n\n  int retval = select(m_serialFd + 1, &readfds, NULL, NULL, &tv);\n  if (retval == -1) {\n    std::cerr << \"select() failed: \" << strerror(errno) << std::endl;\n    return;\n  } else if (retval == 0) {\n    // Timeout occurred\n    return;\n  }\n\n  // Data is available on the serial port\n  uint8_t buffer[1024];\n  ssize_t bytes_read = read(m_serialFd, buffer, sizeof(buffer));\n  if (bytes_read == -1) {\n    std::cerr << \"read() failed: \" << strerror(errno) << std::endl;\n    return;\n  }\n\n  // Parse MAVLink messages from the buffer\n  for (ssize_t i = 0; i < bytes_read; i++) {\n    mavlink_message_t msg;\n    mavlink_status_t status;\n    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n      // Message received, handle it\n      handleMAVLinkMessage(msg);\n    }\n  }\n}", "CodeBleu_score": 55.89966395331517}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(serialPortFd, &readfds);\n\n  int ret = select(serialPortFd + 1, &readfds, NULL, NULL, &timeout);\n\n  if (ret == -1) {\n    std::cerr << \"Error in select: \" << strerror(errno) << std::endl;\n    return;\n  } else if (ret == 0) {\n    // Timeout occurred\n    return;\n  }\n\n  if (FD_ISSET(serialPortFd, &readfds)) {\n    // Data is available on the serial port\n    char buffer[1024];\n    int bytesRead = read(serialPortFd, buffer, sizeof(buffer));\n    if (bytesRead <= 0) {\n      std::cerr << \"Error reading from serial port: \" << strerror(errno)\n                << std::endl;\n      return;\n    }\n\n    for (int i = 0; i < bytesRead; i++) {\n      mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &mavlinkMsg, &mavlinkStatus);\n\n      if (mavlinkStatus.msg_received) {\n        // MAVLink message received\n        handleMAVLinkMessage(mavlinkMsg);\n      }\n    }\n  }\n}", "CodeBleu_score": 50.22928514541446}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t    boost::mutex::scoped_lock lock(mutex_);\n    if (is_open()) {\n        io_service_.stop();\n        serial_dev_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n    }\n}", "CodeBleu_score": 66.9629778746055}, {"code": "void GazeboMavlinkInterface::close() {\n\t    boost::mutex::scoped_lock lock(mutex_);\n    if (is_open()) {\n        io_service_.stop();\n        serial_dev_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n    }\n}", "CodeBleu_score": 66.9629778746055}, {"code": "void GazeboMavlinkInterface::close() {\n\t    boost::mutex::scoped_lock lock(mutex_);\n    if (is_open()) {\n        io_service_.stop();\n        serial_dev_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n    }\n}", "CodeBleu_score": 66.9629778746055}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    const ignition::math::Vector3d &p1,\n    const ignition::math::Vector3d &p2,\n    const ignition::math::Vector3d &v1,\n    const ignition::math::Vector3d &v2,\n    const ignition::math::Vector3d &pos\n}", "CodeBleu_score": 26.31276429242427}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    double x, double y, double z, double x1, double y1, double z1, double x2, double y2, double z2, double x3, double y3, double z3\n}", "CodeBleu_score": 10.563038595253522}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    ignition::math::Vector3d p1, ignition::math::Vector3d p2, double x\n}", "CodeBleu_score": 6.862998591482194}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\n}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t  ignition::math::equal(fmod, _time, this->Length());\n  this->dataPtr->time = _time;\n}", "CodeBleu_score": 34.95564939066734}, {"code": "void Animation::SetTime(double _time){\n\t  ignition::math::equal(fmod(_time, this->Length()), 0.0) ? this->SetTime(_time)\n      : this->SetTime(fmod(_time, this->Length()));\n}", "CodeBleu_score": 36.4342062372513}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    self.construct_target()\n    print(f\"Vehicle Type: {self.vehicle_type}\")\n    print(f\"Vehicle ID: {self.vehicle_id}\")\n    print(f\"Flight Mode: {self.flight_mode}\")\n\n", "CodeBleu_score": 22.24411509598936}, {"code": "def hover(self)\n\t\n    self.cf = 1\n    self.motion_type = 0\n    self.construct_target()\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 29.802469416348394}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.construct_target()\n    print(\"Vehicle type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight mode:\", self.flight_mode)\n\n", "CodeBleu_score": 39.312837944824416}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.set_flight_mode(self.flight_mode)\n            print\n            \"Flight mode changed to \" + self.flight_mode\n            return True\n        except:\n            print\n            \"Failed to change flight mode to \" + self.flight_mode\n            return False\n\n", "CodeBleu_score": 39.804947471479096}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService is None:\n        print(\"Flight mode service not available\")\n        return False\n    if self.flightModeService.flightMode == \"HOVER\":\n        self.hover = 1\n        self.hover()\n        print(\"Hover mode enabled\")\n        return True\n    else:\n        try:\n            self.flightModeService.flightMode = self.flightMode\n            print(\"Flight mode set to \" + self.flightMode)\n            return True\n        except Exception as e:\n            print(\"Failed to set flight mode: \" + str(e))\n            return False\n\n", "CodeBleu_score": 30.149961316743486}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService:\n        if self.flightModeService.flightMode == \"HOVER\":\n            self.hover = 1\n            self.hover()\n            print(\"Flight mode set to HOVER\")\n            return True\n        else:\n            print(\"Attempting to switch flight mode to HOVER\")\n            self.flightModeService.flightMode = \"HOVER\"\n            print(\"Flight mode set to HOVER\")\n            return True\n    else:\n        print(\"Flight mode switch failed\")\n        return False\n\n", "CodeBleu_score": 35.41127129827855}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n", "CodeBleu_score": 35.54321307011656}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n        if not self.hover_flag and not self.hold_flag:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n", "CodeBleu_score": 36.185367139311495}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n", "CodeBleu_score": 35.54321307011656}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005) and self.hover_flag == 1:\n        self.hover_flag = 0\n        self.change_mode(\"OFFBOARD\")\n        self.hover_action.stop()\n        self.hover_action = None\n        self.hover_action = self.hover_action_offboard()\n        self.hover_action.start()\n    elif self.hover_flag == 0 and self.mode == \"HOVER\":\n        self.hover_flag = 1\n        self.hover_action.stop()\n        self.hover_action = None\n        self.hover_action = self.hover_action_hover()\n        self.hover_action.start()\n\n", "CodeBleu_score": 37.39091759828934}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 0:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 1\n            self.change_flight_mode(\"HOVER\")\n            self.hover()\n    elif self.hover_flag == 1:\n        if x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005:\n            self.hover_flag = 0\n            self.change_flight_mode(\"OFFBOARD\")\n\n", "CodeBleu_score": 42.97639934968377}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (\n        x > 0.02\n        or x < -0.02\n        or y > 0.02\n        or y < -0.02\n        or z > 0.02\n        or z < -0.02\n        or w > 0.005\n    ):\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n    elif self.hover_flag == 0 and self.mode == \"HOVER\":\n        self.hover_flag = 1\n        self.set_mode(\"HOVER\")\n        self.hover()\n\n", "CodeBleu_score": 39.449464607119054}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw\n\n", "CodeBleu_score": 24.26411761619382}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw", "CodeBleu_score": 24.26411761619382}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.construct_coordinate_frame()\n    self.motion_type = 'hover'\n    self.construct_target()\n    print(\"Vehicle Type: \" + str(self.vehicle_type))\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: \" + str(self.flight_mode))\n\n", "CodeBleu_score": 22.78691657637938}, {"code": "def hover(self)\n\t\n    self.update_coordinate_frame()\n    self.motion_type = \"hover\"\n    self.construct_target()\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 9.044417987098857}, {"code": "def hover(self)\n\t\n    self.set_coordinate_frame(0)\n    self.set_motion_type(0)\n    self.construct_target()\n    print(f\"Vehicle type: {self.vehicle_type}\")\n    print(f\"Vehicle ID: {self.vehicle_id}\")\n    print(f\"Flight mode: {self.flight_mode}\")\n\n\n\n\n", "CodeBleu_score": 20.453415012802427}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService.get_flight_mode() == 'HOVER':\n        self.hover = True\n        self.hover_mode()\n    else:\n        flight_mode = self.flightModeService.get_flight_mode()\n        if self.flightModeService.set_flight_mode(flight_mode):\n            print('Flight mode switched to {}'.format(flight_mode))\n            return True\n        else:\n            print('Failed to switch flight mode')\n            return False\n\n", "CodeBleu_score": 32.94959433845628}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover_mode()\n        return True\n    else:\n        try:\n            self.flightModeService.set_flight_mode(self.flight_mode)\n            print('Flight mode set to: ' + self.flight_mode)\n            return True\n        except Exception as e:\n            print('Failed to set flight mode: ' + str(e))\n            return False\n\n", "CodeBleu_score": 50.09000824664638}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover_mode()\n    else:\n        try:\n            self.flightModeService.set_flight_mode(self.flight_mode)\n            print(f'Flight mode set to {self.flight_mode}')\n            return True\n        except Exception as e:\n            print(f'Failed to set flight mode: {e}')\n            return False\n\n", "CodeBleu_score": 46.5658053287012}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        if self.gcs_command == 'takeoff':\n            self.takeoff_target_pose = self.local_pose\n            self.hover_target_pose = self.local_pose\n        elif self.gcs_command == 'hover':\n            self.hover_target_pose = self.local_pose\n        elif self.gcs_command == 'land':\n            self.hover_target_pose = self.local_pose\n        elif self.gcs_command == 'move':\n            self.hover_target_pose = self.local_pose\n        self.global_pose = copy.deepcopy(self.local_pose)\n        self.global_pose.pose.position.x += self.position_bias\n        self.global_pose.pose.position.y += self.position_bias\n        self.global_pose.pose.position.z += self.position_bias\n\n", "CodeBleu_score": 26.586564812172714}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg.pose\n        if self.gcs_command == 'takeoff':\n            self.takeoff_target_pose = msg.pose\n        elif self.gcs_command == 'hover':\n            self.hover_target_pose = msg.pose\n        self.global_pose = copy.deepcopy(self.local_pose)\n        self.global_pose.position.x += self.pose_bias[0]\n        self.global_pose.position.y += self.pose_bias[1]\n        self.global_pose.position.z += self.pose_bias[2]\n\n", "CodeBleu_score": 32.49923215848391}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    # Update the local pose\n    if msg.id == self.id:\n        self.local_pose = msg.pose\n        self.local_pose.position.x += self.position_bias[0]\n        self.local_pose.position.y += self.position_bias[1]\n        self.local_pose.position.z += self.position_bias[2]\n        self.local_pose.orientation.x += self.orientation_bias[0]\n        self.local_pose.orientation.y += self.orientation_bias[1]\n        self.local_pose.orientation.z += self.orientation_bias[2]\n        self.local_pose.orientation.w += self.orientation_bias[3]\n\n    # Update the takeoff target pose\n    if self.gcs_command == \"takeoff\":\n        self.takeoff_target_pose = self.local_pose\n        self.takeoff_target_pose.position.z = self.takeoff_height\n\n    # Update the hover target pose\n    if self.gcs_command == \"hover\":\n        self.hover_target_pose = self.local_pose\n\n    # Update the global pose\n    self.global_pose = copy.deepcopy(self.local_pose)\n    self.global_pose.position.x += self.global_position_bias[0]\n    self.global_pose.position.y += self.global_position_bias[1]\n    self.global_pose.position.z += self.global_position_bias[2]\n    self.global_pose.orientation.x += self.global_orientation_bias[0]\n    self.global_pose.orientation.y += self.global_orientation_bias[1]\n    self.global_pose.orientation.z += self.global_orientation_bias[2]\n    self.global_pose.orientation.w += self.global_orientation_bias[3]\n\n", "CodeBleu_score": 22.529882582528682}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == \"ARMED\":\n        return True\n    else:\n        return False\n\n\n\n", "CodeBleu_score": 62.705636058786936}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n\n", "CodeBleu_score": 70.13649723325177}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n\n", "CodeBleu_score": 70.13649723325177}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = int(np.linalg.norm(orig_formation[i] - change_formation[j]))\n    return dist_matrix\n\n", "CodeBleu_score": 24.4363341218603}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize the distance matrix\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n\n    # Loop through the UAVs in the original formation\n    for i in range(len(orig_formation)):\n        # Loop through the UAVs in the changed formation\n        for j in range(len(change_formation)):\n            # Calculate the Euclidean norm between the UAVs\n            distance_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    distance_matrix = (50 - distance_matrix).astype(int)\n\n    # Return the distance matrix\n    return distance_matrix", "CodeBleu_score": 27.60548424940469}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize an empty distance matrix with the same shape as the original and changed formations\n    dist_matrix = np.zeros((orig_formation.shape[0], change_formation.shape[0]))\n\n    # Loop through the original and changed formations\n    for i in range(orig_formation.shape[0]):\n        for j in range(change_formation.shape[0]):\n            # Calculate the Euclidean norm between the current UAV in the original and changed formations\n            norm = np.linalg.norm(orig_formation[i, :] - change_formation[j, :])\n\n            # Adjust the distance by subtracting it from 50 and convert to an integer\n            dist_matrix[i, j] = int(50 - norm)\n\n    # Return the distance matrix\n    return dist_matrix\n\n\n", "CodeBleu_score": 23.01774967043687}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in self.adj[i]:\n        if not self.visited[j]:\n            if self.match[j] == -1 or self.find_path(self.match[j]):\n                self.match[j] = i\n                return True\n    return False\n\n", "CodeBleu_score": 29.012643681464205}, {"code": "def find_path(self, i)\n\t\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in self.adj_list[i]:\n        if self.match[j] == -1 or self.find_path(self.match[j]):\n            self.match[j] = i\n            return True\n    return False\n\n", "CodeBleu_score": 26.01620892184916}, {"code": "def find_path(self, i)\n\t\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in range(self.n):\n        if self.match[j] == -1 or self.find_path(self.match[j]):\n            self.match[j] = i\n            return True\n    return False\n\n", "CodeBleu_score": 26.371087773131137}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    n = len(self.graph)\n    match = [-1] * n\n    label_u = [0] * n\n    label_v = [0] * n\n    slack = [[0] * n for _ in range(n)]\n    visited_u = [False] * n\n    visited_v = [False] * n\n    for u in range(n):\n        min_label = float('inf')\n        for v in range(n):\n            slack[u][v] = self.graph[u][v] - label_u[u] - label_v[v]\n            if slack[u][v] < min_label:\n                min_label = slack[u][v]\n        for i in range(n):\n            label_u[i] += min_label\n        for j in range(n):\n            slack[j][u] -= min_label\n    for u in range(n):\n        while True:\n            visited_u[u] = True\n            v = self.find_path(u, match, visited_u, visited_v, slack)\n            if v >= 0:\n                match[v] = u\n                break\n            min_label = float('inf')\n            for i in range(n):\n                if not visited_v[i]:\n                    min_label = min(min_label, slack[v][i])\n            for i in range(n):\n                if visited_v[i]:\n                    label_u[match[i]] += min_label\n                else:\n                    slack[match[i]][i] -= min_label\n                if visited_u[i]:\n                    label_v[i] -= min_label\n            for i in range(n):\n                slack[i][v] += min_label\n            visited_v[v] = True\n            if match[v] == -1:\n                break\n    return match\n\n", "CodeBleu_score": 25.12896724020927}, {"code": "def KM(self)\n\t\n    n = len(self.graph)\n    m = len(self.graph[0])\n    U = [False] * n\n    V = [False] * m\n    slack = [[0] * m for _ in range(n)]\n    match = [-1] * m\n    for i in range(n):\n        while True:\n            U[i] = True\n            self.find_path(i, U, V, match, slack)\n            if self.find_path(i, U, V, match, slack):\n                break\n            d = float('inf')\n            for i in range(n):\n                if U[i]:\n                    for j in range(m):\n                        if not V[j]:\n                            d = min(d, slack[i][j])\n            for i in range(n):\n                if U[i]:\n                    for j in range(m):\n                        slack[i][j] -= d\n            for j in range(m):\n                if V[j]:\n                    V[j] = False\n                    for i in range(n):\n                        if U[i]:\n                            slack[i][j] += d\n            else:\n                continue\n            break\n    return match\n\n", "CodeBleu_score": 25.512946530512643}, {"code": "def KM(self)\n\t\n\n    # Initialize variables\n    m, n = self.G.shape\n    match = np.zeros(n, dtype=int) - 1\n    label_u = np.zeros(m, dtype=int)\n    label_v = np.zeros(n, dtype=int)\n    slack_u = np.zeros(m, dtype=int)\n    slack_v = np.zeros(n, dtype=int)\n    visited_u = np.zeros(m, dtype=bool)\n    visited_v = np.zeros(n, dtype=bool)\n\n    # Iterate over UAVs\n    for u in range(m):\n        # Initialize slack variables\n        slack_u[u] = np.inf\n        slack_v[:] = np.inf\n\n        # Reset visit arrays\n        visited_u[u] = True\n        visited_v[:] = False\n\n        # Find a path\n        path = self.find_path(u, match, label_u, label_v, visited_u, visited_v, slack_u, slack_v)\n\n        # If no path is found, adjust the labels\n        while path is None:\n            delta = np.min(slack_v)\n            label_u += delta\n            label_v -= delta\n            slack_u -= delta\n            slack_v += delta\n\n            # Find a path\n            path = self.find_path(u, match, label_u, label_v, visited_u, visited_v, slack_u, slack_v)\n\n        # Update the match\n        for v in path[u]:\n            if match[v] == -1:\n                match[v] = u\n            elif self.G[match[v], v] > self.G[u, v]:\n                match[v] = u\n\n    return match\n\n", "CodeBleu_score": 24.784855835329438}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.864792511395397}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([10, 10, 10])\n    upper_yellow = np.array([255, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.392896870130667}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.864792511395397}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t  if (standalone_tag_descriptions_.find(tag_id) == standalone_tag_descriptions_.end()) {\n    if (print_warnings_) {\n      ROS_WARN_THROTTLE(1.0, \"Standalone tag description not found for ID %d\", tag_id);\n    }\n    return false;\n  }\n  description_container = standalone_tag_descriptions_[tag_id];\n  return true;\n}", "CodeBleu_score": 31.681720868192148}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  if (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN_THROTTLE(1.0, \"Could not find standalone tag description for ID %d\", id);\n    }\n    return false;\n  }\n  descriptionContainer = standalone_tag_descriptions_[id];\n  return true;\n}", "CodeBleu_score": 34.364530385480535}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  if (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN_THROTTLE(1.0, \"Standalone tag description for ID %d not found\", id);\n    }\n    return false;\n  }\n  descriptionContainer = standalone_tag_descriptions_[id];\n  return true;\n}", "CodeBleu_score": 34.06472180615135}]}
