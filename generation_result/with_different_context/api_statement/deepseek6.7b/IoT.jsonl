{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\n\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\tuint8_t len = desc->bLength;\n\n\twhile (len > 0) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tlen = next_desc->bLength;\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t UDC_DESC_STORAGE *)next_desc + len);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 37.84089569643654}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bLength) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE * ) ((uint8_t UDC_DESC_STORAGE *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 33.76093606866244}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len = desc->bLength;\n\twhile (desc_len > 0) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t UDC_DESC_STORAGE *)desc + desc_len);\n\t\tdesc_len = desc->bLength;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 36.61756820555803}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t  struct usb_config_descriptor *config = &udc->config_desc;\n  uint8_t *desc_ptr;\n  uint8_t desc_len;\n  uint8_t desc_type;\n  uint8_t i;\n\n  if (config->bNumInterfaces == 0)\n    return false;\n\n  if (iface_num >= config->bNumInterfaces)\n    return false;\n\n  desc_ptr = (uint8_t *)config;\n  desc_len = config->wTotalLength;\n\n  for (i = 0; i < config->bNumInterfaces; i++) {\n    desc_type = *desc_ptr++;\n    desc_len = *desc_ptr++;\n\n    if (desc_type == USB_DT_INTERFACE) {\n      struct usb_interface_descriptor *iface = (struct usb_interface_descriptor *)desc_ptr;\n\n      if (iface->bInterfaceNumber == iface_num && iface->bAlternateSetting == setting_num)\n        return true;\n    }\n\n    desc_ptr += desc_len;\n  }\n\n  return false;\n}", "CodeBleu_score": 42.720532502212706}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    bool ret = false;\n    uint8_t *desc = udc_get_desc(0);\n    uint8_t *desc_end = desc + desc[0];\n    uint8_t *desc_next = desc + desc[0];\n    uint8_t *desc_curr = desc;\n    uint8_t *desc_next_end = desc_next + desc_next[0];\n    uint8_t *desc_next_curr = desc_next;\n\n    while (desc_curr < desc_end) {\n        if (desc_curr[1] == USB_DESC_TYPE_CONFIG) {\n            desc_next = desc_curr + desc_curr[0];\n            desc_next_end = desc_next + desc_next[0];\n            desc_next_curr = desc_next;\n            while (desc_next_curr < desc_next_end) {\n                if (desc_next_curr[1] == USB_DESC_TYPE_INTERFACE) {\n                    if (desc_next_curr[2] == iface_num && desc_next_curr[3] == setting_num) {\n                        ret = true;\n                        break;\n                    }\n                }\n                desc_next_curr += desc_next_curr[0];\n            }\n        }\n        desc_curr += desc_curr[0];\n    }\n\n    return ret;\n}", "CodeBleu_score": 26.61883860900136}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    struct usb_desc_conf *conf_desc;\n    struct usb_desc_iface *iface_desc;\n    uint8_t *desc;\n    uint8_t i;\n    uint8_t j;\n    uint8_t k;\n    uint8_t l;\n    uint8_t m;\n    uint8_t n;\n    uint8_t o;\n    uint8_t p;\n    uint8_t q;\n    uint8_t r;\n    uint8_t s;\n    uint8_t t;\n    uint8_t u;\n    uint8_t v;\n    uint8_t w;\n    uint8_t x;\n    uint8_t y;\n    uint8_t z;\n    uint8_t aa;\n    uint8_t ab;\n    uint8_t ac;\n    uint8_t ad;\n    uint8_t ae;\n    uint8_t af;\n    uint8_t ag;\n    uint8_t ah;\n    uint8_t ai;\n    uint8_t aj;\n    uint8_t ak;\n    uint8_t al;\n    uint8_t am;\n    uint8_t an;\n    uint8_t ao;\n    uint8_t ap;\n    uint8_t aq;\n    uint8_t ar;\n    uint8_t as;\n    uint8_t at;\n    uint8_t au;\n    uint8_t av;\n    uint8_t aw;\n    uint8_t ax;\n    uint8_t ay;\n    uint8_t az;\n    uint8_t ba;\n    uint8_t bb;\n    uint8_t bc;\n    uint8_t bd;\n    uint8_t be;\n    uint8_t bf;\n    uint8_t bg;\n    uint8_t bh;\n    uint8_t bi;\n    uint8_t bj;\n    uint8_t bk;\n    uint8_t bl;\n    uint8_t bm;\n    uint8_t", "CodeBleu_score": 8.127638596184482}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t    uint8_t ep_status = 0;\n    uint8_t *ep_status_ptr = &ep_status;\n    uint8_t ep_num;\n    uint8_t ep_dir;\n\n    /* Check if the request length matches the size of the endpoint status variable */\n    if (req.wLength != sizeof(ep_status)) {\n        return false;\n    }\n\n    /* Determine the endpoint number and direction */\n    ep_num = req.wIndex & 0x0F;\n    ep_dir = (req.wIndex >> 7) & 0x01;\n\n    /* Determine the status of the specified endpoint */\n    if (ep_dir == EP_IN) {\n        ep_status = udd_ep_is_halted(ep_num);\n    } else {\n        ep_status = udd_ep_is_halted(ep_num | EP_DIR_SHIFT);\n    }\n\n    /* Set up the response payload with the endpoint status */\n    udd_set_setup_payload(ep_status_ptr, sizeof(ep_status));\n\n    return true;\n}", "CodeBleu_score": 44.30990402955637}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t *p = udd_req_payload;\n\tuint16_t len = udd_req_payload_len;\n\tuint8_t ep;\n\tbool halted;\n\n\tif (len != sizeof(uint8_t)) {\n\t\treturn false;\n\t}\n\n\tep = *p;\n\thalted = udd_ep_is_halted(ep);\n\tudd_set_setup_payload(len, (uint8_t *)&halted);\n\treturn true;\n}", "CodeBleu_score": 21.68090636433479}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    bool result = true;\n    uint8_t ep_addr;\n    uint16_t req_length;\n    uint16_t ep_status;\n\n    /* Check if the request length matches the size of the endpoint status variable */\n    req_length = udd_get_setup_payload_length();\n    if (req_length != sizeof(ep_status)) {\n        result = false;\n    }\n\n    /* Determine the status of the specified endpoint */\n    if (result) {\n        ep_addr = udd_get_setup_payload_buffer()[0];\n        ep_status = udc_ep_get_status(ep_addr);\n        if (ep_status == UDC_EP_STATUS_HALTED) {\n            ep_status = 1;\n        } else {\n            ep_status = 0;\n        }\n    }\n\n    /* Set up the response payload */\n    if (result) {\n        udd_set_setup_payload(&ep_status, sizeof(ep_status));\n    }\n\n    return result;\n}", "CodeBleu_score": 42.19435447608358}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\n\tbool ret;\n\n\tif (!udc_is_configured())\n\t\treturn false;\n\n\tif (!udc_is_iface_valid(udc_req_iface_num))\n\t\treturn false;\n\n\tret = udc_update_iface_desc(udc_req_iface_num, 0, true);\n\tif (!ret)\n\t\treturn false;\n\n\tret = udi_api->setup(udc_req_iface_num, udc_req_iface_desc,\n\t\t\tudc_req_iface_desc_len, udc_req_iface_desc_type);\n\n\treturn ret;\n}", "CodeBleu_score": 41.850291348599}, {"code": "static bool udc_req_iface(void){\n\t\tbool ret = false;\n\n\tif (udc_state != UDC_CONFIGURED)\n\t\treturn false;\n\n\tif (udi_api->getsetting(udc_iface, 0, &udc_iface_desc) != 0)\n\t\treturn false;\n\n\tif (udi_api->getsetting(udc_iface, udc_iface_desc.bAlternateSetting, &udc_iface_desc) != 0)\n\t\treturn false;\n\n\tret = udi_api->setup(udc_iface, &udc_req, &udc_req_complete);\n\n\treturn ret;\n}", "CodeBleu_score": 40.43820117553273}, {"code": "static bool udc_req_iface(void){\n\t  bool ret = false;\n  uint8_t ifnum = setup_req.wIndex.bytes[1];\n  if (udc_state.state == USB_STATE_CONFIGURED && ifnum < udc_state.num_ifaces) {\n    udi_iface_t *iface = &udc_state.ifaces[ifnum];\n    if (iface->altsetting) {\n      iface->altsetting->desc.bInterfaceNumber = ifnum;\n      iface->altsetting->desc.bAlternateSetting = 0;\n      iface->altsetting->desc.bNumEndpoints = 0;\n      iface->altsetting->desc.bInterfaceClass = UDC_IFACE_CLASS;\n      iface->altsetting->desc.bInterfaceSubClass = 0;\n      iface->altsetting->desc.bInterfaceProtocol = 0;\n      iface->altsetting->desc.iInterface = 0;\n      iface->altsetting->desc.bNumEndpoints = 0;\n      iface->altsetting->desc.bInterfaceClass = UDC_IFACE_CLASS;\n      iface->altsetting->desc.bInterfaceSubClass = 0;\n      iface->altsetting->desc.bInterfaceProtocol = 0;\n      iface->altsetting->desc.iInterface = 0;\n      iface->altsetting->desc.bNumEndpoints = 0;\n      iface->altsetting->desc.bInterfaceClass = UDC_IFACE_CLASS;\n      iface->altsetting->desc.bInterfaceSubClass = 0;\n      iface->altsetting->desc.bInterfaceProtocol = 0;\n      iface->altsetting->desc.iInterface = 0;\n      iface->altsetting->desc.bNumEndpoints = 0;\n      iface->altsetting->desc.bInterfaceClass = UDC_IFACE_CLASS;\n      iface->altsetting->desc.bInterfaceSubClass = 0;\n      iface->altsetting->desc.bInterfaceProtocol = 0;\n      iface->", "CodeBleu_score": 25.244179621535068}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t  /* Initialize the MSC interface state. */\n  udi_msc_state = UDI_MSC_STATE_INITIALIZED;\n\n  /* Get the number of LUNs. */\n  udi_msc_nb_lun = get_nb_lun();\n\n  /* Check if the number of LUNs is zero. */\n  if (udi_msc_nb_lun == 0) {\n    /* If there are no LUNs, return false. */\n    return false;\n  }\n\n  /* Unload the medium on each LUN. */\n  for (udi_msc_lun = 0; udi_msc_lun < udi_msc_nb_lun; udi_msc_lun++) {\n    mem_unload();\n  }\n\n  /* Set the current LUN to zero. */\n  udi_msc_lun = 0;\n\n  /* Check if the external enable function is defined. */\n  if (UDI_MSC_ENABLE_EXT) {\n    /* If the external enable function is defined, call it. */\n    if (!UDI_MSC_ENABLE_EXT()) {\n      /* If the external enable function returns false, return false. */\n      return false;\n    }\n  }\n\n  /* Set the MSC interface state to enabled. */\n  udi_msc_state = UDI_MSC_STATE_ENABLED;\n\n  /* Wait for a CBW reception. */\n  udi_msc_cbw_wait();\n\n  /* Return true. */\n  return true;\n}", "CodeBleu_score": 53.31878361065997}, {"code": "bool udi_msc_enable(void){\n\t    if (UDI_MSC_ENABLE_EXT()) {\n        udi_msc_cbw_wait();\n        return true;\n    }\n    else {\n        mem_unload();\n        if (get_nb_lun() > 0) {\n            udi_msc_cbw_wait();\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 18.363309469070003}, {"code": "bool udi_msc_enable(void){\n\t  udi_msc_cbw_wait();\n  mem_unload();\n  if (get_nb_lun() == 0) {\n    return false;\n  }\n  if (!UDI_MSC_ENABLE_EXT()) {\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 13.04089224636907}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\n    if (status != UDD_EP_STATUS_OK) {\n        if (status == UDD_EP_STATUS_STALL) {\n            udi_msc_csw_process(UDI_MSC_CSW_STATUS_PHASE_ERROR, 0);\n        }\n        udi_msc_sense_pass(UDI_MSC_SENSE_ILLEGAL_REQUEST,\n            UDI_MSC_SENSE_ILLEGAL_REQUEST_PHASE_ERROR);\n        udi_msc_reset_setup();\n        return;\n    }\n\n    udi_msc_sense_pass(UDI_MSC_SENSE_NO_ERROR,\n        UDI_MSC_SENSE_NO_ERROR_PHASE_DATA_OUT);\n\n    if (udi_msc_csw.residue > nb_sent) {\n        udi_msc_csw.residue -= nb_sent;\n    } else {\n        udi_msc_csw.residue = 0;\n    }\n\n    udi_msc_csw_process(UDI_MSC_CSW_STATUS_PHASE_DATA_OUT, nb_sent);\n}", "CodeBleu_score": 48.72332495065175}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    udi_msc_t *msc = &udi_msc;\n    udi_msc_csw_t *csw = &msc->csw;\n    uint8_t *sense = msc->sense;\n    uint32_t residue = csw->residue;\n\n    if (status == UDD_EP_STATUS_SUCCESS) {\n        if (nb_sent > residue) {\n            /*\n             * The number of bytes sent is greater than the residue,\n             * this means that the transfer was not completed.\n             */\n            msc->sense[0] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[1] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[2] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[3] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[4] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[5] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[6] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[7] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[8] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[9] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[10] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[11] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[12] = UDI_MSC_SENSE_ILLEGAL_REQUEST;\n            msc->sense[13] = UDI_MSC_S", "CodeBleu_score": 36.23876518047843}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  udi_msc_sense_t *sense = &udi_msc_sense;\n  udi_msc_csw_t *csw = &udi_msc_csw;\n  udi_msc_cbw_t *cbw = &udi_msc_cbw;\n  udi_msc_ep_t *ep_data = &udi_msc_ep[ep];\n\n  if (status != UDD_EP_STATUS_OK) {\n    /*\n     * If the transfer is not successful, wait for a MSC setup reset to restart\n     * CBW reception.\n     */\n    udi_msc_setup_reset();\n    return;\n  }\n\n  /*\n   * If the transfer is successful, update the sense data and decrease the data\n   * residue in the CSW by the amount of data sent.\n   */\n  if (ep_data->cbw_dir == UDI_MSC_CBW_DIR_IN) {\n    sense->residue -= nb_sent;\n  } else {\n    sense->residue += nb_sent;\n  }\n\n  /*\n   * If the data residue in the CSW is zero, process the CSW.\n   */\n  if (sense->residue == 0) {\n    udi_msc_process_csw();\n  }\n}", "CodeBleu_score": 50.706574226747684}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t    if (udi_msc_cbw.data_residue) {\n        udi_msc_stall_next_req();\n        udi_msc_csw.tag = udi_msc_cbw.tag;\n        udi_msc_csw.data_residue = cpu_to_le32(udi_msc_cbw.data_residue);\n    }\n    udi_msc_csw_send();\n}", "CodeBleu_score": 45.87192824980202}, {"code": "static void udi_msc_csw_process(void){\n\t    uint32_t csw_tag;\n    uint32_t csw_data_residue;\n    uint32_t csw_data_residue_le;\n\n    csw_tag = udi_msc_cbw_get_tag();\n    csw_data_residue = udi_msc_cbw_get_data_residue();\n\n    /* If there is a non-zero data residue, stall the next request from the USB host on the appropriate endpoint based on the direction of the CBW. */\n    if (csw_data_residue != 0) {\n        if (udi_msc_cbw_get_direction() == UDI_MSC_CBW_DIRECTION_IN) {\n            udi_msc_stall_in_ep();\n        } else {\n            udi_msc_stall_out_ep();\n        }\n    }\n\n    /* Prepare the CSW by setting its tag and converting the data residue to little-endian format. */\n    csw_data_residue_le = cpu_to_le32(csw_data_residue);\n    udi_msc_csw_set_tag(csw_tag);\n    udi_msc_csw_set_data_residue(csw_data_residue_le);\n\n    /* Send the CSW. */\n    udi_msc_csw_send();\n}", "CodeBleu_score": 29.626986207774053}, {"code": "static void udi_msc_csw_process(void){\n\t\n  /*\n   * If there is a non-zero data residue, stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n   */\n  if (udi_msc_cbw_data_residue) {\n\n    /*\n     * Stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n     */\n    if (udi_msc_cbw_direction == UDI_MSC_CBW_DIRECTION_OUT) {\n\n      /*\n       * Stall the next request from the USB host on the OUT endpoint.\n       */\n      udi_msc_out_ep_stall();\n    } else {\n\n      /*\n       * Stall the next request from the USB host on the IN endpoint.\n       */\n      udi_msc_in_ep_stall();\n    }\n  }\n\n  /*\n   * Prepare the CSW by setting its tag and converting the data residue to little-endian format.\n   */\n  udi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n  udi_msc_csw.tag = udi_msc_cbw.tag;\n  udi_msc_csw.residue = udi_msc_cbw_data_residue;\n\n  /*\n   * Send the CSW.\n   */\n  udi_msc_csw_send();\n}", "CodeBleu_score": 47.47491461815918}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED\n\tUNUSED\n\tUNUSED\n\tUNUSED\n}", "CodeBleu_score": 10.520255530343748}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\n  // Update the DTR status\n  usb_cdc_port_data[port].b_dtr = b_enable;\n\n  // Check if the DTR rate is 1200\n  if (usb_cdc_port_data[port].b_dtr && usb_cdc_port_data[port].baud_rate == 1200) {\n\n    // If the DTR signal is disabled, schedule a delayed system reset\n    if (!b_enable) {\n      usb_cdc_port_data[port].b_reset_scheduled = true;\n      usb_cdc_port_data[port].reset_time = get_time() + 500;\n      usb_cdc_port_data[port].reset_count = 0;\n      initiateReset();\n    }\n  }\n  else {\n    // If the DTR signal is enabled, cancel any scheduled reset\n    cancelReset();\n  }\n}", "CodeBleu_score": 45.637980691085176}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tusb_task_cdc_set_dtr_dtr_status(port, b_enable);\n\n\tif (usb_task_cdc_get_dtr_rate(port) == 1200 && !b_enable) {\n\t\tusb_task_cdc_set_dtr_reset(port, true);\n\t\tinitiateReset();\n\t} else {\n\t\tusb_task_cdc_set_dtr_reset(port, false);\n\t\tcancelReset();\n\t}\n}", "CodeBleu_score": 38.13349934860479}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t  uint8_t request_type;\n  uint8_t request_index;\n  uint16_t descriptor_size;\n  uint8_t *descriptor_ptr;\n  uint16_t *descriptor_size_ptr;\n  uint8_t *descriptor_size_ptr_byte;\n  uint16_t *descriptor_size_ptr_word;\n\n  // Check if the request type is \"vendor-specific\"\n  if (request.bmRequestType & 0x80) {\n    // Get the request type and index\n    request_type = request.bmRequestType & 0x1F;\n    request_index = request.bRequest;\n\n    // Check if the request type is \"vendor-specific\" and the request index is \"0x04\"\n    if (request_type == 0x03 && request_index == 0x04) {\n      // Set up the ID descriptor pointer and size\n      descriptor_ptr = (uint8_t *)&id_descriptor;\n      descriptor_size = sizeof(id_descriptor);\n\n      // Update the control request payload and size\n      usb_update_control_request_payload(descriptor_ptr, descriptor_size);\n\n      // Return \"true\" to indicate that the request was processed\n      return true;\n    }\n\n    // Check if the request type is \"vendor-specific\" and the request index is \"0x05\"\n    if (request_type == 0x03 && request_index == 0x05) {\n      // Set up the extended properties descriptor pointer and size\n      descriptor_ptr = (uint8_t *)&extended_properties_descriptor;\n      descriptor_size = sizeof(extended_properties_descriptor);\n\n      // Update the control request payload and size\n      usb_update_control_request_payload(descriptor_ptr, descriptor_size);\n\n      // Return \"true\" to indicate that the request was processed\n      return true;\n    }\n  }\n\n  // Return \"false\" to indicate that the request was not processed\n  return false;\n}", "CodeBleu_score": 40.61925906128614}, {"code": "bool usb_task_other_requests(void){\n\t    bool ret = false;\n    uint8_t request_type;\n    uint8_t request_index;\n    uint8_t request_value;\n    uint16_t request_length;\n    uint8_t *request_data;\n    uint8_t *id_desc_ptr;\n    uint8_t *ext_prop_ptr;\n    uint16_t id_desc_size;\n    uint16_t ext_prop_size;\n    uint16_t ext_prop_cnt;\n\n    /* Get the request type, index, value, length, and data pointers from the USB device driver. */\n    request_type = usb_get_request_type();\n    request_index = usb_get_request_index();\n    request_value = usb_get_request_value();\n    request_length = usb_get_request_length();\n    request_data = usb_get_request_data();\n\n    /* Check if the request type is \"vendor specific\" and the request index is either 0x04 or 0x05. */\n    if (request_type == USB_REQUEST_TYPE_VENDOR_SPECIFIC && (request_index == USB_REQUEST_INDEX_SET_ID_DESCRIPTOR || request_index == USB_REQUEST_INDEX_SET_EXTENDED_PROPERTIES)) {\n        /* Set the pointers to the ID and extended properties descriptors, and their sizes. */\n        id_desc_ptr = (uint8_t *)usb_get_id_descriptor();\n        ext_prop_ptr = (uint8_t *)usb_get_extended_properties();\n        id_desc_size = usb_get_id_descriptor_size();\n        ext_prop_size = usb_get_extended_properties_size();\n\n        /* If the request index is 0x04, set the pointers and sizes for the ID descriptor. */\n        if (request_index == USB_REQUEST_INDEX_SET_ID_DESCRIPTOR) {\n            usb_set_id_descriptor_ptr(request_data);\n            usb_set_id_descriptor_size(request_length);\n            ret", "CodeBleu_score": 20.495403296046295}, {"code": "bool usb_task_other_requests(void){\n\t    bool ret = false;\n    uint8_t *p_desc;\n    uint8_t *p_desc_end;\n    uint8_t *p_desc_next;\n    uint8_t *p_desc_next_end;\n    uint8_t *p_desc_next_next;\n    uint8_t *p_desc_next_next_end;\n    uint8_t *p_desc_next_next_next;\n    uint8_t *p_desc_next_next_next_end;\n    uint8_t *p_desc_next_next_next_next;\n    uint8_t *p_desc_next_next_next_next_end;\n    uint8_t *p_desc_next_next_next_next_next;\n    uint8_t *p_desc_next_next_next_next_next_end;\n    uint8_t *p_desc_next_next_next_next_next_next;\n    uint8_t *p_desc_next_next_next_next_next_next_end;\n    uint8_t *p_desc_next_next_next_next_next_next_next;\n    uint8_t *p_desc_next_next_next_next_next_next_next_end;\n    uint8_t *p_desc_next_next_next_next_next_next_next_next;\n    uint8_t *p_desc_next_next_next_next_next_next_next_next_end;\n    uint8_t *p_desc_next_next_next_next_next_next_next_next_next;\n    uint8_t *p_desc_next_next_next_next_next_next_next_next_next_end;\n    uint8_t *p_desc_next_next_next_next_next_next_next_next_next_next;\n    uint8_t *p_desc_next_next_next_next_next_next_next_next_next_next_end;\n    uint8_t *p_desc_next_next_next_next_next_next", "CodeBleu_score": 5.700805003768182}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  uint8_t i;\n\n  if (nbyte == 0)\n    return;\n\n  for (i = 0; i < nbyte - 1; i++) {\n    buf[i] = spiRec();\n    while (!(SPSR & (1 << SPIF)));\n  }\n\n  buf[i] = spiRec();\n}", "CodeBleu_score": 48.79466544715177}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0)\n    return;\n\n  uint8_t dummy = 0x00;\n  for (uint16_t i = 0; i < nbyte; i++) {\n    spiSend(dummy);\n    while (!spiRec())\n      ;\n    buf[i] = spiRec();\n  }\n}", "CodeBleu_score": 50.70036551464383}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0) return;\n  for (uint16_t i = 0; i < nbyte - 1; i++) {\n    while (!spiRec());\n    buf[i] = SPI;\n  }\n  while (!spiRec());\n  buf[nbyte - 1] = SPI;\n}", "CodeBleu_score": 51.402001143313655}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tuint32_t *pISRTable = get_relocated_table_addr();\n\tuint32_t *pISR = &pISRTable[irq];\n\tuint32_t oldISR = *pISR;\n\t*pISR = (uint32_t) newHandler;\n\treturn (pfnISR_Handler) oldISR;\n}", "CodeBleu_score": 40.671977315774264}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n    uint32_t *vectorTable = get_relocated_table_addr();\n    uint32_t *irqHandler = &vectorTable[irq + 16];\n\n    disable_interrupts();\n    oldHandler = (pfnISR_Handler) *irqHandler;\n    *irqHandler = (uint32_t) newHandler;\n    enable_interrupts();\n\n    return oldHandler;\n}", "CodeBleu_score": 54.32546368677331}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n    pfnISR_Handler *pISR;\n\n    /* Get the relocated interrupt vector table address */\n    pISR = get_relocated_table_addr();\n\n    /* Disable global interrupts to ensure atomic operation */\n    __disable_irq();\n\n    /* Retrieve the current handler for the specified IRQ */\n    oldHandler = pISR[irq];\n\n    /* Replace the current handler with the new handler */\n    pISR[irq] = newHandler;\n\n    /* Re-enable global interrupts */\n    __enable_irq();\n\n    /* Return the original ISR handler */\n    return oldHandler;\n}", "CodeBleu_score": 54.9754438195329}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (!udi_cdc_is_rx_ready())\n    return -1;\n  int c = udi_cdc_getc();\n  if (c == -1)\n    return -1;\n  if (emergency_parser.update(c))\n    c = emergency_parser.read();\n  return c;\n}", "CodeBleu_score": 52.35518820534282}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!udi_cdc_is_rx_ready()) {\n    return -1;\n  }\n  int c = udi_cdc_getc();\n  if (c != -1 && emergency_parser.update(c)) {\n    return emergency_parser.get_char();\n  }\n  return c;\n}", "CodeBleu_score": 41.11801880636609}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!udi_cdc_is_rx_ready()) return -1;\n  int c = udi_cdc_getc();\n  if (emergency_parser.update(c)) return emergency_parser.get();\n  return c;\n}", "CodeBleu_score": 36.934769769608536}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  int c = -1;\n\n  // Check if there is a pending character\n  if (pending_char >= 0) {\n    c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n\n  // Check if the USB CDC is enabled and configured\n  if (!udi_cdc_isenabled()) {\n    return -1;\n  }\n\n  // Check if there are any bytes available to read from the PC\n  if (!udi_cdc_is_rx_ready()) {\n    return -1;\n  }\n\n  // Read the byte\n  c = udi_cdc_getc();\n\n  // Update the emergency parser if enabled\n  if (emergency_parser) {\n    emergency_parser->update(c);\n  }\n\n  return c;\n}", "CodeBleu_score": 61.490146756047224}, {"code": "int MarlinSerialUSB::read(){\n\t  int c = -1;\n  if (pending_char) {\n    c = pending_char;\n    pending_char = 0;\n  } else if (udi_cdc_is_rx_ready()) {\n    if (udi_cdc_getc(&c) == -1) return -1;\n    emergency_parser.update(c);\n  }\n  return c;\n}", "CodeBleu_score": 40.00082373295058}, {"code": "int MarlinSerialUSB::read(){\n\t  // Check if there is a pending character\n  if (pending_char >= 0) {\n    int c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n\n  // Check if the USB CDC is enabled and configured\n  if (!udi_cdc_isenabled()) {\n    return -1;\n  }\n\n  // Check if there are any bytes available to read from the PC\n  if (!udi_cdc_is_rx_ready()) {\n    return -1;\n  }\n\n  // Read a byte from the PC\n  uint8_t c;\n  udi_cdc_getc(&c);\n\n  // Update the emergency parser if enabled\n  if (emergency_parser.enabled) {\n    emergency_parser.update(c);\n  }\n\n  // Return the read character\n  return c;\n}", "CodeBleu_score": 64.69910743969427}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t    if (usb_task_cdc_isenabled() && usb_task_cdc_is_rx_ready())\n        return 1;\n    return 0;\n}", "CodeBleu_score": 24.792582955360885}, {"code": "int MarlinSerialUSB::available(){\n\t    if (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready()) {\n        return 1;\n    }\n    return 0;\n}", "CodeBleu_score": 25.877919483784396}, {"code": "int MarlinSerialUSB::available(){\n\t  if (usb_task_cdc_isenabled()) {\n    if (udi_cdc_is_rx_ready()) {\n      return 1;\n    }\n  }\n  return 0;\n}", "CodeBleu_score": 23.860907698891214}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (pos < 0)\n    return false;\n\n  if (crc)\n    *crc = crc16;\n\n  for (size_t i = 0; i < size; i++) {\n    if (pos >= EEPROM_SIZE)\n      return false;\n\n    uint8_t data = ee_Read(pos);\n\n    if (writing)\n      value[i] = data;\n\n    crc16 = crc16_update(crc16, data);\n    pos++;\n  }\n\n  return true;\n}", "CodeBleu_score": 50.21773141876532}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (size == 0)\n    return true;\n  if (pos < 0)\n    pos = 0;\n  if (pos >= EEPROM_SIZE)\n    return false;\n  if (pos + size > EEPROM_SIZE)\n    size = EEPROM_SIZE - pos;\n  if (crc)\n    *crc = crc16;\n  for (size_t i = 0; i < size; i++) {\n    uint8_t data;\n    ee_Read(pos + i, &data);\n    if (writing)\n      value[i] = data;\n    crc16 = update_crc(crc16, data);\n  }\n  pos += size;\n  return true;\n}", "CodeBleu_score": 44.98830631494345}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (size == 0) {\n    return true;\n  }\n\n  uint16_t crc_old = crc16;\n  uint16_t crc_new = crc16;\n\n  for (size_t i = 0; i < size; i++) {\n    uint8_t b = ee_Read(pos);\n    if (writing) {\n      value[i] = b;\n    }\n    crc_new = crc16_update(crc_new, b);\n    pos++;\n  }\n\n  if (crc) {\n    *crc = crc_new;\n  }\n\n  return crc_old == crc_new;\n}", "CodeBleu_score": 45.616276249356375}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin >= NUM_DIGITAL_PINS) return;\n  if (value == 0) {\n    // Disable PWM if value is 0\n    ledcWrite(get_pwm_channel(pin), 0);\n    return;\n  }\n  if (res > 16) {\n    // Only 16 bits resolution is supported\n    return;\n  }\n  if (res == 16) {\n    // Use hardware PWM if full resolution is requested\n    ledcWrite(get_pwm_channel(pin), value);\n    return;\n  }\n  // Calculate 7-bit value\n  uint8_t val = (value * 127) / (1 << res);\n  ledcWrite(get_pwm_channel(pin), val);\n}", "CodeBleu_score": 29.62564278821802}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  ledcWrite(get_pwm_channel(pin), value);\n}", "CodeBleu_score": 6.570460919389171}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t    if (pin >= PINS_COUNT) {\n        return;\n    }\n\n    if (freq > PWM_FREQUENCY) {\n        freq = PWM_FREQUENCY;\n    }\n\n    if (res > 16) {\n        res = 16;\n    }\n\n    if (res < 2) {\n        res = 2;\n    }\n\n    if (value > (1 << res)) {\n        value = (1 << res);\n    }\n\n    if (value == 0) {\n        if (pin_state[pin].pwm_channel != -1) {\n            ledcDetachPin(pin);\n            pin_state[pin].pwm_channel = -1;\n        }\n\n        if (pin_state[pin].pwm_timer != -1) {\n            pin_state[pin].pwm_timer = -1;\n        }\n\n        if (pin_state[pin].pwm_count > 0) {\n            pin_state[pin].pwm_count--;\n        }\n\n        return;\n    }\n\n    int8_t channel = get_pwm_channel(pin, freq, res);\n    if (channel != -1) {\n        ledcWrite(channel, value);\n        return;\n    }\n\n    if (pin_state[pin].pwm_channel == -1) {\n        channel = get_pwm_channel(pin, freq, res);\n        if (channel == -1) {\n            return;\n        }\n\n        pin_state[pin].pwm_channel = channel;\n    }\n\n    ledcWrite(pin_state[pin].pwm_channel, value);\n}", "CodeBleu_score": 49.524177696343095}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(delay) / sizeof(delay[0]) == COUNT, \"Servo delay array length mismatch\");\n  if (attach()) {\n    write(value);\n    safe_delay(delay[TERN_(DEACTIVATE_SERVOS_AFTER_MOVE, 0, 1)]);\n    detach();\n  }\n}", "CodeBleu_score": 48.83592398885526}, {"code": "void Servo::move(const int value){\n\t  static_assert(COUNT == sizeof(delay) / sizeof(delay[0]),\n                \"The number of servo channels does not match the delay array length\");\n  if (attach()) {\n    write(value);\n    safe_delay(delay[_channel]);\n    if constexpr (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      detach();\n    }\n  }\n}", "CodeBleu_score": 53.91967123040848}, {"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(delay) / sizeof(delay[0]) == COUNT, \"Servo delay array length mismatch\");\n  if (attach(channel)) {\n    write(value);\n    safe_delay(delay[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      detach();\n    }\n  }\n}", "CodeBleu_score": 53.00970849298922}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t  for (int i = 0; i < NUM_PINS; i++) {\n    if (pwm_tick_count[i] == 0) {\n      if (pwm_duty_cycle[i] != 0) {\n        pwm_tick_count[i] = pwm_duty_cycle[i];\n      }\n      if (pins[i] == LOW) {\n        pins[i] = HIGH;\n      } else {\n        pins[i] = LOW;\n      }\n    } else {\n      pwm_tick_count[i]--;\n    }\n    dma_buffer[dma_buffer_pos] |= (pins[i] << i);\n  }\n  dma_buffer_pos++;\n}", "CodeBleu_score": 32.867295631039426}, {"code": "void i2s_push_sample(){\n\t    uint32_t i;\n    uint32_t port_data = 0;\n    uint32_t pwm_mask = 0;\n    uint32_t pwm_tick_count = 0;\n    uint32_t pwm_tick_next = 0;\n    uint32_t pwm_tick_period = 0;\n    uint32_t pwm_tick_period_next = 0;\n    uint32_t pwm_tick_period_max = 0;\n    uint32_t pwm_tick_period_max_next = 0;\n    uint32_t pwm_tick_period_max_next_next = 0;\n    uint32_t pwm_tick_period_max_next_next_next = 0;\n    uint32_t pwm_tick_period_max_next_next_next_next = 0;\n    uint32_t pwm_tick_period_max_next_next_next_next_next = 0;\n    uint32_t pwm_tick_period_max_next_next_next_next_next_next = 0;\n    uint32_t pwm_tick_period_max_next_next_next_next_next_next_next = 0;\n    uint32_t pwm_tick_period_max_next_next_next_next_next_next_next_next = 0;\n    uint32_t pwm_tick_period_max_next_next_next_next_next_next_next_next_next = 0;\n    uint32_t pwm_tick_period_max_next_next_next_next_next_next_next_next_next_next = 0;\n    uint32_t pwm_tick_period_max_next_next_next_next_next_next_next_next_next_next_next = 0;\n    uint32_t pwm_tick_period_max_next_next_next_next_next_next_", "CodeBleu_score": 6.315733129442835}, {"code": "void i2s_push_sample(){\n\t  for (uint8_t i = 0; i < NUM_PINS; i++) {\n    if (pwm_states[i].duty_cycle > 0) {\n      pwm_states[i].duty_cycle--;\n      if (pwm_states[i].duty_cycle == 0) {\n        pwm_states[i].state = !pwm_states[i].state;\n        pwm_states[i].duty_cycle = pwm_states[i].period;\n      }\n    }\n    if (pwm_states[i].state) {\n      PORTB |= (1 << i);\n    } else {\n      PORTB &= ~(1 << i);\n    }\n  }\n  for (uint8_t i = 0; i < NUM_PINS; i++) {\n    uint8_t data = pwm_states[i].state ? 0xFF : 0x00;\n    *dma_buffer_ptr = data;\n    dma_buffer_ptr++;\n  }\n}", "CodeBleu_score": 34.724033308950055}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t timer_count;\n\n    switch (timer_num) {\n        case 0:\n            timer_count = TIMER0->COUNT;\n            break;\n        case 1:\n            timer_count = TIMER1->COUNT;\n            break;\n        case 2:\n            timer_count = TIMER2->COUNT;\n            break;\n        case 3:\n            timer_count = TIMER3->COUNT;\n            break;\n        case 4:\n            timer_count = TIMER4->COUNT;\n            break;\n        case 5:\n            timer_count = TIMER5->COUNT;\n            break;\n        case 6:\n            timer_count = TIMER6->COUNT;\n            break;\n        case 7:\n            timer_count = TIMER7->COUNT;\n            break;\n        default:\n            timer_count = 0;\n            break;\n    }\n\n    return timer_count;\n}", "CodeBleu_score": 28.96264477220792}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    if (timer_num > TIMER_MAX_NUM) {\n        return 0;\n    }\n    return (hal_timer_t)hal_timer_get_count_addr(timer_num);\n}", "CodeBleu_score": 20.175536279032194}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  hal_timer_t counter_value;\n  if (timer_num < TIMER_NUM) {\n    counter_value = timer_get_counter_value(timer_num);\n  }\n  return counter_value;\n}", "CodeBleu_score": 40.4495362718907}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint8_t data;\n  uint16_t crc16;\n  for (size_t i = 0; i < size; i++) {\n    data = EEPROM.read(pos);\n    crc16 = crc16_update(data, *crc);\n    if (writing)\n      value[i] = data;\n    pos++;\n  }\n  *crc = crc16;\n  return false;\n}", "CodeBleu_score": 63.26681411226733}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t    for (size_t i = 0; i < size; i++) {\n        uint8_t b = EEPROM.read(pos);\n        if (writing) {\n            value[i] = b;\n        }\n        crc16::crc16_update(*crc, b);\n        pos++;\n    }\n    return false;\n}", "CodeBleu_score": 62.88645602193322}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t    if (!size)\n        return true;\n    uint16_t crc_start = *crc;\n    for (size_t i = 0; i < size; i++) {\n        uint8_t data;\n        if (!read_byte(pos, data))\n            return false;\n        *crc = update_crc(*crc, data);\n        if (writing)\n            value[i] = data;\n    }\n    if (crc_start != *crc)\n        return false;\n    pos += size;\n    return true;\n}", "CodeBleu_score": 59.523422916849334}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    CORE_ASSERT(SDIO_Handle != NULL);\n    CORE_ASSERT(src != NULL);\n\n    uint32_t retries = 0;\n    while (retries < SDCARD_MAX_RETRIES) {\n        if (SDCARD_WriteBlocks(SDIO_Handle, block, 1, src)) {\n            return true;\n        }\n        retries++;\n    }\n\n    printf(\"SDIO_WriteBlock: failed to write block %lu\n\", block);\n    return false;\n}", "CodeBleu_score": 38.570100181639425}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    CORE_ASSERT(sdio_handle != NULL);\n    CORE_ASSERT(src != NULL);\n\n    uint8_t retries = 0;\n    while (retries < SDIO_MAX_RETRIES) {\n        if (SDIO_WriteSingleBlock(sdio_handle, block, src)) {\n            return true;\n        }\n        retries++;\n    }\n\n    printf(\"Failed to write block %d to SD card\n\", block);\n    return false;\n}", "CodeBleu_score": 37.325091609792494}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  CORE_ASSERT(src);\n  CORE_ASSERT(block < SDCARD_NUM_BLOCKS);\n\n  WITH_RETRY(SDCARD_WriteBlocks(block, 1, src), 3, false);\n\n  return true;\n}", "CodeBleu_score": 17.694320051829806}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n    case TEMPERATURE_TIMER:\n      timer_num->setCallbackPriority(TEMPERATURE_TIMER_CALLBACK_PRIORITY);\n      break;\n    case STEPPER_TIMER:\n      timer_num->setCallbackPriority(STEPPER_TIMER_CALLBACK_PRIORITY);\n      break;\n    default:\n      CORE_ASSERT_FAIL();\n      break;\n  }\n  timer_num->start(frequency);\n}", "CodeBleu_score": 29.406872932455673}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    CORE_DEBUG_PRINTF(\"HAL_timer_start: timer_num=%d, frequency=%d\n\", timer_num, frequency);\n\n    if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n        CORE_ASSERT_FAIL(timer_num == TIMER_CHANNEL_TEMPERATURE);\n        CORE_ASSERT_FAIL(frequency > 0);\n\n        timer_num->start(frequency, TIMER_PRESCALE_TEMPERATURE);\n        timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY_TEMPERATURE);\n    } else if (timer_num == TIMER_CHANNEL_STEPPER) {\n        CORE_ASSERT_FAIL(timer_num == TIMER_CHANNEL_STEPPER);\n        CORE_ASSERT_FAIL(frequency > 0);\n\n        timer_num->start(frequency, TIMER_PRESCALE_STEPPER);\n        timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY_STEPPER);\n    } else {\n        CORE_ASSERT_FAIL(timer_num == TIMER_CHANNEL_TEMPERATURE || timer_num == TIMER_CHANNEL_STEPPER);\n    }\n}", "CodeBleu_score": 56.86506526776864}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    CORE_ASSERT_FAIL_IF(timer_num == TIMER_CHANNEL_TEMPERATURE);\n    CORE_ASSERT_FAIL_IF(timer_num == TIMER_CHANNEL_STEPPER);\n\n    timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY);\n    timer_num->start(frequency);\n}", "CodeBleu_score": 28.348781147333785}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  bool result = true;\n\n  if (file) {\n    fclose(file);\n    file = NULL;\n  }\n\n  file = fopen(filename, \"r+\");\n\n  if (file) {\n    fseek(file, 0, SEEK_END);\n    int size = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    if (size < EEPROM_SIZE) {\n      memset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n      fread(buffer, 1, EEPROM_SIZE, file);\n      fseek(file, 0, SEEK_END);\n    } else {\n      fread(buffer, 1, EEPROM_SIZE, file);\n    }\n\n    fclose(file);\n    file = NULL;\n  } else {\n    memset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n    result = false;\n  }\n\n  return result;\n}", "CodeBleu_score": 46.6722313960105}, {"code": "bool PersistentStore::access_start(){\n\t  // Open the file\n  FILE *file = fopen(PERSISTENT_STORE_FILE, \"r+b\");\n  if (file == NULL) {\n    // File does not exist or cannot be opened\n    return false;\n  }\n\n  // Get the file size\n  fseek(file, 0, SEEK_END);\n  size_t file_size = ftell(file);\n  fseek(file, 0, SEEK_SET);\n\n  // Check if the file is of sufficient size\n  if (file_size < PERSISTENT_STORE_SIZE) {\n    // Fill the remainder of the buffer with a default erase value\n    memset(buffer + file_size, PERSISTENT_STORE_ERASE_VALUE, PERSISTENT_STORE_SIZE - file_size);\n  }\n\n  // Read the file's contents into the buffer\n  fread(buffer, 1, PERSISTENT_STORE_SIZE, file);\n\n  // Close the file\n  fclose(file);\n\n  return true;\n}", "CodeBleu_score": 45.969458121087364}, {"code": "bool PersistentStore::access_start(){\n\t  // Open the file\n  FILE* fp = fopen(filename, \"rb+\");\n  if (fp == NULL) {\n    // File does not exist or cannot be opened\n    return false;\n  }\n\n  // Get the file size\n  fseek(fp, 0, SEEK_END);\n  size_t file_size = ftell(fp);\n  fseek(fp, 0, SEEK_SET);\n\n  // Check if the file is of sufficient size\n  if (file_size < EEPROM_SIZE) {\n    // Fill the remainder of the buffer with a default erase value\n    memset(buffer + file_size, EEPROM_ERASE_VALUE, EEPROM_SIZE - file_size);\n  }\n\n  // Read the file contents into the buffer\n  fread(buffer, 1, EEPROM_SIZE, fp);\n\n  // Close the file\n  fclose(fp);\n\n  return true;\n}", "CodeBleu_score": 44.92306357247236}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    for (uint8_t i = 0; i < 8; i++) {\n        r <<= 1;\n        if (b & 0x80) {\n            WRITE\n        } else {\n            WRITE\n        }\n        READ\n        delaySPIFunc\n    }\n    return r;\n}", "CodeBleu_score": 34.90060945635239}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tr <<= 1;\n\t\tdigitalWrite(SPI_CLK, LOW);\n\t\tdigitalWrite(SPI_MOSI, b & 0x80);\n\t\tdigitalWrite(SPI_CLK, HIGH);\n\t\tif (digitalRead(SPI_MISO))\n\t\t\tr |= 1;\n\t}\n\tdelaySPIFunc();\n\treturn r;\n}", "CodeBleu_score": 45.78656313095966}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t r = 0;\n  for (int i = 0; i < 8; i++) {\n    if (b & 0x80) {\n      WRITE\n    } else {\n      WRITE\n    }\n    delaySPIFunc\n    READ\n    r = (r << 1) | (b & 0x80);\n    b <<= 1;\n  }\n  delaySPIFunc\n  return r;\n}", "CodeBleu_score": 37.44308250942877}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 83.96887672648454}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= (uint32_t)(~(uint32_t)RCC_AHBPeriph);\n  }\n}", "CodeBleu_score": 77.44374258262798}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 84.07596204999733}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c = obj->read();\n  if (c != SERIAL_NO_DATA) {\n    if (emergency_parser.enabled) {\n      emergency_parser.update(c);\n    }\n    if (!rx_buffer.isFull()) {\n      rx_buffer.store_char(c);\n      rx_buffer.incr_head();\n    }\n  }\n}", "CodeBleu_score": 29.433950313526232}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c = obj->getc();\n  if (obj->parity_error()) return;\n  if (rx_buffer_head < RX_BUFFER_SIZE) {\n    rx_buffer[rx_buffer_head++] = c;\n  }\n  rx_buffer_index = (rx_buffer_index + 1) % RX_BUFFER_SIZE;\n  if (emergency_parser.enabled) emergency_parser.update(c);\n}", "CodeBleu_score": 30.89370045990696}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  // If parity error, reset the receive buffer\n  if (obj->status & SERIAL_STATUS_RX_OVERFLOW) {\n    obj->status &= ~SERIAL_STATUS_RX_OVERFLOW;\n    obj->rx_buffer_head = 0;\n    obj->rx_buffer_tail = 0;\n  }\n  // Read the received byte\n  uint8_t data = obj->uart->getc();\n  // Store the received byte in the receive buffer if there is space available\n  if (obj->rx_buffer_head != (obj->rx_buffer_tail - 1)) {\n    obj->rx_buffer[obj->rx_buffer_head] = data;\n    obj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n  // Update the emergency parser with the received byte\n  emergency_parser.update(data);\n}", "CodeBleu_score": 44.822830588708264}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_instance[timer_num]->hasInterrupt) {\n        return;\n    }\n\n    if (!HAL_timer_initialized(timer_num)) {\n        return;\n    }\n\n    switch (timer_num) {\n        case MF_TIMER_STEP:\n            timer_instance[timer_num]->attachInterrupt(Step_Handler);\n            break;\n        case MF_TIMER_TEMP:\n            timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n            break;\n    }\n\n    timer_instance[timer_num]->hasInterrupt = true;\n}", "CodeBleu_score": 77.38992443973825}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->hasInterrupt()) {\n\t\treturn;\n\t}\n\n\tswitch (timer_num) {\n\tcase MF_TIMER_STEP:\n\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\tbreak;\n\tcase MF_TIMER_TEMP:\n\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 75.11556298228096}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\n    if (HAL_timer_initialized(timer_num) && !timer_instance[timer_num]->hasInterrupt) {\n        switch (timer_num) {\n            case MF_TIMER_STEP:\n                timer_instance[timer_num]->attachInterrupt(Step_Handler);\n                break;\n            case MF_TIMER_TEMP:\n                timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n                break;\n        }\n    }\n}", "CodeBleu_score": 86.97132943820151}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tlen, hashSep := len(sep), HashStrRev(sep)\n\tif len == 0 {\n\t\treturn 0\n\t}\n\tif len > len(s) {\n\t\treturn -1\n\t}\n\tvar hash uint32\n\tfor i := len - 1; i >= 0; i-- {\n\t\thash = hash*base + uint32(s[i])\n\t}\n\tif hash == hashSep && string(s[len-1:]) == string(sep) {\n\t\treturn len - 1\n\t}\n\tvar pow uint32 = 1\n\tfor i := 0; i < len-1; i++ {\n\t\tpow *= base\n\t}\n\tfor i := len; i < len(s); i++ {\n\t\thash = hash*base - uint32(s[i-len])*pow + uint32(s[i])\n\t\tif hash == hashSep && string(s[i-len+1:i+1]) == string(sep) {\n\t\t\treturn i - len + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 45.22022246432275}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tlenS, lenSep := len(s), len(sep)\n\tif lenSep > lenS {\n\t\treturn -1\n\t}\n\n\thashSep := HashStrRev(sep)\n\thashS := HashStrRev(s[lenS-lenSep : lenS])\n\tif hashSep != hashS {\n\t\treturn -1\n\t}\n\n\tfor i := lenS - lenSep; i >= 0; i-- {\n\t\tif s[i:i+lenSep] == sep {\n\t\t\treturn i\n\t\t}\n\n\t\tif i == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\thashS = (hashS - uint32(s[i+lenSep-1])*pow32[lenSep-1]) * 31 + uint32(s[i-1])\n\t}\n\n\treturn -1\n}", "CodeBleu_score": 37.740564253514954}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tlen, sepLen := len(s), len(sep)\n\tif len < sepLen {\n\t\treturn -1\n\t}\n\tif sepLen == 0 {\n\t\treturn len\n\t}\n\n\thashSep := HashStrRev(sep)\n\thash := HashStrRev(s[len-sepLen:])\n\tpow := uint32(1)\n\tfor i := 0; i < sepLen-1; i++ {\n\t\tpow *= primeRK\n\t}\n\n\tfor i := len - sepLen; i >= 0; i-- {\n\t\tif hash == hashSep && s[i:i+sepLen] == sep {\n\t\t\treturn i\n\t\t}\n\t\tif i > 0 {\n\t\t\thash -= uint32(s[i+sepLen-1]) * pow\n\t\t\thash *= primeRK\n\t\t\thash += uint32(s[i-1])\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 42.19825184120876}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.211916470826246}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.211916470826246}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.211916470826246}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t    i2c.crReg.HasBits.Clear()\n    i2c.crReg.HasBits.Start = 1\n    i2c.crReg.HasBits.En = 1\n\n    for i2c.crReg.HasBits.Start == 0 {\n    }\n\n    i2c.writeByte(address << 1 | write)\n\n    for i2c.crReg.HasBits.Stop == 0 {\n    }\n}", "CodeBleu_score": 31.28686824481523}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(I2C_CR_START)\n\ti2c.crReg.SetBits(I2C_CR_START)\n\ti2c.crReg.SetBits(I2C_CR_ENABLE)\n\tfor i2c.crReg.HasBits(I2C_CR_START) {\n\t}\n\ti2c.writeByte(address, write)\n}", "CodeBleu_score": 36.44104559576431}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(I2C_CR_START | I2C_CR_STOP)\n\ti2c.crReg.SetBits(I2C_CR_START)\n\ti2c.crReg.SetBits(I2C_CR_STA)\n\ti2c.waitForEvent(I2C_ISR_STOPF)\n\n\ti2c.drReg.Set(uint32(address << 1))\n\tif write {\n\t\ti2c.crReg.ClearBits(I2C_CR_RD_WRN)\n\t} else {\n\t\ti2c.crReg.SetBits(I2C_CR_RD_WRN)\n\t}\n\n\ti2c.crReg.SetBits(I2C_CR_START)\n\ti2c.waitForEvent(I2C_ISR_TXE)\n}", "CodeBleu_score": 29.49413546896644}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address based on the block number and block size\n\tstartAddr := f.FlashDataStart + uintptr(start*f.EraseBlockSize)\n\n\t// Wait for any ongoing flash operations to complete\n\twaitWhileFlashBusy()\n\n\t// Configure the flash for erasing\n\tnrf.NVMC.SetCONFIG_WEN\n\n\t// Erase the specified number of blocks\n\tfor i := int64(0); i < len; i++ {\n\t\t// Erase the block\n\t\tnrf.NVMC.ERASEPAGE.Set\n\n\t\t// Wait until the flash is no longer busy\n\t\twaitWhileFlashBusy()\n\t}\n\n\t// Set the flash back to read mode\n\tnrf.NVMC.SetCONFIG_RDEN\n\n\t// Return success\n\treturn nil\n}", "CodeBleu_score": 34.86191571676504}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif f.EraseBlockSize == 0 {\n\t\treturn errors.New(\"EraseBlockSize not set\")\n\t}\n\n\tstartAddr := f.FlashDataStart + uintptr(start*f.EraseBlockSize)\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN\n\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(startAddr + uintptr(i*f.EraseBlockSize))\n\t\twaitWhileFlashBusy()\n\t}\n\n\tnrf.NVMC.SetCONFIG_RDEN\n\n\treturn nil\n}", "CodeBleu_score": 43.808879505658574}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif len == 0 {\n\t\treturn nil\n\t}\n\n\tstartAddr := f.FlashDataStart + uint32(start) * uint32(f.EraseBlockSize)\n\tendAddr := startAddr + uint32(len) * uint32(f.EraseBlockSize)\n\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\tnrf.NVMC.ERASEPAGE.Set\n\n\tfor addr := startAddr; addr < endAddr; addr += uint32(f.EraseBlockSize) {\n\t\twaitWhileFlashBusy\n\t}\n\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 44.509540962022726}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > f.FlashSize()-off {\n\t\treturn 0, ErrInvalidOffset\n\t}\n\tstart := uintptr(f.FlashDataStart) + uintptr(off)\n\tif start%f.WriteBlockSize != 0 {\n\t\tp = binary.LittleEndian.Uint32(p)\n\t\tlen := binary.LittleEndian.Uint32(p)\n\t\tbinary.LittleEndian.PutUint32(p, len)\n\t\tp = append(p, f.pad...)\n\t}\n\tnrf.NVMC.SetCONFIG_WEN(true)\n\tfor len(p) > 0 {\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.SetCONFIG_WEN(true)\n\t\tnrf.NVMC.SetERASEPAGE(uint32(start))\n\t\tnrf.NVMC.SetERASEUIC()\n\t\tnrf.NVMC.SetERASEUEN(true)\n\t\tnrf.NVMC.SetERASEUEN(false)\n\t\tnrf.NVMC.SetCONFIG_WEN(false)\n\t\tnrf.NVMC.SetCONFIG_WEN(true)\n\t\tnrf.NVMC.SetCONFIG_WP(true)\n\t\tnrf.NVMC.SetCONFIG_WP(false)\n\t\tnrf.NVMC.SetCONFIG_WP(true)\n\t\tnrf.NVMC.SetCONFIG_WP(false)\n\t\tnrf.NVMC.SetCONFIG_WP(true)\n\t\tnrf.NVMC.SetCONFIG_WP(false)\n\t\tnrf.NVMC.SetCONFIG_WP(true)\n\t\tnrf.NVMC.SetCONFIG_WP(false)\n\t\tnrf.NVMC.SetCONFIG_WP(true)\n\t\tnrf.NVMC.SetCONFIG_WP(false)\n\t\tnrf.NVMC.SetCONFIG_WP(true)\n\t\tnrf.NVMC.SetCONFIG_WP(false)\n\t\tnrf.NVMC.SetCONFIG_WP(true", "CodeBleu_score": 30.745416230142524}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, ErrInvalidOffset\n\t}\n\n\tstart := f.FlashDataStart + uint32(off)\n\tif start%f.WriteBlockSize != 0 {\n\t\treturn 0, ErrInvalidOffset\n\t}\n\n\tbinary.LittleEndian.PutUint32(f.FlashDataStart, start)\n\n\tpad := f.WriteBlockSize - uintptr(len(p))%f.WriteBlockSize\n\tbinary.LittleEndian.PutUint32(f.FlashDataEnd, start+uint32(len(p))+pad)\n\n\tnrf.NVMC.SetCONFIG_WEN(true)\n\tdefer nrf.NVMC.SetCONFIG_WEN(false)\n\n\tfor len(p) > 0 {\n\t\tbinary.LittleEndian.PutUint32(f.FlashDataEnd, start+uint32(len(p)))\n\n\t\tnrf.NVMC.SetERASEPAGE(start)\n\t\twaitWhileFlashBusy()\n\n\t\tbinary.LittleEndian.PutUint32(f.FlashDataStart, start)\n\t\tbinary.LittleEndian.PutUint32(f.FlashDataEnd, start+uint32(len(p)))\n\t\tnrf.NVMC.SetWRITE(unsafe.Pointer(&p[0]))\n\t\twaitWhileFlashBusy()\n\n\t\tstart += uint32(len(p))\n\t\tp = p[len(p):]\n\t}\n\n\tbinary.LittleEndian.PutUint32(f.FlashDataEnd, start)\n\n\treturn int(len(p)), nil\n}", "CodeBleu_score": 36.03334106662467}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, ErrInvalidWrite\n\t}\n\tif off%f.WriteBlockSize != 0 {\n\t\treturn 0, ErrInvalidWrite\n\t}\n\tstart := uint32(off / f.WriteBlockSize * f.WriteBlockSize)\n\tend := start + uint32(len(p))\n\tbinary.LittleEndian.PutUint32(f.pad, 0xFFFFFFFF)\n\tn = len(p)\n\tnrf.NVMC.SetCONFIG_WEN(true)\n\tdefer nrf.NVMC.SetCONFIG_WEN(false)\n\tfor start < end {\n\t\tblock := start / f.WriteBlockSize\n\t\taddr := FlashDataStart + uintptr(block)*f.WriteBlockSize\n\t\tdata := p[start-off : int(math.Min(float64(end), float64(start+f.WriteBlockSize)))-off]\n\t\tnrf.NVMC.SetCONFIG_WEN(true)\n\t\tnrf.NVMC.SetERASEPAGE(uint32(addr))\n\t\tnrf.NVMC.SetCONFIG_WEN(false)\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.SetCONFIG_WEN(true)\n\t\tnrf.NVMC.SetERASEUICR(uint32(addr))\n\t\tnrf.NVMC.SetCONFIG_WEN(false)\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.SetCONFIG_WEN(true)\n\t\tnrf.NVMC.SetWRITE(uint32(addr), unsafe.Pointer(&data[0]))\n\t\tnrf.NVMC.SetCONFIG_WEN(false)\n\t\twaitWhileFlashBusy()\n\t\tstart += f.WriteBlockSize\n\t}\n\treturn\n}", "CodeBleu_score": 33.283482216224385}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tfd2, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tvar dir *syscall.Dir\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fd2)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(fd2)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\n\treturn uintptr(fd2), \"\", nil\n}", "CodeBleu_score": 74.04496372634135}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdirfd, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tvar dir *syscall.Dirent\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dirfd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(dirfd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\n\treturn uintptr(dirfd), \"\", nil\n}", "CodeBleu_score": 70.99260506126328}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tfd2, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tvar dir *os.File\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fd2)\n\t\tif err != nil {\n\t\t\tif err != syscall.EINTR {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\tif err != nil {\n\t\tsyscall.Close(fd2)\n\t\treturn 0, \"\", err\n\t}\n\n\treturn uintptr(dir.Fd()), \"\", nil\n}", "CodeBleu_score": 75.76140111140364}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t* partition = esp_ota_get_running_partition();\n  if (partition == NULL) {\n    return 0;\n  }\n  if (esp_image_verify(partition->address, partition->size) != ESP_OK) {\n    return 0;\n  }\n  return response == sketchSize_t::sketchSize_t_freeSpace ? partition->size : esp_image_size(partition->address);\n}", "CodeBleu_score": 35.05156684585263}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  esp_partition_iterator_t iter = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_OTA_0, NULL);\n  esp_partition_t *partition = esp_partition_get(iter);\n  esp_partition_iterator_release(iter);\n  if (partition == NULL) {\n    return 0;\n  }\n  if (response == sketchSize_t::FREE_SPACE) {\n    return partition->size - partition->used_size;\n  }\n  return partition->used_size;\n}", "CodeBleu_score": 36.131820421137604}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  uint32_t sketchSize = 0;\n  esp_partition_t *runningPartition = esp_ota_get_running_partition();\n  if (response == SKETCH_SIZE_FREE_SPACE) {\n    sketchSize = runningPartition->size - (runningPartition->address - runningPartition->next->address);\n  } else {\n    esp_app_desc_t app_desc;\n    if (esp_ota_get_partition_description(runningPartition, &app_desc) == ESP_OK) {\n      sketchSize = app_desc.size;\n    }\n  }\n  return sketchSize;\n}", "CodeBleu_score": 41.92070043906124}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t required_disk_sectors;\n    void *disk;\n    bool success = false;\n\n    required_disk_sectors = msc_update_get_required_disk_sectors(volume_label, serial_number);\n    disk = calloc(required_disk_sectors, 512);\n    if (!disk) {\n        log_e(\"Failed to allocate %u bytes for RAM disk\", required_disk_sectors * 512);\n        goto exit;\n    }\n\n    fat_file_system_type = fat_add_boot_sector(disk, required_disk_sectors, volume_label, serial_number);\n    if (!fat_file_system_type) {\n        log_e(\"Failed to add boot sector\");\n        goto exit;\n    }\n\n    if (!fat_add_table(disk, required_disk_sectors)) {\n        log_e(\"Failed to add FAT table\");\n        goto exit;\n    }\n\n    if (partition_is_running()) {\n        if (!fat_add_root_file(disk, \"firmware.bin\", firmware_bin_size, firmware_bin_data)) {\n            log_e(\"Failed to add root file\");\n            goto exit;\n        }\n    }\n\n    success = true;\n\nexit:\n    return success;\n}", "CodeBleu_score": 34.53587019150477}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t required_disk_sectors;\n    uint8_t *disk_data;\n    fat_file_system_type *fat_type;\n    fat_boot_sector *boot_sector;\n    fat_file_allocation_table *table;\n    fat_root_file *root_file;\n    bool success;\n\n    required_disk_sectors = msc_update_get_required_disk_sectors(volume_label, serial_number);\n    disk_data = calloc(required_disk_sectors, sizeof(uint8_t));\n    if (disk_data == NULL) {\n        log_e(\"Failed to allocate memory for disk data\");\n        return false;\n    }\n\n    fat_type = fat_add_boot_sector(disk_data, required_disk_sectors, volume_label, serial_number);\n    if (fat_type == NULL) {\n        log_e(\"Failed to add boot sector\");\n        return false;\n    }\n\n    boot_sector = (fat_boot_sector *) fat_type->boot_sector;\n    table = fat_add_table(disk_data, boot_sector);\n    if (table == NULL) {\n        log_e(\"Failed to add file allocation table\");\n        return false;\n    }\n\n    root_file = fat_add_root_file(disk_data, boot_sector, table, \"firmware.bin\", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "CodeBleu_score": 36.1731824689903}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t required_disk_sectors;\n    uint8_t *disk_data;\n    uint32_t disk_sectors;\n    uint32_t fat_size_to_sectors;\n    uint32_t fat_sectors;\n    uint32_t fat_table_sectors;\n    uint32_t fat_table_size;\n    uint32_t fat_table_entries;\n    uint32_t fat_table_entry_size;\n    uint32_t fat_table_entry_count;\n    uint32_t fat_table_entry_offset;\n    uint32_t fat_table_entry_value;\n    uint32_t fat_table_entry_index;\n    uint32_t fat_table_entry_index_offset;\n    uint32_t fat_table_entry_index_value;\n    uint32_t fat_table_entry_index_count;\n    uint32_t fat_table_entry_index_index;\n    uint32_t fat_table_entry_index_index_offset;\n    uint32_t fat_table_entry_index_index_value;\n    uint32_t fat_table_entry_index_index_count;\n    uint32_t fat_table_entry_index_index_index;\n    uint32_t fat_table_entry_index_index_index_offset;\n    uint32_t fat_table_entry_index_index_index_value;\n    uint32_t fat_table_entry_index_index_index_count;\n    uint32_t fat_table_entry_index_index_index_index;\n    uint32_t fat_table_entry_index_index_index_index_offset;\n    uint32_t fat_table_entry_index_index_index_index_value;\n    uint32_t fat_table_entry_index_index_index_index_count;\n    uint32_t fat_table_entry_index_index_index_index_index;\n    uint32_t fat_table_entry", "CodeBleu_score": 7.116313189253515}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Offset is not aligned with flash sector size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    // Erase the corresponding sector\n    esp_err_t err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase sector: %s\", esp_err_to_name(err));\n        return err;\n    }\n\n    // Write the data to the specified offset\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data: %s\", esp_err_to_name(err));\n        return err;\n    }\n\n    return ESP_OK;\n}", "CodeBleu_score": 53.29534668524312}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    // Check if the offset is aligned with the flash sector size\n    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Offset 0x%08x is not aligned with flash sector size\", offset);\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    // Check if the size is a multiple of the flash sector size\n    if (size % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Size 0x%08x is not a multiple of flash sector size\", size);\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    // Erase the corresponding sector if necessary\n    esp_err_t err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase sector at offset 0x%08x\", offset);\n        return err;\n    }\n\n    // Write the data to the specified offset\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data to partition\");\n    }\n\n    return err;\n}", "CodeBleu_score": 51.05458301230404}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"offset 0x%08x is not aligned with flash sector size\", offset);\n        return ESP_ERR_INVALID_SIZE;\n    }\n    esp_err_t err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"failed to erase flash sector at offset 0x%08x, error %d\", offset, err);\n        return err;\n    }\n    return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 55.89480916860155}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t outlen = 0;\n    while (*in && outlen < maxlen) {\n        unsigned char c = *in++;\n        if (c >= '0' && c <= '9')\n            c -= '0';\n        else if (c >= 'A' && c <= 'F')\n            c -= 'A' - 10;\n        else if (c >= 'a' && c <= 'f')\n            c -= 'a' - 10;\n        else\n            continue;\n        *out++ = c;\n        outlen++;\n        c = *in++;\n        if (c >= '0' && c <= '9')\n            c -= '0';\n        else if (c >= 'A' && c <= 'F')\n            c -= 'A' - 10;\n        else if (c >= 'a' && c <= 'f')\n            c -= 'a' - 10;\n        else\n            continue;\n        *out++ = c;\n        outlen++;\n    }\n    return outlen;\n}", "CodeBleu_score": 36.09315054566705}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  size_t j = 0;\n  while (in[i] && j < maxlen) {\n    unsigned char a = hex_char_to_byte(in[i++]);\n    unsigned char b = hex_char_to_byte(in[i++]);\n    if (a == 0xFF || b == 0xFF) {\n      break;\n    }\n    out[j++] = (a << 4) | b;\n  }\n  return j;\n}", "CodeBleu_score": 37.38270849157093}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i = 0;\n    while (*in && i < maxlen) {\n        unsigned char c = *in++;\n        if (c >= '0' && c <= '9') {\n            out[i] = c - '0';\n        } else if (c >= 'A' && c <= 'F') {\n            out[i] = c - 'A' + 10;\n        } else if (c >= 'a' && c <= 'f') {\n            out[i] = c - 'a' + 10;\n        } else {\n            continue;\n        }\n        if (*in && i < maxlen - 1) {\n            c = *in++;\n            if (c >= '0' && c <= '9') {\n                out[i] = (out[i] << 4) | (c - '0');\n            } else if (c >= 'A' && c <= 'F') {\n                out[i] = (out[i] << 4) | (c - 'A' + 10);\n            } else if (c >= 'a' && c <= 'f') {\n                out[i] = (out[i] << 4) | (c - 'a' + 10);\n            } else {\n                continue;\n            }\n        }\n        i++;\n    }\n    return i;\n}", "CodeBleu_score": 45.760398814476574}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t  if (txRingBuffer != NULL && txLock != NULL) {\n    if (xSemaphoreTake(txLock, 100) == pdTRUE) {\n      int freeSize = xRingbufferGetCurFreeSize(txRingBuffer);\n      xSemaphoreGive(txLock);\n      return freeSize;\n    }\n  }\n  return 0;\n}", "CodeBleu_score": 57.51993437502628}, {"code": "int HWCDC::availableForWrite(void){\n\t  if ((txRingBuffer == NULL) || (txLock == NULL)) {\n    return 0;\n  }\n  if (xSemaphoreTake(txLock, (TickType_t) 1000) == pdTRUE) {\n    int freeSize = xRingbufferGetCurFreeSize(txRingBuffer);\n    xSemaphoreGive(txLock);\n    return freeSize;\n  }\n  return 0;\n}", "CodeBleu_score": 62.56981644325783}, {"code": "int HWCDC::availableForWrite(void){\n\t    if (xSemaphoreTake(xRingbufferLock, portMAX_DELAY) == pdTRUE) {\n        int freeSize = xRingbufferGetCurFreeSize(xRingbuffer);\n        xSemaphoreGive(xRingbufferLock);\n        return freeSize;\n    }\n    return 0;\n}", "CodeBleu_score": 39.16434465484948}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  if (onlyOnTimeout) {\n    uartSetRxTimeout(true);\n  } else {\n    uartSetRxTimeout(false);\n  }\n  if (_onReceiveCB != NULL) {\n    uartSetRxFIFOFull();\n    if (!_eventTask) {\n      _eventTask = _createEventTask();\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 52.01081960962759}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _rxTimeout = onlyOnTimeout;\n  uartSetRxFIFOFull();\n  if (_onReceiveCB) {\n    if (!_eventTask) {\n      _eventTask = _createEventTask();\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 36.816481332797565}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  if (_onReceiveCB) {\n    uartSetRxFIFOFull(true);\n    if (!_eventTask)\n      _createEventTask();\n  }\n  _rxTimeout = onlyOnTimeout;\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 31.53190782371803}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index++] = c;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuffer[index] = '\\0';\n\treturn index;\n}", "CodeBleu_score": 61.19945339842967}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1)\n    return 0;\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0)\n      break;\n    *buffer++ = c;\n    index++;\n    if (c == terminator)\n      break;\n  }\n  return index; // e.g. index - 1\n}", "CodeBleu_score": 74.42574771441221}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1)\n    return 0;\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0)\n      break;\n    *buffer++ = c;\n    index++;\n    if (c == terminator)\n      break;\n  }\n  *buffer = 0;\n  return index;\n}", "CodeBleu_score": 72.31204800924714}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_e(\"tone(%d, %d, %lu)\", pin, frequency, duration);\n  if (tone_init(pin, frequency, duration)) {\n    if (xQueueSend(toneQueue, &tone_cmd, portMAX_DELAY) != pdPASS) {\n      log_d(\"toneQueue is full\");\n    }\n  }\n}", "CodeBleu_score": 27.40061161361032}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_e(\"tone(%d, %d, %d)\", pin, frequency, duration);\n  if (tone_init(pin)) {\n    log_d(\"tone(%d, %d, %d) -> %d\", pin, frequency, duration, xQueueSend(toneQueue, &(ToneCommand){.pin = pin, .frequency = frequency, .duration = duration}, 0));\n  } else {\n    log_e(\"tone(%d, %d, %d) -> %s\", pin, frequency, duration, \"pin in use\");\n  }\n}", "CodeBleu_score": 45.52504312373226}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_e(\"tone(%d, %d, %d)\", pin, frequency, duration);\n  if (tone_init(pin)) {\n    xQueueSend(queue, (void *) &tone_start_command(pin, frequency, duration), portMAX_DELAY);\n  } else {\n    log_d(\"tone(%d) already in use\", pin);\n  }\n}", "CodeBleu_score": 29.348219792077927}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!_usbStarted) {\n    _webUSBEnabled = enabled;\n    if (enabled) {\n      if (_usbVersion < USB_VERSION_2_0) {\n        _usbVersion = USB_VERSION_2_0;\n      }\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 50.73727999352864}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (this->_usbStarted) {\n        return false;\n    }\n    this->_webUSBEnabled = enabled;\n    if (enabled) {\n        this->_usbVersion = 0x0210;\n    }\n    return true;\n}", "CodeBleu_score": 32.58268092902094}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (started) {\n    return false;\n  }\n  webUSBEnabled = enabled;\n  if (webUSBEnabled) {\n    if (usbVersion < 0x0210) {\n      usbVersion = 0x0210;\n    }\n  }\n  return true;\n}", "CodeBleu_score": 57.53135889926083}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t    int bytes_read = tud_cdc_n_read(0);\n    if (bytes_read > 0) {\n        for (int i = 0; i < bytes_read; i++) {\n            if (xQueueSend(rx_queue, &rx_buf[i], 0) != pdTRUE) {\n                log_e(\"RX queue overflow\");\n                _onOverflow(bytes_read - i);\n                return;\n            }\n        }\n        tud_cdc_n_read_flush(0);\n        tud_cdc_n_write_flush(0);\n        arduino_usb_event_post(ARDUINO_USB_EVENT_RX);\n    }\n}", "CodeBleu_score": 21.54639388778234}, {"code": "void USBCDC::_onRX(){\n\t    uint8_t *buf = (uint8_t *)tud_cdc_n_read(0);\n    if (buf) {\n        uint16_t len = tud_cdc_n_available(0);\n        if (len > USB_BUF_SIZE) {\n            len = USB_BUF_SIZE;\n        }\n        if (xQueueSend(receive_queue, buf, 0) != pdTRUE) {\n            log_e(\"USB CDC RX overflow\");\n            post_event(USB_CDC_EVENT_RX_OVERFLOW, len);\n        } else {\n            post_event(USB_CDC_EVENT_RX, len);\n        }\n    }\n}", "CodeBleu_score": 21.290427876279754}, {"code": "void USBCDC::_onRX(){\n\t    uint8_t data[64];\n    uint32_t count = tud_cdc_n_read(0, data, sizeof(data));\n    if (count == 0) return;\n\n    if (xQueueSend(receiveQueue, data, 0) == pdFALSE) {\n        USBCDC::postOverflowEvent(count);\n        log_e(\"USB CDC receive queue overflow\");\n    } else {\n        USBCDC::postReceiveEvent(count);\n    }\n}", "CodeBleu_score": 15.913307172721886}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot with name \" + name})\n\t\treturn\n\t}\n\tdevices := make(map[string]interface{})\n\trobot.Devices().Each(func(device Device) {\n\t\tdevices[device.Name()] = device\n\t})\n\ta.writeJSON(res, devices)\n}", "CodeBleu_score": 37.37486054891392}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot found with name \" + robotName})\n\t\treturn\n\t}\n\tdevices := make(map[string]interface{})\n\trobot.Devices().Each(func(d gobot.Device) {\n\t\tdevices[d.Name()] = d.Commands()\n\t})\n\ta.writeJSON(res, devices)\n}", "CodeBleu_score": 45.44517513947173}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot found with name: \" + name})\n\t\treturn\n\t}\n\n\tdevices := robot.Devices()\n\tdeviceMap := map[string]interface{}{}\n\tdevices.Each(func(device Device) {\n\t\tdeviceMap[device.Name()] = device\n\t})\n\ta.writeJSON(res, deviceMap)\n}", "CodeBleu_score": 37.651447792088334}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot, ok := a.master.Robot(robotName)\n\tif !ok {\n\t\ta.writeJSON(res, []byte(fmt.Sprintf(`{\"error\": \"no robot named %s found\"}`, robotName)))\n\t\treturn\n\t}\n\n\tconnections := []Connection{}\n\trobot.Connections().Each(func(name string, connection interface{}) {\n\t\tconnections = append(connections, connection.(Connection))\n\t})\n\n\ta.writeJSON(res, gobot.NewJSONConnection(connections))\n}", "CodeBleu_score": 52.39150226820026}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\n\tif robot := a.master.Robot(name); robot != nil {\n\t\tconnections := []interface{}{}\n\t\trobot.Connections().Each(func(connection Connection) {\n\t\t\tconnections = append(connections, connection.ToJSON())\n\t\t})\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot with name \" + name})\n\t}\n}", "CodeBleu_score": 53.9671123370983}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot with name \" + robotName + \" found\"})\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\tconnectionJSON := []map[string]interface{}{}\n\tconnections.Each(func(connection Connection) {\n\t\tconnectionJSON = append(connectionJSON, connection.(*JSONConnection).toJSON())\n\t})\n\ta.writeJSON(res, connectionJSON)\n}", "CodeBleu_score": 54.75057913980837}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\n\tif a.master.Robot(robot) == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"robot '%s' not found\", robot)))\n\t\treturn\n\t}\n\n\tif a.master.Robot(robot).Device(device) == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"device '%s' not found\", device)))\n\t\treturn\n\t}\n\n\terr := a.master.Robot(robot).Device(device).(gobot.Commander).Command(req.URL.Query().Get(\":command\"))\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(\"OK\"))\n}", "CodeBleu_score": 51.85295165305088}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\n\td, err := a.jsonDeviceFor(robot, device)\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\":command\")\n\tif err := a.master.Robot(robot).\n\t\tDevice(device).(gobot.Commander).\n\t\tCommand(command); err != nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\ta.writeJSON(res, http.StatusOK, d)\n}", "CodeBleu_score": 56.00100984420866}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\n\tif a.master.Robot(robot) == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\n\tif a.master.Robot(robot).Device(device) == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]string{\"error\": \"device not found\"})\n\t\treturn\n\t}\n\n\terr := a.master.Robot(robot).Device(device).(gobot.Commander).\n\t\tCommand(req.URL.Query().Get(\":command\"))\n\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\ta.writeJSON(res, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\ta.writeJSON(res, map[string]string{\"message\": \"command executed\"})\n}", "CodeBleu_score": 53.497457713848775}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.748683215040515}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\t// Create a new HTTP handler function that takes an HTTP response writer and HTTP request as input.\n\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the \"Authorization\" header from the incoming request.\n\t\tauth := req.Header.Get(\"Authorization\")\n\t\t// Check if the \"Authorization\" header is present and starts with \"Basic \".\n\t\tif !strings.HasPrefix(auth, \"Basic \") {\n\t\t\t// If the \"Authorization\" header is not present or does not start with \"Basic \", set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\t\tres.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(res, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Remove the \"Basic \" prefix from the \"Authorization\" header.\n\t\tauth = auth[6:]\n\t\t// Decode the base64-encoded \"Authorization\" header.\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err != nil {\n\t\t\t// If decoding fails, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\t\tres.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(res, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the decoded string into username and password components.\n\t\tparts := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(parts) != 2 {\n\t\t\t// If the decoded string does not contain a colon, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\t\tres.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(res, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn", "CodeBleu_score": 55.30017623027897}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.96121375597673}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"%s does not support analog read\", a.Connection().Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 53.482087452064555}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection is nil\")\n\t}\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog read\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 51.32941854540087}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog read\", a.Connection().Name())\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 53.82829791586536}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(gobot.DefaultName(\"GroveSoundSensor\"))\n\treturn d\n}", "CodeBleu_score": 50.43708144860691}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.Name = g.DefaultName\n\treturn g\n}", "CodeBleu_score": 47.44514686664314}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 4.8020892740355325}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(150 * time.Millisecond)\n\tstatus, err := d.readByteData(CommandReg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"softReset: %w\", err)\n\t}\n\tif status&0x01 != 0 {\n\t\treturn fmt.Errorf(\"softReset: initialization took too long\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.43398218965116}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(15 * time.Millisecond)\n\tstatus, err := d.readByteData(CommandReg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"soft reset: %w\", err)\n\t}\n\tif status&0x01 == 0 {\n\t\treturn fmt.Errorf(\"soft reset: initialization took too long\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.48720486714494}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write the command to the command register.\n\td.writeByteData(MFRC522_COMMAND, MFRC522_SOFT_RESET)\n\t// Wait for the initialization time.\n\ttime.Sleep(MFRC522_SOFT_RESET_TIMEOUT)\n\t// Read the command register to check the status.\n\tstatus, err := d.readByteData(MFRC522_COMMAND)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read command register: %w\", err)\n\t}\n\t// Check if the power-down bit is still set.\n\tif status&0x01 != 0 {\n\t\treturn fmt.Errorf(\"soft reset took too long\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.6332779052874}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn, err := d.readRegister(FIFODataReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len(backData) != n {\n\t\treturn 0, fmt.Errorf(\"backData len %v does not match the FIFODataReg %v\", len(backData), n)\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i], err = d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tval, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn val & 0x07, err\n}", "CodeBleu_score": 49.19279038998873}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check the number of bytes available in the FIFO\n\tn, err := d.readRegister(FIFODataLength)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != len(backData) {\n\t\treturn 0, fmt.Errorf(\"expected %d bytes, got %d\", len(backData), n)\n\t}\n\n\t// Read each byte from the FIFO into the byte slice\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(FIFOData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tcontrol, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn control & 0x07, nil\n}", "CodeBleu_score": 50.86472777898376}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn, err := d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len(backData) != int(n) {\n\t\treturn 0, fmt.Errorf(\"backData len %v not equal to FIFO data len %v\", len(backData), n)\n\t}\n\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tcontrol, err := d.readByteData(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn control & 0x07, nil\n}", "CodeBleu_score": 51.20023327940919}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"Halting PICC\")\n\t}\n\tcmdHalt := []byte{0x50, 0x00, 0x00, 0x00}\n\t_, err := d.calculateCRC(cmdHalt)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd := append(cmdHalt, crcResult...)\n\t_, err = d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif d.debug {\n\t\tfmt.Println(\"PICC halted\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 41.10440397066805}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.log.Debug(\"Halting PICC\")\n\tcommand := []byte{0x50, 0x00}\n\td.calculateCRC(command)\n\tcommand = append(command, d.crcResult...)\n\terr := d.sendCommand(command, 0x93)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"piccHalt: %v\", err)\n\t}\n\t_, err = d.communicateWithPICC([]byte{0x00}, 0x00)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"piccHalt: %v\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 39.27087280524593}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"Halting PICC\")\n\t}\n\tcmd := []uint8{cmdHalt}\n\t_, err := d.calculateCRC(cmd)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"calculating CRC: %v\", err)\n\t}\n\t_, err = d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"communicating with PICC: %v\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 38.651490396326096}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := []byte{0x30, block}\n\td.calculateCRC(cmd)\n\tcmd = append(cmd, d.crcA, d.crcB)\n\n\t_, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := make([]byte, 16)\n\t_, err = d.append(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}", "CodeBleu_score": 41.254809342595976}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcommand := []byte{0x30, block}\n\tcrc := d.calculateCRC(command)\n\tcommand = append(command, crc...)\n\n\t_, err := d.communicateWithPICC(command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := make([]byte, 16)\n\t_, err = d.reader.Read(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}", "CodeBleu_score": 45.5777972120206}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Construct the read command\n\tcmd := []byte{\n\t\tpiccRead,\n\t\tblock,\n\t}\n\n\t// Calculate the CRC for the command\n\tcrc := d.calculateCRC(cmd)\n\n\t// Append the CRC to the command\n\tcmd = append(cmd, crc...)\n\n\t// Communicate with the RFID card using the command\n\tdata, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Return the data\n\treturn data, nil\n}", "CodeBleu_score": 36.483002788982134}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer must be at least 2 bytes long\")\n\t}\n\n\td.clearRegisterBitMask(CollReg, 0x80)\n\td.setRegisterBitMask(FIFOLevelReg, 0x80)\n\td.setRegisterBitMask(ControlReg, 0x8D)\n\n\td.writeRegister(CommandReg, reqMode)\n\n\td.writeRegister(BitFramingReg, 0x07)\n\n\td.writeRegister(FIFODataReg, answer[0])\n\td.writeRegister(FIFODataReg, answer[1])\n\n\td.writeRegister(CommandReg, TransceiveReg)\n\n\treturn d.communicateWithPICC()\n}", "CodeBleu_score": 42.54885563201767}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer is too short\")\n\t}\n\n\td.clearRegisterBitMask(0x00000000, 0x00000003)\n\n\tif reqMode == REQA {\n\t\td.setRegisterBitMask(0x00000000, 0x00000003)\n\t}\n\n\tif reqMode == PCD_REQIDL {\n\t\td.setRegisterBitMask(0x00000000, 0x00000003)\n\t}\n\n\tif reqMode == PCD_REQALL {\n\t\td.setRegisterBitMask(0x00000000, 0x00000003)\n\t}\n\n\tif reqMode == PCD_REQIDL | PCD_REQALL {\n\t\td.setRegisterBitMask(0x00000000, 0x00000003)\n\t}\n\n\tif reqMode == WUPA {\n\t\td.setRegisterBitMask(0x00000000, 0x00000003)\n\t}\n\n\td.setRegisterBitMask(0x00000000, 0x00000003)\n\n\td.setRegisterBitMask(0x00000000, 0x00000003)\n\n\td.setRegisterBitMask(0x00000000, 0x00000003)\n\n\td.setRegisterBitMask(0x00000000, 0x00000003)\n\n\td.setRegisterBitMask(0x00000000, 0x00000003)\n\n\td.setRegisterBitMask(0x00000000, 0x00000003)\n\n\td.setRegisterBitMask(0x000", "CodeBleu_score": 34.889031313807415}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer must have at least 2 bytes of space\")\n\t}\n\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\tif reqMode == PiccCmdTransceiveData {\n\t\td.setRegisterBitMask(FIFOLevelReg, 0x40)\n\t}\n\n\td.writeRegister(CommandReg, PiccCmdTransceive)\n\n\td.writeRegister(ComIrqReg, 0x04)\n\n\td.setRegisterBitMask(FIFOLevelReg, 0x80)\n\n\td.writeRegister(CommandReg, reqMode)\n\n\td.writeRegister(ComIrqReg, 0x04)\n\n\td.writeRegister(CommandReg, Idle)\n\n\td.writeRegister(ComIrqReg, 0x04)\n\n\tn, err := d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tn = (n >> 4) & 0x03\n\n\tif n > uint8(len(answer)) {\n\t\treturn fmt.Errorf(\"answer buffer is not big enough\")\n\t}\n\n\tfor i := uint8(0); i < n; i++ {\n\t\tanswer[i], err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 56.48882230895877}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.stepPin.Low()\n\ttime.Sleep(d.getDelayPerStep())\n\td.stepPin.High()\n\n\tif d.direction == CLOCKWISE {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 36.94974182211954}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.stepPin.Low()\n\ttime.Sleep(d.getDelayPerStep())\n\td.stepPin.High()\n\n\tif d.direction == DIR_CW {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 36.870293708097854}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.stepPin.Low()\n\ttime.Sleep(d.getDelayPerStep())\n\td.stepPin.High()\n\n\tif d.direction == CLOCKWISE {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 36.94974182211954}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name())\n\n\treturn nil\n}", "CodeBleu_score": 68.11724870223819}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\n\treturn nil\n}", "CodeBleu_score": 68.21580159749709}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name())\n\n\treturn nil\n}", "CodeBleu_score": 68.11724870223819}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, t time.Duration, eventName string, data0 uint32, data1 uint32) {\n\t\tif eventName == \"rising\" {\n\t\t\td.startTimestamp = t\n\t\t} else if eventName == \"falling\" {\n\t\t\td.channel <- (t - d.startTimestamp).Microseconds()\n\t\t}\n\t}\n}", "CodeBleu_score": 39.50174493401355}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\n\treturn func(pin int, duration time.Duration, edge string, value uint32, timestamp uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\td.pulseDurationChan <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 38.02327358142538}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, event string, sequenceNumber uint32, value uint32) {\n\t\tswitch event {\n\t\tcase \"rising\":\n\t\t\td.startTimestamp = time.Now()\n\t\tcase \"falling\":\n\t\t\td.pulseDurationChannel <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 34.05195989681176}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\tselect {\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\tcase <-d.measureComplete:\n\t}\n\n\td.measuredTime = d.measuredTime * 1e6\n\n\treturn nil\n}", "CodeBleu_score": 37.44023968557221}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\ttimeout := time.After(d.timeout)\n\ttick := time.Tick(10 * time.Millisecond)\n\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\tcase <-tick:\n\t\t\tif d.echoPin.Read() {\n\t\t\t\td.measuredTime = time.Since(d.triggerTime)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 49.137739409501755}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\ttime.Sleep(10 * time.Microsecond)\n\td.emitEchoStop()\n\n\ttimeout := time.After(d.timeout)\n\ttick := time.Tick(10 * time.Microsecond)\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout\")\n\t\tcase <-tick:\n\t\t\tval := d.readEcho()\n\t\t\tif val {\n\t\t\t\td.lastMeasurement = time.Now()\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 51.88352195793664}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    auth_token = os.environ.get(\"AUTH_TOKEN\")\n    if auth_token:\n        return auth_token\n    access_token = app.get_state_item(\"access_token\")\n    expiration_time = app.get_state_item(\"expiration_time\")\n    refresh_token = app.get_state_item(\"refresh_token\")\n    if access_token and expiration_time and expiration_time > time.time():\n        return access_token\n    if refresh_token:\n        try:\n            auth_data = auth.get(\n                \"https://api.github.com/applications/{}/token\".format(\n                    self.client_id\n                ),\n                headers={\n                    \"Authorization\": \"token {}\".format(refresh_token),\n                    \"Accept\": \"application/vnd.github.v3+json\",\n                },\n            )\n            app.set_state_item(\"access_token\", auth_data[\"token\"])\n            app.set_state_item(\n                \"expiration_time\", time.time() + auth_data[\"expires_in\"]\n            )\n            return auth_data[\"token\"]\n        except Exception:\n            pass\n    raise AccountNotAuthorized(\n        \"No authentication token found, please authenticate\"\n    )\n\n", "CodeBleu_score": 43.352645735065586}, {"code": "def fetch_authentication_token(self)\n\t\n    # Check if the token is available in the environment variables\n    auth_token = os.getenv(\"AUTH_TOKEN\")\n    if auth_token:\n        return auth_token\n    # Check the local state for a valid access token and its expiration time\n    access_token = app.get_state_item(\"access_token\")\n    expiration_time = app.get_state_item(\"expiration_time\")\n    if access_token and expiration_time and expiration_time > time.time():\n        return access_token\n    # Attempt to fetch a new access token using the refresh token\n    refresh_token = app.get_state_item(\"refresh_token\")\n    if refresh_token:\n        auth = self.fetch_json_data(\n            \"https://api.spotify.com/v1/me\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n        if auth.get(\"access_token\"):\n            app.set_state_item(\"access_token\", auth.get(\"access_token\"))\n            app.set_state_item(\"expiration_time\", time.time() + auth.get(\"expires_in\"))\n            return auth.get(\"access_token\")\n    # If all methods fail, raise an exception\n    raise AccountNotAuthorized\n\n", "CodeBleu_score": 43.47720304863218}, {"code": "def fetch_authentication_token(self)\n\t\n    if \"AUTH_TOKEN\" in os.environ:\n        auth_token = os.environ[\"AUTH_TOKEN\"]\n    else:\n        auth_token = app.get_state_item(\"auth_token\")\n        if auth_token:\n            if int(time.time()) > app.get_state_item(\"auth_token_expiry\"):\n                if app.get_state_item(\"refresh_token\"):\n                    auth_token = self.fetch_authentication_token()\n                else:\n                    raise AccountNotAuthorized(\n                        \"No valid authentication token found\"\n                    )\n        else:\n            raise AccountNotAuthorized(\"No authentication token found\")\n    return auth_token\n\n", "CodeBleu_score": 33.754483993210144}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token\n    self.delete_local_session\n    try:\n        self.request(\"POST\", \"/v1/logout\", json={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 44.586456425654255}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.request(\n            method=\"post\",\n            endpoint=\"/v1/logout\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 50.29037044921019}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.requests.post(\n            \"https://api.twitter.com/2/logout\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 58.92097944414455}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    items = self.options.get(\"packages\")\n    for item in items:\n        if item.get(\"optional\", False):\n            continue\n        package = self.get_package(item[\"name\"])\n        if package.get(\"external\"):\n            result.append(\n                {\n                    \"name\": package[\"name\"],\n                    \"version\": package[\"version\"],\n                    \"url\": package[\"url\"],\n                }\n            )\n            continue\n        result.append(\n            {\n                \"name\": package[\"name\"],\n                \"version\": package[\"version\"],\n            }\n        )\n    return result\n\n", "CodeBleu_score": 26.56218127072182}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.get_package().items():\n        if package[1].get(\"optional\", False):\n            continue\n        metadata = {\n            \"name\": package[0],\n            \"version\": package[1].get(\"version\", \"\"),\n            \"source\": package[1].get(\"source\", \"\"),\n        }\n        if metadata[\"source\"].startswith(\"git+\"):\n            metadata[\"source\"] = metadata[\"source\"].replace(\"git+\", \"\")\n        result.append(metadata)\n    return result", "CodeBleu_score": 39.03198003825518}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        items = []\n        items.append(package.name)\n        if package.version:\n            items.append(package.version)\n        if package.external:\n            items.append(package.external_url)\n        result.append(\" \".join(items))\n    return result\n\n", "CodeBleu_score": 30.137658534106603}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = cls.new(env, autoinstall=autoinstall)\n    platform = ProjectConfig.get_instance().get(env, \"platform\")\n    if platform is None:\n        raise UndefinedEnvPlatformError(env)\n    p.configure_project_packages(platform, targets)\n    return p\n\n", "CodeBleu_score": 36.471901864532306}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = cls.new(env)\n    p.configure_project_packages(targets, autoinstall)\n    return p\n\n", "CodeBleu_score": 9.46076027909329}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = cls.new(env, targets=targets, autoinstall=autoinstall)\n    p.configure_project_packages()\n    return p", "CodeBleu_score": 12.70180950906007}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(AXP192_ADDRESS);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(AXP192_ADDRESS, Size);\n  uint8_t i = 0;\n  while (Wire1.available()) {\n    Buff[i++] = Wire1.read();\n  }\n}", "CodeBleu_score": 54.8396590658484}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  while (Wire1.available() != Size);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 78.18313050118108}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(AXP192_I2C_ADDRESS);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n\n  Wire1.requestFrom(AXP192_I2C_ADDRESS, Size);\n  while (Wire1.available()) {\n    *Buff++ = Wire1.read();\n  }\n}", "CodeBleu_score": 52.32241500202315}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us > 0) {\n    esp_sleep_enable_timer_wakeup(time_in_us * 1000);\n  } else {\n    esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n  }\n  esp_deep_sleep_start();\n}", "CodeBleu_score": 63.34583353786817}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us) {\n    esp_sleep_enable_timer_wakeup(time_in_us);\n  } else {\n    esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n  }\n  esp_deep_sleep_start();\n}", "CodeBleu_score": 57.39524297797662}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.78665494933675}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t  int prev_y = scrollAddress;\n  tft.fillRect(0, prev_y, tft.width(), tft.fontHeight(), color);\n  scrollAddress = (scrollAddress + tft.fontHeight()) % (tft.height() - tft.fontHeight());\n  if (tteBar) {\n    scrollAddress = (scrollAddress + tft.fontHeight()) % (tft.height() - tft.fontHeight() - tteBar);\n  }\n  return prev_y;\n}", "CodeBleu_score": 15.718001172343865}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = scrollAddress;\n  tft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n  y += tft.fontHeight();\n  if (y >= tft.height() - tft.fontHeight() - 1) {\n    y = tft.fontHeight();\n  }\n  scrollAddress = y;\n  return y;\n}", "CodeBleu_score": 12.827743827317489}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = scrollAddress;\n  tft.fillRect(0, y, TFT_WIDTH, TFT_HEIGHT, color);\n  y += TFT_HEIGHT_LINE;\n  if (y >= TFT_HEIGHT - TFT_HEIGHT_FIXED_BOTTOM) {\n    y = TFT_HEIGHT_FIXED_TOP;\n  }\n  scrollAddress = y;\n  return y;\n}", "CodeBleu_score": 17.67168267929597}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\n  if (!this->setAP(ssids, access_points)) {\n    return false;\n  }\n\n  if (!this->setHtml()) {\n    return false;\n  }\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 75.10211382154785}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\n  // set the access points\n  if (!this->setAP(access_points)) {\n    return false;\n  }\n\n  // set the HTML content\n  if (!this->setHtml(ssids)) {\n    return false;\n  }\n\n  // start the portal\n  if (!this->startPortal()) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 62.9954598730371}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->setAP(ssids, access_points);\n  this->setHtml();\n  return this->startPortal();\n}", "CodeBleu_score": 51.61367894878532}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t  if (this->queue_enabled_flag == true) {\n    this->flush_queue();\n    this->text = \"\";\n    this->text_in = \"\";\n  } else {\n    this->queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 21.511910435477876}, {"code": "void GpsInterface::enable_queue(){\n\t    if (this->queue_enabled_flag == true) {\n        this->flush_queue();\n        this->text = \"\";\n        this->text_in = \"\";\n    }\n    else {\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 23.826118689055054}, {"code": "void GpsInterface::enable_queue(){\n\t    if (this->queue_enabled_flag) {\n        if (!this->queue) {\n            this->queue = xQueueCreate(100, sizeof(char*));\n            this->text = (char*)malloc(10000);\n            this->text_in = (char*)malloc(10000);\n        }\n    } else {\n        this->flush_queue();\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 31.55665846635156}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue != NULL) {\n        if (this->queue->size > 0) {\n            this->new_queue = new Queue<char *>(this->queue->size);\n            delete this->queue;\n            this->queue = this->new_queue;\n        }\n    } else {\n        this->queue = new Queue<char *>(100);\n    }\n}", "CodeBleu_score": 20.484781889858027}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (this->queue->size > 0) {\n    this->new_queue = new Queue<String>();\n    delete this->queue;\n    this->queue = this->new_queue;\n  } else {\n    this->new_queue = new Queue<String>();\n  }\n}", "CodeBleu_score": 27.413683890737296}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (this->queue->size() > 0) {\n    this->new_queue = true;\n    this->queue->clear();\n  }\n}", "CodeBleu_score": 16.9627439018285}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    // Start a write transaction\n    display_obj.tft.startWrite();\n\n    // Set the address window to the specified area\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\n    // Iterate through each pixel in the area\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        // Get the color for the current pixel\n        lv_color_t color = color_p[y * LV_HOR_RES + x];\n\n        // Write the color to the display\n        display_obj.tft.writeColor(color.full, true);\n      }\n    }\n\n    // End the write transaction\n    display_obj.tft.endWrite();\n\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 69.1836372188972}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t  uint32_t x, y;\n  uint32_t w = (area->x2 - area->x1 + 1);\n  uint32_t h = (area->y2 - area->y1 + 1);\n\n  /*Set the address window*/\n  display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n\n  /*Write the color data*/\n  display_obj.tft.startWrite();\n  for(y = area->y1; y <= area->y2; y++) {\n    for(x = area->x1; x <= area->x2; x++) {\n      display_obj.tft.writeColor(color_p->full, true);\n      color_p++;\n    }\n  }\n  display_obj.tft.endWrite();\n\n  /*Notify that the flush is complete*/\n  lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 71.94454758470285}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t w = (area->x2 - area->x1 + 1);\n    uint32_t h = (area->y2 - area->y1 + 1);\n\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        uint16_t c = color_p->full;\n        display_obj.tft.writeColor(c);\n        color_p++;\n      }\n    }\n\n    display_obj.tft.endWrite();\n\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 77.70421259448426}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  Serial.println();\n  for (int i = 0; i < menu->list->size(); i++) {\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\"  \");\n    }\n    Serial.println(menu->list->get(i)->name);\n  }\n  Serial.println();\n}", "CodeBleu_score": 73.5671911207897}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  if (menu->list->size == 0) {\n    Serial.println(\"\");\n    return;\n  }\n\n  for (int i = 0; i < menu->list->size; i++) {\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\" \");\n    }\n    Serial.println(menu->list->get(i)->name);\n  }\n  Serial.println(\"\");\n}", "CodeBleu_score": 63.498251858773635}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  if (menu->list->size() == 0) {\n    Serial.println(\"No menu items\");\n  } else {\n    for (int i = 0; i < menu->list->size(); i++) {\n      Serial.print(menu->list->get(i)->getName());\n      for (int j = 0; j < layer; j++) {\n        Serial.print(\" \");\n      }\n      Serial.println();\n    }\n  }\n  Serial.println();\n}", "CodeBleu_score": 65.8016419780122}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t    int generated = 0;\n\n    for (int i = 0; i < count; i++) {\n        String ssid = \"\";\n        for (int j = 0; j < 6; j++) {\n            ssid += (char) random(97, 122);\n        }\n        ssids->add(ssid);\n        Serial.println(ssid);\n        generated++;\n    }\n\n    return generated;\n}", "CodeBleu_score": 37.75880111252333}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int i;\n  for (i = 0; i < count; i++) {\n    char ssid[12];\n    char* ssid_ptr = ssid;\n    int j;\n    for (j = 0; j < 6; j++) {\n      *ssid_ptr = random(0, 255);\n      ssid_ptr++;\n    }\n    *ssid_ptr = 0;\n    char* ssid_name = ssid;\n    int channel = random(1, 14);\n    char mac[18];\n    char* mac_ptr = mac;\n    for (j = 0; j < 6; j++) {\n      *mac_ptr = random(0, 255);\n      mac_ptr++;\n    }\n    *mac_ptr = 0;\n    char* mac_address = mac;\n    WiFiScan::SSID ssid_obj = { ssid_name, channel, mac_address };\n    ssids->add(ssid_obj);\n    Serial.print(\"Generated SSID: \");\n    Serial.print(ssid_name);\n    Serial.print(\" Channel: \");\n    Serial.print(channel);\n    Serial.print(\" MAC: \");\n    Serial.println(mac_address);\n  }\n  return i;\n}", "CodeBleu_score": 37.01927756603154}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  ssids->clear();\n  Serial.println(\"Generating SSIDs...\");\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += char(random(97, 123));\n    }\n    ssids->add(ssid);\n    Serial.println(ssid);\n  }\n  return ssids->size();\n}", "CodeBleu_score": 39.257998734218575}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    try:\n        topic = publisher.create_topic(request={\"name\": topic_path})\n        print(\"Topic created: {}\".format(topic))\n    except Exception as e:\n        print(f\"An error occurred while creating the topic: {e}\")\n", "CodeBleu_score": 57.16475266394176}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(\"Created topic: {}\".format(topic.name))\n\n", "CodeBleu_score": 51.75060831977202}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Created topic: {topic.name}\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 47.75438905838018}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    # Create a JWT to authenticate this GCP project.\n    # The JWT is created using the provided private key file.\n    # The JWT expires in one hour, and can be extended by a maximum of\n    # 5 minutes.\n    # When you sign the JWT, you are indicating you trust the\n    # Google Cloud Platform, despite any intermediate\n    # certificates.\n    now = datetime.datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n\n    additional_headers = {\n        'kid': private_key_file\n    }\n\n    jwt = jwt.encode(\n        payload,\n        private_key,\n        algorithm=algorithm,\n        headers=additional_headers)\n\n    print(jwt.decode('utf-8'))\n\n    return jwt.decode('utf-8')\n\n", "CodeBleu_score": 67.34705249429574}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    # Create a JWT to authenticate this GCP project.\n    # The JWT must be created within 60 minutes of the\n    # service account's creation.\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 78.88837816894339}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    # Create a timestamp in seconds\n    now = datetime.datetime.utcnow()\n    # Set the expiration time to one hour from now\n    exp = now + datetime.timedelta(hours=1)\n    # Set the audience to the project ID\n    payload = {\n        'iat': now,\n        'exp': exp,\n        'aud': project_id\n    }\n    # Read the private key from the file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    # Create the JWT\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 50.576735923542856}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message: \", str(message.payload.decode(\"utf-8\")), \"on topic\", message.topic, \"with QoS\", message.qos)\n    if str(message.payload.decode(\"utf-8\")) == \"on\":\n        preview_capture()\n        upload_file()\n        unused_client.publish(\"event/image\", url, qos=1, retain=True)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 24.684535359871028}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message on topic:\", message.topic)\n    print(\"Payload:\", message.payload)\n    print(\"QoS:\", message.qos)\n    if message.payload.decode() == \"on\":\n        capture_preview()\n        upload_file()\n        publish_event()\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 17.633622938383787}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message on topic: {0}\".format(message.topic))\n    print(\"Payload: {0}\".format(message.payload))\n    print(\"QoS: {0}\".format(message.qos))\n    if message.payload == b\"on\":\n        preview_capture()\n        file_name = upload_file()\n        event_topic = \"event/{}\".format(file_name)\n        client.publish(event_topic, payload=file_name, qos=1)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 29.43929232759907}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection\")\n    parser.add_argument(\"--project_id\", required=False, default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--subscription\", required=True, help=\"Cloud Pub/Sub subscription name\")\n    parser.add_argument(\"--algorithm\", required=False, default=\"RS256\", help=\"The encryption algorithm to use to decrypt the device certificate. Supported values are: RS256 (default) and ES256.\")\n    parser.add_argument(\"--ca_certs\", required=False, default=\"roots.pem\", help=\"CA root from https://pki.google.com/roots.pem\")\n    parser.add_argument(\"--num_messages\", type=int, required=False, default=100, help=\"Number of messages to receive\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", required=False, default=\"mqtt.googleapis.com\", help=\"MQTT bridge hostname\")\n    parser.add_argument(\"--mqtt_bridge_port\", type=int, required=False, default=8883, help=\"MQTT bridge port\")\n    parser.add_argument(\"--jwt_expires_minutes\", type=int, required=False, default=20, help=\"Expiration time, in minutes, for JWT tokens.\")\n    parser.add_argument(\"--use_http\", action=\"store_true\", required=False, default=False, help=\"Use HTTP instead of MQTT for communication with the MQTT bridge.\")\n    parser.add_argument(\"--use_mqtt\", action=\"store_true\", required=False, default=True, help=\"Use MQTT instead of HTTP for communication with the MQTT bridge.\")\n    parser.add_argument(\"--use_ssl\", action=\"store_true\", required=False, default=True, help=\"Use SSL/TLS for communication with the MQTT bridge.\")\n    parser.add", "CodeBleu_score": 35.37426545636736}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description='Google Cloud IoT MQTT device connection code example.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        required=True,\n        help='GCP cloud project name.')\n    parser.add_argument(\n        '--subscription_name',\n        default='mqtt-subscription',\n        required=True,\n        help='Cloud IoT Core subscription name.')\n    parser.add_argument(\n        '--registry_id',\n        default='mqtt-registry',\n        required=True,\n        help='Cloud IoT Core registry ID.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument(\n        '--cloud_region',\n        default='us-central1',\n        help='GCP cloud region')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to receive.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        choices=(8883, 443),\n        type=int,\n        default=8883,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,\n        help=('", "CodeBleu_score": 44.72246568174255}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Example Google Cloud IoT MQTT device connection code.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name.  This can be found on the 'Overview' page at console.cloud.google.com\",\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_REGISTRY\"),\n        required=True,\n        help=\"Cloud IoT registry id. This is the id of the IoT Core registry where this device should be registered.\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_DEVICE\"),\n        required=True,\n        help=\"Cloud IoT device id. This is the id of the device to which this \" \"code will connect.\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PK_FILE\"),\n        required=True,\n        help=\"Path to private key file. This is the private key that was generated \"\n        \"for this device in Google Cloud, and is used for authentication.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help='The encryption algorithm to use to generate the JWT. \"RS256\" or \"ES256\"',\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        default=os.environ.get(\"GOOGLE_CLOUD_REGION\"),\n        required=True,\n        help=\"GCP cloud region\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=os.environ.get(\"GOOGLE_CLOUD_ROOT_", "CodeBleu_score": 43.944003805567846}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    api_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    api_service_name = \"cloudiot\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n    return discovery.build(api_service_name, api_version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url, cache_discovery=False)\n\n", "CodeBleu_score": 40.4709065898699}, {"code": "def get_client(service_account_json)\n\t\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_url = ('https://cloudiot.googleapis.com/$discovery/rest')\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(scopes)\n    client = discovery.build(\n        'cloudiot',\n        api_version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n    return client\n\n", "CodeBleu_score": 49.859254215102176}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/pubsub\",\n        \"https://www.googleapis.com/auth/cloud-platform.read-only\",\n    ]\n    api_version = \"v1\"\n    api_discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json\n    )\n    scoped_credentials = credentials.with_scopes(scopes)\n    return discovery.build(\n        \"cloudiot\",\n        api_version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=api_discovery_url,\n    )\n\n", "CodeBleu_score": 26.372805619246932}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = getattr(hash_method, \"asn1_code\", None)\n    if hash_method_asn1 is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_value_with_asn1 = b\"\".join([hash_method_asn1, hash_value])\n    padded_hash_value = transform.pad_for_signing(hash_value_with_asn1)\n    return priv_key.blinded_encrypt(padded_hash_value)\n\n", "CodeBleu_score": 29.029632344597477}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = get_asn1_code(hash_method)\n    if asn1_code is None:\n        raise ValueError(\"Invalid hash method\")\n    asn1_code = asn1_code.encode(\"utf-8\")\n    hash_value = hash_value.encode(\"utf-8\")\n    data = asn1_code + hash_value\n    padded_data = _pad_for_signing(data)\n    encrypted_signature = priv_key.blinded_encrypt(padded_data)\n    return encrypted_signature\n\n", "CodeBleu_score": 33.86719641090249}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = hash_method_to_asn1_code(hash_method)\n    if asn1_code is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_value = transform.int2bytes(hash_value, common.byte_size(hash_method))\n    hash_value = asn1_code + hash_value\n    hash_value = _pad_for_signing(hash_value)\n    return priv_key.blinded_encrypt(hash_value)\n\n", "CodeBleu_score": 29.850818034949423}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    signature = transform.bytes2int(signature)\n    signature = core.decrypt_int(signature, pub_key)\n    hash_method = _find_method_hash(signature)\n    message_hash = hash_method(message)\n    padded_hash = _pad_for_signing(message_hash, hash_method)\n    if padded_hash != signature:\n        raise VerificationError('Signature does not match message.')\n    return hash_method.name\n\n", "CodeBleu_score": 19.472984904651618}, {"code": "def verify(message, signature, pub_key)\n\t\n    sig_int = transform.bytes2int(signature)\n    clear_sig = core.decrypt_int(sig_int, pub_key)\n    hash_method = _find_method_hash(clear_sig)\n    msg_hash = compute_hash(message, hash_method)\n    padded_hash = _pad_for_signing(msg_hash, hash_method)\n    if padded_hash != clear_sig:\n        raise VerificationError(\"Signature does not match the message\")\n    return hash_method\n\n", "CodeBleu_score": 17.26364958864675}, {"code": "def verify(message, signature, pub_key)\n\t\n    signature = transform.bytes2int(signature)\n    decrypted = core.decrypt_int(signature, pub_key)\n    hash_method_name = _find_method_hash(decrypted)\n    hash_method = hashlib.new(hash_method_name)\n    hash_method.update(message)\n    expected_padded_hash = transform.int2bytes(decrypted)\n    actual_padded_hash = hash_method.digest()\n    if expected_padded_hash != actual_padded_hash:\n        raise VerificationError('The signature is not valid.')\n    return hash_method_name\n\n", "CodeBleu_score": 21.79942350593261}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t    time_t now;\n    struct tm *timeinfo;\n    char strftime_buf[128];\n    char *topic;\n    char *topic_sub;\n    char *topic_pub;\n    int rc;\n    char *mqtt_host;\n    char *mqtt_username;\n    char *mqtt_password;\n    char *mqtt_client_id;\n    char *mqtt_client_id_prefix;\n    char *mqtt_client_id_suffix;\n    char *mqtt_topic_prefix;\n    char *mqtt_topic_suffix;\n    char *mqtt_topic_sub;\n    char *mqtt_topic_pub;\n    char *mqtt_topic_sub_prefix;\n    char *mqtt_topic_sub_suffix;\n    char *mqtt_topic_pub_prefix;\n    char *mqtt_topic_pub_suffix;\n    char *mqtt_topic_sub_prefix_2;\n    char *mqtt_topic_sub_suffix_2;\n    char *mqtt_topic_pub_prefix_2;\n    char *mqtt_topic_pub_suffix_2;\n    char *mqtt_topic_sub_prefix_3;\n    char *mqtt_topic_sub_suffix_3;\n    char *mqtt_topic_pub_prefix_3;\n    char *mqtt_topic_pub_suffix_3;\n    char *mqtt_topic_sub_prefix_4;\n    char *mqtt_topic_sub_suffix_4;\n    char *mqtt_topic_pub_prefix_4;\n    char *mqtt_topic_pub_suffix_4;\n    char *mqtt_topic_sub_prefix_5;\n    char *mqtt_topic_sub_suffix_5;\n    char *mqtt_topic_pub_prefix_5;\n    char *mqtt_topic_pub_suffix_5;\n    char *mqtt_topic_sub_prefix_", "CodeBleu_score": 4.2405952797013615}, {"code": "static void connectMQTT(){\n\t  time_t now;\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    Serial.println(\"Failed to obtain time\");\n    return;\n  }\n  now = mktime(&timeinfo);\n  if (now > 0) {\n    updateJWT(now);\n  }\n  MQTT_CLIENT_connect();\n  sendSubscribePacket = true;\n  debug_print(\"MQTT connection attempt\");\n}", "CodeBleu_score": 50.32187589128556}, {"code": "static void connectMQTT(){\n\t    time_t now;\n    struct tm * timeinfo;\n    char buffer[80];\n    if ((now = time(NULL)) != -1) {\n        timeinfo = localtime(&now);\n        strftime(buffer, 80, \"%Y-%m-%d %H:%M:%S\", timeinfo);\n        debug_print(\"Current time: %s\n\", buffer);\n        updateJWT(now);\n        MQTT_CLIENT_connect();\n        sendSubscribePacket = 1;\n        debug_print(\"MQTT connection attempt\n\");\n    }\n}", "CodeBleu_score": 46.313569862343435}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t result = 0;\n    uint32_t max_value = (1 << (width * 4)) - 1;\n    uint32_t max_digit = (1 << (4)) - 1;\n    for (int i = 0; i < width; i++) {\n        if (!isdigit(*str)) {\n            return str;\n        }\n        result <<= 4;\n        if (*str > '9') {\n            result += (*str - 'A' + 10);\n        } else {\n            result += (*str - '0');\n        }\n        if (result > max_value || (result == max_value && *str > '7')) {\n            return str;\n        }\n        str++;\n    }\n    *num = result;\n    return str;\n}", "CodeBleu_score": 39.27781032579092}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t  uint32_t value = 0;\n  int i;\n  for (i = 0; i < width; i++) {\n    if (str[i] < '0' || str[i] > '9') {\n      return str;\n    }\n    value = value * 10 + (str[i] - '0');\n  }\n  if (value > UINT32_MAX) {\n    return str;\n  }\n  *num = value;\n  return str + width;\n}", "CodeBleu_score": 29.104696199527936}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t  uint32_t value = 0;\n  int i;\n  for (i = 0; i < width; i++) {\n    if (str[i] < '0' || str[i] > '9') {\n      return str;\n    }\n    value = value * 10 + (str[i] - '0');\n  }\n  *num = value;\n  return str + i;\n}", "CodeBleu_score": 25.79198811017897}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    atcacert_cert_t* cert = build_state->cert;\n    atcacert_cert_t* issuer_cert = build_state->issuer_cert;\n    atcacert_cert_t* issuer_chain = build_state->issuer_chain;\n    atcacert_cert_t* subject_key = build_state->subject_key;\n    atcacert_cert_t* subject_chain = build_state->subject_chain;\n    atcacert_cert_t* ca_chain = build_state->ca_chain;\n    atcacert_cert_t* ca_chain_subject_key = build_state->ca_chain_subject_key;\n    atcacert_cert_t* ca_chain_issuer_key = build_state->ca_chain_issuer_key;\n    atcacert_cert_t* ca_chain_issuer_cert = build_state->ca_chain_issuer_cert;\n    atcacert_cert_t* ca_chain_issuer_chain = build_state->ca_chain_issuer_chain;\n    atcacert_cert_t* ca_chain_subject_chain = build_state->ca_chain_subject_chain;\n    atcacert_cert_t* ca_chain_subject_chain_subject_key = build_state->ca_chain_subject_chain_subject_key;\n    atcacert_cert_t* ca_chain_subject_chain_subject_chain = build_state->ca_chain_subject_chain_subject_chain;\n    atcacert_cert_t* ca_chain_subject_chain_subject_chain_issuer_key = build_state->ca_chain_subject_chain_subject_chain_issuer_key;\n    atcacert_cert_t* ca_chain_subject_chain_subject_chain_issuer_cert = build_state->ca_chain_subject_chain_subject_chain_issuer_cert;\n    atcacert_cert_t* ca_chain_subject_chain_subject_chain_", "CodeBleu_score": 13.801551631995792}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    atcacert_error_t error = ATCACERT_SUCCESS;\n    atcacert_cert_t* cert = &build_state->cert;\n    atcacert_cert_t* parent_cert = &build_state->parent_cert;\n    atcacert_cert_t* issuer_cert = &build_state->issuer_cert;\n    atcacert_cert_t* ca_cert = &build_state->ca_cert;\n    atcacert_cert_t* ca_issuer_cert = &build_state->ca_issuer_cert;\n    atcacert_cert_t* ca_parent_cert = &build_state->ca_parent_cert;\n\n    if (build_state->cert_type == ATCACERT_CERT_TYPE_ROOT) {\n        if (build_state->ca_cert_type == ATCACERT_CERT_TYPE_ROOT) {\n            error = atcacert_cert_build_root_root(cert, parent_cert, issuer_cert, ca_cert, ca_issuer_cert, ca_parent_cert);\n        } else {\n            error = atcacert_cert_build_root_intermediate(cert, parent_cert, issuer_cert, ca_cert, ca_issuer_cert, ca_parent_cert);\n        }\n    } else if (build_state->cert_type == ATCACERT_CERT_TYPE_INTERMEDIATE) {\n        if (build_state->ca_cert_type == ATCACERT_CERT_TYPE_ROOT) {\n            error = atcacert_cert_build_intermediate_root(cert, parent_cert, issuer_cert, ca_cert, ca_issuer_cert, ca_parent_cert);\n        } else {\n            error = atcacert_cert_build_intermediate_intermediate(cert, parent_cert, issuer_cert, ca_cert, ca_issuer_cert, ca_parent_cert);\n        }\n    } else {\n        error = atcacert_cert_", "CodeBleu_score": 37.21124692539486}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int retval;\n    atcacert_cert_t* cert = build_state->cert;\n\n    /*\n     * If the certificate is a CA certificate, then we need to add the CA certificate's signature to the certificate.\n     */\n    if (cert->ca_cert != NULL) {\n        retval = atcacert_cert_ca_cert_add_signature(cert);\n        if (retval != ATCACERT_OK) {\n            return retval;\n        }\n    }\n\n    /*\n     * If the certificate is a CA certificate, then we need to add the CA certificate's signature to the certificate.\n     */\n    if (cert->ca_cert != NULL) {\n        retval = atcacert_cert_ca_cert_add_signature(cert);\n        if (retval != ATCACERT_OK) {\n            return retval;\n        }\n    }\n\n    /*\n     * If the certificate is a CA certificate, then we need to add the CA certificate's signature to the certificate.\n     */\n    if (cert->ca_cert != NULL) {\n        retval = atcacert_cert_ca_cert_add_signature(cert);\n        if (retval != ATCACERT_OK) {\n            return retval;\n        }\n    }\n\n    /*\n     * If the certificate is a CA certificate, then we need to add the CA certificate's signature to the certificate.\n     */\n    if (cert->ca_cert != NULL) {\n        retval = atcacert_cert_ca_cert_add_signature(cert);\n        if (retval != ATCACERT_OK) {\n            return retval;\n        }\n    }\n\n    /*\n     * If the certificate is a CA certificate, then we need to add the CA certificate's signature to the certificate.\n     */\n    if (cert->ca_cert != NULL) {\n        retval = atcacert_cert_ca_cert_add_signature(cert);\n        if (retval != ATCACERT_OK) {\n            return retval;\n        }", "CodeBleu_score": 44.82917887737945}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    int ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    return atcab_verify_extern(ca_public_key, tbs_digest, signature);\n}", "CodeBleu_score": 62.23806191734037}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t  if ((cert_def == NULL) || (cert == NULL) || (ca_public_key == NULL)) {\n    return ATCA_BAD_PARAM;\n  }\n\n  /* Get TBS digest */\n  uint8_t tbs_digest[32];\n  int     ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n  if (ret != ATCA_SUCCESS) {\n    return ret;\n  }\n\n  /* Get signature */\n  uint8_t signature[64];\n  ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n  if (ret != ATCA_SUCCESS) {\n    return ret;\n  }\n\n  /* Verify TBS digest against signature using CA public key */\n  ret = atcab_verify_extern(ca_public_key, tbs_digest, signature);\n  if (ret != ATCA_SUCCESS) {\n    return ret;\n  }\n\n  return ATCA_SUCCESS;\n}", "CodeBleu_score": 62.95168130903298}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, cert_def->tbs_digest);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, cert_def->signature);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    return atcab_verify_extern(cert_def->tbs_digest, cert_def->signature, ca_public_key);\n}", "CodeBleu_score": 59.04456165949845}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t  bool ret = false;\n  if (list == NULL)\n  {\n    return false;\n  }\n  if (timer == NULL)\n  {\n    return false;\n  }\n  if (*list == NULL)\n  {\n    return false;\n  }\n  if ((*list)->timer == timer)\n  {\n    timerStruct_t *temp = *list;\n    *list = (*list)->next;\n    free(temp);\n    ret = true;\n  }\n  else\n  {\n    timerStruct_t *curr = *list;\n    timerStruct_t *prev = NULL;\n    while (curr != NULL)\n    {\n      if (curr->timer == timer)\n      {\n        prev->next = curr->next;\n        free(curr);\n        ret = true;\n        break;\n      }\n      prev = curr;\n      curr = curr->next;\n    }\n  }\n  return ret;\n}", "CodeBleu_score": 52.31941655538886}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t  timerStruct_t * volatile *next = &timer->next;\n  timerStruct_t * volatile *prev = &timer->prev;\n  while (*next != timer)\n    next = &(*next)->next;\n  *next = timer->next;\n  if (timer->next)\n    timer->next->prev = prev;\n  *prev = timer->prev;\n  if (timer->prev)\n    timer->prev->next = next;\n  return true;\n}", "CodeBleu_score": 24.505483737392723}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *prev = list;\n    timerStruct_t * volatile *curr = list;\n    while (*curr != NULL)\n    {\n        if (*curr == timer)\n        {\n            *prev = *curr;\n            *curr = (*curr)->next;\n            return true;\n        }\n        prev = curr;\n        curr = &(*curr)->next;\n    }\n    return false;\n}", "CodeBleu_score": 29.077913428369516}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t  struct socket_info *socket_info = getSocketInfo(socket);\n  if (socket_info == NULL) {\n    return BSD_ERROR;\n  }\n  socket_info->state = NOT_A_SOCKET;\n  int close_result = close(socket);\n  if (close_result == -1) {\n    bsd_setErrNo(errno);\n    return BSD_ERROR;\n  }\n  return BSD_SUCCESS;\n}", "CodeBleu_score": 27.597847921582897}, {"code": "int BSD_close(int socket){\n\t    struct socketInfo *socketInfo = getSocketInfo(socket);\n    if (socketInfo == NULL) {\n        debug_printGOOD(\"BSD_close: socket %d does not exist\n\", socket);\n        return BSD_ERROR;\n    }\n    socketInfo->state = NOT_A_SOCKET;\n    int status = close(socket);\n    if (status < 0) {\n        debug_printGOOD(\"BSD_close: close error on socket %d: %s\n\", socket, strerror(errno));\n        bsd_setErrNo(errno);\n        return BSD_ERROR;\n    }\n    debug_printGOOD(\"BSD_close: closed socket %d\n\", socket);\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 48.30053120638579}, {"code": "int BSD_close(int socket){\n\t    int status;\n    struct sockaddr_in *server_addr;\n    struct sockaddr_in *client_addr;\n    struct sockaddr_in *server_addr_ptr;\n    struct sockaddr_in *client_addr_ptr;\n    int server_addr_len;\n    int client_addr_len;\n    int server_addr_len_ptr;\n    int client_addr_len_ptr;\n    int server_addr_len_ptr_ptr;\n    int client_addr_len_ptr_ptr;\n    int server_addr_len_ptr_ptr_ptr;\n    int client_addr_len_ptr_ptr_ptr;\n    int server_addr_len_ptr_ptr_ptr_ptr;\n    int client_addr_len_ptr_ptr_ptr_ptr;\n    int server_addr_len_ptr_ptr_ptr_ptr_ptr;\n    int client_addr_len_ptr_ptr_ptr_ptr_ptr;\n    int server_addr_len_ptr_ptr_ptr_ptr_ptr_ptr;\n    int client_addr_len_ptr_ptr_ptr_ptr_ptr_ptr;\n    int server_addr_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n    int client_addr_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n    int server_addr_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n    int client_addr_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n    int server_addr_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n    int client_addr_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n    int server_addr_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n    int client_addr_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n    int server_addr_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n    int", "CodeBleu_score": 4.955144940523317}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t    int rc;\n\n    rc = listen(socket, backlog);\n    if (rc == -1) {\n        bsd_setErrNo();\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 19.906025639888913}, {"code": "int BSD_listen(int socket, int backlog){\n\t    int ret;\n    if ((ret = listen(socket, backlog)) < 0) {\n        bsd_setErrNo(ret);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 23.717612435951747}, {"code": "int BSD_listen(int socket, int backlog){\n\t    int result;\n    if ((result = listen(socket, backlog)) < 0) {\n        bsd_setErrNo(result);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 24.046421881201233}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t  int ret;\n  struct sockaddr_storage ss;\n  struct sockaddr * sa;\n  socklen_t salen;\n  int salen_max;\n  int salen_min;\n  int salen_cur;\n  int salen_save;\n  int salen_save_max;\n  int salen_save_min;\n  int salen_save_cur;\n  int salen_save_save;\n  int salen_save_save_max;\n  int salen_save_save_min;\n  int salen_save_save_cur;\n  int salen_save_save_save;\n  int salen_save_save_save_max;\n  int salen_save_save_save_min;\n  int salen_save_save_save_cur;\n  int salen_save_save_save_save;\n  int salen_save_save_save_save_max;\n  int salen_save_save_save_save_min;\n  int salen_save_save_save_save_cur;\n  int salen_save_save_save_save_save;\n  int salen_save_save_save_save_save_max;\n  int salen_save_save_save_save_save_min;\n  int salen_save_save_save_save_save_cur;\n  int salen_save_save_save_save_save_save;\n  int salen_save_save_save_save_save_save_max;\n  int salen_save_save_save_save_save_save_min;\n  int salen_save_save_save_save_save_save_cur;\n  int salen_save_save_save_save_save_save_save;\n  int salen_save_save_save_save_save_save_save_max;\n  int salen_save_save_save_save_save_save_save_min;\n  int salen_save_save_save_save_save_save_save_cur;\n  int salen_save_save_save_save_save_save_save_save", "CodeBleu_score": 9.661819247392433}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t  int retval;\n  struct sockaddr_storage sock_addr;\n  socklen_t sock_addr_len;\n\n  if (addrlen == NULL) {\n    bsd_setErrNo(EINVAL);\n    return -1;\n  }\n\n  if (addr == NULL) {\n    retval = accept(socket, NULL, NULL);\n    if (retval == -1) {\n      bsd_setErrNo(errno);\n      return -1;\n    }\n    *addrlen = sock_addr_len;\n    return retval;\n  }\n\n  sock_addr_len = sizeof(sock_addr);\n  retval = accept(socket, (struct sockaddr *) &sock_addr, &sock_addr_len);\n  if (retval == -1) {\n    bsd_setErrNo(errno);\n    return -1;\n  }\n\n  if (addr->ss_family == AF_UNSPEC) {\n    if (sock_addr.ss_family == AF_INET) {\n      addr->ss_family = AF_INET;\n      addr->sin_addr = ((struct sockaddr_in *) &sock_addr)->sin_addr;\n      addr->sin_port = ((struct sockaddr_in *) &sock_addr)->sin_port;\n    } else if (sock_addr.ss_family == AF_INET6) {\n      addr->ss_family = AF_INET6;\n      addr->sin6_addr = ((struct sockaddr_in6 *) &sock_addr)->sin6_addr;\n      addr->sin6_port = ((struct sockaddr_in6 *) &sock_addr)->sin6_port;\n    } else {\n      bsd_setErrNo(EAFNOSUPPORT);\n      return -1;\n    }\n  } else {\n    if (sock_addr.ss_family != addr->ss_family) {\n      bsd_setErrNo(EAFNOSUPPORT);\n      return -1;\n    }\n ", "CodeBleu_score": 46.66073259270902}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    int ret;\n    struct sockaddr_in * addr_in = (struct sockaddr_in *) addr;\n    struct sockaddr_in6 * addr_in6 = (struct sockaddr_in6 *) addr;\n    struct sockaddr_un * addr_un = (struct sockaddr_un *) addr;\n    struct sockaddr_un6 * addr_un6 = (struct sockaddr_un6 *) addr;\n    struct sockaddr_unx * addr_unx = (struct sockaddr_unx *) addr;\n    switch (addr->sa_family) {\n        case AF_INET:\n            ret = accept(socket, (struct sockaddr *) addr_in, addrlen);\n            break;\n        case AF_INET6:\n            ret = accept(socket, (struct sockaddr *) addr_in6, addrlen);\n            break;\n        case AF_UNIX:\n            ret = accept(socket, (struct sockaddr *) addr_un, addrlen);\n            break;\n        case AF_UNIX6:\n            ret = accept(socket, (struct sockaddr *) addr_un6, addrlen);\n            break;\n        case AF_UNIXX:\n            ret = accept(socket, (struct sockaddr *) addr_unx, addrlen);\n            break;\n        default:\n            bsd_setErrNo(EAFNOSUPPORT);\n            return -1;\n    }\n    if (ret == -1) {\n        bsd_setErrNo(errno);\n        return -1;\n    }\n    return ret;\n}", "CodeBleu_score": 44.56358451507608}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t  time_t now = time(NULL);\n  if (now != -1) {\n    updateJWT(now);\n    MQTT_CLIENT_connect(mqtt_client, &mqtt_conn_opts);\n    debug_print(\"MQTT: Attempting connection\");\n    mqtt_send_subscribe = true;\n  }\n}", "CodeBleu_score": 29.267865428121937}, {"code": "static void connectMQTT(){\n\t    time_t currentTime = time(NULL);\n    if (currentTime != -1) {\n        debug_print(\"Time is valid, updating JWT with current time offset\n\");\n        updateJWT(currentTime);\n    } else {\n        debug_print(\"Failed to retrieve current time\n\");\n    }\n\n    debug_print(\"Attempting MQTT connection...\n\");\n    MQTT_CLIENT_connect();\n    sendSubscribePacket = true;\n}", "CodeBleu_score": 59.49852657217165}, {"code": "static void connectMQTT(){\n\t  time_t now;\n  struct tm *timeinfo;\n  char strftime_buf[64];\n  int offset;\n  int time_valid;\n\n  now = time(NULL);\n  timeinfo = localtime(&now);\n  strftime(strftime_buf, sizeof(strftime_buf), \"%FT%TZ\", timeinfo);\n  time_valid = sscanf(strftime_buf, \"%4d-%2d-%2dT%2d:%2d:%2dZ\", &year, &month, &day, &hour, &minute, &second);\n\n  if (time_valid != 6) {\n    debug_print(\"Time is invalid\");\n    return;\n  }\n\n  updateJWT();\n  offset = time_valid ? (hour * 3600 + minute * 60 + second) : 0;\n  snprintf(jwt_buf, sizeof(jwt_buf), \"{\\\"exp\\\":%d,\\\"iat\\\":%d,\\\"nbf\\\":%d,\\\"sub\\\":\\\"%s\\\",\\\"iss\\\":\\\"%s\\\",\\\"aud\\\":\\\"%s\\\",\\\"jti\\\":\\\"%s\\\",\\\"offset\\\":%d}\", exp, iat, nbf, sub, iss, aud, jti, offset);\n  debug_print(\"Connecting to MQTT broker...\");\n  MQTT_CLIENT_connect(mqtt_client, mqtt_broker, mqtt_port, mqtt_keepalive);\n  send_subscribe_flag = 1;\n}", "CodeBleu_score": 43.22755703699502}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t    if (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n        MQTT_ConnectionInfo_t connectionInfo;\n        MQTT_GetClientConnectionInfo(&connectionInfo);\n        debug_printError(\"Disconnected from cloud service (%s).\n\", connectionInfo.clientId);\n        MQTT_Disconnect();\n    }\n}", "CodeBleu_score": 52.78618677747892}, {"code": "void CLOUD_disconnect(void){\n\t    if (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n        MQTT_ConnectionInfo_t connectionInfo;\n        MQTT_GetClientConnectionInfo(&connectionInfo);\n        MQTT_Disconnect();\n        debug_printError(\"Disconnected from cloud service\");\n    }\n}", "CodeBleu_score": 58.028234924444064}, {"code": "void CLOUD_disconnect(void){\n\t    if (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n        MQTT_ConnectionInfo_t connectionInfo;\n        MQTT_GetClientConnectionInfo(&connectionInfo);\n        debug_printError(\"Disconnecting from %s:%d\n\", connectionInfo.host, connectionInfo.port);\n        MQTT_Disconnect();\n    }\n}", "CodeBleu_score": 52.631395244150326}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    // If new credentials are provided, connect using the specified SSID, authentication type, and password\n    if (passed_wifi_creds) {\n        if (wifi_connect(WIFI_SSID, WIFI_AUTH_TYPE, WIFI_PASSWORD) == false) {\n            debug_printError(\"Failed to connect to AP\");\n            networking_setError(NETWORKING_ERROR_WIFI_CONNECT);\n            return false;\n        }\n    }\n    // If not, attempt to connect using the default Wi-Fi settings\n    else {\n        if (wifi_connect(WIFI_SSID_DEFAULT, WIFI_AUTH_TYPE_DEFAULT, WIFI_PASSWORD_DEFAULT) == false) {\n            debug_printError(\"Failed to connect to AP\");\n            networking_setError(NETWORKING_ERROR_WIFI_CONNECT);\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 40.17101512893755}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t  if (passed_wifi_creds == 1) {\n    // Connect to the AP using the new credentials\n    if (!m2m_wifi_default_connect(wifi_creds.ssid, wifi_creds.auth_type, wifi_creds.password)) {\n      debug_printError(\"Failed to connect to AP\");\n      networking_error_status = true;\n      return false;\n    }\n  } else {\n    // Connect to the AP using the default credentials\n    if (!m2m_wifi_default_connect(wifi_creds.ssid, wifi_creds.auth_type, wifi_creds.password)) {\n      debug_printError(\"Failed to connect to AP\");\n      networking_error_status = true;\n      return false;\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 25.770588724025444}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t  // If new credentials are provided, use them to connect\n  if (passed_wifi_creds == 1) {\n    // Connect to the Wi-Fi network using the specified SSID, authentication type, and password\n    if (WiFi.begin(ssid, auth_type, password) != WL_CONNECTED) {\n      // If the connection fails, log an error message and update the networking error status\n      debug_printError(1, \"WiFi connection failed\");\n      networking_error = 1;\n      return false;\n    }\n  }\n  // If not, try to connect using the default Wi-Fi settings\n  else if (passed_wifi_creds == 0) {\n    // Connect to the Wi-Fi network using the default SSID, authentication type, and password\n    if (WiFi.begin() != WL_CONNECTED) {\n      // If the connection fails, log an error message and update the networking error status\n      debug_printError(1, \"WiFi connection failed\");\n      networking_error = 1;\n      return false;\n    }\n  }\n  // If the connection succeeds, return true\n  return true;\n}", "CodeBleu_score": 45.686747184977065}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t  const client = generateClient();\n  const response = await client.graphql({\n    query: `query {\n      listSensors {\n        id\n        name\n        geo {\n          latitude\n          longitude\n        }\n      }\n    }`,\n  });\n  console.log(response);\n  console.log(\"Retrieving sensors...\");\n  response.data.listSensors.forEach((sensor) => {\n    const marker = CreateSensorMarker(sensor);\n    new Marker({ element: marker })\n      .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n      .addTo(map);\n  });\n}", "CodeBleu_score": 61.920250462156964}, {"code": "async function DisplaySensors(map){\n\t  const client = generateClient();\n  const response = await client.graphql({\n    query: CreateSensorMarker,\n  });\n  console.log(response);\n  console.log(\"Retrieval of sensors\");\n  response.data.listSensors.forEach((sensor) => {\n    const marker = document.createElement(\"div\");\n    new Marker({ element: marker })\n      .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n      .addTo(map);\n  });\n}", "CodeBleu_score": 59.50505120769487}, {"code": "async function DisplaySensors(map){\n\t    const client = generateClient();\n    const response = await client.graphql(CreateSensorMarker);\n    console.log(response);\n    if (response.data.listSensors) {\n        console.log(\"Retrieving Sensors\");\n        response.data.listSensors.forEach((sensor) => {\n            const marker = document.createElement(\"div\");\n            marker.innerHTML = sensor.name;\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 60.786289417411886}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor-marker\";\n    marker.style.backgroundColor = \"rgba(0, 150, 136, 0.7)\";\n    marker.style.border = \"2px solid #333\";\n    return marker;\n}", "CodeBleu_score": 45.39863700819752}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div')\n    marker.id = sensor.id\n    marker.className = 'sensor-marker'\n    marker.style.backgroundColor = 'red'\n    marker.style.border = '2px solid black'\n    return marker\n}", "CodeBleu_score": 43.92980211384039}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.backgroundColor = '#000';\n    marker.style.border = '1px solid #fff';\n    return marker;\n}", "CodeBleu_score": 44.541181402093116}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"custom_components.{module_name}\"\n    try:\n        module = async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Failed to import MFA module %s: %s\", module_path, err\n        )\n        raise HomeAssistantError(\n            \"Error: could not load MFA module {}. Is it \"\n            \"installed?\".format(module_name)\n        ) from err\n\n    if hasattr(module, \"requirements\"):\n        if not hass.config.skip_pip:\n            processed = set()\n            for requirement in getattr(module, \"requirements\", []):\n                if requirement not in processed:\n                    await requirements.async_process_requirements(\n                        hass, [requirement]\n                    )\n                    processed.add(requirement)\n\n    return module", "CodeBleu_score": 46.11517102266644}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"multi_factor_auth.{module_name}\"\n    try:\n        mfa_module = async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            f\"Error loading MFA module '{module_name}': {err}\"\n        )\n        raise HomeAssistantError(\n            f\"Error loading MFA module '{module_name}': {err}\"\n        ) from err\n\n    if hasattr(mfa_module, \"requirements\"):\n        requirements = getattr(mfa_module, \"requirements\")\n        if requirements and not hass.config.skip_pip:\n            processed = set()\n            for requirement in requirements:\n                if requirement in processed:\n                    continue\n                await async_process_requirements(hass, [requirement])\n                processed.add(requirement)\n\n    return mfa_module", "CodeBleu_score": 44.48948594352837}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"custom_components.{module_name}\"\n    try:\n        module = async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(f\"Error importing {module_path}: {err}\")\n        raise HomeAssistantError(f\"Error loading MFA module {module_name}\") from err\n    if hasattr(module, \"requirements\"):\n        if not hass.config.skip_pip:\n            processed = set()\n            for requirement in getattr(module, \"requirements\", []):\n                if requirement not in processed:\n                    await requirements.async_process_requirements(hass, [requirement])\n                    processed.add(requirement)\n    return module", "CodeBleu_score": 42.89235907974205}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if self.data is None:\n        self.data = []\n    if self.data:\n        for user in self.data:\n            if user[\"user_id\"] == user_id:\n                user[\"pin\"] = setup_data\n                return\n    self.data.append({\"user_id\": user_id, \"pin\": setup_data})\n\n", "CodeBleu_score": 50.82013780275765}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[CONF_PIN]\n    if not is_valid_pin(pin):\n        raise InvalidPIN\n    user = await self.auth.async_get_or_create_user(user_id)\n    if user.is_new:\n        user.is_active = True\n    if not user.is_active:\n        raise UserNotActive\n    if self.data.get(user_id):\n        self.data[user_id][CONF_PIN] = pin\n    else:\n        self.data[user_id] = {CONF_PIN: pin}\n    return await self.async_finish_setup(user_id, setup_data)\n\n", "CodeBleu_score": 27.61490665768116}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[CONF_PIN]\n    if user_id in self.data:\n        self.data[user_id].update({CONF_PIN: pin})\n    else:\n        self.data[user_id] = {CONF_PIN: pin}\n    return True\n\n", "CodeBleu_score": 31.384726393820046}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._loaded:\n            return\n        data = await self._store.async_load()\n        if not data:\n            data = {}\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id,\n                data.get(user_id, {}),\n            )\n            for user_id in self._users\n        }\n        self._loaded = True\n\n", "CodeBleu_score": 40.16138934880874}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is None:\n            data = await self._store.async_load()\n            if data is None:\n                self._user_settings = {}\n            else:\n                self._user_settings = {\n                    user: NotifySetting(\n                        user,\n                        data.get(user, {}).get(CONF_ENABLED, True),\n                        data.get(user, {}).get(CONF_TITLE, DEFAULT_TITLE),\n                        data.get(user, {}).get(CONF_MESSAGE, DEFAULT_MESSAGE),\n                        data.get(user, {}).get(CONF_SOUND, True),\n                        data.get(user, {}).get(CONF_VIBRATE, True),\n                        data.get(user, {}).get(CONF_LED_COLOR, DEFAULT_LED_COLOR),\n                        data.get(user, {}).get(CONF_LED_INTENSITY, DEFAULT_LED_INTENSITY),\n                        data.get(user, {}).get(CONF_LED_DURATION, DEFAULT_LED_DURATION),\n                        data.get(user, {}).get(CONF_LED_FADE_IN, DEFAULT_LED_FADE_IN),\n                        data.get(user, {}).get(CONF_LED_FADE_OUT, DEFAULT_LED_FADE_OUT),\n                    )\n                    for user in data\n                }\n\n", "CodeBleu_score": 37.889025135942504}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is None:\n            self._user_settings = {}\n            try:\n                data = await self._user_store.async_load()\n            except Exception:\n                _LOGGER.debug(\"Failed to load user settings\", exc_info=True)\n                return\n            if data is None:\n                return\n            for user, user_data in data.items():\n                self._user_settings[user] = NotifySetting(\n                    user,\n                    user_data.get(CONF_ENABLED, False),\n                    user_data.get(CONF_NAME, None),\n                    user_data.get(CONF_DEVICE, None),\n                    user_data.get(CONF_VOLUME, None),\n                    user_data.get(CONF_VOLUME_NORMALIZED, None),\n                    user_data.get(CONF_VOLUME_STEP, None),\n                    user_data.get(CONF_VOLUME_MUTED, None),\n                    user_data.get(CONF_VOLUME_STEP_COUNT, None),\n                    user_data.get(CONF_VOLUME_STEP_COUNT_MAX, None),\n                    user_data.get(CONF_VOLUME_STEP_COUNT_MIN, None),\n                    user_data.get(CONF_VOLUME_STEP_COUNT_DEFAULT, None),\n                    user_data.get(CONF_VOLUME_STEP_COUNT_INCREMENT, None),\n                    user_data.get(CONF_VOLUME_STEP_COUNT_DECREMENT, None),\n                    user_data.get(CONF_VOLUME_STEP_COUNT_RESET, None),\n                    user_data.get(CONF_VOLUME_STEP_COUNT_RESET_DELAY, None),\n                    user_data.get(CONF_VOLUME_STEP_COUNT_RESET_DELAY_DEFAULT, None),\n                    user_data.get(CONF_VOLUME_STEP_COUNT_RESET", "CodeBleu_score": 25.40944393846273}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load(user_id)\n    settings = self._user_settings.get(user_id)\n    if not settings:\n        return False\n    return await async_add_executor_job(self._validate, settings, user_input)\n\n", "CodeBleu_score": 41.71835699098451}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load(user_id)\n    settings = self.users[user_id].get(USER_SETTINGS_KEY)\n    if not settings:\n        return False\n    return await async_add_executor_job(self._validate_otp, settings, user_input)\n\n", "CodeBleu_score": 39.52964285333789}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load(user_id)\n    if user_id not in self._data:\n        return False\n    if \"otp\" not in user_input:\n        return False\n    if \"otp\" in user_input:\n        otp = user_input.get(\"otp\")\n        if otp is None:\n            return False\n        if otp == \"\":\n            return False\n        if len(otp) != 6:\n            return False\n        if not otp.isdigit():\n            return False\n        if not await asyncio.get_running_loop().run_in_executor(\n            None, self.verify_otp, otp\n        ):\n            return False\n    return True\n\n", "CodeBleu_score": 42.707743582254174}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if not entity_entry:\n        return None\n\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if not device_entry:\n        return None\n\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 56.866376498375985}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if not entity_entry:\n        return None\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if not device_entry:\n        return None\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n    area_perms = area_dict.get(area_id)\n    if not area_perms:\n        return None\n    return area_perms", "CodeBleu_score": 56.40811689340719}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n\n    if device_entry.area_id is None:\n        return None\n\n    return area_dict.get(device_entry.area_id)", "CodeBleu_score": 66.94551000049933}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    cast = {\n        \"cast\": {\n            \"cast\": {\n                \"cast\": {\n                    \"cast\": {\n                        \"cast\": {\n                            \"cast\": {\n                                \"cast\": {\n                                    \"cast\": {\n                                        \"cast\": {\n                                            \"cast\": {\n                                                \"cast\": {\n                                                    \"cast\": {\n                                                        \"cast\": {\n                                                            \"cast\": {\n                                                                \"cast\": {\n                                                                    \"cast\": {\n                                                                        \"cast\": {\n                                                                            \"cast\": {\n                                                                                \"cast\": {\n                                                                                    \"cast\": {\n                                                                                        \"cast\": {\n                                                                                            \"cast\": {\n                                                                                                \"cast\": {\n                                                                                                    \"cast\": {\n                                                                                                        \"cast\": {\n                                                                                                            \"cast\": {\n                                                                                                                \"cast\": {\n                                                                                                                    \"cast\": {\n                                                                                                                        \"cast\": {\n                                                                                                                            \"cast\": {\n                                                                                                                                \"cast\": {\n                                                                                                                                    \"cast\": {\n                                                                                                                                        \"cast\": {\n                                                                                                                                            \"cast\": {\n                                                                                                                                                \"cast\": {\n                                                                                                                                                    \"cast\": {\n                                                                                                                                                        \"cast\": {\n                                                                                                                                                            \"cast\": {\n                                                                                                                                                                \"cast\": {\n                                                                                                                                                                    \"cast\": {\n                                                                                                                                                                        \"cast\": {\n                                                                                                                                                                            \"cast\": {\n                                                                                                                                                                                \"cast\": {\n                                                                                                                                                                                    \"cast\": {\n                                                                                                                                                                                        \"cast\": {\n                                                                                                                                                                                            \"cast\": {\n                                                                                                                                                                                                \"cast\": {\n                                                                                                                                                                                                    \"cast\": {\n                                                                                                                                                                                                        \"cast\": {\n                                                                                                                                                                                                            \"cast\": {\n                                                                                                                                                                                                                \"cast\": {\n                                                                                                                                                                                                                    \"cast\": {\n                                                                                                                                                                                                                        \"cast\": {\n                                                                                                                                                                                                                            \"cast\": {\n                                                                                                                                                                                                                                \"cast\": {\n                                                                                                                                                                                                                                    \"cast\": {\n                                                                                                                                                                                                                                        \"cast\": {\n                                                                                                                                                                                                                                            \"cast\": {\n                                                                                                                                                                                                                                                \"cast\": {\n                                                                                                                                                                                                                                                    \"cast\": {\n                                                                                                                                                                                                                                                        \"cast\": {\n                                                                                                                                                                                                                                                            \"cast\": {\n                                                                                                                                                                                                                                                                \"cast\": {\n                                                                                                                                                                                                                                                                    \"cast\": {\n                                                                                                                                                                                                                                                                        \"", "CodeBleu_score": 6.6792796047258935}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy = {}\n    seen = set()\n    for p in policies:\n        for category, rules in p.items():\n            if category not in seen:\n                seen.add(category)\n                policy[category] = merge_rules(rules)\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 33.71362910007042}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy = cast(PolicyType, {})\n    seen = set()\n    for p in policies:\n        for category, categories in p.items():\n            if category not in seen:\n                seen.add(category)\n                policy[category] = merge_categories(categories)\n    return policy\n\n", "CodeBleu_score": 32.99040039096754}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in processed:\n        return provider\n    try:\n        auth_provider_module = await async_import_module(\n            f\"homeassistant.auth.providers.{provider}\"\n        )\n    except ImportError as err:\n        _LOGGER.error(\"Error loading auth provider %s: %s\", provider, err)\n        raise HomeAssistantError(\n            f\"Error loading auth provider {provider}: {err}\"\n        ) from err\n    if not hasattr(auth_provider_module, \"REQUIREMENTS\"):\n        processed.add(provider)\n        return auth_provider_module\n    requirements = getattr(auth_provider_module, \"REQUIREMENTS\")\n    if not requirements:\n        processed.add(provider)\n        return auth_provider_module\n    await async_process_requirements(hass, requirements)\n    processed.add(provider)\n    return auth_provider_module", "CodeBleu_score": 56.533401808491}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = importlib.import_module(f\"homeassistant.auth.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Error loading auth provider module %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Error loading auth provider module {provider}: {err}\"\n        ) from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    requirements = module.REQUIREMENTS\n    if not requirements:\n        return module\n\n    if not processed.add(provider):\n        return module\n\n    await asyncio.gather(\n        *[\n            async_import_module(hass, req)\n            for req in requirements\n            if req not in requirements.async_process_requirements\n        ]\n    )\n\n    for req in requirements.async_process_requirements:\n        await asyncio.gather(\n            *[\n                async_import_module(hass, req)\n                for req in getattr(module, req)\n            ]\n        )\n\n    return module", "CodeBleu_score": 48.06223706875753}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = async_import_module(f\"homeassistant.auth.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Error loading auth provider %s: %s\", provider, err, exc_info=True\n        )\n        raise HomeAssistantError(\n            f\"Error loading auth provider {provider}: {err}\"\n        ) from err\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, processed\n        )\n    return module\n\n", "CodeBleu_score": 46.98963206620935}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    try:\n        self._store = await self._store.async_load()\n        if not self._store:\n            self._store = {}\n    except (\n        json.JSONDecodeError,\n        KeyError,\n        TypeError,\n        ValueError,\n        OSError,\n    ) as err:\n        _LOGGER.warning(\"Error loading data: %s\", err)\n        self._store = {}\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 29.50287361186268}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self.store.async_load()\n    except (FileNotFoundError, JSONDecodeError):\n        data = {}\n    self._data = data\n    await self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 32.709701523192415}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self._async_load_from_store()\n    except (FileNotFoundError, json.JSONDecodeError):\n        data = {}\n\n    if not data:\n        self._users = []\n        return\n\n    self._users = [User(**user) for user in data.values()]\n\n    await self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 30.248662970121288}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if not bcrypt.checkpw(password.encode(), user.password.encode()):\n                raise InvalidAuth()\n            return\n    raise InvalidAuth()\n\n", "CodeBleu_score": 33.76810055250184}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = user[\"password\"]\n            break\n    else:\n        if bcrypt.checkpw(password.encode(), dummy_hash):\n            raise InvalidAuth(\"Invalid username or password\")\n        else:\n            raise InvalidAuth(\"Invalid username or password\")\n    if not bcrypt.checkpw(password.encode(), stored_hash.encode()):\n        raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 39.480696508120985}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = user.password\n            break\n    else:\n        if bcrypt.checkpw(password.encode(), dummy_hash):\n            raise InvalidAuth(\"Invalid username or password\")\n        raise InvalidAuth(\"Invalid username or password\")\n    if not bcrypt.checkpw(password.encode(), stored_hash.encode()):\n        raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 38.3915195186703}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 29.89753697862173}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 29.89753697862173}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    user = next((user for user in self.users if user.username == username), None)\n    if user is None:\n        raise InvalidUser(\"user_not_found\")\n    self.users.remove(user)\n\n", "CodeBleu_score": 31.19364804872186}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.async_initialize:\n        await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n    except InvalidUser:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 47.820450318177535}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.async_initialize:\n        await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n    except Exception:\n        pass\n    await self.async_save()", "CodeBleu_score": 45.64771429897999}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n    except InvalidUser:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 47.64596610290742}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n        else:\n            timeout_for_thread = timeout / len(threads)\n            with contextlib.suppress(TimeoutError):\n                thread.join(timeout=timeout_for_thread)\n            if thread.is_alive():\n                if log:\n                    _log_thread_running_at_shutdown(thread)\n                async_raise(thread, SystemExit)\n            else:\n                joined.add(thread)\n    for thread in threads:\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread)\n            async_raise(thread, SystemExit)\n    return joined\n\n", "CodeBleu_score": 52.293120524174185}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        timeout_for_thread = timeout / len(threads)\n        thread.join(timeout_for_thread)\n        if thread.is_alive():\n            joined.add(thread)\n            if log:\n                _log_thread_running_at_shutdown(thread)\n    for thread in threads - joined:\n        async_raise(thread, SystemExit)\n    return joined\n\n", "CodeBleu_score": 57.167402228437105}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        with suppress(Exception):\n            thread.join(timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n        elif log:\n            _log_thread_running_at_shutdown(thread)\n    for thread in threads:\n        if thread in joined:\n            continue\n        with suppress(Exception):\n            async_raise(thread, SystemExit)\n    return joined\n\n", "CodeBleu_score": 48.39966801613444}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    for thread in threading.enumerate():\n        if thread is not threading.main_thread() and not thread.is_daemon() and thread.is_alive():\n            timeout = SHUTDOWN_TIMEOUT / len(threading.enumerate())\n            try:\n                thread.join(timeout)\n            except Exception:\n                _LOGGER.warning(\"Failed to join thread %s\", thread)\n\n", "CodeBleu_score": 36.4464468186928}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()\n    ]\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = SHUTDOWN_TIMEOUT_SECONDS / len(threads)\n    # Attempt to join each thread within the calculated timeout and log a warning if joining a thread fails\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception:\n            _LOGGER.warning(\"Failed to join thread %s\", thread)\n\n", "CodeBleu_score": 42.69047951577376}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread != threading.main_thread() and not thread.daemon and thread.is_alive()\n    ]\n\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = SHUTDOWN_TIMEOUT / len(threads)\n\n    # Attempt to join each thread within the calculated timeout\n    for thread in threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\n                \"Shutdown timeout exceeded while waiting for thread %s to finish\",\n                thread.name,\n            )", "CodeBleu_score": 39.178824053916436}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._async_dispatch_internal_flag:\n        async_dispatcher_send_internal(self.hass, SIGNAL_UPDATE_ENTITY_FROM_REMAINING_SETUPS)\n        self._async_dispatch_internal_flag = bool(remaining_with_setup_started)", "CodeBleu_score": 50.12392622203299}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._internal_flag:\n        async_dispatcher_send_internal(self._hass, \"setup_remaining\", remaining_with_setup_started)\n        self._internal_flag = bool(remaining_with_setup_started)", "CodeBleu_score": 50.765666133743736}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_state:\n        async_dispatcher_send_internal(self.hass, SIGNAL_SETUP_FINISHED, remaining_with_setup_started)\n    self._previous_state = remaining_with_setup_started", "CodeBleu_score": 55.35416159987086}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Generate and validate the Bluetooth content\n    generate_and_validate(integrations, config)\n\n    # Read the current content of bluetooth.py\n    with open(config.path / \"bluetooth.py\", \"r\") as fp:\n        current_content = fp.read()\n\n    # Compare the generated content with the current content\n    if current_content != config.bluetooth_content:\n        config.add_error(\n            \"bluetooth.py is not up to date\",\n            \"Update bluetooth.py to match the latest integrations\",\n            fixable=True,\n            fix=lambda: str(config.bluetooth_content),\n        )", "CodeBleu_score": 38.531683579145806}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Generate and validate Bluetooth content\n    generate_and_validate(integrations, config)\n\n    # Read current content of bluetooth.py\n    with open(\"bluetooth.py\", \"r\") as f:\n        current_content = f.read()\n\n    # Compare current content with generated content\n    if current_content != config.bluetooth:\n        # Add error to configuration\n        config.add_error(\"bluetooth.py is not up to date\", \"Fix by running `python -m homeassistant.scripts.bluetooth`\")\n\n    # Return None\n    return None\n\n", "CodeBleu_score": 30.892757286574458}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Generate and validate the Bluetooth content based on provided integrations\n    generate_and_validate(integrations, config)\n\n    # Read the current content of bluetooth.py\n    with open('bluetooth.py', 'r') as fp:\n        current_content = fp.read()\n\n    # Generate the expected content for bluetooth.py\n    expected_content = generate_and_validate(integrations, config)\n\n    # Compare the current content with the expected content\n    if current_content != expected_content:\n        # Add an error to the configuration indicating that bluetooth.py is not up to date\n        config.add_error('bluetooth.py is not up to date', 'Run the `generate_bluetooth` command to update it.')\n\n        # Provide a fixable suggestion to update bluetooth.py\n        config.fixable_suggestions.append(FixableSuggestion(\n            'Update bluetooth.py',\n            'Run the `generate_bluetooth` command to update it.',\n            'generate_bluetooth',\n            None\n        ))", "CodeBleu_score": 38.125846046280145}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp Resp\n\tvar e Error\n\tlogger.Info(\"refresh token\")\n\t_, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.TokenEndpoint)\n\tif err != nil {\n\t\tlogger.Error(\"refresh token\", zap.Error(err))\n\t\treturn err\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 66.12845210663633}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp TokenResp\n\tvar e error\n\tlogger.Info(\"refresh token\")\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.TokenURL)\n\tif e != nil {\n\t\tlogger.Error(\"refresh token error\", zap.String(\"error\", e.Error()))\n\t\treturn e\n\t}\n\tif resp.Error != \"\" {\n\t\tlogger.Error(\"refresh token error\", zap.String(\"error\", resp.Error))\n\t\treturn errors.New(resp.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 67.29452314110097}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp TokenResponse\n\tvar e ErrorResponse\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.TokenURL)\n\tif err != nil {\n\t\tlogger.Error(\"refresh token error\", zap.Error(err))\n\t\treturn err\n\t}\n\tif res.IsError() {\n\t\tlogger.Error(\"refresh token error\", zap.String(\"response\", res.String()))\n\t\treturn fmt.Errorf(\"refresh token error\")\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 69.52163316833239}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R().\n\t\tSetHeader(\"Authorization\", \"Bearer \"+d.accessToken).\n\t\tSetQueryParam(\"supportsAllDrives\", \"true\").\n\t\tSetQueryParam(\"includeItemsFromAllDrives\", \"true\").\n\t\tSetQueryParam(\"corpora\", \"allDrives\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tresp, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"request failed: %v\", err)\n\t}\n\n\tif resp.IsError() {\n\t\tswitch resp.StatusCode() {\n\t\tcase 401:\n\t\t\td.refreshToken()\n\t\t\treturn d.request(url, method, callback, resp)\n\t\tcase 403:\n\t\t\treturn nil, fmt.Errorf(\"request failed: %v\", resp.Error())\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"request failed: %v\", resp.Error())\n\t\t}\n\t}\n\n\treturn resp.Body(), nil\n}", "CodeBleu_score": 57.390951406513445}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar err error\n\tvar res *resty.Response\n\n\treq := d.client.R().SetAuthToken(d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\treq.SetQueryParam(\"includePermissions\", \"true\")\n\treq.SetQueryParam(\"supportsTeamDrives\", \"true\")\n\treq.SetQueryParam(\"teamDriveId\", \"root\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tfor i := 0; i < d.maxRetries; i++ {\n\t\tswitch method {\n\t\tcase http.MethodGet:\n\t\t\tres, err = req.Get(url)\n\t\tcase http.MethodPost:\n\t\t\tres, err = req.Post(url)\n\t\tcase http.MethodPut:\n\t\t\tres, err = req.Put(url)\n\t\tcase http.MethodPatch:\n\t\t\tres, err = req.Patch(url)\n\t\tcase http.MethodDelete:\n\t\t\tres, err = req.Delete(url)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unsupported method: %s\", method)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif res.IsError() {\n\t\t\tif res.StatusCode() == http.StatusUnauthorized {\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn nil, fmt.Errorf(\"error %d: %s\", res.StatusCode(), res.Status())\n\t\t}\n\n\t\tbreak\n\t}\n\n\treturn res.Body(), nil\n}", "CodeBleu_score": 54.99436572319464}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\n\t// Create a new request\n\treq := d.client.R().\n\t\tSetHeader(\"Authorization\", \"Bearer \"+d.accessToken).\n\t\tSetQueryParam(\"supportsAllDrives\", \"true\").\n\t\tSetQueryParam(\"includeItemsFromAllDrives\", \"true\").\n\t\tSetQueryParam(\"supportsTeamDrives\", \"true\")\n\n\t// Set the request method\n\treq.SetMethod(method)\n\n\t// Set the request URL\n\treq.SetURL(url)\n\n\t// Set the request callback\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\t// Set the request result\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\t// Execute the request\n\tres, err := req.Execute(d.client.GetClient())\n\n\t// Handle errors\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the response status code is 401\n\tif res.StatusCode() == 401 {\n\t\t// Refresh the access token\n\t\td.refreshToken()\n\n\t\t// Retry the request\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\t// Check if the response status code is not 200\n\tif res.StatusCode() != 200 {\n\t\t// Return an error\n\t\treturn nil, fmt.Errorf(\"error: %s\", res.Status())\n\t}\n\n\t// Return the response body\n\treturn res.Body(), nil\n}", "CodeBleu_score": 59.81234033419449}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size based on the size of the file and the maximum chunk size\n\tchunkSize := int64(math.Min(float64(stream.GetSize()), float64(d.maxChunkSize)))\n\n\t// Calculate the number of chunks needed to upload the entire file\n\tnumChunks := int64(math.Ceil(float64(stream.GetSize()) / float64(chunkSize)))\n\n\t// Loop through each chunk and upload it\n\tfor i := int64(0); i < numChunks; i++ {\n\t\t// Calculate the start and end indices for the current chunk\n\t\tstart := i * chunkSize\n\t\tfinish := start + chunkSize - 1\n\t\tif finish >= stream.GetSize() {\n\t\t\tfinish = stream.GetSize() - 1\n\t\t}\n\n\t\t// Create a new HTTP request to upload the chunk\n\t\treq, err := http.NewRequest(\"PUT\", url, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the appropriate headers for the chunk\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\n\t\t// Send the HTTP request to upload the chunk\n\t\tresp, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// Check if the context has been canceled\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Check if the HTTP response status code indicates an error\n\t\tif resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {\n\t\t\treturn fmt.Errorf(\"failed to upload chunk %d, status code: %d\", i, resp.", "CodeBleu_score": 56.22211269197709}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 10 // 10MB\n\tfinish := 0\n\tfor {\n\t\treq := d.request(url).SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t_, err := req.Post()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfinish += chunkSize\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 49.55487432786247}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := stream.GetSize() / 100\n\tif chunkSize < 1024*1024 {\n\t\tchunkSize = 1024 * 1024\n\t}\n\n\tfinish := 0\n\tfor finish < stream.GetSize() {\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\treq := d.request(http.MethodPut, url, nil)\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\n\t\tif err := req.Send(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfinish += chunkSize\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 61.551434295398636}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar storage = &models.Storage{}\n\tif err := ctx.Bind(storage); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_BIND_DATA_FAILED))\n\t}\n\n\tif storage.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_MOUNT_POINT_IS_EMPTY))\n\t}\n\n\tif err := service.MyService.Storage().UnmountStorage(storage.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ERROR_UNMOUNT_STORAGE_FAILED))\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(storage.Name); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ERROR_DELETE_CONFIG_FAILED))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS))\n}", "CodeBleu_score": 34.348335935435145}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar jsonData struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\n\tif err := ctx.Bind(&jsonData); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidParam))\n\t}\n\n\tif jsonData.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidParam))\n\t}\n\n\tif err := service.MyService.Storage().UnmountStorage(jsonData.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrService))\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(jsonData.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrService))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ErrOK))\n}", "CodeBleu_score": 43.93999014650781}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar storage_config = new(service.StorageConfig)\n\tif err := ctx.Bind(storage_config); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrorParameter))\n\t}\n\n\tif storage_config.Mount_point == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrorParameter))\n\t}\n\n\tif err := service.MyService.Storage().UnmountStorage(storage_config.Mount_point); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrorService))\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(storage_config.Name); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrorService))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.Success))\n}", "CodeBleu_score": 33.875388362419244}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"filePath\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathMissing))\n\t}\n\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.02606160306148}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"filePath\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_FILE_PATH_EMPTY))\n\t}\n\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_FILE_NOT_EXIST))\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.98220448094768}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrMissingPath))\n\t}\n\n\tif !file.Exists(path) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\treturn ctx.File(path)\n}", "CodeBleu_score": 46.50424295480563}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(http.StatusOK, \"success\"))\n}", "CodeBleu_score": 55.54862053429391}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\terr := ctx.Bind(&message)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_BIND_FAIL, err.Error()))\n\t}\n\tservice.MyService.Notify().SendNotify(name, message)\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS, \"success\"))\n}", "CodeBleu_score": 61.28261196208968}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrBind, err.Error()))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrInternalServerError, err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.Success, \"\"))\n}", "CodeBleu_score": 68.1265717804757}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader.CheckOrigin = func(r *http.Request) bool { return true }\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tconnections = append(connections, ws)\n\tgo service.SendMeg()\n\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"recv: \", string(message))\n\t\tif err = ws.WriteMessage(mt, message); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.72426061085634}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tupGrader := websocket.Upgrader{}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service if it is not already running\n\tif !service.IsRunning {\n\t\tgo service.SendMeg()\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tlog.Println(\"message type: \", msg.Type)\n\t\tlog.Println(\"message: \", string(msg.Data))\n\t}\n}", "CodeBleu_score": 46.46533727821288}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader := websocket.Upgrader{}\n\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconnections = append(connections, conn)\n\tgo service.SendMeg()\n\tfor {\n\t\t_, msg, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(string(msg))\n\t}\n\treturn nil\n}", "CodeBleu_score": 44.26522607909159}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tcpuInfo := service.MyService.System().GetCpuInfo()\n\tif cpuInfo == nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ERROR_SYSTEM_CPU_INFO_NOT_FOUND))\n\t}\n\n\tsystemHardwareInfo := make(map[string]interface{})\n\tsystemHardwareInfo[\"drive_model\"] = service.MyService.System().GetDeviceTree()\n\tsystemHardwareInfo[\"architecture\"] = runtime.GOARCH\n\tsystemHardwareInfo[\"cpu_info\"] = cpuInfo\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS, systemHardwareInfo))\n}", "CodeBleu_score": 39.85961709507182}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tcpuInfo, err := service.MyService.System().GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ErrorGetCpuInfo))\n\t}\n\n\thardwareInfo := make(map[string]interface{})\n\thardwareInfo[\"cpu\"] = cpuInfo\n\thardwareInfo[\"drive\"] = service.MyService.System().GetDriveModel()\n\thardwareInfo[\"architecture\"] = runtime.GOARCH\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.Success, hardwareInfo))\n}", "CodeBleu_score": 39.93485984599743}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tsysInfo := service.MyService.System().GetSystemHardwareInfo()\n\tif sysInfo == nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ERROR_SYSTEM_INFO_NOT_FOUND))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS, sysInfo))\n}", "CodeBleu_score": 24.45723293609947}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tstatus, err := systemctl.GetStatus(service)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif status == \"active\" {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 62.55540342152932}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Status == \"running\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 73.49606056498284}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tstatus, err := systemctl.Status(service)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif status.ActiveState == \"active\" {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 62.31012374472142}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to serialize message to JSON\", zap.String(\"name\", name), zap.String(\"message\", string(jsonMessage)), zap.Error(err))\n\t\treturn\n\t}\n\n\tresponse, err := i.MessageBus().PublishEventWithResponse(context.Background(), name, string(jsonMessage))\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.String(\"message\", string(jsonMessage)), zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.String(\"message\", string(jsonMessage)), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 42.20946865191702}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageJson, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to serialize message to JSON\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), name, messageJson)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.String(\"status\", response.Status), zap.String(\"body\", response.Body))\n\t}\n}", "CodeBleu_score": 42.59098404446859}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonStr, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to serialize message to JSON\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), name, string(jsonStr))\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.String(\"status\", response.Status), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 44.08072264266173}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient, err := message_bus.NewClientWithResponses(c.runtimePath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\taddress, err := external.GetMessageBusAddress(c.runtimePath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tclient.Server = address\n\n\treturn client\n}", "CodeBleu_score": 40.85457465194607}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tmessageBusAddress := external.GetMessageBusAddress()\n\tclient, _ := message_bus.NewClientWithResponses(messageBusAddress)\n\treturn client\n}", "CodeBleu_score": 19.395747140194107}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\taddress, err := c.runtime.GetMessageBusAddress()\n\tif err != nil {\n\t\treturn message_bus.NewClientWithResponses(c.config.GetMessageBusAddress())\n\t}\n\treturn message_bus.NewClientWithResponses(address)\n}", "CodeBleu_score": 30.933877431322205}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.Contains(ip, \"::ffff:127.0.0.1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 48.61470773610682}, {"code": "func GetIP(request *http.Request) string{\n\t\txForwardedFor := request.Header.Get(\"x-forwarded-for\")\n\tif xForwardedFor != \"\" {\n\t\tips := strings.Split(xForwardedFor, \",\")\n\t\tif len(ips) > 0 {\n\t\t\tip := strings.TrimSpace(ips[0])\n\t\t\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\t\t\tip = \"127.0.0.1\"\n\t\t\t}\n\t\t\treturn ip\n\t\t}\n\t}\n\n\treturn strings.Split(request.RemoteAddr, \":\")[0]\n}", "CodeBleu_score": 49.47828857707929}, {"code": "func GetIP(request *http.Request) string{\n\t    // Check the \"x-forwarded-for\" header\n    xForwardedFor := request.Header.Get(\"x-forwarded-for\")\n    if xForwardedFor != \"\" {\n        // Extract the first IP\n        ip := strings.Split(xForwardedFor, \",\")[0]\n        // Convert the loopback addresses\n        if ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n            ip = \"127.0.0.1\"\n        }\n        return ip\n    }\n    // Use the request's remote address\n    return strings.Split(request.RemoteAddr, \":\")[0]\n}", "CodeBleu_score": 49.61458112883877}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesPath := filepath.Join(c.path, \"modules\")\n\tentryPath := filepath.Join(modulesPath, \"entry.json\")\n\tif _, err := os.Stat(entryPath); os.IsNotExist(err) {\n\t\t_, err := os.Create(entryPath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"create file error\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\tfiles, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(\"read dir error\", zap.Error(err))\n\t\treturn\n\t}\n\tvar entry []map[string]interface{}\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tfilePath := filepath.Join(modulesPath, file.Name(), \"entry.json\")\n\t\t\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdata, err := os.ReadFile(filePath)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"read file error\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar entryMap []map[string]interface{}\n\t\t\terr = json.Unmarshal(data, &entryMap)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"unmarshal error\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tentry = append(entry, entryMap...)\n\t\t}\n\t}\n\tentryData, err := json.Marshal(entry)\n\tif err != nil {\n\t\tlogger.Error(\"marshal error\", zap.Error(err))\n\t\treturn\n\t}\n\terr = os.WriteFile(entryPath, entryData, 0666)\n\tif err != nil {\n\t\tlogger.Error(\"write file error\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 58.18851820407092}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesDir := filepath.Join(c.path, \"modules\")\n\tentryFile := filepath.Join(c.path, \"entry.json\")\n\n\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\tif err := os.MkdirAll(modulesDir, os.ModePerm); err != nil {\n\t\t\tlogger.Error(err)\n\t\t\treturn\n\t\t}\n\n\t\tif err := os.WriteFile(entryFile, []byte(\"[]\"), os.ModePerm); err != nil {\n\t\t\tlogger.Error(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tentries, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlogger.Error(err)\n\t\treturn\n\t}\n\n\tsystemEntries := make([]interface{}, 0, len(entries))\n\tfor _, entry := range entries {\n\t\tif entry.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tentryPath := filepath.Join(modulesDir, entry.Name())\n\t\tentryData, err := os.ReadFile(entryPath)\n\t\tif err != nil {\n\t\t\tlogger.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar entryJSON interface{}\n\t\tif err := json.Unmarshal(entryData, &entryJSON); err != nil {\n\t\t\tlogger.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tsystemEntries = append(systemEntries, entryJSON)\n\t}\n\n\tsystemEntryData, err := json.Marshal(systemEntries)\n\tif err != nil {\n\t\tlogger.Error(err)\n\t\treturn\n\t}\n\n\tif err := os.WriteFile(entryFile, systemEntryData, os.ModePerm); err != nil {\n\t\tlogger.Error(err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 42.07710908776584}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesDir := c.modulesDir\n\tentryFile := c.entryFile\n\n\t// Check if the entry file exists, if not, create it\n\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\t_, err := os.Create(entryFile)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tvar entries []string\n\tdirs, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to read modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\tfor _, dir := range dirs {\n\t\tentryPath := filepath.Join(modulesDir, dir.Name(), \"entry.json\")\n\t\tentry, err := os.ReadFile(entryPath)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlogger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tentries = append(entries, string(entry))\n\t}\n\n\t// Concatenate the entries into a single JSON array\n\tentryArray := \"[\" + strings.Join(entries, \",\") + \"]\"\n\n\t// Write the entry array to the entry file\n\terr = os.WriteFile(entryFile, []byte(entryArray), 0644)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to write entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 56.67256636541782}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t    interfaces, err := c.Interfaces()\n    if err != nil {\n        return \"\", err\n    }\n\n    networkNames, err := c.GetNetworkNames()\n    if err != nil {\n        return \"\", err\n    }\n\n    for _, networkName := range networkNames {\n        for _, interface := range interfaces {\n            if interface.Name == networkName {\n                return interface.MacAddress, nil\n            }\n        }\n    }\n\n    return \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 58.8735973089857}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, netName := range netNames {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 65.4700382135845}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworks, err := MyService.System().GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, network := range networks {\n\t\t\tif iface.Name == network.Name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 63.59973503395767}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  int32_t iRetCode = TSDB_CODE_SUCCESS;\n\n  if (pRequest != NULL && pTscObj != NULL) {\n    atomic_add_fetch_64(&(pTscObj->requestCount), 1);\n    atomic_add_fetch_64(&(pRequest->refCount), 1);\n\n    if (pTscObj->pAppInfo != NULL) {\n      pTscObj->pAppInfo->totalReqCount++;\n      pTscObj->pAppInfo->curReqCount++;\n    }\n\n    tscDebug(pTscObj, \"Register request, total request count: %\" PRIu64 \", current request count: %\" PRIu64 \".\",\n             pTscObj->pAppInfo->totalReqCount, pTscObj->pAppInfo->curReqCount);\n  } else {\n    iRetCode = TSDB_CODE_INVALID_PARAMETERS;\n  }\n\n  return iRetCode;\n}", "CodeBleu_score": 42.03315784917081}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t iRetCode = TSDB_CODE_SUCCESS;\n\n    if (pRequest == NULL || pTscObj == NULL) {\n        return TSDB_CODE_NULL_PARAM;\n    }\n\n    /* Add a reference to the request object */\n    pRequest->refCount++;\n\n    /* Increment the request count for the TSC object */\n    pTscObj->requestCount++;\n\n    /* Update the application's request summary, if available */\n    if (pTscObj->appInfo != NULL) {\n        pTscObj->appInfo->totalRequestCount++;\n        pTscObj->appInfo->currRequestCount++;\n    }\n\n    /* Log debug information about the new request */\n    TAOS_LOG(pTscObj->logInfo, TAOS_LOG_DEBUG, \"register request: %\" PRIu64 \", total: %\" PRIu64 \", current: %\" PRIu64, pRequest->id, pTscObj->appInfo->totalRequestCount, pTscObj->appInfo->currRequestCount);\n\n    return iRetCode;\n}", "CodeBleu_score": 43.393257312399776}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t rc = TSDB_CODE_SUCCESS;\n    int32_t i;\n    int32_t nCols;\n    int32_t nTags;\n    int32_t nFields;\n    int32_t nDims;\n    int32_t nTables;\n    int32_t nShards;\n    int32_t nReqs;\n    int32_t nReqsPerShard;\n    int32_t nReqsPerTable;\n    int32_t nReqsPerDim;\n    int32_t nReqsPerTag;\n    int32_t nReqsPerField;\n    int32_t nReqsPerCol;\n    int32_t nReqsPerNode;\n    int32_t nReqsPerHost;\n    int32_t nReqsPerIp;\n    int32_t nReqsPerUser;\n    int32_t nReqsPerDb;\n    int32_t nReqsPerTb;\n    int32_t nReqsPerStb;\n    int32_t nReqsPerPt;\n    int32_t nReqsPerPtt;\n    int32_t nReqsPerPttt;\n    int32_t nReqsPerPtttt;\n    int32_t nReqsPerPttttt;\n    int32_t nReqsPerPtttttt;\n    int32_t nReqsPerPttttttt;\n    int32_t nReqsPerPtttttttt;\n    int32_t nReqsPerPttttttttt;\n    int32_t nReqsPerPtttttttttt;\n    int32_t nReqsPerPttttttttttt;\n    int32_t nReqsPerPtttttttttttt;\n    int32_t nReqsPerP", "CodeBleu_score": 7.7976893988168925}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->dbName == NULL || exceptDb == NULL) {\n    return true;\n  }\n\n  if (strcmp(pRequest->dbName, exceptDb) != 0) {\n    int i;\n    for (i = 0; i < pRequest->dbNum; i++) {\n      char *dbName = pRequest->dbNameList[i];\n      char *schema = strchr(dbName, '.');\n      if (schema != NULL) {\n        dbName = schema + 1;\n      }\n\n      if (strcmp(dbName, exceptDb) == 0) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 62.246151951296}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (strcasecmp(pRequest->primaryDb, exceptDb) == 0) {\n        return true;\n    }\n\n    for (int i = 0; i < pRequest->dbNum; ++i) {\n        char *dbName = pRequest->dbName[i];\n        char *schemaName = strchr(dbName, '.');\n        if (schemaName != NULL) {\n            dbName = schemaName + 1;\n        }\n        if (strcasecmp(dbName, exceptDb) == 0) {\n            return true;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 61.415732080991546}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest == NULL || exceptDb == NULL) {\n    return false;\n  }\n\n  // Check if the primary database of the request matches the exception database\n  if (strcmp(pRequest->db, exceptDb) == 0) {\n    return true;\n  }\n\n  // Iterate through the list of databases in the request, ignoring any schema prefixes\n  TAOS_ARRAY_FOR(pRequest->dbs, i) {\n    char *db = taosArrayGet(pRequest->dbs, i);\n    if (db != NULL) {\n      char *dbName = strchr(db, '.');\n      if (dbName != NULL) {\n        dbName++;\n      } else {\n        dbName = db;\n      }\n      if (strcmp(dbName, exceptDb) == 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 49.036859610958814}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  if (code == NEED_REDIRECT_ERROR) {\n    if (msgType != MSG_TYPE_RPC_RESPONSE && msgType != MSG_TYPE_RPC_RESPONSE_ERROR) {\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 30.979775736232675}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == NEED_REDIRECT_ERROR) {\n        if (msgType != tmsg_t::tmsg_t_RpcResponse &&\n            msgType != tmsg_t::tmsg_t_RpcResponse_redirect &&\n            msgType != tmsg_t::tmsg_t_RpcResponse_redirect_error &&\n            msgType != tmsg_t::tmsg_t_RpcResponse_redirect_error_no_reply) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 44.10911065201518}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == NEED_REDIRECT_ERROR) {\n        switch (msgType) {\n            case MSG_TYPE_CLIENT_RPC_REQUEST:\n            case MSG_TYPE_CLIENT_RPC_RESPONSE:\n            case MSG_TYPE_CLIENT_RPC_RESPONSE_ERROR:\n            case MSG_TYPE_CLIENT_RPC_RESPONSE_FAILURE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 40.38659219796177}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t  TAOS_LOG_INFO(\"stop all requests\");\n  TAOS_LOG_INFO(\"requests count: %d\", pRequests->nCount);\n\n  TAOS_HASH_ITERATE(pRequests, pRequest, pRequestId) {\n    TAOS_LOG_INFO(\"stop request: %s\", pRequestId);\n    if (pRequest->pQuery == NULL) {\n      continue;\n    }\n\n    // Stop the query associated with the request\n    taos_stop_query(pRequest->pQuery);\n\n    // Release the request\n    releaseRequest(pRequest);\n  }\n}", "CodeBleu_score": 31.51572886745411}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SHashIterate iter;\n  taos_stop_query(iter.pRequest);\n  iter.pRequest = NULL;\n  taos_releaseRequest(iter.pRequest);\n}", "CodeBleu_score": 12.448917278835639}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  if (pRequests == NULL) {\n    return;\n  }\n\n  TAOS_HASH_ITERATE(pRequests, pReq, pReq) {\n    TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n      TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n        TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n          TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n            TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n              TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n                TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n                  TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n                    TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n                      TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n                        TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n                          TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n                            TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n                              TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n                                TAOS_HASH_ITERATE(pReq->pRequests, pReq, pReq) {\n                                  T", "CodeBleu_score": 23.733057668170982}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t  if (!tscIsCrashReportEnabled()) {\n    return;\n  }\n\n  int clientStop = 1;\n  if (!atomic_val_compare_exchange_32(&g_clientStop, 1, 0)) {\n    logError(\"The crash report thread is already stopped.\");\n    return;\n  }\n\n  while (clientStop) {\n    atomic_load_32(&clientStop, &g_clientStop);\n  }\n}", "CodeBleu_score": 56.03136534862105}, {"code": "void tscStopCrashReport(){\n\t    if (!g_crashReport) {\n        return;\n    }\n\n    if (atomic_val_compare_exchange_32(&g_clientStop, 1, 0) == 0) {\n        taosError(\"The crash report thread is already stopped\");\n        return;\n    }\n\n    while (atomic_load_32(&g_clientStop) != 0) {\n        taosMsleep(100);\n    }\n}", "CodeBleu_score": 75.32158615623187}, {"code": "void tscStopCrashReport(){\n\t  if (!tscIsCrashReportEnabled()) {\n    return;\n  }\n\n  if (atomic_val_compare_exchange_32(&clientStop, 1, 0) == 0) {\n    tscPrint(\"The crash report thread is already stopped\n\");\n    return;\n  }\n\n  while (atomic_load_32(&clientStop) == 1) {\n    tscMsleep(100);\n  }\n}", "CodeBleu_score": 72.1449393360321}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  SViewMetaRsp *pViewMetaRsp = NULL;\n  SViewMeta *pViewMeta = NULL;\n  int32_t ret = 0;\n  int32_t i = 0;\n  int32_t numOfViewMeta = 0;\n  int32_t numOfCol = 0;\n  int32_t *pColNum = NULL;\n\n  if (value == NULL || valueLen <= 0 || pCatalog == NULL) {\n    tscDebug(\"hbProcessViewInfoRsp failed, invalid input param\");\n    return TAOS_RC_INVALID_ARGUMENT;\n  }\n\n  if ((pViewMetaRsp = tDeserializeSViewHbRsp(value, valueLen)) == NULL) {\n    tscDebug(\"hbProcessViewInfoRsp failed, deserialize failed\");\n    return TAOS_RC_INVALID_ARGUMENT;\n  }\n\n  numOfViewMeta = taosArrayGetSize(pViewMetaRsp->pViewMetaArray);\n  if (numOfViewMeta <= 0) {\n    tFreeSViewMetaRsp(pViewMetaRsp);\n    tscDebug(\"hbProcessViewInfoRsp failed, invalid view meta array\");\n    return TAOS_RC_INVALID_ARGUMENT;\n  }\n\n  pColNum = (int32_t *)taosMemoryMalloc(numOfViewMeta * sizeof(int32_t));\n  if (pColNum == NULL) {\n    tFreeSViewMetaRsp(pViewMetaRsp);\n    tscDebug(\"hbProcessViewInfoRsp failed, malloc failed\");\n    return TAOS_RC_INTERNAL_ERROR;\n  }\n\n  for (i = 0; i < numOfViewMeta; ++i) {\n    pViewMeta = taosArrayGetP(pViewMetaRsp->pViewMetaArray, i);\n    if (pViewMeta == NULL) {\n      tFreeSViewMetaRsp(pViewMetaRsp);\n      taosMemoryFree(pColNum);\n      tscDebug(\"hbProcessViewInfoRsp failed, invalid view meta\");", "CodeBleu_score": 34.883906046649706}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t  i;\n  int32_t  rc;\n  TAOS_ARRAY *pArray = NULL;\n  TAOS_ARRAY *pViewArray = NULL;\n  TAOS_ARRAY *pMetaArray = NULL;\n  TAOS_ARRAY *pViewMetaArray = NULL;\n  TAOS_ARRAY *pColMetaArray = NULL;\n  TAOS_ARRAY *pColNameArray = NULL;\n  TAOS_ARRAY *pColTypeArray = NULL;\n  TAOS_ARRAY *pColLenArray = NULL;\n  TAOS_ARRAY *pColDecimalArray = NULL;\n  TAOS_ARRAY *pColTimeArray = NULL;\n  TAOS_ARRAY *pColScaleArray = NULL;\n  TAOS_ARRAY *pColIsKeyArray = NULL;\n  TAOS_ARRAY *pColIsSetArray = NULL;\n  TAOS_ARRAY *pColIsAutoIncArray = NULL;\n  TAOS_ARRAY *pColIsPrimaryKeyArray = NULL;\n  TAOS_ARRAY *pColIsNullArray = NULL;\n  TAOS_ARRAY *pColIsDefaultArray = NULL;\n  TAOS_ARRAY *pColDefaultValueArray = NULL;\n  TAOS_ARRAY *pColIsNotNullArray = NULL;\n  TAOS_ARRAY *pColIsAutoIncArray2 = NULL;\n  TAOS_ARRAY *pColIsAutoIncArray3 = NULL;\n  TAOS_ARRAY *pColIsAutoIncArray4 = NULL;\n  TAOS_ARRAY *pColIsAutoIncArray5 = NULL;\n  TAOS_ARRAY *pColIsAutoIncArray6 = NULL;\n  TAOS_ARRAY *pColIsAutoIncArray7 = NULL;\n  TAOS_ARRAY *pColIsAutoIncArray8 = NULL;\n  TAOS_ARRAY *pColIsAutoIncArray9 = NULL;\n  TAOS_ARRAY *pColIsAutoIncArray10 = NULL", "CodeBleu_score": 7.673392796569277}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t ret = 0;\n  TAOS_ARRAY *pArray = NULL;\n  TAOS_SViewMeta *pViewMeta = NULL;\n  TAOS_SViewMeta *pViewMetaTmp = NULL;\n  TAOS_SViewMeta *pViewMetaTmp2 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp3 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp4 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp5 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp6 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp7 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp8 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp9 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp10 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp11 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp12 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp13 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp14 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp15 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp16 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp17 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp18 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp19 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp20 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp21 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp22 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp23 = NULL;\n  TAOS_SViewMeta *pViewMetaTmp24 = NULL;\n ", "CodeBleu_score": 9.709046167405084}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3UInt64 contentLength = S3GetContentLength(properties);\n    if (contentLength > 0) {\n        S3PutContentLength(callbackData, contentLength);\n    } else {\n        S3PutContentLength(callbackData, 0);\n    }\n    return S3StatusOK;\n}", "CodeBleu_score": 52.71270941411448}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3SizeType contentLength = 0;\n    if (properties->responseContentLength > 0) {\n        contentLength = properties->responseContentLength;\n    }\n    S3ResponsePropertiesCallbackData *callbackDataPtr = (S3ResponsePropertiesCallbackData *)callbackData;\n    callbackDataPtr->contentLength = contentLength;\n    return S3StatusOK;\n}", "CodeBleu_score": 52.8085143030109}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3UInt64 contentLength = 0;\n    if (properties->contentLength > 0) {\n        contentLength = properties->contentLength;\n    }\n    *(S3UInt64 *)callbackData = contentLength;\n    return S3StatusOK;\n}", "CodeBleu_score": 63.95899161431884}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t  char *cmd;\n  int ret;\n  char *checkpointBackupDir = \"/var/lib/taos/checkpoint_backup\";\n  char *rsyncdConfFile = \"/etc/rsyncd.conf\";\n\n  if (taosMulMkDir(checkpointBackupDir, 0777) < 0) {\n    uError(\"Failed to create checkpoint backup directory: %s\", checkpointBackupDir);\n    return;\n  }\n\n  removeEmptyDir(checkpointBackupDir);\n\n  if (generateConfigFile(checkpointBackupDir, rsyncdConfFile) < 0) {\n    uError(\"Failed to generate Rsync configuration file: %s\", rsyncdConfFile);\n    return;\n  }\n\n  snprintf(cmd, 1024, \"rsync --daemon --config=%s\", rsyncdConfFile);\n  ret = system(cmd);\n  if (ret < 0) {\n    uError(\"Failed to start Rsync server with command: %s\", cmd);\n  } else {\n    uDebug(\"Rsync server started successfully with command: %s\", cmd);\n  }\n}", "CodeBleu_score": 31.817390879856283}, {"code": "void startRsync(){\n\t    // Initialize the checkpoint backup directory and log an error if it fails\n    if (taosMulMkDir(TSDB_PATH, TSDB_PATH_LEN, TSDB_DIR_BACKUP, TSDB_DIR_BACKUP_LEN) != 0) {\n        uError(\"create %s failed\", TSDB_DIR_BACKUP);\n        return;\n    }\n\n    // Remove empty directories and generate an Rsync configuration file\n    removeEmptyDir(TSDB_PATH, TSDB_DIR_BACKUP, TSDB_DIR_BACKUP_LEN, TSDB_PATH_LEN);\n    if (generateConfigFile(TSDB_PATH, TSDB_PATH_LEN, TSDB_DIR_BACKUP, TSDB_DIR_BACKUP_LEN, TSDB_DIR_BACKUP_CONF, TSDB_DIR_BACKUP_CONF_LEN) != 0) {\n        uError(\"generate %s failed\", TSDB_DIR_BACKUP_CONF);\n        return;\n    }\n\n    // Construct and execute the Rsync daemon command\n    char cmd[256];\n    snprintf(cmd, sizeof(cmd), \"rsync --daemon --config=%s --port=%d\", TSDB_DIR_BACKUP_CONF, TSDB_BACKUP_PORT);\n    int ret = system(cmd);\n\n    // Log whether the Rsync server started successfully or if it encountered an error\n    if (ret == 0) {\n        uDebug(\"rsync server started successfully\");\n    } else {\n        uError(\"failed to start rsync server\");\n    }\n}", "CodeBleu_score": 46.619909288469884}, {"code": "void startRsync(){\n\t  char* backupDir = \"/var/lib/taos/backup\";\n  char* rsyncConfigFile = \"/var/lib/taos/backup/rsyncd.conf\";\n  int port = 873;\n\n  // Create the checkpoint backup directory if it doesn't exist\n  if (taosMulMkDir(backupDir, 0755) < 0) {\n    uError(\"Failed to create checkpoint backup directory %s\", backupDir);\n    return;\n  }\n\n  // Remove empty directories\n  removeEmptyDir(backupDir);\n\n  // Generate the Rsync configuration file\n  if (generateConfigFile(rsyncConfigFile) < 0) {\n    uError(\"Failed to generate Rsync configuration file\");\n    return;\n  }\n\n  // Construct the command to start the Rsync daemon\n  char cmd[256];\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --port=%d --config=%s\", port, rsyncConfigFile);\n\n  // Execute the command to start the Rsync daemon\n  int ret = system(cmd);\n  if (ret == 0) {\n    uDebug(\"Rsync server started successfully\");\n  } else {\n    uError(\"Failed to start Rsync server\");\n  }\n}", "CodeBleu_score": 32.593023198383285}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found.\");\n    }\n}", "CodeBleu_score": 81.55857841698321}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n    dispatcher.getExecutor().shutdownNow();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 68.34446903892048}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n        dispatchers.remove(dispatcherId);\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not registered\");\n    }\n}", "CodeBleu_score": 73.93084970406073}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    getChildren(parent).stream().filter(childFilter).forEach(child -> {\n        if (get(child) == null) {\n            warn(\"Child actor \" + child + \" is not registered\");\n        } else {\n            tell(child, msg, highPriority);\n        }\n    });\n}", "CodeBleu_score": 37.64251510309304}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    // Retrieve the children of the parent actor from the map\n    List<TbActorId> children = getChildren(parent);\n    // Filter the children based on the provided predicate\n    List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n    // Send the message to each filtered child actor\n    filteredChildren.forEach(child -> {\n        try {\n            if (highPriority) {\n                tell(child, msg, true);\n            } else {\n                tell(child, msg);\n            }\n        } catch (Exception e) {\n            warn(parent, \"Failed to send message to child actor: \" + child.getActorId() + \": \" + e.getMessage());\n        }\n    });\n}", "CodeBleu_score": 48.492432546144194}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    getChildren(parent).stream().filter(childFilter).forEach(child -> {\n        if (!isRegistered(child)) {\n            warn(\"Child actor {} is not registered.\", child);\n            return;\n        }\n        if (highPriority) {\n            tell(child, msg, true);\n        } else {\n            tell(child, msg);\n        }\n    });\n}", "CodeBleu_score": 39.612593767187434}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n        if (destructionInProgress) {\n            if (highPriority) {\n                tryProcessQueue();\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue();\n        }\n    } else {\n        if (destructionInProgress) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue();\n        }\n    }\n}", "CodeBleu_score": 57.68645490287453}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (msg == null) {\n        return;\n    }\n\n    if (isDestructionInProgress() && msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n        if (reinitializeOnFailure) {\n            try {\n                initActor();\n            } catch (Throwable e) {\n                log.error(\"Failed to reinitialize actor: \" + e.getMessage(), e);\n            }\n        }\n        return;\n    }\n\n    msg.onActorStopped(this);\n\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n\n    tryProcessQueue();\n}", "CodeBleu_score": 51.44897260761787}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n        if (destructionInProgress) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue();\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n        }\n    } else {\n        if (destructionInProgress) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue();\n        }\n    }\n}", "CodeBleu_score": 56.750851544494964}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    // Process high-priority queue\n    processQueue(highPriorityQueue, highPriorityQueueSize, highPriorityThroughput)\n\n    // Process normal priority queue\n    processQueue(normalPriorityQueue, normalPriorityQueueSize, normalPriorityThroughput)\n}", "CodeBleu_score": 1.5927651819577178}, {"code": "private void processMailbox(){\n\t    try {\n        while (getStatus() == Status.ACTIVE) {\n            if (getHighPriorityQueue().size() > 0) {\n                processMessage(getHighPriorityQueue().poll());\n            } else if (getNormalPriorityQueue().size() > 0) {\n                processMessage(getNormalPriorityQueue().poll());\n            } else {\n                setStatus(Status.FREE);\n                getExecutor().schedule(this, 0, TimeUnit.MILLISECONDS);\n                return;\n            }\n        }\n    } catch (InitializationException e) {\n        setStopReason(e);\n        destroy();\n    } catch (Exception e) {\n        log.error(\"Processing message failed\", e);\n        if (getProcessFailureStrategy() == ProcessFailureStrategy.STOP) {\n            setStopReason(e);\n            destroy();\n        }\n    }\n}", "CodeBleu_score": 20.706062362335093}, {"code": "private void processMailbox(){\n\t    while (true) {\n        if (isStop()) {\n            setStatus(ActorStatus.FREE)\n            scheduleProcessQueue()\n            return\n        }\n        if (getHighPriorityQueue().isEmpty()) {\n            if (getNormalPriorityQueue().isEmpty()) {\n                setStatus(ActorStatus.FREE)\n                scheduleProcessQueue()\n                return\n            }\n            if (getNormalPriorityQueue().size() > 0) {\n                processMessage(getNormalPriorityQueue().peek())\n            }\n        } else {\n            processMessage(getHighPriorityQueue().peek())\n        }\n    }\n}", "CodeBleu_score": 12.642729760888253}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (getStopReason() == null) {\n        setStopReason(cause);\n    }\n    getDispatcher().getExecutor().execute(() -> {\n        setReadiness(Actor.Readiness.NOT_READY);\n        try {\n            getActor().destroy(getStopReason(), getStopCause());\n        } catch (Throwable t) {\n            getLog().warn(\"Exception thrown during actor destruction\", t);\n        }\n        getActor().onDestroy();\n        getActor().notifyStopped(getStopReason(), getStopCause());\n    });\n}", "CodeBleu_score": 31.296597302136377}, {"code": "public void destroy(Throwable cause){\n\t    if (this.stopReason == null) {\n        this.stopReason = cause;\n    }\n    this.markDestructionInProgress();\n    this.dispatcher.getExecutor().execute(() -> {\n        try {\n            this.setReadiness(ActorReadiness.NOT_READY);\n            this.destroy(this.stopReason, cause);\n            this.notifyQueuedMessages(this.stopReason, cause);\n        } catch (Exception e) {\n            this.log.warn(\"Exception during actor destruction\", e);\n        }\n    });\n}", "CodeBleu_score": 30.708590687625616}, {"code": "public void destroy(Throwable cause){\n\t    if (getStopReason() == null) {\n        setStopReason(cause);\n    }\n    if (isDestroyed()) {\n        return;\n    }\n    setDestroyed(true);\n    getExecutor().execute(() -> {\n        try {\n            if (getOnDestroy() != null) {\n                getOnDestroy().invoke(this, getStopReason());\n            }\n        } catch (Throwable e) {\n            warn(\"Failed to execute onDestroy callback\", e);\n        }\n    });\n}", "CodeBleu_score": 25.82205127877173}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    LimitLevelEntityName limitLevelEntityName = getLimitLevelEntityName(api, level);\n    Map<LimitLevelEntityName, LimitLevel> limitLevels = profile.getLimitLevels();\n    LimitLevel limitLevel = limitLevels.get(limitLevelEntityName);\n    if (limitLevel == null) {\n        return true;\n    }\n    return checkRateLimit(api, tenantId, limitLevel);\n}", "CodeBleu_score": 39.14916327829706}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    LimitLevelEntityName limitLevelEntityName = api.getLimitLevelEntityName();\n    Map<LimitLevelEntityName, LimitLevel> limitLevelMap = profile.getLimitLevelMap();\n    LimitLevel limitLevel = limitLevelMap.get(limitLevelEntityName);\n    if (limitLevel == null) {\n        return true;\n    }\n    return checkRateLimit(limitLevel, level);\n}", "CodeBleu_score": 36.998931496283184}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitResult rateLimitResult = rateLimit.checkLimit(level);\n    if (rateLimitResult.isLimitExceeded()) {\n        processRateLimitNotification(tenantId, api, rateLimitResult);\n    }\n    return !rateLimitResult.isLimitExceeded();\n}", "CodeBleu_score": 45.016586944446615}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = currentTimeMillis() - getInactivityTimeout();\n    for (Map.Entry<DTLSClientSession, Long> entry : getSessions().entrySet()) {\n        if (entry.getValue() < expirationTime) {\n            remove(entry.getKey());\n            trace(\"Removed DTLS session: \" + entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 44.37541555184288}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - getInactivityTimeout();\n    for (Map.Entry<DtlsSessionId, DtlsSession> entry : getDtlsSessions().entrySet()) {\n        DtlsSession session = entry.getValue();\n        long lastActivityTime = session.getLastActivityTime();\n        if (lastActivityTime < expirationTime) {\n            getDtlsSessions().remove(entry.getKey());\n            getLogger().trace(\"Removed DTLS session {}\", session);\n        }\n    }\n}", "CodeBleu_score": 40.24545311883352}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = currentTimeMillis() - getInactivityTimeout();\n    trace(\"Evicting DTLS sessions with last activity time before \" + expirationTime);\n    for (Map.Entry<DTLSClientSession, Long> entry : getSessions().entrySet()) {\n        if (entry.getValue() < expirationTime) {\n            remove(entry.getKey());\n            trace(\"Removed DTLS session with last activity time \" + entry.getValue());\n        }\n    }\n}", "CodeBleu_score": 48.27278897940314}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return emptyList();\n    }\n    return timeseries.entrySet().stream().flatMap(entry -> {\n        List<JsonNode> values = entry.getValue();\n        return values.stream().map(value -> {\n            long timestamp = toLong(value.get(\"timestamp\"));\n            double value = toDouble(value.get(\"value\"));\n            return new TsKvEntry(entry.getKey(), timestamp, value);\n        });\n    }).collect(toList());\n}", "CodeBleu_score": 41.247709485917625}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return emptyList();\n    }\n    return timeseries.entrySet().stream().flatMap(entry -> {\n        List<JsonNode> values = entry.getValue();\n        if (values.isEmpty()) {\n            return emptyList().stream();\n        }\n        return values.stream().map(value -> {\n            String key = entry.getKey();\n            String valueStr = value.toString();\n            return new TsKvEntry(key, valueStr);\n        });\n    }).collect(toList());\n}", "CodeBleu_score": 37.225040342283}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return emptyList();\n    }\n    return timeseries.entrySet().stream().map(entry -> {\n        List<TsKvEntry> list = new ArrayList<>();\n        entry.getValue().forEach(value -> {\n            list.add(new TsKvEntry(entry.getKey(), parseValue(value)));\n        });\n        return list;\n    }).flatMap(List::stream).collect(Collectors.toList());\n}", "CodeBleu_score": 31.28702014117185}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\"refresh_token\", currentTokenInfo.getRefreshToken());\n    HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(request, new HttpHeaders());\n    ResponseEntity<Map> response = restTemplate.postForEntity(authenticationEndpoint, requestEntity, Map.class);\n    currentTokenInfo.setTimestamp(currentTimeMillis());\n    currentTokenInfo.setTokenInfo(response.getBody());\n}", "CodeBleu_score": 49.102995540413005}, {"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\"refresh_token\", tokenInfo.getRefreshToken());\n\n    ResponseEntity<Map> response = restTemplate.postForEntity(authUrl, request, Map.class);\n    tokenInfo.setTimestamp(currentTimeMillis());\n    tokenInfo.setToken(response.getBody().get(\"access_token\").toString());\n}", "CodeBleu_score": 47.73905063968981}, {"code": "public void refreshToken(){\n\t    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refresh_token\", tokenInfo.getRefreshToken());\n    HttpEntity<Map<String, String>> request = new HttpEntity<>(requestMap);\n    ResponseEntity<Map> response = restTemplate.postForEntity(authEndpoint, request, Map.class);\n    tokenInfo.setTimestamp(currentTimeMillis());\n    tokenInfo.setTokenInfo(response.getBody());\n}", "CodeBleu_score": 50.808000276722495}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t    long currentTimeMillis = System.currentTimeMillis();\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n    ResponseEntity<Map> response = restTemplate.postForEntity(authUrl + \"/login\", loginRequest, Map.class);\n    setTokenInfo(response.getBody(), currentTimeMillis);\n}", "CodeBleu_score": 78.06147906872776}, {"code": " private void doLogin(){\n\t    long timestamp = System.currentTimeMillis();\n    Map<String, String> loginRequest = Map.of(\"username\", \"admin\", \"password\", \"admin\");\n    ResponseEntity<Map> response = restTemplate.postForEntity(authUrl + \"/login\", loginRequest, Map.class);\n    tokenInfo.setToken(response.getBody().get(\"token\").toString());\n    tokenInfo.setTimestamp(timestamp);\n}", "CodeBleu_score": 55.257984321363296}, {"code": " private void doLogin(){\n\t        long currentTimeMillis = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", \"admin\");\n        loginRequest.put(\"password\", \"admin\");\n\n        ResponseEntity<Map> response = restTemplate.postForEntity(\n                \"/api/auth/login\", loginRequest, Map.class);\n\n        Map<String, String> tokenInfo = response.getBody();\n        tokenInfo.put(\"timestamp\", String.valueOf(currentTimeMillis));\n        this.setTokenInfo(tokenInfo);\n    }", "CodeBleu_score": 61.607000280891455}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> responseEntity = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(responseEntity.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (HttpStatusCodeException e) {\n        throw e;\n    }\n}", "CodeBleu_score": 55.49348000316723}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> responseEntity = restTemplate.getForEntity(\n                \"/api/device/{deviceId}\",\n                Device.class,\n                deviceId.getId()\n        );\n\n        return Optional.ofNullable(responseEntity.getBody());\n    } catch (HttpClientErrorException.NotFound ex) {\n        return Optional.empty();\n    } catch (Exception ex) {\n        throw ex;\n    }\n}", "CodeBleu_score": 56.19638271610465}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        if (response.getStatusCode() == HttpStatus.OK) {\n            return Optional.of(response.getBody());\n        } else if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw new RuntimeException(\"Unexpected HTTP status code: \" + response.getStatusCode());\n        }\n    } catch (HttpStatusCodeException e) {\n        throw e;\n    }\n}", "CodeBleu_score": 60.23080886712179}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n        ResponseEntity<Device> response = restTemplate.postForEntity(deviceWithCredentialsEndpoint, request, Device.class);\n        if (response.getStatusCode() == HttpStatus.OK) {\n            return Optional.of(response.getBody());\n        } else if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw new RuntimeException(\"Unexpected status code: \" + response.getStatusCode());\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(\"Failed to save device with credentials\", e);\n    }\n}", "CodeBleu_score": 58.41533344068737}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n        ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (Exception e) {\n        throw e;\n    }\n}", "CodeBleu_score": 55.32072609459189}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity<DeviceCredentials> request = new HttpEntity<>(credentials, headers);\n        ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class);\n        if (response.getStatusCode() == HttpStatus.CREATED) {\n            return Optional.of(response.getBody());\n        } else {\n            return Optional.empty();\n        }\n    } catch (HttpStatusCodeException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 57.666673074196616}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t  if (arguments.length === 1) {\n    Board.map(this, 'brightness', addr, val);\n  } else {\n    this.send(addr, 'brightness', val);\n  }\n  return this;\n}", "CodeBleu_score": 52.78249884416333}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n        this.send(Board.map(val, 0, 100, 0, 15));\n    } else if (arguments.length === 2) {\n        this.send(addr, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n}", "CodeBleu_score": 61.2107136960787}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n        this.each(function(device) {\n            device.brightness(val);\n        });\n    } else {\n        this.send(addr, [val]);\n    }\n    return this;\n}", "CodeBleu_score": 42.32554793516598}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t  Object.getOwnPropertyNames(this).forEach(function(key) {\n    if (typeof this[key] === 'function') {\n      this[key] = this[key].bind(this, addr);\n    }\n  }.bind(this));\n  Object.keys(LedControl.prototype).forEach(function(key) {\n    if (typeof this[key] === 'function') {\n      this[key] = this[key].bind(this, addr);\n    }\n  }.bind(this));\n  return this;\n}", "CodeBleu_score": 38.7047893670466}, {"code": "device(addr){\n\t  Object.getOwnPropertyNames(this).forEach(function(key) {\n    if (typeof this[key] === 'function') {\n      this[key] = this[key].bind(this, addr);\n    }\n  }.bind(this));\n\n  Object.keys(LedControl.prototype).forEach(function(key) {\n    if (typeof this[key] === 'function') {\n      this[key] = this[key].bind(this, addr);\n    }\n  }.bind(this));\n\n  return this;\n}", "CodeBleu_score": 38.7047893670466}, {"code": "device(addr){\n\t    var obj = Object.create(LedControl.prototype);\n    Object.getOwnPropertyNames(this).forEach(function(key) {\n        obj[key] = this[key].bind(null, addr);\n    }, this);\n    return obj;\n}", "CodeBleu_score": 31.15404861138751}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = function (duration, callback) {\n            const promises = [];\n            for (let i = 0; i < this.length; i++) {\n                promises.push(new Promise(resolve => {\n                    this[i][method](duration, resolve);\n                }));\n            }\n            Promise.all(promises).then(callback);\n        };\n    });\n}", "CodeBleu_score": 34.90674746711023}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[method] = function (duration, callback) {\n      const promises = this.map(item => item[method](duration, callback));\n      Promise.all(promises).then(callback);\n    };\n  });\n}", "CodeBleu_score": 26.120383648711826}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = (duration, callback) => {\n            const promises = this[i][method]()\n            if (duration) {\n                setTimeout(() => {\n                    Promise.all(promises).then(callback)\n                }, duration)\n            } else {\n                Promise.all(promises).then(callback)\n            }\n        }\n    })\n}", "CodeBleu_score": 35.67222235632879}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t    var input = '';\n    this.io.serialRead(this.port, function(data) {\n        input += data;\n        var sentences = input.split(\"\\r\n\");\n        input = sentences.pop();\n        for (var i = 0; i < sentences.length; i++) {\n            this.parseNmeaSentence(sentences[i]);\n        }\n    }.bind(this));\n}", "CodeBleu_score": 34.7235702141926}, {"code": "listen(){\n\t  var input = \"\";\n  this.io.serialRead(this.serialPort, (data) => {\n    input += data;\n    var sentences = input.split(\"\\r\n\");\n    input = sentences.pop();\n    for (var i = 0; i < sentences.length; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n  });\n}", "CodeBleu_score": 34.025293869868754}, {"code": "listen(){\n\t    let input = \"\";\n    this.io.serialRead((data) => {\n        input += data;\n        const sentences = input.split(\"\\r\n\");\n        input = sentences.pop();\n        for (const sentence of sentences) {\n            this.parseNmeaSentence(sentence);\n        }\n    });\n}", "CodeBleu_score": 29.80668623055634}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\n\tint channels = adc_ad559x_get_channels(dev);\n\n\tuint32_t sample_size = adc_ad559x_get_sample_size(dev);\n\n\tuint32_t buffer_size = channels * sample_size;\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.46079985008413}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tint ret;\n\tuint16_t n_channels;\n\tuint16_t data_size;\n\tuint16_t n_samples;\n\n\tret = adc_ad559x_get_n_channels(dev, &n_channels);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata_size = sequence->resolution / 8;\n\tn_samples = sequence->length / n_channels;\n\n\tif (data_size * n_channels * n_samples > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.25047413967834}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t sample_size = adc_ad559x_get_sample_size(data, sequence);\n\n\tdata->nbr_active_channels = adc_ad559x_get_nbr_active_channels(dev, sequence);\n\n\tif (data->nbr_active_channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sample_size * data->nbr_active_channels > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 35.97709264026195}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    struct adc_ad559x_data *data = dev->data;\n    struct adc_ad559x_config *config = dev->config;\n    uint32_t channel_mask = (1 << sequence->channels) - 1;\n    uint32_t resolution = (1 << sequence->resolution);\n    uint32_t expected_resolution = (1 << config->resolution);\n    int ret;\n\n    if (channel_mask != (channel_mask & data->channel_mask)) {\n        LOG_ERR(\"Invalid channel\");\n        return -EINVAL;\n    }\n\n    if (resolution != expected_resolution) {\n        LOG_ERR(\"Invalid resolution\");\n        return -EINVAL;\n    }\n\n    ret = adc_ad559x_validate_buffer_size(dev, sequence);\n    if (ret) {\n        return ret;\n    }\n\n    data->buffer = sequence->buffer;\n    data->buffer_size = sequence->buffer_size;\n    data->channels = sequence->channels;\n    data->resolution = sequence->resolution;\n    data->sample_count = sequence->length;\n\n    adc_context_start_read(dev);\n    adc_context_wait_for_completion(dev);\n\n    return 0;\n}", "CodeBleu_score": 56.64018736533669}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    struct adc_ad559x_data *data = dev->data;\n    int ret = 0;\n    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int aa;\n    int ab;\n    int ac;\n    int ad;\n    int ae;\n    int af;\n    int ag;\n    int ah;\n    int ai;\n    int aj;\n    int ak;\n    int al;\n    int am;\n    int an;\n    int ao;\n    int ap;\n    int aq;\n    int ar;\n    int as;\n    int at;\n    int au;\n    int av;\n    int aw;\n    int ax;\n    int ay;\n    int az;\n    int ba;\n    int bb;\n    int bc;\n    int bd;\n    int be;\n    int bf;\n    int bg;\n    int bh;\n    int bi;\n    int bj;\n    int bk;\n    int bl;\n    int bm;\n    int bn;\n    int bo;\n    int bp;\n    int bq;\n    int br;\n    int bs;\n    int bt;\n    int bu;\n    int bv;\n    int bw;\n    int bx;\n    int by;\n    int bz;\n    int ca;\n    int cb;\n    int cc;\n    int cd;\n    int ce;\n    int cf;\n    int cg;\n    int ch;\n    int ci;\n    int cj;\n    int ck;\n    int cl;\n    int cm;\n    int cn;\n    int co;\n    int cp;\n    int cq;\n    int cr;\n    int cs;\n    int ct;\n    int cu;", "CodeBleu_score": 13.967221202987846}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    struct adc_ad559x_data *data = dev->data;\n    int ret;\n    uint8_t channels_mask;\n    uint8_t resolution_mask;\n    uint8_t resolution;\n    uint8_t channels;\n    uint8_t channels_mask_adc;\n    uint8_t channels_mask_adc_valid;\n    uint8_t channels_mask_adc_valid_all;\n    uint8_t channels_mask_adc_valid_all_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid_valid_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid_valid_valid_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid_valid_valid_valid_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid_valid_valid_valid_valid_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid_valid_valid_valid_valid_valid_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid_valid_valid_valid_valid_valid_valid_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid_valid_valid_valid_valid_valid_valid_valid_valid_valid;\n    uint8_t channels_mask_adc_valid_all_valid_valid_valid_valid_valid_valid_valid_valid_valid_valid_valid_valid_valid;\n    uint", "CodeBleu_score": 14.69750657750323}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    adc_data_t *data = ctx->data;\n    adc_channel_t *channels = ctx->channels;\n    adc_channel_t *channels_end = channels + ctx->channel_count;\n    int16_t *repeat_buffer = ctx->repeat_buffer;\n    int16_t *repeat_buffer_end = repeat_buffer + ctx->repeat_buffer_size;\n\n    /* Set the channels to be sampled. */\n    for (adc_channel_t *channel = channels; channel < channels_end; channel++) {\n        adc_channel_enable(data, *channel);\n    }\n\n    /* Initialize the repeat buffer. */\n    for (int16_t *sample = repeat_buffer; sample < repeat_buffer_end; sample++) {\n        *sample = 0;\n    }\n\n    /* Release the semaphore to signal the start of sampling. */\n    k_sem_give(&ctx->sampling_sem);\n}", "CodeBleu_score": 28.406746016861938}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t  struct adc_data *data = ctx->data;\n  struct adc_config *cfg = ctx->cfg;\n  uint32_t channels = cfg->channels;\n  uint32_t buffer_size = cfg->buffer_size;\n  uint32_t buffer_size_bytes = buffer_size * sizeof(uint16_t);\n  uint32_t repeat_buffer_size = cfg->repeat_buffer_size;\n  uint32_t repeat_buffer_size_bytes = repeat_buffer_size * sizeof(uint16_t);\n  uint32_t repeat_buffer_offset = buffer_size - repeat_buffer_size;\n  uint32_t repeat_buffer_offset_bytes = repeat_buffer_offset * sizeof(uint16_t);\n  uint32_t repeat_buffer_offset_bytes_aligned = repeat_buffer_offset_bytes + (sizeof(uint32_t) - 1);\n  uint32_t repeat_buffer_offset_bytes_aligned_mask = repeat_buffer_offset_bytes_aligned - 1;\n  uint32_t repeat_buffer_offset_bytes_aligned_mask_neg = ~repeat_buffer_offset_bytes_aligned_mask;\n  uint32_t repeat_buffer_offset_bytes_aligned_mask_neg_neg = ~repeat_buffer_offset_bytes_aligned_mask_neg;\n  uint32_t repeat_buffer_offset_bytes_aligned_mask_neg_neg_neg = ~repeat_buffer_offset_bytes_aligned_mask_neg_neg;\n  uint32_t repeat_buffer_offset_bytes_aligned_mask_neg_neg_neg_neg = ~repeat_buffer_offset_bytes_aligned_mask_neg_neg_neg;\n  uint32_t repeat_buffer_offset_bytes_aligned_mask_neg_neg_neg_neg_neg = ~repeat_buffer_offset_bytes_aligned_mask_neg_neg_neg_neg;\n  uint32_t repeat_buffer_offset_bytes_aligned_mask_neg_neg_neg_neg_neg_neg = ~repeat_buffer_offset_", "CodeBleu_score": 13.82928077439043}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = ctx->data;\n\n    /* Set channels to be sampled */\n    adc_set_channels(data, ctx->channels, ctx->channels_num);\n\n    /* Initialize repeat buffer with data buffer */\n    adc_init_repeat_buffer(data, ctx->buffer, ctx->buffer_size);\n\n    /* Release semaphore to signal the start of sampling */\n    k_sem_give(&data->sampling_sem);\n}", "CodeBleu_score": 45.946153046146556}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_data_container *data_container = &ctx->data_container;\n    if (repeat_sampling) {\n        data_container->buffer_pointer = data_container->repeat_buffer;\n    }\n}", "CodeBleu_score": 51.62442001625427}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_data_container *data_container = &ctx->data_container;\n    if (repeat_sampling) {\n        data_container->buffer_pointer = data_container->repeat_buffer;\n    } else {\n        data_container->buffer_pointer = data_container->buffer;\n    }\n}", "CodeBleu_score": 46.854481266159134}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->data_container = &ctx->repeat_buffer;\n\t}\n}", "CodeBleu_score": 30.628215677687876}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    int err;\n    while (!k_sem_take(&data->sem, K_FOREVER)) {\n        for (int i = 0; i < data->active_channels_count; i++) {\n            uint16_t value;\n            err = adc_ad559x_read_channel(data, data->active_channels[i], &value);\n            if (err) {\n                LOG_ERR(\"Failed to read channel %d\", data->active_channels[i]);\n                adc_context_complete(data->context);\n                return;\n            }\n            data->buffer[i] = value;\n        }\n        adc_context_on_sampling_done(data->context);\n    }\n}", "CodeBleu_score": 40.64103714207398}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\n    while (1) {\n\n        k_sem_take(&data->sem, K_FOREVER);\n\n        for (int i = 0; i < data->active_channels; i++) {\n\n            int channel = data->active_channels_list[i];\n            int value = adc_ad559x_read_channel(data, channel);\n\n            if (value < 0) {\n                LOG_ERR(\"Failed to read from channel %d\", channel);\n                adc_context_complete(data->context);\n                return;\n            }\n\n            data->buffer[channel] = value;\n        }\n\n        adc_context_on_sampling_done(data->context);\n    }\n}", "CodeBleu_score": 39.97179615288998}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t  int i, j, ret;\n  u32_t value;\n  u8_t buf[ADC_AD559X_BUF_LEN];\n  struct adc_context *ctx;\n\n  while (1) {\n    /* Wait for the semaphore to be released */\n    k_sem_take(&data->sem, K_FOREVER);\n\n    /* Iterate through the active channels */\n    for (i = 0; i < ADC_AD559X_CHANNELS; i++) {\n      if (data->channels[i].active) {\n        /* Read the ADC value */\n        ret = adc_ad559x_read_channel(data, i, &value);\n        if (ret < 0) {\n          LOG_ERR(\"Failed to read channel %d\", i);\n          adc_context_complete(data->channels[i].ctx);\n          continue;\n        }\n\n        /* Store the result in the buffer */\n        buf[i] = value;\n      }\n    }\n\n    /* Signal that the sampling is done */\n    adc_context_on_sampling_done(data->ctx, buf);\n  }\n}", "CodeBleu_score": 46.04528174734822}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    uint8_t reg_val;\n    int ret;\n\n    /* Wait for the device to be ready for data reading */\n    k_sleep(K_USEC(ADS1112_RDY_TIME));\n\n    /* Read the configuration register to check the status */\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n    if (ret) {\n        return ret;\n    }\n\n    /* If the device is not ready, repeatedly sleep for 100 microseconds and check the status again */\n    while (!(reg_val & ADS1112_REG_CONFIG_RDY)) {\n        k_sleep(K_USEC(100));\n        ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n        if (ret) {\n            return ret;\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 53.37125637497755}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    int err;\n    uint8_t reg;\n    uint32_t ready_time;\n\n    ready_time = sys_clock_hw_cycles_per_us() * CONFIG_ADS1112_READY_TIME_US;\n\n    while (1) {\n        err = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n        if (err) {\n            return err;\n        }\n\n        if (!(reg & ADS1112_REG_CONFIG_OS)) {\n            k_sleep(ready_time);\n            continue;\n        }\n\n        return 0;\n    }\n}", "CodeBleu_score": 41.957381900801316}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    struct ads1112_data *data = dev->data;\n    int ret;\n\n    /* Wait for the device to be ready for data reading. */\n    k_sleep(data->ready_time);\n\n    /* Read the configuration register to check the status. */\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &data->config);\n    if (ret) {\n        return ret;\n    }\n\n    /* If the device is not ready, repeatedly sleep for 100 microseconds and check the status again. */\n    while (!(data->config & ADS1112_CONFIG_OS_MASK)) {\n        k_sleep(K_USEC(100));\n        ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &data->config);\n        if (ret) {\n            return ret;\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 54.69327505926644}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t  int buffer_size;\n  int required_buffer_size;\n  int samplings;\n  int extra_samplings;\n  int error_code;\n  int extra_samplings_for_options;\n  int extra_samplings_for_options_and_extra_samplings;\n  int extra_samplings_for_options_and_extra_samplings_and_extra_samplings;\n  int extra_samplings_for_options_and_extra_samplings_and_extra_samplings_and_extra_samplings;\n  int extra_samplings_for_options_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings;\n  int extra_samplings_for_options_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings;\n  int extra_samplings_for_options_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings;\n  int extra_samplings_for_options_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings;\n  int extra_samplings_for_options_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings;\n  int extra_samplings_for_options_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and_extra_samplings_and", "CodeBleu_score": 6.39035687055332}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t  int buffer_size = sequence->buffer_size;\n  int samplings = sequence->options & ADS1112_SEQ_OPT_SAMPLINGS_MASK;\n  int extra_samplings = sequence->options & ADS1112_SEQ_OPT_EXTRA_SAMPLINGS_MASK;\n  int required_buffer_size = samplings + extra_samplings;\n  if (buffer_size < required_buffer_size) {\n    LOG_ERR(\"Buffer size %d is too small for %d samplings\", buffer_size, required_buffer_size);\n    return -EINVAL;\n  }\n  return 0;\n}", "CodeBleu_score": 37.44534604735137}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t  int ret;\n  int num_samplings = sequence->length;\n  int extra_samplings = sequence->options & ADS1112_SEQ_OPT_EXTEND_SAMPLING;\n\n  if (extra_samplings) {\n    num_samplings += extra_samplings;\n  }\n\n  if (num_samplings > sequence->buffer_size) {\n    LOG_ERR(\"Insufficient buffer size for %d samplings\", num_samplings);\n    ret = -ENOMEM;\n  } else {\n    ret = 0;\n  }\n\n  return ret;\n}", "CodeBleu_score": 36.27103782270484}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t *seq_buf = sequence->buffer;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\tdata->seq_buf = seq_buf;\n\n\tret = adc_context_start_read(dev, wait);\n\n\treturn ret;\n}", "CodeBleu_score": 58.21459202901374}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tARG_UNUSED(dev);\n\tARG_UNUSED(sequence);\n\tARG_UNUSED(wait);\n\n\treturn 0;\n}", "CodeBleu_score": 13.414738231360229}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\tdata->sequence_size = adc_sequence_length(sequence);\n\n\tret = adc_context_start_read(dev, sequence, wait);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.630505999753474}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    struct device *dev;\n    int ret;\n\n    if (argc < 2) {\n        shell_error(sh, \"Usage: apply_prop <device>\");\n        return -ENODEV;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (dev == NULL) {\n        shell_error(sh, \"Device not found\");\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_properties(dev);\n    if (ret) {\n        shell_error(sh, \"Failed to apply properties (%d)\", ret);\n        return ret;\n    }\n\n    shell_print(sh, \"Properties applied successfully\");\n    return 0;\n}", "CodeBleu_score": 56.651028373558646}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    struct device *dev;\n    int ret;\n\n    if (argc != 2) {\n        shell_error(sh, \"Usage: apply_prop <dev_name>\");\n        return -ENOENT;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (dev == NULL) {\n        shell_error(sh, \"Device %s not found\", argv[1]);\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_properties(dev);\n    if (ret != 0) {\n        shell_error(sh, \"Failed to apply properties to device %s\", argv[1]);\n        return ret;\n    }\n\n    shell_print(sh, \"Properties applied successfully to device %s\", argv[1]);\n    return 0;\n}", "CodeBleu_score": 51.580762372899294}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    struct device *device;\n    int ret;\n\n    if (argc != 2) {\n        shell_error(sh, \"Usage: %s <device>\", argv[0]);\n        return -ENOEXEC;\n    }\n\n    device = device_get_binding(argv[1]);\n    if (device == NULL) {\n        shell_error(sh, \"Device %s not found\", argv[1]);\n        return -ENOEXEC;\n    }\n\n    ret = audio_codec_apply_properties(device);\n    if (ret != 0) {\n        shell_error(sh, \"Failed to apply properties to device %s\", argv[1]);\n        return -ENOEXEC;\n    }\n\n    shell_print(sh, \"Successfully applied properties to device %s\", argv[1]);\n    return 0;\n}", "CodeBleu_score": 46.56984225449305}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t  struct mpxxdtyy_i2s_dev_data *dev_data = dev->data;\n  int ret;\n\n  if (dev_data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n    if (cmd == DMIC_TRIGGER_START) {\n      ret = mpxxdtyy_i2s_start(dev);\n      if (ret) {\n        LOG_ERR(\"Failed to start I2S: %d\", ret);\n        return ret;\n      }\n      dev_data->state = MPXXDTYY_I2S_STATE_ACTIVE;\n    } else if (cmd == DMIC_TRIGGER_STOP) {\n      ret = mpxxdtyy_i2s_stop(dev);\n      if (ret) {\n        LOG_ERR(\"Failed to stop I2S: %d\", ret);\n        return ret;\n      }\n      dev_data->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n    } else {\n      LOG_ERR(\"Invalid DMIC trigger command: %d\", cmd);\n      return -EINVAL;\n    }\n  } else if (dev_data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n    if (cmd == DMIC_TRIGGER_STOP) {\n      ret = mpxxdtyy_i2s_stop(dev);\n      if (ret) {\n        LOG_ERR(\"Failed to stop I2S: %d\", ret);\n        return ret;\n      }\n      dev_data->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n    } else {\n      LOG_ERR(\"Invalid DMIC trigger command for active state: %d\", cmd);\n      return -EINVAL;\n    }\n  } else {\n    LOG_ERR(\"Invalid device state: %d\", dev_data->state);\n    return -EINVAL;\n  }\n\n  return 0;\n}", "CodeBleu_score": 40.0488310564582}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t  int err;\n  struct mpxxdtyy_dev_data *dev_data = dev->data;\n  struct mpxxdtyy_dev_cfg *dev_cfg = dev_data->cfg;\n  struct mpxxdtyy_dev_i2s *dev_i2s = dev_data->i2s;\n\n  if (cmd == DMIC_TRIGGER_START) {\n    if (dev_i2s->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n      err = mpxxdtyy_i2s_cmd(dev, dev_i2s->cmd_start);\n      if (err) {\n        LOG_ERR(\"Failed to send I2S start command (%d)\", err);\n        return err;\n      }\n      dev_i2s->state = MPXXDTYY_I2S_STATE_ACTIVE;\n    } else {\n      LOG_ERR(\"Invalid I2S state (%d)\", dev_i2s->state);\n      return -EINVAL;\n    }\n  } else if (cmd == DMIC_TRIGGER_STOP) {\n    if (dev_i2s->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n      err = mpxxdtyy_i2s_cmd(dev, dev_i2s->cmd_stop);\n      if (err) {\n        LOG_ERR(\"Failed to send I2S stop command (%d)\", err);\n        return err;\n      }\n      dev_i2s->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n    } else {\n      LOG_ERR(\"Invalid I2S state (%d)\", dev_i2s->state);\n      return -EINVAL;\n    }\n  } else {\n    LOG_ERR(\"Invalid DMIC trigger command (%d)\", cmd);\n    return -EINVAL;\n  }\n\n  return 0;\n}", "CodeBleu_score": 39.917002870482634}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t  int ret;\n  struct mpxxdtyy_i2s_dev_data *data = dev->data;\n  struct mpxxdtyy_i2s_cfg *cfg = data->cfg;\n  struct mpxxdtyy_i2s_dev_data *d = dev->data;\n  struct mpxxdtyy_i2s_cfg *c = d->cfg;\n  struct mpxxdtyy_i2s_dev_data *d = dev->data;\n  struct mpxxdtyy_i2s_cfg *c = d->cfg;\n  struct mpxxdtyy_i2s_dev_data *d = dev->data;\n  struct mpxxdtyy_i2s_cfg *c = d->cfg;\n  struct mpxxdtyy_i2s_dev_data *d = dev->data;\n  struct mpxxdtyy_i2s_cfg *c = d->cfg;\n  struct mpxxdtyy_i2s_dev_data *d = dev->data;\n  struct mpxxdtyy_i2s_cfg *c = d->cfg;\n  struct mpxxdtyy_i2s_dev_data *d = dev->data;\n  struct mpxxdtyy_i2s_cfg *c = d->cfg;\n  struct mpxxdtyy_i2s_dev_data *d = dev->data;\n  struct mpxxdtyy_i2s_cfg *c = d->cfg;\n  struct mpxxdtyy_i2s_dev_data *d = dev->data;\n  struct mpxxdtyy_i2s_cfg *c = d->cfg;\n  struct mpxxdtyy_i2s_dev_data *d = dev->data;\n  struct mpxxdtyy_i2s_cfg *c = d->cfg;\n  struct mpxxdtyy_i2s_dev_data *d = dev->data;\n  struct mpxxdtyy_i2s_cfg *c = d->cfg;\n ", "CodeBleu_score": 12.797285475918931}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    struct auxdisplay_hd44780_data *data = dev->data;\n\n    uint8_t command = data->display_mode_command;\n\n    if (data->cursor_enabled) {\n        command |= HD44780_DISPLAY_MODE_CURSOR_ON;\n    } else {\n        command &= ~HD44780_DISPLAY_MODE_CURSOR_ON;\n    }\n\n    if (data->blink_enabled) {\n        command |= HD44780_DISPLAY_MODE_BLINK_ON;\n    } else {\n        command &= ~HD44780_DISPLAY_MODE_BLINK_ON;\n    }\n\n    if (enabled) {\n        command |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n    } else {\n        command &= ~HD44780_DISPLAY_MODE_DISPLAY_ON;\n    }\n\n    data->display_mode_command = command;\n\n    auxdisplay_hd44780_send_command(dev, data->display_mode_command);\n}", "CodeBleu_score": 59.186760467823476}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    struct auxdisplay_hd44780_data *data = dev->data;\n\n    uint8_t command = 0;\n\n    if (data->display_mode_config & AUXDISPLAY_HD44780_DISPLAY_MODE_CONFIG_CURSOR_ON) {\n        command |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON;\n    }\n\n    if (data->display_mode_config & AUXDISPLAY_HD44780_DISPLAY_MODE_CONFIG_CURSOR_BLINK) {\n        command |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK;\n    }\n\n    if (data->display_mode_config & AUXDISPLAY_HD44780_DISPLAY_MODE_CONFIG_DISPLAY_ON) {\n        command |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n    }\n\n    if (enabled) {\n        command |= AUXDISPLAY_HD44780_DISPLAY_MODE_ENABLE;\n    }\n\n    data->display_mode_command = command;\n\n    auxdisplay_hd44780_send_command(dev, data->display_mode_command);\n}", "CodeBleu_score": 55.70736744580335}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    struct auxdisplay_hd44780_data *data = dev->data;\n    uint8_t command = 0;\n\n    // Retrieve the current configuration\n    uint8_t config = auxdisplay_hd44780_get_config(dev);\n\n    // Set the display mode command based on the current configuration\n    if (config & AUXDISPLAY_HD44780_DISPLAY_ON) {\n        command |= AUXDISPLAY_HD44780_DISPLAY_ON;\n    }\n    if (config & AUXDISPLAY_HD44780_CURSOR_ON) {\n        command |= AUXDISPLAY_HD44780_CURSOR_ON;\n    }\n    if (config & AUXDISPLAY_HD44780_BLINK_ON) {\n        command |= AUXDISPLAY_HD44780_BLINK_ON;\n    }\n\n    // Update the command based on the current cursor and position blink settings\n    if (data->cursor_blink) {\n        command |= AUXDISPLAY_HD44780_CURSOR_BLINK;\n    }\n    if (data->position_blink) {\n        command |= AUXDISPLAY_HD44780_POSITION_BLINK;\n    }\n\n    // Set the display enable flag if enabled is true\n    if (enabled) {\n        command |= AUXDISPLAY_HD44780_DISPLAY_ENABLE;\n    }\n\n    // Send the command to the device\n    auxdisplay_hd44780_send_command(dev, command);\n}", "CodeBleu_score": 58.97441853895421}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    struct auxdisplay_itron_data *data = dev->data;\n    int ret;\n\n    if (!data->busy_gpio_port) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get_dt(&data->busy_gpio_port, data->busy_gpio_pin);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to get busy GPIO pin: %d\", ret);\n        return ret;\n    }\n\n    return ret;\n}", "CodeBleu_score": 53.665382388551876}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t  const struct auxdisplay_itron_config *cfg = dev->config;\n\n  if (!cfg->busy_gpio_dev) {\n    return -ENOTSUP;\n  }\n\n  return gpio_pin_get_dt(cfg->busy_gpio_dev, cfg->busy_gpio_pin);\n}", "CodeBleu_score": 37.78125144774857}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n    int ret;\n\n    if (!config->busy_gpio_port) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get_dt(&config->busy_gpio_port, config->busy_gpio_pin);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to get busy status: %d\", ret);\n        return ret;\n    }\n\n    return ret;\n}", "CodeBleu_score": 64.69608875863597}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\t/*\n\t * Construct a buffer containing the special command prefix and the command itself.\nThe buffer is initialized with the special command prefix and the command itself, and the remaining bytes are set to 0.\n\t */\n\tuint8_t buffer[2];\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\t/*\n\t * Write the buffer to the device using the I2C bus.\nThe I2C write operation is performed using the \"i2c_write_dt\" function, which is defined in the \"i2c_api.h\" header file.\nThe \"i2c_write_dt\" function takes as input the device pointer, the address of the buffer, and the number of bytes to write.\nThe function returns the number of bytes written, or a negative value if an error occurred.\n\t */\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst struct i2c_dt_spec *i2c = &config->i2c;\n\tconst int result = i2c_write_dt(i2c, buffer, sizeof(buffer));\n\n\t/*\n\t * If the I2C write operation was successful, introduce a delay specified in the device configuration.\nThe delay is specified in milliseconds and is obtained from the device configuration structure using the \"K_MSEC\" macro.\nThe \"k_sleep\" function is used to introduce the delay.\n\t */\n\tif (result > 0) {\n\t\tk_sleep(K_MSEC(config->delay_ms));\n\t}\n\n\t/*\n\t * Return the result of the I2C write operation.\n\t */\n\treturn result;\n}", "CodeBleu_score": 67.24831584639813}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\t/*\n\t * The function \"auxdisplay_serlcd_send_special_command\" sends a special command to an LCD device via I2C.", "CodeBleu_score": 24.716901069428136}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t    const struct auxdisplay_serlcd_config *config = dev->config;\n    uint8_t buffer[2];\n\n    buffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n    buffer[1] = command;\n\n    return i2c_write_dt(&config->i2c, buffer, sizeof(buffer));\n}", "CodeBleu_score": 65.18889729171553}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\n\tbbram_emul_check_invalid(dev, offset, size, data);\n\tmemcpy(data, &(((struct bbram_emul_data *)dev->data)->memory[offset]), size);\n\n\treturn 0;\n}", "CodeBleu_score": 46.76212768024385}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tARG_UNUSED(dev);\n\n\tbbram_emul_check_invalid(offset, size);\n\n\tmemcpy(data, &bbram_emul.mem[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 40.67419505954744}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t  const struct bbram_emul_cfg *cfg = dev->config;\n  if (bbram_emul_check_invalid(dev, offset, size)) {\n    return -EINVAL;\n  }\n  memcpy(data, &cfg->memory[offset], size);\n  return 0;\n}", "CodeBleu_score": 56.559132993729456}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\t/* Check if the write size is valid */\n\tif (size == 0 || size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM */\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state */\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory */\n\tmemcpy(bbram_emul_get_data(dev) + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 58.65419668076268}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tARG_UNUSED(dev);\n\tstruct bbram_emul_data *emul_data = dev->data;\n\n\tif (bbram_emul_check_invalid(emul_data)) {\n\t\treturn -EIO;\n\t}\n\n\tif (size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(emul_data->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 64.32342376779869}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t  struct bbram_emul_data *dev_data = dev->data;\n  bbram_emul_check_invalid(dev);\n  if (offset + size > dev_data->size) {\n    return -EINVAL;\n  }\n  memcpy(dev_data->data + offset, data, size);\n  return 0;\n}", "CodeBleu_score": 70.81082331927377}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = bbram_init(*bbram_dev);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to initialize device\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 74.63148953823027}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_init(*bbram_dev);\n\tif (ret != 0) {\n\t\tshell_error(sh, \"Failed to initialize device\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 74.602128072349}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst struct device *dev;\n\tint ret;\n\n\tif (argc > 1) {\n\t\tshell_error(sh, \"Too many arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (argc == 1) {\n\t\tdev = device_get_binding(argv[0]);\n\t\tif (!dev) {\n\t\t\tshell_error(sh, \"Device '%s' not found\", argv[0]);\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tdev = device_get_binding(CONFIG_BBRAM_DRIVER_NAME);\n\t\tif (!dev) {\n\t\t\tshell_error(sh, \"No device bound to '%s'\",\n\t\t\t\t    CONFIG_BBRAM_DRIVER_NAME);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tret = bbram_driver_api(dev)->init(dev);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to initialize device '%s'\",\n\t\t\t    dev->name);\n\t\treturn ret;\n\t}\n\n\t*bbram_dev = dev;\n\treturn 0;\n}", "CodeBleu_score": 55.637925243109876}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t    uint8_t *hdr_buf = h4_get_hdr_buf();\n    uint32_t hdr_len = h4_get_hdr_len();\n    uint32_t hdr_read = h4_get_hdr_read();\n    uint32_t hdr_remain = hdr_len - hdr_read;\n    int ret;\n\n    if (hdr_remain == 0) {\n        return;\n    }\n\n    ret = uart_fifo_read(dev, hdr_buf + hdr_read, hdr_remain);\n    if (ret < 0) {\n        LOG_ERR(\"uart_fifo_read failed: %d\", ret);\n        return;\n    }\n\n    hdr_read += ret;\n    h4_set_hdr_read(hdr_read);\n}", "CodeBleu_score": 32.07467842641795}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    struct h4_uart_data *data = dev->data;\n    u32_t bytes_read;\n    u32_t bytes_to_read;\n\n    bytes_read = uart_fifo_read(data->uart, data->hdr_buf, sizeof(data->hdr_buf));\n    if (bytes_read != sizeof(data->hdr_buf)) {\n        LOG_ERR(\"Failed to read header from UART FIFO (%d bytes read)\", bytes_read);\n        return;\n    }\n\n    bytes_to_read = data->hdr.hdr_len - bytes_read;\n    if (bytes_to_read > 0) {\n        u32_t bytes_read_again;\n\n        bytes_read_again = uart_fifo_read(data->uart, data->hdr_buf + bytes_read, bytes_to_read);\n        if (bytes_read_again != bytes_to_read) {\n            LOG_ERR(\"Failed to read header from UART FIFO (%d bytes read)\", bytes_read_again);\n            return;\n        }\n    }\n\n    data->hdr_bytes_read = sizeof(data->hdr_buf);\n}", "CodeBleu_score": 43.28894561563935}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t  int ret;\n  uint32_t bytes_read;\n\n  bytes_read = h4_bytes_read;\n  ret = uart_fifo_read(dev, &h4_hdr[bytes_read],\n                       H4_HDR_LEN - bytes_read);\n  if (ret < 0) {\n    LOG_ERR(\"uart_fifo_read failed\");\n    return;\n  }\n  h4_bytes_read += ret;\n}", "CodeBleu_score": 30.913459836922065}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t  struct uart_csr csr;\n  uint8_t buf[33];\n  size_t read = 0;\n\n  if (!uart) {\n    return 0;\n  }\n\n  while (len) {\n    size_t n = min(len, sizeof(buf));\n    int err = uart_fifo_read(uart, &csr, buf, n);\n    if (err) {\n      LOG_ERR(\"uart_fifo_read: %d\", err);\n      return read;\n    }\n    read += csr.rx_cnt;\n    len -= csr.rx_cnt;\n  }\n\n  return read;\n}", "CodeBleu_score": 43.59059446273721}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t  size_t ret = 0;\n  uint8_t buf[33];\n\n  while (likely(len)) {\n    size_t to_read = min(len, sizeof(buf));\n    size_t read = uart_fifo_read(uart, buf, to_read);\n\n    if (unlikely(!read)) {\n      LOG_ERR(\"uart_fifo_read failed\");\n      return 0;\n    }\n\n    len -= read;\n    ret += read;\n  }\n\n  return ret;\n}", "CodeBleu_score": 38.17222454956193}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t rlen;\n\n    if (len > sizeof(buf)) {\n        len = sizeof(buf);\n    }\n\n    rlen = uart_fifo_read(uart, buf, len);\n    if (rlen != len) {\n        LOG_ERR(\"Failed to read %zu bytes from UART: %d\", len, rlen);\n        return 0;\n    }\n\n    return rlen;\n}", "CodeBleu_score": 53.14194709049392}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\n\tu32_t hop = 0;\n\tfor (int i = 0; i < chan->observer_count; i++) {\n\t\tif (chan->observers[i].enabled && chan->observers[i].priority < hop) {\n\t\t\thop = chan->observers[i].priority;\n\t\t}\n\t}\n\n\tchan->hop = hop;\n\n\tk_spin_unlock(&chan->lock, key);\n}", "CodeBleu_score": 19.1160145940423}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t  zbus_spinlock_t *lock = chan->lock;\n  zbus_spinlock_lock(lock);\n  struct zbus_channel_observer *observer = chan->observers;\n  uint32_t highest = observer->priority;\n  while (observer) {\n    if (observer->enabled && observer->priority < highest) {\n      highest = observer->priority;\n    }\n    observer = observer->next;\n  }\n  chan->hop = highest;\n  zbus_spinlock_unlock(lock);\n}", "CodeBleu_score": 22.152946133669616}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t hop = 0;\n\tuint8_t i;\n\n\tK_SPINLOCK_KEY_SAVE(key, &chan->lock);\n\n\tfor (i = 0; i < chan->observers_count; i++) {\n\t\tstruct zbus_observer *obs = &chan->observers[i];\n\n\t\tif (obs->priority > hop && obs->enabled) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\n\tchan->hop = hop;\n\n\tK_SPINLOCK_KEY_RESTORE(key, &chan->lock);\n}", "CodeBleu_score": 21.886388956019236}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t  STRUCT_SECTION_FOREACH(chan_update_hop, obs)\n}", "CodeBleu_score": 13.862674759417093}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    STRUCT_SECTION_FOREACH(chan_update_hop) {\n        if (chan_update_hop->obs == obs) {\n            chan_update_hop->update_chan(chan_update_hop->chan);\n        }\n    }\n}", "CodeBleu_score": 24.893151809809467}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tSTRUCT_SECTION_FOREACH(chan_update_hop) {\n\t\tif (obs == chan_update_hop->obs)\n\t\t\tchan_update_hop->update_hop();\n\t}\n}", "CodeBleu_score": 23.90153767863196}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t  K_SPINLOCK\n  if (k_is_in_isr()) {\n    _ZBUS_ASSERT(0);\n  }\n  if (obs == NULL) {\n    _ZBUS_ASSERT(0);\n  }\n  k_spinlock_key_t key = k_spin_lock(&obs->lock);\n  obs->priority = K_PRIO_COOP(K_PRIO_LOWEST);\n  update_all_channels_hop(obs);\n  k_spin_unlock(&obs->lock, key);\n  return 0;\n}", "CodeBleu_score": 36.33032730100446}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    if (k_is_in_isr()) {\n        _ZBUS_ASSERT(0);\n        return -1;\n    }\n    if (obs == NULL) {\n        _ZBUS_ASSERT(0);\n        return -1;\n    }\n    K_SPINLOCK(&obs->lock);\n    obs->priority = K_PRIO_COOP(K_LOWEST_PRIO);\n    update_all_channels_hop(obs);\n    return 0;\n}", "CodeBleu_score": 38.16384863544041}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t  K_SPINLOCK\n  k_is_in_isr\n  _ZBUS_ASSERT\n  update_all_channels_hop\n  return 0;\n}", "CodeBleu_score": 9.654991952342911}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    int err;\n\n    ZBUS_ASSERT(chan != NULL);\n\n    if (chan->isr_lock) {\n        timeout = k_isr_lock_timeout(timeout);\n    }\n\n    err = sys_timepoint_calc(&chan->notify_end, timeout);\n    if (err) {\n        return err;\n    }\n\n    chan_lock(chan);\n\n    err = chan->notify(chan);\n\n    chan_unlock(chan);\n\n    return err;\n}", "CodeBleu_score": 46.520065423616806}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    int ret;\n    k_timeout_t end_time;\n\n    ZBUS_ASSERT(chan != NULL);\n\n    if (chan->isr_lock) {\n        timeout = chan_lock(chan, timeout);\n    }\n\n    end_time = sys_timepoint_calc(timeout);\n\n    if (chan->context.prio < K_INHERIT_PRIO(chan->context.base_prio, end_time)) {\n        chan->context.prio = K_INHERIT_PRIO(chan->context.base_prio, end_time);\n    }\n\n    ret = chan->notify(chan, end_time);\n\n    if (chan->isr_lock) {\n        chan_unlock(chan);\n    }\n\n    return ret;\n}", "CodeBleu_score": 46.998183164328196}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t  int ret;\n  k_timepoint_t end_time;\n  k_timepoint_t now;\n  k_timeout_t adjusted_timeout;\n  struct zbus_context *ctx;\n  if (chan == NULL) {\n    _ZBUS_ASSERT(chan != NULL);\n    return -EINVAL;\n  }\n  if (chan->isr_lock) {\n    timeout = sys_timepoint_calc(timeout, &now);\n  }\n  end_time = k_timepoint_add(now, timeout);\n  ctx = chan->context;\n  chan_lock(chan);\n  ctx->priority = chan->priority;\n  ret = chan->notify(chan, &adjusted_timeout);\n  chan_unlock(chan);\n  return ret;\n}", "CodeBleu_score": 42.77319463408305}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t tmpreg;\n\tuint32_t itreg;\n\tuint32_t itreg_mask;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\n\t/* Get the interrupt register address */\n\titreg = (uint32_t)ETH->INTSTS;\n\titreg_mask = (uint32_t)ETH->INTSTS_MASK;\n\n\t/* Configure the interrupt */\n\tif (enable != DISABLE) {\n\t\t/* Enable the interrupt */\n\t\ttmpreg = itreg_mask & (uint32_t)(~Int);\n\t\titreg_mask = tmpreg;\n\n\t\t/* Set the interrupt enable bit */\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->INTEN |= (uint32_t)Int;\n\t\t} else {\n\t\t\tETH->ABNINTEN |= (uint32_t)Int;\n\t\t}\n\t} else {\n\t\t/* Disable the interrupt */\n\t\ttmpreg = itreg & (uint32_t)Int;\n\t\titreg &= (uint32_t)(~Int);\n\n\t\t/* Check if the interrupt is normal or abnormal */\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\t/* Check if there are any other enabled normal interrupts */\n\t\t\tif (itreg & IS_ETH_INT_NORMAL) {\n\t\t\t\t/* Clear the interrupt and enable the normal interrupt enable bit */\n\t\t\t\tETH->INTSTS = (uint32_t)Int;\n\t\t\t\tETH->INTEN |= (uint32_t)Int;\n\t\t\t} else {\n\t\t\t\t/* Clear the interrupt and disable the normal interrupt enable bit */\n\t\t\t\tETH->INTSTS = (uint32_t)Int;\n\t\t\t\tETH->INTEN &= (uint32_t)(~Int);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Check if there are any other enabled abnormal interrupts */\n\t\t\tif (itreg & IS_ETH_INT_ABNORMAL) {\n\t\t\t\t/* Clear the interrupt and enable the ab", "CodeBleu_score": 36.841669520732154}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t}", "CodeBleu_score": 4.451885662912518}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t tmpreg;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\n\t/* Get the current interrupt enable register value */\n\ttmpreg = ETH->INTSTS;\n\n\t/* Configure the Ethernet interrupt */\n\tif (enable != DISABLE) {\n\t\tif (Int == ETH_INT_ABNORMAL) {\n\t\t\tETH->INTEN |= ETH_INT_ABNORMAL;\n\t\t} else if (Int == ETH_INT_NORMAL) {\n\t\t\tETH->INTEN |= ETH_INT_NORMAL;\n\t\t}\n\t} else {\n\t\tif (Int == ETH_INT_ABNORMAL) {\n\t\t\tETH->INTEN &= ~ETH_INT_ABNORMAL;\n\t\t} else if (Int == ETH_INT_NORMAL) {\n\t\t\tETH->INTEN &= ~ETH_INT_NORMAL;\n\t\t}\n\t}\n\n\t/* Check if the interrupt is enabled */\n\tif (Int == ETH_INT_ABNORMAL) {\n\t\tif (ETH->INTEN & ETH_INT_ABNORMAL) {\n\t\t\t/* Enable the Ethernet abnormal interrupt */\n\t\t\tETH->INTEN |= ETH_INT_ABNORMAL;\n\t\t} else {\n\t\t\t/* Disable the Ethernet abnormal interrupt */\n\t\t\tETH->INTEN &= ~ETH_INT_ABNORMAL;\n\t\t}\n\t} else if (Int == ETH_INT_NORMAL) {\n\t\tif (ETH->INTEN & ETH_INT_NORMAL) {\n\t\t\t/* Enable the Ethernet normal interrupt */\n\t\t\tETH->INTEN |= ETH_INT_NORMAL;\n\t\t} else {\n\t\t\t/* Disable the Ethernet normal interrupt */\n\t\t\tETH->INTEN &= ~ETH_INT_NORMAL;\n\t\t}\n\t}\n\n\t/* Check if the interrupt is enabled */\n\tif (Int == ETH_INT_ABNORMAL) {\n\t\tif (ETH->INTEN & ETH_INT_ABNORMAL) {\n\t\t\t/* Enable the Ethernet abnormal interrupt */\n\t\t\tETH", "CodeBleu_score": 42.63042449598044}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t  ETH_TX_DESC *txDesc;\n  uint32_t txDescAddr;\n  uint32_t txDescAddrNext;\n  uint32_t txDescAddrStart;\n  uint32_t txDescAddrEnd;\n  uint32_t txDescAddrEndNext;\n  uint32_t txDescAddrEndPrev;\n  uint32_t txDescAddrEndPrevNext;\n  uint32_t txDescAddrEndPrevPrev;\n  uint32_t txDescAddrEndPrevPrevNext;\n  uint32_t txDescAddrEndPrevPrevPrev;\n  uint32_t txDescAddrEndPrevPrevPrevNext;\n  uint32_t txDescAddrEndPrevPrevPrevPrev;\n  uint32_t txDescAddrEndPrevPrevPrevPrevNext;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrev;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevNext;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrev;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevNext;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrev;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrevNext;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrevPrev;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrevPrevNext;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrevPrevPrev;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrevPrevPrevNext;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevNext;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevNext;\n  uint32_t txDescAddrEndPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev;\n  uint32_t txDesc", "CodeBleu_score": 4.807518622063533}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc;\n    uint32_t i;\n    for (i = 0; i < ETH_TX_DESC_NUM; i++) {\n        txDesc = &ethTxDesc[i];\n        if (txDesc->status & ETH_TX_DESC_OWNED) {\n            continue;\n        }\n        txDesc->status |= ETH_TX_DESC_OWNED;\n        return txDesc;\n    }\n    return 0;\n}", "CodeBleu_score": 32.571306775328125}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc;\n    uint32_t txDescAddr = ETH_TX_DESC_ADDR;\n    uint32_t txDescAddrNext;\n    uint32_t txDescAddrStart = txDescAddr;\n\n    do {\n        txDesc = (ETH_TX_DESC *)txDescAddr;\n        txDescAddrNext = txDescAddr + ETH_TX_DESC_SIZE;\n\n        if (txDesc->status & ETH_TX_DESC_STATUS_OWNED) {\n            txDescAddr = txDescAddrNext;\n        } else {\n            return txDesc;\n        }\n    } while (txDescAddr != txDescAddrStart);\n\n    return 0;\n}", "CodeBleu_score": 48.721466404134745}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    CY_CSDIDAC_Type *dac = cyp_dac_get_channel(device, channel);\n    if (dac == RT_NULL) {\n        LOG_E(\"DAC channel %d not found\", channel);\n        return RT_ERROR;\n    }\n    Cy_CSDIDAC_OutputEnable(dac, *value);\n    return RT_EOK;\n}", "CodeBleu_score": 53.17971602709102}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    Cy_CSDIDAC_OutputEnable(device->priv, channel, *value);\n    LOG_E(\"DAC channel %d: %d\", channel, *value);\n    return RT_EOK;\n}", "CodeBleu_score": 44.40191632422174}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    struct cyp_dac_device *dac = (struct cyp_dac_device *)device;\n    rt_uint32_t ch = cyp_dac_get_channel(dac, channel);\n    rt_err_t result = Cy_CSDIDAC_OutputEnable(dac->base, ch, *value);\n    if (result != RT_EOK) {\n        LOG_E(\"Failed to initialize DAC channel %d\", ch);\n    }\n    return result;\n}", "CodeBleu_score": 58.3296685880337}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    int i;\n    rt_uint32_t end_addr = addr + size;\n    if (end_addr > 0x80000) {\n        LOG_E(\"read flash error, addr:0x%x, size:%d, end_addr:0x%x\", addr, size, end_addr);\n        return -1;\n    }\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n    return i;\n}", "CodeBleu_score": 48.152692780381045}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t  // Check if the read operation would exceed the flash memory's end address\n  if ((addr + size) > (IFX_FLASH_BASE_ADDR + IFX_FLASH_SIZE)) {\n    LOG_E(\"ifx_flash_read_32k: read operation would exceed flash memory end address\");\n    return -1;\n  }\n\n  // Read the specified size of data from the flash memory address into the buffer, byte by byte\n  for (rt_uint32_t i = 0; i < size; i++) {\n    buf[i] = *(rt_uint8_t *)(IFX_FLASH_BASE_ADDR + addr + i);\n  }\n\n  // Return the number of bytes read\n  return size;\n}", "CodeBleu_score": 47.10566629412027}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t  if ((addr + size) > FLASH_END_ADDR) {\n    LOG_E(\"ifx_flash_read_32k: addr=%08x, size=%d, addr+size=%08x, FLASH_END_ADDR=%08x\", addr, size, addr + size, FLASH_END_ADDR);\n    return -1;\n  }\n\n  rt_uint32_t i;\n  for (i = 0; i < size; i++) {\n    buf[i] = *((rt_uint8_t *)(addr + i));\n  }\n  return i;\n}", "CodeBleu_score": 54.27063497025193}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->user_data;\n    return cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 29.478763709113938}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer != RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 27.351588640571233}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t  RT_ASSERT(timer != NULL);\n\n  cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->user_data;\n  rt_uint32_t count = cyhal_timer_read(hal_timer);\n\n  return count;\n}", "CodeBleu_score": 54.53626645328742}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    int res;\n    do {\n        res = rt_mutex_take(dfs_mutex, RT_WAITING_FOREVER);\n    } while (res != RT_EOK);\n}", "CodeBleu_score": 14.434179379284936}, {"code": "void dfs_lock(void){\n\t    rt_mutex_take(DFS_MUTEX, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.523728820507443}, {"code": "void dfs_lock(void){\n\t    int rc;\n    do {\n        rc = rt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER);\n    } while (rc != RT_EOK);\n}", "CodeBleu_score": 19.59480695102075}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n    int i;\n    int nr_fds = fdt->nr_fds;\n    struct fd *fds = fdt->fds;\n\n    /*\n     * Search for an empty slot starting from the specified index.\n     */\n    for (i = startfd; i < nr_fds; i++) {\n        if (fds[i].file == NULL) {\n            return i;\n        }\n    }\n\n    /*\n     * No empty slot found. Attempt to expand the fd table.\n     */\n    if (fdt->max_fds == nr_fds) {\n        return -1;\n    }\n\n    /*\n     * Allocate a new file descriptor slot.\n     */\n    fd = nr_fds;\n    nr_fds++;\n    fdt->nr_fds = nr_fds;\n    fdt->max_fds = nr_fds;\n\n    return fd;\n}", "CodeBleu_score": 43.76931253524068}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n    int nr_fds = fdt->nr_fds;\n    int nr_fds_allocated = fdt->nr_fds_allocated;\n    struct dfs_fd *fds = fdt->fds;\n    struct dfs_fd *fds_allocated = fdt->fds_allocated;\n    struct dfs_fd *fds_to_allocate = fdt->fds_to_allocate;\n\n    for (fd = startfd; fd < nr_fds; fd++) {\n        if (fds[fd].file == NULL) {\n            fds[fd].file = NULL;\n            fds[fd].flags = 0;\n            fds[fd].count = 0;\n            fds[fd].locked = 0;\n            fds[fd].ref_locked = 0;\n            fds[fd].ref_count = 0;\n            fds[fd].ref_count_locked = 0;\n            fds[fd].ref_count_locked_waiters = 0;\n            fds[fd].ref_count_locked_waiters_locked = 0;\n            fds[fd].ref_count_locked_waiters_locked_waiters = 0;\n            fds[fd].ref_count_locked_waiters_locked_waiters_locked = 0;\n            fds[fd].ref_count_locked_waiters_locked_waiters_locked_waiters = 0;\n            fds[fd].ref_count_locked_waiters_locked_waiters_locked_waiters_locked = 0;\n            fds[fd].ref_count_locked_waiters_locked_waiters_locked_waiters_locked_waiters = 0;\n            fds[fd].ref_count_locked_waiters_locked_waiters_locked_waiters_locked_waiters_locked = 0;\n            fds[fd].ref_count_locked_waiters_locked_waiters_locked_waiters_locked", "CodeBleu_score": 21.782272363001134}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t  int i;\n  int fd;\n  int fd_count;\n  int fd_max;\n  int fd_min;\n  int fd_size;\n  int fd_size_max;\n  int fd_size_min;\n  int fd_size_new;\n  int fd_size_new_max;\n  int fd_size_new_min;\n  int fd_size_new_min_max;\n  int fd_size_new_min_min;\n  int fd_size_new_min_min_max;\n  int fd_size_new_min_min_min;\n  int fd_size_new_min_min_min_max;\n  int fd_size_new_min_min_min_min;\n  int fd_size_new_min_min_min_min_max;\n  int fd_size_new_min_min_min_min_min;\n  int fd_size_new_min_min_min_min_min_max;\n  int fd_size_new_min_min_min_min_min_min;\n  int fd_size_new_min_min_min_min_min_min_max;\n  int fd_size_new_min_min_min_min_min_min_min;\n  int fd_size_new_min_min_min_min_min_min_min_max;\n  int fd_size_new_min_min_min_min_min_min_min_min;\n  int fd_size_new_min_min_min_min_min_min_min_min_max;\n  int fd_size_new_min_min_min_min_min_min_min_min_min;\n  int fd_size_new_min_min_min_min_min_min_min_min_min_max;\n  int fd_size_new_min_min_min_min_min_min_min_min_min_min;\n  int fd_size_new_min_min_min_min_min_", "CodeBleu_score": 6.420910403962793}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n\n    for (int i = 0; i < RT_ERR_N; i++) {\n        if (error == rt_err_table[i].err_code) {\n            return rt_err_table[i].err_msg;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 55.05051089911244}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < RT_ERR_NUM; i++) {\n        if (rt_err_table[i].err_code == error) {\n            return rt_err_table[i].err_msg;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 56.83719753184591}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < sizeof(error_strings) / sizeof(error_strings[0]); i++) {\n        if (error_strings[i].error == error) {\n            return error_strings[i].string;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 64.4705072419224}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t result;\n    rt_base_t i;\n    rt_base_t idle_hook_num;\n    rt_base_t *idle_hook_list;\n    rt_base_t *idle_hook_list_end;\n\n    /* lock spinlock */\n    rt_spin_lock_irqsave(&rt_thread_idle_lock);\n\n    /* get idle hook number */\n    idle_hook_num = rt_thread_idle_hook_num;\n\n    /* get idle hook list */\n    idle_hook_list = rt_thread_idle_hook_list;\n    idle_hook_list_end = idle_hook_list + idle_hook_num;\n\n    /* find an empty slot */\n    for (i = 0; i < idle_hook_num; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = (rt_base_t)hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* unlock spinlock */\n    rt_spin_unlock_irqrestore(&rt_thread_idle_lock);\n\n    return result;\n}", "CodeBleu_score": 57.9892969735858}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t index;\n\n    rt_spin_lock(&idle_hook_lock);\n    for (index = 0; index < RT_THREAD_IDLE_HOOK_NUM; index++) {\n        if (idle_hook_table[index] == RT_NULL) {\n            idle_hook_table[index] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n    rt_spin_unlock(&idle_hook_lock);\n\n    return result;\n}", "CodeBleu_score": 58.43857058162389}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_uint32_t level;\n    rt_err_t result;\n\n    /* lock the spinlock */\n    rt_spin_lock_irqsave(&rt_thread_idle_spinlock, level);\n\n    /* iterate through the idle hook list */\n    for (rt_uint32_t i = 0; i < RT_THREAD_IDLE_HOOK_NUM; i++) {\n        /* if the hook slot is empty, assign the hook to it and return success */\n        if (rt_thread_idle_hook[i] == NULL) {\n            rt_thread_idle_hook[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* if no empty slot was found, return an error */\n    if (result != RT_EOK)\n        result = -RT_EFULL;\n\n    /* unlock the spinlock */\n    rt_spin_unlock_irqrestore(&rt_thread_idle_spinlock, level);\n\n    return result;\n}", "CodeBleu_score": 63.31634185622086}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t index;\n    rt_list_t *node;\n    rt_base_t *idle_hook_list;\n    rt_base_t *idle_hook_list_end;\n\n    rt_spin_lock_irqsave(&rt_thread_idle_lock);\n\n    idle_hook_list = rt_thread_idle_hook_list;\n    idle_hook_list_end = idle_hook_list + rt_thread_idle_hook_list_size;\n    for (index = 0, node = idle_hook_list; node != idle_hook_list_end; index++, node++) {\n        if (*node == (rt_base_t)hook) {\n            *node = NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    if (node == idle_hook_list_end) {\n        result = RT_ERROR;\n    }\n\n    rt_spin_unlock_irqrestore(&rt_thread_idle_lock, 0);\n\n    return result;\n}", "CodeBleu_score": 45.09963395492168}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t level;\n    rt_list_t *node;\n\n    rt_spin_lock_irqsave(&idle_hook_lock, level);\n    for (node = rt_list_next(&idle_hook_list); node != &idle_hook_list; node = rt_list_next(node)) {\n        if (node->user_data == hook) {\n            rt_list_remove(node);\n            result = RT_EOK;\n            goto exit;\n        }\n    }\n    result = -RT_ERROR;\n\nexit:\n    rt_spin_unlock_irqrestore(&idle_hook_lock, level);\n    return result;\n}", "CodeBleu_score": 49.281911745169616}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t level;\n\n    rt_spin_lock_irqsave(&rt_thread_idle_lock, level);\n    for (rt_uint8_t i = 0; i < RT_THREAD_IDLE_MAX_HOOK_NUM; i++) {\n        if (rt_thread_idle_hook_list[i] == hook) {\n            rt_thread_idle_hook_list[i] = RT_NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n    rt_spin_unlock_irqrestore(&rt_thread_idle_lock, level);\n\n    return result;\n}", "CodeBleu_score": 62.102985317847235}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t *thread;\n\n    rt_scheduler_lock();\n    while (!rt_list_isempty(susp_list)) {\n        thread = (rt_thread_t *)rt_list_entry(susp_list->next, rt_thread_t, tlist);\n        rt_list_remove(&thread->tlist);\n        rt_thread_resume(thread);\n    }\n    rt_scheduler_unlock();\n    return RT_EOK;\n}", "CodeBleu_score": 34.3347422398892}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_err_t result;\n    rt_thread_t *thread;\n\n    if (susp_list == RT_NULL) {\n        return RT_EINVAL;\n    }\n\n    rt_scheduler_lock();\n    while (rt_list_isempty(susp_list) == RT_FALSE) {\n        thread = (rt_thread_t *) rt_list_entry(susp_list->next, struct rt_thread, tlist);\n        rt_list_remove(&thread->tlist);\n        result = rt_thread_resume(thread);\n        if (result != RT_EOK) {\n            rt_scheduler_unlock();\n            return result;\n        }\n    }\n    rt_scheduler_unlock();\n    return RT_EOK;\n}", "CodeBleu_score": 33.219472038750304}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_base_t level;\n    rt_thread_t thread;\n\n    /* check parameter */\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* check scheduler locking */\n    level = rt_hw_interrupt_disable();\n\n    /* dequeue and resume all suspended threads */\n    while (rt_list_entry(susp_list->next) != susp_list) {\n        thread = rt_list_entry(susp_list->next, rt_thread_t, susp_list);\n        rt_list_remove(&thread->susp_list);\n        rt_thread_resume(thread);\n    }\n\n    /* set thread error */\n    if (thread_error != RT_EOK) {\n        rt_list_entry(susp_list->next, rt_thread_t, susp_list)->error = thread_error;\n    }\n\n    /* resume scheduler */\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 29.98428446310112}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t dev = RT_NULL;\n    rt_device_t old_dev = rt_console_get_device();\n\n    if (old_dev != RT_NULL) {\n        rt_device_close(old_dev);\n    }\n\n    dev = rt_device_find(name);\n    if (dev == RT_NULL) {\n        return old_dev;\n    }\n\n    if (rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return old_dev;\n    }\n\n    rt_console_set_device(dev);\n    return old_dev;\n}", "CodeBleu_score": 52.23220920111573}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_dev = rt_console_get_device();\n    rt_device_t dev = rt_device_find(name);\n    if (dev == RT_NULL)\n        return old_dev;\n\n    if (dev == old_dev)\n        return old_dev;\n\n    if (old_dev != RT_NULL)\n        rt_device_close(old_dev);\n\n    if (rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK)\n        return old_dev;\n\n    rt_console_set_device(dev);\n\n    return old_dev;\n}", "CodeBleu_score": 55.086374164484106}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t dev, old_dev;\n    int result;\n\n    /* save current device */\n    old_dev = rt_console_get_device();\n\n    /* find the new device */\n    dev = rt_device_find(name);\n    if (dev == RT_NULL) {\n        return old_dev;\n    }\n\n    /* check if it is the same as the current device */\n    if (dev == old_dev) {\n        return old_dev;\n    }\n\n    /* close the current device if it exists */\n    if (old_dev != RT_NULL) {\n        rt_device_close(old_dev);\n    }\n\n    /* open the new device with read/write and stream flags */\n    result = rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        return old_dev;\n    }\n\n    /* set it as the new console device */\n    rt_console_set_device(dev);\n\n    return old_dev;\n}", "CodeBleu_score": 55.75978672037193}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object_class *class = rt_object_class_find(type);\n    int count = 0;\n    struct rt_object_list_node *node;\n\n    if (class == RT_NULL)\n        return 0;\n\n    rt_spin_lock_irqsave(&class->lock, class->lock_flag);\n    rt_list_for_each(node, &class->list) {\n        count++;\n    }\n    rt_spin_unlock_irqrestore(&class->lock, class->lock_flag);\n\n    return count;\n}", "CodeBleu_score": 50.97811951118527}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object_information *info;\n\n    rt_spin_lock_irqsave(&rt_object_list_lock);\n    info = rt_object_get_information(type);\n    if (info) {\n        rt_list_for_each(info->list.next, &info->list) {\n            count++;\n        }\n    }\n    rt_spin_unlock_irqrestore(&rt_object_list_lock);\n\n    return count;\n}", "CodeBleu_score": 36.8581033471285}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    rt_object_class_t *class;\n    rt_list_t *node;\n    int count = 0;\n    rt_spinlock_t *lock;\n\n    /* Get the object class */\n    class = rt_object_get_class(type);\n    if (class == RT_NULL) {\n        return 0;\n    }\n\n    /* Lock the spinlock */\n    lock = &class->lock;\n    rt_spin_lock_irqsave(lock);\n\n    /* Iterate through the object list */\n    rt_list_for_each(node, &class->list) {\n        count++;\n    }\n\n    /* Release the spinlock */\n    rt_spin_unlock_irqrestore(lock);\n\n    return count;\n}", "CodeBleu_score": 47.814169065239575}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n\n    RT_ASSERT(object != RT_NULL);\n\n    /* call the detach hook */\n    rt_object_hook_call(object, OBJECT_HOOK_DETACH);\n\n    /* get the object information */\n    rt_object_info_t *object_info = &object->object_info;\n\n    /* lock the spinlock */\n    level = rt_spin_lock_irqsave();\n\n    /* remove the object from the list */\n    rt_list_remove(&object->list);\n\n    /* unlock the spinlock */\n    rt_spin_unlock_irqrestore(level);\n\n    /* set the object type to zero */\n    object->type = 0;\n}", "CodeBleu_score": 25.971847984114195}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n    rt_object_info_t *object_info;\n    RT_ASSERT(object != RT_NULL);\n\n    object_info = (rt_object_info_t *)rt_object_get_information(object);\n    if (object_info->type == RT_Object_Class_Device)\n    {\n        rt_device_t device;\n        device = (rt_device_t)object;\n        rt_device_detach(device);\n    }\n    else if (object_info->type == RT_Object_Class_Timer)\n    {\n        rt_timer_t timer;\n        timer = (rt_timer_t)object;\n        rt_timer_detach(timer);\n    }\n    else if (object_info->type == RT_Object_Class_Event)\n    {\n        rt_event_t event;\n        event = (rt_event_t)object;\n        rt_event_detach(event);\n    }\n    else if (object_info->type == RT_Object_Class_MailBox)\n    {\n        rt_mailbox_t mbox;\n        mbox = (rt_mailbox_t)object;\n        rt_mailbox_detach(mbox);\n    }\n    else if (object_info->type == RT_Object_Class_Semaphore)\n    {\n        rt_sem_t sem;\n        sem = (rt_sem_t)object;\n        rt_sem_detach(sem);\n    }\n    else if (object_info->type == RT_Object_Class_Mutex)\n    {\n        rt_mutex_t mutex;\n        mutex = (rt_mutex_t)object;\n        rt_mutex_detach(mutex);\n    }\n    else if (object_info->type == RT_Object_Class_MessageQueue)\n    {\n        rt_mq_t mq;\n        mq = (rt_mq_t)object;\n        rt_mq_detach(mq);\n    }", "CodeBleu_score": 40.64512445160919}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_object_t *object_ptr;\n    rt_base_t type;\n    rt_base_t level;\n\n    RT_ASSERT(object != RT_NULL);\n\n    object_ptr = (rt_object_t *)object;\n\n    type = object_ptr->type;\n\n    if (type != RT_Object_Class_Device)\n    {\n        rt_object_hook_call(object, RT_Object_Event_Detach);\n    }\n\n    rt_spin_lock_irqsave(&object_ptr->spinlock, level);\n\n    rt_list_remove(&object_ptr->list);\n\n    rt_spin_unlock_irqrestore(&object_ptr->spinlock, level);\n\n    object_ptr->type = 0;\n}", "CodeBleu_score": 47.52852830270525}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t  rt_err_t err;\n  rt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n  if (!custom_obj) {\n    return RT_ERROR_NULL_PTR;\n  }\n  if (custom_obj->type != RT_CUSTOM_OBJECT) {\n    return RT_ERROR_INVALID_OBJECT_TYPE;\n  }\n  if (custom_obj->destroy) {\n    err = custom_obj->destroy(custom_obj);\n  } else {\n    err = RT_ERROR_OK;\n  }\n  rt_object_delete(custom_obj);\n  return err;\n}", "CodeBleu_score": 46.817986988418355}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_ERR_UNKNOWN;\n    rt_object_t *pobj = (rt_object_t *) obj;\n    rt_object_t *pobj_class = (rt_object_t *) pobj->class;\n    rt_object_t *pobj_class_destroy = (rt_object_t *) pobj_class->destroy;\n    if (pobj_class_destroy != NULL) {\n        result = ((rt_custom_object_destroy_t) pobj_class_destroy)(pobj);\n    }\n    rt_object_delete(pobj);\n    return result;\n}", "CodeBleu_score": 33.73141565378936}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t  rt_err_t err;\n  rt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n  if (custom_obj == NULL) {\n    return RT_ERR_INVALID_OBJECT;\n  }\n  if (custom_obj->type != RT_CUSTOM_OBJECT) {\n    return RT_ERR_INVALID_OBJECT_TYPE;\n  }\n  if (custom_obj->destroy != NULL) {\n    err = custom_obj->destroy(obj);\n  } else {\n    err = RT_ERR_OK;\n  }\n  rt_object_delete(obj);\n  return err;\n}", "CodeBleu_score": 46.45129458667371}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\n\tthread = rt_thread_self();\n\tif (thread != RT_NULL) {\n\t\trt_enter_critical();\n\t\trt_thread_close(thread);\n\t\trt_exit_critical_safe();\n\t\trt_schedule();\n\t}\n}", "CodeBleu_score": 58.18299192069837}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n    rt_thread_t next;\n    rt_base_t level;\n\n    /* Get current thread */\n    thread = rt_thread_self();\n\n    /* Enter critical section */\n    level = rt_enter_critical();\n\n    /* Close thread */\n    rt_thread_close(thread);\n\n    /* Enqueue thread to defunct list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* Exit critical section */\n    rt_exit_critical_safe(level);\n\n    /* Trigger a context switch */\n    rt_schedule();\n}", "CodeBleu_score": 72.01802517756786}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread = rt_thread_self();\n    rt_enter_critical();\n    rt_thread_close(thread);\n    rt_exit_critical_safe();\n    rt_thread_defunct_enqueue(thread);\n    rt_schedule();\n}", "CodeBleu_score": 58.812012894100405}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t  rt_thread_t thread = (rt_thread_t)parameter;\n\n  /* parameter check */\n  RT_ASSERT(thread);\n\n  /* lock the scheduler */\n  rt_sched_lock();\n\n  /* check the thread is suspended */\n  RT_ASSERT(rt_thread_is_suspended(thread));\n\n  /* set the thread's error number to a timeout value */\n  thread->error = RT_ETIMEOUT;\n\n  /* remove the thread from the suspend list */\n  rt_list_remove(&(thread->tlist));\n\n  /* insert the thread into the ready list */\n  rt_sched_insert_thread(thread);\n\n  /* unlock the scheduler to reschedule */\n  rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 42.50566736518526}, {"code": "static void _thread_timeout(void *parameter){\n\t  rt_thread_t thread = (rt_thread_t)parameter;\n  rt_err_t result;\n\n  /* parameter check */\n  RT_ASSERT(thread != RT_NULL);\n\n  /* lock the scheduler */\n  result = rt_sched_lock();\n  if (result != RT_EOK) {\n    return;\n  }\n\n  /* verify the thread is suspended */\n  if (thread->current_priority != RT_THREAD_PRIORITY_MAX) {\n    goto _thread_timeout_exit;\n  }\n\n  /* set the thread's error number to a timeout value */\n  thread->error = RT_ETIMEOUT;\n\n  /* remove the thread from the suspend list */\n  rt_list_remove(&(thread->tlist));\n\n  /* insert the thread into the ready list */\n  rt_sched_insert_thread(thread, RT_SCHEDULER_RR);\n\n  /* unlock the scheduler */\n  rt_sched_unlock();\n\n  /* reschedule */\n  rt_sched_resume(thread);\n\n_thread_timeout_exit:\n  /* unlock the scheduler */\n  rt_sched_unlock();\n\n  return;\n}", "CodeBleu_score": 44.32685458934911}, {"code": "static void _thread_timeout(void *parameter){\n\t\n\trt_thread_t thread = (rt_thread_t)parameter;\n\trt_err_t result;\n\n\tresult = rt_sched_lock();\n\tif (result != RT_EOK) {\n\t\treturn;\n\t}\n\n\tif (rt_sched_thread_is_suspended(thread) != RT_TRUE) {\n\t\trt_sched_unlock();\n\t\treturn;\n\t}\n\n\trt_thread_set_errno(thread, RT_ETIMEOUT);\n\trt_list_remove(&(thread->tlist));\n\trt_sched_insert_thread(thread, RT_THREAD_LIST_READY);\n\trt_sched_unlock_n_resched();\n}", "CodeBleu_score": 38.96625889988238}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_list_t *node;\n\trt_mutex_t *mutex;\n\trt_thread_t thread_to_detach;\n\n\trt_spin_lock_irqsave(&thread->spinlock, level);\n\n\tif (thread->pending_object) {\n\t\tmutex = (rt_mutex_t *) thread->pending_object;\n\t\trt_list_for_each_safe(node, &mutex->wait_list, list) {\n\t\t\tthread_to_detach = rt_list_entry(node, rt_thread_t, list);\n\t\t\tif (thread_to_detach == thread) {\n\t\t\t\trt_list_del(&thread_to_detach->list);\n\t\t\t\tthread_to_detach->pending_object = RT_NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\trt_mutex_release(thread);\n\n\trt_spin_unlock_irqrestore(&thread->spinlock, level);\n}", "CodeBleu_score": 51.0660870519386}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_mutex_t mutex;\n\n    level = rt_spin_lock_irqsave();\n\n    if (thread->wait_mutex != RT_NULL) {\n        mutex = thread->wait_mutex;\n        thread->wait_mutex = RT_NULL;\n        rt_mutex_remove_waiting_thread(mutex, thread);\n    }\n\n    rt_mutex_release(thread->taken_mutex);\n    thread->taken_mutex = RT_NULL;\n\n    rt_spin_unlock_irqrestore(level);\n}", "CodeBleu_score": 33.97807704448856}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_list_t *node;\n    rt_thread_t owner;\n\n    /* lock the thread's spinlock */\n    level = rt_spin_lock_irqsave();\n\n    /* check if the thread is waiting on a mutex */\n    node = rt_list_entry(thread->wait_list.next, rt_list_t, next);\n    if (node != &thread->wait_list) {\n        /* remove the thread from the mutex's waiting list */\n        rt_list_del(&thread->wait_list);\n        /* clear the pending object */\n        thread->pending_object = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    rt_mutex_release(thread->mutex_list);\n\n    /* restore the spinlock state */\n    rt_spin_unlock_irqrestore(level);\n}", "CodeBleu_score": 34.88089509148327}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result = RT_EOK;\n    rt_base_t level;\n    rt_uint32_t thread_state;\n    rt_uint32_t thread_type;\n    rt_uint32_t thread_flag;\n    rt_uint32_t thread_prio;\n    rt_uint32_t thread_prio_mask;\n    rt_uint32_t thread_prio_max;\n    rt_uint32_t thread_prio_min;\n    rt_uint32_t thread_prio_init;\n    rt_uint32_t thread_prio_cur;\n    rt_uint32_t thread_prio_max_cur;\n    rt_uint32_t thread_prio_min_cur;\n    rt_uint32_t thread_prio_init_cur;\n    rt_uint32_t thread_prio_max_init;\n    rt_uint32_t thread_prio_min_init;\n    rt_uint32_t thread_prio_max_init_cur;\n    rt_uint32_t thread_prio_min_init_cur;\n    rt_uint32_t thread_prio_max_cur_init;\n    rt_uint32_t thread_prio_min_cur_init;\n    rt_uint32_t thread_prio_max_cur_init_cur;\n    rt_uint32_t thread_prio_min_cur_init_cur;\n    rt_uint32_t thread_prio_max_init_cur_init;\n    rt_uint32_t thread_prio_min_init_cur_init;\n    rt_uint32_t thread_prio_max_init_cur_init_cur;\n    rt_uint32_t thread_prio_min_init_cur_init_cur;\n    rt_uint32_t thread_prio_max_init_cur_init_cur_", "CodeBleu_score": 5.706757181257799}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->state == RT_Thread_State_Initializing);\n\n    LOG_D(\"thread:%s prio:%d\", thread->name, thread->current_priority);\n\n    /* calculate the thread's priority attributes */\n    rt_thread_priority_calculate(thread);\n\n    /* reset the thread state to suspended */\n    thread->state = RT_Thread_State_Suspended;\n\n    /* resume the thread */\n    rt_thread_resume(thread);\n\n    /* trigger a scheduler if available */\n    if (rt_sched_thread_startup(thread) == RT_EOK) {\n        return RT_EOK;\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 58.45546886949593}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n    rt_base_t priority;\n    rt_uint32_t prio_attr;\n    rt_list_t *ready_list;\n    rt_list_t *suspend_list;\n    rt_list_t *wait_list;\n    rt_list_t *thread_list;\n    rt_list_t *thread_list_tail;\n    rt_thread_t current_thread;\n    rt_thread_t prev_thread;\n    rt_uint32_t flags;\n    rt_uint32_t wait_flag;\n    rt_uint32_t suspend_flag;\n    rt_uint32_t ready_flag;\n    rt_uint32_t thread_flag;\n    rt_list_node_t *node;\n    rt_list_node_t *node_next;\n    rt_list_node_t *node_prev;\n    rt_list_node_t *node_thread;\n    rt_list_node_t *node_thread_next;\n    rt_list_node_t *node_thread_prev;\n    rt_list_node_t *node_ready;\n    rt_list_node_t *node_ready_next;\n    rt_list_node_t *node_ready_prev;\n    rt_list_node_t *node_suspend;\n    rt_list_node_t *node_suspend_next;\n    rt_list_node_t *node_suspend_prev;\n    rt_list_node_t *node_wait;\n    rt_list_node_t *node_wait_next;\n    rt_list_node_t *node_wait_prev;\n    rt_list_node_t *node_thread_tail;\n    rt_list_node_t *node_thread_tail_next;\n    rt_list_node_t *node_thread_tail_prev;\n    rt_list_node_t *node_ready_tail;\n    rt", "CodeBleu_score": 5.40152579597703}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t  rt_uint32_t i;\n  rt_list_t *timer_entry_list;\n  rt_timer_t *timer;\n  rt_tick_t timeout;\n\n  /* find the first non-empty timer list */\n  for (i = 0; i < RT_TIMER_MAX_TIMERS; i++) {\n    timer_entry_list = &timer_list[i];\n    if (!rt_list_isempty(timer_entry_list)) {\n      break;\n    }\n  }\n\n  /* no timer list is not empty */\n  if (i == RT_TIMER_MAX_TIMERS) {\n    return -RT_ETIMEOUT;\n  }\n\n  /* get the first timer entry */\n  timer_entry_list = &timer_list[i];\n  timer = rt_list_entry(timer_entry_list->next, rt_timer_t, list);\n\n  /* get the timeout tick */\n  timeout = timer->timeout;\n\n  /* set the timeout tick */\n  *timeout_tick = timeout;\n\n  return RT_EOK;\n}", "CodeBleu_score": 35.79709185265089}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t  rt_uint32_t i;\n  rt_list_t *list;\n  rt_timer_t *timer;\n\n  /* get the highest level of the timer skip list */\n  for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++) {\n    list = &timer_list[i];\n    if (!rt_list_isempty(list)) {\n      /* get the first timer entry */\n      timer = rt_list_entry(list->next, rt_timer_t, list);\n      /* set the timeout tick to the timer's timeout value */\n      *timeout_tick = timer->timeout_tick;\n      /* return RT_EOK */\n      return RT_EOK;\n    }\n  }\n\n  /* return an error code */\n  return -RT_ERROR;\n}", "CodeBleu_score": 43.73882361594559}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *timer_entry;\n    rt_err_t result = RT_ETIMEOUT;\n\n    /* check if the highest level of the timer skip list is not empty */\n    if (!rt_list_isempty(timer_list)) {\n        /* get the first timer entry */\n        timer_entry = rt_list_entry(timer_list[0].next, rt_list_t, sibling);\n        /* set the timeout tick to the timer's timeout value */\n        *timeout_tick = timer_entry->timeout;\n        result = RT_EOK;\n    }\n\n    return result;\n}", "CodeBleu_score": 43.595966750335116}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* check the arguments */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time <= RT_TICK_MAX);\n\n    /* allocate memory for the timer object */\n    timer = (rt_timer_t)rt_object_allocate(\"timer\", sizeof(struct rt_timer_object));\n    if (timer != RT_NULL) {\n        /* initialize the timer object */\n        rt_strncpy(timer->name, name, RT_NAME_MAX);\n        timer->timeout = timeout;\n        timer->parameter = parameter;\n        timer->flag = flag;\n        timer->time = time;\n        timer->current = time;\n        timer->parent.type = RT_Object_Class_Timer;\n        timer->parent.ref_count = 1;\n        timer->parent.deinit = rt_timer_delete;\n\n        /* insert the timer object into the timer list */\n        rt_timer_insert(timer);\n    }\n\n    return timer;\n}", "CodeBleu_score": 48.58175447525496}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    rt_timer_t timer = rt_object_allocate(RT_Object_Class_Timer);\n    if (timer != RT_NULL) {\n        timer->name = name;\n        timer->timeout = timeout;\n        timer->parameter = parameter;\n        timer->time = time;\n        timer->flag = flag;\n        timer->list.next = RT_NULL;\n        timer->list.prev = RT_NULL;\n    }\n\n    return timer;\n}", "CodeBleu_score": 53.49647373817945}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\n  RT_ASSERT(timeout);\n  RT_ASSERT(time <= RT_TICK_MAX);\n\n  /* allocate a timer object */\n  rt_timer_t timer = rt_object_allocate(RT_Object_Class_Timer);\n  if (timer != RT_NULL) {\n    /* initialize the timer object */\n    rt_timer_init(timer, name, timeout, parameter, time, flag);\n  }\n\n  return timer;\n}", "CodeBleu_score": 54.70838785805567}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t    rec := httptest.NewRecorder()\n    a.handler.ServeHTTP(rec, req)\n    for k, v := range rec.Header() {\n        res.Header()[k] = v\n    }\n    if rec.Code == http.StatusUnauthorized {\n        http.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n        return\n    }\n    a.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 72.16348465604229}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t    rec := httptest.NewRecorder()\n    a.router.ServeHTTP(rec, req)\n    for k, v := range rec.Header() {\n        res.Header()[k] = v\n    }\n    if rec.Code == 401 {\n        http.Error(res, \"Not Authorized\", 401)\n        return\n    }\n    rec.Body.WriteTo(res)\n}", "CodeBleu_score": 53.88754211751709}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tres.WriteHeader(rec.Code)\n\tif rec.Code != http.StatusUnauthorized {\n\t\tres.Write(rec.Body.Bytes())\n\t} else {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 56.35976128054845}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tparts := strings.Split(path, \"/\")\n\tif len(parts) < 2 {\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tasset, err := a.assets.Get(parts[1])\n\tif err != nil {\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tswitch parts[1] {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tdefault:\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 61.14090439398896}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := a.assets.Get(req.URL.Path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", a.getContentType(asset.Name()))\n\tres.Write(asset)\n}", "CodeBleu_score": 38.25330573528433}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tparts := strings.Split(path, \"/\")\n\tassetName := parts[len(parts)-1]\n\tasset, err := a.assets.Get(assetName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", a.assets.MimeType(assetName))\n\tres.Write(asset)\n}", "CodeBleu_score": 50.11279684013471}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot found with name: \" + name})\n\t\treturn\n\t}\n\n\tconnections := []map[string]interface{}{}\n\trobot.Connections().Each(func(conn gobot.Connection) {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"Name\":        conn.Name(),\n\t\t\t\"Commands\":    conn.Commands(),\n\t\t\t\"DefaultName\": conn.DefaultName(),\n\t\t\t\"Options\":     conn.Options(),\n\t\t\t\"Adaptor\":     conn.Adaptor().Name(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 50.783620953078824}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"robot\")\n\n\trobot, err := a.master.Robot(name)\n\tif err != nil {\n\t\ta.writeJSON(res, struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{\n\t\t\tError: fmt.Sprintf(\"No robot named %s\", name),\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := []*gobot.JSONConnection{}\n\trobot.Connections().Each(func(connection *gobot.Connection) {\n\t\tconnections = append(connections, connection.ToJSON())\n\t})\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 53.22625479498766}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot found with name \" + robotName})\n\t\treturn\n\t}\n\n\tconnections := make(map[string]interface{})\n\trobot.Connections().Each(func(name string, connection interface{}) {\n\t\tconnections[name] = connection\n\t})\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 38.75008568703298}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.748683215040515}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\tauth := r.Header.Get(\"Authorization\")\n\n\t\t// Check if the \"Authorization\" header starts with \"Basic \".\n\t\tif !strings.HasPrefix(auth, \"Basic \") {\n\t\t\t// If not, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response with a 401 status code.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Remove the \"Basic \" prefix from the \"Authorization\" header.\n\t\tauth = auth[6:]\n\n\t\t// Decode the base64-encoded username and password from the \"Authorization\" header.\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err != nil {\n\t\t\t// If decoding fails, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response with a 401 status code.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the decoded string into the username and password.\n\t\tparts := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(parts) != 2 {\n\t\t\t// If the decoded string does not contain a colon, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response with a 401 status code.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password from the \"Authorization\" header with the provided username and password.\n\t\tif !secureCompare(parts[0], username)", "CodeBleu_score": 49.39539052490599}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.748683215040515}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\n\tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\n\tslope := float64(toRange) / float64(fromRange)\n\tintercept := float64(toMin) - slope*float64(fromMin)\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.180199037345744}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept of the linear transformation\n\tslope := float64(toMax - toMin) / float64(fromMax - fromMin)\n\tintercept := float64(toMin) - slope*float64(fromMin)\n\n\t// Return the function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\t// Apply the linear transformation to the input value\n\t\tscaledValue := int(slope*input + intercept)\n\n\t\t// Clamp the scaled value to the target range\n\t\tif scaledValue < toMin {\n\t\t\tscaledValue = toMin\n\t\t} else if scaledValue > toMax {\n\t\t\tscaledValue = toMax\n\t\t}\n\n\t\treturn scaledValue\n\t}\n}", "CodeBleu_score": 53.010400604697864}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\tslope := toRange / fromRange\n\tintercept := toMin - (fromMin * slope)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(input * slope + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 49.879533149577725}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.sensorCfg.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 52.63651282092352}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection is nil\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) * a.sensorCfg.scale\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 52.82261693096847}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog read\", a.Connection().Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) * a.sensorCfg.scale\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 57.87633654626491}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tscale := float64(toMax-toMin) / float64(fromMax-fromMin)\n\tintercept := toMin - scale*float64(fromMin)\n\treturn func(value int) float64 {\n\t\treturn scale*float64(value) + intercept\n\t}\n}", "CodeBleu_score": 42.362013659464516}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - m*float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 51.822128377076005}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\n\tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\n\tm := toRange / float64(fromRange)\n\tn := toMin - m * float64(fromMin)\n\n\treturn func(input int) float64 {\n\t\treturn m * float64(input) + n\n\t}\n}", "CodeBleu_score": 57.923632927350624}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(d.Event)\n\n\td.On(d.Event(), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(), data)\n\t\t}\n\t})\n\n\tif err := d.AnalogSensorDriver.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 57.17527894012255}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(d.Event(\"vibration\"))\n\td.On(d.Event(\"data\"), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(\"vibration\"), data)\n\t\t}\n\t})\n\tif err := d.SetDataHandler(func(data interface{}) {\n\t\td.Publish(d.Event(\"data\"), data)\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 59.96964598210302}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(Vibration)\n\td.On(Data, func(data interface{}) {\n\t\tif d.threshold < float64(data.(int)) {\n\t\t\td.Publish(Vibration, data)\n\t\t}\n\t})\n\tif err := d.AnalogSensorDriver.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 54.723970583453685}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\tif d.pwm == nil {\n\t\treturn ErrPWMNotSupported\n\t}\n\n\tperiod := time.Duration(1.0 / hz * 1e9)\n\tbeatsPerMinute := float64(d.pwm.Period()) / float64(d.pwm.Max()) * 60\n\ttempo := time.Duration(1.0 / beatsPerMinute * 1e9)\n\n\td.pwm.Set(0, 1)\n\ttime.Sleep(tempo)\n\n\tfor i := 0; i < int(duration/tempo); i++ {\n\t\td.pwm.Set(0, 1)\n\t\ttime.Sleep(period)\n\t\td.pwm.Set(0, 0)\n\t\ttime.Sleep(period)\n\t}\n\n\td.pwm.Set(0, 0)\n\n\treturn nil\n}", "CodeBleu_score": 32.24421685186806}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.Pin == noPin {\n\t\treturn ErrBadPin\n\t}\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\tif d.isOn {\n\t\treturn ErrDeviceBusy\n\t}\n\td.isOn = true\n\tdefer func() { d.isOn = false }()\n\n\t// Calculate the tone period based on the given frequency and the tempo\n\ttonePeriod := time.Duration(float64(time.Second) / hz)\n\ttempo := time.Duration(float64(time.Minute) / (60 * hz))\n\n\t// Calculate the duration of the tone based on the given duration and the tempo\n\tduration = duration * float64(time.Minute) / (60 * hz)\n\n\t// Turn the buzzer on and off at intervals determined by the tone period\n\tfor i := 0; i < int(duration); i += int(tempo) {\n\t\td.On()\n\t\ttime.Sleep(tonePeriod)\n\t\td.Off()\n\t\ttime.Sleep(tonePeriod)\n\t}\n\treturn nil\n}", "CodeBleu_score": 34.999424577350496}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\n\t// Calculate the tone period based on the frequency and the tempo\n\tperiod := (60 / d.BPM) * 1000 * 1000\n\n\t// Calculate the number of times to toggle the buzzer on and off\n\ttimes := int(duration * 1000 * 1000 / period)\n\n\t// Loop through the specified number of times\n\tfor i := 0; i < times; i++ {\n\t\t// Turn the buzzer on\n\t\terr := d.On()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(period))\n\n\t\t// Turn the buzzer off\n\t\terr = d.Off()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(period))\n\t}\n\n\t// Return nil if the tone was played successfully\n\treturn nil\n}", "CodeBleu_score": 51.41446535331428}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"Sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, LOW)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.312522299424323}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, LOW)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.528340806641403}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, LOW)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.528340806641403}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor pins map is not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = a.sys.NewAnalogPin(pin)\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 53.25426539597291}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor pins map is nil\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp := a.sys.NewAnalogPin(path, params...)\n\ta.pins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 53.4527230698568}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor pins map is not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = a.sys.NewAnalogPin(pin)\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 53.25426539597291}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.WithPinDirectionOutput(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 66.50902858598684}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 63.420740034358516}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.WithPinDirectionOutput(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 66.50902858598684}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"digital pin adaptor not connected to pins\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line := a.translate(id)\n\t\tpin = a.sys.NewDigitalPin(chip, line)\n\t\tpin.ApplyOptions(opts...)\n\t\ta.pins[id] = pin\n\t} else {\n\t\tpin.ApplyOptions(opts...)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 35.86474385738203}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.connected {\n\t\treturn nil, fmt.Errorf(\"Adaptor must be connected to initialize pin\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = a.sys.NewDigitalPin(chip, line)\n\t\tpin.ApplyOptions(opts...)\n\n\t\ta.pins[id] = pin\n\t} else {\n\t\tpin.ApplyOptions(opts...)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 50.01797576801573}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.digitalPins == nil {\n\t\treturn nil, fmt.Errorf(\"digital pins not connected\")\n\t}\n\n\tpin, ok := a.digitalPins[id]\n\tif !ok {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = a.sys.NewDigitalPin(chip, line)\n\t\tpin.ApplyOptions(opts...)\n\t\ta.digitalPins[id] = pin\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 48.117065208278696}]}
