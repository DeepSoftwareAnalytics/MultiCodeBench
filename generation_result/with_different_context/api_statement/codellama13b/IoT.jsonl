{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bLength != 0 && desc->bDescriptorType != desc_id) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn desc->bLength ? desc : NULL;\n}", "CodeBleu_score": 28.220277126919015}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\n\twhile (next_desc->bLength != 0 &&\n\t\t\tnext_desc->bDescriptorType != desc_id) {\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t\t((uint8_t UDC_DESC_STORAGE *) next_desc + next_desc->bLength);\n\t}\n\tif (next_desc->bLength == 0) {\n\t\tnext_desc = NULL;\n\t}\n\treturn next_desc;\n}", "CodeBleu_score": 34.767658536040095}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *p = (uint8_t *) desc;\n\n\twhile (p[1] != 0) {\n\t\tif (p[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p;\n\t\t}\n\t\tp += p[0];\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 24.872997759067044}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *p = udc_config_desc;\n\tuint8_t i;\n\tstruct udc_iface_desc *iface_desc;\n\tstruct udc_ep_desc *ep_desc;\n\n\tif (udc_config_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Iterate through the descriptors, starting from the beginning of the configuration descriptor, and check each one to see if it matches the specified interface number and setting number.\n\t */\n\twhile (p < udc_config_desc + udc_config_desc->wTotalLength) {\n\t\tif (p[1] == UDC_DT_INTERFACE) {\n\t\t\tiface_desc = (struct udc_iface_desc *) p;\n\t\t\tif (iface_desc->bInterfaceNumber == iface_num) {\n\t\t\t\tfor (i = 0; i < iface_desc->bNumEndpoints; i++) {\n\t\t\t\t\tep_desc = (struct udc_ep_desc *) (p + iface_desc->bLength);\n\t\t\t\t\tif (ep_desc->bEndpointAddress & 0x80) {\n\t\t\t\t\t\tif (ep_desc->bEndpointAddress & 0x0F) {\n\t\t\t\t\t\t\tif (ep_desc->bEndpointAddress & 0x0F == setting_num) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp += p[0];\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.16042622177423}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tudc_desc_t *desc;\n\tuint8_t *p;\n\tuint8_t *p_end;\n\tuint8_t i;\n\tuint8_t iface_setting_num;\n\tuint8_t iface_num_found;\n\tuint8_t iface_desc_len;\n\tuint8_t iface_desc_type;\n\n\tif (udc_config_num == 0) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_num_interfaces) {\n\t\treturn false;\n\t}\n\n\tdesc = udc_config_desc;\n\tp = desc->data;\n\tp_end = desc->data + desc->len;\n\n\tiface_num_found = 0;\n\n\twhile (p < p_end) {\n\t\tiface_desc_len = p[0];\n\t\tiface_desc_type = p[1];\n\n\t\tif (iface_desc_type == UDC_DESC_TYPE_INTERFACE) {\n\t\t\tiface_setting_num = p[4];\n\n\t\t\tif (iface_num_found == iface_num) {\n\t\t\t\tif (iface_setting_num == setting_num) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tiface_num_found++;\n\t\t}\n\n\t\tp += iface_desc_len;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 43.15516352292825}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    uint8_t *p_desc;\n    uint8_t *p_end;\n    uint8_t iface_desc_length;\n    uint8_t iface_desc_type;\n    uint8_t iface_desc_iface_num;\n    uint8_t iface_desc_setting_num;\n\n    /* Check if the interface number is in bounds */\n    if (iface_num >= udc_num_interfaces) {\n        return false;\n    }\n\n    /* Check if there is a valid configuration */\n    if (udc_config_num == 0) {\n        return false;\n    }\n\n    /* Get the start of the current configuration descriptor */\n    p_desc = udc_config_desc + 1;\n\n    /* Get the end of the current configuration descriptor */\n    p_end = udc_config_desc + udc_config_desc[0];\n\n    /* Iterate through the descriptors */\n    while (p_desc < p_end) {\n        /* Get the length of the current descriptor */\n        iface_desc_length = p_desc[0];\n\n        /* Get the type of the current descriptor */\n        iface_desc_type = p_desc[1];\n\n        /* If the current descriptor is an interface descriptor */\n        if (iface_desc_type == UDC_DESC_TYPE_IFACE) {\n            /* Get the interface number of the current interface descriptor */\n            iface_desc_iface_num = p_desc[2];\n\n            /* Get the setting number of the current interface descriptor */\n            iface_desc_setting_num = p_desc[4];\n\n            /* If the current interface descriptor matches the specified interface number and setting number */\n            if ((iface_desc_iface_num == iface_num) && (iface_desc_setting_num == setting_num)) {\n                /* Return \"true\" */\n                return true;\n            }\n        }\n\n        /* Advance to the next descriptor */\n        p_desc += iface_desc_length;\n    }\n\n    /* Return \"false\" */\n    return", "CodeBleu_score": 39.55853244992206}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength != sizeof(udd_ep_status_t)) {\n\t\treturn false;\n\t}\n\tudd_g_ctrlreq.payload = (uint8_t *)&udd_ep_status;\n\tudd_g_ctrlreq.payload_size = sizeof(udd_ep_status_t);\n\tudd_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.wIndex);\n\treturn true;\n}", "CodeBleu_score": 52.051688311942634}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tudd_g_ctrlreq.payload_size = sizeof(udd_ep_is_halted);\n\tif (udd_g_ctrlreq.req.wLength != udd_g_ctrlreq.payload_size) {\n\t\treturn false;\n\t}\n\tudd_set_setup_payload(udd_ep_is_halted);\n\treturn true;\n}", "CodeBleu_score": 37.59096726969416}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep;\n\tuint8_t ep_status;\n\tuint8_t *payload;\n\tuint8_t *p;\n\tuint8_t *p_end;\n\n\t// Check if the request length matches the size of the endpoint status variable\n\tif (udd_g_ctrlreq.req.wLength != sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\t// Determine the status of the specified endpoint, setting the status to \"halted\" if the endpoint is halted, or \"0\" if it is not\n\tep = udd_g_ctrlreq.req.wIndex & USB_EP_ADDR_MASK;\n\tif (udd_ep_is_halted(ep)) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\t// Set up the response payload with the endpoint status\n\tpayload = (uint8_t *)&udd_g_ctrlreq.payload;\n\tp = payload;\n\tp_end = payload + sizeof(ep_status);\n\tdo {\n\t\t*p++ = ep_status;\n\t} while (p != p_end);\n\n\t// Return \"true\" to indicate that the standard request was successfully handled\n\treturn true;\n}", "CodeBleu_score": 55.794489710054165}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tudi_api_t *udi_api;\n\tudi_ubit8_t iface_num;\n\tudi_ubit8_t iface_alt_setting;\n\tudi_ubit8_t iface_protocol;\n\tudi_ubit8_t iface_index;\n\tudi_ubit8_t iface_num_endpoints;\n\tudi_ubit8_t iface_class;\n\tudi_ubit8_t iface_subclass;\n\tudi_ubit8_t iface_protocol;\n\tudi_ubit8_t iface_index;\n\tudi_ubit8_t iface_num_endpoints;\n\tudi_ubit8_t iface_class;\n\tudi_ubit8_t iface_subclass;\n\tudi_ubit8_t iface_protocol;\n\tudi_ubit8_t iface_index;\n\tudi_ubit8_t iface_num_endpoints;\n\tudi_ubit8_t iface_class;\n\tudi_ubit8_t iface_subclass;\n\tudi_ubit8_t iface_protocol;\n\tudi_ubit8_t iface_index;\n\tudi_ubit8_t iface_num_endpoints;\n\tudi_ubit8_t iface_class;\n\tudi_ubit8_t iface_subclass;\n\tudi_ubit8_t iface_protocol;\n\tudi_ubit8_t iface_index;\n\tudi_ubit8_t iface_num_endpoints;\n\tudi_ubit8_t iface_class;\n\tudi_ubit8_t iface_subclass;\n\tudi_ubit8_t iface_protocol;\n\tudi_ubit8_t iface_index;\n\tudi_ubit8_t iface_num_endpoints;\n\tudi_ubit8_t iface_class;\n\tudi_ubit8_t iface_subclass;\n\tudi_ubit8_t iface_protocol;\n\tudi_ubit8_t iface_index", "CodeBleu_score": 5.665180640703192}, {"code": "static bool udc_req_iface(void){\n\t\tudi_api_t *udi_api;\n\tudi_ubit8_t iface_num;\n\tudi_ubit8_t alt_setting;\n\tudi_ubit8_t *iface_desc;\n\tudi_ubit8_t *alt_desc;\n\tudi_ubit8_t *cur_desc;\n\tudi_ubit8_t *new_desc;\n\tudi_ubit8_t *cur_setting;\n\tudi_ubit8_t *new_setting;\n\tudi_ubit8_t *cur_data;\n\tudi_ubit8_t *new_data;\n\tudi_ubit8_t *cur_extra;\n\tudi_ubit8_t *new_extra;\n\tudi_ubit8_t *cur_str;\n\tudi_ubit8_t *new_str;\n\tudi_ubit8_t *cur_extra_str;\n\tudi_ubit8_t *new_extra_str;\n\tudi_ubit8_t *cur_extra_data;\n\tudi_ubit8_t *new_extra_data;\n\tudi_ubit8_t *cur_extra_alt;\n\tudi_ubit8_t *new_extra_alt;\n\tudi_ubit8_t *cur_extra_setting;\n\tudi_ubit8_t *new_extra_setting;\n\tudi_ubit8_t *cur_extra_iface;\n\tudi_ubit8_t *new_extra_iface;\n\tudi_ubit8_t *cur_extra_endpoint;\n\tudi_ubit8_t *new_extra_endpoint;\n\tudi_ubit8_t *cur_extra_interface;\n\tudi_ubit8_t *new_extra_interface;\n\tudi_ubit8_t *cur_extra_string;\n\tudi_ubit8_t *new_extra_string;\n\tudi_ubit8_t *cur_extra_iface_assoc;\n\tudi_ubit8_t *new_extra_iface_assoc;\n\tudi_ubit8_t", "CodeBleu_score": 5.439448687059244}, {"code": "static bool udc_req_iface(void){\n\t\tudi_api_t *udi_api;\n\tudi_ubit8_t iface_num;\n\tudi_ubit8_t alt_setting;\n\tudi_ubit8_t iface_desc_len;\n\tudi_iface_data_t *iface_data;\n\tudi_ubit8_t *iface_desc;\n\tudi_ubit32_t result;\n\n\tiface_num = ureq->wIndex;\n\talt_setting = ureq->wValue;\n\tudi_api = udi_apis[iface_num];\n\tiface_data = udi_apis_data[iface_num];\n\tiface_desc = iface_data->iface_desc;\n\tiface_desc_len = iface_desc[0];\n\tif (iface_desc_len < 9)\n\t\treturn false;\n\tif (iface_desc[7] != alt_setting)\n\t\treturn false;\n\tif (iface_desc[4] != 0)\n\t\treturn false;\n\tif (iface_desc[5] != 0)\n\t\treturn false;\n\tif (iface_desc[6] != 0)\n\t\treturn false;\n\tif (iface_desc[7] != 0)\n\t\treturn false;\n\tif (iface_desc[8] != 0)\n\t\treturn false;\n\tif (iface_desc[9] != 0)\n\t\treturn false;\n\tif (iface_desc[10] != 0)\n\t\treturn false;\n\tif (iface_desc[11] != 0)\n\t\treturn false;\n\tif (iface_desc[12] != 0)\n\t\treturn false;\n\tif (iface_desc[13] != 0)\n\t\treturn false;\n\tif (iface_desc[14] != 0)\n\t\treturn false;\n\tif (iface_desc[15] != 0)\n\t\treturn false;\n\tif (iface_desc[16] != 0)\n\t\treturn false", "CodeBleu_score": 32.90306358077983}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\tuint8_t i;\n\tudi_msc_cbw_wait = true;\n\tudi_msc_cbw_reset_recovery = false;\n\tudi_msc_cbw_reset_recovery_delay = 0;\n\tudi_msc_cbw_reset_recovery_timer = 0;\n\tudi_msc_cbw_reset_recovery_timer_delay = 0;\n\tudi_msc_cbw_reset_recovery_timer_delay_max = 0;\n\tudi_msc_cbw_reset_recovery_timer_delay_max_default = 0;\n\tudi_msc_cbw_reset_recovery_timer_delay_max_default_valid = false;\n\tudi_msc_cbw_reset_recovery_timer_delay_max_valid = false;\n\tudi_msc_cbw_reset_recovery_timer_delay_valid = false;\n\tudi_msc_cbw_reset_recovery_timer_valid = false;\n\tudi_msc_cbw_reset_recovery_valid = false;\n\tudi_msc_cbw_reset_recovery_delay_valid = false;\n\tudi_msc_cbw_reset_recovery_delay_max_valid = false;\n\tudi_msc_cbw_reset_recovery_delay_max_default_valid = false;\n\tudi_msc_cbw_reset_recovery_delay_max_default = 0;\n\tudi_msc_cbw_reset_recovery_delay = 0;\n\tudi_msc_cbw_reset_recovery_delay_max = 0;\n\tudi_msc_cbw_reset_recovery_delay_max_default = 0;\n\tudi_msc_cbw_reset_recovery_delay_max_default_valid = false;\n\tudi_msc_cbw_reset_recovery_delay_max_valid = false;\n\tudi_msc_cbw_reset_recovery_delay_valid = false;\n\tudi_msc_cbw_reset_recovery_timer_valid =", "CodeBleu_score": 33.55012800192975}, {"code": "bool udi_msc_enable(void){\n\t\tbool b_lun_found = false;\n\tuint8_t i;\n\tudi_msc_cbw_wait = true;\n\tudi_msc_nb_lun = 0;\n\tfor (i=0;i<UDI_MSC_NB_LUN;i++) {\n\t\tudi_msc_mem[i].b_mem_unload = true;\n\t\tudi_msc_mem[i].b_mem_eject = false;\n\t\tudi_msc_mem[i].b_mem_invalid = false;\n\t\tudi_msc_mem[i].b_mem_protected = false;\n\t\tudi_msc_mem[i].b_mem_write_protected = false;\n\t\tudi_msc_mem[i].b_mem_removable = false;\n\t\tudi_msc_mem[i].b_mem_unload = false;\n\t\tudi_msc_mem[i].b_mem_load = false;\n\t\tudi_msc_mem[i].b_mem_ready = false;\n\t\tudi_msc_mem[i].b_mem_check_request = false;\n\t\tudi_msc_mem[i].b_mem_check = false;\n\t\tudi_msc_mem[i].b_mem_stop_trans = false;\n\t\tudi_msc_mem[i].b_mem_start_trans = false;\n\t\tudi_msc_mem[i].b_mem_reset = false;\n\t\tudi_msc_mem[i].b_mem_bad_block = false;\n\t\tudi_msc_mem[i].b_mem_bad_block_no_good_block = false;\n\t\tudi_msc_mem[i].b_mem_bad_block_no_good_block_stop_trans = false;\n\t\tudi_msc_mem[i].b_mem_bad_block_no_good_block_start_trans = false;\n\t\tudi_msc_mem[i].b_mem_bad_block_no_good_block_reset = false;\n\t\t", "CodeBleu_score": 24.121864822226375}, {"code": "bool udi_msc_enable(void){\n\t\tbool b_lun_available = false;\n\tuint8_t i;\n\tudi_msc_cbw_wait = true;\n\tudi_msc_cbw_error_status = UDI_MSC_CBW_ERROR_STATUS_NO_ERROR;\n\tudi_msc_cbw_error_phase = UDI_MSC_CBW_ERROR_PHASE_CBW;\n\tudi_msc_cbw_error_flag = false;\n\tudi_msc_cbw_error_flag_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev_prev_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev_prev_prev_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev_prev_prev_prev_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev_prev_prev_prev_prev_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = false;\n\tudi_msc_cbw_error_flag_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = false;\n\tudi_msc_cbw_error", "CodeBleu_score": 20.333220315638002}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (UDD_EP_TRANSFER_OK != status) {\n\t\tudi_msc_cbw_reset();\n\t\treturn;\n\t}\n\tudi_msc_csw.dCSWDataResidue -= nb_sent;\n\tudi_msc_csw_process();\n}", "CodeBleu_score": 68.33722485884162}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status != UDD_EP_TRANSFER_OK) {\n\t\tudi_msc_sense_pass = false;\n\t\tudi_msc_csw_process = false;\n\t\tudi_msc_cbw_process = true;\n\t\treturn;\n\t}\n\tudi_msc_csw.data_residue -= nb_sent;\n\tudi_msc_csw_process = true;\n}", "CodeBleu_score": 50.24525854461677}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (UDD_EP_TRANSFER_OK != status) {\n    // A problem has occurred, then wait for a MSC setup reset to restart CBW reception\n    udi_msc_cbw_wait_reset();\n    return;\n  }\n  // Update sense data\n  udi_msc_sense_pass();\n  // Decrease data residue in CSW by the amount of data sent\n  udi_msc_csw_data_residue -= nb_sent;\n  // Process updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 67.11118312495393}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tif (udi_msc_cbw.dCBWDataTransferLength) {\n\t\tif (udi_msc_cbw.bmCBWFlags & 0x80) {\n\t\t\tudd_ep_set_halt(MSC_EP_IN);\n\t\t} else {\n\t\t\tudd_ep_set_halt(MSC_EP_OUT);\n\t\t}\n\t}\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 64.76791868270806}, {"code": "static void udi_msc_csw_process(void){\n\t\tif (udi_msc_cbw.dCBWDataTransferLength) {\n\t\tif (udi_msc_cbw.bmCBWFlags & 0x80) {\n\t\t\tudd_ep_set_halt(0);\n\t\t} else {\n\t\t\tudd_ep_set_halt(1);\n\t\t}\n\t}\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 59.11278445059631}, {"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_cbw_t *cbw = &udi_msc_cbw;\n\tudi_msc_csw_t *csw = &udi_msc_csw;\n\tuint32_t residue;\n\n\t/*\n\t * If there is a non-zero data residue, stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n\t */\n\tresidue = cbw->dCBWDataTransferLength - udi_msc_data_transfer_length;\n\tif (residue) {\n\t\tif (cbw->bmCBWFlags & UDI_MSC_CBW_FLAG_DIR_IN) {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\n\t/*\n\t * Prepare the CSW by setting its tag and converting the data residue to little-endian format before sending the CSW.\n\t */\n\tcsw->dCSWDataResidue = cpu_to_le32(residue);\n\tcsw->dCSWTag = cbw->dCBWTag;\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 50.87236189923975}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\tcancelReset();\n\t} else {\n\t\tif (usb_task_cdc_get_baudrate(port) == 1200) {\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 27.921201352034686}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\tcancelReset();\n\t} else {\n\t\tif (usb_task_cdc_get_baudrate(port) == 1200) {\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 27.921201352034686}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    static bool b_dtr_enabled[USB_NUM_PORTS];\n    static uint32_t dtr_rate[USB_NUM_PORTS];\n\n    if (b_enable) {\n        if (b_dtr_enabled[port]) {\n            b_dtr_enabled[port] = false;\n            cancelReset();\n        }\n    } else {\n        if (!b_dtr_enabled[port]) {\n            b_dtr_enabled[port] = true;\n            dtr_rate[port] = usb_cdc_get_line_coding_rate(port);\n            if (dtr_rate[port] == 1200) {\n                initiateReset();\n            }\n        }\n    }\n}", "CodeBleu_score": 34.191018024551425}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t  if (USB_SetupPacket.bmRequestType == (REQTYPE_VENDOR | REQTYPE_DEVICETOHOST)) {\n    switch (USB_SetupPacket.bRequest) {\n      case GET_EXTENDED_PROPERTIES_OS:\n        if (USB_SetupPacket.wIndex == 0x04) {\n          Udd_setup_payload_t payload;\n          payload.ptr = (uint8_t *)&usb_os_desc;\n          payload.len = sizeof(usb_os_desc);\n          udd_g_ctrlreq.payload = &payload;\n          return true;\n        }\n        break;\n      case GET_MS_COMPATIBLE_ID_OS:\n        if (USB_SetupPacket.wIndex == 0x05) {\n          Udd_setup_payload_t payload;\n          payload.ptr = (uint8_t *)&usb_ms_compat_id_desc;\n          payload.len = sizeof(usb_ms_compat_id_desc);\n          udd_g_ctrlreq.payload = &payload;\n          return true;\n        }\n        break;\n      case GET_MS_EXTENDED_COMPATIBLE_ID_OS:\n        if (USB_SetupPacket.wIndex == 0x06) {\n          Udd_setup_payload_t payload;\n          payload.ptr = (uint8_t *)&usb_ms_extended_compat_id_desc;\n          payload.len = sizeof(usb_ms_extended_compat_id_desc);\n          udd_g_ctrlreq.payload = &payload;\n          return true;\n        }\n        break;\n      case GET_MS_OS_20_DESCRIPTOR_OS:\n        if (USB_SetupPacket.wIndex == 0x07) {\n          Udd_setup_payload_t payload;\n          payload.ptr = (uint8_t *)&usb_ms_os_20_desc;\n          payload.len = sizeof(usb_ms_os_20_desc);\n          udd_g_ctrlreq.payload =", "CodeBleu_score": 35.03105447620189}, {"code": "bool usb_task_other_requests(void){\n\t\t/*\n\t * The function \"usb_task_other_requests\" handles USB vendor-specific requests.", "CodeBleu_score": 3.3765013718229606}, {"code": "bool usb_task_other_requests(void){\n\t\tuint8_t request_type;\n\tuint8_t request;\n\tuint8_t wvalue_l;\n\tuint8_t wvalue_h;\n\tuint8_t windex_l;\n\tuint8_t windex_h;\n\tuint8_t wlength_l;\n\tuint8_t wlength_h;\n\n\t// Get request type, request, value, index, and length\n\trequest_type = usb_request_type;\n\trequest = usb_request;\n\twvalue_l = usb_wvalue_l;\n\twvalue_h = usb_wvalue_h;\n\twindex_l = usb_windex_l;\n\twindex_h = usb_windex_h;\n\twlength_l = usb_wlength_l;\n\twlength_h = usb_wlength_h;\n\n\t// Process vendor-specific request index 0x04 (MS OS Descriptors)\n\tif (request_type == (USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_DEVICE) &&\n\t\trequest == 0x04 &&\n\t\twindex_l == 0x04 &&\n\t\twindex_h == 0x00 &&\n\t\twvalue_l == 0x00 &&\n\t\twvalue_h == 0x00 &&\n\t\twlength_l == 0x00 &&\n\t\twlength_h == 0x00) {\n\t\t// Setup descriptor pointer and size\n\t\tusb_request_payload_ptr = (uint8_t*)&usb_msos_descriptor;\n\t\tusb_request_payload_size = sizeof(usb_msos_descriptor);\n\n\t\t// Return true to indicate that the request has been processed\n\t\treturn true;\n\t}\n\n\t// Process vendor-specific request index 0x05 (MS OS Extended Properties)\n\tif (request_type == (USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_DEVICE) &&\n\t\trequest == 0x05 &&\n\t\tw", "CodeBleu_score": 30.339341715366473}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\twhile (nbyte--) {\n\t\tspiRec(0);\n\t\t*buf++ = spiRec(0);\n\t}\n\t*buf = spiRec(0);\n}", "CodeBleu_score": 27.685385432683574}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\n    if (nbyte == 0) return;\n\n    uint16_t i;\n    for (i = 0; i < nbyte - 1; i++) {\n        spiSend(0xFF);\n        buf[i] = spiRec();\n    }\n    spiSend(0xFF);\n    buf[i] = spiRecLast();\n}", "CodeBleu_score": 50.96071790029517}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  uint16_t i;\n  uint8_t j;\n\n  if (nbyte == 0) {\n    return;\n  }\n\n  for (i = 0; i < nbyte; i++) {\n    spiTx(0);\n    while (!spiRxCnt());\n    buf[i] = spiRec();\n  }\n}", "CodeBleu_score": 48.75016069659339}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  pfnISR_Handler oldHandler;\n  uint32_t *isr_table;\n\n  /*\n   * CRITICAL_SECTION_START\n   *\n   * CRITICAL_SECTION_END\n   */\n  CRITICAL_SECTION_START\n  isr_table = get_relocated_table_addr();\n  oldHandler = (pfnISR_Handler)isr_table[irq + 16];\n  isr_table[irq + 16] = (uint32_t)newHandler;\n  CRITICAL_SECTION_END\n\n  return oldHandler;\n}", "CodeBleu_score": 60.62724356972248}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  pfnISR_Handler oldHandler;\n\n  CRITICAL_SECTION_START\n  oldHandler = get_relocated_table_addr()[irq + 16];\n  get_relocated_table_addr()[irq + 16] = newHandler;\n  CRITICAL_SECTION_END\n\n  return oldHandler;\n}", "CodeBleu_score": 62.46621316113598}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tCRITICAL_SECTION_VAR();\n\tCRITICAL_SECTION_START\n\tuint32_t *relocated_isr_table = get_relocated_table_addr();\n\tuint32_t *isr_table = (uint32_t *)SCB->VTOR;\n\tpfnISR_Handler oldHandler = (pfnISR_Handler)isr_table[irq + 16];\n\tisr_table[irq + 16] = (uint32_t)newHandler;\n\trelocated_isr_table[irq + 16] = (uint32_t)newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 57.29786618735275}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (!usb_task_cdc_isenabled()) return -1;\n  return udi_cdc_getc();\n}", "CodeBleu_score": 14.10524727871544}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!usb_task_cdc_isenabled()) return -1;\n\n  if (emergency_parser.isActive()) {\n    // If the emergency parser is active,\n    // it needs to process the next character\n    emergency_parser.update(udi_cdc_getc());\n    if (emergency_parser.isFinished()) {\n      // If the emergency parser is finished,\n      // process the command and return -1\n      process_and_prepare_for_input();\n      return -1;\n    }\n  }\n  else {\n    // If the emergency parser is not active,\n    // it needs to process the next character\n    emergency_parser.update(static_cast<MSerialT1*>(this)->read());\n    if (emergency_parser.isFinished()) {\n      // If the emergency parser is finished,\n      // process the command and return -1\n      process_and_prepare_for_input();\n      return -1;\n    }\n  }\n\n  return emergency_parser.peek();\n}", "CodeBleu_score": 42.03890709414306}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (emergency_parser.isActive()) {\n    if (emergency_parser.isFinished()) {\n      // If the parser is finished, it will be reset in the next call to read()\n      return -1;\n    }\n    if (emergency_parser.isStart()) {\n      // If the parser is waiting for the start code, it will be reset in the next call to read()\n      return -1;\n    }\n    return emergency_parser.get_and_clear_char();\n  }\n  if (!usb_task_cdc_isenabled()) return -1;\n  return udi_cdc_getc();\n}", "CodeBleu_score": 47.659618809426405}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  if (pending_rx_count > 0) return pending_rx_buffer[--pending_rx_count];\n  if (!udi_cdc_is_rx_ready()) return -1;\n  if (!usb_task_cdc_isenabled()) return -1;\n  if (!udi_cdc_getc(&rx_byte)) return -1;\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(rx_byte));\n  return rx_byte;\n}", "CodeBleu_score": 44.71573320778422}, {"code": "int MarlinSerialUSB::read(){\n\t  if (pending_char >= 0) {\n    int c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n  if (!udi_cdc_is_rx_ready()) return -1;\n  uint8_t c = udi_cdc_getc();\n  if (emergency_parser.enabled) emergency_parser.update(c);\n  return c;\n}", "CodeBleu_score": 64.22637284223228}, {"code": "int MarlinSerialUSB::read(){\n\t  if (available()) return uart_buffer_read(buffer_rx);\n  if (!usb_task_cdc_isenabled()) return -1;\n  if (!usb_cdc_rx_available()) return -1;\n  return uart_buffer_overwrite(buffer_rx, usb_cdc_rx_getc());\n}", "CodeBleu_score": 26.729047940719376}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (usb_rx_available()) return usb_rx_available();\n  return usb_task_cdc_isenabled();\n}", "CodeBleu_score": 36.240730055759606}, {"code": "int MarlinSerialUSB::available(){\n\t  int n = 0;\n  if (usb_task_cdc_isenabled()) {\n    n = udi_cdc_get_nb_received_data();\n    if (n == 0) n = -1;\n  }\n  return n;\n}", "CodeBleu_score": 52.61418561680724}, {"code": "int MarlinSerialUSB::available(){\n\t  if (usb_cdc_rx_available()) return usb_cdc_rx_count();\n  return usb_task_cdc_isenabled() ? 1 : 0;\n}", "CodeBleu_score": 21.054025383022257}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  uint8_t * const value_end = value + size;\n  uint16_t * const crc_end = crc + size;\n  do {\n    const uint8_t b = ee_Read(pos);\n    if (writing) *value = b;\n    *crc = CRC_IBM(b, *crc);\n    ++pos;\n  } while (++value < value_end && ++crc < crc_end);\n  return false;\n}", "CodeBleu_score": 56.017426833738824}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  uint8_t c;\n  while (size--) {\n    c = eeprom_read_byte((uint8_t*)pos);\n    if (writing) *value = c;\n    *crc = _crc16_update(*crc, c);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 64.63520591335723}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  uint8_t c;\n  while (size--) {\n    c = ee_Read(pos);\n    if (writing) *value = c;\n    *crc = crc16(*crc, &c, 1);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 70.00680635047215}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  uint32_t timer = 0;\n  uint32_t channel = 0;\n  uint32_t resolution = 0;\n\n  // Check if the pin supports PWM\n  if (WITHIN(pin, 0, 16)) {\n    // If no frequency was specified, use the default\n    if (freq == 0) freq = PWM_FREQUENCY;\n\n    // If no resolution was specified, use the default\n    if (res == 0) res = 8;\n\n    // If the pin is not already in use\n    if (!pwm_info[pin].attached) {\n      // If the pin is not already in use\n      if (!pwm_info[pin].attached) {\n        // Get the next available channel\n        channel = get_pwm_channel(pin);\n\n        // If no channels are available\n        if (channel == -1) {\n          // If the pin supports hardware PWM\n          if (HAL_timer_start(pin, freq, res)) {\n            timer = pin;\n            channel = 0;\n          }\n          else {\n            // No channels or timers available\n            return;\n          }\n        }\n\n        // Set the timer and channel\n        pwm_info[pin].timer = timer;\n        pwm_info[pin].channel = channel;\n\n        // Mark the pin as in use\n        pwm_info[pin].attached = true;\n      }\n      else {\n        // Get the timer and channel\n        timer = pwm_info[pin].timer;\n        channel = pwm_info[pin].channel;\n      }\n\n      // Set the timer and channel\n      pwm_info[pin].timer = timer;\n      pwm_info[pin].channel = channel;\n\n      // Set the timer and channel\n      pwm_info[pin].timer = timer;\n      pwm_info[pin].channel = channel;\n\n      // Set the timer and channel\n      pwm_info[pin].timer = timer;\n      pwm_info[pin].channel = channel;\n\n     ", "CodeBleu_score": 38.44877823616471}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  uint8_t channel = get_pwm_channel(pin);\n  if (channel != 0xFF) {\n    ledcWrite(channel, value);\n    return;\n  }\n\n  channel = get_pwm_channel(pin);\n  if (channel == 0xFF) {\n    // Find the first available channel\n    for (uint8_t i = 0; i < PWM_CHANNELS; i++) {\n      if (pwm_channel[i].pin == 0xFF) {\n        channel = i;\n        break;\n      }\n    }\n\n    // If no channels are available, return\n    if (channel == 0xFF) return;\n  }\n\n  // Set the PWM configuration\n  ledcSetup(channel, freq, res);\n  ledcAttachPin(pin, channel);\n  pwm_channel[channel].pin = pin;\n  pwm_channel[channel].value = value;\n  pwm_channel[channel].freq = freq;\n  pwm_channel[channel].res = res;\n  pwm_count++;\n\n  // If this is the first PWM pin, start the timer\n  if (pwm_count == 1) HAL_timer_start(PWM_TIMER_NUM, PWM_TIMER_FREQ);\n\n  ledcWrite(channel, value);\n}", "CodeBleu_score": 54.07911116139105}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin >= PINS_COUNT) return;\n\n  if (WITHIN(pin, PINS_D0, PINS_D15)) {\n    const uint8_t channel = digitalPinToTimerChannel(pin);\n    if (channel != NOT_ON_TIMER) {\n      ledcWrite(channel, value);\n      return;\n    }\n  }\n\n  #if ENABLED(SOFTWARE_PWM)\n\n    // Find or create a slot for this pin\n    uint8_t pwm_index = -1;\n    for (uint8_t i = 0; i < NUM_SOFTWARE_PWM; i++) {\n      if (software_pwm_info[i].pin == pin) {\n        pwm_index = i;\n        break;\n      }\n    }\n\n    if (pwm_index < 0) {\n      for (uint8_t i = 0; i < NUM_SOFTWARE_PWM; i++) {\n        if (software_pwm_info[i].pin == NOT_A_PIN) {\n          pwm_index = i;\n          software_pwm_info[i].pin = pin;\n          software_pwm_info[i].count = 0;\n          break;\n        }\n      }\n    }\n\n    if (pwm_index < 0) return;\n\n    // Get or create a timer\n    uint8_t timer_index = -1;\n    for (uint8_t i = 0; i < NUM_SOFTWARE_PWM_TIMERS; i++) {\n      if (software_pwm_timer_info[i].pin == pin) {\n        timer_index = i;\n        break;\n      }\n    }\n\n    if (timer_index < 0) {\n      for (uint8_t i = 0; i < NUM_SOFTWARE_PWM_TIMERS; i++) {\n        if (software_pwm_timer_info[i].pin == NOT_A_PIN) {\n          timer_index", "CodeBleu_score": 50.19959273728901}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(servo_delay) == sizeof(servo_channel) && sizeof(servo_delay) > 0, \"Servo delay array length must match the number of servo channels\");\n  if (attach()) {\n    write(value);\n    safe_delay(servo_delay[servo_channel]);\n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n    detach();\n#endif\n  }\n}", "CodeBleu_score": 53.735518686239544}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(sizeof(SERVO_DELAY_ARRAY) / sizeof(SERVO_DELAY_ARRAY[0]) == SERVO_COUNT, \"SERVO_DELAY_ARRAY length does not match SERVO_COUNT\");\n\tif (attach()) {\n\t\twrite(value);\n\t\tsafe_delay(SERVO_DELAY_ARRAY[channel - 1]);\n\t\t#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n\t\tdetach();\n\t\t#endif\n\t}\n}", "CodeBleu_score": 47.974526834706644}, {"code": "void Servo::move(const int value){\n\t  static_assert(SERVO_DELAY_LENGTH == NUM_SERVOS, \"SERVO_DELAY_LENGTH must be equal to NUM_SERVOS\");\n  attach();\n  write(value);\n  safe_delay(SERVO_DELAY_LENGTH);\n  detach();\n}", "CodeBleu_score": 40.04688475375826}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t  int i;\n  uint32_t pwm_mask;\n\n  // Check if any pins have active PWM\n  pwm_mask = 0;\n  for (i = 0; i < NUM_PWM_PINS; i++) {\n    if (pwm_ticks[i] > 0) {\n      pwm_mask |= (1 << i);\n    }\n  }\n\n  // If any pins have active PWM, update their states\n  if (pwm_mask > 0) {\n    // For each pin, check if its PWM tick count is zero\n    for (i = 0; i < NUM_PWM_PINS; i++) {\n      // If the PWM tick count is zero, toggle the pin state and set the tick count for the next transition\n      if (pwm_ticks[i] == 0) {\n        if (pwm_state[i]) {\n          // Set the pin low\n          port_data &= ~(1 << i);\n        } else {\n          // Set the pin high\n          port_data |= (1 << i);\n        }\n        pwm_state[i] = !pwm_state[i];\n        pwm_ticks[i] = pwm_duty[i];\n      } else {\n        // Decrement the PWM tick count\n        pwm_ticks[i]--;\n      }\n    }\n\n    // Store the updated port data into the current position of the DMA buffer and increment the buffer position\n    *dma_buffer_pos = port_data;\n    dma_buffer_pos++;\n  } else {\n    // If no pins have active PWM, just store the current port data into the current position of the DMA buffer and increment the buffer position\n    *dma_buffer_pos = port_data;\n    dma_buffer_pos++;\n  }\n}", "CodeBleu_score": 38.7474861981156}, {"code": "void i2s_push_sample(){\n\t  uint8_t i;\n  uint32_t pwm_state;\n  uint32_t pwm_tick_count;\n  uint32_t port_data;\n  uint32_t port_data_mask;\n\n  for (i = 0; i < 8; i++) {\n    pwm_state = pwm_state_table[i];\n    pwm_tick_count = pwm_tick_count_table[i];\n    port_data = port_data_table[i];\n    port_data_mask = port_data_mask_table[i];\n\n    if (pwm_state == 0) {\n      if (pwm_tick_count == 0) {\n        pwm_state = 1;\n        port_data ^= port_data_mask;\n      } else {\n        pwm_tick_count--;\n      }\n    } else {\n      if (pwm_tick_count == 0) {\n        pwm_state = 0;\n      } else {\n        pwm_tick_count--;\n      }\n    }\n\n    pwm_state_table[i] = pwm_state;\n    pwm_tick_count_table[i] = pwm_tick_count;\n    port_data_table[i] = port_data;\n  }\n\n  dma_buffer[dma_buffer_position] = port_data;\n  dma_buffer_position++;\n}", "CodeBleu_score": 39.09308128101831}, {"code": "void i2s_push_sample(){\n\t    int i;\n    int32_t *buf = (int32_t *)(i2s_state.dma_buf + i2s_state.dma_buf_pos);\n    for (i = 0; i < I2S_NUM_PINS; i++) {\n        if (i2s_state.pwm_ticks[i] == 0) {\n            if (i2s_state.pins[i] == 0) {\n                i2s_state.pins[i] = 1;\n            } else {\n                i2s_state.pins[i] = 0;\n            }\n            i2s_state.pwm_ticks[i] = i2s_state.pwm_period[i];\n        } else {\n            i2s_state.pwm_ticks[i]--;\n        }\n        *buf++ = i2s_state.pins[i];\n    }\n    i2s_state.dma_buf_pos += 4;\n}", "CodeBleu_score": 38.98219048139075}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t count = 0;\n    switch (timer_num) {\n        case 0:\n            count = timer_get_counter_value(TIMER0);\n            break;\n        case 1:\n            count = timer_get_counter_value(TIMER1);\n            break;\n        case 2:\n            count = timer_get_counter_value(TIMER2);\n            break;\n        case 3:\n            count = timer_get_counter_value(TIMER3);\n            break;\n        case 4:\n            count = timer_get_counter_value(TIMER4);\n            break;\n        case 5:\n            count = timer_get_counter_value(TIMER5);\n            break;\n        default:\n            break;\n    }\n    return count;\n}", "CodeBleu_score": 37.73414083700628}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\n  hal_timer_t count;\n\n  // Check if timer_num is valid\n  if (timer_num >= HAL_TIMER_COUNT) {\n    return 0;\n  }\n\n  // Check if timer is enabled\n  if (HAL_timer_is_enabled(timer_num) == 0) {\n    return 0;\n  }\n\n  // Check if timer is running\n  if (HAL_timer_is_running(timer_num) == 0) {\n    return 0;\n  }\n\n  // Get the timer count\n  count = timer_get_counter_value(timer_num);\n\n  return count;\n}", "CodeBleu_score": 32.79816017669089}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer_count = 0;\n\tif (timer_num < HAL_TIMER_MAX) {\n\t\ttimer_count = timer_get_counter_value(timer_num);\n\t}\n\treturn timer_count;\n}", "CodeBleu_score": 35.173774440962696}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint8_t c;\n  for (uint16_t i = 0; i < size; i++) {\n    c = eeprom_read_byte((uint8_t*)pos);\n    if (writing) value[i] = c;\n    *crc = crc16(c, *crc);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 66.41943104225015}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint16_t crc_register = 0;\n  uint8_t * const p = value;\n  LOOP_L_N(i, size) {\n    uint8_t v = eeprom_read_byte((uint8_t *)(persistent_store_address + pos + i));\n    if (writing) p[i] = v;\n    crc_register = crc16(crc_register, v);\n  }\n  if (crc) *crc = crc_register;\n  pos += size;\n  return false;\n}", "CodeBleu_score": 54.08501672481057}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint8_t read_value;\n  for (size_t i = 0; i < size; i++) {\n    read_value = eeprom_read_byte((uint8_t*)pos);\n    if (writing) value[i] = read_value;\n    *crc = crc16((uint8_t*)crc, &read_value, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 64.04145247231958}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    SDCARD_WriteBlocks(block, 1, src);\n    WITH_RETRY(SDCARD_WriteBlocks(block, 1, src));\n    return true;\n}", "CodeBleu_score": 15.723093113403507}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    SDCARD_WriteBlocks(block, src, 1);\n    WITH_RETRY(SDCARD_WriteBlocks(block, src, 1) == 0,\n               printf(\"Failed to write block %d\n\", block));\n}", "CodeBleu_score": 17.87657305908426}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    CORE_ASSERT(src != NULL);\n\n    if (sdio_handle != NULL && src != NULL) {\n        WITH_RETRY(SDCARD_WriteBlocks(sdio_handle, src, block, 1)) {\n            return true;\n        }\n        printf(\"Failed to write block %lu\n\", block);\n    }\n    return false;\n}", "CodeBleu_score": 27.891215119533918}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    CORE_DEBUG_PRINTF(\"HAL_timer_start\n\");\n    switch (timer_num) {\n        case TEMP_TIMER:\n            timer_num->start(frequency, TIMER_TEMP_PRESCALE);\n            timer_num->setCallbackPriority(TEMP_TIMER_PRIORITY);\n            break;\n        case STEP_TIMER:\n            timer_num->start(frequency, TIMER_STEP_PRESCALE);\n            timer_num->setCallbackPriority(STEP_TIMER_PRIORITY);\n            break;\n        default:\n            CORE_ASSERT_FAIL();\n    }\n}", "CodeBleu_score": 42.55213811343475}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  // Initialize the timer with the specified frequency\n  timer_num->start(frequency);\n  // Set the callback priority for the timer\n  timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY);\n}", "CodeBleu_score": 16.769967161851312}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    CORE_DEBUG_PRINTF(\"HAL_timer_start()\");\n    CORE_ASSERT_FAIL(timer_num < TIMER_CHANNEL_NUM);\n\n    if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n        CORE_DEBUG_PRINTF(\"timer_num == TIMER_CHANNEL_TEMPERATURE\");\n        timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY_TEMPERATURE);\n        timer_num->setPrescaleFactor(TIMER_PRESCALE_TEMPERATURE);\n        timer_num->setOverflow(frequency, HERTZ_FORMAT);\n        timer_num->start();\n    } else if (timer_num == TIMER_CHANNEL_STEPPER) {\n        CORE_DEBUG_PRINTF(\"timer_num == TIMER_CHANNEL_STEPPER\");\n        timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY_STEPPER);\n        timer_num->setPrescaleFactor(TIMER_PRESCALE_STEPPER);\n        timer_num->setOverflow(frequency, HERTZ_FORMAT);\n        timer_num->start();\n    } else {\n        CORE_DEBUG_PRINTF(\"timer_num == TIMER_CHANNEL_INVALID\");\n        CORE_ASSERT_FAIL(false);\n    }\n}", "CodeBleu_score": 53.04026721804627}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  char * const buffer = (char * const)eeprom_buffer;\n  const size_t size = eeprom_size;\n  const uint16_t erase = eeprom_erase_value;\n\n  if (file) {\n    SERIAL_ECHO_MSG(STR_ERR_EEPROM_INDEX);\n    return false;\n  }\n\n  if (file = fopen(eeprom_file, \"rb\")) {\n    if (fseek(file, 0, SEEK_END) || ftell(file) < size) {\n      fclose(file);\n      file = fopen(eeprom_file, \"wb\");\n      if (!file) return false;\n      memset(buffer, erase, size);\n      fwrite(buffer, 1, size, file);\n      fclose(file);\n      file = fopen(eeprom_file, \"rb\");\n    }\n    else {\n      fseek(file, 0, SEEK_SET);\n      fread(buffer, 1, size, file);\n    }\n    fclose(file);\n  }\n  else {\n    file = fopen(eeprom_file, \"wb\");\n    if (!file) return false;\n    memset(buffer, erase, size);\n    fwrite(buffer, 1, size, file);\n    fclose(file);\n    file = fopen(eeprom_file, \"rb\");\n  }\n\n  return true;\n}", "CodeBleu_score": 48.306408920709345}, {"code": "bool PersistentStore::access_start(){\n\t  char * const buf = (char *)&eeprom_data;\n  const size_t bufsize = sizeof(eeprom_data);\n\n  eeprom_error = false;\n\n  if (eeprom_fd) {\n    SERIAL_ECHOLNPGM(\"?PersistentStore::access_start: EEPROM already opened.\");\n    eeprom_error = true;\n    return false;\n  }\n\n  eeprom_fd = fopen(eeprom_path, \"rb\");\n  if (!eeprom_fd) {\n    SERIAL_ECHOLNPGM(\"?PersistentStore::access_start: Cannot open EEPROM file.\");\n    eeprom_error = true;\n    return false;\n  }\n\n  const long fsize = ftell(eeprom_fd);\n  if (fsize < 0) {\n    SERIAL_ECHOLNPGM(\"?PersistentStore::access_start: Cannot determine size of EEPROM file.\");\n    eeprom_error = true;\n    return false;\n  }\n\n  if (fsize < bufsize) {\n    SERIAL_ECHOLNPGM(\"?PersistentStore::access_start: EEPROM file is too small.\");\n    eeprom_error = true;\n    return false;\n  }\n\n  if (fsize > bufsize) {\n    SERIAL_ECHOLNPGM(\"?PersistentStore::access_start: EEPROM file is too large.\");\n    eeprom_error = true;\n    return false;\n  }\n\n  if (fread(buf, 1, bufsize, eeprom_fd) != bufsize) {\n    SERIAL_ECHOLNPGM(\"?PersistentStore::access_start: Cannot read EEPROM file.\");\n    eeprom_error = true;\n    return false;\n  }\n\n  fclose(eeprom_fd);\n  eeprom_fd = 0;\n\n  return true;\n}", "CodeBleu_score": 37.29903791380752}, {"code": "bool PersistentStore::access_start(){\n\t  char * const buf = (char *)EEPROM_START_ADDRESS;\n  const size_t size = EEPROM_SIZE;\n  const uint8_t erase = 0xFF;\n  uint16_t fileSize = 0;\n  bool success = false;\n  const char * const fname = persistentStoreFilename();\n  const int fd = open(fname, O_RDWR | O_CREAT);\n  if (fd >= 0) {\n    if (0 == ftruncate(fd, size)) {\n      if (0 == fstat(fd, &fileStat)) {\n        fileSize = fileStat.st_size;\n        if (fileSize >= size) {\n          if (0 == fread(buf, size, 1, fd)) {\n            success = true;\n          }\n        }\n        else {\n          if (0 == fseek(fd, 0, SEEK_SET)) {\n            if (0 == fwrite(buf, size, 1, fd)) {\n              success = true;\n            }\n          }\n        }\n      }\n    }\n    close(fd);\n  }\n  if (!success) {\n    memset(buf, erase, size);\n  }\n  return success;\n}", "CodeBleu_score": 40.71490705436859}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i, r;\n\tfor (i = 0, r = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SpiTransfer_Mode_3_Bit(b, i, r);\n\t}\n\tdelaySPIFunc();\n\treturn r;\n}", "CodeBleu_score": 23.919279951379085}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t i;\n  uint8_t r = 0;\n  for (i = 0; i < 8; i++) {\n    HAL_SPI_STM32_SpiClockLow();\n    if (b & 0x80) {\n      HAL_SPI_STM32_SpiMosiHigh();\n    } else {\n      HAL_SPI_STM32_SpiMosiLow();\n    }\n    HAL_SPI_STM32_SpiClockHigh();\n    if (HAL_SPI_STM32_SpiMisoRead()) {\n      r |= 1;\n    }\n    r <<= 1;\n    b <<= 1;\n  }\n  delaySPIFunc();\n  return r;\n}", "CodeBleu_score": 36.02797016597316}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    uint8_t i;\n    for (i = 0; i < 8; i++) {\n        delaySPIFunc(1);\n        PORTB &= ~(1 << PB2);\n        if (b & 0x80) {\n            PORTB |= (1 << PB3);\n        } else {\n            PORTB &= ~(1 << PB3);\n        }\n        delaySPIFunc(1);\n        PORTB |= (1 << PB2);\n        if (PINB & (1 << PB4)) {\n            r |= (1 << i);\n        }\n        b <<= 1;\n    }\n    return r;\n}", "CodeBleu_score": 41.38042711113356}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 79.90054709524316}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  if (NewState != DISABLE) {\n    /* Enable the selected AHB peripheral clock */\n    RCC->AHBENR |= RCC_AHBPeriph;\n  }\n  else {\n    /* Disable the selected AHB peripheral clock */\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 79.77090318797755}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    /* Check the parameters */\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n    if (NewState != DISABLE) {\n        /* Enable the selected AHB peripheral clock */\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        /* Disable the selected AHB peripheral clock */\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 77.97819102603172}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  // Get the received byte\n  uint8_t c = serial_getc(obj);\n\n  // Check for errors\n  if (serial_get_irq_status(obj) & SERIAL_ERROR_OVERRUN) {\n    // Overrun error occurred, skip this byte and report the error\n    SERIAL_ERROR(ER_RX_OVERRUNS);\n    return;\n  }\n\n  // If no error occurred, store the received byte in the buffer\n  if (rx_buffer_head != rx_buffer_tail) {\n    // Calculate the next head index, increment and mask with the buffer size\n    rx_buffer_head = (rx_buffer_head + 1) & (RX_BUFFER_SIZE - 1);\n    rx_buffer[rx_buffer_head] = c;\n  }\n  else {\n    // No space in the receive buffer\n    SERIAL_ERROR(ER_RX_BUFFER_FULL);\n  }\n\n  // If the emergency parser is enabled, give it the byte\n  #if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(c);\n  #endif\n}", "CodeBleu_score": 35.15144545501545}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t    uint8_t c;\n    uint32_t head;\n\n    // Get the head index to the receive buffer\n    head = _rx_head;\n\n    // Read the byte from the serial peripheral\n    c = serial_getc(obj);\n\n    // If no error occurred, store the byte in the receive buffer\n    if (c != SERIAL_RX_BUFFER_FULL) {\n        _rx_buffer[head] = c;\n\n        // Calculate the next head index and store it\n        head = (head + 1) % SERIAL_RX_BUFFER_SIZE;\n        _rx_head = head;\n\n        // If the parser is enabled, give the byte to the parser\n        if (emergency_parser.enabled)\n            emergency_parser.update(c);\n    }\n}", "CodeBleu_score": 37.29850936920072}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c;\n  if (obj->readable()) {\n    c = obj->getc();\n    if (obj->parity_error) {\n      obj->parity_error = 0;\n      SERIAL_ERROR_START();\n      SERIAL_ERROR(\"Parity Error: \");\n      SERIAL_ERROR_CONT(c);\n      SERIAL_ERROR_END();\n    }\n    else {\n      if (obj->rx_buffer_head < obj->rx_buffer_max) {\n        obj->rx_buffer[obj->rx_buffer_head] = c;\n        obj->rx_buffer_head++;\n        if (obj->rx_buffer_head == obj->rx_buffer_max)\n          obj->rx_buffer_head = 0;\n      }\n      if (obj->emergency_parser.enabled)\n        obj->emergency_parser.update(c);\n    }\n  }\n}", "CodeBleu_score": 37.540354928712794}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_instance[timer_num]->hasInterrupt()) {\n        return;\n    }\n    if (!HAL_timer_initialized(timer_num)) {\n        return;\n    }\n    switch (timer_num) {\n        case MF_TIMER_STEP:\n            timer_instance[timer_num]->attachInterrupt(Step_Handler);\n            break;\n        case MF_TIMER_TEMP:\n            timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n            break;\n        default:\n            break;\n    }\n}", "CodeBleu_score": 77.95824106796648}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_instance[timer_num] != NULL && !timer_instance[timer_num]->hasInterrupt()) {\n        switch (timer_num) {\n            case MF_TIMER_STEP:\n                timer_instance[timer_num]->attachInterrupt(Step_Handler);\n                break;\n            case MF_TIMER_TEMP:\n                timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n                break;\n            default:\n                break;\n        }\n    }\n}", "CodeBleu_score": 82.38815982633922}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (timer_instance[timer_num]->hasInterrupt() == false) {\n    if (timer_num == MF_TIMER_STEP) {\n      timer_instance[timer_num]->attachInterrupt(Step_Handler);\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n      timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n    }\n  }\n}", "CodeBleu_score": 59.21334534828693}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\n\thash := HashStrRev(sep)\n\th := HashStrRev(s[len(s)-len(sep):])\n\tif h == hash && Equal(s[len(s)-len(sep):], sep) {\n\t\treturn len(s) - len(sep)\n\t}\n\n\tfor i := len(s) - len(sep) - 1; i >= 0; i-- {\n\t\th = (h - uint32(s[i])*p32) * p32 + uint32(s[i+len(sep)])\n\t\tif h == hash && Equal(s[i:i+len(sep)], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}", "CodeBleu_score": 44.51990933916471}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\thashSep := HashStrRev(sep)\n\tif hashSep == 0 {\n\t\treturn len(s)\n\t}\n\tvar hash uint32\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\thash = hash*primeRK + uint32(s[i])\n\t\tif hash == hashSep && Equal(s[i-len(sep)+1:i+1], sep) {\n\t\t\treturn i - len(sep) + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 36.40600811392575}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tvar (\n\t\thashSep uint32\n\t\thashStr uint32\n\t\thash    uint32\n\t)\n\tif len(s) == 0 {\n\t\treturn -1\n\t}\n\tif len(sep) == 0 {\n\t\treturn len(s) - 1\n\t}\n\thashSep = HashStrRev(sep)\n\thashStr = HashStrRev(s)\n\tif hashStr == hashSep {\n\t\treturn len(s) - len(sep)\n\t}\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\thash = HashStrRev(s[i:])\n\t\tif hash == hashSep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 37.042282402796594}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() != 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.29771695006677}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() != 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore(interrupt.Global)\n}", "CodeBleu_score": 48.91172876282634}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tmachine.SendUSBInPacket(usbcdc.txBuffer.Get())\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 44.57961051250078}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// 1. Set the control register to clear the interrupt flag, put a start condition on the SDA line, and enable the I2C module.\n\ti2c.crReg.Set(i2c.crReg.Clear(I2C_CR_IF_Msk))\n\ti2c.crReg.Set(i2c.crReg.Set(I2C_CR_STA_Msk))\n\ti2c.crReg.Set(i2c.crReg.Set(I2C_CR_EN_Msk))\n\n\t// 2. Wait for the start condition to be transmitted by checking the interrupt flag.\n\tfor !i2c.crReg.HasBits(I2C_CR_IF_Msk) {\n\t}\n\n\t// 3. Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed, and sends it.\n\ti2c.drReg.Set(uint32(address << 1) | B.If(write, 0, 1))\n}", "CodeBleu_score": 32.181357787824425}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// 1. Set the control register to clear the interrupt flag, put a start condition on the SDA line, and enable the I2C module.\n\ti2c.crReg.Set(uint32(i2c.crReg.Get() | 0x00000001 | 0x00000040 | 0x00000020))\n\n\t// 2. Wait for the start condition to be transmitted by checking the interrupt flag.\n\tfor !i2c.crReg.HasBits(0x00000002) {\n\t}\n\n\t// 3. Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed, and sends it.\n\ti2c.drReg.Set(uint32(address << 1) | (uint32(!write) << 0))\n}", "CodeBleu_score": 33.11553331521869}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Set the control register to clear the interrupt flag, put a start condition on the SDA line, and enable the I2C module.\n\ti2c.crReg.Set(0x80 | 0x10 | 0x01)\n\n\t// Wait for the start condition to be transmitted by checking the interrupt flag.\n\tfor !i2c.crReg.HasBits(0x02) {\n\t}\n\n\t// Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed, and sends it.\n\ti2c.writeByte(address<<1 | uint8(write))\n}", "CodeBleu_score": 24.453214116088233}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"start and len must be non-negative\")\n\t}\n\tif start+len > int64(f.NumBlocks()) {\n\t\treturn errors.New(\"start+len must be less than or equal to NumBlocks\")\n\t}\n\tif len == 0 {\n\t\treturn nil\n\t}\n\tif len%int64(f.EraseBlockSize()) != 0 {\n\t\treturn errors.New(\"len must be a multiple of EraseBlockSize\")\n\t}\n\tn := uint32(len) / uint32(f.EraseBlockSize())\n\taddr := uintptr(start * int64(f.EraseBlockSize()))\n\tfor i := uint32(0); i < n; i++ {\n\t\tnrf.NVMC.SetCONFIG_WEN\n\t\twaitWhileFlashBusy\n\t\tnrf.NVMC.ERASEPAGE.Set(addr)\n\t\twaitWhileFlashBusy\n\t\tnrf.NVMC.SetCONFIG_REN\n\t}\n\treturn nil\n}", "CodeBleu_score": 39.697056843668534}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := f.FlashBlockSize * uintptr(start)\n\tendAddr := startAddr + uintptr(len)*f.FlashBlockSize\n\tnrf.NVMC.SetCONFIG_WEN()\n\twaitWhileFlashBusy()\n\tnrf.NVMC.ERASEPAGE.Set()\n\tfor addr := startAddr; addr < endAddr; addr += f.FlashBlockSize {\n\t\tnrf.NVMC.SetERASEPAGEPAGEADDR(addr)\n\t\tnrf.NVMC.TASKS_ERASEPAGE.Set()\n\t\twaitWhileFlashBusy()\n\t}\n\tnrf.NVMC.SetCONFIG_REN()\n\treturn nil\n}", "CodeBleu_score": 43.24971831407049}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\treturn nil\n}", "CodeBleu_score": 3.3151223363300146}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds.\n\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, errors.New(\"write exceeds flash memory bounds\")\n\t}\n\n\t// Calculate the start address for writing.\n\taddr := uint32(off) + f.StartAddress\n\n\t// Pad the byte slice to fit the write block size.\n\tpad := f.pad(p, f.WriteBlockSize)\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.SetCONFIG_WEN()\n\n\t// Write the data in blocks.\n\tfor len(pad) > 0 {\n\t\t// Wait until the flash memory is ready.\n\t\tnrf.NVMC.WaitForReady()\n\n\t\t// Write a block of data.\n\t\tnrf.NVMC.WriteBlock(addr, (*uint32)(unsafe.Pointer(&pad[0])), uint32(f.WriteBlockSize))\n\n\t\t// Increment the address.\n\t\taddr += uint32(f.WriteBlockSize)\n\n\t\t// Increment the byte slice.\n\t\tpad = pad[f.WriteBlockSize:]\n\t}\n\n\t// Return the number of bytes written.\n\treturn len(p), nil\n}", "CodeBleu_score": 31.564928364539526}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, io.ErrShortBuffer\n\t}\n\tif off%int64(f.WriteBlockSize) != 0 {\n\t\treturn 0, errors.New(\"nrf52840flash: offset must be a multiple of the write block size\")\n\t}\n\t// Pad the data to fit the write block size.\n\tpad := f.WriteBlockSize - (len(p) % f.WriteBlockSize)\n\tif pad != f.WriteBlockSize {\n\t\tp = append(p, make([]byte, pad)...)\n\t}\n\t// Calculate the start address for writing.\n\taddr := uint32(off) + f.Address\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.SetCONFIG_WEN()\n\t// Write the data in blocks.\n\tfor len(p) > 0 {\n\t\t// Wait until the flash memory is ready.\n\t\twaitWhileFlashBusy()\n\t\t// Write the data.\n\t\tnrf.NVMC.WriteBlock(addr, unsafe.Pointer(&p[0]), uintptr(f.WriteBlockSize))\n\t\t// Wait until the flash memory is ready.\n\t\twaitWhileFlashBusy()\n\t\t// Increment the address.\n\t\taddr += uint32(f.WriteBlockSize)\n\t\t// Increment the data pointer.\n\t\tp = p[f.WriteBlockSize:]\n\t}\n\treturn len(p), nil\n}", "CodeBleu_score": 37.42544059878487}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off >= int64(f.Size()) {\n\t\treturn 0, io.EOF\n\t}\n\tif int64(len(p))+off > int64(f.Size()) {\n\t\treturn 0, io.ErrShortWrite\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tstart := int(off)\n\tif start%f.WriteBlockSize != 0 {\n\t\tstart = start - start%f.WriteBlockSize\n\t}\n\tend := start + len(p)\n\tif end%f.WriteBlockSize != 0 {\n\t\tend = end + f.WriteBlockSize - end%f.WriteBlockSize\n\t}\n\tn = len(p)\n\tp = p[:end-start]\n\tfor i := 0; i < len(p); i += f.WriteBlockSize {\n\t\terr = nrf.NVMC.SetCONFIG_WEN()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tfor j := 0; j < f.WriteBlockSize; j++ {\n\t\t\tif i+j >= len(p) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t*(*uint32)(unsafe.Pointer(uintptr(f.pad) + uintptr(j))) = uint32(p[i+j])\n\t\t}\n\t\tbinary.LittleEndian.PutUint32(f.pad, uint32(start+i))\n\t\tnrf.NVMC.Write(f.pad, f.WriteBlockSize)\n\t\twaitWhileFlashBusy()\n\t}\n\treturn\n}", "CodeBleu_score": 42.37247188018542}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dup)\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\tsyscall.Close(dup)\n\t\treturn 0, \"\", err\n\t}\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 82.59591775839174}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\tif err == syscall.EINTR {\n\t\t\treturn 0, \"\", err\n\t\t}\n\n\t\t// Close the duplicated file descriptor and return the error.\n\t\tsyscall.Close(dupFd)\n\t\treturn 0, \"\", err\n\t}\n\n\t// Return the directory pointer.\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 56.628139406148435}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar err error\n\tvar dirp uintptr\n\tvar dupfd syscallFd\n\n\tdupfd, err = syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdirp, err = syscall.Fdopendir(dupfd)\n\t\tif err != nil {\n\t\t\tif err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsyscall.Close(int(dupfd))\n\t\t\treturn 0, \"\", err\n\t\t}\n\t\tbreak\n\t}\n\n\treturn dirp, \"\", nil\n}", "CodeBleu_score": 52.755749884845656}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    esp_err_t err;\n    esp_image_metadata_t data;\n    const esp_partition_t *partition;\n\n    err = esp_ota_get_running_partition(&partition);\n    if (err != ESP_OK) {\n        return 0;\n    }\n\n    err = esp_image_verify(ESP_IMAGE_VERIFY, partition, &data);\n    if (err != ESP_OK) {\n        return 0;\n    }\n\n    if (response == FREE_SKETCH_SPACE) {\n        return partition->size - data.image_len;\n    } else {\n        return data.image_len;\n    }\n}", "CodeBleu_score": 62.51423617021646}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  esp_image_metadata_t data;\n  const esp_partition_t *part;\n  part = esp_ota_get_running_partition();\n  esp_ota_get_partition_metadata(part, &data);\n  if (response) {\n    return part->size - data.image.image_len;\n  }\n  return data.image.image_len;\n}", "CodeBleu_score": 40.994014928296494}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  esp_image_metadata_t data;\n  const esp_partition_t *part;\n  part = esp_ota_get_running_partition();\n  if (part == NULL) {\n    return 0;\n  }\n  if (esp_image_verify(part->address, part->size, &data) != ESP_OK) {\n    return 0;\n  }\n  if (response == true) {\n    return part->size - (data.image.image_len + sizeof(esp_image_header_t));\n  } else {\n    return data.image.image_len + sizeof(esp_image_header_t);\n  }\n}", "CodeBleu_score": 52.51074608468409}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t required_disk_sectors;\n\tuint32_t fat_size_in_sectors;\n\tuint32_t root_dir_sectors;\n\tuint32_t data_sectors;\n\tuint32_t cluster_count;\n\tuint32_t cluster_size;\n\tuint32_t fat_type;\n\tuint32_t i;\n\tuint32_t root_dir_entry_count;\n\tuint32_t root_dir_entries_per_sector;\n\tuint32_t root_dir_entry_offset;\n\tuint32_t root_dir_entry_sector;\n\tuint32_t root_dir_entry_offset_within_sector;\n\tuint32_t root_dir_entry_cluster;\n\tuint8_t *disk;\n\tuint8_t *fat;\n\tuint8_t *root_dir;\n\tuint8_t *root_dir_entry;\n\tbool success;\n\tuint8_t *data;\n\tuint8_t *cluster;\n\tuint8_t *cluster_data;\n\tuint32_t cluster_offset;\n\tuint32_t cluster_offset_within_sector;\n\tuint32_t cluster_sector;\n\tuint32_t cluster_data_offset;\n\tuint32_t cluster_data_offset_within_sector;\n\tuint32_t cluster_data_sector;\n\tuint32_t cluster_data_offset_within_cluster;\n\tuint32_t cluster_data_sector_offset;\n\tuint32_t cluster_data_sector_offset_within_sector;\n\tuint32_t cluster_data_sector_offset_within_cluster;\n\tuint32_t cluster_data_sector_offset_within_cluster_data;\n\tuint32_t cluster_data_sector_offset_within_cluster_data_sector;\n\tuint32_t cluster_data_sector_offset_within_cluster_data_sector_", "CodeBleu_score": 7.819613398031748}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t required_disk_sectors;\n    uint8_t *ram_disk;\n    uint8_t *ram_disk_ptr;\n    uint32_t i;\n    uint32_t j;\n    uint32_t root_file_size;\n    uint32_t root_file_sectors;\n    uint32_t fat_size;\n    uint32_t fat_size_sectors;\n    uint32_t fat_sectors;\n    uint32_t fat_table_size;\n    uint32_t fat_table_sectors;\n    uint32_t fat_table_offset;\n    uint32_t root_file_offset;\n    uint32_t root_file_cluster;\n    uint32_t root_file_cluster_offset;\n    uint32_t root_file_cluster_index;\n    uint32_t root_file_cluster_count;\n    uint32_t root_file_cluster_count_minus_one;\n    uint32_t root_file_cluster_count_minus_two;\n    uint32_t root_file_cluster_count_minus_three;\n    uint32_t root_file_cluster_count_minus_four;\n    uint32_t root_file_cluster_count_minus_five;\n    uint32_t root_file_cluster_count_minus_six;\n    uint32_t root_file_cluster_count_minus_seven;\n    uint32_t root_file_cluster_count_minus_eight;\n    uint32_t root_file_cluster_count_minus_nine;\n    uint32_t root_file_cluster_count_minus_ten;\n    uint32_t root_file_cluster_count_minus_eleven;\n    uint32_t root_file_cluster_count_minus_twelve;\n    uint32_t root_file_cluster_count_minus_thirteen;\n    uint32_t root_file_cluster_count_minus_fourteen;\n    uint32_t root", "CodeBleu_score": 7.797077538706297}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t required_disk_sectors = 0;\n    uint32_t sectors_per_cluster = 0;\n    uint32_t sectors_per_fat = 0;\n    uint32_t fat_size = 0;\n    uint32_t fat_size_in_sectors = 0;\n    uint32_t root_dir_sectors = 0;\n    uint32_t data_sectors = 0;\n    uint32_t total_sectors = 0;\n    uint32_t sectors_per_track = 0;\n    uint32_t num_heads = 0;\n    uint32_t hidden_sectors = 0;\n    uint32_t total_sectors_32 = 0;\n    uint32_t fat_offset = 0;\n    uint32_t root_dir_offset = 0;\n    uint32_t data_offset = 0;\n    uint32_t sectors_per_fat_32 = 0;\n    uint32_t fat_size_in_sectors_32 = 0;\n    uint32_t fat_offset_32 = 0;\n    uint32_t root_dir_offset_32 = 0;\n    uint32_t data_offset_32 = 0;\n    uint32_t root_dir_sectors_32 = 0;\n    uint32_t data_sectors_32 = 0;\n    uint32_t total_sectors_32_32 = 0;\n    uint32_t fat_size_in_sectors_32_32 = 0;\n    uint32_t fat_offset_32_32 = 0;\n    uint32_t root_dir_offset_32_32 = 0;\n    uint32_t data_offset_32_32 = 0;\n    uint32_t root_dir_sectors_32_32 = 0;\n    uint32_t", "CodeBleu_score": 9.786925414191826}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    esp_partition_t *part = (esp_partition_t *)partition;\n    if (part == NULL) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (offset + size > part->size) {\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    if (part->encrypted) {\n        return ESP_ERR_NOT_SUPPORTED;\n    }\n\n    if (offset % SPI_FLASH_SEC_SIZE == 0 && size % SPI_FLASH_SEC_SIZE == 0) {\n        err = esp_partition_erase_range(part, offset, size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Erase failed 0x%x\", err);\n            return err;\n        }\n    }\n\n    return esp_partition_write(part, offset, data, size);\n}", "CodeBleu_score": 57.38489012596111}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Erase failed at 0x%x\", offset);\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Write failed at 0x%x\", offset);\n        return err;\n    }\n    return ESP_OK;\n}", "CodeBleu_score": 67.02802591073271}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t ret = ESP_OK;\n    size_t write_size = size;\n    size_t write_offset = offset;\n    size_t aligned_size = (size + SPI_FLASH_SEC_SIZE - 1) & ~(SPI_FLASH_SEC_SIZE - 1);\n    if (aligned_size != size) {\n        ESP_LOGW(TAG, \"Write size is not aligned. Aligning write size to %d\", aligned_size);\n        write_size = aligned_size;\n    }\n    if (offset & (SPI_FLASH_SEC_SIZE - 1)) {\n        ESP_LOGW(TAG, \"Write offset 0x%x is not aligned. Aligning offset to 0x%x\", offset, write_offset);\n        write_offset = offset & ~(SPI_FLASH_SEC_SIZE - 1);\n        if (write_offset + write_size > partition->size) {\n            ESP_LOGE(TAG, \"Write size is out of bounds. Write size %d, partition size %d\", write_size, partition->size);\n            return ESP_ERR_INVALID_ARG;\n        }\n        ret = esp_partition_erase_range(partition, write_offset, SPI_FLASH_SEC_SIZE);\n        if (ret != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase flash sector at offset 0x%x\", write_offset);\n            return ret;\n        }\n    }\n    ret = esp_partition_write(partition, write_offset, data, write_size);\n    if (ret != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write to flash at offset 0x%x\", write_offset);\n    }\n    return ret;\n}", "CodeBleu_score": 49.93954210629595}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i, j, len;\n\n    for (i = 0, len = 0; len < maxlen && in[i]; i++) {\n        if (in[i] == ' ') {\n            continue;\n        }\n        if (in[i] >= '0' && in[i] <= '9') {\n            out[len] = in[i] - '0';\n        } else if (in[i] >= 'A' && in[i] <= 'F') {\n            out[len] = in[i] - 'A' + 10;\n        } else if (in[i] >= 'a' && in[i] <= 'f') {\n            out[len] = in[i] - 'a' + 10;\n        } else {\n            return len;\n        }\n        if (++i >= strlen(in)) {\n            return len;\n        }\n        if (in[i] >= '0' && in[i] <= '9') {\n            out[len] = (out[len] << 4) | in[i] - '0';\n        } else if (in[i] >= 'A' && in[i] <= 'F') {\n            out[len] = (out[len] << 4) | in[i] - 'A' + 10;\n        } else if (in[i] >= 'a' && in[i] <= 'f') {\n            out[len] = (out[len] << 4) | in[i] - 'a' + 10;\n        } else {\n            return len;\n        }\n        len++;\n    }\n    return len;\n}", "CodeBleu_score": 39.678519187214555}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t len = 0;\n  while (*in && len < maxlen) {\n    unsigned char c = *in++;\n    unsigned char n;\n    if (c >= '0' && c <= '9')\n      n = c - '0';\n    else if (c >= 'a' && c <= 'f')\n      n = c - 'a' + 10;\n    else if (c >= 'A' && c <= 'F')\n      n = c - 'A' + 10;\n    else\n      continue;\n    if (len % 2 == 0)\n      n <<= 4;\n    out[len / 2] |= n;\n    len++;\n  }\n  return len / 2;\n}", "CodeBleu_score": 50.27322926729965}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\tsize_t j = 0;\n\twhile (in[i] != 0) {\n\t\tif (in[i] == ' ') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in[i] == '\\t') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in[i] == '", "CodeBleu_score": 16.55404114848849}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t    int ret = 0;\n    if (mRingBuffer && mRingBufferLock) {\n        if (xSemaphoreTake(mRingBufferLock, mRingBufferTimeout) == pdTRUE) {\n            ret = xRingbufferGetCurFreeSize(mRingBuffer);\n            xSemaphoreGive(mRingBufferLock);\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 43.29931953484293}, {"code": "int HWCDC::availableForWrite(void){\n\t    int available = 0;\n\n    if (m_tx_rb && m_tx_rb_lock) {\n        if (xSemaphoreTake(m_tx_rb_lock, pdMS_TO_TICKS(1000)) == pdTRUE) {\n            available = xRingbufferGetCurFreeSize(m_tx_rb);\n            xSemaphoreGive(m_tx_rb_lock);\n        }\n    }\n\n    return available;\n}", "CodeBleu_score": 43.92496377554346}, {"code": "int HWCDC::availableForWrite(void){\n\t    int freeSize = 0;\n    if (tx_ring_buffer_ && tx_ring_buffer_lock_) {\n        if (xSemaphoreTake(tx_ring_buffer_lock_, 1000 / portTICK_PERIOD_MS) == pdTRUE) {\n            freeSize = xRingbufferGetCurFreeSize(tx_ring_buffer_);\n            xSemaphoreGive(tx_ring_buffer_lock_);\n        }\n    }\n    return freeSize;\n}", "CodeBleu_score": 44.908976343527044}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  // Lock the serial mutex\n  HSERIAL_MUTEX_LOCK\n\n  // Set the callback function\n  _onReceiveCB = function;\n\n  // Set the timeout behavior\n  if (function) {\n    // If the callback is not NULL, set the FIFO full threshold and create an event task if it does not already exist\n    uartSetRxFIFOFull(_uart_nr, 1);\n    _createEventTask();\n  } else {\n    // If the callback is NULL, set the FIFO full threshold to 0 and disable the event task\n    uartSetRxFIFOFull(_uart_nr, 0);\n    if (_eventTask) {\n      _eventTask->disable();\n    }\n  }\n\n  // Unlock the serial mutex\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 39.632945618363046}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (function != NULL) {\n    uartSetRxFIFOFull(_uartNo, 0);\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 33.252392772512344}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  if (function) {\n    _rxTimeout = onlyOnTimeout;\n    uartSetRxFIFOFull(_uart, 1);\n    if (!_eventTask) {\n      _eventTask = _createEventTask();\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 33.70195270669514}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) return 0;\n  size_t index = 0;\n  while (1) {\n    int c = timedRead();\n    if (c < 0 || c == terminator || index == length - 1) {\n      buffer[index] = '\\0';\n      return index;\n    }\n    buffer[index] = (char)c;\n    index++;\n  }\n}", "CodeBleu_score": 71.94310355263215}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if (length < 1) return 0;\n    size_t index = 0;\n    while (1) {\n        int c = timedRead();\n        if (c < 0 || c == terminator || index == length - 1) {\n            buffer[index] = '\\0';\n            return index;\n        }\n        buffer[index] = (char)c;\n        index++;\n    }\n}", "CodeBleu_score": 75.43491898204722}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) return 0;\n  size_t index = 0;\n  while (1) {\n    int c = timedRead();\n    if (c < 0 || c == terminator || index == length - 1) {\n      buffer[index] = '\\0';\n      return index;\n    }\n    buffer[index++] = (char)c;\n  }\n}", "CodeBleu_score": 69.71614753724366}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_e(\"tone(%d, %d, %d)\", pin, frequency, duration);\n  if (is_pin_available(pin)) {\n    tone_init(pin, frequency, duration);\n    xQueueSend(tone_queue, &tone_queue_message, portMAX_DELAY);\n  } else {\n    log_e(\"Pin %d is in use\", pin);\n  }\n}", "CodeBleu_score": 34.87784361441395}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    log_e(\"Tone: %d, %d, %d\", pin, frequency, duration);\n    if (pin_available(pin)) {\n        tone_init(pin);\n        xQueueSend(tone_queue, &(tone_t){pin, frequency, duration}, portMAX_DELAY);\n    } else {\n        log_e(\"Tone error: %d is in use\", pin);\n    }\n}", "CodeBleu_score": 34.65639948431921}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    log_e(\"tone(%d, %d, %d)\", pin, frequency, duration);\n    if (pin_in_use(pin)) {\n        log_e(\"tone error: pin %d is in use\", pin);\n        return;\n    }\n    tone_init(pin, frequency, duration);\n    xQueueSend(tone_queue, &tone_data, portMAX_DELAY);\n}", "CodeBleu_score": 36.53306915144975}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!USB) {\n    webUSBEnabled = enabled;\n    return true;\n  }\n  if (enabled) {\n    if (USB->version() < 0x0210) {\n      USB->setVersion(0x0210);\n    }\n    if (!webUSBEnabled) {\n      USB->setVersion(0x0210);\n      USB->setWebUSBEnabled(true);\n      webUSBEnabled = true;\n    }\n  } else {\n    if (webUSBEnabled) {\n      USB->setWebUSBEnabled(false);\n      webUSBEnabled = false;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 44.65778290899122}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (enabled) {\n\t\tif (!usbStarted) {\n\t\t\tusbVersion = 0x0210;\n\t\t\twebUSBEnabled = true;\n\t\t\treturn true;\n\t\t}\n\t\tif (webUSBEnabled)\n\t\t\treturn false;\n\t\twebUSBEnabled = true;\n\t\tif (usbConfiguration)\n\t\t\tusbConfiguration->webUSBEnabled = true;\n\t\treturn false;\n\t}\n\tif (!usbStarted) {\n\t\twebUSBEnabled = false;\n\t\treturn true;\n\t}\n\tif (!webUSBEnabled)\n\t\treturn false;\n\twebUSBEnabled = false;\n\tif (usbConfiguration)\n\t\tusbConfiguration->webUSBEnabled = false;\n\treturn false;\n}", "CodeBleu_score": 36.7400178312553}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!usbStarted) {\n    webUSBEnabled = enabled;\n    return true;\n  }\n  if (enabled) {\n    if (usbVersion < 0x0210) {\n      usbVersion = 0x0210;\n    }\n    webUSBEnabled = true;\n  } else {\n    webUSBEnabled = false;\n  }\n  return false;\n}", "CodeBleu_score": 55.49998511290123}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t  uint8_t buf[64];\n  uint32_t count = tud_cdc_n_read(0, buf, sizeof(buf));\n\n  if (count > 0) {\n    // Attempt to send each byte to the receive queue\n    for (uint32_t i = 0; i < count; i++) {\n      if (xQueueSend(_rxQueue, &buf[i], 0) != pdPASS) {\n        // Overflow event\n        log_e(\"RX overflow: %u dropped\", count - i);\n        post_event(USBCDC_EVENT_RX_OVERFLOW, count - i);\n        break;\n      }\n    }\n\n    // Receive event\n    post_event(USBCDC_EVENT_RX, count);\n  }\n}", "CodeBleu_score": 29.072731453411606}, {"code": "void USBCDC::_onRX(){\n\t  if (tud_cdc_n_available(_interface)) {\n    uint8_t buf[64];\n    uint32_t count = tud_cdc_n_read(_interface, buf, sizeof(buf));\n    if (count) {\n      if (_rxQueue) {\n        for (uint32_t i = 0; i < count; i++) {\n          if (!xQueueSend(_rxQueue, &buf[i], 0)) {\n            arduino_usb_event_post(USB_CDC_RX_OVERFLOW, _interface, count - i);\n            log_e(\"CDC%u RX overflow, %u dropped\", _interface, count - i);\n            break;\n          }\n        }\n        arduino_usb_event_post(USB_CDC_RX, _interface, count);\n      }\n    }\n  }\n}", "CodeBleu_score": 41.3017013314295}, {"code": "void USBCDC::_onRX(){\n\t  uint32_t len = tud_cdc_n_available(0);\n\n  if (len > 0) {\n    uint8_t buf[len];\n    uint32_t read = tud_cdc_n_read(0, buf, len);\n\n    if (read > 0) {\n      if (xQueueSend(_rx_queue, buf, 0) == pdPASS) {\n        log_e(\"USBCDC: received %d bytes\", read);\n        _event_queue->post(USBCDC_RECEIVE_EVENT);\n      } else {\n        log_e(\"USBCDC: receive queue overflow (%d bytes dropped)\", read);\n        _event_queue->post(USBCDC_OVERFLOW_EVENT, read);\n      }\n    }\n  }\n}", "CodeBleu_score": 22.115630415889452}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve robot name from URL.\n\trobotName := req.URL.Query().Get(\":robot\")\n\n\t// Check if a robot with the given name exists.\n\tvar robot *gobot.Robot\n\ta.master.Robots().Each(func(r *gobot.Robot) {\n\t\tif r.Name == robotName {\n\t\t\trobot = r\n\t\t}\n\t})\n\n\t// If robot exists, return JSON response with its devices.\n\tif robot != nil {\n\t\t// Create JSON response.\n\t\tdevices := []Device{}\n\t\trobot.Devices().Each(func(device Device) {\n\t\t\tdevices = append(devices, device)\n\t\t})\n\t\tresponse := DevicesResponse{\n\t\t\tDevices: devices,\n\t\t}\n\t\t// Write JSON response.\n\t\ta.writeJSON(res, response)\n\t\treturn\n\t}\n\n\t// If robot does not exist, return JSON response with error message.\n\tresponse := ErrorResponse{\n\t\tError: \"No robot found with name \" + robotName,\n\t}\n\ta.writeJSON(res, response)\n}", "CodeBleu_score": 50.61788236379303}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Check if robot with the given name exists\n\tif _, ok := a.master.Robot(req.URL.Query().Get(\":robot\")); !ok {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name \" + req.URL.Query().Get(\":robot\")})\n\t\treturn\n\t}\n\n\t// Gather devices associated with the robot\n\tdevices := []map[string]string{}\n\ta.master.Robot(req.URL.Query().Get(\":robot\")).Devices().Each(func(name string, device gobot.Device) {\n\t\tdevices = append(devices, map[string]string{\"name\": name, \"type\": reflect.TypeOf(device).String()})\n\t})\n\n\t// Write JSON response\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 53.582350442340754}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": fmt.Sprintf(\"robot %s not found\", robotName)})\n\t\treturn\n\t}\n\n\tdevices := make([]map[string]string, 0)\n\trobot.Devices().Each(func(name string, device gobot.Device) {\n\t\tdevices = append(devices, map[string]string{\n\t\t\t\"name\":  name,\n\t\t\t\"class\": reflect.TypeOf(device).String(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 50.60602921569226}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\trobotName := req.URL.Query().Get(\":robot\")\n\t// Check if the robot exists.\n\tif robot, ok := a.master.Robot(robotName); ok {\n\t\t// If the robot exists, iterate through its connections, convert them to JSON format, and write them to the HTTP response.\n\t\tconnections := make([]gobot.Connection, 0)\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tconnections = append(connections, c)\n\t\t})\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\t// If the robot is not found, write an error message to the HTTP response indicating that no robot with the specified name was found.\n\t\ta.writeError(res, \"No robot with the name \\\"\"+robotName+\"\\\" was found.\")\n\t}\n}", "CodeBleu_score": 44.47095574301591}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"Robot '%s' not found\", robotName)\n\t\treturn\n\t}\n\tconnections := make([]map[string]interface{}, 0)\n\trobot.Connections().Each(func(name string, conn gobot.Connection) {\n\t\tconnections = append(connections, a.writeJSON(conn))\n\t})\n\ta.writeJSON(connections).Encode(res)\n}", "CodeBleu_score": 52.00908676243883}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"no robot with name \" + robotName))\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\trobot.Connections().Each(func(name string, conn gobot.Connection) {\n\t\ta.writeJSON(res, conn)\n\t})\n}", "CodeBleu_score": 32.278016685508824}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\n\tif device == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"device not found\"}`))\n\t\treturn\n\t}\n\n\tif err := a.executeCommand(device, req.URL.Query().Get(\":command\"), req.URL.Query().Get(\":arg\")); err != nil {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"` + err.Error() + `\"}`))\n\t\treturn\n\t}\n\n\tres.Write([]byte(`{\"success\": true}`))\n}", "CodeBleu_score": 54.32643068868249}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\ta.writeJSON(res, 404, map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, 404, map[string]string{\"error\": \"device not found\"})\n\t\treturn\n\t}\n\n\tcmd := req.URL.Query().Get(\":command\")\n\tif cmd == \"\" {\n\t\ta.writeJSON(res, 400, map[string]string{\"error\": \"command not specified\"})\n\t\treturn\n\t}\n\n\tif err := device.(gobot.Commander).Command(cmd); err != nil {\n\t\ta.writeJSON(res, 500, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\ta.writeJSON(res, 200, map[string]string{\"success\": \"command executed\"})\n}", "CodeBleu_score": 52.53259676044944}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound,\n\t\t\ta.jsonError(fmt.Sprintf(\"robot %s not found\", req.URL.Query().Get(\":robot\"))))\n\t\treturn\n\t}\n\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound,\n\t\t\ta.jsonError(fmt.Sprintf(\"device %s not found\", req.URL.Query().Get(\":device\"))))\n\t\treturn\n\t}\n\n\tif err := a.executeCommand(device, req.URL.Query().Get(\":command\")); err != nil {\n\t\ta.writeJSON(res, http.StatusBadRequest, a.jsonError(err.Error()))\n\t\treturn\n\t}\n\n\ta.writeJSON(res, http.StatusOK, a.jsonDeviceFor(device))\n}", "CodeBleu_score": 53.14041907997533}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Authorization header from the request\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\t// If the header is empty, return an error\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Slice the header into its two parts\n\t\tauthParts := strings.SplitN(auth, \" \", 2)\n\t\t// If the header is not valid, return an error\n\t\tif len(authParts) != 2 || authParts[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Decode the credentials\n\t\tpayload, err := base64.StdEncoding.DecodeString(authParts[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the decoded payload\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\t// If the payload is not valid, return an error\n\t\tif len(pair) != 2 || !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If the header is valid, proceed to the next handler\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 46.32249059647387}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(u, username) || !secureCompare(p, password) {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Proceed to handler\n\t}\n}", "CodeBleu_score": 51.92827021049957}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(u, username) || !secureCompare(p, password) {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If everything checks out, we can proceed with the request and set the\n\t\t// request context user.\n\t\tctx := context.WithValue(r.Context(), contextKeyUser, u)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t}\n}", "CodeBleu_score": 50.73025469352055}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog read\")\n\t}\n\n\traw, err := a.Pin().AnalogRead()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\n\ta.lastRead = time.Now()\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 51.10322827630497}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog read\", a.Connection().Name())\n\t}\n\n\traw, err := a.Pin().AnalogRead()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := raw * a.sensorCfg.scale\n\n\ta.lastRead = time.Now()\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 54.43746813322592}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection == nil || !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"analog reading not supported\")\n\t}\n\traw, err := a.Pin().AnalogRead()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := raw * a.sensorCfg.scale\n\ta.lastRead = time.Now()\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 51.830054791875824}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tg := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:  pin,\n\t\ta:    a,\n\t}\n\n\tg.mutex = &sync.Mutex{}\n\n\tfor _, option := range opts {\n\t\tif s, ok := option.(string); ok {\n\t\t\tg.name = s\n\t\t}\n\t}\n\n\t// Check if analog reader is already started\n\tif !g.a.Started() {\n\t\tg.a.Start()\n\t}\n\n\treturn g\n}", "CodeBleu_score": 37.7639095078851}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tconnector: &gobot.AnalogSensor{\n\t\t\tname:     gobot.DefaultName(\"GroveSoundSensor\"),\n\t\t\tpin:      pin,\n\t\t\tinterval: 10 * time.Millisecond,\n\t\t\tactive:   true,\n\t\t\tmin:      0,\n\t\t\tmax:      1023,\n\t\t\tadapter:  a,\n\t\t},\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase string:\n\t\t\td.name = option.(string)\n\t\tcase time.Duration:\n\t\t\td.connector.interval = option.(time.Duration)\n\t\tcase int:\n\t\t\td.connector.active = option.(int)\n\t\tcase []int:\n\t\t\td.connector.min = option.([]int)[0]\n\t\t\td.connector.max = option.([]int)[1]\n\t\t}\n\t}\n\n\td.AddEvent(SoundEvent)\n\n\treturn d\n}", "CodeBleu_score": 35.581047059404774}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\treturn &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tconnector: &gobot.AnalogSensorDriver{\n\t\t\tname:       gobot.DefaultName(\"GroveSoundSensor\"),\n\t\t\tconnector:  a,\n\t\t\tpin:        pin,\n\t\t\tgobot.Eventer: gobot.NewEventer(),\n\t\t\tgobot.Commander: gobot.NewCommander(),\n\t\t},\n\t}\n}", "CodeBleu_score": 31.483150196436792}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftResetCommand)\n\ttime.Sleep(10 * time.Millisecond)\n\tval, err := d.readByteData(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&(1<<4) != 0 {\n\t\treturn fmt.Errorf(\"MFRC522: soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 53.26962364905356}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write soft-reset command\n\td.writeByteData(CommandReg, SoftReset)\n\t// Wait for soft-reset to complete\n\ttime.Sleep(time.Millisecond * 50)\n\t// Check if the power-down bit is still set\n\tif d.readByteData(CommandReg)&0x80 != 0 {\n\t\treturn fmt.Errorf(\"softReset: initialization took too long\")\n\t}\n\t// Wait for device to recover from soft-reset\n\ttime.Sleep(time.Millisecond * 10)\n\treturn nil\n}", "CodeBleu_score": 33.07859989389305}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tvalue, err := d.readByteData(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif value&0x80 == 0x80 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 52.11830954705261}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tvar length uint8\n\tvar err error\n\n\t// Get the number of bytes in the FIFO\n\tif length, err = d.readRegister(FIFOLevelReg); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if enough bytes are available in the FIFO\n\tif length > len(backData) {\n\t\treturn 0, fmt.Errorf(\"FIFO length %d is less than back data length %d\", length, len(backData))\n\t}\n\n\t// Read the FIFO buffer\n\tfor i := uint8(0); i < length; i++ {\n\t\tif backData[i], err = d.readRegister(FIFODataReg); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the last bits received\n\treturn d.readRegister(ControlReg) & 0x07, nil\n}", "CodeBleu_score": 42.629435111261756}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tvar length int\n\tvar value uint8\n\tvar err error\n\n\tlength, err = d.getFifoLength()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif length != len(backData) {\n\t\treturn 0, fmt.Errorf(\"MFRC522: readFifo: read %d bytes, expected %d\", length, len(backData))\n\t}\n\n\tfor i := 0; i < length; i++ {\n\t\tbackData[i], err = d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tvalue, err = d.readByteData(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn value, nil\n}", "CodeBleu_score": 49.65262566796481}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Get the number of bytes currently in the FIFO\n\tfifoLen, err := d.getFIFOLength()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// Check if the requested number of bytes to read is available in the FIFO\n\tif fifoLen < len(backData) {\n\t\treturn 0, fmt.Errorf(\"FIFO length is %d, expected %d\", fifoLen, len(backData))\n\t}\n\t// Read the bytes from the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the last bits received\n\treturn d.readByteData(ControlReg)\n}", "CodeBleu_score": 45.95647488254998}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\td.log.Debugf(\"Halting PICC\")\n\t}\n\n\td.clearBitMask(d.regCommand, d.cmdTransceive)\n\n\td.writeByte(d.regTxMode, d.txLastBits24)\n\td.writeByte(d.regCommand, d.piccHalt)\n\td.writeByte(d.regBitFraming, d.txLastBits24)\n\n\td.writeByte(d.regCommand, d.cmdTransceive)\n\n\tif d.communicateWithPICC(d.piccHalt) == false {\n\t\treturn fmt.Errorf(\"Error in communication with PICC\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 19.71770122456553}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Println(\"Halting PICC\")\n\t}\n\tcmd := []byte{0x50, 0x01}\n\td.calculateCRC(cmd, 2)\n\tcmd = append(cmd, d.crcBuffer[0], d.crcBuffer[1])\n\td.write(cmd)\n\t_, err := d.read(1)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error halting PICC: %w\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.06374511832333}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.debugLog(\"piccHalt\")\n\t// Build command buffer\n\tcmd := make([]uint8, 4)\n\tcmd[0] = mifareCommandMFHalt\n\t// Calculate CRC_A\n\tcmd[1] = d.calculateCRC(cmd[:1])\n\t// Send the command\n\td.write(mifareCommandReg, cmd[:2])\n\t// Wait for the PICC to become ready - 1 byte at a time.\n\t// MFRC522 does not perform CRC or parity checks on the halt command and report successful communication even when the PICC is not connected.\n\t// The MFRC522 only communicates with the PICC, so we can check the \"EOF\" byte for valid communication.\n\t// We start with 256, because in the case of MIFARE Classic we know that the UID has 4 bytes, so we do the read in 2 calls of 16 bytes.\n\t// The remaining 8 bytes of the UID are in the buffer.\n\tfor i := 0; i < 256; i++ {\n\t\td.write(mifareCommandReg, []uint8{mifareCommandMFHalt})\n\t\t// Read the resulting 16 bytes\n\t\t// TODO: Verify that this works on all types of MIFARE cards.\n\t\tresp, err := d.read(mifareCommandReg, 16)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Check for the UID in the first 4 bytes (CRC_A is not checked)\n\t\tif resp[0] == 0x00 && resp[1] == 0x00 && resp[2] == 0xff && resp[3] == 0xff {\n\t\t\t// UID is found, communication can end.\n\t\t\treturn nil\n\t\t}\n\t}\n\t// No valid response found, return error.\n\treturn fmt.Errorf(\"No valid response found\")\n}", "CodeBleu_score": 36.722169158934726}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare the command\n\tcmd := []byte{\n\t\tbyte(CMD_READ),\n\t\tbyte(block),\n\t}\n\n\t// Calculate the CRC_A\n\tcrc := d.calculateCRC(cmd)\n\n\t// Append CRC_A to the command\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Transmit the command and retrieve the response\n\tresponse, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the response\n\tif response[0]&0x0F != 0x0A {\n\t\treturn nil, fmt.Errorf(\"Error while reading block %d\", block)\n\t}\n\n\t// Return the data\n\treturn response[1:17], nil\n}", "CodeBleu_score": 37.81452816391388}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare the command.\n\td.clearRegisterBit(d.CommandReg, 0x80) // Power down\n\td.writeRegister(d.CommandReg, d.piccCommand(0x30, block))\n\td.writeRegister(d.BitFramingReg, 0x00) // Default 0x07\n\t// Execute the command.\n\tif err := d.piccRequest(); err != nil {\n\t\treturn nil, err\n\t}\n\t// Read the data.\n\tdata := make([]byte, 18)\n\td.communicateWithPICC(data)\n\t// Check response.\n\tif data[0] != 0x00 || data[1] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"error reading block %d\", block)\n\t}\n\t// Return data.\n\treturn data[2 : 2+16], nil\n}", "CodeBleu_score": 38.79547097598724}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare the command\n\tcmd := make([]byte, 2)\n\tcmd[0] = d.piccReadCmd\n\tcmd[1] = block\n\t// Calculate CRC\n\tcrc := d.calculateCRC(cmd)\n\t// Append CRC to the command\n\tcmd = append(cmd, crc...)\n\t// Send the command\n\terr := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Read the response\n\tresponse := make([]byte, 18)\n\t_, err = d.dev.Read(response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Check the response\n\tif response[0] != d.piccReadResp {\n\t\treturn nil, fmt.Errorf(\"Unexpected response: %v\", response[0])\n\t}\n\t// Check the CRC\n\tif !d.checkCRC(response[:17], response[17:]) {\n\t\treturn nil, fmt.Errorf(\"CRC error\")\n\t}\n\t// Return the data\n\treturn response[1:17], nil\n}", "CodeBleu_score": 42.34724589836939}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Check if the answer buffer is large enough to contain the response\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"buffer too small\")\n\t}\n\n\t// Clear the bit in the collision register\n\tif err := d.clearRegisterBitMask(collReg, 0x80); err != nil {\n\t\treturn err\n\t}\n\n\t// Set the transmission mode\n\tif reqMode == reqModeTransmit {\n\t\tif err := d.clearRegisterBitMask(txModeReg, 0x80); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := d.setRegisterBitMask(txModeReg, 0x80); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Set the transmission mode\n\tif reqMode == reqModeTransmit {\n\t\tif err := d.setRegisterBitMask(txModeReg, 0x03); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := d.clearRegisterBitMask(txModeReg, 0x03); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Send the command\n\tif err := d.communicateWithPICC(reqMode, answer); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 63.359823195611185}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\td.clearRegisterBitMask(CollReg, 0x80)\n\tif reqMode == PICC_CMD_REQA || reqMode == PICC_CMD_WUPA || reqMode == PICC_CMD_CT {\n\t\td.setRegisterBitMask(CollReg, 0x08)\n\t} else {\n\t\td.clearRegisterBitMask(CollReg, 0x08)\n\t}\n\tif reqMode == PICC_CMD_REQA || reqMode == PICC_CMD_WUPA || reqMode == PICC_CMD_HLTA {\n\t\td.clearRegisterBitMask(BitFramingReg, 0x80)\n\t} else {\n\t\td.setRegisterBitMask(BitFramingReg, 0x80)\n\t}\n\t_, err := d.communicateWithPICC(reqMode, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif reqMode == PICC_CMD_HLTA {\n\t\td.clearRegisterBitMask(CollReg, 0x08)\n\t}\n\treturn nil\n}", "CodeBleu_score": 57.71557085929883}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Clear the bit in the Status register that signals that a collision was detected\n\td.clearRegisterBitMask(MFRC522_REG_COLL, MFRC522_VAL_COLL_BIT)\n\n\t// Set the bit in the FIFOLevel register that signals that we want to use the FIFO\n\td.setRegisterBitMask(MFRC522_REG_FIFOLEVEL, MFRC522_VAL_FIFO_LEVEL)\n\n\t// Set the bit in the Command register that signals that we want to use the transmitter\n\td.setRegisterBitMask(MFRC522_REG_COMMAND, MFRC522_VAL_TRANSMIT)\n\n\t// Set the bit in the TxMode register that signals that we want to use the transmitter\n\td.setRegisterBitMask(MFRC522_REG_TXMODE, MFRC522_VAL_TRANSMIT_BIT)\n\n\t// Set the bit in the TxMode register that signals that we want to use the transmitter\n\td.setRegisterBitMask(MFRC522_REG_TXMODE, MFRC522_VAL_TRANSMIT_BIT)\n\n\t// Set the bit in the TxMode register that signals that we want to use the transmitter\n\td.setRegisterBitMask(MFRC522_REG_TXMODE, MFRC522_VAL_TRANSMIT_BIT)\n\n\t// Set the bit in the TxMode register that signals that we want to use the transmitter\n\td.setRegisterBitMask(MFRC522_REG_TXMODE, MFRC522_VAL_TRANSMIT_BIT)\n\n\t// Set the bit in the TxMode register that signals that we want to use the transmitter\n\td.setRegisterBitMask(MFRC522_REG_TXMODE, MFRC522_VAL_TRANSMIT_BIT)\n\n\t// Set the bit in the TxMode register that signals that we want", "CodeBleu_score": 35.31045664188925}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == Clockwise {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 86.00482179380444}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.digitalWrite(d.stepPin, 0)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, 1)\n\n\tif d.direction {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.70503589641457}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 0 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 74.23290519003234}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo d.distanceMonitor(\"distance monitor\")\n\n\treturn nil\n}", "CodeBleu_score": 41.11402221924942}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\td.distanceMonitorStopChan = make(chan struct{})\n\n\tgo d.distanceMonitor(\"continuous\")\n\n\treturn nil\n}", "CodeBleu_score": 38.96439593453604}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.distanceMonitor(\"distance monitor\")\n\n\treturn nil\n}", "CodeBleu_score": 41.11402221924942}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, edge string, level uint32, id uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t}\n\t\tif edge == \"falling\" {\n\t\t\td.pulseDuration <- (time.Now().Sub(startTimestamp)).Microseconds()\n\t\t}\n\t}\n}", "CodeBleu_score": 38.60947041249401}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, id uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t}\n\t\tif edge == \"falling\" {\n\t\t\td.pulseDurationCh <- (time.Now().Sub(startTimestamp)).Microseconds()\n\t\t}\n\t}\n}", "CodeBleu_score": 39.401550922944786}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Duration\n\treturn func(pin int, duration time.Duration, edge string, level uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = d.getTimestamp()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := (d.getTimestamp() - startTimestamp).Microseconds()\n\t\t\td.send(d.channel, duration)\n\t\t}\n\t}\n}", "CodeBleu_score": 47.85690167886052}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor\n\terr := d.trigger()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measurementComplete:\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"HCSR04Driver: Timeout waiting for measurement to complete\")\n\t}\n\n\t// Store the measured time in microseconds\n\td.distance = d.pulseWidth * 1000000 / 58\n\n\treturn nil\n}", "CodeBleu_score": 53.30581440912901}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.trigger.Low()\n\ttime.Sleep(10 * time.Microsecond)\n\td.trigger.High()\n\n\t// Wait for the echo pin to go high\n\tif err := d.waitForPin(d.echo, gpio.High); err != nil {\n\t\treturn fmt.Errorf(\"failed to wait for echo pin to go high: %w\", err)\n\t}\n\n\t// Wait for the echo pin to go low\n\tif err := d.waitForPin(d.echo, gpio.Low); err != nil {\n\t\treturn fmt.Errorf(\"failed to wait for echo pin to go low: %w\", err)\n\t}\n\n\t// Measure the time between the trigger pin going high and the echo pin going low\n\ttimeMicroseconds, err := d.measureTime()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to measure time: %w\", err)\n\t}\n\n\t// Calculate the distance\n\td.distance = d.calculateDistance(timeMicroseconds)\n\n\treturn nil\n}", "CodeBleu_score": 54.78553195822804}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor\n\td.triggerPin.Low()\n\ttime.Sleep(time.Microsecond * 2)\n\td.triggerPin.High()\n\n\t// Wait for the echo pin to go high\n\tfor d.echoPin.Read() == 0 {\n\t\tselect {\n\t\tcase <-d.stopChan:\n\t\t\treturn errors.New(\"measurement cancelled\")\n\t\tdefault:\n\t\t\t// Do nothing\n\t\t}\n\t}\n\n\t// Measure the time it takes for the echo pin to go low\n\tstart := time.Now()\n\tfor d.echoPin.Read() == 1 {\n\t\tselect {\n\t\tcase <-d.stopChan:\n\t\t\treturn errors.New(\"measurement cancelled\")\n\t\tdefault:\n\t\t\t// Do nothing\n\t\t}\n\t}\n\td.distanceMicros = time.Since(start)\n\n\t// Emit the trigger event\n\td.emitTrigger(d.distanceMicros)\n\n\treturn nil\n}", "CodeBleu_score": 51.80307236306704}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    # First check if the token is available in the environment variables\n    if \"GITHUB_AUTH_TOKEN\" in os.environ:\n        return os.environ[\"GITHUB_AUTH_TOKEN\"]\n\n    # If not, check if the token is available in the local state\n    auth_data = self.get_local_state_item(\"authentication\")\n    if auth_data:\n        if time.time() < auth_data[\"expires_at\"]:\n            return auth_data[\"access_token\"]\n        elif auth_data[\"refresh_token\"]:\n            # If the access token is expired but a refresh token is available,\n            # attempt to fetch a new access token using the refresh token\n            auth_data = self.refresh_authentication_token(\n                auth_data[\"refresh_token\"]\n            )\n            if auth_data:\n                self.set_local_state_item(\"authentication\", auth_data)\n                return auth_data[\"access_token\"]\n\n    # If all methods fail, raise an \"AccountNotAuthorized\" exception\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 34.162434784797384}, {"code": "def fetch_authentication_token(self)\n\t\n    if 'ACCESS_TOKEN' in os.environ:\n        self.logger.debug('Using access token from environment variable.')\n        return os.environ['ACCESS_TOKEN']\n    elif 'REFRESH_TOKEN' in os.environ:\n        self.logger.debug('Using refresh token from environment variable.')\n        return self.refresh_authentication_token()\n    else:\n        self.logger.debug('Using access token from local state.')\n        access_token = self.get_local_access_token()\n        if access_token:\n            if self.is_access_token_expired(access_token):\n                self.logger.debug('Access token is expired.')\n                refresh_token = self.get_local_refresh_token()\n                if refresh_token:\n                    self.logger.debug('Using refresh token from local state.')\n                    return self.refresh_authentication_token()\n                else:\n                    self.logger.debug('No refresh token available.')\n                    raise AccountNotAuthorized\n            else:\n                self.logger.debug('Access token is valid.')\n                return access_token\n        else:\n            self.logger.debug('No access token available.')\n            raise AccountNotAuthorized\n\n", "CodeBleu_score": 34.95320430183038}, {"code": "def fetch_authentication_token(self)\n\t\n\n    # Check if the token is available in the environment variables\n    access_token = os.environ.get(ACCESS_TOKEN_ENV_VAR)\n    if access_token is not None:\n        return access_token\n\n    # Check if the token is available in the local state\n    auth_data = self.get_local_authentication_data()\n    if auth_data is not None and auth_data.get(ACCESS_TOKEN_KEY) is not None:\n        return auth_data.get(ACCESS_TOKEN_KEY)\n\n    # Check if the token is available in the local state\n    auth_data = self.get_local_authentication_data()\n    if auth_data is not None and auth_data.get(ACCESS_TOKEN_KEY) is not None:\n        return auth_data.get(ACCESS_TOKEN_KEY)\n\n    # Check if the refresh token is available in the local state\n    auth_data = self.get_local_authentication_data()\n    if auth_data is not None and auth_data.get(REFRESH_TOKEN_KEY) is not None:\n        # Fetch a new access token using the refresh token\n        auth_data = self.fetch_new_access_token(auth_data.get(REFRESH_TOKEN_KEY))\n        if auth_data is not None:\n            # Update the local state with the new authentication data\n            self.set_local_authentication_data(auth_data)\n            return auth_data.get(ACCESS_TOKEN_KEY)\n\n    # Raise an exception if all methods fail\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 25.90340821418084}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            self.api_url + \"/v1/logout\",\n            self.get_refresh_token(),\n            \"POST\",\n            \"accounts/logout\",\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 49.97555666456793}, {"code": "def logout(self)\n\t\n    self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\"/v1/logout\", \"POST\", {\"refresh_token\": self.refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 41.80457408819282}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\n            \"/v1/logout\",\n            method=\"POST\",\n            params={\"refresh_token\": refresh_token},\n        )\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 57.772267624157855}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if not package.is_optional:\n            items = [package.name, package.version]\n            if package.is_external:\n                items.append(package.source_url)\n            result.append(items)\n    return result\n\n", "CodeBleu_score": 23.6708346504999}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if not package.optional:\n            items = [package.name, package.version]\n            if package.metadata.get(\"external\", False):\n                items.append(package.source_url)\n            result.append(items)\n    return result\n\n", "CodeBleu_score": 28.758656614945306}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if not package.options.get('optional', False):\n            items = {}\n            items['name'] = package.name\n            items['version'] = package.version\n            if package.metadata.get('external', False):\n                items['source'] = package.metadata['source']\n            result.append(items)\n    return result\n\n", "CodeBleu_score": 32.13543380971483}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = cls.new(env, targets, autoinstall)\n    p.configure_project_packages()\n    return p\n\n", "CodeBleu_score": 10.7841385663614}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    config = ProjectConfig.get_instance()\n    platform_spec = config.get_platform_spec(env)\n    if platform_spec is None:\n        raise UndefinedEnvPlatformError(env)\n    p = cls(platform_spec, autoinstall=autoinstall)\n    p.set_project_env(env)\n    p.configure_project_packages(targets=targets)\n    return p\n\n", "CodeBleu_score": 31.84576514069096}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if env not in cls.get_env_names():\n        raise UndefinedEnvPlatformError(env)\n    p = cls(config.get(env), autoinstall)\n    p.configure_project_packages(env, targets)\n    return p\n\n", "CodeBleu_score": 38.06414531727287}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 76.36026533254808}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission(false);\n  Wire1.requestFrom(0x34, Size, false);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 75.83304416886996}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 76.36026533254808}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us > 0) {\n    esp_sleep_enable_timer_wakeup(time_in_us);\n  } else {\n    esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n  }\n  esp_deep_sleep_start();\n}", "CodeBleu_score": 67.55475214296553}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 41.44818467707243}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    // Disable all wakeup sources\n    SetSleep();\n\n    // Enable timer wakeup if duration is non-zero\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    }\n\n    // Enter deep sleep\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 52.357098589799946}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t  int y = tte_y;\n  if (tte_bar) {\n    tft.fillRect(0, 0, TFT_WIDTH, TFT_HEIGHT - TTE_BAR_HEIGHT, color);\n    y = TTE_BAR_HEIGHT;\n  }\n  else {\n    tft.fillRect(0, 0, TFT_WIDTH, TFT_HEIGHT - TTE_BAR_HEIGHT, tte_bg_color);\n    y = 0;\n  }\n  tte_y = (y + TTE_LINE_HEIGHT) % (TFT_HEIGHT - TTE_BAR_HEIGHT);\n  tft.setScrollArea(0, TTE_BAR_HEIGHT, TFT_WIDTH, TFT_HEIGHT - TTE_BAR_HEIGHT);\n  tft.setScrollAddress(y);\n  return y;\n}", "CodeBleu_score": 28.959028388726658}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y_old = y_scroll;\n  if (tteBar) {\n    tft.fillRect(0, y_scroll, tft.width(), tft.height() - y_scroll, color);\n    y_scroll += tft.fontHeight(1);\n    if (y_scroll >= tft.height() - tft.fontHeight(1)) {\n      y_scroll = tft.fontHeight(1);\n    }\n  } else {\n    tft.fillRect(0, y_scroll, tft.width(), tft.height() - y_scroll - tft.fontHeight(1), color);\n    y_scroll += tft.fontHeight(1);\n    if (y_scroll >= tft.height() - tft.fontHeight(1) - tft.fontHeight(1)) {\n      y_scroll = tft.fontHeight(1);\n    }\n  }\n  tft.setScroll(y_scroll);\n  return y_old;\n}", "CodeBleu_score": 24.50879876052097}, {"code": "int Display::scroll_line(uint32_t color){\n\t    int y_start = scroll_address;\n    if (tteBar) {\n        tft.fillRect(0, 0, 240, 40, color);\n        y_start += 40;\n    }\n    tft.fillRect(0, y_start, 240, 32, color);\n    y_start += 32;\n    if (y_start >= 176) {\n        y_start = 40;\n        if (tteBar) {\n            tft.fillRect(0, 0, 240, 40, color);\n            y_start += 40;\n        }\n    }\n    scroll_address = y_start;\n    return y_start - 32;\n}", "CodeBleu_score": 21.591116941564543}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  // set the APs\n  if (!this->setAPs(ssids)) {\n    return false;\n  }\n  // set the HTML content\n  if (!this->setHtml(access_points)) {\n    return false;\n  }\n  // start the portal\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 64.40709732208387}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t    this->ssids = ssids;\n    this->access_points = access_points;\n    if(this->setAP() && this->setHtml()) {\n        this->startPortal();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 57.47885841714434}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t    if (ssids->isEmpty() || access_points->isEmpty()) {\n        return false;\n    }\n    if (!setAP(ssids, access_points)) {\n        return false;\n    }\n    if (!setHtml(ssids, access_points)) {\n        return false;\n    }\n    startPortal();\n    return true;\n}", "CodeBleu_score": 59.77756056473342}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t    if (this->queue_enabled_flag) {\n        this->flush_queue();\n    } else {\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 18.58736329861793}, {"code": "void GpsInterface::enable_queue(){\n\t    if (queue_enabled_flag) {\n        if (this->queue == nullptr) {\n            this->queue = new Queue<GpsData*>();\n        }\n        if (this->text == nullptr) {\n            this->text = new Queue<char*>();\n        }\n        if (this->text_in == nullptr) {\n            this->text_in = new Queue<char*>();\n        }\n    } else {\n        this->flush_queue();\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 26.545654188322093}, {"code": "void GpsInterface::enable_queue(){\n\t    if (this->queue_enabled_flag) {\n        this->flush_queue();\n        this->text = \"\";\n        this->text_in = \"\";\n    } else {\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 23.61035490822517}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue != NULL) {\n        this->new_queue = new Queue<string>();\n        delete this->queue;\n        this->queue = this->new_queue;\n    } else {\n        this->queue = new Queue<string>();\n    }\n}", "CodeBleu_score": 26.034488175824457}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\n    // If the queue exists and contains elements, it creates a new queue and deletes the old one\n    if (this->queue_nmea != NULL && this->queue_nmea->size() > 0) {\n\n        // Create a new queue\n        this->queue_nmea = new Queue<NmeaSentence*>();\n\n        // Delete the old queue\n        delete this->queue_nmea_old;\n\n        // Set the old queue to the new queue\n        this->queue_nmea_old = this->queue_nmea;\n    }\n\n    // If the queue does not exist, it simply creates a new queue\n    else if (this->queue_nmea == NULL) {\n\n        // Create a new queue\n        this->queue_nmea = new Queue<NmeaSentence*>();\n    }\n}", "CodeBleu_score": 21.095448451743444}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue != NULL) {\n\t\tdelete this->queue;\n\t\tthis->queue = new Queue();\n\t}\n\telse {\n\t\tthis->queue = new Queue();\n\t}\n}", "CodeBleu_score": 17.447821708327034}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    // Start a write transaction\n    display_obj.tft.startWrite();\n\n    // Set the address window to the provided area\n    display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n\n    // Iterate through each pixel in the provided area and write the corresponding color from the color buffer\n    for (int32_t y = area->y1; y <= area->y2; y++) {\n      for (int32_t x = area->x1; x <= area->x2; x++) {\n        // Write the color of the current pixel\n        display_obj.tft.writeColor(color_p->full, 1);\n\n        // Increment the color buffer pointer by 1 to move on to the next pixel\n        color_p++;\n      }\n    }\n\n    // End the write transaction\n    display_obj.tft.endWrite();\n\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 79.8563581028519}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    // Get the display object\n    tft_obj_t *display_obj = (tft_obj_t *)disp->user_data;\n\n    // Start a write transaction\n    display_obj->tft.startWrite();\n\n    // Set the address window to the specified area\n    display_obj->tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\n    // Iterate through each pixel in the area\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        // Write the corresponding color from the color buffer\n        display_obj->tft.writeColor(*color_p++, 1);\n      }\n    }\n\n    // End the write transaction\n    display_obj->tft.endWrite();\n\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 66.48305258147889}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    // Start a write transaction\n    display_obj.tft.startWrite();\n    // Set the address window to the area\n    display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n    // Iterate through each pixel in the area\n    for (int32_t y = area->y1; y <= area->y2; y++) {\n      for (int32_t x = area->x1; x <= area->x2; x++) {\n        // Write the corresponding color from the color buffer\n        display_obj.tft.writeColor(color_p->full);\n        color_p++;\n      }\n    }\n    // End the write transaction\n    display_obj.tft.endWrite();\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 79.17644425887802}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tSerial.print(\"menu->list->get\");\n\tSerial.print(layer);\n\tSerial.println(\"()\");\n\tSerial.print(\"menu->list->size\");\n\tSerial.print(layer);\n\tSerial.println(\"()\");\n\tSerial.println(\"Serial.print(\\\" \\\");\");\n\tSerial.println(\"Serial.print(menu->list->get\");\n\tSerial.print(layer);\n\tSerial.println(\"()->name);\");\n\tSerial.println(\"Serial.println(\\\"\\\");\");\n}", "CodeBleu_score": 26.59129526935426}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tSerial.print(\"menu->list->get\");\n\tSerial.print(layer);\n\tSerial.println(\"->name\");\n\tSerial.println(\"menu->list->get\");\n\tSerial.print(layer);\n\tSerial.println(\"->name\");\n\tSerial.println(\"menu->list->size\");\n\tSerial.println(\"menu->list->size\");\n\tSerial.println(\"\");\n}", "CodeBleu_score": 28.585994084291432}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  Serial.print(F(\"menu->list->get(\"));\n  Serial.print(layer);\n  Serial.print(F(\")->name\"));\n  Serial.println();\n  Serial.print(menu->list->get(layer)->name);\n  Serial.println();\n  Serial.print(F(\"menu->list->size\"));\n  Serial.println();\n  Serial.print(menu->list->size);\n  Serial.println();\n  Serial.println();\n}", "CodeBleu_score": 43.746219129261505}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  int ssidCount = 0;\n  while (ssidCount < count) {\n    String essid = randomESSID();\n    int channel = randomChannel();\n    String mac = randomMAC();\n    ssids->add(new SSID(essid, channel, mac));\n    Serial.print(F(\"Generated SSID: \"));\n    Serial.println(essid);\n    ssidCount++;\n  }\n  return ssidCount;\n}", "CodeBleu_score": 32.49056779386014}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    Serial.println(F(\"Generating random SSIDs...\"));\n    String ssid;\n    int channel;\n    byte mac[6];\n    for (int i = 0; i < count; i++) {\n        ssid = randomString(6);\n        channel = random(1, 12);\n        for (int j = 0; j < 6; j++) {\n            mac[j] = random(255);\n        }\n        ssids->add(ssid, channel, mac);\n        Serial.println(ssid);\n    }\n    return count;\n}", "CodeBleu_score": 49.055361188090686}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int i;\n  for (i = 0; i < count; i++) {\n    String essid = random(100000, 999999);\n    int channel = random(1, 14);\n    String mac = \"00:00:00:00:00:00\";\n    mac.concat(random(100, 999));\n    mac.concat(\":\");\n    mac.concat(random(100, 999));\n    mac.concat(\":\");\n    mac.concat(random(100, 999));\n    mac.concat(\":\");\n    mac.concat(random(100, 999));\n    mac.concat(\":\");\n    mac.concat(random(100, 999));\n    mac.concat(\":\");\n    mac.concat(random(100, 999));\n    ssids->add(new WiFiScanResult(essid, channel, mac));\n    Serial.println(essid + \" \" + String(channel) + \" \" + mac);\n  }\n  return i;\n}", "CodeBleu_score": 38.397576430316875}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(f\"Topic {topic.name} created.\")\n\n", "CodeBleu_score": 47.73233828837617}, {"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(\n        \"Topic created: {}\".format(topic)\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 76.03801977492601}, {"code": "def create_topic(project_id, topic_name)\n\t\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 90.9582225300981}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    import jwt\n    import datetime\n    from google.auth.transport.requests import Request\n    now = datetime.datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 60.80367409307603}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    import jwt\n    import datetime\n    import os\n\n    # Set the issuer (iss) to the GCP project ID\n    # Set the audience (aud) to the GCP project ID\n    # Set the expiration time (exp) to one hour later\n    # Set the issued time (iat) to the current UTC time\n    # Set the algorithm to the specified algorithm\n    payload = {\n        'iss': project_id,\n        'aud': project_id,\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'iat': datetime.datetime.utcnow()\n    }\n\n    # Read the private key from the specified file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create a JWT using the specified algorithm\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 65.11776673471209}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    import jwt\n    import datetime\n    from google.auth.transport.requests import Request\n    from google.oauth2 import id_token\n    request = Request()\n    now = datetime.datetime.utcnow()\n    payload = {\n        \"iat\": now,\n        \"exp\": now + datetime.timedelta(hours=1),\n        \"aud\": project_id\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    return id_token.jwt_encode(request, payload, private_key, algorithm)\n\n", "CodeBleu_score": 50.570458280837585}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message from topic '{}': {}\".format(message.topic, message.payload.decode(\"utf-8\")))\n    if message.payload.decode(\"utf-8\") == \"on\":\n        print(\"Capturing preview image...\")\n        preview_capture()\n        print(\"Uploading preview image...\")\n        upload_file(preview_image_path, bucket_name)\n        print(\"Publishing image URL...\")\n        unused_client.publish(event_topic, payload.format(preview_image_path), qos=1)\n        print(\"on\")\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 29.87986464513513}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n\n    payload = message.payload.decode(\"utf-8\")\n    topic = message.topic\n    qos = message.qos\n    print(\"Received message '\" + payload + \"' on topic '\" + topic + \"' with QoS \" + str(qos))\n    if payload == \"on\":\n        print(\"Capturing preview image...\")\n        capture_file_name = preview_capture()\n        print(\"Uploading file to bucket...\")\n        upload_file(capture_file_name, args.bucket)\n        print(\"Publishing file URL to MQTT event topic...\")\n        unused_client.publish(args.event_topic, \"https://storage.googleapis.com/{}/{}\".format(args.bucket, capture_file_name), qos=1)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 35.27319321464451}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message on topic {0}: {1}\".format(message.topic, message.payload.decode(\"utf-8\")))\n    if message.payload.decode(\"utf-8\") == \"on\":\n        print(\"Preview capture\")\n        preview_capture()\n        print(\"Upload file\")\n        upload_file()\n        print(\"Publish file URL\")\n        unused_client.publish(\n            \"iot-2/evt/camera_event/fmt/json\",\n            \"{\\\"url\\\": \\\"{0}\\\"}\".format(payload.decode(\"utf-8\")),\n            0,\n        )\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 30.263582578683334}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Project ID of the Google Cloud Project.  If not specified, we '\n        'will use the value of the GOOGLE_CLOUD_PROJECT environment variable.',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument(\n        '--registry_id',\n        help='Registry id to use.',\n        required=True)\n    parser.add_argument(\n        '--device_id',\n        help='Device id to use.',\n        required=True)\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region',\n        help='GCP cloud region to use.',\n        default='us-central1')\n    parser.add_argument(\n        '--ca_certs',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        default=8883,\n        type=int,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,\n        help='Expiration time, in minutes, for JWT tokens.')\n    parser.", "CodeBleu_score": 33.9423888410351}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=\"Google Cloud IoT MQTT device connection example.\")\n    parser.add_argument(\n        \"--project_id\",\n        help=\"GCP cloud project name\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\n        \"--registry_id\",\n        help=\"Cloud IoT registry ID\",\n        default=\"my-registry\")\n    parser.add_argument(\n        \"--device_id\",\n        help=\"Cloud IoT device ID\",\n        default=\"my-device\")\n    parser.add_argument(\n        \"--private_key_file\",\n        help=\"Path to private key file.\")\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n        default=\"RS256\")\n    parser.add_argument(\n        \"--cloud_region\",\n        help=\"GCP cloud region\",\n        default=\"us-central1\")\n    parser.add_argument(\n        \"--ca_certs\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n        default=\"roots.pem\")\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\")\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Indicates whether the message to be published is a 'telemetry' event or a device 'state' update.\")\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        help=\"MQTT bridge hostname.\",\n        default=\"mqtt.googleapis.com\")\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        help=\"MQTT bridge port.\",\n        default=8883)\n    parser.add_argument(\n        \"--jwt_expires_min", "CodeBleu_score": 35.53102633811982}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Identifier of the Google Cloud project that owns the subscription.')\n    parser.add_argument(\n        '--subscription',\n        help='Name of the subscription.')\n    parser.add_argument(\n        '--registry',\n        help='Name of the registry.')\n    parser.add_argument(\n        '--device',\n        help='Name of the device.')\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region',\n        help='GCP cloud region.')\n    parser.add_argument(\n        '--ca_certs',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        default=8883,\n        type=int,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,\n        help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event', 'state'),\n        default='event',\n        help='Indicates whether the message to be published is a '\n        'telemetry", "CodeBleu_score": 31.114639771927493}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # Define the necessary API scopes for the Google Cloud IoT Core service\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    # Define the version of the API to use\n    version = 'v1'\n    # Define the discovery URL for the API\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes)\n\n    # Create the client using the credentials and the discovery URL\n    client = discovery.build('cloudiot', version, credentials=credentials,\n                             discoveryServiceUrl=discovery_url)\n\n    return client\n\n", "CodeBleu_score": 22.772383481549152}, {"code": "def get_client(service_account_json)\n\t\n    # The device that has been created on the Google Cloud IoT Core service\n    device_id = \"RaspberryPi\"\n    # The registry that has been created on the Google Cloud IoT Core service\n    registry_id = \"my-registry\"\n    # The Google Cloud project ID\n    project_id = \"iot-workshop\"\n    # The region (e.g., us-central1) the registry is located in\n    cloud_region = \"europe-west1\"\n    # The URL of the discovery API\n    api_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    # The version of the API to use\n    api_version = \"v1\"\n    # The scopes required for the API to function\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    # Load the service account key JSON file and the necessary scopes\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n    # Build the service using the credentials and create a client\n    service = discovery.build(\n        \"cloudiot\", api_version, credentials=credentials, discoveryServiceUrl=api_url\n    )\n    return service\n\n", "CodeBleu_score": 48.74595028728357}, {"code": "def get_client(service_account_json)\n\t\n    # The device that connects to the service.\n    device_id = \"device_id\"\n    # The path to the service account key json file.\n    # service_account_json = \"./service_account.json\"\n    # The ID of the GCP project associated with the service account.\n    project_id = \"project_id\"\n    # The region (e.g. us-central1) associated with the above project.\n    cloud_region = \"cloud_region\"\n    # The ID of the PubSub topic to publish device events to.\n    pubsub_topic = \"pubsub_topic\"\n    # The ID of the PubSub topic to subscribe to for configuration updates.\n    mqtt_bridge_subscription = \"mqtt_bridge_subscription\"\n    # The ID of the PubSub topic to publish device configuration responses to.\n    mqtt_bridge_config_topic = \"mqtt_bridge_config_topic\"\n    # The MQTT bridge hostname.\n    mqtt_bridge_hostname = \"mqtt.googleapis.com\"\n    # The MQTT bridge port.\n    mqtt_bridge_port = 8883\n\n    # [START iot_core_create_client]\n    # Create the MQTT client using the Google Cloud IoT Core service account\n    # for authentication.\n    client = mqtt.Client(client_id=device_id)\n\n    # Set the path to the service account key json file.\n    client.username_pw_set(\n        username=\"unused\",\n        password=None,\n    )\n\n    # Set the call back functions for connection and disconnection to the\n    # Google Cloud IoT Core MQTT bridge.\n    client.on_connect = on_connect\n    client.on_disconnect = on_disconnect\n\n    # Set the call back functions for connection and disconnection to the\n    # Google Cloud IoT Core MQTT bridge.\n    client.on_connect = on_connect\n    client.on_disconnect = on_disconnect\n\n    # Set the callback function for receiving configuration messages.\n    client.on_message = on_message\n\n    # Set the callback function for receiving configuration", "CodeBleu_score": 30.356025537441745}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_code = hash_method.get_asn1_code()\n    if hash_method_code is None:\n        raise ValueError(\"Invalid hash method\")\n    padded_hash = hash_method_code + hash_value\n    padded_hash = _pad_for_signing(padded_hash)\n    signature = priv_key.blinded_encrypt(padded_hash)\n    return signature\n\n", "CodeBleu_score": 27.781063048655714}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_code = hash_method.get_asn1_code()\n    if not hash_code:\n        raise ValueError(\"Invalid hash method\")\n    hash_value = hash_code + hash_value\n    padded_hash = _pad_for_signing(hash_value)\n    return priv_key.blinded_encrypt(padded_hash)\n\n", "CodeBleu_score": 21.60174070597256}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_code = hash_method.get_asn1_code()\n    if hash_code is None:\n        raise ValueError('Invalid hash method.')\n    hash_code_size = common.byte_size(hash_code)\n    hash_size = common.byte_size(hash_value)\n    padded_hash = hash_code + hash_value\n    padded_hash_size = common.byte_size(padded_hash)\n    if padded_hash_size <= hash_code_size:\n        raise ValueError('Invalid hash value.')\n    padding_size = padded_hash_size - hash_code_size - hash_size\n    padding = transform.int2bytes(0xff, padding_size)\n    padded_hash = padded_hash + padding\n    padded_hash_size = common.byte_size(padded_hash)\n    if padded_hash_size != 128:\n        raise ValueError('Invalid hash value.')\n    return priv_key.blinded_encrypt(padded_hash)\n\n", "CodeBleu_score": 31.647315277637624}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        sig_int = transform.bytes2int(signature)\n    except ValueError as e:\n        raise VerificationError(\"Invalid signature\") from e\n    clear_sig = core.decrypt_int(sig_int, pub_key)\n    hash_method = _find_method_hash(clear_sig)\n    if hash_method is None:\n        raise VerificationError(\"Invalid signature\")\n    hash_method_name = hash_method.name\n    hash_method_size = hash_method.digest_size\n    hash_method_padding = hash_method.block_size\n    hash_method_hash = compute_hash(message, hash_method)\n    expected_padded_hash = _pad_for_signing(hash_method_hash, hash_method_size, hash_method_padding)\n    if expected_padded_hash != clear_sig:\n        raise VerificationError(\"Invalid signature\")\n    return hash_method_name\n\n", "CodeBleu_score": 41.11835619338785}, {"code": "def verify(message, signature, pub_key)\n\t\n    signature = transform.bytes2int(signature)\n    clear_signature = core.decrypt_int(signature, pub_key)\n    hash_method = _find_method_hash(clear_signature)\n    message_hash = compute_hash(message, hash_method)\n    expected_hash = _pad_for_signing(message_hash, hash_method)\n    if expected_hash != clear_signature:\n        raise VerificationError('Invalid signature.')\n    return hash_method\n\n", "CodeBleu_score": 18.75754277851475}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(signature, str):\n        raise TypeError('signature must be a string')\n    if not isinstance(pub_key, str):\n        raise TypeError('pub_key must be a string')\n    if not isinstance(message, str):\n        raise TypeError('message must be a string')\n    signature = transform.bytes2int(signature)\n    pub_key = transform.bytes2int(pub_key)\n    clear_signature = core.decrypt_int(signature, pub_key)\n    method_hash = _find_method_hash(clear_signature)\n    padded_hash = _pad_for_signing(message, method_hash)\n    if padded_hash != clear_signature:\n        raise VerificationError('invalid signature')\n    return method_hash\n\n", "CodeBleu_score": 40.2781671720153}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t  if (time(NULL) < 2000000000) {\n    updateJWT();\n  }\n  MQTT_CLIENT_connect(&mqttClient, &connectParams);\n  sendSubscribe = true;\n  debug_print(\"INFO: Connecting to MQTT.\n\");\n}", "CodeBleu_score": 27.687952375159174}, {"code": "static void connectMQTT(){\n\t  time_t now;\n  time(&now);\n  if (now > 1510644967) {\n    updateJWT();\n  }\n  MQTT_CLIENT_connect();\n  sendSubscribe = true;\n  debug_print(\"Connecting to MQTT...\n\");\n}", "CodeBleu_score": 26.490652263876935}, {"code": "static void connectMQTT(){\n\t    time_t now = time(NULL);\n    if (now > 0) {\n        updateJWT();\n    }\n    MQTT_CLIENT_connect();\n    send_subscribe = true;\n    debug_print(\"MQTT CONNECTING...\n\");\n}", "CodeBleu_score": 32.92665064899919}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t result = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t c = *str++;\n        if (c < '0' || c > '9') {\n            return str;\n        }\n        result = result * 10 + (c - '0');\n    }\n    *num = result;\n    return str;\n}", "CodeBleu_score": 26.352679518759984}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    const uint8_t* p = str;\n    uint32_t n = 0;\n    while (width--) {\n        if (*p < '0' || *p > '9')\n            return str;\n        n = n * 10 + *p++ - '0';\n    }\n    *num = n;\n    return p;\n}", "CodeBleu_score": 23.73340835525422}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t result = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t digit = *str++;\n        if (digit < '0' || digit > '9') {\n            return str;\n        }\n        digit -= '0';\n        if (result > UINT32_MAX / 10) {\n            return str;\n        }\n        result = result * 10 + digit;\n    }\n    *num = result;\n    return str;\n}", "CodeBleu_score": 32.347271679745774}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = 0;\n    uint8_t* cert_ptr = build_state->cert_def->cert_template;\n    size_t cert_size = build_state->cert_def->cert_size;\n    size_t cert_offset = 0;\n    uint8_t* cert_end = cert_ptr + cert_size;\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_size < build_state->cert_def->cert_size)\n    {\n        return ATCACERT_E_BUFFER_TOO_SMALL;\n    }\n\n    if (build_state->cert_def->cert_template == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def->cert_size < build_state->cert_def->tbs_cert_loc.offset + build_state->cert_def->tbs_cert_loc.size)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def->public_key_loc.offset == 0)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def->public_key_loc.size == 0)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def->signature_loc.offset == 0)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def->signature", "CodeBleu_score": 44.791544294121124}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = 0;\n    uint8_t* cert_der = build_state->cert_def->cert_template_der;\n    size_t cert_der_size = build_state->cert_def->cert_template_der_size;\n    size_t cert_der_max = build_state->cert_def->cert_template_der_size;\n    size_t cert_der_size_needed = 0;\n    uint8_t* cert_der_pos = cert_der;\n    uint8_t* cert_der_end = cert_der + cert_der_size;\n    uint8_t* cert_der_pos_end = cert_der_pos + cert_der_size;\n    uint8_t* cert_der_pos_start = cert_der_pos;\n    size_t cert_der_max_needed = 0;\n    size_t cert_der_max_needed_temp = 0;\n    size_t cert_der_size_needed_temp = 0;\n    uint8_t* cert_der_pos_temp = NULL;\n    size_t cert_der_size_needed_temp_prev = 0;\n    size_t cert_der_max_needed_temp_prev = 0;\n    size_t cert_der_size_needed_temp_prev_prev = 0;\n    int cert_der_max_needed_temp_prev_prev_prev = 0;\n    uint8_t* cert_der_pos_temp_prev = NULL;\n    uint8_t* cert_der_pos_temp_prev_prev = NULL;\n    uint8_t* cert_der_pos_temp_prev_prev_prev = NULL;\n    uint8_t* cert_der_pos_temp_prev_prev_prev_prev = NULL;\n    size_t cert_der_size_needed_temp_prev_prev_prev = 0;\n    size_t cert_der_max_needed_temp_prev_prev_prev = 0;\n    size_t cert_der_size_needed_temp_prev_prev_prev_prev", "CodeBleu_score": 16.714140609461094}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t  if (build_state == NULL)\n    return ATCACERT_E_BAD_PARAMS;\n\n  if (build_state->cert_def == NULL)\n    return ATCACERT_E_BAD_PARAMS;\n\n  if (build_state->cert_def->cert_template_size > build_state->cert_size)\n    return ATCACERT_E_BUFFER_TOO_SMALL;\n\n  if (build_state->cert_def->cert_template_size > build_state->cert_size)\n    return ATCACERT_E_BUFFER_TOO_SMALL;\n\n  memcpy(build_state->cert, build_state->cert_def->cert_template, build_state->cert_def->cert_template_size);\n\n  return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 43.9373767605583}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t  int                   ret = ATCACERT_E_SUCCESS;\n  uint8_t               tbs_digest[32];\n  uint8_t               signature[64];\n  size_t                signature_size;\n  atcacert_cert_t       cert_obj;\n  atcacert_device_loc_t device_loc;\n\n  if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n    return ATCACERT_E_BAD_PARAMS;\n  }\n\n  if (cert_def->type != CERTTYPE_X509) {\n    return ATCACERT_E_BAD_PARAMS;\n  }\n\n  ret = atcacert_get_device_loc(cert_def, &device_loc);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  ret = atcacert_get_signature(cert_def, cert, cert_size, signature, &signature_size);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  ret = atcab_verify_extern(tbs_digest, signature, ca_public_key);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  return ret;\n}", "CodeBleu_score": 75.45559801860023}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t  int                      ret = 0;\n  uint8_t                  tbs_digest[32];\n  uint8_t                  signature[64];\n  size_t                   tbs_digest_size = sizeof(tbs_digest);\n  size_t                   signature_size = sizeof(signature);\n  atcacert_device_loc_t    ca_public_key_dev_loc;\n  atcacert_device_loc_t    ca_signature_dev_loc;\n  atcacert_device_loc_t    cert_signature_dev_loc;\n  atcacert_device_loc_map_t device_loc_map;\n\n  if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n    return ATCACERT_E_BAD_PARAMS;\n  }\n\n  ret = atcacert_get_device_loc(cert_def, &device_loc_map);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  ret = atcacert_get_subj_public_key_loc(&device_loc_map, &cert_signature_dev_loc);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  ret = atcacert_get_ca_public_key_loc(&device_loc_map, &ca_public_key_dev_loc);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  ret = atcacert_get_signature_loc(&device_loc_map, &ca_signature_dev_loc);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest, &tbs_digest_size);\n  if (ret != ATCACERT_E_SUCCESS) {\n   ", "CodeBleu_score": 65.15753477463404}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    size_t tbs_digest_size = sizeof(tbs_digest);\n    size_t signature_size = sizeof(signature);\n\n    if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    /* Get the TBS digest */\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    /* Get the signature */\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    /* Verify the signature */\n    ret = atcab_verify_extern(tbs_digest, tbs_digest_size, signature, signature_size, ca_public_key);\n    if (ret != ATCA_SUCCESS) {\n        return ATCACERT_E_VERIFY_FAILED;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 82.57611666792542}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t *volatile *prev = &list;\n\ttimerStruct_t *volatile *curr = list;\n\twhile (curr != NULL) {\n\t\tif (curr == &timer) {\n\t\t\t*prev = timer->next;\n\t\t\treturn true;\n\t\t}\n\t\tprev = &(curr->next);\n\t\tcurr = curr->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 23.241403357621216}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if (timer->next == 0)\n    {\n        *list = 0;\n    }\n    else\n    {\n        timer->next->prev = timer->prev;\n        if (timer->prev == 0)\n        {\n            *list = timer->next;\n        }\n        else\n        {\n            timer->prev->next = timer->next;\n        }\n    }\n    timer->next = 0;\n    timer->prev = 0;\n    return true;\n}", "CodeBleu_score": 19.467214589054436}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\t\ttimerStruct_t * volatile *ptr = list;\n\t\ttimerStruct_t * volatile *prevptr = list;\n\t\ttimerStruct_t * volatile *nextptr = list;\n\t\ttimerStruct_t * volatile *tmp;\n\t\ttimerStruct_t * volatile *tmp2;\n\t\ttimerStruct_t * volatile *tmp3;\n\t\ttimerStruct_t * volatile *tmp4;\n\t\ttimerStruct_t * volatile *tmp5;\n\t\ttimerStruct_t * volatile *tmp6;\n\t\ttimerStruct_t * volatile *tmp7;\n\t\ttimerStruct_t * volatile *tmp8;\n\t\ttimerStruct_t * volatile *tmp9;\n\t\ttimerStruct_t * volatile *tmp10;\n\t\ttimerStruct_t * volatile *tmp11;\n\t\ttimerStruct_t * volatile *tmp12;\n\t\ttimerStruct_t * volatile *tmp13;\n\t\ttimerStruct_t * volatile *tmp14;\n\t\ttimerStruct_t * volatile *tmp15;\n\t\ttimerStruct_t * volatile *tmp16;\n\t\ttimerStruct_t * volatile *tmp17;\n\t\ttimerStruct_t * volatile *tmp18;\n\t\ttimerStruct_t * volatile *tmp19;\n\t\ttimerStruct_t * volatile *tmp20;\n\t\ttimerStruct_t * volatile *tmp21;\n\t\ttimerStruct_t * volatile *tmp22;\n\t\ttimerStruct_t * volatile *tmp23;\n\t\ttimerStruct_t * volatile *tmp24;\n\t\ttimerStruct_t * volatile *tmp25;\n\t\ttimerStruct_t * volatile *tmp26;\n\t\ttimerStruct_t * volatile *tmp27;\n\t\ttimerStruct_t * volatile *tmp28;\n\t\ttimerStruct_t * volatile *tmp29;\n\t\ttimerStruct_t * volatile *tmp30;\n\t\ttimerStruct_t * volatile *tmp31;\n\t\ttimerStruct_t * volatile *", "CodeBleu_score": 7.439221404716475}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tstruct socketInfo* socketInfo = getSocketInfo(socket);\n\tif (socketInfo == NULL) {\n\t\tbsd_setErrNo(EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tint status = close(socket);\n\tif (status == -1) {\n\t\tif (errno == EBADF) {\n\t\t\tbsd_setErrNo(EBADF);\n\t\t} else if (errno == ENOTSOCK) {\n\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t} else if (errno == EINTR) {\n\t\t\tbsd_setErrNo(EINTR);\n\t\t} else {\n\t\t\tbsd_setErrNo(EIO);\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\tsocketInfo->state = NOT_A_SOCKET;\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 48.24505037633306}, {"code": "int BSD_close(int socket){\n\t\tint ret = 0;\n\tstruct socket_info *si = getSocketInfo(socket);\n\tif (si == NULL) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tret = close(si->fd);\n\tif (ret == -1) {\n\t\tif (errno == EBADF) {\n\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t} else if (errno == EINTR) {\n\t\t\tbsd_setErrNo(BSD_EINTR);\n\t\t} else if (errno == EINVAL) {\n\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t} else if (errno == EIO) {\n\t\t\tbsd_setErrNo(BSD_EIO);\n\t\t} else if (errno == EISCONN) {\n\t\t\tbsd_setErrNo(BSD_EISCONN);\n\t\t} else if (errno == ENOTSOCK) {\n\t\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\t} else if (errno == ENOTCONN) {\n\t\t\tbsd_setErrNo(BSD_ENOTCONN);\n\t\t} else if (errno == ENOTCONN) {\n\t\t\tbsd_setErrNo(BSD_ENOTCONN);\n\t\t} else if (errno == ENOTCONN) {\n\t\t\tbsd_setErrNo(BSD_ENOTCONN);\n\t\t} else if (errno == ENOTCONN) {\n\t\t\tbsd_setErrNo(BSD_ENOTCONN);\n\t\t} else if (errno == ENOTCONN) {\n\t\t\tbsd_setErrNo(BSD_ENOTCONN);\n\t\t} else if (errno == ENOTCONN) {\n\t\t\tbsd_setErrNo(BSD_ENOTCONN);\n\t\t} else if (errno == ENOTCONN) {\n\t\t\tbsd_", "CodeBleu_score": 40.996744476874646}, {"code": "int BSD_close(int socket){\n\t    struct socketInfo *socketInfo = getSocketInfo(socket);\n    if (socketInfo == NULL) {\n        debug_printGOOD(\"BSD_close: Socket does not exist.\");\n        bsd_setErrNo(BSD_ENOTSOCK);\n        return BSD_ERROR;\n    }\n    debug_printGOOD(\"BSD_close: Socket exists.\");\n    debug_printGOOD(\"BSD_close: Closing socket...\");\n    int status = close(socket);\n    if (status == -1) {\n        debug_printBAD(\"BSD_close: Error occurred.\");\n        if (errno == EBADF) {\n            bsd_setErrNo(BSD_EBADF);\n            return BSD_ERROR;\n        }\n        if (errno == EINTR) {\n            bsd_setErrNo(BSD_EINTR);\n            return BSD_ERROR;\n        }\n        if (errno == EIO) {\n            bsd_setErrNo(BSD_EIO);\n            return BSD_ERROR;\n        }\n        if (errno == EINVAL) {\n            bsd_setErrNo(BSD_EINVAL);\n            return BSD_ERROR;\n        }\n        if (errno == EISCONN) {\n            bsd_setErrNo(BSD_EISCONN);\n            return BSD_ERROR;\n        }\n        if (errno == ENOTSOCK) {\n            bsd_setErrNo(BSD_ENOTSOCK);\n            return BSD_ERROR;\n        }\n        if (errno == ENOTCONN) {\n            bsd_setErrNo(BSD_ENOTCONN);\n            return BSD_ERROR;\n        }\n        if (errno == EPROTOTYPE) {\n            bsd_setErrNo(BSD_EPROTOTYPE);\n            return BSD_ERROR;\n        }\n        if (errno == EALREADY) {\n            bsd_setErrNo(BSD_EALREADY);\n            return BSD_ERROR;\n        }\n        if (errno == ENOTSOCK", "CodeBleu_score": 42.59156744809834}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint response;\n\t\n\tif ((response = listen(socket, backlog)) < 0) {\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 23.012852302578562}, {"code": "int BSD_listen(int socket, int backlog){\n\t\n\tint ret;\n\n\tret = listen(socket, backlog);\n\tif (ret < 0) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK:\n\t\t\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\t\t\tbreak;\n\t\t\tcase EOPNOTSUPP:\n\t\t\t\tbsd_setErrNo(BSD_EOPNOTSUPP);\n\t\t\t\tbreak;\n\t\t\tcase EADDRINUSE:\n\t\t\t\tbsd_setErrNo(BSD_EADDRINUSE);\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\t\tbreak;\n\t\t\tcase ENOTCONN:\n\t\t\t\tbsd_setErrNo(BSD_ENOTCONN);\n\t\t\t\tbreak;\n\t\t\tcase EAGAIN:\n\t\t\t\tbsd_setErrNo(BSD_EAGAIN);\n\t\t\t\tbreak;\n\t\t\tcase ENOBUFS:\n\t\t\t\tbsd_setErrNo(BSD_ENOBUFS);\n\t\t\t\tbreak;\n\t\t\tcase ECONNABORTED:\n\t\t\t\tbsd_setErrNo(BSD_ECONNABORTED);\n\t\t\t\tbreak;\n\t\t\tcase EINTR:\n\t\t\t\tbsd_setErrNo(BSD_EINTR);\n\t\t\t\tbreak;\n\t\t\tcase EISCONN:\n\t\t\t\tbsd_setErrNo(BSD_EISCONN);\n\t\t\t\tbreak;\n\t\t\tcase ECONNREFUSED:\n\t\t\t\tbsd_setErrNo(BSD_ECONNREFUSED);\n\t\t\t\tbreak;\n\t\t\tcase ECONNRESET:\n\t\t\t\tbsd_setErrNo(", "CodeBleu_score": 39.781023425851785}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret;\n\terrno = 0;\n\tret = listen(socket, backlog);\n\tif (ret == -1) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK:\n\t\t\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\t\t\tbreak;\n\t\t\tcase EOPNOTSUPP:\n\t\t\t\tbsd_setErrNo(BSD_EOPNOTSUPP);\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\t\tbreak;\n\t\t\tcase EADDRINUSE:\n\t\t\t\tbsd_setErrNo(BSD_EADDRINUSE);\n\t\t\t\tbreak;\n\t\t\tcase EADDRNOTAVAIL:\n\t\t\t\tbsd_setErrNo(BSD_EADDRNOTAVAIL);\n\t\t\t\tbreak;\n\t\t\tcase EAFNOSUPPORT:\n\t\t\t\tbsd_setErrNo(BSD_EAFNOSUPPORT);\n\t\t\t\tbreak;\n\t\t\tcase EACCES:\n\t\t\t\tbsd_setErrNo(BSD_EACCES);\n\t\t\t\tbreak;\n\t\t\tcase EAGAIN:\n\t\t\t\tbsd_setErrNo(BSD_EAGAIN);\n\t\t\t\tbreak;\n\t\t\tcase ENOBUFS:\n\t\t\t\tbsd_setErrNo(BSD_ENOBUFS);\n\t\t\t\tbreak;\n\t\t\tcase ENOMEM:\n\t\t\t\tbsd_setErrNo(BSD_ENOMEM);\n\t\t\t\tbreak;\n\t\t\tcase ENOTCONN:\n\t\t\t\tbsd_setErrNo(BSD_ENOTCONN);\n\t\t\t\tbreak;\n\t\t\tcase EPROTONOSUPPORT:\n\t\t\t", "CodeBleu_score": 39.23756364491177}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    int ret;\n    int family;\n    struct bsd_sockaddr_in * addr_in;\n    struct bsd_sockaddr_in6 * addr_in6;\n    struct bsd_sockaddr_un * addr_un;\n    struct bsd_sockaddr_storage * addr_storage;\n    struct bsd_sockaddr_in * addr_in_copy;\n    struct bsd_sockaddr_in6 * addr_in6_copy;\n    struct bsd_sockaddr_un * addr_un_copy;\n    struct bsd_sockaddr_storage * addr_storage_copy;\n    struct bsd_sockaddr_in * addr_in_copy_copy;\n    struct bsd_sockaddr_in6 * addr_in6_copy_copy;\n    struct bsd_sockaddr_un * addr_un_copy_copy;\n    struct bsd_sockaddr_storage * addr_storage_copy_copy;\n\n    if (socket < 0 || socket >= BSD_SOCKET_COUNT) {\n        bsd_setErrNo(BSD_EINVAL);\n        return -1;\n    }\n\n    if (bsd_sockets[socket].type == BSD_SOCKET_TYPE_NONE) {\n        bsd_setErrNo(BSD_EBADF);\n        return -1;\n    }\n\n    if (bsd_sockets[socket].type == BSD_SOCKET_TYPE_STREAM) {\n        family = bsd_sockets[socket].family;\n\n        if (family == BSD_AF_INET) {\n            if (addr == NULL) {\n                ret = accept(bsd_sockets[socket].fd, NULL, NULL);\n            } else {\n                addr_in = (struct bsd_sockaddr_in *) addr;\n                addr_in_copy = (struct bsd_sockaddr_in *) &bsd_sockets[socket].addr_storage;\n                addr_in_copy_copy = (struct bsd_sockaddr_in *) &bsd_sockets[socket].addr_storage_copy;\n\n                memcpy(addr_in_copy, addr_in,", "CodeBleu_score": 37.71124579709362}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    int err;\n    int result;\n    struct sockaddr_in sock_addr;\n    socklen_t sock_addr_len;\n\n    /* Check the address family */\n    if (addr->sa_family == AF_INET) {\n        /* Convert the socket address */\n        sock_addr.sin_family = AF_INET;\n        sock_addr.sin_port = addr->sa_data[0];\n        sock_addr.sin_port = (sock_addr.sin_port << 8) + addr->sa_data[1];\n        sock_addr.sin_addr.s_addr = addr->sa_data[2];\n        sock_addr.sin_addr.s_addr = (sock_addr.sin_addr.s_addr << 8) + addr->sa_data[3];\n        sock_addr.sin_addr.s_addr = (sock_addr.sin_addr.s_addr << 8) + addr->sa_data[4];\n        sock_addr.sin_addr.s_addr = (sock_addr.sin_addr.s_addr << 8) + addr->sa_data[5];\n        sock_addr.sin_addr.s_addr = (sock_addr.sin_addr.s_addr << 8) + addr->sa_data[6];\n        sock_addr.sin_addr.s_addr = (sock_addr.sin_addr.s_addr << 8) + addr->sa_data[7];\n        sock_addr_len = sizeof(sock_addr);\n\n        /* Call the accept function */\n        result = accept(socket, (struct sockaddr *) & sock_addr, & sock_addr_len);\n        if (result == -1) {\n            /* Set the error */\n            bsd_setErrNo(errno);\n        } else {\n            /* Convert the socket address */\n            addr->sa_data[0] = sock_addr.sin_port >> 8;\n            addr->sa_data[1] = sock_addr.sin_port & 0xFF;\n            addr->sa_data[2] =", "CodeBleu_score": 37.023362983173975}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    int ret;\n    int err;\n    int fd;\n    struct sockaddr sa;\n    socklen_t sa_len;\n    struct sockaddr_in * sa_in;\n    struct sockaddr_in6 * sa_in6;\n\n    if (socket < 0 || socket >= MAX_SOCKETS) {\n        bsd_setErrNo(EBADF);\n        return -1;\n    }\n\n    if (sockets[socket].family == 0) {\n        bsd_setErrNo(EBADF);\n        return -1;\n    }\n\n    if (sockets[socket].family == AF_INET) {\n        sa_in = (struct sockaddr_in *) &sa;\n        sa_len = sizeof(struct sockaddr_in);\n        fd = accept(sockets[socket].fd, (struct sockaddr *) sa_in, &sa_len);\n        if (fd < 0) {\n            err = errno;\n            bsd_setErrNo(err);\n            return -1;\n        }\n\n        if (addr != NULL) {\n            addr->sa_family = AF_INET;\n            addr->sa_len = sizeof(struct bsd_sockaddr_in);\n            memcpy(addr->sa_data, &sa_in->sin_addr, sizeof(struct in_addr));\n            memcpy(addr->sa_data + sizeof(struct in_addr), &sa_in->sin_port, sizeof(uint16_t));\n        }\n\n        if (addrlen != NULL) {\n            *addrlen = sizeof(struct bsd_sockaddr_in);\n        }\n\n        return fd;\n    } else if (sockets[socket].family == AF_INET6) {\n        sa_in6 = (struct sockaddr_in6 *) &sa;\n        sa_len = sizeof(struct sockaddr_in6);\n        fd = accept(sockets[socket].fd, (struct sockaddr *) sa_in6, &sa_len);\n        if (fd < 0) {\n            err = errno;\n            bsd_", "CodeBleu_score": 43.69259649941243}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t    time_t now;\n    time(&now);\n    if (now < 1000000000) {\n        debug_print(\"Time is invalid. Not connecting to MQTT.\");\n        return;\n    }\n    updateJWT(now);\n    MQTT_CLIENT_connect();\n    debug_print(\"Connecting to MQTT...\");\n    mqtt_connected = false;\n    mqtt_subscribe = true;\n}", "CodeBleu_score": 50.831582943089096}, {"code": "static void connectMQTT(){\n\t  time_t now;\n  time(&now);\n  if (now < 1000000000) {\n    Serial.println(\"The system time is not set correctly. Please set the time.\");\n    return;\n  }\n  updateJWT();\n  debug_print(\"Connecting to MQTT broker...\");\n  MQTT_CLIENT_connect();\n}", "CodeBleu_score": 22.81173923070278}, {"code": "static void connectMQTT(){\n\t    time_t now;\n    time(&now);\n    if (now < 1000000000) {\n        Serial.println(\"Invalid time, not connecting to MQTT.\");\n        return;\n    }\n    updateJWT();\n    Serial.println(\"Connecting to MQTT...\");\n    MQTT_CLIENT_connect();\n}", "CodeBleu_score": 46.281062764653456}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t  /*\n   * Log a debug message indicating the disconnection.\n   */\n  DEBUG_logDebug(\"Disconnecting from cloud service\");\n\n  /*\n   * If the MQTT connection state is \"CONNECTED\", retrieve the client connection information and disconnect the MQTT client.\n   */\n  if (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n    MQTT_ClientConnectionInfo clientConnectionInfo;\n    MQTT_GetClientConnectionInfo(&clientConnectionInfo);\n    MQTT_Disconnect(clientConnectionInfo.mqttClient);\n  }\n}", "CodeBleu_score": 55.16130117353894}, {"code": "void CLOUD_disconnect(void){\n\t  if (MQTT_GetConnectionState() == CONNECTED) {\n    MQTT_GetClientConnectionInfo(&clientInfo);\n    MQTT_Disconnect(&clientInfo);\n  }\n  debug_printError(\"Disconnected from cloud service.\n\");\n}", "CodeBleu_score": 67.95485272003567}, {"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_GetConnectionState() == CONNECTED) {\n\t\tMQTT_ClientConnectionInfo clientConnectionInfo;\n\t\tMQTT_GetClientConnectionInfo(&clientConnectionInfo);\n\t\tMQTT_Disconnect(&clientConnectionInfo);\n\t}\n\tdebug_printInfo(\"Disconnected from cloud service\");\n}", "CodeBleu_score": 61.61503796643451}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t  char *ssid = NULL;\n  char *password = NULL;\n  uint8_t auth_type = 0;\n  int8_t ret = M2M_ERR_FAIL;\n  bool success = false;\n\n  // If new credentials are provided, connect using those\n  if (passed_wifi_creds == 1) {\n    ssid = WIFI_SSID;\n    password = WIFI_PASSWORD;\n    auth_type = WIFI_AUTH_TYPE;\n\n    ret = m2m_wifi_connect((char *)ssid, strlen(ssid),\n                           (char *)password, strlen(password),\n                           auth_type, M2M_WIFI_CH_ALL);\n  }\n  // If new credentials are not provided, connect using default credentials\n  else {\n    ret = m2m_wifi_default_connect();\n  }\n\n  // If the connection fails, log an error message and return false\n  if (ret != M2M_SUCCESS) {\n    debug_printError(\"[ERROR] Wi-Fi connection failed\");\n    return false;\n  }\n\n  // If the connection succeeds, return true\n  else {\n    success = true;\n    return true;\n  }\n}", "CodeBleu_score": 53.251082001491255}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    if (passed_wifi_creds) {\n        if (m2m_wifi_connect((char *)ssid, strlen(ssid), atoi((char *)auth_type), (char *)password, M2M_WIFI_CH_ALL) != M2M_SUCCESS) {\n            debug_printError(\"Failed to connect to AP with new credentials\");\n            return false;\n        }\n        return true;\n    } else {\n        if (m2m_wifi_default_connect() != M2M_SUCCESS) {\n            debug_printError(\"Failed to connect to AP with default credentials\");\n            return false;\n        }\n        return true;\n    }\n}", "CodeBleu_score": 52.153226094823715}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    // If the user has provided new Wi-Fi credentials\n    if (passed_wifi_creds == 1) {\n        // Connect to the Wi-Fi access point\n        if (m2m_wifi_default_connect() != M2M_SUCCESS) {\n            // If the connection fails, log an error message\n            debug_printError(\"Failed to connect to Wi-Fi access point\");\n            // Update the networking error status\n            networking_error_status = NETWORKING_ERROR_STATUS_WIFI_CONNECTION_FAILED;\n            // Return false\n            return false;\n        }\n        // If the connection succeeds, return true\n        return true;\n    }\n    // If the user has not provided new Wi-Fi credentials\n    else {\n        // Attempt to connect to the Wi-Fi access point using default credentials\n        if (m2m_wifi_connect((char *)wifi_ssid, strlen(wifi_ssid), atoi((char *)wifi_security), (void *)wifi_password, M2M_WIFI_CH_ALL) != M2M_SUCCESS) {\n            // If the connection fails, log an error message\n            debug_printError(\"Failed to connect to Wi-Fi access point\");\n            // Update the networking error status\n            networking_error_status = NETWORKING_ERROR_STATUS_WIFI_CONNECTION_FAILED;\n            // Return false\n            return false;\n        }\n        // If the connection succeeds, return true\n        return true;\n    }\n}", "CodeBleu_score": 48.90733097254337}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t  const client = generateClient();\n  const response = await client.graphql(\n    `query {\n      listSensors {\n        id\n        name\n        geo {\n          latitude\n          longitude\n        }\n      }\n    }`\n  );\n  if (response.data.listSensors.length > 0) {\n    console.log(\"Retrieved sensors\");\n    response.data.listSensors.forEach(sensor => {\n      const marker = document.createElement(\"div\");\n      marker.className = \"marker\";\n      marker.textContent = sensor.name;\n      new Marker({element: marker})\n        .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n        .addTo(map);\n    });\n  }\n  console.log(response);\n}", "CodeBleu_score": 59.72509747834502}, {"code": "async function DisplaySensors(map){\n\t    // Generate a client\n    const client = generateClient();\n\n    // Send a GraphQL query to fetch sensor data\n    const response = await client.graphql(\n        gql`\n            query {\n                listSensors {\n                    id\n                    name\n                    geo {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        `\n    );\n\n    // If the response contains data, log the retrieval of sensors\n    if (response.data.listSensors) {\n        console.log(\"Retrieved sensors\");\n\n        // Iterate through each sensor to create a marker\n        response.data.listSensors.forEach((sensor) => {\n            // Create a marker\n            const marker = document.createElement(\"div\");\n            marker.className = \"marker\";\n            marker.id = sensor.id;\n            marker.innerText = sensor.name;\n\n            // Create a new marker object\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 56.041890321793616}, {"code": "async function DisplaySensors(map){\n\t    // Generate a client\n    const client = generateClient();\n    // Send a GraphQL query to fetch sensor data\n    const response = await client.graphql(\n        gql`\n            query {\n                listSensors {\n                    items {\n                        sensorId\n                        sensorType\n                        geo {\n                            latitude\n                            longitude\n                        }\n                    }\n                }\n            }\n        `\n    );\n    // Log the API response\n    console.log(response);\n    // If the response contains data, log the retrieval of sensors\n    if (response.data.listSensors.items) {\n        console.log('Retrieved sensors:');\n        // Iterate through each sensor\n        response.data.listSensors.items.forEach(sensor => {\n            // Create a marker\n            const marker = document.createElement('div');\n            marker.className = 'marker';\n            marker.id = sensor.sensorId;\n            marker.textContent = sensor.sensorType;\n            // Place the marker on the map at the sensor's geographical coordinates\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n            console.log(sensor.sensorId);\n        });\n    }\n}", "CodeBleu_score": 56.9973551996533}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t    let marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"marker\";\n    marker.style.backgroundColor = sensor.color;\n    marker.style.border = \"1px solid black\";\n    return marker;\n}", "CodeBleu_score": 45.85002544747903}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.classList.add(\"sensorMarker\");\n  marker.style.borderColor = sensor.color;\n  marker.style.backgroundColor = sensor.color;\n  return marker;\n}", "CodeBleu_score": 46.91732625738025}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.backgroundColor = sensor.color;\n    marker.style.borderColor = sensor.color;\n    return marker;\n}", "CodeBleu_score": 47.50375076302219}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = \".\".join([\"homeassistant\", \"auth\", \"mfa_modules\", module_name])\n    try:\n        module = await hass.async_add_executor_job(importlib.import_module, module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Failed to import %s. Make sure all dependencies are installed. \"\n            \"Error was: %s\",\n            module_path,\n            err,\n        )\n        raise HomeAssistantError(\n            f\"Failed to import {module_name} module. See the log for details.\"\n        ) from err\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if module_name in processed:\n        return module\n    if not hass.config.skip_pip:\n        await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n    processed.add(module_name)\n    return module\n\n", "CodeBleu_score": 46.9907518011342}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        module = await hass.async_add_executor_job(importlib.import_module, module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Unable to import %s: %s\", module_path, err)\n        raise HomeAssistantError(f\"Unable to import {module_path}\") from err\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not hass.data.get(DATA_MFA_MODULES):\n        hass.data[DATA_MFA_MODULES] = set()\n    if module.REQUIREMENTS in hass.data[DATA_MFA_MODULES]:\n        return module\n    if not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module_path, module.REQUIREMENTS\n        )\n    hass.data[DATA_MFA_MODULES].add(module.REQUIREMENTS)\n    return module\n\n", "CodeBleu_score": 54.54943727360513}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        module = await hass.async_add_executor_job(importlib.import_module, module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Error importing MFA module %s: %s. Check your installation and try again\",\n            module_name,\n            err,\n        )\n        raise HomeAssistantError(\n            f\"Error importing MFA module {module_name}: {err}. Check your installation and try again\"\n        ) from err\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module_path, module.REQUIREMENTS\n        )\n    processed = getattr(module, \"REQUIREMENTS_PROCESSED\", set())\n    if module_path not in processed:\n        processed.add(module_path)\n        setattr(module, \"REQUIREMENTS_PROCESSED\", processed)\n    return module\n\n", "CodeBleu_score": 53.00859500173929}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n\n    # Extract the PIN from the setup data\n    pin = setup_data[\"pin\"]\n\n    # Check if the user already has an entry in the internal data list\n    if user_id in self.data:\n        # If an entry exists, update the PIN\n        self.data[user_id][\"pin\"] = pin\n    else:\n        # If no entry exists, add a new entry with the user ID and PIN to the data list\n        self.data[user_id] = {\"pin\": pin}\n\n    # Return the setup data\n    return setup_data\n\n", "CodeBleu_score": 37.50703108130836}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    self._data[user_id] = setup_data[\"pin\"]\n    return {\"pin\": setup_data[\"pin\"]}\n\n", "CodeBleu_score": 24.561615146926812}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n", "CodeBleu_score": 33.71592039459607}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    if self._loaded:\n        return\n    with self._lock:\n        if self._loaded:\n            return\n        data = await self.data.get()\n        items = data.get(ATTR_NOTIFY_SETTINGS, {})\n        for user_id, settings in items.items():\n            self._users[user_id] = NotifySetting(\n                user_id,\n                settings.get(ATTR_NOTIFY_SERVICE, \"\"),\n                settings.get(ATTR_NOTIFY_DATA, {}),\n            )\n        self._loaded = True\n\n", "CodeBleu_score": 38.74819499146297}, {"code": "async def _async_load(self) -> None\n\t\n    if self._loaded:\n        return\n\n    async with self._lock:\n        if self._loaded:\n            return\n\n        data = await self.data.get()\n        if data is None:\n            data = {}\n\n        self._settings = {}\n        for user_id, user_data in data.items():\n            if user_id not in self._settings:\n                self._settings[user_id] = NotifySetting(user_id)\n            self._settings[user_id]._async_load(user_data)\n\n        self._loaded = True\n\n", "CodeBleu_score": 36.20072498114218}, {"code": "async def _async_load(self) -> None\n\t\n    if self._loaded:\n        return\n    async with self._lock:\n        if self._loaded:\n            return\n        data = await self._store.async_load()\n        if not data:\n            data = {\n                \"items\": {},\n            }\n        self._items = {}\n        for user_id, user_data in data.get(\"items\", {}).items():\n            self._items[user_id] = NotifySetting(\n                self._hass,\n                user_id,\n                user_data.get(\"notify_service\", \"persistent_notification\"),\n                user_data.get(\"notify_data\", {}),\n            )\n        self._loaded = True\n\n", "CodeBleu_score": 34.84461581978253}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load(user_id)\n    user_settings = self._users.get(user_id)\n    if user_settings is None:\n        return False\n    return await self._async_validate_user_input(user_settings, user_input)\n\n", "CodeBleu_score": 41.53153199570868}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self._async_load()\n    settings = self.settings.get(user_id)\n    if not settings:\n        return False\n    otp = settings.get(CONF_OTP_SECRET)\n    if not otp:\n        return False\n    return await async_add_executor_job(self.validate, otp, user_input.get(CONF_CODE))\n\n", "CodeBleu_score": 47.59619710288832}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load(user_id)\n    if user_id not in self._users:\n        return False\n    user = self._users[user_id]\n    if user.get(CONF_ENABLED, True) is False:\n        return False\n    if user.get(CONF_REQUIRE_PIN, True) is True:\n        if user_input.get(CONF_PIN) != user.get(CONF_PIN):\n            return False\n    if user.get(CONF_REQUIRE_PIN, True) is False:\n        if user_input.get(CONF_PIN) is not None:\n            return False\n    if user.get(CONF_REQUIRE_PIN, True) is True:\n        if user_input.get(CONF_PIN) is None:\n            return False\n    if user.get(CONF_REQUIRE_PIN, True) is False:\n        if user_input.get(CONF_PIN) is not None:\n            return False\n    if user.get(CONF_REQUIRE_PIN, True) is True:\n        if user_input.get(CONF_PIN) is None:\n            return False\n    if user.get(CONF_REQUIRE_PIN, True) is False:\n        if user_input.get(CONF_PIN) is not None:\n            return False\n    if user.get(CONF_REQUIRE_PIN, True) is True:\n        if user_input.get(CONF_PIN) is None:\n            return False\n    if user.get(CONF_REQUIRE_PIN, True) is False:\n        if user_input.get(CONF_PIN) is not None:\n            return False\n    if user.get(CONF_REQUIRE_PIN, True) is True:\n        if user_input.get(CONF_PIN) is None:\n            return False\n    if user.get(CONF_REQUIRE_PIN, True) is False:\n        if user_input.get", "CodeBleu_score": 34.85237299408194}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 64.42890356638978}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 64.42890356638978}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if not entity_entry:\n        return None\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if not device_entry:\n        return None\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 56.866376498375985}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    new_policy = {}\n    seen = set()\n    for policy in policies:\n        for category, values in policy.items():\n            if category not in seen:\n                seen.add(category)\n                new_policy[category] = values\n    return cast(PolicyType, new_policy)\n\n", "CodeBleu_score": 39.89094782266341}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    new_policy = {}\n    seen = set()\n    for policy in policies:\n        for category, policy_category in policy.items():\n            if category not in seen:\n                seen.add(category)\n                new_policy[category] = policy_category\n            else:\n                new_policy[category] = merge_policies([new_policy[category], policy_category])\n    return cast(PolicyType, new_policy)\n\n", "CodeBleu_score": 47.02681756174103}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = {}\n    seen = set()\n    for policy in policies:\n        for category, subpolicy in policy.items():\n            if category not in seen:\n                seen.add(category)\n                merged_policy[category] = subpolicy\n            else:\n                merged_policy[category] = merge_policies([merged_policy[category], subpolicy])\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 43.72980413350351}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import auth provider %s: %s\",\n            provider,\n            err,\n        )\n        raise HomeAssistantError from err\n    if provider not in AUTH_PROVIDERS_REQUIREMENTS:\n        return module\n    reqs = AUTH_PROVIDERS_REQUIREMENTS[provider]\n    if reqs is None:\n        return module\n    processed = hass.data.get(DATA_PROVIDER_SETUP)\n    if processed is None:\n        hass.data[DATA_PROVIDER_SETUP] = processed = set()\n    if provider in processed:\n        return module\n    processed.add(provider)\n    await requirements.async_process_requirements(\n        hass,\n        reqs,\n        CONSTRAINT_EXTRA_REQUIREMENTS,\n        hass.config.path(REQUIREMENTS_DIR),\n    )\n    return module\n\n", "CodeBleu_score": 52.68234457967398}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Error importing auth provider %s: %s\",\n            provider,\n            err,\n        )\n        raise HomeAssistantError() from err\n    if not getattr(module, \"REQUIREMENTS\", None):\n        return module\n    if provider in processed:\n        return module\n    requirements = module.REQUIREMENTS\n    if not isinstance(requirements, list):\n        _LOGGER.error(\n            \"Error importing auth provider %s: invalid requirements\",\n            provider,\n        )\n        raise HomeAssistantError()\n    await requirements.async_process_requirements(hass)\n    processed.add(provider)\n    return module\n\n", "CodeBleu_score": 46.91090824956197}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await hass.async_add_executor_job(importlib.import_module, provider)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import %s: %s. See https://home-assistant.io/docs/authentication/providers/%s/\",\n            provider,\n            err,\n            provider,\n        )\n        raise HomeAssistantError() from err\n    if hasattr(module, \"REQUIREMENTS\"):\n        if module.REQUIREMENTS in processed:\n            return module\n        await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n        processed.add(module.REQUIREMENTS)\n    return module\n\n", "CodeBleu_score": 36.97003165380366}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self._store.async_load()\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Failed to load users: %s\", err)\n        self._users = []\n    else:\n        self._users = data or []\n\n    await self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 31.349747081061928}, {"code": "async def async_load(self) -> None\n\t\n    self._users = await self.store.async_load() or []\n    await self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 18.2313733102548}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        self._users = await self._store.async_load() or []\n        self._async_check_for_not_normalized_usernames()\n    except Exception:  # pylint: disable=broad-except\n        self._users = []\n\n", "CodeBleu_score": 30.46056190850136}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = b\"$2b$12$/0/.oN.EiQhdIcb1.HbWLhOu\"\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise InvalidAuth\n    bcrypt.checkpw(password.encode(), dummy_hash)\n    raise InvalidAuth\n\n", "CodeBleu_score": 49.35942026953735}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.kdf(\n        password.encode(\"utf-8\"),\n        self.bcrypt_rounds,\n        bcrypt.gensalt(self.bcrypt_rounds),\n    )\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(\"utf-8\"), base64.b64decode(user.password)):\n                return\n            else:\n                raise InvalidAuth\n    raise InvalidAuth\n\n", "CodeBleu_score": 36.75585449427673}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = b\"$2b$12$LvRV/Y2mgJUZgH2H0M.k5OxmEt2NQIxXwq.Q8hFU1m6QZo.0w5yGwG\"\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = user[\"password\"].encode(\"utf-8\")\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                return\n            else:\n                bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n                raise InvalidAuth\n    bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n    raise InvalidAuth\n\n", "CodeBleu_score": 40.74363172556621}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(self.messages[\"user_not_found\"])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 39.72285168537327}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.normalize_username(username)\n    for user in enumerate(self.users):\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(self.user_not_found)\n\n", "CodeBleu_score": 32.43712154371108}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            del self.users[i]\n            return\n    raise InvalidUser(self.user_not_found)\n\n", "CodeBleu_score": 35.71640959477507}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.async_initialized:\n        await self.async_initialize\n    try:\n        self.credentials.remove(credentials)\n        await self.async_save\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 41.550773225744926}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n    try:\n        self.data.pop(credentials.data[CONF_USERNAME])\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 54.485379570767655}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        await self.async_initialize()\n    try:\n        self._data.pop(credentials.username)\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 45.4574191776294}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        with contextlib.suppress(TimeoutError):\n            thread.join(timeout)\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread)\n        try:\n            async_raise(thread.ident, SystemExit)\n        except ProcessLookupError:\n            pass\n    return joined\n\n", "CodeBleu_score": 53.600035381941645}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not hasattr(thread, \"ident\"):\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout)\n        except Exception:\n            pass\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread)\n        try:\n            async_raise(thread.ident, SystemExit)\n        except Exception:\n            pass\n    return joined\n\n", "CodeBleu_score": 47.0022472042493}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n        elif thread.ident:\n            try:\n                thread.join(timeout)\n                joined.add(thread)\n            except RuntimeError:\n                pass\n        if log:\n            _log_thread_running_at_shutdown(thread)\n    if len(joined) < len(threads):\n        for thread in threads:\n            if thread not in joined:\n                async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 47.86596506792562}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    timeout = 10\n    threads = [t for t in threading.enumerate() if t is not threading.main_thread() and t.is_alive() and not t.daemon]\n    for t in threads:\n        t.join(timeout=timeout / len(threads))\n        if t.is_alive():\n            _LOGGER.warning(f\"Failed to join thread {t.name} within {timeout} seconds.  It may be deadlocked.\")\n\n", "CodeBleu_score": 25.43365738662035}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Calculate the total time remaining for the shutdown.\n    total_shutdown_time_remaining = _get_total_shutdown_time_remaining()\n\n    # Identify all non-main, non-daemon, alive threads.\n    non_main_non_daemon_alive_threads = _get_non_main_non_daemon_alive_threads()\n\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads.\n    thread_timeouts = _calculate_thread_timeouts(\n        total_shutdown_time_remaining, non_main_non_daemon_alive_threads\n    )\n\n    # Attempt to join each thread within the calculated timeout and log a warning if joining a thread fails.\n    _attempt_to_join_threads(non_main_non_daemon_alive_threads, thread_timeouts)\n\n", "CodeBleu_score": 9.739857920746415}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n\n    def _join_thread(thread: threading.Thread, timeout: float) -> None:\n        try:\n            thread.join(timeout=timeout)\n        except RuntimeError:\n            _LOGGER.warning(\n                f\"Failed to join thread {thread.name} within timeout {timeout} seconds. \"\n                \"This may cause a deadlock.\"\n            )\n\n    _LOGGER.info(\"Shutting down...\")\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread.is_alive() and not thread.daemon and thread != threading.main_thread()\n    ]\n    if len(threads) == 0:\n        _LOGGER.info(\"Shutdown complete.\")\n        return\n    _LOGGER.info(f\"Waiting for {len(threads)} threads to complete...\")\n    timeout = 10\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n        _join_thread(thread, timeout=timeout)\n    for thread in threads:\n", "CodeBleu_score": 32.400716852429355}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_remaining_setups:\n        async_dispatcher_send_internal(self._hass, SIGNAL_SETUP_ENTRY_FINISHED, remaining_with_setup_started)\n    self._previous_remaining_setups = remaining_with_setup_started\n\n\n def _async_setup_entry(self, entry: ConfigEntry) -> None:\n    \"\"\"The function \"_async_setup_entry\" is a wrapper for the function \"async_setup_entry\" to be used in the async_add_entities function.\"\"\"\n    self._hass.async_create_task(self.async_setup_entry(entry))\n\n\n def _async_setup_entries(self, entries: list[ConfigEntry]) -> None:\n    \"\"\"The function \"_async_setup_entries\" is a wrapper for the function \"async_setup_entry\" to be used in the async_add_entities function.\"\"\"\n    for entry in entries:\n        self._hass.async_create_task(self.async_setup_entry(entry))\n\n\n def _async_setup_platform(self, platform_type: str, platform_config: dict[str, Any]) -> None:\n    \"\"\"The function \"_async_setup_platform\" is a wrapper for the function \"async_setup_platform\" to be used in the async_add_entities function.\"\"\"\n    self._hass.async_create_task(self.async_setup_platform(platform_type, platform_config))\n\n\n def _async_setup_platforms(self, platform_types: list[str], platform_configs: dict[str, Any]) -> None:\n    \"\"\"The function \"_async_setup_platforms\" is a wrapper for the function \"async_setup_platform\" to be used in the async_add_entities function.\"\"\"\n    for platform_type, platform_config in platform_configs.items():\n        if platform_type in platform_types:\n            self._hass.async_create_task(self.async_setup_platform(platform_type, platform_config))\n\n\n def _async_start_setup_platforms(self, platform_types:", "CodeBleu_score": 47.3867221372637}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self.remaining_setups or remaining_with_setup_started:\n        async_dispatcher_send_internal(self.hass, self.signal_remaining_setups)\n    self.remaining_setups = remaining_with_setup_started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 44.20058935023657}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self._remaining_setups:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_setups = remaining_with_setup_started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 44.696622384800264}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n", "CodeBleu_score": 7.494588744588746}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    if not config.bluetooth.validate:\n        return\n\n    if config.bluetooth.generate:\n        generate_and_validate(integrations, config)\n        return\n\n    current_content = fp.read(config.bluetooth.path)\n    if not current_content:\n        return\n\n    generated_content = generate(integrations, config)\n    if generated_content == current_content:\n        return\n\n    config.add_error(\n        \"bluetooth.py\",\n        \"Bluetooth configuration is not up to date. Run `python3 -m homeassistant bluetooth` to generate the latest configuration.\",\n        fixable=True,\n    )\n\n", "CodeBleu_score": 44.1262542933663}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    if not config.validate_bluetooth:\n        return\n\n    # Generate the content of bluetooth.py\n    bluetooth_content = generate_and_validate(integrations, config)\n\n    # Check if the content of bluetooth.py has changed\n    if config.bluetooth_content == bluetooth_content:\n        return\n\n    # Add an error to the configuration\n    config.add_error(\n        \"bluetooth.py\",\n        \"bluetooth.py is not up to date. Please run 'python3 -m homeassistant bluetooth' to generate the new file.\",\n        fixable=True,\n    )\n\n", "CodeBleu_score": 37.02710412291626}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\tvar e struct {\n\t\tError string `json:\"error\"`\n\t}\n\tlogger.Info(\"Refreshing Dropbox access token...\")\n\tif err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.DropboxTokenURL); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn err\n\t}\n\tif e.Error != \"\" {\n\t\tlogger.Error(e.Error)\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\tlogger.Info(\"Dropbox access token refreshed.\")\n\treturn nil\n}", "CodeBleu_score": 67.05459842563717}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp := new(RefreshTokenResponse)\n\te := new(ErrorResponse)\n\n\tif err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.DropboxTokenEndpoint); err != nil {\n\t\tlogger.Info(err.Error())\n\t\treturn err\n\t}\n\n\tif e.ErrorSummary != \"\" {\n\t\tlogger.Info(e.ErrorSummary)\n\t\treturn fmt.Errorf(e.ErrorSummary)\n\t}\n\n\td.AccessToken = resp.AccessToken\n\td.ExpiresIn = resp.ExpiresIn\n\td.RefreshToken = resp.RefreshToken\n\td.TokenType = resp.TokenType\n\td.UID = resp.UID\n\n\treturn nil\n}", "CodeBleu_score": 64.19534432215592}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp := &oauth2.Token{}\n\te := &Error{}\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.DropboxOAuth2TokenEndpoint)\n\tif e.Code > 0 {\n\t\tlogger.Info(fmt.Sprintf(\"Failed to refresh the access token for Dropbox, error code: %d, error message: %s, request id: %s\", e.Code, e.Message, e.RequestId))\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 58.06642361949258}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.request(url, method, callback)\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\treturn req.Execute()\n}", "CodeBleu_score": 17.265855164239838}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq, err := d.client.R().SetError(AuthError{}).SetResult(resp).SetHeader(\"Authorization\", \"Bearer \"+d.accessToken).SetHeader(\"Content-Type\", \"application/json\").SetHeader(\"X-Goog-Upload-Protocol\", \"raw\").SetHeader(\"X-Goog-Upload-Command\", \"start\").SetHeader(\"X-Goog-Upload-Content-Length\", \"0\").SetHeader(\"X-Goog-Upload-Offset\", \"0\").SetHeader(\"X-Goog-Upload-Status\", \"final\").SetHeader(\"X-Goog-Upload-File-Name\", \"\").SetHeader(\"X-Goog-Upload-Raw-Size\", \"0\").SetHeader(\"X-Goog-Upload-Mime-Type\", \"application/octet-stream\").SetHeader(\"X-Goog-Upload-Header-Content-Length\", \"0\").SetHeader(\"X-Goog-Upload-Header-Content-Type\", \"application/octet-stream\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-Protocol\", \"raw\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-Command\", \"start\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-Content-Length\", \"0\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-Offset\", \"0\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-Status\", \"final\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-File-Name\", \"\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-Mime-Type\", \"application/octet-stream\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-Raw-Size\", \"0\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-Session-ID\", \"\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-Session-Status\", \"active\").SetHeader(\"X-Goog-Upload-Header-X-Goog-Upload-Session-URI\", \"\").SetHeader(\"X-", "CodeBleu_score": 16.018691001962047}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq, err := d.restyClient.R().SetError(&Error{}).SetResult(resp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetHeader(\"X-Goog-Drive-Resource-Keys\", \"parents\")\n\treq.SetHeader(\"X-Goog-Drive-Resource-Id-Type\", \"driveId\")\n\tif d.driveID != \"\" {\n\t\treq.SetHeader(\"X-Goog-Drive-File-Id\", d.driveID)\n\t}\n\tif d.teamDriveID != \"\" {\n\t\treq.SetHeader(\"X-Goog-Drive-Team-Drive-Id\", d.teamDriveID)\n\t}\n\tvar respBody []byte\n\tfor i := 0; i < 2; i++ {\n\t\tresp, err := req.Execute(method, url)\n\t\tif err != nil {\n\t\t\tif resp != nil && resp.StatusCode() == 401 {\n\t\t\t\td.refreshToken()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\trespBody = resp.Body()\n\t\tbreak\n\t}\n\treturn respBody, nil\n}", "CodeBleu_score": 57.85861818246241}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := d.chunkSize\n\tif chunkSize == 0 {\n\t\tchunkSize = 5 * 1024 * 1024 // 5MB\n\t}\n\tfinish := int64(0)\n\tfor {\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn errors.New(\"request canceled\")\n\t\t}\n\t\treq := d.request(ctx, \"PUT\", url, nil)\n\t\tif finish == 0 {\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t} else {\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize))\n\t\t}\n\t\tif err := req.Do(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfinish += chunkSize\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 57.17687738145874}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(1024 * 1024 * 1024)\n\tfinish := int64(0)\n\tfor {\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn model.ErrCanceled\n\t\t}\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t\tif finish+chunkSize >= stream.GetSize() {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t\treq := d.request.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\tif err := req.Do(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 57.19384442275206}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size.\n\tchunkSize := int64(5 * 1024 * 1024)\n\tif stream.GetSize() < chunkSize {\n\t\tchunkSize = stream.GetSize()\n\t}\n\n\t// Upload the file in chunks.\n\tfinish := int64(0)\n\tfor {\n\t\t// Check if the context was cancelled.\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn errors.New(\"upload cancelled\")\n\t\t}\n\n\t\t// Create the request.\n\t\treq := d.request(url, \"PUT\")\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\n\t\t// Send the request.\n\t\tres, err := req.Send()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check if the request was successful.\n\t\tif res.GetStatus() != 200 && res.GetStatus() != 201 {\n\t\t\treturn errors.New(fmt.Sprintf(\"upload failed: %d\", res.GetStatus()))\n\t\t}\n\n\t\t// Check if the entire file was uploaded.\n\t\tfinish += chunkSize\n\t\tif finish >= stream.GetSize() {\n\t\t\treturn nil\n\t\t}\n\t}\n}", "CodeBleu_score": 61.62959852650267}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar data struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&data); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrBind))\n\t}\n\tif data.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrEmptyMountPoint))\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrUnmount))\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrDeleteConfig))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.Success))\n}", "CodeBleu_score": 43.8399003541315}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar data struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&data); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidParam))\n\t}\n\tif data.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidParam))\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrService))\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrService))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.Success))\n}", "CodeBleu_score": 43.719640155446605}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context and retrieve the \"mount_point\" value.\n\tvar reqData struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&reqData); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrBadRequest))\n\t}\n\tif reqData.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrBadRequest))\n\t}\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err := service.MyService.Storage().UnmountStorage(reqData.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrServiceInternal))\n\t}\n\t// Delete the corresponding configuration.\n\tif err := service.MyService.Storage().DeleteConfigByName(reqData.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrServiceInternal))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ErrSuccess))\n}", "CodeBleu_score": 43.78134439161923}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the request query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\t// Check if the file path is provided.\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathNotProvided))\n\t}\n\t// Check if the file exists.\n\tif !file.Exists(filePath) {\n\t\t// Return a JSON response with an error message.\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\t// Return the file to the client.\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.83482485241514}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters.\n\tpath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided.\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidParam))\n\t}\n\n\t// Check if the file exists.\n\tif !file.Exists(path) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\t// Return the file to the client.\n\treturn ctx.File(path)\n}", "CodeBleu_score": 46.43568537180492}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"filepath\")\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an appropriate error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathNotProvided))\n\t}\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\t// Return a JSON response with an appropriate error message\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.05883306951896}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\t// Bind the request body to a message map.\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err != nil {\n\t\t// If binding fails, return a bad request error with the binding error message.\n\t\treturn common_err.GetMsg(ctx, common_err.ErrBadRequest, err.Error())\n\t}\n\t// Send the notification using the \"name\" and \"message\".\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\t// If the notification fails, return an internal server error.\n\t\treturn common_err.GetMsg(ctx, common_err.ErrInternalServerError, err.Error())\n\t}\n\t// If successful, return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"success\"})\n}", "CodeBleu_score": 54.79494482794496}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar msg map[string]string\n\tif err := ctx.Bind(&msg); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, msg); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 51.30289810253631}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\n\tvar msg map[string]string\n\tif err := ctx.Bind(&msg); err != nil {\n\t\treturn common_err.BadRequest(err.Error())\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(name, msg[\"message\"]); err != nil {\n\t\treturn common_err.InternalServerError(err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.OK)\n}", "CodeBleu_score": 44.9565879032118}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service if it is not already running\n\tif !service.IsRunning() {\n\t\tservice.Start()\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Message type:\", ws.", "CodeBleu_score": 47.176862825052865}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tservice.SendMeg <- conn\n\tfor {\n\t\t_, msg, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\treturn nil\n}", "CodeBleu_score": 40.98771858929119}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\t// Upgrade HTTP request to WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service\n\tif !service.IsRunning {\n\t\tservice.SendMeg()\n\t}\n\n\t// Read messages from the WebSocket connection\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"Message Type: %s", "CodeBleu_score": 48.03566856601401}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Declare variables\n\tvar (\n\t\terr        error\n\t\tdriveModel string\n\t\tcpuInfo    []string\n\t\tcpuInfoLen int\n\t\tarch       string\n\t\tjsonData   []byte\n\t)\n\n\t// Get drive model\n\tdriveModel, err = service.MyService.System().GetDriveModel()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Get CPU information\n\tcpuInfo, err = service.MyService.System().GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Get CPU information length\n\tcpuInfoLen = len(cpuInfo)\n\n\t// Get architecture\n\tarch, err = service.MyService.System().GetArchitecture()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Check if CPU information is available\n\tif cpuInfoLen == 0 {\n\t\tjsonData, err = json.Marshal(map[string]string{\n\t\t\t\"drive_model\": driveModel,\n\t\t\t\"arch\":        arch,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t\t}\n\t\treturn ctx.JSON(http.StatusOK, map[string]string{\n\t\t\t\"message\": \"success\",\n\t\t\t\"data\":    string(jsonData),\n\t\t})\n\t}\n\n\t// If CPU information is available, return it with success message\n\tjsonData, err = json.Marshal(map[string]string{\n\t\t\"drive_model\": driveModel,\n\t\t\"arch\":        arch,\n\t\t\"cpu_info\":    strings.Join(cpuInfo, \"", "CodeBleu_score": 35.281421067211596}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\tcpuInfo   *service.CpuInfo\n\t\tcpuErr    error\n\t\tdiskInfo  []service.DiskInfo\n\t\tdiskErr   error\n\t\tramInfo   []service.RamInfo\n\t\tramErr    error\n\t\terr       error\n\t\tcpuCount  int\n\t\tcpuCount2 int\n\t\tcpuCount3 int\n\t\tcpuCount4 int\n\t\tcpuCount5 int\n\t\tcpuCount6 int\n\t\tcpuCount7 int\n\t\tcpuCount8 int\n\t\tcpuCount9 int\n\t\tcpuCount10 int\n\t\tcpuCount11 int\n\t\tcpuCount12 int\n\t\tcpuCount13 int\n\t\tcpuCount14 int\n\t\tcpuCount15 int\n\t\tcpuCount16 int\n\t\tcpuCount17 int\n\t\tcpuCount18 int\n\t\tcpuCount19 int\n\t\tcpuCount20 int\n\t\tcpuCount21 int\n\t\tcpuCount22 int\n\t\tcpuCount23 int\n\t\tcpuCount24 int\n\t\tcpuCount25 int\n\t\tcpuCount26 int\n\t\tcpuCount27 int\n\t\tcpuCount28 int\n\t\tcpuCount29 int\n\t\tcpuCount30 int\n\t\tcpuCount31 int\n\t\tcpuCount32 int\n\t\tcpuCount33 int\n\t\tcpuCount34 int\n\t\tcpuCount35 int\n\t\tcpuCount36 int\n\t\tcpuCount37 int\n\t\tcpuCount38 int\n\t\tcpuCount39 int\n\t\tcpuCount40 int\n\t\tcpuCount41 int\n\t\tcpuCount42 int\n\t\tcpuCount43 int\n\t\tcpuCount44 int\n\t\tcpuCount45 int\n\t\tcpuCount46 int\n\t\tcpuCount47 int\n\t\tcpuCount48 int\n\t\tcpuCount49 int\n\t\tcpuCount50 int\n\t\tcpuCount51 int\n\t\tcpuCount52 int\n\t\tcpuCount53 int\n\t\tcpuCount54 int\n\t\tcpuCount55 int\n\t\tcpuCount56 int\n\t\tcpuCount57", "CodeBleu_score": 2.8937990404524814}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar err error\n\tvar data []byte\n\tvar driveModel string\n\tvar driveArch string\n\tvar cpuInfo string\n\tvar cpuInfoErr error\n\n\t// Get drive model and architecture\n\tdriveModel, driveArch, err = service.MyService.System().GetDriveModelAndArch()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Get CPU information\n\tcpuInfo, cpuInfoErr = service.MyService.System().GetCpuInfo()\n\tif cpuInfoErr != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Create a map to store the data\n\tdataMap := make(map[string]interface{})\n\n\t// Store the drive model and architecture\n\tdataMap[\"drive_model\"] = driveModel\n\tdataMap[\"drive_arch\"] = driveArch\n\n\t// Store the CPU information\n\tdataMap[\"cpu_info\"] = cpuInfo\n\n\t// Convert the map to JSON\n\tdata, err = json.Marshal(dataMap)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, string(data))\n}", "CodeBleu_score": 37.12568376642756}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 74.03958925909471}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar running []string\n\tvar notRunning []string\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 74.89721802382728}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar runningServices, notRunningServices []string\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 68.24038467315204}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tevent := &notify.Event{\n\t\tName:    name,\n\t\tMessage: message,\n\t}\n\n\tresponse, err := i.MessageBus().PublishEventWithResponse(context.Background(), event)\n\tif err != nil {\n\t\ti.Logger().Error(\"failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\ti.Logger().Error(\"failed to publish event\", zap.String(\"response\", response.Status), zap.Any(\"body\", string(response.Body)))\n\t}\n}", "CodeBleu_score": 40.38216897928088}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tevent := &event.Event{\n\t\tName: name,\n\t\tData: message,\n\t}\n\tpayload, err := json.Marshal(event)\n\tif err != nil {\n\t\ti.logger.Error(\"failed to marshal event\", zap.String(\"event\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\tresponse, err := i.MessageBus().PublishEventWithResponse(context.Background(), payload)\n\tif err != nil {\n\t\ti.logger.Error(\"failed to publish event\", zap.String(\"event\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\"failed to publish event\", zap.String(\"event\", name), zap.Any(\"message\", message), zap.String(\"response\", response.Status))\n\t}\n}", "CodeBleu_score": 45.43314615212275}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings.\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\ti.logger.Error(\"failed to serialize message\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\tresponse, err := i.messageBus.PublishEventWithResponse(context.Background(), &eventbus.PublishEventRequest{\n\t\tName:    name,\n\t\tPayload: jsonMessage,\n\t})\n\tif err != nil {\n\t\ti.logger.Error(\"failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// If the response status code is not OK, log the failure.\n\tif response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\"failed to publish event\",\n\t\t\tzap.String(\"name\", name),\n\t\t\tzap.String(\"status\", response.Status),\n\t\t\tzap.String(\"payload\", string(jsonMessage)),\n\t\t)\n\t}\n}", "CodeBleu_score": 42.50064058807896}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tvar (\n\t\tmessageBusAddress string\n\t\terr               error\n\t)\n\n\tmessageBusAddress, err = external.GetMessageBusAddress(c.runtimePath)\n\tif err != nil {\n\t\tmessageBusAddress = \"error: message bus address not found\"\n\t}\n\n\treturn message_bus.NewClientWithResponses(messageBusAddress)\n}", "CodeBleu_score": 39.29903253016446}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Create a new message bus client with responses.\n\tclient := message_bus.NewClientWithResponses(c.ctx)\n\n\t// Attempt to retrieve the message bus address using a specified runtime path.\n\taddress, err := external.GetMessageBusAddress(c.ctx, c.runtime)\n\tif err != nil {\n\t\t// If the address is not found, set the server to a default error message.\n\t\tclient.Server = \"message bus server not found\"\n\t\treturn client\n\t}\n\n\t// Set the client's server to the retrieved address.\n\tclient.Server = address\n\treturn client\n}", "CodeBleu_score": 48.503296127409435}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\tif address, err := c.GetMessageBusAddress(); err == nil {\n\t\tclient.Server = address\n\t} else {\n\t\tclient.Server = \"message bus address not found\"\n\t}\n\treturn client\n}", "CodeBleu_score": 38.84781565058657}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = strings.Split(request.RemoteAddr, \":\")[0]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t} else if ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 59.38151861651038}, {"code": "func GetIP(request *http.Request) string{\n\t\t// Check if the \"x-forwarded-for\" header is set\n\tif forwardedFor := request.Header.Get(\"x-forwarded-for\"); forwardedFor != \"\" {\n\t\t// The header is set, so retrieve the IP address from it\n\t\t// The header value is a comma-separated list of IP addresses\n\t\t// The first IP address in the list is the original client\n\t\t// We only want the last IP address, so we split the list and take the last element\n\t\t// This also means that we can ignore the rest of the list\n\t\tipAddresses := strings.Split(forwardedFor, \",\")\n\t\treturn ipAddresses[len(ipAddresses)-1]\n\t}\n\n\t// The header is not set, so return the remote address\n\t// The remote address is a string containing the IP address and port number\n\t// We only want the IP address, so we split the string and take the first element\n\t// This also means that we can ignore the port number\n\tipAddress := strings.Split(request.RemoteAddr, \":\")[0]\n\n\t// Check if the IP address is a loopback address\n\t// If it is, then we convert it to \"127.0.0.1\"\n\tif ipAddress == \"::1\" || ipAddress == \"::ffff:127.0.0.1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\n\t// Return the IP address\n\treturn ipAddress\n}", "CodeBleu_score": 34.089439740355424}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \":\")[0]\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t} else if ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 63.34929694912357}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesPath := filepath.Join(c.config.Path, \"modules\")\n\tentryFilePath := filepath.Join(c.config.Path, \"entry.json\")\n\tif _, err := os.Stat(modulesPath); os.IsNotExist(err) {\n\t\tlogger.Error(fmt.Sprintf(\"modules path %s does not exist\", modulesPath))\n\t\treturn\n\t}\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tif err = file.IsNotExistCreateFile(entryFilePath); err != nil {\n\t\t\tlogger.Error(fmt.Sprintf(\"error creating entry file %s\", entryFilePath))\n\t\t\treturn\n\t\t}\n\t}\n\tvar modules []*Module\n\tfileInfos, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(fmt.Sprintf(\"error reading modules directory %s\", modulesPath))\n\t\treturn\n\t}\n\tfor _, fileInfo := range fileInfos {\n\t\tif fileInfo.IsDir() {\n\t\t\tentryFilePath := filepath.Join(modulesPath, fileInfo.Name(), \"entry.json\")\n\t\t\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tentryFileBytes, err := os.ReadFile(entryFilePath)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(fmt.Sprintf(\"error reading entry file %s\", entryFilePath))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar entry *Module\n\t\t\tif err = json.Unmarshal(entryFileBytes, &entry); err != nil {\n\t\t\t\tlogger.Error(fmt.Sprintf(\"error unmarshalling entry file %s\", entryFilePath))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmodules = append(modules, entry)\n\t\t}\n\t}\n\tentryFileBytes, err := json.Marshal(modules)\n\tif err != nil {\n\t\tlogger.Error(fmt.Sprintf(\"error marsh", "CodeBleu_score": 46.72855861945255}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// define the path for the modules directory\n\tmodulesPath := filepath.Join(c.rootPath, \"modules\")\n\n\t// define the path for the entry file\n\tentryFilePath := filepath.Join(c.rootPath, \"entry.json\")\n\n\t// ensure the entry file exists\n\tif err := file.IsNotExistCreateFile(entryFilePath); err != nil {\n\t\tc.logger.Error(\"failed to create entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// read each module directory for entry.json files\n\tentries, err := c.readEntries(modulesPath)\n\tif err != nil {\n\t\tc.logger.Error(\"failed to read entries\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// write the entry file\n\tif err := c.writeEntry(entryFilePath, entries); err != nil {\n\t\tc.logger.Error(\"failed to write entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 37.83087048737929}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesPath := filepath.Join(c.config.GetString(\"app.path\"), \"modules\")\n\tentryFilePath := filepath.Join(modulesPath, \"entry.json\")\n\n\t// Ensure modules directory exists\n\tif _, err := os.Stat(modulesPath); os.IsNotExist(err) {\n\t\tc.logger.Error(\"modules directory does not exist\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Ensure entry file exists\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tif err := file.IsNotExistCreateFile(entryFilePath, []byte(\"[]\")); err != nil {\n\t\t\tc.logger.Error(\"entry file does not exist and could not be created\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read entry files from each module directory\n\tvar entryFiles []string\n\tentries := []*model.SystemEntry{}\n\terr := filepath.Walk(modulesPath, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif filepath.Ext(path) == \".json\" && strings.TrimRight(filepath.Base(path), filepath.Ext(path)) == \"entry\" {\n\t\t\tentryFiles = append(entryFiles, path)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tc.logger.Error(\"error reading entry files\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Read and append each entry file to the entries slice\n\tfor _, entryFile := range entryFiles {\n\t\tentry, err := c.readEntryFile(entryFile)\n\t\tif err != nil {\n\t\t\tc.logger.Error(\"error reading entry file\", zap.String(\"path\", entryFile), zap.Error(err))\n\t\t\treturn\n\t\t}\n\t\tentries = append(entries, entry)\n\t}\n\n\t// Write the entries slice to the entry", "CodeBleu_score": 45.655841415152295}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get a list of network interfaces.\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// Get a list of network names.\n\tnames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// Iterate over the interfaces and network names,\n\t// returning the MAC address of the first matching interface.\n\tfor _, i := range interfaces {\n\t\tfor _, n := range names {\n\t\t\tif i.Name == n {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\t// If no matching interface is found, return an error.\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 69.67083625182134}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworks, err := c.GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, network := range networks {\n\t\tfor _, i := range interfaces {\n\t\t\tif i.Name == network {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 66.02382035736149}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get a list of network interfaces.\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// Get a list of network names.\n\tnames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// Iterate over the interfaces and network names,\n\t// returning the MAC address of the first matching interface.\n\tfor _, iface := range ifaces {\n\t\tfor _, name := range names {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\t// If no matching interface is found, return an error.\n\treturn \"\", errors.New(\"No matching interface found\")\n}", "CodeBleu_score": 63.40789803154363}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t rc = 0;\n    if (pRequest == NULL || pTscObj == NULL) {\n        return -1;\n    }\n    pthread_mutex_lock(&pTscObj->mutex);\n    pTscObj->requestCount++;\n    if (pTscObj->pAppInfo != NULL) {\n        pTscObj->pAppInfo->requestCount++;\n        pTscObj->pAppInfo->currentRequestCount++;\n    }\n    pthread_mutex_unlock(&pTscObj->mutex);\n    rc = atomic_add_fetch_32(&pRequest->refCount, 1);\n    if (rc < 0) {\n        return -1;\n    }\n    tscDebug(\"registerRequest: Request %p, TSC %p, refCount %d, requestCount %d, currentRequestCount %d\n\", pRequest, pTscObj, pRequest->refCount, pTscObj->requestCount, pTscObj->pAppInfo->currentRequestCount);\n    return 0;\n}", "CodeBleu_score": 36.452251098757316}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t rc = 0;\n\n    if (pRequest == NULL || pTscObj == NULL) {\n        TSC_DEBUG_PRINT(TSC_MSG_ERROR, \"Invalid request or TSC object\n\");\n        return TSC_ERR_INVALID_PARAM;\n    }\n\n    TSC_DEBUG_PRINT(TSC_MSG_INFO, \"Registering request %p\n\", pRequest);\n\n    // Add a reference to the request\n    TSC_DEBUG_PRINT(TSC_MSG_INFO, \"Adding request reference %p\n\", pRequest);\n    rc = atomic_add_fetch_32(&pRequest->refCount, 1);\n    if (rc < 0) {\n        TSC_DEBUG_PRINT(TSC_MSG_ERROR, \"Invalid request reference count %d\n\", rc);\n        return TSC_ERR_INVALID_PARAM;\n    }\n\n    // Increment the request count for the TSC object\n    TSC_DEBUG_PRINT(TSC_MSG_INFO, \"Incrementing request count for TSC object %p\n\", pTscObj);\n    rc = atomic_add_fetch_32(&pTscObj->requestCount, 1);\n    if (rc < 0) {\n        TSC_DEBUG_PRINT(TSC_MSG_ERROR, \"Invalid request count %d\n\", rc);\n        return TSC_ERR_INVALID_PARAM;\n    }\n\n    // If the TSC object has application information, update the application's request summary\n    if (pTscObj->pAppInfo != NULL) {\n        TSC_DEBUG_PRINT(TSC_MSG_INFO, \"Updating application request summary\n\");\n        pTscObj->pAppInfo->requestCount++;\n        pTscObj->pAppInfo->currentRequestCount++;\n    }\n\n    return TSC_SUCCESS;\n}", "CodeBleu_score": 45.21704657353526}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t status = 0;\n    int32_t i = 0;\n\n    if (pRequest == NULL || pTscObj == NULL) {\n        return -1;\n    }\n\n    if (pTscObj->appInfo.requestCount == 0) {\n        pTscObj->appInfo.requestCount = 1;\n    } else {\n        pTscObj->appInfo.requestCount++;\n    }\n\n    if (pTscObj->appInfo.requestCount == 1) {\n        pTscObj->appInfo.currentRequestCount = 1;\n    } else {\n        pTscObj->appInfo.currentRequestCount++;\n    }\n\n    if (pTscObj->appInfo.totalRequestCount == 0) {\n        pTscObj->appInfo.totalRequestCount = 1;\n    } else {\n        pTscObj->appInfo.totalRequestCount++;\n    }\n\n    if (pTscObj->appInfo.totalRequestCount == 1) {\n        pTscObj->appInfo.currentRequestCount = 1;\n    } else {\n        pTscObj->appInfo.currentRequestCount++;\n    }\n\n    if (pTscObj->appInfo.requestCount > pTscObj->appInfo.maxRequestCount) {\n        pTscObj->appInfo.maxRequestCount = pTscObj->appInfo.requestCount;\n    }\n\n    if (pTscObj->appInfo.currentRequestCount > pTscObj->appInfo.maxCurrentRequestCount) {\n        pTscObj->appInfo.maxCurrentRequestCount = pTscObj->appInfo.currentRequestCount;\n    }\n\n    if (pTscObj->appInfo.totalRequestCount > pTscObj->appInfo.maxTotalRequestCount) {\n        pTscObj->appInfo.maxTotalRequestCount = pTscObj->appInfo.totalRequestCount;\n    }\n\n    if (pTscObj->appInfo.currentRequestCount > pTscObj->appInfo.maxCurrentRequestCount) {\n        pTscObj->appInfo.maxCurrentRequestCount = p", "CodeBleu_score": 22.489606740945362}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (pRequest->pDb == NULL) {\n        return true;\n    }\n    if (strcmp(pRequest->pDb, exceptDb) != 0) {\n        return true;\n    }\n    if (pRequest->pDbList == NULL) {\n        return false;\n    }\n    for (int i = 0; i < pRequest->pDbList->count; i++) {\n        char* db = taosArrayGet(pRequest->pDbList, i);\n        if (db == NULL) {\n            continue;\n        }\n        char* dot = strchr(db, '.');\n        if (dot != NULL) {\n            db = dot + 1;\n        }\n        if (strcmp(db, exceptDb) != 0) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 69.03606739384416}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (strcmp(pRequest->pDb, exceptDb) != 0) {\n        char *pDb = pRequest->pDb;\n        while (pDb != NULL) {\n            char *pNextDb = strchr(pDb, '.');\n            if (pNextDb != NULL) {\n                pNextDb++;\n            }\n            if (strcmp(pDb, exceptDb) == 0) {\n                return false;\n            }\n            pDb = pNextDb;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 52.86676195418419}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (strcmp(pRequest->db, exceptDb) == 0) {\n        return false;\n    }\n\n    char *pDb;\n    for (int i = 0; i < pRequest->dbCount; i++) {\n        pDb = pRequest->dbs[i];\n        if (strchr(pDb, '.') != NULL) {\n            pDb = strchr(pDb, '.') + 1;\n        }\n        if (strcmp(pDb, exceptDb) == 0) {\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 62.39851038606802}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tswitch (msgType) {\n\tcase TMSG_REQ_RPC_LOCAL:\n\tcase TMSG_REQ_RPC_LOCAL_PACKED:\n\tcase TMSG_REQ_RPC_LOCAL_PACKED_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_PACKED_REPLY_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY_REPLY_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY_REPLY_REPLY_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY_REPLY_REPLY_REPLY_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY_REPLY:\n\tcase TMSG_REQ_RPC_LOCAL_REPLY_REPLY_REPLY_REPLY_REPLY_RE", "CodeBleu_score": 21.376371599889506}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == 0) {\n        return false;\n    }\n\n    switch (msgType) {\n    case TMSG_CORE_LOC_INIT_REQ:\n    case TMSG_CORE_LOC_START_REQ:\n    case TMSG_CORE_LOC_STOP_REQ:\n    case TMSG_CORE_LOC_IOCTL_REQ:\n    case TMSG_CORE_LOC_SET_PARAMETER_REQ:\n    case TMSG_CORE_LOC_GET_PARAMETER_REQ:\n    case TMSG_CORE_LOC_DELETE_ASSIST_DATA_REQ:\n    case TMSG_CORE_LOC_INFORM_NI_USER_REQ:\n    case TMSG_CORE_LOC_SET_CAPABILITIES_REQ:\n    case TMSG_CORE_LOC_GET_CAPABILITIES_REQ:\n    case TMSG_CORE_LOC_SET_SERVER_REQ:\n    case TMSG_CORE_LOC_ASSIST_DATA_REQ:\n    case TMSG_CORE_LOC_SET_ENGINE_LOCK_REQ:\n    case TMSG_CORE_LOC_SET_SPI_VERSION_REQ:\n    case TMSG_CORE_LOC_SET_EXT_POWER_CONFIG_REQ:\n    case TMSG_CORE_LOC_SET_AGC_TUNING_PARAM_REQ:\n    case TMSG_CORE_LOC_SET_GNSS_CONSTELLATION_CONFIG_REQ:\n    case TMSG_CORE_LOC_GET_GNSS_CONSTELLATION_CONFIG_REQ:\n    case TMSG_CORE_LOC_SET_SENSOR_PROPERTIES_REQ:\n    case TMSG_CORE_LOC_SET_SENSOR_PERF_CONTROL_CONFIG_REQ:\n    case TMSG_CORE_LOC_GET_SENSOR_PROPERTIES_REQ:\n    case", "CodeBleu_score": 28.072802570052506}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    bool redirect = false;\n    if (code == NEED_REDIRECT_ERROR) {\n        redirect = true;\n    }\n    else {\n        if (msgType == MSG_DATA_OBJ_OPEN_AND_READ ||\n            msgType == MSG_DATA_OBJ_OPEN_AND_READ_AN ||\n            msgType == MSG_DATA_OBJ_READ ||\n            msgType == MSG_DATA_OBJ_READ_AN ||\n            msgType == MSG_DATA_OBJ_WRITE ||\n            msgType == MSG_DATA_OBJ_WRITE_AN ||\n            msgType == MSG_DATA_OBJ_UNLINK ||\n            msgType == MSG_DATA_OBJ_UNLINK_AN ||\n            msgType == MSG_DATA_OBJ_CREATE ||\n            msgType == MSG_DATA_OBJ_CREATE_AND_WRITE ||\n            msgType == MSG_DATA_OBJ_CREATE_AND_WRITE_AN ||\n            msgType == MSG_DATA_OBJ_OPEN_AND_WRITE ||\n            msgType == MSG_DATA_OBJ_OPEN_AND_WRITE_AN ||\n            msgType == MSG_DATA_OBJ_OPEN ||\n            msgType == MSG_DATA_OBJ_OPEN_AN ||\n            msgType == MSG_DATA_OBJ_PUT ||\n            msgType == MSG_DATA_OBJ_PUT_AN ||\n            msgType == MSG_DATA_OBJ_GET ||\n            msgType == MSG_DATA_OBJ_GET_AN ||\n            msgType == MSG_DATA_OBJ_COPY ||\n            msgType == MSG_DATA_OBJ_COPY_AN ||\n            msgType == MSG_DATA_OBJ_COPY_BULK ||\n            msgType == MSG_DATA_OBJ_COPY_BULK_AN ||\n            msgType == MSG_DATA_OBJ_LSEEK ||\n            msgType == MSG_DATA_OBJ_LSEEK_AN ||\n            msgType == MSG_DATA_OBJ_FSTAT ||\n            msgType == MSG_DATA_", "CodeBleu_score": 43.56669377654803}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t    SHashObj *pRequest;\n    SHashIter *pIter;\n\n    if (pRequests == NULL) return;\n\n    pIter = s_createHashIter(pRequests);\n    if (pIter == NULL) return;\n\n    while (s_hashIterNext(pIter, (void **)&pRequest) == 0) {\n        acquireRequest(pRequest);\n        if (pRequest->valid) {\n            taos_stop_query(pRequest->query);\n        }\n        releaseRequest(pRequest);\n    }\n\n    s_destroyHashIter(pIter);\n}", "CodeBleu_score": 42.929460471455286}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t    SHashIter *pIter = NULL;\n    SHashObj *pObj = NULL;\n    TAOS_REQ *pReq = NULL;\n\n    pIter = sHashIterCreate(pRequests);\n    if (pIter == NULL) {\n        return;\n    }\n\n    while (sHashIterHasNext(pIter)) {\n        pObj = sHashIterNextObj(pIter);\n        if (pObj == NULL) {\n            continue;\n        }\n\n        pReq = (TAOS_REQ *) pObj->data;\n        if (pReq == NULL) {\n            continue;\n        }\n\n        if (acquireRequest(pReq) == 0) {\n            if (pReq->query != NULL) {\n                taos_stop_query(pReq->query);\n            }\n            releaseRequest(pReq);\n        }\n    }\n\n    sHashIterDestroy(pIter);\n}", "CodeBleu_score": 41.54763669857975}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t    SHashObj *pRequest;\n    int i;\n    int nRequests = pRequests->nEntries;\n\n    for (i = 0; i < nRequests; i++) {\n        pRequest = pRequests->pHashArray[i];\n        while (pRequest != NULL) {\n            acquireRequest(pRequest);\n            if (pRequest->pQuery != NULL) {\n                taos_stop_query(pRequest->pQuery);\n            }\n            releaseRequest(pRequest);\n            pRequest = pRequest->pNext;\n        }\n    }\n}", "CodeBleu_score": 41.99510468019181}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t    if (!tscCrashReportingEnabled()) {\n        return;\n    }\n    int32_t oldVal = 1;\n    int32_t newVal = 0;\n    if (!atomic_val_compare_exchange_32(&tscCrashReportingClientStopFlag, &oldVal, newVal)) {\n        tscPrintf(\"tscStopCrashReport: Crash report thread already stopped.\n\");\n        return;\n    }\n    while (atomic_load_32(&tscCrashReportingClientStopFlag)) {\n        tscMsleep(100);\n    }\n}", "CodeBleu_score": 55.25663567741675}, {"code": "void tscStopCrashReport(){\n\t    if (!tscCrashReportingEnabled) {\n        return;\n    }\n\n    int32_t oldValue = 1;\n    int32_t newValue = 0;\n    if (!atomic_val_compare_exchange_32(&tscCrashReportingClientStop, &oldValue, newValue)) {\n        tscDebug(\"tscStopCrashReport: Crash report thread already stopped.\n\");\n        return;\n    }\n\n    tscDebug(\"tscStopCrashReport: Waiting for crash report thread to stop.\n\");\n    while (atomic_load_32(&tscCrashReportingClientStop)) {\n        tscMsleep(1000);\n    }\n    tscDebug(\"tscStopCrashReport: Crash report thread stopped.\n\");\n}", "CodeBleu_score": 54.170923661422755}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\n\tif (!atomic_val_compare_exchange_32(&tscCrashReportClientStop, 0, 1)) {\n\t\tlogMessage(LOG_LEVEL_DEBUG, \"Crash report thread already stopped\");\n\t\treturn;\n\t}\n\n\twhile (atomic_load_32(&tscCrashReportClientStop)) {\n\t\ttscMsleep(10);\n\t}\n}", "CodeBleu_score": 66.38931428130587}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t i;\n\tint32_t j;\n\tint32_t numViews;\n\tint32_t numCols;\n\tint32_t numRows;\n\tint32_t numColsInView;\n\tint32_t numRowsInView;\n\tint32_t numRowsInViewMeta;\n\tint32_t numColsInViewMeta;\n\tint32_t numColsInRow;\n\tint32_t numRowsInRow;\n\tint32_t numColsInCol;\n\tint32_t numRowsInCol;\n\tint32_t numRowsInColMeta;\n\tint32_t numColsInColMeta;\n\tint32_t numRowsInColMeta;\n\tint32_t numColsInColDef;\n\tint32_t numRowsInColDef;\n\tint32_t numRowsInColDefMeta;\n\tint32_t numColsInColDefMeta;\n\tint32_t numRowsInColDefMeta;\n\tint32_t numColsInColDefDef;\n\tint32_t numRowsInColDefDef;\n\tint32_t numRowsInColDefDefMeta;\n\tint32_t numColsInColDefDefMeta;\n\tint32_t numRowsInColDefDefMeta;\n\tint32_t numColsInColDefDefDef;\n\tint32_t numRowsInColDefDefDef;\n\tint32_t numRowsInColDefDefDefMeta;\n\tint32_t numColsInColDefDefDefMeta;\n\tint32_t numRowsInColDefDefDefMeta;\n\tint32_t numColsInColDefDefDefDef;\n\tint32_t numRowsInColDefDefDefDef;\n\tint32_t numRowsInColDefDefDefDefMeta;\n\tint32_t numColsInColDefDefDefDefMeta;\n\tint32_t numRowsInColDefDefDefDefMeta;\n\tint32_t numColsInCol", "CodeBleu_score": 6.971450404214225}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t ret;\n  int32_t i;\n  int32_t nViews;\n  int32_t nCols;\n  int32_t nColsExpected;\n  int32_t nColsRemoved;\n  int32_t nColsUpdated;\n  int32_t nColsAdded;\n  int32_t nColsUpdatedExpected;\n  int32_t nColsAddedExpected;\n  int32_t nColsRemovedExpected;\n  int32_t nColsUpdatedActual;\n  int32_t nColsAddedActual;\n  int32_t nColsRemovedActual;\n  int32_t nColsUpdatedActualExpected;\n  int32_t nColsAddedActualExpected;\n  int32_t nColsRemovedActualExpected;\n  int32_t nColsUpdatedActualRemoved;\n  int32_t nColsAddedActualRemoved;\n  int32_t nColsRemovedActualRemoved;\n  int32_t nColsUpdatedActualRemovedExpected;\n  int32_t nColsAddedActualRemovedExpected;\n  int32_t nColsRemovedActualRemovedExpected;\n  int32_t nColsUpdatedActualRemovedActual;\n  int32_t nColsAddedActualRemovedActual;\n  int32_t nColsRemovedActualRemovedActual;\n  int32_t nColsUpdatedActualRemovedActualExpected;\n  int32_t nColsAddedActualRemovedActualExpected;\n  int32_t nColsRemovedActualRemovedActualExpected;\n  int32_t nColsUpdatedActualRemovedActualRemoved;\n  int32_t nColsAddedActualRemovedActualRemoved;\n  int32_t nColsRemovedActualRemovedActualRemoved", "CodeBleu_score": 7.437488180871219}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t ret;\n    int32_t i;\n    int32_t j;\n    int32_t numViews;\n    int32_t numColumns;\n    char *viewName;\n    char *columnName;\n    char *viewNameTmp;\n    char *columnNameTmp;\n    int32_t viewNameLen;\n    int32_t columnNameLen;\n    int32_t viewNameLenTmp;\n    int32_t columnNameLenTmp;\n    int32_t viewNameOffset;\n    int32_t columnNameOffset;\n    int32_t viewNameOffsetTmp;\n    int32_t columnNameOffsetTmp;\n    int32_t viewNameOffsetNext;\n    int32_t columnNameOffsetNext;\n    int32_t viewNameLenNext;\n    int32_t columnNameLenNext;\n    int32_t viewNameLenTmpNext;\n    int32_t columnNameLenTmpNext;\n    int32_t viewNameLenTmpNext2;\n    int32_t columnNameLenTmpNext2;\n    int32_t viewNameLenTmpNext3;\n    int32_t columnNameLenTmpNext3;\n    int32_t viewNameLenTmpNext4;\n    int32_t columnNameLenTmpNext4;\n    int32_t viewNameLenTmpNext5;\n    int32_t columnNameLenTmpNext5;\n    int32_t viewNameLenTmpNext6;\n    int32_t columnNameLenTmpNext6;\n    int32_t viewNameLenTmpNext7;\n    int32_t columnNameLenTmpNext7;\n    int32_t viewNameLenTmpNext8;\n    int32_t columnNameLenTmpNext8;\n    int32_t viewNameLenTmpNext9;\n    int32_t columnNameLenTmpNext9;\n    int32_t viewNameLenTmpNext10;\n    int32_", "CodeBleu_score": 8.799887647557348}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    S3_get_object_callback_data *data = (S3_get_object_callback_data *) callbackData;\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 72.20107940641509}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status;\n    S3ResponsePropertiesCallbackData *data = (S3ResponsePropertiesCallbackData *) callbackData;\n    int64_t contentLength;\n\n    status = propertiesStatus(properties);\n    if (status != S3StatusOK) {\n        return status;\n    }\n\n    contentLength = properties->contentLength;\n    if (contentLength > 0) {\n        data->contentLength = contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 58.6247383501013}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tif (properties->contentLength > 0) {\n\t\t((S3GetObjectData *) callbackData)->contentLength = properties->contentLength;\n\t} else {\n\t\t((S3GetObjectData *) callbackData)->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 68.28794497475343}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tint i;\n\tint j;\n\tint k;\n\tint l;\n\tint m;\n\tint n;\n\tint o;\n\tint p;\n\tint q;\n\tint r;\n\tint s;\n\tint t;\n\tint u;\n\tint v;\n\tint w;\n\tint x;\n\tint y;\n\tint z;\n\tint A;\n\tint B;\n\tint C;\n\tint D;\n\tint E;\n\tint F;\n\tint G;\n\tint H;\n\tint I;\n\tint J;\n\tint K;\n\tint L;\n\tint M;\n\tint N;\n\tint O;\n\tint P;\n\tint Q;\n\tint R;\n\tint S;\n\tint T;\n\tint U;\n\tint V;\n\tint W;\n\tint X;\n\tint Y;\n\tint Z;\n\tint aa;\n\tint bb;\n\tint cc;\n\tint dd;\n\tint ee;\n\tint ff;\n\tint gg;\n\tint hh;\n\tint ii;\n\tint jj;\n\tint kk;\n\tint ll;\n\tint mm;\n\tint nn;\n\tint oo;\n\tint pp;\n\tint qq;\n\tint rr;\n\tint ss;\n\tint tt;\n\tint uu;\n\tint vv;\n\tint ww;\n\tint xx;\n\tint yy;\n\tint zz;\n\tint aa1;\n\tint bb1;\n\tint cc1;\n\tint dd1;\n\tint ee1;\n\tint ff1;\n\tint gg1;\n\tint hh1;\n\tint ii1;\n\tint jj1;\n\tint kk1;\n\tint ll1;\n\tint mm1;\n\tint nn1;\n\tint oo1;\n\tint pp1;\n\tint qq1;\n\tint rr1;\n\tint ss1;\n\tint tt1;\n\tint uu1;\n\tint vv1;\n\tint ww1", "CodeBleu_score": 1.6643074609400763}, {"code": "void startRsync(){\n\t\tchar *configFile = \"rsyncd.conf\";\n\tchar *command = \"rsync --daemon --config=rsyncd.conf\";\n\tchar *checkpointBackupDir = \"checkpoint\";\n\tchar *rsyncLogFile = \"rsync.log\";\n\tchar *rsyncPidFile = \"rsync.pid\";\n\tchar *rsyncPort = \"873\";\n\tchar *rsyncLogLevel = \"info\";\n\tchar *rsyncLogFormat = \"%t %a %m %f %b\";\n\tchar *rsyncExclude = \"lost+found\";\n\tchar *rsyncStrictModes = \"no\";\n\tchar *rsyncTransferLog = \"yes\";\n\tchar *rsyncList = \"no\";\n\tchar *rsyncUmask = \"0022\";\n\tchar *rsyncAuthUsers = \"root\";\n\tchar *rsyncSeedFile = \"/dev/urandom\";\n\tchar *rsyncExcludeFrom = \"exclude.txt\";\n\tchar *rsyncAddress = \"0.0.0.0\";\n\tchar *rsyncMaxConnections = \"4096\";\n\tchar *rsyncTimeout = \"300\";\n\tchar *rsyncIgnoreNonreadable = \"no\";\n\tchar *rsyncStrictChown = \"no\";\n\tchar *rsyncChown = \"root:root\";\n\tchar *rsyncChmod = \"0644\";\n\tchar *rsyncCompress = \"no\";\n\tchar *rsyncCompressLevel = \"0\";\n\tchar *rsyncLinkDest = \"no\";\n\tchar *rsyncSecureOptions = \"no\";\n\tchar *rsyncXattrs = \"no\";\n\tchar *rsyncDevices = \"no\";\n\tchar *rsyncSpecials = \"no\";\n\tchar *rsyncOneFileSystem = \"no\";\n\tchar *rsyncIpv4 = \"yes\";\n\tchar *rsyncIpv6 = \"yes\";\n\tchar *rsyncStats = \"no\";\n\tchar *rsyncStatsFile = \"stats.log\";\n\tchar *rsyncTransfer = \"no\";\n\tchar *rsyncTransfer", "CodeBleu_score": 6.644300801305874}, {"code": "void startRsync(){\n\t    char *checkpointBackupDir = getCheckpointBackupDir();\n    if (checkpointBackupDir == NULL) {\n        uError(\"Failed to create checkpoint backup directory\");\n        return;\n    }\n    if (removeEmptyDir(checkpointBackupDir) == -1) {\n        uError(\"Failed to remove empty directories\");\n        return;\n    }\n    if (generateConfigFile() == -1) {\n        uError(\"Failed to generate Rsync configuration file\");\n        return;\n    }\n    char *command = \"rsync --daemon --config=/etc/rsyncd.conf\";\n    uDebug(\"Starting Rsync server\");\n    if (system(command) == -1) {\n        uError(\"Failed to start Rsync server\");\n        return;\n    }\n    uDebug(\"Rsync server started successfully\");\n}", "CodeBleu_score": 27.272102094321728}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher d = dispatchers.remove(dispatcherId);\n    if (d != null) {\n        d.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not registered\");\n    }\n}", "CodeBleu_score": 71.25379145616716}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n    }\n}", "CodeBleu_score": 72.60786854679192}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher d = dispatchers.remove(dispatcherId);\n    if (d == null) {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n    }\n    d.shutdownNow();\n}", "CodeBleu_score": 59.70416608369603}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    TbActorRef parentRef = getOrCreateChildActor(parent);\n    if (parentRef != null) {\n      parentRef.getChildren().entrySet().stream()\n          .filter(entry -> childFilter.test(entry.getKey()))\n          .forEach(entry -> {\n            TbActorRef childRef = entry.getValue();\n            if (childRef != null) {\n              if (highPriority) {\n                childRef.tell(msg, ActorRef.noSender());\n              } else {\n                childRef.tell(msg);\n              }\n            } else {\n              log.warn(\"[{}] Child actor [{}] is not registered!\", parent, entry.getKey());\n            }\n          });\n    } else {\n      log.warn(\"[{}] Parent actor is not registered!\", parent);\n    }\n  }", "CodeBleu_score": 42.97330759413388}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        TbActorRef parentRef = getOrCreateChildActor(parent);\n        if (parentRef != null) {\n            Map<TbActorId, TbActorRef> children = parentRef.getChildren();\n            if (children != null) {\n                for (TbActorId childId : children.keySet()) {\n                    if (childFilter.test(childId)) {\n                        TbActorRef childRef = children.get(childId);\n                        if (childRef != null) {\n                            if (highPriority) {\n                                childRef.tell(msg, ActorRef.noSender());\n                            } else {\n                                childRef.tell(msg);\n                            }\n                        } else {\n                            log.warn(\"[{}] Child actor is not registered!\", childId);\n                        }\n                    }\n                }\n            }\n        } else {\n            log.warn(\"[{}] Parent actor is not registered!\", parent);\n        }\n    }", "CodeBleu_score": 43.13834531214595}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    List<TbActorId> children = actorCtx.getChildren(parent);\n    if (children != null) {\n      for (TbActorId childId : children) {\n        if (childFilter.test(childId)) {\n          try {\n            if (highPriority) {\n              tellWithHighPriority(childId, msg);\n            } else {\n              tell(childId, msg);\n            }\n          } catch (Exception e) {\n            log.warn(\"[{}] Failed to send message to child actor: {}\", parent, childId, e);\n          }\n        }\n      }\n    }\n  }", "CodeBleu_score": 50.95343794270257}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (destructionInProgress) {\n        if (msg instanceof RuleNodeUpdatedMsg) {\n            RuleNodeUpdatedMsg ruleNodeUpdatedMsg = (RuleNodeUpdatedMsg) msg;\n            if (ruleNodeUpdatedMsg.getUpdatedRuleNode().getRuleChainId().equals(getSelf().getId())) {\n                if (ruleNodeUpdatedMsg.getUpdatedRuleNode().getType() == RuleNodeType.INPUT) {\n                    if (getActorState() == ActorState.INITIALIZED) {\n                        log.debug(\"[{}] Reinitializing actor after rule node update.\", getSelf().getId());\n                        initActor();\n                    } else {\n                        log.debug(\"[{}] Ignoring rule node update since actor is not in INITIALIZED state.\", getSelf().getId());\n                    }\n                } else {\n                    log.debug(\"[{}] Ignoring rule node update since it is not an input node.\", getSelf().getId());\n                }\n            } else {\n                log.debug(\"[{}] Ignoring rule node update since it is not for this actor.\", getSelf().getId());\n            }\n        } else {\n            msg.getCallback().onFailure(new ActorTerminatedException(\"Actor is being destroyed!\"));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue();\n    }\n}", "CodeBleu_score": 49.87490516268635}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (msg.getMsgType().equals(TbActorMsgType.RULE_NODE_UPDATED_MSG) && !isAlive()) {\n        if (highPriority) {\n            TbActorMsgType msgType = ((RuleNodeUpdatedMsg) msg).getMsgType();\n            if (msgType == TbActorMsgType.RULE_CHAIN_UPDATED_MSG || msgType == TbActorMsgType.RULE_CHAIN_DELETED_MSG) {\n                initActor();\n            }\n        }\n        msg.getCallback().onFailure(new TbActorDestroyedException(\"Actor is destroyed!\"));\n        return;\n    }\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    tryProcessQueue();\n}", "CodeBleu_score": 56.72321098860006}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (isDestroyInProgress()) {\n        if (msg.getType() == TbActorMsgType.RULE_NODE_UPDATED_MSG) {\n            if (!isActorInitialized()) {\n                try {\n                    initActor();\n                } catch (Exception e) {\n                    log.warn(\"[{}] Failed to reinitialize actor after stop\", getActorId(), e);\n                }\n            }\n        } else {\n            msg.getCallback().onFailure(new TbActorDestroyedException(\"Actor was stopped!\"));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue();\n    }\n}", "CodeBleu_score": 57.03956323254861}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    try {\n        while (true) {\n            if (isStop()) {\n                return;\n            }\n            if (getCause() != null) {\n                destroy();\n                return;\n            }\n            if (getActorThroughput() > 0) {\n                if (poll()) {\n                    tryProcessQueue();\n                }\n            }\n            set(ActorStatus.FREE);\n            tryProcessQueue();\n        }\n    } catch (Exception ex) {\n        onProcessFailure(ex);\n    }\n}", "CodeBleu_score": 12.268762642542132}, {"code": "private void processMailbox(){\n\t  // If the actor has been stopped, do nothing\n  if (isStop()) {\n    return;\n  }\n\n  // If the mailbox is empty, set the actor's status to free and schedule a queue processing attempt\n  if (getCause() == null && getExecutor().getMailbox().isEmpty()) {\n    setStatus(Status.FREE);\n    getExecutor().getScheduler().scheduleQueueProcessing();\n    return;\n  }\n\n  // If the actor has a cause, set the actor's status to free and schedule a queue processing attempt\n  if (getCause() != null) {\n    setStatus(Status.FREE);\n    getExecutor().getScheduler().scheduleQueueProcessing();\n    return;\n  }\n\n  // Process messages from high priority queue\n  while (getExecutor().getMailbox().getHighPriorityQueue().peek() != null) {\n    try {\n      getExecutor().getMailbox().getHighPriorityQueue().poll().execute(this);\n    } catch (InitializationFailureException e) {\n      setCause(e);\n      destroy();\n      return;\n    } catch (Exception e) {\n      getExecutor().getScheduler().logFailure(e);\n      onProcessFailure(e);\n      if (isStop()) {\n        destroy();\n        return;\n      }\n    }\n  }\n\n  // Process messages from normal priority queue\n  while (getExecutor().getMailbox().getNormalPriorityQueue().peek() != null) {\n    try {\n      getExecutor().getMailbox().getNormalPriorityQueue().poll().execute(this);\n    } catch (InitializationFailureException e) {\n      setCause(e);\n      destroy();\n      return;\n    } catch (Exception e) {\n      getExecutor().getScheduler().logFailure(e);\n      onProcessFailure(e);\n      if (isStop()) {\n        destroy();\n        return;\n      }\n    }\n  }\n\n  // If the actor has a cause, set the actor's status to free and schedule a queue processing attempt\n  if (getCause() != null) {\n    setStatus(Status.FREE);\n    getExecutor", "CodeBleu_score": 26.19898295298977}, {"code": "private void processMailbox(){\n\t    try {\n        while (true) {\n            if (isStop()) {\n                return;\n            }\n            if (getExecutor().getThroughput() == 0) {\n                // No throughput, so wait for a while\n                getExecutor().waitForThroughput();\n            }\n            if (getExecutor().getThroughput() > 0) {\n                // Throughput available, so process messages\n                getExecutor().decrementThroughput();\n                if (getExecutor().getThroughput() == 0) {\n                    // No throughput left, so wait for a while\n                    getExecutor().waitForThroughput();\n                }\n                if (getExecutor().getThroughput() > 0) {\n                    // Throughput available, so process messages\n                    getExecutor().decrementThroughput();\n                    if (getExecutor().getThroughput() == 0) {\n                        // No throughput left, so wait for a while\n                        getExecutor().waitForThroughput();\n                    }\n                    if (getExecutor().getThroughput() > 0) {\n                        // Throughput available, so process messages\n                        getExecutor().decrementThroughput();\n                        if (getExecutor().getThroughput() == 0) {\n                            // No throughput left, so wait for a while\n                            getExecutor().waitForThroughput();\n                        }\n                        if (getExecutor().getThroughput() > 0) {\n                            // Throughput available, so process messages\n                            getExecutor().decrementThroughput();\n                            if (getExecutor().getThroughput() == 0) {\n                                // No throughput left, so wait for a while\n                                getExecutor().waitForThroughput();\n                            }\n                            if (getExecutor().getThroughput() > 0) {\n                                // Throughput available, so process messages\n                                getExecutor().decrementThroughput();\n                                if (getExecutor().getThroughput() == 0) {\n                                    // No throughput left, so wait for a", "CodeBleu_score": 14.06679806072508}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = new StopReason(StopReason.STOP_REASON_DESTROYED, cause);\n    }\n    if (isDestroyInProgress.compareAndSet(false, true)) {\n        getExecutor().execute(new Runnable() {\n            public void run() {\n                try {\n                    set(false);\n                    actor.destroy(stopReason, cause);\n                    forEach(new Message.Visitor() {\n                        public void visit(Message message) {\n                            message.stopped(stopReason);\n                        }\n                    });\n                } catch (Throwable t) {\n                    warn(t, \"Exception while destroying actor\");\n                }\n            }\n        });\n    }\n}", "CodeBleu_score": 44.759961578720464}, {"code": "public void destroy(Throwable cause){\n\t    if (cause == null) {\n        throw new IllegalArgumentException(\"cause must not be null\");\n    }\n    if (stopReason == null) {\n        stopReason = new StopReason(cause);\n    }\n    if (destroyInProgress) {\n        return;\n    }\n    destroyInProgress = true;\n    try {\n        if (executor != null) {\n            executor.execute(new Runnable() {\n                public void run() {\n                    setReady(false);\n                    try {\n                        actor.destroy(stopReason, cause);\n                    } catch (Throwable e) {\n                        warn(\"Exception during actor.destroy\", e);\n                    }\n                    for (Message m : queuedMessages) {\n                        m.stopped(stopReason);\n                    }\n                    queuedMessages.clear();\n                }\n            });\n        }\n    } catch (Throwable e) {\n        warn(\"Exception during executor.execute\", e);\n    }\n}", "CodeBleu_score": 38.35083464392852}, {"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = new StopReason(StopReason.STOPPED_BY_USER, cause);\n\t}\n\tif (destructionInProgress) {\n\t\treturn;\n\t}\n\tdestructionInProgress = true;\n\ttry {\n\t\tgetExecutor().execute(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tsetReady(false);\n\t\t\t\t\tdestroy(stopReason);\n\t\t\t\t\tfor (Message msg : queuedMessages) {\n\t\t\t\t\t\tmsg.notifyStopped(stopReason);\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\twarn(\"Exception during actor destruction\", t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} catch (Throwable t) {\n\t\twarn(\"Exception during actor destruction\", t);\n\t}\n}", "CodeBleu_score": 38.590307886574465}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    RateLimitType rateLimitType = getRateLimitType(api);\n    RateLimitConfig rateLimitConfig = profile.getRateLimit(rateLimitType);\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    if (rateLimitConfig.isEnabled()) {\n        boolean isAllowed = rateLimitConfig.getLimit().tryAcquire();\n        if (!isAllowed) {\n            processRateLimitNotification(tenantId, rateLimitType, rateLimitConfig);\n        }\n        return isAllowed;\n    } else {\n        return true;\n    }\n}", "CodeBleu_score": 47.190821509617386}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    RateLimitType type = getRateLimitType(api);\n    RateLimitConfig config = profile.getRateLimits().get(type);\n    if (config == null) {\n        return true;\n    }\n    boolean result = config.getRateLimit().tryAcquire();\n    if (!result) {\n        sendRateLimitNotification(api, tenantId, config);\n    }\n    return result;\n}", "CodeBleu_score": 41.54714526485622}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    RateLimitType rateLimitType = api.getLimitLevelEntityName().equals(TenantId.class.getSimpleName()) ? RateLimitType.TENANT : RateLimitType.TENANT_API;\n    RateLimit rateLimit = profile.getRateLimits().get(rateLimitType);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitKey key = api.getLimitLevelEntityName().equals(TenantId.class.getSimpleName()) ? new RateLimitKey(tenantId, null) : new RateLimitKey(tenantId, api.getApiCall());\n    return checkRateLimit(key, rateLimit, level);\n}", "CodeBleu_score": 43.66230381383252}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            trace(\"Removing expired session: \" + entry.getKey());\n            dtlsSessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 50.712152023212596}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n        String sessionId = entry.getKey();\n        DtlsSession session = entry.getValue();\n        long lastActivityTime = session.getLastActivityTime();\n        if (lastActivityTime < expirationTime) {\n            trace(\"Removing DTLS session %s due to inactivity\", sessionId);\n            remove(sessionId);\n        }\n    }\n}", "CodeBleu_score": 44.187927879731824}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - inactivityTimeout;\n\tIterator<Map.Entry<String, DtlsSession>> iter = dtlsSessions.entrySet().iterator();\n\twhile (iter.hasNext()) {\n\t\tMap.Entry<String, DtlsSession> entry = iter.next();\n\t\tlong lastActivityTime = entry.getValue().getLastActivityTime();\n\t\tif (lastActivityTime < expirationTime) {\n\t\t\titer.remove();\n\t\t\tString key = entry.getKey();\n\t\t\tDtlsSession session = entry.getValue();\n\t\t\ttrace(\"Evicting DTLS session for \" + key + \" due to inactivity.\");\n\t\t\tsession.close();\n\t\t}\n\t}\n}", "CodeBleu_score": 34.315232696192425}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> result = new ArrayList<>(timeseries.size());\n    timeseries.forEach((key, values) -> {\n        values.forEach(value -> {\n            result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.asText())));\n        });\n    });\n    return result;\n}", "CodeBleu_score": 41.75157478707414}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    } else {\n        List<TsKvEntry> result = new ArrayList<>();\n        timeseries.forEach((key, value) -> {\n            if (value.size() == 1) {\n                result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.get(0).asText())));\n            } else {\n                result.add(new BasicTsKvEntry(System.currentTimeMillis(), new LongDataEntry(key, value.get(0).asLong())));\n            }\n        });\n        return result;\n    }\n}", "CodeBleu_score": 45.126249311057514}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries != null && !timeseries.isEmpty()) {\n        return timeseries.entrySet().stream().map(entry -> {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            if (values != null && !values.isEmpty()) {\n                return values.stream().map(value -> {\n                    try {\n                        return new BasicTsKvEntry(System.currentTimeMillis(), new LongDataEntry(key, parseValue(value)));\n                    } catch (Exception e) {\n                        throw new RuntimeException(\"Failed to parse value: \" + value, e);\n                    }\n                }).collect(Collectors.toList());\n            } else {\n                return Collections.emptyList();\n            }\n        }).flatMap(List::stream).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 42.02066063885352}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t  Map<String, Object> requestMap = new HashMap<>();\n  requestMap.put(\"refresh_token\", getTokenInfo().getRefreshToken());\n  requestMap.put(\"grant_type\", \"refresh_token\");\n  requestMap.put(\"client_id\", getClientId());\n  requestMap.put(\"client_secret\", getClientSecret());\n  requestMap.put(\"scope\", getScope());\n\n  HttpHeaders headers = new HttpHeaders();\n  headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n\n  HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(\n    new LinkedMultiValueMap<>(requestMap),\n    headers\n  );\n\n  ResponseEntity<Map<String, Object>> response = getRestTemplate().postForEntity(\n    getAuthenticationEndpoint(),\n    request,\n    new ParameterizedTypeReference<Map<String, Object>>() {}\n  );\n\n  setTokenInfo(\n    new TokenInfo(\n      response.getBody().get(\"access_token\").toString(),\n      response.getBody().get(\"refresh_token\").toString(),\n      response.getBody().get(\"expires_in\").toString(),\n      getCurrentTimeMillis()\n    )\n  );\n}", "CodeBleu_score": 40.132989160961934}, {"code": "public void refreshToken(){\n\t    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refresh_token\", tokenInfo.getRefreshToken());\n    requestMap.put(\"grant_type\", \"refresh_token\");\n    requestMap.put(\"client_id\", clientId);\n    requestMap.put(\"client_secret\", clientSecret);\n\n    HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n\n    HttpEntity<Map<String, String>> request = new HttpEntity<>(requestMap, headers);\n\n    ResponseEntity<String> response = restTemplate.postForEntity(authEndpoint, request, String.class);\n\n    if (response.getStatusCode() == HttpStatus.OK) {\n        tokenInfo.setAccessToken(response.getBody());\n        tokenInfo.setTimestamp(currentTimeMillis());\n    }\n}", "CodeBleu_score": 46.144540631279455}, {"code": "public void refreshToken(){\n\t    String refreshToken = this.getTokenInfo().getRefreshToken();\n    String endpoint = this.getTokenInfo().getEndpoint();\n    Map<String, Object> requestMap = new HashMap<>();\n    requestMap.put(\"refresh_token\", refreshToken);\n    requestMap.put(\"grant_type\", \"refresh_token\");\n    requestMap.put(\"client_id\", this.getClientId());\n    requestMap.put(\"client_secret\", this.getClientSecret());\n    HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n    HttpEntity<Map<String, Object>> request = new HttpEntity<>(requestMap, headers);\n    ResponseEntity<Map<String, Object>> response = this.getRestTemplate().postForEntity(endpoint, request, Map.class);\n    Map<String, Object> responseBody = response.getBody();\n    if (responseBody != null) {\n        this.getTokenInfo().setAccessToken((String) responseBody.get(\"access_token\"));\n        this.getTokenInfo().setExpiresIn((Long) responseBody.get(\"expires_in\"));\n        this.getTokenInfo().setRefreshToken((String) responseBody.get(\"refresh_token\"));\n        this.getTokenInfo().setTimestamp(System.currentTimeMillis());\n    }\n}", "CodeBleu_score": 39.40772752042736}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t        long currentTime = System.currentTimeMillis();\n        Map<String, Object> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<Map<String, Object>> response = restTemplate.postForEntity(authUrl, loginRequest, Map.class);\n        setTokenInfo(response.getBody(), currentTime);\n    }", "CodeBleu_score": 66.85174166551077}, {"code": " private void doLogin(){\n\t    long currentTimeMillis = System.currentTimeMillis();\n    String username = \"admin\";\n    String password = \"admin\";\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n    ResponseEntity<Map<String, Object>> response = restTemplate.postForEntity(\n        \"/api/auth/login\",\n        loginRequest,\n        new ParameterizedTypeReference<Map<String, Object>>() {\n        }\n    );\n    Map<String, Object> body = response.getBody();\n    setTokenInfo(\n        (String) body.get(\"token\"),\n        currentTimeMillis\n    );\n}", "CodeBleu_score": 56.3685538124593}, {"code": " private void doLogin(){\n\t        long currentTime = System.currentTimeMillis();\n        Map<String, Object> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<Map> response = restTemplate.postForEntity(\"/api/auth/login\", loginRequest, Map.class);\n        Map<String, Object> body = response.getBody();\n        String token = (String) body.get(\"token\");\n        String refreshToken = (String) body.get(\"refreshToken\");\n        long expiresIn = (long) body.get(\"expiresIn\");\n        tokenInfo = new TokenInfo(token, refreshToken, currentTime, currentTime + expiresIn * 1000);\n    }", "CodeBleu_score": 63.048475131378545}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    return getForEntity(\n            \"/api/device/{deviceId}\",\n            Device.class,\n            deviceId.getId())\n            .map(ResponseEntity::getBody)\n            .ofNullable();\n}", "CodeBleu_score": 19.12159662749649}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        return Optional.of(restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getId()).getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 42.03573894926747}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t  try {\n    return getForEntity(\n      \"/api/device/{deviceId}\",\n      Device.class,\n      deviceId\n    ).getBody();\n  } catch (HttpClientErrorException e) {\n    if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n      return Optional.empty();\n    }\n    throw e;\n  }\n}", "CodeBleu_score": 38.706696821408705}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(url + \"/device-with-credentials\", request, Device.class);\n        if (response.getStatusCode().equals(HttpStatus.OK)) {\n            return Optional.ofNullable(response.getBody());\n        } else if (response.getStatusCode().equals(HttpStatus.NOT_FOUND)) {\n            return Optional.empty();\n        } else {\n            throw new RuntimeException(\"Failed to save device with credentials: \" + response.getStatusCode());\n        }\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode().equals(HttpStatus.NOT_FOUND)) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 57.62380495717141}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n        ResponseEntity<Device> response = restTemplate.postForEntity(deviceUrl + \"/device-with-credentials\", request, Device.class);\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode().equals(HttpStatus.NOT_FOUND)) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 64.8237751189791}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    HttpEntity<DeviceCredentials> request = new HttpEntity<>(credentials);\n    try {\n        return Optional.of(restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class).getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 42.583287034380376}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t    if (arguments.length == 1) {\n        this.each(function(dev) {\n            dev.brightness = val;\n        });\n    } else {\n        this.send(addr, \"brightness\", val);\n    }\n    return this;\n}", "CodeBleu_score": 55.75798745605485}, {"code": "brightness(addr, val){\n\t  if (arguments.length == 1) {\n    this.each(function(dev) {\n      dev.brightness = val;\n    });\n  } else {\n    this.send(addr, 0xE0, val);\n  }\n  return this;\n}", "CodeBleu_score": 54.321652368627745}, {"code": "brightness(addr, val){\n\t  if (arguments.length === 1) {\n    this.each(function(device) {\n      if (device.type === 'led') {\n        device.brightness = addr;\n      }\n    });\n  } else if (arguments.length === 2) {\n    if (this.devices[addr] && this.devices[addr].type === 'led') {\n      this.devices[addr].brightness = val;\n    }\n  }\n\n  return this;\n}", "CodeBleu_score": 55.769251482713955}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t  const device = {};\n  Object.keys(LedControl.prototype).forEach(key => {\n    device[key] = this[key].bind(this, addr);\n  });\n  Object.getOwnPropertyNames(this).forEach(key => {\n    device[key] = this[key];\n  });\n  return device;\n}", "CodeBleu_score": 61.906596890232166}, {"code": "device(addr){\n\t    const device = {};\n    Object.keys(LedControl.prototype).forEach(key => {\n        device[key] = this[key].bind(this, addr);\n    });\n    Object.keys(this).forEach(key => {\n        device[key] = this[key];\n    });\n    return device;\n}", "CodeBleu_score": 58.93829374503341}, {"code": "device(addr){\n\t    let device = {};\n    Object.keys(LedControl.prototype).forEach(key => {\n        if (key != \"device\") {\n            device[key] = this[key].bind(this, addr);\n        }\n    });\n    Object.getOwnPropertyNames(this).forEach(key => {\n        if (key != \"device\") {\n            device[key] = this[key].bind(this, addr);\n        }\n    });\n    return device;\n}", "CodeBleu_score": 66.1636259247566}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[`${method}CallbackReconciliation`] = (collection, duration, callback) => {\n      if (!collection) {\n        throw new Error('Collection is required.');\n      }\n      if (!duration) {\n        duration = 1000;\n      }\n      if (!callback) {\n        throw new Error('Callback is required.');\n      }\n      if (typeof callback !== 'function') {\n        throw new Error('Callback must be a function.');\n      }\n      const signals = [];\n      collection.forEach(element => {\n        signals.push(\n          new Promise(resolve => {\n            setTimeout(() => {\n              element[method]();\n              resolve();\n            }, duration);\n          })\n        );\n      });\n      Promise.all(signals).then(() => callback());\n    };\n  });\n}", "CodeBleu_score": 38.468393008641094}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    for (let i = 0; i < methods.length; i++) {\n        const method = methods[i];\n        target[method] = (collection, duration, callback) => {\n            if (typeof duration === 'function') {\n                callback = duration;\n                duration = 1000;\n            }\n            if (typeof callback !== 'function') {\n                throw new TypeError('Callback must be a function');\n            }\n            const signals = [];\n            collection.forEach(element => {\n                signals.push(element[method](duration));\n            });\n            Promise.all(signals).then(callback);\n        };\n    }\n}", "CodeBleu_score": 54.01565461463065}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[method] = (collection, duration, callback) => {\n      if (typeof duration === 'function') {\n        callback = duration\n        duration = 1000\n      }\n      if (typeof callback !== 'function') {\n        throw new Error(`Callback must be a function, got ${typeof callback}`)\n      }\n      const promises = []\n      collection.forEach(element => {\n        promises.push(element[method](duration))\n      })\n      Promise.all(promises).then(callback)\n    }\n  })\n}", "CodeBleu_score": 41.434801098773924}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t  this.input = '';\n  this.io.serialRead(this.port, this.baudrate, (data) => {\n    this.input += new Buffer(data).toString();\n    const sentences = this.input.split('\\r\n');\n    this.input = sentences.pop();\n    for (let sentence of sentences) {\n      this.parseNmeaSentence(sentence);\n    }\n  });\n}", "CodeBleu_score": 32.50030726919671}, {"code": "listen(){\n\t    let input = \"\";\n    let priv = this;\n    this.io.serialRead(this.port, function (err, data) {\n        if (err) {\n            priv.emit(\"error\", err);\n            return;\n        }\n        input += new Buffer(data).toString();\n        let sentences = input.split(\"\\r\n\");\n        input = sentences.pop();\n        sentences.forEach(function (sentence) {\n            priv.parseNmeaSentence(sentence);\n        });\n    });\n}", "CodeBleu_score": 39.929880497092654}, {"code": "listen(){\n\t    this.input = \"\";\n    this.io.serialRead(this.port, (data) => {\n        this.input += new Buffer(data).toString();\n        this.input.split(\"\\r\n\").forEach((sentence) => {\n            if (sentence.length > 0) {\n                this.parseNmeaSentence(sentence);\n            }\n        });\n        if (this.input.length > 100) {\n            this.input = \"\";\n        }\n    });\n}", "CodeBleu_score": 31.414843561557348}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tint ret = 0;\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tconst struct adc_ad559x_dev_cfg *dev_cfg = config->dev_cfg;\n\tuint8_t num_channels = 0;\n\tuint8_t num_active_channels = 0;\n\tuint8_t num_active_channels_in_sequence = 0;\n\tuint8_t num_channels_in_sequence = 0;\n\tuint8_t channel_mask = 0;\n\tuint8_t channel_mask_in_sequence = 0;\n\tuint8_t channel_mask_in_sequence_index = 0;\n\tuint8_t channel_mask_index = 0;\n\tuint8_t channel_mask_index_in_sequence = 0;\n\tuint8_t channel_mask_in_sequence_index_in_sequence = 0;\n\tuint8_t num_channels_in_sequence_index = 0;\n\tuint8_t num_channels_in_sequence_index_in_sequence = 0;\n\tuint8_t num_channels_in_sequence_index_in_sequence_index = 0;\n\tuint8_t num_channels_in_sequence_index_in_sequence_index_in_sequence = 0;\n\tuint8_t num_channels_in_sequence_index_in_sequence_index_in_sequence_index = 0;\n\tuint8_t num_channels_in_sequence_index_in_sequence_index_in_sequence_index_in_sequence = 0;\n\tuint8_t num_channels_in_sequence_index_in_sequence_index_in_sequence_index_in_sequence_index = 0;\n\tuint8_t num_channels_in_sequence_index_in_sequence_index_in_sequence_index_in_sequence_index_in_sequence = 0;\n\tuint8_t num_channels_in_sequence_index_in_sequence_index_in_sequence_index_in_sequence_index_", "CodeBleu_score": 11.4815754967361}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tint i;\n\tint num_channels = 0;\n\tint num_bytes_per_sample = 0;\n\tint num_samples = 0;\n\tint num_bytes = 0;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i].channel_id != ADC_CHANNEL_ID_VOLTAGE) {\n\t\t\tLOG_ERR(\"Invalid channel id %d\",\n\t\t\t\tsequence->channels[i].channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnum_channels++;\n\t\tnum_bytes_per_sample += sequence->channels[i].buffer->size;\n\t}\n\n\tnum_samples = num_channels * sequence->options;\n\tnum_bytes = num_samples * num_bytes_per_sample;\n\n\tif (sequence->buffer_size < num_bytes) {\n\t\tLOG_ERR(\"Buffer size is insufficient\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.59591594183329}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_cfg *config = dev->config;\n\tint num_channels = 0;\n\tint sample_size = 0;\n\tint num_active_channels = 0;\n\tint buffer_size = 0;\n\tint i = 0;\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unsupported options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->ch", "CodeBleu_score": 38.84656099799832}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_cfg *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channel_count = sequence->channels;\n\tuint16_t *buffer = sequence->buffer;\n\tsize_t buffer_size = sequence->buffer_size;\n\tint err;\n\n\tif (config->resolution != sequence->resolution) {\n\t\tLOG_ERR(\"invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (channel_count > 1) {\n\t\tLOG_ERR(\"invalid channel count\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (buffer_size < channel_count) {\n\t\tLOG_ERR(\"invalid buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc_context_lock(&data->ctx, false, NULL);\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err) {\n\t\tadc_context_release(&data->ctx, err);\n\t\treturn err;\n\t}\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\terr = adc_ad559x_read_async(dev, channel_count, buffer);\n\tif (err) {\n\t\tadc_context_release(&data->ctx, err);\n\t\treturn err;\n\t}\n\n\terr = adc_context_wait_for_completion(&data->ctx);\n\tadc_context_release(&data->ctx, err);\n\n\treturn err;\n}", "CodeBleu_score": 58.138336927566094}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tstruct adc_ad559x_dev_cfg *ad559x_dev_cfg = config->dev_cfg;\n\tstruct adc_ad559x_reg_cfg *ad559x_reg_cfg = config->reg_cfg;\n\tuint32_t buffer_size;\n\tuint32_t sample_buffer_size;\n\tuint32_t sample_buffer_size_in_bytes;\n\tuint32_t channel_id;\n\tuint32_t channel_count;\n\tuint32_t channel_mask;\n\tuint8_t channel_index;\n\tuint8_t channel_offset;\n\tuint8_t channel_gain;\n\tuint8_t channel_res;\n\tuint8_t channel_bits;\n\tuint8_t channel_lsb;\n\tuint8_t channel_msb;\n\tuint8_t channel_mask_lsb;\n\tuint8_t channel_mask_msb;\n\tuint8_t channel_mask_lsb_offset;\n\tuint8_t channel_mask_msb_offset;\n\tuint8_t channel_mask_lsb_mask;\n\tuint8_t channel_mask_msb_mask;\n\tuint8_t channel_mask_lsb_shift;\n\tuint8_t channel_mask_msb_shift;\n\tuint8_t channel_mask_lsb_value;\n\tuint8_t channel_mask_msb_value;\n\tuint8_t channel_mask_lsb_masked;\n\tuint8_t channel_mask_msb_masked;\n\tuint8_t channel_mask_lsb_shifted;\n\tuint8_t channel_mask_msb_shifted;\n\tuint8_t channel_mask_lsb_or;\n\tuint8_t channel_mask_msb_or;\n\tuint8_t channel_mask_lsb_and;\n\tuint8_t", "CodeBleu_score": 14.867477169038157}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_cfg *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint error;\n\tuint8_t msb;\n\tuint8_t lsb;\n\tuint16_t res_bits;\n\tuint8_t channel_count;\n\tuint8_t i;\n\tuint8_t channel;\n\tuint8_t channel_mask;\n\tuint8_t channel_index;\n\tuint8_t channel_index_mask;\n\tuint8_t channel_index_shift;\n\tuint8_t channel_index_count;\n\tuint8_t channel_index_count_mask;\n\tuint8_t channel_index_count_shift;\n\tuint8_t channel_index_count_mask_shift;\n\tuint16_t channel_index_count_mask_shift_mask;\n\tuint16_t channel_index_count_mask_shift_mask_mask;\n\tuint16_t channel_index_count_mask_shift_mask_mask_mask;\n\tuint16_t channel_index_count_mask_shift_mask_mask_mask_mask;\n\tuint16_t channel_index_count_mask_shift_mask_mask_mask_mask_mask;\n\tuint16_t channel_index_count_mask_shift_mask_mask_mask_mask_mask_mask;\n\tuint16_t channel_index_count_mask_shift_mask_mask_mask_mask_mask_mask_mask;\n\tuint16_t channel_index_count_mask_shift_mask_mask_mask_mask_mask_mask_mask_mask;\n\tuint16_t channel_index_count_mask_shift_mask_mask_mask_mask_mask_mask_mask_mask_mask;\n\tuint16_t channel_index_count_mask_shift_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask;\n\tuint16_t channel_index_count_mask_shift_mask_mask_mask_mask_mask_mask_mask_mask", "CodeBleu_score": 13.561267424262278}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = CONTAINER_OF(ctx, struct adc_data, ctx);\n\tadc_context_lock(&data->ctx, false, NULL);\n\tadc_context_start_read(&data->ctx, data->channels);\n\tadc_context_release(&data->ctx, data->channels);\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 61.80905996196784}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tconst struct adc_config *config = ctx->config;\n\tstruct adc_sampling_data *sampling_data = &ctx->sampling;\n\tstruct adc_data *data = &sampling_data->data;\n\tstruct adc_data *repeat_buffer = &sampling_data->repeat_buffer;\n\tstruct adc_data *active_buffer = &sampling_data->active_buffer;\n\tu8_t ch_count = sampling_data->ch_count;\n\tu8_t i;\n\n\tif (sampling_data->state != ADC_SAMPLING_STATE_IDLE) {\n\t\treturn;\n\t}\n\n\tif (sampling_data->channels) {\n\t\tfor (i = 0; i < ch_count; i++) {\n\t\t\tdata->buffer[i] = repeat_buffer->buffer[i];\n\t\t}\n\t}\n\n\tsampling_data->state = ADC_SAMPLING_STATE_SAMPLING;\n\tsampling_data->channels = sampling_data->channels_copy;\n\tsampling_data->ch_count = ch_count;\n\tsampling_data->buffer_id = 0;\n\n\tactive_buffer->buffer = data->buffer;\n\tactive_buffer->buffer_size = data->buffer_size;\n\tactive_buffer->buffer_cnt = 0;\n\tactive_buffer->state = ADC_BUFFER_STATE_EMPTY;\n\n\tadc_enable(config);\n\n\tk_sem_give(&sampling_data->sync_sem);\n}", "CodeBleu_score": 37.19727944360589}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_stm32_data *data = ctx->data;\n\tconst struct adc_stm32_cfg *config = ctx->config;\n\tADC_TypeDef *adc = config->base;\n\tint err;\n\n\t/* set sampling time */\n\tadc->SMPR = config->sampling_time;\n\n\t/* set channels to be sampled */\n\tadc->CHSELR = config->channels;\n\n\t/* set resolution */\n\tadc->CFGR1 = config->resolution;\n\n\t/* set align */\n\tadc->CFGR1 |= config->align;\n\n\t/* set continuous mode */\n\tif (config->oversampling_ratio > 0) {\n\t\tadc->CFGR2 = ADC_CFGR2_OVSE;\n\t} else {\n\t\tadc->CFGR2 = 0;\n\t}\n\n\t/* set external trigger */\n\tif (config->trigger_selection != 0) {\n\t\tadc->CFGR1 |= config->trigger_selection;\n\t}\n\n\t/* set external trigger polarity */\n\tif (config->trigger_polarity != 0) {\n\t\tadc->CFGR1 |= config->trigger_polarity;\n\t}\n\n\t/* set oversampling ratio */\n\tif (config->oversampling_ratio > 0) {\n\t\tadc->CFGR2 |= config->oversampling_ratio;\n\t}\n\n\t/* set oversampling shift */\n\tif (config->oversampling_shift > 0) {\n\t\tadc->CFGR2 |= config->oversampling_shift;\n\t}\n\n\t/* set continuous mode */\n\tif (config->continuous_mode) {\n\t\tadc->CFGR1 |= ADC_CFGR1_CONT;\n\t}\n\n\t/* set single-ended/differential input mode */\n\tif (config->differential_mode) {\n\t\tadc->CFGR1 |= ADC_CFGR1_DIFF;\n\t}\n\n\t/* set cal", "CodeBleu_score": 41.0465520746071}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_data_container *data_container = (struct adc_data_container *)ctx->data_container;\n\n    if (repeat_sampling) {\n        data_container->buffer = data_container->repeat_buffer;\n    }\n}", "CodeBleu_score": 51.560138917835}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->data->buffer_ptr = ctx->data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 42.62774270085977}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->data.buffer_ptr = ctx->data.repeat_buffer;\n\t}\n}", "CodeBleu_score": 41.61657670196224}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (int i = 0; i < data->num_channels; i++) {\n\t\t\tstruct adc_channel_cfg *chan = &data->active_channels[i];\n\t\t\tint32_t val;\n\n\t\t\tif (adc_ad559x_read_channel(data->adc, chan->channel_id, &val) != 0) {\n\t\t\t\tLOG_ERR(\"ADC channel %d read failed\", chan->channel_id);\n\t\t\t\tadc_context_on_sampling_done(&data->ctx, chan->channel_id);\n\t\t\t\tadc_context_complete(&data->ctx, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tadc_context_on_channel_sampling_done(&data->ctx, chan->channel_id, val);\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, ADC_CHANNEL_ALL);\n\t\tadc_context_complete(&data->ctx, 0);\n\t}\n}", "CodeBleu_score": 44.3165056623477}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_context *ctx = &data->ctx;\n\tconst struct adc_ad559x_cfg *config = data->config;\n\tu16_t *buffer = ctx->buffer;\n\tu8_t channel_count = 0U;\n\tu8_t channel_idx;\n\tu8_t channel_sample_count;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tchannel_count = find_lsb_set(ctx->sequence.channels);\n\t\tchannel_sample_count = channel_count * config->oversampling;\n\n\t\tfor (channel_idx = 0U; channel_idx < channel_count; channel_idx++) {\n\t\t\tu8_t sample_idx;\n\t\t\tu16_t sample_accumulator = 0U;\n\n\t\t\tif (!(ctx->sequence.channels & BIT(channel_idx))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (sample_idx = 0U; sample_idx < config->oversampling;\n\t\t\t     sample_idx++) {\n\t\t\t\tu16_t sample;\n\n\t\t\t\tif (adc_ad559x_read_channel(data, channel_idx,\n\t\t\t\t\t\t\t    &sample) != 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %u\",\n\t\t\t\t\t\tchannel_idx);\n\t\t\t\t\tadc_context_complete(ctx, -EIO);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tsample_accumulator += sample;\n\t\t\t}\n\n\t\t\tbuffer[channel_idx] = sample_accumulator /\n\t\t\t\t\t      config->oversampling;\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, channel_sample_count);\n\t}\n}", "CodeBleu_score": 35.47859186822709}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_context *ctx = &data->ctx;\n\tstruct adc_seq_table *seq_table;\n\tstruct adc_seq_entry *cur_entry;\n\tu16_t buffer[1];\n\tint i;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (i = 0; i < ctx->sequence.entries; i++) {\n\t\t\tcur_entry = &ctx->sequence.entries[i];\n\t\t\tseq_table = &data->sequence_table[cur_entry->table_id];\n\t\t\tif (adc_ad559x_read_channel(data, seq_table->channel_id, buffer) != 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d\", seq_table->channel_id);\n\t\t\t\tadc_context_complete(ctx, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcur_entry->buffer = buffer[0];\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, dev);\n\t}\n}", "CodeBleu_score": 40.07174594526497}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t  int ret;\n  uint16_t config;\n  int ready_time = 0;\n  struct ads1112_data *drv_data = dev->data;\n\n  // Wait for the device to be ready\n  k_sleep(K_USEC(drv_data->ready_time));\n\n  // Read the configuration register\n  ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n  if (ret) {\n    return ret;\n  }\n\n  // Check the status\n  if (config & ADS1112_CONFIG_OS) {\n    // Device is ready\n    return 0;\n  }\n\n  // Device is not ready\n  while (ready_time < drv_data->ready_time) {\n    // Sleep for 100 microseconds\n    k_sleep(K_USEC(100));\n\n    // Read the configuration register\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n    if (ret) {\n      return ret;\n    }\n\n    // Check the status\n    if (config & ADS1112_CONFIG_OS) {\n      // Device is ready\n      return 0;\n    }\n\n    // Increment the ready time\n    ready_time += 100;\n  }\n\n  // Device is not ready\n  return -EIO;\n}", "CodeBleu_score": 53.78630626220722}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    struct ads1112_data *data = dev->data;\n    uint8_t reg;\n    int ret;\n\n    /* Wait for the device to be ready */\n    k_sleep(K_USEC(data->ready_time));\n\n    /* Read the configuration register */\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n    if (ret) {\n        return ret;\n    }\n\n    /* Check the status */\n    if (reg & ADS1112_CONFIG_OS_MASK) {\n        return 0;\n    }\n\n    /* Wait for the device to be ready */\n    k_sleep(K_USEC(100));\n\n    /* Read the configuration register */\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n    if (ret) {\n        return ret;\n    }\n\n    /* Check the status */\n    if (reg & ADS1112_CONFIG_OS_MASK) {\n        return 0;\n    }\n\n    return -EIO;\n}", "CodeBleu_score": 57.210703321447895}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t  int err;\n  uint16_t config;\n  struct ads1112_data *drv_data = dev->data;\n  uint8_t ready_time = drv_data->ready_time;\n\n  if (ready_time == 0) {\n    return 0;\n  }\n\n  k_sleep(K_USEC(100 * ready_time));\n\n  err = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n  if (err) {\n    return err;\n  }\n\n  if ((config & ADS1112_CONFIG_OS_MASK) != ADS1112_CONFIG_OS_BUSY) {\n    return 0;\n  }\n\n  return -EBUSY;\n}", "CodeBleu_score": 42.494661336389456}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    if (sequence->samplings < 1) {\n        LOG_ERR(\"The number of samplings must be greater than 0\");\n        return -EINVAL;\n    }\n\n    uint32_t required_buffer_size = sequence->samplings;\n    if (sequence->options & ADC_SEQ_EXTRA_SAMPLINGS) {\n        required_buffer_size += 1;\n    }\n\n    if (sequence->buffer_size < required_buffer_size) {\n        LOG_ERR(\"The buffer size is too small\");\n        return -ENOMEM;\n    }\n\n    return 0;\n}", "CodeBleu_score": 49.730687157008326}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    int samplings;\n    int buffer_size;\n\n    samplings = sequence->samplings;\n    buffer_size = sequence->buffer_size;\n\n    if (samplings > buffer_size) {\n        LOG_ERR(\"Buffer size is too small for the number of samplings\");\n        return -1;\n    }\n\n    return 0;\n}", "CodeBleu_score": 37.63448914436305}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint num_samplings;\n\tint num_extra_samplings;\n\tint required_buffer_size;\n\n\tif (sequence->sampling_count <= 0) {\n\t\tLOG_ERR(\"Invalid sampling count\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_samplings = sequence->sampling_count;\n\tnum_extra_samplings = sequence->options & ADC_SEQ_EXTRA_SAMPLES ? 1 : 0;\n\trequired_buffer_size = num_samplings + num_extra_samplings;\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.338250945377865}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->channels == 0U) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check for valid sequence channels */\n\tif (!ads1112_validate_sequence(dev, sequence)) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Set the sequence buffer */\n\tdata->sequence = sequence;\n\n\t/* Start the ADC read context */\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\t/* Wait for the read to complete */\n\tif (wait) {\n\t\treturn adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 59.914810650813024}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t  struct ads1112_data *drv_data = dev->data;\n  struct ads1112_dev_config *cfg = dev->config;\n  int ret = 0;\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->oversampling != 0) {\n    return -EINVAL;\n  }\n\n  if (sequence->calibrate) {\n    return -ENOTSUP;\n  }\n\n  if (sequence->resolution != 12) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels != BIT(0)) {\n    return -EINVAL;\n  }\n\n  if (sequence->channels", "CodeBleu_score": 31.499817073009094}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct adc_dev_data_t *dev_data = dev->data;\n\tstruct adc_context *ctx = &dev_data->ctx;\n\tuint8_t chan_id = sequence->channels[0].channel_id;\n\tuint8_t gain = sequence->channels[0].gain;\n\tuint8_t reference = sequence->channels[0].reference;\n\tuint8_t acq_time = sequence->channels[0].acquisition_time;\n\tint error;\n\n\t/* Validate the sequence */\n\terror = ads1112_validate_sequence(dev, sequence);\n\tif (error != 0) {\n\t\treturn error;\n\t}\n\n\t/* Set the channel and gain */\n\tads1112_set_channel_and_gain(dev, chan_id, gain, reference, acq_time);\n\n\t/* Start the ADC */\n\tadc_context_start_read(ctx, sequence);\n\n\t/* Wait for the ADC to complete */\n\tif (wait) {\n\t\tadc_context_wait_for_completion(ctx);\n\t}\n\n\t/* Return the read status */\n\terror = adc_context_get_error(ctx);\n\tif (error != 0) {\n\t\treturn error;\n\t}\n\n\t/* Get the ADC reading */\n\t*sequence->buffer = ads1112_get_reading(dev);\n\n\treturn 0;\n}", "CodeBleu_score": 50.55820669435725}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Unable to apply properties\");\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 66.61176071336446}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    int ret;\n    struct device *dev;\n    struct audio_codec_prop_cfg cfg;\n\n    /* Retrieve the device from the shell */\n    dev = device_get_binding(argv[1]);\n\n    /* Check if the device is found */\n    if (dev == NULL) {\n        shell_error(sh, \"Device not found\");\n        return -ENODEV;\n    }\n\n    /* Check if the device is an audio codec device */\n    if (dev->driver_api != &audio_codec_driver_api) {\n        shell_error(sh, \"Invalid device\");\n        return -EINVAL;\n    }\n\n    /* Set the properties to be applied to the device */\n    cfg.prop_id = AUDIO_CODEC_PROP_OUTPUT_VOLUME;\n    cfg.prop_val = 100;\n\n    /* Apply the properties to the device */\n    ret = audio_codec_apply_properties(dev, &cfg);\n\n    /* Return the result of the operation */\n    return ret;\n}", "CodeBleu_score": 56.485097733993086}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\n\tconst struct device *dev;\n\tint ret;\n\tint i;\n\tstruct codec_prop_cfg prop_cfg;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Too few arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!device_is_ready(dev)) {\n\t\tshell_error(sh, \"Device not ready\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Too few arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tprop_cfg.prop_id = strtoul(argv[2], NULL, 16);\n\n\tif (argc < 4) {\n\t\tshell_error(sh, \"Too few arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tprop_cfg.prop_value = strtoul(argv[3], NULL, 16);\n\n\tif (argc > 4) {\n\t\tprop_cfg.prop_mask = strtoul(argv[4], NULL, 16);\n\t} else {\n\t\tprop_cfg.prop_mask = 0xFFFFFFFF;\n\t}\n\n\tret = audio_codec_apply_properties(dev, &prop_cfg);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tshell_print(sh, \"Properties applied successfully\");\n\n\treturn 0;\n}", "CodeBleu_score": 60.11667926415514}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_dev_data *dev_data = dev->data;\n\tstruct mpxxdtyy_dev_cfg *dev_cfg = dev->config;\n\tint ret;\n\tenum mpxxdtyy_i2s_state next_state;\n\tenum mpxxdtyy_i2s_cmd i2s_cmd;\n\n\t/* Check if the device is already in the active state. */\n\tif (dev_data->i2s_state == MPXXDTYY_I2S_ACTIVE) {\n\t\t/*\n\t\t * If the current state is active, the device can only be stopped.\n\t\t * Check if the stop command was received.\n\t\t */\n\t\tif (cmd == DMIC_STOP) {\n\t\t\t/*\n\t\t\t * Set the next state to inactive and the I2S command to stop.\n\t\t\t * The device will transition from active to inactive state.\n\t\t\t */\n\t\t\tnext_state = MPXXDTYY_I2S_INACTIVE;\n\t\t\ti2s_cmd = MPXXDTYY_I2S_CMD_STOP;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If the start command was received, the device is already in the active state.\n\t\t\t * Log an error and return the error code.\n\t\t\t */\n\t\t\tLOG_ERR(\"Device is already in active state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If the device is not in the active state, the device can only be started.\n\t\t * Check if the start command was received.\n\t\t */\n\t\tif (cmd == DMIC_START) {\n\t\t\t/*\n\t\t\t * Set the next state to active and the I2S command to start.\n\t\t\t * The device will transition from inactive to active state.\n\t\t\t */\n\t\t\tnext_state = MPXXDTYY_I2S_ACTIVE;\n\t\t\ti2s_cmd = MPXXDTYY_I2S_CMD_START;\n\t\t} else {\n", "CodeBleu_score": 39.66159139991231}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_dev_data *dev_data = dev->data;\n\tenum mpxxdtyy_state state = dev_data->state;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tswitch (state) {\n\t\tcase MPXXDTYY_STATE_INITIALIZED:\n\t\t\tdev_data->i2s_cmd = MPXXDTYY_I2S_CMD_START;\n\t\t\tdev_data->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\tbreak;\n\t\tcase MPXXDTYY_STATE_ACTIVE:\n\t\t\t/* Ignore repeated start commands */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"Invalid state %d\", state);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tswitch (state) {\n\t\tcase MPXXDTYY_STATE_INITIALIZED:\n\t\t\t/* Ignore repeated stop commands */\n\t\t\tbreak;\n\t\tcase MPXXDTYY_STATE_ACTIVE:\n\t\t\tdev_data->i2s_cmd = MPXXDTYY_I2S_CMD_STOP;\n\t\t\tdev_data->state = MPXXDTYY_STATE_INITIALIZED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"Invalid state %d\", state);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command %d\", cmd);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret == 0) {\n\t\tret = mpxxdtyy_i2s_send_cmd(dev);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"Failed to send I2S command %d\", dev_data->i2s_cmd);\n\t\t\tdev_data->state", "CodeBleu_score": 49.42920643456047}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_dev_data *dev_data = dev->data;\n\tint ret;\n\n\tLOG_DBG(\"cmd = %d\", cmd);\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (dev_data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_set_start(dev);\n\t\t\tif (ret == 0) {\n\t\t\t\tdev_data->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"invalid state %d\", dev_data->state);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (dev_data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_set_stop(dev);\n\t\t\tif (ret == 0) {\n\t\t\t\tdev_data->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"invalid state %d\", dev_data->state);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"invalid trigger command %d\", cmd);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 55.041844485882706}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    struct auxdisplay_hd44780_data *data = dev->data;\n    uint8_t command = 0;\n    uint8_t cursor_blink = 0;\n    uint8_t position_blink = 0;\n    uint8_t display_on = 0;\n\n    if (enabled) {\n        display_on = AUXDISPLAY_HD44780_DISPLAY_ON;\n        if (data->cursor_blink) {\n            cursor_blink = AUXDISPLAY_HD44780_CURSOR_BLINK;\n        }\n        if (data->position_blink) {\n            position_blink = AUXDISPLAY_HD44780_POSITION_BLINK;\n        }\n    }\n\n    command = AUXDISPLAY_HD44780_DISPLAY_MODE_MASK & (display_on | cursor_blink | position_blink);\n\n    auxdisplay_hd44780_command(dev, command);\n}", "CodeBleu_score": 55.9118662886252}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0;\n\n\tif (enabled) {\n\t\tcommand = LCD_DISPLAY_ON | LCD_CURSOR_ON | LCD_BLINK_ON;\n\t}\n\n\tif (data->cursor_position == 0) {\n\t\tcommand &= ~LCD_CURSOR_ON;\n\t}\n\n\tif (data->cursor_position == 1) {\n\t\tcommand &= ~LCD_BLINK_ON;\n\t}\n\n\tif (data->cursor_position == 2) {\n\t\tcommand &= ~(LCD_CURSOR_ON | LCD_BLINK_ON);\n\t}\n\n\tif (data->display_enabled != enabled) {\n\t\tdata->display_enabled = enabled;\n\t\tgpio_pin_set(config->display_enable_dev, config->display_enable_pin, enabled);\n\t}\n\n\tif (data->display_mode != command) {\n\t\tdata->display_mode = command;\n\t\tgpio_pin_set(config->rs_dev, config->rs_pin, 0);\n\t\tgpio_pin_write(config->e_dev, config->e_pin, 0);\n\t\tgpio_pin_write(config->data_dev, config->data_pins, command);\n\t\tgpio_pin_set(config->e_dev, config->e_pin, 1);\n\t\tgpio_pin_set(config->e_dev, config->e_pin, 0);\n\t}\n}", "CodeBleu_score": 54.340479559388996}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\n    struct auxdisplay_hd44780_data *data = dev->data;\n    struct auxdisplay_hd44780_config *config = dev->config;\n    uint8_t command = 0;\n\n    if (enabled) {\n        command |= AUXDISPLAY_HD44780_DISPLAY_ON;\n        command |= AUXDISPLAY_HD44780_CURSOR_ON;\n        command |= AUXDISPLAY_HD44780_BLINK_ON;\n    } else {\n        command |= AUXDISPLAY_HD44780_DISPLAY_OFF;\n        command |= AUXDISPLAY_HD44780_CURSOR_OFF;\n        command |= AUXDISPLAY_HD44780_BLINK_OFF;\n    }\n\n    if (data->cursor_enabled) {\n        command |= AUXDISPLAY_HD44780_CURSOR_ON;\n    }\n\n    if (data->blink_enabled) {\n        command |= AUXDISPLAY_HD44780_BLINK_ON;\n    }\n\n    if (data->display_enabled) {\n        command |= AUXDISPLAY_HD44780_DISPLAY_ON;\n    }\n\n    auxdisplay_hd44780_command(dev, command);\n}", "CodeBleu_score": 61.40772158815704}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\n\tif (config->busy_gpio_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 67.3406594057401}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t  const struct auxdisplay_itron_config *config = dev->config;\n  if (config->busy_gpio_port == NULL) {\n    return -ENOTSUP;\n  }\n  return gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 71.86866323166787}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t  const struct auxdisplay_itron_config *cfg = dev->config;\n  if (cfg->busy_gpio_port == NULL) {\n    return -ENOTSUP;\n  }\n  return gpio_pin_get_dt(cfg->busy_gpio_port, cfg->busy_gpio_pin);\n}", "CodeBleu_score": 67.95551074719238}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tint rc;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\trc = i2c_write_dt(&dev->i2c, buffer, sizeof(buffer));\n\tif (rc != 0) {\n\t\tLOG_ERR(\"Failed to send special command: %d\", rc);\n\t\treturn rc;\n\t}\n\n\tk_sleep(K_MSEC(AUXDISPLAY_SERLCD_SPECIAL_COMMAND_DELAY_MS));\n\n\treturn 0;\n}", "CodeBleu_score": 53.460705912330056}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tint ret;\n\tuint8_t buffer[2];\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\tret = i2c_write_dt(&((struct auxdisplay_serlcd_data *)dev->data)->i2c,\n\t\t\t   buffer, sizeof(buffer));\n\tk_sleep(AUXDISPLAY_SERLCD_SPECIAL_COMMAND_DELAY_MS);\n\treturn ret;\n}", "CodeBleu_score": 51.99831415580623}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tint ret;\n\tuint8_t buf[2];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\tret = i2c_write_dt(&config->i2c, buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tLOG_ERR(\"I2C write failed: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\n\treturn 0;\n}", "CodeBleu_score": 67.01854152469394}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_cfg *cfg = dev->config;\n\tstruct bbram_emul_data *data = dev->data;\n\tint err;\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset % 4 != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (size % 4 != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset % 4 != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (size % 4 != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n", "CodeBleu_score": 41.507276174021676}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_cfg *cfg = dev->config;\n\tstruct bbram_emul_data *data = dev->data;\n\tint rc;\n\n\t/* check if the read size is valid */\n\trc = bbram_emul_check_size(cfg, size);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* check if the read offset is valid */\n\trc = bbram_emul_check_offset(cfg, offset);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* check if the read size is valid */\n\trc = bbram_emul_check_invalid(cfg, offset, size);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* copy the data from the device's memory to the provided buffer */\n\tmemcpy(data->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 57.56613355355182}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\tuint8_t *bbram = data->bbram;\n\tuint32_t bbram_size = data->bbram_size;\n\n\tif (offset + size > bbram_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, bbram + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 59.33138768440727}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_cfg *cfg = dev->config;\n\tstruct bbram_emul_data *data = dev->data;\n\tuint8_t *bbram = cfg->data;\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data->invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&bbram[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 58.73359402450087}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\n\tif (offset + size > data->size) {\n\t\tLOG_ERR(\"write out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tbbram_emul_check_invalid(dev);\n\n\tmemcpy(data->data + offset, data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 61.15419758069891}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\tconst struct bbram_emul_cfg *cfg = dev->config;\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data->invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 67.43945651632941}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Device name not provided\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.41573156640014}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst struct device *dev;\n\tchar *endptr;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing required device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\treturn 0;\n}", "CodeBleu_score": 73.12157203483271}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Too few arguments. \"\n\t\t\t\t\"Expected at least 2 arguments.\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found.\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.78329468896189}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint rc;\n\tuint8_t buf[4];\n\tuint8_t *p;\n\tuint8_t *end;\n\n\tif (h4_read_remain == 0) {\n\t\treturn;\n\t}\n\n\trc = uart_fifo_read(dev, buf, sizeof(buf));\n\tif (rc < 0) {\n\t\tLOG_ERR(\"Error reading from UART: %d\", rc);\n\t\treturn;\n\t}\n\n\tp = buf;\n\tend = buf + rc;\n\n\twhile (p < end) {\n\t\th4_read_buf[h4_read_idx] = *p++;\n\n\t\tif (++h4_read_idx == sizeof(h4_read_buf)) {\n\t\t\th4_read_idx = 0;\n\t\t}\n\n\t\tif (--h4_read_remain == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.76849927359213}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    uint8_t buf[4];\n    uint8_t *p = (uint8_t *)&hdr_buf;\n    int rc;\n\n    rc = uart_fifo_read(dev, buf, sizeof(buf) - hdr_read);\n    if (rc < 0) {\n        LOG_ERR(\"Error reading header: %d\", rc);\n        return;\n    }\n\n    hdr_read += rc;\n    memcpy(p + hdr_read - rc, buf, rc);\n\n    if (hdr_read == sizeof(hdr_buf)) {\n        hdr_read = 0;\n        hdr_len = sys_get_be16(hdr_buf);\n    }\n}", "CodeBleu_score": 41.42297196708639}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\n    /*\n     * The function \"fifo_read\" reads data from a UART device into a buffer.\nIt calculates the number of bytes already read, then attempts to read the remaining bytes from the UART FIFO into the buffer.\nIf the read operation fails, it logs an error message; otherwise, it updates the remaining byte count based on the number of bytes successfully read.\n     */\n    int err = uart_fifo_read(dev, hdr_buf, hdr_remaining, &hdr_read);\n    if (err) {\n        LOG_ERR(\"Failed to read header: %d\", err);\n        return;\n    }\n\n    hdr_remaining -= hdr_read;\n}", "CodeBleu_score": 21.098033058251833}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t r;\n\n    r = uart_fifo_read(uart, buf, len);\n    if (r != len) {\n        LOG_ERR(\"Failed to discard %u bytes (%u read)\", len, r);\n    }\n\n    return r;\n}", "CodeBleu_score": 50.03892768216743}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t  uint8_t tmp_buf[33];\n  size_t read_len;\n\n  if (len == 0) {\n    return 0;\n  }\n\n  if (len > 33) {\n    len = 33;\n  }\n\n  read_len = uart_fifo_read(uart, tmp_buf, len);\n  if (read_len != len) {\n    LOG_ERR(\"Failed to read %d bytes from UART FIFO\", len);\n  }\n\n  return read_len;\n}", "CodeBleu_score": 51.179427269799824}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t read;\n\n    read = uart_fifo_read(uart, buf, sizeof(buf));\n    if (read < len) {\n        LOG_ERR(\"Failed to discard %zu bytes\", len - read);\n        return 0;\n    }\n\n    return read;\n}", "CodeBleu_score": 55.15081059341455}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    k_spinlock_key_t key = k_spin_lock(&chan->lock);\n    uint8_t highest = 0xff;\n    for (uint8_t i = 0; i < chan->observer_count; i++) {\n        struct zbus_observer *observer = &chan->observers[i];\n        if (observer->enabled && observer->priority < highest) {\n            highest = observer->priority;\n        }\n    }\n    chan->highest_observer_priority = highest;\n    k_spin_unlock(&chan->lock, key);\n}", "CodeBleu_score": 22.942012338264465}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tunsigned int hop = 0;\n\tunsigned int obs_prio;\n\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\n\tsys_dlist_for_each_entry(&chan->observers, obs, node) {\n\t\tobs_prio = obs->prio;\n\n\t\tif (obs->enabled && obs_prio < hop) {\n\t\t\thop = obs_prio;\n\t\t}\n\t}\n\n\tchan->highest_obs_prio = hop;\n\n\tk_spin_unlock(&chan->lock, key);\n}", "CodeBleu_score": 17.59476014575923}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    uint8_t i;\n    uint8_t highest_observer_prio = 0xff;\n    uint8_t observer_prio;\n    struct zbus_observer *observer;\n\n    /* Lock the channel data */\n    k_spinlock_key_t key = k_spin_lock(&chan->lock);\n\n    /* Iterate through the observers */\n    for (i = 0; i < chan->observer_count; i++) {\n        observer = &chan->observers[i];\n\n        /* Check if the observer is enabled */\n        if (!observer->enabled) {\n            continue;\n        }\n\n        /* Get the observer's priority */\n        observer_prio = observer->priority;\n\n        /* Check if the observer has a higher priority than the current highest */\n        if (observer_prio < highest_observer_prio) {\n            /* Update the highest observer priority */\n            highest_observer_prio = observer_prio;\n        }\n    }\n\n    /* Set the channel's highest observer priority */\n    chan->highest_observer_prio = highest_observer_prio;\n\n    /* Unlock the channel data */\n    k_spin_unlock(&chan->lock, key);\n}", "CodeBleu_score": 37.48812106018254}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel_observation *obs_hop;\n    TAILQ_FOREACH(obs_hop, &zbus_channel_observations, entries) {\n        if (obs_hop->observer == obs) {\n            obs_hop->update_hop(obs_hop->observer, obs_hop->channel);\n        }\n    }\n}", "CodeBleu_score": 22.516780726456005}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *obs_channel;\n\tstruct zbus_channel_observation *next;\n\tstruct zbus_channel_observation *prev;\n\n\tprev = NULL;\n\tobs_channel = zbus_channels;\n\twhile (obs_channel) {\n\t\tnext = obs_channel->next;\n\t\tif (obs_channel->observer == obs) {\n\t\t\tupdate_channel_hop(obs_channel);\n\t\t\tif (prev) {\n\t\t\t\tprev->next = next;\n\t\t\t} else {\n\t\t\t\tzbus_channels = next;\n\t\t\t}\n\t\t\tobs_channel->next = NULL;\n\t\t\tfree(obs_channel);\n\t\t} else {\n\t\t\tprev = obs_channel;\n\t\t}\n\t\tobs_channel = next;\n\t}\n}", "CodeBleu_score": 15.657874699157514}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel *ch;\n    struct zbus_channel_observer *ch_obs;\n    struct zbus_channel_observer *ch_obs_next;\n\n    struct zbus_channel_observer *ch_obs_tmp;\n    struct zbus_channel_observer *ch_obs_tmp_next;\n\n    ch_obs = zbus_channel_observer_list;\n    while (ch_obs) {\n        ch_obs_next = ch_obs->next;\n        ch = ch_obs->ch;\n\n        if (obs->id == ch->obs_id) {\n            /*\n             * The observer matches the channel observer.\n\n             * Update the channel.\n             */\n            ch->update_hop(ch, obs->data);\n        }\n\n        ch_obs = ch_obs_next;\n    }\n\n    ch_obs_tmp = zbus_channel_observer_tmp_list;\n    while (ch_obs_tmp) {\n        ch_obs_tmp_next = ch_obs_tmp->next;\n        ch = ch_obs_tmp->ch;\n\n        if (obs->id == ch->obs_id) {\n            /*\n             * The observer matches the channel observer.\n\n             * Update the channel.\n             */\n            ch->update_hop(ch, obs->data);\n        }\n\n        ch_obs_tmp = ch_obs_tmp_next;\n    }\n}", "CodeBleu_score": 14.277628727534225}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    /*\n     * Assert that the operation is not being performed in an ISR.\n     */\n    ZBUS_ASSERT(!k_is_in_isr(), \"Operation must not be performed in an ISR.\");\n    /*\n     * Assert that the observer is not null.\n     */\n    ZBUS_ASSERT(obs != NULL, \"Observer must not be null.\");\n    /*\n     * Lock the spinlock.\n     */\n    k_spinlock_key_t key = k_spin_lock(&zbus_spinlock);\n    /*\n     * Set the observer's priority to the minimum thread priority.\n     */\n    obs->priority = K_LOWEST_THREAD_PRIO;\n    /*\n     * Update all channels associated with the observer.\n     */\n    update_all_channels_hop(obs);\n    /*\n     * Unlock the spinlock and return.\n     */\n    k_spin_unlock(&zbus_spinlock, key);\n    return 0;\n}", "CodeBleu_score": 58.0217794928508}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    ZBUS_ASSERT(obs != NULL);\n    ZBUS_ASSERT(!k_is_in_isr());\n    k_spinlock_key_t key = k_spin_lock(&zbus_lock);\n    zbus_obs_set_priority(obs, K_LOWEST_THREAD_PRIO);\n    update_all_channels_hop(obs);\n    k_spin_unlock(&zbus_lock, key);\n    return 0;\n}", "CodeBleu_score": 40.30652665135299}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    _ZBUS_ASSERT(obs != NULL);\n    _ZBUS_ASSERT(!k_is_in_isr());\n\n    k_spinlock_key_t key = k_spin_lock(&zbus_observer_lock);\n    obs->priority = 0;\n    update_all_channels_hop(obs);\n    k_spin_unlock(&zbus_observer_lock, key);\n\n    return 0;\n}", "CodeBleu_score": 41.34978702164609}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    ZBUS_ASSERT(chan != NULL, \"zbus_chan_notify: chan is null\");\n\n    if (k_is_in_isr()) {\n        timeout = sys_timepoint_calc(timeout);\n    }\n\n    struct zbus_chan_notify_context ctx = {\n        .chan = chan,\n        .timeout = timeout,\n        .prio = 0,\n    };\n\n    k_chan_lock(chan);\n    int ret = _zbus_vded_exec(&ctx, _zbus_chan_notify_logic);\n    k_chan_unlock(chan);\n\n    return ret;\n}", "CodeBleu_score": 35.28644498995992}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tstruct k_spinlock *chan_lock = &chan->lock;\n\tstruct zbus_context *ctx = z_current_context();\n\tint ret = 0;\n\n\tZBUS_ASSERT(chan != NULL, \"zbus_chan_notify: chan is NULL\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = ZBUS_ISR_TIMEOUT;\n\t}\n\n\tsys_timepoint_calc(&chan->end_time, timeout);\n\tctx->priority = chan->priority;\n\n\tk_spinlock_key_t key = k_spin_lock(chan_lock);\n\n\tif (chan->status == ZBUS_CHAN_STATUS_CLOSED) {\n\t\tret = -EIO;\n\t} else {\n\t\tret = zbus_vded_exec(chan);\n\t}\n\n\tk_spin_unlock(chan_lock, key);\n\n\treturn ret;\n}", "CodeBleu_score": 47.567510207274296}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t__ASSERT_NO_MSG(chan != NULL);\n\tif (k_is_in_isr()) {\n\t\tif (timeout.ticks == K_NO_WAIT) {\n\t\t\treturn -EWOULDBLOCK;\n\t\t}\n\t\tif (timeout.ticks == K_FOREVER) {\n\t\t\treturn -EBUSY;\n\t\t}\n\t\ttimeout = z_time_timeout_add(timeout, k_is_in_isr());\n\t}\n\tstruct zbus_chan_ctx ctx = {\n\t\t.chan = chan,\n\t\t.prio = chan->prio,\n\t};\n\tk_spinlock_key_t key = chan_lock(chan);\n\tint err = _zbus_vded_exec(chan, &ctx);\n\tchan_unlock(chan, key);\n\treturn err;\n}", "CodeBleu_score": 40.04073714021702}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  uint32_t tmpreg = 0;\n  /* Check the parameters */\n  assert_param(IS_ETH_INT(Int));\n  assert_param(IS_BOOL(enable));\n  /* Check the interrupt enable bit */\n  if (enable) {\n    /* Enable the selected interrupt */\n    tmpreg = ETH->INTEN;\n    if (IS_ETH_INT_ABNORMAL(Int)) {\n      /* Enable the selected abnormal interrupt */\n      tmpreg |= Int;\n    } else {\n      /* Enable the selected normal interrupt */\n      tmpreg |= (Int << 16);\n    }\n    ETH->INTEN = tmpreg;\n  } else {\n    /* Disable the selected interrupt */\n    tmpreg = ETH->INTEN;\n    tmpreg &= ~Int;\n    ETH->INTEN = tmpreg;\n  }\n}", "CodeBleu_score": 41.09984978397796}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  uint32_t tmp = 0;\n  assert_param(IS_ETH_INT_NORMAL(Int));\n  assert_param(IS_ETH_INT(Int));\n  assert_param(IS_BOOL(enable));\n  if (enable) {\n    if (IS_ETH_INT_ABNORMAL(Int)) {\n      tmp = ETH->INTENABLER & 0x00000000FFFFFFFF;\n      ETH->INTENABLER = tmp | Int;\n    } else {\n      tmp = ETH->INTENABLER & 0xFFFFFFFF00000000;\n      ETH->INTENABLER = tmp | Int;\n    }\n  } else {\n    if (IS_ETH_INT_ABNORMAL(Int)) {\n      tmp = ETH->INTENABLER & 0x00000000FFFFFFFF;\n      tmp &= ~Int;\n      ETH->INTENABLER = tmp;\n    } else {\n      tmp = ETH->INTENABLER & 0xFFFFFFFF00000000;\n      tmp &= ~Int;\n      ETH->INTENABLER = tmp;\n    }\n  }\n}", "CodeBleu_score": 49.23897264360899}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  if (enable) {\n    if (Int & IS_ETH_INT_ABNORMAL) {\n      ETH->INTEN |= IS_ETH_INT_ABNORMAL;\n    }\n    if (Int & IS_ETH_INT_NORMAL) {\n      ETH->INTEN |= IS_ETH_INT_NORMAL;\n    }\n  } else {\n    ETH->INTEN &= ~Int;\n    if (Int & IS_ETH_INT_ABNORMAL) {\n      ETH->INTEN |= (ETH->INTST & IS_ETH_INT_ABNORMAL);\n    }\n    if (Int & IS_ETH_INT_NORMAL) {\n      ETH->INTEN |= (ETH->INTST & IS_ETH_INT_NORMAL);\n    }\n  }\n}", "CodeBleu_score": 47.76093354945252}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *pTxDesc;\n    uint32_t i;\n\n    /* Get the current Tx descriptor address */\n    pTxDesc = (ETH_TX_DESC *)ETH_TxDesc;\n\n    /* Search for a free descriptor */\n    for (i = 0; i < ETH_TXBUFNB; i++) {\n        /* Check if the descriptor is owned by the ETHERNET DMA (when the OWN bit is cleared in the TDES0) */\n        if ((pTxDesc->tdes0 & ETH_TDES0_OWN) == (uint32_t)RESET) {\n            /* Return the pointer to the free descriptor */\n            return pTxDesc;\n        }\n        /* Point to the next descriptor */\n        pTxDesc = (ETH_TX_DESC *)(pTxDesc->tdes3);\n    }\n\n    /* There are no free descriptors */\n    return 0;\n}", "CodeBleu_score": 53.33550648943381}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    uint32_t idx;\n    ETH_TX_DESC *pTxDesc;\n    ETH_TX_DESC *pTxDescStart;\n\n    pTxDesc = ETH->TDES_START;\n    pTxDescStart = ETH->TDES_START;\n\n    while (1) {\n        if ((pTxDesc->Status & ETH_TDES_OWN) == 0) {\n            return pTxDesc;\n        }\n        pTxDesc = pTxDesc->pNextDesc;\n        if (pTxDesc == pTxDescStart) {\n            return 0;\n        }\n    }\n}", "CodeBleu_score": 44.601416678825515}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t  ETH_TX_DESC *pTxDesc;\n  uint32_t FirstDesc = 0, LastDesc = 0;\n\n  /* Get the location of the first and last Tx descriptors */\n  FirstDesc = (uint32_t)ETH->TDESAR;\n  LastDesc = FirstDesc + (ETH_TXBUFNB - 1) * sizeof(ETH_TX_DESC);\n\n  /* Search for a free Tx descriptor */\n  pTxDesc = (ETH_TX_DESC *)FirstDesc;\n  do {\n    /* Check if the descriptor is owned by the ETHERNET DMA (when the OWN bit is cleared) */\n    if ((pTxDesc->Status & ETH_DMATXDESC_OWN) == (uint32_t)RESET) {\n      /* Check if the second address chained is set */\n      if ((pTxDesc->Status & ETH_DMATXDESC_LS) == (uint32_t)RESET) {\n        /* Check if the buffer 2 address is not filled */\n        if (pTxDesc->Buffer2Addr == 0x0) {\n          /* Return a pointer to the free Tx descriptor */\n          return (pTxDesc);\n        }\n      } else {\n        /* Check if the buffer 1 address is not filled */\n        if (pTxDesc->Buffer1Addr == 0x0) {\n          /* Return a pointer to the free Tx descriptor */\n          return (pTxDesc);\n        }\n      }\n    }\n    /* Point to the next descriptor */\n    pTxDesc = (ETH_TX_DESC *)((uint32_t)(pTxDesc) + sizeof(ETH_TX_DESC));\n  } while ((uint32_t)pTxDesc <= LastDesc);\n\n  /* There are no free descriptors */\n  return (NULL);\n}", "CodeBleu_score": 47.44224460425404}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n    RT_ASSERT(channel < CYP_DAC_CHANNEL_COUNT);\n\n    cy_en_csd_idac_channel_t dac_channel;\n\n    dac_channel = (cy_en_csd_idac_channel_t)channel;\n\n    if (CY_CSD_IDAC_SUCCESS != Cy_CSDIDAC_OutputEnable(device->dac_base, dac_channel, *value)) {\n        LOG_E(\"DAC channel %d init failed\", channel);\n        return -RT_EIO;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 58.40390697429346}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tRT_ASSERT(device != RT_NULL);\n\tRT_ASSERT(channel < CY_CSD_IDAC_CHANNELS);\n\tRT_ASSERT(value != RT_NULL);\n\n\tcy_en_csd_status_t status;\n\tcy_stc_csd_dac_config_t dac_config;\n\tcy_stc_csd_config_t csd_config;\n\tcy_stc_csd_context_t context;\n\tcy_stc_csd_idac_config_t idac_config;\n\tcy_stc_csd_idac_context_t idac_context;\n\n\tcy_stc_csd_context_t *csd_context = (cy_stc_csd_context_t *)device->parent.user_data;\n\n\t/* Initialize the CSD configuration structure */\n\tcy_stc_csd_config_t_init(&csd_config);\n\t/* Initialize the IDAC configuration structure */\n\tcy_stc_csd_idac_config_t_init(&idac_config);\n\n\t/* Initialize the CSD context structure */\n\tcy_stc_csd_context_t_init(&context);\n\t/* Initialize the IDAC context structure */\n\tcy_stc_csd_idac_context_t_init(&idac_context);\n\n\t/* Configure the CSD configuration structure */\n\tcsd_config.refSel = CY_CSD_VREF_EXT;\n\tcsd_config.sampleDelay = 0UL;\n\tcsd_config.measDelay = 0UL;\n\tcsd_config.lowPowerMode = CY_CSD_NORMAL;\n\tcsd_config.deepSleep = CY_CSD_NORMAL;\n\tcsd_config.halfSckPeriod = CY_CSD_HALF_OF_SCK;\n\tcsd_config.senseClk = CY_CSD_SENSE_CLK_DELAYED;\n\tcsd_config.sense = CY_CSD_S", "CodeBleu_score": 41.89510346191358}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    cy_en_csd_idac_channel_t dac_channel;\n    cy_stc_csd_dac_config_t dac_config;\n\n    LOG_D(\"cyp_adc_convert, channel:%d, value:%d\", channel, *value);\n\n    /* Get the DAC channel */\n    dac_channel = (cy_en_csd_idac_channel_t)channel;\n\n    /* Initialize the DAC configuration structure */\n    dac_config.outputMode = CY_CSD_IDAC_OUTPUT_MODE_VARIABLE;\n    dac_config.reference = CY_CSD_IDAC_REFERENCE_VDDA;\n    dac_config.gain = CY_CSD_IDAC_GAIN_1X;\n    dac_config.deadBand = CY_CSD_IDAC_DEADBAND_20MV;\n    dac_config.power = CY_CSD_IDAC_POWER_1000_uA;\n    dac_config.value = *value;\n\n    /* Attempt to enable the DAC output */\n    if (Cy_CSDIDAC_OutputEnable(cy_dac_base[channel], dac_channel, &dac_config) != CY_CSD_SUCCESS) {\n        LOG_E(\"cyp_adc_convert, Cy_CSDIDAC_OutputEnable failed\");\n        return RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 49.897100167603355}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    rt_uint8_t *p = (rt_uint8_t *)addr;\n\n    if (addr + size > FLASH_END_ADDRESS) {\n        LOG_E(\"read outrange flash size! addr is (0x%p)\", (void *)(addr + size));\n        return -RT_EINVAL;\n    }\n\n    for (i = 0; i < size; i++)\n        *buf++ = *p++;\n\n    return size;\n}", "CodeBleu_score": 67.9182307820496}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    rt_uint32_t end_addr = addr + size;\n\n    if (end_addr > FLASH_END_ADDR) {\n        LOG_E(\"read data would exceed flash end address: 0x%08x\", end_addr);\n        return -RT_EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 53.035606550283944}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i = 0;\n\trt_uint32_t end_addr = addr + size;\n\t\n\tif (end_addr > FLASH_END_ADDR) {\n\t\tLOG_E(\"read would exceed flash memory end address\");\n\t\treturn -RT_EINVAL;\n\t}\n\t\n\tfor (i = addr; i < end_addr; i++) {\n\t\tbuf[i - addr] = *(rt_uint8_t *)i;\n\t}\n\t\n\treturn i - addr;\n}", "CodeBleu_score": 43.16224769041859}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer != RT_NULL);\n\trt_uint32_t count = 0;\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\tRT_ASSERT(timer_obj != RT_NULL);\n\tRT_ASSERT(timer_obj->resource.type == CYHAL_RSC_TIMER);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.channel_num < CY_MXTIMER_MAX_COUNT_WIDTH);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj->resource.block_num < CY_IP_MXTIMER_INSTANCES);\n\tRT_ASSERT(timer_obj", "CodeBleu_score": 43.793820407979354}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    RT_ASSERT(obj != RT_NULL);\n\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 59.28842400051138}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 31.751041619710936}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    /*\n     * The function \"rt_mutex_take\" attempts to acquire a mutex lock for the filesystem.\nIt repeatedly tries to take the mutex until it is successful, waiting indefinitely each time.\nIf the mutex acquisition fails for any reason other than being busy, it triggers an assertion failure.\n     */\n    rt_mutex_take(dfs_lock_mutex);\n}", "CodeBleu_score": 3.3234257369005133}, {"code": "void dfs_lock(void){\n\t    rt_mutex_take(dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.5715837218707165}, {"code": "void dfs_lock(void){\n\t  rt_mutex_take(&fs_mutex);\n}", "CodeBleu_score": 4.153323344072572}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t  int fd;\n  int i;\n\n  for (fd = startfd; fd < fdt->maxfd; fd++) {\n    if (fdt->fd_array[fd].inuse == 0) {\n      fdt->fd_array[fd].inuse = 1;\n      return fd;\n    }\n  }\n\n  if (fdt->maxfd >= DFS_FD_SETSIZE) {\n    return -1;\n  }\n\n  for (i = 0; i < fdt->maxfd; i++) {\n    fdt->fd_array[i].inuse = 0;\n  }\n\n  fdt->fd_array[0].inuse = 1;\n  fdt->maxfd = DFS_FD_SETSIZE;\n\n  return 0;\n}", "CodeBleu_score": 38.827794878609105}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fd[i] == NULL) {\n            return i;\n        }\n    }\n\n    if (fdt->maxfd == fdt->usedfd) {\n        return -1;\n    }\n\n    for (i = 0; i < startfd; i++) {\n        if (fdt->fd[i] == NULL) {\n            return i;\n        }\n    }\n\n    return -1;\n}", "CodeBleu_score": 44.85268781131913}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\n\tfor (i = startfd; i < fdt->max_fds; i++) {\n\t\tif (fdt->fd_array[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (fdt->max_fds == DFS_FD_TABLE_SIZE) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Expand the fd table\n\t */\n\tif (fd_table_expand(fdt) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 41.59618362514451}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    rt_uint32_t index;\n    rt_err_t err_code;\n\n    err_code = (error <= -RT_EOK) ? -error : error;\n    for (index = 0; index < sizeof(error_desc) / sizeof(error_desc[0]); index++) {\n        if (err_code == error_desc[index].err_code) {\n            return error_desc[index].err_desc;\n        }\n    }\n\n    return \"EUNKNOWN\";\n}", "CodeBleu_score": 48.40580333772711}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    rt_uint32_t index;\n    rt_uint32_t err_num;\n\n    err_num = (error < 0) ? -error : error;\n    for (index = 0; index < sizeof(error_table) / sizeof(error_table[0]); index++) {\n        if (error_table[index].num == err_num) {\n            return error_table[index].desc;\n        }\n    }\n\n    return \"EUNKNOWN\";\n}", "CodeBleu_score": 54.1314146254962}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    rt_size_t index;\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    for (index = 0; index < sizeof(error_tab) / sizeof(error_tab[0]); index ++) {\n        if (error_tab[index].err == error) {\n            return error_tab[index].str;\n        }\n    }\n\n    return \"EUNKNOWN\";\n}", "CodeBleu_score": 58.88461888190621}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_err_t result = RT_EFULL;\n    rt_uint8_t i;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* try to find an empty slot */\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_idle_hook_list[i] == RT_NULL) {\n            rt_idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 70.01074163799218}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_thread_idle_hook_t *hook_ptr;\n\n    if (hook == RT_NULL)\n        return -RT_ERROR;\n\n    level = rt_hw_interrupt_disable();\n    for (hook_ptr = &idle_thread->idle_hook[0];\n         hook_ptr < &idle_thread->idle_hook[RT_THREAD_IDLE_HOOK_LIST_SIZE]; hook_ptr++) {\n        if (hook_ptr->idle_hook == RT_NULL) {\n            hook_ptr->idle_hook = hook;\n            rt_hw_interrupt_enable(level);\n\n            return RT_EOK;\n        }\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return -RT_EFULL;\n}", "CodeBleu_score": 44.13605629065739}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_thread_idle_hook_t *idle_hook;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n    rt_enter_critical();\n\n    idle_hook = &rt_thread_idle_gethook(0);\n    while (idle_hook->hook != RT_NULL) {\n        idle_hook++;\n        if (idle_hook >= &rt_thread_idle_gethook(RT_THREAD_IDLE_HOOK_LIST_SIZE)) {\n            idle_hook = &rt_thread_idle_gethook(0);\n        }\n    }\n\n    if (idle_hook->hook == RT_NULL) {\n        idle_hook->hook = hook;\n        idle_hook->next = RT_NULL;\n\n        rt_exit_critical();\n        rt_hw_interrupt_enable(level);\n\n        return RT_EOK;\n    }\n\n    rt_exit_critical();\n    rt_hw_interrupt_enable(level);\n\n    return -RT_EFULL;\n}", "CodeBleu_score": 38.97480393242688}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_base_t lock;\n    rt_err_t ret = -RT_ERROR;\n    struct rt_thread_idle_hook *hook_item;\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    hook_item = _rt_thread_idle_hook_list;\n    while (hook_item != RT_NULL) {\n        if (hook_item->hook == hook) {\n            hook_item->hook = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n        hook_item = hook_item->next;\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    return ret;\n}", "CodeBleu_score": 51.35097260960727}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_uint32_t i;\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* search for hook */\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_idle_hook_list[i] == hook) {\n            rt_idle_hook_list[i] = RT_NULL;\n            break;\n        }\n    }\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    if (i < RT_IDLE_HOOK_LIST_SIZE) {\n        return RT_EOK;\n    }\n    else {\n        return -RT_ERROR;\n    }\n}", "CodeBleu_score": 58.119990104197505}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_base_t i;\n    rt_err_t result = RT_EOK;\n\n    /* disable interrupt */\n    rt_base_t level;\n    level = rt_hw_interrupt_disable();\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_idle_hook_list[i] == hook) {\n            rt_idle_hook_list[i] = RT_NULL;\n            break;\n        }\n    }\n\n    if (i == RT_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_EINVAL;\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 62.39167063556239}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    struct rt_thread *thread;\n    struct rt_list_node *node;\n    rt_base_t lock;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* resume all suspended threads */\n    for (node = susp_list->next; node != susp_list; node = node->next) {\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n        rt_schedule_remove_thread(thread);\n        rt_schedule_insert_thread(thread);\n        thread->error = thread_error;\n        thread->stat = RT_THREAD_READY;\n        rt_schedule();\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    return RT_EOK;\n}", "CodeBleu_score": 35.23952245262782}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    struct rt_thread *thread;\n    struct rt_list_node *node;\n    rt_err_t result = RT_EOK;\n\n    /* ensure the scheduler is unlocked */\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* resume all suspended threads in the list */\n    while (!rt_list_isempty(susp_list)) {\n        /* get thread to be resumed */\n        node = susp_list->next;\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n\n        /* remove thread from suspended list */\n        rt_list_remove(node);\n\n        /* resume thread */\n        rt_thread_resume(thread);\n\n        /* set error code */\n        thread->error = thread_error;\n\n        /* change thread state */\n        thread->stat = RT_THREAD_READY;\n\n        /* insert thread to the ready list */\n        rt_schedule_insert_thread(thread);\n    }\n\n    return result;\n}", "CodeBleu_score": 38.35624465377043}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    struct rt_thread *thread;\n    register rt_base_t temp;\n    register rt_base_t level;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* ensure the scheduler is unlocked */\n    RT_DEBUG_NOT_IN_SCHEDULE;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* resume all suspended threads */\n    while (!rt_list_isempty(susp_list)) {\n        /* get next suspended thread */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n        /* set error code */\n        thread->error = thread_error;\n\n        /* remove thread from suspended list */\n        rt_list_remove(&(thread->tlist));\n\n        /* remove thread from suspended list */\n        rt_schedule_remove_thread(thread);\n\n        /* resume thread */\n        rt_thread_resume(thread);\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 40.70181199240002}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = RT_NULL;\n    rt_device_t new_console = RT_NULL;\n\n    if (name == RT_NULL) return RT_NULL;\n\n    old_console = rt_console_get_device();\n    if (old_console != RT_NULL)\n    {\n        if (strcmp(name, old_console->parent.name) == 0)\n        {\n            return old_console;\n        }\n        rt_device_close(old_console);\n    }\n\n    new_console = rt_device_find(name);\n    if (new_console != RT_NULL)\n    {\n        rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        rt_console_set_device(new_console);\n    }\n\n    return old_console;\n}", "CodeBleu_score": 50.34109944826932}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = RT_NULL;\n    rt_device_t new_console = RT_NULL;\n\n    if (name == RT_NULL) {\n        return RT_NULL;\n    }\n\n    if (rt_console_get_device() != RT_NULL) {\n        old_console = rt_console_get_device();\n    }\n\n    new_console = rt_device_find(name);\n    if (new_console != RT_NULL && new_console != old_console) {\n        rt_device_close(old_console);\n\n        rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_OFLAG_STREAM);\n        rt_console_set_device(new_console);\n    }\n\n    return old_console;\n}", "CodeBleu_score": 54.17337304206983}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = RT_NULL;\n    rt_device_t new_console = RT_NULL;\n\n    RT_ASSERT(name != RT_NULL);\n\n    /* disable interrupt */\n    rt_base_t level;\n    level = rt_hw_interrupt_disable();\n\n    old_console = console_device;\n\n    /* find device */\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        goto __exit;\n    }\n\n    /* same device */\n    if (new_console == old_console) {\n        goto __exit;\n    }\n\n    /* close old console */\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    /* open new console */\n    if (new_console->flag & RT_DEVICE_FLAG_STREAM) {\n        rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    } else {\n        rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR);\n    }\n\n    console_device = new_console;\n\n__exit:\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return old_console;\n}", "CodeBleu_score": 56.597163015048444}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    rt_object_information_t information;\n    rt_list_t *object_list;\n    rt_object_t object;\n    int count;\n\n    /* retrieve the object information */\n    if (rt_object_get_information(type, &information) != RT_EOK)\n        return 0;\n\n    /* lock the object list */\n    rt_spin_lock_irqsave(&(information.object_list->lock));\n\n    /* initialize the count */\n    count = 0;\n\n    /* iterate through the object list */\n    object_list = &(information.object_list->object_list);\n    for (object = rt_list_first_entry(object_list, rt_object_t, list);\n         &object->list != object_list;\n         object = rt_list_entry(object->list.next, rt_object_t, list)) {\n        /* increase the count */\n        count++;\n    }\n\n    /* unlock the object list */\n    rt_spin_unlock_irqrestore(&(information.object_list->lock));\n\n    return count;\n}", "CodeBleu_score": 40.22852054760043}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object *object;\n\tint count = 0;\n\n\trt_enter_critical();\n\t/* get the first object */\n\tobject = rt_object_get_list_head(type);\n\twhile (object != RT_NULL) {\n\t\tcount++;\n\t\tobject = object->list_node.next;\n\t}\n\trt_exit_critical();\n\n\treturn count;\n}", "CodeBleu_score": 32.47662193487037}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object *object;\n    struct rt_object_information *information;\n    register rt_base_t temp;\n    register rt_base_t count = 0;\n\n    /* get object information */\n    information = rt_object_get_information(type);\n    if (information == RT_NULL)\n        return 0;\n\n    /* lock object list */\n    rt_spin_lock_irqsave(&(information->object_list_lock));\n\n    /* try to get the first object */\n    object = rt_list_first_entry_or_null(&(information->object_list),\n                                         struct rt_object, list);\n    while (object != RT_NULL)\n    {\n        count++;\n        object = rt_list_entry(rt_list_next(&(object->list)),\n                               struct rt_object, list);\n    }\n\n    /* unlock object list */\n    rt_spin_unlock_irqrestore(&(information->object_list_lock));\n\n    return count;\n}", "CodeBleu_score": 55.71091682889718}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    struct rt_object_information *information;\n    register rt_base_t temp;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* call object detach hook */\n    RT_OBJECT_HOOK_CALL(object, detach);\n\n    /* get object information */\n    information = (struct rt_object_information *)object;\n\n    /* lock object */\n    rt_spin_lock_irqsave(&(information->lock));\n\n    /* remove object from object list */\n    rt_list_remove(&(information->list));\n\n    /* unlock object */\n    rt_spin_unlock_irqrestore(&(information->lock));\n\n    /* set object type to unknown */\n    object->type = 0;\n}", "CodeBleu_score": 42.27768593999209}, {"code": "void rt_object_detach(rt_object_t object){\n\t    struct rt_object_information *information;\n    register rt_base_t temp;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* get object information */\n    information = (struct rt_object_information *)object;\n\n    /* lock object */\n    rt_spin_lock_irqsave(&(information->object_lock));\n\n    /* remove object from object list */\n    rt_list_remove(&(information->object_list));\n\n    /* unlock object */\n    rt_spin_unlock_irqrestore(&(information->object_lock));\n\n    /* set object type to unknown */\n    object->type = 0;\n\n    /* call object hook */\n    RT_OBJECT_HOOK_CALL(object, detach);\n}", "CodeBleu_score": 40.98699262692544}, {"code": "void rt_object_detach(rt_object_t object){\n\t    register rt_base_t temp;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* call object hook */\n    RT_OBJECT_HOOK_CALL(object, detach);\n\n    /* get object information */\n    RT_DEBUG_LOG(RT_DEBUG_OBJECT, (\"detach object: 0x%08x\n\", object));\n    temp = (rt_base_t)object->type;\n    if (temp >= RT_Object_Class_Max)\n        return;\n    rt_object_information_t information = &(rt_object_information[temp]);\n\n    /* lock object */\n    rt_spin_lock_irqsave(information->lock);\n\n    /* remove object from object list */\n    rt_list_remove(&(object->list));\n\n    /* unlock object */\n    rt_spin_unlock_irqrestore(information->lock);\n\n    /* set object type */\n    object->type = 0;\n}", "CodeBleu_score": 50.68798996962639}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\trt_custom_object_t cobj;\n\n\t/* Check if the object is valid */\n\tRT_ASSERT(obj != RT_NULL);\n\n\t/* Check if the object is of the custom object class type */\n\tRT_ASSERT(rt_object_get_type(obj) == RT_Object_Class_Custom);\n\n\t/* Get the custom object */\n\tcobj = (rt_custom_object_t)obj;\n\n\t/* Check if the object has a destroy method */\n\tif (cobj->destroy != RT_NULL) {\n\t\t/* Call the destroy method */\n\t\tresult = cobj->destroy(cobj);\n\t}\n\n\t/* Delete the object */\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 47.47356984555898}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result;\n    struct rt_object_information *information;\n    struct rt_object *object;\n    struct rt_custom_object *cobj;\n\n    /* parameter check */\n    RT_ASSERT(obj != RT_NULL);\n\n    object = (struct rt_object *)obj;\n    information = (struct rt_object_information *)object->type;\n\n    /* object check */\n    RT_ASSERT(information->object_size >= sizeof(struct rt_custom_object));\n    RT_ASSERT(information->type == RT_Object_Class_Custom);\n\n    cobj = (struct rt_custom_object *)object;\n\n    /* destroy method check */\n    if (cobj->destroy != RT_NULL)\n        result = cobj->destroy(cobj);\n    else\n        result = RT_EOK;\n\n    /* delete object */\n    rt_object_delete(object);\n\n    return result;\n}", "CodeBleu_score": 49.431297497908325}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\tstruct rt_custom_object *cobj;\n\n\tRT_ASSERT(obj != RT_NULL);\n\n\tcobj = (struct rt_custom_object *)obj;\n\n\t/* check object type */\n\tRT_ASSERT(cobj->type == RT_Object_Class_Custom);\n\n\tif (cobj->destroy != RT_NULL)\n\t\tresult = cobj->destroy(cobj);\n\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 56.0879591768036}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t tid;\n\n    tid = rt_thread_self();\n\n    rt_enter_critical();\n    rt_thread_close(tid);\n    rt_schedule();\n}", "CodeBleu_score": 28.007107334535725}, {"code": "static void _thread_exit(void){\n\t    /* enter a critical section */\n    rt_enter_critical();\n\n    /* get current thread */\n    rt_thread_t thread = rt_thread_self();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* leave the critical section */\n    rt_exit_critical_safe(RT_TRUE);\n\n    /* do a context switch */\n    rt_schedule();\n\n    /* never reach here */\n}", "CodeBleu_score": 59.144773118413475}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\tregister rt_base_t temp;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* disable interrupt */\n\ttemp = rt_enter_critical();\n\n\t/* change thread status */\n\tthread->stat = RT_THREAD_CLOSE;\n\n\t/* add to defunct thread list */\n\trt_thread_defunct_enqueue(thread);\n\n\t/* enable interrupt */\n\trt_exit_critical_safe(temp);\n\n\t/* do the schedule */\n\trt_schedule();\n\n\t/* never reach here */\n\tRT_ASSERT(0);\n}", "CodeBleu_score": 61.6982558652954}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n\n    RT_ASSERT(parameter != RT_NULL);\n\n    thread = (struct rt_thread *)parameter;\n\n    rt_sched_lock();\n\n    /* thread checking */\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread timeout: 0x%08x\n\", thread));\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n    RT_ASSERT(thread->error == RT_EOK);\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_sched_thread_is_suspended(thread);\n    rt_sched_insert_thread(thread);\n\n    /* reschedule */\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 61.83853080366744}, {"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\tregister rt_base_t temp;\n\n\tthread = (struct rt_thread *)parameter;\n\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(thread->stat != RT_THREAD_CLOSE);\n\n\trt_sched_lock();\n\n\tif (thread->stat != RT_THREAD_SUSPEND) {\n\t\trt_sched_unlock();\n\t\treturn;\n\t}\n\n\t/* set error number */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* insert to schedule ready list */\n\trt_sched_insert_thread(thread);\n\n\t/* do a schedule */\n\trt_sched_unlock_n_resched();\n}", "CodeBleu_score": 56.62204378020728}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n\n    RT_ASSERT(parameter != RT_NULL);\n    thread = (struct rt_thread *)parameter;\n\n    /* thread checking */\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* thread is not suspended */\n    if (thread->stat != RT_THREAD_SUSPENDED) return;\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to schedule ready list */\n    rt_sched_insert_thread(thread);\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    /* do a schedule */\n    rt_schedule();\n\n    return;\n}", "CodeBleu_score": 53.71578486994789}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_mutex_t mutex;\n    rt_list_t *l, *n;\n\n    RT_ASSERT(thread != RT_NULL);\n\n    /* lock thread spinlock */\n    rt_spin_lock_irqsave(&thread->spinlock);\n\n    /* remove thread from mutex's waiting list */\n    if (thread->pending_object != RT_NULL) {\n        mutex = (rt_mutex_t)thread->pending_object;\n        rt_list_for_each_safe(l, n, &mutex->parent.suspended_list) {\n            if (rt_object_get_type(rt_list_entry(l, struct rt_object, list)) == RT_Object_Class_Thread) {\n                if (rt_list_entry(l, struct rt_object, list) == &(thread->parent.list)) {\n                    rt_list_remove(l);\n                    thread->pending_object = RT_NULL;\n                    break;\n                }\n            }\n        }\n    }\n\n    /* release all mutexes the thread has taken */\n    while (!rt_list_isempty(&thread->mutex_list)) {\n        mutex = rt_list_entry(thread->mutex_list.next,\n                              struct rt_mutex, parent.list);\n        rt_mutex_release(mutex);\n    }\n\n    /* unlock thread spinlock */\n    rt_spin_unlock_irqrestore(&thread->spinlock);\n}", "CodeBleu_score": 50.81020227578457}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_mutex_t mutex;\n    rt_list_t *node;\n\n    rt_spin_lock_irqsave(&(thread->spinlock));\n\n    if (thread->pending_object != RT_NULL) {\n        mutex = (rt_mutex_t)thread->pending_object;\n\n        /* remove from the mutex's waiting list */\n        rt_list_remove(&(thread->tlist));\n        thread->pending_object = RT_NULL;\n\n        /* clear the mutex's owner */\n        mutex->owner = RT_NULL;\n\n        /* remove from the thread's mutex list */\n        rt_list_remove(&(mutex->mlist));\n    }\n\n    /* release all mutexes the thread has taken */\n    while (thread->mutex_list != RT_NULL) {\n        node = thread->mutex_list;\n        mutex = rt_list_entry(node, struct rt_mutex, mlist);\n\n        /* remove from the thread's mutex list */\n        rt_list_remove(thread->mutex_list);\n\n        /* clear the mutex's owner */\n        mutex->owner = RT_NULL;\n\n        /* release mutex */\n        rt_mutex_release(mutex);\n    }\n\n    rt_spin_unlock_irqrestore(&(thread->spinlock));\n}", "CodeBleu_score": 57.53208110247691}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t lock_state;\n    rt_list_t *l;\n    rt_mutex_t mutex;\n\n    RT_ASSERT(thread != RT_NULL);\n\n    lock_state = rt_spin_lock_irqsave(&thread->spinlock);\n\n    /* has waiting object */\n    if (thread->pending_object != RT_NULL) {\n        /* waiting on a mutex */\n        if (rt_object_get_type(thread->pending_object) == RT_Object_Class_Mutex) {\n            mutex = (rt_mutex_t)thread->pending_object;\n\n            /* remove from mutex's waiting list */\n            rt_list_remove(&thread->tlist);\n            thread->pending_object = RT_NULL;\n\n            /* release mutex */\n            rt_mutex_release(mutex);\n        }\n    }\n\n    /* release all mutexes */\n    l = &thread->mutex_list;\n    while (!rt_list_isempty(l)) {\n        /* get mutex */\n        mutex = rt_list_entry(l->next, rt_mutex_t, parent.list);\n\n        /* remove from mutex's taken list */\n        rt_list_remove(&mutex->parent.list);\n\n        /* release mutex */\n        rt_mutex_release(mutex);\n    }\n\n    rt_spin_unlock_irqrestore(&thread->spinlock, lock_state);\n}", "CodeBleu_score": 56.61383464645969}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type(&thread->parent) == RT_Object_Class_Thread);\n\n    LOG_D(\"startup thread: %.*s\", RT_NAME_MAX, thread->name);\n    LOG_D(\"thread priority: %d\", thread->init_priority);\n\n    /* calculate priority attribute */\n    rt_sched_ready(thread);\n\n    /* reset thread stat */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    rt_sched_thread_startup(thread);\n\n    result = RT_EOK;\n\n    return result;\n}", "CodeBleu_score": 53.80537801662372}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type(&thread->parent) == RT_Object_Class_Thread);\n\n    LOG_D(\"startup thread: %.*s\", RT_NAME_MAX, thread->name);\n    LOG_D(\"startup thread priority: %d\", thread->init_priority);\n\n    thread->current_priority = thread->init_priority;\n    thread->number_mask = 0;\n    thread->stat = RT_THREAD_SUSPEND;\n\n    rt_sched_thread_startup(thread);\n\n    return RT_EOK;\n}", "CodeBleu_score": 55.88130662110935}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    register rt_base_t temp;\n    register rt_base_t value;\n    register rt_base_t i;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type(&thread->parent) == RT_Object_Class_Thread);\n\n    /* set to suspend state */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* insert to schedule ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* enable interrupt */\n    temp = rt_hw_interrupt_disable();\n\n    /* increase thread number */\n    ++rt_thread_number;\n\n    /* reset thread error number */\n    thread->error = RT_EOK;\n\n    /* reset thread priority */\n    thread->current_priority = thread->init_priority;\n\n    /* reset thread time slice */\n    thread->remaining_time_slice = 0;\n\n    /* reset thread tick */\n    thread->tick = 0;\n\n    /* reset thread flag */\n    thread->flag = 0;\n\n    /* reset thread event */\n    thread->event_set = 0;\n    thread->event_info = 0;\n\n    /* reset thread timer */\n    rt_timer_control(&(thread->thread_timer),\n                     RT_TIMER_CTRL_SET_TIME,\n                     &thread->init_tick);\n\n    /* init cleanup function */\n    thread->cleanup = RT_NULL;\n\n    /* init thread stack pointer */\n    thread->sp = thread->stack_addr + thread->stack_size;\n    *((rt_uint32_t *)thread->sp) = (rt_uint32_t)RT_NULL;             /* R0 */\n    *((rt_uint32_t *)thread->sp - 1) = (rt_uint32_t)thread->entry;   /* PC */\n    *((rt_uint32_t *)thread->sp -", "CodeBleu_score": 42.37989577241353}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_timer_t timer;\n    rt_list_t *l;\n    rt_list_t *level;\n\n    if (rt_list_isempty(&timer_list[TIMER_LEVEL - 1])) {\n        return -RT_ETIMEOUT;\n    }\n\n    /* get the first timer */\n    l = timer_list[TIMER_LEVEL - 1].next;\n    timer = rt_list_entry(l, struct rt_timer, row[TIMER_LEVEL - 1]);\n    *timeout_tick = timer->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 64.99480474893787}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *l;\n    struct rt_timer *timer;\n    rt_tick_t tick;\n\n    /* get the first timer */\n    l = rt_list_first(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n    if (l != RT_NULL) {\n        timer = rt_list_entry(l, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n        /* set timeout tick */\n        tick = timer->timeout_tick;\n        *timeout_tick = tick;\n\n        return RT_EOK;\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 68.3262018959209}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *l;\n    struct rt_timer *timer;\n\n    /* get the first timer */\n    l = timer_list[0].next;\n    if (l == &(timer_list[0])) {\n        return -RT_ETIMEOUT;\n    }\n\n    /* set timeout tick */\n    timer = rt_list_entry(l, struct rt_timer, list);\n    *timeout_tick = timer->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 53.71033016497662}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* allocate timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* init timer object */\n    rt_timer_init(timer,\n                  name,\n                  timeout,\n                  parameter,\n                  time,\n                  flag);\n\n    return timer;\n}", "CodeBleu_score": 64.03267896366525}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* allocate timer */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    /* initialize timer */\n    _timer_init(timer,\n                name,\n                timeout,\n                parameter,\n                time,\n                flag);\n\n    return timer;\n}", "CodeBleu_score": 60.32716400345751}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t  struct rt_timer *timer;\n  rt_base_t lock;\n\n  /* allocate a timer object */\n  timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);\n  if (timer == RT_NULL) {\n    return RT_NULL;\n  }\n\n  /* initialize timer object */\n  timer->timeout_func = timeout;\n  timer->parameter    = parameter;\n  timer->time         = time;\n  timer->flag         = flag;\n\n  /* insert timer object to system object list */\n  rt_list_insert_before(&(rt_object_system.object_list), &(timer->list));\n\n  /* enable interrupt */\n  lock = rt_hw_interrupt_disable();\n  rt_timer_insert(timer);\n  rt_hw_interrupt_enable(lock);\n\n  return timer;\n}", "CodeBleu_score": 64.66877175800234}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 76.62963690977166}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 74.78282146881165}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tfor _, handler := range a.handlers {\n\t\trec := httptest.NewRecorder()\n\t\thandler.ServeHTTP(rec, req)\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 91.02736890464543}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"\" || path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := a.Asset(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\text := filepath.Ext(path)\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unsupported file extension %s\", ext))\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 56.94366809674689}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := a.Asset(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\text := strings.Split(path, \".\")\n\tswitch ext[len(ext)-1] {\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 60.508386165504845}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := a.Assets.Open(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer asset.Close()\n\text := filepath.Ext(path)\n\tres.Header().Set(\"Content-Type\", contentType[ext])\n\tb, err := ioutil.ReadAll(asset)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tres.Write(b)\n}", "CodeBleu_score": 53.106556095953174}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(`{\"error\": \"no robot found with name %s\"}`, robotName)))\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\tjsonConnections := []map[string]interface{}{}\n\n\tconnections.Each(func(name string, conn gobot.Connection) {\n\t\tjsonConnections = append(jsonConnections, map[string]interface{}{\n\t\t\t\"name\": name,\n\t\t\t\"type\": conn.Name(),\n\t\t\t\"port\": conn.Port(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, jsonConnections)\n}", "CodeBleu_score": 56.41874571518174}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"{\\\"error\\\": \\\"No robot named %s found\\\"}\", robotName)))\n\t\treturn\n\t}\n\n\tconnections := make([]map[string]interface{}, 0)\n\trobot.Connections().Each(func(name string, c gobot.Connection) {\n\t\tconnection := make(map[string]interface{})\n\t\tconnection[\"name\"] = name\n\t\tconnection[\"adaptor\"] = c.Name()\n\t\tconnection[\"port\"] = c.Port()\n\t\tconnection[\"address\"] = c.Address()\n\n\t\tconnections = append(connections, connection)\n\t})\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(gobot.ToJSON(connections)))\n}", "CodeBleu_score": 42.85526391774725}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(`{\"error\": \"No robot found with the name %s\"}`, robotName)))\n\t\treturn\n\t}\n\n\tconnections := []gobot.Connection{}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, c)\n\t})\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(gobot.NewJSONEncoder(os.Stdout).Encode(connections)))\n}", "CodeBleu_score": 46.544258961514316}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), 401)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tif pair[0] != username || pair[1] != password {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 48.80198600916274}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif !secureCompare(r.Header.Get(\"Authorization\"), \"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 62.04773024588577}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), 401)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\t// OK\n\t}\n}", "CodeBleu_score": 48.952187273386656}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope * float64(fromMin)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 58.82285146009757}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope * fromMin\n\treturn func(input float64) (value int)  {\n\t\tvalue = int(math.Min(math.Max(input*slope+intercept, float64(toMin)), float64(toMax)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 57.93653010278354}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope * fromMin\n\treturn func(input float64) (value int)  {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 59.97782768347244}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"nil connection\")\n\t}\n\n\tif !a.Connection.AnalogRead {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.Connection.AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 50.87795693754686}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"no connection\")\n\t}\n\n\tif !a.Connection().AnalogRead {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog read\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.sensorCfg.scale.Apply(float64(raw))\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 56.88884316317815}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"no connection\")\n\t}\n\n\tif !a.Connection().AnalogRead {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) * a.sensorCfg.scale\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 56.11204053241193}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - m * float64(fromMin)\n\treturn func(fromValue int) float64 {\n\t\treturn m * float64(fromValue) + n\n\t}\n}", "CodeBleu_score": 51.65490733382836}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - m*float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 51.822128377076005}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - float64(fromMin) * m\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 55.07382452912394}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\toptions := NewGrovePiezoVibrationSensorDriverOptions()\n\tfor _, o := range opts {\n\t\tif o, ok := o.(func(*GrovePiezoVibrationSensorDriverOptions)); ok {\n\t\t\to(&options)\n\t\t}\n\t}\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: options.Name,\n\t\tconnection: &gobot.Connection{\n\t\t\tName:  \"GrovePiezoVibrationSensorDriver\",\n\t\t\tAdaptor: a.(gobot.AdaptorInterface),\n\t\t\tDigitalWriter: a.(gobot.DigitalWriter),\n\t\t},\n\t\tpin: pin,\n\t\tvibrationEvent: \"vibration\",\n\t\tvibrationThreshold: 1000,\n\t}\n\td.AddEvent(d.vibrationEvent)\n\td.AddEvent(d.Event(\"data\"))\n\td.connection.DigitalWriter.PinMode(pin, gobot.INPUT)\n\tgobot.On(d.Event(\"data\"), func(data interface{}) {\n\t\tif data.(int) > d.vibrationThreshold {\n\t\t\tgobot.Publish(d.Event(d.vibrationEvent), data)\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 42.34119491167068}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tconnector: &gobot.AnalogSensor{\n\t\t\tname:     gobot.DefaultName(\"AnalogSensor\"),\n\t\t\tpin:      pin,\n\t\t\tinterval: 10 * time.Millisecond,\n\t\t\tactive:   true,\n\t\t\treader:   a,\n\t\t},\n\t\tEventer: gobot.NewEventer(),\n\t\tmutex:   &sync.Mutex{},\n\t}\n\n\tfor _, option := range opts {\n\t\tif s, ok := option.(string); ok {\n\t\t\td.name = s\n\t\t} else if s, ok := option.(time.Duration); ok {\n\t\t\td.connector.interval = s\n\t\t}\n\t}\n\n\td.AddEvent(VibrationEvent)\n\td.connector.On(gobot.DataEvent, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(VibrationEvent, data)\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 49.49945988438558}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\toptions := NewGrovePiezoVibrationSensorDriverOptions()\n\tfor _, o := range opts {\n\t\tif o, ok := o.(func(*GrovePiezoVibrationSensorDriverOptions)); ok {\n\t\t\to(&options)\n\t\t}\n\t}\n\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tconnection: &gobot.AnalogSensor{\n\t\t\tname:       gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\t\tpin:        pin,\n\t\t\tconnection: a,\n\t\t},\n\t\tEventer: gobot.NewEventer(),\n\t}\n\n\td.AddEvent(VibrationEvent)\n\td.AddEvent(ErrorEvent)\n\n\td.connection.(*gobot.AnalogSensor).\n\t\tOn(gobot.DataEvent, func(data interface{}) {\n\t\t\tif data.(int) > 1000 {\n\t\t\t\td.Publish(VibrationEvent, data)\n\t\t\t}\n\t\t})\n\n\td.connection.(*gobot.AnalogSensor).\n\t\tOn(gobot.ErrorEvent, func(data interface{}) {\n\t\t\td.Publish(ErrorEvent, data)\n\t\t})\n\n\treturn d\n}", "CodeBleu_score": 43.75999943706784}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := time.Duration(1e9 / hz)\n\ttempo := time.Duration(60e9 / d.BPM)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0; i < int(duration*1e9/tempo); i++ {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(tonePeriod)\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(tonePeriod)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 51.50172916162291}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod, err := d.TonePeriod(hz)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttempo := float64(60) / duration\n\tbeat := float64(period) / tempo\n\n\tfor i := 0; i < int(duration*tempo); i++ {\n\t\td.On()\n\t\ttime.Sleep(time.Duration(beat) * time.Millisecond)\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(beat) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.00562431764352}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn fmt.Errorf(\"invalid frequency (%v)\", hz)\n\t}\n\tif duration <= 0 {\n\t\treturn fmt.Errorf(\"invalid duration (%v)\", duration)\n\t}\n\tif d.tempo <= 0 {\n\t\treturn fmt.Errorf(\"invalid tempo (%v)\", d.tempo)\n\t}\n\n\t// calculate the tone period\n\tperiod := time.Duration(1e9 / hz)\n\t// calculate the tempo period\n\ttempoPeriod := time.Duration(60e9 / d.tempo)\n\n\t// calculate the number of ticks to make up the duration\n\tticks := int(duration / tempoPeriod.Seconds())\n\tif ticks <= 0 {\n\t\treturn fmt.Errorf(\"invalid duration (%v)\", duration)\n\t}\n\n\t// calculate the number of ticks per period\n\tticksPerPeriod := int(tempoPeriod / period)\n\tif ticksPerPeriod <= 0 {\n\t\treturn fmt.Errorf(\"invalid period (%v)\", period)\n\t}\n\n\t// calculate the number of periods per tick\n\tperiodsPerTick := int(period / tempoPeriod)\n\tif periodsPerTick <= 0 {\n\t\treturn fmt.Errorf(\"invalid tempo period (%v)\", tempoPeriod)\n\t}\n\n\t// generate the tone\n\tfor i := 0; i < ticks; i++ {\n\t\tfor j := 0; j < ticksPerPeriod; j++ {\n\t\t\t// turn the buzzer on\n\t\t\tif err := d.On(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// wait for the tone period\n\t\t\ttime.Sleep(period)\n\t\t\t// turn the buzzer off\n\t\t\tif err := d.Off(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// wait for the tempo period\n\t\t\ttime.Sleep(tempoPeriod / time.Duration(periodsPerTick))\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 48.05748064345959}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.SleepPin == nil {\n\t\treturn errors.New(\"No sleep pin configured\")\n\t}\n\tif !d.IsRunning {\n\t\treturn errors.New(\"Driver is not running\")\n\t}\n\td.stop()\n\terr := d.SleepPin.Low()\n\tif err != nil {\n\t\treturn err\n\t}\n\td.IsSleeping = true\n\treturn nil\n}", "CodeBleu_score": 46.06372766398577}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.433985411309234}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn errors.New(\"Sleep pin not set\")\n\t}\n\tif err := d.stopIfRunning(); err != nil {\n\t\treturn err\n\t}\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 45.63958047563763}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpin := a.sys.NewAnalogPin(id)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 34.963288439742776}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor not initialized\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = a.sys.NewAnalogPin(pin.Pin, pin.Aref)\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 55.57963727459578}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin := a.sys.NewAnalogPin(id)\n\tif err := pin.Start(); err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 47.36265199579759}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, gpio.Out)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(gpio.Level(val))\n}", "CodeBleu_score": 68.73496146515777}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 64.57188961529106}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, gpio.Out)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(int(val))\n}", "CodeBleu_score": 76.23285686231671}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor not connected to any pins\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\tfor _, option := range opts {\n\t\t\toption(pin)\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\tif pin, err := a.translate(id); err == nil {\n\t\tpin.ApplyOptions(opts...)\n\t\ta.pins[id] = pin\n\t\treturn pin, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor could not find pin %s\", id)\n}", "CodeBleu_score": 38.45357645016884}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor is not connected to any pins\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\tfor _, o := range opts {\n\t\t\to(p)\n\t\t}\n\t\treturn p, nil\n\t}\n\n\tchip, line, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := a.sys.NewDigitalPin(chip, line)\n\tif err := p.Init(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, o := range opts {\n\t\to(p)\n\t}\n\n\ta.pins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 52.12852924084309}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor is not connected\")\n\t}\n\n\tif _, ok := a.pins[id]; !ok {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin, err := a.sys.NewDigitalPin(chip, line, opts...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.pins[id] = pin\n\t} else {\n\t\ta.pins[id].ApplyOptions(opts...)\n\t}\n\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 55.379552895496396}]}
