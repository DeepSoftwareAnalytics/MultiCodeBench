{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    return _pimpl->CallAndWait<std::vector<std::string>>([=]() {\n        return _pimpl->GetRequiredFiles(folder, download);\n    });\n}", "CodeBleu_score": 26.42232179737941}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    return _pimpl->CallAndWait<std::vector<std::string>>(\"GetRequiredFiles\", folder, download);\n}", "CodeBleu_score": 23.041438537535115}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    // TODO: Implement this function\n    return std::vector<std::string>();\n}", "CodeBleu_score": 8.892157260963078}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n  // Check for valid parent\n  if (parent == rpc::ActorId()) {\n    throw std::invalid_argument(\n          \"Actor description is missing a parent\");\n  }\n\n  // Check for valid attachment type\n  if (attachment_type != rpc::AttachmentType::Rigid &&\n      attachment_type != rpc::AttachmentType::SpringArm &&\n      attachment_type != rpc::AttachmentType::SpringArmGhost) {\n    throw std::invalid_argument(\n          \"Attachment type must be Rigid, SpringArm, or SpringArmGhost\");\n  }\n\n  // Check for valid socket name\n  if (attachment_type == rpc::AttachmentType::Rigid && !socket_name.empty()) {\n    throw std::invalid_argument(\n          \"Attachment type must be Rigid to use a socket\");\n  }\n\n  // Check for valid transformation\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    geom::Vector3D translation = transform.location;\n    geom::Vector3D rotation = transform.rotation.MakeSafeUnitVector();\n    geom::Vector3D scale = transform.scale;\n\n    // Check for valid translation\n    if (std::fabs(translation.x) < std::numeric_limits<float>::epsilon() &&\n        std::fabs(translation.y) < std::numeric_limits<float>::epsilon() &&\n        std::fabs(translation.z) < std::numeric_limits<float>::epsilon()) {\n      throw std::invalid_argument(\n            \"Translation must not be zero for a SpringArm or SpringArmGhost\");\n    }\n\n    // Check for valid rotation\n    if (std::fabs(rotation.x) < std::numeric_limits<float>::epsilon() &&\n        std::fabs(rotation.y) < std::numeric_limits<float>::epsilon() &&\n        std::fabs(rotation.z) < std::numeric_limits<float>::epsilon()) {\n      throw std::invalid_argument(\n            \"Rotation must not be zero for", "CodeBleu_score": 47.69774509268557}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.SquaredLength() < 0.001f) {\n      transform.location.x = 0.001f;\n      transform.location.y = 0.001f;\n      transform.location.z = 0.001f;\n      log_warning(\n          \"The provided transformation for a SpringArm or SpringArmGhost actor is \"\n          \"ill-formed. It has been corrected to a valid transformation.\");\n    }\n  }\n  return SpawnActorWithParentImpl(\n      description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 44.86654372577625}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n      if (transform.location.IsZero(std::numeric_limits<float>::epsilon())) {\n        if (transform.rotation.IsZero(std::numeric_limits<float>::epsilon())) {\n          throw std::invalid_argument(\n              \"The provided transform is ill-formed. \"\n              \"The translation and rotation are both zero.\");\n        } else {\n          if (transform.rotation.IsAligned(geom::Vector3D(0.0f, 0.0f, 1.0f))) {\n            throw std::invalid_argument(\n                \"The provided transform is ill-formed. \"\n                \"The translation is zero but the rotation is not aligned with \"\n                \"the z-axis.\");\n          }\n        }\n      }\n    }\n    return _pimpl->CallAndWait<rpc::Actor>(\n        [=]() {\n          return _client.SpawnActorWithParent(\n              description, transform, parent, attachment_type, socket_name);\n        },\n        timeout_);\n  }", "CodeBleu_score": 53.134358944980455}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n    // Get the token for the G-buffer.\n    auto token = _pimpl->streaming_client.GetGBufferToken(ActorId, GBufferId);\n\n    // Copy the token data.\n    std::vector<unsigned char> token_data(token.size);\n    std::memcpy(token_data.data(), token.data.get(), token_data.size());\n\n    // Subscribe to the streaming client.\n    _pimpl->streaming_client.Subscribe(\n        std::move(token_data),\n        [callback](Buffer buffer) {\n            callback(std::move(buffer));\n        });\n}", "CodeBleu_score": 56.65502718975599}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t    // Get the token for the G-buffer.\n    auto token = _pimpl->streaming_client.GetGBufferToken(ActorId, GBufferId);\n    // Wait for the token to be ready.\n    if (!token.WaitFor(kDefaultTimeout)) {\n        UE_LOG(LogCarla, Error, TEXT(\"Timeout while waiting for G-buffer token!\"));\n        return;\n    }\n    // Copy the token data.\n    std::vector<unsigned char> token_data;\n    token_data.resize(token.GetResult().size);\n    std::memcpy(token_data.data(), token.GetResult().data, token_data.size());\n    // Subscribe to the streaming client.\n    _pimpl->streaming_client.Subscribe(\n        std::move(token_data),\n        [callback](Buffer buffer) {\n            callback(std::move(buffer));\n        });\n}", "CodeBleu_score": 52.046511540089014}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t    // Get the token data for the G-buffer.\n    const auto token_data = _pimpl->streaming_client.GetGBufferToken(ActorId, GBufferId);\n\n    // Copy the token data to a new vector.\n    const auto token = std::vector<unsigned char>(token_data.size);\n    std::memcpy(token.data(), token_data.data, token_data.size);\n\n    // Subscribe to the streaming client using the provided callback function.\n    _pimpl->streaming_client.Subscribe(token, std::move(callback));\n}", "CodeBleu_score": 61.51382128708403}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation;\n  if (_walker_navigation.compare_exchange_strong(navigation, std::make_shared<WalkerNavigation>())) {\n    navigation->SetEpisode(this);\n  }\n  return navigation;\n}", "CodeBleu_score": 34.66659018906975}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    if (_walker_navigation == nullptr) {\n        std::shared_ptr<WalkerNavigation> new_nav = std::make_shared<WalkerNavigation>();\n        if (_walker_navigation.compare_exchange_strong(new_nav, new_nav)) {\n            return new_nav;\n        }\n    }\n    return _walker_navigation;\n}", "CodeBleu_score": 45.9632270567339}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> walker_navigation = _walker_navigation.load();\n  while (walker_navigation == nullptr) {\n    walker_navigation = std::make_shared<WalkerNavigation>();\n    if (_walker_navigation.compare_exchange_strong(walker_navigation, walker_navigation)) {\n      return walker_navigation;\n    }\n  }\n  return walker_navigation;\n}", "CodeBleu_score": 50.83440342350478}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  using namespace std::chrono;\n  auto start_time = system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    if (system_clock::now() - start_time > timeout.to_chrono()) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 36.21223207830796}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  using namespace std::chrono;\n  using namespace std::chrono_literals;\n  const auto start_time = system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    if (system_clock::now() - start_time > timeout.to_chrono()) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 37.923181568407294}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  using namespace std::chrono;\n  auto start_time = system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    if (system_clock::now() - start_time > timeout.to_chrono()) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 36.21223207830796}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  std::string episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n  EpisodeProxy episode = _client.GetEpisode(episode_id);\n  episode.WaitForState(rpc::EpisodeState::Ready);\n  return episode;\n}", "CodeBleu_score": 25.70527315053253}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // Check if we are already connected to an episode\n  if (_episode != nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Simulator already connected to an episode!\"));\n    return EpisodeProxy(std::move(_episode));\n  }\n\n  // Create the new episode\n  auto episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Wait for the episode to be ready\n  UE_LOG(LogCarla, Log, TEXT(\"Waiting for episode %d to be ready...\"), episode.GetId());\n  _episode = _client.GetEpisodeSettings(episode.GetId());\n  _episode->WaitForState(carla::rpc::EpisodeState::Ready);\n  UE_LOG(LogCarla, Log, TEXT(\"Episode %d is ready!\"), episode.GetId());\n\n  // Return the episode\n  return EpisodeProxy(std::move(_episode));\n}", "CodeBleu_score": 46.413080449404745}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  if (IsPaused()) {\n    throw std::runtime_error(\"Cannot load a new episode while the simulator is paused\");\n  }\n  if (IsConnected()) {\n    throw std::runtime_error(\"Cannot load a new episode while connected to a running episode\");\n  }\n\n  // Create a new episode\n  _episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Wait for the episode to start\n  _episode->WaitForState(EpisodeState::Started, _client.GetTimeout());\n  return _episode;\n}", "CodeBleu_score": 35.9831848383666}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = GetWalker(controller.GetId());\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n  DEBUG_ASSERT(_episode != nullptr);\n  _episode->CreateNavigationIfMissing();\n  _episode->GetNavigation()->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 59.626483220322555}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  DEBUG_ASSERT(_episode != nullptr);\n  auto *walker = _episode->GetWalker(controller.GetDisplayId());\n  if (walker == nullptr) {\n    throw std::runtime_error(\"walker not found\");\n  }\n  _episode->CreateNavigationIfMissing();\n  _episode->GetNavigation()->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 58.595673269727385}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto *walker = GetWalker(controller.GetId());\n  if (!walker) {\n    throw std::runtime_error(\"Walker not found: \" + controller.GetId());\n  }\n  DEBUG_ASSERT(_episode != nullptr);\n  if (!_episode->Navigation()) {\n    _episode->CreateNavigationIfMissing();\n  }\n  _episode->Navigation()->RegisterWalker(walker, controller.GetId());\n}", "CodeBleu_score": 58.020520957319185}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    // Make sure the blueprint is valid\n    if (!blueprint.IsValid()) {\n        throw_exception(std::invalid_argument(\"Invalid actor blueprint\"));\n    }\n\n    // Make sure the transform is valid\n    if (!transform.is_valid()) {\n        throw_exception(std::invalid_argument(\"Invalid actor transform\"));\n    }\n\n    // Make sure the parent actor is valid\n    if (parent != nullptr) {\n        if (!parent->IsAlive()) {\n            throw_exception(std::invalid_argument(\"Parent actor is not valid\"));\n        }\n\n        if (parent->GetEpisode() != GetCurrentEpisode()) {\n            throw_exception(std::invalid_argument(\"Parent actor is not in the same episode\"));\n        }\n    }\n\n    // Make sure the attachment type is valid\n    if (attachment_type != rpc::AttachmentType::Rigid &&\n        attachment_type != rpc::AttachmentType::SpringArm) {\n        throw_exception(std::invalid_argument(\"Invalid attachment type\"));\n    }\n\n    // Make sure the garbage collection policy is valid\n    if (gc != GarbageCollectionPolicy::Inherit &&\n        gc != GarbageCollectionPolicy::Enabled &&\n        gc != GarbageCollectionPolicy::Disabled) {\n        throw_exception(std::invalid_argument(\"Invalid garbage collection policy\"));\n    }\n\n    // Make sure the socket name is valid\n    if (!socket_name.empty() &&\n        !blueprint.GetActorDescription().CanAttachTo(socket_name)) {\n        throw_exception(std::invalid_argument(\"Invalid socket name\"));\n    }\n\n    // Make sure the episode is valid\n    if (!GetCurrentEpisode().IsValid()) {\n        throw_exception(std::runtime_error(\"Episode is not valid\"));\n    }\n\n    // Make sure the episode is not paused\n    if (GetCurrentEpisode().IsPaused()) {\n        throw_exception(std::runtime_error(\"Episode is paused\"));\n    }\n\n    // Make sure the episode is not in the process of ending\n    if (GetCurrentEpisode().IsEnding()) {\n        throw_exception(std::runtime_error(\"Episode is", "CodeBleu_score": 42.77641137130789}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  // Get the current episode\n  auto episode = GetCurrentEpisode();\n  if (!episode) {\n    log_debug(\"Simulator::SpawnActor: no episode\");\n    return nullptr;\n  }\n\n  // Make the actor description\n  ActorDescription description;\n  description.set_id(ActorId::Create());\n  description.set_name(blueprint.GetName());\n  description.set_parent_id(parent ? parent->GetId() : ActorId::Null());\n  description.set_attachment_type(attachment_type);\n  description.set_attachment_socket(socket_name);\n  description.set_transform(transform);\n  description.set_is_alive(true);\n  description.set_is_visible(true);\n  description.set_is_locked(blueprint.IsLocked());\n  description.set_semantic_tags(blueprint.GetTags());\n  description.set_is_persistent(blueprint.IsPersistent());\n  description.set_is_autonomous(blueprint.IsAutonomous());\n  description.set_is_social(blueprint.IsSocial());\n  description.set_is_hero(blueprint.IsHero());\n  description.set_is_invincible(blueprint.IsInvincible());\n  description.set_is_visible(blueprint.IsVisible());\n  description.set_is_autopilot(blueprint.IsAutopilot());\n  description.set_is_avoiding_collision(blueprint.IsAvoidingCollision());\n  description.set_is_avoiding_collision_enabled(blueprint.IsAvoidingCollisionEnabled());\n\n  // Create the actor\n  auto actor = episode->SpawnActor(description);\n  if (!actor) {\n    log_debug(\"Simulator::SpawnActor: failed to spawn actor\");\n    return nullptr;\n  }\n\n  // Register the actor in the current episode\n  if (!episode->RegisterActor(actor)) {\n    log_debug(\"Simulator::SpawnActor: failed to register actor\");\n    return nullptr", "CodeBleu_score": 39.16415326690769}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  REPEAT_IF_NOT_SUCCESS(\n      _client.SpawnActorWithParent(\n          blueprint,\n          transform,\n          parent ? parent->GetId() : 0,\n          attachment_type,\n          socket_name,\n          &_episode->GetId(),\n          &_episode->GetCurrentFrame(),\n          &_episode->GetCurrentTimestamp(),\n          &_episode->GetCurrentWeather(),\n          &_episode->GetCurrentMapInfo(),\n          &_episode->GetCurrentState()));\n  const auto actor = _episode->GetActorById(result->GetId());\n  if (actor == nullptr) {\n    throw_exception(std::runtime_error(\"Actor could not be spawned\"));\n  }\n\n  if (gc == GarbageCollectionPolicy::Inherit) {\n    actor->SetGarbageCollectionPolicy(parent ? parent->GetGarbageCollectionPolicy() : GarbageCollectionPolicy::Inherit);\n  } else {\n    actor->SetGarbageCollectionPolicy(gc);\n  }\n\n  log_debug(\"Spawned actor with id \" + std::to_string(actor->GetId()));\n\n  return actor;\n}", "CodeBleu_score": 46.195969298066345}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n    if (!episode_) {\n        UE_LOG(LogCarla, Error, TEXT(\"Simulator::SubscribeToSensor: episode not set!\"));\n        return;\n    }\n\n    auto token = sensor.GetActorDescription().GetStreamToken();\n    if (!token.has_value()) {\n        UE_LOG(LogCarla, Error, TEXT(\"Simulator::SubscribeToSensor: sensor has no stream token!\"));\n        return;\n    }\n\n    auto stream_id = sensor.GetActorDescription().GetStreamToken().value();\n    auto stream_type = sensor.GetActorDescription().GetStreamType();\n\n    client_.SubscribeToStream(stream_id, stream_type, [this, callback](auto buffer) {\n        auto data = sensor::Deserializer::Deserialize(std::move(buffer));\n        DEBUG_ASSERT(data.has_value());\n        data.value()->SetEpisode(episode_);\n        callback(data.value());\n    });\n}", "CodeBleu_score": 56.14020222580197}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t    DEBUG_ASSERT(_episode != nullptr);\n    _client.SubscribeToStream(\n        sensor.GetActorDescription().GetStreamToken(),\n        [this, callback](SharedPtr<sensor::SensorData> sensor_data) {\n            sensor_data->SetEpisode(this->_episode);\n            callback(sensor_data);\n        });\n}", "CodeBleu_score": 47.22264926868763}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t    if (!EpisodeProxy::IsValid()) {\n        UE_LOG(LogCarla, Warning, TEXT(\"Simulator::SubscribeToSensor: episode not valid!\"));\n        return;\n    }\n    auto sensor_id = sensor.GetActorDescription().GetStreamToken();\n    if (sensor_id == 0u) {\n        UE_LOG(LogCarla, Warning, TEXT(\"Simulator::SubscribeToSensor: sensor has no stream token!\"));\n        return;\n    }\n    auto ep = EpisodeProxy::Get();\n    auto callback_shared = std::make_shared<decltype(callback)>(std::move(callback));\n    _client.SubscribeToStream(\n        sensor_id,\n        [this, ep, callback_shared](auto buffer) {\n            auto data = sensor::Deserializer::Deserialize(buffer);\n            data->SetEpisode(ep);\n            (*callback_shared)(data);\n        });\n}", "CodeBleu_score": 55.5552476328429}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  // Load the current walkers\n  std::vector<std::shared_ptr<carla::agent::WalkerAgent>> walkers = _walker_controller->LoadWalkers(episode);\n  if (walkers.empty()) {\n    return;\n  }\n\n  // Remove any walkers that no longer exist\n  RemoveWalkersThatNoLongerExist(episode, walkers);\n\n  // Update vehicles in crowd\n  _nav.UpdateVehiclesInCrowd(walkers);\n\n  // Update crowd\n  _nav.UpdateCrowd();\n\n  // Get commands for each walker\n  std::vector<carla::agent::WalkerControl> commands;\n  commands.reserve(walkers.size());\n  for (auto walker : walkers) {\n    commands.emplace_back(carla::agent::WalkerControl{\n      _nav.GetWalkerTransform(walker),\n      _nav.GetWalkerSpeed(walker)\n    });\n  }\n\n  // Apply commands to simulator\n  _simulator.lock()->ApplyBatchSync(commands, true);\n\n  // Check if any walkers have been killed\n  CheckIfWalkerExist(episode, walkers);\n}", "CodeBleu_score": 32.624642400690455}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    std::vector<ActorId> walkers = _walkers.Load(episode->GetState());\n    if (walkers.empty()) {\n        return;\n    }\n\n    RemoveWalkersThatNoLongerExist(episode, walkers);\n\n    UpdateVehiclesInCrowd(episode);\n\n    std::vector<carla::rpc::Command> commands;\n    commands.reserve(walkers.size());\n    for (auto walker : walkers) {\n        commands.emplace_back(\n            carla::rpc::Command::ApplyVehicleControl{\n                walker,\n                _nav.GetWalkerTransform(walker).rotation.yaw,\n                _nav.GetWalkerSpeed(walker)\n            });\n    }\n    _simulator.lock()->ApplyBatchSync(commands, true);\n\n    for (auto walker : walkers) {\n        if (!_nav.IsWalkerAlive(walker)) {\n            _simulator.lock()->SetActorCollisions(walker, false);\n            _nav.RemoveAgent(walker);\n            UnregisterWalker(walker);\n            _simulator.lock()->DestroyActor(walker);\n        }\n    }\n    _nav.UpdateCrowd(episode->GetTime());\n}", "CodeBleu_score": 42.25811616607108}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  std::vector<WalkerControl> walkers = _walkers.Load();\n  if (walkers.empty()) {\n    return;\n  }\n\n  // Remove dead walkers\n  auto state = episode->GetState();\n  for (auto it = walkers.begin(); it != walkers.end();) {\n    if (!CheckIfWalkerExist(state, it->GetWalker())) {\n      it = RemoveWalker(it);\n    } else {\n      ++it;\n    }\n  }\n\n  // Update vehicles in crowd\n  UpdateVehiclesInCrowd(walkers);\n\n  // Update crowd\n  _nav.UpdateCrowd(episode->GetTime());\n\n  // Apply commands\n  std::vector<carla::rpc::Command> commands;\n  commands.reserve(walkers.size());\n  for (auto &walker : walkers) {\n    const auto &transform = _simulator.lock()->GetActorTransform(walker.GetWalker());\n    const auto speed = _nav.GetWalkerSpeed(walker.GetWalker());\n    commands.emplace_back(\n        carla::rpc::Command::ApplyVehicleControl{\n            walker.GetWalker(),\n            carla::rpc::VehicleControl{\n                speed,\n                0.0f,\n                transform.rotation.yaw,\n                carla::geom::Vector3D{},\n                false\n            }});\n  }\n\n  _simulator.lock()->ApplyBatchSync(commands, true);\n\n  // Check if walker is dead\n  for (auto &walker : walkers) {\n    if (!_simulator.lock()->IsActorAlive(walker.GetWalker())) {\n      _nav.RemoveAgent(walker.GetWalker());\n      UnregisterWalker(walker);\n      _simulator.lock()->DestroyActor(walker.GetWalker());\n    }\n  }\n}", "CodeBleu_score": 53.78668054968014}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.set_uid(uid);\n  description.set_id(id);\n  description.attributes.reserve(attributes.size());\n  for (const auto& attribute : attributes) {\n    description.attributes.push_back(attribute.MakeDescription());\n  }\n  return description;\n}", "CodeBleu_score": 66.50626820289753}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.set_uid(GetUID());\n    description.set_id(GetId());\n    description.attributes.reserve(attributes.size());\n    for (auto& attribute : attributes) {\n        description.attributes.push_back(attribute.MakeDescription());\n    }\n    return description;\n}", "CodeBleu_score": 63.482556208596755}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.set_uid(GetActorId());\n  description.set_id(GetActorId().ToString());\n  description.attributes.reserve(attributes.size());\n  for (auto& attribute : attributes) {\n    attribute.ToRPCDictionary(&description.attributes);\n  }\n  return description;\n}", "CodeBleu_score": 63.055838488890124}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t    auto result = MakeShared<BlueprintLibrary>();\n    for (const auto& pair : blueprints) {\n        if (pair.second.ContainsAttribute(name)) {\n            const auto& attribute = pair.second.GetAttribute(name);\n            if (attribute.GetValue() == value ||\n                attribute.GetRecommendedValues().Contains(value)) {\n                result->emplace(pair.first, pair.second);\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 44.989134420743326}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto &pair : blueprints) {\n    if (pair.second.ContainsAttribute(name)) {\n      const Attribute& attribute = pair.second.GetAttribute(name);\n      if (attribute.GetValue() == value ||\n          attribute.GetRecommendedValues().Contains(value)) {\n        result->blueprints.emplace(pair.first, pair.second);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 46.82356906730576}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  auto result = MakeShared<BlueprintLibrary>();\n  for (auto &pair : blueprints) {\n    if (pair.second.ContainsAttribute(name)) {\n      auto attr = pair.second.GetAttribute(name);\n      if (attr.GetValue().compare(value) == 0 ||\n          attr.GetRecommendedValues().Contains(value)) {\n        result->emplace(pair.first, pair.second);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 42.096982180928514}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string fullPath = m_baseFolder + path;\n  if (carla::FileSystem::ValidateFilePath(fullPath)) {\n    std::ofstream out(fullPath, std::ofstream::binary | std::ofstream::trunc);\n    if (out.is_open()) {\n      out.write(reinterpret_cast<char*>(content.data()), content.size());\n      out.close();\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 48.23523264828533}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string file_path = GetFilePath(path);\n  if (!carla::FileSystem::ValidateFilePath(file_path)) {\n    return false;\n  }\n  std::ofstream out(file_path, std::ios::binary | std::ios::trunc);\n  if (!out.good()) {\n    return false;\n  }\n  out.write(reinterpret_cast<char *>(content.data()), content.size());\n  out.close();\n  return true;\n}", "CodeBleu_score": 49.45579359179669}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string fullPath = GetFullPath(path);\n  if (!ValidateFilePath(fullPath)) {\n    return false;\n  }\n  std::ofstream out(fullPath, std::ios::binary | std::ios::trunc);\n  if (!out.good()) {\n    return false;\n  }\n  out.write((char*)content.data(), content.size());\n  out.close();\n  return true;\n}", "CodeBleu_score": 46.92976824648702}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto location = transform.location + parent_bounds_->GetLocation();\n  const auto yaw = transform.rotation.yaw;\n  const auto extent = parent_bounds_->GetExtent();\n\n  const auto x_left = location.x - extent.x;\n  const auto x_right = location.x + extent.x;\n  const auto y_left = location.y - extent.y;\n  const auto y_right = location.y + extent.y;\n\n  const auto x_left_rotated = x_left * std::cos(yaw) - y_left * std::sin(yaw);\n  const auto x_right_rotated = x_right * std::cos(yaw) - y_right * std::sin(yaw);\n  const auto y_left_rotated = x_left * std::sin(yaw) + y_left * std::cos(yaw);\n  const auto y_right_rotated = x_right * std::sin(yaw) + y_right * std::cos(yaw);\n\n  const auto x_min = std::min(x_left_rotated, x_right_rotated);\n  const auto x_max = std::max(x_left_rotated, x_right_rotated);\n  const auto y_min = std::min(y_left_rotated, y_right_rotated);\n  const auto y_max = std::max(y_left_rotated, y_right_rotated);\n\n  const auto x_center = (x_min + x_max) / 2.0;\n  const auto y_center = (y_min + y_max) / 2.0;\n  const auto extent_rotated = geom::Vector2D(x_max - x_min, y_max - y_min);\n\n  return std::make_shared<const Bounds>(\n      frame, geom::Location(x_center, y_center), extent_rotated);\n}", "CodeBleu_score": 44.76166096056367}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto location = transform.location + parent_bounds_.at(frame).location;\n  const auto yaw = transform.rotation.yaw * M_PI / 180.0;\n  const auto extents = transform.extents.x * std::cos(yaw) + transform.extents.y * std::sin(yaw);\n  const auto bounds = std::make_shared<const Bounds>(\n    frame,\n    location,\n    geom::Location{location.x - extents, location.y - extents},\n    geom::Location{location.x + extents, location.y + extents});\n  return bounds;\n}", "CodeBleu_score": 49.62986848531145}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    const auto location = transform.location + parent_bounds_.GetLocation(frame);\n    const auto yaw = transform.rotation.yaw;\n    const auto extents = parent_bounds_.GetExtents(frame);\n    const auto corners = geom::Location::Corners(extents, yaw);\n    return std::make_shared<const Bounds>(frame, location, corners);\n  }", "CodeBleu_score": 40.067511153471166}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_episode.Lock()->GetMutex());\n    const auto& lights = _episode.Lock()->GetLightManager()->GetAllLights();\n    for (const auto& light : lights) {\n        auto it = _lights.find(light.id);\n        if (it == _lights.end()) {\n            _lights.insert(std::make_pair(light.id, std::make_shared<Light>(light)));\n        } else {\n            it->second->SetLightState(light);\n        }\n    }\n}", "CodeBleu_score": 40.41494585604036}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    _lights = _episode.Lock()->GetLightManager().GetLights();\n    for (auto &light : _lights) {\n        auto &light_state = light.second;\n        if (light_state.IsEnabled()) {\n            if (light_state.GetLightType() == LightType::Point) {\n                _point_lights.insert(light.first);\n            } else if (light_state.GetLightType() == LightType::Spot) {\n                _spot_lights.insert(light.first);\n            } else if (light_state.GetLightType() == LightType::Directional) {\n                _directional_lights.insert(light.first);\n            }\n        }\n    }\n}", "CodeBleu_score": 34.03195270095547}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t_episode.Lock()->GetLock()->lock();\n\n\tconst auto &lights = _episode.Lock()->QueryLightsStateToServer();\n\n\t_episode.Lock()->GetLock()->unlock();\n\n\tfor (const auto &light : lights) {\n\t\tauto it = _lights.find(light.id);\n\t\tif (it == _lights.end()) {\n\t\t\t_lights[light.id] = std::make_unique<Light>(light.id, light.state, this);\n\t\t} else {\n\t\t\tit->second->SetLightState(light.state);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.00909586308736}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(mutex);\n  if (dirty) {\n    rpc::LightStateList message;\n    for (auto it_light = _lights.begin(); it_light != _lights.end(); ++it_light) {\n      if (it_light->second.GetLightState().has_intensity() || it_light->second.GetLightState().has_color()) {\n        rpc::LightState state;\n        state.set_light_id(it_light->first);\n        state.set_intensity(it_light->second.GetLightState().intensity());\n        state.set_color(it_light->second.GetLightState().color());\n        message.add_light_states()->CopyFrom(state);\n      }\n    }\n    if (message.light_states_size() > 0) {\n      _episode.Lock()->UpdateServerLightsState(message, discard_client);\n    }\n    _lights_changes.clear();\n    dirty = false;\n  }\n}", "CodeBleu_score": 56.33246349078033}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  if (discard_client) {\n    _lights_changes.clear();\n    return;\n  }\n  std::lock_guard<std::mutex> lock(_lights_mutex);\n  if (_lights_changes.empty()) {\n    return;\n  }\n\n  std::vector<rpc::LightState> message;\n  for (auto it_light = _lights.begin(); it_light != _lights.end(); ++it_light) {\n    if (it_light->second.GetLightState() != it_light->second.GetLightStateLast()) {\n      rpc::LightState light_state;\n      light_state.set_light_id(it_light->first);\n      light_state.set_light_type(it_light->second.GetLightType());\n      light_state.set_light_on(it_light->second.GetLightState());\n      light_state.set_light_intensity(it_light->second.GetIntensity());\n      light_state.set_light_color(it_light->second.GetColor());\n      light_state.set_light_range(it_light->second.GetRange());\n      light_state.set_light_attenuation_cosine_factor(it_light->second.GetAttenuationConeFactor());\n      light_state.set_light_inner_cone_angle(it_light->second.GetInnerConeAngle());\n      light_state.set_light_outer_cone_angle(it_light->second.GetOuterConeAngle());\n      light_state.set_light_direction(it_light->second.GetDirection());\n      light_state.set_light_location(it_light->second.GetLocation());\n      message.push_back(light_state);\n    }\n  }\n\n  _episode.Lock()->UpdateServerLightsState(message);\n  _lights_changes.clear();\n}", "CodeBleu_score": 48.55713245589352}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(mutex_lights_changes_);\n  if (!lights_changes_.empty()) {\n    std::string message = \"42[\";\n    for (auto it_light = lights_.begin(); it_light != lights_.end(); ++it_light) {\n      if (lights_changes_.find(it_light->first) != lights_changes_.end()) {\n        message.push_back(\"\\\"\");\n        message.append(it_light->first);\n        message.append(\"\\\",\\\"\");\n        message.append(it_light->second.GetLocation());\n        message.append(\"\\\",\\\"\");\n        message.append(it_light->second.GetRotation());\n        message.append(\"\\\",\\\"\");\n        message.append(it_light->second.GetColor());\n        message.append(\"\\\",\\\"\");\n        message.append(std::to_string(it_light->second.GetIntensity()));\n        message.append(\"\\\",\\\"\");\n        message.append(std::to_string(it_light->second.GetRange()));\n        message.append(\"\\\",\\\"\");\n        message.append(std::to_string(it_light->second.GetAttenuation()));\n        message.append(\"\\\",\\\"\");\n        message.append(std::to_string(it_light->second.GetFOV()));\n        message.append(\"\\\",\\\"\");\n        message.append(std::to_string(it_light->second.GetAspectRatio()));\n        message.append(\"\\\",\\\"\");\n        message.append(std::to_string(it_light->second.GetCastShadows()));\n        message.append(\"\\\",\\\"\");\n        message.append(std::to_string(it_light->second.GetIsActive()));\n        message.append(\"\\\"],\");\n      }\n    }\n    message.pop_back();\n    message.append(\"]\");\n    if (discard_client) {\n      client_.SendMessage(message);\n    } else {\n      client_.SendMessage(message, false);\n    }\n    lights_changes_.clear();\n    lights_dirty_ = false;\n  }\n}", "CodeBleu_score": 40.311406259669866}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t    log_debug(\"ServerSideSensor::Send()\");\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"ServerSideSensor::Send()\", \"The sensor ID is not sensor.other.v2x_custom\");\n        return;\n    }\n    GetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 58.02378014001916}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    log_debug(\"ServerSideSensor::Send()\");\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID does not match\");\n        return;\n    }\n    GetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 55.552727405607136}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    log_debug(\"ServerSideSensor::Send\");\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID is not sensor.other.v2x_custom\");\n        return;\n    }\n    GetEpisode().Lock()->Send({\n        {\"type\", \"sensor\"},\n        {\"name\", GetDisplayId()},\n        {\"reading\", message}\n    });\n}", "CodeBleu_score": 57.79236507514626}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  SetAutopilot(enabled, tm_port, 0);\n}", "CodeBleu_score": 26.0692980600016}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        tm.RegisterVehicles(this, tm_port);\n    } else {\n        tm.UnregisterVehicles(this);\n    }\n}", "CodeBleu_score": 45.695980393463486}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    tm.RegisterVehicles({shared_from_this()}, tm_port);\n  } else {\n    tm.UnregisterVehicles({shared_from_this()});\n  }\n}", "CodeBleu_score": 70.98864145327262}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t  Super::Start();\n  auto nav = GetEpisode().Lock()->GetNavigation();\n  auto walker = GetEpisode().Lock()->FindActor(GetWalkerId());\n  if (walker != nullptr) {\n    nav->AddAgent(walker->GetLocation(), walker->GetId());\n    GetEpisode().Lock()->RegisterAIController(this);\n    GetEpisode().Lock()->SetActorCollisions(walker, false);\n    GetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n  }\n}", "CodeBleu_score": 59.68996206753749}, {"code": "void WalkerAIController::Start(){\n\t    Super::Start();\n    UWalkerAIController* walker = Cast<UWalkerAIController>(GetOwner());\n    check(walker != nullptr);\n    UWalkerNavMesh* nav = GetEpisode().Lock()->GetNavigation();\n    check(nav != nullptr);\n    const int walkerId = walker->GetId();\n    check(walkerId >= 0);\n    const FVector location = walker->GetLocation();\n    nav->AddWalker(walkerId, location);\n    GetEpisode().Lock()->RegisterAIController(walkerId, this);\n    GetEpisode().Lock()->SetActorCollisions(walkerId, false);\n    GetEpisode().Lock()->SetActorSimulatePhysics(walkerId, false);\n}", "CodeBleu_score": 48.16207377003444}, {"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\t\n\tANavigationSystem* nav = GetEpisode().Lock()->GetNavigation();\n\t\n\twalker = Cast<AWalker>(GetEpisode().Lock()->GetActorByID(walkerId));\n\t\n\tif (walker) {\n\t\tnav->AddWalker(walker);\n\t\t\n\t\tFVector startLocation = walker->GetLocation();\n\t\tstartLocation.Z += 100;\n\t\t\n\t\tnav->SetWalkerLocation(walker, startLocation);\n\t\t\n\t\tGetEpisode().Lock()->RegisterAIController(this);\n\t\t\n\t\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n\t\tGetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n\t}\n}", "CodeBleu_score": 44.6383494276157}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  // Retrieve the current episode\n  FEpisodeProxy episode = GetEpisode();\n  // Check if the episode is valid\n  if (episode.IsValid()) {\n    // Retrieve the parent walker\n    AWalker* walker = Cast<AWalker>(GetParent());\n    // Check if the walker is valid\n    if (walker != nullptr) {\n      // Retrieve the navigation instance from the episode\n      ANavigation* nav = episode.GetNavigation();\n      // Check if the navigation instance is valid\n      if (nav != nullptr) {\n        // Attempt to set the maximum speed of the walker using the navigation instance\n        if (nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n          // If successful, log a message\n          UE_LOG(LogCarla, Log, TEXT(\"Walker %d: maximum speed set to %f\"), walker->GetId(), max_speed);\n        } else {\n          // If unsuccessful, log a warning\n          UE_LOG(LogCarla, Warning, TEXT(\"Walker %d: could not set maximum speed\"), walker->GetId());\n        }\n      } else {\n        // If the navigation instance is not valid, log a warning\n        UE_LOG(LogCarla, Warning, TEXT(\"Walker %d: could not set maximum speed\"), walker->GetId());\n      }\n    } else {\n      // If the walker is not valid, log a warning\n      UE_LOG(LogCarla, Warning, TEXT(\"Walker %d: could not set maximum speed\"), GetParent()->GetId());\n    }\n  } else {\n    // If the episode is not valid, log a warning\n    UE_LOG(LogCarla, Warning, TEXT(\"Walker %d: could not set maximum speed\"), GetParent()->GetId());\n  }\n}", "CodeBleu_score": 55.309433774579894}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  carla::log_warning(\"WalkerAIController: SetMaxSpeed is deprecated, use SetWalkerSpeed instead.\");\n  auto episode = GetEpisode();\n  auto nav = episode.Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        carla::log_warning(\"WalkerAIController: failed to set walker speed\");\n      }\n    } else {\n      carla::log_warning(\"WalkerAIController: parent walker not found\");\n    }\n  } else {\n    carla::log_warning(\"WalkerAIController: failed to retrieve navigation\");\n  }\n}", "CodeBleu_score": 65.42866963660042}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", TEXT(\"\"), LogDebugLevel::Informational);\n\n  // Retrieve the current episode\n  const auto episode = GetEpisode();\n\n  // Check if the episode is valid\n  if (!episode) {\n    // Log a warning\n    UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", TEXT(\"Episode is null\"), LogDebugLevel::Failure);\n\n    // Return from the function\n    return;\n  }\n\n  // Retrieve the navigation instance from the current episode\n  const auto nav = episode->GetNavigation();\n\n  // Check if the navigation instance is valid\n  if (!nav) {\n    // Log a warning\n    UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", TEXT(\"Navigation is null\"), LogDebugLevel::Failure);\n\n    // Return from the function\n    return;\n  }\n\n  // Retrieve the parent walker\n  const auto walker = GetParent();\n\n  // Check if the walker is valid\n  if (!walker) {\n    // Log a warning\n    UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", TEXT(\"Walker is null\"), LogDebugLevel::Failure);\n\n    // Return from the function\n    return;\n  }\n\n  // Attempt to set the maximum speed of the walker using the navigation instance\n  if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n    // Log a warning\n    UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", TEXT(\"Failed to set maximum speed\"), LogDebugLevel::Failure);\n\n    // Return from the function\n    return;\n  }\n\n  // Log a message\n  UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", TEXT(\"Maximum speed set to \") + FString::SanitizeFloat(max_speed), LogDebugLevel::Success);\n}", "CodeBleu_score": 48.947054487438805}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(static_cast<size_t>(distance / _parent->GetMap().GetResolution()));\n\n  for (auto waypoint : _parent->GetMap().GetPrevious(*this, distance)) {\n    result.emplace_back(std::make_shared<Waypoint>(*waypoint));\n  }\n\n  return result;\n}", "CodeBleu_score": 55.95867932288271}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(_parent->GetMap().GetPrevious(*this, distance).size());\n    for (auto& waypoint : _parent->GetMap().GetPrevious(*this, distance)) {\n        result.emplace_back(std::make_shared<Waypoint>(waypoint));\n    }\n    return result;\n}", "CodeBleu_score": 56.720871566184584}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(_parent->GetMap().GetPrevious(this, distance).size());\n    for (auto waypoint : _parent->GetMap().GetPrevious(this, distance)) {\n        result.emplace_back(std::move(SharedPtr<Waypoint>(new Waypoint(waypoint, _parent))));\n    }\n    return result;\n}", "CodeBleu_score": 57.871197574370626}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::set<SharedPtr<Signal>> added_signals;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  for (auto signal : signals) {\n    if (added_signals.count(signal) == 0) {\n      added_signals.insert(signal);\n      result.emplace_back(\n          SharedPtr<Landmark>(new Landmark(signal, _parent)));\n    }\n  }\n  return result;\n}", "CodeBleu_score": 38.25956204116924}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n\n  // Get all signals within distance\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\n  // Create a set to avoid duplicates\n  std::set<SharedPtr<Signal>> added_signals;\n\n  // For each signal\n  for (SharedPtr<Signal> signal : signals) {\n    // If signal is not already in the set\n    if (added_signals.count(signal) == 0) {\n      // Add signal to set\n      added_signals.insert(signal);\n\n      // Create a new Waypoint and Landmark\n      SharedPtr<Waypoint> landmark = _parent->GetMap().GetWaypoint(signal->GetTransform());\n      SharedPtr<Landmark> new_landmark =\n        std::make_shared<Landmark>(landmark, signal, _parent->GetMap());\n\n      // Add new landmark to result\n      result.emplace_back(new_landmark);\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 50.26291245570068}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::set<SharedPtr<Signal>> added_signals;\n\n  for (const auto& signal : GetSignalsInDistance(distance, stop_at_junction)) {\n    if (added_signals.count(signal) > 0) {\n      continue;\n    }\n    added_signals.insert(signal);\n    result.emplace_back(\n          std::make_shared<Landmark>(_parent->GetMap(), signal));\n  }\n  return result;\n}", "CodeBleu_score": 41.66335750217818}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  const auto &new_settings = settings.GetEpisodeSettings();\n  const auto &curr_snapshot = GetSnapshot();\n  const auto curr_timestamp = curr_snapshot.GetTimestamp();\n  const auto curr_frame_number = curr_snapshot.GetFrameNumber();\n\n  // Set a local timeout based on the provided timeout or the episode's\n  // networking timeout.\n  const auto &timeout_milliseconds = timeout.milliseconds();\n  const auto &networking_timeout_milliseconds = _episode.Lock()->GetNetworkingTimeout().milliseconds();\n  const auto local_timeout_milliseconds =\n      timeout_milliseconds == 0u ? networking_timeout_milliseconds : timeout_milliseconds;\n\n  // If the settings include a fixed delta time, it attempts to verify the\n  // accuracy of this setting over a series of ticks.\n  if (new_settings.fixed_delta_seconds.has_value()) {\n    const auto fixed_delta_seconds = new_settings.fixed_delta_seconds.get();\n    const auto fixed_delta_seconds_epsilon = std::numeric_limits<float>::epsilon();\n    auto last_delta_seconds = 0.0f;\n    auto delta_seconds_diff = 0.0f;\n    auto delta_seconds_diff_sum = 0.0f;\n    auto delta_seconds_diff_sum_squared = 0.0f;\n    auto delta_seconds_diff_count = 0u;\n    auto delta_seconds_diff_sum_squared_max = 0.0f;\n    auto delta_seconds_diff_max = 0.0f;\n\n    // Attempt to verify the accuracy of this setting over a series of ticks.\n    for (auto i = 0u; i < 10u; ++i) {\n      // Set the new settings.\n      _episode.Lock()->SetEpisodeSettings(new_settings);\n\n      // Wait for a tick.\n      if (!Tick(local_timeout_milliseconds)) {\n        log_warning(\n            \"Failed to apply fixed delta seconds setting. The client may have timed out while waiting for a tick.\");\n        break;\n      }\n\n     ", "CodeBleu_score": 49.12199557104447}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  // Get a lock on the episode to change settings\n  auto episode = _episode.Lock();\n\n  // Set a local timeout based on the provided timeout or the episode's\n  // networking timeout\n  const auto timeout_milliseconds =\n      std::chrono::duration_cast<std::chrono::milliseconds>(\n          timeout == time_duration::zero() ?\n              episode->GetNetworkingTimeout() :\n              timeout).count();\n\n  // Get the current snapshot\n  const auto curr_snapshot = _client->GetWorldSnapshot();\n  const auto curr_timestamp = curr_snapshot.GetTimestamp();\n\n  // If the settings include a fixed delta time, attempt to verify the accuracy\n  // of this setting over a series of ticks\n  if (settings.fixed_delta_seconds.has_value()) {\n    const auto new_settings = episode->ApplySettings(settings);\n    if (abs(new_settings.fixed_delta_seconds.get() - settings.fixed_delta_seconds.get()) > std::numeric_limits<float>::epsilon()) {\n      log_warning(\n          \"Fixed delta seconds setting not correctly applied. The client and server disagree on the accuracy of the time step. The client will use the server's time step setting.\");\n    }\n  } else {\n    // If the settings do not include a fixed delta time, apply them without\n    // verification\n    episode->ApplySettings(settings);\n  }\n\n  // If the settings include a fixed delta time, attempt to verify the accuracy\n  // of this setting over a series of ticks\n  if (settings.fixed_delta_seconds.has_value()) {\n    // Get the current snapshot\n    const auto curr_snapshot = _client->GetWorldSnapshot();\n    const auto curr_timestamp = curr_snapshot.GetTimestamp();\n\n    // The number of attempts to make before failing\n    const uint32_t attempts = 10u;\n\n    // The number of ticks to perform before failing\n    const uint32_t ticks = 10u;\n\n    // The number of attempts that have been made so far\n    uint32_t attempt = 0u;\n\n    // The number of ticks that have been", "CodeBleu_score": 46.52734949433256}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  // Get the settings to apply\n  const auto &new_settings = settings.GetEpisodeSettings();\n\n  // Get the timeout to use\n  timeout = std::chrono::duration_cast<time_duration>(\n      std::chrono::milliseconds(settings.GetNetworkingTimeout()));\n\n  // Lock the episode to apply the settings\n  auto episode = _episode.Lock();\n\n  // Set the timeout for the episode\n  episode->SetNetworkingTimeout(timeout);\n\n  // Get the current snapshot\n  const auto &curr_snapshot = episode->GetSnapshot();\n\n  // Get the current timestamp\n  const auto curr_timestamp = curr_snapshot.GetTimestamp();\n\n  // Get the current fixed delta seconds\n  const auto curr_fixed_delta_seconds = curr_snapshot.GetSettings().fixed_delta_seconds;\n\n  // Get the new fixed delta seconds\n  const auto new_fixed_delta_seconds = new_settings.fixed_delta_seconds.get();\n\n  // If the new fixed delta seconds is not set, use the current one\n  if (!new_settings.fixed_delta_seconds.has_value()) {\n    new_fixed_delta_seconds = curr_fixed_delta_seconds;\n  }\n\n  // If the new fixed delta seconds is not set, use the current one\n  if (!new_settings.fixed_delta_seconds.has_value()) {\n    new_fixed_delta_seconds = curr_fixed_delta_seconds;\n  }\n\n  // If the new fixed delta seconds is not set, use the current one\n  if (!new_settings.fixed_delta_seconds.has_value()) {\n    new_fixed_delta_seconds = curr_fixed_delta_seconds;\n  }\n\n  // If the new fixed delta seconds is not set, use the current one\n  if (!new_settings.fixed_delta_seconds.has_value()) {\n    new_fixed_delta_seconds = curr_fixed_delta_seconds;\n  }\n\n  // If the new fixed delta seconds is not set, use the current one\n  if (!new_settings.fixed_delta_seconds.has_value()) {\n    new_fixed_delta_seconds = curr_fixed_delta_", "CodeBleu_score": 39.060322862531216}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    /*\n     * This function is a member of a static class.\n     */\n\n    /*\n     * The function returns a pair of floats.\n     */\n\n    /*\n     * The first float is the distance along the segment and the second float is the distance from the projection to the point.\n     */\n\n    /*\n     * The function takes two arguments.\n     */\n\n    /*\n     * The first argument is a point.\n     */\n\n    /*\n     * The second argument is a line segment.\n     */\n\n    /*\n     * The first argument is a point.\n     */\n\n    /*\n     * The second argument is a line segment.\n     */\n\n    /*\n     * The function returns a pair of floats.\n     */\n\n    /*\n     * The first float is the distance along the segment and the second float is the distance from the projection to the point.\n     */\n\n    /*\n     * The function takes two arguments.\n     */\n\n    /*\n     * The first argument is a point.\n     */\n\n    /*\n     * The second argument is a line segment.\n     */\n\n    /*\n     * The first argument is a point.\n     */\n\n    /*\n     * The second argument is a line segment.\n     */\n\n    /*\n     * The function returns a pair of floats.\n     */\n\n    /*\n     * The first float is the distance along the segment and the second float is the distance from the projection to the point.\n     */\n\n    /*\n     * The function takes two arguments.\n     */\n\n    /*\n     * The first argument is a point.\n     */\n\n    /*\n     * The second argument is a line segment.\n     */\n\n    /*\n     * The first argument is a point.\n     */\n\n    /*\n     * The second argument is a line segment.\n     */\n\n    /*\n     * The function returns a pair of floats.\n     */\n\n    /*\n     * The first float is the distance along the segment and the second float is the distance from the projection to the point.\n     */\n\n    /*\n     * The function takes two arguments.\n     */\n\n    /*\n     * The first argument is a", "CodeBleu_score": 3.3782400659232708}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    /*\n     * Computes the squared length of the segment\n     */\n    auto segmentLengthSquared = Dot2D(segmentEnd - segmentStart, segmentEnd - segmentStart);\n    /*\n     * If the segment length is zero, it returns zero and the distance from the point to one endpoint\n     */\n    if (segmentLengthSquared == 0.0f) {\n        return std::make_pair(0.0f, Distance2D(segmentStart, point));\n    }\n    /*\n     * Otherwise, it projects the point onto the segment, clamps the projection, and returns the distance along the segment and the distance from the projection to the point\n     */\n    auto t = Clamp((Dot2D(point - segmentStart, segmentEnd - segmentStart) / segmentLengthSquared), 0.0f, 1.0f);\n    auto projection = segmentStart + t * (segmentEnd - segmentStart);\n    return std::make_pair(Distance2D(projection, point), Distance2D(projection, point));\n}", "CodeBleu_score": 44.6525764837214}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    /*\n     * This function returns the squared length of the segment.\n     */\n    auto squared_length = [](const Vector2 & a, const Vector2 & b) {\n        return (a - b).SquaredLength();\n    };\n    /*\n     * This function returns the length of the segment.\n     */\n    auto length = [](const Vector2 & a, const Vector2 & b) {\n        return std::sqrt(squared_length(a, b));\n    };\n    /*\n     * This function clamps the projection to the segment.\n     */\n    auto clamp = [](float projection, float length) {\n        return std::max(0.0f, std::min(length, projection));\n    };\n    /*\n     * This function returns the distance from the projection to the point.\n     */\n    auto distance = [](const Vector2 & projection, const Vector2 & point) {\n        return (point - projection).Length();\n    };\n    /*\n     * This function returns the distance from the point to the segment.\n     */\n    auto distance_from_point = [&](const Vector2 & a, const Vector2 & b, const Vector2 & point) {\n        const float squared_length = squared_length(a, b);\n        const float length = length(a, b);\n        if (squared_length == 0.0f) {\n            return std::make_pair(0.0f, distance(a, point));\n        }\n        const float projection = Dot2D(point - a, b - a) / squared_length;\n        const float clamped_projection = clamp(projection, length);\n        return std::make_pair(clamped_projection, distance(a + clamped_projection * (b - a), point));\n    };\n    return distance_from_point(a, b, point);\n}", "CodeBleu_score": 52.45949719585627}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    DEBUG_ASSERT(vertices.size() >= 3);\n    unsigned int initialIndex = AddVertices(vertices);\n    for (unsigned int i = 0; i < vertices.size() - 2; i++) {\n        AddIndex(initialIndex);\n        AddIndex(initialIndex + i + 1);\n        AddIndex(initialIndex + i + 2);\n    }\n}", "CodeBleu_score": 51.294043645879995}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    DEBUG_ASSERT(vertices.size() >= 3);\n    const size_t initial_index = GetVerticesNum();\n    for (const auto &v : vertices) {\n        AddVertex(v);\n    }\n    for (size_t i = 0; i < vertices.size() - 2; ++i) {\n        AddIndex(initial_index);\n        AddIndex(initial_index + i + 1);\n        AddIndex(initial_index + i + 2);\n    }\n}", "CodeBleu_score": 63.393555030079064}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tDEBUG_ASSERT(vertices.size() >= 3, \"Mesh::AddTriangleFan: at least three vertices are required to form a triangle fan\");\n\tstd::size_t initial_index = vertices.size() - 1;\n\tfor (std::size_t i = 0; i < initial_index; ++i) {\n\t\tAddIndex(initial_index);\n\t\tAddIndex(i);\n\t\tAddIndex(i + 1);\n\t}\n}", "CodeBleu_score": 51.611707797454144}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->GetSize() > 0);\n  DEBUG_ASSERT(message->GetSize() <= carla::streaming::detail::tcp::Message::MAX_SIZE);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::INVALID);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::UNUSED);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::EOS);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::ACK);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::NACK);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::PING);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::PONG);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESET);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESET_ACK);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESET_NACK);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESET_DONE);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESET_DONE_ACK);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESET_DONE_NACK);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESET_ALL);\n  DEBUG_ASSERT(message->GetType() != carla", "CodeBleu_score": 20.28014702759337}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::EOS);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::ACK);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::NAK);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::CONN);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::DISC);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::PING);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::PONG);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESYNC);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESYNC_OK);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESYNC_FAIL);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESYNC_DONE);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESYNC_ALL_DONE);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESYNC_ALL_FAIL);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESYNC_ALL_DONE_OK);\n  DEBUG_ASSERT(message->GetType() != carla::streaming::detail::tcp::Message::Type::RESYNC_ALL_DONE_FAIL);\n  DEBUG_ASSERT(message->GetType", "CodeBleu_score": 20.298703690685453}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->GetSize() <= std::numeric_limits<uint32_t>::max());\n  DEBUG_ASSERT(message->GetSize() <= std::numeric_limits<uint16_t>::max());\n  DEBUG_ASSERT(message->GetSize() > 0u);\n\n  // Post a lambda to the strand for execution.\n  _strand.post([self = shared_from_this(), message]() {\n\n    // Check if the socket is open.\n    if (!self->_socket.is_open()) {\n      return;\n    }\n\n    // Set a timeout for the operation.\n    self->_deadline.expires_from_now(boost::posix_time::milliseconds(_timeout));\n\n    // Initiate an asynchronous write.\n    boost::asio::async_write(\n        self->_socket,\n        message->GetBufferSequence(),\n        boost::asio::bind_executor(\n            self->_strand,\n            [self, message](boost::system::error_code ec, std::size_t) {\n              self->handle_sent(ec, message);\n            }));\n  });\n}", "CodeBleu_score": 48.5457861504303}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n\n  if (!ec) {\n    if (_socket.is_open()) {\n      boost::system::error_code shutdown_ec;\n      _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, shutdown_ec);\n      _socket.close(shutdown_ec);\n    }\n  }\n\n  if (ec) {\n    _on_closed(ec);\n  } else {\n    _on_closed();\n  }\n\n  log_debug(\"session closed\");\n}", "CodeBleu_score": 71.27232416974363}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n\n    if (!ec) {\n        if (_socket.is_open()) {\n            _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n            _socket.close(ec);\n        }\n    }\n\n    if (ec) {\n        log_debug(\"Session closed with error: \" + ec.message());\n    } else {\n        log_debug(\"Session closed\");\n    }\n\n    _on_closed(ec);\n}", "CodeBleu_score": 66.50137256272886}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n\n  if (!ec) {\n    // Attempt a graceful shutdown\n    _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n    // Not all operating systems support the SO_LINGER option for\n    // shutting down the underlying TCP connection.\n    if (ec == boost::asio::error::not_supported)\n      ec.assign(0, ec.category());\n  }\n\n  if (ec)\n    log_debug(\"Error closing socket: \" << ec.message());\n\n  // At this point the connection is closed gracefully or forcefully.\n  _on_closed();\n  log_debug(\"Session closed\");\n}", "CodeBleu_score": 51.39347746241039}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t    // Create a buffer from the message\n    auto msg = std::make_shared<flatbuffers::FlatBufferBuilder>();\n    auto msg_offset = CreateMessage(msg.get(), \"Are you alive?\", MessageType::YOU_ALIVE);\n    FinishMessageBuffer(*msg, msg_offset);\n\n    // Log the sending action\n    log_info(\"Sending 'Are you alive?' to %s\", _router->GetNextRouterName().c_str());\n\n    // Write the buffer to the next router with the command YOU_ALIVE\n    _router->WriteToNext(MessageType::YOU_ALIVE, std::move(msg));\n\n    // Wait for and log the response from the system\n    auto response = _router->ReadFromNext();\n    auto response_buffer = response.buffer.data();\n    auto response_msg = GetMessage(response_buffer->data());\n    log_info(\"Received response from %s: %s\", _router->GetNextRouterName().c_str(), response_msg->message()->c_str());\n}", "CodeBleu_score": 49.71300161681569}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  std::string msg = \"Are you alive?\";\n  Buffer buffer = Buffer(msg.size() + 1);\n  memcpy(buffer.data(), msg.c_str(), msg.size() + 1);\n  log_info(\"Sending is alive message.\");\n  _router->WriteToNext(buffer, YOU_ALIVE);\n  Buffer response;\n  _router->ReadFromNext(&response);\n  log_info(\"Received is alive response.\");\n}", "CodeBleu_score": 52.933631102385824}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t    std::string msg = \"Are you alive?\";\n    auto buffer = std::make_shared<Buffer>(msg.size());\n    memcpy(buffer->data(), msg.c_str(), msg.size());\n    log_info(\"Sending message to next router: %s\", msg.c_str());\n    _router->WriteToNext(std::move(buffer), YOU_ALIVE);\n    auto fut = _router->Read();\n    auto response = fut.get();\n    log_info(\"Received response from next router: %s\", response.buffer.data());\n}", "CodeBleu_score": 58.1508644636484}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  auto fut = _router->WriteToOne(\n      std::make_shared<PrimaryBuffer>(PrimaryBuffer::Type::ENABLE_ROS, sensor_id));\n  fut.get();\n  auto response = _router->ReadFromOne();\n  if (response.buffer.data.size() != 0) {\n    if (reinterpret_cast<bool *>(response.buffer.data.data())[0]) {\n      _servers[response.server_id].sensor_ids.insert(sensor_id);\n    } else {\n      log_error(\"Sensor ID %u not found on any server\", sensor_id);\n    }\n  } else {\n    log_error(\"Sensor ID %u not found on any server\", sensor_id);\n  }\n}", "CodeBleu_score": 50.20243902036994}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  // Check if sensor is on any server\n  auto it = _servers.find(sensor_id);\n  if (it == _servers.end()) {\n    log_error(\"Sensor ID %u not found on any server\", sensor_id);\n    return;\n  }\n  // Create buffer with sensor ID\n  std::unique_ptr<char[]> buf(new char[sizeof(stream_id)]);\n  stream_id *sensor_id_buf = reinterpret_cast<stream_id *>(buf.get());\n  *sensor_id_buf = sensor_id;\n  // Send ENABLE_ROS command to server\n  auto fut = _router->WriteToOne(sensor_id, Command::ENABLE_ROS,\n                                 response.buffer.data, buf.get(),\n                                 sizeof(stream_id));\n  // Wait for response\n  response.status = fut.get();\n  if (response.status != Response::Status::OK) {\n    log_error(\"Failed to enable ROS for sensor %u\", sensor_id);\n  }\n}", "CodeBleu_score": 55.83683535125715}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\n  // Find the server that has the sensor\n  auto server = _servers.find(sensor_id);\n\n  // If the server is found\n  if (server != _servers.end()) {\n\n    // Create a buffer with the sensor ID\n    Buffer buffer(sizeof(stream_id));\n    auto *data = reinterpret_cast<stream_id *>(buffer.data());\n    *data = sensor_id;\n\n    // Send the command to the server\n    auto fut = _router->WriteToOne(buffer, server->second);\n\n    // Wait for and process the server's response\n    auto response = fut.get();\n    if (response.error_code != 0) {\n      log_error(\"Error sending ENABLE_ROS command: %s\",\n                response.error_message.c_str());\n    }\n\n  } else {\n\n    // If the sensor is not found on any server, log an error message\n    log_error(\"Sensor %d not found\", sensor_id);\n\n  }\n\n}", "CodeBleu_score": 59.48082213474824}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t    log_debug(\"GetToken\");\n\n    auto it = _tokens.find(sensor_id);\n    if (it != _tokens.end()) {\n        log_debug(\"Token already exists\");\n        return it->second;\n    }\n\n    log_debug(\"Token doesn't exist\");\n    auto server = _router->GetNextServer();\n    auto token = server->SendGetToken(sensor_id);\n\n    _tokens[sensor_id] = token;\n    _servers[sensor_id] = server;\n    _streams[sensor_id] = _servers[sensor_id]->GetStream(sensor_id);\n\n    log_debug(\"Token created\");\n    return token;\n}", "CodeBleu_score": 64.59196059254144}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t    // First, check if the sensor is already activated.\n    auto it = _tokens.find(sensor_id);\n    if (it != _tokens.end()) {\n        log_debug(\"Sensor %d is already activated.\", sensor_id);\n        return it->second;\n    }\n    // If the sensor is not activated, enable the sensor on a secondary server,\n    // retrieve a new token, update the maps, log the action, and return the new token.\n    auto server = _router->GetNextServer();\n    auto token = SendGetToken(server, sensor_id);\n    _tokens[sensor_id] = token;\n    _streams[token.get_stream_id()] = sensor_id;\n    log_debug(\"Activated sensor %d on server %s:%d.\", sensor_id, server.get_ip().c_str(), server.get_port());\n    return token;\n}", "CodeBleu_score": 67.1757758185164}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // Check if the sensor is already activated\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_debug(\"Sensor %u is already activated\", sensor_id);\n    return it->second;\n  }\n\n  // Enable the sensor on a secondary server\n  auto server = _router->GetNextServer();\n  log_debug(\"Enabling sensor %u on server %u\", sensor_id, server);\n  SendGetToken(server, sensor_id);\n\n  // Retrieve a new token\n  token_type token = token_type(server, sensor_id);\n  log_debug(\"New token for sensor %u: %u:%u\", sensor_id, token.get_port(), token.get_stream_id());\n\n  // Update the maps\n  _tokens.insert(std::make_pair(sensor_id, token));\n  _servers.insert(std::make_pair(token, server));\n\n  return token;\n}", "CodeBleu_score": 60.73534355132145}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<char> data((std::istreambuf_iterator<char>(f)),\n                         std::istreambuf_iterator<char>());\n  f.close();\n  return Load(data);\n}", "CodeBleu_score": 62.768166658759085}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f(filename, std::ios::binary);\n    if (!f.is_open()) {\n        return false;\n    }\n    std::vector<unsigned char> data;\n    f.seekg(0, std::ios::end);\n    data.resize(f.tellg());\n    f.seekg(0, std::ios::beg);\n    f.read((char *)data.data(), data.size());\n    f.close();\n    return Load(data);\n}", "CodeBleu_score": 55.59276896275547}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f;\n  f.open(filename.c_str(), std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<char> data;\n  f.seekg(0, std::ios::end);\n  data.resize(f.tellg());\n  f.seekg(0, std::ios::beg);\n  f.read(&data[0], data.size());\n  f.close();\n  return Load(data);\n}", "CodeBleu_score": 65.9645263858475}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!_is_ready) {\n        return false;\n    }\n    DEBUG_ASSERT(_crowd != nullptr);\n    Crowd::Index index;\n    Crowd::AgentId agent_id;\n    Crowd::Agent *agent = nullptr;\n    auto it = _mapped_walkers_id.find(id);\n    if (it != _mapped_walkers_id.end()) {\n        index = it->second;\n        agent_id = _walker_manager->GetAgentId(index);\n        agent = _crowd->getAgent(agent_id);\n    } else {\n        auto it = _mapped_vehicles_id.find(id);\n        if (it != _mapped_vehicles_id.end()) {\n            index = it->second;\n            agent_id = _vehicle_manager->GetAgentId(index);\n            agent = _crowd->getAgent(agent_id);\n        }\n    }\n    if (agent != nullptr) {\n        Crowd::CrowdAgentParams params = agent->params;\n        Crowd::CrowdAgentState state = agent->state;\n        Crowd::CrowdAgentTargetState target_state = agent->targetState;\n        Crowd::CrowdAgentObstacleAvoidanceParams obstacle_params = agent->obstacleParams;\n        Crowd::CrowdAgentAnimationParams animation_params = agent->animationParams;\n        Crowd::CrowdAgentAvoidanceParams avoidance_params = agent->avoidanceParams;\n        Crowd::CrowdAgentSeparationParams separation_params = agent->separationParams;\n        Crowd::CrowdAgentGroupsMask groups_mask = agent->groupsMask;\n        Crowd::CrowdAgentTreeNode* node = agent->node;\n        Crowd::CrowdAgentUserData user_data = agent->userData;\n        Crowd::CrowdAgentQueryFilter filter = agent->filter;\n        Crowd::CrowdAgentDebugData debug_data = agent->debugData;\n        Crowd::CrowdAgentParams agent_params = agent->params;\n        Crowd::CrowdAgent", "CodeBleu_score": 50.41211921886992}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!IsReady()) {\n        return false;\n    }\n\n    if (_crowd == nullptr) {\n        return false;\n    }\n\n    Crowd::AgentId agentId;\n    Crowd::AgentId *agentIdPtr;\n    Crowd::Agent *agent;\n    Crowd::AgentState state;\n\n    agentIdPtr = _mapped_walkers_id.find(id);\n    if (agentIdPtr != _mapped_walkers_id.end()) {\n        agentId = *agentIdPtr;\n        agent = _crowd->getEditableAgent(agentId);\n        state = agent->state;\n        if (state == Crowd::WALKING) {\n            _crowd->requestMoveTargetForAgent(agentId, agent->npos, Crowd::STOP_AT_END);\n        }\n        _crowd->removeAgent(agentId);\n        _walker_manager.RemoveWalker(id);\n        return true;\n    }\n\n    agentIdPtr = _mapped_vehicles_id.find(id);\n    if (agentIdPtr != _mapped_vehicles_id.end()) {\n        agentId = *agentIdPtr;\n        agent = _crowd->getEditableAgent(agentId);\n        state = agent->state;\n        if (state == Crowd::WALKING) {\n            _crowd->requestMoveTargetForAgent(agentId, agent->npos, Crowd::STOP_AT_END);\n        }\n        _crowd->removeAgent(agentId);\n        _vehicle_manager.RemoveVehicle(id);\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 53.211679023215055}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!IsReady()) {\n        return false;\n    }\n    DEBUG_ASSERT(_crowd);\n    std::lock_guard<std::mutex> lock(_mutex);\n    auto it = _mapped_vehicles_id.find(id);\n    if (it != _mapped_vehicles_id.end()) {\n        _crowd->removeAgent(it->second);\n        _mapped_vehicles_id.erase(it);\n        _mapped_by_index.erase(it->second);\n        _vehicle_manager->RemoveVehicle(id);\n        return true;\n    }\n    it = _mapped_walkers_id.find(id);\n    if (it != _mapped_walkers_id.end()) {\n        _crowd->removeAgent(it->second);\n        _mapped_walkers_id.erase(it);\n        _mapped_by_index.erase(it->second);\n        _walker_manager->RemoveWalker(id);\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 77.7598634765993}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::set<int> updated;\n\tfor (auto& vehicle : vehicles) {\n\t\tAddOrUpdateVehicle(vehicle, updated);\n\t}\n\tfor (auto& vehicle : m_vehicles) {\n\t\tif (updated.find(vehicle.first) == updated.end()) {\n\t\t\tRemoveAgent(vehicle.first);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 48.12748659110109}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n    // Collect the IDs of currently mapped vehicles into a set.\n    std::set<int> updated;\n\n    // Add or update vehicles from the provided list, marking them as updated.\n    for (auto vehicle : vehicles) {\n        AddOrUpdateVehicle(vehicle);\n        updated.insert(vehicle.id);\n    }\n\n    // Vehicles not marked as updated are removed, indicating they do not exist in the current frame.\n    for (auto it = m_vehicles.begin(); it != m_vehicles.end();) {\n        if (updated.find(it->first) == updated.end()) {\n            RemoveAgent(it);\n        } else {\n            ++it;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 51.48698498054722}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    std::set<int> updated;\n    for (auto v : vehicles) {\n        int id = v.id;\n        auto it = vehicle_map.find(id);\n        if (it == vehicle_map.end()) {\n            AddOrUpdateVehicle(v);\n            updated.insert(id);\n        } else {\n            it->second.Update(v);\n            updated.insert(id);\n        }\n    }\n    for (auto it = vehicle_map.begin(); it != vehicle_map.end();) {\n        if (updated.find(it->first) == updated.end()) {\n            RemoveAgent(it);\n        } else {\n            ++it;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 47.69202430419938}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  auto itr = _mapped_walkers_id.find(id);\n  if (itr != _mapped_walkers_id.end()) {\n    carla::geom::Location location = itr->second->GetLocation();\n    float dx = location.x - direction.x;\n    float dy = location.y - direction.y;\n    float squared_distance = dx * dx + dy * dy;\n    if (squared_distance <= distance * distance) {\n      std::lock_guard<std::mutex> guard(_crowd_mutex);\n      return _crowd->hasVehicleNear(location.x, location.y, location.z, distance);\n    }\n  }\n  return false;\n}", "CodeBleu_score": 54.45792668679555}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    const auto &actor = it->second;\n    const auto &loc = actor->GetLocation();\n    const auto &rot = actor->GetTransform().rotation;\n    const auto &vec = loc + rot.GetForwardVector() * distance;\n    const auto &vec_rot = carla::geom::Math::RotateVector2D(direction, rot.yaw);\n    const auto &vec_end = vec + vec_rot;\n    const auto &vec_end_2d = carla::geom::Location(vec_end.x, vec_end.y, vec.z);\n    const auto &vec_2d = carla::geom::Location(vec.x, vec.y, vec.z);\n    const auto &vec_end_2d_norm = carla::geom::Math::MakeVec2d(vec_end_2d);\n    const auto &vec_2d_norm = carla::geom::Math::MakeVec2d(vec_2d);\n    const auto &vec_end_2d_norm_length = carla::geom::Math::Length(vec_end_2d_norm);\n    const auto &vec_2d_norm_length = carla::geom::Math::Length(vec_2d_norm);\n    const auto &vec_end_2d_norm_length_sqr = vec_end_2d_norm_length * vec_end_2d_norm_length;\n    const auto &vec_2d_norm_length_sqr = vec_2d_norm_length * vec_2d_norm_length;\n    const auto &vec_2d_norm_length_sqr_min_dist_sqr = vec_2d_norm_length_sqr - _min_dist_sqr;\n    if (vec_end_2d_norm_length_sqr < vec_2d_norm_length_sqr_min_dist_sqr) {\n      carla::crowd::AgentId agent_id;\n      {\n        std", "CodeBleu_score": 40.636955240302775}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  std::lock_guard<std::mutex> guard(_lock);\n  auto walker_it = _mapped_walkers_id.find(id);\n  if (walker_it != _mapped_walkers_id.end()) {\n    const float squared_distance = (walker_it->second.GetLocation() - direction).SquaredLength();\n    if (squared_distance < distance * distance) {\n      return _crowd->hasVehicleNear(walker_it->second.GetAgent(), distance);\n    }\n  }\n  auto vehicle_it = _mapped_vehicles_id.find(id);\n  if (vehicle_it != _mapped_vehicles_id.end()) {\n    const float squared_distance = (vehicle_it->second.GetLocation() - direction).SquaredLength();\n    if (squared_distance < distance * distance) {\n      return _crowd->hasVehicleNear(vehicle_it->second.GetAgent(), distance);\n    }\n  }\n  return false;\n}", "CodeBleu_score": 53.64986106392475}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    const auto &route = info.route;\n    const auto &current_point = route.GetCurrentPoint();\n\n    WalkerEventVisitor visitor(id, info, delta);\n    EventResult result = boost::variant2::visit(visitor, current_point.event);\n\n    return result;\n}", "CodeBleu_score": 53.27035929138002}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tif (info.route.empty()) {\n\t\treturn EventResult::FAILED;\n\t}\n\tauto routePoint = info.route.front();\n\tWalkerEventVisitor visitor(id, info.context, delta);\n\treturn boost::variant2::visit(visitor, routePoint);\n}", "CodeBleu_score": 53.69154541390346}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  // Retrieve the current route point for the walker from the WalkerInfo structure\n  const RoutePoint &routePoint = info.routePoint;\n\n  // Create a WalkerEventVisitor with the current context and uses it to process the event at the current route point using boost::variant2::visit\n  WalkerEventVisitor visitor(id, delta, info.context);\n  return boost::variant2::visit(visitor, routePoint.event);\n}", "CodeBleu_score": 59.90880499891391}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"road\")) {\n    // Extract the road ID\n    uint32_t road_id = road_node.attribute(\"id\").as_uint();\n\n    // Iterate through each lane section node\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\")) {\n      // Retrieve the left, center, and right lane nodes\n      pugi::xml_node left_lane_node = lane_section_node.child(\"laneOffset\");\n      pugi::xml_node center_lane_node = lane_section_node.child(\"lane\");\n      pugi::xml_node right_lane_node = lane_section_node.child(\"lane\");\n\n      // Parse the left, center, and right lane nodes\n      ParseLanes(left_lane_node, center_lane_node, right_lane_node, map_builder, road_id);\n    }\n  }\n}", "CodeBleu_score": 43.99754850821315}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  pugi::xml_node open_drive_node = xml.child(\"OpenDRIVE\");\n  for (pugi::xml_node road_node : open_drive_node.children(\"road\")) {\n    carla::road::RoadId road_id = road_node.attribute(\"id\").as_uint();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      double s = lane_section_node.attribute(\"s\").as_double();\n      ParseLanes(lane_section_node, s, map_builder.GetRoad(road_id));\n    }\n  }\n}", "CodeBleu_score": 43.10810192218509}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"road\")) {\n    std::string road_id = road_node.attribute(\"id\").as_string();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\")) {\n      std::string lane_section_id = lane_section_node.attribute(\"s\").as_string();\n      for (pugi::xml_node lane_node : lane_section_node.children()) {\n        std::string lane_id = lane_node.attribute(\"id\").as_string();\n        std::string lane_type = lane_node.attribute(\"type\").as_string();\n        ParseLanes(lane_node, map_builder, road_id, lane_section_id, lane_id, lane_type);\n      }\n    }\n  }\n}", "CodeBleu_score": 44.515386065755436}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    // new match\n    if (info.total_count == 1) {\n      // first match\n      this->first_connected_ = true;\n    }\n    this->matched_count_++;\n  } else if (info.current_count_change == -1) {\n    // match lost\n    this->matched_count_--;\n  } else {\n    // invalid count change\n    std::cout << \"Invalid count change: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 55.89379480833735}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\n\tif (info.current_count_change == 1) {\n\t\tmatched_ = info.total_count;\n\t\tfirst_connected_ = true;\n\t\tstd::cout << \"Carla is now connected to \" << info.total_count << \" clients.\" << std::endl;\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_ = info.total_count;\n\t\tstd::cout << \"Carla is now connected to \" << info.total_count << \" clients.\" << std::endl;\n\t} else {\n\t\tstd::cout << \"on_publication_matched: \" << info.current_count_change\n\t\t\t\t<< \" is not a valid value for CurrentCountChange.\" << std::endl;\n\t}\n}", "CodeBleu_score": 69.19397973319924}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_count_++;\n        if (matched_count_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_count_--;\n    } else {\n        efd::Log::error(\"Publication matched count change was \" + std::to_string(info.current_count_change) +\n                        \" instead of +1 or -1.\");\n    }\n}", "CodeBleu_score": 56.699410934421124}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched\" << std::endl;\n        first_connected = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched\" << std::endl;\n        if (info.total_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::cout << \"Subscriber matched error\" << std::endl;\n    }\n}", "CodeBleu_score": 62.46063165396514}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        _matched_count++;\n        if (_matched_count == 1) {\n            _first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        _matched_count--;\n        if (_matched_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        UE_LOG(LogCarla, Error, TEXT(\"Unknown current count change value %d\"), info.current_count_change);\n    }\n}", "CodeBleu_score": 64.23145567784931}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    _first_connected = true;\n  }\n  if (info.current_count_change == -1) {\n    _first_connected = false;\n  }\n  if (info.current_count_change == 0) {\n    _owner->DestroySubscriber();\n  }\n  if (info.current_count_change != 1 && info.current_count_change != -1) {\n    UE_LOG(LogCarla, Error, TEXT(\"Invalid subscription change count.\"));\n  }\n}", "CodeBleu_score": 59.17458139059887}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < CarlaCollisionEvent::getKeyMaxCdrSerializedSize(); ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 85.07524682516879}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(m_keyBuffer, m_keyBufferLen);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || Cdr::checkKeyMaxSize(ser.getSerializedDataLength())) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, ser.getSerializedDataLength());\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 73.49309206702821}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n    if (!m_cdr.serialize(data, m_keyBuffer, force_md5)) {\n        return false;\n    }\n    if (force_md5) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(m_keyBufferLen));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 54.038022690928166}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 98.7249351516631}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 98.7249351516631}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    try {\n        p_type->serialize(ser);\n        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n        return true;\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n}", "CodeBleu_score": 91.00724878025216}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (g.sysid_target == -1) {\n        mavlink_heartbeat_t hb;\n        mavlink_msg_heartbeat_decode(&msg, &hb);\n        if (hb.type == MAV_TYPE_GCS) {\n            g.sysid_target = msg.sysid;\n            gcs().request_datastream_position(g.sysid_target, 10);\n            gcs().request_datastream_airpressure(g.sysid_target, 10);\n            gcs_set_target_set();\n        }\n    }\n}", "CodeBleu_score": 36.24474455937327}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    mavlink_heartbeat_t heartbeat;\n    mavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n    if (g.sysid_target == 0) {\n        g.sysid_target = heartbeat.system_id;\n        g.gcs().request_datastream_position(g.sysid_target);\n        g.gcs().request_datastream_airpressure(g.sysid_target);\n        g.target_set = true;\n    }\n}", "CodeBleu_score": 36.296694125651506}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\n    // exit immediately if the target has already been set\n    if (target_set)\n        return;\n\n    // decode the MAVLink message\n    mavlink_message_t decoded_msg;\n    mavlink_status_t status;\n    mavlink_msg_heartbeat_decode(&msg, &decoded_msg, &status);\n\n    // exit immediately if the message type is not one that should be tracked\n    if (decoded_msg.msgid != MAVLINK_MSG_ID_HEARTBEAT)\n        return;\n\n    // exit immediately if the target system ID is not set\n    if (target_sysid == 0) {\n        target_sysid = decoded_msg.sysid;\n        gcs().request_datastream_position(target_sysid);\n        gcs().request_datastream_airpressure(target_sysid);\n        return;\n    }\n\n    // flag that the target has been set\n    target_set = true;\n}", "CodeBleu_score": 35.66353018825013}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _baro_cal_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 67.28307896212618}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n    if (result == MAV_RESULT_ACCEPTED) {\n        _baro_cal_needed = true;\n    }\n\n    return result;\n}", "CodeBleu_score": 67.28307896212618}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_calibration_baro_done = false;\n\t}\n\treturn result;\n}", "CodeBleu_score": 59.6506560124766}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    if (is_equal(packet.param1, 1.0)) {\n        tracker.arm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    } else if (is_equal(packet.param1, 0.0)) {\n        tracker.disarm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    }\n    return result;\n}", "CodeBleu_score": 63.79706738960098}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0) {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 75.80727962606619}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    if (packet.param1 == 1.0) {\n        tracker.arm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0) {\n        tracker.disarm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    }\n    return result;\n}", "CodeBleu_score": 61.265487994591695}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    uint8_t channel = 0;\n    uint8_t chan_count = 0;\n    uint8_t chan_count_max = 0;\n    uint8_t chan_count_min = 0;\n    uint8_t chan_count_avail = 0;\n    uint8_t chan_count_used = 0;\n    uint8_t chan_count_unused = 0;\n    uint8_t chan_count_unused_max = 0;\n    uint8_t chan_count_unused_min = 0;\n    uint8_t chan_count_unused_avail = 0;\n    uint8_t chan_count_unused_used = 0;\n    uint8_t chan_count_unused_used_max = 0;\n    uint8_t chan_count_unused_used_min = 0;\n    uint8_t chan_count_unused_used_avail = 0;\n    uint8_t chan_count_unused_used_used = 0;\n    uint8_t chan_count_unused_used_used_max = 0;\n    uint8_t chan_count_unused_used_used_min = 0;\n    uint8_t chan_count_unused_used_used_avail = 0;\n    uint8_t chan_count_unused_used_used_used = 0;\n    uint8_t chan_count_unused_used_used_used_max = 0;\n    uint8_t chan_count_unused_used_used_used_min = 0;\n    uint8_t chan_count_unused_used_used_used_avail = 0;\n    uint8_t chan_count_unused_used_used_used_used = 0;\n    uint8_t chan_count_unused_used_used_used_used_max = 0;\n    uint8_t chan_count_unused_used_used_used_used_min", "CodeBleu_score": 9.694576412483721}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (int i = 0; i < num_gcs; i++) {\n        if (gcs_list[i].get_channel() != nullptr && gcs_list[i].get_channel()->get_payload_space() > 0) {\n            gcs_list[i].get_channel()->send_message(\n                MAVLINK_MSG_ID_REQUEST_DATA_STREAM,\n                sysid,\n                compid,\n                &mavlink_msg_request_data_stream_send,\n                MAVLINK_DATA_STREAM_POSITION,\n                10,\n                0,\n                0);\n        }\n    }\n}", "CodeBleu_score": 52.65724144424983}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    // Iterate over all available GCS channels\n    for (int i = 0; i < GCS_CHANNEL_COUNT; i++) {\n        // Check if the channel is active\n        if (gcs_channels[i].active) {\n            // Check if the channel has payload space available\n            if (gcs_channels[i].payload_space_available()) {\n                // Send a request to start the stream on the channel with the specified update rate\n                mavlink_msg_request_data_stream_send(gcs_channels[i].chan, gcs_channels[i].sysid, gcs_channels[i].compid, i, 10, 0, 0, 0, 0, 0);\n                // Set the channel's update rate\n                gcs_channels[i].update_rate = 10;\n                // Set the channel's target system ID\n                gcs_channels[i].target_system = sysid;\n                // Set the channel's target component ID\n                gcs_channels[i].target_component = compid;\n                // Set the channel's target type\n                gcs_channels[i].target_type = GCS_TARGET_TYPE_POSITION;\n                // Set the channel's active flag to true\n                gcs_channels[i].active = true;\n                // Return from the function\n                return;\n            }\n        }\n    }\n}", "CodeBleu_score": 47.42427498334152}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t  AHRS* ahrs = AP::ahrs;\n  if (ahrs->cos_pitch != 0) {\n    ef_pitch = atan2(ahrs->sin_roll * ahrs->sin_pitch + ahrs->cos_roll * ahrs->cos_pitch * ahrs->sin_yaw, ahrs->cos_pitch * ahrs->cos_yaw);\n    ef_yaw = atan2(ahrs->sin_roll * ahrs->cos_pitch * ahrs->cos_yaw - ahrs->sin_pitch * ahrs->sin_yaw, ahrs->cos_roll * ahrs->cos_pitch);\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 35.02561382838512}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    AHRS *ahrs = AP::ahrs;\n    if (is_zero(ahrs->cos_pitch)) {\n        return false;\n    }\n    ef_pitch = asin(-ahrs->sin_roll * ahrs->sin_pitch + ahrs->cos_roll * ahrs->cos_pitch * sinf(pitch));\n    ef_yaw = atan2f(-ahrs->sin_roll * ahrs->cos_pitch * sinf(pitch) + ahrs->cos_roll * ahrs->sin_pitch,\n                    ahrs->cos_pitch * cosf(pitch));\n    return true;\n}", "CodeBleu_score": 42.23140079103606}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    AHRS* ahrs = AP_AHRS::get_instance();\n    if (ahrs->cos_pitch == 0) {\n        return false;\n    }\n    ef_pitch = atan2(ahrs->sin_pitch * ahrs->sin_roll * sin(yaw) + ahrs->cos_pitch * sin(pitch), ahrs->cos_pitch * cos(pitch));\n    ef_yaw = atan2(ahrs->sin_pitch * ahrs->cos_roll * sin(yaw) - ahrs->sin_roll * sin(pitch), ahrs->cos_pitch * ahrs->cos_roll * cos(yaw) - ahrs->sin_roll * ahrs->sin_pitch * cos(pitch));\n    return true;\n}", "CodeBleu_score": 54.280207539548776}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t  // Get the current navigation status\n  NavigationStatus nav_status = tracker.get_nav_status();\n  // Get the current navigation parameters\n  NavigationParameters nav_params = tracker.get_nav_params();\n  // Get the current tracker parameters\n  TrackerParameters tracker_params = tracker.get_tracker_params();\n  // Get the current tracker status\n  TrackerStatus tracker_status = tracker.get_tracker_status();\n  // Get the current tracker settings\n  TrackerSettings tracker_settings = tracker.get_tracker_settings();\n  // Get the current tracker errors\n  TrackerErrors tracker_errors = tracker.get_tracker_errors();\n  // Get the current tracker calibration\n  TrackerCalibration tracker_calibration = tracker.get_tracker_calibration();\n  // Get the current tracker control\n  TrackerControl tracker_control = tracker.get_tracker_control();\n  // Get the current tracker data\n  TrackerData tracker_data = tracker.get_tracker_data();\n  // Get the current tracker debug\n  TrackerDebug tracker_debug = tracker.get_tracker_debug();\n  // Get the current tracker limits\n  TrackerLimits tracker_limits = tracker.get_tracker_limits();\n  // Get the current tracker version\n  TrackerVersion tracker_version = tracker.get_tracker_version();\n\n  // Calculate the target yaw in centidegrees\n  float target_yaw = nav_status.target_yaw * 100;\n  // Calculate the target pitch in centidegrees\n  float target_pitch = nav_status.target_pitch * 100;\n  // Calculate the target distance in centimeters\n  float target_distance = nav_status.target_distance * 100;\n  // Calculate the target roll in centidegrees\n  float target_roll = nav_status.target_roll * 100;\n  // Calculate the target yaw rate in centidegrees per second\n  float target_yaw_rate = nav_status", "CodeBleu_score": 28.364070338288826}, {"code": "void Mode::update_auto(void){\n\t    // Calculate the target yaw and pitch in centidegrees\n    tracker.target_yaw = wrap_180_cd(tracker.get_yaw_servo_cd() + tracker.get_yaw_error_cd());\n    tracker.target_pitch = tracker.get_pitch_servo_cd() + tracker.get_pitch_error_cd();\n\n    // Check if the direction is reversed\n    if (tracker.get_yaw_direction() == -1) {\n        tracker.target_yaw = -tracker.target_yaw;\n    }\n\n    // Calculate the angle error\n    tracker.yaw_error = calc_angle_error(tracker.target_yaw, tracker.get_yaw_servo_cd());\n    tracker.pitch_error = calc_angle_error(tracker.target_pitch, tracker.get_pitch_servo_cd());\n\n    // Convert the errors from earth frame to body frame\n    tracker.target_yaw = convert_ef_to_bf(tracker.target_yaw, tracker.get_yaw_direction());\n    tracker.target_pitch = convert_ef_to_bf(tracker.target_pitch, tracker.get_pitch_direction());\n\n    // If the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly\n    if (tracker.get_distance_valid() || tracker.get_min_distance() == 0) {\n        tracker.update_yaw_servo();\n        tracker.update_pitch_servo();\n    }\n}", "CodeBleu_score": 25.442815451320527}, {"code": "void Mode::update_auto(void){\n\t  // Calculate target yaw and pitch in centidegrees\n  tracker.update_yaw_servo();\n  // Get the direction of the error\n  get_ef_yaw_direction();\n  // Convert error from earth frame to body frame\n  convert_ef_to_bf();\n  // Update pitch servo\n  tracker.update_pitch_servo();\n  // Constrain the float\n  constrain_float();\n  // Calculate angle error\n  calc_angle_error();\n}", "CodeBleu_score": 9.235806099265453}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t  // update GPS\n  gps.update();\n\n  // check if the last message time has changed\n  if (gps.last_message_time_ms != last_message_time_ms) {\n    last_message_time_ms = gps.last_message_time_ms;\n\n    // check if the GPS status is at least 3D fix\n    if (gps.status >= 3) {\n      // check if the countdown is active\n      if (ground_start_countdown > 0) {\n        // check if the current location is valid\n        if (gps.location.isValid()) {\n          // set the home location\n          set_home();\n\n          // reset the countdown\n          ground_start_countdown = 0;\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 35.36851934716439}, {"code": "void Tracker::update_GPS(void){\n\t  // update GPS data\n  gps.update();\n\n  // check if the last message time has changed\n  if (gps.last_message_time_ms != last_message_time_ms) {\n    last_message_time_ms = gps.last_message_time_ms;\n\n    // check if the GPS status is at least 3D fix\n    if (gps.status >= 3) {\n      // if the location is valid, set the home location\n      if (gps.location.isValid()) {\n        set_home();\n      }\n    }\n  }\n\n  // manage a countdown for ground start\n  if (ground_start_countdown > 0) {\n    ground_start_countdown--;\n    if (ground_start_countdown == 1) {\n      // if the location is invalid, reset the countdown\n      if (!gps.location.isValid()) {\n        ground_start_countdown = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 43.77941034289638}, {"code": "void Tracker::update_GPS(void){\n\t  gps.update();\n  if (gps.last_message_time_ms() != last_message_time_ms) {\n    last_message_time_ms = gps.last_message_time_ms();\n    if (gps.status() >= 3) {\n      if (ground_start_countdown > 0) {\n        ground_start_countdown--;\n      }\n      if (ground_start_countdown == 1) {\n        set_home();\n      }\n    }\n  }\n}", "CodeBleu_score": 36.03278877718895}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // TODO: implement\n    if (pitch > 0) {\n        SRV_Pitch_OnOff.write(1);\n    } else {\n        SRV_Pitch_OnOff.write(0);\n    }\n}", "CodeBleu_score": 13.398734715771116}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// Set the pitch servo to the pitch value\n\tif (pitch < 0.0f) {\n\t\t// Set the pitch servo to the pitch value\n\t\tSRV_Pitch::set_output_scaled(-pitch);\n\t} else {\n\t\t// Set the pitch servo to the pitch value\n\t\tSRV_Pitch::set_output_scaled(pitch);\n\t}\n}", "CodeBleu_score": 12.082332167271872}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t  // If the pitch is within the range of the servo, send it\n  if (pitch >= -1.0f && pitch <= 1.0f) {\n    // Scale the pitch to the range of the servo\n    float pitch_scaled = SRV_Channels::set_output_scaled(pitch, PITCH_MIN, PITCH_MAX, PITCH_MIN_SERVO, PITCH_MAX_SERVO);\n    // Send the pitch to the servo\n    SRV_Channels::send_output(PITCH_SERVO_CHANNEL, pitch_scaled);\n  }\n}", "CodeBleu_score": 14.977368013824094}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    bool ret = AP_Arming::barometer_checks(display_failure);\n    if (ret && _arming_check_baro) {\n        float inertial_nav_alt = copter.inertial_nav.get_position_z_up_cm() / 100.0f;\n        float baro_alt = barometer.get_altitude();\n        float diff = fabsf(inertial_nav_alt - baro_alt);\n        if (diff > _baro_alt_threshold) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Baro altitude check failed: %f %f %f\n\"), (double)inertial_nav_alt, (double)baro_alt, (double)diff);\n            }\n            check_failed();\n            ret = false;\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 53.62542173431996}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n    if (AP_NotArmed::arming_check(arming.arming_checks, ARMING_CHECK_BARO)) {\n        return true;\n    }\n    if (abs(baro.get_altitude_cm() - inertial_nav.get_position_z_up_cm()) > 100) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Barometer altitude check failed\");\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 32.74202159692712}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call parent\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n    // check barometer reference\n    if (g.arming_check_baro) {\n        float baro_alt = barometer.get_altitude();\n        float inertial_alt = inertial_nav.get_position_z_up_cm() / 100.0f;\n        float diff = fabsf(baro_alt - inertial_alt);\n        if (diff > g.arming_baro_alt_err) {\n            if (display_failure) {\n                DataFlash.Log_Write_Error(ERROR_ARM_BARO_ALT);\n            }\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 46.47274485860622}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == AP_Terrain::RANGEFINDER) {\n        return false;\n    }\n    return copter.mode_rtl.get_alt_type() == RTL_ALT_TERRAIN;\n}", "CodeBleu_score": 35.788300907053106}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == AP_Terrain::SOURCE_RANGEFINDER) {\n        return false;\n    }\n    if (copter.mode_rtl.get_alt_type() == RTL_ALT_TYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 62.71826580298292}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t  if (copter.wp_nav->get_terrain_source() == AP_Terrain::RANGEFINDER) {\n    return false;\n  } else if (copter.mode_rtl.get_alt_type() == AP_RTL::RTL_ALT_TERRAIN) {\n    return true;\n  } else {\n    return AP_Arming::terrain_database_required();\n  }\n}", "CodeBleu_score": 57.87012981068693}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    // set the loop time for the attitude, position, and motor controllers\n    attitude_control->rate_controller_run();\n    position_control->rate_controller_run();\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n    // run the low-level rate controllers that require only IMU data\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 36.76619925662962}, {"code": "void Copter::run_rate_controller(){\n\t    // get the time of the last loop\n    float dt = AP::scheduler().get_last_loop_time_s();\n\n    // set dt for rate controllers\n    attitude_control->set_dt(dt);\n    pos_control->set_dt(dt);\n    motors->set_dt(dt);\n\n    // run the rate controllers\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 63.94741352450786}, {"code": "void Copter::run_rate_controller(){\n\t    // set the loop time for the attitude, position, and motor controllers\n    attitude_control->rate_controller_run();\n    pos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n}", "CodeBleu_score": 49.09361696377902}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // get the next waypoint location\n    Location target_location = flightmode->get_wp();\n    // check if the old location matches this waypoint\n    if (!old_loc.same_loc_as(target_location)) {\n        return false;\n    }\n    // check if the altitude frames of the old and new locations are the same\n    if (!old_loc.get_alt_frame().same_frame_as(new_loc.get_alt_frame())) {\n        return false;\n    }\n    // set the new location as the target\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 63.250412562698585}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (flightmode->get_wp() == NULL || !old_loc.same_loc_as(new_loc) || !old_loc.get_alt_frame().same_alt_frame_as(new_loc.get_alt_frame())) {\n        return false;\n    }\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 57.82727719937202}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (!new_loc.get_alt_frame().same_loc_as(old_loc.get_alt_frame())) {\n        return false;\n    }\n    if (!new_loc.same_loc_as(old_loc)) {\n        return false;\n    }\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 57.30490925909003}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (aux_switch_on(ch_flag)) {\n        copter.set_mode(mode);\n    }else if (copter.flightmode->mode_number == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 57.78600252572955}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (aux_function_active(ch_flag)) {\n        if (aux_function_value(ch_flag) == AUX_FUNCTION_ON) {\n            if (rc().mode_switch_enabled) {\n                if (rc().mode_switch_is_high()) {\n                    copter.set_mode(mode);\n                } else {\n                    // switch is not high so we reset the mode switch\n                    rc().reset_mode_switch();\n                }\n            } else {\n                copter.set_mode(mode);\n            }\n        }\n    }\n}", "CodeBleu_score": 53.85524875118832}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    // check for the aux switch in the HIGH position\n    if (aux_switch_on(ch_flag)) {\n        // set the mode\n        copter.set_mode(mode);\n    }else{\n        // if the switch is not in the HIGH position, and the current mode matches the given mode, reset the mode switch\n        if (copter.flightmode->mode_number == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 62.04099276132694}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // get the trim values from the channels\n    float roll_trim = channel_roll->get_control_in();\n    float pitch_trim = channel_pitch->get_control_in();\n\n    // convert to radians\n    roll_trim = ToRad(roll_trim);\n    pitch_trim = ToRad(pitch_trim);\n\n    // add the trim to the AHRS\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log the event\n    Log_Write_Event(DATA_TRIM_SAVED);\n\n    // send a confirmation message\n    gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 61.38267810685952}, {"code": "void Copter::save_trim(){\n\t    // save the trim values\n    ahrs.set_trim(channel_roll->get_control_in()*ToRad,\n                  channel_pitch->get_control_in()*ToRad);\n    // log the event\n    Log_Write_Event(LOGGER_WRITE_EVENT, LOG_MODE_APPEND, \"Copter saved trims: %f %f\",\n                    (double)channel_roll->get_control_in(),\n                    (double)channel_pitch->get_control_in());\n    // send a confirmation message\n    gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Copter saved trims: %f %f\",\n                      (double)channel_roll->get_control_in(),\n                      (double)channel_pitch->get_control_in());\n}", "CodeBleu_score": 44.801244901951556}, {"code": "void Copter::save_trim(){\n\t    // calculate trim from control inputs\n    float roll_trim = ToRad(channel_roll->get_control_in());\n    float pitch_trim = ToRad(channel_pitch->get_control_in());\n\n    // add trim to AHRS\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log event\n    Log_Write_Event(LOG_COPTER_SAVE_TRIM);\n\n    // send confirmation message\n    gcs().send_text_fmt(MAV_SEVERITY_INFO, \"Copter::save_trim() - roll:%f pitch:%f\", (double)roll_trim, (double)pitch_trim);\n}", "CodeBleu_score": 61.34565098277203}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    Vector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n    float speed_squared = vel.xy().length_squared();\n    if (copter.inertial_nav.position_ok() && speed_squared > LOOK_AHEAD_SPEED_THRESHOLD) {\n        look_ahead_yaw_angle = atan2f(vel.y, vel.x);\n        look_ahead_yaw_angle *= RADIANS_TO_DEGREES;\n    }\n    return look_ahead_yaw_angle;\n}", "CodeBleu_score": 53.48142594200519}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    float vel_xy_length_squared = copter.inertial_nav.get_velocity_neu_cms().xy().length_squared();\n    if (copter.inertial_nav.get_position_ok() && vel_xy_length_squared > MIN_LOOKAHEAD_SPEED_SQUARED) {\n        look_ahead_yaw = atan2f(copter.inertial_nav.get_velocity_neu_cms().y(), copter.inertial_nav.get_velocity_neu_cms().x());\n    }\n    return look_ahead_yaw;\n}", "CodeBleu_score": 39.19383046868764}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t  float speed_squared = copter.inertial_nav.get_velocity_neu_cms().xy().length_squared();\n  if (copter.inertial_nav.position_ok() && speed_squared > 1000) {\n    look_ahead_yaw_angle = atan2f(copter.inertial_nav.get_velocity_neu_cms().x, copter.inertial_nav.get_velocity_neu_cms().y) * 180.0 / M_PI;\n    if (look_ahead_yaw_angle < 0) {\n      look_ahead_yaw_angle += 360;\n    }\n    return look_ahead_yaw_angle;\n  }\n  return 0;\n}", "CodeBleu_score": 34.15437313267399}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    bool result = false;\n    switch (method) {\n        case AP_Arming::RUDDER:\n            result = _check_rudder_arming();\n            break;\n        default:\n            result = AP_Arming::arm_checks(method);\n            break;\n    }\n    return result;\n}", "CodeBleu_score": 36.132959882382416}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // rudder arming is disabled or throttle is not zero\n    if (method == AP_Arming::RUDDER && \n        (get_rudder_arming_type() == AP_Arming_Plane::DISABLED || \n         plane.get_throttle_input() != 0)) {\n        return false;\n    }\n    // if arming checks are disabled or watchdog was armed, bypass checks\n    if (!hal.util->get_soft_armed() || hal.util->was_watchdog_armed()) {\n        return true;\n    }\n    // run parent class's arm checks\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 50.166539264164975}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::RUDDER) {\n        // rudder arming checks\n        if (get_rudder_arming_type() == AP_Arming_Plane::DISABLED || plane.get_throttle_input() != 0) {\n            gcs().send_text(MAV_SEVERITY_INFO, \"Arming failed: rudder arming disabled or throttle not zero\");\n            return false;\n        }\n    }\n    // check if arming checks are disabled\n    if (hal.util->was_watchdog_armed()) {\n        // bypass arming checks\n        return true;\n    }\n    // check if the parent class's arm_checks method returns true\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 51.169640514830704}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\n    // we don't want to arm if we are already armed\n    if (plane.is_armed()) {\n        return false;\n    }\n\n    // if we are not in a position to arm, return false\n    if (!plane.is_flying()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, return false\n    if (!plane.is_allowed_arming_state()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, return false\n    if (!plane.is_allowed_arming_state()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, return false\n    if (!plane.is_allowed_arming_state()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, return false\n    if (!plane.is_allowed_arming_state()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, return false\n    if (!plane.is_allowed_arming_state()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, return false\n    if (!plane.is_allowed_arming_state()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, return false\n    if (!plane.is_allowed_arming_state()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, return false\n    if (!plane.is_allowed_arming_state()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, return false\n    if (!plane.is_allowed_arming_state()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed", "CodeBleu_score": 27.54065749903037}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // check if already armed\n    if (arm_state == ARM_STATE_ARMED) {\n        return false;\n    }\n\n    // check if we are already arming\n    if (arm_state == ARM_STATE_ARMING) {\n        return false;\n    }\n\n    // check if we are disarming\n    if (arm_state == ARM_STATE_DISARMING) {\n        return false;\n    }\n\n    // check if we are in a bad state\n    if (arm_state == ARM_STATE_FAILED) {\n        return false;\n    }\n\n    // check if we have a valid home location\n    if (!plane.home_is_set()) {\n        return false;\n    }\n\n    // check if we are in a valid location\n    if (!plane.current_loc.is_valid()) {\n        return false;\n    }\n\n    // check if we have a valid GPS fix\n    if (!plane.gps.status() >= AP_GPS::GPS_OK_FIX_2D) {\n        return false;\n    }\n\n    // check if we are in a valid airspeed\n    if (!plane.airspeed.healthy()) {\n        return false;\n    }\n\n    // check if we are in a valid altitude\n    if (!plane.terrain.use_terrain_takeoff_alt() && !plane.terrain.use_gps_for_takeoff_alt() && !plane.terrain.use_baro_for_takeoff_alt()) {\n        return false;\n    }\n\n    // check if we are in a valid position\n    if (!plane.terrain.use_gps_for_takeoff_alt() && !plane.terrain.use_baro_for_takeoff_alt()) {\n        return false;\n    }\n\n    // check if we are in a valid attitude\n    if (!plane.ahrs.healthy()) {\n        return false;\n    }\n\n    // check if we are in a valid battery voltage\n    if (!plane.battery.healthy()) {\n        return false;\n    }\n\n    // check", "CodeBleu_score": 31.678876994060335}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow arming if we are in a critical state\n    if (plane.is_failsafe_active()) {\n        return false;\n    }\n    // do not allow", "CodeBleu_score": 26.299087704024675}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (arming.is_armed()) {\n        return true;\n    }\n    if (!has_disarm_button()) {\n        if (display_failure) {\n            gcs_send_text_fmt(PSTR(\"AP_Arming_Sub::pre_arm_checks: no disarm button configured\"));\n        }\n        return false;\n    }\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 67.63574756505479}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (armed()) {\n        return true;\n    }\n    if (!has_disarm_function) {\n        if (display_failure) {\n            gcs_send_text_fmt(PSTR(\"Arming failed: no disarm function defined\"));\n        }\n        return false;\n    }\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 67.07610846566287}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // check if vehicle is already armed\n    if (armed()) {\n        return true;\n    }\n\n    // check if a disarm button is configured\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs_send_text_fmt(PSTR(\"Disarm button not configured\"));\n        }\n        return false;\n    }\n\n    // proceed with standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 72.00638821008418}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.35798259889287}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.35798259889287}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t  float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n  float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n  x = ne_x;\n  y = ne_y;\n}", "CodeBleu_score": 67.0217903083481}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // Check if the yaw angle is within the acceptable range.\n    if (!is_zero(packet.param1) && !is_equal(packet.param1, 180.0f)) {\n        // Yaw angle is not zero or 180.\n        if (!is_zero(packet.param1) && !is_equal(packet.param1, -180.0f)) {\n            // Yaw angle is not zero or -180.\n            // Check if the yaw angle is within the acceptable range.\n            if (!is_zero(packet.param1) && !is_equal(packet.param1, 360.0f)) {\n                // Yaw angle is not zero or 360.\n                // Check if the yaw angle is within the acceptable range.\n                if (!is_zero(packet.param1) && !is_equal(packet.param1, -360.0f)) {\n                    // Yaw angle is not zero or -360.\n                    // Check if the yaw angle is within the acceptable range.\n                    if (!is_zero(packet.param1) && !is_equal(packet.param1, 540.0f)) {\n                        // Yaw angle is not zero or 540.\n                        // Check if the yaw angle is within the acceptable range.\n                        if (!is_zero(packet.param1) && !is_equal(packet.param1, -540.0f)) {\n                            // Yaw angle is not zero or -540.\n                            // Check if the yaw angle is within the acceptable range.\n                            if (!is_zero(packet.param1) && !is_equal(packet.param1, 720.0f)) {\n                                // Yaw angle is not zero or 720.\n                                // Check if the yaw angle is within the acceptable range.\n                                if (!is_zero(packet.param1) && !is_equal(packet.param1, -720.0f)) {\n                                    // Yaw angle is not zero", "CodeBleu_score": 44.73015842212825}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_DENIED;\n    if (is_zero(packet.param1) && is_zero(packet.param2) && is_zero(packet.param3) && is_zero(packet.param4)) {\n        // set yaw heading to zero\n        sub.mode_auto.set_auto_yaw_look_at_heading(0);\n        result = MAV_RESULT_ACCEPTED;\n    } else if (is_equal(packet.param1, 1) && is_zero(packet.param2) && is_zero(packet.param3) && is_zero(packet.param4)) {\n        // set yaw heading to current heading\n        sub.mode_auto.set_auto_yaw_look_at_heading(sub.ahrs.yaw_sensor);\n        result = MAV_RESULT_ACCEPTED;\n    } else if (is_zero(packet.param1) && is_zero(packet.param2) && is_zero(packet.param3) && is_equal(packet.param4, 1)) {\n        // set yaw heading to current heading\n        sub.mode_auto.set_auto_yaw_look_at_heading(sub.ahrs.yaw_sensor);\n        result = MAV_RESULT_ACCEPTED;\n    } else if (is_zero(packet.param1) && is_zero(packet.param2) && is_zero(packet.param3) && is_equal(packet.param4, 2)) {\n        // set yaw heading to current heading\n        sub.mode_auto.set_auto_yaw_look_at_heading(sub.ahrs.yaw_sensor);\n        result = MAV_RESULT_ACCEPTED;\n    } else if (is_zero(packet.param1) && is_zero(packet.param2) && is_zero(packet.param3) && is_equal(packet.param4, 3)) {\n        // set yaw heading to current heading\n", "CodeBleu_score": 44.305678339727955}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_DENIED;\n    float yaw = packet.param1;\n    float lat = packet.param2;\n    float lon = packet.param3;\n    float alt = packet.param4;\n    float yaw_rate = packet.param5;\n    float loiter_radius = packet.param6;\n    float loiter_direction = packet.param7;\n\n    if (sub.mode_auto.is_zero()) {\n        result = MAV_RESULT_DENIED;\n        goto out;\n    }\n\n    if (sub.mode_auto.is_equal(MAV_MODE_AUTO_LOITER)) {\n        result = MAV_RESULT_DENIED;\n        goto out;\n    }\n\n    if (sub.mode_auto.is_equal(MAV_MODE_AUTO_RTL)) {\n        result = MAV_RESULT_DENIED;\n        goto out;\n    }\n\n    if (sub.mode_auto.is_equal(MAV_MODE_AUTO_LAND)) {\n        result = MAV_RESULT_DENIED;\n        goto out;\n    }\n\n    if (sub.mode_auto.is_equal(MAV_MODE_AUTO_TAKEOFF)) {\n        result = MAV_RESULT_DENIED;\n        goto out;\n    }\n\n    if (sub.mode_auto.is_equal(MAV_MODE_AUTO_FOLLOW_TARGET)) {\n        result = MAV_RESULT_DENIED;\n        goto out;\n    }\n\n    if (sub.mode_auto.is_equal(MAV_MODE_AUTO_PRECLAND)) {\n        result = MAV_RESULT_DENIED;\n        goto out;\n    }\n\n    if (sub.mode_auto.is_equal(MAV_MODE_AUTO_MISSION)) {\n        result = MAV_RESULT_DENIED;\n        goto out;\n    }\n\n    if (sub.mode", "CodeBleu_score": 36.96202613854022}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    //return _high_latency_tgt_heading;\n    return 0;\n}", "CodeBleu_score": 7.914038644833381}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    uint8_t ret = 0;\n\n    if (_mavlink->get_control_mode().flag_control_auto_enabled || _mavlink->get_control_mode().flag_control_guided_enabled) {\n        wrap_360_cd(sub.wp_nav.get_wp_bearing_to_destination());\n        ret = sub.wp_nav.get_wp_bearing_to_destination() / 2;\n    }\n\n    return ret;\n}", "CodeBleu_score": 49.887526510968584}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return (wrap_180_cd(sub.wp_nav.get_wp_bearing_to_destination()) / 2);\n    } else {\n        return 0;\n    }\n}", "CodeBleu_score": 51.42131680940377}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log) {\n        LogPacket packet = {\n            .time = AP_HAL::micros64(),\n            .id = id,\n            .value = value\n        };\n        logger.WriteCriticalBlock(&packet, sizeof(packet));\n    }\n}", "CodeBleu_score": 49.78845752536058}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t  if (should_log) {\n    uint8_t packet[LOG_PACKET_HEADER_SIZE + LOG_PACKET_DATA_SIZE];\n    LOG_PACKET_HEADER_INIT(packet, LOG_PACKET_DATA_SIZE, id);\n    LOG_PACKET_DATA_WRITE(packet, value);\n    logger.WriteCriticalBlock(packet, LOG_PACKET_HEADER_SIZE + LOG_PACKET_DATA_SIZE);\n  }\n}", "CodeBleu_score": 37.115356870315686}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\n\t// If logging is enabled\n\tif (should_log) {\n\n\t\t// Create a log packet with the current time, log data ID, and value\n\t\tLogPacket packet;\n\t\tpacket.time = AP_HAL::micros64();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\n\t\t// Write this packet to the logger as a critical block\n\t\tlogger.WriteCriticalBlock(&packet, sizeof(packet));\n\t}\n}", "CodeBleu_score": 42.71968569068592}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    if (ahrs.home_is_set) {\n        return;\n    }\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location();\n    }\n}", "CodeBleu_score": 49.00967058380202}, {"code": "void Sub::update_home_from_EKF(){\n\t\t// If the home is already set, exit immediately\n\tif (ahrs.home_is_set()) {\n\t\treturn;\n\t}\n\n\t// If the motors are armed, set the home to the current location in-flight\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t\treturn;\n\t}\n\n\t// If the motors are not armed, attempt to set the home to the current EKF location and ignore any failure in this attempt\n\tset_home_to_current_location();\n}", "CodeBleu_score": 40.21867513974133}, {"code": "void Sub::update_home_from_EKF(){\n\t    // if the motors are armed, set the home location to the current location\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    }\n    // if the motors are not armed, set the home location to the current EKF location\n    else {\n        // if the home is not already set, set it to the current EKF location\n        if (!ahrs.home_is_set()) {\n            set_home_to_current_location_EKF();\n        }\n    }\n}", "CodeBleu_score": 45.70295318875019}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t    // If not armed, set throttle to zero, relax attitude controllers, and exit\n    if (!motors.armed()) {\n        motors.set_throttle_out(0);\n        motors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // Set spool state to unlimited throttle\n    motors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n\n    // Convert pilot inputs to desired body frame rates\n    attitude_control->input_rate_bf_roll_pitch_yaw(\n        get_pilot_desired_angle_rates(channel_roll->get_control_in(),\n                                      channel_pitch->get_control_in(),\n                                      channel_yaw->get_control_in()));\n\n    // Run attitude controller\n    attitude_control->run();\n\n    // Set motor outputs\n    motors.set_forward(channel_forward->norm_input());\n    motors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 46.85922916663259}, {"code": "void ModeAcro::run(){\n\t    if (!motors.armed()) {\n        motors.set_throttle_out(0);\n        motors.set_desired_spool_state(Motors::SPOOL_STATE_OFF);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    motors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n\n    attitude_control->input_rate_bf_roll_pitch_yaw(\n        channel_roll->get_control_in(),\n        channel_pitch->get_control_in(),\n        channel_yaw->get_control_in());\n\n    attitude_control->set_throttle_out(\n        channel_throttle->norm_input());\n\n    motors.set_forward(channel_forward->norm_input());\n    motors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 41.66060888242041}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed()) {\n\t\tmotors.set_throttle_out(0);\n\t\tmotors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\tmotors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n\tfloat roll_in = channel_roll->get_control_in();\n\tfloat pitch_in = channel_pitch->get_control_in();\n\tfloat yaw_in = channel_yaw->get_control_in();\n\tfloat throttle_in = channel_throttle->norm_input();\n\tfloat roll_rate = roll_in * get_pilot_desired_angle_rates()->roll;\n\tfloat pitch_rate = pitch_in * get_pilot_desired_angle_rates()->pitch;\n\tfloat yaw_rate = yaw_in * get_pilot_desired_angle_rates()->yaw;\n\tattitude_control->input_rate_bf_roll_pitch_yaw(roll_rate, pitch_rate, yaw_rate);\n\tattitude_control->set_throttle_out(throttle_in);\n\tmotors.set_forward(channel_forward->norm_input());\n\tmotors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 53.673155214135114}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // XXX: this is a hack to get the correct initial yaw angle for the waypoint navigation\n    // we should be able to set the yaw angle in the waypoint controller directly\n    _vehicle_control_mode.flag_control_auto_enabled = false;\n    _vehicle_control_mode.flag_control_attitude_enabled = false;\n    _vehicle_control_mode.flag_control_position_enabled = false;\n    _vehicle_control_mode.flag_control_velocity_enabled = false;\n    _vehicle_control_mode.flag_control_altitude_enabled = false;\n    _vehicle_control_mode.flag_control_climb_rate_enabled = false;\n    _vehicle_control_mode.flag_control_position_velocity_enabled = false;\n    _vehicle_control_mode.flag_control_acceleration_enabled = false;\n    _vehicle_control_mode.flag_control_termination_enabled = false;\n    _vehicle_control_mode.flag_control_offboard_enabled = false;\n    _vehicle_control_mode.flag_control_rates_enabled = false;\n    _vehicle_control_mode.flag_control_manual_enabled = false;\n    _vehicle_control_mode.flag_control_acro_enabled = false;\n    _vehicle_control_mode.flag_control_rattitude_enabled = false;\n    _vehicle_control_mode.flag_control_velpos_enabled = false;\n    _vehicle_control_mode.flag_control_posvel_enabled = false;\n    _vehicle_control_mode.flag_control_velposrate_enabled = false;\n    _vehicle_control_mode.flag_control_manual_altitude_enabled = false;\n    _vehicle_control_mode.flag_control_manual_position_enabled = false;\n    _vehicle_control_mode.flag_control_manual_attitude_enabled = false;\n    _vehicle_control_mode.flag_control_manual_yawrate_enabled", "CodeBleu_score": 22.157348001805367}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set guided mode\n\t_internal_state.main_state = commander_state_s::MAIN_STATE_POSCTL;\n\t_internal_state.main_state_changes++;\n\t// Set position control state\n\t_internal_state.nav_state = vehicle_status_s::NAVIGATION_STATE_POSCTL;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.pos_control_nav_state = vehicle_status_s::NAVIGATION_STATE_POSCTL;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.guided_mode = true;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.guided_mode_changes++;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.control_mode_current = vehicle_status_s::NAVIGATION_STATE_POSCTL;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.control_mode_current_changes++;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.control_mode_changes++;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.control_mode_generation++;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.timestamp = hrt_absolute_time();\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.landed_state = vehicle_status_s::VEHICLE_STATE_ON_GROUND_MOVING;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.landed_state_changes++;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.vtol_transition_failsafe = false;\n\t// Set the flag that indicates that the position control is in guided mode\n\t_internal_state.vtol_transition_f", "CodeBleu_score": 34.36782283023071}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // TODO: set position control mode\n    // TODO: initialize the waypoint controller\n    // TODO: retrieve the stopping point\n    // TODO: set the waypoint destination\n    // TODO: initialize the yaw using the default auto yaw mode\n}", "CodeBleu_score": 3.006399650678141}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set max speed to pilot-defined value\n    position_control->set_max_speed_accel_xy(\n        _param_mpc_xy_cruise.get(),\n        _param_mpc_xy_cruise.get());\n\n    // initialize position controller vertical velocity control\n    position_control->init_z_controller();\n\n    // set vertical speed and acceleration limits\n    position_control->set_correction_speed_accel_z(\n        _param_mpc_z_cruise.get(),\n        _param_mpc_z_cruise.get());\n\n    // set yaw mode to auto-hold\n    set_auto_yaw_mode();\n}", "CodeBleu_score": 43.948734500716434}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t  // set the maximum speeds and acceleration for the vertical and horizontal velocity controllers\n  position_control->set_max_speed_accel_xy(\n      _param_mpc_xy_vel_max.get(),\n      _param_mpc_xy_acc_max.get());\n  position_control->set_max_speed_accel_z(\n      _param_mpc_z_vel_max_dn.get(),\n      _param_mpc_z_acc_max_dn.get());\n\n  // initialize the velocity controllers\n  position_control->init_xy_controller();\n  position_control->init_z_controller();\n\n  // set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n  set_auto_yaw_mode();\n}", "CodeBleu_score": 36.85897540460402}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // TODO: set max speed and acceleration\n    // TODO: initialize velocity controllers\n    // TODO: set auto yaw mode\n}", "CodeBleu_score": 2.2996549372656574}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have reached the timeout\n    if (hrt_elapsed_time(&_time_first_inside_orbit) > _param_mpc_land_delay.get() * 1000UL) {\n        return true;\n    }\n\n    // check if we have reached the maximum altitude\n    if (_param_mpc_land_alt2.get() > 0.0f && _global_pos.alt > _param_mpc_land_alt2.get()) {\n        return true;\n    }\n\n    // check if we have reached the minimum altitude\n    if (_param_mpc_land_alt1.get() > 0.0f && _global_pos.alt < _param_mpc_land_alt1.get()) {\n        return true;\n    }\n\n    // check if we have reached the desired distance from home\n    if (is_zero(_param_mpc_land_dis.get()) || _global_pos.alt < _param_mpc_land_alt1.get()) {\n        return false;\n    }\n\n    float dist_xy = get_horizontal_distance_cm(_home.get_position(), _global_pos.get_position());\n\n    if (dist_xy > _param_mpc_land_dis.get() * 100.0f) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 43.92616861521222}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    bool ret = false;\n    if (_time_wp_reached > 0) {\n        if (hrt_absolute_time() - _time_wp_reached > GUIDED_LIMIT_TIMEOUT) {\n            ret = true;\n        }\n    }\n    if (!ret && _alt_min_cm > 0) {\n        if (inertial_nav.get_altitude_cm() < _alt_min_cm) {\n            ret = true;\n        }\n    }\n    if (!ret && _alt_max_cm > 0) {\n        if (inertial_nav.get_altitude_cm() > _alt_max_cm) {\n            ret = true;\n        }\n    }\n    if (!ret && _dist_max_cm > 0) {\n        float dist_xy = get_horizontal_distance_cm();\n        if (dist_xy > _dist_max_cm) {\n            ret = true;\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 43.50132331028485}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    bool ret = false;\n    float time_since_takeoff = (float)(hrt_absolute_time() - _takeoff_time) / 1000000.0f;\n    if (time_since_takeoff > _param_mpc_land_delay.get()) {\n        ret = true;\n    }\n    if (_param_mpc_alt_max.get() > 0 && _global_pos.alt > _param_mpc_alt_max.get()) {\n        ret = true;\n    }\n    if (_param_mpc_alt_min.get() > 0 && _global_pos.alt < _param_mpc_alt_min.get()) {\n        ret = true;\n    }\n    if (_param_mpc_xy_cruise.get() > 0) {\n        float dist_since_takeoff = get_horizontal_distance_cm();\n        if (dist_since_takeoff > _param_mpc_xy_cruise.get() * 100.0f) {\n            ret = true;\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 39.023294219218975}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t  bool pass = true;\n  // if the motor test is not active, return true\n  if (!motor_test_active) {\n    return true;\n  }\n  // check if the motor test requests are received at least every 2 Hz\n  if (AP::arming().motor_test_received == 0) {\n    // if the motor test requests are not received, send a timeout message\n    gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Motor test timed out\"));\n    // set the pass flag to false\n    pass = false;\n    // disable the motor test\n    motor_test_active = false;\n    // disarm the system\n    AP::arming().disarm();\n    // record the failure time\n    motor_test_fail_time = AP::arming().motor_test_start_time;\n    // return false\n    return false;\n  }\n  // return true\n  return true;\n}", "CodeBleu_score": 58.45138351810581}, {"code": "bool Sub::verify_motor_test(){\n\t  if (motor_test_state == MOTOR_TEST_STATE_RUNNING) {\n    if (AP_HAL::millis() - motor_test_last_request_time > motor_test_timeout) {\n      gcs().send_text_fmt(MAV_SEVERITY_CRITICAL, \"Motor test timed out. Disabling motor test.\");\n      motor_test_pass = false;\n      motor_test_state = MOTOR_TEST_STATE_DISARMED;\n      AP::arming().disarm(false, true);\n      motor_test_fail_time = AP_HAL::millis();\n      return false;\n    }\n  }\n  if (motor_test_state == MOTOR_TEST_STATE_DISARMED) {\n    if (AP_HAL::millis() - motor_test_fail_time > motor_test_timeout) {\n      gcs().send_text_fmt(MAV_SEVERITY_CRITICAL, \"Motor test passed.\");\n      motor_test_pass = true;\n      motor_test_state = MOTOR_TEST_STATE_DISARMED;\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 55.09568845063788}, {"code": "bool Sub::verify_motor_test(){\n\t  // check if motor test requests are received at least every 2 Hz\n  if (AP_HAL::millis() - motor_test_last_request_time > 500) {\n    // send timeout message\n    gcs().send_text_fmt(MAV_SEVERITY_WARNING, \"Motor test timed out\");\n    // set pass flag to false\n    motor_test_pass = false;\n    // disable motor test\n    motor_test_enabled = false;\n    // disarm\n    AP::arming().disarm();\n    // record failure time\n    motor_test_failure_time = AP_HAL::millis();\n    // return false\n    return false;\n  }\n  // if the test passes, return true\n  return true;\n}", "CodeBleu_score": 46.44538370656591}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = 0;\n\tfloat pitch_target = 0;\n\tfloat roll_normalized = 0;\n\tfloat pitch_normalized = 0;\n\n\t/*\n\t * Retrieve roll and pitch targets from wp_nav in centidegrees.\n\t */\n\troll_target = wp_nav.get_roll();\n\tpitch_target = wp_nav.get_pitch();\n\n\t/*\n\t * Constrain roll and pitch targets within a specified maximum angle range.\n\t */\n\troll_target = constrain_int16(roll_target, -1000, 1000);\n\tpitch_target = constrain_int16(pitch_target, -1000, 1000);\n\n\t/*\n\t * Normalize roll and pitch targets.\n\t */\n\troll_normalized = (float)roll_target / 100;\n\tpitch_normalized = (float)pitch_target / 100;\n\n\t/*\n\t * Assign normalized roll and pitch targets to lateral_out and forward_out.\n\t */\n\tlateral_out = roll_normalized;\n\tforward_out = pitch_normalized;\n\n}", "CodeBleu_score": 41.299021576843096}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // Get roll and pitch targets from wp_nav in centidegrees\n    float roll_target = wp_nav.get_roll() * 100;\n    float pitch_target = wp_nav.get_pitch() * 100;\n\n    // Constrain roll and pitch targets within a specified maximum angle range\n    roll_target = constrain_int16(roll_target, -1000, 1000);\n    pitch_target = constrain_int16(pitch_target, -1000, 1000);\n\n    // Normalize roll and pitch targets\n    float roll_norm = roll_target / 1000;\n    float pitch_norm = pitch_target / 1000;\n\n    // Assign normalized roll and pitch targets to lateral_out and forward_out\n    lateral_out = roll_norm;\n    forward_out = pitch_norm;\n}", "CodeBleu_score": 42.200096113949634}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t  int16_t roll_target, pitch_target;\n  int16_t roll_max, pitch_max;\n\n  roll_max = constrain_int16(wp_nav.get_roll(), -300, 300);\n  pitch_max = constrain_int16(wp_nav.get_pitch(), -300, 300);\n\n  roll_target = constrain_int16(roll_max, -100, 100);\n  pitch_target = constrain_int16(pitch_max, -100, 100);\n\n  lateral_out = (float)roll_target / 100.0;\n  forward_out = (float)pitch_target / 100.0;\n}", "CodeBleu_score": 44.81884969466539}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t  // Read barometer data\n  barometer.update();\n\n  // If the altitude is above zero, update the barometer calibration\n  if (barometer.get_altitude() > 0) {\n    barometer.update_calibration();\n  }\n\n  // If a depth sensor is present, update the sensor health status based on the barometer's health\n  if (depth_sensor_present) {\n    if (barometer.healthy()) {\n      depth_sensor_healthy = true;\n    } else {\n      depth_sensor_healthy = false;\n    }\n  }\n}", "CodeBleu_score": 70.93776280335253}, {"code": "void Sub::read_barometer(){\n\t  barometer.update();\n  if (barometer.get_altitude() > 0) {\n    barometer.update_calibration();\n  }\n  if (depth_sensor_present) {\n    if (barometer.healthy()) {\n      depth_sensor_healthy = true;\n    } else {\n      depth_sensor_healthy = false;\n    }\n  }\n}", "CodeBleu_score": 70.8635872213841}, {"code": "void Sub::read_barometer(){\n\t  // Read barometer data\n  barometer.get_altitude();\n  barometer.update();\n\n  // If the altitude is above zero, update the barometer calibration\n  if (barometer.altitude > 0) {\n    barometer.update_calibration();\n  }\n\n  // If a depth sensor is present, update the sensor health status based on the barometer's health\n  if (depth_sensor_present) {\n    if (barometer.healthy) {\n      depth_sensor_healthy = true;\n    } else {\n      depth_sensor_healthy = false;\n    }\n  }\n}", "CodeBleu_score": 67.57966691977131}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t  // check if inertial nav is available\n  if (!inertial_nav.get_filter_status().flags.relative_position) {\n    return false;\n  }\n\n  // check if motors are armed\n  if (!motors.armed()) {\n    // if motors are disarmed, accept a predicted horizontal position\n    return inertial_nav.get_filter_status().flags.predicted_position;\n  }\n\n  // motors are armed, ensure EKF is not in constant position mode\n  return !inertial_nav.get_filter_status().flags.constant_position_mode;\n}", "CodeBleu_score": 47.98610385548348}, {"code": "bool Sub::ekf_position_ok(){\n\t    return (inertial_nav.get_filter_status() & inertial_nav.FILTER_STATUS_GPS_FIX) != 0;\n}", "CodeBleu_score": 21.051649841344528}, {"code": "bool Sub::ekf_position_ok(){\n\t    return inertial_nav.get_filter_status().flags.relative_position_valid;\n}", "CodeBleu_score": 10.628516608406388}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n    if (rover.control_mode->requires_position && !ahrs.pre_arm_check(display_failure)) {\n        return false;\n    }\n    if (rover.control_mode->requires_velocity && !rover.ekf_position_ok(display_failure)) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 33.35165080893231}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n    // if we are in a mode that doesn't require position or velocity, we are ok\n    if (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\n        return true;\n    }\n    // check if AHRS system is ready\n    if (!ahrs.pre_arm_check()) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"AHRS not ready\");\n        }\n        return false;\n    }\n    // check if EKF failsafe is active\n    if (rover.ekf_failsafe.enabled()) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"EKF failsafe active\");\n        }\n        return false;\n    }\n    // check if position estimate is valid\n    if (!rover.ekf_position_ok()) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"Position estimate invalid\");\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 61.4737568899121}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // if not requiring position or velocity, then we can pass\n    if (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\n        return true;\n    }\n\n    // call parent class's GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ahrs.pre_arm_check()) {\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (rover.ekf_position_ok()) {\n        return true;\n    }\n\n    // check if position estimate is valid\n    if (check_failed(rover.control_mode->requires_position, rover.position_ok(), display_failure)) {\n        return false;\n    }\n\n    // check if velocity estimate is valid\n    if (check_failed(rover.control_mode->requires_velocity, rover.velocity_ok(), display_failure)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 50.99247784076708}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // record the time of the last arm request\n    _last_arm_time = hal.scheduler->millis();\n\n    // record the last arming method\n    _last_arming_method = method;\n\n    // if we are already armed, return immediately\n    if (armed()) {\n        return true;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we are not ready to arm, return immediately\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // if we", "CodeBleu_score": 30.03994380954065}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (do_arming_checks) {\n        if (!pre_arm_checks()) {\n            return false;\n        }\n    }\n    if (!arm_switch_available()) {\n        return false;\n    }\n    if (!arm_switch_enabled()) {\n        return false;\n    }\n    if (!arm_switch_failsafe()) {\n        return false;\n    }\n    if (method == AP_Arming::RC_SWITCH) {\n        if (!arm_switch_rc_failsafe()) {\n            return false;\n        }\n    }\n    if (method == AP_Arming::RC_SWITCH && !arm_switch_rc_failsafe()) {\n        return false;\n    }\n    if (method == AP_Arming::RC_SWITCH && !arm_switch_rc_failsafe()) {\n        return false;\n    }\n    if (method == AP_Arming::RC_SWITCH && !arm_switch_rc_failsafe()) {\n        return false;\n    }\n    if (method == AP_Arming::RC_SWITCH && !arm_switch_rc_failsafe()) {\n        return false;\n    }\n    if (method == AP_Arming::RC_SWITCH && !arm_switch_rc_failsafe()) {\n        return false;\n    }\n    if (method == AP_Arming::RC_SWITCH && !arm_switch_rc_failsafe()) {\n        return false;\n    }\n    if (method == AP_Arming::RC_SWITCH && !arm_switch_rc_failsafe()) {\n        return false;\n    }\n    if (method == AP_Arming::RC_SWITCH && !arm_switch_rc_failsafe()) {\n        return false;\n    }\n    if (method == AP_Arming::RC_SWITCH && !arm_switch_rc_failsafe()) {\n        return false;\n    }\n    if (method == AP_Arming::RC_SWITCH && !arm_switch_rc_failsafe()) {", "CodeBleu_score": 37.58956210598844}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // record the method used to arm the vehicle\n    _arming_method = method;\n\n    // perform arming checks if required\n    if (do_arming_checks && !check_arming_allowed()) {\n        return false;\n    }\n\n    // set home location for SmartRTL\n    rover.g2.smart_rtl.set_home();\n\n    // initialise the simple mode heading\n    rover.mode_simple.init_heading();\n\n    // record the home heading for sail vehicles\n    rover.g2.windvane.record_home_heading();\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    send_arm_disarm_statustext();\n\n    // arming succeeded\n    return true;\n}", "CodeBleu_score": 54.0550134822519}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (shouldCharge) {\n      digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n      charging_enabled = true;\n      charge_start_time = millis();\n      charging_disabled_time = 0;\n    }\n  } else {\n    if (charging_enabled) {\n      digitalWrite(CHARGE_ENABLE_PIN, LOW);\n      charging_enabled = false;\n      charge_start_time = 0;\n      charging_disabled_time = millis();\n    } else {\n      if (millis() - charging_disabled_time > CHARGING_RETRY_DELAY) {\n        updateChargingEnabled();\n      }\n    }\n  }\n}", "CodeBleu_score": 65.03112030392893}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed && !charging_enabled) {\n    charging_enabled = true;\n    digitalWrite(CHARGE_ENABLE, HIGH);\n    charging_start_time = millis();\n  } else if (!charging_allowed && charging_enabled) {\n    digitalWrite(CHARGE_ENABLE, LOW);\n    charging_enabled = false;\n    charging_stop_time = millis();\n    if (charging_stop_time - charging_start_time > 10000) {\n      charging_stop_time = 0;\n      charging_start_time = 0;\n    }\n    delay(500);\n    updateChargingEnabled();\n  }\n}", "CodeBleu_score": 49.23716757355711}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (checkShouldCharge()) {\n      digitalWrite(CHARGING_ENABLE_PIN, HIGH);\n      charging_enabled = true;\n      charging_enabled_time = millis();\n    } else {\n      digitalWrite(CHARGING_ENABLE_PIN, LOW);\n      charging_enabled = false;\n      charging_enabled_time = millis();\n    }\n  } else {\n    if (charging_enabled) {\n      digitalWrite(CHARGING_ENABLE_PIN, LOW);\n      charging_enabled = false;\n    } else {\n      if (millis() - charging_enabled_time > CHARGING_ENABLE_DELAY) {\n        updateChargingEnabled();\n      }\n    }\n  }\n}", "CodeBleu_score": 66.5207875578253}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t  if (ros::ok() && size >= 4) {\n    uint8_t *messageWithCRC = (uint8_t *)malloc(size + 2);\n    memcpy(messageWithCRC, message, size);\n    uint16_t crc = CRC16.ccitt(messageWithCRC, size);\n    messageWithCRC[size] = crc & 0xff;\n    messageWithCRC[size + 1] = crc >> 8;\n    packetSerial.send(messageWithCRC, size + 2);\n    free(messageWithCRC);\n  }\n}", "CodeBleu_score": 49.22346016999434}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros::ok() && size >= 4) {\n    uint8_t *msg = (uint8_t *)message;\n    uint16_t crc = CRC16.ccitt(msg, size);\n    msg[size] = crc & 0xff;\n    msg[size + 1] = crc >> 8;\n    packetSerial.send(msg, size + 2);\n  }\n}", "CodeBleu_score": 48.786110951772265}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros::ok() && size >= 4) {\n    uint16_t crc = CRC16.ccitt(message, size);\n    uint8_t *crc_ptr = (uint8_t *)&crc;\n    uint8_t *message_ptr = (uint8_t *)message;\n    message_ptr[size] = crc_ptr[0];\n    message_ptr[size + 1] = crc_ptr[1];\n    packetSerial.send(message, size + 2);\n  }\n}", "CodeBleu_score": 52.81055313272759}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t  // initialize the serial port\n  soundSerial.begin(9600);\n  // flush the serial port\n  soundSerial.flush();\n  // initialize the sound module\n  sendCommand(CMD_INIT);\n  // wait for the response\n  while (!soundSerial.available());\n  // read the response\n  soundSerial.read();\n  // get the number of sound files\n  numSdTracks = getNumTracks();\n  // return true if there is at least one sound file\n  return (numSdTracks > 0);\n}", "CodeBleu_score": 48.98127732317744}, {"code": "bool MP3Sound::begin(){\n\t  if (soundSerial.begin(9600) == 0) {\n    return false;\n  }\n  soundSerial.flush();\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0x01);\n  soundSerial.write(0x01);\n  soundSerial.write(0xEF);\n  delay(100);\n  if (soundSerial.available() == 0) {\n    return false;\n  }\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  sound", "CodeBleu_score": 35.57195325015117}, {"code": "bool MP3Sound::begin(){\n\t  // initialize the serial connection:\n  soundSerial.begin(9600);\n  // flush the serial port buffer:\n  soundSerial.flush();\n  // send the initialization command to the sound module:\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x01);\n  soundSerial.write(0x56);\n  soundSerial.write(0xAE);\n  // wait for the sound module to respond with the number of sound files available:\n  while (soundSerial.available() < 1);\n  // read the number of sound files available:\n  numSdTracks = soundSerial.read();\n  // return true if there is at least one sound file available:\n  return (numSdTracks > 0);\n}", "CodeBleu_score": 52.34120055424979}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0) {\n\t\treturn active_sounds.size();\n\t}\n\tif (myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\tmyMP3.play(active_sounds.back());\n\tactive_sounds.pop_back();\n\treturn active_sounds.size();\n}", "CodeBleu_score": 46.21548009356336}, {"code": "int MP3Sound::processSounds(){\n\t  int num_sounds = active_sounds.size();\n  if (num_sounds == 0) {\n    return num_sounds;\n  }\n  if (myMP3.isPlaying()) {\n    return num_sounds;\n  }\n  myMP3.play(active_sounds.back());\n  active_sounds.pop_back();\n  return active_sounds.size();\n}", "CodeBleu_score": 62.11760902704706}, {"code": "int MP3Sound::processSounds(){\n\t  int active_sounds_size = active_sounds.size();\n  if (active_sounds_size == 0) {\n    return active_sounds_size;\n  }\n  if (myMP3.isPlaying()) {\n    return active_sounds_size;\n  }\n  myMP3.play(active_sounds.back());\n  active_sounds.pop_back();\n  return active_sounds.size();\n}", "CodeBleu_score": 60.04926877081551}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *ac = d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      const char *filename = wb_request_read_string(r);\n      if (filename) {\n        if (ac->memory_mapped_file)\n          munmap(ac->memory_mapped_file, ac->memory_mapped_file_size);\n        ac->memory_mapped_file = NULL;\n        ac->memory_mapped_file_size = 0;\n        ac->memory_mapped_file = wb_camera_set_memory_mapped_file(d, filename);\n        if (ac->memory_mapped_file)\n          ac->memory_mapped_file_size = wb_camera_get_memory_mapped_file_size(d);\n      }\n      wb_request_write_uchar(r, ac->memory_mapped_file ? 1 : 0);\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 47.03546259955751}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (camera->memory_mapped_file)\n      wb_camera_cleanup(camera);\n    wb_camera_setup(camera, r);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 26.410441879190472}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *ac = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (ac->memory_mapped_file)\n        munmap(ac->memory_mapped_file, ac->memory_mapped_file_size);\n      ac->memory_mapped_file = NULL;\n      ac->memory_mapped_file_size = 0;\n      int file_descriptor = open(r->read_string(), O_RDWR);\n      if (file_descriptor == -1) {\n        fprintf(stderr, \"Error: cannot open memory-mapped file '%s'.\n\", r->read_string());\n        return false;\n      }\n      struct stat st;\n      if (fstat(file_descriptor, &st) == -1) {\n        fprintf(stderr, \"Error: cannot stat memory-mapped file '%s'.\n\", r->read_string());\n        close(file_descriptor);\n        return false;\n      }\n      ac->memory_mapped_file_size = st.st_size;\n      ac->memory_mapped_file = mmap(NULL, ac->memory_mapped_file_size, PROT_READ | PROT_WRITE, MAP_SHARED, file_descriptor, 0);\n      if (ac->memory_mapped_file == MAP_FAILED) {\n        fprintf(stderr, \"Error: cannot map memory-mapped file '%s'.\n\", r->read_string());\n        close(file_descriptor);\n        return false;\n      }\n      close(file_descriptor);\n      break;\n    }\n    default:\n      return false;\n  }\n  return true;\n}", "CodeBleu_score": 46.15713567797947}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int result = -1;\n  robot_mutex_lock_step();\n  AbstractCamera *camera = abstract_camera_get_struct(d);\n  if (camera)\n    result = camera->height;\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 64.08867871152411}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int result = -1;\n  robot_mutex_lock_step();\n  AbstractCamera *camera = abstract_camera_get_struct(d);\n  if (camera)\n    result = camera->height;\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 64.08867871152411}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height;\n  robot_mutex_lock_step();\n  height = d->pdata->camera->height;\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 48.62310473382497}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  robot_mutex_lock();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    sampling_period = 0;\n  }\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 55.679169084684844}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  robot_mutex_lock();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    sampling_period = 0;\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  }\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 55.33780611667628}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  WbDevice *d = robot_get_device_with_node(tag, WB_NODE_ACCELEROMETER, true);\n  if (!d)\n    return 0;\n  robot_mutex_lock_step();\n  WbAccelerometer *a = d->pdata;\n  if (a->sampling_period == 0)\n    fprintf(stderr, \"Error: %s() called for a disabled device! Please use: wb_accelerometer_enable().\n\", __FUNCTION__);\n  int period = a->sampling_period;\n  robot_mutex_unlock_step();\n  return period;\n}", "CodeBleu_score": 37.19852033480872}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(const_cast<char *>(dms));\n  free(dms);\n  return result;\n}", "CodeBleu_score": 46.471147739885645}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = static_cast<string>(const_cast<char *>(dms));\n  free(dms);\n  return result;\n}", "CodeBleu_score": 55.6389530397148}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dmsString = static_cast<string>(dms);\n  free(const_cast<char *>(dms));\n  return dmsString;\n}", "CodeBleu_score": 56.799248138968515}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dAASSERT (g && g->type == dBoxClass);\n    dUASSERT (plane, \"argument plane is NULL\");\n    dVector3 pos,normal;\n    dReal *side = ((dxBox*)g)->side;\n    dReal *R = ((dxBox*)g)->final_posr->R;\n    dReal *pos2 = ((dxBox*)g)->final_posr->pos;\n    dReal *pos1 = ((dxBox*)g)->final_posr->pos;\n    pos[0] = x - pos1[0];\n    pos[1] = y - pos1[1];\n    pos[2] = z - pos1[2];\n    dMultiply1_331 (normal,R,pos);\n    dReal max = dFabs (normal[0]);\n    dReal dot = dCalcVectorDot3_41 (normal,R+0);\n    if (dFabs (dot) > max) {\n        max = dFabs (dot);\n        normal[0] = dot;\n        normal[1] = 0;\n        normal[2] = 0;\n    }\n    dot = dCalcVectorDot3_41 (normal,R+4);\n    if (dFabs (dot) > max) {\n        max = dFabs (dot);\n        normal[0] = dot;\n        normal[1] = 0;\n        normal[2] = 0;\n    }\n    dot = dCalcVectorDot3_41 (normal,R+8);\n    if (dFabs (dot) > max) {\n        max = dFabs (dot);\n        normal[0] = dot;\n        normal[1] = 0;\n        normal[2] = 0;\n    }\n    dot = dCalcVectorDot3_41 (normal,R+1);\n    if (dFabs (dot) > max) {\n        max = dFabs (dot);\n        normal[0] = 0;\n        normal[1] = dot;\n        normal[2] = 0;\n    }\n    dot = dCalcVectorDot3", "CodeBleu_score": 38.960313644086554}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  dUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n  dxBox *b = (dxBox *) g;\n  dVector3 relpos;\n  dReal side[3];\n  dReal proj[3];\n  dReal min, max, d;\n  int i;\n  dReal *pos = b->final_posr->pos;\n  dVector3 sides = {b->side[0], b->side[1], b->side[2]};\n\n  // compute the relative position of the point to the box center\n  relpos[0] = x - pos[0];\n  relpos[1] = y - pos[1];\n  relpos[2] = z - pos[2];\n\n  // find the side that the point is closest to\n  side[0] = dFabs (relpos[0]) - sides[0];\n  side[1] = dFabs (relpos[1]) - sides[1];\n  side[2] = dFabs (relpos[2]) - sides[2];\n  if (side[0] < side[1]) {\n    if (side[0] < side[2]) {\n      // side[0] is closest\n      if (relpos[0] > 0) {\n        // positive side is closest\n        plane[0] = 1;\n        plane[1] = 0;\n        plane[2] = 0;\n        plane[3] = -sides[0];\n      }\n      else {\n        // negative side is closest\n        plane[0] = -1;\n        plane[1] = 0;\n        plane[2] = 0;\n        plane[3] = sides[0];\n      }\n    }\n    else {\n      // side[2] is closest\n      if (relpos[2] > 0) {\n        // positive side is closest\n        plane[0] = 0;\n        plane[1] = 0;\n        plane[2] = 1;\n        plane[3] = -sides[2];\n      }\n      else {\n        // negative side is closest\n        plane[0] = ", "CodeBleu_score": 38.536411607833124}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdAASSERT (g && g->type == dBoxClass);\n\tdUASSERT (plane, \"argument plane is NULL\");\n\n\tconst dxBox *b = (dxBox*) g;\n\n\tdVector3 p,q,r;\n\tdVector3Subtract (&b->final_posr->pos[0], &b->final_posr->pos[0], &p[0]);\n\tdVector3Subtract (&p[0], &b->final_posr->pos[0], &q[0]);\n\tdVector3Subtract (&q[0], &b->final_posr->pos[0], &r[0]);\n\n\tdVector3 n;\n\tdVector3Cross (&q[0], &r[0], &n[0]);\n\tdVector3Normalize3 (&n[0]);\n\n\tdReal d = dVector3Dot (&n[0], &b->final_posr->pos[0]);\n\n\tplane[0] = n[0];\n\tplane[1] = n[1];\n\tplane[2] = n[2];\n\tplane[3] = d;\n}", "CodeBleu_score": 26.308976044870196}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 7.193979290691487}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dAASSERT (box);\n  dAASSERT (fluidPlane);\n  dAASSERT (immersion);\n  dUASSERT (flags >= 0 && flags < dIVERTEXCOUNT, \"invalid flag\");\n  dUASSERT (box->body, \"box must be connected to a body\");\n  dUASSERT (box->sidecount >= 4 && box->sidecount <= 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == 6, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 6 || box->sidecount == 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == 6 ||\n            box->sidecount == 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == 6 ||\n            box->sidecount == 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == 6 ||\n            box->sidecount == 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == 6 ||\n            box->sidecount == 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == 6 ||\n            box->sidecount == 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == 6 ||\n            box->sidecount == 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == 6 ||\n            box->sidecount == 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == 6 ||\n            box->sidecount == 8, \"invalid sidecount\");\n  dUASSERT (box->sidecount == 4 || box->sidecount == ", "CodeBleu_score": 39.23945821545694}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n  dAASSERT (box && box->body && (flags & (dIMMERSE_BOX_BODY | dIMMERSE_BOX_FLUID)) == dIMMERSE_BOX_BODY);\n\n  dImmersionData data;\n  data.performImmersionChecking = 1;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.flags = flags;\n  data.immersion = immersion;\n\n  dImmerseGeneric (&data);\n\n  return data.result;\n}", "CodeBleu_score": 46.688039221437904}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (immersion);\n  dIASSERT ((flags & NUMI_MASK) >= 1 && (flags & NUMI_MASK) <= 3);\n  dIASSERT (flags & (IMMERSION_BOX | IMMERSION_CAPSULE));\n\n  // Validate the input arguments\n  if (dGeomGetClass(o1) != dBoxClass) {\n    dDEBUGMSG (\"Capsule-Box immersion: The first geom is not a box.\");\n    return 0;\n  }\n  if (dGeomGetClass(o2) != dCapsuleClass) {\n    dDEBUGMSG (\"Capsule-Box immersion: The second geom is not a capsule.\");\n    return 0;\n  }\n\n  // Compute the immersion plane for the capsule\n  dVector3 normal;\n  dReal depth = dCollideCapsuleBox (o2, o1, normal);\n  if (depth < 0) {\n    // No collision\n    return 0;\n  }\n\n  // Set the immersion parameters\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n  immersion->flags = flags;\n  immersion->depth = depth;\n  immersion->normal = normal;\n\n  // Process the immersion of the box in the fluid\n  return dImmerseBox (o1, immersion);\n}", "CodeBleu_score": 50.374629544191876}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (immersion != NULL);\n  dIASSERT (immersion->box != NULL);\n  dIASSERT (immersion->capsule != NULL);\n  dIASSERT ((flags & NUMI_MASK) >= 1 && (flags & NUMI_MASK) <= 3);\n  dIASSERT ((flags & IGNORE_RAY) == 0);\n  dIASSERT ((flags & IGNORE_CONTACTS) == 0);\n\n  dUASSERT (o1->type == dBoxClass, \"argument 1 must be a box\");\n  dUASSERT (o2->type == dCapsuleClass, \"argument 2 must be a capsule\");\n\n  dImmerseBox (o1, o2, flags, immersion);\n  return immersion->num_contacts;\n}", "CodeBleu_score": 37.687699551563725}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (immersion != NULL);\n  dIASSERT (immersion->flip == 0);\n  dIASSERT ((flags & NUMC_MASK) >= 1 && (flags & NUMC_MASK) <= 3);\n  dIASSERT (flags >= 0 && flags < (dContactGeomFlag) 0x000000ff);\n\n  dUASSERT (o1->type == dBoxClass, \"argument 1 must be a box\");\n  dUASSERT (o2->type == dCapsuleClass, \"argument 2 must be a capsule\");\n\n  dxBox *b = (dxBox *) o1;\n  dxCapsule *c = (dxCapsule *) o2;\n\n  const dReal *R1 = dGeomGetRotation (o1);\n  const dReal *R2 = dGeomGetRotation (o2);\n  const dReal *pos1 = dGeomGetPosition (o1);\n  const dReal *pos2 = dGeomGetPosition (o2);\n\n  dVector3 normal;\n  dReal depth;\n  dReal radius = c->radius;\n  dReal length = c->lz;\n\n  dVector3 ss,tt;\n  dReal s,t;\n  dReal side1,side2,side3;\n\n  // get the vector from the box center to the capsule center\n  dVector3 center;\n  center[0] = pos2[0] - pos1[0];\n  center[1] = pos2[1] - pos1[1];\n  center[2] = pos2[2] - pos1[2];\n\n  // find the nearest point on the box to the center of the capsule\n  dVector3 q;\n  q[0] = center[0];\n  q[1] = center[1];\n  q[2] = center[2];\n  dVector3Cross (&R1[0],&center[0],&ss[0]);\n  dVector3Cross (&R1[0],&ss[0],&tt[0]);\n  dVector3Cross (&R", "CodeBleu_score": 45.23586450961417}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    dReal zIOverR2 = zIOverR * zIOverR;\n    dReal tanTheta02 = tanTheta0 * tanTheta0;\n    dReal sinTheta12 = sinTheta1 * sinTheta1;\n\n    dReal zIOverR2_tanTheta02 = zIOverR2 * tanTheta02;\n    dReal zIOverR2_sinTheta12 = zIOverR2 * sinTheta12;\n\n    dReal cosTheta0 = dSqrt(dRecip(1.0f + tanTheta02));\n    dReal cosTheta1 = dSqrt(dRecip(1.0f + sinTheta12));\n\n    dReal sinTheta0 = dSqrt(dRecip(1.0f - tanTheta02));\n    dReal sinTheta1 = dSqrt(dRecip(1.0f - sinTheta12));\n\n    dReal cosTheta0_zIOverR2 = cosTheta0 * zIOverR2;\n    dReal cosTheta1_zIOverR2 = cosTheta1 * zIOverR2;\n\n    dReal sinTheta0_zIOverR2 = sinTheta0 * zIOverR2;\n    dReal sinTheta1_zIOverR2 = sinTheta1 * zIOverR2;\n\n    dReal cosTheta0_zIOverR2_tanTheta02 = cosTheta0_zIOverR2 * tanTheta02;\n    dReal cosTheta1_zIOverR2_sinTheta12 = cosTheta1_zIOverR2 * sinTheta12;\n\n    dReal sinTheta0_zIOverR2_tanTheta02 = sinTheta0_zIOverR2 * tanTheta02;\n    dReal sinTheta1_zIOverR2_sinTheta12 = sinTheta1_zIOverR2 * sinTheta12;\n\n    dReal cosTheta0_zIOverR2_tanTheta02_zIOverR2_sinTheta12 = cosTheta0_zIOverR2_tanTheta02 * zIOverR2_sinTheta12;\n    d", "CodeBleu_score": 35.18749615388379}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    dReal zI = zIOverR * m_radius;\n    dReal z0 = m_capsuleLength * tanTheta0;\n    dReal z1 = m_capsuleLength * sinTheta1;\n\n    dReal z0OverR = z0 / m_radius;\n    dReal z1OverR = z1 / m_radius;\n\n    dReal tanTheta1 = sinTheta1 / tanTheta0;\n\n    dReal cosTheta0 = dSqrt(dRecip(1.0 + z0OverR * z0OverR));\n    dReal cosTheta1 = dSqrt(dRecip(1.0 + z1OverR * z1OverR));\n\n    dReal cosTheta = dSqrt(dRecip(1.0 + zIOverR * zIOverR));\n\n    dReal sinTheta0 = dSqrt(dRecip(1.0 - cosTheta0 * cosTheta0));\n    dReal sinTheta1 = dSqrt(dRecip(1.0 - cosTheta1 * cosTheta1));\n\n    dReal sinTheta = dSqrt(dRecip(1.0 - cosTheta * cosTheta));\n\n    dReal tanTheta = sinTheta / cosTheta;\n\n    dReal sinTheta0OverR = sinTheta0 / m_radius;\n    dReal sinTheta1OverR = sinTheta1 / m_radius;\n\n    dReal sinThetaOverR = sinTheta / m_radius;\n\n    dReal cosTheta0OverR = cosTheta0 / m_radius;\n    dReal cosTheta1OverR = cosTheta1 / m_radius;\n\n    dReal cosThetaOverR = cosTheta / m_radius;\n\n    dReal z0OverR2 = z0OverR * z0OverR;\n    dReal z1OverR2 = z1OverR * z1OverR;\n\n    dReal zIOverR2 = zIOverR * zIOverR;\n\n    dReal sinTheta0OverR2 = sinTheta0OverR * sinTheta0OverR;\n    dReal sinTheta1OverR2 = sinTheta1OverR * sinTheta1OverR;", "CodeBleu_score": 34.636359134190954}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\t// The hemisphere volume is given by:\n\t//\n\t//\t\tV = (2/3) pi r^3 (1 - cos(theta))\n\t//\n\t// where theta is the angle between the capsule axis and the hemisphere axis.\n\t//\n\t// The normalized hemisphere volume is given by:\n\t//\n\t//\t\tV / (pi r^3) = (2/3) (1 - cos(theta))\n\t//\n\t// We use Simpson's rule to integrate the hemisphere volume over theta.\n\t//\n\t// The integration bounds are:\n\t//\n\t//\t\ttheta_0 = atan(z/r)\n\t//\t\ttheta_1 = asin(sin(theta_0) / sin(theta_0 + theta_1))\n\t//\n\t// where theta_0 is the angle between the capsule axis and the hemisphere axis,\n\t// and theta_1 is the angle between the capsule axis and the hemisphere axis plus the hemisphere axis.\n\t//\n\t// We divide the integration into two parts to handle potential singularities.\n\t//\n\t// The first part integrates from theta_0 to pi/2.\n\t//\n\t// The second part integrates from pi/2 to theta_1.\n\t//\n\t// The integration is performed in terms of theta_0 and theta_1.\n\t//\n\t// The integration is performed in terms of theta_0 and theta_1.\n\t//\n\t// The first part integrates from theta_0 to pi/2.\n\t//\n\t// The second part integrates from pi/2 to theta_1.\n\t//\n\t// The integration is performed in terms of theta_0 and theta_1.\n\t//\n\t// The integration is performed in terms of theta_0 and theta_1.\n\t//\n\t// The integration is performed in terms of theta_0 and theta_1.\n\t//\n\t// The integration is performed in terms of theta_0 and theta_1.\n\t//\n\t// The integration is performed in terms of theta_0 and theta_1.\n\t", "CodeBleu_score": 7.100587002159861}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\t// Calculate the x-coordinate of the buoyancy center\n\tsHemisphereIntegrationData integrationData(zIOverR, tanTheta0, sinTheta1, volume);\n\treturn Simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(0, 1, 1000, integrationData);\n}", "CodeBleu_score": 29.82213956137134}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tsHemisphereIntegrationData integrationData;\n\tintegrationData.zIOverR = zIOverR;\n\tintegrationData.tanTheta0 = tanTheta0;\n\tintegrationData.sinTheta1 = sinTheta1;\n\tintegrationData.volume = volume;\n\n\t// Calculate the x-coordinate of the buoyancy center using Simpson's rule.\n\treturn Simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(integrationData, 0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.", "CodeBleu_score": 37.12637454098993}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\t//Calculate the x-coordinate of the buoyancy center for the immersed hemisphere.\n\tsHemisphereIntegrationData data;\n\tdata.xCenterOfMassIntegrand = &sHemisphereIntegrationData::xCenterOfMassIntegrand;\n\tdata.zIOverR = zIOverR;\n\tdata.tanTheta0 = tanTheta0;\n\tdata.sinTheta1 = sinTheta1;\n\tdata.volume = volume;\n\treturn simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(data);\n}", "CodeBleu_score": 46.17528664905174}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (immersion);\n\tdUASSERT (immersion->tome_first_contact != 0, \"tome_first_contact must not be 0\");\n\tdUASSERT (immersion->tome_first_contact != 1, \"tome_first_contact must not be 1\");\n\tdUASSERT (immersion->tome_first_contact != 2, \"tome_first_contact must not be 2\");\n\tdUASSERT (immersion->tome_first_contact != 3, \"tome_first_contact must not be 3\");\n\tdUASSERT (immersion->tome_first_contact != 4, \"tome_first_contact must not be 4\");\n\tdUASSERT (immersion->tome_first_contact != 5, \"tome_first_contact must not be 5\");\n\tdUASSERT (immersion->tome_first_contact != 6, \"tome_first_contact must not be 6\");\n\tdUASSERT (immersion->tome_first_contact != 7, \"tome_first_contact must not be 7\");\n\tdUASSERT (immersion->tome_first_contact != 8, \"tome_first_contact must not be 8\");\n\tdUASSERT (immersion->tome_first_contact != 9, \"tome_first_contact must not be 9\");\n\tdUASSERT (immersion->tome_first_contact != 10, \"tome_first_contact must not be 10\");\n\tdUASSERT (immersion->tome_first_contact != 11, \"tome_first_contact must not be 11\");\n\tdUASSERT (immersion->tome_first_contact != 12, \"tome_first_contact must not be 12\");\n\tdUASSERT (immersion->tome_first_contact != 13, \"tome_first_contact must not be 13\");\n\tdUASSERT (immersion->tome_first_contact != 14, \"tome_first_contact must not be 1", "CodeBleu_score": 19.72316446867787}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (immersion);\n\tdIASSERT ((flags & NUMC_MASK) >= 1);\n\tdIASSERT ((flags & NUMC_MASK) <= 4);\n\tdIASSERT (o1->type == dCapsuleClass);\n\tdIASSERT (o2->type == dTriMeshClass);\n\n\tdxCapsule *c = (dxCapsule*) o1;\n\tdxTriMesh *t = (dxTriMesh*) o2;\n\n\tconst dReal *c_pos = c->final_posr->pos;\n\tconst dReal *c_R = c->final_posr->R;\n\tconst dReal *t_pos = t->final_posr->pos;\n\tconst dReal *t_R = t->final_posr->R;\n\n\tdVector3 c_pos_t, c_pos_c, t_pos_c;\n\tdMultiply0_331 (c_pos_t, c_R, c_pos);\n\tdMultiply0_331 (c_pos_c, t_R, c_pos_t);\n\tdMultiply0_331 (t_pos_c, t_R, t_pos);\n\tdVector3 c_pos_t_c;\n\tdSubtractVectors3 (c_pos_t_c, c_pos_c, t_pos_c);\n\tdReal c_radius = c->radius;\n\tdReal c_radius2 = c_radius * c_radius;\n\tdReal c_length = c->lz;\n\tdReal c_length2 = c_length * c_length;\n\tdReal c_length_h = 0.5 * c_length;\n\tdReal c_length_h2 = c_length_h * c_length_h;\n\tdReal c_length_h3 = c_length_h2 * c_length_h;\n\tdReal c_length_h4 = c_length_h2 * c_length_h2;\n\tdReal c_length_h5 = c_length_h3 *", "CodeBleu_score": 35.04239608558471}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (immersion);\n  dUASSERT (o1 && o1->type == dCapsuleClass, \"argument not a capsule\");\n  dUASSERT (o2 && o2->type == dTriMeshClass, \"argument not a trimesh\");\n  dUASSERT (immersion->immersionData, \"immersion data not allocated\");\n  dUASSERT (immersion->immersionData->type == dImmersionCapsuleTrimesh, \"wrong immersion data type\");\n\n  dxCapsule *capsule = (dxCapsule*) o1;\n  dxTriMesh *tm = (dxTriMesh*) o2;\n  sCapsuleImmersionData *immersionData = (sCapsuleImmersionData*) immersion->immersionData;\n\n  // check if the capsule is immersed\n  dReal depth = dGeomCapsuleGetDepth (o1);\n  if (depth > 0) {\n    // the capsule is not immersed\n    return 0;\n  }\n\n  // calculate the radius\n  dReal radius = capsule->radius;\n\n  // calculate the height of the capsule\n  dReal height = capsule->lz;\n\n  // calculate the volume of the capsule\n  dReal volume = M_PI * radius * radius * height;\n\n  // calculate the immersion depth ratio\n  dReal depthRatio = -depth / height;\n\n  // calculate the initial angle of the hemisphere\n  dReal initialAngle = asin (depthRatio);\n\n  // calculate the final angle of the hemisphere\n  dReal finalAngle = asin (1 - depthRatio);\n\n  // calculate the x-coordinate of the buoyancy center for the hemisphere\n  dReal buoyancyCenterX = immersionData->immersedHemisphereXBuoyancyCenter (depthRatio, tan (initialAngle), sin (finalAngle), volume);\n\n  // calculate the x-coordinate of the buoyancy center for the capsule\n  dReal buoyancyCenter = buoyancyCenterX * radius;\n\n  // calculate the x-coordinate of the", "CodeBleu_score": 40.34552220893228}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t  // Retrieve the duration from the input\n  auto duration = getInput<std::chrono::milliseconds>(\"duration\");\n\n  // If the duration is missing or non-positive, return SUCCESS\n  if (!duration) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // If the duration is positive, set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n\n  // Start the timer\n  timer_.add(duration.value(), [this] {\n    // Emit the wake-up signal\n    emitWakeUpSignal();\n  });\n\n  // If the timer is aborted, ensure the timer_waiting_ flag is reset\n  timer_.setAbortHandler([this] { timer_waiting_ = false; });\n\n  // Set the timer_waiting_ flag to true\n  timer_waiting_ = true;\n\n  // Return RUNNING\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 51.19932741901173}, {"code": "NodeStatus SleepNode::onStart(){\n\t  auto duration = getInput<std::chrono::milliseconds>(\"duration\");\n  if (!duration) {\n    RCLCPP_ERROR(getLogger(), \"Duration is missing or non-positive\");\n    return NodeStatus::FAILURE;\n  }\n\n  if (*duration <= 0ms) {\n    RCLCPP_INFO(getLogger(), \"Duration is 0, returning SUCCESS\");\n    return NodeStatus::SUCCESS;\n  }\n\n  setStatus(NodeStatus::RUNNING);\n  timer_ = rclcpp::create_timer(\n    this, getClock(), *duration,\n    [this]() {\n      timer_waiting_ = false;\n      setStatus(NodeStatus::SUCCESS);\n    });\n  timer_waiting_ = true;\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 51.462549174179415}, {"code": "NodeStatus SleepNode::onStart(){\n\t  std::chrono::milliseconds duration;\n  getInput(\"duration\", duration);\n  if (duration <= std::chrono::milliseconds(0)) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_.add(duration, [this]() {\n    timer_waiting_ = false;\n    emitWakeUpSignal();\n  });\n  timer_waiting_ = true;\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 47.77955121642462}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // Check if the entry exists in the blackboard\n    if (config().blackboard->exists(config().key)) {\n        // Retrieve the entry\n        auto entry = config().blackboard->getEntry(config().key);\n        // Lock the entry mutex\n        entry.lock();\n        // Check if the sequence ID has been updated\n        if (entry.getSequenceId() != config().sequence_id) {\n            // Update the stored sequence ID\n            config().sequence_id = entry.getSequenceId();\n            // Unlock the entry mutex\n            entry.unlock();\n            // Return success\n            return NodeStatus::SUCCESS;\n        }\n        // Unlock the entry mutex\n        entry.unlock();\n    }\n    // Return failure\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 35.470938113326845}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  std::string key = config().blackboard->getEntry(config().key);\n  if (key.empty()) {\n    return NodeStatus::FAILURE;\n  }\n\n  std::lock_guard<std::mutex> guard(config().blackboard->getEntry(key).mutex);\n  if (config().blackboard->getEntry(key).sequenceId == config().sequenceId) {\n    return NodeStatus::FAILURE;\n  }\n\n  config().blackboard->getEntry(key).sequenceId = config().sequenceId;\n  return NodeStatus::SUCCESS;\n}", "CodeBleu_score": 42.143427713882}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // get the entry\n    auto entry = config().blackboard->getEntry(config().key);\n\n    // if the entry does not exist, return FAILURE\n    if (!entry) {\n        return NodeStatus::FAILURE;\n    }\n\n    // lock the entry\n    entry->lock();\n\n    // check if the sequence ID has changed\n    if (entry->getSequence() != last_sequence) {\n        // update the last sequence ID\n        last_sequence = entry->getSequence();\n        // unlock the entry\n        entry->unlock();\n        // return SUCCESS\n        return NodeStatus::SUCCESS;\n    }\n\n    // unlock the entry\n    entry->unlock();\n    // return FAILURE\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 45.35436678194215}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t  if (success_threshold_ < 0) {\n    return std::max(size_t(0), children_nodes_.size() + success_threshold_);\n  }\n  return success_threshold_;\n}", "CodeBleu_score": 55.12664458558917}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  if (success_threshold_ < 0) {\n    return children_nodes_.size() + success_threshold_;\n  }\n  return success_threshold_;\n}", "CodeBleu_score": 51.94570187695842}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return std::max(children_nodes_.size() + success_threshold_, 0);\n    }\n    return success_threshold_;\n}", "CodeBleu_score": 55.04940828560257}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    auto currentTime = std::chrono::system_clock::now();\n    if (currentTime - lastHeartbeatTime > std::chrono::milliseconds(100)) {\n      if (heartbeatStatus == HeartbeatStatus::ACTIVE) {\n        heartbeatStatus = HeartbeatStatus::INACTIVE;\n        disableAllHooks();\n      }\n    } else {\n      if (heartbeatStatus == HeartbeatStatus::INACTIVE) {\n        heartbeatStatus = HeartbeatStatus::ACTIVE;\n        enableAllHooks();\n      }\n    }\n  }\n}", "CodeBleu_score": 43.125731089151344}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        auto now = std::chrono::system_clock::now();\n        auto lastHeartbeat = std::chrono::system_clock::now() - lastHeartbeatTime;\n        if (lastHeartbeat > std::chrono::milliseconds(1000)) {\n            if (isHeartbeatActive) {\n                isHeartbeatActive = false;\n                disableAllHooks();\n            }\n        } else {\n            if (!isHeartbeatActive) {\n                isHeartbeatActive = true;\n                enableAllHooks();\n            }\n        }\n    }\n}", "CodeBleu_score": 45.22937676324405}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while(true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::time_t currentTime = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n        std::time_t heartbeatTime = std::chrono::system_clock::to_time_t(lastHeartbeatTime);\n        if(currentTime - heartbeatTime > 10) {\n            if(heartbeatActive) {\n                heartbeatActive = false;\n                disableAllHooks();\n            }\n        } else {\n            if(!heartbeatActive) {\n                heartbeatActive = true;\n                enableAllHooks();\n            }\n        }\n    }\n}", "CodeBleu_score": 37.78509775807834}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> ret;\n  std::vector<std::string> blackboard_list = BT::splitString(bb_list, \",\");\n  nlohmann::json json_object;\n  for (const auto& bb_name : blackboard_list) {\n    auto it = _p->subtrees.find(bb_name);\n    if (it != _p->subtrees.end()) {\n      std::lock_guard<std::mutex> lock(it->second.lock);\n      if (it->second.subtree) {\n        nlohmann::json bb_json = BT::ExportBlackboardToJSON(it->second.subtree->rootNode()->blackboard());\n        json_object[bb_name] = bb_json;\n      }\n    }\n  }\n  ret = nlohmann::json::to_msgpack(json_object);\n  return ret;\n}", "CodeBleu_score": 55.80841663397486}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  nlohmann::json json_blackboards;\n  auto bb_names = BT::splitString(bb_list, ',');\n  for (const auto& bb_name : bb_names) {\n    auto it = _p->subtrees.find(bb_name);\n    if (it != _p->subtrees.end()) {\n      it->second.lock();\n      nlohmann::json json_bb = BT::ExportBlackboardToJSON(it->second.get());\n      json_blackboards[bb_name] = json_bb;\n    }\n  }\n  return nlohmann::json::to_msgpack(json_blackboards);\n}", "CodeBleu_score": 62.03353693259842}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  nlohmann::json j;\n  std::vector<uint8_t> out;\n  std::vector<std::string> bb_names = BT::splitString(bb_list, \",\");\n  for (auto& bb_name : bb_names) {\n    auto it = _p->subtrees.find(bb_name);\n    if (it != _p->subtrees.end()) {\n      auto subtree = it->second.lock();\n      if (subtree) {\n        nlohmann::json bb = subtree->rootNode()->getBlackboard()->ExportBlackboardToJSON();\n        j[bb_name] = bb;\n      }\n    }\n  }\n  out = nlohmann::json::to_msgpack(j);\n  return out;\n}", "CodeBleu_score": 58.81939176463212}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t    std::lock_guard<std::mutex> lk(_p->nodes_by_uid_mutex);\n    auto it = _p->nodes_by_uid.find(node_uid);\n    if (it == _p->nodes_by_uid.end()) {\n        return false;\n    }\n    if (!it->second.isValid()) {\n        return false;\n    }\n    auto hook = it->second.lock();\n    if (hook->mode != Breakpoint) {\n        return false;\n    }\n    hook->mode = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->wakeup.notify_all();\n    return true;\n}", "CodeBleu_score": 56.869771375673736}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::lock_guard<std::mutex> lk(_p->nodes_by_uid_mutex);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  if (it->second.lock == nullptr) {\n    return false;\n  }\n  auto hook = it->second.lock->getHook();\n  if (hook == nullptr) {\n    return false;\n  }\n  std::lock_guard<std::mutex> lk2(hook->mutex);\n  if (hook->mode != Hook::Mode::BREAKPOINT) {\n    return false;\n  }\n  hook->wakeup.notify_all();\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  return true;\n}", "CodeBleu_score": 58.56891462407386}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  // Check if the node exists and is valid.\n  if (!nodeExists(node_uid)) {\n    ROS_WARN(\"Node %d does not exist.\", node_uid);\n    return false;\n  }\n  // Retrieve the associated hook.\n  std::shared_ptr<Groot2Hook> hook = getHook(pos);\n  // Lock the hook's mutex.\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  // Check if the hook is in BREAKPOINT mode.\n  if (hook->mode != BREAKPOINT) {\n    ROS_WARN(\"Hook %d is not in BREAKPOINT mode.\", pos);\n    return false;\n  }\n  // Set the desired status and removal flag.\n  hook->wakeup.status = result;\n  hook->wakeup.remove = remove;\n  // Mark the hook as ready.\n  hook->wakeup.ready = true;\n  // Notify all waiting threads.\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 40.905450880878696}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    if (getStatus() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_ = false;\n        std::future<NodeStatus> future_result = std::async(std::launch::async, &ThreadedAction::tick, this);\n        future_result.wait();\n        if (!halt_requested_) {\n            setStatus(future_result.get());\n        } else {\n            setStatus(NodeStatus::IDLE);\n        }\n    }\n    return getStatus();\n}", "CodeBleu_score": 35.07527263730776}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    // Check if the action is already running\n    if (status() != NodeStatus::IDLE) {\n        // If so, check if it has been halted\n        if (isHaltRequested()) {\n            // If so, halt the action\n            halt();\n        }\n        // Return the current status\n        return status();\n    }\n\n    // If not, set the status to RUNNING and start a new thread\n    setStatus(NodeStatus::RUNNING);\n    std::future<NodeStatus> future_status = std::async(std::launch::async, &ThreadedAction::tick, this);\n\n    // Wait for the thread to finish\n    future_status.wait();\n\n    // If the thread finished without a halt request, set the status to SUCCESS or FAILURE depending on the result of the tick function\n    if (!isHaltRequested()) {\n        setStatus(future_status.get());\n    }\n    // Otherwise, set the status to IDLE\n    else {\n        setStatus(NodeStatus::IDLE);\n    }\n\n    // Check for any stored exceptions\n    if (std::current_exception()) {\n        // If so, rethrow the exception\n        std::rethrow_exception(std::current_exception());\n    }\n\n    // Return the current status of the node\n    return status();\n}", "CodeBleu_score": 40.97374502758693}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  // Check if the action is currently IDLE.\n  if (getStatus() == NodeStatus::IDLE) {\n    // Set the flag to false.\n    halt_requested_ = false;\n    // Set the status to RUNNING.\n    setStatus(NodeStatus::RUNNING);\n    // Start a new asynchronous thread to run the tick function.\n    std::future<NodeStatus> future_result = std::async(std::launch::async, &ThreadedAction::tick, this);\n    // Store the future result in the map.\n    tick_map_[getRegistrationName()] = future_result;\n  }\n  // Check if the action is currently RUNNING.\n  else if (getStatus() == NodeStatus::RUNNING) {\n    // Check if the halt request flag is true.\n    if (isHaltRequested()) {\n      // Set the halt request flag to false.\n      halt_requested_ = false;\n      // Emit the wakeup signal.\n      emitWakeUpSignal();\n    }\n  }\n  // Check if the action has finished.\n  if (tick_map_.count(getRegistrationName()) > 0) {\n    // Check if the future result is ready.\n    if (tick_map_[getRegistrationName()].wait_for(std::chrono::seconds(0)) == std::future_status::ready) {\n      // Get the future result.\n      NodeStatus node_status = tick_map_[getRegistrationName()].get();\n      // Check if the future result is SUCCESS or FAILURE.\n      if (node_status == NodeStatus::SUCCESS || node_status == NodeStatus::FAILURE) {\n        // Remove the future result from the map.\n        tick_map_.erase(getRegistrationName());\n      }\n      // Set the status to the future result.\n      setStatus(node_status);\n    }\n  }\n  // Check if an exception has been thrown.\n  if (exception_ptr_) {\n    // Catch the exception.\n    try {\n      std::rethrow_exception(exception_ptr_);\n    }\n    // Catch the exception and log", "CodeBleu_score": 43.160121464002444}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto print_tree = [&](const TreeNode* node, int depth) {\n        stream << std::string(depth, ' ') << node->name << std::endl;\n        if (const auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children) {\n                print_tree(child, depth + 2);\n            }\n        } else if (const auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            print_tree(decorator->child, depth + 2);\n        }\n    };\n    stream << \"----------------------------------------\" << std::endl;\n    print_tree(root_node, 0);\n    stream << \"----------------------------------------\" << std::endl;\n}", "CodeBleu_score": 47.993808771673706}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  stream << \"----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "CodeBleu_score": 5.413516660495196}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    const std::string indent = \"  \";\n    const std::string separator = \"\n\";\n\n    auto print_node = [&](const TreeNode* node, int depth) {\n        stream << std::string(depth * 2, ' ') << node->name << separator;\n\n        if (const auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children) {\n                print_node(child.get(), depth + 1);\n            }\n        } else if (const auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            print_node(decorator->child.get(), depth + 1);\n        }\n    };\n\n    stream << separator;\n    print_node(root_node, 0);\n    stream << separator;\n}", "CodeBleu_score": 46.417662328141084}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (node == nullptr) {\n    throw LogicError(\"Cannot apply visitor to a null node.\");\n  }\n  visitor(node);\n  if (node->type == NodeType::CONTROL) {\n    for (const auto& child : dynamic_cast<const BT::ControlNode*>(node)->children) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->type == NodeType::DECORATOR) {\n    applyRecursiveVisitor(\n        dynamic_cast<const BT::DecoratorNode*>(node)->child, visitor);\n  }\n}", "CodeBleu_score": 54.71689117214217}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (!node)\n        throw LogicError(\"Cannot apply visitor to null node\");\n\n    visitor(node);\n\n    if (const auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n        for (const auto& child : control->children)\n            applyRecursiveVisitor(child, visitor);\n    }\n    else if (const auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n        applyRecursiveVisitor(decorator->child, visitor);\n    }\n}", "CodeBleu_score": 65.58855381275937}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"The node is null\");\n  }\n\n  visitor(node);\n\n  if (const auto* control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto* child : control->children) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (const auto* decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child, visitor);\n  }\n}", "CodeBleu_score": 66.59794683001311}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    std::lock_guard<std::mutex> lock(_p->mutex);\n    if (_p->builders.find(manifest.registration_ID) != _p->builders.end()) {\n        throw BehaviorTreeException(\n            \"BehaviorTreeFactory::registerBuilder: a builder with the same \"\n            \"registration ID is already registered.\");\n    }\n    _p->manifests.insert(std::make_pair(manifest.registration_ID, manifest));\n    _p->builders.insert(std::make_pair(manifest.registration_ID, builder));\n}", "CodeBleu_score": 50.921781264354685}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (_p->builders.find(manifest.registrationID) != _p->builders.end()) {\n        throw BehaviorTreeException(\n            \"BehaviorTreeFactory::registerBuilder: the registration ID '\" +\n            manifest.registrationID + \"' is already registered\");\n    }\n    _p->builders.insert(std::make_pair(manifest.registrationID, builder));\n    _p->manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 54.79782216407942}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    // Check if the registration ID already exists in the builders map.\n    if (_p->builders.find(manifest.registrationID()) != _p->builders.end()) {\n        throw BehaviorTreeException(\n            \"BehaviorTreeFactory::registerBuilder: Registration ID already exists.\");\n    }\n\n    // Insert the builder and manifest into their respective maps using the registration ID.\n    _p->builders.insert(std::make_pair(manifest.registrationID(), builder));\n    _p->manifests.insert(std::make_pair(manifest.registrationID(), manifest));\n}", "CodeBleu_score": 52.18292633455505}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  // Create the builder\n  auto builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  // Create the manifest\n  TreeNodeManifest manifest;\n  manifest.type = TreeNodeManifest::SIMPLE_ACTION;\n  manifest.ports = ports;\n  manifest.ID = ID;\n\n  // Register the builder and manifest\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 70.19913834392175}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  registerBuilder(\n      ID,\n      [tick_functor](const std::string& name, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n      },\n      ports);\n}", "CodeBleu_score": 52.149790295252465}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t    auto builder = [=]() {\n        return std::make_unique<SimpleActionNode>(tick_functor);\n    };\n\n    auto manifest = TreeNodeManifest{ ID,\n                                      std::move(ports),\n                                      NodeType::ACTION,\n                                      std::make_unique<SimpleActionNode>(tick_functor) };\n\n    registerBuilder(manifest, builder);\n}", "CodeBleu_score": 55.51734172481062}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (auto& sub : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tsub->blackboard->cloneInto(bb.back());\n\t}\n\treturn bb;\n}", "CodeBleu_score": 74.27714100867776}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (auto& sub : tree.subtrees) {\n        bb.push_back(Blackboard::create());\n        sub->blackboard->cloneInto(bb.back().get());\n    }\n    return bb;\n}", "CodeBleu_score": 76.19748789971142}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (auto& sub : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tsub->blackboard->cloneInto(bb.back().get());\n\t}\n\treturn bb;\n}", "CodeBleu_score": 74.31727602436393}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (executor.has_value()) {\n        return executor.value().execute(env);\n    } else {\n        return nonstd::make_unexpected(executor.error());\n    }\n}", "CodeBleu_score": 82.08338522012997}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if (!executor) {\n    return nonstd::make_unexpected(executor.error());\n  }\n  return executor.value()->Execute(env);\n}", "CodeBleu_score": 72.74294157005143}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if (executor.has_value()) {\n    return executor.value().Execute(env);\n  }\n  return nonstd::make_unexpected(executor.error());\n}", "CodeBleu_score": 70.83749428083006}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n    if (lib)\n        throw RuntimeError(\"Library already loaded\");\n    lib = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!lib)\n        throw RuntimeError(std::string(\"Failed to load library: \") + dlerror());\n    this->path = path;\n}", "CodeBleu_score": 51.88839487937076}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(m_mutex);\n    if (m_handle != nullptr) {\n        throw RuntimeError(\"Shared library is already loaded.\");\n    }\n    m_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (m_handle == nullptr) {\n        throw RuntimeError(dlerror());\n    }\n    m_path = path;\n}", "CodeBleu_score": 49.59960633203774}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n\n    if (loaded) {\n        throw RuntimeError(\"Shared library already loaded\");\n    }\n\n    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    if (!handle) {\n        std::string error = dlerror();\n        throw RuntimeError(error);\n    }\n\n    this->handle = handle;\n    this->path = path;\n    loaded = true;\n}", "CodeBleu_score": 56.75404532536309}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.strip();\n\tif (stripped.size < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped[0] != '{' || stripped[stripped.size - 1] != '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.subString(1, stripped.size - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 24.46999947767341}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.strip();\n\tif (stripped.size < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped.at(0) != '{' || stripped.at(stripped.size - 1) != '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 24.487149337460217}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size < 3) {\n        return false;\n    }\n\n    StringView stripped = str.strip();\n\n    if (stripped.size < 3) {\n        return false;\n    }\n\n    if (stripped.str[0] != '{' || stripped.str[stripped.size - 1] != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = StringView(stripped.str + 1, stripped.size - 2);\n    }\n\n    return true;\n}", "CodeBleu_score": 30.216572213549114}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double lineCost = 0.0;\n  LineIterator line(x0, y0, x1, y1, false);\n  while (line.isValid()) {\n    double pointCost = this->pointCost(line.getX(), line.getY());\n    if (pointCost < 0.0) {\n      return pointCost;\n    }\n    lineCost = std::max(lineCost, pointCost);\n    line.advance();\n  }\n  return lineCost;\n}", "CodeBleu_score": 56.659139011276864}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double lineCost = 0.0;\n  LineIterator line(x0, x1, y0, y1);\n  while (line.isValid()) {\n    double cost = pointCost(line.getX(), line.getY());\n    if (cost < 0.0) {\n      return cost;\n    }\n    lineCost += cost;\n    line.advance();\n  }\n  return lineCost;\n}", "CodeBleu_score": 55.9539460270013}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double lineCost = 0.0;\n  double pointCost = 0.0;\n\n  LineIterator line(x0, y0, x1, y1);\n\n  while (line.isValid()) {\n    pointCost = pointCost(line.getX(), line.getY());\n    if (pointCost < 0.0) {\n      return pointCost;\n    }\n    lineCost += pointCost;\n    line.advance();\n  }\n\n  return lineCost;\n}", "CodeBleu_score": 63.32253023719724}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty())  {\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.header = path[0].header;\n  gui_path.poses.resize(path.size());\n  for (unsigned int i = 0; i < path.size(); ++i)  {\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 69.5357655081337}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty()) {\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses.resize(path.size());\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i].pose;\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 78.36572685410795}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty())\n    return;\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  for (unsigned int i = 0; i < path.size(); ++i)\n  {\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 89.04685076506863}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t    return (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity);\n}", "CodeBleu_score": 87.3185143219738}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t    if (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n        fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity &&\n        fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 74.4422000167491}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t    if (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n        fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity &&\n        fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity)\n      return true;\n    else\n      return false;\n  }", "CodeBleu_score": 75.33549825401519}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\n  if (setup_done_ && restore_defaults) {\n    // reset to default limits\n    config.max_vel_x = default_config_.max_vel_x;\n    config.max_vel_x_backwards = default_config_.max_vel_x_backwards;\n    config.max_vel_y = default_config_.max_vel_y;\n    config.max_vel_theta = default_config_.max_vel_theta;\n    config.min_in_place_vel_theta = default_config_.min_in_place_vel_theta;\n    config.max_trans_acc = default_config_.max_trans_acc;\n    config.max_rot_acc = default_config_.max_rot_acc;\n    config.max_vel_x_in_place = default_config_.max_vel_x_in_place;\n    config.max_vel_y_in_place = default_config_.max_vel_y_in_place;\n    config.max_rot_vel = default_config_.max_rot_vel;\n    config.min_in_place_rot_vel = default_config_.min_in_place_rot_vel;\n    config.xy_goal_tolerance = default_config_.xy_goal_tolerance;\n    config.yaw_goal_tolerance = default_config_.yaw_goal_tolerance;\n    config.costmap_inscribed_radius = default_config_.costmap_inscribed_radius;\n    config.costmap_circumscribed_radius = default_config_.costmap_circumscribed_radius;\n    config.costmap_inscribed_offset = default_config_.costmap_inscribed_offset;\n    config.footprint_radius = default_config_.footprint_radius;\n    config.costmap_obstacles_behind_robot_dist = default_config_.costmap_obstacles_behind_robot_dist;\n    config.costmap_obstacles_behind_robot_dist_mult = default_config_.costmap_obstacles_behind_robot_dist_mult;\n    config.costmap_conservative", "CodeBleu_score": 29.97956125323469}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  // Lock the configuration mutex\n  boost::mutex::scoped_lock lock(config_mutex_);\n\n  // If setup is not yet done, initialize the default limits with the provided configuration and set the setup flag\n  if (!setup_) {\n    default_limits_.max_vel_x = config.max_vel_x;\n    default_limits_.max_vel_x_backwards = config.max_vel_x_backwards;\n    default_limits_.max_vel_y = config.max_vel_y;\n    default_limits_.max_vel_theta = config.max_vel_theta;\n    default_limits_.max_vel_x_inplace = config.max_vel_x_inplace;\n    default_limits_.max_vel_theta_inplace = config.max_vel_theta_inplace;\n    default_limits_.max_acc_x = config.max_acc_x;\n    default_limits_.max_acc_y = config.max_acc_y;\n    default_limits_.max_acc_theta = config.max_acc_theta;\n    default_limits_.max_acc_x_inplace = config.max_acc_x_inplace;\n    default_limits_.max_acc_theta_inplace = config.max_acc_theta_inplace;\n    default_limits_.min_inplace_vel_x = config.min_inplace_vel_x;\n    default_limits_.min_inplace_vel_theta = config.min_inplace_vel_theta;\n    default_limits_.min_inplace_acc_x = config.min_inplace_acc_x;\n    default_limits_.min_inplace_acc_theta = config.min_inplace_acc_theta;\n    default_limits_.max_trans_xy = config.max_trans_xy;\n    default_limits_.max_trans_theta = config.max_trans_theta;\n    default_limits_.min_turning_radius = config.min_turning_radius;\n    default_limits_.max_trans_xy_inplace = config.max_trans_xy_inplace;\n    default_limits_.max_trans_theta_in", "CodeBleu_score": 27.659433819623736}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (setup) {\n\t\tif (restore_defaults) {\n\t\t\t// Reset the configuration to default limits\n\t\t\tconfig.max_vel_x = 0.5;\n\t\t\tconfig.max_vel_x_backwards = 0.2;\n\t\t\tconfig.min_vel_x = 0.1;\n\t\t\tconfig.max_vel_x_in_decel = 0.2;\n\t\t\tconfig.max_vel_x_in_accel = 0.5;\n\t\t\tconfig.max_vel_x_in_turn = 0.5;\n\t\t\tconfig.max_vel_x_in_turn_backwards = 0.2;\n\t\t\tconfig.max_vel_y = 0.5;\n\t\t\tconfig.max_vel_y_backwards = 0.2;\n\t\t\tconfig.min_vel_y = 0.1;\n\t\t\tconfig.max_vel_y_in_decel = 0.2;\n\t\t\tconfig.max_vel_y_in_accel = 0.5;\n\t\t\tconfig.max_vel_y_in_turn = 0.5;\n\t\t\tconfig.max_vel_y_in_turn_backwards = 0.2;\n\t\t\tconfig.max_vel_theta = 0.5;\n\t\t\tconfig.max_vel_theta_backwards = 0.2;\n\t\t\tconfig.min_vel_theta = 0.1;\n\t\t\tconfig.max_vel_theta_in_decel = 0.2;\n\t\t\tconfig.max_vel_theta_in_accel = 0.5;\n\t\t\tconfig.max_vel_theta_in_turn = 0.5;\n\t\t\tconfig.max_vel_theta_in_turn_backwards = 0.2;\n\t\t\tconfig.max_vel_trans = 0.5;\n\t\t\tconfig.max_vel_trans_backwards = 0.2;\n\t\t\tconfig.min_vel_trans = 0.1", "CodeBleu_score": 20.500239560379175}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  // Check if the cell is an obstacle or has no information\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = obstacleCosts_;\n    return false;\n  }\n\n  // Calculate a new target distance\n  double new_distance = std::sqrt(\n      std::pow(current_cell->x - check_cell->x, 2)\n      + std::pow(current_cell->y - check_cell->y, 2));\n\n  // Update the cell's target distance if the new distance is shorter\n  if (new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n  }\n\n  return true;\n}", "CodeBleu_score": 66.52290863488578}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = obstacleCosts_[cost];\n    return false;\n  }\n  double new_target_distance = current_cell->target_distance +\n      sqrt(pow(check_cell->x - current_cell->x, 2) +\n      pow(check_cell->y - current_cell->y, 2));\n  if (new_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_target_distance;\n  }\n  return true;\n}", "CodeBleu_score": 69.26626632416232}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = obstacle_cost_value_;\n    return false;\n  }\n\n  double distance = std::sqrt((current_cell->x - check_cell->x) * (current_cell->x - check_cell->x) +\n                              (current_cell->y - check_cell->y) * (current_cell->y - check_cell->y));\n\n  if (distance > check_cell->target_distance)\n    check_cell->target_distance = distance;\n\n  return true;\n}", "CodeBleu_score": 63.781718230039566}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scaling_factor = 1.0;\n  double scaling_factor_inv = 1.0;\n  double footprint_cost = 0.0;\n  double max_footprint_cost = 0.0;\n\n  // Initialize the cost and scaling factor based on the trajectory and speed parameters\n  if (!initCost(traj)) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory(): Cannot initialize cost\");\n    return -9.0;\n  }\n\n  // For each point in the trajectory, calculate the footprint cost\n  for (unsigned int i = 0; i < traj.getPointsSize(); i++) {\n    footprint_cost = footprintCost(traj.getPoint(i));\n\n    // If the footprint cost is negative, return the cost immediately\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n\n    // Otherwise, either sum the scores or take the maximum score based on the sum_scores_ flag\n    if (sum_scores_) {\n      cost += footprint_cost;\n    }\n    else {\n      max_footprint_cost = std::max(max_footprint_cost, footprint_cost);\n    }\n  }\n\n  // Return the total cost\n  if (sum_scores_) {\n    cost *= scaling_factor;\n  }\n  else {\n    cost = max_footprint_cost * scaling_factor;\n  }\n\n  return cost;\n}", "CodeBleu_score": 54.796935033725255}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t    double cost = 0.0;\n    double scaling_factor = getScalingFactor(traj.getPointsSize());\n    if (footprint_spec_.size() == 0) {\n        ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: No footprint specification set\");\n        return -9.0;\n    }\n    for (int i = 0; i < traj.getPointsSize(); i++) {\n        double footprint_cost = footprintCost(traj.getPoint(i), scaling_factor);\n        if (footprint_cost < 0.0) {\n            return footprint_cost;\n        }\n        if (sum_scores_) {\n            cost += footprint_cost;\n        } else {\n            cost = std::max(cost, footprint_cost);\n        }\n    }\n    return cost;\n}", "CodeBleu_score": 53.165978239104625}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scaling_factor = getScalingFactor(traj.getPointsSize(), traj.getSpeed());\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint specification is empty!\");\n    return -9;\n  }\n  for (int i = 0; i < traj.getPointsSize(); i++) {\n    double footprint_cost = footprintCost(traj.getPoint(i));\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    cost += footprint_cost * scaling_factor;\n  }\n  if (sum_scores_) {\n    return cost;\n  } else {\n    return std::max(cost, 0.0);\n  }\n}", "CodeBleu_score": 48.35841665913987}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t  // scale the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    scaled_footprint.push_back(world_model->scalePoint(footprint_spec[i], scale));\n  }\n\n  // get the footprint cost\n  double footprint_cost = world_model->footprintCost(scaled_footprint, costmap, x, y, th);\n\n  // if the footprint cost is negative, return -6.0\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  // if the position is off the map, return -7.0\n  if (!costmap->worldToMap(x, y, x, y)) {\n    return -7.0;\n  }\n\n  // get the cost at the given position\n  unsigned int mx, my;\n  costmap->worldToMap(x, y, mx, my);\n  unsigned int cost = costmap->getCost(mx, my);\n\n  // return the maximum cost between the footprint cost and the cell cost\n  return std::max(cost, footprint_cost);\n}", "CodeBleu_score": 64.10067726646311}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  // Scale the footprint points by the given scale factor\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point p;\n    p.x = scale * footprint_spec[i].x;\n    p.y = scale * footprint_spec[i].y;\n    scaled_footprint.push_back(p);\n  }\n\n  // Compute the footprint cost using a world model\n  double footprint_cost = world_model->footprintCost(scaled_footprint, x, y, th);\n\n  // If the cost is negative, return -6.0\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  // If the position is off the map, return -7.0\n  if (!costmap->worldToMap(x, y, x, y)) {\n    return -7.0;\n  }\n\n  // Otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n  return std::max(footprint_cost, costmap->getCost(x, y));\n}", "CodeBleu_score": 70.11150178529664}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t  if (scale <= 0.0) {\n    ROS_ERROR(\"Scale factor must be positive\");\n    return -1.0;\n  }\n\n  // scale the footprint points\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  scaled_footprint.reserve(footprint_spec.size());\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point scaled_point;\n    scaled_point.x = footprint_spec[i].x * scale;\n    scaled_point.y = footprint_spec[i].y * scale;\n    scaled_footprint.push_back(scaled_point);\n  }\n\n  // compute the footprint cost\n  double footprint_cost = world_model->footprintCost(scaled_footprint, x, y, th, costmap);\n\n  if (footprint_cost < 0.0) {\n    return -6.0;\n  }\n\n  // compute the cost at the given position\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n  unsigned int cost = costmap->getCost(mx, my);\n\n  // return the maximum cost\n  return std::max(cost, footprint_cost);\n}", "CodeBleu_score": 68.05864238047084}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 52.511849404814996}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = gn.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 52.78324627910622}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_.empty()) {\n      odom_sub_.shutdown();\n    } else {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n  }\n}", "CodeBleu_score": 45.67084826080766}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\n  // Calculate the squared distance between the current and previous positions\n  float sqrDist = (pos - prev).squaredNorm();\n\n  // Calculate the angular difference between the current and previous positions\n  float angle = (pos - prev).norm();\n  angle = (angle < 0.0001f) ? 0.0f : angle;\n  angle = acos(angle);\n  angle = (angle > 1.5708f) ? 1.5708f : angle;\n  angle = (angle < -1.5708f) ? -1.5708f : angle;\n\n  // If the squared distance exceeds a threshold or the angular difference is greater than a set angle, reset the oscillation flags\n  if (sqrDist > 0.01f || angle > 0.1f) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 33.56282665663493}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    const float distance_threshold = 0.001;\n    const float angle_threshold = 0.001;\n\n    Eigen::Vector3f distance = pos - prev;\n    float distance_squared = distance.dot(distance);\n    if (distance_squared > distance_threshold) {\n        resetOscillationFlags();\n    }\n    else {\n        float angle = fabs(atan2(distance[1], distance[0]) - atan2(prev[1], prev[0]));\n        if (angle > angle_threshold) {\n            resetOscillationFlags();\n        }\n    }\n}", "CodeBleu_score": 44.64465620629105}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    float distSquared = (pos - prev).squaredNorm();\n    float angle = (pos - prev).norm();\n\n    if (distSquared > _distanceThresholdSquared || angle > _angleThreshold) {\n        _oscillationFlags = 0;\n    }\n}", "CodeBleu_score": 27.09579182494104}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // get the grid coordinates of the point\n  int grid_x, grid_y, grid_z;\n  if (!getGridCoords(pt, grid_x, grid_y, grid_z)) {\n    return;\n  }\n\n  // check if the point is too close to its nearest neighbor\n  if (nearestNeighborDistance(grid_x, grid_y, grid_z) < min_distance_) {\n    return;\n  }\n\n  // calculate the grid index\n  int grid_index = gridIndex(grid_x, grid_y, grid_z);\n\n  // insert the point into the cell\n  cells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 49.741949515533015}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // Determine the grid coordinates of the point\n  int x, y;\n  if (!gridCoords(pt, x, y)) {\n    return;\n  }\n\n  // If the coordinates are outside the grid bounds or the point is too close to its nearest neighbor, return\n  if (x < 0 || x >= grid_width_ || y < 0 || y >= grid_height_ || nearestNeighborDistance(x, y, pt) < min_distance_) {\n    return;\n  }\n\n  // Calculate the grid index and insert the point into the corresponding cell\n  int pt_index = x + y * grid_width_;\n  cells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 55.028149774689915}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    // Determine the grid coordinates of the point\n    int x = (int)((pt.x - grid_origin_.x) / grid_cell_size_);\n    int y = (int)((pt.y - grid_origin_.y) / grid_cell_size_);\n    int z = (int)((pt.z - grid_origin_.z) / grid_cell_size_);\n\n    // If the coordinates are outside the grid bounds or the point is too close to its nearest neighbor, return without inserting the point\n    if (x < 0 || x >= grid_size_ || y < 0 || y >= grid_size_ || z < 0 || z >= grid_size_) {\n        return;\n    }\n\n    // Calculate the grid index\n    int pt_index = x + y * grid_size_ + z * grid_size_ * grid_size_;\n\n    // Insert the point into the corresponding cell\n    cells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 44.822513353227336}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    // if the target velocity is higher than the current velocity, increase the velocity\n    if (sample_target_vel(i) > vel(i)) {\n      new_vel(i) = std::min(vel(i) + acclimits(i) * dt, sample_target_vel(i));\n    }\n    // if the target velocity is lower than the current velocity, decrease the velocity\n    else if (sample_target_vel(i) < vel(i)) {\n      new_vel(i) = std::max(vel(i) - acclimits(i) * dt, sample_target_vel(i));\n    }\n    // if the target velocity is equal to the current velocity, keep the velocity\n    else {\n      new_vel(i) = vel(i);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 62.131979914669046}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n  // compute new velocity\n  for (int i = 0; i < 3; i++) {\n    new_vel(i) = vel(i) + acclimits(i) * dt;\n    if (new_vel(i) < sample_target_vel(i) - acclimits(i) * dt)\n      new_vel(i) = sample_target_vel(i) - acclimits(i) * dt;\n    if (new_vel(i) > sample_target_vel(i) + acclimits(i) * dt)\n      new_vel(i) = sample_target_vel(i) + acclimits(i) * dt;\n  }\n  return new_vel;\n}", "CodeBleu_score": 57.29316966472159}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; ++i) {\n        new_vel[i] = std::min(std::max(vel[i] + acclimits[i] * dt, -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits[i]);\n        new_vel[i] = std::min(std::max(new_vel[i], -acclimits[i]), acclimits", "CodeBleu_score": 54.45302136083118}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double diff = DBL_MAX;\n  double x_diff, y_diff;\n  double goal_x, goal_y;\n  double goal_heading;\n  unsigned int i = global_plan_.size() - 1;\n\n  while (i > 0) {\n    costmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y, goal_x, goal_y);\n    goal_heading = angles::normalize_angle(atan2(goal_y - y, goal_x - x));\n    x_diff = fabs(goal_x - x);\n    y_diff = fabs(goal_y - y);\n    if (x_diff <= 0.5 && y_diff <= 0.5 && lineCost(cell_x, cell_y, global_plan_[i].x, global_plan_[i].y) == 0) {\n      diff = angles::shortest_angular_distance(heading, goal_heading);\n      break;\n    }\n    --i;\n  }\n\n  return diff;\n}", "CodeBleu_score": 52.59655983458218}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double diff = 0;\n  // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell.\n  for (int i = (int)global_plan_.size() - 1; i >= 0; i--) {\n    // Convert the global plan cell coordinates to world coordinates.\n    double gx = costmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y).x;\n    double gy = costmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y).y;\n    // Check if the global plan point is in the robot's FOV.\n    if (lineCost(cell_x, cell_y, global_plan_[i].x, global_plan_[i].y, x, y, heading) < 0.5) {\n      // Convert the global plan cell coordinates to world coordinates.\n      double gx = costmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y).x;\n      double gy = costmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y).y;\n      // Calculate the shortest angular distance between the current heading and the direction to the goal point.\n      double diff = angles::shortest_angular_distance(heading, atan2(gy - y, gx - x));\n      // Return the absolute value of the shortest angular distance between the current heading and the direction to the goal point.\n      return fabs(diff);\n    }\n  }\n  // Return DBL_MAX.\n  return DBL_MAX;\n}", "CodeBleu_score": 54.10097797898818}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double heading_diff = 0.0;\n  unsigned int i = 0;\n  unsigned int j = 0;\n  unsigned int k = 0;\n  unsigned int l = 0;\n  unsigned int m = 0;\n  unsigned int n = 0;\n  unsigned int o = 0;\n  unsigned int p = 0;\n  unsigned int q = 0;\n  unsigned int r = 0;\n  unsigned int s = 0;\n  unsigned int t = 0;\n  unsigned int u = 0;\n  unsigned int v = 0;\n  unsigned int w = 0;\n  unsigned int x_ = 0;\n  unsigned int y_ = 0;\n  unsigned int z_ = 0;\n  unsigned int aa = 0;\n  unsigned int bb = 0;\n  unsigned int cc = 0;\n  unsigned int dd = 0;\n  unsigned int ee = 0;\n  unsigned int ff = 0;\n  unsigned int gg = 0;\n  unsigned int hh = 0;\n  unsigned int ii = 0;\n  unsigned int jj = 0;\n  unsigned int kk = 0;\n  unsigned int ll = 0;\n  unsigned int mm = 0;\n  unsigned int nn = 0;\n  unsigned int oo = 0;\n  unsigned int pp = 0;\n  unsigned int qq = 0;\n  unsigned int rr = 0;\n  unsigned int ss = 0;\n  unsigned int tt = 0;\n  unsigned int uu = 0;\n  unsigned int vv = 0;\n  unsigned int ww = 0;\n  unsigned int xx = 0;\n  unsigned int yy = 0;\n  unsigned int zz = 0;\n  unsigned int aa_ = 0;\n  unsigned int bb_ = 0;\n  unsigned int cc_ = 0;\n  unsigned int dd_ = 0;\n  unsigned int ee_ = 0;\n  unsigned int ff_ = 0;\n  unsigned int gg_ = 0;\n  unsigned int hh_ = 0;\n  unsigned int ii", "CodeBleu_score": 7.638228349114964}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  if (cost < 0) {\n    ROS_WARN_STREAM(\"Trajectory rejected: cost = \" << cost << \", sample velocities = \"\n                    << vx_samp << \", \" << vy_samp << \", \" << vtheta_samp);\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 69.46375400761828}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n    // Compute the cost of the trajectory\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    // If the cost is non-negative, the trajectory is valid, so return true\n    if (cost >= 0) {\n        return true;\n    }\n\n    // If the cost is negative, the trajectory is invalid, so log a warning and return false\n    ROS_WARN(\"Invalid trajectory: vx_samp = %f, vy_samp = %f, vtheta_samp = %f, cost = %f\",\n             vx_samp, vy_samp, vtheta_samp, cost);\n    return false;\n}", "CodeBleu_score": 82.81336232981337}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  // Compute the cost of the trajectory\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  // Check if the trajectory is valid\n  if (cost >= 0) {\n    return true;\n  } else {\n    // Log the trajectory as invalid\n    ROS_WARN(\"Invalid trajectory: x=%f, y=%f, theta=%f, vx=%f, vy=%f, vtheta=%f, vx_samp=%f, vy_samp=%f, vtheta_samp=%f, cost=%f\",\n        x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\n    return false;\n  }\n}", "CodeBleu_score": 74.37197424915225}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"The behavior has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmap pointers are not set\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside of the specified area\");\n  } else {\n    ROS_WARN(\"Clearing inside of the specified area\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_ == AFFECT_GLOBAL_COSTMAP) {\n    global_costmap_->clearMap();\n    ROS_DEBUG(\"Global costmap cleared in %f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if (affected_maps_ == AFFECT_LOCAL_COSTMAP) {\n    local_costmap_->clearMap();\n    ROS_DEBUG(\"Local costmap cleared in %f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if (affected_maps_ == AFFECT_BOTH_COSTMAPS) {\n    global_costmap_->clearMap();\n    local_costmap_->clearMap();\n    ROS_DEBUG(\"Global and local costmaps cleared in %f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if (force_clearing_) {\n    if (affected_maps_ == AFFECT_GLOBAL_COSTMAP) {\n      global_costmap_->updateMap();\n      ROS_DEBUG(\"Global costmap updated in %f seconds\", (ros::WallTime::now() - t0).toSec());\n    }\n\n    if (affected_maps_ == AFFECT_LOCAL_COSTMAP) {\n      local_costmap_->updateMap();\n      ROS_DEBUG(\"Local costmap updated in %f seconds\", (ros::WallTime::now()", "CodeBleu_score": 56.289159318812246}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"The behavior has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmap pointers are not set!\");\n    return;\n  }\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside the area specified in the recovery behavior\");\n  } else {\n    ROS_WARN(\"Clearing outside the area specified in the recovery behavior\");\n  }\n  ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_ & CLEAR_GLOBAL_COSTMAP) {\n    global_costmap_->clearMap();\n    ROS_DEBUG(\"Global costmap cleared in %f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n  if (affected_maps_ & CLEAR_LOCAL_COSTMAP) {\n    local_costmap_->clearMap();\n    ROS_DEBUG(\"Local costmap cleared in %f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n  if (affected_maps_ & FORCE_COSTMAP_UPDATE) {\n    if (affected_maps_ & CLEAR_GLOBAL_COSTMAP) {\n      global_costmap_->updateMap();\n      ROS_DEBUG(\"Global costmap updated in %f seconds\", (ros::WallTime::now() - t0).toSec());\n    }\n    if (affected_maps_ & CLEAR_LOCAL_COSTMAP) {\n      local_costmap_->updateMap();\n      ROS_DEBUG(\"Local costmap updated in %f seconds\", (ros::WallTime::now() - t0).toSec());\n    }\n  }\n}", "CodeBleu_score": 57.082119430390456}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  // Check if we're initialized\n  if (!initialized_) {\n    ROS_ERROR(\"The plugin must be initialized before runBehavior is called.\");\n    return;\n  }\n\n  // Check if the costmaps are valid\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"Costmap pointers inside the plugin are NULL.  The plugin must be initialized before runBehavior is called.\");\n    return;\n  }\n\n  // Warn if we're clearing inside or outside the area\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside the area specified by the recovery behavior.\");\n  }\n  else {\n    ROS_WARN(\"Clearing inside the area specified by the recovery behavior.\");\n  }\n\n  // Clear the costmaps\n  ros::WallTime t0 = ros::WallTime::now();\n  if (invert_area_to_clear_) {\n    global_costmap_->setCostmapToDefaultValue(true);\n    local_costmap_->setCostmapToDefaultValue(true);\n  }\n  else {\n    global_costmap_->setCostmapToDefaultValue(false);\n    local_costmap_->setCostmapToDefaultValue(false);\n  }\n\n  // Update the costmaps\n  if (update_costmaps_) {\n    global_costmap_->updateMap();\n    local_costmap_->updateMap();\n  }\n\n  // Log the time it took\n  ROS_DEBUG(\"Clearing the costmaps took %f seconds.\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 44.10834412806343}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tPolygonOutlineCells outline(polygon.size());\n\tfor (unsigned int i = 0; i < polygon.size(); ++i) {\n\t\tif (i == polygon.size() - 1) {\n\t\t\traytraceLine(polygon[i], polygon[0], outline);\n\t\t} else {\n\t\t\traytraceLine(polygon[i], polygon[i + 1], outline);\n\t\t}\n\t}\n\toutline.getCells(polygon_cells);\n}", "CodeBleu_score": 53.850510192378046}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\n\tpolygon_cells.clear();\n\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\n\tPolygonOutlineCells outlineCells(polygon, polygon_cells);\n\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tMapLocation p1 = polygon[i];\n\t\tMapLocation p2 = polygon[(i + 1) % polygon.size()];\n\n\t\tif (p1.x == p2.x) {\n\t\t\t// vertical line\n\t\t\tif (p1.y < p2.y) {\n\t\t\t\tfor (int j = p1.y; j <= p2.y; j++) {\n\t\t\t\t\toutlineCells.addCell(p1.x, j);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = p1.y; j >= p2.y; j--) {\n\t\t\t\t\toutlineCells.addCell(p1.x, j);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (p1.y == p2.y) {\n\t\t\t// horizontal line\n\t\t\tif (p1.x < p2.x) {\n\t\t\t\tfor (int j = p1.x; j <= p2.x; j++) {\n\t\t\t\t\toutlineCells.addCell(j, p1.y);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = p1.x; j >= p2.x; j--) {\n\t\t\t\t\toutlineCells.addCell(j, p1.y);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// diagonal line\n\t\t\traytraceLine(p1, p2, outlineCells);\n\t\t}\n\t}\n\n\tif (polygon.size() > 1) {\n\t\tMapLocation p1 = polygon[0];\n\t\tMapLocation p2 = polygon[polygon.size() - 1];\n\n\t\tif (p1.x == p2.", "CodeBleu_score": 48.32446453057253}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tPolygonOutlineCells outline(polygon);\n\tif (polygon.size() > 1) {\n\t\tfor (std::vector<MapLocation>::const_iterator it = polygon.begin(); it != polygon.end(); ++it) {\n\t\t\tMapLocation start = *it;\n\t\t\tMapLocation end = *(it + 1);\n\t\t\tif (end.x() == start.x() && end.y() == start.y()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\traytraceLine(start, end, outline);\n\t\t}\n\t\t// close the polygon\n\t\tMapLocation start = *(polygon.end() - 1);\n\t\tMapLocation end = polygon[0];\n\t\traytraceLine(start, end, outline);\n\t}\n\toutline.getPolygon(polygon_cells);\n}", "CodeBleu_score": 38.4796095369197}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  // If we have not been initialized yet, do so\n  if (!initialized_) {\n    initialize();\n  }\n  // If we have not been updated yet, do so\n  if (!updated_) {\n    update();\n  }\n  // Prepare the grid data\n  prepareGrid();\n  // Publish the prepared grid\n  pub.publish(grid_);\n}", "CodeBleu_score": 64.00206073110444}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  if (pub.getSubscriber().getTopic() == costmap_topic_) {\n    // if this is the first subscriber, we need to start publishing\n    if (!is_active_) {\n      is_active_ = true;\n      // if we're not configured yet, we need to configure first\n      if (!is_configured_) {\n        configure();\n      }\n      // start the timer\n      if (publish_frequency_ > 0.0) {\n        timer_ = nh_.createTimer(ros::Duration(1.0 / publish_frequency_), &Costmap2DPublisher::publishLoop, this);\n      }\n    }\n  }\n}", "CodeBleu_score": 44.940827068379605}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  if (!initialized_) {\n    initialize();\n  }\n\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 67.46157027417836}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // Lock the costmap mutex\n  boost::mutex::scoped_lock lock(*costmap_->getMutex());\n\n  // Retrieve the resolution\n  double resolution = costmap_->getResolution();\n\n  // Set the grid's header\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n\n  // Set the grid's resolution, width, and height\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Convert the map coordinates to world coordinates for the origin\n  double wx, wy;\n  costmap_->mapToWorld(0.0, 0.0, wx, wy);\n\n  // Set the origin's position and orientation\n  grid_.info.origin.position.x = wx;\n  grid_.info.origin.position.y = wy;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  wx_ = wx;\n  wy_ = wy;\n\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  unsigned int i = 0;\n  for (unsigned int y = 0; y < grid_.info.height; ++y) {\n    for (unsigned int x = 0; x < grid_.info.width; ++x) {\n      grid_.data[i] = charMapToCost(costmap_->getCharMap()(x, y));\n      ++i;\n    }\n  }\n}", "CodeBleu_score": 71.10584285258274}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  costmap_->getMutex()->lock();\n  double res = costmap_->getResolution();\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = res;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = charMapToIntMap(costmap_->getCharMap()[i]);\n  }\n  costmap_->getMutex()->unlock();\n}", "CodeBleu_score": 59.6791457113292}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // Lock the costmap mutex\n  boost::mutex::scoped_lock lock(*costmap_->getMutex());\n\n  // Get the costmap's resolution\n  double resolution = costmap_->getResolution();\n\n  // Set the grid's header\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n\n  // Set the grid's resolution, width, and height\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Convert the map coordinates to world coordinates for the origin\n  double origin_x, origin_y;\n  costmap_->mapToWorld(0, 0, origin_x, origin_y);\n\n  // Set the origin's position and orientation\n  grid_.info.origin.position.x = origin_x;\n  grid_.info.origin.position.y = origin_y;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n\n  // Save the origin coordinates\n  origin_x_ = origin_x;\n  origin_y_ = origin_y;\n\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < costmap_->getSizeInCellsX(); ++i) {\n    for (unsigned int j = 0; j < costmap_->getSizeInCellsY(); ++j) {\n      unsigned int index = i + j * costmap_->getSizeInCellsX();\n      unsigned char value = costmap_->getCharMap()[index];\n      grid_.data[index]", "CodeBleu_score": 70.1703761149858}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // Check if the footprint and robot radius are the same\n  if (new_config.robot_radius == old_config.robot_radius &&\n      new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  // Check if the new configuration contains a valid footprint string\n  if (!new_config.footprint.empty()) {\n    // Try to convert the footprint string to a footprint\n    std::vector<geometry_msgs::Point> footprint;\n    if (makeFootprintFromString(new_config.footprint, footprint)) {\n      // Set the footprint\n      setUnpaddedRobotFootprint(footprint);\n      return;\n    }\n\n    // Log an error\n    ROS_ERROR(\"Invalid footprint string: %s\", new_config.footprint.c_str());\n  }\n\n  // Set the footprint based on the robot radius\n  makeFootprintFromRadius(new_config.robot_radius, new_config.inscribed_radius,\n                          new_config.circumscribed_radius);\n}", "CodeBleu_score": 60.20284540999074}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n  if (!new_config.footprint.empty()) {\n    if (makeFootprintFromString(new_config.footprint)) {\n      return;\n    }\n  }\n\n  // If the footprint string is invalid, it logs an error.\n  ROS_ERROR(\"Invalid footprint string: %s\", new_config.footprint.c_str());\n\n  // If no valid footprint string is provided, it sets the footprint based on the robot radius.\n  setUnpaddedRobotFootprint(new_config.robot_radius);\n}", "CodeBleu_score": 49.87278097897483}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (!new_config.footprint.empty()) {\n    if (makeFootprintFromString(new_config.footprint)) {\n      return;\n    }\n  }\n\n  if (setUnpaddedRobotFootprint(new_config.robot_radius)) {\n    return;\n  }\n\n  ROS_ERROR(\"Failed to set footprint\");\n}", "CodeBleu_score": 48.12999265477963}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t    if (!getRobotPose(new_pose)) {\n        ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose for reconfiguration. Reconfiguration cancelled.\");\n        return;\n    }\n\n    if (!transformListener.waitForTransform(global_frame, base_frame, ros::Time(0), ros::Duration(1.0))) {\n        ROS_WARN_THROTTLE(1.0, \"Failed to get transform from %s to %s for reconfiguration. Reconfiguration cancelled.\", global_frame.c_str(), base_frame.c_str());\n        return;\n    }\n\n    // get the robot's current pose in the global frame\n    tf::Stamped<tf::Pose> current_pose;\n    tf::poseStampedMsgToTF(tf::Stamped<tf::Pose>(new_pose, ros::Time::now(), global_frame), current_pose);\n    tf::Stamped<tf::Pose> robot_pose;\n    tf::poseStampedMsgToTF(tf::Stamped<tf::Pose>(new_pose, ros::Time::now(), base_frame), robot_pose);\n    tf::Stamped<tf::Pose> global_pose;\n    tf::poseStampedMsgToTF(tf::Stamped<tf::Pose>(new_pose, ros::Time::now(), global_frame), global_pose);\n    tf::Stamped<tf::Pose> robot_pose_in_global_frame;\n    transformListener.transformPose(global_frame, robot_pose, robot_pose_in_global_frame);\n\n    // check to see if the robot has moved\n    if (current_pose.getOrigin().distance(last_pose.getOrigin()) < reconfigure_tolerance &&\n        tf::quaternionAngle(current_pose.getRotation(), last_pose.getRotation()) < reconfigure_tolerance) {\n        return;\n    }\n\n    // check to see if the robot has moved far enough to warrant reconfiguration\n    double dist = current_pose.getOrigin().distance(last_pose.getOrigin());\n    double angle", "CodeBleu_score": 50.72338134154841}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  // get the robot's pose\n  if (!tf_->getRobotPose(global_frame_, ros::Time(0), new_pose_)) {\n    ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose in costmap2d.  This is \"\n                     \"usually because the tf information has not been received yet.  Will try again later.\");\n    return;\n  }\n\n  // if the robot's pose has changed, we need to update the costmap\n  if (new_pose_.position.x != current_pose_.position.x ||\n      new_pose_.position.y != current_pose_.position.y ||\n      new_pose_.position.z != current_pose_.position.z ||\n      new_pose_.orientation.x != current_pose_.orientation.x ||\n      new_pose_.orientation.y != current_pose_.orientation.y ||\n      new_pose_.orientation.z != current_pose_.orientation.z ||\n      new_pose_.orientation.w != current_pose_.orientation.w) {\n    // update the current pose\n    current_pose_ = new_pose_;\n\n    // update the costmap\n    updateMap();\n  }\n}", "CodeBleu_score": 40.32348377143909}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get the robot's pose for reconfiguration. Cancelling reconfiguration.\");\n\t\treturn;\n\t}\n\t\n\tif (tf_buffer_.canTransform(global_frame_, robot_base_frame_, ros::Time(0))) {\n\t\ttf2::Transform tf_robot_base_to_global;\n\t\ttf2::fromMsg(tf_buffer_.lookupTransform(global_frame_, robot_base_frame_, ros::Time(0)).transform, tf_robot_base_to_global);\n\t\ttf2::Transform tf_global_to_new_pose;\n\t\ttf2::fromMsg(tf_buffer_.lookupTransform(global_frame_, new_pose.header.frame_id, new_pose.header.stamp).transform, tf_global_to_new_pose);\n\t\ttf2::Transform tf_robot_base_to_new_pose = tf_robot_base_to_global * tf_global_to_new_pose;\n\t\tnew_pose.header.frame_id = global_frame_;\n\t\tnew_pose.header.stamp = ros::Time::now();\n\t\tnew_pose.pose.position.x = tf_robot_base_to_new_pose.getOrigin().x();\n\t\tnew_pose.pose.position.y = tf_robot_base_to_new_pose.getOrigin().y();\n\t\tnew_pose.pose.position.z = tf_robot_base_to_new_pose.getOrigin().z();\n\t\tnew_pose.pose.orientation = tf2::toMsg(tf2::Quaternion(tf_robot_base_to_new_pose.getRotation()));\n\t}\n\t\n\tif (tf_buffer_.canTransform(global_frame_, robot_base_frame_, new_pose.header.stamp)) {\n\t\ttf2::Transform tf_robot_base_to_global;\n\t\ttf2::fromMsg(tf_buffer_.lookupTransform(global_frame_, robot_base_frame_, new_", "CodeBleu_score": 51.089244911574575}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  if (stop_updates_) {\n    // re-subscribe to topics\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n      (*plugin)->activate();\n    }\n    stop_updates_ = false;\n  }\n  // wait for ROS to start running\n  while (!ros::ok()) {\n    ros::Duration(0.01).sleep();\n  }\n  // wait for the costmap to be initialized\n  while (!initialized_) {\n    ros::Duration(0.01).sleep();\n  }\n  // wait for the map update thread to start\n  while (!map_update_thread_active_) {\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 58.3100698301791}, {"code": "void Costmap2DROS::start(){\n\t  if (!stopped_) {\n    return;\n  }\n  stopped_ = false;\n  ROS_DEBUG(\"Starting the costmap...\");\n  std::vector<boost::shared_ptr<Layer> >::iterator plugin;\n  for (plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n    (*plugin)->activate();\n  }\n  if (map_update_thread_) {\n    map_update_thread_->start();\n  }\n  ROS_DEBUG(\"Waiting for the costmap to initialize...\");\n  while (ros::ok() && !initialized_) {\n    r.sleep();\n  }\n  ROS_DEBUG(\"The costmap is initialized...\");\n  while (ros::ok() && !map_update_thread_->isAlive()) {\n    r.sleep();\n  }\n  ROS_DEBUG(\"The costmap is running...\");\n  stop_updates_ = false;\n}", "CodeBleu_score": 59.50671237913438}, {"code": "void Costmap2DROS::start(){\n\t  if (stop_updates_) {\n    ROS_INFO(\"Reactivating plugins\");\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n      (*plugin)->activate();\n    }\n    stop_updates_ = false;\n  }\n  if (!is_initialized_) {\n    ROS_INFO(\"Waiting for costmap to be initialized\");\n    while (!is_initialized_) {\n      ros::Duration(0.1).sleep();\n    }\n  }\n  if (!map_update_thread_.joinable()) {\n    ROS_INFO(\"Starting map update thread\");\n    map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this));\n  }\n  ROS_INFO(\"Costmap2DROS started\");\n}", "CodeBleu_score": 57.80840319414757}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_.toSec() == 0.0) {\n    if (observation_list_.size() > 0) {\n      observation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n    }\n  } else {\n    ros::Time current_time = ros::Time::now();\n    for (ObservationList::iterator it = observation_list_.begin(); it != observation_list_.end();) {\n      if ((current_time - it->time_).toSec() > observation_keep_time_.toSec()) {\n        it = observation_list_.erase(it);\n      } else {\n        ++it;\n      }\n    }\n  }\n}", "CodeBleu_score": 46.62668898229623}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t    if (observation_keep_time_.toSec() == 0.0) {\n        if (!observation_list_.empty()) {\n            observation_list_.erase(observation_list_.begin(), observation_list_.end());\n        }\n    } else {\n        ros::Time now = ros::Time::now();\n        while (!observation_list_.empty()) {\n            if (now - observation_list_.front().header.stamp < observation_keep_time_) {\n                break;\n            }\n            observation_list_.pop_front();\n        }\n    }\n}", "CodeBleu_score": 41.94676149674849}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t    if (observation_keep_time_.toSec() == 0) {\n        if (!observation_list_.empty()) {\n            observation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n        }\n    } else {\n        ros::Time current_time = ros::Time::now();\n        while (observation_list_.begin()->first + observation_keep_time_ < current_time) {\n            observation_list_.erase(observation_list_.begin());\n            if (observation_list_.empty()) {\n                return;\n            }\n        }\n    }\n}", "CodeBleu_score": 45.38443978083403}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n  // If there are no poses in the path, or the start index is invalid, return\n  if (path.size() == 0 || start_index < 0 || start_index >= path.size()) {\n    return;\n  }\n\n  // If the end index is invalid, set it to the last pose in the path\n  if (end_index < 0 || end_index >= path.size()) {\n    end_index = path.size() - 1;\n  }\n\n  // If the start index is the same as the end index, return\n  if (start_index == end_index) {\n    return;\n  }\n\n  // Get the yaw angles at the start and end indices\n  double start_yaw = angles::shortest_angular_distance(0.0, tf2::getYaw(path[start_index].pose.orientation));\n  double end_yaw = angles::shortest_angular_distance(0.0, tf2::getYaw(path[end_index].pose.orientation));\n\n  // Determine the shortest angular distance between the start and end yaw angles\n  double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // If the change in yaw angle is 0, return\n  if (delta_yaw == 0) {\n    return;\n  }\n\n  // Compute the angular change in yaw for each pose in the path\n  double delta_yaw_increment = delta_yaw / (end_index - start_index);\n\n  // Iterate through the poses in the path between the start and end indices\n  for (int i = start_index; i <= end_index; i++) {\n\n    // Get the current yaw angle\n    double current_yaw = angles::shortest_angular_distance(0.0, tf2::getYaw(path[i].pose.orientation));\n\n    // Compute the new yaw angle\n    double new_yaw = angles::shortest_angular_distance(current_yaw, current_yaw + delta_yaw_increment);\n\n    // Set the new yaw angle\n    set_angle(", "CodeBleu_score": 51.393742131449436}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n    // Check that the start and end indices are valid\n    if (start_index >= end_index) {\n        return;\n    }\n\n    // Get the yaw angle at the start and end indices\n    double start_yaw = angles::shortest_angular_distance(tf2::getYaw(path[start_index].pose.orientation), 0.0);\n    double end_yaw = angles::shortest_angular_distance(tf2::getYaw(path[end_index].pose.orientation), 0.0);\n\n    // Determine the shortest angular distance between the start and end yaw angles\n    double increment = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Compute the incremental change in yaw for each pose between the start and end indices\n    double change = increment / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index + 1; i < end_index; i++) {\n        tf2::Quaternion q;\n        q.setRPY(0, 0, start_yaw);\n        path[i].pose.orientation = tf2::toMsg(q);\n        start_yaw += change;\n    }\n}", "CodeBleu_score": 58.90830948369731}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  if (path.size() <= 1)\n    return;\n\n  if (start_index < 0 || end_index > path.size() - 1) {\n    ROS_ERROR(\"OrientationFilter::interpolate: start_index or end_index is out of range\");\n    return;\n  }\n\n  if (start_index > end_index) {\n    ROS_ERROR(\"OrientationFilter::interpolate: start_index is greater than end_index\");\n    return;\n  }\n\n  double start_yaw = angles::shortest_angular_distance(tf2::getYaw(path[start_index].pose.orientation), 0.0);\n  double end_yaw = angles::shortest_angular_distance(tf2::getYaw(path[end_index].pose.orientation), 0.0);\n  double increment = angles::shortest_angular_distance(start_yaw, end_yaw) / (end_index - start_index + 1);\n\n  for (int i = start_index + 1; i <= end_index; ++i) {\n    double yaw = angles::shortest_angular_distance(start_yaw, increment * (i - start_index));\n    set_angle(path[i].pose.orientation, yaw);\n  }\n}", "CodeBleu_score": 49.42868747237469}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  // Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  bool success = makePlan(req.start, req.goal, resp.plan);\n\n  // Update the response with the success status and the generated path\n  resp.success = success;\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 60.949646033815}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  ROS_DEBUG(\"PlannerWithCostmap::makePlanService()\");\n\n  // set the start and goal poses to be in the map frame\n  geometry_msgs::PoseStamped start;\n  start.header.frame_id = \"map\";\n  start.pose = req.start;\n\n  geometry_msgs::PoseStamped goal;\n  goal.header.frame_id = \"map\";\n  goal.pose = req.goal;\n\n  // make the plan\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(start, goal, path);\n\n  // set the success status and plan in the response\n  resp.success = success;\n  resp.plan = path;\n\n  // return true if a plan was found\n  return success;\n}", "CodeBleu_score": 49.5523909660029}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  // Set the start and goal frame_id to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  bool success = makePlan(req.start, req.goal, resp.plan);\n\n  // Update the response with the success status and the generated path\n  resp.success = success;\n  if (success) {\n    resp.plan_length = resp.plan.poses.size();\n  }\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 71.33537799085757}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 56.21610625677618}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 56.21610625677618}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 56.21610625677618}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\n  // Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    return false;\n  }\n\n  // Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // Check if the map coordinates are within the costmap's size limits\n  if (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 45.86200037210124}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  // Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n      wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    ROS_WARN(\"The world coordinates are outside the bounds of the costmap's origin\");\n    return false;\n  }\n\n  // Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // Check if the map coordinates are within the costmap's size limits\n  if (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() ||\n      my >= costmap_->getSizeInCellsY()) {\n    ROS_WARN(\"The map coordinates are outside the bounds of the costmap's size\");\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 45.26130141309671}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  // Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n      wx > costmap_->getOriginX() + costmap_->getSizeInCellsX() * costmap_->getResolution() ||\n      wy > costmap_->getOriginY() + costmap_->getSizeInCellsY() * costmap_->getResolution()) {\n    return false;\n  }\n\n  // Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // Return true if the map coordinates are within the costmap's size limits\n  return (mx >= 0 && mx < costmap_->getSizeInCellsX() && my >= 0 && my < costmap_->getSizeInCellsY());\n}", "CodeBleu_score": 45.17038934191194}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 90.27475432308391}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tgui_path.header.stamp = ros::Time::now();\n\tgui_path.poses.resize(path.size());\n\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.91375102202574}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  if (path.empty()) {\n    ROS_ERROR(\"The plan has no valid poses\");\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n  gui_path.poses.resize(path.size());\n\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 79.62285850520303}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Got a new goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 74.71676399349313}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Wrapping goal in an action message\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 77.36604320483325}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Got a goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 74.54200421249404}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  ROS_INFO(\"Checking distance\");\n  if (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"Moved far enough\");\n    distance_check_timer_.stop();\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n  }\n}", "CodeBleu_score": 77.48342194886108}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (getSqDistance(last_pose_, current_pose_) > sq_distance_limit_) {\n    ROS_INFO(\"[%s] Robot has moved far enough\", action_name_.c_str());\n    remove_limit_thread_->join();\n    delete remove_limit_thread_;\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 51.82281199760453}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  // Check if the robot has moved far enough\n  if (getSqDistance(robot_pose_->getPose(), last_pose_) >= sq_distance_) {\n    ROS_INFO(\"[%s] Distance check passed. Moving on.\", name_.c_str());\n    // Join and delete any existing remove limit thread\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    // Start a new thread to remove the speed limit\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    // Stop the distance check timer\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 58.29061603328633}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the current robot pose\n  robot_pose_ = cmap_->getRobotPose();\n\n  // Get the global goal pose\n  goal_pose_ = goal->pose;\n\n  // Generate a path from the current pose to the goal pose\n  makePlan(robot_pose_, goal_pose_, path_);\n}", "CodeBleu_score": 43.58280832336586}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\n  // Get the current global pose of the robot\n  tf::Stamped<tf::Pose> robotPose;\n  try {\n    tf_->transformPose(global_frame_, *goal, robotPose);\n  }\n  catch (tf::TransformException& ex) {\n    ROS_ERROR(\"Received an exception trying to transform a pose to the global frame: %s\", ex.what());\n    return;\n  }\n\n  // Generate a plan\n  std::vector<geometry_msgs::PoseStamped> path;\n  if (makePlan(robotPose, *goal, path)) {\n    // Publish the plan\n    nav_msgs::Path plan;\n    plan.poses = path;\n    plan.header.frame_id = global_frame_;\n    plan.header.stamp = ros::Time::now();\n    plan_pub_.publish(plan);\n  }\n}", "CodeBleu_score": 48.55489218594855}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  ROS_INFO(\"Received a new goal pose\");\n  // get the global pose of the robot\n  rm::PoseStamped robot_pose = cmap_->getRobotPose();\n  // generate a path from the current pose to the goal pose\n  std::vector<rm::PoseStamped> path;\n  makePlan(robot_pose, *goal, path);\n  // publish the path\n  path_pub_.publish(path);\n}", "CodeBleu_score": 53.2052767628558}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\n    // Create a service request\n    ros::ServiceClient param_set_client_ = nh_.serviceClient<mavros_msgs::ParamSet>(\"mavros/param/set\");\n    mavros_msgs::ParamSet srv;\n\n    // Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n    srv.request.param_id = param_set.param_id;\n    srv.request.value.integer = param_set.param_value;\n\n    // Call the param_set_client_ to send the request\n    if (!param_set_client_.call(srv)) {\n        ROS_ERROR(\"Failed to call service mavros/param/set\");\n    }\n}", "CodeBleu_score": 56.62741588844605}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\n    // Create a service request\n    ros::ServiceClient param_set_client_ = nh_.serviceClient<mavros_msgs::ParamSet>(\"mavros/param/set\");\n    mavros_msgs::ParamSet srv_param_set;\n\n    // Assign the parameter ID and value to the service request\n    srv_param_set.request.param_id = param_set.param_id;\n    srv_param_set.request.value.float_value = param_set.param_value;\n\n    // Send the service request\n    param_set_client_.call(srv_param_set);\n\n    if (!srv_param_set.response.success) {\n        ROS_ERROR(\"Error setting parameter %s\", param_set.param_id.c_str());\n    }\n}", "CodeBleu_score": 45.53666536089569}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    // Create a service request\n    mavros_msgs::ParamSet srv;\n\n    // Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n    srv.request.param_id = param_set.param_id;\n    srv.request.param_value = param_set.param_value;\n\n    // Call the param_set_client_ to send the request\n    this->param_set_client_.call(srv);\n\n    // Check the response\n    if (!srv.response.success) {\n        ROS_ERROR(\"Param set failed\");\n    }\n}", "CodeBleu_score": 72.33704514403104}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\n\t// Create a socket\n\tint sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sockfd < 0) {\n\t\tperror(\"ERROR opening socket\");\n\t\texit(1);\n\t}\n\n\t// Bind the socket to the port\n\tstruct sockaddr_in serv_addr;\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(port);\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr,\n\t\t\tsizeof(serv_addr)) < 0) {\n\t\tperror(\"ERROR on binding\");\n\t\texit(1);\n\t}\n\n\t// Listen for incoming connections\n\tlisten(sockfd, 5);\n\tcout << \"Listening on port \" << port << endl;\n\n\t// Wait for a connection from the ground station\n\tstruct sockaddr_in cli_addr;\n\tsocklen_t clilen = sizeof(cli_addr);\n\tint newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\tif (newsockfd < 0) {\n\t\tperror(\"ERROR on accept\");\n\t\texit(1);\n\t}\n\n\t// Enter a loop to handle further connections\n\twhile (true) {\n\t\t// Wait for a connection from the ground station\n\t\tcout << \"Waiting for a connection from the ground station\" << endl;\n\t\tnewsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\t\tif (newsockfd < 0) {\n\t\t\tperror(\"ERROR on accept\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Receive data\n\t\tcout << \"Received a connection from the ground station\" << endl;\n\t\trecvConnectionFromGroundStation(newsockfd);\n\t}\n\n\tclose(sockfd);\n}", "CodeBleu_score": 46.79920125155837}, {"code": "void CommunicationBridge::serverFun(){\n\t\n    int new_fd;\n    struct sockaddr_in their_addr;\n    socklen_t sin_size;\n    char buffer[BUFFER_SIZE];\n    int numBytes;\n    int i;\n    int n;\n    int rc;\n    int num_bytes_received = 0;\n    int num_bytes_to_receive = 0;\n    int num_bytes_remaining = 0;\n    int num_bytes_to_send = 0;\n    int num_bytes_sent = 0;\n    int num_bytes_received_total = 0;\n    int num_bytes_to_receive_total = 0;\n    int num_bytes_remaining_total = 0;\n    int num_bytes_to_send_total = 0;\n    int num_bytes_sent_total = 0;\n    int num_bytes_received_per_loop = 0;\n    int num_bytes_to_receive_per_loop = 0;\n    int num_bytes_remaining_per_loop = 0;\n    int num_bytes_to_send_per_loop = 0;\n    int num_bytes_sent_per_loop = 0;\n    int num_bytes_received_per_loop_total = 0;\n    int num_bytes_to_receive_per_loop_total = 0;\n    int num_bytes_remaining_per_loop_total = 0;\n    int num_bytes_to_send_per_loop_total = 0;\n    int num_bytes_sent_per_loop_total = 0;\n    int num_bytes_received_per_loop_per_loop = 0;\n    int num_bytes_to_receive_per_loop_per_loop = 0;\n    int num_bytes_remaining_per_loop_per_loop = 0;\n    int num_bytes_to_send_per_loop_per_loop = 0;\n    int num_bytes_sent_per_loop_per_loop = 0;\n    int num_bytes_received_per_loop_per", "CodeBleu_score": 7.511444409502632}, {"code": "void CommunicationBridge::serverFun(){\n\t    int serverSocket, clientSocket, portNumber;\n    struct sockaddr_in serverAddress, clientAddress;\n    int clientAddressSize;\n    char buffer[BUFFER_SIZE];\n    string receivedMessage;\n    int n;\n    bool isConnected = false;\n    int i = 0;\n    int messageLength = 0;\n\n    // Create the socket\n    serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverSocket < 0) {\n        perror(\"Socket\");\n        exit(1);\n    }\n\n    // Set the port number\n    portNumber = PORT_NUMBER;\n\n    // Set the server address\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_addr.s_addr = INADDR_ANY;\n    serverAddress.sin_port = htons(portNumber);\n\n    // Bind the socket\n    if (bind(serverSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0) {\n        perror(\"Bind\");\n        exit(1);\n    }\n\n    // Listen for connections\n    listen(serverSocket, 1);\n\n    // Wait for a connection\n    cout << \"Waiting for a connection...\" << endl;\n    clientAddressSize = sizeof(clientAddress);\n    clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, (socklen_t *) &clientAddressSize);\n    if (clientSocket < 0) {\n        perror(\"Accept\");\n        exit(1);\n    }\n    isConnected = true;\n    cout << \"Connected!\" << endl;\n\n    // Loop to accept connections and receive data\n    while (isConnected) {\n        // Receive data\n        n = recv(clientSocket, buffer, BUFFER_SIZE, 0);\n        if (n < 0) {\n            perror(\"Recv\");\n            exit(1);\n        }\n\n        // Decode the received message\n        receivedMessage = decodeMsg(buffer, n);\n\n        // Check if the received message length is zero or less\n        messageLength = receivedMessage.length();\n        if", "CodeBleu_score": 47.01417814835962}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\n    if (this->simulation_mode_) {\n        std::map<int, UAVBasic*>::iterator it;\n        it = this->swarm_control_simulation_.find(uav_cmd.id);\n        if (it != this->swarm_control_simulation_.end()) {\n            (*it).second->uavCmdPub.publish(uav_cmd);\n        }\n    } else {\n        this->uav_basic_->uavCmdPub.publish(uav_cmd);\n    }\n}", "CodeBleu_score": 54.66683497044181}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\n    // If not in simulation mode, publish the command to a single UAV\n    if(!this->simulation_mode_) {\n        this->uav_basic_->uavCmdPub(uav_cmd);\n    }\n\n    // If in simulation mode, find the corresponding UAV by ID from swarm_control_simulation_ and publish the command to the matching UAV\n    else {\n        std::map<std::string, std::shared_ptr<UAVBasic> >::iterator it;\n        it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n        if(it != this->swarm_control_simulation_.end()) {\n            (*it).second->uavCmdPub(uav_cmd);\n        }\n    }\n}", "CodeBleu_score": 60.37475550673324}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->simulation_mode_) {\n        std::map<int, UAVBasic*>::iterator it;\n        it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n        if (it != this->swarm_control_simulation_.end()) {\n            this->uav_basic_->uavCmdPub(it->second->uavCmdPub, uav_cmd);\n        }\n    } else {\n        this->uav_basic_->uavCmdPub(this->uav_basic_->uavCmdPub, uav_cmd);\n    }\n}", "CodeBleu_score": 51.91546996705427}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t  if (mode_selection.use_mode == REBOOTNX) {\n    system(\"reboot\");\n  } else if (mode_selection.use_mode == EXITNX) {\n    system(\"exit\");\n  } else if (mode_selection.use_mode == CREATEMODE) {\n    createMode(mode_selection.mode_name);\n  } else if (mode_selection.use_mode == DELETEMODE) {\n    deleteMode(mode_selection.mode_name);\n  }\n}", "CodeBleu_score": 51.24517979601039}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t}\n\telse if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"poweroff\");\n\t}\n\telse {\n\t\tif (mode_selection.use_mode == CREATE) {\n\t\t\tcreateMode(mode_selection);\n\t\t}\n\t\telse if (mode_selection.use_mode == DELETE) {\n\t\t\tdeleteMode(mode_selection);\n\t\t}\n\t}\n}", "CodeBleu_score": 60.303007406574835}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode == REBOOTNX) {\n        system(\"reboot\");\n    } else if (mode_selection.use_mode == EXITNX) {\n        system(\"poweroff\");\n    } else if (mode_selection.use_mode == CREATEMODE) {\n        createMode(mode_selection);\n    } else if (mode_selection.use_mode == DELETEMODE) {\n        deleteMode(mode_selection);\n    }\n}", "CodeBleu_score": 64.16946871150763}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  if (heartbeat_counter == heartbeat_counter_threshold) {\n    ROS_ERROR(\"Lost heartbeat\");\n    if (disconnect_flag == false) {\n      disconnect_flag = true;\n      if (vehicle_type == \"swarm\") {\n        triggerSwarmControl();\n      } else if (vehicle_type == \"UAV\") {\n        triggerUAV();\n      } else if (vehicle_type == \"UGV\") {\n        triggerUGV();\n      }\n    }\n  }\n}", "CodeBleu_score": 25.37079809331052}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (heartbeat_counter == heartbeat_count) {\n        ROS_ERROR(\"Communication Bridge: Heartbeat lost. No heartbeat received for %d seconds\", heartbeat_count);\n        if (disconnect_flag == false) {\n            disconnect_flag = true;\n            if (vehicle_type == \"swarm\") {\n                triggerSwarmControl(false);\n            } else if (vehicle_type == \"uav\") {\n                triggerUAV(false);\n            } else if (vehicle_type == \"ugv\") {\n                triggerUGV(false);\n            }\n        }\n    } else {\n        heartbeat_counter = 0;\n        disconnect_flag = false;\n    }\n}", "CodeBleu_score": 32.594486558519684}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (heartbeat_count == 0) {\n        if (heartbeat_count_prev == 0) {\n            ROS_INFO(\"[CommBridge]: Heartbeat received\");\n            heartbeat_count_prev = heartbeat_count;\n        } else {\n            heartbeat_count_prev = heartbeat_count;\n        }\n    } else {\n        if (heartbeat_count_prev == heartbeat_count) {\n            ROS_ERROR(\"[CommBridge]: Heartbeat lost\");\n            heartbeat_count_prev = heartbeat_count;\n            heartbeat_count_attempts++;\n        } else {\n            heartbeat_count_prev = heartbeat_count;\n            heartbeat_count_attempts = 0;\n        }\n    }\n\n    if (heartbeat_count_attempts == heartbeat_count_max_attempts) {\n        if (vehicle_type == \"swarm\") {\n            ROS_ERROR(\"[CommBridge]: Swarm disconnected\");\n            triggerSwarmControl();\n        } else if (vehicle_type == \"uav\") {\n            ROS_ERROR(\"[CommBridge]: UAV disconnected\");\n            triggerUAV();\n        } else if (vehicle_type == \"ugv\") {\n            ROS_ERROR(\"[CommBridge]: UGV disconnected\");\n            triggerUGV();\n        }\n        heartbeat_count_attempts = 0;\n    }\n}", "CodeBleu_score": 48.660015594100535}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract the drone ID\n    int id = msg->id;\n    // For each trajectory\n    for (int i = 0; i < msg->traj.size(); i++) {\n        // Initialize a Bspline struct\n        Bspline bspline;\n        // Set its attributes\n        bspline.id = id;\n        bspline.start_time = msg->traj[i].start_time.toSec();\n        bspline.duration = msg->traj[i].duration.toSec();\n        bspline.knots.clear();\n        bspline.pos_pts.clear();\n        bspline.yaw_pts.clear();\n        // Populate its knots\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots.push_back(msg->traj[i].knots[j]);\n        }\n        // Populate its position points\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts.push_back(msg->traj[i].pos_pts[j]);\n        }\n        // Populate its yaw points\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n        }\n        // Add the Bspline to the list of Bsplines\n        this->bsplines.push_back(bspline);\n    }\n    // Encode the MultiBsplines data\n    std::string data = this->communication->encodeMsg(this->bsplines);\n    // Send the encoded data via TCP\n    this->communication->sendMsgByTcp(data);\n}", "CodeBleu_score": 66.06915353249245}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t  // Extract drone ID from message\n  int id = msg->id;\n  // Initialize Bspline struct\n  Bspline bspline;\n  // Set Bspline attributes\n  bspline.id = id;\n  bspline.size = msg->traj.size();\n  bspline.knots.clear();\n  bspline.pos_pts.clear();\n  bspline.yaw_pts.clear();\n  // Populate Bspline knots\n  for (int i = 0; i < msg->traj.size(); i++) {\n    bspline.knots.push_back(msg->traj[i].knots);\n  }\n  // Populate Bspline position points\n  for (int i = 0; i < msg->traj.size(); i++) {\n    bspline.pos_pts.push_back(msg->traj[i].pos_pts);\n  }\n  // Populate Bspline yaw points\n  for (int i = 0; i < msg->traj.size(); i++) {\n    bspline.yaw_pts.push_back(msg->traj[i].yaw_pts);\n  }\n  // Populate Bspline start time\n  for (int i = 0; i < msg->traj.size(); i++) {\n    bspline.start_time.push_back(msg->traj[i].start_time.toSec());\n  }\n  // Encode Bspline data\n  this->communication->sendMsgByTcp(id, bspline);\n}", "CodeBleu_score": 43.076483238014106}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    for (int i = 0; i < msg->traj.size(); i++) {\n        Bspline bspline;\n        bspline.id = msg->traj[i].id;\n        bspline.knots.clear();\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots.push_back(msg->traj[i].knots[j]);\n        }\n        bspline.pos_pts.clear();\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts.push_back(msg->traj[i].pos_pts[j]);\n        }\n        bspline.yaw_pts.clear();\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n        }\n        bspline.start_time = msg->traj[i].start_time.toSec();\n        this->communication->sendMsgByTcp(this->communication->encodeMsg(bspline));\n    }\n}", "CodeBleu_score": 57.920996901658306}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(msg, cloud);\n\n    pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree_compression(0.005f);\n    octree_compression.setInputCloud(cloud.makeShared());\n\n    std::vector<uint8_t> compressed_data;\n    octree_compression.encodePointCloud(compressed_data);\n\n    sensor_msgs::PointCloud2 compressed_str;\n    compressed_str.header.stamp = msg.header.stamp;\n    compressed_str.header.frame_id = msg.header.frame_id;\n    compressed_str.height = 1;\n    compressed_str.width = compressed_data.size();\n    compressed_str.fields.resize(3);\n    compressed_str.fields[0].name = \"x\";\n    compressed_str.fields[1].name = \"y\";\n    compressed_str.fields[2].name = \"z\";\n    compressed_str.fields[0].offset = 0;\n    compressed_str.fields[1].offset = 4;\n    compressed_str.fields[2].offset = 8;\n    compressed_str.fields[0].datatype = 7;\n    compressed_str.fields[1].datatype = 7;\n    compressed_str.fields[2].datatype = 7;\n    compressed_str.fields[0].count = 1;\n    compressed_str.fields[1].count = 1;\n    compressed_str.fields[2].count = 1;\n    compressed_str.is_bigendian = false;\n    compressed_str.point_step = 12;\n    compressed_str.row_step = compressed_str.point_step * compressed_str.width;\n    compressed_str.is_dense = false;\n    compressed_str.data.resize(compressed_str.row_step);\n    std::memcpy(&compressed_str.data", "CodeBleu_score": 39.11239413190384}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t  // Convert the input message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Compress the point cloud\n  octree_compression.setInputCloud(cloud);\n  octree_compression.setMaximumDepth(max_depth);\n  octree_compression.setOctreeResolution(octree_resolution);\n  octree_compression.setCompressionMethod(pcl::octree::OcTreeCompressionMethod::OCTREE_MEDIAN_OCTREE_MEDIAN);\n  octree_compression.setCompressionLevel(pcl::octree::OcTreeCompressionLevel::OCTREE_LEVEL_FAST);\n  octree_compression.encodePointCloud();\n  std::vector<uint8_t> compressed_data = octree_compression.getCompressedData();\n\n  // Create a new PointCloud2 message with the compressed data\n  sensor_msgs::PointCloud2 compressed_msg;\n  compressed_msg.header = msg.header;\n  compressed_msg.height = 1;\n  compressed_msg.width = compressed_data.size();\n  compressed_msg.fields = msg.fields;\n  compressed_msg.is_bigendian = msg.is_bigendian;\n  compressed_msg.point_step = sizeof(uint8_t);\n  compressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n  compressed_msg.is_dense = msg.is_dense;\n  compressed_msg.data.resize(compressed_msg.row_step);\n  std::memcpy(compressed_msg.data.data(), compressed_data.data(), compressed_data.size());\n\n  // Release dynamically allocated memory\n  cloud.reset();\n\n  return compressed_msg;\n}", "CodeBleu_score": 47.10860418609578}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t  // Create a point cloud object\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  // Convert the ROS message to a pcl point cloud\n  pcl::fromROSMsg(msg, *cloud);\n  // Create a compressed point cloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr compressed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  // Create an octree compression object\n  pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression(resolution_);\n  // Set the input point cloud\n  octree_compression.setInputCloud(cloud);\n  // Compress the point cloud\n  octree_compression.encodePointCloud();\n  // Get the compressed data\n  std::vector<uint8_t> compressed_data = octree_compression.getCompressedData();\n  // Create a new PointCloud2 message\n  sensor_msgs::PointCloud2 compressed_msg;\n  // Set the header information\n  compressed_msg.header.frame_id = msg.header.frame_id;\n  compressed_msg.header.stamp = msg.header.stamp;\n  // Set the point cloud data fields\n  compressed_msg.fields = msg.fields;\n  // Set the point cloud height and width\n  compressed_msg.height = 1;\n  compressed_msg.width = compressed_data.size();\n  // Set the point cloud is_dense flag\n  compressed_msg.is_dense = msg.is_dense;\n  // Set the point cloud row step\n  compressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n  // Set the point cloud data\n  compressed_msg.data.resize(compressed_msg.row_step);\n  // Copy the compressed data to the point cloud message\n  std::memcpy(&compressed_msg.data[0], compressed_data.data(), compressed_data.size());\n  // Release dynamically allocated memory\n  cloud", "CodeBleu_score": 46.06861742255764}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 96.75999708297736}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].UAV_ID == uav_state.UAV_ID) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 79.97420543621121}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\n    for(int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++){\n        if(this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id){\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 71.2347259885006}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\n  // Initialize a MultiUGVState message\n  swarm_control::MultiUGVState multi_ugv_state;\n\n  // Iterate through each UGV state in the provided MultiUGVState structure\n  for (std::vector<swarm_control::UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n\n    // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n    swarm_control::UGVState ugv_state;\n    ugv_state.id = it->id;\n    ugv_state.battery = it->battery;\n    ugv_state.position.x = it->position.x;\n    ugv_state.position.y = it->position.y;\n    ugv_state.position.z = it->position.z;\n    ugv_state.velocity.x = it->velocity.x;\n    ugv_state.velocity.y = it->velocity.y;\n    ugv_state.velocity.z = it->velocity.z;\n    ugv_state.attitude.x = it->attitude.x;\n    ugv_state.attitude.y = it->attitude.y;\n    ugv_state.attitude.z = it->attitude.z;\n    ugv_state.attitude.w = it->attitude.w;\n\n    // Increment the UGV count and add each UGVState to the MultiUGVState message\n    multi_ugv_state.ugv_count++;\n    multi_ugv_state.ugv_state_all.push_back(ugv_state);\n  }\n\n  // Publish the assembled MultiUGVState message\n  this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 49.50886816262164}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\n    // Initialize a MultiUGVState message\n    swarm_robotics::MultiUGVState multi_ugv_state;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (std::vector<swarm_robotics::UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); ++it) {\n\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        swarm_robotics::UGVState ugv_state;\n        ugv_state.id = it->id;\n        ugv_state.battery = it->battery;\n        ugv_state.position.x = it->position.x;\n        ugv_state.position.y = it->position.y;\n        ugv_state.position.z = it->position.z;\n        ugv_state.velocity.x = it->velocity.x;\n        ugv_state.velocity.y = it->velocity.y;\n        ugv_state.velocity.z = it->velocity.z;\n        ugv_state.attitude.x = it->attitude.x;\n        ugv_state.attitude.y = it->attitude.y;\n        ugv_state.attitude.z = it->attitude.z;\n        ugv_state.attitude.w = it->attitude.w;\n\n        // Increment the UGV count and add each UGVState to the MultiUGVState message\n        multi_ugv_state.ugv_count++;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n    }\n\n    // Publish the assembled MultiUGVState message\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 50.404135668357696}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    // Initialize MultiUGVState message\n    m_multi_ugv_state.ugv_count = 0;\n    m_multi_ugv_state.ugv_state_all.clear();\n\n    // Iterate through each UGV state in the MultiUGVState structure\n    for (std::map<int, struct UGVState>::iterator it = m_multi_ugv_state.ugv_state_map.begin(); it != m_multi_ugv_state.ugv_state_map.end(); it++) {\n        // Populate UGVState message with ID, battery, position, velocity, and attitude data\n        m_multi_ugv_state.ugv_state_all.push_back(it->second);\n        m_multi_ugv_state.ugv_count++;\n    }\n\n    // Publish MultiUGVState message\n    this->all_ugv_state_pub_.publish(m_multi_ugv_state);\n}", "CodeBleu_score": 18.604704174042357}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  gradient.setZero();\n  // Iterate through control points\n  for (int i = 0; i < q.cols(); ++i) {\n    // Iterate through moving objects\n    for (int j = 0; j < moving_objs_->getObjNums(); ++j) {\n      // Get the predicted position of the object\n      Eigen::Vector3d obj_prid;\n      double t = (ros::Time::now().toSec() - moving_objs_->getObjTime(j)) / moving_objs_->getObjTf(j);\n      moving_objs_->evaluateConstVel(q.col(i), j, t, obj_prid);\n      // Calculate the distance between the control point and the object\n      double dist = (cps_.points.col(i) - obj_prid).norm();\n      if (dist < clearance_) {\n        // Update the cost and gradient\n        cost += pow(dist - clearance_, 2);\n        gradient.col(i) += 2.0 * (dist - clearance_) * (cps_.points.col(i) - obj_prid).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 46.85241526804967}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  gradient.resize(q.cols(), q.cols());\n  gradient.setZero();\n  cost = 0;\n  for (int i = 0; i < cps_.points.cols(); i++) {\n    // get the predicted position of moving objects\n    Eigen::VectorXd obj_prid = Eigen::VectorXd::Zero(moving_objs_->getObjNums());\n    for (int j = 0; j < moving_objs_->getObjNums(); j++) {\n      Eigen::VectorXd obj_pos = moving_objs_->evaluateConstVel(q.col(i), j);\n      obj_prid(j) = obj_pos(0);\n    }\n    // calculate the distance between the control point and the predicted position of moving objects\n    for (int j = 0; j < moving_objs_->getObjNums(); j++) {\n      double dist = (cps_.points.col(i) - obj_prid(j)).norm();\n      if (dist < clearance_) {\n        double diff = dist - clearance_;\n        cost += diff * diff;\n        gradient.col(i) += 2 * diff * (cps_.points.col(i) - obj_prid(j)).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 48.918403686643884}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Iterate through control points\n  for (int i = 0; i < q.cols(); ++i) {\n    // Evaluate the predicted positions of moving objects\n    std::vector<Eigen::Vector3d> obj_prids;\n    moving_objs_->evaluateConstVel(q.col(i), obj_prids);\n    // Iterate through moving objects\n    for (int j = 0; j < obj_prids.size(); ++j) {\n      // Calculate the distance between control points and these objects\n      Eigen::Vector3d obj_prid = obj_prids[j];\n      double dist = (cps_.points.col(i) - obj_prid).norm();\n      // If the distance is less than a specified clearance, update the cost and gradient\n      if (dist < clearance_) {\n        cost += pow(dist, 2);\n        gradient.col(i) += 2 * (cps_.points.col(i) - obj_prid).normalized() * pow(dist, 2);\n      }\n    }\n  }\n}", "CodeBleu_score": 41.86632266806569}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    // Initialize cost to zero\n    cost = 0.0;\n    // Initialize gradient to zero\n    gradient.setZero(q.rows(), q.cols());\n    // Iterate through control points\n    for (int i = 0; i < q.cols(); i++) {\n        // Compute positional error\n        Eigen::Vector3d x = q.col(i) - ref_pts_[i];\n        // Compute velocity vector\n        Eigen::Vector3d v = (ref_pts_[i + 1] - ref_pts_[i - 1]) / 2.0;\n        // Compute cost\n        cost += a2 * x.dot(x) + b2 * x.cross(v).norm();\n        // Compute gradient\n        gradient.col(i) = 2.0 * a2 * x + 2.0 * b2 * xcrossv.norm() * v;\n    }\n}", "CodeBleu_score": 28.841083881714326}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n\n    for (int i = 0; i < num_ref_pts_; i++) {\n        Eigen::Vector3d x = q.col(i);\n        Eigen::Vector3d v = (ref_pts_[i] - ref_pts_[i - 2]).normalized();\n\n        double a2 = 1.0;\n        double b2 = 1.0;\n        double c2 = 1.0;\n\n        double a = sqrt(a2);\n        double b = sqrt(b2);\n        double c = sqrt(c2);\n\n        double xdotv = x.dot(v);\n        double xcrossv = x.cross(v).norm();\n\n        double cost_i = a2 * pow(xdotv, 2) + b2 * pow(xcrossv, 2) + c2 * pow(x.cross(v).norm(), 2);\n        cost += cost_i;\n\n        Eigen::Vector3d grad_i = 2 * a2 * xdotv * v + 2 * b2 * xcrossv * xcrossv * v + 2 * c2 * xcrossv * v;\n        gradient.col(i) = grad_i;\n    }\n}", "CodeBleu_score": 49.19777462833185}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n  cost = 0;\n  gradient.setZero();\n\n  for (int i = 0; i < q.cols(); i++) {\n    Eigen::Vector3d x = q.col(i);\n    Eigen::Vector3d v = (q.col(i + 1) - q.col(i - 1)) / 2.0;\n    Eigen::Vector3d qi = ref_pts_[i];\n    Eigen::Vector3d qi_1 = ref_pts_[i - 1];\n    Eigen::Vector3d qi_2 = ref_pts_[i - 2];\n\n    Eigen::Vector3d xcrossv = x.cross(v);\n    Eigen::Vector3d qicrossqi_1 = qi.cross(qi_1);\n    Eigen::Vector3d qicrossqi_2 = qi.cross(qi_2);\n\n    double xdotv = x.dot(v);\n    double qidotqi_1 = qi.dot(qi_1);\n    double qidotqi_2 = qi.dot(qi_2);\n\n    double xnorm = x.norm();\n    double vnorm = v.norm();\n    double qinorm = qi.norm();\n    double qi_1norm = qi_1.norm();\n    double qi_2norm = qi_2.norm();\n\n    cost += a2 * pow(xnorm - qinorm, 2) + b2 * pow(xdotv - qidotqi_1, 2) +\n            c2 * pow(xcrossv.norm() - qicrossqi_1.norm(), 2) +\n            d2 * pow(xcrossv.norm() - qicrossqi_2.norm(), 2);\n\n    gradient.col(i) =\n        2 * a2 * (x - qi) / pow(xnorm - qinorm, 2) +\n        2 * b2 * (v - qi_1 + qi - qi_2) / pow(xdotv - qidotqi_1, 2) +\n        2 * c2", "CodeBleu_score": 45.84515100540011}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t  // Calculate the third derivative of the spline to obtain the jerk trajectory\n  Bspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  // Retrieve the knot times and control points of the jerk trajectory\n  vector<double> knot_times = jerk_traj.getKnotTimes();\n  MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n  // Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n  double jerk = 0;\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk += pow(ctrl_pts(j, i), 2) * (knot_times[i + 1] - knot_times[i]);\n    }\n  }\n\n  // Return the total jerk value\n  return jerk;\n}", "CodeBleu_score": 62.504974554298}, {"code": "double UniformBspline::getJerk(){\n\t\n\t// Calculate the third derivative of the spline\n\tUniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n\t// Retrieve the knot times and control points of the jerk trajectory\n\tvector<double> knot_times = jerk_traj.getKnotTimes();\n\tMatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n\t// Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n\tdouble total_jerk = 0.0;\n\tfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows(); j++) {\n\t\t\ttotal_jerk += pow(ctrl_pts(j, i), 2.0) * (knot_times[i + 1] - knot_times[i]);\n\t\t}\n\t}\n\n\t// Return the total jerk value\n\treturn total_jerk;\n}", "CodeBleu_score": 60.90270034331831}, {"code": "double UniformBspline::getJerk(){\n\t  // Compute the third derivative of the spline\n  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  // Retrieve the knot times and control points of the jerk trajectory\n  Eigen::VectorXd knot_times = jerk_traj.getKnotTimes();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n  // Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n  double jerk = 0;\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk += ctrl_pts(j, i) * ctrl_pts(j, i) * (knot_times(i + 1) - knot_times(i));\n    }\n  }\n\n  // Return the total jerk value\n  return jerk;\n}", "CodeBleu_score": 74.33801441852765}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\n  Eigen::Vector4d pos_camera;\n  pos_camera(0) = (u - cx_) * depth / fx_;\n  pos_camera(1) = (v - cy_) * depth / fy_;\n  pos_camera(2) = depth;\n  pos_camera(3) = 1.0;\n\n  return pos_camera;\n}", "CodeBleu_score": 84.1314400721232}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos_in_camera;\n    pos_in_camera << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n    return pos_in_camera;\n}", "CodeBleu_score": 53.766940494466695}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos_in_camera;\n    pos_in_camera[0] = (u - cx_) * depth / fx_;\n    pos_in_camera[1] = (v - cy_) * depth / fy_;\n    pos_in_camera[2] = depth;\n    pos_in_camera[3] = 1;\n    return pos_in_camera;\n}", "CodeBleu_score": 70.08609911445186}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(1, 1)));\n    } catch (const std::exception& e) {\n        ROS_ERROR_STREAM(\"Error extracting drone ID from odometry message: \" << e.what());\n    }\n}", "CodeBleu_score": 43.146925797402396}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(1, 1)));\n  } catch (const std::exception& e) {\n    ROS_ERROR_STREAM(\"Failed to extract drone ID from child_frame_id: \" << e.what());\n  }\n}", "CodeBleu_score": 42.97569867955439}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        int id = std::stoi(odom.child_frame_id.substr(1));\n        rcvDroneOdomCallbackBase(odom, id);\n    } catch (std::exception& e) {\n        ROS_ERROR_STREAM(\"Error extracting drone ID from odometry message: \" << e.what());\n    }\n}", "CodeBleu_score": 51.611769564915264}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // get the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = getTruePose(drone_id);\n    // get the true pose of the drone in the world frame\n    Eigen::Vector3d world_pose = getWorldPose(drone_id);\n    // compute the pose error between the camera and world coordinates\n    Eigen::Vector3d pose_error = world_pose - true_pose;\n    // check for drone presence\n    if (pose_error.norm() < POSE_ERROR_THRESHOLD) {\n        // if found, update the debug result\n        debug_result_.detected = true;\n        // compute the drone pose in the camera frame\n        Eigen::Vector3d drone_pose = getDronePose(drone_id);\n        // compute the drone pose in the image frame\n        Eigen::Vector2i image_pixel = getImagePose(drone_pose);\n        // compute the drone pose error\n        Eigen::Vector2i pose_error = image_pixel - true_pixel;\n        // publish the pose error\n        geometry_msgs::Vector3Stamped pose_error_msg;\n        pose_error_msg.header.stamp = ros::Time::now();\n        pose_error_msg.header.frame_id = \"world\";\n        pose_error_msg.vector.x = pose_error(0);\n        pose_error_msg.vector.y = pose_error(1);\n        pose_error_msg.vector.z = 0.0;\n        drone_pose_err_pub_[drone_id].publish(pose_error_msg);\n    } else {\n        // if not found, update the debug result\n        debug_result_.detected = false;\n    }\n}", "CodeBleu_score": 43.84177390203874}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n  // 1. Calculate the true pose of the drone in the camera frame\n  Eigen::Vector3d true_pose;\n  true_pose = getTruePose(drone_id, true_pixel);\n\n  // 2. Check for the presence of the drone in the camera frame\n  if (checkPresence(true_pose)) {\n\n    // 3. Compute the pose error between the camera and world coordinates\n    Eigen::Vector3d pose_error;\n    pose_error = getPoseError(true_pose);\n\n    // 4. Update the debug result\n    debug_result_.result = true;\n    debug_result_.drone_id = drone_id;\n    debug_result_.true_pixel.x = true_pixel.x();\n    debug_result_.true_pixel.y = true_pixel.y();\n    debug_result_.pose_error.x = pose_error.x();\n    debug_result_.pose_error.y = pose_error.y();\n    debug_result_.pose_error.z = pose_error.z();\n\n    // 5. Publish the pose error\n    drone_pose_err_pub_[drone_id].publish(pose_error);\n\n  } else {\n\n    // 3. Update the debug result to indicate failure\n    debug_result_.result = false;\n    debug_result_.drone_id = drone_id;\n    debug_result_.true_pixel.x = true_pixel.x();\n    debug_result_.true_pixel.y = true_pixel.y();\n    debug_result_.pose_error.x = 0.0;\n    debug_result_.pose_error.y = 0.0;\n    debug_result_.pose_error.z = 0.0;\n\n  }\n\n}", "CodeBleu_score": 39.318916930679194}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Set the debug result to indicate failure.\n    debug_result_[drone_id].found = false;\n    debug_result_[drone_id].pose_error = 100000000;\n\n    // If the drone is not in the list, return.\n    if (drone_list_.find(drone_id) == drone_list_.end()) {\n        return;\n    }\n\n    // Get the drone's true pose in the camera frame.\n    Eigen::Vector3d true_pose = drone_list_[drone_id].getTruePose();\n\n    // Check if the drone is in the camera frame.\n    if (true_pose(2) < 0) {\n        return;\n    }\n\n    // Convert the true pose to a pixel position.\n    Eigen::Vector2i pixel;\n    camera_model_.project3dToPixel(true_pose, pixel);\n\n    // Calculate the pose error between the camera and world coordinates.\n    double pose_error = sqrt(pow(true_pixel(0) - pixel(0), 2) + pow(true_pixel(1) - pixel(1), 2));\n\n    // If the pose error is less than the threshold, set the debug result to indicate success.\n    if (pose_error < POSE_ERROR_THRESHOLD) {\n        debug_result_[drone_id].found = true;\n        debug_result_[drone_id].pose_error = pose_error;\n    }\n\n    // Publish the pose error.\n    geometry_msgs::PointStamped pose_error_msg;\n    pose_error_msg.header.frame_id = \"world\";\n    pose_error_msg.header.stamp = ros::Time::now();\n    pose_error_msg.point.x = true_pose(0);\n    pose_error_msg.point.y = true_pose(1);\n    pose_error_msg.point.z = true_pose(2);\n    drone_pose_err_pub_[drone_id].publish(pose_error_msg);\n}", "CodeBleu_score": 47.189349891065355}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->getCameFrom()) {\n\t\tcurrent = current->getCameFrom();\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.08874154033074}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getCameFrom() != nullptr) {\n        current = current->getCameFrom();\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 77.40374327276972}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 84.87661016034235}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\n    // convert to indices\n    if (!Coord2Index(start_pt, start_idx)) {\n        // conversion failed\n        return false;\n    }\n    if (!Coord2Index(end_pt, end_idx)) {\n        // conversion failed\n        return false;\n    }\n\n    // check if start or end point is inside an obstacle\n    if (IsObstacle(start_idx) || IsObstacle(end_idx)) {\n\n        // adjust start or end point to be outside obstacle\n        Vector3d adjusted_start_pt = start_pt;\n        Vector3d adjusted_end_pt = end_pt;\n        Vector3i adjusted_start_idx = start_idx;\n        Vector3i adjusted_end_idx = end_idx;\n        if (IsObstacle(start_idx)) {\n            // start point is inside an obstacle\n            if (!AdjustPointToBeOutsideObstacle(start_pt, end_pt, adjusted_start_pt, adjusted_end_pt, adjusted_start_idx, adjusted_end_idx)) {\n                // adjustment failed\n                return false;\n            }\n        }\n        else {\n            // end point is inside an obstacle\n            if (!AdjustPointToBeOutsideObstacle(end_pt, start_pt, adjusted_end_pt, adjusted_start_pt, adjusted_end_idx, adjusted_start_idx)) {\n                // adjustment failed\n                return false;\n            }\n        }\n\n        // check if adjusted start or end point is inside an obstacle\n        if (IsObstacle(adjusted_start_idx) || IsObstacle(adjusted_end_idx)) {\n            // adjusted start or end point is still inside an obstacle\n            return false;\n        }\n\n        // update start and end points\n        start_pt = adjusted_start_pt;\n        end_pt = adjusted_end_pt;\n        start_idx = adjusted_start_idx;\n        end_idx = adjusted_end_idx;\n    }\n\n    // conversion and adjustment successful\n    return true;\n", "CodeBleu_score": 46.28018584529251}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  // Convert the points to indices\n  bool start_idx_valid = Coord2Index(start_pt, start_idx);\n  bool end_idx_valid = Coord2Index(end_pt, end_idx);\n\n  if (!start_idx_valid || !end_idx_valid) {\n    return false;\n  }\n\n  // If the start or end point is inside an obstacle, adjust it\n  if (IsObstacle(start_idx) || IsObstacle(end_idx)) {\n    // Attempt to adjust the start point\n    if (IsObstacle(start_idx)) {\n      Vector3d new_start_pt = AdjustPoint(start_pt, end_pt);\n      if (!Coord2Index(new_start_pt, start_idx)) {\n        return false;\n      }\n    }\n\n    // Attempt to adjust the end point\n    if (IsObstacle(end_idx)) {\n      Vector3d new_end_pt = AdjustPoint(end_pt, start_pt);\n      if (!Coord2Index(new_end_pt, end_idx)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 46.341366704516716}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  if (!ConvertToIndex(start_pt, start_idx) || !ConvertToIndex(end_pt, end_idx)) {\n    return false;\n  }\n  if (IsOccupied(start_idx) || IsOccupied(end_idx)) {\n    Vector3d adjusted_start_pt = start_pt;\n    Vector3d adjusted_end_pt = end_pt;\n    Vector3d direction_to_start = (start_pt - end_pt).normalized();\n    Vector3d direction_to_end = (end_pt - start_pt).normalized();\n    Vector3d adjusted_start_pt_direction = direction_to_start;\n    Vector3d adjusted_end_pt_direction = direction_to_end;\n    int count = 0;\n    while (IsOccupied(start_idx) || IsOccupied(end_idx)) {\n      if (IsOccupied(start_idx)) {\n        adjusted_start_pt = start_pt + adjusted_start_pt_direction * (1.0 + 0.5 * count);\n        if (!ConvertToIndex(adjusted_start_pt, start_idx)) {\n          return false;\n        }\n        adjusted_start_pt_direction = adjusted_start_pt_direction + direction_to_start;\n      }\n      if (IsOccupied(end_idx)) {\n        adjusted_end_pt = end_pt + adjusted_end_pt_direction * (1.0 + 0.5 * count);\n        if (!ConvertToIndex(adjusted_end_pt, end_idx)) {\n          return false;\n        }\n        adjusted_end_pt_direction = adjusted_end_pt_direction + direction_to_end;\n      }\n      count++;\n      if (count > 10000) {\n        return false;\n      }\n    }\n  }\n  return true;\n}", "CodeBleu_score": 51.78625295867055}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\n    // Get the corresponding grid coordinates for the min and max positions.\n    Eigen::Vector3i min_id = getGridCoords(min_pos);\n    Eigen::Vector3i max_id = getGridCoords(max_pos);\n\n    // Iterate over the grid coordinates and set the corresponding elements in the occupancy buffer to zero.\n    for (int x = min_id(0); x <= max_id(0); x++) {\n        for (int y = min_id(1); y <= max_id(1); y++) {\n            for (int z = min_id(2); z <= max_id(2); z++) {\n                occupancy_buffer_inflate_(x, y, z) = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 65.60410075426093}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n  resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 26.467120033493703}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n  getGridId(min_pos, min_id);\n  getGridId(max_pos, max_id);\n\n  resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 26.45811990966002}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\n\tdouble max_x = map_size_x_m / 2.0;\n\tdouble min_x = -max_x;\n\tdouble max_y = map_size_y_m / 2.0;\n\tdouble min_y = -max_y;\n\tdouble max_z = map_size_z_m / 2.0;\n\tdouble min_z = -max_z;\n\n\tdouble max_trans_x = diff[0] > 0 ? max_x - pt[0] : min_x - pt[0];\n\tdouble max_trans_y = diff[1] > 0 ? max_y - pt[1] : min_y - pt[1];\n\tdouble max_trans_z = diff[2] > 0 ? max_z - pt[2] : min_z - pt[2];\n\n\tdouble max_trans = std::max(std::max(max_trans_x, max_trans_y), max_trans_z);\n\n\tdouble trans_x = diff[0] > 0 ? max_trans : -max_trans;\n\tdouble trans_y = diff[1] > 0 ? max_trans : -max_trans;\n\tdouble trans_z = diff[2] > 0 ? max_trans : -max_trans;\n\n\tEigen::Vector3d new_pt;\n\tnew_pt[0] = pt[0] + trans_x;\n\tnew_pt[1] = pt[1] + trans_y;\n\tnew_pt[2] = pt[2] + trans_z;\n\n\treturn new_pt;\n}", "CodeBleu_score": 31.975233841565732}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d max_translation = Eigen::Vector3d::Zero();\n\tEigen::Vector3d min_translation = Eigen::Vector3d::Zero();\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff(i) > 0) {\n\t\t\tmax_translation(i) = diff(i);\n\t\t\tmin_translation(i) = 0;\n\t\t} else {\n\t\t\tmax_translation(i) = 0;\n\t\t\tmin_translation(i) = diff(i);\n\t\t}\n\t}\n\n\tdouble max_scale = 1;\n\tdouble min_scale = 1;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tdouble max_scale_i = max_translation(i) / (resolution_ * (size_ - 1));\n\t\tdouble min_scale_i = min_translation(i) / (resolution_ * (size_ - 1));\n\n\t\tif (max_scale_i < max_scale) {\n\t\t\tmax_scale = max_scale_i;\n\t\t}\n\n\t\tif (min_scale_i > min_scale) {\n\t\t\tmin_scale = min_scale_i;\n\t\t}\n\t}\n\n\tEigen::Vector3d adjusted_pt = pt;\n\tfor (int i = 0; i < 3; i++) {\n\t\tadjusted_pt(i) = camera_pt(i) + (max_scale * (resolution_ * (size_ - 1)));\n\t}\n\n\treturn adjusted_pt;\n}", "CodeBleu_score": 43.7929710862993}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff_vec = pt - camera_pt;\n\tEigen::Vector3d min_vec = Eigen::Vector3d::Zero();\n\tEigen::Vector3d max_vec = Eigen::Vector3d::Zero();\n\tEigen::Vector3d adjusted_pt = pt;\n\tdouble min_scale = 1.0;\n\tdouble max_scale = 1.0;\n\tdouble scale = 1.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff_vec(i) < 0.0) {\n\t\t\tmin_vec(i) = diff_vec(i);\n\t\t\tmax_vec(i) = 0.0;\n\t\t}\n\t\telse {\n\t\t\tmin_vec(i) = 0.0;\n\t\t\tmax_vec(i) = diff_vec(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (min_vec(i) < 0.0) {\n\t\t\tscale = -min_vec(i) / diff_vec(i);\n\t\t\tif (scale < min_scale) {\n\t\t\t\tmin_scale = scale;\n\t\t\t}\n\t\t}\n\t\tif (max_vec(i) > 0.0) {\n\t\t\tscale = max_vec(i) / diff_vec(i);\n\t\t\tif (scale > max_scale) {\n\t\t\t\tmax_scale = scale;\n\t\t\t}\n\t\t}\n\t}\n\tif (max_scale < min_scale) {\n\t\tscale = min_scale;\n\t}\n\telse {\n\t\tscale = max_scale;\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tadjusted_pt(i) = camera_pt(i) + diff_vec(i) * scale;\n\t}\n\treturn adjusted_pt;\n}", "CodeBleu_score": 42.15455564245153}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  if (md_.is_initialized_) {\n    // Update last occupancy update time.\n    md_.last_occ_update_time_ = ros::Time::now();\n\n    // Update occupancy grid.\n    if (md_.update_needed_) {\n      // Project depth image into points.\n      projectDepthImage();\n\n      // Process points with raycasting.\n      if (raycastProcess()) {\n        // Clear and inflate local map.\n        clearAndInflateLocalMap();\n      }\n    }\n\n    // Handle timeout errors for odometry or depth data.\n    if (md_.odom_timeout_error_) {\n      ROS_ERROR(\"Odometry data timeout error.\");\n      md_.odom_timeout_error_ = false;\n    }\n    if (md_.depth_timeout_error_) {\n      ROS_ERROR(\"Depth data timeout error.\");\n      md_.depth_timeout_error_ = false;\n    }\n  }\n}", "CodeBleu_score": 45.04410657375875}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Update occupancy grid based on latest sensor data.\n  if (updateOccupancyGrid()) {\n    // Clear and inflate local map.\n    clearAndInflateLocalMap();\n  }\n\n  // Handle timeout errors for odometry or depth data.\n  if (ros::Time::now() - md_.last_odom_time_ > ros::Duration(md_.odom_timeout_)) {\n    ROS_ERROR(\"Timeout error for odometry data (%f s).\", (ros::Time::now() - md_.last_odom_time_).toSec());\n    md_.odom_timeout_error_ = true;\n  }\n  if (ros::Time::now() - md_.last_depth_time_ > ros::Duration(md_.depth_timeout_)) {\n    ROS_ERROR(\"Timeout error for depth data (%f s).\", (ros::Time::now() - md_.last_depth_time_).toSec());\n    md_.depth_timeout_error_ = true;\n  }\n\n  // Set relevant flags.\n  md_.occ_grid_updated_ = true;\n  md_.map_updated_ = true;\n}", "CodeBleu_score": 60.78282735823585}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // update last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // check if update is needed\n  if (md_.last_odom_update_time_.toSec() + md_.min_time_between_updates_ <\n      md_.last_occ_update_time_.toSec()) {\n    // check if depth data is available\n    if (md_.depth_data_available_) {\n      // project depth image into points\n      projectDepthImage();\n      // process points with raycasting\n      if (raycastProcess()) {\n        // clear and inflate local map\n        clearAndInflateLocalMap();\n      }\n    } else {\n      // set flag for timeout error\n      md_.timeout_error_ = true;\n    }\n  }\n}", "CodeBleu_score": 36.52509634383893}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n\t// Check that the input vectors are the same size\n\tif (image_fns.size() != gt_fns.size() || image_fns.size() != dt_fns.size()) {\n\t\tcerr << \"Error: The input vectors must have the same number of elements.\" << endl;\n\t\treturn 0;\n\t}\n\n\t// Initialize the accumulator\n\tfloat f_measure = 0;\n\n\t// Iterate through the images\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\n\t\t// Load the image\n\t\tMat image = imread(image_fns[i]);\n\n\t\t// Load the ground truth and detected ellipses\n\t\tvector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i], gt_angle_radians);\n\n\t\t// Evaluate the detection performance\n\t\tfloat f_measure_image = _ellipse_evaluate_one(image, gt_ellipses, dt_ellipses);\n\n\t\t// Accumulate the F-measure\n\t\tf_measure += f_measure_image;\n\n\t}\n\n\t// Return the average F-measure\n\treturn f_measure / image_fns.size();\n\n}", "CodeBleu_score": 59.64099367006826}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    // Initialize the accumulator\n    float f_accum = 0.0;\n\n    // Iterate through the image filenames\n    for (int i = 0; i < image_fns.size(); i++) {\n        // Load the image\n        Mat image = imread(image_fns[i]);\n\n        // Load the ground truth\n        vector<Ellipse> gt = _load_ellipse_GT(gt_fns[i], image, gt_angle_radians);\n\n        // Load the detected ellipses\n        vector<Ellipse> dt = _load_ellipse_DT(dt_fns[i], image);\n\n        // Evaluate the detection performance\n        float f = _ellipse_evaluate_one(image, gt, dt);\n\n        // Accumulate the F-measure\n        f_accum += f;\n    }\n\n    // Return the average F-measure\n    return f_accum / image_fns.size();\n}", "CodeBleu_score": 67.32899313364447}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tint n_images = image_fns.size();\n\tfloat f_measure = 0;\n\tfor (int i = 0; i < n_images; i++) {\n\t\tMat image = imread(image_fns[i]);\n\t\tMat gt_ellipse = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\tMat dt_ellipse = _load_ellipse_DT(dt_fns[i]);\n\t\tf_measure += _ellipse_evaluate_one(image, gt_ellipse, dt_ellipse);\n\t}\n\treturn f_measure / n_images;\n}", "CodeBleu_score": 56.15315904106001}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle;\n    float angle1, angle2;\n    float diff;\n\n    if (foci) {\n        angle1 = atan2(y - foci[0], x - foci[1]);\n        angle2 = atan2(y - foci[2], x - foci[3]);\n        diff = angle_diff_signed(angle1, angle2);\n        angle = angle1 + diff / 2.0f;\n    } else {\n        angle = atan2(y, x);\n    }\n\n    if (angle < 0) {\n        angle += 2 * M_PI;\n    }\n\n    return angle;\n}", "CodeBleu_score": 47.624285514693675}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle_1, angle_2;\n    if (foci) {\n        angle_1 = atan2(y - foci[0], x - foci[1]);\n        angle_2 = atan2(y - foci[2], x - foci[3]);\n    } else {\n        angle_1 = atan2(y, x);\n        angle_2 = angle_1;\n    }\n    return angle_diff_signed(angle_1, angle_2);\n}", "CodeBleu_score": 41.48508865825805}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle_to_focus1, angle_to_focus2, angle_diff_signed;\n    if (foci != NULL) {\n        angle_to_focus1 = atan2(y - foci[0], x - foci[1]);\n        angle_to_focus2 = atan2(y - foci[2], x - foci[3]);\n        angle_diff_signed = angle_to_focus2 - angle_to_focus1;\n    } else {\n        angle_diff_signed = atan2(y, x);\n    }\n    return fmod(angle_diff_signed + 3.141592653589793, 6.283185307179586) - 3.141592653589793;\n}", "CodeBleu_score": 44.340131789842296}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint i;\n\tdouble min_x, max_x, min_y, max_y;\n\tdouble above_integral = 0, below_integral = 0;\n\n\tmin_x = vp1[start].x;\n\tmax_x = vp1[start].x;\n\tmin_y = vp1[start].y;\n\tmax_y = vp1[start].y;\n\n\tfor (i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\telse if (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\telse if (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\n\tfor (i = start + 1; i <= end; i++) {\n\t\tabove_integral += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y + vp1[i - 1].y);\n\t\tbelow_integral += (vp1[i].x - vp1[i - 1].x) * (min_y + max_y - vp1[i].y - vp1[i - 1].y);\n\t}\n\n\tif (above_integral < below_integral)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 36.66968035552743}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint min_x = vp1[start].x, max_x = vp1[start].x, min_y = vp1[start].y, max_y = vp1[start].y;\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\telse if (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\telse if (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\tdouble integral_above = 0, integral_below = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tintegral_above += (vp1[i].y - min_y) * (vp1[i].x - min_x);\n\t\tintegral_below += (max_y - vp1[i].y) * (vp1[i].x - min_x);\n\t}\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 37.40162679174993}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint i, j;\n\tdouble minx, maxx, miny, maxy, integral_above, integral_below, x, y;\n\tminx = maxx = vp1[start].x;\n\tminy = maxy = vp1[start].y;\n\tfor (i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < minx)\n\t\t\tminx = vp1[i].x;\n\t\telse if (vp1[i].x > maxx)\n\t\t\tmaxx = vp1[i].x;\n\t\tif (vp1[i].y < miny)\n\t\t\tminy = vp1[i].y;\n\t\telse if (vp1[i].y > maxy)\n\t\t\tmaxy = vp1[i].y;\n\t}\n\tintegral_above = 0.0;\n\tfor (i = start; i < end; i++) {\n\t\tj = i + 1;\n\t\tif (j == end)\n\t\t\tj = start;\n\t\tx = vp1[j].x - vp1[i].x;\n\t\ty = vp1[j].y - vp1[i].y;\n\t\tif (x < 0.0)\n\t\t\tintegral_above += x * (vp1[i].y + vp1[j].y) / 2.0;\n\t\telse\n\t\t\tintegral_above += x * (vp1[j].y + vp1[i].y) / 2.0;\n\t}\n\tintegral_below = 0.0;\n\tfor (i = start; i < end; i++) {\n\t\tj = i + 1;\n\t\tif (j == end)\n\t\t\tj = start;\n\t\tx = vp1[j].x - vp1[i].x;\n\t\ty = vp1[j].y - vp1[i].y;\n\t\tif (x < 0.0)\n\t\t\tintegral_below +=", "CodeBleu_score": 33.810449078146995}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  if (msg->detected_num > 0) {\n    for (int i = 0; i < msg->detected_num; i++) {\n      if (msg->detected_objects[i].object_name == \"T\") {\n        num_regain++;\n        num_lost = 0;\n      } else {\n        num_regain = 0;\n        num_lost++;\n      }\n    }\n  }\n  if (num_lost > VISION_THRES) {\n    is_detected = false;\n  }\n  if (num_regain > VISION_THRES) {\n    is_detected = true;\n  }\n  if (is_detected) {\n    ellipse_det = msg->detected_objects[0];\n    ellipse_det.sight_angle[0] = msg->detected_objects[1].sight_angle[0];\n    ellipse_det.sight_angle[1] = msg->detected_objects[1].sight_angle[1];\n  }\n}", "CodeBleu_score": 68.36419574288423}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\n  for (int i = 0; i < msg->info.size(); i++) {\n\n    if (msg->info[i].name == \"T\") {\n      ellipse_det.is_detected = true;\n      ellipse_det.num_regain++;\n      ellipse_det.num_lost = 0;\n\n      if (ellipse_det.num_regain > VISION_THRES) {\n        ellipse_det.num_regain = 0;\n        ellipse_det.num_lost = 0;\n      }\n    } else {\n      ellipse_det.is_detected = false;\n      ellipse_det.num_regain = 0;\n      ellipse_det.num_lost++;\n\n      if (ellipse_det.num_lost > VISION_THRES) {\n        ellipse_det.num_regain = 0;\n        ellipse_det.num_lost = 0;\n      }\n    }\n\n    if (ellipse_det.is_detected == true) {\n      ellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n      ellipse_det.sight_angle[1] = ellipse_det.sight_angle[2];\n      ellipse_det.sight_angle[2] = msg->info[i].sight_angle;\n    }\n  }\n}", "CodeBleu_score": 43.85360590112488}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  for (int i = 0; i < msg->detections.size(); i++) {\n    if (msg->detections[i].name == \"T\") {\n      ellipse_det.is_detected = true;\n      ellipse_det.sight_angle = msg->detections[i].sight_angle;\n      ellipse_det.sight_angle.swap(ellipse_det.sight_angle);\n      num_regain++;\n      num_lost = 0;\n    } else {\n      num_regain = 0;\n      num_lost++;\n    }\n  }\n  if (num_lost > VISION_THRES) {\n    ellipse_det.is_detected = false;\n  }\n  if (num_regain > VISION_THRES) {\n    ellipse_det.is_detected = true;\n  }\n}", "CodeBleu_score": 57.04294349456903}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    if (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 45.605529573253236}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t  Eigen::Vector3d pos;\n  pos << cur_pos(0), cur_pos(1), cur_pos(2);\n  if (Occupy_map_ptr->check_safety(pos, safe_distance)) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 50.39925326761796}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    // Check the safety of the current position\n    bool is_safe = Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n    return is_safe;\n}", "CodeBleu_score": 66.91215096233195}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t  NodePtr curr_node = end_node;\n\n  path_nodes_.push_back(curr_node);\n\n  while (curr_node->parent_ != nullptr) {\n    curr_node = curr_node->parent_;\n    path_nodes_.push_back(curr_node);\n  }\n\n  std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 65.66793193471632}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.push_back(end_node);\n\tNodePtr current_node = end_node;\n\twhile (current_node->parent_ != nullptr) {\n\t\tcurrent_node = current_node->parent_;\n\t\tpath_nodes_.push_back(current_node);\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 58.662766588454076}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t  // TODO: Implement this function\n  path_nodes_.push_back(end_node);\n  while (end_node->parent != NULL) {\n    end_node = end_node->parent;\n    path_nodes_.push_back(end_node);\n  }\n  reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 53.53417857073821}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n  // Get the odometry data\n  double x = odom->pose.pose.position.x;\n  double y = odom->pose.pose.position.y;\n  double z = odom->pose.pose.position.z;\n\n  // Set the state of the neighboring UGV\n  state_nei[id] = {x, y, z};\n\n  // In simulation mode, check the distance from the start position and set the get_nei_state flag to false if the distance exceeds 5 meters\n  if(sim_mode) {\n    double dist = sqrt((x - start_pos.x) * (x - start_pos.x) + (y - start_pos.y) * (y - start_pos.y) + (z - start_pos.z) * (z - start_pos.z));\n    if(dist > 5) {\n      get_nei_state[id] = false;\n    }\n    else {\n      get_nei_state[id] = true;\n    }\n  }\n  else {\n    get_nei_state[id] = true;\n  }\n}", "CodeBleu_score": 53.264082991337226}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n\t//Get the current position of the UGV\n\tdouble x = odom->pose.pose.position.x;\n\tdouble y = odom->pose.pose.position.y;\n\tdouble z = odom->pose.pose.position.z;\n\n\t//Update the state of the neighboring UGV\n\tstate_nei[id] = Vector3d(x, y, z);\n\n\t//Check if the distance from the start position is less than 5 meters\n\tif (start_pos_set) {\n\t\tdouble distance = sqrt(pow(x - start_pos.x(), 2) + pow(y - start_pos.y(), 2) + pow(z - start_pos.z(), 2));\n\t\tif (distance > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.593667131152095}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    // Get the state of the neighboring UGV\n    double x = odom->pose.pose.position.x;\n    double y = odom->pose.pose.position.y;\n    double z = odom->pose.pose.position.z;\n    // If in simulation mode, check the distance from the start position\n    if (sim_mode) {\n        // Calculate the distance from the start position\n        double dist = sqrt(pow(start_pos.x - x, 2) + pow(start_pos.y - y, 2));\n        // If the distance exceeds 5 meters, set the get_nei_state flag to false\n        if (dist > 5) {\n            get_nei_state[id] = false;\n        }\n        // Otherwise, set the get_nei_state flag to true\n        else {\n            get_nei_state[id] = true;\n        }\n    }\n    // Otherwise, set the get_nei_state flag to true\n    else {\n        get_nei_state[id] = true;\n    }\n    // Assign the UGV's position and height to the state_nei array\n    state_nei[id][0] = x;\n    state_nei[id][1] = y;\n    state_nei[id][2] = z;\n}", "CodeBleu_score": 60.08714622029794}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  update_count++;\n  if (update_count % 5 != 0) {\n    return;\n  }\n  update_count = 0;\n  // ROS_INFO(\"Updating map with new point cloud data\");\n  // std::cout << \"Updating map with new point cloud data\" << std::endl;\n  // std::cout << \"Astar_ptr->Occupy_map_ptr->map_update_gpcl\" << std::endl;\n  Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n}", "CodeBleu_score": 58.69484826366694}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n  if (odom_ready == false) {\n    return;\n  }\n\n  sensor_ready = true;\n  sensor_update_count++;\n\n  if (sensor_update_count == 5) {\n\n    // update the occupancy grid map with the new point cloud data\n    Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg, Astar_ptr->Occupy_map_ptr->map_size, Astar_ptr->Occupy_map_ptr->resolution, Astar_ptr->Occupy_map_ptr->origin_x, Astar_ptr->Occupy_map_ptr->origin_y, Astar_ptr->Occupy_map_ptr->origin_z);\n\n    sensor_update_count = 0;\n  }\n}", "CodeBleu_score": 54.40485833549388}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Gpointcloud_cb\");\n\tif (odom_ready == false) {\n\t\t//ROS_INFO(\"odom_ready is false\");\n\t\treturn;\n\t}\n\tif (sensor_ready == false) {\n\t\t//ROS_INFO(\"sensor_ready is false\");\n\t\tsensor_ready = true;\n\t\treturn;\n\t}\n\t//ROS_INFO(\"sensor_ready is true\");\n\tupdate_counter++;\n\tif (update_counter % 5 != 0) {\n\t\treturn;\n\t}\n\t//ROS_INFO(\"update_counter is 5\");\n\t//ROS_INFO(\"Astar_ptr->Occupy_map_ptr->map_update_gpcl\");\n\tAstar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n\tupdate_counter = 0;\n\tsensor_ready = false;\n}", "CodeBleu_score": 48.12977915216665}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl == false) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, global_pcl);\n    inflate_point_cloud(global_pcl, global_pcl_inflate, inflate_distance);\n  }\n}", "CodeBleu_score": 49.459714778611136}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl) {\n    return;\n  }\n  else {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, global_map);\n    inflate_point_cloud(global_map, global_map_inflated);\n  }\n}", "CodeBleu_score": 53.878056220230455}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl) {\n    return;\n  } else {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, gpcl);\n    gpcl.header.frame_id = \"map\";\n    gpcl.header.stamp = ros::Time::now();\n    inflate_point_cloud(gpcl, inflated_gpcl, inflation_radius);\n  }\n}", "CodeBleu_score": 56.483759272577736}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n  if(simulation_mode_){\n    map_update_laser_simulation(local_point, odom);\n  }else{\n    map_update_laser_real(local_point, odom);\n  }\n\n}", "CodeBleu_score": 30.129869736165826}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t  if(map_loaded_flag_ == false){\n    ROS_WARN(\"The occupancy map has not been loaded, please load the map first.\");\n    return;\n  }\n\n  if(simulation_mode_ == false){\n    //ROS_INFO(\"Local map merge odom\");\n    local_map_merge_odom(local_point, odom);\n  }\n  else{\n    //ROS_INFO(\"Local map merge\");\n    local_map_merge(local_point);\n  }\n}", "CodeBleu_score": 36.93113011507377}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t  // 1. project laser scan into PointCloud2 format\n  sensor_msgs::PointCloud2 local_point_cloud;\n  projector_.projectLaser(*local_point, local_point_cloud);\n\n  // 2. convert PointCloud2 to pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ> local_pcl_cloud;\n  pcl::fromROSMsg(local_point_cloud, local_pcl_cloud);\n\n  // 3. if not in simulation mode, merge the local map with the provided odometry data\n  if (!simulation_mode_) {\n    local_map_merge_odom(local_pcl_cloud, odom);\n  }\n\n  // 4. update the occupancy map with the local map\n  occupancy_map_update(local_pcl_cloud);\n}", "CodeBleu_score": 50.29470751248874}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  // convert the global point cloud map to a ROS message and publish it with the frame ID \"world\" to the global_pcl_pub topic\n  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(global_pcl_map, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // convert and publish the inflated point cloud to the inflate_pcl_pub topic with the same frame ID\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(inflate_pcl_map, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 58.442385566379414}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  // Publish the global point cloud map\n  global_pcl_pub.publish(pcl::toROSMsg(global_pcl_map));\n\n  // Publish the inflated point cloud\n  inflate_pcl_pub.publish(pcl::toROSMsg(inflate_pcl_map));\n}", "CodeBleu_score": 16.47785451484232}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Publish global point cloud map\n    global_pcl_pub.publish(pcl::toROSMsg(global_pcl_map));\n\n    // Publish inflated point cloud\n    inflate_pcl_pub.publish(pcl::toROSMsg(inflate_pcl_map));\n}", "CodeBleu_score": 16.63454470727954}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n\n    if (sensor_ready == false) {\n        if (odom_ready == true) {\n            sensor_ready = true;\n        }\n    }\n\n    if (sensor_ready == true) {\n        //ROS_INFO(\"sensor_ready\");\n        //ROS_INFO(\"sensor_ready\");\n        //ROS_INFO(\"sensor_ready\");\n        //ROS_INFO(\"sensor_ready\");\n        //ROS_INFO(\"sensor_ready\");\n\n        if (odom_ready == true) {\n            //ROS_INFO(\"odom_ready\");\n            //ROS_INFO(\"odom_ready\");\n            //ROS_INFO(\"odom_ready\");\n            //ROS_INFO(\"odom_ready\");\n            //ROS_INFO(\"odom_ready\");\n\n            Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n        }\n    }\n}", "CodeBleu_score": 55.78976997340288}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\tif(odometry_ready == false) {\n\t\tROS_INFO(\"Lpointcloud_cb: odometry not ready, returning\");\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: odometry ready, updating map\");\n\t// update the map\n\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: map updated, returning\");\n\treturn;\n}", "CodeBleu_score": 58.194646428616146}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  // If odometry is ready, set the sensor_ready flag to true\n  if (odom_ready) {\n    sensor_ready = true;\n  }\n\n  // Update the A* algorithm's map using the new point cloud data and current UAV odometry\n  Occupy_map_ptr->map_update_lpcl(msg);\n}", "CodeBleu_score": 46.66534030536219}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Get the current time\n  ros::Time now = ros::Time::now();\n\n  // Check if the robot is in a safe position\n  if (!isRobotSafe_) {\n    // If not, publish the last known joint positions and zero foot contact information\n    publishJoints_(now);\n    publishFootContacts_(now);\n\n    // And return\n    return;\n  }\n\n  // Get the current time in seconds\n  double time_in_seconds = now.toSec();\n\n  // Get the current base position and orientation\n  Eigen::Vector3d base_position = robot_state_.getBasePosition();\n  Eigen::Quaterniond base_orientation = robot_state_.getBaseOrientation();\n\n  // Get the current base linear and angular velocity\n  Eigen::Vector3d base_linear_velocity = robot_state_.getBaseLinearVelocity();\n  Eigen::Vector3d base_angular_velocity = robot_state_.getBaseAngularVelocity();\n\n  // Get the current joint positions\n  Eigen::VectorXd joint_positions = robot_state_.getJointPositions();\n\n  // Get the current joint velocities\n  Eigen::VectorXd joint_velocities = robot_state_.getJointVelocities();\n\n  // Get the current joint torques\n  Eigen::VectorXd joint_torques = robot_state_.getJointTorques();\n\n  // Get the current IMU orientation\n  Eigen::Quaterniond imu_orientation = robot_state_.getImuOrientation();\n\n  // Get the current IMU angular velocity\n  Eigen::Vector3d imu_angular_velocity = robot_state_.getImuAngularVelocity();\n\n  // Get the current IMU linear acceleration\n  Eigen::Vector3d imu_linear_acceleration = robot_state_.getImuLinearAcceleration();\n\n  // Get the current contact information\n  Eigen::VectorXd foot_contacts = robot_state_.getFootContacts();\n\n  // Get the current foot positions\n  Eigen::VectorXd foot_positions = robot_state_.getFootPositions();\n\n", "CodeBleu_score": 38.40191618272241}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Calculate target foot positions\n  // ---------------------------------------------------------------------------\n  // Calculate the desired foot positions for the next timestep.\n  // The body controller uses the desired foot positions to calculate the desired foot velocities.\n  // The foot positions are calculated based on the desired pose and the current pose.\n  // The desired foot positions are computed in the body frame.\n  // The desired foot positions are published in the world frame.\n  // The desired foot positions are used by the leg controller to compute the desired joint positions.\n  // The desired foot positions are also used to compute the desired foot contact forces.\n  // The desired foot positions are also used to compute the desired foot contact states.\n  // The desired foot positions are also used to compute the desired foot contact velocities.\n  // The desired foot positions are also used to compute the desired foot contact accelerations.\n  body_controller_.poseCommand(\n      desired_pose_,\n      current_pose_,\n      current_twist_,\n      current_foot_positions_,\n      current_foot_velocities_,\n      current_foot_contacts_,\n      desired_foot_positions_,\n      desired_foot_velocities_,\n      desired_foot_contacts_,\n      desired_foot_contact_states_,\n      desired_foot_contact_velocities_,\n      desired_foot_contact_accelerations_);\n\n  // Compute leg joint positions\n  // ---------------------------------------------------------------------------\n  // Compute the desired joint positions for the next timestep.\n  // The leg controller uses the desired foot positions to compute the desired joint positions.\n  // The desired joint positions are computed in the leg frame.\n  // The desired joint positions are published in the world frame.\n  // The desired joint positions are used by the leg controller to compute the desired joint velocities.\n  // The desired joint positions are used by the leg controller to compute the desired joint accelerations.\n  // The desired joint positions are used by the leg controller to compute the desired joint torques.\n  leg_controller_.poseCommand(\n      desired_foot_positions_,\n      current_foot_positions_,\n      current_foot_velocities_,\n      current_foot_contacts_,\n      current_joint_positions_,\n      current", "CodeBleu_score": 34.48581174503189}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Get current time\n  ros::Time now = ros::Time::now();\n\n  // Get current state\n  StateEstimator::State state = state_estimator_.getResult();\n  state.header.stamp = now;\n\n  // Get the desired pose\n  QuadrupedPoseCommand::SharedPtr pose_command = ros::topic::waitForMessage<QuadrupedPoseCommand>(*quadruped_pose_command_topic_, ros::Duration(1.0));\n  if (pose_command) {\n    // Get the desired pose\n    QuadrupedPoseCommand::SharedPtr desired_pose = ros::topic::waitForMessage<QuadrupedPoseCommand>(*quadruped_pose_command_topic_, ros::Duration(1.0));\n    if (desired_pose) {\n      // Compute the desired foot positions\n      body_controller_.poseCommand(*desired_pose, state);\n\n      // Compute the desired joint positions\n      Kinematics::Result inverse_kinematics = kinematics_.inverse(body_controller_.getResult());\n\n      // Publish the joint positions\n      Joints joints;\n      joints.header.stamp = now;\n      joints.position = inverse_kinematics.joints;\n      joints.velocity.resize(joints.position.size(), 0.0);\n      joints_publisher_.publish(joints);\n\n      // Publish the foot contacts\n      FootContacts foot_contacts;\n      foot_contacts.header.stamp = now;\n      foot_contacts.contact = inverse_kinematics.contacts;\n      foot_contacts_publisher_.publish(foot_contacts);\n    }\n  }\n}", "CodeBleu_score": 39.969058250368924}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    if (!in_gazebo_) {\n      // Create a new message\n      quadruped_msgs::ContactsStamped contacts_msg;\n\n      // Populate the message with the current gait phase of each leg\n      for (int i = 0; i < 4; i++) {\n        contacts_msg.contacts[i].leg_id = i;\n        contacts_msg.contacts[i].gait_phase = base_.legs[i]->gait_phase;\n        contacts_msg.contacts[i].contact = foot_contacts[i];\n      }\n\n      // Publish the message\n      foot_contacts_publisher_.publish(contacts_msg);\n    }\n  }\n}", "CodeBleu_score": 51.44250638750728}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    if (robot_->isGazebo()) {\n      // If the robot is in Gazebo, then we publish the foot contacts using the Gazebo topic.\n      publishFootContactsGazebo_(foot_contacts);\n    } else {\n      // Otherwise, we publish the foot contacts using the ROS topic.\n      publishFootContactsROS_(foot_contacts);\n    }\n  }\n}", "CodeBleu_score": 21.28961959431218}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    if (!use_gazebo_) {\n      std::string gait_phase_string[4] = {\n          \"standing\", \"trot\", \"pronking\", \"gallop\"};\n      contacts_msg.header.stamp = ros::Time::now();\n      contacts_msg.contacts.resize(4);\n      for (int i = 0; i < 4; ++i) {\n        contacts_msg.contacts[i].name =\n            base_.legs[i]->name + \"_\" + gait_phase_string[gait_phase_];\n        contacts_msg.contacts[i].contact = foot_contacts[i];\n      }\n      foot_contacts_publisher_.publish(contacts_msg);\n    }\n  }\n}", "CodeBleu_score": 52.91001449708169}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\n    # Create a JointState message to publish.\n    joints_msg = JointState()\n\n    # Set the joint positions and velocities.\n    joints_msg.position = joints.position[0:12]\n    joints_msg.velocity = joints.velocity[0:12]\n\n    # Publish the joint positions.\n    self.pub_joints.publish(joints_msg)\n\n    # Create a JointTrajectory message.\n    joint_trajectory = JointTrajectory()\n\n    # Set the joint names, positions, and duration.\n    joint_trajectory.joint_names = self.joint_names[0:12]\n    joint_trajectory.points.append(JointTrajectoryPoint(\n        positions=joints.position[0:12],\n        velocities=joints.velocity[0:12],\n        time_from_start=rospy.Duration(1.0)))\n\n    # Publish the joint trajectory.\n    self.pub_joint_trajectory.publish(joint_trajectory)\n}", "CodeBleu_score": 37.220072414059594}, {"code": "def joints_cmd_callback(self, joints){\n\t  # Create a Joints message with the first 12 joint positions\n  joints_msg = Joints()\n  joints_msg.header.stamp = rospy.Time.now()\n  joints_msg.header.frame_id = 'base_link'\n  joints_msg.name = self.joint_names[0:12]\n  joints_msg.position = joints.position[0:12]\n  # Publish the Joints message\n  self.joints_pub.publish(joints_msg)\n  # Create a JointTrajectory message with the same positions and a specified duration\n  joint_traj_msg = JointTrajectory()\n  joint_traj_msg.header.stamp = rospy.Time.now()\n  joint_traj_msg.header.frame_id = 'base_link'\n  joint_traj_msg.joint_names = self.joint_names[0:12]\n  joint_traj_point = JointTrajectoryPoint()\n  joint_traj_point.positions = joints.position[0:12]\n  joint_traj_point.time_from_start = rospy.Duration(1.0)\n  joint_traj_msg.points.append(joint_traj_point)\n  # Publish the JointTrajectory message\n  self.joint_traj_pub.publish(joint_traj_msg)\n}", "CodeBleu_score": 43.49745818191209}, {"code": "def joints_cmd_callback(self, joints){\n\t\n    # Create a minimal joints message with the first 12 joint positions\n    joints_msg = JointState()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.name = self.joint_names[0:12]\n    joints_msg.position = joints.position[0:12]\n\n    # Publish the joints message to the joints topic\n    self.joints_pub.publish(joints_msg)\n\n    # Create a joint trajectory message with the same positions and a specified duration\n    joint_traj = JointTrajectory()\n    joint_traj.header.stamp = rospy.Time.now()\n    joint_traj.joint_names = self.joint_names[0:12]\n    joint_traj.points = [JointTrajectoryPoint(positions=joints.position[0:12], velocities=[0]*12, time_from_start=rospy.Duration(1.0))]\n\n    # Publish the joint trajectory message to the joint trajectory topic\n    self.joint_traj_pub.publish(joint_traj)\n\n}", "CodeBleu_score": 42.98972264445721}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::vector<std::string> collisions = boost::split(_msg->contact(i).collision1, \"::\");\n    if (collisions.size() != 3) {\n      std::cout << \"Error: Unexpected number of collisions in \" << _msg->contact(i).collision1 << std::endl;\n      continue;\n    }\n    if (collisions[2] == \"l_foot_contact\") {\n      left_foot_contact_ = true;\n    } else if (collisions[2] == \"r_foot_contact\") {\n      right_foot_contact_ = true;\n    }\n  }\n}", "CodeBleu_score": 38.20379435712896}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  // Initialize all foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    foot_contact_[i] = false;\n  }\n\n  // For each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Split the collision string to identify the contact link\n    std::vector<std::string> split_str;\n    boost::split(split_str, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n\n    // If a contact matches one of the foot links\n    if (split_str.back() == \"l_foot\" || split_str.back() == \"r_foot\") {\n      // Set the corresponding foot contact state to true\n      if (split_str.back() == \"l_foot\") {\n        foot_contact_[0] = true;\n      } else if (split_str.back() == \"r_foot\") {\n        foot_contact_[1] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 54.016029421752755}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::vector<std::string> split_collision1;\n    boost::split(split_collision1, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n    std::vector<std::string> split_collision2;\n    boost::split(split_collision2, _msg->contact(i).collision2(), boost::is_any_of(\"::\"));\n    if (split_collision1[1] == \"l_foot_contact\" || split_collision2[1] == \"l_foot_contact\") {\n      l_foot_contact_ = true;\n    } else if (split_collision1[1] == \"r_foot_contact\" || split_collision2[1] == \"r_foot_contact\") {\n      r_foot_contact_ = true;\n    }\n  }\n}", "CodeBleu_score": 42.28411309104387}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  // Check input.\n  assert(rotor_velocities != nullptr);\n  // Check parameters.\n  assert(vehicle_parameters_.rotor_configuration_.rotors.size() ==\n         vehicle_parameters_.rotor_configuration_.rotor_count);\n  // Check if controller is active.\n  if (!is_active_) {\n    // Set all rotor velocities to zero.\n    *rotor_velocities = Eigen::VectorXd::Zero(\n        vehicle_parameters_.rotor_configuration_.rotor_count);\n  } else {\n    // Calculate desired acceleration.\n    const Eigen::Vector3d desired_acceleration =\n        ComputeDesiredAcceleration();\n    // Calculate desired angular acceleration.\n    const Eigen::Vector3d desired_angular_acceleration =\n        ComputeDesiredAngularAcc();\n    // Project thrust onto the body z-axis.\n    const double thrust = desired_acceleration.z();\n    // Combine angular acceleration and thrust into a single vector.\n    const Eigen::Vector3d desired_acceleration_thrust =\n        desired_angular_acceleration.cross(\n            odometry_.orientation.toRotationMatrix().col(2)) +\n        Eigen::Vector3d(0.0, 0.0, thrust);\n    // Compute rotor velocities.\n    *rotor_velocities =\n        Eigen::VectorXd::Zero(vehicle_parameters_.rotor_configuration_.rotor_count);\n    for (int i = 0; i < vehicle_parameters_.rotor_configuration_.rotor_count;\n         ++i) {\n      // Compute rotor velocity.\n      const double rotor_velocity =\n          desired_acceleration_thrust.dot(\n              vehicle_parameters_.rotor_configuration_.rotors[i].direction) /\n          vehicle_parameters_.rotor_configuration_.rotors[i].speed;\n      // Ensure non-negative rotor velocity.\n      (*rotor_velocities)(i) =\n          std::max(rotor_velocity,\n                   vehicle_parameters_.rotor_configuration_.rot", "CodeBleu_score": 42.80521773948554}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n  assert(rotor_velocities->size() ==\n         vehicle_parameters_.rotor_configuration_.rotors.size());\n\n  // If the controller is not active, set all rotor velocities to zero.\n  if (!IsActive()) {\n    *rotor_velocities = Eigen::VectorXd::Zero(\n        vehicle_parameters_.rotor_configuration_.rotors.size());\n    return;\n  }\n\n  // Compute the desired acceleration and angular acceleration.\n  const Eigen::Vector3d desired_acceleration =\n      ComputeDesiredAcceleration();\n  const Eigen::Vector3d desired_angular_acceleration =\n      ComputeDesiredAngularAcc();\n\n  // Project thrust onto the body z-axis.\n  const Eigen::Vector3d thrust =\n      desired_acceleration + desired_angular_acceleration.cross(\n          odometry_.position);\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::VectorXd angular_acceleration_thrust(4);\n  angular_acceleration_thrust.block<3, 1>(1, 0) = desired_angular_acceleration;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = thrust;\n\n  // Compute the rotor velocities.\n  *rotor_velocities =\n      vehicle_parameters_.rotor_configuration_.rotor_velocity_to_thrust_map\n          .transpose() *\n      angular_acceleration_thrust;\n\n  // Ensure non-negative values.\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(\n      vehicle_parameters_.rotor_configuration_.rotors.size()));\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 58.68799428800844}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  // Check if the controller is active.\n  if (!IsActive()) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Check if the input is valid.\n  assert(rotor_velocities != nullptr);\n  assert(rotor_velocities->size() ==\n         vehicle_parameters_.rotor_configuration_.rotors.size());\n\n  // Compute the desired acceleration and angular acceleration.\n  const Eigen::Vector3d desired_acceleration =\n      ComputeDesiredAcceleration(odometry_.position, odometry_.orientation,\n                                 desired_position_, desired_velocity_);\n  const Eigen::Vector3d desired_angular_acceleration =\n      ComputeDesiredAngularAcc(odometry_.orientation.toRotationMatrix().col(2),\n                               odometry_.orientation.toRotationMatrix().col(1),\n                               desired_angular_rate_);\n\n  // Project the thrust onto the body z-axis.\n  const double thrust = desired_acceleration.z();\n\n  // Combine the angular acceleration and thrust.\n  Eigen::Vector3d desired_acceleration_thrust;\n  desired_acceleration_thrust.block<3, 1>(0, 0) = desired_acceleration;\n  desired_acceleration_thrust.dot(\n      odometry_.orientation.toRotationMatrix().col(2)) = thrust;\n\n  // Compute the rotor velocities.\n  *rotor_velocities =\n      desired_acceleration_thrust.cwiseProduct(\n          rotor_velocity_gain_.asDiagonal())\n          .cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()))\n          .cwiseProduct(rotor_velocities->cwiseSqrt());\n}", "CodeBleu_score": 48.64069738289929}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // 1. Calculate the position error\n  Eigen::Vector3d position_error = odometry_.position - command_trajectory_.position;\n\n  // 2. Calculate the velocity error\n  Eigen::Vector3d velocity_error = odometry_.velocity - command_trajectory_.velocity;\n\n  // 3. Transform the velocity error to the world frame\n  Eigen::Matrix3d rotation_matrix = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_error_world = rotation_matrix * velocity_error;\n\n  // 4. Calculate the desired acceleration\n  *acceleration = position_error * position_gain_ + velocity_error_world * velocity_gain_ +\n                 Eigen::Vector3d(0, 0, 9.81) - odometry_.acceleration;\n}", "CodeBleu_score": 44.242439003216305}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\n  // Get the current odometry data\n  const auto& odometry_ = *odometry_;\n\n  // Get the current command trajectory data\n  const auto& command_trajectory_ = *command_trajectory_;\n\n  // Get the current vehicle state data\n  const auto& vehicle_state_ = *vehicle_state_;\n\n  // Get the current vehicle parameters\n  const auto& vehicle_parameters_ = *vehicle_parameters_;\n\n  // Get the current vehicle control data\n  const auto& vehicle_control_ = *vehicle_control_;\n\n  // Get the current vehicle command data\n  const auto& vehicle_command_ = *vehicle_command_;\n\n  // Get the current vehicle control command data\n  const auto& vehicle_control_command_ = *vehicle_control_command_;\n\n  // Get the current vehicle state command data\n  const auto& vehicle_state_command_ = *vehicle_state_command_;\n\n  // Get the current vehicle control mode data\n  const auto& vehicle_control_mode_ = *vehicle_control_mode_;\n\n  // Get the current vehicle state command data\n  const auto& vehicle_state_command_ = *vehicle_state_command_;\n\n  // Get the current vehicle control command data\n  const auto& vehicle_control_command_ = *vehicle_control_command_;\n\n  // Get the current vehicle state data\n  const auto& vehicle_state_ = *vehicle_state_;\n\n  // Get the current vehicle parameters\n  const auto& vehicle_parameters_ = *vehicle_parameters_;\n\n  // Get the current vehicle control data\n  const auto& vehicle_control_ = *vehicle_control_;\n\n  // Get the current vehicle command data\n  const auto& vehicle_command_ = *vehicle_command_;\n\n  // Get the current vehicle control command data\n  const auto& vehicle_control_command_ = *vehicle_control_command_;\n\n  // Get the current vehicle state command data\n  const auto& vehicle_state_command_ = *vehicle_state_command_;\n\n  // Get the current vehicle control mode data\n  const auto& vehicle_control_mode_", "CodeBleu_score": 32.58481583841332}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  Eigen::Vector3d desired_acceleration;\n\n  // Calculate the position error.\n  position_error = odometry_.position - command_trajectory_.position;\n\n  // Calculate the velocity error.\n  velocity_error = odometry_.velocity - command_trajectory_.velocity;\n\n  // Transform the velocity error from the body frame to the world frame.\n  velocity_error = odometry_.orientation.toRotationMatrix() * velocity_error;\n\n  // Calculate the desired acceleration.\n  desired_acceleration = (position_error.cwiseProduct(position_gains_) + velocity_error.cwiseProduct(velocity_gains_)) / mass_;\n  desired_acceleration[2] = desired_acceleration[2] - gravity_;\n\n  // Adjust the desired acceleration for the commanded acceleration.\n  desired_acceleration[0] = desired_acceleration[0] + command_trajectory_.acceleration[0];\n  desired_acceleration[1] = desired_acceleration[1] + command_trajectory_.acceleration[1];\n  desired_acceleration[2] = desired_acceleration[2] + command_trajectory_.acceleration[2];\n\n  // Set the desired acceleration.\n  *acceleration = desired_acceleration;\n}", "CodeBleu_score": 46.920765716227756}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t    // Ensure input is valid.\n    assert(rotor_velocities != nullptr);\n    // Ensure parameters are valid.\n    assert(control_attitude_thrust_reference_ != nullptr);\n    assert(angular_acceleration_thrust_ != nullptr);\n    // Resize the rotor velocities vector.\n    rotor_velocities->resize(control_attitude_thrust_reference_->rows());\n    // Compute the desired angular acceleration.\n    Eigen::VectorXd desired_angular_acceleration = angular_acceleration_thrust_->block<3, 1>(0, 0) +\n        control_attitude_thrust_reference_->block<3, 1>(0, 0);\n    // Combine the desired angular acceleration and thrust reference into a single vector.\n    Eigen::VectorXd desired_angular_acceleration_thrust_reference =\n        Eigen::VectorXd::Ones(desired_angular_acceleration.rows());\n    desired_angular_acceleration_thrust_reference << desired_angular_acceleration,\n        control_attitude_thrust_reference_->block<1, 1>(3, 0);\n    // Compute the rotor velocities.\n    *rotor_velocities = desired_angular_acceleration_thrust_reference.cwiseMax(Eigen::VectorXd::Ones(\n        desired_angular_acceleration_thrust_reference.rows())) * rotor_velocities_matrix_.cwiseSqrt();\n    // Ensure rotor velocities are at least one.\n    rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()));\n}", "CodeBleu_score": 44.738162791471446}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(control_attitude_thrust_reference_.size() == 4);\n  assert(control_attitude_thrust_reference_.minCoeff() >= 0.0);\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(kNumMotors);\n\n  // Compute the desired angular acceleration.\n  Eigen::VectorXd angular_acceleration_thrust =\n      ComputeDesiredAngularAcc(control_attitude_thrust_reference_);\n\n  // Combine the desired angular acceleration with the thrust reference.\n  Eigen::VectorXd angular_acceleration_thrust_reference =\n      Eigen::VectorXd::Ones(kNumMotors) * angular_acceleration_thrust.transpose() +\n      control_attitude_thrust_reference_;\n\n  // Compute the rotor velocities.\n  (*rotor_velocities) = kRotorVelocityGain * angular_acceleration_thrust_reference;\n\n  // Ensure the rotor velocities are at least one.\n  (*rotor_velocities) = (*rotor_velocities).cwiseMax(1.0);\n\n  // Take the square root of each component.\n  (*rotor_velocities) = (*rotor_velocities).cwiseSqrt();\n}", "CodeBleu_score": 49.067553684384904}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n  // Ensure the input is valid\n  assert(rotor_velocities != nullptr);\n\n  // Ensure the parameters are valid\n  assert(params_ != nullptr);\n\n  // Resize the rotor velocities vector to match the number of rotors\n  rotor_velocities->resize(params_->num_rotors);\n\n  // Calculate the desired angular acceleration\n  Eigen::Vector3d angular_acceleration_thrust;\n  ComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n  // Combine the desired angular acceleration and thrust reference into a single vector\n  Eigen::VectorXd control_attitude_thrust_reference(params_->num_rotors);\n  control_attitude_thrust_reference.block<3, 1>(0, 0) = angular_acceleration_thrust;\n  control_attitude_thrust_reference.block<1, 1>(3, 0) = params_->thrust_reference;\n\n  // Compute the rotor velocities\n  (*rotor_velocities) = control_attitude_thrust_reference.cwiseSqrt();\n\n  // Ensure that the rotor velocities are at least one\n  (*rotor_velocities).cwiseMax(Eigen::VectorXd::Ones(params_->num_rotors));\n}", "CodeBleu_score": 49.62775333059681}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # find the indices corresponding to the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n\n    # make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n\n    # update each attribute to contain only the sliced data\n    for attribute in self.__dict__:\n        # get the attribute from the copied object\n        copied_attribute = getattr(copied_obj, attribute)\n\n        # update the attribute to contain only the sliced data\n        copied_attribute[start_index:end_index] = self.__dict__[attribute][start_index:end_index]\n\n    # return the copied and sliced object\n    return copied_obj\n\n", "CodeBleu_score": 41.88204205693684}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the start and end indices\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # Make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n    # Update each attribute of the copied object to contain only the sliced data\n    for attribute in copied_obj.__getattribute__(\"_attributes\"):\n        copied_obj.__setattr__(attribute, self.__getattribute__(attribute)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 58.24242547254419}, {"code": "def slice(self, start_time, end_time)\n\t\n    # find the start and end indices\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n\n    # make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n\n    # update each attribute of the copied object to contain only the sliced data\n    for attribute in self.__dict__.keys():\n        if attribute != 'time':\n            copied_obj.__setattr__(attribute, self.__getattribute__(attribute)[start_index:end_index])\n\n    # return the copied and sliced object\n    return copied_obj\n\n", "CodeBleu_score": 58.209362021238675}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    orientation = waypoint_msg.pose.pose.orientation\n    # Convert the rotation to Euler angles\n    euler = euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n    # Create a Point object\n    point = Point(position.x, position.y, position.z, euler[2])\n    # Check if the current waypoint is different from the last one\n    if (self.last_point is None) or (self.last_point.position != point.position) or (self.last_point.yaw != point.yaw):\n        # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(point.yaw)\n        self.append_times(msg_time, bag_time)\n        self.last_point = point\n\n", "CodeBleu_score": 25.083125636349912}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    euler = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create Point object\n    point = Point(position.x, position.y, position.z, euler[2])\n\n    # Check if the current waypoint is different from the last one\n    if self.waypoint_list[-1] != point:\n        # Append new point, yaw, and corresponding times to their respective arrays\n        self.waypoint_list.append(point)\n        self.yaw_list.append(euler[2])\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 20.553292232914348}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Get position and rotation from waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    euler = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create Point object\n    point = Point(position.x, position.y, position.z, euler[2])\n    # Check if the current waypoint is different from the last one by comparing position and yaw values\n    if (not self.waypoints) or (self.waypoints[-1].position != point.position) or (self.waypoints[-1].yaw != point.yaw):\n        # Append new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point, msg_time, bag_time)\n        self.append_yaw(point.yaw, msg_time, bag_time)\n\n", "CodeBleu_score": 22.533827478952837}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    # Convert the message timestamp to seconds\n    msg_time = msg.header.stamp.to_sec()\n    # Append the linear acceleration data to the corresponding x, y, and z attributes\n    if topic == \"/imu/data_raw\":\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.time_acceleration.append(msg_time)\n        self.time_bag.append(bag_time)\n    elif topic == \"/imu/data_raw_mag\":\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.time_acceleration.append(msg_time)\n        self.time_bag.append(bag_time)\n    elif topic == \"/imu/data_raw_temp\":\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.time_acceleration.append(msg_time)\n        self.time_bag.append(bag_time)\n\n", "CodeBleu_score": 26.98040314085151}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    # convert the message timestamp to seconds\n    msg_time = to_sec(msg.header.stamp)\n    # for each IMU topic, if the topic matches, it appends the linear acceleration data to the corresponding x, y, and z attributes\n    if topic == self.imu_topic_list[0]:\n        self.imu_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acceleration_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(msg_time)\n        self.imu_bag_time.append(bag_time)\n    elif topic == self.imu_topic_list[1]:\n        self.imu_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acceleration_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(msg_time)\n        self.imu_bag_time.append(bag_time)\n    elif topic == self.imu_topic_list[2]:\n        self.imu_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acceleration_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(msg_time)\n        self.imu_bag_time.append(bag_time)\n\n", "CodeBleu_score": 18.639307214226193}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    # convert the message timestamp to seconds\n    msg_time = msg.header.stamp.to_sec()\n    # append the message time and bag time to the time attributes\n    self.time.append(msg_time)\n    self.bag_time.append(bag_time)\n    # append the linear acceleration data to the corresponding x, y, and z attributes\n    if topic == \"/imu/imu_linear_acceleration\":\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 32.36113996417383}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create figure and subplot\n    fig = pyplot.figure()\n    ax = fig.add_subplot(111)\n    fig.suptitle(\"Accelerations\")\n    # Plot x, y, and z acceleration data\n    for i, accel in enumerate(self.accelerations):\n        ax.plot(accel.x, label=\"x\" + str(i), color=\"red\")\n        ax.plot(accel.y, label=\"y\" + str(i), color=\"green\")\n        ax.plot(accel.z, label=\"z\" + str(i), color=\"blue\")\n    # Add labels for x and y axes and a legend\n    pyplot.ylabel(\"Acceleration (m/s^2)\")\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.legend()\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix\n    # and save the plot as a PNG file\n    if self.save_plots:\n        filename = \"accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 37.515493178273445}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n\n    # Create a figure with a title and a subplot for accelerations.\n    fig = pyplot.figure()\n    fig.suptitle(self.name)\n    ax = fig.add_subplot(111)\n\n    # Plot the x, y, and z components over time with different colors and labels.\n    for i, accel in enumerate(self.accelerations):\n        ax.plot(accel.time, accel.x, label='x' + str(i), color=accel.color)\n        ax.plot(accel.time, accel.y, label='y' + str(i), color=accel.color)\n        ax.plot(accel.time, accel.z, label='z' + str(i), color=accel.color)\n\n    # Add labels for the x and y axes and include a legend.\n    pyplot.ylabel('acceleration (m/s^2)')\n    pyplot.xlabel('time (s)')\n    pyplot.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file.\n    if self.save_plots:\n        if plot_suffix is None:\n            pyplot.savefig(self.plot_dir + self.name + '_accelerations.png')\n        else:\n            pyplot.savefig(self.plot_dir + self.name + '_accelerations_' + plot_suffix + '.png')\n\n", "CodeBleu_score": 39.517252164989245}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure and a subplot for accelerometer data\n    fig = pyplot.figure()\n    ax = fig.add_subplot(111)\n    fig.suptitle(\"Accelerometer Data\")\n\n    # Plot the x, y, and z components of each acceleration dataset\n    for i, accel in enumerate(self.accelerations):\n        ax.plot(accel.x, label=\"acceleration x \" + str(i), color=colors[i])\n        ax.plot(accel.y, label=\"acceleration y \" + str(i), color=colors[i])\n        ax.plot(accel.z, label=\"acceleration z \" + str(i), color=colors[i])\n\n    # Add labels for the x and y axes\n    pyplot.ylabel(\"Acceleration (g)\")\n    pyplot.xlabel(\"Time (s)\")\n\n    # Add a legend\n    pyplot.legend()\n\n    # If saving plots is enabled, construct a filename and save the plot as a PNG\n    if self.save_plots:\n        filename = self.plot_filename_prefix + \"accelerations\"\n        if plot_suffix is not None:\n            filename += plot_suffix\n        filename += \".png\"\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 39.21148782354892}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n\n    # Check if at least two pose indices were provided\n    if len(pose_indeces) < 2:\n        print(\"Error: Please provide at least two pose indices\")\n        return\n\n    # Loop through the pose indeces\n    for i in range(0, len(pose_indeces)):\n        # Compare the current pose index to all subsequent pose indices\n        for j in range(i + 1, len(pose_indeces)):\n            # Compare the two pose indeces\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 42.316120213387364}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # check if the number of pose indices is greater than 1\n    if len(pose_indeces) > 1:\n        # initialize an empty list to store the results of the comparisons\n        results = []\n        # iterate through the pose indices\n        for i in range(len(pose_indeces)):\n            # compare the current pose index with all subsequent pose indices\n            results.append(self.compare_two_xyz(pose_indeces[i], pose_indeces[i + 1:]))\n        # return the results\n        return results\n    else:\n        # if the number of pose indices is not greater than 1, return an error message\n        return \"Error: You need to provide at least two pose indices to compare the positions of multiple poses.\"\n\n", "CodeBleu_score": 38.4036869396284}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) > 1:\n        for index in enumerate(pose_indeces):\n            for index2 in enumerate(pose_indeces):\n                if index2[0] > index[0]:\n                    compare_two_xyz(self, index[1], index2[1])\n    else:\n        print(\"Please provide at least two pose indices to compare positions.\")\n", "CodeBleu_score": 30.698822605291614}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time is None or time >= start_time:\n            if end_time is None or time <= end_time:\n                collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 38.766509270398835}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    if start_time is None:\n        start_time = self.wrench[0][0]\n    if end_time is None:\n        end_time = self.wrench[-1][0]\n    for collision in self.wrench:\n        if collision[0] >= start_time and collision[0] <= end_time:\n            collision_times.append(collision[0])\n    return collision_times\n\n", "CodeBleu_score": 36.55953026226432}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time < time < end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 31.877336744088474}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(\n        start_time, end_time, absolute_settling_time, x_range, plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 38.20206225847643}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(\n        start_time, end_time, absolute_settling_time, x_range, plot_suffix,\n        y_range=(-1.5, 1.5))\n\n", "CodeBleu_score": 35.758886498665134}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = start_time + rospy.Duration(settling_time)\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, y_range=(-1.5, 1.5))\n\n", "CodeBleu_score": 30.326253195825515}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n  // Calculate the multiplier for the depth data\n  float multiplier = 1.0f;\n  if (camera_info_.pixel_width > 0) {\n    multiplier = 1000.0f / camera_info_.pixel_width;\n  }\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  // Calculate the RMS noise\n  Eigen::VectorXf rms_noise = (data_vector_map * multiplier).array().square().matrix().sqrt();\n  // Add noise to the data\n  for (uint32_t i = 0; i < width * height; i++) {\n    // Check if the pixel value is in range\n    if (data[i] >= camera_info_.min_range && data[i] <= camera_info_.max_range) {\n      // Add noise to the pixel value\n      data[i] += rms_noise(i);\n    } else {\n      // Set the pixel value to a bad point value\n      data[i] = camera_info_.max_range + 1.0f;\n    }\n  }\n}", "CodeBleu_score": 52.79499723274396}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) return;\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  const float multiplier =\n      (1.0f / (256.0f * 1000.0f)) *\n      (1.0f / (1.0f - 0.001f * (1.0f / 0.006f)));\n  const Eigen::VectorXf noise_values =\n      (data_vector_map * 1000.0f).array().square() * multiplier;\n  const Eigen::VectorXf rms_noise =\n      noise_values.array().sqrt().matrix().asDiagonal();\n  const Eigen::VectorXf noise =\n      (data_vector_map * 1000.0f).array() +\n      rms_noise.array().tanh().array() * rms_noise.array();\n  for (int i = 0; i < width * height; i++) {\n    if (data_vector_map(i) > 0.0f && data_vector_map(i) < 1.0f) {\n      data[i] = noise(i) / 1000.0f;\n    } else {\n      data[i] = 0.0f;\n    }\n  }\n}", "CodeBleu_score": 59.94834880359852}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (!data) {\n    return;\n  }\n\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n  const float multiplier = 1000.0f / (float)this->depth_scale;\n  const Eigen::VectorXf data_vector_map_scaled = data_vector_map * multiplier;\n  const float rms_noise = this->rms_noise.array().square().sum() / this->rms_noise.size();\n  const float noise = sqrtf(rms_noise);\n\n  for (int i = 0; i < data_vector_map_scaled.size(); i++) {\n    if (InRange(data_vector_map_scaled(i), this->min_range, this->max_range)) {\n      data_vector_map(i) = data_vector_map(i) + noise * tanf(data_vector_map(i) / 1000.0f);\n    } else {\n      data_vector_map(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 53.119494157273216}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  ros::Time simulation_time = ros::Time(world_->SimTime().Double());\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = ros::Time(simulation_time.sec, simulation_time.nsec);\n\n  // Write the trajectory message to a bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 61.911996758381584}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  common::Time sim_time = world_->SimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = ros::Time(sim_time.sec, sim_time.nsec);\n\n  // Write the trajectory message to a bag file\n  writeBag(ros_time, waypoint_topic_, trajectory_msg);\n}", "CodeBleu_score": 63.07216364518655}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n  // Retrieve current simulation time\n  world_->GetSimTime(sim_time_);\n\n  // Convert Gazebo time to ROS time\n  ros::Time ros_time = ros::Time(sim_time_.sec, sim_time_.nsec);\n\n  // Write trajectory message to bag file\n  waypoint_bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time,\n                      *trajectory_msg);\n}", "CodeBleu_score": 60.545237914451135}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert Gazebo time to ROS time\n  ros::Time now_ros = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for motor velocities\n  actuator_msgs::ActuatorVelocities rot_velocities_msg;\n  rot_velocities_msg.header.stamp = now_ros;\n\n  // Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Get the motor joint\n    physics::JointPtr joint = m->second;\n\n    // Get the velocity of the motor joint\n    double rot_velocity = joint->GetVelocity(0);\n\n    // Calculate the slowed-down rotational velocity\n    rot_velocity = rot_velocity * slowdown_factor_;\n\n    // Assign the slowed-down rotational velocity to the message\n    rot_velocities_msg.angular_velocities.resize(rot_velocities_msg.angular_velocities.size() + 1);\n    rot_velocities_msg.angular_velocities[rot_velocities_msg.angular_velocities.size() - 1] = rot_velocity;\n  }\n\n  // Write the data to a bag file using the specified namespace and motor topic\n  motor_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 56.74636064226725}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for motor velocities\n  actuator_msgs::ActuatorVelocities rot_velocities_msg;\n  rot_velocities_msg.header.stamp = ros_now;\n  rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\n  // Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    rot_velocities_msg.angular_velocities[m->first] = m->second->GetVelocity(0);\n  }\n\n  // Write the message to a bag file using the specified namespace and motor topic\n  motor_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 57.60940380289193}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert Gazebo time to ROS time\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for motor velocities\n  gazebo_msgs::Actuators rot_velocities_msg;\n  rot_velocities_msg.header.stamp = ros_now;\n  rot_velocities_msg.header.frame_id = \"base_link\";\n  rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\n  // Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message\n  for (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    rot_velocities_msg.angular_velocities[m->second->GetIndex()] = m->second->GetVelocity(0) / motor_velocity_slowdown_factor_;\n  }\n\n  // Write the data to a bag file using the specified namespace and motor topic\n  motor_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 62.33208318095672}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  // If debug printing is enabled, log that the callback was called.\n  if (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called\n\";\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  roll_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  pitch_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch());\n  yaw_rate_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message.\n  thrust_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 37.88031619038981}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called.\n\";\n  }\n\n  // Convert normalized inputs to control surface angles\n  roll_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  pitch_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch());\n  yaw_rate_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate());\n  thrust_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 37.913531948802195}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    std::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\"\n              << std::endl;\n  }\n\n  // Convert normalized roll, pitch, and yaw rate inputs to control surface\n  // angles for ailerons, elevator, and rudder respectively.\n  aileron_angle_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  elevator_angle_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch());\n  rudder_angle_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message.\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust().x;\n}", "CodeBleu_score": 41.113838726723756}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(this->uartFD, &fds);\n  int ret = select(this->uartFD + 1, &fds, NULL, NULL, &tv);\n  if (ret > 0) {\n    // Data available on the serial port\n    // Receive data\n    unsigned char buf[MAVLINK_MAX_PACKET_LEN];\n    int len = ::read(this->uartFD, buf, MAVLINK_MAX_PACKET_LEN);\n    if (len <= 0) {\n      gzerr << \"Error reading from serial port\n\";\n      return;\n    }\n    // Parse MAVLink messages from the buffer\n    for (int i = 0; i < len; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &this->mavlink_message,\n          &this->mavlink_status)) {\n        // Message parsed successfully\n        // Forward to serial port\n        if (this->forward_received_messages) {\n          ::write(this->uartFD, &buf[i], 1);\n        }\n        // Handle message\n        this->handleMessage(&this->mavlink_message);\n      }\n    }\n  }\n  else if (ret == 0) {\n    // Timeout\n    gzerr << \"MAVLink poll timeout\n\";\n  }\n  else {\n    // Error\n    gzerr << \"Error polling MAVLink port\n\";\n  }\n}", "CodeBleu_score": 55.53704095299254}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  int fds = 0;\n  fds = this->udpSocket->GetDescriptor();\n\n  int poll_ret = poll(&fds, 1, _timeoutMs);\n  if (poll_ret > 0) {\n    if (fds.revents & POLLIN) {\n      int len = 0;\n      len = this->udpSocket->RecvFrom(this->recvBuffer,\n                                      sizeof(this->recvBuffer),\n                                      this->remoteAddr);\n\n      if (len > 0) {\n        this->recvBuffer[len] = '\\0';\n        this->recvBufferLen = len;\n        this->recvBufferIndex = 0;\n        this->recvBufferPos = 0;\n        this->recvBufferStart = this->recvBuffer;\n        this->recvBufferEnd = this->recvBuffer + len;\n\n        this->parseChar(this->recvBufferStart[this->recvBufferPos]);\n        this->recvBufferPos++;\n      }\n    }\n  }\n}", "CodeBleu_score": 38.98613307629538}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // 1. Convert timeout to timeval\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // 2. Poll for data\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(this->uart, &fds);\n  int ret = select(this->uart+1, &fds, NULL, NULL, &tv);\n\n  if (ret < 0) {\n    gzerr << \"Error in select\n\";\n    return;\n  }\n\n  // 3. If data is available, receive it\n  if (ret > 0) {\n    // Receive data\n    char buf[1024];\n    int len = read(this->uart, buf, sizeof(buf));\n\n    if (len > 0) {\n      // Parse messages\n      for (int i = 0; i < len; ++i) {\n        mavlink_parse_char(MAVLINK_COMM_0, buf[i], &this->mavlink_message,\n            &this->mavlink_status);\n      }\n    }\n  }\n\n  // 4. Handle messages\n  handleMessages(_dt);\n}", "CodeBleu_score": 60.47290905023037}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t    std::lock_guard<std::mutex> lock(mutex_);\n    if (is_open_) {\n        io_service_.stop();\n        serial_dev_.close();\n        if (io_thread_.joinable())\n            io_thread_.join();\n        is_open_ = false;\n    }\n}", "CodeBleu_score": 68.84915248734352}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(mutex_);\n\tif (is_open()) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 67.2958273388848}, {"code": "void GazeboMavlinkInterface::close() {\n\t\n    boost::mutex::scoped_lock lock(mutex_);\n\n    if (!is_open())\n    {\n        ROS_WARN(\"Interface is not open, nothing to close\");\n        return;\n    }\n\n    io_service_.stop();\n    serial_dev_.close();\n\n    if (io_thread_.joinable())\n    {\n        io_thread_.join();\n    }\n\n}", "CodeBleu_score": 68.12437344980924}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d point1,\n  ignition::math::Vector3d point2,\n  ignition::math::Vector3d pos\n}", "CodeBleu_score": 13.26901169878406}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d p0,\n  ignition::math::Vector3d p1,\n  ignition::math::Vector3d v0,\n  ignition::math::Vector3d v1,\n  double t\n}", "CodeBleu_score": 15.452139139752564}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  const ignition::math::Vector3d &position,\n  const ignition::math::Vector3d &point1,\n  const ignition::math::Vector3d &point2,\n  const ignition::math::Vector3d &value1,\n  const ignition::math::Vector3d &value2\n}", "CodeBleu_score": 26.922264446503362}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\t/*BEGINNING OF TABLE SWITCH*/\n\tstatic const CELL_TYPE _catch_table[] = {\n\t\t/*0*/ _(0),\n\t\t/*1*/ _(1),\n\t\t/*2*/ _(2),\n\t\t/*3*/ _(3),\n\t\t/*4*/ _(4),\n\t\t/*5*/ _(5),\n\t\t/*6*/ _(6),\n\t\t/*7*/ _(7),\n\t\t/*8*/ _(8),\n\t\t/*9*/ _(9),\n\t\t/*10*/ _(10),\n\t\t/*11*/ _(11),\n\t\t/*12*/ _(12),\n\t\t/*13*/ _(13),\n\t\t/*14*/ _(14),\n\t\t/*15*/ _(15),\n\t\t/*16*/ _(16),\n\t\t/*17*/ _(17),\n\t\t/*18*/ _(18),\n\t\t/*19*/ _(19),\n\t\t/*20*/ _(20),\n\t\t/*21*/ _(21),\n\t\t/*22*/ _(22),\n\t\t/*23*/ _(23),\n\t\t/*24*/ _(24),\n\t\t/*25*/ _(25),\n\t\t/*26*/ _(26),\n\t\t/*27*/ _(27),\n\t\t/*28*/ _(28),\n\t\t/*29*/ _(29),\n\t\t/*30*/ _(30),\n\t\t/*31*/ _(31),\n\t\t/*32*/ _(32),\n\t\t/*33*/ _(33),\n\t\t/*34*/ _(34),\n\t\t/*35*/ _(35),\n\t\t/*36*/ _(36),\n\t\t/*37*/ _(37),\n\t\t/*38*/ _(38),\n\t\t/*39*/ _(39),\n\t\t/*40*/ _(40),\n\t\t/*41*/ _", "CodeBleu_score": 29.79718036928419}, {"code": "void Animation::SetTime(double _time){\n\t\tif (this->time == _time) {\n\t\treturn;\n\t}\n\tthis->time = _time;\n\tthis->UpdateTime();\n}", "CodeBleu_score": 35.35294850858615}, {"code": "void Animation::SetTime(double _time){\n\t\tif (this->time == _time) return;\n\tthis->time = _time;\n\tif (this->loop) {\n\t\twhile (this->time > this->length) this->time -= this->length;\n\t\twhile (this->time < 0) this->time += this->length;\n\t} else {\n\t\tif (this->time > this->length) this->time = this->length;\n\t\tif (this->time < 0) this->time = 0;\n\t}\n\tthis->UpdateTime();\n}", "CodeBleu_score": 60.36433060803286}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    # Set coordinate frame to local NED\n    self.set_frame_local_ned()\n    # Set motion type to \"forward\"\n    self.set_motion_type_forward()\n    # Construct target motion using current position and yaw\n    self.construct_target()\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle Type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight Mode:\", self.flight_mode)\n\n", "CodeBleu_score": 21.843759034482197}, {"code": "def hover(self)\n\t\n    self.construct_target()\n    self.target.coordinate_frame = 1\n    self.target.motion_type = 0\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 21.476462615476596}, {"code": "def hover(self)\n\t\n    # Set coordinate frame to local NED\n    self.set_frame_local_ned()\n\n    # Set motion to be position command\n    self.set_motion_position()\n\n    # Construct a target position\n    target = self.construct_target()\n\n    # Print out the vehicle type, ID, and flight mode\n    print(\"Vehicle Type: %s\" % self.get_vehicle_type())\n    print(\"Vehicle ID: %s\" % self.get_vehicle_id())\n    print(\"Flight Mode: %s\" % self.get_flight_mode())\n\n    # Move to the target\n    self.move_to_position(target)\n\n", "CodeBleu_score": 23.011237442362074}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService == None:\n        self.flightModeService = rospy.ServiceProxy('/mavros/set_mode', mavros_msgs.srv.SetMode)\n    if self.flightModeService.wait_for_service(1.0):\n        if self.flight_mode == 'HOVER':\n            self.hover = 1\n            self.hover_method()\n            return True\n        else:\n            try:\n                self.flightModeService(custom_mode=self.flight_mode)\n                self.flight_mode = self.flight_mode\n                self.hover = 0\n                print \"Flight mode changed to: \" + self.flight_mode\n                return True\n            except rospy.ServiceException, e:\n                print \"Service call failed: %s\"%e\n                return False\n    else:\n        print \"Flight mode service not available\"\n        return False\n\n", "CodeBleu_score": 34.98942146901099}, {"code": "def flight_mode_switch(self)\n\t\n    # Check if the vehicle is armed\n    if not self.armed:\n        print \"Vehicle is not armed! Please arm first\"\n        return False\n\n    # Check if vehicle is already in the desired mode\n    if self.flightMode == self.flight_mode:\n        print \"Vehicle is already in %s mode\" % self.flight_mode\n        return True\n\n    # Set the hover flag if the mode is 'HOVER'\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        return True\n\n    # Attempt to switch modes\n    try:\n        # Switch to the desired mode\n        self.flightModeService(self.flight_mode)\n\n        # Wait for the mode to switch\n        while self.flightMode != self.flight_mode:\n            time.sleep(0.1)\n\n        # Print a success message\n        print \"Switched to %s mode\" % self.flight_mode\n\n        # Return True to indicate success\n        return True\n\n    # Print a failure message and return False if the mode switch fails\n    except:\n        print \"Failed to switch to %s mode\" % self.flight_mode\n        return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 37.66135180897425}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService.is_available() and self.flightModeService.is_enabled():\n        if self.flightMode == 'HOVER':\n            self.hover()\n            return True\n        else:\n            try:\n                self.flightModeService(self.flightMode)\n                print \"Flight mode switched to %s\" % self.flightMode\n                return True\n            except Exception, e:\n                print \"Flight mode switch failed: %s\" % e\n                return False\n    else:\n        print \"Flight mode switch failed: service unavailable\"\n        return False\n\n", "CodeBleu_score": 28.446134962463653}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    # Get the linear and angular components of the message\n    linear_x = msg.linear.x\n    linear_y = msg.linear.y\n    linear_z = msg.linear.z\n    angular_x = msg.angular.x\n    angular_y = msg.angular.y\n    angular_z = msg.angular.z\n\n    # Call hover_state_transition with the linear and angular components of the message\n    self.hover_state_transition(linear_x, linear_y, linear_z, angular_x, angular_y, angular_z)\n\n    # If the hover_flag is not set, call hold_state_transition with the same components and the 'enu' frame\n    if not self.hover_flag:\n        self.hold_state_transition(linear_x, linear_y, linear_z, angular_x, angular_y, angular_z, 'enu')\n\n    # If both hover_flag and hold_flag are not set, set the coordinate_frame and motion_type to 1, and construct the target motion using the message components\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(linear_x, linear_y, linear_z, angular_x, angular_y, angular_z)\n", "CodeBleu_score": 27.53233038009312}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n        if not self.hold_flag:\n            self.construct_target(1, 1, msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n", "CodeBleu_score": 27.39606663045428}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag == 1:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    elif self.hold_flag == 1:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    else:\n        self.construct_target(1, 1, msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n", "CodeBleu_score": 42.47287202331794}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    # Checks if the drone is in the hover state\n    if self.hover_flag == 0:\n        # Checks if any of the x, y, z values exceed 0.02 or w exceeds 0.005\n        if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02) or (abs(w) > 0.005):\n            # Sets hover_flag to 0 and changes the flight mode to 'OFFBOARD'\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            print('Flight mode changed to OFFBOARD')\n        # Checks if the flight mode is not \"HOVER\" and the conditions are met\n        elif (self.flight_mode != 'HOVER') and (abs(x) < 0.02) and (abs(y) < 0.02) and (abs(z) < 0.02) and (abs(w) < 0.005):\n            # Sets hover_flag to 1, changes the flight mode to 'HOVER', and initiates the hover action\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            print('Flight mode changed to HOVER')\n\n", "CodeBleu_score": 61.68874341320101}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n\n    # Define variables\n    hover_flag = 0\n    hover_thresh = 0.02\n    rot_thresh = 0.005\n\n    # Check if the drone is in hover mode\n    if self.flight_mode == 'HOVER':\n        # Check if the drone is hovering\n        if hover_flag == 1:\n            # Check if the drone is not hovering\n            if (abs(x) > hover_thresh) or (abs(y) > hover_thresh) or (abs(z) > hover_thresh) or (abs(w) > rot_thresh):\n                # Set hover_flag to 0\n                hover_flag = 0\n                # Change the flight mode to \"OFFBOARD\"\n                self.flight_mode = 'OFFBOARD'\n                # Initiate the offboard action\n                self.offboard_action()\n        # Check if the drone is hovering\n        if hover_flag == 0:\n            # Check if the drone is hovering\n            if (abs(x) < hover_thresh) and (abs(y) < hover_thresh) and (abs(z) < hover_thresh) and (abs(w) < rot_thresh):\n                # Set hover_flag to 1\n                hover_flag = 1\n                # Change the flight mode to \"HOVER\"\n                self.flight_mode = 'HOVER'\n                # Initiate the hover action\n                self.hover_action()\n\n    # Check if the drone is not in hover mode\n    if self.flight_mode != 'HOVER':\n        # Check if the drone is hovering\n        if hover_flag == 1:\n            # Set hover_flag to 0\n            hover_flag = 0\n            # Change the flight mode to \"OFFBOARD\"\n            self.flight_mode = 'OFFBOARD'\n            # Initiate the offboard action\n            self.offboard_action()\n        # Check if the drone is hovering\n        if hover_flag == 0:\n            # Check if the drone is hovering\n            if (abs(x) < hover_th", "CodeBleu_score": 43.29451513520186}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    # print(x, y, z, w)\n    if self.hover_flag == 0:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.hover_action()\n        else:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover_action()\n    else:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.hover_action()\n        else:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover_action()\n\n", "CodeBleu_score": 70.16539738247876}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n\n    if isinstance(q, Quaternion):\n        return q.yaw()\n    else:\n        return Quaternion(q).yaw()\n\n", "CodeBleu_score": 17.87598314614692}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    print(\"Setting vehicle to hover mode...\")\n    self.coordinate_frame = mavutil.mavlink.MAV_FRAME_LOCAL_NED\n    self.motion_type = mavutil.mavlink.MAV_MOUNT_MODE_MAVLINK_TARGETING\n    self.construct_target()\n    print(\"Vehicle type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight mode: \" + str(self.flight_mode))\n\n", "CodeBleu_score": 27.59536363077609}, {"code": "def hover(self)\n\t\n\n    self.coordinate_frame = \"LOCAL_FRAME\"\n    self.motion_type = \"HOVER\"\n    self.construct_target()\n    print(\"Vehicle type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight mode:\", self.flight_mode)\n\n", "CodeBleu_score": 22.74115511677798}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = mavutil.mavlink.MAV_FRAME_LOCAL_NED\n    self.motion_type = mavutil.mavlink.MAV_MOUNT_MODE_MAVLINK_TARGETING\n    self.construct_target()\n    print('Vehicle Type: ' + self.vehicle_type)\n    print('Vehicle ID: ' + str(self.vehicle_id))\n    print('Flight Mode: ' + self.flight_mode)\n\n", "CodeBleu_score": 23.007736957796286}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover_service()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            self.flight_mode = self.flightModeService()\n            print \"Flight mode set to \" + self.flight_mode\n            return True\n        except:\n            print \"Flight mode switch failed\"\n            return False\n\n", "CodeBleu_score": 51.09245525666603}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n    else:\n        try:\n            self.flight_mode = self.flight_mode_service(self.flight_mode)\n            print 'Flight mode switched to', self.flight_mode\n        except:\n            print 'Failed to switch flight mode to', self.flight_mode\n            return False\n    return True\n\n", "CodeBleu_score": 48.38537221732443}, {"code": "def flight_mode_switch(self)\n\t\n    # Check if the vehicle is in hover mode. If it is, set the hover flag to True and call the hover method.\n    if self.flightMode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n\n    # Attempt to switch the flight mode.\n    try:\n        self.flightModeService(self.flightMode)\n    except rospy.ServiceException as e:\n        print(\"Flight mode switch service call failed: %s\" % e)\n        return False\n\n    # If the service call was successful, print the new flight mode and return True.\n    print(\"Flight mode switched to %s\" % self.flightMode)\n    return True\n\n", "CodeBleu_score": 45.67072357186513}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n\n    self.get_total_reward()\n\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    # update local pose\n    if msg.id == i:\n        self.local_pose = msg\n\n    # update takeoff target pose\n    if self.takeoff_target_pose is None and self.takeoff_flag:\n        self.takeoff_target_pose = msg\n\n    # update hover target pose\n    if self.hover_target_pose is None and self.hover_flag:\n        self.hover_target_pose = msg\n\n    # update global pose\n    self.global_pose = msg\n    self.global_pose.position.x += self.x_bias\n    self.global_pose.position.y += self.y_bias\n    self.global_pose.position.z += self.z_bias\n\n", "CodeBleu_score": 23.97185925307471}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.id:\n        self.local_pose = msg\n        self.local_pose.position.x += self.bias_x\n        self.local_pose.position.y += self.bias_y\n\n    if self.gcs_command == \"TAKEOFF\":\n        self.takeoff_target_pose = msg\n\n    if self.gcs_command == \"HOVER\":\n        self.hover_target_pose = msg\n\n    self.global_pose = copy.deepcopy(self.local_pose)\n    self.global_pose.position.x += self.bias_x\n    self.global_pose.position.y += self.bias_y\n\n", "CodeBleu_score": 32.57037478441368}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.id:\n        self.local_pose = msg\n\n    if self.gcs_command == \"TAKEOFF\":\n        self.takeoff_target_pose = msg\n        self.takeoff_target_pose.position.x -= self.local_pose.position.x\n        self.takeoff_target_pose.position.y -= self.local_pose.position.y\n        self.takeoff_target_pose.position.z -= self.local_pose.position.z\n\n    if self.gcs_command == \"HOVER\":\n        self.hover_target_pose = msg\n        self.hover_target_pose.position.x -= self.local_pose.position.x\n        self.hover_target_pose.position.y -= self.local_pose.position.y\n        self.hover_target_pose.position.z -= self.local_pose.position.z\n\n    self.global_pose.position.x = self.local_pose.position.x + self.local_pose.position.x\n    self.global_pose.position.y = self.local_pose.position.y + self.local_pose.position.y\n    self.global_pose.position.z = self.local_pose.position.z + self.local_pose.position.z\n\n", "CodeBleu_score": 21.750818616161386}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.862379601652705}, {"code": "def takeoff_detection(self)\n\t\n\n    if self.arm_state == 'active' and self.altitude > 0.2:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 60.617887392028216}, {"code": "def takeoff_detection(self)\n\t\n    if self.arm_state == \"active\":\n        if self.altitude > 0.2:\n            return True\n        else:\n            return False\n    else:\n        return False\n\n", "CodeBleu_score": 60.03719435848858}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    dist_orig = self.calculate_distances(orig_formation)\n    dist_change = self.calculate_distances(change_formation)\n\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    dist_orig = np.array([[int(round(dist_orig[i, j] - 50)) for j in range(len(dist_orig))] for i in range(len(dist_orig))])\n    dist_change = np.array([[int(round(dist_change[i, j] - 50)) for j in range(len(dist_change))] for i in range(len(dist_change))])\n\n    # Return the distance matrix\n    return dist_orig, dist_change\n", "CodeBleu_score": 21.201509829143827}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    dist_matrix = np.zeros((orig_formation.num_uavs, change_formation.num_uavs))\n    for i in range(orig_formation.num_uavs):\n        for j in range(change_formation.num_uavs):\n            dist_matrix[i, j] = int(50 - np.linalg.norm(orig_formation.uavs[i].pos - change_formation.uavs[j].pos))\n    return dist_matrix\n\n", "CodeBleu_score": 24.90433356715382}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = np.zeros((orig_formation.num_of_uavs, change_formation.num_of_uavs))\n    for i in range(orig_formation.num_of_uavs):\n        for j in range(change_formation.num_of_uavs):\n            distance_matrix[i][j] = int(50 - np.linalg.norm(orig_formation.uav_positions[i] - change_formation.uav_positions[j]))\n    return distance_matrix\n\n", "CodeBleu_score": 27.60845861995933}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visited[i] = True\n    for j in self.graph[i]:\n        if self.visited[j] == False:\n            gap = self.labels[i] - self.labels[j]\n            if gap == 0:\n                self.visited[j] = True\n                if self.find_path(j):\n                    return True\n                elif self.slack[j] == 0:\n                    self.match[i] = j\n                    self.match[j] = i\n                    return True\n            elif self.slack[j] > gap:\n                self.slack[j] = gap\n                self.parent[j] = i\n    return False\n\n", "CodeBleu_score": 39.63657226676571}, {"code": "def find_path(self, i)\n\t\n    if self.left[i].visited:\n        return False\n    self.left[i].visited = True\n    for j in self.left[i].adj:\n        if self.right[j].visited:\n            continue\n        gap = self.left[i].label - self.right[j].label\n        if gap == 0:\n            self.left[i].visited = False\n            self.right[j].visited = True\n            if self.find_path(j):\n                return True\n            else:\n                self.left[i].visited = True\n                self.right[j].visited = False\n                if self.slack[j] == 0:\n                    self.slack[j] = self.left[i].label\n                    self.slack[i] = self.right[j].label\n                    return False\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n\n", "CodeBleu_score": 34.31859606135027}, {"code": "def find_path(self, i)\n\t\n    self.left[i].visited = True\n    for j in self.left[i].adjacent:\n        if self.right[j].visited:\n            continue\n        gap = self.left[i].label - self.right[j].label\n        if gap == 0:\n            self.right[j].visited = True\n            if self.find_path(j):\n                return True\n            else:\n                self.left[i].visited = False\n                self.right[j].visited = False\n                if self.slack[j] == 0:\n                    return False\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n\n", "CodeBleu_score": 38.551776156209506}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    self.slack = {}\n    self.visited = {}\n    self.matched = {}\n    self.path = {}\n    self.predecessor = {}\n    self.label = {}\n    self.zero_pairs = []\n    self.marked = {}\n    self.marked_count = 0\n    self.marked_pairs = []\n    self.marked_count = 0\n    self.unmarked_pairs = []\n    self.unmarked_count = 0\n    self.unmarked_pairs = []\n    self.unmarked_count = 0\n    self.L = self.left_size\n    self.R = self.right_size\n    self.LpR = self.left_to_right\n    self.RpL = self.right_to_left\n    self.left_covered = numpy.zeros(self.L, dtype=bool)\n    self.right_covered = numpy.zeros(self.R, dtype=bool)\n    self.find_path()\n    return self.matched\n\n", "CodeBleu_score": 16.794365616941697}, {"code": "def KM(self)\n\t\n    # Initialize the slack values\n    slack = np.array([0.0] * self.n_agents)\n    # Initialize the labeling arrays\n    labeling = np.array([0] * self.n_agents)\n    # Initialize the visit arrays\n    visit = np.array([0] * self.n_agents)\n    # Initialize the path array\n    path = np.array([0] * self.n_agents)\n    # Initialize the augmenting path array\n    augmenting_path = np.array([0] * self.n_agents)\n    # Initialize the augmenting path end\n    augmenting_path_end = 0\n    # Initialize the number of unmatched agents\n    unmatched_agents = self.n_agents\n    # Initialize the number of unmatched UAVs\n    unmatched_uavs = self.n_uavs\n    # Initialize the number of iterations\n    iterations = 0\n    # Iterate over UAVs\n    while unmatched_agents > 0:\n        # Iterate over agents\n        for i in range(self.n_agents):\n            # If the agent is not matched and the UAV is not matched\n            if labeling[i] == 0 and slack[i] == 0:\n                # Initialize the current agent\n                current_agent = i\n                # Initialize the current UAV\n                current_uav = 0\n                # Initialize the current path\n                current_path = 0\n                # Initialize the current path end\n                current_path_end = 0\n                # Iterate until a path is found\n                while True:\n                    # If the current agent is not matched\n                    if labeling[current_agent] == 0:\n                        # If the current UAV is not matched\n                        if labeling[self.n_agents + current_uav] == 0:\n                            # If the current agent is not the current UAV\n                            if current_agent != self.n_agents + current_uav:\n                                # If the current agent is not the first agent in the path\n                                if current_path == 0:\n                                    #", "CodeBleu_score": 26.88780665257887}, {"code": "def KM(self)\n\t\n    # Initialize the output\n    match_results = []\n    # Initialize the slack and visit arrays\n    slack = numpy.array([0] * self.num_of_uavs)\n    visit = numpy.array([False] * self.num_of_uavs)\n    # Iterate over the UAVs\n    for u in range(self.num_of_uavs):\n        # Initialize the slack and visit arrays for each UAV\n        slack = numpy.array([0] * self.num_of_uavs)\n        visit = numpy.array([False] * self.num_of_uavs)\n        # Initialize the path array\n        path = numpy.array([-1] * self.num_of_uavs)\n        # Initialize the path length\n        path_length = 0\n        # Initialize the slack and visit arrays for each UAV\n        for i in range(self.num_of_uavs):\n            slack[i] = self.find_path(u, i, path, path_length)\n            visit[i] = False\n        # Iterate over the UAVs until a path is found\n        while True:\n            # Find the minimum slack value\n            min_slack = min(slack)\n            # Find the index of the minimum slack value\n            min_slack_index = slack.tolist().index(min_slack)\n            # If the minimum slack value is 0, a path is found\n            if min_slack == 0:\n                # Iterate over the UAVs\n                for i in range(self.num_of_uavs):\n                    # If the slack value is 0, the UAV is matched\n                    if slack[i] == 0:\n                        # Append the UAV to the match results\n                        match_results.append(i)\n                # Break from the loop\n                break\n            # If the minimum slack value is greater than 0, adjust the labels\n            else:\n                # Find the UAVs with the minimum slack value\n                for i in range(self.num_of_uavs):\n                    # If the slack", "CodeBleu_score": 25.78054553721157}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Create a mask for the color \"yellow\"\n    lower_yellow = np.array([10, 100, 100])\n    upper_yellow = np.array([40, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 29.46137912697503}, {"code": "def yellow_dectection(image)\n\t\n    # convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # define range of yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    # Threshold the HSV image to get only yellow colors\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;\n  const TagDescription* descriptionContainer;", "CodeBleu_score": 8.923264599005845}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 0.5893535280724209}]}
